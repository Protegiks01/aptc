# Audit Report

## Title
Incomplete Epoch Chain Served with Incorrect `more=false` Flag Causes State Sync Failure

## Summary
The `get_epoch_ending_ledger_infos_by_size()` function in the storage service always sets `more = false` in the returned `EpochChangeProof`, even when the database iterator returns `None` early due to missing epoch ending ledger infos. This causes client nodes to receive incomplete epoch chains marked as complete, leading to state sync verification failures with "Inconsistent epoch change proof and latest ledger info" errors.

## Finding Description

The vulnerability exists in the storage service's epoch ending ledger info retrieval logic. When serving epoch ending ledger infos to client nodes during state synchronization: [1](#0-0) 

When the iterator returns `None` early (indicating missing epoch data in the database), the function logs a warning and breaks from the loop. It then unconditionally creates an `EpochChangeProof` with `more = false`: [2](#0-1) 

The `more` flag has a specific semantic meaning in the protocol: it indicates whether there are additional epoch changes beyond what's provided in the proof. The database layer correctly validates epoch completeness and returns an error when data is missing: [3](#0-2) 

However, the storage service bypasses this validation by using an iterator-based approach and suppresses the error condition by just logging a warning.

When a client receives this incomplete epoch chain with `more = false`, it attempts verification in `TrustedState::verify_and_ratchet_inner()`: [4](#0-3) 

The verification logic explicitly checks: if the latest ledger info's epoch is beyond the proof's last epoch AND `more = true`, the incomplete proof is accepted. But if `more = false`, it bails with "Inconsistent epoch change proof and latest ledger info".

This behavior is confirmed by the test suite: [5](#0-4) 

**Broken Invariant**: This violates the **State Consistency** invariant - state transitions must be atomic and verifiable via complete proofs. It also impacts **Consensus Safety** by preventing nodes from syncing correctly.

## Impact Explanation

This is a **High Severity** issue (potentially **Critical** depending on scope):

1. **State Sync Failure**: Nodes receiving incomplete epoch chains fail to sync with a confusing error message, unable to join or stay synchronized with the network.

2. **Network Availability Impact**: If multiple nodes query a storage service with missing epoch data, they all fail to sync, potentially causing significant network degradation.

3. **Silent Data Corruption**: The warning is only logged server-side. Clients receive no indication that the data is incomplete until verification fails, making debugging difficult.

4. **Protocol Violation**: The incorrect `more` flag violates the epoch change proof protocol contract, which could have cascading effects on other state sync components.

This meets the **High Severity** criteria: "Significant protocol violations" and "Validator node slowdowns" (nodes cannot progress). It approaches **Critical** severity if it affects enough nodes to cause "Total loss of liveness/network availability".

## Likelihood Explanation

**Medium to High Likelihood:**

1. **Database Corruption**: While epoch ending ledger infos are never pruned, database corruption can occur due to hardware failures, software bugs, or incomplete writes.

2. **Concurrent Operations**: Race conditions during epoch transitions or database writes could leave gaps in epoch data.

3. **Backup/Restore Issues**: Incomplete database restores or backup corruption could result in missing epoch ending ledger infos.

4. **Real-World Occurrence**: The code explicitly handles this case with a warning message, suggesting the developers anticipated this scenario could occur.

The attack doesn't require malicious intent - it's triggered by operational issues that can realistically happen in production systems.

## Recommendation

The `more` flag should be set based on whether all requested epochs were successfully fetched:

```rust
// After the while loop (line 286), check if we got all expected data
let num_fetched = epoch_ending_ledger_infos.len() as u64;
let more = num_fetched < num_ledger_infos_to_fetch;

// If the iterator returned None early and we didn't fetch enough, return an error
if !more && num_fetched < num_ledger_infos_to_fetch {
    return Err(Error::StorageErrorEncountered(format!(
        "Database corruption: missing epoch ending ledger infos. \
        Expected {} epochs from {} to {}, but only retrieved {}",
        num_ledger_infos_to_fetch, start_epoch, expected_end_epoch, num_fetched
    )));
}

let epoch_change_proof = EpochChangeProof::new(epoch_ending_ledger_infos, more);
```

Alternatively, if returning partial data is acceptable, always set `more = true` when the iterator returns `None` early:

```rust
let more = epoch_ending_ledger_infos.len() as u64 < num_ledger_infos_to_fetch;
let epoch_change_proof = EpochChangeProof::new(epoch_ending_ledger_infos, more);
```

## Proof of Concept

```rust
// Test demonstrating the vulnerability
#[test]
fn test_incomplete_epoch_chain_with_false_more_flag() {
    // Setup: Create a database with epochs 0-5, but missing epochs 6-10
    let mut storage = MockStorage::new();
    storage.insert_epoch_ending_ledger_infos(0..=5);
    // Epochs 6-10 are missing (simulating database corruption)
    
    let storage_service = StorageReader::new(
        default_config(),
        Arc::new(storage),
        TimeService::mock(),
    );
    
    // Request epochs 0-10
    let result = storage_service.get_epoch_ending_ledger_infos(0, 10);
    
    // Bug: Returns Ok with incomplete data and more=false
    let epoch_change_proof = result.unwrap();
    assert_eq!(epoch_change_proof.ledger_info_with_sigs.len(), 6); // Only got 0-5
    assert_eq!(epoch_change_proof.more, false); // BUG: Should be true or error!
    
    // When client tries to verify with a ledger info at epoch 10
    let latest_li = create_ledger_info_at_epoch(10);
    let trusted_state = create_trusted_state_at_epoch(0);
    
    // This will fail with "Inconsistent epoch change proof and latest ledger info"
    let result = trusted_state.verify_and_ratchet_inner(&latest_li, &epoch_change_proof);
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Inconsistent"));
}
```

The PoC demonstrates that incomplete epoch data is returned with `more = false`, causing verification failures when clients attempt to use the incomplete proof.

**Notes:**
- The issue affects the new size-and-time-aware chunking code path (lines 210-296), not the legacy implementation
- Similar issues may exist in other data fetching functions using the same pattern (transactions, outputs, state values)
- The `ResponseDataProgressTracker` correctly tracks truncation for size/time limits at line 292-293, but doesn't account for iterator exhaustion

### Citations

**File:** state-sync/storage-service/server/src/storage.rs (L276-284)
```rust
                None => {
                    // Log a warning that the iterator did not contain all the expected data
                    warn!(
                        "The epoch ending ledger info iterator is missing data! \
                        Start epoch: {:?}, expected end epoch: {:?}, num ledger infos to fetch: {:?}",
                        start_epoch, expected_end_epoch, num_ledger_infos_to_fetch
                    );
                    break;
                },
```

**File:** state-sync/storage-service/server/src/storage.rs (L289-289)
```rust
        let epoch_change_proof = EpochChangeProof::new(epoch_ending_ledger_infos, false);
```

**File:** storage/aptosdb/src/db/aptosdb_reader.rs (L1056-1063)
```rust
        ensure!(
            lis.len() == (paging_epoch - start_epoch) as usize,
            "DB corruption: missing epoch ending ledger info for epoch {}",
            lis.last()
                .map(|li| li.ledger_info().next_block_epoch() - 1)
                .unwrap_or(start_epoch),
        );
        Ok((lis, more))
```

**File:** types/src/trusted_state.rs (L183-187)
```rust
            } else if latest_li.ledger_info().epoch() > new_epoch && epoch_change_proof.more {
                epoch_change_li
            } else {
                bail!("Inconsistent epoch change proof and latest ledger info");
            };
```

**File:** types/src/unit_tests/trusted_state_test.rs (L387-393)
```rust
        // ratcheting with more = false should fail, since the state proof claims
        // we're done syncing epoch changes but doesn't get us all the way to the
        // latest ledger info
        let mut change_proof = EpochChangeProof::new(lis_with_sigs, false /* more */);
        trusted_state
            .verify_and_ratchet_inner(&latest_li, &change_proof)
            .expect_err("Should return Err when more is false and there's a gap");
```
