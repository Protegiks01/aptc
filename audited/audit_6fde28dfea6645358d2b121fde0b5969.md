# Audit Report

## Title
Gas Undercharging in Bulletproofs Batch Verification with Single Element

## Summary
The `native_verify_batch_range_proof()` function charges significantly less gas (~11% less) when verifying a single commitment compared to the dedicated `native_verify_range_proof()` function, despite both being exposed as public APIs. This allows users to save gas by calling batch verification with a single-element vector instead of single verification.

## Finding Description

The Aptos bulletproofs implementation provides two verification paths that users can choose between:

1. **Single verification path**: [1](#0-0) 

2. **Batch verification path**: [2](#0-1) 

The native Rust implementations charge gas differently:

**Single verification** uses formula-based charging: [3](#0-2) 

**Batch verification** uses fixed lookup table: [4](#0-3) 

The gas parameters were calibrated at different times with different pricing models: [5](#0-4) 

For a 64-bit range proof (672 bytes):
- **Single verification**: 11,794,651 + (121 × 672) + (1,004,253 × 64) = **76,148,155 gas**
- **Batch verification (size=1)**: **67,748,218 gas**
- **Difference**: 8,399,937 gas saved (**11.03% discount**)

A user can exploit this by calling `verify_batch_range_proof([commitment], proof, bits, dst)` with a single-element vector instead of `verify_range_proof(commitment, proof, bits, dst)`.

## Impact Explanation

This issue falls under **Low Severity** per Aptos bug bounty criteria as a "non-critical implementation bug." The impact is limited to:

- **Economic inefficiency**: Users can save ~11% gas on range proof verification
- **Marginal DoS amplification**: Attackers could verify ~11% more proofs for the same gas cost
- **No consensus impact**: All validators execute the same code paths deterministically
- **No funds at risk**: This is purely a gas pricing discrepancy

This does NOT meet Critical, High, or Medium severity thresholds because:
- No loss of funds (Critical)
- No consensus/safety violations (Critical)
- No validator node crashes or slowdowns (High)
- No state inconsistencies or limited funds loss (Medium)

## Likelihood Explanation

**Likelihood: High** - This is easily exploitable by any user who:
1. Needs to verify a single bulletproof range proof
2. Discovers both verification functions are publicly exposed
3. Realizes batch verification with size=1 is supported and cheaper

The exploitation requires no special privileges, just knowledge of the API.

## Recommendation

**Option 1: Equalize gas parameters**
Recalibrate the batch verification gas parameters for size=1 to match the single verification cost. Update the gas schedule generation script to ensure parity.

**Option 2: Enforce API boundaries**
Modify the batch verification function to reject single-element batches and redirect to single verification: [6](#0-5) 

Add a check after line 142:
```rust
if comm_points.len() == 1 {
    // Redirect to single verification for correct gas charging
    return native_verify_range_proof(context, ty_args, /* convert args */);
}
```

**Option 3: Accept as design choice**
If the gas discount for batch size=1 is intentional (e.g., batch verification is optimized even for single elements), document this clearly and deprecate the single verification API.

## Proof of Concept

```move
#[test(fx = @std)]
fun test_gas_discrepancy_single_vs_batch(fx: signer) {
    use aptos_std::ristretto255_bulletproofs;
    use aptos_std::ristretto255_pedersen;
    use aptos_framework::aptos_governance;
    
    // Enable both features
    features::change_feature_flags_for_testing(&fx, 
        vector[features::get_bulletproofs_feature(), features::get_bulletproofs_batch_feature()], 
        vector[]);
    
    // Create a test commitment and proof
    let value = ristretto255::new_scalar_from_u64(100);
    let blinding = ristretto255::new_scalar_from_u64(42);
    let (proof, comm) = bulletproofs::prove_range_pedersen(&value, &blinding, 64, b"test");
    
    // Test single verification
    let gas_before_single = /* get current gas */;
    assert!(bulletproofs::verify_range_proof_pedersen(&comm, &proof, 64, b"test"), 1);
    let gas_single = /* gas_before_single - current gas */;
    
    // Test batch verification with size=1
    let gas_before_batch = /* get current gas */;
    assert!(bulletproofs::verify_batch_range_proof_pedersen(&vector[comm], &proof, 64, b"test"), 1);
    let gas_batch = /* gas_before_batch - current gas */;
    
    // Verify the discrepancy
    assert!(gas_single > gas_batch, 2);
    // Expected: gas_single ≈ 76.1M, gas_batch ≈ 67.7M (11% difference)
}
```

---

## Notes

This finding represents a **gas pricing inconsistency** rather than a critical security vulnerability. While the discrepancy exists and is exploitable, it does not meet the Medium+ severity threshold required by the validation checklist. The cryptographic behavior remains identical between both paths (both should accept/reject the same proofs correctly), and there is no impact on consensus, funds safety, or network availability.

### Citations

**File:** aptos-move/framework/aptos-stdlib/sources/cryptography/ristretto255_bulletproofs.move (L105-118)
```text
    public fun verify_range_proof(
        com: &RistrettoPoint,
        val_base: &RistrettoPoint, rand_base: &RistrettoPoint,
        proof: &RangeProof, num_bits: u64, dst: vector<u8>): bool
    {
        assert!(features::bulletproofs_enabled(), error::invalid_state(E_NATIVE_FUN_NOT_AVAILABLE));
        assert!(dst.length() <= 256, error::invalid_argument(E_DST_TOO_LONG));

        verify_range_proof_internal(
            ristretto255::point_to_bytes(&ristretto255::point_compress(com)),
            val_base, rand_base,
            proof.bytes, num_bits, dst
        )
    }
```

**File:** aptos-move/framework/aptos-stdlib/sources/cryptography/ristretto255_bulletproofs.move (L145-160)
```text
    public fun verify_batch_range_proof(
        comms: &vector<RistrettoPoint>,
        val_base: &RistrettoPoint, rand_base: &RistrettoPoint,
        proof: &RangeProof, num_bits: u64, dst: vector<u8>): bool
    {
        assert!(features::bulletproofs_batch_enabled(), error::invalid_state(E_NATIVE_FUN_NOT_AVAILABLE));
        assert!(dst.length() <= 256, error::invalid_argument(E_DST_TOO_LONG));

        let comms = comms.map_ref(|com| ristretto255::point_to_bytes(&ristretto255::point_compress(com)));

        verify_batch_range_proof_internal(
            comms,
            val_base, rand_base,
            proof.bytes, num_bits, dst
        )
    }
```

**File:** aptos-move/framework/src/natives/cryptography/bulletproofs.rs (L113-142)
```rust
fn native_verify_batch_range_proof(
    context: &mut SafeNativeContext,
    ty_args: &[Type],
    mut args: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    debug_assert!(ty_args.is_empty());
    debug_assert!(args.len() == 6);

    let dst = safely_pop_arg!(args, Vec<u8>);
    let num_bits = safely_pop_arg!(args, u64) as usize;
    let proof_bytes = safely_pop_arg!(args, Vec<u8>);
    let rand_base_handle = get_point_handle(&safely_pop_arg!(args, StructRef))?;
    let val_base_handle = get_point_handle(&safely_pop_arg!(args, StructRef))?;
    let comm_bytes = safely_pop_vec_arg!(args, Vec<u8>);

    let comm_points = comm_bytes
        .iter()
        .map(|comm_bytes| CompressedRistretto::from_slice(comm_bytes.as_slice()))
        .collect::<Vec<_>>();

    if !is_supported_number_of_bits(num_bits) {
        return Err(SafeNativeError::Abort {
            abort_code: abort_codes::NFE_RANGE_NOT_SUPPORTED,
        });
    }
    if !is_supported_batch_size(comm_points.len()) {
        return Err(SafeNativeError::Abort {
            abort_code: abort_codes::NFE_BATCH_SIZE_NOT_SUPPORTED,
        });
    }
```

**File:** aptos-move/framework/src/natives/cryptography/bulletproofs.rs (L328-344)
```rust
    context.charge(
        BULLETPROOFS_BASE
            + BULLETPROOFS_PER_BYTE_RANGEPROOF_DESERIALIZE
                * NumBytes::new(proof_bytes.len() as u64),
    )?;

    let range_proof = match bulletproofs::RangeProof::from_bytes(proof_bytes) {
        Ok(proof) => proof,
        Err(_) => {
            return Err(SafeNativeError::Abort {
                abort_code: abort_codes::NFE_DESERIALIZE_RANGE_PROOF,
            })
        },
    };

    // The (Bullet)proof size is $\log_2(num_bits)$ and its verification time is $O(num_bits)$
    context.charge(BULLETPROOFS_PER_BIT_RANGEPROOF_VERIFY * NumArgs::new(bit_length as u64))?;
```

**File:** aptos-move/framework/src/natives/cryptography/bulletproofs.rs (L397-426)
```rust
/// Charges base gas fee for verifying and deserializing a Bulletproof range proof.
fn charge_gas(
    context: &mut SafeNativeContext,
    batch_size: usize,
    bit_length: usize,
) -> SafeNativeResult<()> {
    match (batch_size, bit_length) {
        (1, 8) => context.charge(BULLETPROOFS_VERIFY_BASE_BATCH_1_BITS_8),
        (1, 16) => context.charge(BULLETPROOFS_VERIFY_BASE_BATCH_1_BITS_16),
        (1, 32) => context.charge(BULLETPROOFS_VERIFY_BASE_BATCH_1_BITS_32),
        (1, 64) => context.charge(BULLETPROOFS_VERIFY_BASE_BATCH_1_BITS_64),
        (2, 8) => context.charge(BULLETPROOFS_VERIFY_BASE_BATCH_2_BITS_8),
        (2, 16) => context.charge(BULLETPROOFS_VERIFY_BASE_BATCH_2_BITS_16),
        (2, 32) => context.charge(BULLETPROOFS_VERIFY_BASE_BATCH_2_BITS_32),
        (2, 64) => context.charge(BULLETPROOFS_VERIFY_BASE_BATCH_2_BITS_64),
        (4, 8) => context.charge(BULLETPROOFS_VERIFY_BASE_BATCH_4_BITS_8),
        (4, 16) => context.charge(BULLETPROOFS_VERIFY_BASE_BATCH_4_BITS_16),
        (4, 32) => context.charge(BULLETPROOFS_VERIFY_BASE_BATCH_4_BITS_32),
        (4, 64) => context.charge(BULLETPROOFS_VERIFY_BASE_BATCH_4_BITS_64),
        (8, 8) => context.charge(BULLETPROOFS_VERIFY_BASE_BATCH_8_BITS_8),
        (8, 16) => context.charge(BULLETPROOFS_VERIFY_BASE_BATCH_8_BITS_16),
        (8, 32) => context.charge(BULLETPROOFS_VERIFY_BASE_BATCH_8_BITS_32),
        (8, 64) => context.charge(BULLETPROOFS_VERIFY_BASE_BATCH_8_BITS_64),
        (16, 8) => context.charge(BULLETPROOFS_VERIFY_BASE_BATCH_16_BITS_8),
        (16, 16) => context.charge(BULLETPROOFS_VERIFY_BASE_BATCH_16_BITS_16),
        (16, 32) => context.charge(BULLETPROOFS_VERIFY_BASE_BATCH_16_BITS_32),
        (16, 64) => context.charge(BULLETPROOFS_VERIFY_BASE_BATCH_16_BITS_64),
        _ => unreachable!(),
    }
}
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/aptos_framework.rs (L241-253)
```rust
        // Bulletproofs gas parameters begin.
        // Generated at time 1683148919.0628748 by `scripts/algebra-gas/update_bulletproofs_gas_params.py` with gas_per_ns=10.0.
        [bulletproofs_base: InternalGas, { 11.. => "bulletproofs.base" }, 11794651],
        [bulletproofs_per_bit_rangeproof_verify: InternalGasPerArg, { 11.. => "bulletproofs.per_bit_rangeproof_verify" }, 1004253],
        [bulletproofs_per_byte_rangeproof_deserialize: InternalGasPerByte, { 11.. => "bulletproofs.per_byte_rangeproof_deserialize" }, 121],
        // Bulletproofs gas parameters end.

        // Bulletproofs batch verify gas parameters begin.
        // Generated at time 1738897425.2325199 by `scripts/algebra-gas/update_bulletproofs_batch_verify_gas_params.py` with gas_per_ns=37.59.
        [bulletproofs_verify_base_batch_1_bits_8: InternalGas, { RELEASE_V1_28.. => "bulletproofs.verify.base_batch_1_bits_8" }, 17_099_501],
        [bulletproofs_verify_base_batch_1_bits_16: InternalGas, { RELEASE_V1_28.. => "bulletproofs.verify.base_batch_1_bits_16" }, 25_027_962],
        [bulletproofs_verify_base_batch_1_bits_32: InternalGas, { RELEASE_V1_28.. => "bulletproofs.verify.base_batch_1_bits_32" }, 39_739_929],
        [bulletproofs_verify_base_batch_1_bits_64: InternalGas, { RELEASE_V1_28.. => "bulletproofs.verify.base_batch_1_bits_64" }, 67_748_218],
```
