# Audit Report

## Title
Byzantine Validators Can Crash Consensus Nodes via Empty Weights HashMap in Secret Share Aggregation

## Summary
The `SecretShareStore` in the consensus layer contains unchecked `expect()` calls that panic when looking up validator weights in an empty HashMap. Byzantine validators can trigger these panics by sending valid secret shares before a victim node adds its own share, causing the victim's consensus node to crash and lose liveness.

## Finding Description

The vulnerability exists in the secret sharing aggregation logic used during consensus randomness generation. The core issue is a mismatch between two weight-related methods in `SecretShareConfig`: [1](#0-0) 

The `get_peer_weight()` method returns `1` for all peers, while `get_peer_weights()` returns an empty HashMap initialized in the constructor: [2](#0-1) 

This creates a critical inconsistency in `SecretShareStore`. When shares from other validators arrive via the network, they are added using `add_share()`: [3](#0-2) 

Note that `add_share()` uses `get_peer_weight()` (line 260) which returns `1`, so shares are successfully added to the aggregator.

However, when the node processes its own block and calls `add_self_share()`, it invokes `add_share_with_metadata()`: [4](#0-3) 

This method retrieves peer weights from the empty HashMap (line 242) and has two panic points:

**Panic Point 1:** [5](#0-4) 

**Panic Point 2 (in `retain()`):** [6](#0-5) 

**Attack Scenario:**
1. Byzantine validators send cryptographically valid shares for round N to a victim node
2. These shares pass verification and are added via `add_share()` to the `PendingMetadata` aggregator
3. When the victim node processes the block for round N, it calls `add_self_share()`
4. Line 164 attempts to look up the node's own author in the empty `peer_weights` HashMap
5. The `expect()` panics, crashing the consensus node

The shares are verified before adding: [7](#0-6) 

And shares can arrive from any validator in the validator set at any time, subject only to round bounds: [8](#0-7) 

## Impact Explanation

This vulnerability falls under **High Severity** per the Aptos bug bounty criteria: "Validator node slowdowns / API crashes."

**Specific Impacts:**
- **Consensus Participation Loss**: The crashed node cannot participate in consensus rounds
- **Network Liveness Degradation**: If enough nodes crash, the network may lose liveness
- **Repeatable DoS**: Byzantine validators can continuously trigger this crash on epoch restart
- **No Recovery Without Restart**: The node process must be manually restarted

This breaks the **Consensus Liveness** invariant - Byzantine validators (< 1/3) should not be able to prevent honest nodes from participating in consensus.

## Likelihood Explanation

**Likelihood: HIGH**

This vulnerability can be triggered with:
- **Low complexity**: Byzantine validators simply send valid shares early
- **No special timing required**: Shares can be sent at any time within `FUTURE_ROUNDS_TO_ACCEPT`
- **Deterministic outcome**: The panic is guaranteed if shares exist when `add_self_share()` is called
- **Normal operation exposure**: This can even happen accidentally due to network timing between honest validators

Byzantine validators are expected in BFT systems (up to 1/3), making this a realistic threat model. The vulnerability affects every node running the secret sharing feature.

## Recommendation

Initialize the `weights` HashMap with actual validator weights instead of leaving it empty. Modify the `SecretShareConfig` constructor:

```rust
pub fn new(
    author: Author,
    epoch: u64,
    validator: Arc<ValidatorVerifier>,
    digest_key: DigestKey,
    msk_share: MasterSecretKeyShare,
    verification_keys: Vec<VerificationKey>,
    config: <FPTXWeighted as BatchThresholdEncryption>::ThresholdConfig,
    encryption_key: EncryptionKey,
) -> Self {
    // Populate weights from validator verifier
    let weights: HashMap<Author, u64> = validator
        .get_ordered_account_addresses_iter()
        .map(|addr| (*addr, 1)) // Use actual voting power when weighted config is implemented
        .collect();
    
    Self {
        _author: author,
        _epoch: epoch,
        validator,
        digest_key,
        msk_share,
        verification_keys,
        config,
        encryption_key,
        weights,
    }
}
```

Additionally, replace `expect()` with proper error handling:

```rust
// In retain()
self.total_weight = self
    .shares
    .keys()
    .filter_map(|author| weights.get(author))
    .sum();

// In add_share_with_metadata()
let share_weight = *share_weights
    .get(share.author())
    .unwrap_or(&1); // Default to weight 1 if missing
```

## Proof of Concept

```rust
#[cfg(test)]
mod test {
    use super::*;
    use aptos_types::{
        validator_verifier::ValidatorVerifier,
        account_address::AccountAddress,
        secret_sharing::{SecretShare, SecretShareMetadata, SecretShareConfig},
    };
    use std::sync::Arc;
    
    #[test]
    #[should_panic(expected = "Author must exist in weights")]
    fn test_byzantine_panic_trigger() {
        // Setup: Create a SecretShareConfig with empty weights
        let author = AccountAddress::random();
        let byzantine = AccountAddress::random();
        let epoch = 1;
        
        let mut validator_infos = vec![
            (author, 1),
            (byzantine, 1),
        ];
        let validator_verifier = Arc::new(
            ValidatorVerifier::new_for_test(validator_infos)
        );
        
        // Create config with empty weights (current implementation)
        let config = SecretShareConfig::new(
            author,
            epoch,
            validator_verifier,
            /* ... other params ... */
        );
        
        let (tx, _rx) = unbounded();
        let mut store = SecretShareStore::new(epoch, author, config, tx);
        store.update_highest_known_round(10);
        
        // Byzantine validator sends a share for round 10
        let byzantine_share = SecretShare::new(
            byzantine,
            SecretShareMetadata::new(epoch, 10, 1000, HashValue::zero(), vec![]),
            /* ... valid cryptographic share ... */
        );
        
        // Add Byzantine share - this succeeds
        store.add_share(byzantine_share).unwrap();
        
        // Node generates its own share
        let self_share = SecretShare::new(
            author,
            SecretShareMetadata::new(epoch, 10, 1000, HashValue::zero(), vec![]),
            /* ... valid cryptographic share ... */
        );
        
        // This panics at line 164 because weights HashMap is empty
        store.add_self_share(self_share).unwrap();
    }
}
```

## Notes

The vulnerability exists because the stub implementation of `get_peer_weights()` returns an empty HashMap, while `get_peer_weight()` returns a constant value. This creates an inconsistency where shares can be added but weight recalculation fails. The TODO comment at line 78 in `types/src/secret_sharing.rs` ("TODO(ibalajiarun): Check index out of bounds") suggests this code is incomplete and under development, but it's currently deployed in production consensus code where Byzantine validators can exploit it.

### Citations

**File:** types/src/secret_sharing.rs (L168-168)
```rust
            weights: HashMap::new(),
```

**File:** types/src/secret_sharing.rs (L196-202)
```rust
    pub fn get_peer_weight(&self, _peer: &Author) -> u64 {
        1
    }

    pub fn get_peer_weights(&self) -> &HashMap<Author, u64> {
        &self.weights
    }
```

**File:** consensus/src/rand/secret_sharing/secret_share_store.rs (L74-81)
```rust
    fn retain(&mut self, metadata: &SecretShareMetadata, weights: &HashMap<Author, u64>) {
        self.shares.retain(|_, share| share.metadata == *metadata);
        self.total_weight = self
            .shares
            .keys()
            .map(|author| weights.get(author).expect("Author must exist for weight"))
            .sum();
    }
```

**File:** consensus/src/rand/secret_sharing/secret_share_store.rs (L162-164)
```rust
        let share_weight = *share_weights
            .get(share.author())
            .expect("Author must exist in weights");
```

**File:** consensus/src/rand/secret_sharing/secret_share_store.rs (L237-257)
```rust
    pub fn add_self_share(&mut self, share: SecretShare) -> anyhow::Result<()> {
        assert!(
            self.self_author == share.author,
            "Only self shares can be added with metadata"
        );
        let peer_weights = self.secret_share_config.get_peer_weights();
        let metadata = share.metadata();
        ensure!(metadata.epoch == self.epoch, "Share from different epoch");
        ensure!(
            metadata.round <= self.highest_known_round + FUTURE_ROUNDS_TO_ACCEPT,
            "Share from future round"
        );

        let item = self
            .secret_share_map
            .entry(metadata.round)
            .or_insert_with(|| SecretShareItem::new(self.self_author));
        item.add_share_with_metadata(share, peer_weights)?;
        item.try_aggregate(&self.secret_share_config, self.decision_tx.clone());
        Ok(())
    }
```

**File:** consensus/src/rand/secret_sharing/secret_share_store.rs (L259-275)
```rust
    pub fn add_share(&mut self, share: SecretShare) -> anyhow::Result<bool> {
        let weight = self.secret_share_config.get_peer_weight(share.author());
        let metadata = share.metadata();
        ensure!(metadata.epoch == self.epoch, "Share from different epoch");
        ensure!(
            metadata.round <= self.highest_known_round + FUTURE_ROUNDS_TO_ACCEPT,
            "Share from future round"
        );

        let item = self
            .secret_share_map
            .entry(metadata.round)
            .or_insert_with(|| SecretShareItem::new(self.self_author));
        item.add_share(share, weight)?;
        item.try_aggregate(&self.secret_share_config, self.decision_tx.clone());
        Ok(item.has_decision())
    }
```

**File:** consensus/src/rand/secret_sharing/secret_share_manager.rs (L205-234)
```rust
    async fn verification_task(
        epoch_state: Arc<EpochState>,
        mut incoming_rpc_request: aptos_channel::Receiver<Author, IncomingSecretShareRequest>,
        verified_msg_tx: UnboundedSender<SecretShareRpc>,
        config: SecretShareConfig,
        bounded_executor: BoundedExecutor,
    ) {
        while let Some(dec_msg) = incoming_rpc_request.next().await {
            let tx = verified_msg_tx.clone();
            let epoch_state_clone = epoch_state.clone();
            let config_clone = config.clone();
            bounded_executor
                .spawn(async move {
                    match bcs::from_bytes::<SecretShareMessage>(dec_msg.req.data()) {
                        Ok(msg) => {
                            if msg.verify(&epoch_state_clone, &config_clone).is_ok() {
                                let _ = tx.unbounded_send(SecretShareRpc {
                                    msg,
                                    protocol: dec_msg.protocol,
                                    response_sender: dec_msg.response_sender,
                                });
                            }
                        },
                        Err(e) => {
                            warn!("Invalid dec message: {}", e);
                        },
                    }
                })
                .await;
        }
```
