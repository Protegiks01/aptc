# Audit Report

## Title
Insufficient Consensus-Time Validation of ObservedJWKUpdate Validator Transactions Enables Resource Exhaustion Attack

## Summary
ObservedJWKUpdate validator transactions bypass cryptographic verification during consensus validation, allowing malicious validators to inject transactions with forged multi-signatures into DAG blocks. While these transactions are discarded during execution, they consume network bandwidth, computational resources, and blockchain storage, enabling a resource exhaustion attack that can block legitimate validator transactions.

## Finding Description

The vulnerability exists due to a validation gap between consensus and execution layers for `ObservedJWKUpdate` validator transactions: [1](#0-0) 

During consensus validation in the DAG reliable broadcast handler, each validator transaction's `verify()` method is called: [2](#0-1) 

For `ObservedJWKUpdate` transactions, this validation immediately returns `Ok(())` without verifying the embedded `AggregateSignature` (multi-sig). The actual multi-signature verification only occurs during execution: [3](#0-2) 

**Attack Flow:**
1. A malicious validator creates a DAG node containing `ObservedJWKUpdate` transactions with forged multi-signatures
2. The node passes consensus validation because `vtxn.verify()` returns `Ok()` without checking signatures
3. Honest validators vote for the node (validation passed for all)
4. The node gets certified by 2f+1 validators' signatures
5. The certified node is ordered and used to construct a DAG block via `new_for_dag()`: [4](#0-3) 

6. The DAG block contains the malicious validator transactions (signature is `None` as expected)
7. During block execution, the multi-signature verification fails and transactions are discarded: [5](#0-4) 

8. However, the invalid transactions have already consumed resources and occupy validator transaction slots

The validator transactions in DAG blocks come from aggregated certified nodes: [6](#0-5) 

## Impact Explanation

**Severity: Medium to High**

This vulnerability enables a resource exhaustion attack with the following impacts:

1. **Validator Transaction Slot Exhaustion**: Per-block limits exist for validator transactions. A malicious validator can fill these slots with invalid transactions, blocking legitimate DKG results, JWK updates, and other critical validator transactions.

2. **Computational Resource Waste**: Every validator must:
   - Receive and deserialize malicious transactions
   - Validate nodes containing them
   - Sign and aggregate votes
   - Order and process blocks
   - Execute and discard invalid transactions

3. **Network Bandwidth Waste**: Invalid validator transactions are broadcast to all validators, consuming network capacity.

4. **Blockchain Bloat**: Invalid transactions are permanently stored on-chain (even though discarded during execution), increasing storage requirements for all validators.

5. **Potential Liveness Impact**: If critical validator transactions (e.g., DKG for randomness) are repeatedly blocked by invalid transactions filling slots, protocol functionality could be degraded.

This qualifies as **High Severity** under "Significant protocol violations" or **Medium Severity** under "State inconsistencies requiring intervention" depending on the actual impact on protocol liveness.

## Likelihood Explanation

**Likelihood: High**

- **Attack Requirement**: Single malicious validator (requires stake, but no collusion needed)
- **Detection Difficulty**: Moderate (execution failures are logged but may be dismissed as network issues)
- **Mitigation Complexity**: Requires protocol upgrade to add consensus-time signature verification
- **Attack Cost**: Low (computational cost of creating invalid transactions is minimal)
- **Attack Sustainability**: Can be repeated indefinitely across multiple rounds

The attack is highly practical because:
1. No coordination with other validators required
2. Transactions pass all consensus checks (by design flaw)
3. Per-block limits don't prevent continuous attacks across multiple blocks
4. No immediate slashing mechanism for this behavior

## Recommendation

**Immediate Fix**: Implement proper multi-signature verification during consensus validation for `ObservedJWKUpdate` transactions:

```rust
// In types/src/validator_txn.rs
pub fn verify(&self, verifier: &ValidatorVerifier) -> anyhow::Result<()> {
    match self {
        ValidatorTransaction::DKGResult(dkg_result) => dkg_result
            .verify(verifier)
            .context("DKGResult verification failed"),
        ValidatorTransaction::ObservedJWKUpdate(update) => {
            // Verify the multi-signature during consensus validation
            verifier
                .verify_multi_signatures(&update.update, &update.multi_sig)
                .context("ObservedJWKUpdate multi-signature verification failed")?;
            
            // Additional check: ensure signers have sufficient voting power
            let authors = update.multi_sig.get_signers_addresses(
                &verifier.get_ordered_account_addresses()
            );
            verifier
                .check_voting_power(authors.iter(), true)
                .context("ObservedJWKUpdate insufficient voting power")?;
            
            Ok(())
        },
    }
}
```

**Additional Hardening**:
1. Add rate limiting for failed validator transactions per validator
2. Consider slashing validators who repeatedly submit invalid validator transactions
3. Add monitoring and alerting for high rates of discarded validator transactions
4. Consider requiring validator transaction pool pre-validation before node creation

## Proof of Concept

```rust
// Proof of Concept: Creating a malicious ObservedJWKUpdate that passes consensus validation

use aptos_types::{
    jwks::{ProviderJWKs, QuorumCertifiedUpdate, issuer_from_str},
    aggregate_signature::AggregateSignature,
    validator_txn::ValidatorTransaction,
    validator_verifier::ValidatorVerifier,
};
use aptos_bitvec::BitVec;

fn create_malicious_jwk_update() -> ValidatorTransaction {
    // Create a fake JWK update
    let fake_update = ProviderJWKs {
        issuer: issuer_from_str("https://malicious.attacker"),
        version: 999,
        jwks: vec![],
    };
    
    // Create a forged/empty multi-signature (no actual signatures)
    let forged_multi_sig = AggregateSignature::new(
        BitVec::with_num_bits(4), // Fake bitvec
        None, // No actual signature
    );
    
    // Create the malicious validator transaction
    ValidatorTransaction::ObservedJWKUpdate(QuorumCertifiedUpdate {
        update: fake_update,
        multi_sig: forged_multi_sig,
    })
}

#[test]
fn test_malicious_jwk_update_passes_consensus_validation() {
    let malicious_vtxn = create_malicious_jwk_update();
    
    // Create a mock validator verifier
    let verifier = ValidatorVerifier::new(vec![]); // Simplified for PoC
    
    // This should return Ok() without actually checking the multi-sig
    // demonstrating the vulnerability
    let result = malicious_vtxn.verify(&verifier);
    
    assert!(result.is_ok(), "Malicious transaction should pass consensus validation");
    
    // However, during execution, this would fail at:
    // aptos-move/aptos-vm/src/validator_txns/jwk.rs:140-142
    // verifier.verify_multi_signatures(&observed, &multi_sig)
    // .map_err(|_| Expected(MultiSigVerificationFailed))?;
}

// Attack scenario:
// 1. Malicious validator creates nodes with multiple malicious_jwk_updates
// 2. Each node passes validation (vtxn.verify() returns Ok())
// 3. Other validators vote for the nodes
// 4. Nodes get certified and included in DAG blocks
// 5. During execution, all malicious transactions fail and are discarded
// 6. But validator transaction quota is exhausted, blocking legitimate transactions
// 7. Attack repeats across multiple rounds, causing sustained DoS
```

**Notes:**
- The vulnerability stems from incomplete defense-in-depth: consensus validation should be a preliminary filter, not a pass-through
- The lack of signature on DAG blocks (line 343) is actually not the issue - the real problem is that validator transactions from certified nodes aren't pre-validated for authenticity
- This breaks the **Resource Limits** invariant: operations should respect computational limits, but invalid transactions waste resources before being discarded

### Citations

**File:** types/src/validator_txn.rs (L45-52)
```rust
    pub fn verify(&self, verifier: &ValidatorVerifier) -> anyhow::Result<()> {
        match self {
            ValidatorTransaction::DKGResult(dkg_result) => dkg_result
                .verify(verifier)
                .context("DKGResult verification failed"),
            ValidatorTransaction::ObservedJWKUpdate(_) => Ok(()),
        }
    }
```

**File:** consensus/src/dag/rb_handler.rs (L120-131)
```rust
        let num_vtxns = node.validator_txns().len() as u64;
        ensure!(num_vtxns <= self.vtxn_config.per_block_limit_txn_count());
        for vtxn in node.validator_txns() {
            let vtxn_type_name = vtxn.type_name();
            ensure!(
                is_vtxn_expected(&self.randomness_config, &self.jwk_consensus_config, vtxn),
                "unexpected validator transaction: {:?}",
                vtxn_type_name
            );
            vtxn.verify(self.epoch_state.verifier.as_ref())
                .context(format!("{} verification failed", vtxn_type_name))?;
        }
```

**File:** aptos-move/aptos-vm/src/validator_txns/jwk.rs (L78-88)
```rust
            Err(Expected(failure)) => {
                // Pretend we are inside Move, and expected failures are like Move aborts.
                debug!("Processing dkg transaction expected failure: {:?}", failure);
                Ok((
                    VMStatus::MoveAbort {
                        location: AbortLocation::Script,
                        code: failure as u64,
                        message: None,
                    },
                    VMOutput::empty_with_status(TransactionStatus::Discard(StatusCode::ABORTED)),
                ))
```

**File:** aptos-move/aptos-vm/src/validator_txns/jwk.rs (L139-142)
```rust
        // Verify multi-sig.
        verifier
            .verify_multi_signatures(&observed, &multi_sig)
            .map_err(|_| Expected(MultiSigVerificationFailed))?;
```

**File:** consensus/consensus-types/src/block.rs (L316-345)
```rust
    pub fn new_for_dag(
        epoch: u64,
        round: Round,
        timestamp: u64,
        validator_txns: Vec<ValidatorTransaction>,
        payload: Payload,
        author: Author,
        failed_authors: Vec<(Round, Author)>,
        parent_block_id: HashValue,
        parents_bitvec: BitVec,
        node_digests: Vec<HashValue>,
    ) -> Self {
        let block_data = BlockData::new_for_dag(
            epoch,
            round,
            timestamp,
            validator_txns,
            payload,
            author,
            failed_authors,
            parent_block_id,
            parents_bitvec,
            node_digests,
        );
        Self {
            id: block_data.hash(),
            block_data,
            signature: None,
        }
    }
```

**File:** consensus/src/dag/adapter.rs (L156-160)
```rust
        for node in &ordered_nodes {
            validator_txns.extend(node.validator_txns().clone());
            payload = payload.extend(node.payload().clone());
            node_digests.push(node.digest());
        }
```
