# Audit Report

## Title
OptQuorumStore Payload Author Verification Bypass Enables Manipulation of Missing Authors BitVec

## Summary

The `check_payload_availability()` function in `QuorumStorePayloadManager` fails to verify that batch authors in OptQuorumStore payloads match the actual authors of stored batches, allowing malicious proposers to manipulate the `missing_authors` BitVec used in consensus timeout voting and validator reputation tracking.

## Finding Description

When validators process OptQuorumStore payloads (V1 and V2), the availability checking logic contains a critical verification gap. The payload verification only confirms that claimed batch authors are valid validators [1](#0-0) , but performs no cryptographic binding or author matching.

During availability checking, `batch_reader.exists()` returns `Option<PeerId>` containing the **actual** batch author from storage [2](#0-1) . However, the code only checks if this returns `None` and never validates that the returned author matches the claimed `batch.author()` in the payload [3](#0-2) [4](#0-3) .

**Attack Execution:**

1. Malicious proposer creates OptQuorumStore payload with fabricated `BatchInfo` entries
2. Claims batch digest D is from validator A (but D was actually created by validator Z or doesn't exist)
3. `check_payload_availability()` calls `exists(D)`:
   - If D exists from Z: returns `Some(Z)`, code sees not None, passes check despite wrong author claim
   - If D missing: returns `None`, validator A's bit set in `missing_authors` despite being innocent
4. Poisoned `missing_authors` BitVec propagates through timeout voting [5](#0-4) 
5. `ExponentialWindowFailureTracker` extracts these authors and excludes them from future OptQS proposals [6](#0-5) 

The codebase demonstrates awareness of this pattern - `ProofCoordinator.init_proof()` correctly performs author matching validation [7](#0-6) , confirming this is an oversight rather than intentional design.

## Impact Explanation

**MEDIUM Severity** - This vulnerability enables protocol-level manipulation affecting validator reputation and leader selection:

1. **Reputation System Compromise**: Malicious proposers can falsely attribute missing batches to innocent validators, poisoning the failure tracking system that determines OptQS proposal eligibility.

2. **Leader Selection Bias**: Systematic false blame over multiple rounds causes honest validators to be excluded from OptQuorumStore proposals, biasing selection toward colluding validators.

3. **Consensus Quality Degradation**: While not breaking consensus safety, manipulating which validators participate in optimistic proposals reduces protocol efficiency and fairness assumptions.

This does not reach CRITICAL severity as it:
- Does not enable direct funds loss or theft
- Does not cause consensus safety violations (different state roots)
- Does not create permanent chain splits
- Does not halt the network completely

The impact is bounded by the rotating proposer role and affects primarily the OptQuorumStore optimization layer rather than core consensus safety.

## Likelihood Explanation

**High Likelihood:**

1. **Low Execution Barrier**: Any validator elected as proposer can exploit this by crafting payloads with incorrect author fields - no special privileges required beyond normal proposer rotation.

2. **No Runtime Detection**: The verification logic accepts any valid validator address without cryptographic proof or author matching [8](#0-7) , providing no defense mechanism.

3. **Immediate Impact**: Each malicious proposal instantly poisons `missing_authors` data for that round, affecting timeout voting and metrics without requiring coordination.

4. **Attribution Difficulty**: The attack involves subtle misattribution in consensus metadata rather than overt protocol violations, making detection and attribution challenging for network operators.

Mitigating factors include proposer role rotation (limiting sustained attacks by single validator) and potential detection through timeout aggregation inconsistencies across validators.

## Recommendation

Add author matching verification in `check_payload_availability()` to validate that claimed batch authors match actual stored batch authors:

```rust
// In check_payload_availability() for OptQuorumStore variants
for batch in p.opt_batches().deref() {
    match self.batch_reader.exists(batch.digest()) {
        None => {
            let index = *self
                .address_to_validator_index
                .get(&batch.author())
                .expect("Payload author should have been verified");
            missing_authors.set(index as u16);
        },
        Some(actual_author) => {
            // Verify claimed author matches actual author
            if actual_author != batch.author() {
                let index = *self
                    .address_to_validator_index
                    .get(&batch.author())
                    .expect("Payload author should have been verified");
                missing_authors.set(index as u16);
            }
        },
    }
}
```

This matches the validation pattern already implemented in `ProofCoordinator.init_proof()` [7](#0-6) .

## Proof of Concept

A Rust test demonstrating the vulnerability:

```rust
#[test]
fn test_author_verification_bypass() {
    // Setup: Create batch from validator Z
    let validator_z_batch = create_test_batch(validator_z_signer);
    batch_store.save(validator_z_batch);
    
    // Attack: Proposer creates payload claiming batch is from validator A
    let malicious_payload = OptQuorumStorePayload::new(
        InlineBatches::from(vec![]),
        OptBatches::new(vec![
            BatchInfo::new(
                validator_a_address,  // Wrong author!
                validator_z_batch.digest(),  // Real digest
                // ... other fields
            )
        ]),
        ProofBatches::new(vec![]),
        PayloadExecutionLimit::None,
    );
    
    // Vulnerability: check_payload_availability() accepts this
    // even though validator A didn't create the batch
    let result = payload_manager.check_payload_availability(&block);
    
    // Expected: Should detect author mismatch and mark validator A as missing
    // Actual: Passes availability check, no missing_authors set
    assert!(result.is_ok()); // Vulnerability allows this
}
```

## Notes

This vulnerability exploits the trust placed in block proposers to accurately report batch authorship in OptQuorumStore payloads. While the impact is bounded by the rotating proposer role and doesn't break core consensus safety, it undermines the fairness assumptions of the validator reputation system and OptQuorumStore's optimistic execution model. The existence of correct author matching validation in `ProofCoordinator` suggests this is an implementation oversight rather than a fundamental design flaw.

### Citations

**File:** consensus/consensus-types/src/common.rs (L558-571)
```rust
    pub fn verify_opt_batches<T: TBatchInfo>(
        verifier: &ValidatorVerifier,
        opt_batches: &OptBatches<T>,
    ) -> anyhow::Result<()> {
        let authors = verifier.address_to_validator_index();
        for batch in &opt_batches.batch_summary {
            ensure!(
                authors.contains_key(&batch.author()),
                "Invalid author {} for batch {}",
                batch.author(),
                batch.digest()
            );
        }
        Ok(())
```

**File:** consensus/consensus-types/src/common.rs (L606-607)
```rust
                Self::verify_opt_batches(verifier, p.opt_batches())?;
                Ok(())
```

**File:** consensus/src/quorum_store/batch_store.rs (L727-732)
```rust
    fn exists(&self, digest: &HashValue) -> Option<PeerId> {
        self.batch_store
            .get_batch_from_local(digest)
            .map(|v| v.author())
            .ok()
    }
```

**File:** consensus/src/payload_manager/quorum_store_payload_manager.rs (L409-424)
```rust
            Payload::OptQuorumStore(OptQuorumStorePayload::V1(p)) => {
                let mut missing_authors = BitVec::with_num_bits(self.ordered_authors.len() as u16);
                for batch in p.opt_batches().deref() {
                    if self.batch_reader.exists(batch.digest()).is_none() {
                        let index = *self
                            .address_to_validator_index
                            .get(&batch.author())
                            .expect("Payload author should have been verified");
                        missing_authors.set(index as u16);
                    }
                }
                if missing_authors.all_zeros() {
                    Ok(())
                } else {
                    Err(missing_authors)
                }
```

**File:** consensus/src/payload_manager/quorum_store_payload_manager.rs (L426-441)
```rust
            Payload::OptQuorumStore(OptQuorumStorePayload::V2(p)) => {
                let mut missing_authors = BitVec::with_num_bits(self.ordered_authors.len() as u16);
                for batch in p.opt_batches().deref() {
                    if self.batch_reader.exists(batch.digest()).is_none() {
                        let index = *self
                            .address_to_validator_index
                            .get(&batch.author())
                            .expect("Payload author should have been verified");
                        missing_authors.set(index as u16);
                    }
                }
                if missing_authors.all_zeros() {
                    Ok(())
                } else {
                    Err(missing_authors)
                }
```

**File:** consensus/consensus-types/src/round_timeout.rs (L17-22)
```rust
pub enum RoundTimeoutReason {
    Unknown,
    ProposalNotReceived,
    PayloadUnavailable { missing_authors: BitVec },
    NoQC,
}
```

**File:** consensus/src/liveness/proposal_status_tracker.rs (L80-98)
```rust
    fn get_exclude_authors(&self) -> HashSet<Author> {
        let mut exclude_authors = HashSet::new();

        let limit = self.window;
        for round_reason in self.past_round_statuses.iter().rev().take(limit) {
            if let NewRoundReason::Timeout(RoundTimeoutReason::PayloadUnavailable {
                missing_authors,
            }) = round_reason
            {
                for author_idx in missing_authors.iter_ones() {
                    if let Some(author) = self.ordered_authors.get(author_idx) {
                        exclude_authors.insert(*author);
                    }
                }
            }
        }

        exclude_authors
    }
```

**File:** consensus/src/quorum_store/proof_coordinator.rs (L277-283)
```rust
        let batch_author = self
            .batch_reader
            .exists(signed_batch_info.digest())
            .ok_or(SignedBatchInfoError::NotFound)?;
        if batch_author != signed_batch_info.author() {
            return Err(SignedBatchInfoError::WrongAuthor);
        }
```
