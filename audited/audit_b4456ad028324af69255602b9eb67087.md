# Audit Report

## Title
Version Rollback Attack in GetTransactionsFromNode RPC Endpoint Due to Missing Cryptographic Verification

## Summary
The `GetTransactionsFromNode` gRPC endpoint lacks cryptographic proof verification, allowing malicious fullnodes to serve historical transactions with fabricated version numbers. This enables version rollback attacks where indexers and downstream systems accept old blockchain state as current, violating state consistency guarantees.

## Finding Description

The `GetTransactionsFromNode` RPC endpoint defined in the fullnode data service streams transaction data without cryptographic proofs binding transactions to their claimed version numbers. Unlike the secure `TransactionListWithProof` mechanism used in state sync, this endpoint relies solely on client trust. [1](#0-0) 

The Transaction protobuf includes a version field that is simply a `uint64` with no cryptographic binding: [2](#0-1) 

When the server converts transactions, it extracts the version from storage without providing any proof: [3](#0-2) 

Clients only validate version continuity, not cryptographic authenticity: [4](#0-3) 

**Attack Flow:**
1. Attacker deploys malicious fullnode exposing GetTransactionsFromNode
2. Indexer connects to malicious node requesting transactions from version 5000
3. Attacker serves transaction actually from version 1000 with `version` field set to 5000
4. Indexer validates only that versions are sequential (passes)
5. Indexer stores incorrect transaction at version 5000
6. All downstream systems consume corrupted blockchain state

This breaks the **State Consistency** invariant: "State transitions must be atomic and verifiable via Merkle proofs." The endpoint provides no Merkle proofs or LedgerInfo for verification.

In contrast, the secure state sync mechanism uses `TransactionListWithProof` with cryptographic verification: [5](#0-4) 

## Impact Explanation

**Severity: Medium** ($10,000 category)

This vulnerability causes **state inconsistencies requiring intervention** as defined in the Aptos bug bounty program. Affected systems include:

- **Indexers**: Store incorrect transaction history, leading to wrong API responses
- **Analytics Platforms**: Build metrics from corrupted data
- **Wallets/Explorers**: Display incorrect balances and transaction history
- **Data Pipelines**: Propagate corruption to dependent services

While this doesn't directly compromise blockchain consensus (validators use separate mechanisms), it enables systematic corruption of the off-chain data infrastructure that users and applications rely on to interact with the blockchain.

Recovery requires indexers to detect the corruption and perform full resync from trusted sources, causing service disruption.

## Likelihood Explanation

**Likelihood: High**

The attack is straightforward to execute:
- No validator access or stake required
- Attacker only needs to run a fullnode with modified GetTransactionsFromNode implementation
- Indexers may connect to untrusted fullnodes for load balancing or geographic distribution
- No authentication or cryptographic verification exists to detect the attack
- Attack succeeds silently without triggering any alarms

The lack of documentation specifying that only trusted fullnodes should be used increases the likelihood of indexers connecting to malicious nodes.

## Recommendation

Implement cryptographic proof verification for the GetTransactionsFromNode endpoint:

**Option 1:** Include TransactionInfoListWithProof in responses
```rust
// Add to TransactionsOutput protobuf:
message TransactionsOutput {
    repeated Transaction transactions = 1;
    TransactionInfoListWithProof proof = 2; // NEW
    LedgerInfo ledger_info = 3; // NEW
}
```

**Option 2:** Add explicit documentation requiring trusted fullnodes and implement additional validation
```rust
// In client validation code:
pub fn validate_transaction_batch(
    transactions: &[Transaction],
    expected_start_version: u64,
    ledger_info: &LedgerInfo, // Obtain from trusted source
) -> Result<()> {
    // Verify transaction hashes match accumulator proofs
    for (idx, txn) in transactions.iter().enumerate() {
        let expected_version = expected_start_version + idx as u64;
        ensure!(txn.version == expected_version, "Version mismatch");
        
        // Verify transaction hash against ledger info
        verify_transaction_info(
            ledger_info,
            txn.version,
            &txn.info,
            &proof_at_version // Requires proof from server
        )?;
    }
    Ok(())
}
```

**Option 3:** Minimal fix - Add chain-specific transaction hash validation
```rust
// Clients should maintain a checkpoint of known valid transaction hashes
// from a trusted source and validate against them periodically
```

## Proof of Concept

```rust
// Mock malicious fullnode serving old transactions with fake versions
use aptos_protos::internal::fullnode::v1::*;
use aptos_protos::transaction::v1::Transaction;

async fn malicious_get_transactions_from_node(
    request: GetTransactionsFromNodeRequest,
) -> impl Stream<Item = TransactionsFromNodeResponse> {
    // Attacker serves transaction from version 1000
    let old_transaction = fetch_transaction_from_storage(1000).await;
    
    // But claims it's version 5000
    let mut fake_transaction = old_transaction.clone();
    fake_transaction.version = 5000; // ATTACK: Fake version number
    
    // Client receives and accepts without verification
    TransactionsFromNodeResponse {
        response: Some(Response::Data(TransactionsOutput {
            transactions: vec![fake_transaction],
        })),
        chain_id: CHAIN_ID,
    }
}

// Demonstration that client accepts it:
#[tokio::test]
async fn test_version_rollback_attack() {
    let mut client = create_malicious_fullnode_client().await;
    let request = GetTransactionsFromNodeRequest {
        starting_version: Some(5000),
        transactions_count: Some(1),
    };
    
    let mut stream = client.get_transactions_from_node(request).await.unwrap();
    let response = stream.next().await.unwrap().unwrap();
    
    // Extract transaction
    if let Some(Response::Data(data)) = response.response {
        let txn = &data.transactions[0];
        // Client trusts version 5000 but received transaction from version 1000
        assert_eq!(txn.version, 5000); // Passes - attack successful
        // No cryptographic verification performed!
    }
}
```

**Notes**

The vulnerability stems from architectural design where the GetTransactionsFromNode endpoint prioritizes performance over security by omitting cryptographic proofs present in `TransactionListWithProof`. While labeled as "internal" in the namespace, indexers commonly connect to third-party fullnodes, making this a realistic attack vector. The fix should either add proof verification or clearly document trusted-only operation with additional security controls.

### Citations

**File:** protos/rust/src/pb/aptos.internal.fullnode.v1.rs (L14-18)
```rust
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransactionsOutput {
    #[prost(message, repeated, tag="1")]
    pub transactions: ::prost::alloc::vec::Vec<super::super::super::transaction::v1::Transaction>,
}
```

**File:** protos/proto/aptos/transaction/v1/transaction.proto (L40-46)
```text
message Transaction {
  aptos.util.timestamp.Timestamp timestamp = 1;
  uint64 version = 2 [jstype = JS_STRING];
  TransactionInfo info = 3;
  uint64 epoch = 4 [jstype = JS_STRING];
  uint64 block_height = 5 [jstype = JS_STRING];

```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/convert.rs (L827-933)
```rust
pub fn convert_transaction(
    transaction: &Transaction,
    block_height: u64,
    epoch: u64,
    size_info: TransactionSizeInfo,
) -> transaction::Transaction {
    let mut timestamp: Option<timestamp::Timestamp> = None;

    let txn_type = match transaction {
        Transaction::UserTransaction(_) => transaction::transaction::TransactionType::User,
        Transaction::GenesisTransaction(_) => transaction::transaction::TransactionType::Genesis,
        Transaction::BlockMetadataTransaction(_) => {
            transaction::transaction::TransactionType::BlockMetadata
        },
        Transaction::StateCheckpointTransaction(_) => {
            transaction::transaction::TransactionType::StateCheckpoint
        },
        Transaction::BlockEpilogueTransaction(_) => {
            transaction::transaction::TransactionType::BlockEpilogue
        },
        Transaction::PendingTransaction(_) => panic!("PendingTransaction is not supported"),
        Transaction::ValidatorTransaction(_) => {
            transaction::transaction::TransactionType::Validator
        },
    };

    let txn_data = match &transaction {
        Transaction::UserTransaction(ut) => {
            timestamp = Some(convert_timestamp_usecs(ut.timestamp.0));
            let expiration_timestamp_secs = Some(convert_timestamp_secs(
                ut.request.expiration_timestamp_secs.0,
            ));
            transaction::transaction::TxnData::User(transaction::UserTransaction {
                request: Some(transaction::UserTransactionRequest {
                    sender: ut.request.sender.to_string(),
                    sequence_number: ut.request.sequence_number.0,
                    max_gas_amount: ut.request.max_gas_amount.0,
                    gas_unit_price: ut.request.gas_unit_price.0,
                    expiration_timestamp_secs,
                    payload: Some(convert_transaction_payload(
                        &ut.request.payload,
                        ut.request.replay_protection_nonce.map(|n| n.into()),
                    )),
                    signature: convert_transaction_signature(&ut.request.signature),
                }),
                events: convert_events(&ut.events),
            })
        },
        Transaction::GenesisTransaction(gt) => {
            let payload = match &gt.payload {
                GenesisPayload::WriteSetPayload(wsp) => convert_write_set(&wsp.write_set),
            };
            transaction::transaction::TxnData::Genesis(transaction::GenesisTransaction {
                payload: Some(payload),
                events: convert_events(&gt.events),
            })
        },
        Transaction::BlockMetadataTransaction(bm) => {
            timestamp = Some(convert_timestamp_usecs(bm.timestamp.0));
            transaction::transaction::TxnData::BlockMetadata(
                transaction::BlockMetadataTransaction {
                    id: bm.id.to_string(),
                    events: convert_events(&bm.events),
                    previous_block_votes_bitvec: bm.previous_block_votes_bitvec.clone(),
                    proposer: bm.proposer.to_string(),
                    failed_proposer_indices: bm.failed_proposer_indices.clone(),
                    round: bm.round.0,
                },
            )
        },
        Transaction::StateCheckpointTransaction(_st) => {
            transaction::transaction::TxnData::StateCheckpoint(
                transaction::StateCheckpointTransaction {},
            )
        },
        Transaction::BlockEpilogueTransaction(block_epilogue) => {
            transaction::transaction::TxnData::BlockEpilogue(
                transaction::BlockEpilogueTransaction {
                    block_end_info: block_epilogue
                        .block_end_info
                        .as_ref()
                        .map(|block_end_info| transaction::BlockEndInfo {
                            block_gas_limit_reached: block_end_info.block_gas_limit_reached,
                            block_output_limit_reached: block_end_info.block_output_limit_reached,
                            block_effective_block_gas_units: block_end_info
                                .block_effective_block_gas_units,
                            block_approx_output_size: block_end_info.block_approx_output_size,
                        }),
                },
            )
        },
        Transaction::PendingTransaction(_) => panic!("PendingTransaction not supported"),
        Transaction::ValidatorTransaction(api_validator_txn) => {
            convert_validator_transaction(api_validator_txn)
        },
    };

    transaction::Transaction {
        timestamp: Some(
            timestamp.unwrap_or_else(|| convert_timestamp_usecs(transaction.timestamp())),
        ),
        version: transaction.version().unwrap_or_else(|| {
            panic!(
                "Could not extract version from Transaction '{:?}'",
                transaction
            )
        }),
```

**File:** ecosystem/indexer-grpc/indexer-grpc-file-store-backfiller/src/processor.rs (L194-199)
```rust
                        for (ide, t) in transactions.iter().enumerate() {
                            ensure!(
                                t.version == transactions[0].version + ide as u64,
                                "Unexpected version"
                            );
                        }
```

**File:** types/src/transaction/mod.rs (L2295-2354)
```rust
    pub fn verify(
        &self,
        ledger_info: &LedgerInfo,
        first_transaction_version: Option<Version>,
    ) -> Result<()> {
        // Verify the first transaction versions match
        ensure!(
            self.get_first_transaction_version() == first_transaction_version,
            "First transaction version ({:?}) doesn't match given version ({:?}).",
            self.get_first_transaction_version(),
            first_transaction_version,
        );

        // Verify the lengths of the transactions and transaction infos match
        ensure!(
            self.proof.transaction_infos.len() == self.get_num_transactions(),
            "The number of TransactionInfo objects ({}) does not match the number of \
             transactions ({}).",
            self.proof.transaction_infos.len(),
            self.get_num_transactions(),
        );

        // Verify the transaction hashes match those of the transaction infos
        self.transactions
            .par_iter()
            .zip_eq(self.proof.transaction_infos.par_iter())
            .map(|(txn, txn_info)| {
                let txn_hash = CryptoHash::hash(txn);
                ensure!(
                    txn_hash == txn_info.transaction_hash(),
                    "The hash of transaction does not match the transaction info in proof. \
                     Transaction hash: {:x}. Transaction hash in txn_info: {:x}.",
                    txn_hash,
                    txn_info.transaction_hash(),
                );
                Ok(())
            })
            .collect::<Result<Vec<_>>>()?;

        // Verify the transaction infos are proven by the ledger info.
        self.proof
            .verify(ledger_info, self.get_first_transaction_version())?;

        // Verify the events if they exist.
        if let Some(event_lists) = &self.events {
            ensure!(
                event_lists.len() == self.get_num_transactions(),
                "The length of event_lists ({}) does not match the number of transactions ({}).",
                event_lists.len(),
                self.get_num_transactions(),
            );
            event_lists
                .into_par_iter()
                .zip_eq(self.proof.transaction_infos.par_iter())
                .map(|(events, txn_info)| verify_events_against_root_hash(events, txn_info))
                .collect::<Result<Vec<_>>>()?;
        }

        Ok(())
    }
```
