# Audit Report

## Title
Silent Failure in Consensus Key Rotation Due to Suppressed Identity Blob Loading Errors

## Summary
The `overriding_identity_paths` field in `InitialSafetyRulesConfig` uses `.unwrap_or_default()` when loading identity blobs during validator startup, silently suppressing all file access errors. Combined with the `skip_serializing_if` attribute making empty vectors invisible in serialized configs, this creates a silent failure mode where validators fail to load rotation keys, causing consensus participation failure after on-chain key rotation without clear error indication.

## Finding Description

The vulnerability involves three interconnected issues in the consensus key rotation mechanism:

**Issue 1: Invisible Field in Serialized Configs** [1](#0-0) 

The `skip_serializing_if = "Vec::is_empty"` attribute causes the `overriding_identity_paths` field to be omitted from YAML configs when empty. This reduces operator visibility of the field's existence.

**Issue 2: Silent Error Suppression** [2](#0-1) 

The `.unwrap_or_default()` silently catches and suppresses ALL errors when loading overriding identity blobs, including:
- File not found errors
- Permission denied errors  
- I/O errors
- Deserialization/corruption errors

**Issue 3: Insufficient Error Logging** [3](#0-2) 

Only a timing log exists, with no indication of whether zero vs. many keys were loaded, and no warning if loading failed.

**Attack Scenario:**

1. Validator operator configures key rotation by adding identity blob paths to `overriding_identity_paths` and saves config
2. A file system issue occurs (moved file, permission change, disk corruption, etc.)
3. On validator restart, the safety rules manager attempts to load the blobs
4. Loading fails, but `.unwrap_or_default()` returns an empty vector—no error propagated
5. The validator starts normally with zero rotation keys loaded into storage
6. When on-chain key rotation activates in a new epoch, the validator attempts to initialize with the new key [4](#0-3) 

7. `consensus_sk_by_pk()` fails to find the rotation key in storage [5](#0-4) 

8. The validator cannot initialize its signer with the new key (returns `Error::ValidatorKeyNotFound`)
9. All subsequent signing attempts fail with `Error::NotInitialized` [6](#0-5) 

10. **The validator cannot participate in consensus—complete liveness failure for that validator**

This breaks the consensus liveness invariant: validators must be able to sign blocks and participate in consensus after legitimate key rotation.

## Impact Explanation

**Severity: Medium** per Aptos bug bounty criteria—"State inconsistencies requiring intervention"

**Impact:**
- **Single validator liveness failure**: The affected validator completely stops participating in consensus
- **Loss of validator rewards**: The validator earns no rewards while unable to sign
- **Potential slashing**: Depending on Aptos's penalty mechanisms for non-participation
- **Silent failure**: No clear error indication makes diagnosis difficult, extending downtime
- **Operational security risk**: Undermines confidence in key rotation procedures

This does not affect network-wide consensus safety (requires >1/3 Byzantine validators), but causes operational harm to individual validators and reduces network resilience.

## Likelihood Explanation

**Likelihood: Medium to High in production environments**

Common triggering scenarios:
- File permission changes during system maintenance
- Disk space exhaustion preventing file reads
- Network-mounted storage becoming unavailable
- File system corruption
- Accidental file deletion or movement
- Container/VM migration losing file paths
- Configuration management tools overwriting files

The issue is highly likely to occur in real operational environments where file system issues are common. The silent nature makes detection difficult, increasing mean-time-to-recovery.

## Recommendation

**Fix 1: Fail-Fast on Loading Errors**

Change the error handling to propagate errors instead of silently suppressing them:

```rust
// In consensus/safety-rules/src/safety_rules_manager.rs, lines 81-98
let overriding_blobs = config
    .initial_safety_rules_config
    .overriding_identity_blobs()
    .map_err(|e| {
        panic!("Failed to load overriding identity blobs: {}. Check file paths and permissions in overriding_identity_paths.", e)
    })?;

for blob in overriding_blobs {
    if let Some(sk) = blob.consensus_private_key {
        let pk_hex = hex::encode(PublicKey::from(&sk).to_bytes());
        let storage_key = format!("{}_{}", CONSENSUS_KEY, pk_hex);
        storage.internal_store().set(storage_key.as_str(), sk)
            .map_err(|e| panic!("Failed to store consensus key {}: {}", storage_key, e))?;
        info!("Successfully loaded and stored rotation key: {}", storage_key);
    }
}
info!("Loaded {} overriding consensus keys in {:?}", overriding_blobs.len(), timer.elapsed());
```

**Fix 2: Add Config Validation**

Add validation to ensure paths exist and are readable before starting the validator.

**Fix 3: Improve Logging**

Add explicit logging for success/failure cases with counts of loaded keys.

## Proof of Concept

```rust
// Rust reproduction demonstrating the silent failure

#[test]
fn test_silent_key_rotation_failure() {
    use std::fs::File;
    use std::path::PathBuf;
    use tempfile::tempdir;
    
    // Create a validator config with overriding identity paths
    let temp_dir = tempdir().unwrap();
    let non_existent_path = temp_dir.path().join("non_existent_key.yaml");
    
    let mut config = SafetyRulesConfig::default();
    config.initial_safety_rules_config = InitialSafetyRulesConfig::from_file(
        temp_dir.path().join("validator.yaml"),
        vec![non_existent_path], // Path that doesn't exist
        WaypointConfig::None,
    );
    
    // This will silently return empty vector instead of error
    let blobs = config.initial_safety_rules_config
        .overriding_identity_blobs()
        .unwrap_or_default();
    
    // Assert that error was silently suppressed
    assert_eq!(blobs.len(), 0, "Expected empty vec due to file not found");
    
    // In production, validator would start without rotation keys
    // When epoch changes to new key, validator cannot sign -> downtime
}
```

**Notes:**

This vulnerability represents a failure of defensive programming principles in a critical consensus component. While it requires operational issues to trigger rather than malicious input, it constitutes a legitimate security concern because:

1. It violates the fail-safe principle—errors should be loud, not silent
2. It reduces system resilience against operational mistakes  
3. It creates operational security risk during key rotation procedures
4. The impact (validator downtime + potential slashing) has direct financial consequences

The combination of the invisible field (due to `skip_serializing_if`) and silent error suppression (due to `.unwrap_or_default()`) creates a dangerous failure mode that operators cannot easily detect or debug.

### Citations

**File:** config/src/config/safety_rules_config.rs (L125-126)
```rust
        #[serde(skip_serializing_if = "Vec::is_empty", default)]
        overriding_identity_paths: Vec<PathBuf>,
```

**File:** consensus/safety-rules/src/safety_rules_manager.rs (L81-84)
```rust
        for blob in config
            .initial_safety_rules_config
            .overriding_identity_blobs()
            .unwrap_or_default()
```

**File:** consensus/safety-rules/src/safety_rules_manager.rs (L99-99)
```rust
        info!("Overriding key work time: {:?}", timer.elapsed());
```

**File:** consensus/safety-rules/src/safety_rules.rs (L123-127)
```rust
    pub(crate) fn signer(&self) -> Result<&ValidatorSigner, Error> {
        self.validator_signer
            .as_ref()
            .ok_or_else(|| Error::NotInitialized("validator_signer".into()))
    }
```

**File:** consensus/safety-rules/src/safety_rules.rs (L326-336)
```rust
                    match self.persistent_storage.consensus_sk_by_pk(expected_key) {
                        Ok(consensus_key) => {
                            self.validator_signer =
                                Some(ValidatorSigner::new(author, Arc::new(consensus_key)));
                            Ok(())
                        },
                        Err(Error::SecureStorageMissingDataError(error)) => {
                            Err(Error::ValidatorKeyNotFound(error))
                        },
                        Err(error) => Err(error),
                    }
```

**File:** consensus/safety-rules/src/persistent_safety_storage.rs (L106-132)
```rust
    pub fn consensus_sk_by_pk(
        &self,
        pk: bls12381::PublicKey,
    ) -> Result<bls12381::PrivateKey, Error> {
        let _timer = counters::start_timer("get", CONSENSUS_KEY);
        let pk_hex = hex::encode(pk.to_bytes());
        let explicit_storage_key = format!("{}_{}", CONSENSUS_KEY, pk_hex);
        let explicit_sk = self
            .internal_store
            .get::<bls12381::PrivateKey>(explicit_storage_key.as_str())
            .map(|v| v.value);
        let default_sk = self.default_consensus_sk();
        let key = match (explicit_sk, default_sk) {
            (Ok(sk_0), _) => sk_0,
            (Err(_), Ok(sk_1)) => sk_1,
            (Err(_), Err(_)) => {
                return Err(Error::ValidatorKeyNotFound("not found!".to_string()));
            },
        };
        if key.public_key() != pk {
            return Err(Error::SecureStorageMissingDataError(format!(
                "Incorrect sk saved for {:?} the expected pk",
                pk
            )));
        }
        Ok(key)
    }
```
