# Audit Report

## Title
Backup Restore Version Manipulation via Compromised Backup Source Metadata

## Summary
The restore coordinator sets `COORDINATOR_TARGET_VERSION` based on `max_transaction_version` from backup metadata without validating against trusted sources. A compromised backup source can provide artificially low version metadata, causing the restore to complete with incomplete blockchain state while appearing successful.

## Finding Description

The restore process determines the target version for restoration through the following flow: [1](#0-0) 

The `max_transaction_version` is obtained from backup metadata loaded from the backup storage: [2](#0-1) 

This metadata originates from files downloaded from the backup source: [3](#0-2) 

The metadata structures are deserialized directly from JSON without validation of completeness: [4](#0-3) 

**Attack Scenario:**

1. Attacker compromises backup storage (e.g., S3 bucket, backup service)
2. Attacker provides metadata files claiming `last_version: 1000` when real blockchain is at version 50000
3. Attacker provides internally consistent backup data for versions 0-1000 (valid signatures, proofs, hashes)
4. Operator runs restore without specifying `target_version` (defaults to `Version::MAX`): [5](#0-4) 

5. Operator doesn't provide `trust_waypoint` parameters (optional, not required): [6](#0-5) 

6. Restore coordinator sets `target_version = min(Version::MAX, 1000) = 1000`
7. All cryptographic validation passes (data is internally consistent)
8. Restore completes successfully with only 1000 versions instead of 50000
9. Restored node believes it has complete blockchain but is missing 49000 versions

**Why This Bypasses Security Controls:**

Without trusted waypoints, signature verification uses epoch history from the same compromised backup source: [7](#0-6) 

The epoch history verification falls back to signature checking using validator sets from the backup itself (line 306-309), creating circular trust. The only external validation would come from trusted waypoints, but these are optional.

## Impact Explanation

This vulnerability qualifies as **HIGH severity** under Aptos bug bounty criteria for "Significant protocol violations":

1. **State Consistency Violation**: Restored node operates with incomplete blockchain state, violating the critical invariant that "State transitions must be atomic and verifiable via Merkle proofs"

2. **Validator Impact**: If a validator uses this compromised restore:
   - Cannot sync with network (version mismatch)
   - May attempt to participate in consensus with stale state
   - Could cause consensus disruption or liveness issues

3. **Full Node Impact**: Regular nodes serving this incomplete state:
   - Provide incorrect blockchain data to users/applications
   - Return wrong account states, transaction history
   - Cannot properly sync with network

4. **Network Partition Risk**: Multiple nodes restoring from compromised backup could form an isolated network segment

The only mitigation is an INFO-level log message that most operators would miss or misinterpret. [8](#0-7) 

## Likelihood Explanation

**HIGH likelihood** due to:

1. **No Security Warnings**: Documentation suggests trusted waypoints are for specific scenarios (genesis, writeset transactions), not mandatory security controls

2. **Common Operational Pattern**: Operators typically restore without explicit target_version (want latest) and without waypoints (trust backup provider)

3. **Realistic Attack Vector**: Backup storage compromise is a known supply chain attack vector
   - Compromised cloud storage credentials
   - Malicious backup service provider
   - Man-in-the-middle on backup download

4. **Silent Failure**: No validation error, only INFO log that shows `Version::MAX` (18446744073709551615) which operators won't recognize as suspicious

## Recommendation

Implement mandatory validation of backup completeness:

1. **Require Trusted Waypoints for Production Restores**: Make `trust_waypoint` mandatory when not in dry-run mode, or require explicit `--allow-untrusted-backup` flag

2. **Add Validation Against Known Network State**: Before completing restore, query network peers for current version and compare against restored version

3. **Implement Target Version Validation**: Add explicit check that warns/errors if backup metadata provides suspiciously low version:

```rust
// In RestoreCoordinator::run_impl(), after line 132:
if self.global_opt.target_version == Version::MAX && max_txn_ver < expected_minimum_version {
    bail!(
        "Backup metadata claims max version {} but this seems suspiciously low. \
        If this is correct, explicitly specify --target-version {}. \
        Otherwise, verify backup source integrity and use --trust-waypoint for validation.",
        max_txn_ver, max_txn_ver
    );
}
```

4. **Enhance Logging**: Change INFO log to WARNING with clear explanation:

```rust
if self.global_opt.target_version == Version::MAX {
    warn!(
        "Restoring to version {} from backup metadata. \
        Verify this matches expected blockchain height. \
        Use --trust-waypoint to validate against known checkpoints.",
        target_version
    );
}
```

## Proof of Concept

**Setup:**
1. Create backup storage with manipulated metadata
2. Run restore coordinator without target_version or trusted waypoints

**Expected Behavior:**
- Restore completes successfully at artificially low version
- Node cannot sync with real network
- State queries return incomplete/incorrect data

**Reproduction Steps:**

```rust
// 1. Create malicious metadata file
let malicious_metadata = TransactionBackupMeta {
    first_version: 0,
    last_version: 1000,  // Real blockchain at version 50000
    manifest: FileHandle::new("fake_manifest.json"),
};

// 2. Run restore without protections
let opt = GlobalRestoreOpt {
    target_version: None,  // Defaults to Version::MAX
    trusted_waypoints: TrustedWaypointOpt::default(),  // Empty
    db_dir: Some(PathBuf::from("/tmp/compromised_db")),
    ..Default::default()
};

// 3. Restore completes at version 1000
RestoreCoordinator::new(
    RestoreCoordinatorOpt::default(),
    opt.try_into()?,
    compromised_storage,
).run().await?;

// 4. Verify incomplete state
let db = AptosDB::open(...)?;
assert_eq!(db.get_latest_version()?, 1000);  // Missing 49000 versions!
```

**Notes:**
- The vulnerability requires control over backup source (compromised storage, malicious provider)
- Impact is severe: restored nodes cannot properly participate in network
- No security warnings prevent this attack
- Trusted waypoints would mitigate but are not mandatory

### Citations

**File:** storage/backup/backup-cli/src/coordinators/restore.rs (L125-134)
```rust
        let max_txn_ver = metadata_view
            .max_transaction_version()?
            .ok_or_else(|| anyhow!("No transaction backup found."))?;
        let target_version = std::cmp::min(self.global_opt.target_version, max_txn_ver);
        info!(
            "User specified target version: {}, max transaction version: {}, Target version is set to {}",
            self.global_opt.target_version, max_txn_ver, target_version
        );

        COORDINATOR_TARGET_VERSION.set(target_version as i64);
```

**File:** storage/backup/backup-cli/src/metadata/view.rs (L162-169)
```rust
    pub fn max_transaction_version(&self) -> Result<Option<Version>> {
        Ok(self
            .transaction_backups
            .iter()
            .sorted()
            .next_back()
            .map(|backup| backup.last_version))
    }
```

**File:** storage/backup/backup-cli/src/metadata/cache.rs (L90-122)
```rust
pub async fn sync_and_load(
    opt: &MetadataCacheOpt,
    storage: Arc<dyn BackupStorage>,
    concurrent_downloads: usize,
) -> Result<MetadataView> {
    let timer = Instant::now();
    let cache_dir = opt.cache_dir();
    create_dir_all(&cache_dir).await.err_notes(&cache_dir)?; // create if not present already

    // List cached metadata files.
    let dir = read_dir(&cache_dir).await.err_notes(&cache_dir)?;
    let local_hashes_vec: Vec<String> = ReadDirStream::new(dir)
        .filter_map(|entry| match entry {
            Ok(e) => {
                let path = e.path();
                let file_name = path.file_name()?.to_str()?;
                Some(file_name.to_string())
            },
            Err(_) => None,
        })
        .collect()
        .await;
    let local_hashes: HashSet<_> = local_hashes_vec.into_iter().collect();
    // List remote metadata files.
    let mut remote_file_handles = storage.list_metadata_files().await?;
    if remote_file_handles.is_empty() {
        initialize_identity(&storage).await.context(
            "\
            Backup storage appears empty and failed to put in identity metadata, \
            no point to go on. If you believe there is content in the backup, check authentication.\
            ",
        )?;
        remote_file_handles = storage.list_metadata_files().await?;
```

**File:** storage/backup/backup-cli/src/metadata/mod.rs (L191-196)
```rust
#[derive(Clone, Debug, Deserialize, Serialize, Eq, PartialEq, Ord, PartialOrd)]
pub struct TransactionBackupMeta {
    pub first_version: Version,
    pub last_version: Version,
    pub manifest: FileHandle,
}
```

**File:** storage/backup/backup-cli/src/utils/mod.rs (L290-297)
```rust
impl TryFrom<GlobalRestoreOpt> for GlobalRestoreOptions {
    type Error = anyhow::Error;

    fn try_from(opt: GlobalRestoreOpt) -> anyhow::Result<Self> {
        let target_version = opt.target_version.unwrap_or(Version::MAX);
        let concurrent_downloads = opt.concurrent_downloads.get();
        let replay_concurrency_level = opt.replay_concurrency_level.get();
        let run_mode = if let Some(db_dir) = &opt.db_dir {
```

**File:** storage/backup/backup-cli/src/utils/mod.rs (L331-346)
```rust
#[derive(Clone, Default, Parser)]
pub struct TrustedWaypointOpt {
    #[clap(
        long,
        help = "(multiple) When provided, an epoch ending LedgerInfo at the waypoint version will be \
        checked against the hash in the waypoint, but signatures on it are NOT checked. \
        Use this for two purposes: \
        1. set the genesis or the latest waypoint to confirm the backup is compatible. \
        2. set waypoints at versions where writeset transactions were used to overwrite the \
        validator set, so that the signature check is skipped. \
        N.B. LedgerInfos are verified only when restoring / verifying the epoch ending backups, \
        i.e. they are NOT checked at all when doing one-shot restoring of the transaction \
        and state backups."
    )]
    pub trust_waypoint: Vec<Waypoint>,
}
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L276-312)
```rust
    pub fn verify_ledger_info(&self, li_with_sigs: &LedgerInfoWithSignatures) -> Result<()> {
        let epoch = li_with_sigs.ledger_info().epoch();
        ensure!(!self.epoch_endings.is_empty(), "Empty epoch history.",);
        if epoch > self.epoch_endings.len() as u64 {
            // TODO(aldenhu): fix this from upper level
            warn!(
                epoch = epoch,
                epoch_history_until = self.epoch_endings.len(),
                "Epoch is too new and can't be verified. Previous chunks are verified and node \
                won't be able to start if this data is malicious."
            );
            return Ok(());
        }
        if epoch == 0 {
            ensure!(
                li_with_sigs.ledger_info() == &self.epoch_endings[0],
                "Genesis epoch LedgerInfo info doesn't match.",
            );
        } else if let Some(wp_trusted) = self
            .trusted_waypoints
            .get(&li_with_sigs.ledger_info().version())
        {
            let wp_li = Waypoint::new_any(li_with_sigs.ledger_info());
            ensure!(
                *wp_trusted == wp_li,
                "Waypoints don't match. In backup: {}, trusted: {}",
                wp_li,
                wp_trusted,
            );
        } else {
            self.epoch_endings[epoch as usize - 1]
                .next_epoch_state()
                .ok_or_else(|| anyhow!("Shouldn't contain non- epoch bumping LIs."))?
                .verify(li_with_sigs)?;
        };
        Ok(())
    }
```
