# Audit Report

## Title
Integer Underflow in Key Version Arithmetic Allows Retrieval of Old Compromised Cryptographic Keys

## Summary
The `get_public_key_previous_version()` function in VaultStorage contains an unchecked integer subtraction that wraps around when the highest key version is 0, potentially allowing access to old, compromised validator keys that should no longer be accessible.

## Finding Description

The Aptos VaultStorage system manages cryptographic keys for validators with version-based rotation. When retrieving the previous version of a key, the code performs unchecked arithmetic that violates **Cryptographic Correctness** invariants. [1](#0-0) 

When `highest_version` is 0 (either as the initial version or after version counter wraparound), the subtraction `version - 1` wraps to `u32::MAX` (4,294,967,295) due to Rust's default wrapping arithmetic in release builds. The function then searches for and returns a key with version `u32::MAX` if it exists, potentially retrieving an old compromised key version instead of failing safely.

**Attack Scenario:**
1. A long-running validator has rotated keys many times, approaching version limits
2. Key versions wrap from `u32::MAX` to 0 (either through natural progression or due to truncation of Vault's internal i64 versions during deserialization)
3. The newest key has version 0, but old keys near `u32::MAX` still exist in Vault's storage
4. A call to `get_public_key_previous_version()` triggers the integer underflow
5. The function returns the key with version `u32::MAX` (an old, potentially compromised key from months/years ago)
6. This old key is used for consensus operations, allowing an attacker who previously compromised that key to sign malicious blocks

This breaks the **Cryptographic Correctness** invariant that validator keys must use current, non-compromised cryptographic material for consensus participation.

## Impact Explanation

**Severity: High** ($50,000 tier per Aptos Bug Bounty)

This vulnerability enables:
- **Validator Security Compromise**: Use of old, potentially compromised consensus keys violates validator security guarantees
- **Significant Protocol Violation**: Incorrect key version retrieval breaks the key rotation security model
- **Potential Consensus Impact**: If an attacker has compromised an old validator key, they could use it to sign malicious consensus messages

While this doesn't directly cause "Consensus/Safety violations" requiring the Critical tier, it represents a **significant protocol violation** affecting validator cryptographic operations, placing it in the High severity category.

The similar issue in `trim_key_versions()` has defensive checked arithmetic that prevents exploitation: [2](#0-1) 

However, `get_public_key_previous_version()` lacks these protections.

## Likelihood Explanation

**Likelihood: Low to Medium**

Prerequisites for exploitation:
- Version counter must reach 0 (requires either natural wraparound or deserialization edge cases)
- Old keys with versions near `u32::MAX` must still exist in Vault storage
- Attacker must have previously compromised an old key version
- Key trimming must not have removed the old key versions

While Vault internally uses i64 for versions, the Rust code deserializes to u32: [3](#0-2) 

The fuzzing infrastructure explicitly tests this edge case with arbitrary u32 values: [4](#0-3) 

The presence of fuzzing tests for this scenario indicates the developers recognized this as a potential issue requiring validation.

## Recommendation

Replace unchecked subtraction with checked arithmetic and handle the underflow case explicitly:

```rust
fn get_public_key_previous_version(&self, name: &str) -> Result<Ed25519PublicKey, Error> {
    let name = self.crypto_name(name);
    let pubkeys = self.client().read_ed25519_key(&name)?;
    let highest_version = pubkeys.iter().map(|pubkey| pubkey.version).max();
    match highest_version {
        Some(version) => {
            let previous_version = version.checked_sub(1)
                .ok_or_else(|| Error::KeyVersionNotFound(name.clone(), "previous version (version 0 has no predecessor)".into()))?;
            let pubkey = pubkeys.iter().find(|pubkey| pubkey.version == previous_version);
            Ok(pubkey
                .ok_or_else(|| Error::KeyVersionNotFound(name, "previous version".into()))?
                .value
                .clone())
        },
        None => Err(Error::KeyVersionNotFound(name, "previous version".into())),
    }
}
```

Additionally, apply the same defensive pattern to the comparison in `trim_key_versions()`:
```rust
// Use saturating_sub to prevent wraparound in version comparison
if max_version.saturating_sub(min_version) >= MAX_NUM_KEY_VERSIONS {
    // existing checked arithmetic...
}
```

## Proof of Concept

```rust
#[cfg(test)]
mod version_underflow_test {
    use super::*;
    
    #[test]
    fn test_get_previous_version_underflow() {
        // Simulate scenario where version counter has wrapped to 0
        let mut storage = create_test_vault_storage();
        
        // Create initial key with version u32::MAX (simulating old key)
        storage.import_key_with_version("test_key", u32::MAX).unwrap();
        
        // Rotate to version 0 (wraparound scenario)
        storage.rotate_key_to_version("test_key", 0).unwrap();
        
        // Attempt to get previous version - should fail safely, not return u32::MAX key
        let result = storage.get_public_key_previous_version("test_key");
        
        // Current buggy behavior: returns key with version u32::MAX
        // Expected behavior: should return KeyVersionNotFound error
        assert!(matches!(result, Err(Error::KeyVersionNotFound(_, _))));
    }
    
    #[test] 
    fn test_trim_versions_wraparound() {
        let mut storage = create_test_vault_storage();
        
        // Create keys with versions near u32::MAX
        for v in (u32::MAX - 3)..=u32::MAX {
            storage.import_key_with_version("test_key", v).unwrap();
        }
        
        // Rotate to version 0-3 (wraparound)
        for v in 0..4 {
            storage.rotate_key_to_version("test_key", v).unwrap();
        }
        
        // Trim should handle wraparound safely
        let result = storage.trim_key_versions("test_key");
        
        // Should either succeed with correct trimming or return OverflowError
        // Should NOT incorrectly trim based on wrapped arithmetic
        assert!(result.is_ok() || matches!(result, Err(Error::OverflowError(_))));
    }
}
```

**Notes**

This vulnerability affects the cryptographic key management layer used by Aptos validators for consensus operations. While the attack surface is constrained by requiring specific version wraparound conditions, the security impact is significant as it could allow use of compromised historical keys. The defensive coding pattern already used in `trim_key_versions()` with checked arithmetic should be applied consistently across all version-related operations to prevent integer overflow/underflow vulnerabilities.

### Citations

**File:** secure/storage/src/vault.rs (L252-266)
```rust
    fn get_public_key_previous_version(&self, name: &str) -> Result<Ed25519PublicKey, Error> {
        let name = self.crypto_name(name);
        let pubkeys = self.client().read_ed25519_key(&name)?;
        let highest_version = pubkeys.iter().map(|pubkey| pubkey.version).max();
        match highest_version {
            Some(version) => {
                let pubkey = pubkeys.iter().find(|pubkey| pubkey.version == version - 1);
                Ok(pubkey
                    .ok_or_else(|| Error::KeyVersionNotFound(name, "previous version".into()))?
                    .value
                    .clone())
            },
            None => Err(Error::KeyVersionNotFound(name, "previous version".into())),
        }
    }
```

**File:** secure/storage/vault/src/lib.rs (L373-380)
```rust
        if (max_version - min_version) >= MAX_NUM_KEY_VERSIONS {
            // let min_available_version = max_version - MAX_NUM_KEY_VERSIONS + 1;
            let min_available_version = max_version
                .checked_sub(MAX_NUM_KEY_VERSIONS)
                .and_then(|n| n.checked_add(1))
                .ok_or_else(|| {
                    Error::OverflowError("trim_key_versions::min_available_version".into())
                })?;
```

**File:** secure/storage/vault/src/lib.rs (L1052-1055)
```rust
struct ReadSecretMetadata {
    created_time: String,
    version: u32,
}
```

**File:** secure/storage/vault/src/fuzzing.rs (L73-86)
```rust
    pub fn arb_secret_read_response(
    )(
        status in any::<u16>(),
        status_text in any::<String>(),
        data in prop::collection::btree_map(any::<String>(), arb_json_value(), 0..MAX_COLLECTION_SIZE),
        created_time in any::<String>(),
        version in any::<u32>(),
        secret in any::<String>(),
        key in any::<String>(),
    ) -> (Response, String, String) {
        let metadata = ReadSecretMetadata {
            created_time,
            version,
        };
```
