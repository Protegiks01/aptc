# Audit Report

## Title
Transaction Version Manipulation via Unverified Backup Restoration in db-tool

## Summary
The `db-tool` Oneoff::Transaction restore command allows an attacker with backup storage access to restore transactions with manipulated version numbers, causing ledger inconsistencies and enabling potential transaction replay attacks. This occurs because the restore operation hardcodes `VerifyExecutionMode::NoVerify` and passes `None` for `epoch_history`, bypassing critical cryptographic and version validation checks.

## Finding Description

The vulnerability exists in the transaction restoration flow where two critical security flaws combine to allow version manipulation:

**Flaw 1: Hardcoded NoVerify Mode**
The Oneoff::Transaction restore command hardcodes `VerifyExecutionMode::NoVerify`, which disables transaction execution verification. [1](#0-0) 

**Flaw 2: Missing Epoch History Validation**
The same command passes `None` for `epoch_history`, which disables ledger info signature verification. [2](#0-1) 

**Attack Flow:**

1. **Backup Verification Bypass**: When loading backup chunks, the system normally verifies the `LedgerInfoWithSignatures` against trusted epoch history. However, when `epoch_history` is `None`, this verification is skipped: [3](#0-2) 

Without epoch history, an attacker can provide a fake `LedgerInfoWithSignatures` with:
- Fake validator signatures (not verified)
- Fake transaction accumulator root hash
- No validation against trusted genesis or waypoints

2. **Internal Consistency Check Only**: The cryptographic verification only checks internal consistency between the proof and the fake ledger info: [4](#0-3) 

This verification passes because the attacker creates a self-consistent malicious backup with manipulated version numbers.

3. **Execution Verification Skipped**: When `NoVerify` mode is used, the chunk executor skips re-execution verification that would detect output mismatches: [5](#0-4) 

4. **Pre-commit Validation Bypassed**: The restore path uses `restore_utils::save_transactions` which directly writes to the database, bypassing the normal `pre_commit_validation` that checks version continuity: [6](#0-5) 

The normal validation path would enforce that `chunk.first_version == next_expected_version`: [7](#0-6) 

But the restore path bypasses this entirely.

5. **Database Corruption**: Transactions are written to the database with manipulated version numbers via direct database writes: [8](#0-7) 

The `put_transaction` operation overwrites any existing data without validation: [9](#0-8) 

**Breaking Invariants:**
- **State Consistency**: Transactions at wrong versions violate the ledger's linear history
- **Deterministic Execution**: Different nodes could have different transactions at the same versions
- **Cryptographic Correctness**: Signature verification is bypassed when epoch_history is None

## Impact Explanation

**Severity: HIGH**

This vulnerability meets the HIGH severity criteria per Aptos bug bounty rules:

1. **Significant Protocol Violations**: Allows manipulation of the fundamental transaction ledger structure
2. **State Inconsistencies**: Creates ledger inconsistencies that could require manual intervention or chain rollback
3. **Validator Node Compromise**: A compromised validator's backup storage leads to corrupted database state

**Potential Impacts:**
- **Ledger Inconsistencies**: Transactions written at incorrect version numbers break the sequential ledger invariant
- **Transaction Replay**: Same transaction could exist at multiple versions, potentially enabling double-spending
- **State Corruption**: Wrong transactions applied at wrong versions lead to incorrect state transitions
- **Consensus Divergence**: Validators restoring from manipulated backups diverge from honest validators

While this doesn't directly cause fund loss, it creates conditions that could enable subsequent exploits and requires sophisticated recovery procedures.

## Likelihood Explanation

**Likelihood: MEDIUM**

**Attack Prerequisites:**
1. Write access to backup storage (e.g., compromised S3 bucket, cloud storage credentials, or local backup directory)
2. Knowledge of backup format and manifest structure
3. Ability to craft valid cryptographic structures (though not requiring signature forgery)

**Factors Increasing Likelihood:**
- Backup storage is often less secured than production systems
- Cloud storage misconfigurations are common
- The attack doesn't require breaking cryptographic primitives
- No special privileges or validator insider access needed

**Factors Decreasing Likelihood:**
- Requires specific knowledge of Aptos backup internals
- Attack detection possible through monitoring of restore operations
- Limited attack window (during restore operations)

## Recommendation

**Immediate Fixes:**

1. **Remove NoVerify Hardcoding**: Make verification mode configurable with safe defaults:

```rust
Oneoff::Transaction {
    storage,
    opt,
    global,
} => {
    // Add CLI option for verify mode with secure default
    let verify_mode = opt.skip_verify
        .then(|| VerifyExecutionMode::NoVerify)
        .unwrap_or_else(|| VerifyExecutionMode::verify_all());
    
    TransactionRestoreController::new(
        opt,
        global.try_into()?,
        storage.init_storage().await?,
        None, /* epoch_history - should be required */
        verify_mode,
    )
    .run()
    .await?;
}
```

2. **Require Epoch History**: Make epoch_history mandatory for security-critical restore operations:

```rust
// In TransactionRestoreController::new()
pub fn new(
    opt: TransactionRestoreOpt,
    global_opt: GlobalRestoreOptions,
    storage: Arc<dyn BackupStorage>,
    epoch_history: Option<Arc<EpochHistory>>, // Should be required, not optional
    verify_execution_mode: VerifyExecutionMode,
) -> Self {
    // Validate epoch_history is provided
    ensure!(
        epoch_history.is_some(),
        "epoch_history is required for secure transaction restoration"
    );
    // ... rest of implementation
}
```

3. **Add Version Conflict Detection**: Implement validation that prevents restoring over existing data:

```rust
// In save_transactions
fn save_transactions(...) -> Result<()> {
    // Get next expected version from DB
    let next_expected = restore_handler.get_next_expected_transaction_version()?;
    
    // Validate version continuity
    ensure!(
        first_version >= next_expected,
        "Cannot restore transactions at version {} when DB expects {}. Possible version manipulation detected.",
        first_version,
        next_expected
    );
    
    // ... continue with save
}
```

**Long-term Solutions:**
- Implement backup signature verification independent of epoch history
- Add checksum validation for backup manifests
- Implement audit logging for all restore operations
- Add --force flag requirement for operations that could overwrite data

## Proof of Concept

**Attack Scenario:**

```rust
// Step 1: Attacker creates malicious backup files
// File: malicious_manifest.json
{
    "first_version": 1000,  // Manipulated version
    "last_version": 1999,   // Manipulated version
    "transactions": "chunk_1000_1999.blob",
    "proof": "fake_proof.blob"
}

// Step 2: Attacker creates fake LedgerInfoWithSignatures
// File: fake_proof.blob (BCS-serialized)
// - Contains fake transaction_accumulator_hash
// - Contains invalid validator signatures (not checked without epoch_history)
// - Range proof created against fake accumulator root

// Step 3: Execute restore command
// $ aptos-db-tool restore one-off transaction \
//     --transaction-manifest /path/to/malicious_manifest.json \
//     --target-db /path/to/victim/db

// Step 4: Verification bypasses
// - epoch_history is None → no signature verification
// - NoVerify mode → no execution verification
// - Direct DB write → no version conflict detection

// Step 5: Result
// - Transactions written at versions 1000-1999
// - May overwrite legitimate data if DB already has those versions
// - Ledger consistency violated
// - State corruption occurs
```

**Reproduction Steps:**

1. Set up test environment with AptosDB
2. Create legitimate backup of transactions
3. Modify manifest to change version numbers
4. Create self-consistent fake ledger info and proofs
5. Run `db-tool restore one-off transaction` command
6. Observe transactions written at manipulated versions
7. Verify ledger inconsistency by comparing with legitimate chain

**Validation:**
The vulnerability is confirmed by code analysis showing:
- NoVerify is hardcoded (cannot be disabled)
- epoch_history is None (signature verification bypassed)
- restore_utils bypasses pre_commit_validation
- No version conflict detection exists

This breaks the "State Consistency" invariant that transactions must maintain sequential version numbers in the ledger.

### Citations

**File:** storage/db-tool/src/restore.rs (L97-111)
```rust
                    Oneoff::Transaction {
                        storage,
                        opt,
                        global,
                    } => {
                        TransactionRestoreController::new(
                            opt,
                            global.try_into()?,
                            storage.init_storage().await?,
                            None, /* epoch_history */
                            VerifyExecutionMode::NoVerify,
                        )
                        .run()
                        .await?;
                    },
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L147-154)
```rust
        let (range_proof, ledger_info) = storage
            .load_bcs_file::<(TransactionAccumulatorRangeProof, LedgerInfoWithSignatures)>(
                &manifest.proof,
            )
            .await?;
        if let Some(epoch_history) = epoch_history {
            epoch_history.verify_ledger_info(&ledger_info)?;
        }
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L156-167)
```rust
        // make a `TransactionListWithProof` to reuse its verification code.
        let txn_list_with_proof =
            TransactionListWithProofV2::new(TransactionListWithAuxiliaryInfos::new(
                TransactionListWithProof::new(
                    txns,
                    Some(event_vecs),
                    Some(manifest.first_version),
                    TransactionInfoListWithProof::new(range_proof, txn_infos),
                ),
                persisted_aux_info,
            ));
        txn_list_with_proof.verify(ledger_info.ledger_info(), Some(manifest.first_version))?;
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L507-517)
```rust
                        tokio::task::spawn_blocking(move || {
                            restore_handler.save_transactions(
                                first_version,
                                &txns_to_save,
                                &persisted_aux_info_to_save,
                                &txn_infos_to_save,
                                &event_vecs_to_save,
                                write_sets_to_save,
                            )
                        })
                        .await??;
```

**File:** execution/executor/src/chunk_executor/mod.rs (L562-575)
```rust
            let next_begin = if verify_execution_mode.should_verify() {
                self.verify_execution(
                    transactions,
                    persisted_aux_info,
                    transaction_infos,
                    write_sets,
                    event_vecs,
                    batch_begin,
                    batch_end,
                    verify_execution_mode,
                )?
            } else {
                batch_end
            };
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L245-261)
```rust
    fn pre_commit_validation(&self, chunk: &ChunkToCommit) -> Result<()> {
        let _timer = OTHER_TIMERS_SECONDS.timer_with(&["save_transactions_validation"]);

        ensure!(!chunk.is_empty(), "chunk is empty, nothing to save.");

        let next_version = self.state_store.current_state_locked().next_version();
        // Ensure the incoming committing requests are always consecutive and the version in
        // buffered state is consistent with that in db.
        ensure!(
            chunk.first_version == next_version,
            "The first version passed in ({}), and the next version expected by db ({}) are inconsistent.",
            chunk.first_version,
            next_version,
        );

        Ok(())
    }
```

**File:** storage/aptosdb/src/backup/restore_utils.rs (L206-229)
```rust
    for (idx, txn) in txns.iter().enumerate() {
        ledger_db.transaction_db().put_transaction(
            first_version + idx as Version,
            txn,
            /*skip_index=*/ false,
            &mut ledger_db_batch.transaction_db_batches,
        )?;
    }

    for (idx, aux_info) in persisted_aux_info.iter().enumerate() {
        PersistedAuxiliaryInfoDb::put_persisted_auxiliary_info(
            first_version + idx as Version,
            aux_info,
            &mut ledger_db_batch.persisted_auxiliary_info_db_batches,
        )?;
    }

    for (idx, txn_info) in txn_infos.iter().enumerate() {
        TransactionInfoDb::put_transaction_info(
            first_version + idx as Version,
            txn_info,
            &mut ledger_db_batch.transaction_info_db_batches,
        )?;
    }
```

**File:** storage/aptosdb/src/ledger_db/transaction_db.rs (L163-163)
```rust
        batch.put::<TransactionSchema>(&version, transaction)?;
```
