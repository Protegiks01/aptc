# Audit Report

## Title
Missing Sender Authentication Enables DoS Attack via Expensive Secret Share Verification

## Summary
An attacker can flood validators with malicious `SecretShare` messages claiming to be from any legitimate validator, forcing each recipient to perform expensive pairing-based cryptographic verification operations before rejecting the shares, creating a Denial-of-Service vector against consensus availability.

## Finding Description

The secret sharing verification flow contains a critical authentication gap that allows unprivileged attackers to force validators to perform expensive cryptographic operations:

**Attack Flow:**

1. When a `SecretShareMsg` is received over the network, the receiving validator wraps it in an `IncomingSecretShareRequest` with the actual sender's peer ID. [1](#0-0) 

2. The `sender` field is marked as unused and never validated. [2](#0-1) 

3. The verification task deserializes the message and calls `verify()` without checking if the claimed author matches the actual network sender. [3](#0-2) 

4. The `SecretShareMessage::verify()` method only checks the epoch, then immediately calls the expensive `share.verify(config)` for Share messages. [4](#0-3) 

5. `SecretShare::verify()` retrieves the verification key based on the claimed author and immediately invokes expensive cryptographic verification. [5](#0-4) 

6. The verification performs expensive operations including two pairing computations (thousands of CPU cycles each). [6](#0-5) 

**Vulnerability Details:**

An attacker can exploit this by:
- Sending multiple `SecretShare` messages with the `author` field set to any validator address in the current epoch
- The attacker doesn't need to control that validator's private key
- Each message forces the recipient validator to perform expensive BLS pairing operations
- The verification only fails AFTER these expensive operations complete
- The `BoundedExecutor` limits concurrent verifications but doesn't prevent queue saturation

This violates the **Resource Limits** invariant: "All operations must respect gas, storage, and computational limits."

## Impact Explanation

This vulnerability qualifies as **Medium Severity** per Aptos bug bounty criteria:

- **Validator Node Slowdowns**: Flooding validators with malicious shares causes significant CPU consumption from pairing operations, degrading node performance
- **Consensus Liveness Impact**: Delayed processing of legitimate shares can cause validators to miss consensus deadlines, affecting block production
- **Network-Wide Effect**: All validators in the epoch can be targeted simultaneously
- **No Authentication Required**: Any network peer can execute the attack without validator privileges

While this doesn't directly cause loss of funds or permanent consensus failure, it creates measurable availability degradation aligning with "validator node slowdowns" (High severity category) and could escalate to consensus timeouts under sustained attack.

## Likelihood Explanation

**Likelihood: High**

- **Low Attack Complexity**: Attacker only needs to send network messages with arbitrary author fields
- **No Special Access Required**: Any peer connected to the validator network can execute the attack
- **Scalable**: Single attacker can target multiple validators simultaneously
- **Hard to Rate-Limit**: Legitimate validators also send shares, making it difficult to distinguish attack traffic
- **No Cost to Attacker**: Unlike transaction spam (which requires gas fees), network messages are free

The attack is trivial to execute and highly effective due to the asymmetric cost: sending a malicious message is cheap, but verifying it is computationally expensive.

## Recommendation

**Implement sender authentication before expensive cryptographic operations:**

```rust
// In consensus/src/rand/secret_sharing/network_messages.rs
impl SecretShareMessage {
    pub fn verify(
        &self,
        epoch_state: &EpochState,
        config: &SecretShareConfig,
        sender: &Author, // Add sender parameter
    ) -> anyhow::Result<()> {
        ensure!(self.epoch() == epoch_state.epoch);
        match self {
            SecretShareMessage::RequestShare(_) => Ok(()),
            SecretShareMessage::Share(share) => {
                // Validate sender matches claimed author BEFORE expensive crypto
                ensure!(
                    share.author() == sender,
                    "Share author {:?} does not match network sender {:?}",
                    share.author(),
                    sender
                );
                share.verify(config)
            },
        }
    }
}

// In consensus/src/rand/secret_sharing/secret_share_manager.rs
async fn verification_task(...) {
    while let Some(dec_msg) = incoming_rpc_request.next().await {
        let tx = verified_msg_tx.clone();
        let epoch_state_clone = epoch_state.clone();
        let config_clone = config.clone();
        let sender = dec_msg.sender; // Capture sender
        bounded_executor
            .spawn(async move {
                match bcs::from_bytes::<SecretShareMessage>(dec_msg.req.data()) {
                    Ok(msg) => {
                        // Pass sender to verify
                        if msg.verify(&epoch_state_clone, &config_clone, &sender).is_ok() {
                            let _ = tx.unbounded_send(SecretShareRpc {
                                msg,
                                protocol: dec_msg.protocol,
                                response_sender: dec_msg.response_sender,
                            });
                        }
                    },
                    Err(e) => {
                        warn!("Invalid dec message: {}", e);
                    },
                }
            })
            .await;
    }
}
```

Also remove the `#[allow(unused)]` annotation from the `sender` field: [7](#0-6) 

## Proof of Concept

```rust
// Test to demonstrate the vulnerability
#[tokio::test]
async fn test_malicious_share_dos_attack() {
    use aptos_types::secret_sharing::{SecretShare, SecretShareMetadata};
    use aptos_crypto::hash::HashValue;
    
    // Setup: Create a valid epoch state and config
    let (epoch_state, config) = setup_test_epoch();
    
    // Attacker: Create a malicious share claiming to be from validator_0
    let victim_validator = epoch_state.verifier.get_ordered_account_addresses()[0];
    let attacker_peer_id = AccountAddress::random(); // Attacker's actual peer ID
    
    let malicious_metadata = SecretShareMetadata::new(
        epoch_state.epoch,
        1, // round
        12345, // timestamp
        HashValue::random(),
        random_digest(), // Random/invalid digest
    );
    
    let malicious_share = SecretShare::new(
        victim_validator, // Claim to be from legitimate validator
        malicious_metadata,
        random_secret_key_share(), // Random/invalid share
    );
    
    let msg = SecretShareMessage::Share(malicious_share);
    
    // Measure CPU time for verification
    let start = std::time::Instant::now();
    
    // This will perform expensive pairing operations even though
    // the attacker (attacker_peer_id) is not the claimed author (victim_validator)
    let result = msg.verify(&epoch_state, &config);
    
    let elapsed = start.elapsed();
    
    // The verification should fail, but only AFTER expensive operations
    assert!(result.is_err());
    
    // Demonstrate that verification took significant time (pairing operations)
    // On typical hardware, pairing operations take milliseconds
    assert!(elapsed.as_millis() > 5, "Verification was suspiciously fast");
    
    println!("Malicious share verification took: {:?}", elapsed);
    println!("Attack succeeded: Forced expensive verification without authentication");
}
```

**Notes**

This vulnerability exploits the gap between network-level peer authentication (which occurs during connection establishment) and application-level message authentication. While the network layer knows the true sender (peer_id), the consensus layer never validates that the claimed author in the message matches the actual network sender before performing expensive cryptographic operations. This is similar to other consensus messages which properly validate `author == sender` before expensive processing, but the secret sharing implementation omits this critical check.

### Citations

**File:** consensus/src/network.rs (L155-161)
```rust
pub struct IncomingSecretShareRequest {
    pub req: SecretShareNetworkMessage,
    #[allow(unused)]
    pub sender: Author,
    pub protocol: ProtocolId,
    pub response_sender: oneshot::Sender<Result<Bytes, RpcError>>,
}
```

**File:** consensus/src/network.rs (L920-936)
```rust
                        ConsensusMsg::SecretShareMsg(req) => {
                            let (tx, _rx) = oneshot::channel();
                            let req_with_callback = IncomingRpcRequest::SecretShareRequest(
                                IncomingSecretShareRequest {
                                    req,
                                    sender: peer_id,
                                    protocol: RPC[0],
                                    response_sender: tx,
                                },
                            );
                            if let Err(e) = self.rpc_tx.push(
                                (peer_id, discriminant(&req_with_callback)),
                                (peer_id, req_with_callback),
                            ) {
                                warn!(error = ?e, "aptos channel closed");
                            };
                        },
```

**File:** consensus/src/rand/secret_sharing/secret_share_manager.rs (L217-226)
```rust
                .spawn(async move {
                    match bcs::from_bytes::<SecretShareMessage>(dec_msg.req.data()) {
                        Ok(msg) => {
                            if msg.verify(&epoch_state_clone, &config_clone).is_ok() {
                                let _ = tx.unbounded_send(SecretShareRpc {
                                    msg,
                                    protocol: dec_msg.protocol,
                                    response_sender: dec_msg.response_sender,
                                });
                            }
```

**File:** consensus/src/rand/secret_sharing/network_messages.rs (L28-38)
```rust
    pub fn verify(
        &self,
        epoch_state: &EpochState,
        config: &SecretShareConfig,
    ) -> anyhow::Result<()> {
        ensure!(self.epoch() == epoch_state.epoch);
        match self {
            SecretShareMessage::RequestShare(_) => Ok(()),
            SecretShareMessage::Share(share) => share.verify(config),
        }
    }
```

**File:** types/src/secret_sharing.rs (L75-82)
```rust
    pub fn verify(&self, config: &SecretShareConfig) -> anyhow::Result<()> {
        let index = config.get_id(self.author());
        let decryption_key_share = self.share().clone();
        // TODO(ibalajiarun): Check index out of bounds
        config.verification_keys[index]
            .verify_decryption_key_share(&self.metadata.digest, &decryption_key_share)?;
        Ok(())
    }
```

**File:** crates/aptos-batch-encryption/src/shared/key_derivation.rs (L118-133)
```rust
fn verify_bls(
    verification_key_g2: G2Affine,
    digest: &Digest,
    offset: G2Affine,
    signature: G1Affine,
) -> Result<()> {
    let hashed_offset: G1Affine = symmetric::hash_g2_element(offset)?;

    if PairingSetting::pairing(digest.as_g1() + hashed_offset, verification_key_g2)
        == PairingSetting::pairing(signature, G2Affine::generator())
    {
        Ok(())
    } else {
        Err(anyhow::anyhow!("bls verification error"))
    }
}
```
