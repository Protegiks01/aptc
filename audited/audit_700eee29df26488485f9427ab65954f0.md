# Audit Report

## Title
Integer Underflow and Division-by-Zero in DKG Weight Rounding with Empty Validator Sets

## Summary
The DKG (Distributed Key Generation) weight rounding logic in `types/src/dkg/real_dkg/rounding/mod.rs` contains multiple critical vulnerabilities when processing an empty validator set: division-by-zero operations and integer underflow in weight calculations. These issues cause validator node crashes during epoch transitions, leading to network liveness failures.

## Finding Description

While the original `weighted_config.rs` file has proper bounds checking to prevent weight underflows [1](#0-0) , the related DKG rounding subsystem that consumes weighted configurations contains exploitable vulnerabilities.

When `stake::next_validator_consensus_infos()` computes the next epoch's validator set, it filters validators by minimum stake requirements [2](#0-1) . If no validators meet the minimum stake threshold, an empty vector is returned and propagated through the DKG initialization path [3](#0-2) .

The empty validator set flows to `DKGRounding::new()` [4](#0-3) , which calls `DKGRoundingProfile::new()` with an empty `validator_stakes` vector.

**Vulnerability #1 - Division by Zero (Initial Profile):** [5](#0-4) 

With empty `validator_stakes`: `stake_total = 0` and `weight_low = 0`, resulting in `U64F64::from_num(0) / U64F64::from_num(0)` on line 208, which panics.

**Vulnerability #2 - Integer Underflow (Binary Search):** [6](#0-5) 

If the binary search reaches `weight_mid = 0` (when `weight_low = weight_high = 0`), line 235 executes `weight_high = weight_mid - 1 = 0 - 1`, which underflows to `u64::MAX` (18,446,744,073,709,551,615), corrupting the binary search bounds.

**Vulnerability #3 - Division by Zero (Profile Computation):** [7](#0-6) 

In `compute_profile_fixed_point`, with empty stakes: `stake_sum_fixed = 0`, and line 332 computes `stake_per_weight * delta_total_fixed / stake_sum_fixed`, producing `0/0` indeterminate form.

## Impact Explanation

This vulnerability meets **High Severity** criteria per Aptos bug bounty guidelines:

- **Validator Node Crashes**: Division-by-zero panics crash validator nodes processing epoch transitions
- **Network Liveness Failure**: DKG cannot complete, blocking epoch progression and halting the network
- **Consensus Availability**: Multiple validator crashes prevent quorum formation

The impact is not classified as Critical because:
- No fund loss or theft occurs
- No permanent state corruption (chain can recover after node restarts)
- Requires specific preconditions (empty validator set)

## Likelihood Explanation

**Likelihood: Low to Medium**

The vulnerability triggers when `stake::next_validator_consensus_infos()` returns an empty validator set. This occurs when:

1. **All validators drop below minimum stake threshold** - Could happen during extreme market conditions or validator exits, but typically requires economic manipulation (out of scope per bug bounty rules)
2. **Staking logic bugs** - Separate vulnerabilities in stake calculation could create this scenario
3. **Edge case transitions** - Legitimate but rare scenarios during validator set reconfigurations
4. **Testnet/devnet operations** - Misconfigured parameters or deliberate testing scenarios

The vulnerability is more likely in test environments but possible in production under extreme edge cases. However, direct exploitation by an unprivileged attacker is difficult without first compromising the staking system through separate means.

## Recommendation

Add validation for empty validator sets at multiple layers:

**1. Move Layer Validation** (Most Effective):
Add check in `dkg.move::start()`: [8](#0-7) 

```move
public(friend) fun start(
    dealer_epoch: u64,
    randomness_config: RandomnessConfig,
    dealer_validator_set: vector<ValidatorConsensusInfo>,
    target_validator_set: vector<ValidatorConsensusInfo>,
) acquires DKGState {
    assert!(
        !vector::is_empty(&target_validator_set),
        error::invalid_argument(EEMPTY_VALIDATOR_SET)
    );
    // ... rest of function
}
```

**2. Rust Layer Guards** (Defense in Depth):
Add early validation in `DKGRoundingProfile::new()`: [9](#0-8) 

```rust
pub fn new(
    validator_stakes: &Vec<u64>,
    // ... other params
) -> anyhow::Result<Self> {
    ensure!(
        !validator_stakes.is_empty(),
        "validator_stakes cannot be empty"
    );
    ensure!(total_weight_min >= validator_stakes.len());
    // ... rest of function
}
```

**3. Fix Underflow** (Immediate Safety):
Use checked arithmetic in binary search: [10](#0-9) 

```rust
weight_high = weight_mid.saturating_sub(1);
```

## Proof of Concept

```rust
#[cfg(test)]
mod underflow_poc {
    use super::*;
    
    #[test]
    #[should_panic(expected = "validator_stakes cannot be empty")]
    fn test_empty_validator_set_crash() {
        let empty_stakes: Vec<u64> = vec![];
        let secrecy_threshold = U64F64::from_num(1) / U64F64::from_num(2);
        let reconstruct_threshold = U64F64::from_num(2) / U64F64::from_num(3);
        
        // This should panic with division by zero or underflow
        let _result = DKGRounding::new(
            &empty_stakes,
            secrecy_threshold,
            reconstruct_threshold,
            None,
        );
    }
    
    #[test]
    fn test_underflow_scenario() {
        // Demonstrate the underflow path
        let weight_mid: u64 = 0;
        let weight_high_before = 0u64;
        
        // This underflows to u64::MAX
        let weight_high_after = weight_mid.wrapping_sub(1);
        
        assert_eq!(weight_high_after, u64::MAX);
        assert!(weight_high_after > weight_high_before);
    }
}
```

## Notes

While the original security question focused on `weighted_config.rs`, the investigation revealed that file has proper underflow protections [11](#0-10) . However, the related DKG weight rounding subsystem contains the exploitable vulnerabilities described above.

The vulnerability's exploitability by unprivileged attackers is limited since it requires preconditions (empty validator set) that typically result from economic conditions or separate bugs rather than direct manipulation. This places it at the boundary of the bug bounty scope, but the technical vulnerability and potential for network disruption warrant reporting for defense-in-depth hardening.

### Citations

**File:** crates/aptos-crypto/src/weighted_config.rs (L74-76)
```rust
        if weights.is_empty() {
            return Err(anyhow!("expected a non-empty vector of player weights"));
        }
```

**File:** crates/aptos-crypto/src/weighted_config.rs (L356-359)
```rust
            if len > 1 {
                player_and_weights.swap(idx, len - 1);
                player_and_weights.pop();
            }
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1539-1556)
```text
            if (new_voting_power >= minimum_stake) {
                let config = *borrow_global<ValidatorConfig>(candidate.addr);
                config.validator_index = num_new_actives;
                let new_validator_info = ValidatorInfo {
                    addr: candidate.addr,
                    voting_power: new_voting_power,
                    config,
                };

                // Update ValidatorSet.
                spec {
                    assume new_total_power + new_voting_power <= MAX_U128;
                };
                new_total_power = new_total_power + (new_voting_power as u128);
                vector::push_back(&mut new_active_validators, new_validator_info);
                num_new_actives = num_new_actives + 1;

            };
```

**File:** aptos-move/framework/aptos-framework/sources/reconfiguration_with_dkg.move (L34-39)
```text
        dkg::start(
            cur_epoch,
            randomness_config::current(),
            stake::cur_validator_consensus_infos(),
            stake::next_validator_consensus_infos(),
        );
```

**File:** types/src/dkg/real_dkg/mod.rs (L112-117)
```rust
    } = DKGRounding::new(
        &validator_stakes,
        secrecy_threshold,
        reconstruct_threshold,
        maybe_fast_path_secrecy_threshold,
    );
```

**File:** types/src/dkg/real_dkg/rounding/mod.rs (L187-195)
```rust
    pub fn new(
        validator_stakes: &Vec<u64>,
        total_weight_min: usize,
        total_weight_max: usize,
        secrecy_threshold_in_stake_ratio: U64F64,
        reconstruct_threshold_in_stake_ratio: U64F64,
        fast_secrecy_threshold_in_stake_ratio: Option<U64F64>,
    ) -> anyhow::Result<Self> {
        ensure!(total_weight_min >= validator_stakes.len());
```

**File:** types/src/dkg/real_dkg/rounding/mod.rs (L201-208)
```rust
        let stake_total: u64 = validator_stakes.iter().sum();
        let mut weight_low = total_weight_min as u64;
        let mut weight_high = total_weight_max as u64;
        let mut best_profile = compute_profile_fixed_point(
            validator_stakes,
            max(
                U64F64::from_num(1),
                U64F64::from_num(stake_total) / U64F64::from_num(weight_low),
```

**File:** types/src/dkg/real_dkg/rounding/mod.rs (L219-239)
```rust
        while weight_low <= weight_high {
            let weight_mid = weight_low + (weight_high - weight_low) / 2;
            let stake_per_weight = max(
                U64F64::from_num(1),
                U64F64::from_num(stake_total) / U64F64::from_num(weight_mid),
            );
            let profile = compute_profile_fixed_point(
                validator_stakes,
                stake_per_weight,
                secrecy_threshold_in_stake_ratio,
                fast_secrecy_threshold_in_stake_ratio,
            );

            // Check if the current weight satisfies the conditions
            if is_valid_profile(&profile, reconstruct_threshold_in_stake_ratio) {
                best_profile = profile;
                weight_high = weight_mid - 1;
            } else {
                weight_low = weight_mid + 1;
            }
        }
```

**File:** types/src/dkg/real_dkg/rounding/mod.rs (L305-332)
```rust
    let stake_sum: u64 = validator_stakes.iter().sum::<u64>();
    let stake_sum_fixed = U64F64::from_num(stake_sum);
    let mut delta_down_fixed = U64F64::from_num(0);
    let mut delta_up_fixed = U64F64::from_num(0);
    let mut validator_weights: Vec<u64> = vec![];
    for stake in validator_stakes {
        let ideal_weight_fixed = U64F64::from_num(*stake) / stake_per_weight;
        // rounded to the nearest integer
        let rounded_weight_fixed = (ideal_weight_fixed + (one / 2)).floor();
        let rounded_weight = rounded_weight_fixed.to_num::<u64>();
        validator_weights.push(rounded_weight);
        if ideal_weight_fixed > rounded_weight_fixed {
            delta_down_fixed += ideal_weight_fixed - rounded_weight_fixed;
        } else {
            delta_up_fixed += rounded_weight_fixed - ideal_weight_fixed;
        }
    }
    let weight_total: u64 = validator_weights.clone().into_iter().sum();
    let delta_total_fixed = delta_down_fixed + delta_up_fixed;
    let reconstruct_threshold_in_weights_fixed =
        (secrecy_threshold_in_stake_ratio * stake_sum_fixed / stake_per_weight + delta_up_fixed)
            .ceil()
            + one;
    let reconstruct_threshold_in_weights: u64 = min(
        weight_total,
        reconstruct_threshold_in_weights_fixed.to_num::<u64>(),
    );
    let stake_gap_fixed = stake_per_weight * delta_total_fixed / stake_sum_fixed;
```

**File:** aptos-move/framework/aptos-framework/sources/dkg.move (L61-73)
```text
    public(friend) fun start(
        dealer_epoch: u64,
        randomness_config: RandomnessConfig,
        dealer_validator_set: vector<ValidatorConsensusInfo>,
        target_validator_set: vector<ValidatorConsensusInfo>,
    ) acquires DKGState {
        let dkg_state = borrow_global_mut<DKGState>(@aptos_framework);
        let new_session_metadata = DKGSessionMetadata {
            dealer_epoch,
            randomness_config,
            dealer_validator_set,
            target_validator_set,
        };
```
