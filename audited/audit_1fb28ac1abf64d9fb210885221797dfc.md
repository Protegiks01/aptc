# Audit Report

## Title
Sponsored Account Creation Fee Bypass via Self-Sponsorship with Zero Gas Price

## Summary
The `should_create_account_resource()` function allows attackers to create accounts without paying storage fees by setting themselves as both sender and fee_payer with `gas_unit_price = 0`. This bypasses the intended sponsored transaction security model where a separate sponsor pays for account creation.

## Finding Description

The vulnerability exists in the interaction between three components:

1. **Account Creation Logic** [1](#0-0) 

The `should_create_account_resource()` function checks if automatic account creation should occur. It validates:
- Feature flag `SPONSORED_AUTOMATIC_ACCOUNT_V1_CREATION` is enabled
- `txn_data.fee_payer.is_some()` (but does NOT verify fee_payer â‰  sender)
- Sequence number equals 0
- Account doesn't exist

2. **Gas Validation Bypass** [2](#0-1) 

The account creation fee validation is skipped when `gas_unit_price == 0` and `DEFAULT_ACCOUNT_RESOURCE` feature is enabled. Both feature flags are enabled by default [3](#0-2) [4](#0-3) .

3. **Prologue Check Behavior** [5](#0-4) 

When `sender_address == gas_payer_address`, the prologue requires the account to exist, causing the transaction to fail with `PROLOGUE_EACCOUNT_DOES_NOT_EXIST`.

4. **Failure Path Account Creation** [6](#0-5) 

In `finish_aborted_transaction()`, the account is created when `should_create_account_resource()` returns true, even though the original transaction failed.

5. **Zero-Fee Epilogue Success** [7](#0-6) 

With `gas_unit_price = 0`, the `transaction_fee_amount` is 0, allowing the balance check to pass even with a newly created account having 0 balance.

**Attack Execution:**
An attacker crafts a transaction where they are both sender and fee_payer, sets `gas_unit_price = 0` and `sequence_number = 0`. The prologue fails, but the failure path creates the account without charging fees because the epilogue succeeds with zero fee amount.

## Impact Explanation

**Medium Severity** - This vulnerability allows:
- **Limited Funds Manipulation**: Bypasses storage fee payment mechanism for account creation
- **State Inconsistency**: Creates accounts without proper fee deduction, violating the economic model
- **Spam Attack Vector**: Attackers can create unlimited accounts without paying storage fees, potentially bloating state storage

While this doesn't directly steal funds or break consensus, it circumvents the fee payment system designed to prevent state bloat and ensure economic sustainability. The impact is limited to account creation and doesn't affect existing account balances or critical protocol operations.

## Likelihood Explanation

**High Likelihood** - The attack requires:
- Default feature flag configuration (both flags enabled by default)
- Simple transaction construction (sender == fee_payer, gas_unit_price = 0)
- No special privileges or validator access
- Publicly documented transaction format

The attack is trivial to execute and repeatable, making it highly likely if discovered by malicious actors.

## Recommendation

Add a validation check in `should_create_account_resource()` to prevent self-sponsorship:

```rust
pub(crate) fn should_create_account_resource(
    txn_data: &TransactionMetadata,
    features: &Features,
    resolver: &impl AptosMoveResolver,
    module_storage: &impl ModuleStorage,
) -> VMResult<bool> {
    if (features.is_enabled(FeatureFlag::DEFAULT_ACCOUNT_RESOURCE)
        || (features.is_enabled(FeatureFlag::SPONSORED_AUTOMATIC_ACCOUNT_V1_CREATION)
            && txn_data.fee_payer.is_some()
            // ADD THIS CHECK: Prevent self-sponsorship
            && txn_data.fee_payer != Some(txn_data.sender)))
        && txn_data.replay_protector == ReplayProtector::SequenceNumber(0)
    {
        // ... rest of function
    }
    Ok(false)
}
```

This ensures sponsored account creation only works when a different account (the actual sponsor) pays for the new account creation.

## Proof of Concept

```rust
// Test case to reproduce the vulnerability
#[test]
fn test_self_sponsored_account_creation_bypass() {
    // Setup: Enable both required feature flags
    let mut features = Features::default();
    
    // Create transaction where sender == fee_payer with gas_unit_price = 0
    let sender = AccountAddress::from_hex_literal("0xDEADBEEF").unwrap();
    
    let txn = SignedTransaction::new(
        RawTransaction::new(
            sender, // sender
            0,      // sequence_number = 0
            TransactionPayload::EntryFunction(/* some payload */),
            1000,   // max_gas_amount
            0,      // gas_unit_price = 0 !!!
            0,      // expiration
            ChainId::test(),
        ),
        // Authenticator with fee_payer = sender (self-sponsorship)
        TransactionAuthenticator::fee_payer(
            AccountAuthenticator::ed25519(/* sender auth */),
            vec![],  // no secondary signers
            vec![],
            sender,  // fee_payer == sender !!!
            AccountAuthenticator::ed25519(/* fee_payer auth */),
        ),
    );
    
    // Expected: Account should NOT be created without paying fees
    // Actual: Account IS created with 0 balance, bypassing fee payment
    let output = execute_transaction(txn, &state_view);
    
    // Verify account was created despite paying no fees
    assert!(state_view.get_account_resource(sender).is_some());
    assert_eq!(state_view.get_balance(sender), 0); // 0 balance!
}
```

**Notes:**
- The vulnerability exploits the combination of `SPONSORED_AUTOMATIC_ACCOUNT_V1_CREATION` allowing self-sponsorship and `DEFAULT_ACCOUNT_RESOURCE` disabling fee validation at zero gas price
- The missing validation `fee_payer != sender` in [8](#0-7)  is the root cause
- Both required feature flags are enabled in the default production configuration [9](#0-8)

### Citations

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L705-739)
```rust
        let should_create_account_resource =
            should_create_account_resource(txn_data, self.features(), resolver, module_storage)?;

        let (previous_session_change_set, fee_statement) = if should_create_account_resource {
            let mut abort_hook_session =
                AbortHookSession::new(self, txn_data, resolver, prologue_session_change_set);

            abort_hook_session.execute(|session| {
                create_account_if_does_not_exist(
                    session,
                    module_storage,
                    gas_meter,
                    txn_data.sender(),
                    traversal_context,
                )
                // If this fails, it is likely due to out of gas, so we try again without metering
                // and then validate below that we charged sufficiently.
                .or_else(|_err| {
                    create_account_if_does_not_exist(
                        session,
                        module_storage,
                        &mut UnmeteredGasMeter,
                        txn_data.sender(),
                        traversal_context,
                    )
                })
                .map_err(expect_no_verification_errors)
                .or_else(|err| {
                    expect_only_successful_execution(
                        err,
                        &format!("{:?}::{}", ACCOUNT_MODULE, CREATE_ACCOUNT_IF_DOES_NOT_EXIST),
                        log_context,
                    )
                })
            })?;
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L3451-3484)
```rust
pub(crate) fn should_create_account_resource(
    txn_data: &TransactionMetadata,
    features: &Features,
    resolver: &impl AptosMoveResolver,
    module_storage: &impl ModuleStorage,
) -> VMResult<bool> {
    if (features.is_enabled(FeatureFlag::DEFAULT_ACCOUNT_RESOURCE)
        || (features.is_enabled(FeatureFlag::SPONSORED_AUTOMATIC_ACCOUNT_V1_CREATION)
            && txn_data.fee_payer.is_some()))
        && txn_data.replay_protector == ReplayProtector::SequenceNumber(0)
    {
        let account_tag = AccountResource::struct_tag();

        // INVARIANT:
        //   Account lives at a special address, so we should not be charging for it and unmetered
        //   access is safe. There are tests that ensure that address is always special.
        assert!(account_tag.address.is_special());
        let module = module_storage.unmetered_get_existing_deserialized_module(
            &account_tag.address,
            &account_tag.module,
        )?;

        let (maybe_bytes, _) = resolver
            .get_resource_bytes_with_metadata_and_layout(
                &txn_data.sender(),
                &account_tag,
                &module.metadata,
                None,
            )
            .map_err(|e| e.finish(Location::Undefined))?;
        return Ok(maybe_bytes.is_none());
    }
    Ok(false)
}
```

**File:** aptos-move/aptos-vm/src/gas.rs (L214-246)
```rust
    if crate::aptos_vm::should_create_account_resource(
        txn_metadata,
        features,
        resolver,
        module_storage,
    )? && (gas_unit_price != 0 || !features.is_default_account_resource_enabled())
    {
        let max_gas_amount: u64 = txn_metadata.max_gas_amount().into();
        let pricing = DiskSpacePricing::new(gas_feature_version, features);
        let storage_fee_per_account_create: u64 = pricing
            .hack_estimated_fee_for_account_creation(txn_gas_params)
            .into();

        let expected = gas_unit_price * 10
            + if features.is_new_account_default_to_fa_store() {
                1
            } else {
                2
            } * storage_fee_per_account_create;
        let actual = gas_unit_price * max_gas_amount;
        if actual < expected {
            speculative_warn!(
                log_context,
                format!(
                    "[VM] Insufficient gas for account creation; min {}, submitted {}",
                    expected, actual,
                ),
            );
            return Err(VMStatus::error(
                StatusCode::MAX_GAS_UNITS_BELOW_MIN_TRANSACTION_GAS_UNITS,
                None,
            ));
        }
```

**File:** types/src/on_chain_config/aptos_features.rs (L171-277)
```rust
    pub fn default_features() -> Vec<Self> {
        vec![
            FeatureFlag::CODE_DEPENDENCY_CHECK,
            FeatureFlag::TREAT_FRIEND_AS_PRIVATE,
            FeatureFlag::SHA_512_AND_RIPEMD_160_NATIVES,
            FeatureFlag::APTOS_STD_CHAIN_ID_NATIVES,
            // Feature flag V6 is used to enable metadata v1 format and needs to stay on, even
            // if we enable a higher version.
            FeatureFlag::VM_BINARY_FORMAT_V6,
            FeatureFlag::VM_BINARY_FORMAT_V7,
            FeatureFlag::MULTI_ED25519_PK_VALIDATE_V2_NATIVES,
            FeatureFlag::BLAKE2B_256_NATIVE,
            FeatureFlag::RESOURCE_GROUPS,
            FeatureFlag::MULTISIG_ACCOUNTS,
            FeatureFlag::DELEGATION_POOLS,
            FeatureFlag::CRYPTOGRAPHY_ALGEBRA_NATIVES,
            FeatureFlag::BLS12_381_STRUCTURES,
            FeatureFlag::ED25519_PUBKEY_VALIDATE_RETURN_FALSE_WRONG_LENGTH,
            FeatureFlag::STRUCT_CONSTRUCTORS,
            FeatureFlag::PERIODICAL_REWARD_RATE_DECREASE,
            FeatureFlag::PARTIAL_GOVERNANCE_VOTING,
            FeatureFlag::_SIGNATURE_CHECKER_V2,
            FeatureFlag::STORAGE_SLOT_METADATA,
            FeatureFlag::CHARGE_INVARIANT_VIOLATION,
            FeatureFlag::DELEGATION_POOL_PARTIAL_GOVERNANCE_VOTING,
            FeatureFlag::APTOS_UNIQUE_IDENTIFIERS,
            FeatureFlag::GAS_PAYER_ENABLED,
            FeatureFlag::BULLETPROOFS_NATIVES,
            FeatureFlag::SIGNER_NATIVE_FORMAT_FIX,
            FeatureFlag::MODULE_EVENT,
            FeatureFlag::EMIT_FEE_STATEMENT,
            FeatureFlag::STORAGE_DELETION_REFUND,
            FeatureFlag::SIGNATURE_CHECKER_V2_SCRIPT_FIX,
            FeatureFlag::AGGREGATOR_V2_API,
            FeatureFlag::SAFER_RESOURCE_GROUPS,
            FeatureFlag::SAFER_METADATA,
            FeatureFlag::SINGLE_SENDER_AUTHENTICATOR,
            FeatureFlag::SPONSORED_AUTOMATIC_ACCOUNT_V1_CREATION,
            FeatureFlag::FEE_PAYER_ACCOUNT_OPTIONAL,
            FeatureFlag::AGGREGATOR_V2_DELAYED_FIELDS,
            FeatureFlag::CONCURRENT_TOKEN_V2,
            FeatureFlag::LIMIT_MAX_IDENTIFIER_LENGTH,
            FeatureFlag::OPERATOR_BENEFICIARY_CHANGE,
            FeatureFlag::BN254_STRUCTURES,
            FeatureFlag::RESOURCE_GROUPS_SPLIT_IN_VM_CHANGE_SET,
            FeatureFlag::COMMISSION_CHANGE_DELEGATION_POOL,
            FeatureFlag::WEBAUTHN_SIGNATURE,
            FeatureFlag::KEYLESS_ACCOUNTS,
            FeatureFlag::FEDERATED_KEYLESS,
            FeatureFlag::KEYLESS_BUT_ZKLESS_ACCOUNTS,
            FeatureFlag::JWK_CONSENSUS,
            FeatureFlag::REFUNDABLE_BYTES,
            FeatureFlag::OBJECT_CODE_DEPLOYMENT,
            FeatureFlag::MAX_OBJECT_NESTING_CHECK,
            FeatureFlag::KEYLESS_ACCOUNTS_WITH_PASSKEYS,
            FeatureFlag::MULTISIG_V2_ENHANCEMENT,
            FeatureFlag::DELEGATION_POOL_ALLOWLISTING,
            FeatureFlag::MODULE_EVENT_MIGRATION,
            FeatureFlag::_REJECT_UNSTABLE_BYTECODE,
            FeatureFlag::TRANSACTION_CONTEXT_EXTENSION,
            FeatureFlag::COIN_TO_FUNGIBLE_ASSET_MIGRATION,
            FeatureFlag::_OBJECT_NATIVE_DERIVED_ADDRESS,
            FeatureFlag::DISPATCHABLE_FUNGIBLE_ASSET,
            FeatureFlag::NEW_ACCOUNTS_DEFAULT_TO_FA_APT_STORE,
            FeatureFlag::OPERATIONS_DEFAULT_TO_FA_APT_STORE,
            FeatureFlag::CONCURRENT_FUNGIBLE_ASSETS,
            FeatureFlag::_AGGREGATOR_V2_IS_AT_LEAST_API,
            FeatureFlag::CONCURRENT_FUNGIBLE_BALANCE,
            FeatureFlag::_LIMIT_VM_TYPE_SIZE,
            FeatureFlag::ABORT_IF_MULTISIG_PAYLOAD_MISMATCH,
            FeatureFlag::_DISALLOW_USER_NATIVES,
            FeatureFlag::ALLOW_SERIALIZED_SCRIPT_ARGS,
            FeatureFlag::_USE_COMPATIBILITY_CHECKER_V2,
            FeatureFlag::ENABLE_ENUM_TYPES,
            FeatureFlag::ENABLE_RESOURCE_ACCESS_CONTROL,
            FeatureFlag::_REJECT_UNSTABLE_BYTECODE_FOR_SCRIPT,
            FeatureFlag::TRANSACTION_SIMULATION_ENHANCEMENT,
            FeatureFlag::_NATIVE_MEMORY_OPERATIONS,
            FeatureFlag::_ENABLE_LOADER_V2,
            FeatureFlag::_DISALLOW_INIT_MODULE_TO_PUBLISH_MODULES,
            FeatureFlag::COLLECTION_OWNER,
            FeatureFlag::PERMISSIONED_SIGNER,
            FeatureFlag::ENABLE_CALL_TREE_AND_INSTRUCTION_VM_CACHE,
            FeatureFlag::ACCOUNT_ABSTRACTION,
            FeatureFlag::BULLETPROOFS_BATCH_NATIVES,
            FeatureFlag::DERIVABLE_ACCOUNT_ABSTRACTION,
            FeatureFlag::VM_BINARY_FORMAT_V8,
            FeatureFlag::ENABLE_FUNCTION_VALUES,
            FeatureFlag::NEW_ACCOUNTS_DEFAULT_TO_FA_STORE,
            FeatureFlag::DEFAULT_ACCOUNT_RESOURCE,
            FeatureFlag::JWK_CONSENSUS_PER_KEY_MODE,
            FeatureFlag::TRANSACTION_PAYLOAD_V2,
            FeatureFlag::ORDERLESS_TRANSACTIONS,
            FeatureFlag::CALCULATE_TRANSACTION_FEE_FOR_DISTRIBUTION,
            FeatureFlag::DISTRIBUTE_TRANSACTION_FEE,
            FeatureFlag::ENABLE_LAZY_LOADING,
            FeatureFlag::MONOTONICALLY_INCREASING_COUNTER,
            FeatureFlag::ENABLE_CAPTURE_OPTION,
            FeatureFlag::ENABLE_TRUSTED_CODE,
            FeatureFlag::ENABLE_ENUM_OPTION,
            FeatureFlag::VM_BINARY_FORMAT_V9,
            FeatureFlag::ENABLE_FRAMEWORK_FOR_OPTION,
            FeatureFlag::ENABLE_FUNCTION_REFLECTION,
            FeatureFlag::VM_BINARY_FORMAT_V10,
            FeatureFlag::SLH_DSA_SHA2_128S_SIGNATURE,
        ]
    }
```

**File:** aptos-move/framework/aptos-framework/sources/transaction_validation.move (L220-226)
```text
        if (
            sender_address == gas_payer_address
                || account::exists_at(sender_address)
                || !features::sponsored_automatic_account_creation_enabled()
                || txn_sequence_number > 0
        ) {
            assert!(account::exists_at(sender_address), error::invalid_argument(PROLOGUE_EACCOUNT_DOES_NOT_EXIST));
```

**File:** aptos-move/framework/aptos-framework/sources/transaction_validation.move (L812-838)
```text
        assert!(txn_max_gas_units >= gas_units_remaining, error::invalid_argument(EOUT_OF_GAS));
        let gas_used = txn_max_gas_units - gas_units_remaining;

        assert!(
            (txn_gas_price as u128) * (gas_used as u128) <= MAX_U64,
            error::out_of_range(EOUT_OF_GAS)
        );
        let transaction_fee_amount = txn_gas_price * gas_used;

        let gas_payer_address = signer::address_of(&gas_payer);
        // it's important to maintain the error code consistent with vm
        // to do failed transaction cleanup.
        if (!skip_gas_payment(
            is_simulation,
            gas_payer_address
        )) {
            if (features::operations_default_to_fa_apt_store_enabled()) {
                assert!(
                    aptos_account::is_fungible_balance_at_least(gas_payer_address, transaction_fee_amount),
                    error::out_of_range(PROLOGUE_ECANT_PAY_GAS_DEPOSIT),
                );
            } else {
                assert!(
                    coin::is_balance_at_least<AptosCoin>(gas_payer_address, transaction_fee_amount),
                    error::out_of_range(PROLOGUE_ECANT_PAY_GAS_DEPOSIT),
                );
            };
```
