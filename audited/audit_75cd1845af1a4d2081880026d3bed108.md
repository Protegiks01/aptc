# Audit Report

## Title
Remote Sharding Missing Total Supply Aggregation Causes Consensus Divergence

## Summary
The remote sharded block executor fails to aggregate total supply values after parallel execution, causing validators using remote sharding to compute different state roots than validators using local sharding for identical blocks, leading to consensus divergence.

## Finding Description

The sharded block executor system uses `AggregatorOverriddenStateView` to override total supply reads with a base value (`TOTAL_SUPPLY_AGGR_BASE_VAL = u128::MAX >> 1`) during parallel execution across shards. [1](#0-0)  After execution completes, the total supply deltas from all shards must be aggregated and used to update transaction outputs with correct values.

**The Critical Bug:**

`LocalExecutorClient::execute_block()` correctly calls `aggregate_and_update_total_supply()` to fix total supply values after parallel execution: [2](#0-1) 

However, `RemoteExecutorClient::execute_block()` completely omits this aggregation step: [3](#0-2) 

The TODO comment explicitly acknowledges this is incomplete: [4](#0-3) 

**Execution Flow:**

The decision between local and remote sharding occurs per-node based on configuration: [5](#0-4) 

This is called during block execution in consensus: [6](#0-5) 

**Consensus Divergence:**

When nodes use different execution modes:
1. Node A (remote sharding) returns transaction outputs with total supply = `TOTAL_SUPPLY_AGGR_BASE_VAL ± delta` (≈ 1.7 × 10³⁸)
2. Node B (local sharding) returns transaction outputs with total supply = `real_supply ± delta` (≈ 10⁹)
3. Different write sets → different Merkle tree hashes → different state roots
4. Validators cannot reach consensus on the block

This breaks **Invariant #1: Deterministic Execution** - validators must produce identical state roots for identical blocks.

## Impact Explanation

**Severity: Critical** (Consensus/Safety Violation - up to $1,000,000)

This vulnerability causes:
- **Consensus safety violation**: Validators compute different state roots for the same block
- **Network partition**: Validators split into incompatible factions based on execution mode
- **Chain halt**: Consensus cannot be reached when >1/3 validators use different execution modes
- **Requires hardfork**: Recovery requires coordinated validator configuration changes

The total supply value is included in write sets [7](#0-6)  and affects state root computation. The magnitude of error (≈10³⁸ vs ≈10⁹) guarantees detection but also guarantees consensus failure.

## Likelihood Explanation

**Likelihood: Medium-to-High** if remote sharding is enabled

The vulnerability triggers automatically when:
1. Any validator enables remote sharding by configuring `remote_executor_addresses` [8](#0-7) 
2. Any block containing total supply modifications is executed
3. No attacker action required - this is a determinism bug

Currently, remote sharding appears experimental (primarily in executor-benchmark). However, if deployed without fixing this bug, consensus immediately fails. The TODO indicates developers are aware the implementation is incomplete for remote sharding.

## Recommendation

Add total supply aggregation to `RemoteExecutorClient::execute_block()`:

**File:** `execution/executor-service/src/remote_executor_client.rs`

Modify the `execute_block` method to include aggregation before returning results:

```rust
fn execute_block(
    &self,
    state_view: Arc<S>,
    transactions: PartitionedTransactions,
    concurrency_level_per_shard: usize,
    onchain_config: BlockExecutorConfigFromOnchain,
) -> Result<ShardedExecutionOutput, VMStatus> {
    // ... existing code to send to shards ...
    
    let mut execution_results = self.get_output_from_shards()?;
    
    // FIX: Add total supply aggregation for remote sharding
    let mut global_output = vec![];
    sharded_aggregator_service::aggregate_and_update_total_supply(
        &mut execution_results,
        &mut global_output,
        state_view.as_ref(),
        self.thread_pool.clone(),
    );
    
    self.state_view_service.drop_state_view();
    Ok(ShardedExecutionOutput::new(execution_results, global_output))
}
```

Alternatively, move aggregation logic into `ShardedBlockExecutor::execute_block()` so it applies uniformly to both local and remote execution modes.

## Proof of Concept

**Rust Reproduction Steps:**

1. Create two executor instances:
```rust
// Local sharding executor
let local_executor = LocalExecutorClient::create_local_sharded_block_executor(4, None);

// Remote sharding executor  
let remote_executor = RemoteExecutorClient::create_remote_sharded_block_executor(
    coordinator_addr, 
    vec![shard1_addr, shard2_addr, shard3_addr, shard4_addr],
    None
);
```

2. Prepare identical block with total supply modifications:
```rust
let transactions = vec![
    // Transaction that modifies fungible asset total supply
    create_mint_transaction(100_000_000), // Mints 100M tokens
];
let partitioned = partition_transactions(transactions, 4);
```

3. Execute through both paths:
```rust
let local_outputs = local_executor.execute_block(
    state_view.clone(), 
    partitioned.clone(),
    8,
    onchain_config.clone()
)?;

let remote_outputs = remote_executor.execute_block(
    state_view.clone(),
    partitioned.clone(), 
    8,
    onchain_config.clone()
)?;
```

4. Compare total supply values:
```rust
let local_supply = local_outputs[0].write_set().get_total_supply().unwrap();
let remote_supply = remote_outputs[0].write_set().get_total_supply().unwrap();

assert_ne!(local_supply, remote_supply); // FAILS - different values
// local_supply ≈ 1_000_000_000 (1B coins)
// remote_supply ≈ 170_141_183_460_469_231_731_687_303_715_884_105_727 (AGGR_BASE_VAL)
```

5. Compute state roots:
```rust
let local_root = compute_state_root(&local_outputs);
let remote_root = compute_state_root(&remote_outputs);

assert_eq!(local_root, remote_root); // FAILS - consensus divergence
```

This demonstrates that identical blocks produce different state roots based on executor configuration, violating deterministic execution guarantees required for consensus safety.

**Notes**

The vulnerability is in production code paths used by `BlockExecutor` [6](#0-5)  and affects any block execution scenario including consensus, state sync, and recovery. While remote sharding may currently be experimental, the bug exists in mainline code and would cause immediate consensus failure if deployed. The TODO comment indicates this is known as incomplete but has not been addressed as a security vulnerability requiring immediate fixing before remote sharding can be safely enabled.

### Citations

**File:** aptos-move/aptos-vm/src/sharded_block_executor/aggr_overridden_state_view.rs (L14-14)
```rust
pub const TOTAL_SUPPLY_AGGR_BASE_VAL: u128 = u128::MAX >> 1;
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/aggr_overridden_state_view.rs (L43-45)
```rust
            // TODO: Remove this when we have aggregated total supply implementation for remote
            //       sharding. For now we need this because after all the txns are executed, the
            //       proof checker expects the total_supply to read/written to the tree.
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/local_executor_shard.rs (L215-220)
```rust
        sharded_aggregator_service::aggregate_and_update_total_supply(
            &mut sharded_output,
            &mut global_output,
            state_view.as_ref(),
            self.global_executor.get_executor_thread_pool(),
        );
```

**File:** execution/executor-service/src/remote_executor_client.rs (L180-212)
```rust
    fn execute_block(
        &self,
        state_view: Arc<S>,
        transactions: PartitionedTransactions,
        concurrency_level_per_shard: usize,
        onchain_config: BlockExecutorConfigFromOnchain,
    ) -> Result<ShardedExecutionOutput, VMStatus> {
        trace!("RemoteExecutorClient Sending block to shards");
        self.state_view_service.set_state_view(state_view);
        let (sub_blocks, global_txns) = transactions.into();
        if !global_txns.is_empty() {
            panic!("Global transactions are not supported yet");
        }
        for (shard_id, sub_blocks) in sub_blocks.into_iter().enumerate() {
            let senders = self.command_txs.clone();
            let execution_request = RemoteExecutionRequest::ExecuteBlock(ExecuteBlockCommand {
                sub_blocks,
                concurrency_level: concurrency_level_per_shard,
                onchain_config: onchain_config.clone(),
            });

            senders[shard_id]
                .lock()
                .unwrap()
                .send(Message::new(bcs::to_bytes(&execution_request).unwrap()))
                .unwrap();
        }

        let execution_results = self.get_output_from_shards()?;

        self.state_view_service.drop_state_view();
        Ok(ShardedExecutionOutput::new(execution_results, vec![]))
    }
```

**File:** execution/executor/src/workflow/do_get_execution_output.rs (L261-275)
```rust
        if !get_remote_addresses().is_empty() {
            Ok(V::execute_block_sharded(
                &REMOTE_SHARDED_BLOCK_EXECUTOR.lock(),
                partitioned_txns,
                state_view,
                onchain_config,
            )?)
        } else {
            Ok(V::execute_block_sharded(
                &SHARDED_BLOCK_EXECUTOR.lock(),
                partitioned_txns,
                state_view,
                onchain_config,
            )?)
        }
```

**File:** execution/executor/src/block_executor/mod.rs (L242-250)
```rust
                DoGetExecutionOutput::by_transaction_execution(
                    &self.block_executor,
                    transactions,
                    auxiliary_info,
                    parent_output.result_state(),
                    state_view,
                    onchain_config.clone(),
                    TransactionSliceMetadata::block(parent_block_id, block_id),
                )?
```

**File:** types/src/write_set.rs (L717-739)
```rust
    fn get_total_supply(&self) -> Option<u128> {
        let value = self
            .0
            .get(&TOTAL_SUPPLY_STATE_KEY)
            .and_then(|op| op.bytes())
            .map(|bytes| bcs::from_bytes::<u128>(bytes));
        value.transpose().map_err(anyhow::Error::msg).unwrap()
    }

    // This is a temporary method to update the total supply in the write set.
    // TODO: get rid of this func() and use WriteSetMut instead; for that we need to change
    //       VM execution such that to 'TransactionOutput' is materialized after updating
    //       total_supply.
    fn update_total_supply(&mut self, value: u128) {
        assert!(self
            .0
            .write_set
            .insert(
                TOTAL_SUPPLY_STATE_KEY.clone(),
                WriteOp::legacy_modification(bcs::to_bytes(&value).unwrap().into())
            )
            .is_some());
    }
```

**File:** execution/executor-benchmark/src/main.rs (L632-648)
```rust
        remote_executor_client::set_remote_addresses(
            opt.pipeline_opt
                .sharding_opt
                .remote_executor_addresses
                .clone()
                .unwrap(),
        );
        assert_eq!(
            execution_shards,
            remote_executor_client::get_remote_addresses().len(),
            "Number of execution shards ({}) must be equal to the number of remote addresses ({}).",
            execution_shards,
            remote_executor_client::get_remote_addresses().len()
        );
        remote_executor_client::set_coordinator_address(
            opt.pipeline_opt.sharding_opt.coordinator_address.unwrap(),
        );
```
