# Audit Report

## Title
Non-Monotonic Clock Usage in Batch Expiration Validation Enables Clock Skew-Based Consensus Disruption

## Summary
The `SignedBatchInfo::verify()` function uses `duration_since_epoch()`, which relies on non-monotonic `SystemTime`, to validate batch expiration times. This creates a time-of-check-time-of-use (TOCTOU) vulnerability where validators with clock skew can disagree on batch validity, potentially causing consensus liveness failures.

## Finding Description

The core issue lies in the use of `duration_since_epoch()` for time-sensitive consensus validation: [1](#0-0) 

This function uses `SystemTime::now()`, which the codebase explicitly documents as non-monotonic: [2](#0-1) 

In `SignedBatchInfo::verify()`, this non-monotonic time source is used to check if batch expirations are too far in the future: [3](#0-2) 

The problem manifests when validators have clock skew:

**Attack Scenario:**
1. Validator V1's clock is 90 seconds ahead of real time (due to NTP misconfiguration or manipulation)
2. V1 creates a batch with `expiration = V1_time + 60s`
3. V1's check passes: `expiration ≤ V1_time + 60s` ✓
4. Validator V2 (with correct time) receives the batch
5. From V2's perspective: `expiration = V2_time + 150s` (90s clock skew + 60s delta)
6. V2's check: `(V2_time + 150s) > V2_time + 60s` → **REJECTED**

The batch expiration gap is configured to only 60 seconds: [4](#0-3) 

This tight tolerance means even moderate clock skew (>60 seconds) causes validators to reject each other's batches. The same issue affects block timestamp validation, though with a larger 5-minute tolerance: [5](#0-4) 

**Invariant Violation:** This breaks **Consensus Safety** invariant #2: "AptosBFT must prevent chain splits under < 1/3 Byzantine." While not causing direct chain splits, if >1/3 of validators have clock skew exceeding the tolerance, the network cannot reach consensus on batch inclusion, effectively halting progress.

## Impact Explanation

**Severity: High** (per "Validator node slowdowns" and "Significant protocol violations")

The impact depends on the distribution of clock skew:

- **Scenario A** (>33% validators with >60s skew): Network cannot certify batches (2f+1 signatures required), causing complete liveness failure for quorum store
- **Scenario B** (10-33% validators with skew): Reduced throughput, affected validators cannot participate in batch certification
- **Scenario C** (Malicious exploitation): An attacker with root access to a validator node could intentionally desynchronize clocks to disrupt specific batches or cause targeted denial-of-service

The vulnerability enables time-based attacks that don't require Byzantine behavior in consensus voting, only control over system clocks.

## Likelihood Explanation

**Likelihood: Medium**

While the vulnerability exists in production code, exploitation requires:

1. **Natural occurrence**: NTP failures, misconfigurations, or clock drift >60 seconds (uncommon but documented in production systems)
2. **Malicious exploitation**: Root/administrator access to validator nodes to manipulate system clocks

The 60-second batch tolerance is significantly tighter than the industry-standard 5-minute block tolerance, making this more sensitive to real-world clock variations. Large cloud providers have documented NTP failures causing 100+ second time jumps.

However, this primarily affects validators with existing operational issues (poor time sync) rather than being directly exploitable by external attackers without validator access.

## Recommendation

**Solution 1: Use Monotonic Timestamps from Last Certified Block**

Replace system time checks with validation against the most recent certified block's timestamp:

```rust
pub fn verify(
    &self,
    sender: PeerId,
    max_batch_expiry_gap_usecs: u64,
    last_committed_timestamp_usecs: u64,  // Add parameter
    validator: &ValidatorVerifier,
) -> anyhow::Result<()> {
    if sender != self.signer {
        bail!("Sender {} mismatch signer {}", sender, self.signer);
    }

    // Validate against consensus-agreed time instead of local system time
    if self.expiration() > last_committed_timestamp_usecs + max_batch_expiry_gap_usecs {
        bail!(
            "Batch expiration too far in future: {} > {}",
            self.expiration(),
            last_committed_timestamp_usecs + max_batch_expiry_gap_usecs
        );
    }

    Ok(validator.optimistic_verify(self.signer, &self.info, &self.signature)?)
}
```

**Solution 2: Increase Batch Expiry Gap Tolerance**

Increase `batch_expiry_gap_when_init_usecs` from 60 seconds to 300 seconds (matching block TIMEBOUND) to reduce sensitivity to moderate clock skew:

```rust
batch_expiry_gap_when_init_usecs: Duration::from_secs(300).as_micros() as u64,
```

**Solution 3: Add Explicit Clock Synchronization Requirement**

Document and enforce NTP requirements in validator setup, with automated health checks that alert when clock skew exceeds thresholds.

## Proof of Concept

```rust
// Rust test demonstrating the clock skew vulnerability
#[cfg(test)]
mod clock_skew_test {
    use super::*;
    use aptos_types::validator_signer::ValidatorSigner;
    use std::time::{Duration, SystemTime, UNIX_EPOCH};
    
    #[test]
    fn test_batch_validation_with_clock_skew() {
        // Setup: Create a batch on validator with fast clock
        let signer = ValidatorSigner::random(None);
        
        // Simulate validator with clock 90 seconds ahead
        let fast_time = SystemTime::now().duration_since(UNIX_EPOCH).unwrap()
            + Duration::from_secs(90);
        let expiration = fast_time.as_micros() as u64 + 60_000_000; // +60s
        
        let batch_info = BatchInfo::new(
            signer.author(),
            BatchId::new(0),
            1, // epoch
            expiration,
            HashValue::zero(),
            100, // num_txns
            1024, // num_bytes
            0, // gas_bucket_start
        );
        
        let signed_batch = SignedBatchInfo::new(batch_info, &signer).unwrap();
        
        // Validator with correct clock receives batch
        // This will fail because expiration appears 90s too far in future
        let validator_verifier = ValidatorVerifier::new(vec![(signer.author(), signer.public_key())]);
        let result = signed_batch.verify(
            signer.author(),
            60_000_000, // max_batch_expiry_gap_usecs = 60s
            &validator_verifier,
        );
        
        // Demonstrates that batch is rejected due to clock skew
        assert!(result.is_err());
        assert!(result.unwrap_err().to_string().contains("too far in future"));
    }
}
```

## Notes

This vulnerability represents a fundamental tension between using wall-clock time for user-facing timestamps and the need for deterministic, consensus-safe time in distributed systems. The Aptos codebase is aware that `now_unix_time()` is non-monotonic (explicitly documented), yet uses it for consensus-critical validation. While validators are implicitly expected to maintain synchronized clocks, the lack of explicit enforcement or mitigation creates operational fragility. This is particularly concerning given the tight 60-second batch tolerance compared to the 5-minute block tolerance.

### Citations

**File:** crates/aptos-infallible/src/time.rs (L9-13)
```rust
pub fn duration_since_epoch() -> Duration {
    SystemTime::now()
        .duration_since(SystemTime::UNIX_EPOCH)
        .expect("System time is before the UNIX_EPOCH")
}
```

**File:** crates/aptos-time-service/src/lib.rs (L127-154)
```rust
    /// Query the current unix timestamp as a [`Duration`].
    ///
    /// When used on a `TimeService::real()`, this is equivalent to
    /// `SystemTime::now().duration_since(SystemTime::UNIX_EPOCH)`.
    ///
    /// Note: the [`Duration`] returned from this function is _NOT_ guaranteed to
    /// be monotonic. Use [`now`](#method.now) if you need monotonicity.
    ///
    /// From the [`SystemTime`] docs:
    ///
    /// > Distinct from the [`Instant`] type, this time measurement is
    /// > not monotonic. This means that you can save a file to the file system,
    /// > then save another file to the file system, and the second file has a
    /// > [`SystemTime`] measurement earlier than the first. In other words, an
    /// > operation that happens after another operation in real time may have
    /// > an earlier SystemTime!
    ///
    /// For example, the system administrator could [`clock_settime`] into the
    /// past, breaking clock time monotonicity.
    ///
    /// On Linux, this is equivalent to
    /// [`clock_gettime(CLOCK_REALTIME, _)`](https://linux.die.net/man/3/clock_gettime).
    ///
    /// [`Duration`]: std::time::Duration
    /// [`Instant`]: std::time::Instant
    /// [`SystemTime`]: std::time::SystemTime
    /// [`clock_settime`]: https://linux.die.net/man/3/clock_settime
    fn now_unix_time(&self) -> Duration;
```

**File:** consensus/consensus-types/src/proof_of_store.rs (L459-482)
```rust
    pub fn verify(
        &self,
        sender: PeerId,
        max_batch_expiry_gap_usecs: u64,
        validator: &ValidatorVerifier,
    ) -> anyhow::Result<()> {
        if sender != self.signer {
            bail!("Sender {} mismatch signer {}", sender, self.signer);
        }

        if self.expiration()
            > aptos_infallible::duration_since_epoch().as_micros() as u64
                + max_batch_expiry_gap_usecs
        {
            bail!(
                "Batch expiration too far in future: {} > {}",
                self.expiration(),
                aptos_infallible::duration_since_epoch().as_micros() as u64
                    + max_batch_expiry_gap_usecs
            );
        }

        Ok(validator.optimistic_verify(self.signer, &self.info, &self.signature)?)
    }
```

**File:** config/src/config/quorum_store_config.rs (L131-132)
```rust
            batch_expiry_gap_when_init_usecs: Duration::from_secs(60).as_micros() as u64,
            remote_batch_expiry_gap_when_init_usecs: Duration::from_millis(500).as_micros() as u64,
```

**File:** consensus/consensus-types/src/block.rs (L526-540)
```rust
        } else {
            ensure!(
                self.timestamp_usecs() > parent.timestamp_usecs(),
                "Blocks must have strictly increasing timestamps"
            );

            let current_ts = duration_since_epoch();

            // we can say that too far is 5 minutes in the future
            const TIMEBOUND: u64 = 300_000_000;
            ensure!(
                self.timestamp_usecs() <= (current_ts.as_micros() as u64).saturating_add(TIMEBOUND),
                "Blocks must not be too far in the future"
            );
        }
```
