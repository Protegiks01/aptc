# Audit Report

## Title
Unverified Epoch in Consensus Observer Sync Target Enables State Sync Disruption Attack

## Summary
The consensus observer component accepts `CommitDecision` messages with future epoch numbers without cryptographic verification, passing the unverified `LedgerInfoWithSignatures` directly to state sync as a sync target. This allows malicious peers to disrupt validator synchronization by triggering premature epoch ending requests and creating unreachable sync targets.

## Finding Description

The vulnerability exists in the consensus observer's handling of commit decisions for future epochs. The attack flow is as follows:

**Step 1: Bypass Verification**
When a `CommitDecision` message arrives with an epoch number greater than the validator's current epoch, verification is explicitly skipped: [1](#0-0) 

The comment at lines 497-498 acknowledges this limitation: "TODO: identify the best way to handle an invalid commit decision for a future epoch. In such cases, we currently rely on state sync."

**Step 2: Unverified Target Propagation**
The unverified commit decision is passed to the state sync manager, which calls `sync_to_target()` with the commit proof: [2](#0-1) 

**Step 3: Missing Epoch Validation in State Sync**
The state sync driver's `initialize_sync_target_request()` only validates version numbers, NOT epoch numbers: [3](#0-2) 

Lines 276-285 show that only version-based checks are performed. The target's epoch is never verified against the current epoch state.

**Step 4: Premature Epoch Ending Requests**
The stream engine uses the unverified target's epoch to determine if an epoch change has occurred: [4](#0-3) 

When `target_ledger_info.ledger_info().epoch() > next_request_epoch`, the engine immediately requests epoch ending ledger infos, even though the target was never cryptographically validated.

**Attack Scenario:**
1. Attacker (malicious peer) sends `CommitDecision` with epoch 999, version 1000000
2. Consensus observer sees epoch 999 > current epoch 10, skips verification
3. State sync accepts the target with only version checks
4. Stream engine detects "epoch change" and requests epoch ending for epoch 10
5. Validator wastes resources; sync may stall waiting for non-existent version 1000000

## Impact Explanation

This vulnerability qualifies as **High Severity** per Aptos bug bounty criteria:

- **Validator Node Slowdowns**: Validators waste network and computational resources processing premature epoch ending requests and attempting to reach fabricated sync targets
- **Significant Protocol Violations**: The epoch validation invariant is violated - unverified epoch numbers are used to make synchronization decisions
- **Availability Impact**: Validators can be forced into stuck sync states where they wait indefinitely for non-existent target versions

**Important Note**: This does NOT constitute a **Critical** consensus safety violation because:
- Actual epoch ending ledger infos received from peers ARE verified using `EpochState::verify()` [5](#0-4) 
- Transaction data payloads ARE verified against the current epoch state [6](#0-5) 

Therefore, validators will not accept invalid epoch transitions, but they will waste resources attempting to sync to fabricated targets.

## Likelihood Explanation

**Likelihood: High**

- **Attacker Requirements**: Only requires ability to send network messages to validators (any peer)
- **Attack Complexity**: Low - simply craft a `CommitDecision` with arbitrary future epoch and version
- **Detection Difficulty**: Moderate - attack traffic may blend with normal sync messages
- **Exploitation Feasibility**: Trivial once network access is obtained

## Recommendation

Add epoch validation when receiving sync targets from consensus:

```rust
pub async fn initialize_sync_target_request(
    &mut self,
    sync_target_notification: ConsensusSyncTargetNotification,
    latest_pre_committed_version: Version,
    latest_synced_ledger_info: LedgerInfoWithSignatures,
) -> Result<(), Error> {
    let sync_target = sync_target_notification.get_target();
    let sync_target_version = sync_target.ledger_info().version();
    let sync_target_epoch = sync_target.ledger_info().epoch();
    let latest_committed_version = latest_synced_ledger_info.ledger_info().version();
    let current_epoch = latest_synced_ledger_info.ledger_info().epoch();

    // NEW: Validate epoch is not too far in the future (allow +1 for epoch transitions)
    if sync_target_epoch > current_epoch + 1 {
        let error = Err(Error::InvalidSyncRequest(
            format!("Sync target epoch {} is too far ahead of current epoch {}", 
                    sync_target_epoch, current_epoch),
        ));
        self.respond_to_sync_target_notification(sync_target_notification, error.clone())?;
        return error;
    }

    // Existing version checks...
    if sync_target_version < latest_committed_version || 
       sync_target_version < latest_pre_committed_version {
        // existing error handling...
    }
    
    // Rest of function...
}
```

Additionally, the consensus observer should validate future epoch commits more carefully rather than blindly trusting them for state sync.

## Proof of Concept

```rust
// Proof of Concept: Malicious peer sends fake commit decision
// Add to consensus/src/consensus_observer/observer/consensus_observer.rs tests

#[tokio::test]
async fn test_unverified_future_epoch_attack() {
    // Setup: Create consensus observer at epoch 10
    let current_epoch = 10;
    let observer = create_consensus_observer_for_test(current_epoch);
    
    // Attack: Create CommitDecision with fabricated future epoch
    let fake_commit = CommitDecision::new(
        CommitProof::new(
            LedgerInfoWithSignatures::new(
                LedgerInfo::new(
                    BlockInfo::new(
                        999, // Fake future epoch
                        0,
                        HashValue::zero(),
                        HashValue::zero(),
                        1000000, // Fake high version
                        0,
                        None,
                    ),
                    HashValue::zero(),
                ),
                AggregateSignature::empty(), // Invalid signatures
            ),
        ),
    );
    
    // Send malicious commit to observer
    observer.process_commit_decision_message(
        fake_peer_id,
        Instant::now(),
        fake_commit,
    );
    
    // Verify: Observer accepted unverified commit and initiated state sync
    // This should FAIL but currently SUCCEEDS
    assert!(observer.state_sync_manager.is_syncing());
    
    // Verify: Stream engine is now requesting epoch endings prematurely
    // This demonstrates the vulnerability
}
```

## Notes

The root cause is a trust boundary violation: the consensus observer trusts peer-provided epoch numbers without cryptographic verification when they reference future epochs. While the system correctly validates actual epoch transition data when it arrives, the unverified target causes resource waste and potential synchronization stalls.

This finding demonstrates a **High Severity** vulnerability enabling denial-of-service against validators, though it does not constitute a consensus safety violation due to downstream verification protections.

### Citations

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L466-495)
```rust
        // If the commit decision is for the current epoch, verify and process it
        let epoch_state = self.get_epoch_state();
        if commit_epoch == epoch_state.epoch {
            // Verify the commit decision
            if let Err(error) = commit_decision.verify_commit_proof(&epoch_state) {
                // Log the error and update the invalid message counter
                error!(
                    LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                        "Failed to verify commit decision! Ignoring: {:?}, from peer: {:?}. Error: {:?}",
                        commit_decision.proof_block_info(),
                        peer_network_id,
                        error
                    ))
                );
                increment_invalid_message_counter(&peer_network_id, metrics::COMMIT_DECISION_LABEL);
                return;
            }

            // Update the latency metrics for commit processing
            update_message_processing_latency_metrics(
                message_received_time,
                &peer_network_id,
                metrics::COMMIT_DECISION_LABEL,
            );

            // Update the pending blocks with the commit decision
            if self.process_commit_decision_for_pending_block(&commit_decision) {
                return; // The commit decision was successfully processed
            }
        }
```

**File:** consensus/src/consensus_observer/observer/state_sync_manager.rs (L218-222)
```rust
                // Sync to the commit decision
                if let Err(error) = execution_client
                    .clone()
                    .sync_to_target(commit_decision.commit_proof().clone())
                    .await
```

**File:** state-sync/state-sync-driver/src/notification_handlers.rs (L261-318)
```rust
    /// Initializes the sync target request received from consensus
    pub async fn initialize_sync_target_request(
        &mut self,
        sync_target_notification: ConsensusSyncTargetNotification,
        latest_pre_committed_version: Version,
        latest_synced_ledger_info: LedgerInfoWithSignatures,
    ) -> Result<(), Error> {
        // Get the target sync version and latest committed version
        let sync_target_version = sync_target_notification
            .get_target()
            .ledger_info()
            .version();
        let latest_committed_version = latest_synced_ledger_info.ledger_info().version();

        // If the target version is old, return an error to consensus (something is wrong!)
        if sync_target_version < latest_committed_version
            || sync_target_version < latest_pre_committed_version
        {
            let error = Err(Error::OldSyncRequest(
                sync_target_version,
                latest_pre_committed_version,
                latest_committed_version,
            ));
            self.respond_to_sync_target_notification(sync_target_notification, error.clone())?;
            return error;
        }

        // If the committed version is at the target, return successfully
        if sync_target_version == latest_committed_version {
            info!(
                LogSchema::new(LogEntry::NotificationHandler).message(&format!(
                    "We're already at the requested sync target version: {} \
                (pre-committed version: {}, committed version: {})!",
                    sync_target_version, latest_pre_committed_version, latest_committed_version
                ))
            );
            let result = Ok(());
            self.respond_to_sync_target_notification(sync_target_notification, result.clone())?;
            return result;
        }

        // If the pre-committed version is already at the target, something has else gone wrong
        if sync_target_version == latest_pre_committed_version {
            let error = Err(Error::InvalidSyncRequest(
                sync_target_version,
                latest_pre_committed_version,
            ));
            self.respond_to_sync_target_notification(sync_target_notification, error.clone())?;
            return error;
        }

        // Save the request so we can notify consensus once we've hit the target
        let consensus_sync_request =
            ConsensusSyncRequest::new_with_target(sync_target_notification);
        self.consensus_sync_request = Arc::new(Mutex::new(Some(consensus_sync_request)));

        Ok(())
    }
```

**File:** state-sync/data-streaming-service/src/stream_engine.rs (L1193-1209)
```rust
                if target_ledger_info.ledger_info().epoch() > next_request_epoch {
                    // There was an epoch change. Request an epoch ending ledger info.
                    info!(
                        (LogSchema::new(LogEntry::AptosDataClient)
                            .event(LogEvent::Pending)
                            .message(&format!(
                                "Requested an epoch ending ledger info for epoch: {:?}",
                                next_request_epoch
                            )))
                    );
                    self.end_of_epoch_requested = true;
                    return Ok(vec![DataClientRequest::EpochEndingLedgerInfos(
                        EpochEndingLedgerInfosRequest {
                            start_epoch: next_request_epoch,
                            end_epoch: next_request_epoch,
                        },
                    )]);
```

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L103-108)
```rust
        // Verify the ledger info against the latest epoch state
        self.latest_epoch_state
            .verify(epoch_ending_ledger_info)
            .map_err(|error| {
                Error::VerificationError(format!("Ledger info failed verification: {:?}", error))
            })?;
```

**File:** state-sync/state-sync-driver/src/utils.rs (L101-110)
```rust
    pub fn verify_ledger_info_with_signatures(
        &mut self,
        ledger_info_with_signatures: &LedgerInfoWithSignatures,
    ) -> Result<(), Error> {
        self.epoch_state
            .verify(ledger_info_with_signatures)
            .map_err(|error| {
                Error::VerificationError(format!("Ledger info failed verification: {:?}", error))
            })
    }
```
