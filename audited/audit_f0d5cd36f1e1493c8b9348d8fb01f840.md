# Audit Report

## Title
Indexer Crash Due to Unchecked NULL Dereference in Token Claim Deletion Processing

## Summary
The indexer's token claim processing code contains a critical NULL pointer dereference vulnerability at line 122 of `token_claims.rs`. When processing `DeleteTableItem` events for token claims, the code calls `.unwrap()` on `table_item.data` without validating that it is non-NULL. Since the indexer is hardcoded to run without table metadata support (`indexer_reader = None`), all `DeleteTableItem` events have `data = None`, causing the indexer to panic and crash whenever a token claim deletion occurs.

## Finding Description

The vulnerability exists in the token claim deletion processing pipeline:

1. **Hardcoded Configuration**: The indexer creates its API context with `indexer_reader = None` [1](#0-0) 

2. **Missing Metadata Propagation**: When the `MoveConverter` attempts to populate `DeleteTableItem.data`, it calls `get_table_info()` which returns `None` when `indexer_reader` is absent [2](#0-1) 

3. **NULL Data Creation**: The `try_delete_table_item_into_deleted_table_data()` function returns `Ok(None)` when table info is unavailable [3](#0-2) 

4. **Event with NULL Data**: `DeleteTableItem` is created with `data = None` [4](#0-3) 

5. **Unchecked Unwrap**: The token claims processor calls `.unwrap()` on this NULL value without validation [5](#0-4) 

The `DeleteTableItem` struct explicitly documents that `data` is optional and only available when the table indexer is enabled [6](#0-5) 

However, the `from_delete_table_item()` function unconditionally unwraps this optional field, violating the API contract. The same vulnerability exists in `from_write_table_item()` at line 44 [7](#0-6) 

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos bug bounty program's "API crashes" category:

- **Service Disruption**: The indexer permanently crashes when processing any token claim deletion event, requiring manual restart
- **Data Loss**: Token claim deletion events are not tracked in the PostgreSQL database, causing permanent data inconsistency between on-chain state and indexed data
- **User Impact**: Applications relying on the indexer API for token claim queries receive stale or incomplete data
- **Scope**: Affects the `TokenTransactionProcessor` used by the legacy indexer service [8](#0-7) 

While this does not affect consensus or validator operations, it severely impacts the indexer infrastructure that many applications depend on for querying blockchain data.

## Likelihood Explanation

**Likelihood: High**

- **Guaranteed Trigger**: The configuration is hardcoded in the indexer bootstrap code, ensuring `indexer_reader` is always `None`
- **Common Operation**: Token claim creation and deletion are standard operations in the Aptos token framework (Token v1)
- **No Mitigation**: No defensive checks exist between the NULL data creation and the unwrap call
- **Immediate Crash**: The panic occurs synchronously during transaction processing, immediately halting the indexer

Any user performing a token claim cancellation or acceptance (which deletes the pending claim entry) will trigger this crash.

## Recommendation

Add NULL validation before accessing `table_item.data`:

**In `token_claims.rs` at line 122:**

```rust
pub fn from_delete_table_item(
    table_item: &APIDeleteTableItem,
    txn_version: i64,
    txn_timestamp: chrono::NaiveDateTime,
    table_handle_to_owner: &TableHandleToOwner,
) -> anyhow::Result<Option<Self>> {
    // Add defensive check for missing data
    let table_item_data = match table_item.data.as_ref() {
        Some(data) => data,
        None => {
            aptos_logger::warn!(
                transaction_version = txn_version,
                "DeleteTableItem missing data field - table indexer may be disabled"
            );
            return Ok(None);
        }
    };
    
    // Rest of the function remains unchanged...
}
```

Apply the same fix to `from_write_table_item()` at line 44. Additionally, consider either:
1. Enabling the table indexer for the legacy indexer service, or
2. Documenting that the legacy indexer requires table metadata support

## Proof of Concept

**Reproduction Steps:**

1. Deploy a token collection and mint a token using the Aptos Token v1 framework
2. Create a token offer to another account (creates a pending claim entry)
3. Cancel or accept the token offer (deletes the pending claim entry, emitting a `DeleteTableItem` event)
4. Observe the indexer crash with panic message: `"called Option::unwrap() on a None value"`

**Expected Crash Location:**
```
thread 'tokio-runtime-worker' panicked at 'called `Option::unwrap()` on a `None` value'
crates/indexer/src/models/token_models/token_claims.rs:122
```

**Code Path:**
- Transaction execution â†’ `WriteSetChange::DeleteTableItem` created [4](#0-3) 
- Indexer fetches transaction batch [9](#0-8) 
- Token processor handles delete event [10](#0-9) 
- `CurrentTokenPendingClaim::from_delete_table_item()` called
- Panic at line 122 due to NULL unwrap

**Notes**

- This vulnerability also affects `WriteTableItem` processing at line 44, though the write path may be less commonly triggered for token claims
- The root cause is the architectural decision to run the indexer without table metadata support, combined with insufficient defensive programming in the token models
- The indexer is a legacy component being replaced by the indexer-grpc infrastructure, but it remains in production use
- Impact is limited to data indexing infrastructure and does not affect consensus, validator operations, or on-chain state

### Citations

**File:** crates/indexer/src/runtime.rs (L93-99)
```rust
        let context = Arc::new(Context::new(
            chain_id,
            db,
            mp_sender,
            node_config,
            None, /* table info reader */
        ));
```

**File:** crates/indexer/src/runtime.rs (L137-141)
```rust
        Processor::TokenProcessor => Arc::new(TokenTransactionProcessor::new(
            conn_pool.clone(),
            config.ans_contract_address,
            config.nft_points_contract,
        )),
```

**File:** api/types/src/convert.rs (L532-537)
```rust
                WriteSetChange::DeleteTableItem(DeleteTableItem {
                    state_key_hash,
                    handle: hex_handle,
                    key,
                    data,
                })
```

**File:** api/types/src/convert.rs (L585-590)
```rust
        let table_info = match self.get_table_info(handle)? {
            Some(ti) => ti,
            None => {
                log_missing_table_info(handle);
                return Ok(None); // if table item not found return None anyway to avoid crash
            },
```

**File:** api/types/src/convert.rs (L1060-1065)
```rust
    fn get_table_info(&self, handle: TableHandle) -> Result<Option<TableInfo>> {
        if let Some(indexer_reader) = self.indexer_reader.as_ref() {
            return Ok(indexer_reader.get_table_info(handle).unwrap_or(None));
        }
        Ok(None)
    }
```

**File:** crates/indexer/src/models/token_models/token_claims.rs (L44-44)
```rust
        let table_item_data = table_item.data.as_ref().unwrap();
```

**File:** crates/indexer/src/models/token_models/token_claims.rs (L122-122)
```rust
        let table_item_data = table_item.data.as_ref().unwrap();
```

**File:** api/types/src/transaction.rs (L1130-1133)
```rust
    // This is optional, and only possible to populate if the table indexer is enabled for this node
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub data: Option<DeletedTableData>,
```

**File:** crates/indexer/src/indexer/fetcher.rs (L244-245)
```rust
    let state_view = context.latest_state_view().unwrap();
    let converter = state_view.as_converter(context.db.clone(), context.indexer_reader.clone());
```

**File:** crates/indexer/src/models/token_models/tokens.rs (L156-164)
```rust
                    APIWriteSetChange::DeleteTableItem(delete_table_item) => {
                        CurrentTokenPendingClaim::from_delete_table_item(
                            delete_table_item,
                            txn_version,
                            txn_timestamp,
                            table_handle_to_owner,
                        )
                        .unwrap()
                    },
```
