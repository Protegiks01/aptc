# Audit Report

## Title
Critical Network Topology Exposure via Unauthenticated Inspection Service Endpoint

## Summary
The `/peer_information` endpoint in the aptos-inspection-service exposes highly sensitive network topology data including validator network addresses, peer identities, synchronization states, and build information through the `internal_client_state` field. This endpoint is enabled by default, requires no authentication, and can be publicly accessible in misconfigured deployments, enabling targeted attacks against validator infrastructure.

## Finding Description

The `display_internal_client_state()` function exposes the complete internal peer monitoring state via an HTTP endpoint without authentication. [1](#0-0) 

This function reveals `internal_client_state`, which contains a JSON-serialized dump of all peer state information: [2](#0-1) 

The exposed data includes:

1. **NetworkInformationResponse** - Complete network topology with connected peer addresses, IDs, and roles: [3](#0-2) 

2. **NodeInformationResponse** - Synchronization state and build information: [4](#0-3) 

3. **ConnectionMetadata** - Precise network addresses for each peer: [5](#0-4) 

The endpoint is **enabled by default**: [6](#0-5) 

The service binds to all interfaces (0.0.0.0) and has **no authentication mechanism**: [7](#0-6) 

### Attack Vectors Enabled:

1. **Validator Network Mapping**: By querying multiple nodes, attackers construct a complete map of the validator network topology, identifying all validators' network addresses and peer relationships.

2. **Targeted DDoS/Eclipse Attacks**: With exact validator IP addresses and network identities, attackers can launch surgical network-level attacks against specific validators to disrupt consensus.

3. **Synchronization State Exploitation**: The `highest_synced_version` and `lowest_available_version` fields reveal nodes that are lagging, making them prime targets for eclipse attacks during catch-up.

4. **Build Version Exploitation**: The `build_information` field reveals exact software versions, enabling attackers to exploit known vulnerabilities in specific builds.

5. **Validator Set Inference**: The `peer_role` field (Validator, VFN, PFN) combined with network topology allows attackers to identify the active validator set and their VFN infrastructure.

6. **Timing Attack Coordination**: The `uptime` field enables attackers to identify recently restarted nodes or coordinate attacks during epoch transitions.

## Impact Explanation

While the default Docker configuration binds to localhost only, production deployments often deviate from defaults. In Kubernetes deployments, the service can be publicly exposed: [8](#0-7) 

Within Kubernetes clusters, the endpoint is accessible to any namespace: [9](#0-8) 

This represents a **High Severity** vulnerability because:
- It enables reconnaissance for coordinated attacks on validator infrastructure
- Network topology disclosure facilitates eclipse attacks that can isolate validators
- Synchronization state exposure helps attackers target vulnerable nodes during state sync
- No authentication means any entity reaching the endpoint gets full access

The information disclosed goes far beyond what's necessary for legitimate monitoring and debugging purposes.

## Likelihood Explanation

**High likelihood** in production environments because:
- The endpoint is **enabled by default** (`expose_peer_information: true`)
- Operators may unknowingly expose metrics publicly (setting `exposeMetrics: true` for legitimate monitoring)
- Cloud deployment templates show port 9101 is routable within monitoring infrastructure
- Many operators prioritize observability over security and expose metrics endpoints
- The lack of authentication makes exploitation trivial once network access is obtained

## Recommendation

1. **Disable internal_client_state exposure by default** - Remove this field from the public endpoint entirely
2. **Implement authentication** for the inspection service, similar to the admin service
3. **Add explicit warnings** in deployment documentation about exposing port 9101
4. **Separate sensitive debugging endpoints** from metrics endpoints
5. **Default to disabled** for peer_information endpoint in production environments

Proposed fix for `peer_information.rs`:

```rust
// Remove the display_internal_client_state() call entirely from get_peer_information()
// Or make it conditional on an additional explicit config flag:
if node_config.inspection_service.expose_internal_debug_state {
    display_internal_client_state(...);
}
```

Add authentication middleware similar to the admin service: [10](#0-9) 

## Proof of Concept

**Setup**: Deploy an Aptos fullnode with default configuration and expose metrics publicly (common in cloud environments for Prometheus scraping).

**Exploitation**:
```bash
# Query the peer information endpoint
curl http://<node-ip>:9101/peer_information

# Output reveals complete network topology:
# Internal client state for each peer:
#   - Peer: 00000000(Validator, vfn), internal client state: {
#       "latency_info": "...",
#       "network_info": "NetworkInfoState { 
#           recorded_network_info_response: Some(NetworkInformationResponse { 
#               connected_peers: {
#                   00000001(Validator, validator): ConnectionMetadata {
#                       network_address: "/ip4/10.0.1.5/tcp/6180",
#                       peer_id: 00000001,
#                       peer_role: Validator
#                   },
#                   00000002(Validator, validator): ConnectionMetadata {
#                       network_address: "/ip4/10.0.1.6/tcp/6180",
#                       ...
#                   }
#               },
#               distance_from_validators: 0
#           })
#       }",
#       "node_info": "NodeInfoState { 
#           recorded_node_info_response: Some(NodeInformationResponse {
#               build_information: {...},
#               highest_synced_version: 123456789,
#               lowest_available_version: 123400000,
#               ...
#           })
#       }"
#   }
```

With this data, an attacker:
1. Maps all validators and their network addresses
2. Identifies lagging nodes (low `highest_synced_version`)
3. Launches targeted eclipse attacks on vulnerable nodes
4. Disrupts consensus by isolating validators from the network

## Notes

This vulnerability exists in the intersection of:
1. **Default-enabled sensitive data exposure** - The endpoint reveals operational data by default
2. **Lack of authentication** - No access control on sensitive debugging information  
3. **Deployment reality** - Production systems often expose monitoring ports for observability tools

While default Docker configurations mitigate this through localhost binding, production Kubernetes and cloud deployments frequently expose metrics endpoints, making this a realistic attack vector against live validator infrastructure.

### Citations

**File:** crates/aptos-inspection-service/src/server/peer_information.rs (L128-146)
```rust
/// Displays the internal client state for each peer
fn display_internal_client_state(
    peer_information_output: &mut Vec<String>,
    all_peers: &Vec<PeerNetworkId>,
    peers_and_metadata: &PeersAndMetadata,
) {
    peer_information_output.push("Internal client state for each peer:".into());

    // Fetch and display the internal client state for each peer
    for peer in all_peers {
        if let Ok(peer_metadata) = peers_and_metadata.get_metadata_for_peer(*peer) {
            let peer_monitoring_metadata = peer_metadata.get_peer_monitoring_metadata();
            peer_information_output.push(format!(
                "\t- Peer: {}, internal client state: {:?}",
                peer, peer_monitoring_metadata.internal_client_state
            ));
        }
    }
}
```

**File:** peer-monitoring-service/client/src/peer_states/peer_state.rs (L275-294)
```rust
    /// Returns a detailed internal state string (for logging and debugging purposes)
    fn get_internal_client_state(&self) -> Result<Option<String>, Error> {
        // Construct a string map for each of the state entries
        let mut client_state_strings = HashMap::new();
        for (state_key, state_value) in self.state_entries.read().iter() {
            let peer_state_label = state_key.get_label().to_string();
            let peer_state_value = format!("{}", state_value.read().deref());
            client_state_strings.insert(peer_state_label, peer_state_value);
        }

        // Pretty print and return the client state string
        let client_state_string =
            serde_json::to_string_pretty(&client_state_strings).map_err(|error| {
                Error::UnexpectedError(format!(
                    "Failed to serialize the client state string: {:?}",
                    error
                ))
            })?;
        Ok(Some(client_state_string))
    }
```

**File:** peer-monitoring-service/types/src/response.rs (L50-67)
```rust
/// A response for the network information request
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
pub struct NetworkInformationResponse {
    pub connected_peers: BTreeMap<PeerNetworkId, ConnectionMetadata>, // Connected peers
    pub distance_from_validators: u64, // The distance of the peer from the validator set
}

// Display formatting provides a high-level summary of the response
impl Display for NetworkInformationResponse {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "{{ num_connected_peers: {:?}, distance_from_validators: {:?} }}",
            self.connected_peers.len(),
            self.distance_from_validators,
        )
    }
}
```

**File:** peer-monitoring-service/types/src/response.rs (L69-85)
```rust
/// Simple connection metadata associated with each peer
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
pub struct ConnectionMetadata {
    pub network_address: NetworkAddress,
    pub peer_id: PeerId,
    pub peer_role: PeerRole,
}

impl ConnectionMetadata {
    pub fn new(network_address: NetworkAddress, peer_id: PeerId, peer_role: PeerRole) -> Self {
        Self {
            network_address,
            peer_id,
            peer_role,
        }
    }
}
```

**File:** peer-monitoring-service/types/src/response.rs (L93-118)
```rust
/// A response for the node information request
#[derive(Clone, Debug, Default, Deserialize, Eq, PartialEq, Serialize)]
pub struct NodeInformationResponse {
    pub build_information: BTreeMap<String, String>, // The build information of the node
    pub highest_synced_epoch: u64,                   // The highest synced epoch of the node
    pub highest_synced_version: u64,                 // The highest synced version of the node
    pub ledger_timestamp_usecs: u64, // The latest timestamp of the blockchain (in microseconds)
    pub lowest_available_version: u64, // The lowest stored version of the node (in storage)
    pub uptime: Duration,            // The amount of time the peer has been running
}

// Display formatting provides a high-level summary of the response
impl Display for NodeInformationResponse {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "{{ highest_synced_epoch: {:?}, highest_synced_version: {:?}, ledger_timestamp_usecs: {:?}, \
            lowest_available_version: {:?}, uptime: {:?} }}",
            self.highest_synced_epoch,
            self.highest_synced_version,
            self.ledger_timestamp_usecs,
            self.lowest_available_version,
            self.uptime,
        )
    }
}
```

**File:** config/src/config/inspection_service_config.rs (L26-37)
```rust
impl Default for InspectionServiceConfig {
    fn default() -> InspectionServiceConfig {
        InspectionServiceConfig {
            address: "0.0.0.0".to_string(),
            port: 9101,
            expose_configuration: false,
            expose_identity_information: true,
            expose_peer_information: true,
            expose_system_information: true,
        }
    }
}
```

**File:** crates/aptos-inspection-service/src/server/mod.rs (L48-101)
```rust
/// Starts the inspection service that listens on the configured
/// address and handles various endpoint requests.
pub fn start_inspection_service(
    node_config: NodeConfig,
    aptos_data_client: AptosDataClient,
    peers_and_metadata: Arc<PeersAndMetadata>,
) {
    // Fetch the service port and address
    let service_port = node_config.inspection_service.port;
    let service_address = node_config.inspection_service.address.clone();

    // Create the inspection service socket address
    let address: SocketAddr = (service_address.as_str(), service_port)
        .to_socket_addrs()
        .unwrap_or_else(|_| {
            panic!(
                "Failed to parse {}:{} as address",
                service_address, service_port
            )
        })
        .next()
        .unwrap();

    // Create a runtime for the inspection service
    let runtime = aptos_runtimes::spawn_named_runtime("inspection".into(), None);

    // Spawn the inspection service
    thread::spawn(move || {
        // Create the service function that handles the endpoint requests
        let make_service = make_service_fn(move |_conn| {
            let node_config = node_config.clone();
            let aptos_data_client = aptos_data_client.clone();
            let peers_and_metadata = peers_and_metadata.clone();
            async move {
                Ok::<_, Infallible>(service_fn(move |request| {
                    serve_requests(
                        request,
                        node_config.clone(),
                        aptos_data_client.clone(),
                        peers_and_metadata.clone(),
                    )
                }))
            }
        });

        // Start and block on the server
        runtime
            .block_on(async {
                let server = Server::bind(&address).serve(make_service);
                server.await
            })
            .unwrap();
    });
}
```

**File:** terraform/helm/fullnode/templates/service.yaml (L21-25)
```yaml
  {{- if .Values.service.exposeMetrics }}
  - name: metrics
    port: 9101
    targetPort: 9101
  {{- end }}
```

**File:** terraform/helm/aptos-node/templates/networkpolicy.yaml (L38-46)
```yaml
  # Monitoring metrics port
  - from:
    - namespaceSelector: {}
    - podSelector:
        matchLabels:
          app.kubernetes.io/name: monitoring
    ports:
    - protocol: TCP
      port: 9101
```

**File:** config/src/config/admin_service_config.rs (L15-31)
```rust
#[derive(Clone, Debug, Deserialize, PartialEq, Eq, Serialize)]
#[serde(default, deny_unknown_fields)]
pub struct AdminServiceConfig {
    pub enabled: Option<bool>,
    pub address: String,
    pub port: u16,
    // If empty, will allow all requests without authentication. (Not allowed on mainnet.)
    pub authentication_configs: Vec<AuthenticationConfig>,
    pub malloc_stats_max_len: usize,
}

#[derive(Clone, Debug, Deserialize, PartialEq, Eq, Serialize)]
#[serde(rename_all = "snake_case")]
pub enum AuthenticationConfig {
    // This will allow authentication through query parameter.
    // e.g. `/profilez?passcode=abc`.
    //
```
