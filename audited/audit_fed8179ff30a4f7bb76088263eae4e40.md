# Audit Report

## Title
Critical Consensus Race Condition: OrderVote Creation Uses Inconsistent State Compute Results Across Validators

## Summary
A critical race condition exists in the consensus protocol where different validators create `OrderVote` messages with different `BlockInfo` data for the same block, depending on whether execution has completed when they form their quorum certificate. This causes validators to vote on different state transitions, breaking consensus safety and preventing order certificate aggregation, leading to liveness failures.

## Finding Description

The vulnerability occurs in the `broadcast_order_vote()` flow where `OrderVoteProposal` is created from a `PipelinedBlock`'s current state. The core issue is that blocks are initially created with a dummy `StateComputeResult` and later updated to actual values after asynchronous execution completes.

**The vulnerable flow:**

1. When a block is inserted into the block store, it's created with a dummy state compute result [1](#0-0) 

2. The dummy result uses `ACCUMULATOR_PLACEHOLDER_HASH` as the root hash [2](#0-1) 

3. Execution happens asynchronously and later updates the state via `set_compute_result()` [3](#0-2) 

4. When validators form a QC and broadcast order votes, they call `create_order_vote()` which reads the **current** state [4](#0-3) 

5. The `order_vote_proposal()` method generates `BlockInfo` from the current state compute result [5](#0-4) 

6. The `BlockInfo` is created with the state's root hash and version [6](#0-5) 

**The race condition:**

- Validator V1 forms QC at time T1 (before execution completes) → creates `OrderVote` with `BlockInfo(ACCUMULATOR_PLACEHOLDER_HASH, version=0)`
- Execution completes and updates state_compute_result
- Validator V2 forms QC at time T2 (after execution completes) → creates `OrderVote` with `BlockInfo(ACTUAL_HASH, version=N)`

**Impact on aggregation:**

The `OrderVote` contains a `LedgerInfo` which contains the `BlockInfo` [7](#0-6) 

In `PendingOrderVotes`, votes are aggregated by the hash of their ledger_info [8](#0-7) 

OrderVotes with different `BlockInfo` values have different ledger_info hashes and are stored in separate HashMap entries, never aggregating together. If voting power is split between the two versions, neither can reach the 2f+1 threshold needed for certificate formation.

## Impact Explanation

**Critical Severity** - This vulnerability meets multiple critical impact criteria:

1. **Consensus Safety Violation**: Different validators vote on different state transitions (different root hashes and versions) for the same block, violating the fundamental consensus invariant that all honest validators must agree on state transitions.

2. **Liveness Failure**: If voting power splits between validators using dummy state vs. actual state, neither group can aggregate 2f+1 votes to form an order certificate. This permanently blocks consensus progress for that block, requiring manual intervention or chain reorganization.

3. **Non-Deterministic Behavior**: The outcome depends on timing and network conditions rather than deterministic protocol rules, making the system unpredictable and unreliable.

This breaks **Critical Invariants #1 (Deterministic Execution)** and **#2 (Consensus Safety)** from the Aptos specification.

## Likelihood Explanation

**Likelihood: HIGH**

This vulnerability occurs naturally during normal operation:

1. **No attack required**: The race condition is inherent in the pipelined consensus design where voting can happen before execution completes.

2. **Network variability**: Different validators receive votes at different times due to normal network latency, causing them to form QCs at different moments.

3. **Execution timing**: Block execution is non-deterministic in duration, depending on transaction complexity and system load.

4. **Observable in production**: Any block where execution takes longer than the time for QC formation will trigger this race. Given the pipelining design, this is expected to happen regularly.

The vulnerability requires no malicious behavior, privileged access, or complex setup - it's a natural consequence of the current implementation.

## Recommendation

**Solution**: Ensure all validators create `OrderVoteProposal` with the same state by synchronizing on execution completion before broadcasting order votes.

**Option 1 - Wait for execution completion (recommended):**

Modify `broadcast_order_vote()` to wait for execution to complete before creating the order vote:

```rust
async fn broadcast_order_vote(
    &mut self,
    vote: &Vote,
    qc: Arc<QuorumCert>,
) -> anyhow::Result<()> {
    if let Some(proposed_block) = self.block_store.get_block(vote.vote_data().proposed().id()) {
        // ADDED: Wait for execution to complete
        if let Some(pipeline_futs) = proposed_block.pipeline_futs().lock().as_ref() {
            let _ = pipeline_futs.ledger_update_fut.clone().await;
        }
        
        // Generate an order vote with ledger_info = proposed_block
        let order_vote = self
            .create_order_vote(proposed_block.clone(), qc.clone())
            .await?;
        // ... rest of function
    }
    Ok(())
}
```

**Option 2 - Use deterministic placeholder:**

If order votes should be based on ordering rather than execution, ensure ALL validators consistently use the dummy state by not updating it until after order certificate formation. However, this requires redesigning the pipeline phases.

**Option 3 - Include execution flag:**

Add a flag indicating whether the `BlockInfo` is based on actual or dummy execution, and ensure validators only aggregate votes with matching flags.

## Proof of Concept

**Rust reproduction steps:**

1. Create a test that spawns multiple validator threads processing the same block
2. Introduce artificial delay in execution completion for some validators
3. Trigger QC formation at different times across validators
4. Observe that created `OrderVote` messages have different `ledger_info` hashes
5. Verify that `PendingOrderVotes` creates separate entries and fails to aggregate

**Concrete test scenario:**

```rust
#[tokio::test]
async fn test_order_vote_race_condition() {
    // Setup: Create a block with dummy state
    let block = create_test_block();
    let pipelined_block = PipelinedBlock::new_ordered(block, OrderedBlockWindow::empty());
    
    // Validator 1: Create order vote BEFORE execution
    let order_vote_1 = create_order_vote_from_block(&pipelined_block, qc.clone());
    let hash_1 = order_vote_1.ledger_info().hash();
    
    // Simulate execution completion
    pipelined_block.set_compute_result(actual_compute_result, Duration::from_secs(1));
    
    // Validator 2: Create order vote AFTER execution  
    let order_vote_2 = create_order_vote_from_block(&pipelined_block, qc.clone());
    let hash_2 = order_vote_2.ledger_info().hash();
    
    // Assert: Different hashes, cannot aggregate
    assert_ne!(hash_1, hash_2);
    
    // Verify aggregation fails
    let mut pending = PendingOrderVotes::new();
    pending.insert_order_vote(&order_vote_1, &validator_verifier, Some(qc.clone()));
    let result = pending.insert_order_vote(&order_vote_2, &validator_verifier, None);
    // Result should show votes went to different entries, not aggregated together
}
```

The test demonstrates that the same block produces different `OrderVote` messages with different ledger_info hashes based on execution timing, confirming the race condition vulnerability.

### Citations

**File:** consensus/consensus-types/src/pipelined_block.rs (L277-307)
```rust
    pub fn set_compute_result(
        &self,
        state_compute_result: StateComputeResult,
        execution_time: Duration,
    ) {
        let mut to_commit = 0;
        let mut to_retry = 0;
        for txn in state_compute_result.compute_status_for_input_txns() {
            match txn {
                TransactionStatus::Keep(_) => to_commit += 1,
                TransactionStatus::Retry => to_retry += 1,
                _ => {},
            }
        }

        let execution_summary = ExecutionSummary {
            payload_len: self
                .block
                .payload()
                .map_or(0, |payload| payload.len_for_execution()),
            to_commit,
            to_retry,
            execution_time,
            root_hash: state_compute_result.root_hash(),
            gas_used: state_compute_result
                .execution_output
                .block_end_info
                .as_ref()
                .map(|info| info.block_effective_gas_units()),
        };
        *self.state_compute_result.lock() = state_compute_result;
```

**File:** consensus/consensus-types/src/pipelined_block.rs (L394-398)
```rust
    pub fn new_ordered(block: Block, window: OrderedBlockWindow) -> Self {
        let input_transactions = Vec::new();
        let state_compute_result = StateComputeResult::new_dummy();
        Self::new(block, input_transactions, state_compute_result).with_block_window(window)
    }
```

**File:** consensus/consensus-types/src/pipelined_block.rs (L452-459)
```rust
    pub fn block_info(&self) -> BlockInfo {
        let compute_result = self.compute_result();
        self.block().gen_block_info(
            compute_result.root_hash(),
            compute_result.last_version_or_0(),
            compute_result.epoch_state().clone(),
        )
    }
```

**File:** execution/executor-types/src/state_compute_result.rs (L74-76)
```rust
    pub fn new_dummy() -> Self {
        Self::new_dummy_with_root_hash(*ACCUMULATOR_PLACEHOLDER_HASH)
    }
```

**File:** consensus/src/round_manager.rs (L1626-1651)
```rust
    async fn create_order_vote(
        &mut self,
        block: Arc<PipelinedBlock>,
        qc: Arc<QuorumCert>,
    ) -> anyhow::Result<OrderVote> {
        let order_vote_proposal = block.order_vote_proposal(qc);
        let order_vote_result = self
            .safety_rules
            .lock()
            .construct_and_sign_order_vote(&order_vote_proposal);
        let order_vote = order_vote_result.context(format!(
            "[RoundManager] SafetyRules Rejected {} for order vote",
            block.block()
        ))?;

        fail_point!("consensus::create_invalid_order_vote", |_| {
            use aptos_crypto::bls12381;
            let faulty_order_vote = OrderVote::new_with_signature(
                order_vote.author(),
                order_vote.ledger_info().clone(),
                bls12381::Signature::dummy_signature(),
            );
            Ok(faulty_order_vote)
        });
        Ok(order_vote)
    }
```

**File:** consensus/consensus-types/src/block.rs (L237-252)
```rust
    pub fn gen_block_info(
        &self,
        executed_state_id: HashValue,
        version: Version,
        next_epoch_state: Option<EpochState>,
    ) -> BlockInfo {
        BlockInfo::new(
            self.epoch(),
            self.round(),
            self.id(),
            executed_state_id,
            version,
            self.timestamp_usecs(),
            next_epoch_state,
        )
    }
```

**File:** consensus/consensus-types/src/order_vote.rs (L15-23)
```rust
#[derive(Deserialize, Serialize, Clone)]
pub struct OrderVote {
    /// The identity of the voter.
    author: Author,
    /// LedgerInfo of a block that is going to be ordered in case this vote gathers QC.
    ledger_info: LedgerInfo,
    /// Signature on the LedgerInfo along with a status on whether the signature is verified.
    signature: SignatureWithStatus,
}
```

**File:** consensus/src/pending_order_votes.rs (L61-81)
```rust
    pub fn insert_order_vote(
        &mut self,
        order_vote: &OrderVote,
        validator_verifier: &ValidatorVerifier,
        verified_quorum_cert: Option<QuorumCert>,
    ) -> OrderVoteReceptionResult {
        // derive data from order vote
        let li_digest = order_vote.ledger_info().hash();

        // obtain the ledger info with signatures associated to the order vote's ledger info
        let (quorum_cert, status) = self.li_digest_to_votes.entry(li_digest).or_insert_with(|| {
            // if the ledger info with signatures doesn't exist yet, create it
            (
                verified_quorum_cert.expect(
                    "Quorum Cert is expected when creating a new entry in pending order votes",
                ),
                OrderVoteStatus::NotEnoughVotes(SignatureAggregator::new(
                    order_vote.ledger_info().clone(),
                )),
            )
        });
```
