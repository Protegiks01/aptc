# Audit Report

## Title
Code Injection Vulnerability in SDK Builder Due to Unsanitized ABI Names in Generated Rust Code

## Summary
The `output()` function in the Rust SDK builder fails to sanitize function and argument names from ABI files before inserting them into generated Rust source code. Since ABI names are stored as plain `String` types without validation, an attacker can craft malicious ABI files containing special characters (quotes, semicolons, etc.) that break out of string literals in the generated code, enabling arbitrary Rust code injection during SDK compilation. [1](#0-0) 

## Finding Description
The vulnerability exists in the code generation pipeline of the Aptos SDK builder. When processing ABI files to generate Rust transaction builders, the system fails to sanitize user-controlled string values before embedding them in generated source code.

**Root Cause**: ABI structures use plain `String` fields for names without validation. The `ScriptFunctionABI`, `TransactionScriptABI`, `ArgumentABI`, and `TypeArgumentABI` types all store names as unvalidated `String` objects: [2](#0-1) 

When ABI files are deserialized from BCS format, these strings bypass any Move identifier validation: [3](#0-2) 

The unvalidated names are then directly inserted into generated Rust code using format strings without escaping: [4](#0-3) 

Additionally, the `quote_identifier()` function embeds identifiers directly into string literals: [5](#0-4) 

**Attack Vector**: An attacker creates a malicious `.abi` file (BCS-encoded) where function names contain special characters like `"`, `;`, or `}`. For example, a function name could be: `transfer"); malicious_code(); ("foo`

When processed, this generates code like:
```rust
map.insert("module_transfer"); malicious_code(); ("foo".to_string(), Box::new(decoder::module_transfer"); malicious_code(); ("foo));
```

The malicious code executes during compilation of the generated SDK.

## Impact Explanation
This vulnerability enables **arbitrary code execution** in build environments that process untrusted or compromised ABI files. While this doesn't directly affect blockchain consensus or validator nodes, it creates a **supply chain attack vector** with significant security implications:

1. **Compromised Developer Machines**: Developers running SDK builder on malicious ABI files execute arbitrary code
2. **CI/CD Pipeline Compromise**: Automated build systems processing ABI files can be compromised
3. **Malicious SDK Distribution**: Generated SDKs containing backdoors could be distributed to end users
4. **Indirect Fund Theft**: Compromised SDKs used in wallets could steal private keys or misroute transactions

While not fitting traditional blockchain runtime categories, this represents a **High severity** issue as marked in the security question, affecting the integrity of the Aptos SDK development ecosystem.

## Likelihood Explanation
**Moderate to High Likelihood** depending on development practices:

- **Attack Complexity**: Low - attacker only needs to craft a malicious BCS-encoded ABI file
- **Attacker Requirements**: Ability to supply ABI files to SDK builder (via supply chain, compromised repository, or social engineering)
- **Detection Difficulty**: Generated malicious code may not be reviewed before compilation
- **Realistic Scenarios**:
  - Compromised package repository providing malicious ABI files
  - Insider threat in development pipeline
  - Developer tricked into processing untrusted ABI files
  - Compromised third-party Move modules with malicious ABIs

However, legitimate ABI files generated by the Move compiler contain validated identifiers, so normal compilation workflows are safe. The vulnerability requires processing of specially-crafted malicious ABI files.

## Recommendation
Implement proper escaping/sanitization of all ABI-derived strings before inserting into generated code:

**Option 1 - Escape Special Characters**:
```rust
fn escape_rust_string(s: &str) -> String {
    s.replace('\\', "\\\\")
     .replace('"', "\\\"")
     .replace('\n', "\\n")
     .replace('\r', "\\r")
     .replace('\t', "\\t")
}

fn quote_identifier(&self, ident: &str) -> String {
    let escaped = escape_rust_string(ident);
    if self.local_types {
        format!("ident_str!(\"{}\").to_owned()", escaped)
    } else {
        format!("Identifier(\"{}\".to_string())", escaped)
    }
}
```

**Option 2 - Validate Identifiers** (Preferred):
Add validation when deserializing ABIs to ensure names comply with Move identifier rules:

```rust
pub fn read_abis(dir_paths: &[impl AsRef<Path>]) -> anyhow::Result<Vec<EntryABI>> {
    let mut abis = Vec::<EntryABI>::new();
    for dir in dir_paths.iter() {
        for path in get_abi_paths(dir.as_ref())? {
            let mut buffer = Vec::new();
            let mut f = std::fs::File::open(path)?;
            f.read_to_end(&mut buffer)?;
            let abi: EntryABI = bcs::from_bytes(&buffer)?;
            
            // Validate all names are valid Move identifiers
            validate_abi_names(&abi)?;
            
            abis.push(abi);
        }
    }
    Ok(abis)
}

fn validate_abi_names(abi: &EntryABI) -> anyhow::Result<()> {
    // Validate function name, argument names, type argument names
    if !Identifier::is_valid(abi.name()) {
        bail!("Invalid ABI function name: {}", abi.name());
    }
    for arg in abi.args() {
        if !Identifier::is_valid(arg.name()) {
            bail!("Invalid argument name: {}", arg.name());
        }
    }
    for ty_arg in abi.ty_args() {
        if !Identifier::is_valid(ty_arg.name()) {
            bail!("Invalid type argument name: {}", ty_arg.name());
        }
    }
    Ok(())
}
```

## Proof of Concept
Create a malicious ABI file demonstrating the injection:

```rust
// File: create_malicious_abi.rs
use aptos_types::transaction::{EntryABI, EntryFunctionABI, ArgumentABI};
use move_core_types::{
    identifier::Identifier,
    language_storage::{ModuleId, TypeTag},
    account_address::AccountAddress,
};

fn main() {
    // Create malicious ABI with code injection in function name
    let malicious_name = r#"transfer"); println!("INJECTED CODE EXECUTED"); ("foo"#.to_string();
    
    let module_id = ModuleId::new(
        AccountAddress::ONE,
        Identifier::new("test").unwrap()
    );
    
    let abi = EntryABI::EntryFunction(EntryFunctionABI {
        name: malicious_name,
        module_name: module_id,
        doc: String::new(),
        ty_args: vec![],
        args: vec![],
    });
    
    // Serialize to BCS and write to file
    let serialized = bcs::to_bytes(&abi).unwrap();
    std::fs::write("malicious.abi", serialized).unwrap();
    
    println!("Created malicious.abi");
}

// Then run: aptos-sdk-builder --abi-directories . --target-source-dir ./output --module-name test
// The generated lib.rs will contain injected code that executes during compilation
```

When the SDK builder processes this ABI, it generates Rust code containing `println!("INJECTED CODE EXECUTED")` outside of a string context, which executes during compilation.

---

**Notes**: 
- This vulnerability affects the SDK builder tool, not the blockchain runtime
- Normal Move compilation produces valid ABIs with validated identifiers
- Exploitation requires processing malicious ABI files
- Defense-in-depth principle requires sanitization even for "trusted" inputs
- Module names from `ModuleId` are validated via the `Identifier` type, but function/argument names from ABI structs are not

### Citations

**File:** aptos-move/aptos-sdk-builder/src/rust.rs (L689-715)
```rust
    fn output_entry_function_decoder_map(&mut self, abis: &[EntryFunctionABI]) -> Result<()> {
        writeln!(
            self.out,
            r#"
type EntryFunctionDecoderMap = std::collections::HashMap<String, Box<dyn Fn(&TransactionPayload) -> Option<EntryFunctionCall> + std::marker::Sync + std::marker::Send>>;

static SCRIPT_FUNCTION_DECODER_MAP: once_cell::sync::Lazy<EntryFunctionDecoderMap> = once_cell::sync::Lazy::new(|| {{"#
        )?;
        self.out.indent();
        writeln!(
            self.out,
            "let mut map : EntryFunctionDecoderMap = std::collections::HashMap::new();"
        )?;
        for abi in abis {
            writeln!(
                self.out,
                "map.insert(\"{}_{}\".to_string(), Box::new(decoder::{}_{}));",
                abi.module_name().name(),
                abi.name(),
                abi.module_name().name().to_string().to_snake_case(),
                abi.name()
            )?;
        }
        writeln!(self.out, "map")?;
        self.out.unindent();
        writeln!(self.out, "}});")
    }
```

**File:** aptos-move/aptos-sdk-builder/src/rust.rs (L776-782)
```rust
    fn quote_identifier(&self, ident: &str) -> String {
        if self.local_types {
            format!("ident_str!(\"{}\").to_owned()", ident)
        } else {
            format!("Identifier(\"{}\".to_string())", ident)
        }
    }
```

**File:** third_party/move/move-core/types/src/abi.rs (L15-59)
```rust
#[derive(Clone, Debug, Hash, Eq, PartialEq, Serialize, Deserialize)]
pub struct ScriptFunctionABI {
    /// The public name of the script.
    name: String,
    /// The module name where the script lives.
    module_name: ModuleId,
    /// Some text comment.
    doc: String,
    /// The names of the type arguments.
    ty_args: Vec<TypeArgumentABI>,
    /// The description of regular arguments.
    args: Vec<ArgumentABI>,
}

#[derive(Clone, Debug, Hash, Eq, PartialEq, Serialize, Deserialize)]
pub struct TransactionScriptABI {
    /// The public name of the script.
    name: String,
    /// Some text comment.
    doc: String,
    /// The `code` value to set in the `Script` object.
    #[serde(with = "serde_bytes")]
    code: Vec<u8>,
    /// The names of the type arguments.
    ty_args: Vec<TypeArgumentABI>,
    /// The description of regular arguments.
    args: Vec<ArgumentABI>,
}

/// The description of a (regular) argument in a script.
#[derive(Clone, Debug, Hash, Eq, PartialEq, Serialize, Deserialize)]
pub struct ArgumentABI {
    /// The name of the argument.
    name: String,
    /// The expected type.
    /// In Move scripts, this does contain generics type parameters.
    type_tag: TypeTag,
}

/// The description of a type argument in a script.
#[derive(Clone, Debug, Hash, Eq, PartialEq, Serialize, Deserialize)]
pub struct TypeArgumentABI {
    /// The name of the argument.
    name: String,
}
```

**File:** aptos-move/aptos-sdk-builder/src/lib.rs (L30-39)
```rust
pub fn read_abis(dir_paths: &[impl AsRef<Path>]) -> anyhow::Result<Vec<EntryABI>> {
    let mut abis = Vec::<EntryABI>::new();
    for dir in dir_paths.iter() {
        for path in get_abi_paths(dir.as_ref())? {
            let mut buffer = Vec::new();
            let mut f = std::fs::File::open(path)?;
            f.read_to_end(&mut buffer)?;
            abis.push(bcs::from_bytes(&buffer)?);
        }
    }
```
