# Audit Report

## Title
Genesis Transaction Data Loss in Fast Sync Mode Leading to API Inconsistency

## Summary
During fast sync bootstrap, genesis transaction data committed to `temporary_db_with_genesis` is not migrated to `db_for_fast_sync`, causing the genesis transaction (version 0) to become permanently inaccessible after fast sync completes. This creates API inconsistency where nodes bootstrapped via fast sync cannot serve genesis transaction queries while normally bootstrapped nodes can.

## Finding Description

The `FastSyncStorageWrapper` maintains two separate databases during fast sync bootstrap: [1](#0-0) 

The critical vulnerability lies in how writes are routed based on `FastSyncStatus`: [2](#0-1) 

**Exploitation Flow:**

1. **Genesis Application Phase** (Status = UNKNOWN): Genesis transaction is committed to `temporary_db_with_genesis` via `maybe_apply_genesis()`: [3](#0-2) 

2. **Partial Data Migration**: Only the genesis **ledger info** is copied to `db_for_fast_sync`, not the complete transaction data: [4](#0-3) 

The `commit_genesis_ledger_info()` function only persists ledger metadata: [5](#0-4) 

3. **Snapshot Initialization** (Status → STARTED): When `get_state_snapshot_receiver()` is called, status transitions to STARTED: [6](#0-5) 

4. **Database Switchover** (Status → FINISHED): After snapshot completes, reads permanently switch to `db_for_fast_sync`: [7](#0-6) 

**Result**: The genesis transaction saved via `save_transactions()` to `temporary_db_with_genesis` becomes permanently inaccessible. The API endpoint for version 0 queries will fail: [8](#0-7) 

## Impact Explanation

**Severity: Medium**

This issue creates **state inconsistencies requiring intervention** across the network:

1. **API Non-Uniformity**: Fast sync nodes cannot serve `/transactions/by_version/0` while genesis-bootstrapped nodes can, creating unpredictable client behavior.

2. **Transaction History Gap**: Fast sync nodes have incomplete transaction history starting from snapshot version rather than genesis, violating the expectation that all full nodes maintain consistent historical data.

3. **Explorers/Indexers Impact**: Blockchain explorers or indexers querying fast sync nodes will receive errors when requesting genesis transaction details, despite the genesis ledger info being present.

This does NOT qualify as Critical severity because:
- No funds are lost or at risk
- Consensus safety is not violated
- State at the snapshot version is correct
- Network continues to function

However, it creates operational issues requiring manual intervention or node reconfiguration.

## Likelihood Explanation

**Likelihood: High**

This vulnerability occurs **automatically** on every node bootstrapped with fast sync mode: [9](#0-8) 

No attacker action is required. Any node operator choosing `DownloadLatestStates` bootstrapping mode will experience this issue.

## Recommendation

**Solution**: Migrate complete genesis transaction data (not just ledger info) to `db_for_fast_sync` before snapshot initialization.

Modify `aptos-node/src/storage.rs` to save the full genesis transaction to `db_for_fast_sync`:

```rust
// After line 77, before wrapping FastSyncStorageWrapper
let genesis_chunk = {
    // Extract genesis transaction from temporary DB
    let genesis_txn = temp_db.get_transaction_by_version(0, 0, true)?;
    // Create ChunkToCommit from genesis transaction
    // ... (implementation details)
};

// Save complete genesis to fast sync DB
DbReaderWriter::from_arc(db_arc.get_fast_sync_db())
    .writer
    .save_transactions(genesis_chunk, Some(&ledger_info), true)?;
```

**Alternative**: Document that fast sync nodes cannot serve historical transaction queries before the snapshot version and implement proper API error responses indicating this limitation.

## Proof of Concept

```rust
// test_fast_sync_genesis_loss.rs
use aptos_config::config::BootstrappingMode;
use aptos_node::storage::bootstrap_db;

#[tokio::test]
async fn test_genesis_transaction_lost_after_fast_sync() {
    // 1. Configure node for fast sync
    let mut config = NodeConfig::default();
    config.state_sync.state_sync_driver.bootstrapping_mode = 
        BootstrappingMode::DownloadLatestStates;
    
    // 2. Bootstrap database (applies genesis to temporary DB)
    let (reader, db_rw, _, _, _) = bootstrap_db(&config).unwrap();
    
    // 3. Simulate fast sync completion
    // (In real scenario, get_state_snapshot_receiver + finalize would be called)
    
    // 4. Attempt to query genesis transaction
    let result = reader.get_transaction_by_version(0, 0, false);
    
    // EXPECTED: Should succeed
    // ACTUAL: Fails because genesis is in abandoned temporary_db_with_genesis
    assert!(result.is_err(), "Genesis transaction should be inaccessible after fast sync");
}
```

---

**Notes**: This vulnerability represents an incomplete implementation of fast sync where genesis data is partially preserved (ledger info only) but not fully migrated. While fast sync intentionally skips transaction history, the system's explicit genesis application and API support for version 0 queries suggests genesis should remain accessible post-bootstrap.

### Citations

**File:** storage/aptosdb/src/fast_sync_storage_wrapper.rs (L31-38)
```rust
pub struct FastSyncStorageWrapper {
    // Used for storing genesis data during fast sync
    temporary_db_with_genesis: Arc<AptosDB>,
    // Used for restoring fast sync snapshot and all the read/writes afterwards
    db_for_fast_sync: Arc<AptosDB>,
    // This is for reading the fast_sync status to determine which db to use
    fast_sync_status: Arc<RwLock<FastSyncStatus>>,
}
```

**File:** storage/aptosdb/src/fast_sync_storage_wrapper.rs (L126-132)
```rust
    pub(crate) fn get_aptos_db_read_ref(&self) -> &AptosDB {
        if self.is_fast_sync_bootstrap_finished() {
            self.db_for_fast_sync.as_ref()
        } else {
            self.temporary_db_with_genesis.as_ref()
        }
    }
```

**File:** storage/aptosdb/src/fast_sync_storage_wrapper.rs (L134-140)
```rust
    pub(crate) fn get_aptos_db_write_ref(&self) -> &AptosDB {
        if self.is_fast_sync_bootstrap_started() || self.is_fast_sync_bootstrap_finished() {
            self.db_for_fast_sync.as_ref()
        } else {
            self.temporary_db_with_genesis.as_ref()
        }
    }
```

**File:** storage/aptosdb/src/fast_sync_storage_wrapper.rs (L144-152)
```rust
    fn get_state_snapshot_receiver(
        &self,
        version: Version,
        expected_root_hash: HashValue,
    ) -> Result<Box<dyn StateSnapshotReceiver<StateKey, StateValue>>> {
        *self.fast_sync_status.write() = FastSyncStatus::STARTED;
        self.get_aptos_db_write_ref()
            .get_state_snapshot_receiver(version, expected_root_hash)
    }
```

**File:** aptos-node/src/storage.rs (L75-77)
```rust
        Either::Right(fast_sync_db_wrapper) => {
            let temp_db = fast_sync_db_wrapper.get_temporary_db_with_genesis();
            maybe_apply_genesis(&DbReaderWriter::from_arc(temp_db), node_config)?;
```

**File:** aptos-node/src/storage.rs (L81-94)
```rust
            let ledger_info = db_arc
                .get_temporary_db_with_genesis()
                .get_epoch_ending_ledger_info(0)
                .expect("Genesis ledger info must exist");

            if fast_sync_db
                .get_latest_ledger_info_option()
                .expect("should returns Ok results")
                .is_none()
            {
                // it means the DB is empty and we need to
                // commit the genesis ledger info to the DB.
                fast_sync_db.commit_genesis_ledger_info(&ledger_info)?;
            }
```

**File:** storage/aptosdb/src/db/mod.rs (L207-219)
```rust
    pub fn commit_genesis_ledger_info(&self, genesis_li: &LedgerInfoWithSignatures) -> Result<()> {
        let ledger_metadata_db = self.ledger_db.metadata_db();
        let current_epoch = ledger_metadata_db
            .get_latest_ledger_info_option()
            .map_or(0, |li| li.ledger_info().next_block_epoch());
        ensure!(
            genesis_li.ledger_info().epoch() == current_epoch && current_epoch == 0,
            "Genesis ledger info epoch is not 0"
        );
        let mut ledger_batch = SchemaBatch::new();
        ledger_metadata_db.put_ledger_info(genesis_li, &mut ledger_batch)?;
        ledger_metadata_db.write_schemas(ledger_batch)
    }
```

**File:** api/src/tests/transactions_test.rs (L36-42)
```rust
async fn test_deserialize_genesis_transaction() {
    let context = new_test_context(current_function_name!());
    let resp = context.get("/transactions/by_version/0").await;
    // TODO: serde_json::from_value doesn't work here, either make it work
    // or remove the ability to do that.
    aptos_api_types::Transaction::parse_from_json(Some(resp)).unwrap();
}
```

**File:** config/src/config/state_sync_config.rs (L48-49)
```rust
    /// Downloads the state keys and values (at the latest version)
    DownloadLatestStates,
```
