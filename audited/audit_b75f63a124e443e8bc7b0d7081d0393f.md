# Audit Report

## Title
Missing Zero-Value Validation in DKG Key Deserialization Enables Weak Encryption Keys from Corrupted Storage

## Summary
The `to()` function in `enc.rs` and the deserialization paths for `DecryptPrivKey` and `PublicParameters` do not validate against zero scalars or identity group elements. If persistent storage corruption returns all-zero bytes or identity element encodings, validators will derive identity encryption keys, causing DKG transcript ciphertexts to be effectively unencrypted. An attacker observing on-chain transcripts can trivially extract shares and reconstruct the dealt secret key if threshold-weight validators are affected, compromising on-chain randomness.

## Finding Description

The DKG (Distributed Key Generation) system derives encryption keys from `DecryptPrivKey` using the `to()` function: [1](#0-0) 

This function computes `ek = g^{dk}` where `dk` is the decryption scalar. When `DecryptPrivKey` is deserialized from storage, it uses `scalar_from_bytes_le()`: [2](#0-1) 

This validation function **does not check for zero scalars**. The underlying `Scalar::from_bytes_le()` accepts zero as valid. Similarly, `DecryptPrivKey::try_from` only checks for valid scalar deserialization: [3](#0-2) 

Additionally, `PublicParameters` deserialization does not check for identity elements: [4](#0-3) 

**Attack Scenario:**
1. Storage corruption (disk failure, database bug, or malicious storage backend) returns zero bytes when loading a validator's consensus private key
2. The BLS private key converts to zero-scalar `DecryptPrivKey` via `maybe_dk_from_bls_sk()`: [5](#0-4) 

3. The `to()` function computes: `ek = g^0 = identity`
4. During DKG dealing, ciphertexts become: `C[k] = h^{share} * identity^{randomness} = h^{share}` (unencrypted): [6](#0-5) 

5. Transcript verification **does not catch identity encryption keys** - the multi-pairing check at verification passes because `e(identity, X) = 1`: [7](#0-6) 

6. Attacker extracts unencrypted shares `h^{share}` from on-chain transcript
7. With threshold-weight compromised validators, attacker reconstructs dealt secret key: [8](#0-7) 

8. Attacker predicts/manipulates on-chain randomness derived from this key: [9](#0-8) 

## Impact Explanation

**High Severity** per Aptos bug bounty criteria:
- Compromises cryptographic correctness invariant (breaks on-chain randomness security)
- Enables prediction/manipulation of randomness used in consensus, validator selection, and dApps
- Could lead to validator node slowdowns if randomness affects block production
- Represents a significant protocol violation (PVSS security guarantee broken)
- Does not require direct funds loss but enables secondary attacks on randomness-dependent systems

The impact is elevated because:
1. DKG dealt secrets are used for WVUF (Weighted VRF) evaluation in randomness generation
2. Compromised randomness affects consensus leader selection and on-chain randomness beacon
3. Multiple validators with corrupted storage amplifies the attack surface

## Likelihood Explanation

**Medium-Low Likelihood:**
- Requires storage corruption on threshold-weight of validators simultaneously
- Corruption must specifically result in zero-value bytes (not arbitrary corruption)
- Natural causes: disk failures, bit flips, database bugs affecting multiple nodes
- Malicious causes: compromised storage backends, insider attacks on validator infrastructure
- Not directly exploitable by external attackers without first compromising storage systems

However, the lack of validation is a clear defensive programming failure that amplifies the impact of any storage corruption scenario.

## Recommendation

Add explicit validation checks for zero scalars and identity elements:

**1. In `scalar_from_bytes_le()`, reject zero scalars:**
```rust
pub fn scalar_from_bytes_le(bytes: &[u8]) -> Result<Scalar, CryptoMaterialError> {
    let slice = match <&[u8; SCALAR_NUM_BYTES]>::try_from(bytes) {
        Ok(slice) => slice,
        Err(_) => return Err(CryptoMaterialError::WrongLengthError),
    };

    let opt = Scalar::from_bytes_le(slice);
    if opt.is_some().unwrap_u8() == 1u8 {
        let scalar = opt.unwrap();
        // Reject zero scalars for cryptographic keys
        if scalar == Scalar::ZERO {
            return Err(CryptoMaterialError::ValidationError);
        }
        Ok(scalar)
    } else {
        Err(CryptoMaterialError::DeserializationError)
    }
}
```

**2. In `PublicParameters::try_from()`, validate non-identity:**
```rust
impl TryFrom<&[u8]> for PublicParameters {
    type Error = CryptoMaterialError;

    fn try_from(bytes: &[u8]) -> std::result::Result<PublicParameters, Self::Error> {
        let g = $gt_proj_from_bytes(&bytes[0..$GT_PROJ_NUM_BYTES])?;
        let h = $gt_proj_from_bytes(&bytes[$GT_PROJ_NUM_BYTES..])?;

        // Validate g and h are not identity elements
        if g == $GTProjective::identity() || h == $GTProjective::identity() {
            return Err(CryptoMaterialError::ValidationError);
        }
        // Validate g and h are distinct
        if g == h {
            return Err(CryptoMaterialError::ValidationError);
        }

        Ok(PublicParameters { g, h })
    }
}
```

**3. Add validation in `maybe_dk_from_bls_sk()`:**
```rust
pub fn maybe_dk_from_bls_sk(
    sk: &PrivateKey,
) -> anyhow::Result<<WTrx as Transcript>::DecryptPrivKey> {
    let mut bytes = sk.to_bytes();
    bytes.reverse();
    let dk = <WTrx as Transcript>::DecryptPrivKey::try_from(bytes.as_slice())
        .map_err(|e| anyhow!("dk_from_bls_sk failed with dk deserialization error: {e}"))?;
    
    // Additional validation: ensure the scalar is non-zero
    if dk.dk == Scalar::ZERO {
        return Err(anyhow!("dk_from_bls_sk failed: zero scalar detected"));
    }
    
    Ok(dk)
}
```

## Proof of Concept

```rust
#[cfg(test)]
mod security_tests {
    use super::*;
    use blstrs::{G1Projective, Scalar};
    use ff::Field;

    #[test]
    #[should_panic(expected = "weak encryption key")]
    fn test_zero_scalar_produces_identity_encryption_key() {
        // Simulate corrupted storage returning zero bytes
        let zero_bytes = [0u8; 32];
        
        // This should fail but currently succeeds
        let dk = DecryptPrivKey::try_from(&zero_bytes[..])
            .expect("zero scalar accepted!");
        
        // Verify the scalar is actually zero
        assert_eq!(dk.dk, Scalar::ZERO);
        
        // Create public parameters
        let g = G1Projective::generator();
        let h = G1Projective::generator() * Scalar::from(2u64);
        let pp = PublicParameters::new(g, h);
        
        // Derive encryption key - produces identity!
        let ek = dk.to(&pp);
        
        // Verify encryption key is identity element
        let ek_as_point: G1Projective = (&ek).into();
        assert_eq!(ek_as_point, G1Projective::identity(), 
                   "weak encryption key: identity element produced!");
    }

    #[test]
    #[should_panic(expected = "identity public parameter")]
    fn test_identity_public_parameter_produces_weak_key() {
        // Simulate corrupted storage returning identity element bytes
        let identity_bytes = G1Projective::identity().to_compressed();
        let valid_bytes = G1Projective::generator().to_compressed();
        
        let mut pp_bytes = Vec::new();
        pp_bytes.extend_from_slice(&identity_bytes); // g = identity
        pp_bytes.extend_from_slice(&valid_bytes);    // h = generator
        
        // This should fail but currently succeeds
        let pp = PublicParameters::try_from(&pp_bytes[..])
            .expect("identity public parameter accepted!");
        
        // Any encryption key derived will be identity
        let dk = DecryptPrivKey::try_from(&[1u8; 32][..]).unwrap();
        let ek = dk.to(&pp);
        
        let ek_as_point: G1Projective = (&ek).into();
        assert_eq!(ek_as_point, G1Projective::identity(),
                   "identity public parameter leads to weak keys!");
    }
}
```

**Notes:**
- The vulnerability is in the DKG key derivation and validation paths
- Requires storage corruption affecting threshold validators to be exploitable
- Missing input validation amplifies storage corruption impact into cryptographic weakness
- Fix requires adding zero-value and identity element checks at deserialization boundaries
- This is a defense-in-depth issue classified as High severity per the security question scope

### Citations

**File:** crates/aptos-dkg/src/pvss/das/enc.rs (L11-17)
```rust
impl traits::Convert<EncryptPubKey, PublicParameters> for DecryptPrivKey {
    /// Given a decryption key $dk$, computes its associated encryption key $g_1^{dk}$
    fn to(&self, pp: &PublicParameters) -> EncryptPubKey {
        EncryptPubKey {
            ek: pp.pubkey_base().mul(self.dk),
        }
    }
```

**File:** crates/aptos-crypto/src/blstrs/mod.rs (L131-143)
```rust
pub fn scalar_from_bytes_le(bytes: &[u8]) -> Result<Scalar, CryptoMaterialError> {
    let slice = match <&[u8; SCALAR_NUM_BYTES]>::try_from(bytes) {
        Ok(slice) => slice,
        Err(_) => return Err(CryptoMaterialError::WrongLengthError),
    };

    let opt = Scalar::from_bytes_le(slice);
    if opt.is_some().unwrap_u8() == 1u8 {
        Ok(opt.unwrap())
    } else {
        Err(CryptoMaterialError::DeserializationError)
    }
}
```

**File:** crates/aptos-dkg/src/pvss/encryption_dlog.rs (L137-143)
```rust
        impl TryFrom<&[u8]> for DecryptPrivKey {
            type Error = CryptoMaterialError;

            fn try_from(bytes: &[u8]) -> std::result::Result<DecryptPrivKey, Self::Error> {
                scalar_from_bytes_le(bytes).map(|dk| DecryptPrivKey { dk })
            }
        }
```

**File:** crates/aptos-dkg/src/pvss/encryption_elgamal.rs (L70-79)
```rust
        impl TryFrom<&[u8]> for PublicParameters {
            type Error = CryptoMaterialError;

            fn try_from(bytes: &[u8]) -> std::result::Result<PublicParameters, Self::Error> {
                let g = $gt_proj_from_bytes(&bytes[0..$GT_PROJ_NUM_BYTES])?;
                let h = $gt_proj_from_bytes(&bytes[$GT_PROJ_NUM_BYTES..])?;

                Ok(PublicParameters { g, h })
            }
        }
```

**File:** types/src/dkg/real_dkg/mod.rs (L597-604)
```rust
pub fn maybe_dk_from_bls_sk(
    sk: &PrivateKey,
) -> anyhow::Result<<WTrx as Transcript>::DecryptPrivKey> {
    let mut bytes = sk.to_bytes(); // in big-endian
    bytes.reverse();
    <WTrx as Transcript>::DecryptPrivKey::try_from(bytes.as_slice())
        .map_err(|e| anyhow!("dk_from_bls_sk failed with dk deserialization error: {e}"))
}
```

**File:** crates/aptos-dkg/src/pvss/das/weighted_protocol.rs (L157-170)
```rust
        let mut C = Vec::with_capacity(W);
        for i in 0..n {
            let w_i = sc.get_player_weight(&sc.get_player(i));

            let bases = vec![h, Into::<G1Projective>::into(&eks[i])];
            for j in 0..w_i {
                let k = sc.get_share_index(i, j).unwrap();

                C.push(g1_multi_exp(
                    bases.as_slice(),
                    [f_evals[k], r[k]].as_slice(),
                ))
            }
        }
```

**File:** crates/aptos-dkg/src/pvss/das/weighted_protocol.rs (L360-376)
```rust
        let lhs = [g_1, &lc_VRC, h].into_iter().chain(&eks);
        // The vector of right-hand-side ($\mathbb{G}_2$) inputs to each pairing in the multi-pairing.
        let rhs = [&lc_VR_hat, &g_2_neg, &lc_V_hat]
            .into_iter()
            .chain(&lc_R_hat);

        let res = multi_pairing(lhs, rhs);
        if res != Gt::identity() {
            bail!(
                "Expected zero during multi-pairing check for {} {}, but got {}",
                sc,
                <Self as traits::Transcript>::scheme_name(),
                res
            );
        }

        return Ok(());
```

**File:** crates/aptos-dkg/src/pvss/dealt_secret_key.rs (L91-122)
```rust
            fn reconstruct(sc: &ThresholdConfigBlstrs, shares: &[ShamirShare<Self::ShareValue>]) -> anyhow::Result<Self> {
                assert_ge!(shares.len(), sc.get_threshold());
                assert_le!(shares.len(), sc.get_total_num_players());

                let ids = shares.iter().map(|(p, _)| p.id).collect::<Vec<usize>>();
                let lagr = lagrange_coefficients(
                    sc.get_batch_evaluation_domain(),
                    ids.as_slice(),
                    &Scalar::ZERO,
                );
                let bases = shares
                    .iter()
                    .map(|(_, share)| *share.as_group_element())
                    .collect::<Vec<$GTProjective>>();

                // println!();
                // println!("Lagrange IDs: {:?}", ids);
                // println!("Lagrange coeffs");
                // for l in lagr.iter() {
                // println!(" + {}", hex::encode(l.to_bytes_le()));
                // }
                // println!("Bases: ");
                // for b in bases.iter() {
                // println!(" + {}", hex::encode(b.to_bytes()));
                // }

                assert_eq!(lagr.len(), bases.len());

                Ok(DealtSecretKey {
                    h_hat: $gt_multi_exp(bases.as_slice(), lagr.as_slice()),
                })
            }
```

**File:** consensus/src/epoch_manager.rs (L1040-1100)
```rust
        let dkg_session = dkg_state
            .last_completed
            .ok_or_else(|| NoRandomnessReason::DKGCompletedSessionResourceMissing)?;
        if dkg_session.metadata.dealer_epoch + 1 != new_epoch_state.epoch {
            return Err(NoRandomnessReason::CompletedSessionTooOld);
        }
        let dkg_pub_params = DefaultDKG::new_public_params(&dkg_session.metadata);
        let my_index = new_epoch_state
            .verifier
            .address_to_validator_index()
            .get(&self.author)
            .copied()
            .ok_or_else(|| NoRandomnessReason::NotInValidatorSet)?;

        let dkg_decrypt_key = maybe_dk_from_bls_sk(consensus_key.as_ref())
            .map_err(NoRandomnessReason::ErrConvertingConsensusKeyToDecryptionKey)?;
        let transcript = bcs::from_bytes::<<DefaultDKG as DKGTrait>::Transcript>(
            dkg_session.transcript.as_slice(),
        )
        .map_err(NoRandomnessReason::TranscriptDeserializationError)?;

        let vuf_pp = WvufPP::from(&dkg_pub_params.pvss_config.pp);

        // No need to verify the transcript.

        // keys for randomness generation
        let (sk, pk) = DefaultDKG::decrypt_secret_share_from_transcript(
            &dkg_pub_params,
            &transcript,
            my_index as u64,
            &dkg_decrypt_key,
        )
        .map_err(NoRandomnessReason::SecretShareDecryptionFailed)?;

        let fast_randomness_is_enabled = onchain_randomness_config.fast_randomness_enabled()
            && sk.fast.is_some()
            && pk.fast.is_some()
            && transcript.fast.is_some()
            && dkg_pub_params.pvss_config.fast_wconfig.is_some();

        let pk_shares = (0..new_epoch_state.verifier.len())
            .map(|id| {
                transcript
                    .main
                    .get_public_key_share(&dkg_pub_params.pvss_config.wconfig, &Player { id })
            })
            .collect::<Vec<_>>();

        // Recover existing augmented key pair or generate a new one
        let (augmented_key_pair, fast_augmented_key_pair) = if let Some((_, key_pair)) = self
            .rand_storage
            .get_key_pair_bytes()
            .map_err(NoRandomnessReason::RandDbNotAvailable)?
            .filter(|(epoch, _)| *epoch == new_epoch)
        {
            info!(epoch = new_epoch, "Recovering existing augmented key");
            bcs::from_bytes(&key_pair).map_err(NoRandomnessReason::KeyPairDeserializationError)?
        } else {
            info!(
                epoch = new_epoch_state.epoch,
                "Generating a new augmented key"
```
