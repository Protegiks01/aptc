# Audit Report

## Title
SecretShare Constructor Missing Validation Enables Validator Node DoS via Panic

## Summary
The `SecretShare::new()` constructor in `types/src/secret_sharing.rs` accepts arbitrary author, metadata, and share values without cryptographic validation. This allows creation of malformed `SecretShare` objects that trigger panics in the verification path when the author field contains an address not in the current validator set, potentially causing denial-of-service against validator nodes processing secret sharing messages.

## Finding Description

The `SecretShare` struct represents a validator's contribution to threshold decryption in Aptos' encrypted transaction system. The constructor creates instances without validating cryptographic consistency: [1](#0-0) 

When these unvalidated shares are verified, the `verify()` method calls `config.get_id()` which uses `.expect()` that panics if the author is not in the validator set: [2](#0-1) 

The `get_id()` implementation contains the panic-inducing `.expect()`: [3](#0-2) 

An attacker can exploit this by sending `SecretShareMessage::Share` messages over the network with author fields containing addresses not in the current validator set. When the verification task processes these messages, it panics: [4](#0-3) 

The verification happens in bounded executor tasks (line 217). While the code checks `if msg.verify(...).is_ok()` at line 220, this only catches returned errors—not panics. Each malformed message spawns a task that panics, consuming executor resources.

Additionally, there's an acknowledged bounds-checking issue (TODO comment at line 78) where even if `get_id()` succeeds, direct array indexing into `verification_keys` could panic if indices are misaligned.

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos bug bounty program ("Validator node slowdowns", "Significant protocol violations"):

1. **Resource Exhaustion**: An attacker flooding malformed shares forces continuous task spawning and panicking, degrading bounded executor performance
2. **Processing Delays**: Legitimate secret shares may experience delayed processing, impacting encrypted transaction decryption
3. **Liveness Risk**: If nodes cannot aggregate sufficient shares within round deadlines due to executor saturation, they fail to decrypt transactions for that round, causing localized liveness failures
4. **Log Pollution**: Panic traces fill logs, obscuring legitimate operational issues

The vulnerability breaks the **Cryptographic Correctness** invariant by allowing cryptographically inconsistent objects to enter the system, and the **Resource Limits** invariant by enabling unbounded task spawning through malicious messages.

Comparison with secure implementations shows proper error handling exists elsewhere: [5](#0-4) 

The code at line 326 uses `.ok_or(VerifyError::UnknownAuthor)?` instead of `.expect()`, demonstrating the correct pattern.

## Likelihood Explanation

**Likelihood: High**

- **Attack Requirements**: Minimal—any network peer can send consensus messages to validators
- **Complexity**: Trivial—attacker simply crafts `SecretShare` with arbitrary author addresses
- **Detection Difficulty**: Panics may be logged but could be mistaken for transient network issues
- **Attack Cost**: Negligible—no stake or validator access required

The attack is easily automated and can target multiple validators simultaneously during critical rounds when encrypted transactions require decryption.

## Recommendation

Implement defensive validation at the constructor level and fix the unsafe error handling in `verify()`:

```rust
// In SecretShare::new()
pub fn new(
    author: Author, 
    metadata: SecretShareMetadata, 
    share: SecretKeyShare
) -> Self {
    // Validation should be done by caller or use a separate validated constructor
    Self {
        author,
        metadata,
        share,
    }
}

// Fix verify() to handle unknown authors gracefully
pub fn verify(&self, config: &SecretShareConfig) -> anyhow::Result<()> {
    let index = config.validator
        .address_to_validator_index()
        .get(self.author())
        .ok_or_else(|| anyhow::anyhow!("Author {} not in validator set", self.author()))?;
    
    // Also add bounds check as indicated by TODO
    if *index >= config.verification_keys.len() {
        bail!("Validator index {} exceeds verification_keys length {}", 
              index, config.verification_keys.len());
    }
    
    let decryption_key_share = self.share().clone();
    config.verification_keys[*index]
        .verify_decryption_key_share(&self.metadata.digest, &decryption_key_share)?;
    Ok(())
}
```

Alternatively, implement a validated constructor pattern:

```rust
impl SecretShare {
    pub fn new_unchecked(author: Author, metadata: SecretShareMetadata, share: SecretKeyShare) -> Self {
        Self { author, metadata, share }
    }
    
    pub fn new_validated(
        author: Author, 
        metadata: SecretShareMetadata, 
        share: SecretKeyShare,
        config: &SecretShareConfig
    ) -> anyhow::Result<Self> {
        let instance = Self::new_unchecked(author, metadata, share);
        instance.verify(config)?;
        Ok(instance)
    }
}
```

## Proof of Concept

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use aptos_types::account_address::AccountAddress;
    
    #[test]
    #[should_panic(expected = "Peer should be in the index!")]
    fn test_malformed_secret_share_panics_on_verify() {
        // Setup: Create a SecretShareConfig with a small validator set
        let validator_set = vec![
            AccountAddress::from_hex_literal("0x1").unwrap(),
            AccountAddress::from_hex_literal("0x2").unwrap(),
        ];
        
        // Create config with these validators
        // (Simplified - actual setup requires DKG keys)
        let config = create_test_config(validator_set);
        
        // Attack: Create SecretShare with author NOT in validator set
        let malicious_author = AccountAddress::from_hex_literal("0xDEADBEEF").unwrap();
        let metadata = SecretShareMetadata::default();
        let share = SecretKeyShare::default();
        
        let malformed_share = SecretShare::new(malicious_author, metadata, share);
        
        // This panics instead of returning an error!
        let result = malformed_share.verify(&config);
        // Expected: Should return Err, not panic
    }
    
    #[test]
    fn test_dos_scenario() {
        // Simulate attacker flooding verification tasks
        let malicious_shares = (0..1000).map(|i| {
            SecretShare::new(
                AccountAddress::from_hex_literal(&format!("0x{:x}", i + 0x1000)).unwrap(),
                SecretShareMetadata::default(),
                SecretKeyShare::default(),
            )
        }).collect::<Vec<_>>();
        
        // Each verification attempt would panic, exhausting executor
        // Legitimate shares would be delayed
    }
}
```

**Notes**

The vulnerability stems from violating the principle of "making invalid states unrepresentable" in the type system. The `SecretShare` constructor should enforce that only cryptographically valid shares can be constructed, or at minimum, the `verify()` method must handle all error cases without panicking. The current implementation creates a fragile security boundary where network-facing code must remember to validate, rather than the type system enforcing correctness.

The TODO comment at line 78 indicates this bounds-checking issue is known but unaddressed, suggesting this may be a longstanding technical debt item that has evolved into an exploitable vulnerability.

### Citations

**File:** types/src/secret_sharing.rs (L67-73)
```rust
    pub fn new(author: Author, metadata: SecretShareMetadata, share: SecretKeyShare) -> Self {
        Self {
            author,
            metadata,
            share,
        }
    }
```

**File:** types/src/secret_sharing.rs (L75-82)
```rust
    pub fn verify(&self, config: &SecretShareConfig) -> anyhow::Result<()> {
        let index = config.get_id(self.author());
        let decryption_key_share = self.share().clone();
        // TODO(ibalajiarun): Check index out of bounds
        config.verification_keys[index]
            .verify_decryption_key_share(&self.metadata.digest, &decryption_key_share)?;
        Ok(())
    }
```

**File:** types/src/secret_sharing.rs (L172-178)
```rust
    pub fn get_id(&self, peer: &Author) -> usize {
        *self
            .validator
            .address_to_validator_index()
            .get(peer)
            .expect("Peer should be in the index!")
    }
```

**File:** consensus/src/rand/secret_sharing/secret_share_manager.rs (L205-235)
```rust
    async fn verification_task(
        epoch_state: Arc<EpochState>,
        mut incoming_rpc_request: aptos_channel::Receiver<Author, IncomingSecretShareRequest>,
        verified_msg_tx: UnboundedSender<SecretShareRpc>,
        config: SecretShareConfig,
        bounded_executor: BoundedExecutor,
    ) {
        while let Some(dec_msg) = incoming_rpc_request.next().await {
            let tx = verified_msg_tx.clone();
            let epoch_state_clone = epoch_state.clone();
            let config_clone = config.clone();
            bounded_executor
                .spawn(async move {
                    match bcs::from_bytes::<SecretShareMessage>(dec_msg.req.data()) {
                        Ok(msg) => {
                            if msg.verify(&epoch_state_clone, &config_clone).is_ok() {
                                let _ = tx.unbounded_send(SecretShareRpc {
                                    msg,
                                    protocol: dec_msg.protocol,
                                    response_sender: dec_msg.response_sender,
                                });
                            }
                        },
                        Err(e) => {
                            warn!("Invalid dec message: {}", e);
                        },
                    }
                })
                .await;
        }
    }
```

**File:** types/src/validator_verifier.rs (L320-335)
```rust
        let mut sigs = vec![];
        let mut masks = BitVec::with_num_bits(self.len() as u16);
        for (addr, sig) in signatures {
            let index = *self
                .address_to_validator_index
                .get(addr)
                .ok_or(VerifyError::UnknownAuthor)?;
            masks.set(index as u16);
            sigs.push(sig.clone());
        }
        // Perform an optimistic aggregation of the signatures without verification.
        let aggregated_sig = bls12381::Signature::aggregate(sigs)
            .map_err(|_| VerifyError::FailedToAggregateSignature)?;

        Ok(AggregateSignature::new(masks, Some(aggregated_sig)))
    }
```
