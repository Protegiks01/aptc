# Audit Report

## Title
Transaction Filter Fail-Open Vulnerability Allows Complete Security Bypass via Non-Matching Transactions

## Summary
The `allows_transaction()` function in the transaction filtering system implements a fail-open design pattern that returns `true` (allow) by default when no filter rules match a transaction. This allows attackers to craft transactions that intentionally avoid matching any configured rules, completely bypassing mempool, API, and consensus security filters if operators do not explicitly add a catch-all deny/allow rule at the end of their rule list. [1](#0-0) 

## Finding Description

The transaction filter system is used throughout Aptos for security-critical filtering at multiple layers: mempool submission, API endpoints, and consensus block validation. The core vulnerability lies in the default behavior when no rules match. [2](#0-1) 

The critical flaw is on line 46, which returns `true` when no rules match, implementing a **fail-open** security model instead of **fail-closed**.

**Attack Scenario:**

1. An operator wants to implement a whitelist approach for a permissioned network
2. They configure allow rules: `TransactionFilter::empty().add_sender_filter(true, trusted_address_1).add_sender_filter(true, trusted_address_2)`
3. The operator expects only transactions from trusted addresses to be allowed
4. **However**, without adding `.add_all_filter(false)` at the end, ANY transaction from non-trusted addresses is allowed because it matches no rules and line 46 returns `true`
5. Attacker sends transactions from arbitrary addresses â†’ all bypass the filter

**Propagation Through System:**

In mempool, the filter is applied during transaction submission: [3](#0-2) 

The `filter_transactions` function calls `allows_transaction()`: [4](#0-3) 

If the transaction doesn't match any rules, it's allowed by default, bypassing intended security restrictions.

**Evidence from Test Code:**

All test configurations demonstrate that a catch-all rule is **required** for correct security behavior: [5](#0-4) 

Note line 265: `.add_all_filter(true)` is explicitly added. Without this, the filter would be insecure.

Similarly, the consensus filter configuration: [6](#0-5) 

And API filter tests: [7](#0-6) 

## Impact Explanation

**Severity: Critical** (up to $1,000,000)

This vulnerability enables:

1. **Complete Bypass of Transaction Validation Controls**: Attackers can bypass all configured transaction filters by crafting transactions that don't match any rules. This violates the Transaction Validation invariant that all transactions must pass security checks.

2. **Mempool Pollution**: Malicious transactions can enter the mempool despite filters intended to block them, leading to resource exhaustion and network degradation.

3. **Consensus Safety Implications**: If consensus filters are misconfigured, validators may accept blocks containing transactions that should be rejected, potentially causing consensus splits if different validators have different filter configurations.

4. **Operator Security Expectation Violation**: The non-obvious requirement to add catch-all rules creates a significant security gap. Operators naturally expect that configuring only allow rules creates an implicit deny-all for everything else (whitelist model), or that deny rules create an implicit allow-all for everything else (blacklist model). The current implementation violates these security expectations.

The vulnerability affects three critical layers:
- `mempool_filter` for transaction admission
- `consensus_filter` for block validation  
- `api_filter` for API endpoint protection [8](#0-7) 

## Likelihood Explanation

**Likelihood: High**

1. **Non-Obvious Security Requirement**: The requirement to add `.add_all_filter()` is not documented in the API or enforced by the type system. Operators configuring filters for the first time are highly likely to miss this requirement.

2. **Natural Security Model Mismatch**: Operators implementing whitelists naturally expect a default-deny model. The current default-allow behavior contradicts this expectation.

3. **Easy to Exploit**: Once a misconfigured filter is deployed, any attacker can trivially bypass it by sending transactions with properties that don't match the configured rules (e.g., using different sender addresses, different entry functions, etc.).

4. **Production Impact**: This affects production validator nodes, public fullnodes, and APIs that rely on transaction filtering for security or compliance requirements.

## Recommendation

**Immediate Fix: Change Default Behavior to Fail-Closed**

Modify `allows_transaction()` to return `false` (deny) by default when no rules match, implementing a secure-by-default fail-closed design:

```rust
pub fn allows_transaction(&self, signed_transaction: &SignedTransaction) -> bool {
    // If the filter is empty, allow the transaction by default
    if self.is_empty() {
        return true;
    }

    // Check if any rule matches the transaction
    for transaction_rule in &self.transaction_rules {
        if transaction_rule.matches(signed_transaction) {
            return match transaction_rule {
                TransactionRule::Allow(_) => true,
                TransactionRule::Deny(_) => false,
            };
        }
    }

    // SECURITY FIX: Deny by default when rules exist but none match
    // This enforces explicit allow/deny decisions
    false // Changed from true
}
```

**Alternative: Add Validation**

If backward compatibility is required, add a validation function that warns or errors when a filter lacks a catch-all rule:

```rust
pub fn validate_filter_security(&self) -> Result<(), String> {
    if self.is_empty() {
        return Ok(());
    }
    
    // Check if the last rule is a catch-all
    if let Some(last_rule) = self.transaction_rules.last() {
        let matchers = match last_rule {
            TransactionRule::Allow(m) | TransactionRule::Deny(m) => m,
        };
        
        if matchers.len() == 1 && matches!(matchers[0], TransactionMatcher::All) {
            return Ok(());
        }
    }
    
    Err("WARNING: Filter lacks a catch-all rule. Add .add_all_filter(true/false) to make security policy explicit.".to_string())
}
```

## Proof of Concept

```rust
#[test]
fn test_whitelist_bypass_vulnerability() {
    use aptos_transaction_filters::transaction_filter::TransactionFilter;
    use aptos_types::transaction::SignedTransaction;
    
    // Create a whitelist filter allowing only address_1
    let trusted_address = AccountAddress::random();
    let attacker_address = AccountAddress::random();
    
    // VULNERABLE: Operator creates whitelist without catch-all deny
    let vulnerable_filter = TransactionFilter::empty()
        .add_sender_filter(true, trusted_address);
    // Missing: .add_all_filter(false)
    
    // Create transaction from trusted address - should be allowed
    let trusted_txn = create_signed_transaction_from(trusted_address);
    assert!(vulnerable_filter.allows_transaction(&trusted_txn));
    
    // Create transaction from attacker address - SHOULD BE DENIED but is ALLOWED!
    let attacker_txn = create_signed_transaction_from(attacker_address);
    assert!(vulnerable_filter.allows_transaction(&attacker_txn)); // BUG: Returns true!
    
    println!("VULNERABILITY CONFIRMED: Attacker transaction bypassed whitelist filter");
    
    // SECURE: Proper whitelist with catch-all deny
    let secure_filter = TransactionFilter::empty()
        .add_sender_filter(true, trusted_address)
        .add_all_filter(false); // Deny everything else
    
    assert!(secure_filter.allows_transaction(&trusted_txn));
    assert!(!secure_filter.allows_transaction(&attacker_txn)); // Correctly denied
}

fn create_signed_transaction_from(sender: AccountAddress) -> SignedTransaction {
    // Create a minimal transaction for testing
    use aptos_crypto::ed25519::Ed25519PrivateKey;
    use aptos_crypto::{PrivateKey, Uniform};
    use aptos_types::chain_id::ChainId;
    use aptos_types::transaction::{RawTransaction, Script, TransactionPayload};
    
    let private_key = Ed25519PrivateKey::generate_for_testing();
    let raw_txn = RawTransaction::new(
        sender,
        0,
        TransactionPayload::Script(Script::new(vec![], vec![], vec![])),
        0,
        0,
        0,
        ChainId::new(1),
    );
    
    SignedTransaction::new(
        raw_txn,
        private_key.public_key(),
        private_key.sign(&raw_txn).unwrap(),
    )
}
```

This PoC demonstrates that a whitelist filter without a catch-all deny rule allows transactions from any non-whitelisted address to bypass the filter, confirming the vulnerability.

## Notes

The vulnerability is particularly insidious because:

1. **Silent Failure**: There are no warnings or errors when deploying a misconfigured filter
2. **Test Coverage Masks Issue**: All existing tests include catch-all rules, hiding the underlying design flaw
3. **Security vs. Usability Trade-off**: The current default-allow behavior may have been chosen for usability, but it violates security best practices
4. **Wide Impact**: Affects mempool, consensus, and API layers across the entire Aptos network

The fix should be carefully deployed with adequate migration support for existing filter configurations, as changing the default behavior is a breaking change that could affect deployed validators and fullnodes.

### Citations

**File:** crates/aptos-transaction-filters/src/transaction_filter.rs (L14-18)
```rust
/// if a transaction should be allowed or denied.
///
/// Rules are applied in the order they are defined, and the first
/// matching rule determines the outcome for the transaction.
/// If no rules match, the transaction is allowed by default.
```

**File:** crates/aptos-transaction-filters/src/transaction_filter.rs (L30-47)
```rust
    pub fn allows_transaction(&self, signed_transaction: &SignedTransaction) -> bool {
        // If the filter is empty, allow the transaction by default
        if self.is_empty() {
            return true;
        }

        // Check if any rule matches the transaction
        for transaction_rule in &self.transaction_rules {
            if transaction_rule.matches(signed_transaction) {
                return match transaction_rule {
                    TransactionRule::Allow(_) => true,
                    TransactionRule::Deny(_) => false,
                };
            }
        }

        true // No rules match (allow the transaction by default)
    }
```

**File:** mempool/src/shared_mempool/tasks.rs (L318-326)
```rust
    // Filter out any disallowed transactions
    let mut statuses = vec![];
    let transactions =
        filter_transactions(&smp.transaction_filter_config, transactions, &mut statuses);

    // If there are no transactions left after filtering, return early
    if transactions.is_empty() {
        return statuses;
    }
```

**File:** mempool/src/shared_mempool/tasks.rs (L434-439)
```rust
        .filter_map(|(transaction, account_sequence_number, priority)| {
            if transaction_filter_config
                .transaction_filter()
                .allows_transaction(&transaction)
            {
                Some((transaction, account_sequence_number, priority))
```

**File:** testsuite/smoke-test/src/transaction_filter.rs (L246-258)
```rust
/// Adds a filter to the consensus config to ignore transactions from the given sender
fn filter_inline_transactions(node_config: &mut NodeConfig, sender_address: AccountAddress) {
    // Create the block transaction filter
    let block_transaction_filter = BlockTransactionFilter::empty()
        .add_multiple_matchers_filter(false, vec![BlockTransactionMatcher::Transaction(
            TransactionMatcher::Sender(sender_address),
        )])
        .add_all_filter(true);

    // Update the node config with the new filter
    node_config.transaction_filters.consensus_filter =
        BlockTransactionFilterConfig::new(true, block_transaction_filter);
}
```

**File:** testsuite/smoke-test/src/transaction_filter.rs (L260-270)
```rust
/// Adds a filter to the mempool config to ignore transactions from the given sender
fn filter_mempool_transactions(node_config: &mut NodeConfig, sender_address: AccountAddress) {
    // Create the transaction filter
    let transaction_filter = TransactionFilter::empty()
        .add_multiple_matchers_filter(false, vec![TransactionMatcher::Sender(sender_address)])
        .add_all_filter(true);

    // Update the node config with the new filter
    node_config.transaction_filters.mempool_filter =
        TransactionFilterConfig::new(true, transaction_filter);
}
```

**File:** api/src/tests/transactions_test.rs (L2757-2762)
```rust
    // Allow the root sender only.
    let transaction_filter = TransactionFilter::empty()
        .add_sender_filter(true, aptos_test_root_address())
        .add_all_filter(false);
    let transaction_filter_config = TransactionFilterConfig::new(true, transaction_filter);
    node_config.transaction_filters.api_filter = transaction_filter_config;
```

**File:** config/src/config/transaction_filters_config.rs (L10-18)
```rust
#[derive(Clone, Debug, Default, Deserialize, PartialEq, Eq, Serialize)]
#[serde(default, deny_unknown_fields)]
pub struct TransactionFiltersConfig {
    pub api_filter: TransactionFilterConfig, // Filter for the API (e.g., txn simulation)
    pub consensus_filter: BlockTransactionFilterConfig, // Filter for consensus (e.g., proposal voting)
    pub execution_filter: BlockTransactionFilterConfig, // Filter for execution (e.g., block execution)
    pub mempool_filter: TransactionFilterConfig,        // Filter for mempool (e.g., txn submission)
    pub quorum_store_filter: BatchTransactionFilterConfig, // Filter for quorum store (e.g., batch voting)
}
```
