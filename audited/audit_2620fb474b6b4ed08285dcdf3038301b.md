# Audit Report

## Title
Unverified Quorum Certificates in Block Synchronization Enable Consensus Safety Violations

## Summary
During block synchronization (fast-forward sync and fetch operations), Quorum Certificates (QCs) embedded in retrieved blocks are not cryptographically verified before being used in the execution pipeline. An attacker can inject blocks containing malicious QCs with fabricated voter information, causing different nodes to select different transaction sets and execute different state transitions, violating consensus safety.

## Finding Description

The vulnerability exists in the block synchronization flow where blocks retrieved from network peers are verified, but the Quorum Certificates embedded within those blocks are not.

**Attack Flow:**

1. **Block Retrieval Without QC Verification**: When a node syncs via `fast_forward_sync()` or `fetch_quorum_cert()`, it retrieves blocks from network peers. The `BlockRetrievalResponse::verify()` method validates block signatures and well-formedness but does NOT verify the QCs embedded in those blocks. [1](#0-0) 

2. **Block Well-Formedness Lacks QC Signature Validation**: The `Block::verify_well_formed()` method only checks structural properties (round ordering, epoch consistency) but does not verify QC signatures. [2](#0-1) 

3. **QC Extraction During Sync**: In `fast_forward_sync()`, QCs are extracted directly from retrieved blocks without verification and added to the quorum_certs list. [3](#0-2) 

4. **Unverified QC Insertion**: The extracted QCs are passed to `rebuild()` which calls `insert_single_quorum_cert()`. This function only validates that the QC's certified block matches the local block infoâ€”it does NOT verify signatures. [4](#0-3) 

5. **QC Sent to Pipeline**: `insert_single_quorum_cert()` calls `pipelined_block.set_qc()` which sends the unverified QC through a channel to the execution pipeline. [5](#0-4) 

6. **Unvalidated QC Usage**: In `materialize_block()`, the QC is received and its voter bitvec is extracted without any validation. [6](#0-5) 

7. **Transaction Selection Manipulation**: The voter information from the malicious QC is passed to `payload_manager.get_transactions()`. For OptQuorumStore payloads, this determines which peers to request transaction batches from. [7](#0-6) 

8. **Peer Selection Based on Fake Voters**: The `process_optqs_payload()` function uses the voter bitvec to build a list of signers to request batches from, allowing the attacker to control which transaction sources are used. [8](#0-7) 

**Attack Scenario:**
- Attacker controls a malicious peer or validator
- During synchronization, honest node requests blocks
- Attacker responds with valid blocks (correct signatures) but embeds malicious QCs with fabricated voter bitvecsThe honest node accepts these blocks because they pass signature verification
- The malicious QCs are extracted and used without cryptographic verification
- Different nodes receiving different malicious QCs will request transactions from different peers
- Nodes execute different transaction sets, producing different state roots
- **Consensus safety is violated**: nodes disagree on the canonical chain state

## Impact Explanation

**Severity: CRITICAL** (up to $1,000,000 per Aptos Bug Bounty)

This vulnerability constitutes a **Consensus Safety Violation**, which falls under the Critical severity category. Specifically:

1. **Breaks Deterministic Execution Invariant**: The fundamental invariant that "all validators must produce identical state roots for identical blocks" is violated because different validators can be tricked into executing different transaction sets for the same block.

2. **Enables Chain Splits**: When different nodes execute different transactions, they produce different state roots. This can cause the network to fork, with different validators following different chains.

3. **No Byzantine Threshold Required**: The attack does not require 1/3 Byzantine validators. A single malicious peer during synchronization can inject malicious QCs that propagate through the system.

4. **Non-Recoverable Without Hard Fork**: Once nodes have diverged in their state due to executing different transactions, reconciliation requires manual intervention and potentially a hard fork to reset the canonical chain.

## Likelihood Explanation

**Likelihood: HIGH**

1. **Common Trigger Condition**: Block synchronization occurs regularly when:
   - New nodes join the network
   - Nodes fall behind and need to catch up
   - State sync operations are triggered
   - Fast-forward sync is initiated

2. **Low Attacker Requirements**: 
   - Attacker only needs to be a network peer (not necessarily a validator)
   - No cryptographic key compromise required
   - No complex timing or race conditions to exploit

3. **Readily Exploitable**: 
   - Attack can be executed by simply responding to block retrieval requests with crafted blocks
   - No special privileges needed beyond network connectivity
   - Malicious QCs can be pre-generated offline

4. **Detection Difficulty**: The malicious QCs appear structurally valid (correct block IDs, plausible round numbers) and only fail on cryptographic signature verification, which is not performed in the vulnerable path.

## Recommendation

**Immediate Fix**: Add cryptographic verification of QCs before they are used in the execution pipeline.

**Implementation:**

1. **Verify QCs During Block Retrieval**: Extend `BlockRetrievalResponse::verify()` to verify not just blocks but also their embedded QCs:

```rust
pub fn verify(
    &self,
    retrieval_request: BlockRetrievalRequest,
    sig_verifier: &ValidatorVerifier,
) -> anyhow::Result<()> {
    self.verify_inner(&retrieval_request)?;

    self.blocks
        .iter()
        .try_fold(retrieval_request.block_id(), |expected_id, block| {
            block.validate_signature(sig_verifier)?;
            block.verify_well_formed()?;
            
            // ADD THIS: Verify the QC embedded in each block
            block.quorum_cert().verify(sig_verifier)
                .context("Failed to verify QC embedded in retrieved block")?;
            
            ensure!(
                block.id() == expected_id,
                "blocks doesn't form a chain: expect {}, get {}",
                expected_id,
                block.id()
            );
            Ok(block.parent_id())
        })
        .map(|_| ())
}
```

2. **Add QC Verification in insert_single_quorum_cert**: As defense-in-depth, verify QCs at insertion time:

```rust
pub fn insert_single_quorum_cert(&self, qc: QuorumCert) -> anyhow::Result<()> {
    // ADD THIS: Verify QC signatures before insertion
    qc.verify(&self.epoch_state().verifier)
        .context("QC verification failed in insert_single_quorum_cert")?;
    
    match self.get_block(qc.certified_block().id()) {
        // ... rest of existing code
    }
}
```

3. **Verify QCs in fast_forward_sync**: Add explicit verification after extracting QCs from blocks:

```rust
// After extracting QCs at line 411 in sync_manager.rs
for qc in &quorum_certs {
    qc.verify(retriever.validator_verifier())
        .with_context(|| format!("Failed to verify QC for block {}", qc.certified_block().id()))?;
}
```

## Proof of Concept

```rust
// PoC demonstrating the vulnerability
// This would be added as a test in consensus/src/block_storage/sync_manager_test.rs

#[tokio::test]
async fn test_malicious_qc_injection() {
    // Setup: Create test validator set and block store
    let (signers, validator_verifier) = random_validator_verifier(4, None, false);
    let block_store = setup_block_store(...);
    
    // Step 1: Attacker creates a valid block with correct signature
    let valid_block = test_utils::build_empty_block(&signers[0], 1, None);
    
    // Step 2: Attacker creates a MALICIOUS QC with fabricated voters
    let malicious_voters = BitVec::from_iter(vec![true, true, false, false]); // Fake voter set
    let malicious_qc = QuorumCert::new(
        VoteData::new(...),
        LedgerInfoWithSignatures::new(
            LedgerInfo::new(...),
            AggregateSignature::new(malicious_voters, None) // Invalid signatures!
        )
    );
    
    // Step 3: Create block with malicious QC embedded
    let block_with_malicious_qc = Block::new_proposal(
        Payload::empty(),
        1,
        unix_timestamp_now(),
        malicious_qc, // Unverified QC injected here
        &signers[0]
    );
    
    // Step 4: Block passes verification (only block signature checked)
    let response = BlockRetrievalResponse::new(
        BlockRetrievalStatus::Succeeded,
        vec![block_with_malicious_qc]
    );
    assert!(response.verify(...).is_ok()); // Block itself is valid!
    
    // Step 5: QC is extracted without verification
    let extracted_qc = block_with_malicious_qc.quorum_cert().clone();
    
    // Step 6: Malicious QC is inserted (no signature verification!)
    block_store.insert_single_quorum_cert(extracted_qc.clone()).unwrap();
    
    // Step 7: Verify the malicious QC would FAIL signature verification if checked
    assert!(extracted_qc.verify(&validator_verifier).is_err());
    
    // Step 8: But it was already accepted and sent to pipeline!
    // This demonstrates the vulnerability: unverified QC is now in the system
    let pipelined_block = block_store.get_block(block_with_malicious_qc.id()).unwrap();
    assert!(pipelined_block.qc().is_some()); // Malicious QC is available
    
    // Step 9: Show that different fabricated voter sets lead to different transaction selection
    let voter_bitvec = extracted_qc.ledger_info().get_voters_bitvec();
    // This bitvec will cause different transaction sources to be queried
    // leading to potential consensus disagreement
}
```

## Notes

The vulnerability is particularly insidious because:

1. **Verification Exists But Isn't Used**: The codebase contains `QuorumCert::verify()` method that properly validates signatures, but it's not called in the sync paths. [9](#0-8) 

2. **Misleading Comments**: The `insert_single_quorum_cert()` function has a comment saying "Validates quorum certificates" but only performs structural validation, not cryptographic verification.

3. **Multiple Vulnerable Paths**: Both `fast_forward_sync()` and `fetch_quorum_cert()` have this vulnerability, increasing the attack surface.

4. **Trust Assumption Violation**: The code implicitly trusts that QCs embedded in verified blocks are valid, but blocks can be signed by one validator while containing QCs fabricated by an attacker.

### Citations

**File:** consensus/consensus-types/src/block_retrieval.rs (L260-281)
```rust
    pub fn verify(
        &self,
        retrieval_request: BlockRetrievalRequest,
        sig_verifier: &ValidatorVerifier,
    ) -> anyhow::Result<()> {
        self.verify_inner(&retrieval_request)?;

        self.blocks
            .iter()
            .try_fold(retrieval_request.block_id(), |expected_id, block| {
                block.validate_signature(sig_verifier)?;
                block.verify_well_formed()?;
                ensure!(
                    block.id() == expected_id,
                    "blocks doesn't form a chain: expect {}, get {}",
                    expected_id,
                    block.id()
                );
                Ok(block.parent_id())
            })
            .map(|_| ())
    }
```

**File:** consensus/consensus-types/src/block.rs (L469-520)
```rust
    pub fn verify_well_formed(&self) -> anyhow::Result<()> {
        ensure!(
            !self.is_genesis_block(),
            "We must not accept genesis from others"
        );
        let parent = self.quorum_cert().certified_block();
        ensure!(
            parent.round() < self.round(),
            "Block must have a greater round than parent's block"
        );
        ensure!(
            parent.epoch() == self.epoch(),
            "block's parent should be in the same epoch"
        );
        if parent.has_reconfiguration() {
            ensure!(
                self.payload().is_none_or(|p| p.is_empty()),
                "Reconfiguration suffix should not carry payload"
            );
        }

        if let Some(payload) = self.payload() {
            payload.verify_epoch(self.epoch())?;
        }

        if let Some(failed_authors) = self.block_data().failed_authors() {
            // when validating for being well formed,
            // allow for missing failed authors,
            // for whatever reason (from different max configuration, etc),
            // but don't allow anything that shouldn't be there.
            //
            // we validate the full correctness of this field in round_manager.process_proposal()
            let succ_round = self.round() + u64::from(self.is_nil_block());
            let skipped_rounds = succ_round.checked_sub(parent.round() + 1);
            ensure!(
                skipped_rounds.is_some(),
                "Block round is smaller than block's parent round"
            );
            ensure!(
                failed_authors.len() <= skipped_rounds.unwrap() as usize,
                "Block has more failed authors than missed rounds"
            );
            let mut bound = parent.round();
            for (round, _) in failed_authors {
                ensure!(
                    bound < *round && *round < succ_round,
                    "Incorrect round in failed authors"
                );
                bound = *round;
            }
        }

```

**File:** consensus/src/block_storage/sync_manager.rs (L405-411)
```rust
        let mut quorum_certs = vec![highest_quorum_cert.clone()];
        quorum_certs.extend(
            blocks
                .iter()
                .take(blocks.len() - 1)
                .map(|block| block.quorum_cert().clone()),
        );
```

**File:** consensus/src/block_storage/block_store.rs (L519-556)
```rust
    pub fn insert_single_quorum_cert(&self, qc: QuorumCert) -> anyhow::Result<()> {
        // If the parent block is not the root block (i.e not None), ensure the executed state
        // of a block is consistent with its QuorumCert, otherwise persist the QuorumCert's
        // state and on restart, a new execution will agree with it.  A new execution will match
        // the QuorumCert's state on the next restart will work if there is a memory
        // corruption, for example.
        match self.get_block(qc.certified_block().id()) {
            Some(pipelined_block) => {
                ensure!(
                    // decoupled execution allows dummy block infos
                    pipelined_block
                        .block_info()
                        .match_ordered_only(qc.certified_block()),
                    "QC for block {} has different {:?} than local {:?}",
                    qc.certified_block().id(),
                    qc.certified_block(),
                    pipelined_block.block_info()
                );
                observe_block(
                    pipelined_block.block().timestamp_usecs(),
                    BlockStage::QC_ADDED,
                );
                if pipelined_block.block().is_opt_block() {
                    observe_block(
                        pipelined_block.block().timestamp_usecs(),
                        BlockStage::QC_ADDED_OPT_BLOCK,
                    );
                }
                pipelined_block.set_qc(Arc::new(qc.clone()));
            },
            None => bail!("Insert {} without having the block in store first", qc),
        };

        self.storage
            .save_tree(vec![], vec![qc.clone()])
            .context("Insert block failed when saving quorum")?;
        self.inner.write().insert_quorum_cert(qc)
    }
```

**File:** consensus/consensus-types/src/pipelined_block.rs (L340-345)
```rust
    pub fn set_qc(&self, qc: Arc<QuorumCert>) {
        *self.block_qc.lock() = Some(qc.clone());
        if let Some(tx) = self.pipeline_tx().lock().as_mut() {
            tx.qc_tx.take().map(|tx| tx.send(qc));
        }
    }
```

**File:** consensus/src/block_preparer.rs (L54-63)
```rust
        let (txns, max_txns_from_block_to_execute, block_gas_limit) = tokio::select! {
                // Poll the block qc future until a QC is received. Ignore None outcomes.
                Some(qc) = block_qc_fut => {
                    let block_voters = Some(qc.ledger_info().get_voters_bitvec().clone());
                    self.payload_manager.get_transactions(block, block_voters).await
                },
                result = self.payload_manager.get_transactions(block, None) => {
                   result
                }
        }?;
```

**File:** consensus/src/payload_manager/quorum_store_payload_manager.rs (L512-518)
```rust
                let opt_batch_txns = process_optqs_payload(
                    opt_qs_payload.opt_batches(),
                    self.batch_reader.clone(),
                    block,
                    &self.ordered_authors,
                    block_signers.as_ref(),
                )
```

**File:** consensus/src/payload_manager/quorum_store_payload_manager.rs (L609-615)
```rust
    if let Some(peers) = additional_peers_to_request {
        for i in peers.iter_ones() {
            if let Some(author) = ordered_authors.get(i) {
                signers.push(*author);
            }
        }
    }
```

**File:** consensus/consensus-types/src/quorum_cert.rs (L119-148)
```rust
    pub fn verify(&self, validator: &ValidatorVerifier) -> anyhow::Result<()> {
        let vote_hash = self.vote_data.hash();
        ensure!(
            self.ledger_info().ledger_info().consensus_data_hash() == vote_hash,
            "Quorum Cert's hash mismatch LedgerInfo"
        );
        // Genesis's QC is implicitly agreed upon, it doesn't have real signatures.
        // If someone sends us a QC on a fake genesis, it'll fail to insert into BlockStore
        // because of the round constraint.
        if self.certified_block().round() == 0 {
            ensure!(
                self.parent_block() == self.certified_block(),
                "Genesis QC has inconsistent parent block with certified block"
            );
            ensure!(
                self.certified_block() == self.ledger_info().ledger_info().commit_info(),
                "Genesis QC has inconsistent commit block with certified block"
            );
            ensure!(
                self.ledger_info().get_num_voters() == 0,
                "Genesis QC should not carry signatures"
            );
            return Ok(());
        }
        self.ledger_info()
            .verify_signatures(validator)
            .context("Fail to verify QuorumCert")?;
        self.vote_data.verify()?;
        Ok(())
    }
```
