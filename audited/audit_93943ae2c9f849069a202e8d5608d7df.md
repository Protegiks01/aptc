# Audit Report

## Title
Consensus Publisher Panic on Zero Garbage Collection Interval Causes Complete Node Crash

## Summary
The `garbage_collection_interval_ms` configuration field in `ConsensusObserverConfig` lacks validation to prevent zero values. When set to zero, the consensus publisher panics during initialization when creating a `tokio::time::interval`, causing the crash handler to terminate the entire node process with exit code 12. This affects validators and validator fullnodes, creating a severe availability issue.

## Finding Description
The consensus publisher's `start()` function creates a garbage collection ticker using `tokio::time::interval()`. [1](#0-0) 

When `garbage_collection_interval_ms` is set to zero in the configuration, `Duration::from_millis(0)` creates a zero duration. According to Tokio's contract and the codebase's own interval implementation, creating an interval with zero duration panics. [2](#0-1) 

The `ConsensusObserverConfig` structure defines `garbage_collection_interval_ms` with a default of 60,000 milliseconds but provides no validation: [3](#0-2) 

The configuration system's `ConfigSanitizer` trait is used to validate node configurations, but `ConsensusObserverConfig` is notably absent from the sanitization checks: [4](#0-3) 

When the consensus publisher starts, it is spawned as a tokio task in the publisher runtime: [5](#0-4) 

If the interval creation panics, the crash handler intercepts it and terminates the entire process: [6](#0-5) 

## Impact Explanation
This qualifies as **High Severity** per the Aptos bug bounty criteria for "Validator node crashes." The impact includes:

1. **Complete Node Termination**: The panic causes the crash handler to exit the entire node process, not just the publisher component
2. **Validator Impact**: Consensus publishers are enabled by default on validators and validator fullnodes, meaning this affects consensus-participating nodes
3. **Network Availability**: If multiple validators crash due to misconfiguration, network liveness degrades
4. **No Graceful Recovery**: The node requires manual restart with corrected configuration

The configuration is enabled for validators by the optimizer: [7](#0-6) 

## Likelihood Explanation
**Moderate to High Likelihood**:

1. **Accidental Misconfiguration**: Typos, missing digits, or copy-paste errors when editing YAML configuration files could easily result in `garbage_collection_interval_ms: 0`
2. **No Validation Layer**: The complete absence of validation means this error is not caught at configuration load time or sanitization
3. **Delayed Detection**: The panic only occurs when the publisher starts, which happens during node initialization after configuration has been loaded
4. **Operational Context**: Node operators frequently adjust configurations for tuning, increasing exposure to configuration errors

The issue is less likely to be intentionally exploited since it requires configuration file access, but the lack of validation makes accidental occurrences realistic.

## Recommendation
Implement `ConfigSanitizer` for `ConsensusObserverConfig` to validate all interval fields are non-zero:

```rust
impl ConfigSanitizer for ConsensusObserverConfig {
    fn sanitize(
        node_config: &NodeConfig,
        _node_type: NodeType,
        _chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();
        let config = &node_config.consensus_observer;
        
        // Validate garbage collection interval is non-zero
        if config.garbage_collection_interval_ms == 0 {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "garbage_collection_interval_ms must be greater than zero".into(),
            ));
        }
        
        // Validate progress check interval is non-zero
        if config.progress_check_interval_ms == 0 {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "progress_check_interval_ms must be greater than zero".into(),
            ));
        }
        
        // Validate other interval fields...
        
        Ok(())
    }
}
```

Add the sanitizer call to `NodeConfig::sanitize()`:
```rust
ConsensusObserverConfig::sanitize(node_config, node_type, chain_id)?;
```

## Proof of Concept
```rust
#[tokio::test]
#[should_panic(expected = "duration must not be zero")]
async fn test_zero_garbage_collection_interval_panics() {
    use aptos_config::config::ConsensusObserverConfig;
    use aptos_network::{
        application::storage::PeersAndMetadata,
        protocols::network::NetworkClient,
    };
    use aptos_config::network_id::NetworkId;
    use maplit::hashmap;
    use std::sync::Arc;
    
    // Create a config with zero garbage collection interval
    let mut config = ConsensusObserverConfig::default();
    config.garbage_collection_interval_ms = 0;
    
    // Create network dependencies
    let network_id = NetworkId::Public;
    let peers_and_metadata = PeersAndMetadata::new(&[network_id]);
    let network_client = NetworkClient::new(
        vec![], vec![], hashmap![], peers_and_metadata
    );
    let consensus_observer_client = Arc::new(
        ConsensusObserverClient::new(network_client)
    );
    
    // Create publisher with zero interval config
    let (consensus_publisher, outbound_rx) = 
        ConsensusPublisher::new(config, consensus_observer_client);
    
    // Create dummy receiver
    let (_, publisher_rx) = aptos_channels::aptos_channel::new(
        aptos_channels::message_queues::QueueStyle::FIFO, 
        10, 
        None
    );
    
    // This will panic when creating the interval with Duration::ZERO
    consensus_publisher.start(outbound_rx, publisher_rx).await;
}
```

**Notes**
This vulnerability demonstrates a critical gap in configuration validation. While the default value is safe (60 seconds), the lack of sanitization allows dangerous misconfigurations to crash production validator nodes. The fix is straightforward: implement `ConfigSanitizer` for `ConsensusObserverConfig` to validate all interval durations are non-zero before the node attempts to start these components. This pattern should also be applied to other configuration structures with similar interval fields (e.g., `MempoolConfig::system_transaction_gc_interval_ms`).

### Citations

**File:** consensus/src/consensus_observer/publisher/consensus_publisher.rs (L247-252)
```rust
        // Create a garbage collection ticker
        let mut garbage_collection_interval = IntervalStream::new(interval(Duration::from_millis(
            self.consensus_observer_config
                .garbage_collection_interval_ms,
        )))
        .fuse();
```

**File:** crates/aptos-time-service/src/interval.rs (L30-34)
```rust
    pub fn new(delay: Sleep, period: Duration) -> Self {
        assert!(period > ZERO_DURATION, "`period` must be non-zero.");

        Self { delay, period }
    }
```

**File:** config/src/config/consensus_observer_config.rs (L34-35)
```rust
    /// Interval (in milliseconds) to garbage collect peer state
    pub garbage_collection_interval_ms: u64,
```

**File:** config/src/config/consensus_observer_config.rs (L112-117)
```rust
            NodeType::Validator => {
                if ENABLE_ON_VALIDATORS && !publisher_manually_set {
                    // Only enable the publisher for validators
                    consensus_observer_config.publisher_enabled = true;
                    modified_config = true;
                }
```

**File:** config/src/config/config_sanitizer.rs (L50-68)
```rust
        // Sanitize all of the sub-configs
        AdminServiceConfig::sanitize(node_config, node_type, chain_id)?;
        ApiConfig::sanitize(node_config, node_type, chain_id)?;
        BaseConfig::sanitize(node_config, node_type, chain_id)?;
        ConsensusConfig::sanitize(node_config, node_type, chain_id)?;
        DagConsensusConfig::sanitize(node_config, node_type, chain_id)?;
        ExecutionConfig::sanitize(node_config, node_type, chain_id)?;
        sanitize_failpoints_config(node_config, node_type, chain_id)?;
        sanitize_fullnode_network_configs(node_config, node_type, chain_id)?;
        IndexerGrpcConfig::sanitize(node_config, node_type, chain_id)?;
        InspectionServiceConfig::sanitize(node_config, node_type, chain_id)?;
        LoggerConfig::sanitize(node_config, node_type, chain_id)?;
        MempoolConfig::sanitize(node_config, node_type, chain_id)?;
        NetbenchConfig::sanitize(node_config, node_type, chain_id)?;
        StateSyncConfig::sanitize(node_config, node_type, chain_id)?;
        StorageConfig::sanitize(node_config, node_type, chain_id)?;
        InternalIndexerDBConfig::sanitize(node_config, node_type, chain_id)?;
        sanitize_validator_network_config(node_config, node_type, chain_id)?;

```

**File:** aptos-node/src/consensus.rs (L260-264)
```rust
    runtime.spawn(
        consensus_publisher
            .clone()
            .start(outbound_message_receiver, publisher_message_receiver),
    );
```

**File:** crates/crash-handler/src/lib.rs (L56-57)
```rust
    // Kill the process
    process::exit(12);
```
