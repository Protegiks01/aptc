# Audit Report

## Title
Sponsored Account Creation Fee Bypass via Self-Sponsorship with Zero Gas Price

## Summary
The `should_create_account_resource()` function combined with zero gas price validation bypasses allows attackers to create accounts without paying storage fees by setting themselves as both sender and fee_payer with `gas_unit_price = 0`. This exploits the failure path account creation mechanism to bypass storage fee requirements.

## Finding Description

The vulnerability exists through the interaction of multiple components in the transaction execution pipeline:

**1. Account Creation Logic**

The `should_create_account_resource()` function returns true when either the `DEFAULT_ACCOUNT_RESOURCE` feature flag is enabled OR when `SPONSORED_AUTOMATIC_ACCOUNT_V1_CREATION` is enabled with a fee payer present, combined with sequence number 0 and a non-existent account. [1](#0-0)  Critically, this function does NOT validate that the fee_payer differs from the sender.

**2. Feature Flags Enabled by Default**

Both `SPONSORED_AUTOMATIC_ACCOUNT_V1_CREATION` (line 208) and `DEFAULT_ACCOUNT_RESOURCE` (line 260) are enabled in the default feature set. [2](#0-1) [3](#0-2) 

**3. Prologue Validation Forces Failure**

When `sender_address == gas_payer_address`, the `check_for_replay_protection_regular_txn` function requires the account to exist. If it doesn't, the transaction fails with `PROLOGUE_EACCOUNT_DOES_NOT_EXIST`. [4](#0-3) 

**4. Storage Fee Validation Bypass**

During account creation in `finish_aborted_transaction`, the storage fee validation is explicitly skipped when `gas_unit_price == 0` AND `DEFAULT_ACCOUNT_RESOURCE` feature is enabled. [5](#0-4)  A second validation point in `finish_aborted_transaction` also skips fee verification under the same conditions. [6](#0-5) 

The `process_storage_fee_for_all` function also returns early when gas_unit_price is zero. [7](#0-6) 

**5. Failure Path Account Creation**

In `finish_aborted_transaction`, when `should_create_account_resource()` returns true, the account is created using `create_account_if_does_not_exist` even though the transaction failed in the prologue. [8](#0-7) 

**6. Zero-Fee Epilogue Success**

The epilogue calculates `transaction_fee_amount = txn_gas_price * gas_used`, which equals zero when `txn_gas_price = 0`. [9](#0-8)  The balance check then passes with a zero fee requirement. [10](#0-9) 

**Attack Execution Path:**
1. Attacker submits a fee payer transaction with `sender == fee_payer`, `gas_unit_price = 0`, `sequence_number = 0`
2. Prologue fails at account existence check
3. `finish_aborted_transaction` creates the account via `should_create_account_resource` returning true
4. Storage fee validation is skipped due to zero gas price with DEFAULT_ACCOUNT_RESOURCE enabled
5. Epilogue succeeds because transaction_fee_amount = 0
6. Account is created on-chain without paying storage fees

## Impact Explanation

**MEDIUM Severity** - This vulnerability enables:
- **Economic Model Bypass**: Circumvents the storage fee payment mechanism designed to prevent state bloat
- **State Bloat Attack Vector**: Unlimited account creation without economic cost enables spam attacks that bloat blockchain state
- **Limited Funds Manipulation**: While not direct theft, bypasses mandatory storage fee payment

This aligns with the Aptos bug bounty **MEDIUM severity category** for "Limited Protocol Violations" including state inconsistencies and limited funds manipulation. The vulnerability does not enable direct fund theft, consensus violations, or network liveness issues, but it violates a core economic security guarantee.

## Likelihood Explanation

**HIGH Likelihood** - The attack is trivially executable:
- **No Prerequisites**: Works with default feature flag configuration
- **Simple Execution**: Standard transaction construction with sender == fee_payer and gas_unit_price = 0
- **No Privileges Required**: Any network participant can execute
- **Repeatable**: Attack can be executed unlimited times
- **Public Interface**: Uses standard transaction submission APIs

## Recommendation

Implement validation to prevent self-sponsorship with zero gas price from bypassing storage fees:

1. **Require fee_payer ≠ sender for SPONSORED_AUTOMATIC_ACCOUNT_V1_CREATION**: Modify `should_create_account_resource()` to reject self-sponsored account creation when using the sponsored account creation feature
2. **Enforce minimum storage fee regardless of gas_unit_price**: Remove the `gas_unit_price == 0` bypass in storage fee validation when creating accounts
3. **Add validation in check_for_replay_protection_regular_txn**: Reject transactions where sender == fee_payer with gas_unit_price = 0 and non-existent sender account

## Proof of Concept

```rust
// Transaction construction demonstrating the vulnerability
let txn = TransactionBuilder::new()
    .sender(attacker_address)
    .fee_payer(attacker_address)  // Self-sponsorship
    .gas_unit_price(0)            // Zero gas price
    .sequence_number(0)           // First transaction
    .build();

// Expected: Transaction fails, no account created
// Actual: Transaction fails in prologue but account is created in failure path
// Result: Account created without paying storage fees
```

## Notes

This vulnerability specifically exploits the interaction between the sponsored account creation feature and the zero gas price bypass. The intended design appears to be that sponsored accounts (fee_payer ≠ sender) can be created automatically, but the implementation fails to prevent self-sponsorship with zero gas price from bypassing storage fee validation. The bypass occurs because multiple validation points check `gas_unit_price == 0` and skip fee enforcement when the `DEFAULT_ACCOUNT_RESOURCE` feature is enabled, which is part of the default feature set.

### Citations

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L708-739)
```rust
        let (previous_session_change_set, fee_statement) = if should_create_account_resource {
            let mut abort_hook_session =
                AbortHookSession::new(self, txn_data, resolver, prologue_session_change_set);

            abort_hook_session.execute(|session| {
                create_account_if_does_not_exist(
                    session,
                    module_storage,
                    gas_meter,
                    txn_data.sender(),
                    traversal_context,
                )
                // If this fails, it is likely due to out of gas, so we try again without metering
                // and then validate below that we charged sufficiently.
                .or_else(|_err| {
                    create_account_if_does_not_exist(
                        session,
                        module_storage,
                        &mut UnmeteredGasMeter,
                        txn_data.sender(),
                        traversal_context,
                    )
                })
                .map_err(expect_no_verification_errors)
                .or_else(|err| {
                    expect_only_successful_execution(
                        err,
                        &format!("{:?}::{}", ACCOUNT_MODULE, CREATE_ACCOUNT_IF_DOES_NOT_EXIST),
                        log_context,
                    )
                })
            })?;
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L762-762)
```rust
            if gas_unit_price != 0 || !self.features().is_default_account_resource_enabled() {
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L3451-3484)
```rust
pub(crate) fn should_create_account_resource(
    txn_data: &TransactionMetadata,
    features: &Features,
    resolver: &impl AptosMoveResolver,
    module_storage: &impl ModuleStorage,
) -> VMResult<bool> {
    if (features.is_enabled(FeatureFlag::DEFAULT_ACCOUNT_RESOURCE)
        || (features.is_enabled(FeatureFlag::SPONSORED_AUTOMATIC_ACCOUNT_V1_CREATION)
            && txn_data.fee_payer.is_some()))
        && txn_data.replay_protector == ReplayProtector::SequenceNumber(0)
    {
        let account_tag = AccountResource::struct_tag();

        // INVARIANT:
        //   Account lives at a special address, so we should not be charging for it and unmetered
        //   access is safe. There are tests that ensure that address is always special.
        assert!(account_tag.address.is_special());
        let module = module_storage.unmetered_get_existing_deserialized_module(
            &account_tag.address,
            &account_tag.module,
        )?;

        let (maybe_bytes, _) = resolver
            .get_resource_bytes_with_metadata_and_layout(
                &txn_data.sender(),
                &account_tag,
                &module.metadata,
                None,
            )
            .map_err(|e| e.finish(Location::Undefined))?;
        return Ok(maybe_bytes.is_none());
    }
    Ok(false)
}
```

**File:** types/src/on_chain_config/aptos_features.rs (L208-208)
```rust
            FeatureFlag::SPONSORED_AUTOMATIC_ACCOUNT_V1_CREATION,
```

**File:** types/src/on_chain_config/aptos_features.rs (L260-260)
```rust
            FeatureFlag::DEFAULT_ACCOUNT_RESOURCE,
```

**File:** aptos-move/framework/aptos-framework/sources/transaction_validation.move (L220-226)
```text
        if (
            sender_address == gas_payer_address
                || account::exists_at(sender_address)
                || !features::sponsored_automatic_account_creation_enabled()
                || txn_sequence_number > 0
        ) {
            assert!(account::exists_at(sender_address), error::invalid_argument(PROLOGUE_EACCOUNT_DOES_NOT_EXIST));
```

**File:** aptos-move/framework/aptos-framework/sources/transaction_validation.move (L597-603)
```text
        let gas_used = txn_max_gas_units - gas_units_remaining;

        assert!(
            (txn_gas_price as u128) * (gas_used as u128) <= MAX_U64,
            error::out_of_range(EOUT_OF_GAS)
        );
        let transaction_fee_amount = txn_gas_price * gas_used;
```

**File:** aptos-move/framework/aptos-framework/sources/transaction_validation.move (L608-617)
```text
            if (features::operations_default_to_fa_apt_store_enabled()) {
                assert!(
                    aptos_account::is_fungible_balance_at_least(gas_payer, transaction_fee_amount),
                    error::out_of_range(PROLOGUE_ECANT_PAY_GAS_DEPOSIT),
                );
            } else {
                assert!(
                    coin::is_balance_at_least<AptosCoin>(gas_payer, transaction_fee_amount),
                    error::out_of_range(PROLOGUE_ECANT_PAY_GAS_DEPOSIT),
                );
```

**File:** aptos-move/aptos-vm/src/gas.rs (L219-219)
```rust
    )? && (gas_unit_price != 0 || !features.is_default_account_resource_enabled())
```

**File:** aptos-move/aptos-gas-meter/src/traits.rs (L171-172)
```rust
        if gas_unit_price.is_zero() {
            return Ok(0.into());
```
