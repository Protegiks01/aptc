# Audit Report

## Title
API Layer Type Confusion via `__variant__` Field Injection in Enum Serialization

## Summary
An attacker can deploy Move enums with fields named `__variant__`, causing the API serialization to incorrectly represent the variant type to external clients. However, this vulnerability is limited to the API layer and does NOT affect Move VM execution, consensus, or on-chain state integrity.

## Finding Description

The vulnerability exists in the `MoveStructValue::try_from(AnnotatedMoveStruct)` implementation where enum variants are serialized to JSON. [1](#0-0) 

The code first inserts the variant marker with key `__variant__`, then iterates through all struct fields. If an enum variant contains a field also named `__variant__`, the field value overwrites the variant marker in the BTreeMap since `BTreeMap::insert()` replaces existing values.

Move's identifier validation allows `__variant__` as a valid field name. [2](#0-1) 

The bytecode verifier only checks for duplicate field names within each variant, but does NOT prevent reserved naming patterns. [3](#0-2) 

**Critical Clarification**: This vulnerability does NOT affect Move VM type checking or execution. The Move VM uses bytecode variant tags from `AnnotatedMoveStruct.variant_info` [4](#0-3) , not field names. The vulnerability only affects the API's JSON representation consumed by external clients.

## Impact Explanation

This issue is classified as **Low Severity** (not High as suggested in the question) because:

1. **No Consensus Impact**: All validators execute identical bytecode using variant tags, maintaining deterministic execution
2. **No State Corruption**: On-chain state remains correctly stored and verified
3. **No Funds at Risk**: Cannot cause theft, loss, or manipulation of assets
4. **API Layer Only**: Affects external API consumers (wallets, explorers, dApps) but not blockchain core functionality

Per the Aptos bug bounty criteria, this qualifies as "Non-critical implementation bugs" under Low Severity, not the High Severity "API crashes" category, as the API continues functioningâ€”it just returns misleading metadata.

## Likelihood Explanation

**Low Likelihood** - While technically exploitable:
- Requires deploying custom Move modules with unusual field naming
- Most legitimate code doesn't use double-underscore prefixed fields
- Impact limited to clients that make security decisions based on API variant information without on-chain verification
- No financial incentive for exploitation

## Recommendation

Add validation to reject field names that conflict with API serialization special markers:

```rust
// In api/types/src/move_types.rs, MoveStructValue::try_from()
const RESERVED_FIELD_NAMES: &[&str] = &[
    "__variant__", "__fun_name__", "__ty_args__", 
    "__mask__", "__captured__", "__variant_tag__"
];

for (id, val) in s.value {
    let field_name = id.as_str();
    if RESERVED_FIELD_NAMES.contains(&field_name) {
        return Err(anyhow::anyhow!(
            "Field name '{}' conflicts with API reserved names", 
            field_name
        ));
    }
    map.insert(id.into(), MoveValue::try_from(val)?.json()?);
}
```

Alternatively, use a different naming convention that's guaranteed not to conflict (e.g., `@variant` with `@` which is not a valid Move identifier character).

## Proof of Concept

```move
module attacker::confused {
    enum Malicious has key, store {
        Trusted { value: u64 },
        Untrusted { __variant__: vector<u8>, value: u64 }
    }

    public entry fun exploit(account: &signer) {
        // Create Untrusted variant with __variant__ field set to b"Trusted"
        let fake = Malicious::Untrusted { 
            __variant__: b"Trusted",  // This will overwrite the real variant marker
            value: 123 
        };
        move_to(account, fake);
        
        // API will show: {"__variant__": <bytes>, "value": "123"}
        // Instead of:    {"__variant__": "Untrusted", "__variant__": <bytes>, "value": "123"}
    }
}
```

**Verification**: Deploy this module and call `exploit()`, then query the resource via REST API. The `__variant__` field in the JSON response will contain the byte vector value instead of the string "Untrusted".

## Notes

**Important**: The original security question asked whether this "bypasses type checking in Move VM execution" - the answer is **NO**. The Move VM operates correctly using bytecode-level variant tags. This vulnerability only affects the API layer's JSON representation and does not compromise blockchain security invariants.

This finding demonstrates an API data integrity issue rather than a core blockchain vulnerability, and therefore does not meet the High Severity threshold specified in the question premise.

### Citations

**File:** api/types/src/move_types.rs (L271-279)
```rust
        if let Some((_, name)) = s.variant_info {
            map.insert(
                IdentifierWrapper::from_str("__variant__")?,
                MoveValue::String(name.to_string()).json()?,
            );
        }
        for (id, val) in s.value {
            map.insert(id.into(), MoveValue::try_from(val)?.json()?);
        }
```

**File:** third_party/move/move-core/types/src/identifier.rs (L82-94)
```rust
pub const fn is_valid(s: &str) -> bool {
    // Rust const fn's don't currently support slicing or indexing &str's, so we
    // have to operate on the underlying byte slice. This is not a problem as
    // valid identifiers are (currently) ASCII-only.
    let b = s.as_bytes();
    match b {
        b"<SELF>" => true,
        [b'<', b'S', b'E', b'L', b'F', b'>', b'_', ..] if b.len() > 7 => all_bytes_numeric(b, 7),
        [b'a'..=b'z', ..] | [b'A'..=b'Z', ..] => all_bytes_valid(b, 1),
        [b'_', ..] | [b'$', ..] if b.len() > 1 => all_bytes_valid(b, 1),
        _ => false,
    }
}
```

**File:** third_party/move/move-bytecode-verifier/src/check_duplication.rs (L312-324)
```rust
    fn check_duplicate_fields<'l>(
        fields: impl Iterator<Item = &'l FieldDefinition>,
    ) -> PartialVMResult<()> {
        if let Some(idx) = Self::first_duplicate_element(fields.map(|x| x.name)) {
            Err(verification_error(
                StatusCode::DUPLICATE_ELEMENT,
                IndexKind::FieldDefinition,
                idx,
            ))
        } else {
            Ok(())
        }
    }
```

**File:** third_party/move/tools/move-resource-viewer/src/lib.rs (L48-54)
```rust
#[derive(Clone, Debug)]
pub struct AnnotatedMoveStruct {
    pub abilities: AbilitySet,
    pub ty_tag: StructTag,
    pub variant_info: Option<(u16, Identifier)>,
    pub value: Vec<(Identifier, AnnotatedMoveValue)>,
}
```
