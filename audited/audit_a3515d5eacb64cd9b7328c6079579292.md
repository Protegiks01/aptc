# Audit Report

## Title
Authentication Bypass in Aptos Faucet via X-IS-JWT Header Presence Check

## Summary
The `AuthTokenChecker` in the Aptos faucet can be completely bypassed by including any `x-is-jwt` header in the request, regardless of its value. This allows attackers to obtain faucet funds without providing a valid authentication token, breaking the intended access control mechanism.

## Finding Description

The vulnerability exists in the interaction between two authentication mechanisms in the faucet:

1. **AuthTokenChecker** validates Bearer tokens from the `Authorization` header
2. **Firebase JWT verification** validates JWT tokens when the `x-is-jwt` header is set to "true"

The critical flaw is in the `AuthTokenChecker::check()` method, which uses `contains_key()` to check for the presence of the `x-is-jwt` header, not its value: [1](#0-0) 

When this header exists (with ANY value including "false", "", or malformed data), the entire auth token validation is skipped. However, the JWT validation in `jwt_sub()` only proceeds if the header value equals "true": [2](#0-1) 

**Attack scenario:**
1. Attacker sends a fund request with headers:
   ```
   x-is-jwt: false
   Authorization: Bearer invalid-token
   ```
2. `AuthTokenChecker` sees the header exists and skips validation entirely
3. JWT verification is NOT enforced (only happens in `RedisRatelimitChecker` with JWT mode, which may not be configured)
4. Request passes all checks and receives funds without valid authentication

The vulnerability is exploitable when the faucet is configured with `AuthTokenChecker` but without JWT-based rate limiting, as shown in the example configuration: [3](#0-2) 

## Impact Explanation

This vulnerability allows unauthorized access to faucet funds, qualifying as **Medium Severity** under the Aptos bug bounty program criteria for "Limited funds loss or manipulation."

**Specific impacts:**
- Attackers can drain faucet funds without valid API keys
- Rate limiting per IP can still apply (via `MemoryRatelimit` or `RedisRatelimit` with IP mode), limiting but not preventing abuse
- Faucet operators lose control over who can access funds
- Could be exploited to DoS the faucet by draining all available funds

While faucet tokens are typically testnet tokens without monetary value, the vulnerability represents a complete authentication bypass affecting availability and access control.

## Likelihood Explanation

**High likelihood** of exploitation:
- Simple to exploit: only requires adding a single HTTP header
- No special tools or knowledge required
- Affects any faucet deployment using `AuthTokenChecker` without JWT-based rate limiting
- The vulnerability is in production code, not test code
- The flaw exists in the core checker logic, making it broadly applicable

The vulnerability is triggered by a common deployment scenario where operators want token-based authentication via `AuthTokenChecker` but don't configure JWT validation.

## Recommendation

Fix the `AuthTokenChecker` to validate the `x-is-jwt` header value instead of just checking its presence. The checker should only skip validation if the header value explicitly equals "true":

```rust
async fn check(
    &self,
    data: CheckerData,
    _dry_run: bool,
) -> Result<Vec<RejectionReason>, AptosTapError> {
    // Only skip auth token check if x-is-jwt is explicitly set to "true"
    let is_jwt = data
        .headers
        .get(X_IS_JWT_HEADER)
        .and_then(|v| v.to_str().ok())
        .map(|v| v.eq_ignore_ascii_case("true"))
        .unwrap_or(false);
    
    if is_jwt {
        return Ok(vec![]);
    }

    // Continue with auth token validation...
    let auth_token = match data
        .headers
        .get(AUTHORIZATION)
        // ... rest of validation
}
```

Alternatively, consolidate the JWT presence check logic into a shared helper function to ensure consistency across all checkers.

## Proof of Concept

```rust
#[tokio::test]
async fn test_auth_bypass_via_x_is_jwt_header() -> Result<()> {
    // Setup faucet with AuthTokenChecker but no JWT validation
    make_auth_tokens_file(&["valid_token"])?;
    let config = r#"
    checker_configs:
      - type: "AuthToken"
        file: "/tmp/auth_tokens.txt"
    funder_config:
      type: "FakeFunder"
    "#;
    let (port, _handle) = start_server(config).await?;

    // Attack: Include x-is-jwt header with invalid value to bypass auth check
    let response = reqwest::Client::new()
        .post(get_fund_endpoint(port))
        .body(get_fund_request(Some(10)).to_json_string())
        .header(CONTENT_TYPE, "application/json")
        .header("x-is-jwt", "false")  // Header present but value is "false"
        .header(AUTHORIZATION, "Bearer invalid_token")  // Invalid token
        .send()
        .await?;

    // Expected: Request should be rejected due to invalid token
    // Actual: Request succeeds because AuthTokenChecker is bypassed
    assert_eq!(response.status(), 200);  // Vulnerability: This passes!
    
    Ok(())
}
```

**Notes:**
- This vulnerability specifically affects the faucet component, not core consensus or VM functionality
- The issue stems from inconsistent header validation logic between `AuthTokenChecker` (checks existence) and `jwt_sub()` (checks value)
- The `poem` framework's `HeaderMap.get()` method correctly returns only the first header value when duplicates exist, so duplicate headers alone don't introduce additional vulnerabilities beyond the existence check flaw
- Production deployments should immediately audit their faucet configurations and either remove `AuthTokenChecker` or ensure JWT validation is properly enforced through `RedisRatelimitChecker` with JWT mode enabled

### Citations

**File:** crates/aptos-faucet/core/src/checkers/auth_token.rs (L38-40)
```rust
        if data.headers.contains_key(X_IS_JWT_HEADER) {
            return Ok(vec![]);
        }
```

**File:** crates/aptos-faucet/core/src/firebase_jwt.rs (L70-89)
```rust
    let is_jwt = headers
        .get(X_IS_JWT_HEADER)
        .and_then(|v| v.to_str().ok())
        .map(|v| v.eq_ignore_ascii_case("true"))
        .ok_or_else(|| {
            AptosTapError::new(
                format!(
                    "The {} header must be present and set to 'true'",
                    X_IS_JWT_HEADER
                ),
                AptosTapErrorCode::AuthTokenInvalid,
            )
        })?;

    if !is_jwt {
        return Err(AptosTapError::new(
            format!("The {} header must be set to 'true'", X_IS_JWT_HEADER),
            AptosTapErrorCode::AuthTokenInvalid,
        ));
    }
```

**File:** crates/aptos-faucet/configs/testing_checkers.yaml (L7-9)
```yaml
checker_configs:
  - type: "AuthToken"
    file: "/tmp/auth_tokens.txt"
```
