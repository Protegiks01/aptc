# Audit Report

## Title
Cross-Shard Message Queue OOM via Unbounded Channels in Sharded Block Executor

## Summary
The sharded block executor uses unbounded channels for cross-shard communication, allowing malicious or compromised shards to flood receiver queues with `RemoteTxnWriteMsg` messages, causing out-of-memory (OOM) conditions and validator node crashes.

## Finding Description

The sharded block executor implements parallel transaction execution by partitioning blocks across multiple shards. Cross-shard dependencies are communicated via `RemoteTxnWriteMsg` messages sent from sender shards to receiver shards.

**Vulnerability Chain:**

1. **Unbounded Channel Creation**: The `NetworkController` creates unbounded channels for cross-shard message queues [1](#0-0)  and [2](#0-1) , allowing unlimited messages to queue in memory.

2. **No Authentication**: The gRPC message handler accepts messages from any sender without authentication or verification [3](#0-2) , directly forwarding them to unbounded channels.

3. **Unrestricted Message Sending**: The `CrossShardCommitSender` sends `RemoteTxnWriteMsg` for each dependent edge without rate limiting [4](#0-3) .

4. **Sequential Processing**: The `CrossShardCommitReceiver` processes messages sequentially in a loop [5](#0-4) , creating a bottleneck.

**Attack Scenario:**
A compromised or malicious shard can exploit this by:
- Sending duplicate `RemoteTxnWriteMsg` messages for the same state keys repeatedly
- Sending messages in a tight loop faster than the receiver can process
- Flooding all expected state keys from cross-shard dependencies simultaneously

Since the channels are unbounded, all messages accumulate in memory before processing, eventually exhausting available memory and causing OOM crashes.

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos bug bounty program because it can cause:

- **Validator node crashes**: OOM kills the victim shard's execution process, disrupting block execution
- **Denial of service**: Repeated attacks can prevent shards from completing execution rounds
- **Execution delays**: Memory pressure causes performance degradation before crash

The impact is limited to execution layer availability rather than consensus safety, as it doesn't allow state manipulation or fund theft. However, it can significantly disrupt network operation by taking validator execution shards offline.

## Likelihood Explanation

**Likelihood: Medium-High** in environments using distributed sharded execution.

**Prerequisites for exploitation:**
- Access to internal shard communication network (either through compromise or misconfiguration)
- Knowledge of message format, target shard IDs, round IDs, and valid state keys
- Ability to send gRPC messages to victim shard endpoints

**Mitigating factors:**
- Sharded executor is primarily used for internal optimization within validator nodes
- Production deployments should firewall internal shard communication
- Attack requires compromised shard or network access to internal channels

**Note on Trust Model Violation**: This vulnerability technically requires either compromised shard access or network misconfiguration, which places it outside the "unprivileged attacker" scope defined in the validation checklist. However, the code-level vulnerability (unbounded channels + no authentication) represents a significant defense-in-depth failure that could be exploited if any shard is compromised or if deployment security is misconfigured.

## Recommendation

Implement the following defense-in-depth measures:

1. **Replace unbounded channels with bounded channels**:
```rust
// In NetworkController::create_inbound_channel()
pub fn create_inbound_channel(&mut self, message_type: String) -> Receiver<Message> {
    const MAX_CROSS_SHARD_QUEUE_SIZE: usize = 10000; // Tune based on max expected dependencies
    let (inbound_sender, inbound_receiver) = bounded(MAX_CROSS_SHARD_QUEUE_SIZE);
    // ... rest of implementation
}
```

2. **Add message deduplication in CrossShardStateView**:
```rust
pub fn set_value(&self, state_key: &StateKey, state_value: Option<StateValue>) {
    if let Some(remote_value) = self.cross_shard_data.get(state_key) {
        // Only set if still waiting (ignore duplicates)
        if !remote_value.is_ready() {
            remote_value.set_value(state_value);
        }
    }
}
```

3. **Implement authentication for cross-shard messages** in the gRPC layer using shared secrets or cryptographic signatures to verify sender identity.

4. **Add monitoring and alerts** for channel queue depths to detect flooding attacks early.

## Proof of Concept

```rust
// Simulated attack demonstrating unbounded queue growth
// This would be executed by a malicious shard with network access

use aptos_vm::sharded_block_executor::messages::{CrossShardMsg, RemoteTxnWrite};
use aptos_types::state_store::state_key::StateKey;
use crossbeam_channel::unbounded;

#[test]
fn test_cross_shard_message_flood() {
    // Simulate unbounded channel as used in production
    let (tx, rx) = unbounded::<CrossShardMsg>();
    
    // Simulate malicious shard flooding with duplicate messages
    let state_key = StateKey::raw(b"test_key");
    let flood_count = 1_000_000; // 1 million messages
    
    // Attacker sends messages in tight loop
    for _ in 0..flood_count {
        let msg = CrossShardMsg::RemoteTxnWriteMsg(
            RemoteTxnWrite::new(state_key.clone(), None)
        );
        tx.send(msg).unwrap(); // Never blocks - unbounded
    }
    
    // Measure memory consumption
    let msg_size = std::mem::size_of::<CrossShardMsg>();
    let total_memory = flood_count * msg_size;
    
    println!("Queued {} messages consuming ~{} MB", 
             flood_count, total_memory / 1_048_576);
    
    // In production, this would cause OOM before processing completes
    assert!(total_memory > 100_000_000); // Over 100MB queued
}
```

**Expected outcome**: The test demonstrates that unbounded channels allow arbitrary memory accumulation. In a real attack against a running validator, this would cause progressive memory exhaustion leading to OOM kills.

---

**Notes**

Given strict interpretation of the validation checklist requirement for "unprivileged attacker (no validator insider access required)", this vulnerability may not fully qualify as it requires either:
- Compromised shard access, OR  
- Misconfigured network allowing external access to internal gRPC endpoints

However, the code-level vulnerability (unbounded channels + no authentication/rate limiting) is a critical defense-in-depth failure that should be addressed regardless of deployment assumptions.

### Citations

**File:** secure/net/src/network_controller/mod.rs (L120-120)
```rust
        let (outbound_sender, outbound_receiver) = unbounded();
```

**File:** secure/net/src/network_controller/mod.rs (L129-129)
```rust
        let (inbound_sender, inbound_receiver) = unbounded();
```

**File:** secure/net/src/grpc_network_service/mod.rs (L93-115)
```rust
    async fn simple_msg_exchange(
        &self,
        request: Request<NetworkMessage>,
    ) -> Result<Response<Empty>, Status> {
        let _timer = NETWORK_HANDLER_TIMER
            .with_label_values(&[&self.self_addr.to_string(), "inbound_msgs"])
            .start_timer();
        let remote_addr = request.remote_addr();
        let network_message = request.into_inner();
        let msg = Message::new(network_message.message);
        let message_type = MessageType::new(network_message.message_type);

        if let Some(handler) = self.inbound_handlers.lock().unwrap().get(&message_type) {
            // Send the message to the registered handler
            handler.send(msg).unwrap();
        } else {
            error!(
                "No handler registered for sender: {:?} and msg type {:?}",
                remote_addr, message_type
            );
        }
        Ok(Response::new(Empty {}))
    }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/cross_shard_client.rs (L26-45)
```rust
    pub fn start<S: StateView + Sync + Send>(
        cross_shard_state_view: Arc<CrossShardStateView<S>>,
        cross_shard_client: Arc<dyn CrossShardClient>,
        round: RoundId,
    ) {
        loop {
            let msg = cross_shard_client.receive_cross_shard_msg(round);
            match msg {
                RemoteTxnWriteMsg(txn_commit_msg) => {
                    let (state_key, write_op) = txn_commit_msg.take();
                    cross_shard_state_view
                        .set_value(&state_key, write_op.and_then(|w| w.as_state_value()));
                },
                CrossShardMsg::StopMsg => {
                    trace!("Cross shard commit receiver stopped for round {}", round);
                    break;
                },
            }
        }
    }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/cross_shard_client.rs (L103-134)
```rust
    fn send_remote_update_for_success(
        &self,
        txn_idx: TxnIndex,
        txn_output: &OnceCell<TransactionOutput>,
    ) {
        let edges = self.dependent_edges.get(&txn_idx).unwrap();
        let write_set = txn_output
            .get()
            .expect("Committed output must be set")
            .write_set();

        for (state_key, write_op) in write_set.expect_write_op_iter() {
            if let Some(dependent_shard_ids) = edges.get(state_key) {
                for (dependent_shard_id, round_id) in dependent_shard_ids.iter() {
                    trace!("Sending remote update for success for shard id {:?} and txn_idx: {:?}, state_key: {:?}, dependent shard id: {:?}", self.shard_id, txn_idx, state_key, dependent_shard_id);
                    let message = RemoteTxnWriteMsg(RemoteTxnWrite::new(
                        state_key.clone(),
                        Some(write_op.clone()),
                    ));
                    if *round_id == GLOBAL_ROUND_ID {
                        self.cross_shard_client.send_global_msg(message);
                    } else {
                        self.cross_shard_client.send_cross_shard_msg(
                            *dependent_shard_id,
                            *round_id,
                            message,
                        );
                    }
                }
            }
        }
    }
```
