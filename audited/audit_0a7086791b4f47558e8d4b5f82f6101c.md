# Audit Report

## Title
Write Set Tampering in Backup Restoration Allows Unauthorized State Injection

## Summary
The transaction backup restoration process fails to verify that `WriteSet` objects match their cryptographic commitment (`state_change_hash`) in `TransactionInfo`. An attacker with access to backup files can modify write sets to inject arbitrary state changes, which will be applied to the blockchain during restoration without any cryptographic verification, leading to complete state corruption.

## Finding Description

The Aptos backup system stores transactions in chunks containing `(Transaction, TransactionInfo, Vec<ContractEvent>, WriteSet)` tuples. [1](#0-0) 

During restoration, the `LoadedChunk::load()` function deserializes write sets from backup files and creates a `TransactionListWithProofV2` for verification. [2](#0-1) 

However, the verification only validates transaction hashes and events—**not write sets**. The `TransactionListWithProof::verify()` method checks that transaction hashes match `TransactionInfo` entries and that events match their root hashes, but never verifies write sets against `state_change_hash`. [3](#0-2) 

When transactions are saved without replay (the default restoration mode), write sets are directly persisted to the database via `save_transactions_impl()` without any integrity checks. [4](#0-3) 

**Attack Vector:**
1. Attacker obtains legitimate backup files from cloud storage or compromised backup infrastructure
2. Attacker modifies write sets in chunk files to inject malicious state changes (e.g., increase account balances, modify validator set, change governance votes)
3. Attacker leaves `TransactionInfo` and cryptographic proofs (Merkle proofs, signatures) intact
4. Victim restores backup without `--replay-transactions-from-version` flag
5. Tampered write sets are saved directly to AptosDB without verification
6. Blockchain state is corrupted with attacker-controlled changes

The `--replay-transactions-from-version` flag is **optional**, and restoration without replay is a documented use case. [5](#0-4) 

Write set verification **only** occurs during transaction replay via `ensure_match_transaction_info()`, which computes `CryptoHash::hash(write_set)` and compares it to `state_change_hash`. [6](#0-5) 

But this verification is bypassed when restoring without replay, making the attack feasible.

## Impact Explanation

**Critical Severity** - This vulnerability enables complete state manipulation:

1. **Loss of Funds**: Attacker can modify write sets to increase their token balances or transfer funds from any account
2. **Governance Takeover**: Attacker can manipulate voting power, proposal outcomes, or validator set composition
3. **Consensus Violation**: Different nodes restoring from tampered backups will have divergent state roots, causing irrecoverable chain splits
4. **State Consistency Breach**: Violates the fundamental invariant that "State transitions must be atomic and verifiable via Merkle proofs"

This meets **Critical Severity** criteria per Aptos Bug Bounty:
- Enables theft/minting of funds
- Causes consensus/safety violations  
- Creates non-recoverable network partitions requiring hardfork

The attack requires no validator privileges—only access to backup files, which are often stored in less-secure cloud storage with broader access permissions than live validator nodes.

## Likelihood Explanation

**High Likelihood** for the following reasons:

1. **Common Operational Practice**: Backup restoration is a standard disaster recovery procedure performed regularly during node setup, migration, and incident response
2. **Default Behavior**: The vulnerable code path (restoration without replay) is the **default**—replay requires explicit opt-in via `--replay-transactions-from-version`
3. **Accessible Attack Surface**: Backup files are typically stored in cloud object storage (S3, GCS) with broader access permissions than production validator infrastructure
4. **No Defense in Depth**: There is zero cryptographic verification of write sets in the non-replay path—the vulnerability is guaranteed to succeed
5. **Silent Corruption**: The attack produces no errors or warnings; tampered state is silently committed to the database

Attackers could exploit this through:
- Compromised backup storage credentials
- Supply chain attacks on backup infrastructure
- Insider threats with backup access
- Social engineering targeting backup administrators

## Recommendation

Add write set hash verification in `LoadedChunk::load()` immediately after deserializing write sets:

```rust
// In storage/backup/backup-cli/src/backup_types/transaction/restore.rs
// After line 137, before line 139:

// Verify write sets match state_change_hash in TransactionInfo
for (idx, (write_set, txn_info)) in write_sets.iter().zip(txn_infos.iter()).enumerate() {
    let write_set_hash = aptos_crypto::CryptoHash::hash(write_set);
    ensure!(
        write_set_hash == txn_info.state_change_hash(),
        "WriteSet hash mismatch at index {}. Expected: {:?}, Got: {:?}",
        idx,
        txn_info.state_change_hash(),
        write_set_hash
    );
}
```

This ensures write set integrity is verified against the cryptographically-committed `state_change_hash` **before** any write sets are saved to the database, regardless of whether transaction replay is enabled.

**Additional Hardening:**
1. Make write set verification mandatory in all restore code paths
2. Add backup file integrity checks (HMAC/signatures) at the chunk level
3. Document that restoration without replay trusts backup file integrity
4. Consider requiring replay verification for production environments

## Proof of Concept

```rust
// Reproduction steps:

// 1. Create a legitimate backup with transaction at version 100
// Transaction transfers 1000 tokens from Alice to Bob
// WriteSet contains: Alice balance -= 1000, Bob balance += 1000
// state_change_hash = hash(WriteSet) = 0xABCD...

// 2. Attacker tampers with backup file:
// Modified WriteSet: Alice balance -= 1000, Attacker balance += 1000
// New hash: hash(Modified WriteSet) = 0x1234...
// BUT TransactionInfo still contains old state_change_hash = 0xABCD...

// 3. Restore backup WITHOUT replay:
// $ aptos-db-tool restore bootstrap-db \
//     --target-db-dir /path/to/db \
//     --transaction-manifest backup.json

// 4. LoadedChunk::load() loads tampered WriteSet
// 5. TransactionListWithProof::verify() checks:
//    - Transaction hash matches ✓ (transaction unchanged)
//    - Events match event_root_hash ✓ (events unchanged)
//    - WriteSet hash matches state_change_hash ✗ (NOT CHECKED!)

// 6. save_transactions() persists tampered WriteSet to database
// Result: Attacker's balance increased without valid transaction

// Verification that write sets are NOT checked:
// grep -r "state_change_hash" storage/backup/backup-cli/src/backup_types/transaction/restore.rs
// Returns: 0 matches (no verification present)
```

To demonstrate the vulnerability, modify a backup file's write set, restore without `--replay-transactions-from-version`, and observe that the tampered state is committed without any verification errors.

## Notes

The vulnerability exists because the backup format separates write sets from their cryptographic commitments (stored in `TransactionInfo`), but the restoration code path that saves write sets directly to the database never validates this commitment. 

Write set verification **does** occur during transaction replay [7](#0-6) , but replay is optional and not the default restoration mode.

This represents a fundamental breakdown in defense-in-depth: cryptographic proofs exist (`state_change_hash`) but are not enforced in a critical code path, allowing complete state manipulation through backup file tampering.

### Citations

**File:** storage/backup/backup-cli/src/backup_types/transaction/manifest.rs (L11-15)
```rust
    // (Transaction, TransactionInfo, Vec<ContractEvent>, WriteSet)
    V0,
    // (Transaction, PersistedAuxiliaryInfo, TransactionInfo, Vec<ContractEvent>, WriteSet)
    V1,
}
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L68-77)
```rust
    #[clap(
        long = "replay-transactions-from-version",
        help = "Transactions with this version and above will be replayed so state and events are \
        gonna pop up. Requires state at the version right before this to exist, either by \
        recovering a state snapshot, or previous transaction replay."
    )]
    pub replay_from_version: Option<Version>,
    #[clap(long)]
    pub kv_only_replay: Option<bool>,
}
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L112-137)
```rust
        while let Some(record_bytes) = file.read_record_bytes().await? {
            let (txn, aux_info, txn_info, events, write_set): (
                _,
                PersistedAuxiliaryInfo,
                _,
                _,
                WriteSet,
            ) = match manifest.format {
                TransactionChunkFormat::V0 => {
                    let (txn, txn_info, events, write_set) = bcs::from_bytes(&record_bytes)?;
                    (
                        txn,
                        PersistedAuxiliaryInfo::None,
                        txn_info,
                        events,
                        write_set,
                    )
                },
                TransactionChunkFormat::V1 => bcs::from_bytes(&record_bytes)?,
            };
            txns.push(txn);
            persisted_aux_info.push(aux_info);
            txn_infos.push(txn_info);
            event_vecs.push(events);
            write_sets.push(write_set);
        }
```

**File:** types/src/transaction/mod.rs (L1898-1908)
```rust
        let write_set_hash = CryptoHash::hash(self.write_set());
        ensure!(
            write_set_hash == txn_info.state_change_hash(),
            "{}: version:{}, write_set_hash:{:?}, expected:{:?}, write_set: {:?}, expected(if known): {:?}",
            ERR_MSG,
            version,
            write_set_hash,
            txn_info.state_change_hash(),
            self.write_set,
            expected_write_set,
        );
```

**File:** types/src/transaction/mod.rs (L2318-2351)
```rust
        self.transactions
            .par_iter()
            .zip_eq(self.proof.transaction_infos.par_iter())
            .map(|(txn, txn_info)| {
                let txn_hash = CryptoHash::hash(txn);
                ensure!(
                    txn_hash == txn_info.transaction_hash(),
                    "The hash of transaction does not match the transaction info in proof. \
                     Transaction hash: {:x}. Transaction hash in txn_info: {:x}.",
                    txn_hash,
                    txn_info.transaction_hash(),
                );
                Ok(())
            })
            .collect::<Result<Vec<_>>>()?;

        // Verify the transaction infos are proven by the ledger info.
        self.proof
            .verify(ledger_info, self.get_first_transaction_version())?;

        // Verify the events if they exist.
        if let Some(event_lists) = &self.events {
            ensure!(
                event_lists.len() == self.get_num_transactions(),
                "The length of event_lists ({}) does not match the number of transactions ({}).",
                event_lists.len(),
                self.get_num_transactions(),
            );
            event_lists
                .into_par_iter()
                .zip_eq(self.proof.transaction_infos.par_iter())
                .map(|(events, txn_info)| verify_events_against_root_hash(events, txn_info))
                .collect::<Result<Vec<_>>>()?;
        }
```

**File:** storage/aptosdb/src/backup/restore_utils.rs (L261-267)
```rust
    for (idx, ws) in write_sets.iter().enumerate() {
        WriteSetDb::put_write_set(
            first_version + idx as Version,
            ws,
            &mut ledger_db_batch.write_set_db_batches,
        )?;
    }
```

**File:** execution/executor/src/chunk_executor/mod.rs (L636-641)
```rust
            if let Err(err) = txn_out.ensure_match_transaction_info(
                version,
                txn_info,
                Some(write_set),
                Some(events),
            ) {
```
