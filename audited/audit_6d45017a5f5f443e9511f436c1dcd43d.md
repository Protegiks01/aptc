# Audit Report

## Title
Validator Node Crash via Panic on Invalid Value in native_compare() Gas Calculation

## Summary
The `native_compare()` function in the Move standard library can cause a validator node crash when processing `Value::Invalid` arguments. While line 54's `compare()` call handles Invalid values gracefully by returning an error, the gas calculation at lines 50-51 triggers a panic via `unreachable!()` that crashes the entire validator process, violating defense-in-depth principles.

## Finding Description

The security question asks whether Invalid values can cause `compare()` at line 54 to panic. The answer is nuanced: **line 54 handles Invalid values correctly, but lines 50-51 panic before reaching line 54**. [1](#0-0) 

The vulnerability chain:

1. **Gas Calculation Panics on Invalid**: At lines 50-51, `context.abs_val_size_dereferenced()` is called on both arguments. This method internally calls `Value::visit()` to traverse the value structure.

2. **Unreachable Panic**: In the value visitor implementation, Invalid values trigger `unreachable!()`: [2](#0-1) 

3. **Unhandled Panic**: Native functions don't use `catch_unwind`, so panics propagate to the global panic handler: [3](#0-2) 

4. **Validator Crash**: The panic handler kills the process with `process::exit(12)` unless the panic occurred during verification (which native function execution is not).

5. **Compare() Would Handle It**: If execution reached line 54, the `compare()` function would handle Invalid values gracefully by returning `INTERNAL_TYPE_ERROR`: [4](#0-3) 

**Defense-in-Depth Violation**: The bytecode verifier prevents Invalid values from being copied or moved from locals: [5](#0-4) 

However, if a verifier bug allows Invalid values to reach the operand stack and be passed to native functions, the runtime should handle this gracefully rather than crashing the validator.

## Impact Explanation

**Severity: Critical to High**

- **Critical Impact (if exploitable)**: Validator node crashes constitute "Total loss of liveness/network availability" per the bug bounty program. An attacker who can trigger this could crash all validators processing the malicious transaction.

- **Consensus Safety Risk**: If different validators have different verifier versions or different verifier bugs, some nodes might crash while others process the transaction successfully, causing consensus divergence and potential chain splits.

- **Deterministic Execution Violation**: The crash breaks the invariant that "all validators must produce identical state roots for identical blocks" - crashing nodes produce no state at all.

The impact severity depends on whether a bytecode verifier bypass exists. The defense-in-depth violation itself is a High severity issue because it makes the system fragile against verifier bugs.

## Likelihood Explanation

**Likelihood: Low to Medium**

- **Requires Verifier Bug**: Exploitation requires bypassing the bytecode verifier's locals safety checks that prevent Invalid values from being used. The verifier is well-tested and uses control-flow analysis to track local variable availability.

- **Historical Precedent**: Bytecode verifier bugs have occurred historically in Move VM implementations, making this a realistic concern rather than purely theoretical.

- **Easy to Trigger**: Once a verifier bypass exists, triggering the vulnerability is trivial - simply call `std::cmp::compare()` with the Invalid value.

- **Defense-in-Depth Philosophy**: Even if the likelihood of verifier bypass is low, the system should not crash on invalid inputs. Using `unreachable!()` assumes perfect verification, which is a dangerous assumption for critical infrastructure.

## Recommendation

**Option 1: Remove unreachable!() from Value::visit_impl()**

Replace the panic with proper error handling:

```rust
impl Value {
    fn visit_impl(&self, visitor: &mut impl ValueVisitor, depth: u64) -> PartialVMResult<()> {
        use Value::*;

        match self {
            Invalid => Err(PartialVMError::new(StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR)
                .with_message("attempted to visit invalid value")),
            // ... rest of the match arms unchanged
        }
    }
}
```

**Option 2: Add defensive checks in native_compare()**

Validate arguments before gas calculation:

```rust
fn native_compare(
    context: &mut SafeNativeContext,
    _ty_args: &[Type],
    args: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    debug_assert!(args.len() == 2);
    if args.len() != 2 {
        return Err(SafeNativeError::InvariantViolation(PartialVMError::new(
            StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR,
        )));
    }

    // Defensive check: ensure values are not Invalid
    // This is redundant if verifier is correct, but provides defense-in-depth
    for (i, arg) in args.iter().enumerate() {
        if matches!(arg, Value::Invalid) {
            return Err(SafeNativeError::InvariantViolation(
                PartialVMError::new(StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR)
                    .with_message(format!("invalid value at argument {}", i))
            ));
        }
    }

    let cost = CMP_COMPARE_BASE
        + CMP_COMPARE_PER_ABS_VAL_UNIT
            * (context.abs_val_size_dereferenced(&args[0])?
                + context.abs_val_size_dereferenced(&args[1])?);
    context.charge(cost)?;

    let ordering = args[0].compare(&args[1])?;
    // ... rest unchanged
}
```

**Recommendation**: Implement Option 1 as it fixes the root cause system-wide, not just for this one native function.

## Proof of Concept

**Theoretical PoC** (requires verifier bypass to execute):

```rust
// This would compile and run IF a verifier bug allowed Invalid values on the stack
module 0x1::exploit {
    use std::cmp;
    
    public fun trigger_crash() {
        // Assume verifier bug allows us to get an Invalid value somehow
        // (e.g., through uninitialized local that bypasses verification)
        let invalid_value = /* hypothetical Invalid value */;
        let normal_value = 42u64;
        
        // This call would crash the validator at gas calculation
        cmp::compare(&invalid_value, &normal_value);
    }
}
```

**Runtime verification** (Rust unit test showing the panic):

```rust
#[test]
#[should_panic(expected = "Should not be able to visit an invalid value")]
fn test_invalid_value_visitor_panics() {
    use move_vm_types::values::Value;
    use move_vm_types::views::ValueView;
    
    struct DummyVisitor;
    impl ValueVisitor for DummyVisitor {
        // Implement required methods...
    }
    
    let invalid = Value::Invalid;
    let mut visitor = DummyVisitor;
    
    // This panics instead of returning an error
    invalid.visit(&mut visitor).unwrap();
}
```

## Notes

**Key Clarification**: The security question focuses on line 54's `compare()` call, but the actual vulnerability is at lines 50-51's gas calculation. The `compare()` function itself handles Invalid values correctly by returning `INTERNAL_TYPE_ERROR`. The panic occurs earlier in the execution flow during gas metering, which makes the issue more severe since it prevents even reaching the comparison logic.

**Invariants Broken**:
- **Deterministic Execution**: Crashing nodes cannot produce state roots
- **Move VM Safety**: Should handle all inputs gracefully within gas/memory constraints
- **Defense-in-Depth**: Should not trust verifier absolutely; runtime should be robust

### Citations

**File:** aptos-move/framework/move-stdlib/src/natives/cmp.rs (L36-64)
```rust
fn native_compare(
    context: &mut SafeNativeContext,
    _ty_args: &[Type],
    args: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    debug_assert!(args.len() == 2);
    if args.len() != 2 {
        return Err(SafeNativeError::InvariantViolation(PartialVMError::new(
            StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR,
        )));
    }

    let cost = CMP_COMPARE_BASE
        + CMP_COMPARE_PER_ABS_VAL_UNIT
            * (context.abs_val_size_dereferenced(&args[0])?
                + context.abs_val_size_dereferenced(&args[1])?);
    context.charge(cost)?;

    let ordering = args[0].compare(&args[1])?;
    let ordering_move_variant = match ordering {
        std::cmp::Ordering::Less => ORDERING_LESS_THAN_VARIANT,
        std::cmp::Ordering::Equal => ORDERING_EQUAL_VARIANT,
        std::cmp::Ordering::Greater => ORDERING_GREATER_THAN_VARIANT,
    };

    Ok(smallvec![Value::struct_(Struct::pack(vec![Value::u16(
        ordering_move_variant
    )]))])
}
```

**File:** third_party/move/move-vm/types/src/values/values_impl.rs (L1000-1030)
```rust
            (Invalid, _)
            | (U8(_), _)
            | (U16(_), _)
            | (U32(_), _)
            | (U64(_), _)
            | (U128(_), _)
            | (U256(_), _)
            | (I8(_), _)
            | (I16(_), _)
            | (I32(_), _)
            | (I64(_), _)
            | (I128(_), _)
            | (I256(_), _)
            | (Bool(_), _)
            | (Address(_), _)
            | (Container(_), _)
            | (ContainerRef(_), _)
            | (IndexedRef(_), _)
            | (ClosureValue(_), _)
            | (DelayedFieldID { .. }, _) => {
                return Err(
                    PartialVMError::new(StatusCode::INTERNAL_TYPE_ERROR).with_message(format!(
                        "inconsistent argument types passed to comparison: {:?}, {:?}",
                        self, other
                    )),
                )
            },
        };

        Ok(res)
    }
```

**File:** third_party/move/move-vm/types/src/values/values_impl.rs (L2352-2375)
```rust
    pub fn copy_loc(&self, idx: usize) -> PartialVMResult<Value> {
        let locals = self.0.borrow();
        match locals.get(idx) {
            Some(Value::Invalid) => Err(PartialVMError::new(
                StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR,
            )
            .with_message(format!("cannot copy invalid value at index {}", idx))),
            Some(v) => Ok(v.copy_value(1, Some(DEFAULT_MAX_VM_VALUE_NESTED_DEPTH))?),
            None => Err(Self::local_index_out_of_bounds(idx, locals.len())),
        }
    }

    #[cfg_attr(feature = "inline-locals", inline(always))]
    pub fn move_loc(&mut self, idx: usize) -> PartialVMResult<Value> {
        let mut locals = self.0.borrow_mut();
        match locals.get_mut(idx) {
            Some(Value::Invalid) => Err(PartialVMError::new(
                StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR,
            )
            .with_message(format!("cannot move invalid value at index {}", idx))),
            Some(v) => Ok(std::mem::replace(v, Value::Invalid)),
            None => Err(Self::local_index_out_of_bounds(idx, locals.len())),
        }
    }
```

**File:** third_party/move/move-vm/types/src/values/values_impl.rs (L5589-5615)
```rust
impl Value {
    fn visit_impl(&self, visitor: &mut impl ValueVisitor, depth: u64) -> PartialVMResult<()> {
        use Value::*;

        match self {
            Invalid => unreachable!("Should not be able to visit an invalid value"),
            U8(val) => visitor.visit_u8(depth, *val),
            U16(val) => visitor.visit_u16(depth, *val),
            U32(val) => visitor.visit_u32(depth, *val),
            U64(val) => visitor.visit_u64(depth, *val),
            U128(val) => visitor.visit_u128(depth, *val),
            U256(val) => visitor.visit_u256(depth, val.as_ref()),
            I8(val) => visitor.visit_i8(depth, *val),
            I16(val) => visitor.visit_i16(depth, *val),
            I32(val) => visitor.visit_i32(depth, *val),
            I64(val) => visitor.visit_i64(depth, *val),
            I128(val) => visitor.visit_i128(depth, *val),
            I256(val) => visitor.visit_i256(depth, val.as_ref()),
            Bool(val) => visitor.visit_bool(depth, *val),
            Address(val) => visitor.visit_address(depth, val.as_ref()),
            Container(c) => c.visit_impl(visitor, depth),
            ContainerRef(r) => r.visit_impl(visitor, depth),
            IndexedRef(r) => r.visit_impl(visitor, depth),
            ClosureValue(c) => c.visit_impl(visitor, depth),
            DelayedFieldID { id } => visitor.visit_delayed(depth, *id),
        }
    }
```

**File:** crates/crash-handler/src/lib.rs (L26-58)
```rust
pub fn setup_panic_handler() {
    panic::set_hook(Box::new(move |pi: &PanicHookInfo<'_>| {
        handle_panic(pi);
    }));
}

// Formats and logs panic information
fn handle_panic(panic_info: &PanicHookInfo<'_>) {
    // The Display formatter for a PanicHookInfo contains the message, payload and location.
    let details = format!("{}", panic_info);
    let backtrace = format!("{:#?}", Backtrace::new());

    let info = CrashInfo { details, backtrace };
    let crash_info = toml::to_string_pretty(&info).unwrap();
    error!("{}", crash_info);
    // TODO / HACK ALARM: Write crash info synchronously via eprintln! to ensure it is written before the process exits which error! doesn't guarantee.
    // This is a workaround until https://github.com/aptos-labs/aptos-core/issues/2038 is resolved.
    eprintln!("{}", crash_info);

    // Wait till the logs have been flushed
    aptos_logger::flush();

    // Do not kill the process if the panics happened at move-bytecode-verifier.
    // This is safe because the `state::get_state()` uses a thread_local for storing states. Thus the state can only be mutated to VERIFIER by the thread that's running the bytecode verifier.
    //
    // TODO: once `can_unwind` is stable, we should assert it. See https://github.com/rust-lang/rust/issues/92988.
    if state::get_state() == VMState::VERIFIER || state::get_state() == VMState::DESERIALIZER {
        return;
    }

    // Kill the process
    process::exit(12);
}
```
