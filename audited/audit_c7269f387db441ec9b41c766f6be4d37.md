# Audit Report

## Title
Consensus Safety Violation Through Unsynchronized BlockTransactionFilterConfig Across Validators

## Summary
The `BlockTransactionFilterConfig` used for consensus proposal validation is loaded from each validator's local configuration file and never synchronized across the validator set. This allows different validators to have inconsistent transaction filtering policies, causing them to disagree on block validity and violating consensus safety guarantees.

## Finding Description

The Aptos consensus protocol uses `BlockTransactionFilterConfig` to determine whether block proposals containing certain inline transactions should be rejected. However, this configuration suffers from a critical design flaw:

**Configuration Source and Lifecycle:** [1](#0-0) 

The configuration is loaded once from the local `NodeConfig` during `EpochManager` initialization and never updated from on-chain configs or synchronized with other validators. [2](#0-1) 

Each epoch's `RoundManager` receives a clone of this same configuration, meaning changes only take effect after node restart.

**Consensus Decision Impact:** [3](#0-2) 

When a validator processes a block proposal, it checks inline transactions against its local filter configuration. If denied transactions are found, the validator **refuses to vote** on that block, incrementing the rejection counter.

**Filter Behavior Divergence:** [4](#0-3) 

The filter's `is_enabled()` method returns true only if both the flag is set and the filter is non-empty. This creates three possible states across validators:
1. Filter completely disabled (returns all transactions as valid)
2. Filter enabled with ruleset A
3. Filter enabled with ruleset B [5](#0-4) 

If a validator's filter is disabled, `check_denied_inline_transactions` immediately returns `Ok(())`, accepting all transactions.

**Attack Scenario:**
1. Network operates normally with all validators having `filter_enabled: false` (default)
2. Validator operator A modifies their local config to enable filtering with specific rules
3. Validator A restarts, loading the new configuration
4. Malicious proposer creates a block containing inline transactions that match Validator A's filter rules
5. Validator A rejects the proposal and doesn't vote (per line 1209-1213 in round_manager.rs)
6. Other validators (B, C, D) with disabled filters accept and vote for the same block
7. **Validators disagree on block validity, violating consensus safety**

The configuration is also used during block execution: [6](#0-5) [7](#0-6) 

This means validators may filter different transactions during execution, potentially causing state divergence.

## Impact Explanation

**Severity: Critical** (Consensus Safety Violation)

This vulnerability breaks two fundamental invariants:

1. **Consensus Safety** - AptosBFT's safety guarantee requires that honest validators agree on block validity. Divergent filtering policies cause validators to vote differently on the same proposal, potentially leading to:
   - Equivocation (validators signing conflicting blocks)
   - Liveness failures (inability to reach quorum on valid blocks)
   - Chain splits in adversarial scenarios

2. **Deterministic Execution** - Different validators may execute different transaction sets from the same block, producing different state roots and breaking state consistency.

Per the Aptos bug bounty criteria, consensus safety violations qualify for **Critical Severity** (up to $1,000,000) as they can cause "Non-recoverable network partition (requires hardfork)" and "Consensus/Safety violations."

## Likelihood Explanation

**Likelihood: High**

While this requires a validator operator to modify their configuration, the likelihood is high because:

1. **No Warning or Validation** - The system provides no indication that changing this config breaks consensus invariants
2. **Legitimate Reasons** - Operators may change configs for seemingly legitimate reasons (spam prevention, compliance requirements)
3. **Accidental Drift** - Different operators using different deployment scripts or configs naturally leads to inconsistency
4. **No Detection** - There's no runtime mechanism to detect or alert on configuration mismatches across validators
5. **Persistent State** - Once configuration divergence occurs, it persists until all validators synchronize their configs

The configuration is read from YAML files: [8](#0-7) 

Making it easy for operators to modify without understanding consensus implications.

## Recommendation

**Immediate Fix:** Move `BlockTransactionFilterConfig` to on-chain governance configuration, similar to other consensus-critical parameters.

**Implementation Steps:**

1. Add a new on-chain resource `BlockTransactionFilterConfigResource` to the framework
2. Update `start_new_epoch` in EpochManager to read filter config from on-chain payload:

```rust
async fn start_new_epoch(&mut self, payload: OnChainConfigPayload<P>) {
    // ... existing code ...
    
    // Read transaction filter config from on-chain state
    let onchain_txn_filter_config: anyhow::Result<BlockTransactionFilterConfig> = 
        payload.get();
    
    if let Ok(config) = onchain_txn_filter_config {
        self.consensus_txn_filter_config = config;
    } else {
        warn!("Failed to read on-chain transaction filter config, using default");
    }
}
```

3. Create governance proposal mechanism for updating transaction filter config (similar to consensus_config.rs)
4. Add validation at epoch start to ensure all validators receive identical configs

**Alternative (Defense in Depth):** If local configs must be retained for flexibility, add mandatory consistency checks:
- Hash all consensus-affecting configs and include in block proposals
- Validators reject blocks with mismatched config hashes
- Alert operators when local config diverges from on-chain config

## Proof of Concept

**Scenario Setup:**
```rust
// Node A config (validator.yaml):
transaction_filters:
  consensus_filter:
    filter_enabled: true
    block_transaction_filter:
      rules:
        - Deny
      matchers:
        - Sender: "0xBADADD6355"

// Node B,C,D config:
transaction_filters:
  consensus_filter:
    filter_enabled: false  # Default
```

**Exploitation Steps:**
1. Deploy 4-validator network with configs above
2. Wait for Validator A to restart with new config
3. Submit transaction from address `0xBADADD6355` to mempool
4. Validator X proposes block containing this inline transaction
5. **Expected Result:**
   - Validator A calls `check_denied_inline_transactions()`, sees denied transaction, refuses to vote
   - Validators B, C, D have filter disabled, accept proposal and vote
   - With 3/4 votes, block may be certified despite Validator A's objection
   - Network continues but Validator A is out of sync on which blocks are "valid"
6. **If Validator A is the proposer:**
   - Validator A filters the transaction during block preparation
   - Other validators expect it in the block based on mempool state
   - Validators may disagree on expected block contents

**Validation:**
Monitor counters: [9](#0-8) 

Validator A will show increasing `REJECTED_PROPOSAL_DENY_TXN_COUNT` while others show zero.

---

**Notes:**
- No on-chain mechanism exists to enforce uniform transaction filtering policies across validators
- The `TransactionFiltersConfig` structure is entirely local to each node
- Epoch transitions do not update or validate filter configurations
- This creates a permanent risk of configuration drift causing consensus failures

### Citations

**File:** consensus/src/epoch_manager.rs (L211-213)
```rust
        let consensus_txn_filter_config = node_config.transaction_filters.consensus_filter.clone();
        let quorum_store_txn_filter_config =
            node_config.transaction_filters.quorum_store_filter.clone();
```

**File:** consensus/src/epoch_manager.rs (L982-982)
```rust
            self.consensus_txn_filter_config.clone(),
```

**File:** consensus/src/round_manager.rs (L1204-1214)
```rust
        if let Err(error) = self
            .block_store
            .check_denied_inline_transactions(&proposal, &self.block_txn_filter_config)
        {
            counters::REJECTED_PROPOSAL_DENY_TXN_COUNT.inc();
            bail!(
                "[RoundManager] Proposal for block {} contains denied inline transactions: {}. Dropping proposal!",
                proposal.id(),
                error
            );
        }
```

**File:** config/src/config/transaction_filters_config.rs (L105-108)
```rust
    /// Returns true iff the filter is enabled and not empty
    pub fn is_enabled(&self) -> bool {
        self.filter_enabled && !self.block_transaction_filter.is_empty()
    }
```

**File:** consensus/src/payload_manager/direct_mempool_payload_manager.rs (L35-38)
```rust
        // If the filter is disabled, return early
        if !block_txn_filter_config.is_enabled() {
            return Ok(());
        }
```

**File:** consensus/src/state_computer.rs (L79-79)
```rust
            txn_filter_config: Arc::new(txn_filter_config),
```

**File:** consensus/src/block_preparer.rs (L80-80)
```rust
        let txn_filter_config = self.txn_filter_config.clone();
```

**File:** config/src/config/node_config.rs (L87-87)
```rust
    pub transaction_filters: TransactionFiltersConfig,
```
