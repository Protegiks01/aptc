# Audit Report

## Title
Resource Exhaustion via Oversized Script Code Vector Bypassing Transaction Size Validation

## Summary
The transaction processing pipeline deserializes Script payloads containing arbitrarily large code vectors before enforcing the 64 KB transaction size limit. This allows attackers to force validators to allocate up to 8 MB (via REST API) or 64 MB (via P2P network) per transaction before rejection, enabling memory exhaustion attacks on validator nodes.

## Finding Description

The vulnerability arises from improper ordering of validation checks in the transaction processing pipeline:

**1. No size validation in Script constructor:**
The `Script::new()` function accepts code vectors of any size without validation. [1](#0-0) 

**2. Mismatched size limits across layers:**

- REST API HTTP body limit: 8 MB [2](#0-1) 

- P2P network message limit: 64 MB [3](#0-2) 

- Intended transaction size limit: 64 KB [4](#0-3) 

**3. BCS deserialization limits depth, not size:**
Transaction deserialization uses `bcs::from_bytes_with_limit` with `MAX_SIGNED_TRANSACTION_DEPTH = 16`, which only constrains nesting depth, not total byte size. [5](#0-4) [6](#0-5) 

**4. Size validation occurs after full deserialization:**
The 64 KB transaction size check in `check_gas()` is called during VM validation, after BCS deserialization has already allocated memory for the entire transaction. [7](#0-6) [8](#0-7) 

**Attack Execution Flow:**

**Via REST API:**
1. HTTP POST with Content-Length ≤ 8 MB passes `PostSizeLimit` middleware [9](#0-8) 

2. BCS deserializes entire SignedTransaction, allocating memory for 7+ MB Script code vector
3. Transaction enters mempool and VM validation pipeline
4. `check_gas()` rejects transaction for exceeding 64 KB limit
5. Memory allocated in step 2 (128x intended limit)

**Via P2P Network:**
1. `MempoolSyncMsg::BroadcastTransactionsRequest` with transactions containing large Script payloads (≤ 64 MB) passes network layer [10](#0-9) 

2. Network layer deserializes entire message, allocating memory for 60+ MB Script code vectors
3. Same validation pipeline rejects for exceeding 64 KB
4. Memory allocated in step 2 (1024x intended limit)

By sending 100 concurrent malicious transactions via API, an attacker forces allocation of ~800 MB (vs intended 6.4 MB), or via P2P forces multiple GB allocation per validator.

## Impact Explanation

This qualifies as **HIGH severity** under Aptos bug bounty category 8: "Validator Node Slowdowns."

**Concrete Impacts:**
- **Memory pressure**: Sustained attacks allocate 128x-1024x more memory than intended per transaction
- **Performance degradation**: Memory exhaustion causes validator slowdowns affecting consensus participation
- **Crash potential**: Concurrent malicious transactions can exhaust available memory, crashing validator processes
- **Network liveness risk**: If multiple validators crash simultaneously, the network experiences liveness degradation

This directly matches the bounty program example: "Gas calculation bug causes validator slowdowns" - both involve improper validation ordering allowing disproportionate resource consumption.

The vulnerability breaks the resource limit invariant: all operations must respect computational and memory limits. The gap between enforced limits (8 MB API / 64 MB P2P) and intended limits (64 KB) represents a critical resource management failure.

## Likelihood Explanation

**HIGH likelihood** of exploitation:

**Attack Requirements:**
- No special privileges - any API user or network peer can exploit
- No cryptographic capabilities needed
- No consensus manipulation required

**Execution Simplicity:**
- Craft SignedTransaction with Script containing large code vector
- Submit via public REST API endpoint or broadcast via P2P
- No timing constraints or complex state manipulation

**Amplification Factors:**
- 100 concurrent API requests = 800 MB allocation (vs 6.4 MB intended)
- Multiple validators simultaneously targeted = network-wide impact
- Both API and P2P attack vectors available

**Detection Difficulty:**
- Transactions appear legitimate until size validation
- Pre-validation exploitation makes rate limiting ineffective
- Standard monitoring may not detect oversized deserialization before rejection

## Recommendation

Implement early size validation before BCS deserialization:

**Option 1: Pre-deserialization size check**
Add Content-Length validation against transaction size limit (64 KB) in API middleware before deserialization, not just HTTP body limit (8 MB).

**Option 2: BCS deserialization with byte limit**
Modify BCS deserialization calls to include byte-size limits in addition to depth limits, rejecting payloads exceeding 64 KB during deserialization.

**Option 3: Script constructor validation**
Add size validation in `Script::new()` to reject code vectors exceeding reasonable limits before construction.

**Recommended approach:** Implement Option 1 for API path and add validation at network message deserialization layer for P2P path, ensuring size checks occur before memory allocation.

## Proof of Concept

```rust
// Craft malicious transaction with 7 MB Script code vector
let large_code = vec![0u8; 7 * 1024 * 1024]; // 7 MB
let script = Script::new(large_code, vec![], vec![]);
let payload = TransactionPayload::Script(script);
let raw_txn = RawTransaction::new(..., payload, ...);
let signed_txn = SignedTransaction::new(...);

// Submit via API - passes 8 MB limit, allocates 7 MB before rejection
// POST /v1/transactions with BCS-encoded signed_txn
// Result: Memory allocated, then EXCEEDED_MAX_TRANSACTION_SIZE error

// Via P2P: Similar approach with 60 MB code vector in MempoolSyncMsg
```

The vulnerability is demonstrable by monitoring memory allocation during transaction processing and observing that oversized transactions allocate full payload size before rejection at `check_gas()` validation.

### Citations

**File:** types/src/transaction/script.rs (L72-78)
```rust
    pub fn new(code: Vec<u8>, ty_args: Vec<TypeTag>, args: Vec<TransactionArgument>) -> Self {
        Script {
            code,
            ty_args,
            args,
        }
    }
```

**File:** config/src/config/api_config.rs (L97-97)
```rust
const DEFAULT_REQUEST_CONTENT_LENGTH_LIMIT: u64 = 8 * 1024 * 1024; // 8 MB
```

**File:** config/src/config/network_config.rs (L50-50)
```rust
pub const MAX_MESSAGE_SIZE: usize = 64 * 1024 * 1024; /* 64 MiB */
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L73-76)
```rust
            max_transaction_size_in_bytes: NumBytes,
            "max_transaction_size_in_bytes",
            64 * 1024
        ],
```

**File:** api/src/transactions.rs (L851-851)
```rust
    const MAX_SIGNED_TRANSACTION_DEPTH: usize = 16;
```

**File:** api/src/transactions.rs (L1223-1232)
```rust
                let signed_transaction: SignedTransaction =
                    bcs::from_bytes_with_limit(&data.0, Self::MAX_SIGNED_TRANSACTION_DEPTH)
                        .context("Failed to deserialize input into SignedTransaction")
                        .map_err(|err| {
                            SubmitTransactionError::bad_request_with_code(
                                err,
                                AptosErrorCode::InvalidInput,
                                ledger_info,
                            )
                        })?;
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L2805-2814)
```rust
        check_gas(
            self.gas_params(log_context)?,
            self.gas_feature_version(),
            session.resolver,
            module_storage,
            txn_data,
            self.features(),
            is_approved_gov_script,
            log_context,
        )?;
```

**File:** aptos-move/aptos-vm/src/gas.rs (L109-121)
```rust
    } else if txn_metadata.transaction_size > txn_gas_params.max_transaction_size_in_bytes {
        speculative_warn!(
            log_context,
            format!(
                "[VM] Transaction size too big {} (max {})",
                txn_metadata.transaction_size, txn_gas_params.max_transaction_size_in_bytes
            ),
        );
        return Err(VMStatus::error(
            StatusCode::EXCEEDED_MAX_TRANSACTION_SIZE,
            None,
        ));
    }
```

**File:** api/src/check_size.rs (L43-58)
```rust
    async fn call(&self, req: Request) -> Result<Self::Output> {
        if req.method() != Method::POST {
            return self.inner.call(req).await;
        }

        let content_length = req
            .headers()
            .typed_get::<headers::ContentLength>()
            .ok_or(SizedLimitError::MissingContentLength)?;

        if content_length.0 > self.max_size {
            return Err(SizedLimitError::PayloadTooLarge.into());
        }

        self.inner.call(req).await
    }
```

**File:** mempool/src/shared_mempool/network.rs (L48-54)
```rust
pub enum MempoolSyncMsg {
    /// Broadcast request issued by the sender.
    BroadcastTransactionsRequest {
        /// Unique id of sync request. Can be used by sender for rebroadcast analysis
        message_id: MempoolMessageId,
        transactions: Vec<SignedTransaction>,
    },
```
