# Audit Report

## Title
Backup Poisoning via Unverified Ledger Info Import in Epoch Ending Restore

## Summary
The epoch ending restore process fails to cryptographically verify the first ledger info when restoring backups without trusted waypoints, allowing attackers who compromise backup storage to inject malicious ledger infos that corrupt the validator database, causing startup failure and validator unavailability.

## Finding Description

The vulnerability exists in the epoch ending ledger info restoration logic within `EpochEndingRestoreController::preheat_impl`. The system should cryptographically verify each `LedgerInfoWithSignatures` before accepting it into the database, but contains a critical verification gap. [1](#0-0) 

The verification has two branches: (1) verify against trusted waypoint if one exists for that version, or (2) verify signatures using the previous ledger info's validator set. However, if **both conditions fail** (no trusted waypoint AND no previous ledger info), the code falls through without any cryptographic verification. [2](#0-1) 

The `previous_li` variable is initialized as `None`, making the **first ledger info in any restore vulnerable** when no trusted waypoint is provided. [3](#0-2) 

Trusted waypoints are optional CLI parameters (`--trust-waypoint`) with an empty default value. The `TrustedWaypointOpt` struct uses the `Default` trait, allowing operators to inadvertently skip this security check. [4](#0-3) 

After the failed verification checks, the unverified ledger info is immediately added to the list. [5](#0-4) 

The unverified ledger infos are then saved to the database through the restore handler. [6](#0-5) 

**Attack Scenario:**
1. Attacker compromises backup storage or performs MitM during backup retrieval
2. Attacker creates malicious backup with fake genesis ledger info containing attacker-controlled validator set in `next_epoch_state`
3. Attacker creates manifest with waypoints matching the fake ledger infos (passes structural validation only)
4. Victim restores backup without providing `--trust-waypoint` CLI parameters
5. First ledger info bypasses both verification checks and is saved to database
6. Subsequent ledger infos are verified against the fake validator set, forming a complete fake chain
7. When validator starts, consensus initialization retrieves the epoch change proof from storage [7](#0-6) 

8. SafetyRules attempts to verify the proof against the configured genesis waypoint [8](#0-7) 

9. Waypoint verification detects hash mismatch between fake ledger info and correct genesis waypoint [9](#0-8) 

10. Consensus initialization fails, preventing validator startup

## Impact Explanation

This vulnerability qualifies as **High Severity** per Aptos bug bounty categories:

**Validator Node Unavailability (High Severity - Guaranteed):**
- When the validator attempts to start, consensus initialization calls `EpochChangeProof::verify()` with the configured genesis waypoint as verifier
- The waypoint verification checks both version and hash, detecting the mismatch with the fake ledger info
- Consensus initialization fails with verification error, preventing the validator from starting
- Creates a Denial of Service condition requiring manual intervention: operators must wipe the corrupted database and re-restore from a clean backup source
- Results in extended validator downtime and operational disruption

**Silent Database Corruption:**
- The restore process completes "successfully" without any error or warning
- Operators remain unaware the database contains invalid data until node startup fails
- No audit trail or indication of which backup source was compromised

Per Aptos bug bounty rules, validator node unavailability due to exploitable vulnerabilities qualifies as High Severity (up to $50,000).

## Likelihood Explanation

**Likelihood: Medium-High**

**Factors Increasing Likelihood:**
1. **Optional Security Parameter**: Trusted waypoints are optional CLI flags with no enforcement mechanism or warning when omitted
2. **Default Behavior is Insecure**: The `Default` trait on `TrustedWaypointOpt` means operators who don't explicitly provide waypoints get no verification
3. **Realistic Threat Model**: Compromised backup storage is a documented threat for blockchain infrastructure - backups may be stored in cloud storage, network shares, or third-party services with varying security postures
4. **Operator Error**: Documentation mentions waypoints "confirm the backup is compatible" but doesn't emphasize this is a critical security requirement to prevent database poisoning

**Factors Decreasing Likelihood:**
1. **Detected on Startup**: The waypoint check during consensus initialization will detect corruption before the validator can participate in consensus, limiting impact to DoS rather than consensus compromise
2. **Requires Backup Access**: Attacker needs ability to modify backup data or perform man-in-the-middle attack during backup retrieval

## Recommendation

**Immediate Fix:**
1. Make trusted waypoints **mandatory** for epoch ending restore operations, failing fast if not provided for genesis/epoch 0
2. Add explicit validation that refuses to restore without at least a genesis waypoint

**Code Fix:**
```rust
// In preheat_impl, before processing first ledger info:
if next_epoch == 0 && self.trusted_waypoints.get(&0).is_none() {
    return Err(anyhow!(
        "SECURITY: Genesis waypoint is required for epoch ending restore. \
        Use --trust-waypoint to specify the genesis waypoint from a trusted source. \
        Never restore backups without waypoint verification as this allows database poisoning."
    ));
}
```

**Additional Mitigations:**
1. Add warning logs when restoring without waypoints
2. Document in restore CLI help that waypoints are a critical security requirement, not optional
3. Consider adding manifest signing/verification to detect tampered backups at load time
4. Add integration test that validates restore correctly rejects unverified epoch 0 ledger info

## Proof of Concept

```rust
// Test demonstrating the vulnerability
#[tokio::test]
async fn test_restore_accepts_unverified_genesis_without_waypoint() {
    // Setup: Create malicious backup with fake genesis ledger info
    let fake_validator_set = create_fake_validator_set();
    let fake_genesis_li = create_fake_genesis_ledger_info(fake_validator_set);
    let manifest = create_manifest_with_fake_waypoint(&fake_genesis_li);
    
    // Restore without providing --trust-waypoint
    let global_opt = GlobalRestoreOptions {
        trusted_waypoints: Arc::new(HashMap::new()), // Empty!
        // ... other options
    };
    
    let controller = EpochEndingRestoreController::new(
        EpochEndingRestoreOpt { manifest_handle },
        global_opt,
        storage,
    );
    
    // Vulnerability: Restore succeeds without verifying first ledger info
    let result = controller.run(None).await;
    assert!(result.is_ok()); // Should fail but doesn't!
    
    // Validator startup will fail due to waypoint mismatch
    let genesis_waypoint = Waypoint::new_epoch_boundary(&real_genesis_li).unwrap();
    let proof = storage.get_state_proof(0).unwrap();
    let verify_result = proof.verify(&genesis_waypoint);
    assert!(verify_result.is_err()); // Startup fails!
}
```

## Notes

This vulnerability represents a failure in defense-in-depth for the backup restore process. While the waypoint check during consensus initialization provides a safety net that prevents the worst-case scenario (consensus compromise), the restore process should independently verify data integrity. The current design allows corrupted data to silently enter the database, violating the principle that storage operations should maintain cryptographic verification at all layers.

The vulnerability is in-scope as it affects the storage system's restore verification logic (`storage/backup/backup-cli/`), not as a CLI parsing issue but as a core security gap in the cryptographic verification flow.

### Citations

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L88-88)
```rust
        let mut previous_li: Option<&LedgerInfoWithSignatures> = None;
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L129-147)
```rust
                if let Some(wp_trusted) = self.trusted_waypoints.get(&wp_li.version()) {
                    ensure!(
                        *wp_trusted == wp_li,
                        "Waypoints don't match. In backup: {}, trusted: {}",
                        wp_li,
                        wp_trusted,
                    );
                } else if let Some(pre_li) = previous_li {
                    pre_li
                        .ledger_info()
                        .next_epoch_state()
                        .ok_or_else(|| {
                            anyhow!(
                                "Next epoch state not found from LI at epoch {}.",
                                pre_li.ledger_info().epoch()
                            )
                        })?
                        .verify(&li)?;
                }
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L148-148)
```rust
                ledger_infos.push(li);
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L249-249)
```rust
                restore_handler.save_ledger_infos(&preheat_data.ledger_infos)?;
```

**File:** storage/backup/backup-cli/src/utils/mod.rs (L331-346)
```rust
#[derive(Clone, Default, Parser)]
pub struct TrustedWaypointOpt {
    #[clap(
        long,
        help = "(multiple) When provided, an epoch ending LedgerInfo at the waypoint version will be \
        checked against the hash in the waypoint, but signatures on it are NOT checked. \
        Use this for two purposes: \
        1. set the genesis or the latest waypoint to confirm the backup is compatible. \
        2. set waypoints at versions where writeset transactions were used to overwrite the \
        validator set, so that the signature check is skipped. \
        N.B. LedgerInfos are verified only when restoring / verifying the epoch ending backups, \
        i.e. they are NOT checked at all when doing one-shot restoring of the transaction \
        and state backups."
    )]
    pub trust_waypoint: Vec<Waypoint>,
}
```

**File:** storage/aptosdb/src/backup/restore_utils.rs (L41-58)
```rust
pub(crate) fn save_ledger_infos(
    ledger_metadata_db: &LedgerMetadataDb,
    ledger_infos: &[LedgerInfoWithSignatures],
    existing_batch: Option<&mut SchemaBatch>,
) -> Result<()> {
    ensure!(!ledger_infos.is_empty(), "No LedgerInfos to save.");

    if let Some(existing_batch) = existing_batch {
        save_ledger_infos_impl(ledger_metadata_db, ledger_infos, existing_batch)?;
    } else {
        let mut batch = SchemaBatch::new();
        save_ledger_infos_impl(ledger_metadata_db, ledger_infos, &mut batch)?;
        ledger_metadata_db.write_schemas(batch)?;
        update_latest_ledger_info(ledger_metadata_db, ledger_infos)?;
    }

    Ok(())
}
```

**File:** consensus/src/persistent_liveness_storage.rs (L607-614)
```rust
    fn retrieve_epoch_change_proof(&self, version: u64) -> Result<EpochChangeProof> {
        let (_, proofs) = self
            .aptos_db
            .get_state_proof(version)
            .map_err(DbError::from)?
            .into_inner();
        Ok(proofs)
    }
```

**File:** consensus/safety-rules/src/safety_rules.rs (L265-269)
```rust
    fn guarded_initialize(&mut self, proof: &EpochChangeProof) -> Result<(), Error> {
        let waypoint = self.persistent_storage.waypoint()?;
        let last_li = proof
            .verify(&waypoint)
            .map_err(|e| Error::InvalidEpochChangeProof(format!("{}", e)))?;
```

**File:** types/src/waypoint.rs (L62-79)
```rust
    pub fn verify(&self, ledger_info: &LedgerInfo) -> Result<()> {
        ensure!(
            ledger_info.version() == self.version(),
            "Waypoint version mismatch: waypoint version = {}, given version = {}",
            self.version(),
            ledger_info.version()
        );
        let converter = Ledger2WaypointConverter::new(ledger_info);
        ensure!(
            converter.hash() == self.value(),
            format!(
                "Waypoint value mismatch: waypoint value = {}, given value = {}",
                self.value().to_hex(),
                converter.hash().to_hex()
            )
        );
        Ok(())
    }
```
