# Audit Report

## Title
OnDiskStorage Exposes Validator Consensus Private Keys Through Insufficient Filesystem Permissions and Missing Application-Level Policy Enforcement

## Summary
The `OnDiskStorage` implementation in Aptos Core lacks both application-level policy enforcement and restrictive filesystem permissions when storing validator consensus private keys. This allows unauthorized local processes to read the `secure-data.json` file containing BLS12-381 private keys in plaintext, enabling validator impersonation and consensus safety violations.

## Finding Description

The security question correctly identifies a critical vulnerability: **OnDiskStorage has no application-level policy enforcement and relies solely on filesystem ACLs, which can be misconfigured to expose validator private keys.**

### Missing Application-Level Policy Enforcement

The `Policy` struct exists in the codebase [1](#0-0)  but `OnDiskStorage` never enforces it. The `KVStorage` trait documentation explicitly states that policies should be "enforced internally by the actual backend" [2](#0-1) , but `OnDiskStorage` provides no such enforcement [3](#0-2) .

In contrast, `VaultStorage` has a dedicated `VaultPolicy` wrapper that enforces policies [4](#0-3) , including permission checks for read, write, export, sign, and rotate operations [5](#0-4) .

### No Restrictive File Permissions

`OnDiskStorage` creates files using standard `File::create()` without setting restrictive permissions [6](#0-5) . The temporary file used during writes also lacks permission restrictions [7](#0-6) .

The codebase demonstrates the correct pattern for setting secure file permissions (`mode 0o600`) [8](#0-7) , but this pattern is **not applied** to `OnDiskStorage`.

Files created with `File::create()` inherit permissions from the system umask, typically resulting in mode `0644` (world-readable) or `0664` (group-readable), depending on configuration.

### Validator Consensus Keys Stored in Plaintext

Validator consensus private keys (BLS12-381) are stored using `OnDiskStorage` through `PersistentSafetyStorage` [9](#0-8) . The keys are stored under the `CONSENSUS_KEY` constant [10](#0-9) .

These keys are serialized to hex-encoded strings in JSON format via the `SerializeKey` macro [11](#0-10) , which uses `to_encoded_string()` to produce `"0x" + hex(private_key_bytes)` [12](#0-11) .

### Used in Validator Deployments

Despite documentation warnings, `OnDiskStorage` appears in validator configuration files:
- Docker Compose deployments [13](#0-12) 
- Kubernetes Helm charts [14](#0-13) 
- Test network templates [15](#0-14) 

Critically, the `ConfigSanitizer` only prevents `InMemoryStorage` on mainnet [16](#0-15)  but does **not** prevent `OnDiskStorage`, allowing it to be used on production validators.

### Exploitation Path

1. **Attacker gains local filesystem read access** through:
   - Compromised container or sidecar in the same Kubernetes pod
   - Process running as user `6180` (the validator user) [17](#0-16) 
   - Misconfigured shared volumes or backup tools
   - Container escape vulnerability

2. **Attacker reads `secure-data.json`** (world-readable or group-readable due to insufficient permissions)

3. **Attacker extracts consensus private key** by parsing JSON under the `"consensus"` key

4. **Attacker signs malicious consensus messages** using the stolen BLS12-381 private key

5. **Consensus safety violation occurs**:
   - Equivocation (signing conflicting blocks at same height)
   - Double-signing votes
   - Malicious timeout certificates
   - Forged quorum certificates

## Impact Explanation

This vulnerability qualifies as **Critical Severity** under the Aptos Bug Bounty program for the following reasons:

**Consensus/Safety Violations**: An attacker with the validator's consensus private key can sign arbitrary consensus messages, violating the fundamental safety guarantee that "AptosBFT must prevent double-spending and chain splits under < 1/3 Byzantine" [18](#0-17) . The `ValidatorSigner` uses this key to sign blocks, votes, and timeouts, which are core consensus operations.

**Cryptographic Correctness Violation**: The invariant that "BLS signatures, VRF, and hash operations must be secure" is broken when private keys can be exfiltrated through filesystem access.

**Access Control Failure**: While the documented invariant focuses on system addresses, the extended principle that critical cryptographic material must be protected is violated.

The potential impacts include:
- Validator impersonation enabling consensus manipulation
- Chain splits if conflicting blocks are signed
- Loss of stake for equivocation (slashing)
- Network liveness degradation
- Loss of confidence in validator security

## Likelihood Explanation

**Likelihood: Medium to High**

The vulnerability requires local filesystem access, which is realistic in several scenarios:

1. **Container environments**: Kubernetes pods can run multiple containers sharing the same filesystem namespace. A compromised sidecar container (monitoring, logging, backup agent) could access validator keys.

2. **Process co-location**: Any process running as user `6180` can read files created by the validator process if permissions are `0644` or `0664`.

3. **Configuration errors**: Operators may inadvertently configure shared volumes or backup systems that expose the storage directory.

4. **Development/testing spillover**: Configurations using `OnDiskStorage` for testing may accidentally reach production environments since `ConfigSanitizer` doesn't prevent it.

The likelihood is elevated because:
- The vulnerability is present by default in the code (no permissions set)
- Multiple validator deployment examples show `OnDiskStorage` usage
- No config validation prevents its use on mainnet
- Defense-in-depth is absent (no application-level policy enforcement)

## Recommendation

### Immediate Mitigations

1. **Set restrictive file permissions in `OnDiskStorage`**: [19](#0-18) 

Apply the pattern from `write_to_user_only_file`:

```rust
fn new_with_time_service(file_path: PathBuf, time_service: TimeService) -> Self {
    if !file_path.exists() {
        let mut opts = fs::OpenOptions::new();
        opts.write(true).create(true);
        #[cfg(unix)]
        opts.mode(0o600); // User read/write only
        opts.open(&file_path)
            .unwrap_or_else(|_| panic!("Unable to create storage at path: {:?}", file_path));
    }
    // ... rest of implementation
}

fn write(&self, data: &HashMap<String, Value>) -> Result<(), Error> {
    let contents = serde_json::to_vec(data)?;
    let mut opts = fs::OpenOptions::new();
    opts.write(true).create(true);
    #[cfg(unix)]
    opts.mode(0o600);
    let mut file = opts.open(self.temp_path.path())?;
    file.write_all(&contents)?;
    fs::rename(&self.temp_path, &self.file_path)?;
    Ok(())
}
```

2. **Add `ConfigSanitizer` check** to prevent `OnDiskStorage` on mainnet validators: [16](#0-15) 

Extend validation to check for `OnDiskStorage`:

```rust
if chain_id.is_mainnet() && node_type.is_validator() {
    if safety_rules_config.backend.is_in_memory() {
        return Err(Error::ConfigSanitizerFailed(
            sanitizer_name,
            "The secure backend should not be set to in memory storage in mainnet!".to_string(),
        ));
    }
    if matches!(safety_rules_config.backend, SecureBackend::OnDiskStorage(_)) {
        return Err(Error::ConfigSanitizerFailed(
            sanitizer_name,
            "OnDiskStorage provides no security guarantees and must not be used for mainnet validators! Use Vault instead.".to_string(),
        ));
    }
}
```

3. **Implement application-level policy enforcement** for `OnDiskStorage` (or deprecate it entirely for production use).

4. **Add runtime warnings** when `OnDiskStorage` is initialized with validator keys.

5. **Update deployment documentation** to strongly recommend Vault for all production validators.

## Proof of Concept

### Rust Reproduction Steps

```rust
// File: secure/storage/src/tests/file_permission_test.rs
#[cfg(unix)]
#[test]
fn test_ondisk_file_permissions_vulnerability() {
    use std::fs;
    use std::os::unix::fs::PermissionsExt;
    use crate::{OnDiskStorage, Storage, KVStorage};
    use aptos_temppath::TempPath;
    
    // Create OnDiskStorage with a consensus key
    let path_buf = TempPath::new().path().to_path_buf();
    let mut storage = Storage::from(OnDiskStorage::new(path_buf.clone()));
    
    // Store a mock consensus key
    storage.set("consensus", "0xDEADBEEF_SECRET_KEY").unwrap();
    
    // Check file permissions
    let metadata = fs::metadata(&path_buf).unwrap();
    let permissions = metadata.permissions();
    let mode = permissions.mode();
    
    // Verify vulnerability: file is world-readable or group-readable
    // Mode 0o100644 = regular file with rw-r--r-- (world-readable)
    // Mode 0o100664 = regular file with rw-rw-r-- (group-readable)
    assert!(
        (mode & 0o044) != 0,
        "VULNERABILITY CONFIRMED: File is readable by non-owner (mode: {:o})",
        mode
    );
    
    // This proves any process can read the consensus key
    let contents = fs::read_to_string(&path_buf).unwrap();
    assert!(contents.contains("DEADBEEF_SECRET_KEY"));
    println!("EXPLOIT: Successfully read consensus key from world/group-readable file!");
}
```

### Attack Simulation

```bash
#!/bin/bash
# Simulating an attacker with local filesystem access

# 1. List validator data directory
ls -la /opt/aptos/data/

# 2. Check permissions on secure-data.json
ls -l /opt/aptos/data/secure-data.json
# Expected output: -rw-r--r-- (world-readable) or -rw-rw-r-- (group-readable)

# 3. Read consensus private key
cat /opt/aptos/data/secure-data.json | jq '.consensus.value'
# Output: "0x<hex_encoded_bls12381_private_key>"

# 4. Attacker can now use this key to sign malicious consensus messages
# and impersonate the validator
```

## Notes

This vulnerability exists due to a fundamental design gap in `OnDiskStorage`: it lacks the security properties required for storing consensus-critical cryptographic material. While the README warns against production use [20](#0-19) , the code itself provides no enforcement mechanisms.

The vulnerability is particularly concerning because:
- Kubernetes deployments show `OnDiskStorage` configuration in base templates
- `ConfigSanitizer` allows it on mainnet (only blocks `InMemoryStorage`)
- No runtime warnings alert operators to the security risk
- The `TempPath` implementation also lacks permission restrictions [21](#0-20) 

The recommended mitigation is to enforce Vault usage for all production validators and add defense-in-depth through file permissions and application-level policy enforcement for any remaining `OnDiskStorage` usage in testing/development environments.

### Citations

**File:** secure/storage/src/policy.rs (L8-23)
```rust
pub struct Policy {
    pub permissions: Vec<Permission>,
}

impl Policy {
    pub fn new(permissions: Vec<Permission>) -> Self {
        Self { permissions }
    }

    pub fn public() -> Self {
        Self::new(vec![Permission::new(Identity::Anyone, vec![
            Capability::Read,
            Capability::Write,
        ])])
    }
}
```

**File:** secure/storage/src/kv_storage.rs (L8-11)
```rust
/// A secure key/value storage engine. Create takes a policy that is enforced internally by the
/// actual backend. The policy contains public identities that the backend can translate into a
/// unique and private token for another service. Hence get and set internally will pass the
/// current service private token to the backend to gain its permissions.
```

**File:** secure/storage/src/on_disk.rs (L16-22)
```rust
/// OnDiskStorage represents a key value store that is persisted to the local filesystem and is
/// intended for single threads (or must be wrapped by a Arc<RwLock<>>). This provides no permission
/// checks and simply offers a proof of concept to unblock building of applications without more
/// complex data stores. Internally, it reads and writes all data to a file, which means that it
/// must make copies of all key material which violates the code base. It violates it because
/// the anticipation is that data stores would securely handle key material. This should not be used
/// in production.
```

**File:** secure/storage/src/on_disk.rs (L34-69)
```rust
    fn new_with_time_service(file_path: PathBuf, time_service: TimeService) -> Self {
        if !file_path.exists() {
            File::create(&file_path)
                .unwrap_or_else(|_| panic!("Unable to create storage at path: {:?}", file_path));
        }

        // The parent will be one when only a filename is supplied. Therefore use the current
        // working directory provided by PathBuf::new().
        let file_dir = file_path
            .parent()
            .map_or_else(PathBuf::new, |p| p.to_path_buf());

        Self {
            file_path,
            temp_path: TempPath::new_with_temp_dir(file_dir),
            time_service,
        }
    }

    fn read(&self) -> Result<HashMap<String, Value>, Error> {
        let mut file = File::open(&self.file_path)?;
        let mut contents = String::new();
        file.read_to_string(&mut contents)?;
        if contents.is_empty() {
            return Ok(HashMap::new());
        }
        let data = serde_json::from_str(&contents)?;
        Ok(data)
    }

    fn write(&self, data: &HashMap<String, Value>) -> Result<(), Error> {
        let contents = serde_json::to_vec(data)?;
        let mut file = File::create(self.temp_path.path())?;
        file.write_all(&contents)?;
        fs::rename(&self.temp_path, &self.file_path)?;
        Ok(())
```

**File:** secure/storage/src/vault.rs (L324-328)
```rust
    pub struct VaultPolicy {
        vault: VaultStorage,
        namespace: Option<String>,
    }

```

**File:** secure/storage/src/vault.rs (L373-410)
```rust
        pub fn set_policy(
            &self,
            policy_name: &str,
            engine: &VaultEngine,
            key: &str,
            capabilities: &[Capability],
        ) -> Result<(), Error> {
            let policy_name = self.name(policy_name, engine);

            let mut vault_policy = self.client().read_policy(&policy_name).unwrap_or_default();
            let mut core_capabilities = Vec::new();
            for capability in capabilities {
                match capability {
                    Capability::Export => {
                        let export_capability = vec![vault::Capability::Read];
                        let export_policy = format!("transit/export/signing-key/{}", key);
                        vault_policy.add_policy(&export_policy, export_capability);
                    },
                    Capability::Read => core_capabilities.push(vault::Capability::Read),
                    Capability::Rotate => {
                        let rotate_capability = vec![vault::Capability::Update];
                        let rotate_policy = format!("transit/keys/{}/rotate", key);
                        vault_policy.add_policy(&rotate_policy, rotate_capability);
                    },
                    Capability::Sign => {
                        let sign_capability = vec![vault::Capability::Update];
                        let sign_policy = format!("transit/sign/{}", key);
                        vault_policy.add_policy(&sign_policy, sign_capability);
                    },
                    Capability::Write => core_capabilities.push(vault::Capability::Update),
                }
            }

            let path = format!("{}/{}", engine.to_policy_path(), self.name(key, engine));
            vault_policy.add_policy(&path, core_capabilities);
            self.client().set_policy(&policy_name, &vault_policy)?;
            Ok(())
        }
```

**File:** crates/aptos/src/common/utils.rs (L224-229)
```rust
pub fn write_to_user_only_file(path: &Path, name: &str, bytes: &[u8]) -> CliTypedResult<()> {
    let mut opts = OpenOptions::new();
    #[cfg(unix)]
    opts.mode(0o600);
    write_to_file_with_opts(path, name, bytes, &mut opts)
}
```

**File:** consensus/safety-rules/src/persistent_safety_storage.rs (L63-81)
```rust
    fn initialize_keys_and_accounts(
        internal_store: &mut Storage,
        author: Author,
        consensus_private_key: bls12381::PrivateKey,
    ) -> Result<(), Error> {
        let result = internal_store.set(CONSENSUS_KEY, consensus_private_key);
        // Attempting to re-initialize existing storage. This can happen in environments like
        // forge. Rather than be rigid here, leave it up to the developer to detect
        // inconsistencies or why they did not reset storage between rounds. Do not repeat the
        // checks again below, because it is just too strange to have a partially configured
        // storage.
        if let Err(aptos_secure_storage::Error::KeyAlreadyExists(_)) = result {
            warn!("Attempted to re-initialize existing storage");
            return Ok(());
        }

        internal_store.set(OWNER_ACCOUNT, author)?;
        Ok(())
    }
```

**File:** config/global-constants/src/lib.rs (L12-12)
```rust
pub const CONSENSUS_KEY: &str = "consensus";
```

**File:** crates/aptos-crypto-derive/src/lib.rs (L185-211)
```rust
#[proc_macro_derive(SerializeKey)]
pub fn serialize_key(source: TokenStream) -> TokenStream {
    let ast: DeriveInput = syn::parse(source).expect("Incorrect macro input");
    let name = &ast.ident;
    let name_string = find_key_name(&ast, name.to_string());
    quote! {
        impl ::serde::Serialize for #name {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: ::serde::Serializer,
            {
                if serializer.is_human_readable() {
                    self.to_encoded_string()
                        .map_err(<S::Error as ::serde::ser::Error>::custom)
                        .and_then(|str| serializer.serialize_str(&str[..]))
                } else {
                    // See comment in deserialize_key.
                    serializer.serialize_newtype_struct(
                        #name_string,
                        serde_bytes::Bytes::new(&ValidCryptoMaterial::to_bytes(self).as_slice()),
                    )
                }
            }
        }
    }
    .into()
}
```

**File:** crates/aptos-crypto/src/traits/mod.rs (L101-104)
```rust
    /// A function to encode into hex-string after serializing.
    fn to_encoded_string(&self) -> Result<String> {
        Ok(format!("0x{}", ::hex::encode(self.to_bytes())))
    }
```

**File:** docker/compose/aptos-node/validator.yaml (L11-13)
```yaml
    backend:
      type: "on_disk_storage"
      path: secure-data.json
```

**File:** terraform/helm/aptos-node/files/configs/validator-base.yaml (L14-16)
```yaml
    backend:
      type: "on_disk_storage"
      path: secure-data.json
```

**File:** testsuite/pangu_lib/template_testnet_files/validator.yaml (L11-13)
```yaml
    backend:
      type: "on_disk_storage"
      path: secure-data.json
```

**File:** config/src/config/safety_rules_config.rs (L85-96)
```rust
        if let Some(chain_id) = chain_id {
            // Verify that the secure backend is appropriate for mainnet validators
            if chain_id.is_mainnet()
                && node_type.is_validator()
                && safety_rules_config.backend.is_in_memory()
            {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "The secure backend should not be set to in memory storage in mainnet!"
                        .to_string(),
                ));
            }
```

**File:** terraform/helm/aptos-node/templates/validator.yaml (L217-227)
```yaml
      securityContext:
        {{- if $.Values.enablePrivilegedMode }}
        runAsUser: 0
        runAsGroup: 0
        fsGroup: 0
        {{- else }}
        runAsNonRoot: true
        runAsUser: 6180
        runAsGroup: 6180
        fsGroup: 6180
        {{- end }}
```

**File:** consensus/safety-rules/src/safety_rules.rs (L40-48)
```rust
/// @TODO consider a cache of verified QCs to cut down on verification costs
pub struct SafetyRules {
    pub(crate) persistent_storage: PersistentSafetyStorage,
    pub(crate) validator_signer: Option<ValidatorSigner>,
    pub(crate) epoch_state: Option<EpochState>,
    // Skip verification of signatures and well-formed, this can be set if it's used in local mode
    // where consensus already verifies.
    pub(crate) skip_sig_verify: bool,
}
```

**File:** secure/storage/README.md (L37-42)
```markdown
- `OnDisk`: Similar to InMemory, the OnDisk secure storage implementation provides another
useful testing implementation: an on-disk storage engine, where the storage backend is
implemented using a single file written to local disk. In a similar fashion to the in-memory
storage, on-disk should not be used in production environments as it provides no security
guarantees (e.g., encryption before writing to disk). Moreover, OnDisk storage does not
currently support concurrent data accesses.
```

**File:** crates/aptos-temppath/src/lib.rs (L60-65)
```rust
    pub fn create_as_file(&self) -> io::Result<()> {
        let mut builder = fs::OpenOptions::new();
        builder.write(true).create_new(true);
        builder.open(self.path())?;
        Ok(())
    }
```
