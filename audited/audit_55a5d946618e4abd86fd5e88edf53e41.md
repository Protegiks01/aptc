# Audit Report

## Title
Timed Feature Activations Lack Governance Emergency Override Mechanism

## Summary
Timed features have hardcoded activation timestamps with no on-chain governance mechanism to delay or disable activations in emergency situations when critical bugs are discovered before scheduled activation.

## Finding Description

The `TimedFeatureFlag` system implements time-based feature activations with hardcoded timestamps in Rust code. When a timed feature is scheduled to activate (e.g., `FixMemoryUsageTracking` on mainnet at March 11, 2025), the activation is determined by comparing the block timestamp against the hardcoded activation time. [1](#0-0) 

The activation logic compares the current block timestamp (from `ConfigurationResource.last_reconfiguration_time`) against these hardcoded times: [2](#0-1) 

The block timestamp is controlled by consensus through the `timestamp::update_global_time()` function, which can only be called by the VM signer during block prologue and enforces monotonic time progression: [3](#0-2) 

While a `TimedFeatureOverride` mechanism exists, it is only settable via Rust code using a `OnceCell` and is exclusively used for replay verification and testing: [4](#0-3) [5](#0-4) 

Critically, there is **no on-chain governance mechanism** to override or delay timed features. The separate `Features` system controlled by governance operates independently: [6](#0-5) 

**This creates a governance security gap:** If a critical bug is discovered in a timed feature (such as `FixMemoryUsageTracking`, `ChargeBytesForPrints`, or `FixTableNativesMemoryDoubleCounting`) days or weeks before its scheduled mainnet activation, governance has no mechanism to delay the activation. The only options are:

1. Emergency validator coordination for code upgrade and network restart
2. Network halt until fix is deployed
3. Allow buggy feature to activate with potential consequences

## Impact Explanation

**High Severity** - This finding represents a significant governance security gap that violates the principle of on-chain governance control over critical protocol changes. Per the Aptos bug bounty criteria for High Severity: "Significant protocol violations."

If a critical consensus or VM bug is discovered in a timed feature before activation, the inability to delay through governance could lead to:
- **Consensus safety violations** if the feature causes deterministic execution failures
- **Network availability issues** requiring emergency interventions
- **Validator coordination overhead** for emergency code deployments

This breaks the **Governance Integrity** invariant: governance should have ultimate control over protocol-impacting changes, especially in emergency scenarios.

## Likelihood Explanation

**Medium Likelihood** - While timed features undergo rigorous review and testnet deployment before mainnet activation, several factors increase likelihood:

1. **Compressed timeline**: Bugs may be discovered between testnet and mainnet activation windows
2. **Environmental differences**: Issues may manifest only under mainnet conditions
3. **Historical precedent**: Many blockchain projects have encountered last-minute critical bugs
4. **Complexity**: Features like memory tracking fixes involve complex VM internals with edge cases

The several-week window between testnet and mainnet activations (e.g., `FixMemoryUsageTracking`: Mar 7 testnet â†’ Mar 11 mainnet) provides limited time to discover and respond to critical issues. [7](#0-6) 

## Recommendation

Implement an on-chain governance-controlled emergency override mechanism for timed features:

1. **Add on-chain resource to store overrides**:
```move
struct TimedFeatureOverrides has key {
    disabled_features: vector<u64>,  // Feature IDs to keep disabled
    delayed_until: Table<u64, u64>,  // Feature ID -> delayed timestamp
}
```

2. **Add governance function**:
```move
public entry fun emergency_disable_timed_feature(
    proposal: &GovernanceProposal,
    feature_id: u64,
    delay_seconds: u64
) acquires TimedFeatureOverrides
```

3. **Modify Rust activation logic** to check on-chain overrides:
```rust
fn is_enabled(&self, flag: TimedFeatureFlag) -> bool {
    // Check on-chain override first
    if let Some(override_config) = fetch_timed_feature_overrides(state_view) {
        if override_config.is_disabled(flag) {
            return false;
        }
        if let Some(delayed_time) = override_config.get_delay(flag) {
            return *timestamp_micros >= delayed_time;
        }
    }
    
    // Existing time-based check
    *timestamp_micros >= flag.activation_time_on(named_chain).timestamp_micros() as u64
}
```

4. **Require supermajority** (e.g., 2/3) governance vote for emergency overrides to prevent abuse

## Proof of Concept

The following demonstrates that governance cannot delay timed features:

```move
#[test(aptos_framework = @aptos_framework)]
#[expected_failure(abort_code = 0x1)] // EAPI_DISABLED or permission error
fun test_cannot_delay_timed_feature_via_governance(aptos_framework: &signer) {
    // Attempt to modify timed feature activation
    // No such function exists in aptos_governance or features modules
    
    // Available governance functions only control regular Features, not TimedFeatures:
    // - aptos_governance::toggle_features() -> calls features::change_feature_flags_for_next_epoch()
    // - features::change_feature_flags_for_next_epoch() -> operates on Features resource
    
    // TimedFeatures are built from hardcoded Rust constants with no on-chain override:
    // types/src/on_chain_config/timed_features.rs:72-141
    
    // This test demonstrates the security gap by showing no governance function exists
    // to delay or disable TimedFeatureFlag activations
}
```

**Notes**

This finding represents a **governance architecture limitation** rather than a traditional exploitable vulnerability. While no direct attack vector exists for unprivileged actors, the lack of emergency governance control over time-based feature activations represents a significant protocol risk that could lead to Critical severity impacts (consensus failures, network unavailability) if a buggy timed feature activates without recourse.

The separation between governance-controlled `Features` and hardcoded `TimedFeatures` creates an asymmetry where protocol changes can activate automatically without governance override capability, violating defense-in-depth principles for critical blockchain infrastructure.

### Citations

**File:** types/src/on_chain_config/timed_features.rs (L72-141)
```rust
    pub fn activation_time_on(&self, chain_id: &NamedChain) -> DateTime<Utc> {
        use NamedChain::*;
        use TimedFeatureFlag::*;

        match (self, chain_id) {
            // Note: These have been enabled since the start due to a bug.
            (_LimitTypeTagSize, TESTNET) => BEGINNING_OF_TIME,
            (_LimitTypeTagSize, MAINNET) => BEGINNING_OF_TIME,

            (_ModuleComplexityCheck, TESTNET) => Los_Angeles
                .with_ymd_and_hms(2024, 6, 25, 16, 0, 0)
                .unwrap()
                .with_timezone(&Utc),
            (_ModuleComplexityCheck, MAINNET) => Los_Angeles
                .with_ymd_and_hms(2024, 7, 3, 12, 0, 0)
                .unwrap()
                .with_timezone(&Utc),

            (EntryCompatibility, TESTNET) => Los_Angeles
                .with_ymd_and_hms(2024, 11, 6, 12, 0, 0)
                .unwrap()
                .with_timezone(&Utc),
            (EntryCompatibility, MAINNET) => Los_Angeles
                .with_ymd_and_hms(2024, 11, 12, 12, 0, 0)
                .unwrap()
                .with_timezone(&Utc),

            // Note: Activation time set to 1 hour after the beginning of time
            //       so we can test the old and new behaviors in tests.
            (FixMemoryUsageTracking, TESTING) => Utc.with_ymd_and_hms(1970, 1, 1, 1, 0, 0).unwrap(),
            (FixMemoryUsageTracking, TESTNET) => Los_Angeles
                .with_ymd_and_hms(2025, 3, 7, 12, 0, 0)
                .unwrap()
                .with_timezone(&Utc),
            (FixMemoryUsageTracking, MAINNET) => Los_Angeles
                .with_ymd_and_hms(2025, 3, 11, 17, 0, 0)
                .unwrap()
                .with_timezone(&Utc),

            (ChargeBytesForPrints, TESTNET) => Los_Angeles
                .with_ymd_and_hms(2025, 3, 7, 12, 0, 0)
                .unwrap()
                .with_timezone(&Utc),
            (ChargeBytesForPrints, MAINNET) => Los_Angeles
                .with_ymd_and_hms(2025, 3, 11, 17, 0, 0)
                .unwrap()
                .with_timezone(&Utc),
            (DisabledCaptureOption, TESTNET) => Los_Angeles
                .with_ymd_and_hms(2025, 9, 15, 12, 0, 0)
                .unwrap()
                .with_timezone(&Utc),
            // For testing, time set to 1 hour after the beginning of time to test the old and new behaviors in tests.
            (DisabledCaptureOption, TESTING) => Utc.with_ymd_and_hms(1970, 1, 1, 1, 0, 0).unwrap(),
            // For mainnet, always enable this feature.
            (DisabledCaptureOption, MAINNET) => BEGINNING_OF_TIME,

            (FixTableNativesMemoryDoubleCounting, TESTNET) => Los_Angeles
                .with_ymd_and_hms(2025, 10, 16, 17, 0, 0)
                .unwrap()
                .with_timezone(&Utc),
            (FixTableNativesMemoryDoubleCounting, MAINNET) => Los_Angeles
                .with_ymd_and_hms(2025, 10, 21, 10, 0, 0)
                .unwrap()
                .with_timezone(&Utc),

            // For chains other than testnet and mainnet, a timed feature is considered enabled from
            // the very beginning, if left unspecified.
            (_, TESTING | DEVNET | PREMAINNET) => BEGINNING_OF_TIME,
        }
    }
```

**File:** types/src/on_chain_config/timed_features.rs (L181-199)
```rust
    fn is_enabled(&self, flag: TimedFeatureFlag) -> bool {
        use TimedFeaturesImpl::*;

        if let Some(override_) = &self.override_ {
            if let Some(enabled) = override_.get_override(flag) {
                return enabled;
            }
        }

        match &self.inner {
            OnNamedChain {
                named_chain,
                timestamp_micros,
            } => {
                *timestamp_micros >= flag.activation_time_on(named_chain).timestamp_micros() as u64
            },
            EnableAll => true,
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/timestamp.move (L31-50)
```text
    /// Updates the wall clock time by consensus. Requires VM privilege and will be invoked during block prologue.
    public fun update_global_time(
        account: &signer,
        proposer: address,
        timestamp: u64
    ) acquires CurrentTimeMicroseconds {
        // Can only be invoked by AptosVM signer.
        system_addresses::assert_vm(account);

        let global_timer = borrow_global_mut<CurrentTimeMicroseconds>(@aptos_framework);
        let now = global_timer.microseconds;
        if (proposer == @vm_reserved) {
            // NIL block with null address as proposer. Timestamp must be equal.
            assert!(now == timestamp, error::invalid_argument(EINVALID_TIMESTAMP));
        } else {
            // Normal block. Time must advance
            assert!(now < timestamp, error::invalid_argument(EINVALID_TIMESTAMP));
            global_timer.microseconds = timestamp;
        };
    }
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L95-103)
```rust
/// Set the timed feature override.
pub fn set_timed_feature_override(profile: TimedFeatureOverride) {
    TIMED_FEATURE_OVERRIDE.set(profile).ok();
}

/// Returns the timed feature override, and [None] if not set.
pub fn get_timed_feature_override() -> Option<TimedFeatureOverride> {
    TIMED_FEATURE_OVERRIDE.get().cloned()
}
```

**File:** storage/backup/backup-cli/src/coordinators/replay_verify.rs (L100-103)
```rust
    async fn run_impl(self) -> Result<(), ReplayError> {
        AptosVM::set_concurrency_level_once(self.replay_concurrency_level);
        set_timed_feature_override(TimedFeatureOverride::Replay);

```

**File:** aptos-move/framework/move-stdlib/sources/configs/features.move (L804-828)
```text
    /// Enable and disable features for the next epoch.
    public fun change_feature_flags_for_next_epoch(
        framework: &signer,
        enable: vector<u64>,
        disable: vector<u64>
    ) acquires PendingFeatures, Features {
        assert!(signer::address_of(framework) == @std, error::permission_denied(EFRAMEWORK_SIGNER_NEEDED));

        // Figure out the baseline feature vec that the diff will be applied to.
        let new_feature_vec = if (exists<PendingFeatures>(@std)) {
            // If there is a buffered feature vec, use it as the baseline.
            let PendingFeatures { features } = move_from<PendingFeatures>(@std);
            features
        } else if (exists<Features>(@std)) {
            // Otherwise, use the currently effective feature flag vec as the baseline, if it exists.
            Features[@std].features
        } else {
            // Otherwise, use an empty feature vec.
            vector[]
        };

        // Apply the diff and save it to the buffer.
        apply_diff(&mut new_feature_vec, enable, disable);
        move_to(framework, PendingFeatures { features: new_feature_vec });
    }
```
