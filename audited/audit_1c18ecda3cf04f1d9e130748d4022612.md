# Audit Report

## Title
Native Table Operations Perform Expensive Serialization Before Gas Charging, Enabling Validator Resource Exhaustion

## Summary
The table native functions (`native_add_box`, `native_borrow_box`, `native_contains_box`, `native_remove_box`) perform expensive key serialization and table lookups before charging variable gas costs, violating the "charge first, execute later" principle. An attacker can exploit this by calling table operations with large keys while providing minimal gas budgets, forcing validators to perform expensive CPU/memory operations that are never paid for when the transaction runs out of gas. [1](#0-0) 

## Finding Description

The vulnerability exists in the gas charging order within table native functions. The documented principle in `SafeNativeContext` explicitly states "Always remember: first charge gas, then execute!" [2](#0-1) 

However, the table native functions violate this principle. In `native_add_box`, the execution flow is:

1. **Line 394**: Charges base gas cost (ADD_BOX_BASE = 4,411 units)
2. **Lines 403-405**: Pops arguments from stack
3. **Line 411**: **Calls `serialize_key()` - expensive CPU operation for large keys**
4. **Line 414-415**: **Calls `get_or_create_global_value()` - expensive I/O and potential deserialization**
5. **Lines 417-426**: Memory usage calculation
6. **Lines 428-433**: Performs operation (may abort with ALREADY_EXISTS)
7. **Line 437**: **ONLY THEN charges variable cost** `key_cost = 36 * key_bytes_length`

The TODO comment on line 437 explicitly acknowledges this issue: `// TODO(Gas): Figure out a way to charge this earlier.` [3](#0-2) 

This same pattern exists in all table operations: [4](#0-3) [5](#0-4) [6](#0-5) 

**Attack Path:**

1. Attacker creates a table with a large key type: `Table<vector<u8>, u64>`
2. Attacker submits transaction calling `table::add(table, large_key, value)` where `large_key` is 50KB vector
3. Attacker provides minimal gas budget (e.g., 6,000 units) - only enough for base costs
4. Native function executes:
   - Charges 4,411 base gas (1,589 remaining)
   - Serializes 50KB key (expensive CPU work consuming milliseconds)
   - Performs table lookup (expensive I/O)
   - Attempts to charge 36 Ã— 50,000 = 1,800,000 gas units
   - **OUT_OF_GAS error occurs**
5. Transaction fails with only base cost charged, but validator already consumed significant CPU/memory resources

The gas parameters are defined as: [7](#0-6) 

The maximum transaction gas is 2,000,000 units: [8](#0-7) 

## Impact Explanation

This vulnerability constitutes **High Severity** under the Aptos Bug Bounty program criteria:

- **Validator node slowdowns**: Attackers can repeatedly submit transactions that force validators to perform expensive serialization and I/O operations while paying only minimal gas costs, degrading validator performance and potentially causing consensus delays.

The vulnerability breaks the **Resource Limits** invariant: "All operations must respect gas, storage, and computational limits" - operations consume computational resources without charging appropriate gas before execution.

An attacker could spam the network with such transactions, causing sustained validator resource exhaustion. While each individual transaction is cheap for the attacker (only pays base gas ~4,411 units), validators must perform expensive work (serialization of large keys, database lookups). This asymmetry allows resource amplification attacks.

## Likelihood Explanation

This vulnerability is **highly likely** to be exploited because:

1. **No special privileges required**: Any user can create tables and submit transactions
2. **Low cost for attacker**: Only pays base gas costs per transaction (~4,411 units)
3. **Easy to execute**: Simple Move code calling standard table operations
4. **No detection barriers**: Looks like normal failed transactions
5. **High amplification**: Each cheap transaction forces expensive validator work

The attack is deterministic and requires no race conditions or timing precision. The TODO comments in the code indicate developers are aware of the issue but haven't fixed it yet, suggesting it may be considered a known but unaddressed problem.

## Recommendation

**Immediate Fix**: Charge gas for variable costs BEFORE performing expensive operations. Specifically:

1. Calculate the serialized size estimate or charge conservatively upfront
2. Perform serialization and table operations
3. Refund any overcharge if applicable

**Recommended Code Fix** for `native_add_box`:

```rust
fn native_add_box(...) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    context.charge(ADD_BOX_BASE)?;
    
    let val = args.pop_back().unwrap();
    let key = args.pop_back().unwrap();
    let handle = get_table_handle(&safely_pop_arg!(args, StructRef))?;

    // CHARGE ESTIMATED COST UPFRONT based on key size
    let estimated_key_size = context.abs_val_size(&key)?;
    let estimated_cost = ADD_BOX_PER_BYTE_SERIALIZED * NumBytes::new(estimated_key_size.get());
    context.charge(estimated_cost)?;
    
    // Now safe to perform expensive operations
    let key_bytes = serialize_key(&function_value_extension, &table.key_layout, &key)?;
    let (gv, loaded) = table.get_or_create_global_value(...)?;
    
    // Charge any remaining costs
    let actual_cost = ADD_BOX_PER_BYTE_SERIALIZED * NumBytes::new(key_bytes.len() as u64);
    if actual_cost > estimated_cost {
        context.charge(actual_cost - estimated_cost)?;
    }
    
    // Continue with operation...
}
```

Apply the same pattern to `native_borrow_box`, `native_contains_box`, and `native_remove_box`.

## Proof of Concept

```move
#[test_only]
module test_addr::table_gas_exploit {
    use std::vector;
    use extensions::table;
    
    #[test(account = @test_addr)]
    #[expected_failure(abort_code = 0x020001, location = Self)] // OUT_OF_GAS
    fun test_table_gas_exhaustion(account: &signer) {
        // Create table with large key type
        let t = table::new<vector<u8>, u64>();
        
        // Create a large key (50KB)
        let large_key = vector::empty<u8>();
        let i = 0;
        while (i < 50000) {
            vector::push_back(&mut large_key, (i % 256) as u8);
            i = i + 1;
        };
        
        // This will charge only base gas (4411), 
        // perform expensive serialization (50KB),
        // then fail with OUT_OF_GAS when charging variable cost (1.8M gas)
        // Validator consumed CPU for serialization but attacker paid minimal gas
        table::add(&mut t, large_key, 1);
        
        table::destroy_empty(t);
    }
}
```

**Expected behavior**: Transaction fails with OUT_OF_GAS after validator has already performed expensive serialization work, demonstrating the resource exhaustion vulnerability.

## Notes

This vulnerability is particularly concerning because:

1. The TODO comments indicate developers are aware of the gas charging issue but consider it difficult to fix
2. The issue affects all table operations, making it a systemic problem
3. Tables are widely used in Aptos Move programs for storage
4. The attack can be automated and scaled to cause sustained validator degradation
5. The fix requires careful redesign of the gas charging mechanism to estimate costs before execution

The root cause is the fundamental design challenge in gas metering for native functions that perform variable-cost operations: you need to know the cost before execution, but the cost depends on the execution result.

### Citations

**File:** aptos-move/framework/table-natives/src/lib.rs (L386-445)
```rust
fn native_add_box(
    context: &mut SafeNativeContext,
    ty_args: &[Type],
    mut args: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    assert_eq!(ty_args.len(), 3);
    assert_eq!(args.len(), 3);

    context.charge(ADD_BOX_BASE)?;
    let fix_memory_double_counting =
        context.timed_feature_enabled(TimedFeatureFlag::FixTableNativesMemoryDoubleCounting);

    let (extensions, mut loader_context, abs_val_gas_params, gas_feature_version) =
        context.extensions_with_loader_context_and_gas_params();
    let table_context = extensions.get::<NativeTableContext>();
    let mut table_data = table_context.table_data.borrow_mut();

    let val = args.pop_back().unwrap();
    let key = args.pop_back().unwrap();
    let handle = get_table_handle(&safely_pop_arg!(args, StructRef))?;

    let table =
        table_data.get_or_create_table(&mut loader_context, handle, &ty_args[0], &ty_args[2])?;

    let function_value_extension = loader_context.function_value_extension();
    let key_bytes = serialize_key(&function_value_extension, &table.key_layout, &key)?;
    let key_cost = ADD_BOX_PER_BYTE_SERIALIZED * NumBytes::new(key_bytes.len() as u64);

    let (gv, loaded) =
        table.get_or_create_global_value(&function_value_extension, table_context, key_bytes)?;
    let mem_usage = if !fix_memory_double_counting || loaded.is_some() {
        gv.view()
            .map(|val| {
                abs_val_gas_params
                    .abstract_heap_size(&val, gas_feature_version)
                    .map(u64::from)
            })
            .transpose()?
    } else {
        None
    };

    let res = match gv.move_to(val) {
        Ok(_) => Ok(smallvec![]),
        Err(_) => Err(SafeNativeError::Abort {
            abort_code: ALREADY_EXISTS,
        }),
    };

    drop(table_data);

    // TODO(Gas): Figure out a way to charge this earlier.
    context.charge(key_cost)?;
    if let Some(amount) = mem_usage {
        context.use_heap_memory(amount)?;
    }
    charge_load_cost(context, loaded)?;

    res
}
```

**File:** aptos-move/framework/table-natives/src/lib.rs (L497-498)
```rust
    // TODO(Gas): Figure out a way to charge this earlier.
    context.charge(key_cost)?;
```

**File:** aptos-move/framework/table-natives/src/lib.rs (L551-552)
```rust
    // TODO(Gas): Figure out a way to charge this earlier.
    context.charge(key_cost)?;
```

**File:** aptos-move/framework/table-natives/src/lib.rs (L611-612)
```rust
    // TODO(Gas): Figure out a way to charge this earlier.
    context.charge(key_cost)?;
```

**File:** aptos-move/aptos-native-interface/src/context.rs (L69-73)
```rust
    /// Always remember: first charge gas, then execute!
    ///
    /// In other words, this function **MUST** always be called **BEFORE** executing **any**
    /// gas-metered operation or library call within a native function.
    #[must_use = "must always propagate the error returned by this function to the native function that called it using the ? operator"]
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/table.rs (L22-23)
```rust
        [add_box_base: InternalGas, "add_box.base", 4411],
        [add_box_per_byte_serialized: InternalGasPerByte, "add_box.per_byte_serialized", 36],
```

**File:** config/global-constants/src/lib.rs (L28-31)
```rust
#[cfg(any(test, feature = "testing"))]
pub const MAX_GAS_AMOUNT: u64 = 100_000_000;
#[cfg(not(any(test, feature = "testing")))]
pub const MAX_GAS_AMOUNT: u64 = 2_000_000;
```
