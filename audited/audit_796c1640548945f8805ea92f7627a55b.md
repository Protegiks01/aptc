# Audit Report

## Title
Panic-Induced Denial of Service via Invalid Author in Secret Share Messages

## Summary
Byzantine validators can send malformed `SecretShare` messages with invalid author addresses (not in the current validator set), causing verification tasks to panic. This can lead to validator node slowdowns and resource exhaustion in the secret sharing subsystem.

## Finding Description

The `SecretShare::verify()` function contains an unchecked array access that panics when a share's author is not in the validator set. [1](#0-0) 

When a Byzantine validator crafts a `SecretShareMessage::Share` with an `author` field set to an address not in the current epoch's validator set, the verification flow proceeds as follows:

1. The message passes BCS deserialization in `from_network_message()`: [2](#0-1) 

2. The message is processed by the `verification_task` which calls `verify()`: [3](#0-2) 

3. The `SecretShareMessage::verify()` performs an epoch check but does not validate the author: [4](#0-3) 

4. When `share.verify(config)` is called, it invokes `config.get_id(self.author())` which panics: [5](#0-4) 

The `.expect()` call on line 177 causes a panic when the author is not found in the validator index. Notably, there is a TODO comment on line 78 acknowledging this bounds check is missing.

**Attack Path:**
1. Byzantine validator constructs a `SecretShare` with `author` set to an arbitrary address (e.g., `0x0` or any non-validator address)
2. Sets valid epoch, arbitrary metadata, and arbitrary share data
3. Broadcasts it as a `SecretShareMsg` to honest validators
4. Each receiving validator spawns a verification task in the bounded executor
5. The task panics at `get_id()`, crashing the task but not the node
6. Attacker repeats continuously to saturate the bounded executor

**Invariant Violations:**
- **Resource Limits**: Byzantine messages cause unbounded panic processing instead of graceful error handling
- **Expected Byzantine Resilience**: The system should handle malicious inputs via error returns, not panics

**Contrast with Reliable Broadcast Path:**
In the reliable broadcast RPC response path, there is proper author validation: [6](#0-5) 

The check on line 45 ensures `share.author() == &peer`, preventing this attack vector in RPC responses. However, the direct broadcast path in `verification_task` lacks this protection.

## Impact Explanation

This vulnerability qualifies as **Medium Severity** based on the following:

1. **Validator Node Slowdowns**: An attacker can spam invalid shares to saturate the bounded executor, delaying processing of legitimate secret shares. This can slow down randomness generation, potentially impacting block production timing.

2. **Resource Exhaustion**: Continuous panic-inducing messages waste CPU cycles spawning and aborting tasks, generate excessive panic logs, and consume bounded executor permits.

3. **Randomness Subsystem Degradation**: Delays in secret share aggregation could affect the randomness generation protocol's liveness, though not its safety.

The impact is limited by:
- Tokio's panic isolation (node doesn't crash)
- Permit reuse after task completion
- Existing network rate limiting via `aptos_channel`

However, a determined attacker with sufficient network bandwidth could maintain sustained executor saturation, causing measurable validator slowdowns.

## Likelihood Explanation

**Likelihood: High**

- **Attack Complexity**: Very low - attacker just needs to craft a message with an invalid author field
- **Attacker Requirements**: Any network peer capable of sending consensus messages
- **No Special Access Needed**: Does not require validator key compromise or insider access
- **Trivial to Execute**: Simple message construction and network broadcast
- **Detection Difficulty**: Panics are logged by tokio but may be overlooked in normal operations

The TODO comment indicates developers are aware this validation is missing, suggesting the attack surface is known but unfixed.

## Recommendation

Add author validation before calling `get_id()` in the verification path:

```rust
pub fn verify(&self, config: &SecretShareConfig) -> anyhow::Result<()> {
    // Validate author is in the validator set before index access
    ensure!(
        config.validator.address_to_validator_index().contains_key(&self.author),
        "Share author {} not in validator set",
        self.author
    );
    
    let index = config.get_id(self.author());
    let decryption_key_share = self.share().clone();
    config.verification_keys[index]
        .verify_decryption_key_share(&self.metadata.digest, &decryption_key_share)?;
    Ok(())
}
```

Alternatively, modify `get_id()` to return `Result` instead of panicking:

```rust
pub fn get_id(&self, peer: &Author) -> anyhow::Result<usize> {
    self.validator
        .address_to_validator_index()
        .get(peer)
        .copied()
        .ok_or_else(|| anyhow!("Author {} not in validator set", peer))
}
```

## Proof of Concept

```rust
#[tokio::test]
async fn test_invalid_author_panic() {
    use aptos_types::secret_sharing::{SecretShare, SecretShareMetadata};
    use aptos_crypto::hash::HashValue;
    
    // Setup: Create a SecretShareConfig with a known validator set
    let (epoch_state, config) = /* initialize with validators */;
    
    // Attack: Create share with invalid author (not in validator set)
    let invalid_author = AccountAddress::from_hex_literal("0xDEADBEEF").unwrap();
    let metadata = SecretShareMetadata::new(
        epoch_state.epoch,
        1, // round
        0, // timestamp
        HashValue::zero(),
        vec![0u8; 32], // arbitrary digest
    );
    
    // Create share with arbitrary data
    let malicious_share = SecretShare::new(
        invalid_author,
        metadata,
        vec![0u8; 96], // arbitrary share data
    );
    
    // This will panic at get_id() with "Peer should be in the index!"
    let result = std::panic::catch_unwind(|| {
        malicious_share.verify(&config)
    });
    
    assert!(result.is_err(), "Expected panic but verification succeeded");
    
    // In production, this panic occurs inside bounded_executor.spawn(),
    // causing task abortion but not node crash
}
```

**Notes**

This vulnerability demonstrates a gap between the reliable broadcast RPC path (which validates `share.author() == peer`) and the direct broadcast path (which lacks author validation). The fix should ensure consistent validation across both code paths to prevent panic-induced DoS attacks against the secret sharing subsystem.

### Citations

**File:** types/src/secret_sharing.rs (L75-82)
```rust
    pub fn verify(&self, config: &SecretShareConfig) -> anyhow::Result<()> {
        let index = config.get_id(self.author());
        let decryption_key_share = self.share().clone();
        // TODO(ibalajiarun): Check index out of bounds
        config.verification_keys[index]
            .verify_decryption_key_share(&self.metadata.digest, &decryption_key_share)?;
        Ok(())
    }
```

**File:** types/src/secret_sharing.rs (L172-178)
```rust
    pub fn get_id(&self, peer: &Author) -> usize {
        *self
            .validator
            .address_to_validator_index()
            .get(peer)
            .expect("Peer should be in the index!")
    }
```

**File:** consensus/src/rand/secret_sharing/network_messages.rs (L28-38)
```rust
    pub fn verify(
        &self,
        epoch_state: &EpochState,
        config: &SecretShareConfig,
    ) -> anyhow::Result<()> {
        ensure!(self.epoch() == epoch_state.epoch);
        match self {
            SecretShareMessage::RequestShare(_) => Ok(()),
            SecretShareMessage::Share(share) => share.verify(config),
        }
    }
```

**File:** consensus/src/rand/secret_sharing/network_messages.rs (L51-56)
```rust
    fn from_network_message(msg: ConsensusMsg) -> anyhow::Result<Self> {
        match msg {
            ConsensusMsg::SecretShareMsg(msg) => Ok(bcs::from_bytes(&msg.data)?),
            _ => bail!("unexpected consensus message type {:?}", msg),
        }
    }
```

**File:** consensus/src/rand/secret_sharing/secret_share_manager.rs (L217-226)
```rust
                .spawn(async move {
                    match bcs::from_bytes::<SecretShareMessage>(dec_msg.req.data()) {
                        Ok(msg) => {
                            if msg.verify(&epoch_state_clone, &config_clone).is_ok() {
                                let _ = tx.unbounded_send(SecretShareRpc {
                                    msg,
                                    protocol: dec_msg.protocol,
                                    response_sender: dec_msg.response_sender,
                                });
                            }
```

**File:** consensus/src/rand/secret_sharing/reliable_broadcast_state.rs (L44-52)
```rust
    fn add(&self, peer: Author, share: Self::Response) -> anyhow::Result<Option<()>> {
        ensure!(share.author() == &peer, "Author does not match");
        ensure!(
            share.metadata() == &self.secret_share_metadata,
            "Metadata does not match: local {:?}, received {:?}",
            self.secret_share_metadata,
            share.metadata()
        );
        share.verify(&self.secret_share_config)?;
```
