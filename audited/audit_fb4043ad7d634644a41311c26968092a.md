# Audit Report

## Title
Database Corruption Causes Unrecoverable Validator Crash via Panic in Pruner Progress Retrieval

## Summary
The `get_or_initialize_subpruner_progress()` function calls `expect_version()` which uses `unreachable!()` macro to panic when encountering a non-Version `DbMetadataValue` variant. If database corruption causes a pruner progress metadata key to contain a `StateSnapshotProgress` value instead of the expected `Version` value, the validator will crash with an unrecoverable panic during initialization, preventing the node from starting.

## Finding Description

The vulnerability exists in the pruner initialization code path, specifically in how database metadata values are retrieved and validated. [1](#0-0) 

When `get_or_initialize_subpruner_progress()` retrieves an existing value from the database, it unconditionally calls `expect_version()` on the result. [2](#0-1) 

The `expect_version()` method uses `unreachable!()` macro for non-Version variants, which causes an unrecoverable panic rather than returning an error. [3](#0-2) 

The `DbMetadataValue` enum has two variants: `Version` and `StateSnapshotProgress`. If database corruption or a software bug causes a `StateSnapshotProgress` value to be stored under a key that expects `Version` (such as `EventPrunerProgress`, `TransactionPrunerProgress`, etc.), the panic will occur.

**Attack Path:**

1. Validator node initiates startup and opens AptosDB [4](#0-3) 

2. `LedgerPrunerManager::new()` is called, which conditionally initializes the pruner worker [5](#0-4) 

3. `LedgerPruner::new()` is called with `.expect()` error handling [6](#0-5) 

4. Multiple sub-pruners are initialized, including `EventStorePruner::new()` [7](#0-6) 

5. Each sub-pruner's `new()` method calls `get_or_initialize_subpruner_progress()` [8](#0-7) 

6. If the database contains a corrupted value (wrong variant type), the panic occurs and propagates up, crashing the validator

This breaks the **liveness/availability invariant**: validators must be able to recover from transient failures and database inconsistencies without requiring manual intervention.

## Impact Explanation

**Severity: HIGH** per Aptos Bug Bounty Program criteria.

This qualifies as "Validator node crashes" under High Severity ($50,000 category). The impact includes:

1. **Complete Validator Unavailability**: The affected validator cannot start up and participate in consensus
2. **Manual Recovery Required**: Operators must manually repair the database or restore from backup
3. **Network Impact**: If multiple validators encounter this simultaneously (e.g., from a widespread software bug), network liveness could be degraded
4. **No Graceful Degradation**: The panic provides no recovery path or useful diagnostics beyond a stack trace

The vulnerability does not directly cause consensus safety violations or fund loss, but severely impacts network availability and validator operational reliability.

## Likelihood Explanation

**Likelihood: MEDIUM**

The vulnerability can be triggered by:

1. **Hardware Failures**: Disk corruption, memory bit flips, or storage system failures that corrupt database values
2. **Software Bugs**: A bug elsewhere in the codebase that accidentally writes a `StateSnapshotProgress` value to a pruner progress key
3. **Database Migration Issues**: Schema changes or data migration errors during upgrades
4. **Concurrent Write Races**: Although RocksDB provides ACID guarantees, potential race conditions in higher-level code

While direct database corruption from hardware is relatively rare on modern systems, the likelihood increases when considering:
- The large number of validators in the network (increases probability of encountering the issue)
- Potential software bugs that could trigger this across multiple nodes
- The fact that this is a single point of failure during critical initialization

The likelihood is NOT negligible for a production blockchain system that must maintain high availability.

## Recommendation

Replace the panicking `expect_version()` method with proper error handling that returns a `Result`:

```rust
// In db_metadata/mod.rs
impl DbMetadataValue {
    pub fn try_into_version(self) -> Result<Version> {
        match self {
            Self::Version(version) => Ok(version),
            other => Err(anyhow::anyhow!(
                "Expected DbMetadataValue::Version, but found {:?}. This may indicate database corruption.",
                other
            )),
        }
    }
}

// In pruner_utils.rs
pub(crate) fn get_or_initialize_subpruner_progress(
    sub_db: &DB,
    progress_key: &DbMetadataKey,
    metadata_progress: Version,
) -> Result<Version> {
    Ok(
        if let Some(v) = sub_db.get::<DbMetadataSchema>(progress_key)? {
            v.try_into_version()? // Returns error instead of panicking
        } else {
            sub_db.put::<DbMetadataSchema>(
                progress_key,
                &DbMetadataValue::Version(metadata_progress),
            )?;
            metadata_progress
        },
    )
}
```

Additionally, consider adding database integrity checks during startup that validate metadata value types match expected variants for their keys, allowing early detection and graceful handling of corruption.

## Proof of Concept

```rust
#[cfg(test)]
mod test {
    use super::*;
    use aptos_db_indexer_schemas::metadata::StateSnapshotProgress;
    use aptos_temppath::TempPath;
    use aptos_schemadb::DB;

    #[test]
    #[should_panic(expected = "expected Version")]
    fn test_corrupted_metadata_causes_panic() {
        // Create temporary database
        let tmpdir = TempPath::new();
        let db = DB::open(
            tmpdir.path(),
            "test_db",
            &[DB_METADATA_CF_NAME],
            &Default::default(),
        ).unwrap();

        // Simulate database corruption: write StateSnapshotProgress 
        // to a key that expects Version
        let corrupted_value = DbMetadataValue::StateSnapshotProgress(
            StateSnapshotProgress::default()
        );
        db.put::<DbMetadataSchema>(
            &DbMetadataKey::EventPrunerProgress,
            &corrupted_value,
        ).unwrap();

        // This should panic with "expected Version, got StateSnapshotProgress"
        let _result = get_or_initialize_subpruner_progress(
            &db,
            &DbMetadataKey::EventPrunerProgress,
            0,
        );
        
        // Test fails because panic prevents reaching this line
    }
}
```

## Notes

This vulnerability represents a **defensive programming failure** rather than a direct exploitability issue. While an unprivileged remote attacker cannot directly corrupt the database, the lack of graceful error handling means that ANY source of database corruption (hardware failure, software bug, or malicious local access) will cause catastrophic validator failure. 

High-availability systems like blockchain validators should be resilient to storage corruption and provide recovery mechanisms. The use of `unreachable!()` assumes perfect database integrity, which is an unsafe assumption for production systems.

### Citations

**File:** storage/aptosdb/src/pruner/pruner_utils.rs (L44-60)
```rust
pub(crate) fn get_or_initialize_subpruner_progress(
    sub_db: &DB,
    progress_key: &DbMetadataKey,
    metadata_progress: Version,
) -> Result<Version> {
    Ok(
        if let Some(v) = sub_db.get::<DbMetadataSchema>(progress_key)? {
            v.expect_version()
        } else {
            sub_db.put::<DbMetadataSchema>(
                progress_key,
                &DbMetadataValue::Version(metadata_progress),
            )?;
            metadata_progress
        },
    )
}
```

**File:** storage/aptosdb/src/schema/db_metadata/mod.rs (L24-29)
```rust
#[derive(Clone, Debug, Deserialize, PartialEq, Serialize)]
#[cfg_attr(any(test, feature = "fuzzing"), derive(proptest_derive::Arbitrary))]
pub(crate) enum DbMetadataValue {
    Version(Version),
    StateSnapshotProgress(StateSnapshotProgress),
}
```

**File:** storage/aptosdb/src/schema/db_metadata/mod.rs (L32-37)
```rust
    pub fn expect_version(self) -> Version {
        match self {
            Self::Version(version) => version,
            _ => unreachable!("expected Version, got {:?}", self),
        }
    }
```

**File:** storage/aptosdb/src/db/aptosdb_internal.rs (L86-90)
```rust
        let ledger_pruner = LedgerPrunerManager::new(
            Arc::clone(&ledger_db),
            pruner_config.ledger_pruner_config,
            internal_indexer_db,
        );
```

**File:** storage/aptosdb/src/pruner/ledger_pruner/ledger_pruner_manager.rs (L113-119)
```rust
        let pruner_worker = if ledger_pruner_config.enable {
            Some(Self::init_pruner(
                Arc::clone(&ledger_db),
                ledger_pruner_config,
                internal_indexer_db,
            ))
        } else {
```

**File:** storage/aptosdb/src/pruner/ledger_pruner/ledger_pruner_manager.rs (L146-149)
```rust
        let pruner = Arc::new(
            LedgerPruner::new(ledger_db, internal_indexer_db)
                .expect("Failed to create ledger pruner."),
        );
```

**File:** storage/aptosdb/src/pruner/ledger_pruner/mod.rs (L138-142)
```rust
        let event_store_pruner = Box::new(EventStorePruner::new(
            Arc::clone(&ledger_db),
            metadata_progress,
            internal_indexer_db.clone(),
        )?);
```

**File:** storage/aptosdb/src/pruner/ledger_pruner/event_store_pruner.rs (L90-94)
```rust
        let progress = get_or_initialize_subpruner_progress(
            ledger_db.event_db_raw(),
            &DbMetadataKey::EventPrunerProgress,
            metadata_progress,
        )?;
```
