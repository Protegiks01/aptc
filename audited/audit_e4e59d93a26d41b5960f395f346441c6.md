# Audit Report

## Title
Missing Second Voting Rule Enforcement in construct_and_sign_vote_two_chain() Violates 2-Chain Consensus Safety

## Summary
The `construct_and_sign_vote_two_chain()` function fails to enforce the "Second voting rule" (`verify_and_update_preferred_round()`) when validators vote on proposals. While `sign_proposal()` correctly enforces this check, the voting path bypasses it, potentially allowing validators to vote for blocks that violate the 2-chain safety guarantee, leading to consensus splits.

## Finding Description

The AptosBFT consensus protocol implements a 2-chain commit rule requiring two consecutive rounds for block commitment. The safety mechanism relies on two voting rules documented in the codebase:

1. **First voting rule**: Prevents double-voting in the same round (enforced via `verify_and_update_last_vote_round()`)
2. **Second voting rule**: Ensures QC certified block round ≥ preferred_round (should be enforced via `verify_and_update_preferred_round()`) [1](#0-0) 

The `sign_proposal()` function correctly enforces both rules: [2](#0-1) 

However, the `construct_and_sign_vote_two_chain()` function has a critical gap. Despite a comment stating "Two voting rules" at line 76, it only enforces the first rule: [3](#0-2) 

The second voting rule (`verify_and_update_preferred_round()`) is never called in the voting path. Instead, only `safe_to_vote()` is invoked, which checks round continuity but NOT the preferred_round constraint: [4](#0-3) 

**Attack Scenario with Timeout Certificates:**

When a timeout occurs, `safe_to_vote()` allows the second condition: `block.round == tc.round + 1 && block.qc.round >= tc.hqc_round`. This permits voting on blocks extending old QCs as long as they meet the timeout certificate's threshold.

**Example:**
1. Validator V votes on blocks A1→A2→A3→A4→A5 (rounds 1-5)
2. After voting on A5, V's `preferred_round = 3` (from observing A4's QC with parent at round 3)
3. Network experiences timeout at round 6, creating TC6 with `hqc_round = 2`
4. Malicious/buggy leader proposes block B7 at round 7 with QC certifying block at round 2 (parent at round 1)
5. `safe_to_vote()` checks: `7 == 6 + 1 && 2 >= 2` → **PASSES** ✓
6. But QC's parent is at round 1 < `preferred_round` (3) → **Should FAIL** but no check exists!
7. Validator V votes on B7, potentially creating a conflicting chain

This violates the invariant that validators should only vote for blocks extending chains at least as recent as their locked/preferred round, breaking the fundamental safety guarantee of the 2-chain protocol.

## Impact Explanation

**Severity: Critical** (Consensus Safety Violation)

This vulnerability directly violates **Critical Invariant #2: Consensus Safety** - "AptosBFT must prevent double-spending and chain splits under < 1/3 Byzantine."

By allowing validators to vote for blocks that extend old QCs (with parent rounds below their preferred_round), the protocol can experience:

1. **Chain Forks**: Validators with different preferred_rounds can vote for conflicting blocks, both meeting the `safe_to_vote()` check but extending incompatible chains
2. **Safety Violation**: Two conflicting blocks could both achieve quorum certification, allowing different validators to commit different transaction histories
3. **Double-Spend Risk**: If conflicting chains both commit, the same UTXOs/resources could be spent twice on different forks

The impact meets the **Critical Severity** criteria: "Consensus/Safety violations" potentially requiring a hard fork to resolve if exploited.

## Likelihood Explanation

**Likelihood: Medium-High**

The vulnerability is exploitable whenever:
1. A timeout occurs (common during network partitions or high latency)
2. The timeout certificate's `hqc_round` is lower than some validators' `preferred_round` (occurs when validators have seen different QCs)
3. A leader proposes a block extending an old QC that satisfies the timeout conditions

This scenario is realistic in adversarial conditions or network disruptions. While it requires specific timing, the conditions occur naturally during consensus protocol stress (network partitions, Byzantine leaders, etc.).

The bug has persisted because:
- Tests only verify `safe_to_vote()` logic, not the missing preferred_round check
- The protocol may rarely hit this edge case in normal operation with honest validators
- The comment "Two voting rules" suggests developer intent that was not fully implemented

## Recommendation

Add the second voting rule check to `guarded_construct_and_sign_vote_two_chain()` before calling `safe_to_vote()`:

```rust
// Two voting rules
self.verify_and_update_last_vote_round(
    proposed_block.block_data().round(),
    &mut safety_data,
)?;

// Add the second voting rule check
self.verify_and_update_preferred_round(
    proposed_block.quorum_cert(),
    &mut safety_data,
)?;

self.safe_to_vote(proposed_block, timeout_cert)?;
```

This ensures both safety rules are enforced during voting, matching the checks performed during proposal signing. The `verify_and_update_preferred_round()` call should occur BEFORE updating `observe_qc()` to ensure the check uses the current preferred_round value.

## Proof of Concept

```rust
#[test]
fn test_voting_with_early_preferred_round() {
    let (mut safety_rules, signer) = test_setup();
    let (proof, genesis_qc) = make_genesis(&signer);
    safety_rules.initialize(&proof).unwrap();

    // Build chain A1->A2->A3->A4->A5 to update preferred_round
    let a1 = make_proposal_with_qc(1, genesis_qc.clone(), &signer);
    let a2 = make_proposal_with_parent(2, &a1, None, &signer);
    let a3 = make_proposal_with_parent(3, &a2, None, &signer);
    let a4 = make_proposal_with_parent(4, &a3, None, &signer);
    let a5 = make_proposal_with_parent(5, &a4, None, &signer);
    
    // Vote on blocks to update preferred_round to 3 (from A4's QC parent)
    safety_rules.construct_and_sign_vote_two_chain(&a2, None).unwrap();
    safety_rules.construct_and_sign_vote_two_chain(&a3, None).unwrap();
    safety_rules.construct_and_sign_vote_two_chain(&a4, None).unwrap();
    safety_rules.construct_and_sign_vote_two_chain(&a5, None).unwrap();

    // Create timeout certificate at round 6 with hqc_round = 2
    let tc6 = make_timeout_cert(6, a2.block().quorum_cert(), &signer);
    
    // Propose B7 at round 7 extending old QC from A2 (round 2, parent round 1)
    // This has parent at round 1, which is < preferred_round (3)
    let b7 = make_proposal_with_qc(7, a2.block().quorum_cert().clone(), &signer);
    
    // BUG: This vote should fail with IncorrectPreferredRound but currently succeeds
    let result = safety_rules.construct_and_sign_vote_two_chain(&b7, Some(&tc6));
    
    // Expected: Err(Error::IncorrectPreferredRound(2, 3))
    // Actual: Ok(Vote) - VULNERABILITY!
    assert_err!(result); // This assertion would currently FAIL
}
```

This test demonstrates that validators can vote for blocks extending old QCs when timeout certificates are present, bypassing the preferred_round safety check that should prevent such votes.

### Citations

**File:** consensus/safety-rules/src/safety_rules.rs (L172-188)
```rust
    /// Second voting rule
    fn verify_and_update_preferred_round(
        &mut self,
        quorum_cert: &QuorumCert,
        safety_data: &mut SafetyData,
    ) -> Result<bool, Error> {
        let preferred_round = safety_data.preferred_round;
        let one_chain_round = quorum_cert.certified_block().round();

        if one_chain_round < preferred_round {
            return Err(Error::IncorrectPreferredRound(
                one_chain_round,
                preferred_round,
            ));
        }
        Ok(self.observe_qc(quorum_cert, safety_data))
    }
```

**File:** consensus/safety-rules/src/safety_rules.rs (L346-370)
```rust
    fn guarded_sign_proposal(
        &mut self,
        block_data: &BlockData,
    ) -> Result<bls12381::Signature, Error> {
        self.signer()?;
        self.verify_author(block_data.author())?;

        let mut safety_data = self.persistent_storage.safety_data()?;
        self.verify_epoch(block_data.epoch(), &safety_data)?;

        if block_data.round() <= safety_data.last_voted_round {
            return Err(Error::InvalidProposal(format!(
                "Proposed round {} is not higher than last voted round {}",
                block_data.round(),
                safety_data.last_voted_round
            )));
        }

        self.verify_qc(block_data.quorum_cert())?;
        self.verify_and_update_preferred_round(block_data.quorum_cert(), &mut safety_data)?;
        // we don't persist the updated preferred round to save latency (it'd be updated upon voting)

        let signature = self.sign(block_data)?;
        Ok(signature)
    }
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L76-81)
```rust
        // Two voting rules
        self.verify_and_update_last_vote_round(
            proposed_block.block_data().round(),
            &mut safety_data,
        )?;
        self.safe_to_vote(proposed_block, timeout_cert)?;
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L147-166)
```rust
    /// Core safety voting rule for 2-chain protocol. Return success if 1 or 2 is true
    /// 1. block.round == block.qc.round + 1
    /// 2. block.round == tc.round + 1 && block.qc.round >= tc.highest_hqc.round
    fn safe_to_vote(
        &self,
        block: &Block,
        maybe_tc: Option<&TwoChainTimeoutCertificate>,
    ) -> Result<(), Error> {
        let round = block.round();
        let qc_round = block.quorum_cert().certified_block().round();
        let tc_round = maybe_tc.map_or(0, |tc| tc.round());
        let hqc_round = maybe_tc.map_or(0, |tc| tc.highest_hqc_round());
        if round == next_round(qc_round)?
            || (round == next_round(tc_round)? && qc_round >= hqc_round)
        {
            Ok(())
        } else {
            Err(Error::NotSafeToVote(round, qc_round, tc_round, hqc_round))
        }
    }
```
