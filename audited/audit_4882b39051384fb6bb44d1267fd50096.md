# Audit Report

## Title
Integer Parsing Panic Vulnerability in Indexer-GRPC Cache Operator Causes Denial of Service

## Summary
The `check_cache_coverage_status()` function in `cache_operator.rs` uses `.expect()` when parsing the Redis `latest_version` value as a u64, which causes a panic and crashes the indexer-grpc-data-service if an attacker injects malicious strings into Redis. This is inconsistent with the safer error handling used in `get_config_by_key()` for the same operation.

## Finding Description
The vulnerability exists in the inconsistent error handling of integer parsing from Redis values: [1](#0-0) 

The `check_cache_coverage_status()` function retrieves the `latest_version` from Redis and parses it with `.expect()`, which panics if parsing fails. In contrast, the `get_config_by_key()` function properly handles parsing errors: [2](#0-1) 

**Attack Scenario:**
1. Attacker gains write access to the Redis instance (which lacks authentication by default in the provided docker-compose configuration) [3](#0-2) 

2. Attacker injects a malicious string into the `latest_version` key, such as:
   - `"18446744073709551616"` (u64::MAX + 1, causes overflow)
   - `"-1"` (negative number, invalid for u64)
   - `"malicious_string"` (non-numeric characters)

3. When `indexer-grpc-data-service` calls `check_cache_coverage_status()` during transaction fetching, the parsing fails: [4](#0-3) 

4. The `.expect()` call triggers a panic, crashing the service
5. The indexer service becomes unavailable until manually restarted

**Why parse::<u64>() doesn't prevent the attack:**
Rust's `str::parse::<u64>()` returns `Result<u64, ParseIntError>` for invalid inputs including negative numbers, overflow values, and non-numeric strings. The `.expect()` call converts this error into a panic rather than gracefully handling it.

## Impact Explanation
This vulnerability qualifies as **High Severity** under the Aptos bug bounty program criteria for "API crashes."

**Impact:**
- Complete denial of service of the indexer-grpc-data-service
- All indexer API queries fail during downtime
- Requires manual intervention to restart the service
- Disrupts blockchain data indexing and availability
- Users and applications relying on the indexer lose access to historical transaction data

**Scope Limitation:**
This does NOT affect consensus or core blockchain operation, as the indexer is a separate read-only service. However, it severely impacts the availability of critical infrastructure that applications depend on for querying blockchain state.

## Likelihood Explanation
**Likelihood: Medium to High**

**Requirements for exploitation:**
1. Write access to the Redis instance
2. Knowledge of the `latest_version` key name

**Factors increasing likelihood:**
- Redis is exposed on port 6379 without authentication in the default configuration [5](#0-4) 

- No authentication mechanism is implemented in the Redis connection code
- If the Redis instance is accessible from untrusted networks, exploitation is straightforward

**Factors decreasing likelihood:**
- In production deployments, Redis should be isolated behind network security controls
- Requires network access to the Redis port

However, misconfigurations or insider threats make this a realistic attack vector.

## Recommendation
Replace the `.expect()` call with proper error handling consistent with `get_config_by_key()`:

**Fix for `check_cache_coverage_status()` (lines 197-206):**
```rust
let latest_version: u64 = match self
    .conn
    .get::<&str, String>(CACHE_KEY_LATEST_VERSION)
    .await
{
    Ok(v) => v
        .parse::<u64>()
        .with_context(|| format!("Redis {} is not a valid number: {}", CACHE_KEY_LATEST_VERSION, v))?,
    Err(err) => return Err(err.into()),
};
```

**Additional hardening recommendations:**
1. Implement Redis authentication using username/password in the connection URL
2. Add input validation before writing to Redis to ensure only valid u64 values are stored
3. Use network isolation (VPC, firewall rules) to restrict Redis access
4. Add monitoring/alerting for unexpected Redis value formats
5. Consider using Redis ACLs to restrict write access to critical keys

## Proof of Concept

**Rust test to demonstrate the panic:**

```rust
#[cfg(test)]
mod vulnerability_poc {
    use super::*;
    use redis_test::{MockCmd, MockRedisConnection};

    #[tokio::test]
    #[should_panic(expected = "Redis latest_version is not a number.")]
    async fn test_malicious_overflow_string_causes_panic() {
        // Simulate attacker injecting u64::MAX + 1
        let malicious_value = "18446744073709551616";
        let cmds = vec![MockCmd::new(
            redis::cmd("GET").arg(CACHE_KEY_LATEST_VERSION),
            Ok(malicious_value.to_string()),
        )];
        let mock_connection = MockRedisConnection::new(cmds);
        let mut cache_operator: CacheOperator<MockRedisConnection> =
            CacheOperator::new(mock_connection, StorageFormat::Base64UncompressedProto);

        // This will panic with "Redis latest_version is not a number."
        let _ = cache_operator.check_cache_coverage_status(100).await;
    }

    #[tokio::test]
    #[should_panic(expected = "Redis latest_version is not a number.")]
    async fn test_malicious_negative_string_causes_panic() {
        // Simulate attacker injecting negative number
        let malicious_value = "-1";
        let cmds = vec![MockCmd::new(
            redis::cmd("GET").arg(CACHE_KEY_LATEST_VERSION),
            Ok(malicious_value.to_string()),
        )];
        let mock_connection = MockRedisConnection::new(cmds);
        let mut cache_operator: CacheOperator<MockRedisConnection> =
            CacheOperator::new(mock_connection, StorageFormat::Base64UncompressedProto);

        // This will panic
        let _ = cache_operator.check_cache_coverage_status(100).await;
    }

    #[tokio::test]
    #[should_panic(expected = "Redis latest_version is not a number.")]
    async fn test_malicious_string_causes_panic() {
        // Simulate attacker injecting arbitrary string
        let malicious_value = "malicious_payload";
        let cmds = vec![MockCmd::new(
            redis::cmd("GET").arg(CACHE_KEY_LATEST_VERSION),
            Ok(malicious_value.to_string()),
        )];
        let mock_connection = MockRedisConnection::new(cmds);
        let mut cache_operator: CacheOperator<MockRedisConnection> =
            CacheOperator::new(mock_connection, StorageFormat::Base64UncompressedProto);

        // This will panic
        let _ = cache_operator.check_cache_coverage_status(100).await;
    }
}
```

**Real-world exploitation steps:**
1. Access the Redis instance (default port 6379)
2. Execute: `SET latest_version "18446744073709551616"`
3. Wait for the indexer-grpc-data-service to process a transaction request
4. Service crashes with panic: "Redis latest_version is not a number."
5. Service remains unavailable until manual restart

## Notes

The vulnerability specifically affects the indexer-grpc ecosystem, which is infrastructure for querying blockchain data but does not participate in consensus. While the impact is limited to availability rather than consensus safety, the ease of exploitation and complete service disruption warrant High severity classification under the "API crashes" category.

The inconsistency between `check_cache_coverage_status()` and `get_config_by_key()` suggests this was an oversight rather than an intentional design choice, making it a clear implementation bug that should be fixed.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/cache_operator.rs (L169-179)
```rust
    async fn get_config_by_key(&mut self, key: &str) -> anyhow::Result<Option<u64>> {
        let result = self.conn.get::<&str, Vec<u8>>(key).await?;
        if result.is_empty() {
            Ok(None)
        } else {
            let result_string = String::from_utf8(result).unwrap();
            Ok(Some(result_string.parse::<u64>().with_context(|| {
                format!("Redis key {} is not a number.", key)
            })?))
        }
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/cache_operator.rs (L197-206)
```rust
        let latest_version: u64 = match self
            .conn
            .get::<&str, String>(CACHE_KEY_LATEST_VERSION)
            .await
        {
            Ok(v) => v
                .parse::<u64>()
                .expect("Redis latest_version is not a number."),
            Err(err) => return Err(err.into()),
        };
```

**File:** docker/compose/indexer-grpc/docker-compose.yaml (L16-27)
```yaml
  redis:
    image: ${REDIS_IMAGE_REPO:-redis}:7.2
    command: redis-server --appendonly yes
    networks:
      shared:
        ipv4_address:  172.16.1.12
    restart: unless-stopped
    expose:
      - 6379
    ports:
      - 6379:6379

```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service/src/service.rs (L258-260)
```rust
    let cache_coverage_status = cache_operator
        .check_cache_coverage_status(start_version)
        .await;
```
