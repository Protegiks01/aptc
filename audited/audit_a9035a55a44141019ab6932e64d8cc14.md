# Audit Report

## Title
Collusion Attack: Byzantine Peers Can Report False Network Distances to Manipulate Peer Selection

## Summary
Multiple Byzantine peers can coordinate to report false `distance_from_validators` values (e.g., claiming distance 2 when actually at distance 50+), bypassing validation and getting prioritized for critical network operations including consensus observer subscriptions, mempool transaction broadcasting, and state sync data requests.

## Finding Description

The peer monitoring service validates `distance_from_validators` values inconsistently based on the reported distance. For distances 0 and 1, the system validates that the peer's role matches the claimed distance. However, for distances ≥ 2, validation only checks that the value is ≤ 100, with no verification of accuracy. [1](#0-0) 

The validation logic shows that for `distance_from_validators` of 0 or 1, the system verifies peer roles (validator or VFN). However, for any distance ≥ 2, the only check is against `MAX_DISTANCE_FROM_VALIDATORS`: [2](#0-1) 

**Attack Propagation:**

When a node calculates its own distance, it trusts peer-reported distances without cryptographic verification: [3](#0-2) 

The server finds the minimum distance among connected peers and adds 1. This creates a trust amplification effect where false low distances propagate through the network.

**Critical Impact - Consensus Observer:**

The consensus observer uses distance as the primary metric for peer prioritization: [4](#0-3) 

Byzantine peers reporting false low distances will be prioritized for consensus observer subscriptions, potentially causing nodes to subscribe to malicious peers for consensus data.

**Critical Impact - Mempool:**

Mempool transaction broadcasting prioritizes peers by validator distance: [5](#0-4) 

The distance comparison function: [6](#0-5) 

Byzantine peers with false low distances receive transactions first, enabling selective propagation or censorship.

**Critical Impact - State Sync:**

State synchronization groups peers by distance in ascending order: [7](#0-6) 

Byzantine peers at false low distances are selected first for state data requests.

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos bug bounty criteria for "Validator node slowdowns" and "Significant protocol violations":

1. **Validator/Node Performance Degradation**: Byzantine peers prioritized across consensus observer, mempool, and state sync can deliberately delay or drop requests, causing:
   - Consensus observer subscription timeouts and constant re-subscriptions
   - Delayed transaction propagation in mempool
   - State sync request timeouts and retries
   
2. **Network Protocol Violation**: The peer selection mechanism across multiple critical subsystems is subverted, violating the protocol's assumption that distance-based prioritization improves network efficiency.

3. **Censorship Vector**: Malicious peers receiving mempool transactions first can selectively propagate or censor transactions, affecting network fairness.

While this doesn't directly break consensus safety (blocks still require valid validator signatures), it degrades network operation and creates attack vectors for performance-based attacks.

## Likelihood Explanation

**High Likelihood** - The attack is straightforward to execute:

1. **Low Barrier to Entry**: Any node can connect to the public network and report arbitrary distances ≥ 2
2. **No Authentication Required**: Distance values are not cryptographically signed or verifiable
3. **Collusion Amplification**: Multiple colluding nodes create stronger false consensus about network topology
4. **Persistent Effect**: Once a node accepts false distances, it propagates incorrect distance calculations to others

The only requirement is running multiple nodes on the public network, which is trivial for an attacker.

## Recommendation

Implement multi-layered validation for distance values:

1. **Cross-Validation**: Compare distance values from multiple peers and detect outliers
2. **Distance Bounds by Role**: Enforce stricter bounds based on connection patterns (e.g., public nodes should be ≥ 2 from validators)
3. **Reputation System**: Track peer reliability for distance reporting over time
4. **Cryptographic Attestation**: Consider validator-signed attestations for distance values in future protocol versions

**Immediate Fix** - Add stricter validation for distance ≥ 2:

```rust
// In handle_monitoring_service_response(), add cross-validation
distance_from_validators => {
    // The distance must be less than or equal to the max
    if distance_from_validators > MAX_DISTANCE_FROM_VALIDATORS {
        return false;
    }
    
    // Additional validation: if we have distance info from other peers,
    // verify this peer's claimed distance is consistent
    if let Some(expected_distance) = calculate_expected_peer_distance(
        peer_network_id,
        &peer_metadata,
        &self.base_config
    ) {
        // Allow some tolerance but flag suspicious discrepancies
        let distance_diff = distance_from_validators.abs_diff(expected_distance);
        if distance_diff > DISTANCE_TOLERANCE {
            warn!("Suspicious distance claim from peer");
            return false;
        }
    }
    
    true
}
```

## Proof of Concept

```rust
#[test]
fn test_byzantine_distance_collusion_attack() {
    use aptos_config::{
        config::{BaseConfig, NodeConfig, PeerRole, RoleType},
        network_id::{NetworkId, PeerNetworkId},
    };
    use aptos_network::application::metadata::PeerMetadata;
    use aptos_peer_monitoring_service_types::response::NetworkInformationResponse;
    
    // Create a VFN node that will be targeted
    let node_config = NodeConfig {
        base: BaseConfig {
            role: RoleType::FullNode,
            ..Default::default()
        },
        ..Default::default()
    };
    let mut network_info_state = NetworkInfoState::new(node_config, TimeService::mock());
    
    // Create 3 Byzantine peers on public network claiming distance 2
    // (they are actually distance 50+ but validation doesn't check this)
    for i in 0..3 {
        let byzantine_peer = PeerNetworkId::new(NetworkId::Public, PeerId::random());
        let connection_metadata = ConnectionMetadata::new(
            byzantine_peer.peer_id(),
            ConnectionId::default(),
            NetworkAddress::from_str("/ip4/127.0.0.1/tcp/8081").unwrap(),
            ConnectionOrigin::Inbound,
            MessagingProtocolVersion::V1,
            ProtocolIdSet::empty(),
            PeerRole::Unknown, // Public full node
        );
        let peer_metadata = PeerMetadata::new(connection_metadata);
        
        // Byzantine peer claims distance 2 (false - actually much farther)
        let false_response = PeerMonitoringServiceResponse::NetworkInformation(
            NetworkInformationResponse {
                connected_peers: Default::default(),
                distance_from_validators: 2, // FALSE CLAIM
            }
        );
        
        // This passes validation because distance >= 2 only checks <= MAX_DISTANCE
        network_info_state.handle_monitoring_service_response(
            &byzantine_peer,
            peer_metadata,
            PeerMonitoringServiceRequest::GetNetworkInformation,
            false_response,
            0.0,
        );
        
        // Verify the false distance was accepted
        let stored_response = network_info_state.get_latest_network_info_response().unwrap();
        assert_eq!(stored_response.distance_from_validators, 2);
    }
    
    // Now when consensus observer/mempool/state-sync select peers,
    // these Byzantine peers will be prioritized due to their false low distance
    // This enables censorship, delayed propagation, and network disruption
}
```

## Notes

The vulnerability stems from trusting self-reported network topology information without verification. The system assumes honest peer behavior for distance reporting, but this assumption is violated by coordinated Byzantine actors. The impact is primarily performance degradation and potential censorship rather than direct consensus safety violations, but still constitutes a significant protocol weakness exploitable by relatively unsophisticated attackers.

### Citations

**File:** peer-monitoring-service/client/src/peer_states/network_info.rs (L116-154)
```rust
        // Sanity check the response depth from the peer metadata
        let network_id = peer_network_id.network_id();
        let is_valid_depth = match network_info_response.distance_from_validators {
            0 => {
                // Verify the peer is a validator and has the correct network id
                let peer_is_validator = peer_metadata.get_connection_metadata().role.is_validator();
                let peer_has_correct_network = match self.base_config.role {
                    RoleType::Validator => network_id.is_validator_network(), // We're a validator
                    RoleType::FullNode => network_id.is_vfn_network(),        // We're a VFN
                };
                peer_is_validator && peer_has_correct_network
            },
            1 => {
                // Verify the peer is a VFN and has the correct network id
                let peer_is_vfn = peer_metadata.get_connection_metadata().role.is_vfn();
                let peer_has_correct_network = match self.base_config.role {
                    RoleType::Validator => network_id.is_vfn_network(), // We're a validator
                    RoleType::FullNode => network_id.is_public_network(), // We're a VFN or PFN
                };
                peer_is_vfn && peer_has_correct_network
            },
            distance_from_validators => {
                // The distance must be less than or equal to the max
                distance_from_validators <= MAX_DISTANCE_FROM_VALIDATORS
            },
        };

        // If the depth did not pass our sanity checks, handle a failure
        if !is_valid_depth {
            warn!(LogSchema::new(LogEntry::NetworkInfoRequest)
                .event(LogEvent::InvalidResponse)
                .peer(peer_network_id)
                .message(&format!(
                    "Peer returned invalid depth from validators: {}",
                    network_info_response.distance_from_validators
                )));
            self.handle_request_failure();
            return;
        }
```

**File:** peer-monitoring-service/server/src/lib.rs (L296-340)
```rust
/// Returns the distance from the validators using the given base config
/// and the peers and metadata information.
fn get_distance_from_validators(
    base_config: &BaseConfig,
    peers_and_metadata: Arc<PeersAndMetadata>,
) -> u64 {
    // Get the connected peers and metadata
    let connected_peers_and_metadata = match peers_and_metadata.get_connected_peers_and_metadata() {
        Ok(connected_peers_and_metadata) => connected_peers_and_metadata,
        Err(error) => {
            warn!(LogSchema::new(LogEntry::PeerMonitoringServiceError).error(&error.into()));
            return MAX_DISTANCE_FROM_VALIDATORS;
        },
    };

    // If we're a validator and we have active validator peers, we're in the validator set.
    // TODO: figure out if we need to deal with validator set forks here.
    if base_config.role.is_validator() {
        for peer_metadata in connected_peers_and_metadata.values() {
            if peer_metadata.get_connection_metadata().role.is_validator() {
                return 0;
            }
        }
    }

    // Otherwise, go through our peers, find the min, and return a distance relative to the min
    let mut min_peer_distance_from_validators = MAX_DISTANCE_FROM_VALIDATORS;
    for peer_metadata in connected_peers_and_metadata.values() {
        if let Some(ref latest_network_info_response) = peer_metadata
            .get_peer_monitoring_metadata()
            .latest_network_info_response
        {
            min_peer_distance_from_validators = min(
                min_peer_distance_from_validators,
                latest_network_info_response.distance_from_validators,
            );
        }
    }

    // We're one hop away from the peer
    min(
        MAX_DISTANCE_FROM_VALIDATORS,
        min_peer_distance_from_validators + 1,
    )
}
```

**File:** consensus/src/consensus_observer/observer/subscription_utils.rs (L283-312)
```rust
pub fn sort_peers_by_subscription_optimality(
    peers_and_metadata: &HashMap<PeerNetworkId, PeerMetadata>,
) -> Vec<PeerNetworkId> {
    // Group peers and latencies by validator distance, i.e., distance -> [(peer, latency)]
    let mut unsupported_peers = Vec::new();
    let mut peers_and_latencies_by_distance = BTreeMap::new();
    for (peer_network_id, peer_metadata) in peers_and_metadata {
        // Verify that the peer supports consensus observer
        if !supports_consensus_observer(peer_metadata) {
            unsupported_peers.push(*peer_network_id);
            continue; // Skip the peer
        }

        // Get the distance and latency for the peer
        let distance = get_distance_for_peer(peer_network_id, peer_metadata);
        let latency = get_latency_for_peer(peer_network_id, peer_metadata);

        // If the distance is not found, use the maximum distance
        let distance =
            distance.unwrap_or(aptos_peer_monitoring_service_types::MAX_DISTANCE_FROM_VALIDATORS);

        // If the latency is not found, use a large latency
        let latency = latency.unwrap_or(MAX_PING_LATENCY_SECS);

        // Add the peer and latency to the distance group
        peers_and_latencies_by_distance
            .entry(distance)
            .or_insert_with(Vec::new)
            .push((*peer_network_id, OrderedFloat(latency)));
    }
```

**File:** mempool/src/shared_mempool/priority.rs (L103-109)
```rust
        // Otherwise, compare by peer distance from the validators.
        // This avoids badly configured/connected peers (e.g., broken VN-VFN connections).
        let distance_ordering =
            compare_validator_distance(monitoring_metadata_a, monitoring_metadata_b);
        if !distance_ordering.is_eq() {
            return distance_ordering; // Only return if it's not equal
        }
```

**File:** mempool/src/shared_mempool/priority.rs (L613-639)
```rust
/// Compares the validator distance for the given pair of monitoring metadata.
/// The peer with the lowest validator distance is prioritized.
fn compare_validator_distance(
    monitoring_metadata_a: &Option<&PeerMonitoringMetadata>,
    monitoring_metadata_b: &Option<&PeerMonitoringMetadata>,
) -> Ordering {
    // Get the validator distance from the monitoring metadata
    let validator_distance_a = get_distance_from_validators(monitoring_metadata_a);
    let validator_distance_b = get_distance_from_validators(monitoring_metadata_b);

    // Compare the distances
    match (validator_distance_a, validator_distance_b) {
        (Some(validator_distance_a), Some(validator_distance_b)) => {
            // Prioritize the peer with the lowest validator distance
            validator_distance_a.cmp(&validator_distance_b).reverse()
        },
        (Some(_), None) => {
            Ordering::Greater // Prioritize the peer with a validator distance
        },
        (None, Some(_)) => {
            Ordering::Less // Prioritize the peer with a validator distance
        },
        (None, None) => {
            Ordering::Equal // Neither peer has a validator distance
        },
    }
}
```

**File:** state-sync/aptos-data-client/src/utils.rs (L23-64)
```rust
/// Chooses peers weighted by distance from the validator set
/// and latency. We prioritize distance over latency as we want
/// to avoid close but not up-to-date peers.
pub fn choose_random_peers_by_distance_and_latency(
    peers: HashSet<PeerNetworkId>,
    peers_and_metadata: Arc<PeersAndMetadata>,
    num_peers_to_choose: usize,
) -> HashSet<PeerNetworkId> {
    // Group peers and latency weights by validator distance, i.e., distance -> [(peer, latency weight)]
    let mut peers_and_latencies_by_distance = BTreeMap::new();
    for peer in peers {
        if let Some((distance, latency)) =
            get_distance_and_latency_for_peer(&peers_and_metadata, peer)
        {
            let latency_weight = convert_latency_to_weight(latency);
            peers_and_latencies_by_distance
                .entry(distance)
                .or_insert_with(Vec::new)
                .push((peer, latency_weight));
        }
    }

    // Select the peers by distance and latency weights. Note: BTreeMaps are
    // sorted by key, so the entries will be sorted by distance in ascending order.
    let mut selected_peers = HashSet::new();
    for (_, peers_and_latencies) in peers_and_latencies_by_distance {
        // Select the peers by latency weights
        let num_peers_remaining = num_peers_to_choose.saturating_sub(selected_peers.len()) as u64;
        let peers = choose_random_peers_by_weight(num_peers_remaining, peers_and_latencies);

        // Add the peers to the entire set
        selected_peers.extend(peers);

        // If we have selected enough peers, return early
        if selected_peers.len() >= num_peers_to_choose {
            return selected_peers;
        }
    }

    // Return the selected peers
    selected_peers
}
```
