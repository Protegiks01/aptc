# Audit Report

## Title
SSRF Vulnerability in NFT Metadata Crawler Asset Uploader Allows Unauthorized Access to Local Filesystem and Internal Services

## Summary
The `upload_asset()` function in the NFT metadata crawler's asset uploader worker does not validate URL schemes before sending URLs to Cloudflare's image upload API. This allows attackers to submit `file://` protocol URLs or internal network addresses, leading to Server-Side Request Forgery (SSRF) attacks that could expose local filesystem contents and internal services.

## Finding Description

The vulnerability exists in the asset upload workflow where user-supplied URLs are passed directly to Cloudflare without scheme validation.

**Vulnerable Code Flow:**

1. The `UploadRequest` struct accepts any valid URL type without scheme restrictions: [1](#0-0) 

2. The `upload_asset()` function receives the URL and sends it directly to Cloudflare's API without validating the scheme: [2](#0-1) 

3. The URL is converted to a string and included in the multipart form sent to Cloudflare: [3](#0-2) 

**Attack Vectors:**

An attacker can submit malicious requests with:
- `file:///etc/passwd` - Read local filesystem files
- `file:///home/user/.ssh/id_rsa` - Access SSH private keys
- `http://127.0.0.1:8080/admin` - Access internal services
- `http://169.254.169.254/latest/meta-data/` - Access cloud metadata endpoints (AWS)
- `http://localhost:5432/` - Probe internal databases

**Contrast with Secure Pattern:**

The codebase demonstrates the correct approach in other modules. The `RedisUrl` type properly validates schemes during deserialization: [4](#0-3) 

**Missing Validation:**

Neither the parser worker nor the uploader throttler perform scheme validation: [5](#0-4) [6](#0-5) 

## Impact Explanation

**Severity: High** 

This vulnerability meets the High severity criteria as it represents a significant security violation in a production API endpoint. While it does not directly impact blockchain consensus or validator operations, it could lead to:

1. **Confidential Data Exposure**: Access to configuration files, credentials, and private keys stored on the metadata crawler server
2. **Internal Network Reconnaissance**: Mapping and accessing internal services not exposed to the internet  
3. **Cloud Metadata Leakage**: If running on AWS/GCP/Azure, attackers could access instance metadata containing IAM credentials
4. **Service Disruption**: The exposed information could be used to launch further attacks against the infrastructure

This falls under "Significant protocol violations" and "API crashes" categories in the High severity tier, as it represents a critical failure in input validation for a public-facing API.

## Likelihood Explanation

**Likelihood: High**

The attack is highly likely to succeed because:

1. **No Authentication Required**: The endpoint accepts requests from any source
2. **Trivial Exploitation**: Requires only a single HTTP POST request with a malicious URL
3. **Standard Attack Pattern**: SSRF is a well-known vulnerability class with readily available exploitation tools
4. **No Defense in Depth**: There are no intermediate validation layers to catch malicious URLs

The Rust `url` crate's `Url::parse()` function accepts `file://` URLs as valid, providing no protection against this attack vector.

## Recommendation

Implement URL scheme validation using a custom type similar to `RedisUrl`. Create a `HttpUrl` or `HttpsUrl` type that only accepts `http://` and `https://` schemes:

```rust
use serde::{Deserialize, Serialize};
use url::Url;

/// A URL that only allows http:// and https:// schemes
#[derive(Clone, Debug, Serialize)]
pub struct HttpUrl(pub Url);

impl<'de> Deserialize<'de> for HttpUrl {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let url = Url::deserialize(deserializer)?;
        match url.scheme() {
            "http" | "https" => Ok(Self(url)),
            _ => Err(serde::de::Error::custom(format!(
                "Invalid URL scheme '{}': only http:// and https:// are allowed",
                url.scheme()
            ))),
        }
    }
}

// Update UploadRequest to use HttpUrl
#[derive(Debug, Deserialize, Serialize)]
pub struct UploadRequest {
    pub url: HttpUrl,
}
```

Additionally, implement IP address validation to block private IP ranges and localhost:
- `127.0.0.0/8` (localhost)
- `10.0.0.0/8` (private networks)
- `172.16.0.0/12` (private networks)  
- `192.168.0.0/16` (private networks)
- `169.254.0.0/16` (link-local)

## Proof of Concept

**Step 1**: Send a malicious request to the asset uploader endpoint:

```bash
curl -X POST http://<asset-uploader-host>/ \
  -H "Content-Type: application/json" \
  -d '{"url": "file:///etc/passwd"}'
```

**Step 2**: The server accepts the request and forwards it to Cloudflare: [7](#0-6) 

**Step 3**: Cloudflare attempts to fetch `file:///etc/passwd` from the metadata crawler server's local filesystem.

**Expected Result**: If successful, the contents of `/etc/passwd` would be uploaded to Cloudflare's image storage and potentially accessible to the attacker.

**Alternative PoC for internal service access**:

```bash
curl -X POST http://<asset-uploader-host>/ \
  -H "Content-Type: application/json" \
  -d '{"url": "http://127.0.0.1:8080/internal-admin"}'
```

This probes for internal services running on the same host.

## Notes

While this is a legitimate SSRF vulnerability in the NFT metadata crawler service, it's important to note that this is an **ecosystem/auxiliary service** and not part of the Aptos blockchain's core consensus, execution, or state management layers. It does not impact:

- Blockchain consensus or validator operations
- Move VM execution or gas metering
- On-chain state or Merkle tree integrity
- Governance or staking mechanisms

However, it represents a significant security risk for the infrastructure running the NFT metadata crawler and could potentially be leveraged for further attacks against the broader Aptos ecosystem infrastructure.

### Citations

**File:** ecosystem/nft-metadata-crawler/src/asset_uploader/worker/mod.rs (L56-59)
```rust
#[derive(Debug, Deserialize, Serialize)]
pub struct UploadRequest {
    pub url: Url,
}
```

**File:** ecosystem/nft-metadata-crawler/src/asset_uploader/worker/mod.rs (L69-82)
```rust
    async fn upload_asset(&self, url: &Url) -> anyhow::Result<impl IntoResponse + use<>> {
        let hashed_url = sha256::digest(url.to_string());
        let client = Client::builder()
            .timeout(Duration::from_secs(MAX_ASSET_UPLOAD_RETRY_SECONDS))
            .build()
            .context("Error building reqwest client")?;
        let form = Form::new()
            .text("id", hashed_url.clone())
            .text(
                // Save the asset_uri in the upload metadata to enable retrieval by asset_uri later
                "metadata",
                format!("{{\"asset_uri\": \"{}\"}}", url),
            )
            .text("url", url.to_string());
```

**File:** ecosystem/nft-metadata-crawler/src/asset_uploader/worker/mod.rs (L89-101)
```rust
        let res = client
            .post(format!(
                "https://api.cloudflare.com/client/v4/accounts/{}/images/v1",
                self.config.cloudflare_account_id
            ))
            .header(
                "Authorization",
                format!("Bearer {}", self.config.cloudflare_auth_key),
            )
            .multipart(form)
            .send()
            .await
            .context("Error sending request to Cloudflare")?;
```

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/types.rs (L16-25)
```rust
impl FromStr for RedisUrl {
    type Err = anyhow::Error;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let url = Url::parse(s)?;
        if url.scheme() != "redis" {
            return Err(anyhow::anyhow!("Invalid scheme: {}", url.scheme()));
        }
        Ok(RedisUrl(url))
    }
```

**File:** ecosystem/nft-metadata-crawler/src/parser/worker.rs (L103-108)
```rust
        if Url::parse(&self.asset_uri).is_err() {
            self.log_info("URI is invalid, skipping parse, marking as do_not_parse");
            self.model.set_do_not_parse(true);
            SKIP_URI_COUNT.with_label_values(&["invalid"]).inc();
            return Ok(());
        }
```

**File:** ecosystem/nft-metadata-crawler/src/asset_uploader/throttler/mod.rs (L112-114)
```rust
            .json(&UploadRequest {
                url: Url::parse(&asset.asset_uri)?,
            })
```
