# Audit Report

## Title
InconsistentExecutionResult Fails to Detect Cross-Validator Non-Deterministic Execution Leading to Consensus Safety Violation

## Summary
The `InconsistentExecutionResult` error does not catch non-deterministic execution across different validators. The `match_ordered_only()` method intentionally ignores `executed_state_id` (the actual execution result), only comparing epoch/round/id. This allows validators with different execution results to each pass validation independently, enabling consensus to either halt or commit incorrect state if ≥2f+1 validators happen to produce the same wrong result.

## Finding Description

The security guarantee being violated is **Critical Invariant #1: Deterministic Execution** - "All validators must produce identical state roots for identical blocks."

### The Core Issue [1](#0-0) 

The `match_ordered_only()` method only validates that epoch, round, id, and timestamp match between ordered and executed block info. Critically, it does **not** check:
- `executed_state_id` (the Merkle accumulator root hash after execution)
- `version` (the ledger version)
- `next_epoch_state`

This method is called during commit vote signing: [2](#0-1) 

The check compares a single validator's ordered ledger info (with placeholder `ACCUMULATOR_PLACEHOLDER_HASH`) against their own executed ledger info. It validates internal consistency but **not** cross-validator consistency.

### The Attack Path

1. A subtle bug in the execution engine (race condition, undefined behavior, etc.) causes non-deterministic execution
2. Validators execute the same block but produce different `executed_state_id` values
3. Each validator independently calls `guarded_sign_commit_vote()` which passes the `match_ordered_only()` check (only validates epoch/round/id)
4. Each validator creates a `CommitVote` with their own unique `executed_state_id`
5. During vote aggregation, mismatched votes are silently filtered: [3](#0-2) 

6. **Failure Mode A**: If validators are evenly split between results, no quorum forms → chain halts (liveness failure)
7. **Failure Mode B**: If ≥2f+1 validators happen to get the same incorrect result → wrong state committed (consensus safety violation)

### Why This Is a Vulnerability

The `commit_ledger_info` used for vote matching is derived from **local execution**: [4](#0-3) 

Each validator filters incoming votes against their own execution result. Votes with different `executed_state_id` values are silently discarded without raising `InconsistentExecutionResult` or any other error.

## Impact Explanation

**Critical Severity** per Aptos Bug Bounty criteria:

1. **Consensus/Safety Violations**: If ≥2f+1 validators produce the same incorrect `executed_state_id` due to a non-deterministic bug, consensus will commit invalid state. This violates the fundamental safety property that all honest validators agree on the same state.

2. **Total Loss of Liveness/Network Availability**: If validators produce different results without a clear majority, the chain halts indefinitely. No error is surfaced to operators indicating the root cause is non-deterministic execution.

3. **Non-Recoverable Network Partition**: Validators may fork into groups voting on different state roots. If multiple groups each have <2f+1 voting power, the network cannot recover without manual intervention or a hardfork.

The impact is critical because:
- Breaks the core deterministic execution invariant
- Can lead to committing provably incorrect state
- Provides no visibility to operators (votes silently filtered)
- Requires hardfork to recover from committed wrong state

## Likelihood Explanation

**Moderate to High Likelihood:**

1. **Execution bugs are common**: Non-determinism has affected major blockchain systems (Ethereum's Shanghai incident, Solana's repeated outages). Common causes include:
   - Floating-point operations with platform-specific rounding
   - Race conditions in parallel execution
   - Undefined behavior in unsafe Rust code
   - Hardware-specific instruction differences
   - Compiler optimization variations

2. **Aptos executes complex Move bytecode**: The VM has multiple native functions, resource access patterns, and state management operations where subtle non-determinism could be introduced.

3. **Silent failure mode**: Because mismatched votes are silently filtered rather than raising errors, non-determinism could go undetected during testing but manifest in production under specific conditions.

4. **No defense in depth**: The `InconsistentExecutionResult` check is positioned as the safety mechanism but doesn't actually detect the problem.

## Recommendation

### Immediate Fix

Add explicit cross-validator execution result validation. Modify vote aggregation to detect and reject mismatched execution results with a clear error:

```rust
// In consensus/src/pipeline/buffer_item.rs, modify create_signature_aggregator:
fn create_signature_aggregator(
    unverified_votes: HashMap<Author, CommitVote>,
    commit_ledger_info: &LedgerInfo,
) -> Result<SignatureAggregator<LedgerInfo>, Error> {
    let mut sig_aggregator = SignatureAggregator::new(commit_ledger_info.clone());
    let mut mismatched_votes = Vec::new();
    
    for (author, vote) in unverified_votes.iter() {
        let sig = vote.signature_with_status();
        if vote.ledger_info() == commit_ledger_info {
            sig_aggregator.add_signature(vote.author(), sig);
        } else if vote.ledger_info().commit_info().match_ordered_only(commit_ledger_info.commit_info()) {
            // Same epoch/round/id but different execution results!
            mismatched_votes.push((author, vote.ledger_info().commit_info().clone()));
        }
    }
    
    if !mismatched_votes.is_empty() {
        error!(
            "NON-DETERMINISTIC EXECUTION DETECTED! Expected: {}, Mismatched votes: {:?}",
            commit_ledger_info.commit_info(), mismatched_votes
        );
        // Optionally panic or return error to force operator intervention
        return Err(Error::InconsistentExecutionResult(
            format!("{:?}", mismatched_votes),
            format!("{}", commit_ledger_info.commit_info())
        ));
    }
    
    Ok(sig_aggregator)
}
```

### Long-Term Fix

1. **Enhanced validation in match_ordered_only**: Add a separate method `match_execution_results()` that explicitly compares `executed_state_id`, `version`, and `next_epoch_state` across validators.

2. **Monitoring and alerting**: Add metrics tracking when votes are filtered due to mismatched execution results, with alerts when count exceeds threshold.

3. **Determinism testing**: Expand test suite to include cross-validator non-determinism scenarios where different validators produce different execution results.

## Proof of Concept

```rust
// Test demonstrating the vulnerability
// Add to consensus/safety-rules/src/tests/suite.rs

#[test]
fn test_cross_validator_non_determinism_undetected() {
    use aptos_crypto::HashValue;
    use aptos_types::block_info::BlockInfo;
    
    // Setup two validators
    let (mut safety_rules_1, _) = make_safety_rules();
    let (mut safety_rules_2, _) = make_safety_rules();
    
    // Create ordered ledger info with placeholder execution result
    let ordered_block_info = BlockInfo::new(
        1, // epoch
        100, // round
        HashValue::random(),
        *ACCUMULATOR_PLACEHOLDER_HASH, // placeholder for execution
        0, // version
        12345, // timestamp
        None,
    );
    let ordered_ledger_info = LedgerInfoWithSignatures::new(
        LedgerInfo::new(ordered_block_info.clone(), HashValue::zero()),
        AggregateSignature::empty(), // Would have signatures in real scenario
    );
    
    // Validator 1 executes and gets state root A
    let executed_block_info_v1 = BlockInfo::new(
        1, // same epoch
        100, // same round
        ordered_block_info.id(), // same block id
        HashValue::from_u64(0xAAAA), // different execution result!
        100, // version after execution
        12345, // same timestamp
        None,
    );
    let commit_ledger_info_v1 = LedgerInfo::new(
        executed_block_info_v1,
        HashValue::zero(),
    );
    
    // Validator 2 executes and gets state root B (non-determinism!)
    let executed_block_info_v2 = BlockInfo::new(
        1, // same epoch
        100, // same round
        ordered_block_info.id(), // same block id
        HashValue::from_u64(0xBBBB), // DIFFERENT execution result!
        100, // version after execution
        12345, // same timestamp
        None,
    );
    let commit_ledger_info_v2 = LedgerInfo::new(
        executed_block_info_v2,
        HashValue::zero(),
    );
    
    // VULNERABILITY: Both validators pass the InconsistentExecutionResult check!
    let result_v1 = safety_rules_1.sign_commit_vote(
        ordered_ledger_info.clone(),
        commit_ledger_info_v1.clone(),
    );
    let result_v2 = safety_rules_2.sign_commit_vote(
        ordered_ledger_info.clone(),
        commit_ledger_info_v2.clone(),
    );
    
    // Both succeed even though they have different execution results!
    assert!(result_v1.is_ok(), "Validator 1 should pass validation");
    assert!(result_v2.is_ok(), "Validator 2 should pass validation");
    
    // But their commit votes have DIFFERENT executed_state_ids!
    assert_ne!(
        commit_ledger_info_v1.commit_info().executed_state_id(),
        commit_ledger_info_v2.commit_info().executed_state_id(),
        "Non-determinism: different state roots!"
    );
    
    // The InconsistentExecutionResult error was NOT raised!
    // This demonstrates the vulnerability: cross-validator non-determinism
    // is silently allowed to pass validation.
}
```

## Notes

This vulnerability demonstrates a gap between what the `InconsistentExecutionResult` error name suggests (catching all execution inconsistencies) versus what it actually does (only catching intra-validator inconsistencies). The security model implicitly relies on vote aggregation filtering to prevent commitment of divergent states, but this provides no visibility or explicit error handling for non-deterministic execution bugs. In a worst-case scenario where ≥2f+1 validators share the same execution bug conditions, consensus would commit incorrect state without any validator detecting the inconsistency.

### Citations

**File:** types/src/block_info.rs (L196-204)
```rust
    pub fn match_ordered_only(&self, executed_block_info: &BlockInfo) -> bool {
        self.epoch == executed_block_info.epoch
            && self.round == executed_block_info.round
            && self.id == executed_block_info.id
            && (self.timestamp_usecs == executed_block_info.timestamp_usecs
            // executed block info has changed its timestamp because it's a reconfiguration suffix
                || (self.timestamp_usecs > executed_block_info.timestamp_usecs
                    && executed_block_info.has_reconfiguration()))
    }
```

**File:** consensus/safety-rules/src/safety_rules.rs (L395-403)
```rust
        if !old_ledger_info
            .commit_info()
            .match_ordered_only(new_ledger_info.commit_info())
        {
            return Err(Error::InconsistentExecutionResult(
                old_ledger_info.commit_info().to_string(),
                new_ledger_info.commit_info().to_string(),
            ));
        }
```

**File:** consensus/src/pipeline/buffer_item.rs (L40-52)
```rust
fn create_signature_aggregator(
    unverified_votes: HashMap<Author, CommitVote>,
    commit_ledger_info: &LedgerInfo,
) -> SignatureAggregator<LedgerInfo> {
    let mut sig_aggregator = SignatureAggregator::new(commit_ledger_info.clone());
    for vote in unverified_votes.values() {
        let sig = vote.signature_with_status();
        if vote.ledger_info() == commit_ledger_info {
            sig_aggregator.add_signature(vote.author(), sig);
        }
    }
    sig_aggregator
}
```

**File:** consensus/src/pipeline/buffer_item.rs (L132-166)
```rust
                let mut commit_info = executed_blocks
                    .last()
                    .expect("execute_blocks should not be empty!")
                    .block_info();
                match epoch_end_timestamp {
                    Some(timestamp) if commit_info.timestamp_usecs() != timestamp => {
                        assert!(executed_blocks
                            .last()
                            .expect("")
                            .is_reconfiguration_suffix());
                        commit_info.change_timestamp(timestamp);
                    },
                    _ => (),
                }
                if let Some(commit_proof) = commit_proof {
                    // We have already received the commit proof in fast forward sync path,
                    // we can just use that proof and proceed to aggregated
                    assert_eq!(commit_proof.commit_info().clone(), commit_info);
                    debug!(
                        "{} advance to aggregated from ordered",
                        commit_proof.commit_info()
                    );
                    Self::Aggregated(Box::new(AggregatedItem {
                        executed_blocks,
                        commit_proof,
                    }))
                } else {
                    let commit_ledger_info = generate_commit_ledger_info(
                        &commit_info,
                        &ordered_proof,
                        order_vote_enabled,
                    );

                    let mut partial_commit_proof =
                        create_signature_aggregator(unverified_votes, &commit_ledger_info);
```
