# Audit Report

## Title
Version Rollback Attack via Inconsistent Staleness Checks in TrustedState Epoch Transitions

## Summary
The `TrustedState` implementation delegates staleness checking to underlying verifiers (`Waypoint` or `EpochState`), which use different staleness definitions. `Waypoint` checks version-based staleness while `EpochState` checks epoch-based staleness. This inconsistency allows a malicious full node to trick light clients into accepting epoch change proofs with earlier versions, causing a version rollback within the same epoch.

## Finding Description

The vulnerability exists in how `TrustedState` validates epoch change proofs when in `EpochState` mode. [1](#0-0) 

When delegating staleness checks, `EpochState` only validates epoch numbers, not versions: [2](#0-1) 

In contrast, `Waypoint` correctly checks version-based staleness: [3](#0-2) 

During epoch change proof verification, the staleness check is performed using the current verifier's definition: [4](#0-3) 

The critical vulnerability occurs in `verify_and_ratchet_inner` when the conditions are met for using `epoch_change_li` as the verified ledger info: [5](#0-4) 

**Attack Scenario:**

1. Light client is at `TrustedState::EpochState { epoch: 10, waypoint: version 1000 }`
2. Blockchain has progressed to epoch 15, version 2000
3. At epoch 10, version 900, validators legitimately signed a ledger info (historical record)
4. Malicious full node provides:
   - `latest_li`: epoch 15, version 2000 (current legitimate state)
   - `epoch_change_proof`: Historical ledger info at (epoch 10, version 900) with `more=true`

5. In `EpochChangeProof::verify()`:
   - Staleness check uses `EpochState::is_ledger_info_stale()`
   - Check: `epoch 10 < epoch 10` = false (NOT stale) ✓
   - Version 900 < 1000 is **never checked**

6. In `verify_and_ratchet_inner()`:
   - Line 155-159: Checks `latest_li` version (2000 >= 1000) ✓
   - Line 183-184: Since `latest_li.epoch() (15) > new_epoch (11)` and `more=true`:
     - `verified_ledger_info = epoch_change_li` (version 900)
   - Line 188: `new_waypoint = Waypoint::new_any(epoch_change_li)`
   - **Client version rolls back from 1000 → 900**

This breaks the monotonic version progression invariant. The light client now has a stale view of epoch 10, potentially missing 100 versions of state transitions.

## Impact Explanation

**High Severity** - This vulnerability enables state inconsistency attacks against light clients:

1. **Stale State Views**: Light clients accept outdated state within an epoch, missing recent transactions and state updates
2. **Transaction Replay Risk**: Transactions from versions 900-1000 appear to have never occurred
3. **Account Balance Manipulation**: Clients see incorrect account balances from the rolled-back version
4. **Consensus View Divergence**: Different light clients could have conflicting views of chain state
5. **Governance Impact**: Stale validator sets or governance decisions could be shown

While not directly causing consensus safety violations among validators, this enables light client manipulation that could lead to double-spending scenarios or incorrect application behavior based on stale state data.

The attack requires a malicious full node but uses only legitimate validator signatures from historical blocks, making it feasible without validator collusion.

## Likelihood Explanation

**Medium-High Likelihood:**

**Attack Requirements:**
- Malicious full node serving state proofs to light clients (realistic threat model)
- Access to historical ledger infos with valid signatures (publicly available on-chain)
- Light client attempting to sync across multiple epochs

**Ease of Exploitation:**
- No validator private keys needed
- No signature forgery required
- Simply requires serving stale-but-valid epoch change proofs
- Can target any light client syncing from a malicious full node

The attack is particularly effective against:
- Newly syncing light clients
- Clients recovering from downtime
- Mobile/browser-based light clients with intermittent connectivity

## Recommendation

Add version-based staleness validation in `EpochState::is_ledger_info_stale()` or add an explicit version check in `EpochChangeProof::verify()`:

**Option 1 - Fix in EpochState (Recommended):**
```rust
// In types/src/epoch_state.rs
impl Verifier for EpochState {
    fn is_ledger_info_stale(&self, ledger_info: &LedgerInfo) -> bool {
        // Check epoch-based staleness OR version-based staleness
        // Note: We need to track the last verified version in EpochState
        ledger_info.epoch() < self.epoch
        // TODO: Also check ledger_info.version() < self.last_verified_version
    }
}
```

**Option 2 - Fix in EpochChangeProof::verify() (Alternative):**
```rust
// In types/src/epoch_change.rs, around line 72
pub fn verify(&self, verifier: &dyn Verifier) -> Result<&LedgerInfoWithSignatures> {
    ensure!(
        !self.ledger_info_with_sigs.is_empty(),
        "The EpochChangeProof is empty"
    );
    
    let last_li = self.ledger_info_with_sigs.last().unwrap().ledger_info();
    
    // Check epoch-based staleness
    ensure!(
        !verifier.is_ledger_info_stale(last_li),
        "The EpochChangeProof is stale (epoch check)"
    );
    
    // ADD: Check version-based staleness if verifier is EpochState
    if let Some(epoch_state) = verifier.downcast_ref::<EpochState>() {
        ensure!(
            last_li.version() >= epoch_state.waypoint.version(),
            "The EpochChangeProof is stale (version check)"
        );
    }
    
    // ... rest of verification
}
```

**Preferred Solution:** Track last verified version in `TrustedState::EpochState` and validate it in both staleness checks and epoch change proof verification.

## Proof of Concept

```rust
#[cfg(test)]
mod test_version_rollback_attack {
    use super::*;
    use crate::{
        aggregate_signature::PartialSignatures,
        block_info::BlockInfo,
        epoch_change::EpochChangeProof,
        epoch_state::EpochState,
        ledger_info::{LedgerInfo, LedgerInfoWithSignatures},
        transaction::Version,
        trusted_state::{TrustedState, TrustedStateChange},
        validator_verifier::random_validator_verifier,
        waypoint::Waypoint,
    };
    use aptos_crypto::hash::HashValue;
    use std::sync::Arc;

    #[test]
    fn test_version_rollback_via_epoch_staleness_check() {
        // Setup: Create validator set for epoch 10
        let (signers_epoch_10, verifier_epoch_10) = 
            random_validator_verifier(4, None, true);
        let verifier_epoch_10 = Arc::new(verifier_epoch_10);
        
        // Setup: Create validator set for epoch 11
        let (_signers_epoch_11, verifier_epoch_11) = 
            random_validator_verifier(4, None, true);
        let epoch_state_11 = EpochState::new(11, (*verifier_epoch_11).clone());

        // Create ledger info at epoch 10, version 900 (the "stale" one)
        let li_epoch10_v900 = LedgerInfo::new(
            BlockInfo::new(
                10, 0, HashValue::zero(), HashValue::zero(),
                900, 0, Some(epoch_state_11.clone())
            ),
            HashValue::zero(),
        );
        
        // Sign it with epoch 10 validators
        let partial_sigs_900 = PartialSignatures::new(
            signers_epoch_10.iter()
                .map(|s| (s.author(), s.sign(&li_epoch10_v900).unwrap()))
                .collect()
        );
        let agg_sig_900 = verifier_epoch_10
            .aggregate_signatures(partial_sigs_900.signatures_iter())
            .unwrap();
        let li_with_sigs_v900 = LedgerInfoWithSignatures::new(
            li_epoch10_v900, agg_sig_900
        );

        // Client's current state: epoch 10, version 1000
        let li_epoch10_v1000 = LedgerInfo::new(
            BlockInfo::new(
                10, 0, HashValue::zero(), HashValue::zero(),
                1000, 0, Some(epoch_state_11.clone())
            ),
            HashValue::zero(),
        );
        let current_waypoint = Waypoint::new_any(&li_epoch10_v1000);
        let trusted_state = TrustedState::EpochState {
            waypoint: current_waypoint,
            epoch_state: EpochState::new(10, (*verifier_epoch_10).clone()),
        };

        // Attacker provides: latest_li at epoch 13, epoch_change_proof with stale v900
        let (signers_epoch_13, verifier_epoch_13) = 
            random_validator_verifier(4, None, true);
        let li_epoch13_v1300 = LedgerInfo::new(
            BlockInfo::new(
                13, 0, HashValue::zero(), HashValue::zero(),
                1300, 0, None
            ),
            HashValue::zero(),
        );
        let partial_sigs_1300 = PartialSignatures::new(
            signers_epoch_13.iter()
                .map(|s| (s.author(), s.sign(&li_epoch13_v1300).unwrap()))
                .collect()
        );
        let agg_sig_1300 = verifier_epoch_13
            .aggregate_signatures(partial_sigs_1300.signatures_iter())
            .unwrap();
        let latest_li = LedgerInfoWithSignatures::new(
            li_epoch13_v1300, agg_sig_1300
        );

        // Malicious epoch change proof with stale version 900
        let epoch_change_proof = EpochChangeProof::new(
            vec![li_with_sigs_v900], 
            true // more=true to trigger the vulnerable code path
        );

        // Attempt to ratchet - this should fail but currently succeeds
        let result = trusted_state.verify_and_ratchet_inner(
            &latest_li, 
            &epoch_change_proof
        );

        match result {
            Ok(TrustedStateChange::Epoch { new_state, .. }) => {
                // VULNERABILITY: Version rolled back from 1000 to 900!
                assert_eq!(new_state.version(), 900);
                println!("VULNERABILITY CONFIRMED: Version rolled back from 1000 to 900");
            }
            _ => {
                println!("Attack failed - version rollback prevented");
            }
        }
    }
}
```

**Notes:**
- The PoC demonstrates how epoch-based staleness checking allows version rollback within the same epoch
- The vulnerability is exploitable when `more=true` and `latest_li` is far ahead in epochs
- The root cause is the inconsistency between `Waypoint::is_ledger_info_stale()` (version-based) and `EpochState::is_ledger_info_stale()` (epoch-based)
- This breaks the monotonic version progression invariant critical for state consistency
- Light clients are the primary attack surface, as they rely on full nodes for state proofs

### Citations

**File:** types/src/trusted_state.rs (L178-188)
```rust
            let verified_ledger_info = if epoch_change_li == latest_li {
                latest_li
            } else if latest_li.ledger_info().epoch() == new_epoch {
                new_epoch_state.verify(latest_li)?;
                latest_li
            } else if latest_li.ledger_info().epoch() > new_epoch && epoch_change_proof.more {
                epoch_change_li
            } else {
                bail!("Inconsistent epoch change proof and latest ledger info");
            };
            let new_waypoint = Waypoint::new_any(verified_ledger_info.ledger_info());
```

**File:** types/src/trusted_state.rs (L255-262)
```rust
    fn is_ledger_info_stale(&self, ledger_info: &LedgerInfo) -> bool {
        match self {
            Self::EpochWaypoint(waypoint) => Verifier::is_ledger_info_stale(waypoint, ledger_info),
            Self::EpochState { epoch_state, .. } => {
                Verifier::is_ledger_info_stale(epoch_state, ledger_info)
            },
        }
    }
```

**File:** types/src/epoch_state.rs (L56-58)
```rust
    fn is_ledger_info_stale(&self, ledger_info: &LedgerInfo) -> bool {
        ledger_info.epoch() < self.epoch
    }
```

**File:** types/src/waypoint.rs (L91-93)
```rust
    fn is_ledger_info_stale(&self, ledger_info: &LedgerInfo) -> bool {
        ledger_info.version() < self.version()
    }
```

**File:** types/src/epoch_change.rs (L72-76)
```rust
            !verifier
                .is_ledger_info_stale(self.ledger_info_with_sigs.last().unwrap().ledger_info()),
            "The EpochChangeProof is stale as our verifier is already ahead \
             of the entire EpochChangeProof"
        );
```
