# Audit Report

## Title
Storage Service Request Validation Bypass: Missing proof_version >= end_version Check Allows Invalid Request DoS

## Summary
The `can_service()` validation logic for transaction/output requests fails to verify that `proof_version >= end_version`, allowing malicious peers to submit semantically invalid requests that bypass the invalid request counter. These requests waste server resources during processing and fail with internal errors rather than being counted as invalid requests, effectively bypassing the peer rate-limiting and blocking mechanism.

## Finding Description

The vulnerability exists in the `DataSummary::can_service_transactions_with_proof()`, `can_service_transaction_outputs_with_proof()`, and `can_service_transactions_or_outputs_with_proof()` methods. These methods validate whether a storage server can service a request for transactions/outputs with a proof, but they fail to enforce a critical constraint: **the proof version must be greater than or equal to the end version of the requested range**. [1](#0-0) 

The validation only checks:
1. Whether a valid `CompleteDataRange` can be created from `start_version` to `end_version`
2. Whether the server has the requested transactions in that range
3. Whether `can_create_proof(proof_version)` returns true [2](#0-1) 

The `can_create_proof()` method only checks if `synced_ledger_info.version() >= proof_version`, **but does NOT validate that `proof_version >= end_version`**.

When a malicious peer sends a request with `proof_version < end_version`:

1. The request passes `can_service()` validation in the request moderator [3](#0-2) 

2. The `invalid_request_count` is NOT incremented because `can_service()` returned `true`

3. The server attempts to process the request and fetch the transactions

4. When creating the accumulator range proof, the underlying accumulator validation fails [4](#0-3) 

The accumulator correctly enforces that `last_leaf_index < self.num_leaves`, which translates to requiring `end_version <= proof_version`. However, by this point, the request has already bypassed the invalid request counter.

5. The error is returned as an `InternalError` rather than `InvalidRequest` [5](#0-4) 

This breaks the security invariant that invalid requests should increment `invalid_request_count`, which is designed to block malicious peers after too many invalid requests. [6](#0-5) 

## Impact Explanation

**Severity: High**

This vulnerability enables a resource exhaustion attack against storage service nodes:

1. **Bypass of Peer Rate Limiting**: Malicious peers can send unlimited invalid requests without ever being blocked, as the `invalid_request_count` is never incremented for requests with `proof_version < end_version`.

2. **Resource Waste**: Each invalid request consumes server resources (CPU, I/O) to:
   - Fetch transactions from storage iterators
   - Attempt to create accumulator range proofs
   - Generate and log error responses

3. **Validator Node Slowdowns**: Flooding a storage service with these requests can degrade performance for legitimate state synchronization, affecting the node's ability to serve honest peers and participate in consensus.

4. **Protocol Violation**: The peer blocking mechanism (a critical defense against Byzantine peers) is fundamentally broken for this class of requests.

This meets the **High Severity** criteria per Aptos bug bounty:
- Validator node slowdowns
- Significant protocol violations (broken peer blocking mechanism)

## Likelihood Explanation

**Likelihood: High**

This vulnerability is highly exploitable:

1. **Low Barrier to Entry**: Any network peer can send storage service requests without authentication beyond basic P2P connection establishment.

2. **Simple Attack Vector**: The attacker simply needs to craft `GetTransactionsWithProof`, `GetTransactionOutputsWithProof`, or `GetTransactionsOrOutputsWithProof` requests with `proof_version < end_version`.

3. **No Special Privileges Required**: No validator status, stake, or consensus participation is needed.

4. **High Impact-to-Cost Ratio**: Each malicious request costs the attacker minimal bandwidth but forces the server to perform expensive storage operations and proof generation attempts.

5. **No Rate Limiting**: Since `invalid_request_count` is never incremented, the attacker can sustain the attack indefinitely without being blocked.

## Recommendation

Add explicit validation that `proof_version >= end_version` in all proof-based validation methods:

```rust
fn can_service_transactions_with_proof(
    &self,
    start_version: u64,
    end_version: u64,
    proof_version: u64,
) -> bool {
    // Validate that proof_version is sufficient to prove the requested range
    if proof_version < end_version {
        return false;
    }

    let desired_range = match CompleteDataRange::new(start_version, end_version) {
        Ok(desired_range) => desired_range,
        Err(_) => return false,
    };

    let can_service_transactions = self.can_service_transactions(&desired_range);
    let can_create_proof = self.can_create_proof(proof_version);
    can_service_transactions && can_create_proof
}
```

Apply the same fix to:
- `can_service_transaction_outputs_with_proof()`
- `can_service_transactions_or_outputs_with_proof()`

Additionally, for `GetStateValuesWithProof` requests, the same validation should be applied to ensure `proof_version >= version`.

## Proof of Concept

```rust
use aptos_config::config::{AptosDataClientConfig, StorageServiceConfig};
use aptos_storage_service_types::{
    requests::{DataRequest, StorageServiceRequest, TransactionsWithProofRequest},
    responses::{CompleteDataRange, DataSummary, StorageServerSummary},
};
use aptos_time_service::TimeService;
use aptos_types::ledger_info::LedgerInfoWithSignatures;

#[test]
fn test_can_service_validation_bypass() {
    // Setup: Create a storage server summary with synced version 1000
    let mut data_summary = DataSummary::default();
    
    // Mock ledger info at version 1000
    let synced_ledger_info = create_mock_ledger_info(1000);
    data_summary.synced_ledger_info = Some(synced_ledger_info);
    
    // Server has transactions [0, 1000]
    data_summary.transactions = Some(CompleteDataRange::new(0, 1000).unwrap());
    
    let storage_summary = StorageServerSummary {
        protocol_metadata: Default::default(),
        data_summary,
    };
    
    // Attack: Request transactions [100, 200] with proof_version=150
    // This is INVALID because proof_version (150) < end_version (200)
    let invalid_request = StorageServiceRequest::new(
        DataRequest::GetTransactionsWithProof(TransactionsWithProofRequest {
            proof_version: 150,
            start_version: 100,
            end_version: 200,
            include_events: false,
        }),
        false,
    );
    
    let config = AptosDataClientConfig::default();
    let time_service = TimeService::mock();
    
    // BUG: can_service() incorrectly returns TRUE
    let result = storage_summary.can_service(&config, time_service, &invalid_request);
    
    assert!(result, "BUG: can_service() should return false for proof_version < end_version, but returns true!");
    
    // This request would:
    // 1. Pass validation in moderator.rs without incrementing invalid_request_count
    // 2. Waste server resources attempting to process it
    // 3. Fail during accumulator proof generation with InternalError
    // 4. NOT penalize the malicious peer
}

fn create_mock_ledger_info(version: u64) -> LedgerInfoWithSignatures {
    // Implementation to create a mock LedgerInfoWithSignatures at the given version
    // This would use the actual types from aptos_types
    unimplemented!("Mock implementation needed for full PoC")
}
```

**Attack Scenario:**
1. Malicious peer connects to a storage service node
2. Peer repeatedly sends `GetTransactionsWithProof` requests with `proof_version=100, start_version=0, end_version=200`
3. Each request passes `can_service()` validation
4. Server wastes CPU/IO fetching 201 transactions from storage
5. Server fails to create proof at the accumulator level
6. Error returned as `InternalError`, `invalid_request_count` remains 0
7. Peer is never blocked, attack continues indefinitely
8. Storage service performance degrades, affecting legitimate state sync operations

## Notes

This vulnerability also affects:
- `GetTransactionOutputsWithProof` requests
- `GetTransactionsOrOutputsWithProof` requests  
- `GetTransactionDataWithProof` requests (v2 API)
- `GetStateValuesWithProof` requests (requires `proof_version >= version`)

All these request types share the same flawed validation pattern where `proof_version` constraints are not properly checked against the requested data range.

### Citations

**File:** state-sync/storage-service/types/src/responses.rs (L811-816)
```rust
    fn can_create_proof(&self, proof_version: u64) -> bool {
        self.synced_ledger_info
            .as_ref()
            .map(|li| li.ledger_info().version() >= proof_version)
            .unwrap_or(false)
    }
```

**File:** state-sync/storage-service/types/src/responses.rs (L868-882)
```rust
    fn can_service_transactions_with_proof(
        &self,
        start_version: u64,
        end_version: u64,
        proof_version: u64,
    ) -> bool {
        let desired_range = match CompleteDataRange::new(start_version, end_version) {
            Ok(desired_range) => desired_range,
            Err(_) => return false,
        };

        let can_service_transactions = self.can_service_transactions(&desired_range);
        let can_create_proof = self.can_create_proof(proof_version);
        can_service_transactions && can_create_proof
    }
```

**File:** state-sync/storage-service/server/src/moderator.rs (L47-69)
```rust
    /// Increments the invalid request count for the peer and marks
    /// the peer to be ignored if it has sent too many invalid requests.
    /// Note: we only ignore peers on the public network.
    pub fn increment_invalid_request_count(&mut self, peer_network_id: &PeerNetworkId) {
        // Increment the invalid request count
        self.invalid_request_count += 1;

        // If the peer is a PFN and has sent too many invalid requests, start ignoring it
        if self.ignore_start_time.is_none()
            && peer_network_id.network_id().is_public_network()
            && self.invalid_request_count >= self.max_invalid_requests
        {
            // TODO: at some point we'll want to terminate the connection entirely

            // Start ignoring the peer
            self.ignore_start_time = Some(self.time_service.now());

            // Log the fact that we're now ignoring the peer
            warn!(LogSchema::new(LogEntry::RequestModeratorIgnoredPeer)
                .peer_network_id(peer_network_id)
                .message("Ignoring peer due to too many invalid requests!"));
        }
    }
```

**File:** state-sync/storage-service/server/src/moderator.rs (L155-186)
```rust
            if !storage_server_summary.can_service(
                &self.aptos_data_client_config,
                self.time_service.clone(),
                request,
            ) {
                // Increment the invalid request count for the peer
                let mut unhealthy_peer_state = self
                    .unhealthy_peer_states
                    .entry(*peer_network_id)
                    .or_insert_with(|| {
                        // Create a new unhealthy peer state (this is the first invalid request)
                        let max_invalid_requests =
                            self.storage_service_config.max_invalid_requests_per_peer;
                        let min_time_to_ignore_peers_secs =
                            self.storage_service_config.min_time_to_ignore_peers_secs;
                        let time_service = self.time_service.clone();

                        UnhealthyPeerState::new(
                            max_invalid_requests,
                            min_time_to_ignore_peers_secs,
                            time_service,
                        )
                    });
                unhealthy_peer_state.increment_invalid_request_count(peer_network_id);

                // Return the validation error
                return Err(Error::InvalidRequest(format!(
                    "The given request cannot be satisfied. Request: {:?}, storage summary: {:?}",
                    request, storage_server_summary
                )));
            }

```

**File:** storage/accumulator/src/lib.rs (L421-429)
```rust
        let last_leaf_index = first_leaf_index
            .checked_add(num_leaves - 1)
            .ok_or_else(|| format_err!("Requesting too many leaves."))?;
        ensure!(
            last_leaf_index < self.num_leaves,
            "Invalid last_leaf_index: {}, num_leaves: {}",
            last_leaf_index,
            self.num_leaves,
        );
```

**File:** state-sync/storage-service/server/src/handler.rs (L196-202)
```rust
        process_result.map_err(|error| match error {
            Error::InvalidRequest(error) => StorageServiceError::InvalidRequest(error),
            Error::TooManyInvalidRequests(error) => {
                StorageServiceError::TooManyInvalidRequests(error)
            },
            error => StorageServiceError::InternalError(error.to_string()),
        })
```
