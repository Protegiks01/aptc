# Audit Report

## Title
Incomplete Pattern Visitor Coverage in Match Expressions Allows Cross-Module Private Struct Unpacking

## Summary
The `check_privileged_operations_on_structs()` function in the Move compiler v2's visibility checker does not validate patterns within `match` expression arms, only checking the discriminator type. This allows patterns containing cross-module private struct unpacking to bypass access control checks, potentially violating Move's module encapsulation guarantees.

## Finding Description

The `check_privileged_operations_on_structs()` function enforces that privileged struct operations (pack, unpack, field access) can only be performed within the defining module unless the struct has public or friend visibility. [1](#0-0) 

The function correctly handles `ExpData::Assign`, `ExpData::Block`, and `ExpData::Lambda` by calling `pat.visit_pre_post()` to recursively visit all nested patterns and check for `Pattern::Struct` unpacking.

However, for `ExpData::Match` expressions, the implementation is incomplete: [2](#0-1) 

This code only validates the discriminator type but completely ignores the patterns in match arms (the third parameter to `ExpData::Match` is discarded with `_`). Each `MatchArm` contains a `pattern` field that may include struct unpacking: [3](#0-2) 

The `Pattern::visit_pre_post()` method recursively traverses nested patterns including those within `Pattern::Struct`: [4](#0-3) 

**Attack Scenario:**

Consider this cross-module scenario:

```move
// Module A (0x1::A)
public enum Container has drop {
    V1(Inner),
    V2(u64)
}

struct Inner has drop {  // private!
    secret: u64
}

public fun make_container(x: u64): Container {
    Container::V1(Inner { secret: x })
}

// Module B (0x2::B)
use 0x1::A;

fun exploit(c: A::Container): u64 {
    match (c) {
        // Discriminator check passes (Container is public)
        // But pattern unpacks private Inner struct!
        A::Container::V1(A::Inner { secret }) => secret,
        A::Container::V2(x) => x,
    }
}
```

The vulnerability manifests because:
1. The discriminator `c` has type `A::Container` (public enum from module A)
2. The visibility check at line 460-481 validates that matching on `A::Container` is allowed
3. However, the nested pattern `A::Inner { secret }` unpacks the private `Inner` struct
4. Since match arm patterns are never traversed, this private struct unpacking bypasses the access control check

The same bug exists in the inlining optimization code: [5](#0-4) 

## Impact Explanation

**Severity: Medium**

This vulnerability breaks Move's fundamental module encapsulation invariant that private structs cannot be unpacked outside their defining module. The security implications include:

1. **Access Control Bypass**: Private struct fields can be accessed from unauthorized modules, violating the "Access Control" invariant that system resources and module-internal data structures must be protected

2. **State Consistency Violations**: If private structs maintain critical invariants (e.g., in governance or staking modules), unauthorized unpacking could expose internal state that was intended to be opaque

3. **Compilation Pipeline Failure**: The compiler's static safety guarantees are compromised, allowing potentially unsafe code to pass compilation

While this is a compile-time vulnerability (not runtime), it allows malicious or buggy Move modules to be compiled and deployed to the blockchain, where they would execute with access to private data structures they should not be able to observe.

## Likelihood Explanation

**Likelihood: Medium**

The vulnerability requires:
1. A public enum/struct type containing private struct fields from the same module
2. Cross-module code attempting to match on this type with patterns that unpack the private nested structs
3. Deployment of such code to the blockchain

Likelihood is medium because:
- The pattern (public enum with private struct fields) is uncommon but valid Move code
- Developers might inadvertently write such patterns when refactoring
- Malicious actors could deliberately exploit this to access protected data in framework modules
- The bug affects both visibility checking (function_checker.rs) and inlining decisions (inlining_optimization.rs)

## Recommendation

Fix the `check_privileged_operations_on_structs()` function to traverse match arm patterns:

```rust
ExpData::Match(_, discriminator, arms) => {
    // Check discriminator type
    let discriminator_node_id = discriminator.node_id();
    if let Type::Struct(mid, sid, _) =
        env.get_node_type(discriminator_node_id).drop_reference()
    {
        // ... existing discriminator check ...
    }
    
    // CHECK MATCH ARM PATTERNS (NEW CODE)
    for arm in arms {
        arm.pattern.visit_pre_post(&mut |_, pat| {
            if let Pattern::Struct(id, str, _, _) = pat {
                let module_id = str.module_id;
                let struct_env = env.get_struct(str.to_qualified_id());
                let msg_maker = || {
                    format!("unpack of `{}` in match pattern", 
                            struct_env.get_full_name_str())
                };
                check_for_access_error_or_warning(
                    env,
                    fun_env,
                    &struct_env,
                    &caller_module_id,
                    false,
                    id,
                    "unpacked",
                    msg_maker,
                    &struct_env.module_env,
                    module_id != caller_module_id,
                    caller_is_inline_non_private,
                );
            }
        });
    }
},
```

Apply the same fix to `has_privileged_operations()` in `inlining_optimization.rs`.

## Proof of Concept

Create two Move modules to demonstrate the bypass:

```move
// File: sources/private_container.move
module 0x1::private_container {
    public enum Container has drop {
        V1(SecretData),
        V2(u64)
    }
    
    struct SecretData has drop {
        private_value: u64
    }
    
    public fun make(x: u64): Container {
        Container::V1(SecretData { private_value: x })
    }
}

// File: sources/exploit.move  
module 0x2::exploit {
    use 0x1::private_container;
    
    // This should fail compilation but currently doesn't
    public fun extract_private(c: private_container::Container): u64 {
        match (c) {
            private_container::Container::V1(
                private_container::SecretData { private_value }
            ) => private_value,
            private_container::Container::V2(x) => x,
        }
    }
}
```

**Expected behavior**: Compilation should fail with "Invalid operation: unpack of `private_container::SecretData` can only be done within the defining module"

**Actual behavior**: Code compiles successfully, bypassing the visibility check

## Notes

The vulnerability affects the Move compiler v2's static analysis phase. While there may be additional runtime checks in the bytecode verifier, relying solely on runtime checks violates defense-in-depth principles. The compiler should enforce all visibility rules during compilation to prevent unsafe code from ever being deployed.

### Citations

**File:** third_party/move/move-compiler-v2/src/env_pipeline/function_checker.rs (L433-457)
```rust
                    ExpData::Assign(_, pat, _)
                    | ExpData::Block(_, pat, _, _)
                    | ExpData::Lambda(_, pat, _, _, _) => {
                        pat.visit_pre_post(&mut |_, pat| {
                            if let Pattern::Struct(id, str, _, _) = pat {
                                let module_id = str.module_id;
                                let struct_env = env.get_struct(str.to_qualified_id());
                                let msg_maker =
                                    || format!("unpack of `{}`", struct_env.get_full_name_str(),);
                                check_for_access_error_or_warning(
                                    env,
                                    fun_env,
                                    &struct_env,
                                    &caller_module_id,
                                    false,
                                    id,
                                    "unpacked",
                                    msg_maker,
                                    &struct_env.module_env,
                                    module_id != caller_module_id,
                                    caller_is_inline_non_private,
                                );
                            }
                        });
                    },
```

**File:** third_party/move/move-compiler-v2/src/env_pipeline/function_checker.rs (L458-482)
```rust
                    ExpData::Match(_, discriminator, _) => {
                        let discriminator_node_id = discriminator.node_id();
                        if let Type::Struct(mid, sid, _) =
                            env.get_node_type(discriminator_node_id).drop_reference()
                        {
                            let qualified_struct_id = mid.qualified(sid);
                            let struct_env = env.get_struct(qualified_struct_id);
                            let msg_maker = || {
                                format!("match on enum type `{}`", struct_env.get_full_name_str(),)
                            };
                            check_for_access_error_or_warning(
                                env,
                                fun_env,
                                &struct_env,
                                &caller_module_id,
                                false,
                                &discriminator_node_id,
                                "matched",
                                msg_maker,
                                &struct_env.module_env,
                                mid != caller_module_id,
                                caller_is_inline_non_private,
                            );
                        }
                    },
```

**File:** third_party/move/move-model/src/ast.rs (L777-783)
```rust
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MatchArm {
    pub loc: Loc,
    pub pattern: Pattern,
    pub condition: Option<Exp>,
    pub body: Exp,
}
```

**File:** third_party/move/move-model/src/ast.rs (L2489-2506)
```rust
    {
        use Pattern::*;
        visitor(false, self);
        match self {
            Var(..) | Wildcard(..) | Error(..) => {},
            Tuple(_, patvec) => {
                for pat in patvec {
                    pat.visit_pre_post(visitor);
                }
            },
            Struct(_, _, _, patvec) => {
                for pat in patvec {
                    pat.visit_pre_post(visitor);
                }
            },
        };
        visitor(true, self);
    }
```

**File:** third_party/move/move-compiler-v2/src/env_pipeline/inlining_optimization.rs (L446-453)
```rust
                    ExpData::Match(_, discriminator, _) => {
                        let did = discriminator.node_id();
                        if let Type::Struct(mid, ..) = env.get_node_type(did).drop_reference() {
                            if mid != caller_mid {
                                found = true;
                            }
                        }
                    },
```
