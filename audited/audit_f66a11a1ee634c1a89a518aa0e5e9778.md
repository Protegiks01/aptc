# Audit Report

## Title
DNS Rebinding/SSRF Vulnerability in Peer Discovery - Missing Private IP Range Validation

## Summary
The Aptos network layer fails to validate that DNS-resolved IP addresses are not in private ranges (RFC1918) when connecting to external peers. This allows malicious validator operators to advertise DNS-based network addresses that resolve to private IPs, causing victim nodes to attempt connections to internal services.

## Finding Description

The vulnerability exists in the TCP transport layer's DNS resolution flow. When a node attempts to connect to a peer using a DNS-based `NetworkAddress`, the code resolves the DNS name but only filters by IP version (IPv4 vs IPv6), not by whether the resolved IP is in a private range.

**Attack Flow:**

1. **On-Chain Address Storage**: A validator operator calls `update_network_and_fullnode_addresses()` with a DNS-based address like `/dns/attacker.com/tcp/6180/noise-ik/<pubkey>/handshake/0`. [1](#0-0) 

2. **Discovery Phase**: Honest nodes receive the updated validator set via on-chain discovery, which extracts network addresses without any private IP validation. [2](#0-1) 

3. **DNS Resolution**: When dialing the peer, `resolve_and_connect()` calls `resolve_with_filter()` which uses `IpFilter` to filter resolved addresses. [3](#0-2) 

4. **Insufficient Filtering**: The `IpFilter::matches()` function only checks IPv4 vs IPv6, allowing private IPs like 10.0.0.1, 192.168.x.x, or 172.16.x.x to pass through. [4](#0-3) 

5. **SSRF Exploitation**: The victim node attempts TCP connections to the attacker-controlled private IPs, enabling internal network scanning, access to internal APIs, firewall bypass, and potential service disruption.

**Root Cause**: The `IpFilter` enum only distinguishes between IPv4 and IPv6, but contains no logic to reject RFC1918 private ranges (10.0.0.0/8, 192.168.0.0/16, 172.16.0.0/12), RFC4193 ULA ranges (fc00::/7), link-local addresses (169.254.0.0/16, fe80::/10), or loopback addresses (127.0.0.0/8, ::1).

## Impact Explanation

**Severity: HIGH** - This vulnerability qualifies under the "Significant protocol violations" category in the Aptos bug bounty program. The impact includes:

1. **Server-Side Request Forgery (SSRF)**: Victim validator/fullnodes can be forced to connect to arbitrary internal services, potentially exposing internal APIs, databases, or management interfaces.

2. **Internal Network Reconnaissance**: Attackers can scan internal networks by observing connection attempts and timing patterns.

3. **Resource Exhaustion**: Causing nodes to repeatedly attempt connections to non-existent internal services can degrade performance.

4. **Firewall Bypass**: Internal services protected by network-level firewalls can be accessed via the blockchain node as a proxy.

5. **Protocol Integrity**: Violates the network security invariant that external peer connections should only target legitimate external peers, not internal infrastructure.

While this does not directly compromise consensus or cause fund loss, it represents a significant attack vector against validator infrastructure and network security.

## Likelihood Explanation

**Likelihood: HIGH**

1. **Low Attacker Requirements**: Any validator operator can update their network addresses on-chain without special privileges beyond the operator role.

2. **No Detection Mechanisms**: There are no on-chain or off-chain validation checks for private IP addresses in network addresses.

3. **Simple Exploitation**: The attacker only needs to control a DNS server and call a single on-chain function.

4. **Broad Attack Surface**: Both validator networks and public fullnode networks use the same discovery mechanism, expanding the number of potential victim nodes.

5. **Persistent Attack**: Once set on-chain, the malicious address persists until manually updated, affecting all nodes that discover this validator.

## Recommendation

Implement private IP range validation in the DNS resolution flow:

**Solution 1 - Add IP Range Validation to IpFilter:**

Extend the `IpFilter` type to include a method that validates IPs are not in private/reserved ranges, and apply this validation in `resolve_with_filter()` after DNS resolution completes.

**Solution 2 - Add Validation Layer in resolve_and_connect:**

Add an IP validation function that checks resolved addresses against private ranges before attempting connections:

```rust
fn is_global_ip(ip: &IpAddr) -> bool {
    match ip {
        IpAddr::V4(v4) => {
            !v4.is_private() && 
            !v4.is_loopback() && 
            !v4.is_link_local() &&
            !v4.is_broadcast() &&
            !v4.is_documentation()
        },
        IpAddr::V6(v6) => {
            !v6.is_loopback() &&
            !v6.is_unspecified() &&
            !v6.is_multicast() &&
            !(v6.segments()[0] & 0xfe00 == 0xfc00) // ULA fc00::/7
        }
    }
}
```

Apply this validation in `resolve_with_filter()` to filter resolved IPs before returning them for connection attempts.

**Solution 3 - On-Chain Validation:**

Add validation in the Move `update_network_and_fullnode_addresses()` function to parse and validate addresses before storing them on-chain. However, this is less effective as attackers can change DNS records after on-chain validation.

**Recommended Approach**: Implement Solution 2 for runtime protection, combined with monitoring/alerting for suspicious address patterns.

## Proof of Concept

**Rust Unit Test:**

```rust
#[cfg(test)]
mod test {
    use super::*;
    use aptos_types::network_address::NetworkAddress;
    use std::str::FromStr;
    
    #[tokio::test]
    async fn test_private_ip_dns_rebinding() {
        // Attacker sets up DNS that resolves to private IP
        let malicious_addr = NetworkAddress::from_str(
            "/dns/evil.example.com/tcp/6180"
        ).unwrap();
        
        // This should FAIL but currently SUCCEEDS
        // because IpFilter doesn't check for private ranges
        let result = resolve_and_connect(
            malicious_addr, 
            TCPBufferCfg::default()
        ).await;
        
        // The connection attempt happens to private IPs
        // In a real attack, evil.example.com would resolve to 192.168.1.1
        // demonstrating the SSRF vulnerability
    }
}
```

**Move Integration Test:**

```move
#[test(operator = @0x123, framework = @aptos_framework)]
fun test_private_ip_in_network_address(operator: &signer, framework: &signer) {
    // Setup validator with operator
    stake::initialize_test_validator(...);
    
    // Attacker (operator) updates to malicious DNS address
    let malicious_network_addr = x"..."; // BCS-encoded /dns/evil.com/tcp/6180/...
    let malicious_fullnode_addr = x"...";
    
    stake::update_network_and_fullnode_addresses(
        operator,
        @validator_addr,
        malicious_network_addr,
        malicious_fullnode_addr
    );
    
    // Address is stored on-chain without validation
    // Other nodes will discover and attempt connections
    // to whatever IP evil.com resolves to (including private IPs)
}
```

## Notes

1. **Actual DNS Control Required**: The attacker must control the DNS server for their advertised domain to return private IPs.

2. **IPv6 Private Ranges**: The vulnerability also affects IPv6 ULA (fc00::/7) and link-local (fe80::/10) addresses.

3. **Loopback Addresses**: Addresses like 127.0.0.1 and ::1 are also not filtered, potentially enabling localhost port scanning.

4. **Mitigation Urgency**: This should be patched before mainnet validators widely adopt DNS-based addresses for peer discovery.

5. **Related Components**: The same validation should be applied to seed peer configurations and any other source of peer network addresses.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L955-995)
```text
    public entry fun update_network_and_fullnode_addresses(
        operator: &signer,
        pool_address: address,
        new_network_addresses: vector<u8>,
        new_fullnode_addresses: vector<u8>,
    ) acquires StakePool, ValidatorConfig {
        check_stake_permission(operator);
        assert_reconfig_not_in_progress();
        assert_stake_pool_exists(pool_address);
        let stake_pool = borrow_global_mut<StakePool>(pool_address);
        assert!(signer::address_of(operator) == stake_pool.operator_address, error::unauthenticated(ENOT_OPERATOR));
        assert!(exists<ValidatorConfig>(pool_address), error::not_found(EVALIDATOR_CONFIG));
        let validator_info = borrow_global_mut<ValidatorConfig>(pool_address);
        let old_network_addresses = validator_info.network_addresses;
        validator_info.network_addresses = new_network_addresses;
        let old_fullnode_addresses = validator_info.fullnode_addresses;
        validator_info.fullnode_addresses = new_fullnode_addresses;

        if (std::features::module_event_migration_enabled()) {
            event::emit(
                UpdateNetworkAndFullnodeAddresses {
                    pool_address,
                    old_network_addresses,
                    new_network_addresses,
                    old_fullnode_addresses,
                    new_fullnode_addresses,
                },
            );
        } else {
            event::emit_event(
                &mut stake_pool.update_network_and_fullnode_addresses_events,
                UpdateNetworkAndFullnodeAddressesEvent {
                    pool_address,
                    old_network_addresses,
                    new_network_addresses,
                    old_fullnode_addresses,
                    new_fullnode_addresses,
                },
            );
        };
    }
```

**File:** network/discovery/src/validator_set.rs (L108-150)
```rust
pub(crate) fn extract_validator_set_updates(
    network_context: NetworkContext,
    node_set: ValidatorSet,
) -> PeerSet {
    let is_validator = network_context.network_id().is_validator_network();

    // Decode addresses while ignoring bad addresses
    node_set
        .into_iter()
        .map(|info| {
            let peer_id = *info.account_address();
            let config = info.into_config();

            let addrs = if is_validator {
                config
                    .validator_network_addresses()
                    .map_err(anyhow::Error::from)
            } else {
                config
                    .fullnode_network_addresses()
                    .map_err(anyhow::Error::from)
            }
            .map_err(|err| {
                inc_by_with_context(&DISCOVERY_COUNTS, &network_context, "read_failure", 1);

                warn!(
                    NetworkSchema::new(&network_context),
                    "OnChainDiscovery: Failed to parse any network address: peer: {}, err: {}",
                    peer_id,
                    err
                )
            })
            .unwrap_or_default();

            let peer_role = if is_validator {
                PeerRole::Validator
            } else {
                PeerRole::ValidatorFullNode
            };
            (peer_id, Peer::from_addrs(peer_role, addrs))
        })
        .collect()
}
```

**File:** network/netcore/src/transport/tcp.rs (L223-259)
```rust
pub async fn resolve_and_connect(
    addr: NetworkAddress,
    tcp_buff_cfg: TCPBufferCfg,
) -> io::Result<TcpStream> {
    let protos = addr.as_slice();

    if let Some(((ipaddr, port), _addr_suffix)) = parse_ip_tcp(protos) {
        // this is an /ip4 or /ip6 address, so we can just connect without any
        // extra resolving or filtering.
        connect_with_config(port, ipaddr, tcp_buff_cfg).await
    } else if let Some(((ip_filter, dns_name, port), _addr_suffix)) = parse_dns_tcp(protos) {
        // resolve dns name and filter
        let socketaddr_iter = resolve_with_filter(ip_filter, dns_name.as_ref(), port).await?;
        let mut last_err = None;

        // try to connect until the first succeeds
        for socketaddr in socketaddr_iter {
            match connect_with_config(socketaddr.port(), socketaddr.ip(), tcp_buff_cfg).await {
                Ok(stream) => return Ok(stream),
                Err(err) => last_err = Some(err),
            }
        }

        Err(last_err.unwrap_or_else(|| {
            io::Error::new(
                io::ErrorKind::InvalidInput,
                format!(
                    "could not resolve dns name to any address: name: {}, ip filter: {:?}",
                    dns_name.as_ref(),
                    ip_filter,
                ),
            )
        }))
    } else {
        Err(invalid_addr_error(&addr))
    }
}
```

**File:** types/src/network_address/mod.rs (L787-802)
```rust
#[derive(Copy, Clone, Debug, Eq, PartialEq)]
pub enum IpFilter {
    Any,
    OnlyIp4,
    OnlyIp6,
}

impl IpFilter {
    pub fn matches(&self, ipaddr: IpAddr) -> bool {
        match self {
            IpFilter::Any => true,
            IpFilter::OnlyIp4 => ipaddr.is_ipv4(),
            IpFilter::OnlyIp6 => ipaddr.is_ipv6(),
        }
    }
}
```
