# Audit Report

## Title
Validator Identity Disclosure via Inspection Service Peer Monitoring Metadata

## Summary
The inspection service endpoint `/peer_information` exposes the `distance_from_validators` metric for all connected peers, enabling attackers to identify which peers are validators (distance=0), validator full nodes (distance=1), or public full nodes (distance=2+). This information disclosure occurs when `expose_peer_information` is enabled (the default configuration).

## Finding Description

The `display_peer_monitoring_metadata()` function exposes peer monitoring metadata that includes `NetworkInformationResponse` containing the `distance_from_validators` field. [1](#0-0) 

This field is calculated such that validators return a distance of 0 when connected to other validators. [2](#0-1) 

The `NetworkInformationResponse` Display implementation explicitly shows this value: [3](#0-2) 

The inspection service binds to `0.0.0.0:9101` by default and the `expose_peer_information` flag defaults to `true`. [4](#0-3) 

For non-mainnet networks, the config optimizer automatically enables this endpoint. [5](#0-4) 

**Attack Path:**
1. Attacker sends HTTP GET request to `http://<node-ip>:9101/peer_information`
2. Response includes monitoring metadata for all connected peers
3. Each peer's `distance_from_validators` value reveals their role:
   - `distance_from_validators: 0` → Validator
   - `distance_from_validators: 1` → Validator Full Node (VFN)
   - `distance_from_validators: 2+` → Public Full Node
4. Attacker can map validator topology and identify specific validator nodes

## Impact Explanation

This vulnerability falls under **Low Severity** per the Aptos bug bounty criteria as "Minor information leaks." While it enables reconnaissance of the validator network topology, it does not directly cause:
- Loss of funds or fund manipulation
- Consensus safety violations
- State inconsistencies
- Liveness issues

The disclosed information could theoretically enable secondary attacks (targeted DDoS, eclipse attacks), but such network-level attacks are explicitly out of scope for the bug bounty program.

**Note:** The security question categorizes this as "Medium" severity, but according to the strict bug bounty criteria provided, information disclosure without direct impact to funds, consensus, or availability constitutes Low severity.

## Likelihood Explanation

**High likelihood** on testnet and devnet where `expose_peer_information` is automatically enabled. **Medium likelihood** on mainnet depending on configuration, though the default value is `true`. Exploitation requires only a single unauthenticated HTTP request to a publicly accessible endpoint.

## Recommendation

1. **Disable by default on mainnet**: Set `expose_peer_information: false` as the default for mainnet deployments
2. **Sanitize exposed data**: Filter out or aggregate `distance_from_validators` to prevent validator identification
3. **Add authentication**: Require authentication for the `/peer_information` endpoint
4. **Bind to localhost**: Change default address from `0.0.0.0` to `127.0.0.1` for sensitive endpoints

**Code Fix:**
```rust
// In inspection_service_config.rs, change default for mainnet
impl Default for InspectionServiceConfig {
    fn default() -> InspectionServiceConfig {
        InspectionServiceConfig {
            address: "127.0.0.1".to_string(), // Bind to localhost only
            port: 9101,
            expose_configuration: false,
            expose_identity_information: false,
            expose_peer_information: false, // Disable by default
            expose_system_information: false,
        }
    }
}
```

## Proof of Concept

```bash
#!/bin/bash
# Exploit script to identify validators from inspection service

NODE_IP="<target-node-ip>"
NODE_PORT="9101"

# Query the peer information endpoint
response=$(curl -s "http://${NODE_IP}:${NODE_PORT}/peer_information")

# Parse for distance_from_validators values
echo "$response" | grep -A 5 "Basic monitoring metadata" | grep "distance_from_validators: 0"

# Any peer with distance_from_validators: 0 is a validator
# Output will show: "distance_from_validators: 0" for validator peers
```

**Rust Test Reproduction:**

```rust
#[tokio::test]
async fn test_validator_identification_via_inspection_service() {
    // Create a validator config with inspection service enabled
    let mut config = NodeConfig::get_default_validator_config();
    config.inspection_service.expose_peer_information = true;
    
    // Send request to peer_information endpoint
    let response = send_get_request_to_path(&config, PEER_INFORMATION_PATH).await;
    let body = body::to_bytes(response.body_mut()).await.unwrap();
    let body_string = String::from_utf8(body.to_vec()).unwrap();
    
    // Verify that distance_from_validators is exposed
    assert!(body_string.contains("distance_from_validators"));
    
    // This demonstrates that validator identification is possible
    // by checking which peers have distance_from_validators: 0
}
```

## Notes

While this vulnerability enables network reconnaissance and validator identification, its classification as Low severity (per strict bug bounty criteria) versus Medium severity (per the security question) depends on whether we consider the *potential* for enabling secondary attacks or only the *direct* impact. The inspection service was likely designed for debugging purposes but creates an information disclosure risk when deployed on production networks with default settings.

### Citations

**File:** crates/aptos-inspection-service/src/server/peer_information.rs (L186-203)
```rust
fn display_peer_monitoring_metadata(
    peer_information_output: &mut Vec<String>,
    all_peers: &Vec<PeerNetworkId>,
    peers_and_metadata: &PeersAndMetadata,
) {
    peer_information_output.push("Basic monitoring metadata for each peer:".into());

    // Fetch and display the basic metadata for each peer
    for peer in all_peers {
        if let Ok(peer_metadata) = peers_and_metadata.get_metadata_for_peer(*peer) {
            let peer_monitoring_metadata = peer_metadata.get_peer_monitoring_metadata();
            peer_information_output.push(format!(
                "\t- Peer: {}, basic metadata: {}", // Display formatting for basic metadata
                peer, peer_monitoring_metadata
            ));
        }
    }
}
```

**File:** peer-monitoring-service/server/src/lib.rs (L296-340)
```rust
/// Returns the distance from the validators using the given base config
/// and the peers and metadata information.
fn get_distance_from_validators(
    base_config: &BaseConfig,
    peers_and_metadata: Arc<PeersAndMetadata>,
) -> u64 {
    // Get the connected peers and metadata
    let connected_peers_and_metadata = match peers_and_metadata.get_connected_peers_and_metadata() {
        Ok(connected_peers_and_metadata) => connected_peers_and_metadata,
        Err(error) => {
            warn!(LogSchema::new(LogEntry::PeerMonitoringServiceError).error(&error.into()));
            return MAX_DISTANCE_FROM_VALIDATORS;
        },
    };

    // If we're a validator and we have active validator peers, we're in the validator set.
    // TODO: figure out if we need to deal with validator set forks here.
    if base_config.role.is_validator() {
        for peer_metadata in connected_peers_and_metadata.values() {
            if peer_metadata.get_connection_metadata().role.is_validator() {
                return 0;
            }
        }
    }

    // Otherwise, go through our peers, find the min, and return a distance relative to the min
    let mut min_peer_distance_from_validators = MAX_DISTANCE_FROM_VALIDATORS;
    for peer_metadata in connected_peers_and_metadata.values() {
        if let Some(ref latest_network_info_response) = peer_metadata
            .get_peer_monitoring_metadata()
            .latest_network_info_response
        {
            min_peer_distance_from_validators = min(
                min_peer_distance_from_validators,
                latest_network_info_response.distance_from_validators,
            );
        }
    }

    // We're one hop away from the peer
    min(
        MAX_DISTANCE_FROM_VALIDATORS,
        min_peer_distance_from_validators + 1,
    )
}
```

**File:** peer-monitoring-service/types/src/response.rs (L50-67)
```rust
/// A response for the network information request
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
pub struct NetworkInformationResponse {
    pub connected_peers: BTreeMap<PeerNetworkId, ConnectionMetadata>, // Connected peers
    pub distance_from_validators: u64, // The distance of the peer from the validator set
}

// Display formatting provides a high-level summary of the response
impl Display for NetworkInformationResponse {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "{{ num_connected_peers: {:?}, distance_from_validators: {:?} }}",
            self.connected_peers.len(),
            self.distance_from_validators,
        )
    }
}
```

**File:** config/src/config/inspection_service_config.rs (L26-37)
```rust
impl Default for InspectionServiceConfig {
    fn default() -> InspectionServiceConfig {
        InspectionServiceConfig {
            address: "0.0.0.0".to_string(),
            port: 9101,
            expose_configuration: false,
            expose_identity_information: true,
            expose_peer_information: true,
            expose_system_information: true,
        }
    }
}
```

**File:** config/src/config/inspection_service_config.rs (L71-109)
```rust
impl ConfigOptimizer for InspectionServiceConfig {
    fn optimize(
        node_config: &mut NodeConfig,
        local_config_yaml: &Value,
        _node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<bool, Error> {
        let inspection_service_config = &mut node_config.inspection_service;
        let local_inspection_config_yaml = &local_config_yaml["inspection_service"];

        // Enable all endpoints for non-mainnet nodes (to aid debugging)
        let mut modified_config = false;
        if let Some(chain_id) = chain_id {
            if !chain_id.is_mainnet() {
                if local_inspection_config_yaml["expose_configuration"].is_null() {
                    inspection_service_config.expose_configuration = true;
                    modified_config = true;
                }

                if local_inspection_config_yaml["expose_identity_information"].is_null() {
                    inspection_service_config.expose_identity_information = true;
                    modified_config = true;
                }

                if local_inspection_config_yaml["expose_peer_information"].is_null() {
                    inspection_service_config.expose_peer_information = true;
                    modified_config = true;
                }

                if local_inspection_config_yaml["expose_system_information"].is_null() {
                    inspection_service_config.expose_system_information = true;
                    modified_config = true;
                }
            }
        }

        Ok(modified_config)
    }
}
```
