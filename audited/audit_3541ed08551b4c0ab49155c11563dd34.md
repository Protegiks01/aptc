# Audit Report

## Title
Drop Implementation in Faucet Logging Middleware Violates Panic-Safety Guarantees

## Summary
The `Drop` trait implementation for `DropLogger` in the faucet middleware contains multiple operations that can panic, violating Aptos secure coding guidelines that mandate Drop implementations must not panic. This can cause process abort via double-panic during error unwinding.

## Finding Description

The `DropLogger::drop()` implementation violates the documented security requirement in `RUST_SECURE_CODING.md`: [1](#0-0) 

The Drop implementation performs several operations that can panic: [2](#0-1) 

**Panic Sources:**

1. **String allocation**: Lines 129 and 137 call `.to_string()` which allocates memory and can panic under OOM conditions

2. **Sample macro with system time**: Lines 143-146 use the `sample!` macro, which internally calls: [3](#0-2) 

This `.expect()` will panic if `SystemTime::now()` is before UNIX_EPOCH.

3. **Logging macros**: Lines 145, 148, 150, and 156 invoke logging macros that perform string formatting and I/O operations, which can panic on allocation failures or internal logger bugs.

**Attack Scenario:**
If a request handler panics during unwinding and the Drop implementation also panics (double-panic), Rust immediately aborts the process. The global panic handler confirms this behavior: [4](#0-3) 

## Impact Explanation

**Severity: Not Critical for Blockchain Security**

While this violates documented coding standards, the actual security impact is **limited**:

1. **Non-Consensus Component**: The faucet is a testnet token distribution service, not part of the consensus layer, validator operations, or core blockchain
2. **No Fund Risk**: Faucet distributes testnet tokens, not real value
3. **Isolated Service**: Crashing the faucet does not affect blockchain operation, validators, or state consistency
4. **Low Exploitability**: Requires both:
   - Triggering a panic in the request handler
   - AND triggering a panic in Drop (requires system clock before 1970 OR extreme memory pressure)

Per the bug bounty criteria, "API crashes" qualify as High Severity, but this applies to core blockchain APIs, not auxiliary testnet services.

## Likelihood Explanation

**Very Low Likelihood:**
- String allocation panic on u16 values is extremely unlikely
- System clock before UNIX_EPOCH (1970) is unrealistic in production
- Double-panic scenario requires two independent low-probability events
- Faucet endpoints use proper Result-based error handling, minimizing panic sources

## Recommendation

Refactor the Drop implementation to catch and suppress any potential panics using `std::panic::catch_unwind` or restructure to avoid panic-prone operations:

```rust
impl Drop for DropLogger<'_> {
    fn drop(&mut self) {
        // Wrap all operations in catch_unwind to prevent double-panic
        let _ = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            // Existing Drop logic here
        }));
    }
}
```

Alternatively, move metric recording and logging to the normal success path rather than Drop.

## Proof of Concept

```rust
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    #[should_panic]
    fn test_drop_double_panic() {
        // This test demonstrates the vulnerability, but requires
        // mocking system time or forcing allocation failures,
        // which is not feasible in a realistic attack scenario
        
        let drop_logger = DropLogger::new(HttpRequestLog {
            source_ip: None,
            method: "GET".to_string(),
            path: "/".to_string(),
            referer: None,
            user_agent: None,
            forwarded: None,
        });
        
        // Trigger panic during unwinding
        panic!("First panic");
        // Drop is called, if it panics -> double panic -> abort
    }
}
```

**Note**: A realistic PoC requires mocking `SystemTime` or simulating OOM conditions, which cannot be reliably demonstrated in a standard test environment.

---

## Notes

After thorough analysis, while this code **does violate the documented secure coding guidelines**, it does **NOT** constitute a high-severity security vulnerability affecting the Aptos blockchain because:

1. The faucet is not part of consensus, execution, storage, governance, or staking
2. The exploitability is extremely low (requires unrealistic conditions)
3. The impact is isolated to a non-critical testnet service
4. No realistic attack path demonstrated

This represents a **code quality issue** and **guideline violation** rather than an exploitable blockchain security vulnerability. The "EXTREMELY high bar" for validity is not met given the limited scope and low exploitability.

### Citations

**File:** RUST_SECURE_CODING.md (L93-94)
```markdown
In a Rust secure development, the implementation of the `std::ops::Drop` trait
must not panic.
```

**File:** crates/aptos-faucet/core/src/middleware/log.rs (L118-159)
```rust
impl Drop for DropLogger<'_> {
    fn drop(&mut self) {
        // Get some process info, e.g. the POD_NAME in case we're in a k8s context.
        let process_info = ProcessInfo {
            pod_name: std::env::var("POD_NAME").ok(),
        };

        match &self.response_log {
            Some(response_log) => {
                // Log response statuses generally.
                RESPONSE_STATUS
                    .with_label_values(&[response_log.response_status.to_string().as_str()])
                    .observe(response_log.elapsed.as_secs_f64());

                // Log response status per-endpoint + method.
                HISTOGRAM
                    .with_label_values(&[
                        self.request_log.method.as_str(),
                        response_log.operation_id,
                        response_log.response_status.to_string().as_str(),
                    ])
                    .observe(response_log.elapsed.as_secs_f64());

                // For now log all requests, no sampling, unless it is for `/`.
                if response_log.operation_id == "root" {
                    sample!(
                        SampleRate::Duration(Duration::from_secs(60)),
                        info!(self.request_log, *response_log, process_info)
                    );
                } else if response_log.response_status >= 500 {
                    error!(self.request_log, *response_log, process_info);
                } else {
                    info!(self.request_log, *response_log, process_info);
                }
            },
            None => {
                // If we don't have a response log, it means the client
                // hung up mid-request.
                warn!(self.request_log, process_info, destiny = "hangup");
            },
        }
    }
```

**File:** crates/aptos-logger/src/sample.rs (L62-68)
```rust
    fn sample_duration(rate: &Duration, last_sample: &AtomicU64) -> bool {
        let rate = rate.as_secs();
        // Seconds since Unix Epoch
        let now = SystemTime::now()
            .duration_since(SystemTime::UNIX_EPOCH)
            .expect("SystemTime before UNIX EPOCH!")
            .as_secs();
```

**File:** crates/crash-handler/src/lib.rs (L48-57)
```rust
    // Do not kill the process if the panics happened at move-bytecode-verifier.
    // This is safe because the `state::get_state()` uses a thread_local for storing states. Thus the state can only be mutated to VERIFIER by the thread that's running the bytecode verifier.
    //
    // TODO: once `can_unwind` is stable, we should assert it. See https://github.com/rust-lang/rust/issues/92988.
    if state::get_state() == VMState::VERIFIER || state::get_state() == VMState::DESERIALIZER {
        return;
    }

    // Kill the process
    process::exit(12);
```
