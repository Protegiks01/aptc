# Audit Report

## Title
Insufficient Audit Logging and Authentication Controls for Profiling Endpoints Allow Undetected Reconnaissance and Access

## Summary
The profiling endpoints (`/profilez`) in both the Admin Service and Indexer GRPC Framework lack comprehensive audit logging of authentication attempts and session details. Additionally, the Indexer GRPC Framework exposes profiling capabilities without any authentication. This enables attackers to perform system reconnaissance and trigger resource-intensive profiling operations without detection, violating security monitoring and access control requirements.

## Finding Description

The Aptos codebase exposes profiling functionality through two main pathways:

**1. Admin Service Profiling Endpoint (crates/aptos-admin-service/src/server/mod.rs)**

The admin service implements authentication for the `/profilez` endpoint using passcode-based SHA256 verification. [1](#0-0) 

However, **critical security events are not logged**:
- Authentication failures are not logged or tracked
- Successful authentication is not logged with details (source IP, timestamp, passcode used)
- Profiling session start/stop events lack authentication context
- When `authentication_configs` is empty (allowed on testnet/devnet), all requests are silently authenticated without any logging [2](#0-1) 

The configuration explicitly allows empty authentication on non-mainnet environments: [3](#0-2) 

**2. Profiling Implementation Logging (crates/aptos-system-utils/src/profiling.rs)**

The profiling implementation logs session start and completion, but **without any authentication or requester details**: [4](#0-3) [5](#0-4) 

These logs contain only technical parameters (duration, frequency) but no information about:
- Who initiated the profiling session
- Source IP address
- Authentication credentials used
- Whether authentication was required or bypassed

**3. Unauthenticated Indexer GRPC Framework Endpoint**

The Indexer GRPC server framework exposes a `/profilez` endpoint with **no authentication whatsoever**: [6](#0-5) 

This endpoint is exposed on the `health_check_port` for all indexer services (gateway, parser, data-service, file-store, cache-worker) and allows any network client to trigger CPU profiling.

**4. Absence of Security Event Logging**

The security logging system does not include events for admin service access or profiling operations: [7](#0-6) 

The `SecurityEvent` enum lacks categories for:
- Admin service authentication failures
- Unauthorized access attempts
- Profiling session initiation/termination
- Sensitive operational events

## Impact Explanation

This vulnerability constitutes **Medium Severity** under the Aptos Bug Bounty program for the following reasons:

**1. Reconnaissance Vector**: Attackers can use profiling data to understand system performance characteristics, identify bottlenecks, and plan targeted attacks without detection.

**2. Validator Security Monitoring Gap**: On testnet/devnet validators where authentication is disabled by default, profiling operations occur with zero audit trail. Even on mainnet validators with authentication enabled, failed brute-force attempts go undetected.

**3. Compliance and Incident Response**: The absence of audit logs violates security best practices for privileged operations and prevents:
   - Detection of unauthorized access attempts
   - Forensic analysis after security incidents
   - Compliance with audit logging requirements
   - Anomaly detection and intrusion detection systems

**4. Operational Impact**: Repeated profiling sessions, while mutex-protected from concurrency, can still degrade performance over time. Without logging, operators cannot identify the source of performance degradation.

**5. Defense Evasion**: Attackers can probe admin service endpoints and attempt authentication without triggering any security alerts, enabling persistent reconnaissance.

While this does not directly cause funds loss or consensus violations, it represents a "state inconsistency requiring intervention" in the security monitoring and access control systems, qualifying as Medium severity under the bug bounty criteria.

## Likelihood Explanation

**High Likelihood** of exploitation:

1. **Network Accessibility**: The admin service (port 9102/9202) and indexer health check ports are network-accessible services.

2. **Zero Detection**: The complete absence of authentication logging means attackers face no detection risk during reconnaissance.

3. **Default Configuration**: On testnet/devnet, the default configuration allows unauthenticated admin access, making exploitation trivial.

4. **Simple Attack Vector**: No complex exploitation required - simple HTTP GET requests to `/profilez` suffice.

5. **Valuable Intelligence**: Profiling data provides actionable intelligence for planning more sophisticated attacks.

## Recommendation

Implement comprehensive audit logging and strengthen authentication controls:

**1. Add Security Event Logging**

Extend the `SecurityEvent` enum to include admin service events:
```rust
pub enum SecurityEvent {
    // ... existing events ...
    
    // Admin Service
    AdminServiceAuthenticationFailure,
    AdminServiceAuthenticationSuccess,
    AdminServiceUnauthorizedAccess,
    ProfilingSessionStarted,
    ProfilingSessionCompleted,
}
```

**2. Implement Audit Logging in Admin Service**

Modify the authentication logic to log all attempts:
```rust
// Log authentication attempts
if !authenticated {
    error!(
        SecurityEvent::AdminServiceAuthenticationFailure,
        endpoint = req.uri().path(),
        source_ip = req.headers().get("Forwarded")
            .and_then(|h| h.to_str().ok())
            .unwrap_or("unknown"),
        timestamp = chrono::Utc::now().to_rfc3339(),
    );
    return Ok(reply_with_status(/* ... */));
} else {
    info!(
        SecurityEvent::AdminServiceAuthenticationSuccess,
        endpoint = req.uri().path(),
        source_ip = req.headers().get("Forwarded")
            .and_then(|h| h.to_str().ok())
            .unwrap_or("unknown"),
        timestamp = chrono::Utc::now().to_rfc3339(),
    );
}
```

**3. Enhance Profiling Logging**

Modify `start_cpu_profiling` to accept and log requester information:
```rust
pub async fn start_cpu_profiling(
    seconds: u64,
    frequency: i32,
    use_proto: bool,
    requester_info: Option<&str>,
) -> anyhow::Result<Vec<u8>> {
    info!(
        SecurityEvent::ProfilingSessionStarted,
        seconds = seconds,
        frequency = frequency,
        use_proto = use_proto,
        requester = requester_info.unwrap_or("unknown"),
        timestamp = chrono::Utc::now().to_rfc3339(),
        "Starting cpu profiling."
    );
    // ... existing code ...
}
```

**4. Add Authentication to Indexer GRPC Profiling**

Implement token-based authentication for the indexer framework's `/profilez` endpoint, or restrict access to localhost/internal networks only.

**5. Enforce Authentication on All Environments**

Consider requiring authentication even on testnet/devnet, or add explicit warnings when authentication is disabled.

## Proof of Concept

**Step 1: Demonstrate Unauthenticated Indexer Profiling**
```bash
# Access indexer profilez without authentication
curl http://<indexer-host>:<health_check_port>/profilez

# Returns CPU profile SVG with no authentication required
# No log entry indicates who accessed it or when
```

**Step 2: Demonstrate Admin Service Brute Force Without Detection**
```bash
# Attempt authentication with wrong passcode
for i in {1..100}; do
    curl "http://<validator-admin>:9202/profilez?passcode=wrong_$i"
done

# Check logs - NO failed authentication attempts logged
# Attacker can brute force without detection
```

**Step 3: Demonstrate Missing Authentication Context in Logs**
```bash
# Trigger profiling with correct passcode
curl "http://<validator-admin>:9202/profilez?passcode=<correct>"

# Check logs - see only:
# "Starting cpu profiling." (from profiling.rs:85-90)
# "Cpu profiling is done." (from profiling.rs:119)
# 
# Missing information:
# - Who made the request (source IP)
# - What passcode was used
# - Whether authentication was required
# - Full audit trail
```

**Step 4: Verify Testnet/Devnet Default Configuration**
```rust
// Create a testnet node config (from admin_service_config.rs tests)
let mut node_config = NodeConfig {
    admin_service: AdminServiceConfig {
        enabled: Some(true),
        authentication_configs: vec![], // Empty = no auth required
        ..Default::default()
    },
    ..Default::default()
};

// On testnet, admin service is enabled with NO authentication by default
// Profiling is completely open with zero logging
```

## Notes

The vulnerability spans multiple components:
- **Admin Service**: Authentication exists but lacks audit logging
- **Indexer Framework**: No authentication at all on profiling endpoint
- **Profiling Implementation**: Logs technical details but not security context
- **Security Events**: Missing categories for admin/profiling events

The combined effect creates a significant security monitoring gap that enables undetected reconnaissance and access. While HAProxy provides some network-level protection (IP blocking, connection limits), it does not address the application-level audit logging deficiency or the unauthenticated indexer endpoint.

This issue is particularly concerning for testnet/devnet validators where authentication is disabled by default, creating a completely open profiling interface with no audit trail.

### Citations

**File:** crates/aptos-admin-service/src/server/mod.rs (L154-181)
```rust
        let mut authenticated = false;
        if context.config.authentication_configs.is_empty() {
            authenticated = true;
        } else {
            for authentication_config in &context.config.authentication_configs {
                match authentication_config {
                    AuthenticationConfig::PasscodeSha256(passcode_sha256) => {
                        let query = req.uri().query().unwrap_or("");
                        let query_pairs: HashMap<_, _> =
                            url::form_urlencoded::parse(query.as_bytes()).collect();
                        let passcode: Option<String> =
                            query_pairs.get("passcode").map(|p| p.to_string());
                        if let Some(passcode) = passcode {
                            if sha256::digest(passcode) == *passcode_sha256 {
                                authenticated = true;
                            }
                        }
                    },
                }
            }
        };

        if !authenticated {
            return Ok(reply_with_status(
                StatusCode::NETWORK_AUTHENTICATION_REQUIRED,
                format!("{} endpoint requires authentication.", req.uri().path()),
            ));
        }
```

**File:** config/src/config/admin_service_config.rs (L21-22)
```rust
    // If empty, will allow all requests without authentication. (Not allowed on mainnet.)
    pub authentication_configs: Vec<AuthenticationConfig>,
```

**File:** crates/aptos-system-utils/src/profiling.rs (L85-90)
```rust
    info!(
        seconds = seconds,
        frequency = frequency,
        use_proto = use_proto,
        "Starting cpu profiling."
    );
```

**File:** crates/aptos-system-utils/src/profiling.rs (L119-119)
```rust
    info!("Cpu profiling is done.");
```

**File:** ecosystem/indexer-grpc/indexer-grpc-server-framework/src/lib.rs (L226-249)
```rust
        let profilez = warp::path("profilez").and_then(|| async move {
            // TODO(grao): Consider make the parameters configurable.
            Ok::<_, Infallible>(match start_cpu_profiling(10, 99, false).await {
                Ok(body) => {
                    let response = Response::builder()
                        .header("Content-Length", body.len())
                        .header("Content-Disposition", "inline")
                        .header("Content-Type", "image/svg+xml")
                        .body(body);

                    match response {
                        Ok(res) => warp::reply::with_status(res, warp::http::StatusCode::OK),
                        Err(e) => warp::reply::with_status(
                            Response::new(format!("Profiling failed: {e:?}.").as_bytes().to_vec()),
                            warp::http::StatusCode::INTERNAL_SERVER_ERROR,
                        ),
                    }
                },
                Err(e) => warp::reply::with_status(
                    Response::new(format!("Profiling failed: {e:?}.").as_bytes().to_vec()),
                    warp::http::StatusCode::INTERNAL_SERVER_ERROR,
                ),
            })
        });
```

**File:** crates/aptos-logger/src/security.rs (L23-82)
```rust
#[derive(Clone, Copy, Debug, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum SecurityEvent {
    //
    // Mempool
    //
    /// Mempool received a transaction from another peer with an invalid signature
    InvalidTransactionMempool,

    /// Mempool received an invalid network event
    InvalidNetworkEventMempool,

    // Consensus
    // ---------
    /// Consensus received an invalid message (not well-formed, invalid vote data or incorrect signature)
    ConsensusInvalidMessage,

    /// Consensus received an equivocating vote
    ConsensusEquivocatingVote,

    /// Consensus received an equivocating order vote
    ConsensusEquivocatingOrderVote,

    /// Consensus received an invalid proposal
    InvalidConsensusProposal,

    /// Consensus received an invalid new round message
    InvalidConsensusRound,

    /// Consensus received an invalid sync info message
    InvalidSyncInfoMsg,

    /// A received block is invalid
    InvalidRetrievedBlock,

    /// A block being committed or executed is invalid
    InvalidBlock,

    // State-Sync
    // ----------
    /// Invalid chunk of transactions received
    StateSyncInvalidChunk,

    // Health Checker
    // --------------
    /// HealthChecker received an invalid network event
    InvalidNetworkEventHC,

    /// HealthChecker received an invalid message
    InvalidHealthCheckerMsg,

    // Network
    // -------
    /// Network received an invalid message from a remote peer
    InvalidNetworkEvent,

    /// A failed noise handshake that's either a clear bug or indicates some
    /// security issue.
    NoiseHandshake,
}
```
