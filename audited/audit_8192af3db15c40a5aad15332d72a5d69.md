# Audit Report

## Title
Circular Trust Vulnerability: Config Sanitizer Bypass via Untrusted Config File Allows Malicious Settings Injection During Validator Startup

## Summary
An attacker with filesystem access can replace the validator's configuration file to inject malicious settings that execute during startup before any signature verification. The vulnerability stems from a circular trust issue where the `skip_config_sanitizer` flag—which controls whether security checks are performed—is itself loaded from the untrusted configuration file. This allows complete bypass of all configuration sanitization, enabling injection of malicious settings including failpoint actions, manipulated genesis files, redirected data directories, and disabled security features.

## Finding Description

The configuration loading process in Aptos Core suffers from a fundamental circular trust vulnerability: [1](#0-0) 

The `load_config()` function directly deserializes YAML configuration files without any cryptographic signature verification or integrity checking. The loaded configuration data is implicitly trusted.

During validator startup, configuration loading proceeds as follows: [2](#0-1) 

This delegates to: [3](#0-2) 

The critical flaw occurs in the sanitization step: [4](#0-3) 

The `skip_config_sanitizer` flag itself comes from the untrusted configuration file: [5](#0-4) 

**Attack Flow:**

1. Attacker gains filesystem access (via compromised host, container escape, supply chain attack, etc.)
2. Attacker replaces `node.yaml` with a malicious configuration containing:
   - `node_startup.skip_config_sanitizer: true`
   - Malicious settings like disabled security features, failpoint injections, or redirected file paths
3. Validator restarts and loads the malicious configuration
4. Because `skip_config_sanitizer: true`, ALL security sanitization is bypassed
5. Malicious settings execute during startup before any cryptographic verification

**Examples of Exploitable Settings (when sanitization is bypassed):**

- **Failpoints** (if compiled with failpoints feature): Inject arbitrary panic/sleep/return actions at critical consensus or execution points
- **Disabled Security Features**: Set `paranoid_hot_potato_verification: false` or `paranoid_type_verification: false` on mainnet, bypassing critical VM safety checks
- **Network Authentication**: Set `mutual_authentication: false` on validator network, disabling peer authentication
- **File Redirection**: Point `genesis_file_location` to attacker-controlled genesis file or redirect `data_dir` to attacker-controlled storage [6](#0-5) 

If failpoints are enabled, they execute during startup: [7](#0-6) 

## Impact Explanation

**Severity: High to Critical**

This vulnerability meets **High Severity** criteria (validator node crashes/slowdowns) and potentially **Critical Severity** depending on exploitation:

1. **Validator Availability (High)**: Attacker can inject failpoint actions causing validator to panic/crash on startup, or sleep indefinitely, leading to validator downtime and missed consensus participation.

2. **Security Feature Bypass (High)**: On mainnet validators, attacker can disable `paranoid_hot_potato_verification` and `paranoid_type_verification`, removing critical Move VM safety checks designed to prevent consensus splits and execution errors.

3. **Network Security Degradation (High)**: Attacker can disable `mutual_authentication` on validator network, allowing unauthenticated peers to connect to the validator.

4. **Genesis Manipulation (Critical Potential)**: Attacker can redirect `genesis_file_location` to load malicious genesis state, potentially affecting initial validator set or chain parameters.

5. **Data Directory Redirection (Critical Potential)**: Attacker can change `data_dir` to attacker-controlled location, potentially causing state corruption or information disclosure.

The impact affects consensus safety invariant #2 (AptosBFT must prevent chain splits) and validator liveness, which are critical to network operation.

## Likelihood Explanation

**Likelihood: Medium-High**

Prerequisites:
- Attacker needs filesystem write access to validator's config directory
- Requires validator restart/startup to trigger

Realistic attack vectors:
- **Compromised host**: Attacker gains access through vulnerability in OS, container, or other service
- **Container escape**: In containerized deployments, escape from container to host filesystem  
- **Supply chain attack**: Malicious CI/CD pipeline modifying configs during deployment
- **Insider threat**: Non-validator personnel with infrastructure access
- **Misconfigurations**: World-writable config directories due to deployment errors

While filesystem access is a strong prerequisite, it's not unrealistic for infrastructure deployments. Validators restart during upgrades, maintenance, or failures, providing exploitation windows.

## Recommendation

Implement defense-in-depth with multiple layers:

**1. Config File Signature Verification (Primary Fix)**

Add cryptographic signature verification before loading any configuration file:

```rust
// In persistable_config.rs
pub trait PersistableConfig: Serialize + DeserializeOwned {
    fn load_config<P: AsRef<Path>>(path: P) -> Result<Self, Error> {
        // Read and verify signature first
        let config_path = path.as_ref();
        let sig_path = config_path.with_extension("yaml.sig");
        
        let file_contents = Self::read_config_file(&path)?;
        
        // Verify signature if exists
        if sig_path.exists() {
            Self::verify_config_signature(&file_contents, &sig_path)?;
        } else {
            // In production, require signatures
            #[cfg(not(test))]
            return Err(Error::MissingConfigSignature(
                config_path.to_str().unwrap().to_string()
            ));
        }
        
        Self::parse_serialized_config(&file_contents)
    }
    
    fn verify_config_signature(
        contents: &str, 
        sig_path: &Path
    ) -> Result<(), Error> {
        // Verify using validator's public key or trusted authority key
        // Implementation details depend on key management strategy
        todo!("Implement signature verification")
    }
}
```

**2. Remove skip_config_sanitizer or Require Special Authorization**

The `skip_config_sanitizer` flag should either be removed entirely or require additional authorization (environment variable, separate signed file, hardware token) that cannot come from the config file itself:

```rust
// In config_sanitizer.rs
impl ConfigSanitizer for NodeConfig {
    fn sanitize(
        node_config: &NodeConfig,
        node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        // Check environment variable, not config field
        let skip_sanitizer = std::env::var("APTOS_SKIP_CONFIG_SANITIZER")
            .map(|v| v == "1")
            .unwrap_or(false);
            
        if skip_sanitizer {
            warn!("Config sanitization SKIPPED via environment variable!");
            return Ok(());
        }
        
        // Ignore the config file's skip_config_sanitizer field entirely
        // Always run sanitization unless environment override
        
        // ... rest of sanitization logic
    }
}
```

**3. Config File Immutability Checks**

Add filesystem-level protections:
- Use immutable files (chattr +i on Linux)
- Implement runtime integrity monitoring (hash checking)
- Alert on config file modifications

**4. Principle of Least Privilege**

- Config files should be owned by root with 400 permissions (read-only by owner)
- Validator process should run as non-root user
- Use separate mount namespaces in containers

## Proof of Concept

Create a malicious config file `malicious_validator.yaml`:

```yaml
base:
  role: "validator"
  data_dir: "/tmp/malicious_data"  # Attacker-controlled location

execution:
  genesis_file_location: "/tmp/malicious_genesis.blob"
  paranoid_hot_potato_verification: false  # Disable security checks
  paranoid_type_verification: false

node_startup:
  skip_config_sanitizer: true  # Bypass all validation!

validator_network:
  mutual_authentication: false  # Disable peer auth

failpoints:
  "consensus::start": "panic"  # Cause immediate crash on consensus start
```

**Exploitation Steps:**

1. Attacker gains filesystem access to validator host
2. Backup original config: `cp /opt/aptos/etc/node.yaml /opt/aptos/etc/node.yaml.bak`
3. Replace with malicious config: `cp malicious_validator.yaml /opt/aptos/etc/node.yaml`
4. Wait for validator restart (or trigger via service restart)
5. Validator loads malicious config with `skip_config_sanitizer: true`
6. All sanitization bypassed - security features disabled, failpoints active
7. If failpoints enabled in binary: validator panics on `consensus::start` 
8. If not: validator runs with security features disabled and potentially corrupted state from malicious genesis/data_dir

**To test without compromising a real validator:**

```bash
# Build aptos-node with failpoints feature
cargo build --release --features failpoints

# Create malicious config
cat > /tmp/test_malicious.yaml << EOF
base:
  role: "validator"
node_startup:
  skip_config_sanitizer: true
failpoints:
  "consensus::start": "panic"
execution:
  paranoid_hot_potato_verification: false
EOF

# Attempt to start node with malicious config
# This should panic due to failpoint, demonstrating the vulnerability
./target/release/aptos-node -f /tmp/test_malicious.yaml
```

Expected result: Validator panics at consensus startup, or runs with security features disabled, proving config injection without any cryptographic verification.

## Notes

This vulnerability represents a **fundamental design flaw** in the configuration trust model. The issue is not merely about failpoints (which may not be compiled in production), but about the **circular trust dependency** where security controls can be disabled by the very data they're meant to validate.

The absence of any signature verification or integrity checking on configuration files means that filesystem access alone is sufficient to completely compromise validator security posture. This violates defense-in-depth principles and creates a single point of failure at the filesystem level.

### Citations

**File:** config/src/config/persistable_config.rs (L14-20)
```rust
    fn load_config<P: AsRef<Path>>(path: P) -> Result<Self, Error> {
        // Read the file into a string
        let file_contents = Self::read_config_file(&path)?;

        // Parse the file string
        Self::parse_serialized_config(&file_contents)
    }
```

**File:** aptos-node/src/lib.rs (L177-183)
```rust
            let config = NodeConfig::load_from_path(config_path.clone()).unwrap_or_else(|error| {
                panic!(
                    "Failed to load the node config file! Given file path: {:?}. Error: {:?}",
                    config_path.display(),
                    error
                )
            });
```

**File:** aptos-node/src/lib.rs (L256-273)
```rust
    // Ensure failpoints are configured correctly
    if fail::has_failpoints() {
        warn!("Failpoints are enabled!");

        // Set all of the failpoints
        if let Some(failpoints) = &config.failpoints {
            for (point, actions) in failpoints {
                fail::cfg(point, actions).unwrap_or_else(|_| {
                    panic!(
                        "Failed to set actions for failpoint! Failpoint: {:?}, Actions: {:?}",
                        point, actions
                    )
                });
            }
        }
    } else if config.failpoints.is_some() {
        warn!("Failpoints is set in the node config, but the binary didn't compile with this feature!");
    }
```

**File:** config/src/config/node_config_loader.rs (L72-90)
```rust
    pub fn load_and_sanitize_config(&self) -> Result<NodeConfig, Error> {
        // Load the node config from disk
        let mut node_config = NodeConfig::load_config(&self.node_config_path)?;

        // Load the execution config
        let input_dir = RootPath::new(&self.node_config_path);
        node_config.execution.load_from_path(&input_dir)?;

        // Update the data directory. This needs to be done before
        // we optimize and sanitize the node configs (because some optimizers
        // rely on the data directory for file reading/writing).
        node_config.set_data_dir(node_config.get_data_dir().to_path_buf());

        // Optimize and sanitize the node config
        let local_config_yaml = get_local_config_yaml(&self.node_config_path)?;
        optimize_and_sanitize_node_config(&mut node_config, local_config_yaml)?;

        Ok(node_config)
    }
```

**File:** config/src/config/config_sanitizer.rs (L44-48)
```rust
    ) -> Result<(), Error> {
        // If config sanitization is disabled, don't do anything!
        if node_config.node_startup.skip_config_sanitizer {
            return Ok(());
        }
```

**File:** config/src/config/node_startup_config.rs (L6-21)
```rust
#[derive(Clone, Copy, Debug, Deserialize, PartialEq, Eq, Serialize)]
#[serde(default, deny_unknown_fields)]
pub struct NodeStartupConfig {
    pub skip_config_optimizer: bool, // Whether or not to skip the config optimizer at startup
    pub skip_config_sanitizer: bool, // Whether or not to skip the config sanitizer at startup
}

#[allow(clippy::derivable_impls)] // Derive default manually (this is safer than guessing defaults)
impl Default for NodeStartupConfig {
    fn default() -> Self {
        Self {
            skip_config_optimizer: false,
            skip_config_sanitizer: false,
        }
    }
}
```

**File:** config/src/config/execution_config.rs (L100-140)
```rust
    pub fn load_from_path(&mut self, root_dir: &RootPath) -> Result<(), Error> {
        if !self.genesis_file_location.as_os_str().is_empty() {
            // Ensure the genesis file exists
            let genesis_path = root_dir.full_path(&self.genesis_file_location);
            if !genesis_path.exists() {
                return Err(Error::Unexpected(format!(
                    "The genesis file could not be found! Ensure the given path is correct: {:?}",
                    genesis_path.display()
                )));
            }

            // Open the genesis file and read the bytes
            let mut file = File::open(&genesis_path).map_err(|error| {
                Error::Unexpected(format!(
                    "Failed to open the genesis file: {:?}. Error: {:?}",
                    genesis_path.display(),
                    error
                ))
            })?;
            let mut buffer = vec![];
            file.read_to_end(&mut buffer).map_err(|error| {
                Error::Unexpected(format!(
                    "Failed to read the genesis file into a buffer: {:?}. Error: {:?}",
                    genesis_path.display(),
                    error
                ))
            })?;

            // Deserialize the genesis file and store it
            let genesis = bcs::from_bytes(&buffer).map_err(|error| {
                Error::Unexpected(format!(
                    "Failed to BCS deserialize the genesis file: {:?}. Error: {:?}",
                    genesis_path.display(),
                    error
                ))
            })?;
            self.genesis = Some(genesis);
        }

        Ok(())
    }
```
