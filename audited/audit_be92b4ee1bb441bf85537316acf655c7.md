# Audit Report

## Title
Invalid Range Validation Bypass in AdvertisedData::contains_range Allows State Sync Resource Exhaustion

## Summary
The `AdvertisedData::contains_range()` function in `global_summary.rs` fails to validate that `lowest <= highest`, allowing streams with inverted version ranges to incorrectly pass data availability checks. This enables resource exhaustion attacks where invalid streams consume slots and cause repeated timeouts, degrading state synchronization performance.

## Finding Description

The `CompleteDataRange<T>` type correctly validates ranges during construction [1](#0-0) , ensuring that `lowest <= highest`. However, the `AdvertisedData::contains_range()` helper function accepts raw `lowest` and `highest` parameters without validation [2](#0-1) .

When `lowest > highest`, the Rust range expression `lowest..=highest` creates an empty range. The validation loop never executes, causing the function to incorrectly return `true`, indicating that data is available when it should return `false`.

**Attack Path:**

1. Attacker creates a stream request with inverted ranges (e.g., `GetAllTransactionsRequest { start_version: 100, end_version: 50 }`)

2. `TransactionStreamEngine::new()` accepts the request without validation [3](#0-2) 

3. `ensure_data_is_available()` calls `is_remaining_data_available()` which invokes `AdvertisedData::contains_range(100, 50, ...)` [4](#0-3) 

4. The function incorrectly returns `true`, allowing the stream to pass validation [5](#0-4) 

5. When `create_data_client_request_batch()` is called with the inverted range, it correctly detects the issue and returns an empty vector [6](#0-5) 

6. No data notifications are ever produced, causing the stream to repeatedly timeout until hitting the critical timeout threshold [7](#0-6) 

## Impact Explanation

This vulnerability enables **Medium severity** resource exhaustion attacks:

- **State Sync Degradation**: Multiple invalid streams can exhaust available stream slots, preventing legitimate synchronization
- **Timeout Cascades**: Each invalid stream causes `max_stream_wait_time_ms Ã— max_num_stream_timeouts` delay before cleanup
- **Node Performance Impact**: Repeated timeout handling wastes CPU cycles and delays blockchain state synchronization
- **Availability Risk**: During coordinated attacks, nodes may fail to sync, affecting network participation

While the timeout mechanism eventually cleans up invalid streams, the window of vulnerability allows attackers to create persistent degradation by continuously spawning new invalid streams. This fits the **Medium** category: "State inconsistencies requiring intervention" as administrators may need to investigate and mitigate repeated state sync failures.

## Likelihood Explanation

**High Likelihood** - The attack is straightforward:

- **Low Complexity**: Simply construct a stream request with `start_version > end_version`
- **No Special Privileges**: Any network peer can send stream requests
- **Undetected**: The validation bypass allows invalid requests to pass through
- **Reproducible**: The bug is deterministic and always triggers with inverted ranges

The only barrier is network participation (running a node), but this is a low threshold for motivated attackers.

## Recommendation

Add range validation to `AdvertisedData::contains_range()`:

```rust
pub fn contains_range(
    lowest: u64,
    highest: u64,
    advertised_ranges: &[CompleteDataRange<u64>],
) -> bool {
    // Reject invalid ranges
    if lowest > highest {
        return false;
    }
    
    for item in lowest..=highest {
        let mut item_exists = false;
        
        for advertised_range in advertised_ranges {
            if advertised_range.contains(item) {
                item_exists = true;
                break;
            }
        }
        
        if !item_exists {
            return false;
        }
    }
    true
}
```

Additionally, add validation in stream engine constructors:

```rust
fn new(stream_request: &StreamRequest) -> Result<Self, Error> {
    match stream_request {
        StreamRequest::GetAllTransactions(request) => {
            if request.start_version > request.end_version {
                return Err(Error::InvalidStreamRequest(
                    "start_version must be <= end_version".into()
                ));
            }
            Ok(TransactionStreamEngine { ... })
        },
        // ... similar for other variants
    }
}
```

## Proof of Concept

```rust
#[test]
fn test_invalid_range_bypass() {
    use aptos_storage_service_types::responses::CompleteDataRange;
    use state_sync::aptos_data_client::global_summary::AdvertisedData;
    
    // Create advertised data with valid range [0, 100]
    let advertised_ranges = vec![
        CompleteDataRange::new(0, 100).unwrap()
    ];
    
    // Test 1: Valid range should return true
    assert!(AdvertisedData::contains_range(10, 20, &advertised_ranges));
    
    // Test 2: Invalid range (highest < lowest) incorrectly returns true
    // This should return false but currently returns true due to the bug
    let result = AdvertisedData::contains_range(100, 50, &advertised_ranges);
    assert_eq!(result, true); // BUG: Should be false!
    
    // Test 3: Create a stream with invalid range
    let invalid_request = GetAllTransactionsRequest {
        start_version: 100,
        end_version: 50,  // Invalid: end < start
        proof_version: 100,
        include_events: false,
    };
    
    // The stream engine accepts this without validation
    let stream_engine = TransactionStreamEngine::new(
        &StreamRequest::GetAllTransactions(invalid_request)
    );
    assert!(stream_engine.is_ok()); // BUG: Should reject invalid range!
    
    // The stream passes data availability check incorrectly
    let advertised_data = create_advertised_data();
    let is_available = stream_engine.unwrap()
        .is_remaining_data_available(&advertised_data)
        .unwrap();
    assert_eq!(is_available, true); // BUG: Should be false!
}
```

### Citations

**File:** state-sync/storage-service/types/src/responses.rs (L962-968)
```rust
    pub fn new(lowest: T, highest: T) -> crate::Result<Self, Error> {
        if lowest > highest || range_length_checked(lowest, highest).is_err() {
            Err(DegenerateRangeError)
        } else {
            Ok(Self { lowest, highest })
        }
    }
```

**File:** state-sync/aptos-data-client/src/global_summary.rs (L153-173)
```rust
    pub fn contains_range(
        lowest: u64,
        highest: u64,
        advertised_ranges: &[CompleteDataRange<u64>],
    ) -> bool {
        for item in lowest..=highest {
            let mut item_exists = false;

            for advertised_range in advertised_ranges {
                if advertised_range.contains(item) {
                    item_exists = true;
                    break;
                }
            }

            if !item_exists {
                return false;
            }
        }
        true
    }
```

**File:** state-sync/data-streaming-service/src/stream_engine.rs (L1668-1690)
```rust
    fn new(stream_request: &StreamRequest) -> Result<Self, Error> {
        match stream_request {
            StreamRequest::GetAllTransactions(request) => Ok(TransactionStreamEngine {
                request: stream_request.clone(),
                next_stream_version: request.start_version,
                next_request_version: request.start_version,
                stream_is_complete: false,
            }),
            StreamRequest::GetAllTransactionOutputs(request) => Ok(TransactionStreamEngine {
                request: stream_request.clone(),
                next_stream_version: request.start_version,
                next_request_version: request.start_version,
                stream_is_complete: false,
            }),
            StreamRequest::GetAllTransactionsOrOutputs(request) => Ok(TransactionStreamEngine {
                request: stream_request.clone(),
                next_stream_version: request.start_version,
                next_request_version: request.start_version,
                stream_is_complete: false,
            }),
            request => invalid_stream_request!(request),
        }
    }
```

**File:** state-sync/data-streaming-service/src/stream_engine.rs (L1862-1866)
```rust
        Ok(AdvertisedData::contains_range(
            self.next_stream_version,
            request_end_version,
            advertised_ranges,
        ))
```

**File:** state-sync/data-streaming-service/src/stream_engine.rs (L2056-2058)
```rust
    if start_index > end_index {
        return Ok(vec![]);
    }
```

**File:** state-sync/data-streaming-service/src/data_stream.rs (L866-877)
```rust
    pub fn ensure_data_is_available(&self, advertised_data: &AdvertisedData) -> Result<(), Error> {
        if !self
            .stream_engine
            .is_remaining_data_available(advertised_data)?
        {
            return Err(Error::DataIsUnavailable(format!(
                "Unable to satisfy stream engine: {:?}, with advertised data: {:?}",
                self.stream_engine, advertised_data
            )));
        }
        Ok(())
    }
```

**File:** state-sync/state-sync-driver/src/utils.rs (L226-230)
```rust
        if active_data_stream.num_consecutive_timeouts >= max_num_stream_timeouts {
            Err(Error::CriticalDataStreamTimeout(format!(
                "{:?}",
                max_num_stream_timeouts
            )))
```
