# Audit Report

## Title
Unknown Peer Connection Slot Exhaustion DoS on Public Network

## Summary
Public fullnodes enforce a global limit of 100 unknown inbound peer connections without per-IP restrictions or priority-based eviction. An attacker can exhaust all available slots by establishing 100 malicious connections, permanently blocking legitimate downstream clients (wallets, light clients, block explorers) from connecting and receiving state updates.

## Finding Description

The vulnerability exists in the peer connection management system for public network nodes. The attack path is as follows:

1. **Permissive Authentication**: Public network nodes operate in `MaybeMutual` authentication mode, where any peer not in the trusted peers list is assigned `PeerRole::Unknown` and allowed to connect. [1](#0-0) 

2. **Global Connection Limit**: The `PeerManager` enforces a hard limit of 100 unknown inbound connections (`MAX_INBOUND_CONNECTIONS`). [2](#0-1) 

3. **No Per-IP Limiting**: The connection counting logic only considers `PeerRole` and `ConnectionOrigin`, not source IP addresses. An attacker can use multiple IPs to establish connections up to the global limit. [3](#0-2) 

4. **Rejection Without Eviction**: When the limit is reached, ALL new unknown inbound connections are rejected, regardless of legitimacy or priority. There is no mechanism to evict low-priority malicious connections in favor of higher-priority legitimate clients. [4](#0-3) 

5. **Acknowledged Design Weakness**: The code contains a TODO comment acknowledging the DDoS vulnerability: "TODO: Keep track of somewhere else to not take this hit in case of DDoS". [5](#0-4) 

6. **Ineffective Infrastructure Protection**: HAProxy configurations provide bandwidth limits per IP but not connection count limits per IP, and are optional deployment components. [6](#0-5) 

**Attack Execution**:
- Attacker establishes 100 inbound connections from different IP addresses (or same IP if no HAProxy)
- Each connection successfully completes Noise handshake and is assigned `PeerRole::Unknown`
- All 100 unknown connection slots are now occupied by attacker-controlled peers
- Legitimate downstream clients attempt to connect but are also classified as `Unknown` (not in trusted peers)
- Legitimate clients are immediately rejected due to the connection limit being reached
- Attacker maintains connections indefinitely, sustaining the denial of service

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos bug bounty program criteria:

1. **Validator Node Slowdowns**: While the primary impact is on fullnodes, validator fullnodes (VFNs) on the public network are also affected, potentially impacting validator performance.

2. **Significant Protocol Violations**: The attack violates the fundamental availability guarantee that legitimate clients should be able to access blockchain data and submit transactions.

3. **Ecosystem-Wide Impact**: Public fullnodes serve as the primary interface for:
   - Wallet applications submitting transactions
   - Block explorers querying blockchain state
   - Light clients syncing blockchain data
   - DApp backends accessing on-chain information
   
   All these services become unavailable when connection slots are exhausted.

The issue does NOT reach Critical severity because:
- No funds are directly at risk
- Consensus safety is not compromised
- The network can recover by restarting nodes or implementing IP bans
- Validators can continue operating on their private networks

## Likelihood Explanation

**Likelihood: HIGH**

The attack is highly feasible because:

1. **Low Resource Requirements**: Only 100 connections needed, each requiring minimal bandwidth to maintain
2. **No Authentication Barrier**: Public network explicitly accepts unknown peers
3. **Simple Execution**: Standard TCP connection establishment, no complex protocol manipulation required
4. **Sustained Attack**: Connections can be held indefinitely with periodic keep-alive messages
5. **Cost-Effective**: Can use cloud providers with 100 different IP addresses at low cost
6. **No Detection Mechanism**: No built-in anomaly detection or automatic IP banning at the P2P protocol layer

The attack is NOT prevented by:
- HAProxy limits (optional deployment, no per-IP connection limits)
- Bandwidth throttling (attacker needs minimal bandwidth)
- Connection rate limits (can connect slowly over time)

## Recommendation

Implement a multi-layered defense strategy:

**1. Per-IP Connection Limiting** (Primary Fix):
Add per-IP connection tracking in `PeerManager::handle_new_connection_event()`:

```rust
// Track connections per source IP
let connections_per_ip: HashMap<IpAddr, usize> = /* ... */;
const MAX_UNKNOWN_CONNECTIONS_PER_IP: usize = 2;

if let Some(ip_addr) = conn.metadata.addr.find_ip_addr() {
    let ip_conn_count = connections_per_ip.get(&ip_addr).unwrap_or(&0);
    if *ip_conn_count >= MAX_UNKNOWN_CONNECTIONS_PER_IP {
        // Reject connection from this IP
        counters::connections_rejected_per_ip(&self.network_context).inc();
        self.disconnect(conn);
        return;
    }
}
```

**2. Priority-Based Eviction** (Secondary Defense):
Implement a mechanism to evict idle or low-priority unknown connections when legitimate clients need slots:

```rust
fn evict_lowest_priority_unknown_peer(&mut self) -> Option<PeerId> {
    // Find unknown peer with longest idle time or lowest data transfer
    // Disconnect and return PeerId
}
```

**3. Connection Quality Metrics**:
Track per-peer metrics (data transferred, request frequency, uptime) and preferentially evict peers with suspicious patterns.

**4. Configurable Trusted Peer Expansion**:
Allow operators to dynamically add downstream clients to trusted peers list with `PeerRole::Downstream` to bypass unknown peer limits.

**5. Monitoring and Alerting**:
Add metrics for unknown connection slot utilization and alert when threshold exceeded.

## Proof of Concept

```rust
// File: network/framework/src/peer_manager/tests.rs

#[tokio::test]
async fn test_unknown_peer_dos_attack() {
    use std::net::{IpAddr, Ipv4Addr};
    
    // Setup: Create a public network PeerManager with default config
    let (mut peer_manager, _) = setup_peer_manager(
        NetworkId::Public,
        MAX_INBOUND_CONNECTIONS, // 100
    ).await;
    
    // Attack: Establish 100 unknown peer connections
    let mut attacker_connections = vec![];
    for i in 0..100 {
        let attacker_peer_id = PeerId::random();
        let attacker_addr = NetworkAddress::from_str(&format!(
            "/ip4/192.168.1.{}/tcp/6180",
            i + 1
        )).unwrap();
        
        // Create inbound connection with Unknown role
        let conn_metadata = ConnectionMetadata {
            remote_peer_id: attacker_peer_id,
            connection_id: ConnectionId::from(i),
            addr: attacker_addr,
            origin: ConnectionOrigin::Inbound,
            messaging_protocol: MessagingProtocolVersion::V1,
            application_protocols: ProtocolIdSet::empty(),
            role: PeerRole::Unknown, // Assigned during handshake
        };
        
        let (conn, _) = build_test_connection(conn_metadata);
        
        // Send connection to PeerManager
        peer_manager.handle_new_connection_event(conn);
        attacker_connections.push(attacker_peer_id);
    }
    
    // Verify: All 100 slots occupied
    assert_eq!(peer_manager.active_peers.len(), 100);
    
    // Attack Impact: Legitimate client connection attempt
    let legitimate_peer_id = PeerId::random();
    let legitimate_addr = NetworkAddress::from_str(
        "/ip4/10.0.0.1/tcp/6180"
    ).unwrap();
    
    let legitimate_conn_metadata = ConnectionMetadata {
        remote_peer_id: legitimate_peer_id,
        connection_id: ConnectionId::from(100),
        addr: legitimate_addr,
        origin: ConnectionOrigin::Inbound,
        messaging_protocol: MessagingProtocolVersion::V1,
        application_protocols: ProtocolIdSet::empty(),
        role: PeerRole::Unknown, // Also unknown - not in trusted peers
    };
    
    let (legitimate_conn, _) = build_test_connection(legitimate_conn_metadata);
    
    // This connection should be REJECTED
    peer_manager.handle_new_connection_event(legitimate_conn);
    
    // Verify: Legitimate client was rejected (still only 100 connections)
    assert_eq!(peer_manager.active_peers.len(), 100);
    assert!(!peer_manager.active_peers.contains_key(&legitimate_peer_id));
    
    // Verify: Rejection metric incremented
    let rejection_count = counters::connections_rejected(
        &peer_manager.network_context,
        ConnectionOrigin::Inbound
    ).get();
    assert_eq!(rejection_count, 1);
}
```

## Notes

1. **Scope Clarification**: While the security question mentions `downstream_roles()`, this function is defined but never actually used in the codebase. The vulnerability exists in the connection acceptance logic regardless of this function. [7](#0-6) 

2. **Network Type Specificity**: This vulnerability specifically affects the `Public` network type. The `Validator` network uses `Mutual` authentication and rejects unknown peers entirely. The `Vfn` network has more restricted acceptance policies. [8](#0-7) 

3. **Existing Protections Are Insufficient**: HAProxy provides bandwidth throttling but not connection count limiting per IP, and is an optional deployment component not enforced at the protocol layer. [9](#0-8) 

4. **Real-World Impact**: This attack has practical implications for public fullnode operators who serve ecosystem applications. A successful attack would render wallets, explorers, and DApps unable to interact with the blockchain through affected nodes.

### Citations

**File:** network/framework/src/noise/handshake.rs (L369-383)
```rust
            HandshakeAuthMode::Mutual {
                peers_and_metadata, ..
            } => {
                let trusted_peers = peers_and_metadata.get_trusted_peers(&network_id)?;
                let trusted_peer = trusted_peers.get(&remote_peer_id).cloned();
                match trusted_peer {
                    Some(peer) => {
                        Self::authenticate_inbound(remote_peer_short, &peer, &remote_public_key)
                    },
                    None => Err(NoiseHandshakeError::UnauthenticatedClient(
                        remote_peer_short,
                        remote_peer_id,
                    )),
                }
            },
```

**File:** network/framework/src/noise/handshake.rs (L384-426)
```rust
            HandshakeAuthMode::MaybeMutual(peers_and_metadata) => {
                let trusted_peers = peers_and_metadata.get_trusted_peers(&network_id)?;
                let trusted_peer = trusted_peers.get(&remote_peer_id).cloned();
                match trusted_peer {
                    Some(peer) => {
                        Self::authenticate_inbound(remote_peer_short, &peer, &remote_public_key)
                    },
                    None => {
                        // The peer is not in the trusted peer set. Verify that the Peer ID is
                        // constructed correctly from the public key.
                        let derived_remote_peer_id =
                            aptos_types::account_address::from_identity_public_key(
                                remote_public_key,
                            );
                        if derived_remote_peer_id != remote_peer_id {
                            // The peer ID is not constructed correctly from the public key
                            Err(NoiseHandshakeError::ClientPeerIdMismatch(
                                remote_peer_short,
                                remote_peer_id,
                                derived_remote_peer_id,
                            ))
                        } else {
                            // Try to infer the role from the network context
                            if self.network_context.role().is_validator() {
                                if network_id.is_vfn_network() {
                                    // Inbound connections to validators on the VFN network must be VFNs
                                    Ok(PeerRole::ValidatorFullNode)
                                } else {
                                    // Otherwise, they're unknown. Validators will connect through
                                    // authenticated channels (on the validator network) so shouldn't hit
                                    // this, and PFNs will connect on public networks (which aren't common).
                                    Ok(PeerRole::Unknown)
                                }
                            } else {
                                // We're a VFN or PFN. VFNs get no inbound connections on the vfn network
                                // (so the peer won't be a validator). Thus, we're on the public network
                                // so mark the peer as unknown.
                                Ok(PeerRole::Unknown)
                            }
                        }
                    },
                }
            },
```

**File:** config/src/config/network_config.rs (L44-44)
```rust
pub const MAX_INBOUND_CONNECTIONS: usize = 100;
```

**File:** network/framework/src/peer_manager/mod.rs (L356-356)
```rust
                // TODO: Keep track of somewhere else to not take this hit in case of DDoS
```

**File:** network/framework/src/peer_manager/mod.rs (L358-367)
```rust
                let unknown_inbound_conns = self
                    .active_peers
                    .iter()
                    .filter(|(peer_id, (metadata, _))| {
                        metadata.origin == ConnectionOrigin::Inbound
                            && trusted_peers
                                .get(peer_id)
                                .is_none_or(|peer| peer.role == PeerRole::Unknown)
                    })
                    .count();
```

**File:** network/framework/src/peer_manager/mod.rs (L372-388)
```rust
                if !self
                    .active_peers
                    .contains_key(&conn.metadata.remote_peer_id)
                    && unknown_inbound_conns + 1 > self.inbound_connection_limit
                {
                    info!(
                        NetworkSchema::new(&self.network_context)
                            .connection_metadata_with_address(&conn.metadata),
                        "{} Connection rejected due to connection limit: {}",
                        self.network_context,
                        conn.metadata
                    );
                    counters::connections_rejected(&self.network_context, conn.metadata.origin)
                        .inc();
                    self.disconnect(conn);
                    return;
                }
```

**File:** docker/compose/aptos-node/haproxy.cfg (L8-12)
```text
    # Limit the maximum number of connections to 500 (this is ~5x the validator set size)
    maxconn 500

    # Limit the maximum number of connections per second to 300 (this is ~3x the validator set size)
    maxconnrate 300
```

**File:** config/src/network_id.rs (L189-204)
```rust
    pub fn downstream_roles(&self, role: &RoleType) -> &'static [PeerRole] {
        match self {
            NetworkId::Validator => &[PeerRole::Validator],
            // In order to allow fallbacks, we must allow for nodes to accept ValidatorFullNodes
            NetworkId::Public => &[
                PeerRole::ValidatorFullNode,
                PeerRole::Downstream,
                PeerRole::Known,
                PeerRole::Unknown,
            ],
            NetworkId::Vfn => match role {
                RoleType::Validator => &[PeerRole::ValidatorFullNode],
                RoleType::FullNode => &[],
            },
        }
    }
```

**File:** docker/compose/aptos-node/haproxy-fullnode.cfg (L38-57)
```text
## Specify the public network frontend
frontend fullnode-fn
    mode tcp
    bind :6182
    default_backend fullnode

    # Deny requests from blocked IPs
    tcp-request connection reject if { src -n -f /usr/local/etc/haproxy/blocked.ips }

    # Create TCP request bandwidth limits of 25 MB/s (per TCP stream)
    filter bwlim-in incoming-limit default-limit 25m default-period 1s
    filter bwlim-out outgoing-limit default-limit 25m default-period 1s
    tcp-request content set-bandwidth-limit incoming-limit
    tcp-request content set-bandwidth-limit outgoing-limit

    # Create TCP request bandwidth limits of 50 MB/s (per source IP)
    filter bwlim-in incoming-src-limit key src table limit-by-src limit 50m
    filter bwlim-out outgoing-src-limit key src table limit-by-src limit 50m
    tcp-request content set-bandwidth-limit incoming-src-limit
    tcp-request content set-bandwidth-limit outgoing-src-limit
```
