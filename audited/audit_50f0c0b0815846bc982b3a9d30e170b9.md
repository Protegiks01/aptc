# Audit Report

## Title
Indexer Denial of Service via Panic on Missing Table Metadata in Token Claims Deletion

## Summary
The `CurrentTokenPendingClaim::from_delete_table_item()` function contains a critical design flaw where it panics when table handle metadata is missing from the per-batch mapping, causing the entire indexer process to crash. This differs from other similar functions in the codebase that handle the same scenario gracefully with warning logs.

## Finding Description

The indexer builds a `table_handle_to_owner` mapping per transaction batch by scanning only `WriteResource` changes: [1](#0-0) 

When processing token claim deletions, the `from_delete_table_item()` function uses `unwrap_or_else` with `panic!` if the table handle is not found in this mapping: [2](#0-1) 

However, the same file's `from_write_table_item()` function handles the identical missing metadata case gracefully by logging a warning and continuing: [3](#0-2) 

This inconsistency creates a vulnerability. Similarly, `TokenOwnership::from_token()` demonstrates the correct defensive pattern: [4](#0-3) 

**Attack Scenario**: Since the mapping is constructed per-batch and only from WriteResource changes, if a `DeleteTableItem` event references a table handle from a previous batch and no `WriteResource` for that table owner appears in the current batch, the mapping will be incomplete, triggering the panic.

While Move semantics normally ensure resource writes accompany table modifications, edge cases in VM write set generation, state corruption, or transaction batching could create this condition. The indexer must handle all possible blockchain states defensively.

When the indexer panics, the crash handler terminates the process: [5](#0-4) 

## Impact Explanation

**Severity: High** per Aptos bug bounty category "API crashes"

The indexer is a critical infrastructure component that:
- Provides queryable blockchain data to wallets, explorers, and dApps
- Cannot be bypassed (users depend on indexed data for transaction history and token ownership)
- Requires manual intervention to restart after crash
- Leaves a gap in indexed data during downtime

While this does not affect consensus or validator operations (the indexer runs separately), it breaks the **availability** invariant for blockchain data services. An attacker could repeatedly trigger this panic to cause sustained indexer unavailability, degrading user experience and breaking applications that depend on indexed token data.

The panic occurs during transaction processing in the token processor: [6](#0-5) 

## Likelihood Explanation

**Likelihood: Medium**

The vulnerability requires specific conditions:
1. A `DeleteTableItem` for a pending claim must be processed
2. The corresponding table owner's resource must not have a `WriteResource` in the same batch
3. The table handle was created in a previous batch

While Move semantics normally prevent condition #2, the defensive programming principle requires handling unexpected states. The fact that other similar functions in the codebase handle this case gracefully indicates the developers anticipated this possibility.

The per-batch mapping construction is explicitly designed to handle cross-transaction metadata dependencies, as evidenced by the comment: [7](#0-6) 

## Recommendation

Replace the `unwrap_or_else` with `panic!` with the same graceful handling pattern used in `from_write_table_item()` and `TokenOwnership::from_token()`:

```rust
pub fn from_delete_table_item(
    table_item: &APIDeleteTableItem,
    txn_version: i64,
    txn_timestamp: chrono::NaiveDateTime,
    table_handle_to_owner: &TableHandleToOwner,
) -> anyhow::Result<Option<Self>> {
    let table_item_data = table_item.data.as_ref().unwrap();
    
    let maybe_offer = match TokenWriteSet::from_table_item_type(
        table_item_data.key_type.as_str(),
        &table_item_data.key,
        txn_version,
    )? {
        Some(TokenWriteSet::TokenOfferId(inner)) => Some(inner),
        _ => None,
    };
    
    if let Some(offer) = maybe_offer {
        let table_handle = standardize_address(&table_item.handle.to_string());
        
        // FIXED: Graceful handling instead of panic
        let maybe_table_metadata = table_handle_to_owner.get(&table_handle);
        
        if let Some(table_metadata) = maybe_table_metadata {
            let token_id = offer.token_id;
            let token_data_id_struct = token_id.token_data_id;
            let collection_data_id_hash = token_data_id_struct.get_collection_data_id_hash();
            let token_data_id_hash = token_data_id_struct.to_hash();
            let collection_id = token_data_id_struct.get_collection_id();
            let token_data_id = token_data_id_struct.to_id();
            let collection_name = token_data_id_struct.get_collection_trunc();
            let name = token_data_id_struct.get_name_trunc();
            
            return Ok(Some(Self {
                token_data_id_hash,
                property_version: token_id.property_version,
                from_address: standardize_address(&table_metadata.owner_address),
                to_address: standardize_address(&offer.to_addr),
                collection_data_id_hash,
                creator_address: standardize_address(&token_data_id_struct.creator),
                collection_name,
                name,
                amount: BigDecimal::zero(),
                table_handle,
                last_transaction_version: txn_version,
                last_transaction_timestamp: txn_timestamp,
                token_data_id,
                collection_id,
            }));
        } else {
            aptos_logger::warn!(
                transaction_version = txn_version,
                table_handle = table_handle,
                "Missing table handle metadata for PendingClaim deletion. {:?}",
                table_handle_to_owner
            );
        }
    }
    Ok(None)
}
```

This change aligns the error handling with the established pattern in the codebase and prevents indexer crashes from unexpected blockchain states.

## Proof of Concept

**Reproduction Steps**:

1. Deploy the Token V1 framework with PendingClaims functionality
2. Create a token offer from Account A to Account B (creates PendingClaims resource at A with table handle)
3. Process this in Batch N - the indexer builds a mapping including the table handle
4. In Batch N+1, trigger a claim/cancel operation that generates a DeleteTableItem
5. Ensure no WriteResource for Account A's PendingClaims appears in Batch N+1 (this may require specific transaction batching or edge case conditions)
6. The indexer processes Batch N+1:
   - Builds `table_handle_to_owner` from WriteResource changes only
   - Table handle from Batch N is not in this mapping
   - Encounters DeleteTableItem for the claim
   - Calls `from_delete_table_item()` which attempts to get metadata
   - Panics at line 135, crashing the indexer process

**Expected behavior**: Indexer logs a warning and continues processing
**Actual behavior**: Indexer panics and exits, requiring manual restart

The crash can be observed in system logs showing the panic message with the missing table handle information, followed by process termination via the crash handler.

---

**Notes**

This vulnerability demonstrates a violation of the **defensive programming** principle - the indexer should never panic on user-generated blockchain data. The inconsistency between `from_write_table_item()` (graceful) and `from_delete_table_item()` (panic) in the same file is a code smell indicating this was an oversight rather than intentional design. The per-batch mapping construction acknowledges that metadata might be missing across transactions, yet the delete path fails to handle this scenario properly.

### Citations

**File:** crates/indexer/src/models/token_models/tokens.rs (L358-369)
```rust
                for wsc in &user_txn.info.changes {
                    if let APIWriteSetChange::WriteResource(write_resource) = wsc {
                        let maybe_map = TableMetadataForToken::get_table_handle_to_owner(
                            write_resource,
                            txn_version,
                        )
                        .unwrap();
                        if let Some(map) = maybe_map {
                            table_handle_to_owner.extend(map);
                        }
                    }
                }
```

**File:** crates/indexer/src/models/token_models/token_claims.rs (L96-103)
```rust
                } else {
                    aptos_logger::warn!(
                        transaction_version = txn_version,
                        table_handle = table_handle,
                        "Missing table handle metadata for TokenClaim. {:?}",
                        table_handle_to_owner
                    );
                }
```

**File:** crates/indexer/src/models/token_models/token_claims.rs (L135-141)
```rust
            let table_metadata = table_handle_to_owner.get(&table_handle).unwrap_or_else(|| {
                panic!(
                    "Missing table handle metadata for claim. \
                    Version: {}, table handle for PendingClaims: {}, all metadata: {:?}",
                    txn_version, table_handle, table_handle_to_owner
                )
            });
```

**File:** crates/indexer/src/models/token_models/token_ownerships.rs (L114-122)
```rust
            None => {
                aptos_logger::warn!(
                    transaction_version = txn_version,
                    table_handle = table_handle,
                    "Missing table handle metadata for TokenStore. {:?}",
                    table_handle_to_owner
                );
                (None, None, None)
            },
```

**File:** crates/crash-handler/src/lib.rs (L23-40)
```rust
/// Tokio's default behavior is to catch panics and ignore them.  Invoking this function will
/// ensure that all subsequent thread panics (even Tokio threads) will report the
/// details/backtrace and then exit.
pub fn setup_panic_handler() {
    panic::set_hook(Box::new(move |pi: &PanicHookInfo<'_>| {
        handle_panic(pi);
    }));
}

// Formats and logs panic information
fn handle_panic(panic_info: &PanicHookInfo<'_>) {
    // The Display formatter for a PanicHookInfo contains the message, payload and location.
    let details = format!("{}", panic_info);
    let backtrace = format!("{:#?}", Backtrace::new());

    let info = CrashInfo { details, backtrace };
    let crash_info = toml::to_string_pretty(&info).unwrap();
    error!("{}", crash_info);
```

**File:** crates/indexer/src/processors/token_processor.rs (L156-163)
```rust
    basic_token_transaction_lists: (
        Vec<Token>,
        Vec<TokenOwnership>,
        Vec<TokenData>,
        Vec<CollectionData>,
    ),
    basic_token_current_lists: (
        Vec<CurrentTokenOwnership>,
```

**File:** crates/indexer/src/processors/token_processor.rs (L860-862)
```rust
        // First get all token related table metadata from the batch of transactions. This is in case
        // an earlier transaction has metadata (in resources) that's missing from a later transaction.
        let table_handle_to_owner =
```
