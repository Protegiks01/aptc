# Audit Report

## Title
Faucet CLI Lacks Validation Against Reserved System Addresses Enabling State Pollution and Resource Exhaustion

## Summary
The `process_account_address()` function in the Aptos faucet CLI does not validate whether parsed addresses are reserved system addresses (0x0, 0x1, 0x2-0xa). This allows users to request faucet funds be sent to governance-controlled addresses, enabling testnet faucet resource exhaustion and creation of unwanted state associated with critical system addresses.

## Finding Description
The faucet CLI's address parsing function accepts any valid address format without checking if it corresponds to a reserved system address that should not receive arbitrary faucet funds. [1](#0-0) 

The function simply parses the address string and returns it, or panics if invalid. There is no validation against system addresses defined in the framework. [2](#0-1) 

Framework reserved addresses (0x1-0xa) are created during genesis and placed under governance control: [3](#0-2) 

When the faucet attempts to mint to these addresses, the `aptos_coin::mint` function has no address validation: [4](#0-3) 

The deposit flow through `primary_fungible_store::deposit` and `create_primary_store` also lacks system address validation: [5](#0-4) 

While `create_account_if_does_not_exist` prevents account creation at @vm_reserved, @aptos_framework, and @aptos_token: [6](#0-5) 

This check does NOT apply to primary fungible store creation, which uses derived object addresses and does not require account creation at the system address itself.

## Impact Explanation
This qualifies as **Medium severity** under "Limited funds loss or manipulation" and "State inconsistencies requiring intervention":

1. **Testnet Resource Exhaustion**: Attackers can repeatedly request faucet funds to system addresses, draining the faucet account and denying service to legitimate testnet users
2. **State Pollution**: Primary stores are created for governance-controlled addresses (0x2-0xa), associating unexpected balances with critical system accounts
3. **Gas Waste**: For addresses like 0x0 and 0x1 where certain restrictions exist, the faucet wastes gas on transactions that may fail downstream
4. **Principle Violation**: System addresses under governance control should not be arbitrarily fundable via public faucets

## Likelihood Explanation
**HIGH** - This is trivially exploitable:
- No authentication required beyond normal faucet access
- Simple CLI invocation: `--accounts 0x1,0x2,0x3`
- No rate limiting specific to system addresses
- Works on all testnets/devnets where the faucet CLI is deployed

## Recommendation
Add validation in `process_account_address()` to reject reserved system addresses:

```rust
fn process_account_address(str: &str) -> AccountAddress {
    let str = str.trim();
    let address = if let Ok(address) = AccountAddress::from_str(str) {
        address
    } else {
        panic!("Account address is in an invalid format {}", str)
    };
    
    // Validate against reserved system addresses
    const RESERVED_ADDRESSES: [&str; 11] = [
        "0x0", "0x1", "0x2", "0x3", "0x4", "0x5", 
        "0x6", "0x7", "0x8", "0x9", "0xa"
    ];
    
    if RESERVED_ADDRESSES.iter().any(|&reserved| {
        address == AccountAddress::from_hex_literal(reserved).unwrap()
    }) {
        panic!("Cannot send faucet funds to reserved system address: {}", address);
    }
    
    address
}
```

Alternatively, use the system_addresses module validation functions if creating a Move-side check in the faucet service.

## Proof of Concept
```bash
# Compile the faucet CLI
cd aptos-core/crates/aptos-faucet/cli
cargo build

# Attempt to fund governance-controlled address 0x2
./target/debug/aptos-faucet-cli \
    --node-url http://localhost:8080 \
    --amount 100000000 \
    --accounts "0x2" \
    --key-file-path ./mint.key

# Expected: Transaction succeeds, creating primary store for 0x2
# Actual: Should be rejected with validation error
```

The transaction will succeed on-chain, demonstrating that system addresses can receive faucet funds despite being under governance control.

## Notes
While this vulnerability is limited to testnet environments where faucet funds have no economic value, it represents a security control gap that violates defense-in-depth principles. System addresses, particularly those under governance control (0x2-0xa), should have explicit protections against arbitrary funding to maintain clean separation between system operations and user operations.

### Citations

**File:** crates/aptos-faucet/cli/src/main.rs (L163-170)
```rust
fn process_account_address(str: &str) -> AccountAddress {
    let str = str.trim();
    if let Ok(address) = AccountAddress::from_str(str) {
        address
    } else {
        panic!("Account address is in an invalid format {}", str)
    }
}
```

**File:** aptos-move/framework/aptos-framework/sources/system_addresses.move (L44-56)
```text
    /// Return true if `addr` is 0x0 or under the on chain governance's control.
    public fun is_framework_reserved_address(addr: address): bool {
        is_aptos_framework_address(addr) ||
            addr == @0x2 ||
            addr == @0x3 ||
            addr == @0x4 ||
            addr == @0x5 ||
            addr == @0x6 ||
            addr == @0x7 ||
            addr == @0x8 ||
            addr == @0x9 ||
            addr == @0xa
    }
```

**File:** aptos-move/framework/aptos-framework/sources/genesis.move (L100-106)
```text
        // put reserved framework reserved accounts under aptos governance
        let framework_reserved_addresses = vector<address>[@0x2, @0x3, @0x4, @0x5, @0x6, @0x7, @0x8, @0x9, @0xa];
        while (!vector::is_empty(&framework_reserved_addresses)) {
            let address = vector::pop_back<address>(&mut framework_reserved_addresses);
            let (_, framework_signer_cap) = account::create_framework_reserved_account(address);
            aptos_governance::store_signer_cap(&aptos_framework_account, address, framework_signer_cap);
        };
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_coin.move (L93-108)
```text
    public entry fun mint(
        account: &signer,
        dst_addr: address,
        amount: u64,
    ) acquires MintCapStore {
        let account_addr = signer::address_of(account);

        assert!(
            exists<MintCapStore>(account_addr),
            error::not_found(ENO_CAPABILITIES),
        );

        let mint_cap = &borrow_global<MintCapStore>(account_addr).mint_cap;
        let coins_minted = coin::mint<AptosCoin>(amount, mint_cap);
        coin::deposit<AptosCoin>(dst_addr, coins_minted);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/primary_fungible_store.move (L74-88)
```text
    /// Create a primary store object to hold fungible asset for the given address.
    public fun create_primary_store<T: key>(
        owner_addr: address,
        metadata: Object<T>,
    ): Object<FungibleStore> acquires DeriveRefPod {
        let metadata_addr = metadata.object_address();
        object::address_to_object<Metadata>(metadata_addr);
        let derive_ref = &borrow_global<DeriveRefPod>(metadata_addr).metadata_derive_ref;
        let constructor_ref = &object::create_user_derived_object(owner_addr, derive_ref);
        // Disable ungated transfer as deterministic stores shouldn't be transferrable.
        let transfer_ref = &constructor_ref.generate_transfer_ref();
        transfer_ref.disable_ungated_transfer();

        fungible_asset::create_store(constructor_ref, metadata)
    }
```

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L276-284)
```text
    public fun create_account_if_does_not_exist(account_address: address) {
        if (!resource_exists_at(account_address)) {
            assert!(
                account_address != @vm_reserved && account_address != @aptos_framework && account_address != @aptos_token,
                error::invalid_argument(ECANNOT_RESERVED_ADDRESS)
            );
            create_account_unchecked(account_address);
        }
    }
```
