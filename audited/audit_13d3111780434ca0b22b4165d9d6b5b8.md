# Audit Report

## Title
Mempool Pollution via Reserved Address Sender Bypass in Sponsored Transaction Validation

## Summary
When the `SPONSORED_AUTOMATIC_ACCOUNT_V1_CREATION` feature is enabled, the `validate_transaction()` implementation allows transactions with reserved system addresses (@aptos_framework, @vm_reserved, @aptos_token) as senders to pass validation and enter the mempool. These transactions will always fail during execution but still consume mempool resources and network bandwidth, enabling a mempool pollution attack.

## Finding Description
The transaction validation flow has a gap in checking sender address validity during the prologue phase. Specifically, in the sponsored account creation path: [1](#0-0) 

When a transaction meets the sponsored account creation criteria (sender differs from gas payer, sender account doesn't exist, sponsored feature enabled, sequence number is 0), the validation skips the account existence check in the else block and only validates sequence number equals zero. The authentication key check is also conditionally skipped: [2](#0-1) 

The critical issue is that **reserved address validation only occurs during execution**, not during validation: [3](#0-2) 

This creates an attack vector where transactions with reserved addresses as senders pass `validate_transaction()` and enter the mempool, only to fail when `create_account_if_does_not_exist` is called during execution.

**Attack Flow:**
1. Attacker creates transaction with sender = @aptos_framework (or any reserved address)
2. Transaction has attacker's funded account as fee_payer
3. Transaction has sequence_number = 0
4. `validate_transaction()` in mempool: ✓ PASSES (no reserved address check)
5. Transaction enters mempool and propagates across network
6. During consensus and block execution: ✗ FAILS at account creation with ECANNOT_RESERVED_ADDRESS
7. Attacker's gas is charged, but mempool was polluted

## Impact Explanation
This constitutes **High Severity** under the Aptos bug bounty program criteria for "Validator node slowdowns" and "Significant protocol violations" because:

1. **Mempool Pollution**: Invalid transactions that will definitely fail consume limited mempool space, potentially crowding out legitimate transactions during an attack.

2. **Network Bandwidth Waste**: Invalid transactions propagate through the P2P network, consuming bandwidth across all nodes.

3. **Validator Resource Waste**: Validators spend computational resources validating, ordering, and executing transactions that are guaranteed to fail.

4. **Protocol Invariant Violation**: The system's invariant that "Transaction Validation: Prologue/epilogue checks must enforce all invariants" is violated, as invalid transactions bypass early rejection.

While there is an economic disincentive (attacker pays gas), the attack remains viable because:
- Gas costs for failed transactions may be lower than the network disruption caused
- Multiple reserved addresses can be used to bypass per-sender rate limiting if mempool tracks by transaction sender rather than fee payer
- Sustained attacks can degrade validator performance

## Likelihood Explanation
**Likelihood: MEDIUM**

Prerequisites for exploitation:
- `SPONSORED_AUTOMATIC_ACCOUNT_V1_CREATION` feature must be enabled (configurable feature flag) [4](#0-3) 

- Attacker needs a funded account to use as fee payer
- Attack requires continuous funding to maintain impact

The attack is straightforward to execute once prerequisites are met, requiring only standard transaction submission APIs.

## Recommendation
Add reserved address validation in the prologue phase during `validate_transaction()`, not just during execution. Modify `check_for_replay_protection_regular_txn` to include a check for reserved addresses:

```move
fun check_for_replay_protection_regular_txn(
    sender_address: address,
    gas_payer_address: address,
    txn_sequence_number: u64,
) {
    // NEW: Validate sender is not a reserved address early
    assert!(
        sender_address != @vm_reserved && sender_address != @aptos_framework && sender_address != @aptos_token,
        error::invalid_argument(PROLOGUE_ECANNOT_RESERVED_ADDRESS)
    );
    
    if (
        sender_address == gas_payer_address
            || account::exists_at(sender_address)
            || !features::sponsored_automatic_account_creation_enabled()
            || txn_sequence_number > 0
    ) {
        assert!(account::exists_at(sender_address), error::invalid_argument(PROLOGUE_EACCOUNT_DOES_NOT_EXIST));
        // ... rest of existing logic
    } else {
        // ... existing else block
    }
}
```

This ensures invalid transactions are rejected during mempool validation before entering the transaction pool.

## Proof of Concept

```move
#[test_only]
module test_addr::reserved_address_mempool_pollution_test {
    use std::signer;
    use aptos_framework::account;
    use aptos_framework::aptos_account;
    use aptos_framework::coin;
    use aptos_framework::aptos_coin::AptosCoin;
    
    #[test(attacker = @0xcafe, framework = @aptos_framework)]
    #[expected_failure(abort_code = 0x10003, location = aptos_framework::account)]
    fun test_reserved_address_passes_validation_fails_execution(
        attacker: &signer,
        framework: &signer
    ) {
        // Setup: Create and fund attacker account
        aptos_account::create_account(signer::address_of(attacker));
        coin::register<AptosCoin>(attacker);
        aptos_coin::mint(framework, signer::address_of(attacker), 1000000);
        
        // Attack: Try to create transaction with reserved address as sender
        // In real attack, this would use transaction with:
        // - sender = @aptos_framework
        // - fee_payer = attacker
        // - sequence_number = 0
        
        // This simulates what happens during execution after passing validation
        account::create_account_if_does_not_exist(@aptos_framework);
        
        // Expected: This should fail with ECANNOT_RESERVED_ADDRESS (0x10003)
        // But in validation, there's no check, so transaction enters mempool
    }
}
```

**Note**: The full PoC requires testing against the mempool validation path. The above demonstrates the execution failure after the transaction has already polluted the mempool by passing validation.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/transaction_validation.move (L149-167)
```text
        if (!skip_auth_key_check(is_simulation, &txn_authentication_key)) {
            if (option::is_some(&txn_authentication_key)) {
                if (
                    sender_address == gas_payer_address ||
                    account::exists_at(sender_address) ||
                    !features::sponsored_automatic_account_creation_enabled()
                ) {
                    assert!(
                        txn_authentication_key == option::some(account::get_authentication_key(sender_address)),
                        error::invalid_argument(PROLOGUE_EINVALID_ACCOUNT_AUTH_KEY),
                    );
                };
            } else {
                assert!(
                    allow_missing_txn_authentication_key(sender_address),
                    error::invalid_argument(PROLOGUE_EINVALID_ACCOUNT_AUTH_KEY)
                );
            };
        };
```

**File:** aptos-move/framework/aptos-framework/sources/transaction_validation.move (L215-250)
```text
    fun check_for_replay_protection_regular_txn(
        sender_address: address,
        gas_payer_address: address,
        txn_sequence_number: u64,
    ) {
        if (
            sender_address == gas_payer_address
                || account::exists_at(sender_address)
                || !features::sponsored_automatic_account_creation_enabled()
                || txn_sequence_number > 0
        ) {
            assert!(account::exists_at(sender_address), error::invalid_argument(PROLOGUE_EACCOUNT_DOES_NOT_EXIST));
            let account_sequence_number = account::get_sequence_number(sender_address);
            assert!(
                txn_sequence_number < (1u64 << 63),
                error::out_of_range(PROLOGUE_ESEQUENCE_NUMBER_TOO_BIG)
            );

            assert!(
                txn_sequence_number >= account_sequence_number,
                error::invalid_argument(PROLOGUE_ESEQUENCE_NUMBER_TOO_OLD)
            );

            assert!(
                txn_sequence_number == account_sequence_number,
                error::invalid_argument(PROLOGUE_ESEQUENCE_NUMBER_TOO_NEW)
            );
        } else {
            // In this case, the transaction is sponsored and the account does not exist, so ensure
            // the default values match.
            assert!(
                txn_sequence_number == 0,
                error::invalid_argument(PROLOGUE_ESEQUENCE_NUMBER_TOO_NEW)
            );
        };
    }
```

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L276-284)
```text
    public fun create_account_if_does_not_exist(account_address: address) {
        if (!resource_exists_at(account_address)) {
            assert!(
                account_address != @vm_reserved && account_address != @aptos_framework && account_address != @aptos_token,
                error::invalid_argument(ECANNOT_RESERVED_ADDRESS)
            );
            create_account_unchecked(account_address);
        }
    }
```

**File:** aptos-move/framework/move-stdlib/sources/configs/features.move (L301-307)
```text
    const SPONSORED_AUTOMATIC_ACCOUNT_CREATION: u64 = 34;

    public fun get_sponsored_automatic_account_creation(): u64 { SPONSORED_AUTOMATIC_ACCOUNT_CREATION }

    public fun sponsored_automatic_account_creation_enabled(): bool acquires Features {
        is_enabled(SPONSORED_AUTOMATIC_ACCOUNT_CREATION)
    }
```
