# Audit Report

## Title
Event Sequence Number Collision During V1/V2 Event Migration Causes Duplicate TokenClaimEvent Instances

## Summary
The token claim event system can emit duplicate `TokenClaimEvent` instances with identical sequence numbers during the migration period between V1 (EventHandle-based) and V2 (module event) event systems, causing indexers to overwrite events and violate sequence number uniqueness invariants.

## Finding Description

The vulnerability arises from a fundamental incompatibility between how V1 and V2 events manage sequence numbers during the event migration period:

**V1 Event System (Legacy):**
When `module_event_migration_enabled()` returns `false`, the `claim()` function emits events using `emit_event<TokenClaimEvent>()`, which increments the `claim_events` EventHandle counter. [1](#0-0) 

The `emit_event` implementation uses the current counter value as the sequence number, then increments it: [2](#0-1) 

**V2 Event System (New):**
When `module_event_migration_enabled()` returns `true`, the `claim()` function emits events using `emit(Claim{...})`, which does NOT touch the EventHandle counter: [3](#0-2) 

**Indexer Translation Logic:**
The `ClaimTranslator` translates V2 `Claim` events back to V1 `TokenClaimEvent` format for backward compatibility. It determines the sequence number by calling `get_next_sequence_number` with the EventHandle counter as the default: [4](#0-3) 

The `get_next_sequence_number` function uses the EventHandle counter as the default when no cached or DB value exists: [5](#0-4) 

**The Collision:**
When the migration flag toggles, sequence numbers collide:

1. **Transaction 1** (flag=false): V1 event with sequence 0 emitted → counter incremented to 1
2. **Transaction 2** (flag=true): V2 event emitted → counter stays at 1 → translated with sequence 1
3. **Transaction 3** (flag=false): V1 event with sequence 1 emitted → counter incremented to 2

Both Transaction 2 (translated) and Transaction 3 (native) have sequence number 1 for the same event key. When stored in `EventByKeySchema`, Transaction 3 overwrites Transaction 2: [6](#0-5) [7](#0-6) 

The result is data loss (Transaction 2's event is lost) and violation of the sequence number uniqueness invariant that indexers rely upon.

## Impact Explanation

**Severity: MEDIUM to HIGH**

This qualifies as a **Protocol Violation** affecting the internal indexer:

1. **Indexer Data Corruption**: The indexer loses translated V2 events when they are overwritten by native V1 events with the same sequence number. This causes:
   - Missing claim operations in event history
   - Incorrect token transfer records
   - Broken analytics and metrics for applications relying on complete event data

2. **State Consistency Violation**: The system violates the documented invariant that event sequence numbers must be unique. The event lookup code expects continuous, non-duplicated sequence numbers: [8](#0-7) [9](#0-8) 

3. **Ecosystem Impact**: Applications relying on event data (wallets, explorers, analytics tools) will receive incomplete information, as events are silently lost during flag transitions.

## Likelihood Explanation

**Likelihood: HIGH**

This issue occurs automatically during the event migration period without requiring attacker intervention:

1. **Automatic Trigger**: The vulnerability triggers whenever the `module_event_migration_enabled()` feature flag changes state, which is controlled by governance and affects all users simultaneously.

2. **Real-World Scenario**: During migration deployments:
   - Phase 1: Flag is OFF, V1 events emitted with counter increments
   - Phase 2: Flag is ON, V2 events emitted without counter increments
   - Phase 3: Any rollback or canary deployment toggles flag OFF again
   - Result: Automatic sequence number collision and event overwrites

3. **Not Covered by Tests**: The existing event V2 translation tests do not cover the scenario where the flag toggles back to disabled after being enabled: [10](#0-9) 

## Recommendation

Implement one of the following fixes:

1. **Never Decrement the Counter**: When emitting V2 events, still increment the EventHandle counter even though it's not used, to maintain consistency when the flag toggles back.

2. **Translator Counter Synchronization**: Have the `ClaimTranslator` check both the EventHandle counter AND the cached sequence number, using the maximum value to avoid collisions.

3. **One-Way Migration**: Ensure the `module_event_migration_enabled()` flag can only be enabled, never disabled, preventing backwards transitions that cause collisions.

4. **Separate Sequence Spaces**: Use entirely separate sequence number spaces for V1 and V2 events, with the translator maintaining its own sequence counter independent of the EventHandle.

## Proof of Concept

A Move test demonstrating the collision:

```move
#[test(framework = @aptos_framework, sender = @0xcafe, receiver = @0xface)]
fun test_event_sequence_collision(framework: &signer, sender: &signer, receiver: &signer) {
    // Setup accounts and token
    account::create_account_for_test(signer::address_of(sender));
    account::create_account_for_test(signer::address_of(receiver));
    
    // Create and offer token
    let token_id = create_test_token(sender, 3);
    
    // Transaction 1: Flag OFF - V1 event with seq=0
    features::disable_feature(features::MODULE_EVENT_MIGRATION);
    offer(sender, signer::address_of(receiver), token_id, 1);
    // Counter is now 1
    
    // Transaction 2: Flag ON - V2 event, translated with seq=1
    features::enable_feature(features::MODULE_EVENT_MIGRATION);
    offer(sender, signer::address_of(receiver), token_id, 1);
    // Counter still 1
    
    // Transaction 3: Flag OFF - V1 event with seq=1 (COLLISION!)
    features::disable_feature(features::MODULE_EVENT_MIGRATION);
    offer(sender, signer::address_of(receiver), token_id, 1);
    // Counter is now 2
    
    // Query events - Transaction 2's event has been overwritten by Transaction 3
    // Both have sequence number 1 but represent different offers
}
```

**Notes**

This vulnerability is real and affects the internal indexer's event storage during feature flag transitions. While it does not directly compromise consensus or cause fund loss, it violates critical data integrity invariants that the ecosystem depends on. The issue is particularly concerning because it happens automatically during governance-controlled migrations without any malicious actor required. The missing test coverage for flag toggle-back scenarios suggests this was an overlooked edge case in the migration design.

### Citations

**File:** aptos-move/framework/aptos-token/sources/token_transfers.move (L177-195)
```text
        if (std::features::module_event_migration_enabled()) {
            event::emit(
                Claim {
                    account: sender,
                    to_address: signer::address_of(receiver),
                    token_id,
                    amount,
                }
            )
        } else {
            event::emit_event<TokenClaimEvent>(
                &mut PendingClaims[sender].claim_events,
                TokenClaimEvent {
                    to_address: signer::address_of(receiver),
                    token_id,
                    amount,
                },
            );
        };
```

**File:** aptos-move/framework/aptos-framework/sources/event.move (L17-19)
```text
    public fun emit<T: store + drop>(msg: T) {
        write_module_event_to_store<T>(msg);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/event.move (L54-60)
```text
    public fun emit_event<T: drop + store>(handle_ref: &mut EventHandle<T>, msg: T) {
        write_to_event_store<T>(bcs::to_bytes(&handle_ref.guid), handle_ref.counter, msg);
        spec {
            assume handle_ref.counter + 1 <= MAX_U64;
        };
        handle_ref.counter += 1;
    }
```

**File:** storage/indexer/src/event_v2_translator.rs (L190-200)
```rust
    pub fn get_next_sequence_number(&self, event_key: &EventKey, default: u64) -> Result<u64> {
        if let Some(seq) = self.get_cached_sequence_number(event_key) {
            Ok(seq + 1)
        } else {
            let seq = self
                .internal_indexer_db
                .get::<EventSequenceNumberSchema>(event_key)?
                .map_or(default, |seq| seq + 1);
            Ok(seq)
        }
    }
```

**File:** storage/indexer/src/event_v2_translator.rs (L963-970)
```rust
        let (key, sequence_number) = if let Some(state_value_bytes) =
            engine.get_state_value_bytes_for_resource(claim.account(), &struct_tag)?
        {
            let object_resource: PendingClaimsResource = bcs::from_bytes(&state_value_bytes)?;
            let key = *object_resource.claim_events().key();
            let sequence_number =
                engine.get_next_sequence_number(&key, object_resource.claim_events().count())?;
            (key, sequence_number)
```

**File:** storage/indexer/src/db_indexer.rs (L232-238)
```rust
            if seq != cur_seq {
                let msg = if cur_seq == start_seq_num {
                    "First requested event is probably pruned."
                } else {
                    "DB corruption: Sequence number not continuous."
                };
                bail!("{} expected: {}, actual: {}", msg, cur_seq, seq);
```

**File:** storage/indexer/src/db_indexer.rs (L433-447)
```rust
                events.iter().enumerate().try_for_each(|(idx, event)| {
                    if let ContractEvent::V1(v1) = event {
                        batch
                            .put::<EventByKeySchema>(
                                &(*v1.key(), v1.sequence_number()),
                                &(version, idx as u64),
                            )
                            .expect("Failed to put events by key to a batch");
                        batch
                            .put::<EventByVersionSchema>(
                                &(*v1.key(), version, v1.sequence_number()),
                                &(idx as u64),
                            )
                            .expect("Failed to put events by version to a batch");
                    }
```

**File:** storage/indexer/src/db_indexer.rs (L459-476)
```rust
                                let key = *translated_v1_event.key();
                                let sequence_number = translated_v1_event.sequence_number();
                                self.event_v2_translation_engine
                                    .cache_sequence_number(&key, sequence_number);
                                event_keys.insert(key);
                                batch
                                    .put::<EventByKeySchema>(
                                        &(key, sequence_number),
                                        &(version, idx as u64),
                                    )
                                    .expect("Failed to put events by key to a batch");
                                batch
                                    .put::<EventByVersionSchema>(
                                        &(key, version, sequence_number),
                                        &(idx as u64),
                                    )
                                    .expect("Failed to put events by version to a batch");
                                batch
```

**File:** storage/aptosdb/src/event_store/mod.rs (L130-136)
```rust
            if seq != cur_seq {
                let msg = if cur_seq == start_seq_num {
                    "First requested event is probably pruned."
                } else {
                    "DB corruption: Sequence number not continuous."
                };
                db_other_bail!("{} expected: {}, actual: {}", msg, cur_seq, seq);
```

**File:** api/src/tests/event_v2_translation_test.rs (L45-91)
```rust
#[tokio::test(flavor = "multi_thread", worker_threads = 2)]
#[ignore]
async fn test_event_v2_translation_coin_deposit_event() {
    let context = &mut new_test_context(current_function_name!());

    // Start with the MODULE_EVENT_MIGRATION feature disabled
    context.disable_feature(MODULE_EVENT_MIGRATION).await;

    // Create two accounts
    let account1 = &mut context.api_create_account().await;
    let account2 = &mut context.api_create_account().await;

    // Transfer coins from account1 to account2, emitting V1 events as the feature is disabled
    context
        .api_execute_aptos_account_transfer(account2, account1.address(), 101)
        .await;

    // Enable the MODULE_EVENT_MIGRATION feature
    context.enable_feature(MODULE_EVENT_MIGRATION).await;

    // Check the simulation API outputs the translated V1 event rather than the V2 event as it is
    let payload = json!({
        "type": "entry_function_payload",
        "function": "0x1::coin::transfer",
        "type_arguments": ["0x1::aptos_coin::AptosCoin"],
        "arguments": [
            account1.address().to_hex_literal(), "102"
        ]
    });
    let resp = context.simulate_transaction(account2, payload, 200).await;

    let is_expected_event = |e: &Value| {
        matches_event_details(e, "0x1::coin::DepositEvent", 2, account1.address(), 2)
            && e["data"]["amount"] == "102"
    };

    assert!(resp[0]["events"]
        .as_array()
        .unwrap()
        .iter()
        .any(is_expected_event));

    // Transfer coins from account2 to account1, emitting V2 events as the feature is enabled
    context
        .api_execute_aptos_account_transfer(account2, account1.address(), 102)
        .await;
    context.wait_for_internal_indexer_caught_up().await;
```
