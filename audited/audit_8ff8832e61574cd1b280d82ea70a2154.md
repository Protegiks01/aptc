# Audit Report

## Title
Unauthenticated Message Amplification Attack in Remote Executor gRPC Service

## Summary
The `simple_msg_exchange()` gRPC endpoint in the remote executor service lacks authentication and enables message amplification attacks. An attacker can send a single malicious `ExecuteBlockCommand` message containing many transactions with extensive read/write hints, causing the victim node to generate and send hundreds or thousands of outbound state key request messages, overwhelming downstream validators.

## Finding Description

The vulnerability exists in the interaction between three components:

1. **Unauthenticated gRPC Endpoint**: The `simple_msg_exchange()` function accepts messages from any network peer without authentication or rate limiting. [1](#0-0) 

2. **Unbounded Channel Processing**: Incoming messages are immediately forwarded to unbounded crossbeam channels with no backpressure mechanism. [2](#0-1) 

3. **Amplification Logic**: When processing an `ExecuteBlockCommand`, the handler extracts all state keys from transaction hints and batches them into groups of 200, sending a separate outbound network message for each batch. [3](#0-2) [4](#0-3) 

**Attack Execution Path:**

1. Attacker crafts a malicious `ExecuteBlockCommand` with N transactions, each containing M read/write hints (specific `StorageLocation::Specific` state keys)
2. Attacker sends this single message (up to 80MB) to the victim's `simple_msg_exchange()` endpoint
3. Message is deserialized and processed by `RemoteCoordinatorClient::receive_execute_command()`
4. The handler calls `extract_state_keys()` which flattens all hints into a single vector
5. Handler calls `state_view_client.init_for_block(state_keys)` with potentially tens of thousands of state keys
6. The `init_for_block()` function splits state keys into batches of 200 and spawns threads to send each batch as a separate `RemoteKVRequest` message [5](#0-4) [6](#0-5) 

**Amplification Calculation:**
- Maximum inbound message size: 80 MB [7](#0-6) 
- Batch size for outbound messages: 200 state keys per message [8](#0-7) 
- Assuming minimal `StateKey` size (~100 bytes), an attacker can pack ~800,000 state keys
- **Amplification factor: 4,000x** (800,000 / 200 = 4,000 outbound messages)

**Invariant Violations:**
- Breaks **Resource Limits invariant (#9)**: Operations do not respect computational and network bandwidth limits
- Enables network protocol attacks without proper authentication or authorization

## Impact Explanation

This is a **HIGH severity** vulnerability per Aptos bug bounty criteria:

1. **Validator Node Slowdowns**: Victims must process and send thousands of messages, consuming CPU, memory, and network bandwidth
2. **Network Flooding**: Amplified traffic can overwhelm network links between coordinator and executor shards
3. **Denial of Service**: Multiple concurrent attacks can exhaust validator resources, degrading or halting block execution
4. **Cascading Failures**: If the coordinator receiving amplified messages is also a victim, the attack can propagate through the network

The lack of authentication means **any network peer** can launch this attack without requiring validator credentials or stake. The attack is trivial to execute and can be repeated continuously.

## Likelihood Explanation

**Likelihood: HIGH**

The attack has minimal barriers to execution:
- **No authentication required**: Any peer can connect to the gRPC endpoint [9](#0-8) 
- **No rate limiting**: The service accepts messages without throttling
- **Simple payload construction**: Attacker only needs to craft a valid BCS-serialized `ExecuteBlockCommand` with many hints
- **Low attacker cost**: Single small message triggers massive response
- **Repeatable**: Attack can be launched continuously from multiple sources

The vulnerability is highly exploitable in production environments where remote executor services are deployed.

## Recommendation

Implement multiple defense layers:

**1. Add Authentication and TLS:**
```rust
// In GRPCNetworkMessageServiceServerWrapper::start_async()
Server::builder()
    .tls_config(ServerTlsConfig::new()
        .identity(Identity::from_pem(cert, key))
        .client_ca_root(Certificate::from_pem(ca_cert)))
    .timeout(std::time::Duration::from_millis(rpc_timeout_ms))
    .add_service(NetworkMessageServiceServer::new(self))
    .serve_with_shutdown(server_addr, shutdown_rx)
    .await
```

**2. Implement Rate Limiting:**
Add per-peer rate limiting on `simple_msg_exchange()`:
```rust
async fn simple_msg_exchange(&self, request: Request<NetworkMessage>) 
    -> Result<Response<Empty>, Status> {
    let remote_addr = request.remote_addr();
    
    // Check rate limit
    if !self.rate_limiter.check_and_update(remote_addr) {
        return Err(Status::resource_exhausted("Rate limit exceeded"));
    }
    
    // ... existing logic
}
```

**3. Validate Message Content:**
Add limits on the number of state keys that can be requested:
```rust
fn extract_state_keys(command: &ExecuteBlockCommand) -> Result<Vec<StateKey>, Error> {
    const MAX_STATE_KEYS: usize = 10_000;
    
    let state_keys = /* existing extraction logic */;
    
    if state_keys.len() > MAX_STATE_KEYS {
        return Err(Error::TooManyStateKeys);
    }
    Ok(state_keys)
}
```

**4. Use Bounded Channels:**
Replace unbounded channels with bounded channels to provide backpressure: [10](#0-9) 

## Proof of Concept

```rust
#[cfg(test)]
mod amplification_attack_test {
    use super::*;
    use aptos_types::{
        block_executor::partitioner::{SubBlock, SubBlocksForShard},
        transaction::analyzed_transaction::{AnalyzedTransaction, StorageLocation},
        state_store::state_key::StateKey,
    };
    
    #[test]
    fn test_message_amplification_attack() {
        // Create malicious ExecuteBlockCommand with many transactions
        // Each transaction has many read/write hints
        let num_transactions = 1000;
        let hints_per_transaction = 100; // Total: 100,000 state keys
        
        let mut transactions = vec![];
        for i in 0..num_transactions {
            let mut read_hints = vec![];
            let mut write_hints = vec![];
            
            for j in 0..hints_per_transaction {
                let state_key = StateKey::raw(format!("key_{}_{}", i, j).into_bytes());
                if j % 2 == 0 {
                    read_hints.push(StorageLocation::Specific(state_key));
                } else {
                    write_hints.push(StorageLocation::Specific(state_key));
                }
            }
            
            // Create AnalyzedTransaction with many hints
            // In real attack, attacker would craft proper SignatureVerifiedTransaction
            // For this PoC, we demonstrate the state key extraction logic
            transactions.push((read_hints, write_hints));
        }
        
        // Simulate extract_state_keys() logic
        let total_state_keys: usize = transactions.iter()
            .map(|(r, w)| r.len() + w.len())
            .sum();
        
        // Calculate amplification
        const BATCH_SIZE: usize = 200; // REMOTE_STATE_KEY_BATCH_SIZE
        let num_outbound_messages = (total_state_keys + BATCH_SIZE - 1) / BATCH_SIZE;
        
        println!("Total state keys: {}", total_state_keys);
        println!("Outbound messages generated: {}", num_outbound_messages);
        println!("Amplification factor: {}x", num_outbound_messages);
        
        // With 100,000 state keys:
        // Outbound messages = 100,000 / 200 = 500
        // Amplification: 500x from single inbound message
        assert!(num_outbound_messages > 100, 
            "Attack should generate significant amplification");
    }
}
```

## Notes

**Additional DoS Vector Identified:** If an attacker sends wildcard `StorageLocation` variants (e.g., `WildCardStruct` or `WildCardTable`) instead of `Specific` variants, the `state_key()` method will panic: [11](#0-10) 

This causes the executor shard to crash, which is a separate denial-of-service vulnerability.

The root cause is the absence of authentication on the remote executor gRPC service, combined with unbounded message processing and amplification logic. This service appears designed for trusted internal communication but lacks the security controls necessary for production deployment in adversarial network environments.

### Citations

**File:** secure/net/src/grpc_network_service/mod.rs (L23-23)
```rust
const MAX_MESSAGE_SIZE: usize = 1024 * 1024 * 80;
```

**File:** secure/net/src/grpc_network_service/mod.rs (L75-86)
```rust
        Server::builder()
            .timeout(std::time::Duration::from_millis(rpc_timeout_ms))
            .add_service(
                NetworkMessageServiceServer::new(self).max_decoding_message_size(MAX_MESSAGE_SIZE),
            )
            .add_service(reflection_service)
            .serve_with_shutdown(server_addr, async {
                server_shutdown_rx.await.ok();
                info!("Received signal to shutdown server at {:?}", server_addr);
            })
            .await
            .unwrap();
```

**File:** secure/net/src/grpc_network_service/mod.rs (L93-115)
```rust
    async fn simple_msg_exchange(
        &self,
        request: Request<NetworkMessage>,
    ) -> Result<Response<Empty>, Status> {
        let _timer = NETWORK_HANDLER_TIMER
            .with_label_values(&[&self.self_addr.to_string(), "inbound_msgs"])
            .start_timer();
        let remote_addr = request.remote_addr();
        let network_message = request.into_inner();
        let msg = Message::new(network_message.message);
        let message_type = MessageType::new(network_message.message_type);

        if let Some(handler) = self.inbound_handlers.lock().unwrap().get(&message_type) {
            // Send the message to the registered handler
            handler.send(msg).unwrap();
        } else {
            error!(
                "No handler registered for sender: {:?} and msg type {:?}",
                remote_addr, message_type
            );
        }
        Ok(Response::new(Empty {}))
    }
```

**File:** secure/net/src/network_controller/mod.rs (L128-137)
```rust
    pub fn create_inbound_channel(&mut self, message_type: String) -> Receiver<Message> {
        let (inbound_sender, inbound_receiver) = unbounded();

        self.inbound_handler
            .lock()
            .unwrap()
            .register_handler(message_type, inbound_sender);

        inbound_receiver
    }
```

**File:** execution/executor-service/src/remote_cordinator_client.rs (L52-76)
```rust
    fn extract_state_keys(command: &ExecuteBlockCommand) -> Vec<StateKey> {
        command
            .sub_blocks
            .sub_block_iter()
            .flat_map(|sub_block| {
                sub_block
                    .transactions
                    .par_iter()
                    .map(|txn| {
                        let mut state_keys = vec![];
                        for storage_location in txn
                            .txn()
                            .read_hints()
                            .iter()
                            .chain(txn.txn().write_hints().iter())
                        {
                            state_keys.push(storage_location.state_key().clone());
                        }
                        state_keys
                    })
                    .flatten()
                    .collect::<Vec<StateKey>>()
            })
            .collect::<Vec<StateKey>>()
    }
```

**File:** execution/executor-service/src/remote_state_view.rs (L27-27)
```rust
pub static REMOTE_STATE_KEY_BATCH_SIZE: usize = 200;
```

**File:** execution/executor-service/src/remote_state_view.rs (L118-124)
```rust
    pub fn init_for_block(&self, state_keys: Vec<StateKey>) {
        *self.state_view.write().unwrap() = RemoteStateView::new();
        REMOTE_EXECUTOR_REMOTE_KV_COUNT
            .with_label_values(&[&self.shard_id.to_string(), "prefetch_kv"])
            .inc_by(state_keys.len() as u64);
        self.pre_fetch_state_values(state_keys, false);
    }
```

**File:** execution/executor-service/src/remote_state_view.rs (L136-144)
```rust
        state_keys
            .chunks(REMOTE_STATE_KEY_BATCH_SIZE)
            .map(|state_keys_chunk| state_keys_chunk.to_vec())
            .for_each(|state_keys| {
                let sender = kv_tx.clone();
                thread_pool.spawn(move || {
                    Self::send_state_value_request(shard_id, sender, state_keys);
                });
            });
```

**File:** execution/executor-service/src/remote_state_view.rs (L172-180)
```rust
    fn send_state_value_request(
        shard_id: ShardId,
        sender: Arc<Sender<Message>>,
        state_keys: Vec<StateKey>,
    ) {
        let request = RemoteKVRequest::new(shard_id, state_keys);
        let request_message = bcs::to_bytes(&request).unwrap();
        sender.send(Message::new(request_message)).unwrap();
    }
```

**File:** types/src/transaction/analyzed_transaction.rs (L59-64)
```rust
    pub fn state_key(&self) -> &StateKey {
        match self {
            StorageLocation::Specific(state_key) => state_key,
            _ => panic!("Cannot convert wildcard storage location to state key"),
        }
    }
```
