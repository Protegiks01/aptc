# Audit Report

## Title
Sensitive Magic Header Value Exposed Through Debug Logging in Faucet Configuration

## Summary
The `MagicHeaderCheckerConfig` struct derives both `Debug` and `Serialize` traits, causing the sensitive `magic_header_value` field to be logged in plaintext during faucet startup and configuration validation. This exposes the secret authentication value in log files, telemetry systems, and other log aggregation infrastructure where it can be accessed by unauthorized parties.

## Finding Description

The `MagicHeaderCheckerConfig` struct contains a sensitive authentication secret (`magic_header_value`) that is used to authenticate faucet requests via HTTP headers. This struct derives the `Debug` trait, which automatically implements debug formatting for all fields including the sensitive value. [1](#0-0) 

The vulnerability manifests in two locations where the faucet configuration is logged using the `Debug` trait formatter:

1. **During normal faucet startup** - The entire `RunConfig` (which contains `MagicHeaderCheckerConfig` via the `CheckerConfig` enum) is logged: [2](#0-1) 

2. **During configuration validation** - The configuration is logged again during the validate-config command: [3](#0-2) 

The `RunConfig` contains `checker_configs: Vec<CheckerConfig>`, and `CheckerConfig` is an enum that includes the `MagicHeader` variant containing `MagicHeaderCheckerConfig`: [4](#0-3) 

Since all these types derive `Debug`, the Rust compiler generates debug formatters that output all fields. When `info!("Running with config: {:#?}", self)` executes, it produces log output containing the plaintext `magic_header_value`.

**Attack Path:**
1. Faucet service starts or configuration validation runs
2. Configuration is logged via `info!()` macro with `{:#?}` debug formatting
3. Logs are written to stdout/stderr, log files, remote telemetry systems, or centralized logging infrastructure
4. Attacker gains access to logs through:
   - Compromised log aggregation systems
   - Accidental exposure in bug reports or support tickets
   - Insufficient access controls on logging infrastructure
   - Container logs with overly permissive access
5. Attacker extracts the `magic_header_value` from logs
6. Attacker uses this value to bypass the `MagicHeaderChecker`, circumventing intended access controls

## Impact Explanation

This qualifies as **Medium** severity according to Aptos bug bounty criteria:

1. **Information Leak**: Exposes a secret authentication value that should remain confidential
2. **Limited Funds Loss Potential**: An attacker who obtains the magic header value can bypass the `MagicHeaderChecker` and potentially:
   - Circumvent rate limiting and other protective checkers
   - Request unlimited faucet funds (subject to other checker constraints)
   - Drain the faucet account of test tokens

While the faucet primarily serves testnet/devnet environments, the principle of exposing authentication secrets in logs is a security anti-pattern that could have broader implications if similar patterns exist elsewhere in the codebase.

## Likelihood Explanation

**Likelihood: Medium**

The vulnerability automatically triggers on every faucet startup and configuration validation without requiring any attacker action. However, exploitation requires:

1. **Log Access**: Attacker must gain access to log output through one of:
   - Centralized logging systems (CloudWatch, Datadog, Splunk, etc.)
   - Container orchestration platforms (Kubernetes logs)
   - Compromised servers running the faucet
   - Accidental exposure in public bug reports

2. **Realistic Scenarios**:
   - Developers may copy logs into public issue trackers when debugging
   - Log aggregation systems often have broader access controls than production services
   - Container logs may be accessible to cluster administrators without faucet-specific privileges
   - Telemetry systems may transmit logs over networks with insufficient encryption

The fact that this is an `info!()` level log (not `debug!()` or `trace!()`) means it will be included in default production logging configurations.

## Recommendation

Implement custom `Debug` formatting for `MagicHeaderCheckerConfig` that redacts the sensitive `magic_header_value`:

```rust
use std::fmt;

#[derive(Clone, Deserialize, Serialize)]
pub struct MagicHeaderCheckerConfig {
    pub magic_header_key: String,
    #[serde(skip_serializing)]  // Also prevent serialization exposure
    pub magic_header_value: String,
}

impl fmt::Debug for MagicHeaderCheckerConfig {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("MagicHeaderCheckerConfig")
            .field("magic_header_key", &self.magic_header_key)
            .field("magic_header_value", &"<redacted>")
            .finish()
    }
}
```

Alternatively, use the `secrecy` crate to wrap sensitive values:

```rust
use secrecy::{Secret, ExposeSecret};

#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct MagicHeaderCheckerConfig {
    pub magic_header_key: String,
    pub magic_header_value: Secret<String>,
}

// Update usage to call .expose_secret() only when needed
if header_value != self.config.magic_header_value.expose_secret() {
    // rejection logic
}
```

## Proof of Concept

**Steps to reproduce:**

1. Create a faucet configuration file with a MagicHeaderChecker:

```yaml
checker_configs:
  - type: MagicHeader
    magic_header_key: "X-Secret-Auth"
    magic_header_value: "super_secret_password_12345"
```

2. Start the faucet with this configuration:
```bash
cargo run --bin aptos-faucet -- run --config-path config.yaml
```

3. Observe the startup logs. You will see output similar to:
```
INFO Running with config: RunConfig {
    ...
    checker_configs: [
        MagicHeader(
            MagicHeaderCheckerConfig {
                magic_header_key: "X-Secret-Auth",
                magic_header_value: "super_secret_password_12345",
            },
        ),
    ],
    ...
}
```

The `magic_header_value: "super_secret_password_12345"` is exposed in plaintext in the logs, allowing anyone with log access to extract this secret and bypass the authentication mechanism.

**Expected behavior:** The sensitive value should be redacted as `magic_header_value: "<redacted>"` or similar.

## Notes

While the faucet is an auxiliary service rather than a core consensus component, this vulnerability represents a broader security concern about credential handling in the Aptos ecosystem. The same pattern (deriving `Debug` on structs containing secrets) could exist in other components where the impact would be more severe. A codebase-wide audit for similar issues is recommended.

### Citations

**File:** crates/aptos-faucet/core/src/checkers/magic_header.rs (L10-14)
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct MagicHeaderCheckerConfig {
    pub magic_header_key: String,
    pub magic_header_value: String,
}
```

**File:** crates/aptos-faucet/core/src/server/run.rs (L86-86)
```rust
        info!("Running with config: {:#?}", self);
```

**File:** crates/aptos-faucet/core/src/server/validate_config.rs (L32-32)
```rust
        info!("Config is valid: {:#?}", run_config);
```

**File:** crates/aptos-faucet/core/src/checkers/mod.rs (L81-94)
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(tag = "type")]
pub enum CheckerConfig {
    /// Requires that an auth token is included in the Authorization header.
    AuthToken(ListManagerConfig),

    /// Requires a legitimate Google ReCaptcha token.
    GoogleCaptcha(GoogleCaptchaCheckerConfig),

    /// Rejects requests if their IP is in a blocklisted IPrnage.
    IpBlocklist(IpRangeManagerConfig),

    /// Checkers whether a config-defined magic header kv is present.
    MagicHeader(MagicHeaderCheckerConfig),
```
