# Audit Report

## Title
Panic in ProofRead Implementation Causes Validator Node Crashes During State Checkpoint Computation

## Summary
The `ProofRead` trait implementations in `state_summary.rs` use `.expect()` calls that panic when proof generation fails, causing validator nodes to crash during the critical state checkpoint computation phase of block execution. This affects network liveness when database errors, pruned state, or I/O failures occur.

## Finding Description

During block execution, the `DoStateCheckpoint::run()` workflow computes state summaries by updating the sparse merkle tree with new state changes. [1](#0-0) 

This update process requires fetching proofs from the database through the `ProofRead` trait. The trait is implemented by `HotProvableStateSummary` and `ColdProvableStateSummary` in the state summary module. [2](#0-1) 

Both implementations use `.expect()` to unwrap the `Result` from `inner.get_proof()`, which can return errors in several scenarios:

1. **Pruned state**: When the requested version has been pruned from the database [3](#0-2) 

2. **Database corruption**: Missing merkle tree nodes or corrupted data structures [4](#0-3) 

3. **Hot state configuration errors**: Missing hot state merkle DB when required [5](#0-4) 

4. **I/O failures**: Disk errors, network storage issues, or file system errors during database operations

The TODO comments in the code explicitly acknowledge this issue needs fixing. [6](#0-5) 

When proof generation fails, the `.expect()` causes a panic that propagates up through the execution stack, crashing the validator node during the critical block execution phase. [7](#0-6) 

This violates the **State Consistency** invariant that state transitions must be atomic and handle errors gracefully, and the **Deterministic Execution** principle that validators should not crash during normal block processing.

## Impact Explanation

This qualifies as **High Severity** per Aptos bug bounty criteria under "API crashes" and "Significant protocol violations". When proof generation fails:

- **Immediate impact**: The affected validator node panics and terminates
- **Network impact**: If multiple validators encounter the same condition (e.g., due to synchronized pruning or widespread database issues), network liveness can be severely degraded
- **Consensus impact**: Crashed validators cannot participate in consensus, reducing the network's Byzantine fault tolerance margin
- **Recovery requirement**: Manual node restart and potential database recovery operations

While not as severe as consensus safety violations or fund loss, validator crashes during block processing constitute a significant availability issue that can cascade across the network.

## Likelihood Explanation

The likelihood is **MEDIUM to LOW** under normal operations with proper configuration:

**Conditions that increase likelihood:**
- Aggressive pruning configurations with insufficient retention windows
- Database corruption or hardware failures
- Race conditions between pruning operations and state updates
- Storage I/O issues on validator infrastructure
- Misconfigured hot state sharding settings

**Mitigating factors:**
- Default pruning windows are typically conservative
- Database operations are generally reliable
- Validators typically have robust infrastructure

However, the fact that this is in a **critical execution path** (state checkpoint during block execution) means any failure has immediate and severe consequences. The TODO comments indicate developers recognize this as a known issue requiring proper error handling.

## Recommendation

Replace the `.expect()` calls with proper error propagation. The `ProofRead` trait should be modified to return `Result<Option<SparseMerkleProofExt>>` instead of `Option<SparseMerkleProofExt>`:

```rust
pub trait ProofRead: Sync {
    /// Gets verified proof for this key in persistent storage.
    fn get_proof(&self, key: &HashValue, root_depth: usize) 
        -> Result<Option<SparseMerkleProofExt>>;
}

impl ProofRead for HotProvableStateSummary<'_, '_> {
    fn get_proof(&self, key: &HashValue, root_depth: usize) 
        -> Result<Option<SparseMerkleProofExt>> {
        let inner = &self.inner;
        Ok(inner.version().map(|ver| {
            let _timer = TIMER.timer_with(&["hot_provable_state_summary__get_proof"]);
            inner.get_proof(key, ver, root_depth, /* use_hot_state = */ true)
        }).transpose()?)
    }
}

impl ProofRead for ColdProvableStateSummary<'_, '_> {
    fn get_proof(&self, key: &HashValue, root_depth: usize) 
        -> Result<Option<SparseMerkleProofExt>> {
        let inner = &self.inner;
        Ok(inner.version().map(|ver| {
            let _timer = TIMER.timer_with(&["provable_state_summary__get_proof"]);
            inner.get_proof(key, ver, root_depth, /* use_hot_state = */ false)
        }).transpose()?)
    }
}
```

All callers of `proof_reader.get_proof()` should handle the `Result` appropriately, allowing errors to propagate up to the block executor where they can be logged and handled gracefully without crashing the node.

## Proof of Concept

A Rust test can demonstrate this by simulating a database error:

```rust
#[test]
fn test_proof_read_panic_on_db_error() {
    // Setup: Create a mock DbReader that returns errors
    struct FailingDbReader;
    impl DbReader for FailingDbReader {
        fn get_state_proof_by_version_ext(
            &self,
            _key_hash: &HashValue,
            _version: Version,
            _root_depth: usize,
            _use_hot_state: bool,
        ) -> Result<SparseMerkleProofExt> {
            Err(AptosDbError::Other("Simulated database error".to_string()).into())
        }
        // ... other required trait methods ...
    }
    
    let db = FailingDbReader;
    let state_summary = StateSummary::new_empty(HotStateConfig::default());
    let provable = ProvableStateSummary::new(state_summary, &db);
    let proof_reader = ColdProvableStateSummary::new(&provable);
    
    // This will panic instead of returning an error
    let result = std::panic::catch_unwind(|| {
        proof_reader.get_proof(&HashValue::random(), 0)
    });
    
    assert!(result.is_err(), "Expected panic when proof generation fails");
}
```

To trigger this in production, one could:
1. Configure aggressive pruning that approaches the persisted state version
2. Simulate database corruption or I/O failures
3. Misconfigure hot state settings
4. Induce race conditions through rapid state updates and pruning cycles

**Notes:**
- The vulnerability exists at lines 334 and 347 (not line 244 as mentioned in the question - possibly a line number discrepancy)
- The TODO comments confirm developers are aware this needs fixing
- This is a defensive programming issue where critical operations lack proper error handling
- While not directly exploitable by external attackers, it represents a significant robustness issue that can cause validator crashes under adverse conditions
- The fix requires changes to the `ProofRead` trait definition and all downstream consumers

### Citations

**File:** execution/executor/src/workflow/do_state_checkpoint.rs (L18-30)
```rust
    pub fn run(
        execution_output: &ExecutionOutput,
        parent_state_summary: &LedgerStateSummary,
        persisted_state_summary: &ProvableStateSummary,
        known_state_checkpoints: Option<Vec<Option<HashValue>>>,
    ) -> Result<StateCheckpointOutput> {
        let _timer = OTHER_TIMERS.timer_with(&["do_state_checkpoint"]);

        let state_summary = parent_state_summary.update(
            persisted_state_summary,
            &execution_output.hot_state_updates,
            execution_output.to_commit.state_update_refs(),
        )?;
```

**File:** storage/storage-interface/src/state_store/state_summary.rs (L326-349)
```rust
impl ProofRead for HotProvableStateSummary<'_, '_> {
    // TODO(aldenhu): return error
    fn get_proof(&self, key: &HashValue, root_depth: usize) -> Option<SparseMerkleProofExt> {
        let inner = &self.inner;
        inner.version().map(|ver| {
            let _timer = TIMER.timer_with(&["hot_provable_state_summary__get_proof"]);
            inner
                .get_proof(key, ver, root_depth, /* use_hot_state = */ true)
                .expect("Failed to get account state with proof by version.")
        })
    }
}

impl ProofRead for ColdProvableStateSummary<'_, '_> {
    // TODO(aldenhu): return error
    fn get_proof(&self, key: &HashValue, root_depth: usize) -> Option<SparseMerkleProofExt> {
        let inner = &self.inner;
        inner.version().map(|ver| {
            let _timer = TIMER.timer_with(&["provable_state_summary__get_proof"]);
            inner
                .get_proof(key, ver, root_depth, /* use_hot_state = */ false)
                .expect("Failed to get account state with proof by version.")
        })
    }
```

**File:** storage/aptosdb/src/db/aptosdb_internal.rs (L273-303)
```rust
    pub(super) fn error_if_state_merkle_pruned(
        &self,
        data_type: &str,
        version: Version,
    ) -> Result<()> {
        let min_readable_version = self
            .state_store
            .state_db
            .state_merkle_pruner
            .get_min_readable_version();
        if version >= min_readable_version {
            return Ok(());
        }

        let min_readable_epoch_snapshot_version = self
            .state_store
            .state_db
            .epoch_snapshot_pruner
            .get_min_readable_version();
        if version >= min_readable_epoch_snapshot_version {
            self.ledger_db.metadata_db().ensure_epoch_ending(version)
        } else {
            bail!(
                "{} at version {} is pruned. snapshots are available at >= {}, epoch snapshots are available at >= {}",
                data_type,
                version,
                min_readable_version,
                min_readable_epoch_snapshot_version,
            )
        }
    }
```

**File:** storage/jellyfish-merkle/src/lib.rs (L732-741)
```rust
            let next_node = self
                .reader
                .get_node_with_tag(&next_node_key, "get_proof")
                .map_err(|err| {
                    if nibble_depth == 0 {
                        AptosDbError::MissingRootError(version)
                    } else {
                        err
                    }
                })?;
```

**File:** storage/aptosdb/src/state_store/mod.rs (L192-206)
```rust
        let db = if use_hot_state {
            if self.state_merkle_db.sharding_enabled() {
                self.hot_state_merkle_db
                    .as_ref()
                    .ok_or(AptosDbError::HotStateError)?
            } else {
                // Unsharded unit tests still rely on this.
                &self.state_merkle_db
            }
        } else {
            &self.state_merkle_db
        };
        let (_, proof) = db.get_with_proof_ext(key_hash, version, root_depth)?;
        Ok(proof)
    }
```

**File:** execution/executor/src/block_executor/mod.rs (L315-320)
```rust
                output.set_state_checkpoint_output(DoStateCheckpoint::run(
                    &output.execution_output,
                    parent_block.output.ensure_result_state_summary()?,
                    &ProvableStateSummary::new_persisted(self.db.reader.as_ref())?,
                    None,
                )?);
```
