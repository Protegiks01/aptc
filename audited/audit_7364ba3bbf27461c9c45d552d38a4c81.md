# Audit Report

## Title
Cached TypeTag Desynchronization Between Rust and Move Framework During Randomness Module Upgrades

## Summary
A governance-approved framework upgrade can modify the `RandomnessGeneratedEvent` event type at address `0x1`, but the Rust validator code maintains a static cached `TypeTag` that is never updated, causing permanent desynchronization between the Move framework and Rust consensus/event filtering logic.

## Finding Description

The vulnerability exists in the interaction between three system layers:

**1. Cached Type Tag in Rust** [1](#0-0) 

This static `Lazy<TypeTag>` is initialized once at node startup and never updated during the node's lifetime, even when the Move framework is upgraded.

**2. Governance Framework Upgrade Capability** [2](#0-1) 

Governance can upgrade modules at `0x1` using `resolve_multi_step_proposal`, which grants signer capability for the framework address and allows publishing new module bytecode via `code::publish_package_txn`.

**3. Usage in Consensus Safety Check** [3](#0-2) 

The pipeline uses the cached tag to verify randomness consistency: if a block doesn't have `has_randomness` set, no `RandomnessGeneratedEvent` should be emitted. However, this check only logs errors and increments counters—it does not abort transaction processing.

**4. Event Subscription Filtering** [4](#0-3) 

The cached tag determines which events are forwarded to subscription services for off-chain systems.

**Attack Scenario:**

A governance proposal upgrades the randomness module with compatible public functions but changes the event struct name (e.g., from `RandomnessGeneratedEvent` to `RandomnessGeneratedEventV2`). The Move compatibility check passes because: [5](#0-4) 

Event structs have `drop, store` abilities (not resources), so renaming them doesn't violate function signature or resource layout compatibility. Post-upgrade, all validator nodes continue running with the stale cached `TypeTag`, causing:
- The randomness consistency check to fail silently (missing the new event type)
- Event subscription services to miss critical randomness events
- Monitoring/detection systems to become blind to randomness violations

## Impact Explanation

**Severity: Medium (not Critical)**

This issue does NOT meet Critical severity criteria because:
1. The consensus check only **logs errors** without aborting—it's a monitoring feature, not enforcement [6](#0-5) 
2. No direct consensus safety violation occurs (validators continue to agree on state)
3. No funds are lost or frozen
4. The network remains operational

However, it qualifies as **Medium severity** due to:
- **State inconsistency requiring intervention**: Monitoring systems lose visibility into randomness invariants
- **Infrastructure disruption**: Off-chain systems dependent on event subscriptions break
- **Safety monitoring bypass**: The randomness consistency check becomes ineffective at detecting violations
- **Operational risk**: Legitimate upgrades could accidentally trigger this without malicious intent

## Likelihood Explanation

**Likelihood: Low to Medium**

**Prerequisites for exploitation:**
1. Successful governance proposal (requires significant stake and validator voting)
2. Upgrade must modify event structure while maintaining function compatibility
3. No coordinated node restart to refresh caches

**However:**
- This could occur **accidentally** during legitimate framework upgrades, not just malicious attacks
- Framework upgrades happen regularly as the protocol evolves
- Developers may not realize event renaming bypasses Rust caches
- The Move compatibility checker doesn't prevent event struct changes [7](#0-6) 

## Recommendation

**Immediate Fix:** Implement dynamic type tag resolution or cache invalidation on framework upgrades.

**Option 1: Dynamic Resolution (Recommended)**
Instead of static caching, resolve the type tag dynamically by querying the actual module state:

```rust
// In types/src/account_config/events/randomness_event.rs
pub fn get_randomness_event_type_tag(module_view: &impl ModuleAccess) -> Result<TypeTag> {
    // Query the actual module to get the current event type
    // This ensures synchronization with Move framework state
}
```

**Option 2: Cache Invalidation Hook**
Add a mechanism to invalidate Rust static caches when framework modules are published:

```rust
pub static RANDOMNESS_GENERATED_EVENT_MOVE_TYPE_TAG: RwLock<TypeTag> = ...;

// In executor, after code::publish_package for @0x1
if published_address == 0x1 && module_name == "randomness" {
    invalidate_event_type_caches();
}
```

**Option 3: Version Checking**
Tie the cached tag to a framework version number and validate on each use:

```rust
struct VersionedTypeTag {
    tag: TypeTag,
    framework_version: u64,
}

// Validate before each use that framework_version matches current
```

**Long-term Solution:** Eliminate static Rust caches that duplicate Move framework state. The source of truth should be the Move module state, not Rust static variables.

## Proof of Concept

```move
// governance_upgrade_test.move
script {
    use aptos_framework::aptos_governance;
    use aptos_framework::code;
    
    fun upgrade_randomness_module(governance_signer: &signer) {
        // This proposal upgrades the randomness module
        // Changes RandomnessGeneratedEvent -> RandomnessGeneratedEventV2
        // All public functions remain compatible
        
        let proposal_id = /* create proposal */;
        aptos_governance::vote(governance_signer, pool, proposal_id, true);
        
        // After proposal passes
        let framework_signer = aptos_governance::resolve_multi_step_proposal(
            proposal_id,
            @0x1,
            vector::empty()
        );
        
        code::publish_package_txn(
            &framework_signer,
            /* metadata with renamed event */,
            /* bytecode */
        );
        
        // Nodes continue running without restart
        // Rust cache still has old "RandomnessGeneratedEvent"
        // New events of type "RandomnessGeneratedEventV2" are emitted
        // Consistency check in pipeline_builder.rs misses them
        // Event subscriptions fail to forward them
    }
}
```

**Rust Test Demonstrating Cache Staleness:**
```rust
#[test]
fn test_cached_type_tag_desync() {
    // 1. Initialize node with original randomness module
    let original_tag = RANDOMNESS_GENERATED_EVENT_MOVE_TYPE_TAG.clone();
    assert_eq!(original_tag.to_string(), "0x1::randomness::RandomnessGeneratedEvent");
    
    // 2. Simulate framework upgrade via governance
    // (publish new randomness module with renamed event)
    
    // 3. Verify Rust cache remains unchanged
    let cached_tag_after_upgrade = RANDOMNESS_GENERATED_EVENT_MOVE_TYPE_TAG.clone();
    assert_eq!(cached_tag_after_upgrade, original_tag); // Still old name!
    
    // 4. Create event with new type and verify check fails
    let new_event = create_event("0x1::randomness::RandomnessGeneratedEventV2");
    assert_ne!(new_event.type_tag(), cached_tag_after_upgrade.deref()); // Mismatch!
}
```

## Notes

While this is a legitimate architectural flaw, it **does not meet the "unprivileged attacker" criterion** from the validation checklist. The trust model explicitly states that "governance participants" are trusted actors [8](#0-7) . 

Furthermore, the immediate security impact is limited to monitoring failures rather than consensus safety violations, as the check only logs errors without aborting execution. This qualifies as a **Medium severity design issue** requiring remediation, but not a Critical exploitable vulnerability under the strict validation criteria.

### Citations

**File:** types/src/account_config/events/randomness_event.rs (L8-10)
```rust
pub static RANDOMNESS_GENERATED_EVENT_MOVE_TYPE_TAG: Lazy<TypeTag> = Lazy::new(|| {
    TypeTag::from_str("0x1::randomness::RandomnessGeneratedEvent").expect("Cannot fail")
});
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L1-12)
```text
///
/// AptosGovernance represents the on-chain governance of the Aptos network. Voting power is calculated based on the
/// current epoch's voting power of the proposer or voter's backing stake pool. In addition, for it to count,
/// the stake pool's lockup needs to be at least as long as the proposal's duration.
///
/// It provides the following flow:
/// 1. Proposers can create a proposal by calling AptosGovernance::create_proposal. The proposer's backing stake pool
/// needs to have the minimum proposer stake required. Off-chain components can subscribe to CreateProposalEvent to
/// track proposal creation and proposal ids.
/// 2. Voters can vote on a proposal. Their voting power is derived from the backing stake pool. A stake pool can vote
/// on a proposal multiple times as long as the total voting power of these votes doesn't exceed its total voting power.
module aptos_framework::aptos_governance {
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L643-661)
```text
    /// Resolve a successful multi-step proposal. This would fail if the proposal is not successful.
    public fun resolve_multi_step_proposal(
        proposal_id: u64,
        signer_address: address,
        next_execution_hash: vector<u8>
    ): signer acquires GovernanceResponsbility, ApprovedExecutionHashes {
        voting::resolve_proposal_v2<GovernanceProposal>(@aptos_framework, proposal_id, next_execution_hash);
        // If the current step is the last step of this multi-step proposal,
        // we will remove the execution hash from the ApprovedExecutionHashes map.
        if (vector::length(&next_execution_hash) == 0) {
            remove_approved_hash(proposal_id);
        } else {
            // If the current step is not the last step of this proposal,
            // we replace the current execution hash with the next execution hash
            // in the ApprovedExecutionHashes map.
            add_approved_script_hash(proposal_id)
        };
        get_signer(signer_address)
    }
```

**File:** consensus/src/pipeline/pipeline_builder.rs (L902-919)
```rust
        // check for randomness consistency
        let (_, has_randomness) = rand_check.await?;
        if !has_randomness {
            let mut label = "consistent";
            for event in result.execution_output.subscribable_events.get(None) {
                if event.type_tag() == RANDOMNESS_GENERATED_EVENT_MOVE_TYPE_TAG.deref() {
                    error!(
                            "[Pipeline] Block {} {} {} generated randomness event without has_randomness being true!",
                            block.id(),
                            block.epoch(),
                            block.round()
                        );
                    label = "inconsistent";
                    break;
                }
            }
            counters::RAND_BLOCK.with_label_values(&[label]).inc();
        }
```

**File:** execution/executor-types/src/lib.rs (L275-282)
```rust
pub fn should_forward_to_subscription_service(event: &ContractEvent) -> bool {
    let type_tag = event.type_tag();
    type_tag == OBSERVED_JWK_UPDATED_MOVE_TYPE_TAG.deref()
        || type_tag == DKG_START_EVENT_MOVE_TYPE_TAG.deref()
        || type_tag == NEW_EPOCH_EVENT_MOVE_TYPE_TAG.deref()
        || type_tag == NEW_EPOCH_EVENT_V2_MOVE_TYPE_TAG.deref()
        || type_tag == RANDOMNESS_GENERATED_EVENT_MOVE_TYPE_TAG.deref()
}
```

**File:** aptos-move/framework/aptos-framework/sources/code.move (L137-141)
```text
    /// Whether a compatibility check should be performed for upgrades. The check only passes if
    /// a new module has (a) the same public functions (b) for existing resources, no layout change.
    public fun upgrade_policy_compat(): UpgradePolicy {
        UpgradePolicy { policy: 1 }
    }
```

**File:** third_party/move/move-binary-format/src/compatibility.rs (L21-27)
```rust
/// The result of a linking and layout compatibility check. Here is what the different combinations. NOTE that if `check_struct_layout` is false, type safety over a series of upgrades cannot be guaranteed.
/// mean:
/// `{ check_struct_and_pub_function_linking: true, check_struct_layout: true, check_friend_linking: true }`: fully backward compatible
/// `{ check_struct_and_pub_function_linking: true, check_struct_layout: true, check_friend_linking: false }`: Backward compatible, exclude the friend module declare and friend functions
/// `{ check_struct_and_pub_function_linking: false, check_struct_layout: true, check_friend_linking: false }`: Dependent modules that reference functions or types in this module may not link. However, fixing, recompiling, and redeploying all dependent modules will work--no data migration needed.
/// `{ check_struct_and_pub_function_linking: true, check_struct_layout: false, check_friend_linking: true }`: Attempting to read structs published by this module will now fail at runtime. However, dependent modules will continue to link. Requires data migration, but no changes to dependent modules.
/// `{ check_struct_and_pub_function_linking: false, check_struct_layout: false, check_friend_linking: false }`: Everything is broken. Need both a data migration and changes to dependent modules.
```
