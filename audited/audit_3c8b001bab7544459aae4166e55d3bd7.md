# Audit Report

## Title
Consensus Configuration Inconsistency Due to Missing Version Compatibility Enforcement in OnChain Config Deserialization

## Summary
When validators running different software versions attempt to deserialize on-chain configurations, BCS deserialization failures cause some validators to fall back to default configurations while others use the on-chain values. This creates inconsistent consensus behavior across the validator set, potentially violating consensus safety guarantees.

## Finding Description

The vulnerability exists in how on-chain configurations are fetched and deserialized across the validator set. The core issue involves the interaction between:

1. **Enum-based versioned configs** like `OnChainConsensusConfig` which has variants V1-V5 [1](#0-0) 

2. **BCS deserialization** that fails when encountering unknown enum variants [2](#0-1) 

3. **Fallback behavior** using `unwrap_or_default()` when deserialization fails [3](#0-2) 

**Attack Scenario:**

1. The network has validators running mixed software versions (e.g., during a rolling upgrade)
2. Validator subset A runs code that knows OnChainConsensusConfig variants V1-V5
3. Validator subset B runs older code that only knows V1-V4
4. A governance proposal updates the on-chain config to V5 with specific parameters (e.g., `order_vote_enabled: true`, `rand_check_enabled: true`)
5. At the next epoch transition:
   - **Validators A**: Successfully deserialize V5, use on-chain config
   - **Validators B**: BCS deserialization fails on unknown variant, fall back to `OnChainConsensusConfig::default()` which returns V4 with different parameters [4](#0-3) 

6. Critical differences emerge:
   - V5 on-chain may have `order_vote_enabled: true`
   - V4 default has `order_vote_enabled: false` [5](#0-4) 

7. The `order_vote_enabled` flag affects consensus recovery and liveness storage initialization [6](#0-5) 

This breaks the **Deterministic Execution** invariant - validators must produce identical behavior for identical inputs.

## Impact Explanation

**Critical Severity** - This is a consensus safety violation:

- **Consensus Splits**: Validators with different configs may disagree on block validity, voting behavior, and transaction ordering
- **Non-deterministic Execution**: Same block executed by different validators could produce different results
- **Liveness Failures**: Validators may not reach quorum if they're operating under incompatible consensus rules

The impact meets **Critical Severity** criteria per the Aptos bug bounty:
- Consensus/Safety violations (explicitly listed as Critical)
- Potential for non-recoverable network partition requiring hardfork to resolve
- Breaks fundamental blockchain invariant of deterministic execution

## Likelihood Explanation

**Medium-High Likelihood** during upgrade windows:

- **Realistic Scenario**: Rolling upgrades are standard practice where validators upgrade at different times
- **No Version Enforcement**: The codebase has no validation that all active validators can deserialize new config variants before they're applied [7](#0-6) 

- **Governance-Triggered**: Any governance proposal updating configs to newer variants can trigger this
- **Silent Failure**: Validators log warnings but continue operating with defaults, making the issue hard to detect [8](#0-7) 

Mitigating factors:
- Requires validators to not upgrade in coordination
- Assumes governance proposals aren't coordinated with validator upgrades
- Operational procedures may prevent this (but not enforced in code)

## Recommendation

Implement version compatibility validation before applying new config variants:

```rust
// In DbBackedOnChainConfig::get() or similar
impl OnChainConfigProvider for DbBackedOnChainConfig {
    fn get<T: OnChainConfig>(&self) -> Result<T> {
        let bytes = self
            .reader
            .get_state_value_by_version(&StateKey::on_chain_config::<T>()?, self.version)?
            .ok_or_else(|| {
                anyhow!(
                    "no config {} found in aptos root account state",
                    T::CONFIG_ID
                )
            })?
            .bytes()
            .clone();

        // ADDED: Validate deserialization succeeds before epoch transition
        T::deserialize_into_config(&bytes).map_err(|e| {
            // If deserialization fails, this should prevent epoch transition
            // rather than falling back to defaults
            anyhow!(
                "CRITICAL: Cannot deserialize config {} - validator software may be outdated. Error: {}",
                T::CONFIG_ID,
                e
            )
        })
    }
}
```

Additionally:

1. **Remove silent fallbacks**: Replace `unwrap_or_default()` with explicit version checks:
   - Validators should refuse to start new epoch if critical configs can't be deserialized
   - Log errors should be elevated to fatal errors for consensus-critical configs

2. **Add version compatibility metadata**: Include minimum required software version in on-chain configs

3. **Governance validation**: Add pre-flight checks to governance proposals that verify all active validators can deserialize new config formats

4. **Consistent error handling**: Remove panic inconsistency between ValidatorSet (panics) and other configs (defaults) [9](#0-8) 

## Proof of Concept

```rust
// Reproduction steps (conceptual - requires multi-node testnet):

// 1. Setup: Deploy network with 4 validators
//    - Validators 0-1: Running binary with OnChainConsensusConfig V1-V5 support
//    - Validators 2-3: Running binary with OnChainConsensusConfig V1-V4 support only

// 2. Verify initial state: All validators use V4 config
// (Initial config is V4, all can deserialize)

// 3. Submit governance proposal to update to V5:
let new_config = OnChainConsensusConfig::V5 {
    alg: ConsensusAlgorithmConfig::JolteonV2 {
        main: ConsensusConfigV1::default(),
        quorum_store_enabled: true,
        order_vote_enabled: true,  // Key difference from default
    },
    vtxn: ValidatorTxnConfig::default_enabled(),
    window_size: None,
    rand_check_enabled: true,
};

// 4. Proposal passes, config updated on-chain

// 5. Next epoch transition occurs:
//    - Validators 0-1: Deserialize V5 successfully, use order_vote_enabled=true
//    - Validators 2-3: Deserialization fails, fall back to default with order_vote_enabled=false

// 6. Observe consensus divergence:
//    - Different validators have different consensus behavior
//    - Block production/voting patterns differ
//    - Network may split or experience liveness failures

// Expected: Consensus safety violation, potential chain split
// Actual: Silent fallback creates configuration inconsistency
```

## Notes

This vulnerability highlights a systemic issue in the config management design: **forward compatibility is not guaranteed**. The enum-based versioning approach combined with BCS deserialization creates brittleness during upgrades. While operational procedures likely coordinate upgrades to prevent this, the lack of programmatic enforcement makes the system vulnerable to configuration-induced consensus failures during any upgrade window or operational mistake.

### Citations

**File:** types/src/on_chain_config/consensus_config.rs (L46-52)
```rust
    pub fn default_if_missing() -> Self {
        Self::JolteonV2 {
            main: ConsensusConfigV1::default(),
            quorum_store_enabled: true,
            order_vote_enabled: false,
        }
    }
```

**File:** types/src/on_chain_config/consensus_config.rs (L191-213)
```rust
#[derive(Clone, Debug, Deserialize, PartialEq, Eq, Serialize)]
pub enum OnChainConsensusConfig {
    V1(ConsensusConfigV1),
    V2(ConsensusConfigV1),
    V3 {
        alg: ConsensusAlgorithmConfig,
        vtxn: ValidatorTxnConfig,
    },
    V4 {
        alg: ConsensusAlgorithmConfig,
        vtxn: ValidatorTxnConfig,
        // Execution pool block window
        window_size: Option<u64>,
    },
    V5 {
        alg: ConsensusAlgorithmConfig,
        vtxn: ValidatorTxnConfig,
        // Execution pool block window
        window_size: Option<u64>,
        // Whether to check if we can skip generating randomness for blocks
        rand_check_enabled: bool,
    },
}
```

**File:** types/src/on_chain_config/consensus_config.rs (L443-450)
```rust
impl Default for OnChainConsensusConfig {
    fn default() -> Self {
        OnChainConsensusConfig::V4 {
            alg: ConsensusAlgorithmConfig::default_if_missing(),
            vtxn: ValidatorTxnConfig::default_if_missing(),
            window_size: DEFAULT_WINDOW_SIZE,
        }
    }
```

**File:** types/src/on_chain_config/consensus_config.rs (L453-469)
```rust
impl OnChainConfig for OnChainConsensusConfig {
    const MODULE_IDENTIFIER: &'static str = "consensus_config";
    const TYPE_IDENTIFIER: &'static str = "ConsensusConfig";

    /// The Move resource is
    /// ```ignore
    /// struct AptosConsensusConfig has copy, drop, store {
    ///    config: vector<u8>,
    /// }
    /// ```
    /// so we need two rounds of bcs deserilization to turn it back to OnChainConsensusConfig
    fn deserialize_into_config(bytes: &[u8]) -> Result<Self> {
        let raw_bytes: Vec<u8> = bcs::from_bytes(bytes)?;
        bcs::from_bytes(&raw_bytes)
            .map_err(|e| format_err!("[on-chain config] Failed to deserialize into config: {}", e))
    }
}
```

**File:** consensus/src/epoch_manager.rs (L1165-1167)
```rust
        let validator_set: ValidatorSet = payload
            .get()
            .expect("failed to get ValidatorSet from payload");
```

**File:** consensus/src/epoch_manager.rs (L1178-1201)
```rust
        let onchain_consensus_config: anyhow::Result<OnChainConsensusConfig> = payload.get();
        let onchain_execution_config: anyhow::Result<OnChainExecutionConfig> = payload.get();
        let onchain_randomness_config_seq_num: anyhow::Result<RandomnessConfigSeqNum> =
            payload.get();
        let randomness_config_move_struct: anyhow::Result<RandomnessConfigMoveStruct> =
            payload.get();
        let onchain_jwk_consensus_config: anyhow::Result<OnChainJWKConsensusConfig> = payload.get();
        let dkg_state = payload.get::<DKGState>();

        if let Err(error) = &onchain_consensus_config {
            warn!("Failed to read on-chain consensus config {}", error);
        }

        if let Err(error) = &onchain_execution_config {
            warn!("Failed to read on-chain execution config {}", error);
        }

        if let Err(error) = &randomness_config_move_struct {
            warn!("Failed to read on-chain randomness config {}", error);
        }

        self.epoch_state = Some(epoch_state.clone());

        let consensus_config = onchain_consensus_config.unwrap_or_default();
```

**File:** consensus/src/epoch_manager.rs (L1383-1386)
```rust
        match self.storage.start(
            consensus_config.order_vote_enabled(),
            consensus_config.window_size(),
        ) {
```

**File:** state-sync/inter-component/event-notifications/src/lib.rs (L397-412)
```rust
impl OnChainConfigProvider for DbBackedOnChainConfig {
    fn get<T: OnChainConfig>(&self) -> Result<T> {
        let bytes = self
            .reader
            .get_state_value_by_version(&StateKey::on_chain_config::<T>()?, self.version)?
            .ok_or_else(|| {
                anyhow!(
                    "no config {} found in aptos root account state",
                    T::CONFIG_ID
                )
            })?
            .bytes()
            .clone();

        T::deserialize_into_config(&bytes)
    }
```
