# Audit Report

## Title
Resource Exhaustion via Unbounded Memory Allocation in Backup CLI `open_for_read()` Function

## Summary
The backup-cli's `open_for_read()` function lacks size limits when consuming the returned AsyncRead stream. An attacker with access to either supply CLI parameters or modify backup storage can cause memory exhaustion by providing a `file_handle` that points to very large files or infinite data streams, leading to OOM crashes during restore operations.

## Finding Description

The vulnerability exists in the backup restore flow where `FileHandle` values are consumed without size validation. The attack path is:

1. **Entry Point - User-Supplied FileHandle**: The restore operations accept `file_handle` values via CLI parameters like `--state-manifest` [1](#0-0) 

2. **Unbounded Read Operation**: The `manifest_handle` is passed to `load_json_file()` which calls `read_all()` [2](#0-1) 

3. **Memory Exhaustion Point**: The `read_all()` function creates an empty `Vec<u8>` and calls `read_to_end()` without any size limits [3](#0-2) 

4. **Command Execution**: The `open_for_read()` function spawns a shell command with the `file_handle` as an environment variable, executing user-configured commands that output to stdout [4](#0-3) 

5. **Streaming Without Bounds**: The `ChildStdoutAsDataSource` implements AsyncRead and streams data from the child process without size restrictions [5](#0-4) 

**Attack Scenarios:**

**Scenario A - Malicious CLI Parameters**: An operator with CLI access (or compromised credentials) supplies a malicious file handle pointing to a very large file or device:
```bash
aptos-backup-cli state-snapshot restore \
  --state-manifest "path/to/10GB-file" \
  --state-into-version 0
```

**Scenario B - Compressed Bomb**: If the backup storage command includes decompression (as shown in sample configs), a compressed bomb can be used [6](#0-5) 

**Scenario C - Compromised Metadata**: If backup storage is compromised, attackers can modify metadata files to point `manifest.proof` FileHandles to malicious large files [7](#0-6) 

The `FileHandle` type is just a String alias with no validation [8](#0-7) 

## Impact Explanation

**Severity: Medium**

This vulnerability aligns with Medium severity in the Aptos bug bounty program as it causes "state inconsistencies requiring intervention." The impacts include:

1. **Denial of Service**: Memory exhaustion crashes the restore process, preventing disaster recovery operations
2. **Operational Disruption**: Validator operators cannot restore databases from backup during critical recovery scenarios  
3. **Resource Exhaustion**: OOM kills can affect the entire host system if restore is run on validator nodes

This does NOT constitute Critical or High severity because:
- It does not affect live consensus operations or validator availability
- It does not enable theft or manipulation of funds
- It requires either CLI access or backup storage compromise (not a network-level attack)
- It impacts operational tooling, not the core blockchain protocol

## Likelihood Explanation

**Likelihood: Medium**

The vulnerability requires one of:
1. Access to run backup-cli restore commands with malicious parameters
2. Compromise of backup storage infrastructure to modify metadata files

While these prerequisites limit widespread exploitation, the likelihood is elevated because:
- Backup credentials may be stored in CI/CD systems or configuration files
- Misconfigurations in backup storage permissions are common
- Insider threats or compromised operator credentials
- Even unintentional operational errors (pointing to wrong files) trigger the vulnerability

The lack of defensive programming makes this exploitable in realistic operational scenarios.

## Recommendation

Implement multiple defense-in-depth mitigations:

**1. Add Size Limits to `read_all()`**:
```rust
// In storage_ext.rs
const MAX_FILE_SIZE: usize = 100 * 1024 * 1024; // 100 MB limit

async fn read_all(&self, file_handle: &FileHandleRef) -> Result<Vec<u8>> {
    let mut file = self.open_for_read(file_handle).await?;
    let mut bytes = Vec::new();
    
    // Use take() to limit maximum read size
    let mut limited_reader = file.take(MAX_FILE_SIZE as u64);
    limited_reader.read_to_end(&mut bytes).await?;
    
    // Check if limit was hit
    if bytes.len() >= MAX_FILE_SIZE {
        bail!("File size exceeds maximum allowed size of {} bytes", MAX_FILE_SIZE);
    }
    
    Ok(bytes)
}
```

**2. Add FileHandle Validation**: Validate that FileHandles don't contain dangerous paths or characters before use.

**3. Use Streaming Deserialization**: Where possible, avoid loading entire files into memory by using streaming JSON/BCS deserializers.

**4. Add Operation Timeouts**: Implement timeouts for all read operations to prevent hanging on infinite streams.

**5. Memory-Mapped Files**: For very large files, consider using memory-mapped I/O instead of loading entirely into RAM.

## Proof of Concept

```rust
// Test demonstrating the vulnerability
// Place in: storage/backup/backup-cli/src/storage/command_adapter/tests.rs

#[tokio::test]
async fn test_resource_exhaustion_via_large_file() {
    use std::io::Write;
    use tempfile::TempDir;
    
    // Create a config that outputs large data
    let config_content = r#"
commands:
  create_backup: "echo 'test'"
  create_for_write: "echo 'test.file'"
  open_for_read: |
    # Output 1GB of zeros - will exhaust memory
    dd if=/dev/zero bs=1M count=1024
  save_metadata_line: "echo 'metadata/test'"
  list_metadata_files: "echo 'metadata/test'"
env_vars: []
"#;
    
    let tmp_dir = TempDir::new().unwrap();
    let config_path = tmp_dir.path().join("config.yaml");
    std::fs::write(&config_path, config_content).unwrap();
    
    let config = CommandAdapterConfig::load_from_file(&config_path).await.unwrap();
    let adapter = CommandAdapter::new(config);
    
    // This will attempt to read 1GB into memory
    // Expected: Should fail with size limit error
    // Actual: Attempts to allocate 1GB, may OOM
    let result = adapter.open_for_read("malicious_file").await;
    
    match result {
        Ok(mut reader) => {
            let mut buffer = Vec::new();
            // This will keep reading until OOM
            let read_result = reader.read_to_end(&mut buffer).await;
            
            // Without protection, this will exhaust memory
            // With fix, should return error before memory exhaustion
            assert!(read_result.is_err(), "Should reject oversized reads");
        }
        Err(_) => {
            // With proper validation, should fail early
        }
    }
}
```

## Notes

- This vulnerability breaks Invariant #9: "Resource Limits: All operations must respect gas, storage, and computational limits"
- The issue affects all consumers of `load_json_file()` and `load_bcs_file()` including state snapshot, transaction, and epoch ending restore operations
- While this requires some level of access (CLI or backup storage), it represents a failure of defensive programming that could be exploited through compromised credentials, insider threats, or operational errors
- The backup-cli tool should implement robust input validation even when run by trusted operators, as defense-in-depth against mistakes and compromise

### Citations

**File:** storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs (L51-52)
```rust
    #[clap(long = "state-manifest")]
    pub manifest_handle: FileHandle,
```

**File:** storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs (L123-124)
```rust
        let manifest: StateSnapshotBackup =
            self.storage.load_json_file(&self.manifest_handle).await?;
```

**File:** storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs (L125-126)
```rust
        let (txn_info_with_proof, li): (TransactionInfoWithProof, LedgerInfoWithSignatures) =
            self.storage.load_bcs_file(&manifest.proof).await?;
```

**File:** storage/backup/backup-cli/src/utils/storage_ext.rs (L24-28)
```rust
    async fn read_all(&self, file_handle: &FileHandleRef) -> Result<Vec<u8>> {
        let mut file = self.open_for_read(file_handle).await?;
        let mut bytes = Vec::new();
        file.read_to_end(&mut bytes).await?;
        Ok(bytes)
```

**File:** storage/backup/backup-cli/src/storage/command_adapter/mod.rs (L114-124)
```rust
    async fn open_for_read(
        &self,
        file_handle: &FileHandleRef,
    ) -> Result<Box<dyn AsyncRead + Send + Unpin>> {
        let child = self
            .cmd(&self.config.commands.open_for_read, vec![
                EnvVar::file_handle(file_handle.to_string()),
            ])
            .spawn()?;
        Ok(Box::new(child.into_data_source()))
    }
```

**File:** storage/backup/backup-cli/src/storage/command_adapter/command.rs (L143-165)
```rust
impl AsyncRead for ChildStdoutAsDataSource<'_> {
    fn poll_read(
        mut self: Pin<&mut Self>,
        cx: &mut Context<'_>,
        buf: &mut ReadBuf<'_>,
    ) -> Poll<::std::io::Result<()>> {
        if self.child.is_some() {
            let filled_before_poll = buf.filled().len();
            let res = Pin::new(self.child.as_mut().unwrap().stdout()).poll_read(cx, buf);
            match res {
                Poll::Ready(Ok(())) if buf.filled().len() == filled_before_poll => {
                    // hit EOF, start joining self.child
                    self.join_fut = Some(self.child.take().unwrap().join().boxed());
                },
                _ => return res,
            }
        }

        Pin::new(self.join_fut.as_mut().unwrap())
            .poll(cx)
            .map_err(::std::io::Error::other)
    }
}
```

**File:** storage/backup/backup-cli/src/storage/command_adapter/sample_configs/s3.sample.yaml (L19-21)
```yaml
  open_for_read: |
    # route file handle content to stdout
    aws s3 cp "s3://$BUCKET/$SUB_DIR/$FILE_HANDLE" - | gzip -cd
```

**File:** storage/backup/backup-cli/src/storage/mod.rs (L36-41)
```rust
/// URI pointing to a file in a backup storage, like "s3:///bucket/path/file".
/// These are created by the storage when `create_for_write()`, stored in manifests by the backup
/// controller, and passed back to the storage when `open_for_read()` by the restore controller
/// to retrieve a file referred to in the manifest.
pub type FileHandle = String;
pub type FileHandleRef = str;
```
