# Audit Report

## Title
Consensus Private Key Leakage Through Dual Storage Architecture Bypassing SafetyRules Isolation

## Summary
The `EpochManager` maintains two separate instances of `PersistentSafetyStorage`: one within `safety_rules_manager` and a separate `key_storage` field. The `key_storage` field is used to extract the consensus private key and distribute it to multiple components (QuorumStore, ExecutionClient, RandManager), violating SafetyRules isolation and creating multiple attack surfaces where the key can be accessed or compromised outside of SafetyRules' voting safety checks.

## Finding Description
SafetyRules is designed to be the sole guardian of the consensus private key, enforcing critical voting invariants (last_voted_round, preferred_round) to prevent equivocation and maintain consensus safety. However, the current architecture breaks this isolation: [1](#0-0) [2](#0-1) 

Both fields are initialized from the same configuration: [3](#0-2) 

The `key_storage` field directly extracts the consensus private key: [4](#0-3) 

This extracted key is then distributed across component boundaries:

**1. To QuorumStore's BatchStore:** [5](#0-4) [6](#0-5) 

**2. To ExecutionClient's RandManager:** [7](#0-6) [8](#0-7) [9](#0-8) 

**3. To pipeline builder:** [10](#0-9) 

The consensus private key now exists in multiple `ValidatorSigner` instances across BatchStore, RandManager, and the pipeline, all capable of signing messages independently without SafetyRules' safety checks. This violates the architectural invariant that only SafetyRules should possess and use the consensus key.

## Impact Explanation
**Critical Severity** - This architectural flaw creates multiple attack vectors:

1. **Equivocation Risk**: If any component holding the key (BatchStore, RandManager, etc.) is compromised or contains a vulnerability, an attacker could sign conflicting votes or proposals without SafetyRules' last_voted_round/preferred_round checks, leading to consensus safety violations.

2. **Defense-in-Depth Failure**: SafetyRules' safety checks (preventing double voting, enforcing round progression) can be bypassed entirely if an attacker gains access to the key through any of the secondary components.

3. **Increased Attack Surface**: Each additional component holding the key represents a potential compromise point. A vulnerability in QuorumStore batch signing or RandManager could leak the consensus key.

4. **Consensus Safety Violation**: Per the Aptos critical invariant "Consensus Safety: AptosBFT must prevent double-spending and chain splits under < 1/3 Byzantine", this architectural flaw undermines the core safety mechanism by allowing key usage outside SafetyRules' protection.

## Likelihood Explanation
**High Likelihood** - This is an existing architectural pattern used in every epoch initialization. The key extraction and distribution happens automatically during normal operation. While exploitation requires:
- A vulnerability in one of the components receiving the key (BatchStore, RandManager, etc.)
- Or compromised validator node with memory access

The widespread distribution of the key significantly increases the probability that one of these conditions will be met compared to having the key confined solely to SafetyRules.

## Recommendation
Refactor the architecture to eliminate the `key_storage` field and all direct key extraction. Components requiring signing operations should obtain signatures through SafetyRules via the TSafetyRules interface:

1. **Remove** the `key_storage` field from EpochManager
2. **Eliminate** the `load_consensus_key()` method  
3. **Refactor** BatchStore, RandManager, and pipeline to request signatures through SafetyRules rather than maintaining their own ValidatorSigner instances
4. **Extend** the TSafetyRules trait with methods for batch signing and randomness signing if needed
5. **Ensure** all consensus-critical signing operations flow through SafetyRules' safety checks

Example conceptual fix for BatchStore:
```rust
// Instead of:
let signer = ValidatorSigner::new(self.author, consensus_key.clone());

// Use:
let signature = safety_rules_client.sign_batch_data(&batch_data)?;
```

## Proof of Concept
The vulnerability can be demonstrated by showing key extraction and usage outside SafetyRules:

```rust
// In EpochManager::start_new_epoch()
// Step 1: Key is extracted from key_storage (bypassing SafetyRules)
let loaded_consensus_key = self.load_consensus_key(&epoch_state.verifier)?;

// Step 2: Key is passed to QuorumStore
let consensus_key = Arc::new(loaded_consensus_key);
InnerBuilder::new(..., consensus_key.clone())

// Step 3: In QuorumStore, ValidatorSigner created independently
let signer = ValidatorSigner::new(author, consensus_key);

// Step 4: Batch signed without SafetyRules checks
let signature = signer.sign(&batch)?;

// At this point, the key has been used to sign data without:
// - SafetyRules' last_voted_round check
// - SafetyRules' preferred_round enforcement  
// - SafetyRules' epoch validation
// - Any voting safety invariant verification
```

## Notes
This is an architectural security issue rather than a traditional exploitable bug. The vulnerability manifests as a violation of the principle of least privilege and defense-in-depth. While SafetyRules correctly implements all safety checks, the architecture undermines its effectiveness by allowing components to bypass it entirely through direct key access. The fix requires significant refactoring but is essential for maintaining consensus safety guarantees.

### Citations

**File:** consensus/src/epoch_manager.rs (L145-145)
```rust
    safety_rules_manager: SafetyRulesManager,
```

**File:** consensus/src/epoch_manager.rs (L180-180)
```rust
    key_storage: PersistentSafetyStorage,
```

**File:** consensus/src/epoch_manager.rs (L209-210)
```rust
        let safety_rules_manager = SafetyRulesManager::new(sr_config);
        let key_storage = safety_rules_manager::storage(sr_config);
```

**File:** consensus/src/epoch_manager.rs (L754-754)
```rust
                consensus_key,
```

**File:** consensus/src/epoch_manager.rs (L866-866)
```rust
                consensus_key.clone(),
```

**File:** consensus/src/epoch_manager.rs (L882-882)
```rust
        let signer = Arc::new(ValidatorSigner::new(self.author, consensus_sk));
```

**File:** consensus/src/epoch_manager.rs (L1971-1984)
```rust
    fn load_consensus_key(&self, vv: &ValidatorVerifier) -> anyhow::Result<PrivateKey> {
        match vv.get_public_key(&self.author) {
            Some(pk) => self
                .key_storage
                .consensus_sk_by_pk(pk)
                .map_err(|e| anyhow!("could not find sk by pk: {:?}", e)),
            None => {
                warn!("could not find my pk in validator set, loading default sk!");
                self.key_storage
                    .default_consensus_sk()
                    .map_err(|e| anyhow!("could not load default sk: {e}"))
            },
        }
    }
```

**File:** consensus/src/quorum_store/quorum_store_builder.rs (L236-237)
```rust
    fn create_batch_store(&mut self) -> Arc<BatchReaderImpl<NetworkSender>> {
        let signer = ValidatorSigner::new(self.author, self.consensus_key.clone());
```

**File:** consensus/src/pipeline/execution_client.rs (L238-238)
```rust
        let signer = Arc::new(ValidatorSigner::new(self.author, consensus_sk));
```

**File:** consensus/src/pipeline/execution_client.rs (L409-409)
```rust
                        consensus_sk,
```
