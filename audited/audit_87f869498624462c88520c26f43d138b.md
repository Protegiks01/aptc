# Audit Report

## Title
Variant Field Instantiations Bypass Module Complexity Budget Checks

## Summary
The module complexity metering system fails to account for `variant_field_instantiations` and `struct_variant_instantiations` tables, allowing attackers to publish modules with unbounded complexity that bypass the intended resource limits.

## Finding Description

The Move binary format complexity checker in `check_module_complexity()` is responsible for ensuring that published modules do not exceed complexity budgets to prevent resource exhaustion during module loading and verification. However, this function has a critical omission. [1](#0-0) 

The function meters regular `field_instantiations` via `meter_field_instantiations()` at line 411, but completely omits metering for `variant_field_instantiations` and `struct_variant_instantiations` tables.

These tables exist in `CompiledModule` since bytecode version 7: [2](#0-1) 

Each entry in these tables contains a `type_parameters: SignatureIndex` field that can point to arbitrarily complex nested type signatures: [3](#0-2) [4](#0-3) 

While individual variant field instantiations ARE metered when used in bytecode instructions: [5](#0-4) 

The tables themselves are never iterated and metered during the module-level complexity check, unlike regular field instantiations: [6](#0-5) 

During module publishing, the complexity check is invoked with a budget based on blob size: [7](#0-6) 

An attacker can exploit this by:
1. Creating a module with many entries in `variant_field_instantiations` and `struct_variant_instantiations` tables
2. Each entry points to deeply nested generic type signatures (e.g., `Vec<Vec<Vec<...>>>`)
3. The module passes complexity checks since these tables are unmetered
4. Upon loading, the VM must process all these complex type instantiations, causing excessive memory usage and computation

## Impact Explanation

This vulnerability qualifies as **High Severity** per the Aptos bug bounty program because it enables **validator node slowdowns** through resource exhaustion.

The complexity budget exists specifically to prevent modules from consuming excessive resources during loading and verification. By bypassing this check, an attacker can:

- Cause memory exhaustion on validator nodes processing the module publish transaction
- Trigger excessive CPU usage during type checking and verification
- Potentially cause validator crashes or severe performance degradation
- Affect multiple validators simultaneously if they all process the malicious transaction

This breaks the **Resource Limits** invariant (#9): "All operations must respect gas, storage, and computational limits" and the **Move VM Safety** invariant (#3): "Bytecode execution must respect gas limits and memory constraints."

## Likelihood Explanation

This vulnerability has **HIGH likelihood** of exploitation:

1. **Low barrier to entry**: Any user can publish a module by submitting a transaction
2. **Easy to exploit**: Creating modules with many variant field instantiations is straightforward
3. **Hard to detect**: The malicious module appears normal in size but hides complexity in unmetered tables
4. **Network-wide impact**: All validators processing the transaction are affected
5. **No special privileges required**: No validator access or governance participation needed

The only cost to the attacker is the transaction fee for module publishing, which is minimal compared to the potential network disruption.

## Recommendation

Implement the missing metering functions for variant-related instantiation tables. Add the following to `check_complexity.rs`:

```rust
fn meter_variant_field_instantiations(&self) -> PartialVMResult<()> {
    let variant_field_insts = self.resolver.variant_field_instantiations()
        .ok_or_else(|| {
            PartialVMError::new(StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR)
                .with_message("Can't get variant field instantiations -- not a module.".to_string())
        })?;
    
    for variant_field_inst_idx in 0..variant_field_insts.len() {
        self.meter_variant_field_instantiation(
            VariantFieldInstantiationIndex(variant_field_inst_idx as u16)
        )?;
    }
    Ok(())
}

fn meter_struct_variant_instantiations(&self) -> PartialVMResult<()> {
    let struct_variant_insts = self.resolver.struct_variant_instantiations()
        .ok_or_else(|| {
            PartialVMError::new(StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR)
                .with_message("Can't get struct variant instantiations -- not a module.".to_string())
        })?;
    
    for struct_variant_inst_idx in 0..struct_variant_insts.len() {
        self.meter_struct_variant_instantiation(
            StructVariantInstantiationIndex(struct_variant_inst_idx as u16)
        )?;
    }
    Ok(())
}
```

Then modify `check_module_complexity()` to call these functions:

```rust
pub fn check_module_complexity(module: &CompiledModule, budget: u64) -> PartialVMResult<u64> {
    let meter = BinaryComplexityMeter {
        resolver: BinaryIndexedView::Module(module),
        cached_signature_costs: RefCell::new(BTreeMap::new()),
        balance: RefCell::new(budget),
    };

    meter.meter_signatures()?;
    meter.meter_function_instantiations()?;
    meter.meter_struct_def_instantiations()?;
    meter.meter_struct_variant_instantiations()?;  // ADD THIS
    meter.meter_field_instantiations()?;
    meter.meter_variant_field_instantiations()?;   // ADD THIS

    meter.meter_function_handles()?;
    meter.meter_struct_handles()?;
    meter.meter_function_defs()?;
    meter.meter_struct_defs()?;

    let used = budget - *meter.balance.borrow();
    Ok(used)
}
```

## Proof of Concept

To demonstrate this vulnerability, create a Move module with numerous variant field instantiations containing deeply nested generic types:

```move
module 0x1::exploit {
    // Define an enum with generic variant fields
    enum MyEnum<T> {
        Variant1 { field: T },
        Variant2 { field: T },
        Variant3 { field: T },
        // ... repeat many times
    }
    
    // Create many instantiations with deeply nested types
    public fun exploit_complexity_1(): MyEnum<vector<vector<vector<vector<u64>>>>> {
        abort 0
    }
    
    public fun exploit_complexity_2(): MyEnum<vector<vector<vector<vector<vector<u64>>>>>> {
        abort 0
    }
    
    // Repeat with different nesting depths and combinations
    // Each function creates entries in variant_field_instantiations table
    // that reference complex type signatures, but these are never metered
    // during module complexity checking
}
```

Compile this module and attempt to publish it. Despite the high complexity hidden in the variant field instantiation table, it will pass the complexity check because those tables are not metered. The module size remains small (passing the blob size check), but the unmetered complexity can cause resource exhaustion during loading.

**Verification steps:**
1. Compile the malicious module with Move compiler v2 (supporting enums)
2. Submit as a module publish transaction
3. Observe that `check_module_complexity()` succeeds despite high hidden complexity
4. Monitor validator memory/CPU usage during module loading
5. Confirm resource exhaustion occurs without hitting complexity limits

### Citations

**File:** third_party/move/move-binary-format/src/check_complexity.rs (L197-207)
```rust
    fn meter_field_instantiations(&self) -> PartialVMResult<()> {
        let field_insts = self.resolver.field_instantiations().ok_or_else(|| {
            PartialVMError::new(StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR)
                .with_message("Can't get field instantiations -- not a module.".to_string())
        })?;

        for field_inst_idx in 0..field_insts.len() {
            self.meter_field_instantiation(FieldInstantiationIndex(field_inst_idx as u16))?;
        }
        Ok(())
    }
```

**File:** third_party/move/move-binary-format/src/check_complexity.rs (L285-287)
```rust
                ImmBorrowVariantFieldGeneric(idx) | MutBorrowVariantFieldGeneric(idx) => {
                    self.meter_variant_field_instantiation(*idx)?;
                },
```

**File:** third_party/move/move-binary-format/src/check_complexity.rs (L401-420)
```rust
pub fn check_module_complexity(module: &CompiledModule, budget: u64) -> PartialVMResult<u64> {
    let meter = BinaryComplexityMeter {
        resolver: BinaryIndexedView::Module(module),
        cached_signature_costs: RefCell::new(BTreeMap::new()),
        balance: RefCell::new(budget),
    };

    meter.meter_signatures()?;
    meter.meter_function_instantiations()?;
    meter.meter_struct_def_instantiations()?;
    meter.meter_field_instantiations()?;

    meter.meter_function_handles()?;
    meter.meter_struct_handles()?;
    meter.meter_function_defs()?;
    meter.meter_struct_defs()?;

    let used = budget - *meter.balance.borrow();
    Ok(used)
}
```

**File:** third_party/move/move-binary-format/src/file_format.rs (L541-544)
```rust
pub struct StructVariantInstantiation {
    pub handle: StructVariantHandleIndex,
    pub type_parameters: SignatureIndex,
}
```

**File:** third_party/move/move-binary-format/src/file_format.rs (L585-588)
```rust
pub struct VariantFieldInstantiation {
    pub handle: VariantFieldHandleIndex,
    pub type_parameters: SignatureIndex,
}
```

**File:** third_party/move/move-binary-format/src/file_format.rs (L3474-3478)
```rust
    /// Since bytecode version 7: variant related handle tables
    pub struct_variant_handles: Vec<StructVariantHandle>,
    pub struct_variant_instantiations: Vec<StructVariantInstantiation>,
    pub variant_field_handles: Vec<VariantFieldHandle>,
    pub variant_field_instantiations: Vec<VariantFieldInstantiation>,
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1554-1559)
```rust
        for (module, blob) in modules.iter().zip(bundle.iter()) {
            // TODO(Gas): Make budget configurable.
            let budget = 2048 + blob.code().len() as u64 * 20;
            move_binary_format::check_complexity::check_module_complexity(module, budget)
                .map_err(|err| err.finish(Location::Undefined))?;
        }
```
