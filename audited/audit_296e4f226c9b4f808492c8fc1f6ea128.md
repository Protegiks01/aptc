# Audit Report

## Title
Missing Storage Integrity Verification in Randomness Generation System Allows Undetected Data Corruption Leading to Validator Crashes

## Summary
The RandStorage trait implementation lacks verification mechanisms to detect contract violations. When CertifiedAugData is loaded from storage during validator recovery, signature verification is skipped, allowing corrupted or maliciously modified data to cause validator panics. This violates the "verify at trust boundaries" security principle and creates a validator availability vulnerability.

## Finding Description

The randomness generation system treats storage as a trusted source, but network messages as untrusted. This asymmetric trust model creates a vulnerability where data integrity violations in storage go undetected until cryptographic operations fail catastrophically.

**Critical Code Paths:**

**Network Message Path (Verified):**
When CertifiedAugData arrives over the network, it undergoes signature verification: [1](#0-0) 

**Storage Recovery Path (Unverified):**
When loading from storage during validator restart, NO signature verification occurs: [2](#0-1) 

The loaded certified data is passed directly to `augment()` which expects cryptographic properties to be valid: [3](#0-2) 

**Panic Trigger:**
If corrupted data is loaded, the cryptographic verification in `derive_apk` fails, causing the `.expect()` to panic: [4](#0-3) 

The `WVUF::augment_pubkey` performs pairing checks that will fail on corrupted delta values, returning an error that propagates up to the `.expect("Add delta should succeed")` call, triggering a panic.

**Attack Scenarios:**

1. **Storage Implementation Bug**: A bug in RandDb or SchemaDB that corrupts serialized CertifiedAugData during write/read operations
2. **BCS Deserialization Fault**: Corruption during binary canonical serialization causing malformed Delta structures  
3. **Filesystem Corruption**: Disk errors or filesystem bugs corrupting database files
4. **External Tampering**: If an attacker gains filesystem access to validator storage, they can modify database files to inject corrupted augmented data
5. **Concurrent Write Race**: Race conditions in storage layer causing partial writes or data corruption

**Exploitation Flow:**

1. Validator receives valid CertifiedAugData from network → verified → saved to storage
2. Storage bug/corruption/tampering modifies the saved data (Delta field)
3. Validator restarts during the same epoch
4. `AugDataStore::new()` loads corrupted data from storage without verification
5. `augment()` attempts to process corrupted delta → `derive_apk()` fails cryptographic checks
6. `.expect()` triggers panic → validator crashes
7. Validator cannot start until storage is manually repaired

**Broken Invariant:**
This violates the **defense-in-depth** security principle and the implied contract that "save then get should return saved data." It also breaks validator **availability guarantees** by allowing storage issues to cause unrecoverable crashes.

## Impact Explanation

**Severity: HIGH** per Aptos bug bounty criteria.

This qualifies as "Validator node slowdowns" and "API crashes" under High Severity ($50,000 category) because:

1. **Validator Availability Loss**: Affected validators cannot restart and participate in consensus until manual intervention
2. **No Automatic Recovery**: The panic occurs during initialization, preventing the validator from operating
3. **Cascading Effect**: If multiple validators experience similar storage corruption (e.g., from a common bug in a storage library update), network liveness could be impacted
4. **Silent Failure Mode**: The corruption goes undetected until restart, making diagnosis difficult

While the issue doesn't directly cause consensus safety violations, it impacts **liveness** and **availability** - critical properties for blockchain operation.

## Likelihood Explanation

**Likelihood: LOW-MEDIUM**

**Factors Increasing Likelihood:**
- Storage system complexity increases bug probability
- BCS serialization bugs could affect all validators running the same code version
- Filesystem corruption, while rare, does occur in production systems
- No monitoring/detection means issues accumulate silently

**Factors Decreasing Likelihood:**
- Requires triggering condition (storage bug or corruption)
- RandDb and InMemRandDb implementations are relatively simple
- BCS is battle-tested serialization format
- Most validators run on reliable infrastructure

The likelihood increases significantly if there's a latent bug in the storage layer or serialization code that hasn't been discovered yet.

## Recommendation

**Immediate Fix: Add Signature Verification on Storage Load**

Modify `AugDataStore::new()` to verify signatures when loading certified data: [2](#0-1) 

**Proposed Fix:**
```rust
let all_certified_data = db.get_all_certified_aug_data().unwrap_or_default();
let (to_remove, certified_data) =
    Self::filter_by_epoch(epoch, all_certified_data.into_iter());
if let Err(e) = db.remove_certified_aug_data(to_remove) {
    error!("[AugDataStore] failed to remove certified aug data: {:?}", e);
}

// Add verification for data loaded from storage
let mut verified_certified_data = Vec::new();
for (id, certified_data) in certified_data {
    // Verify signatures before accepting data from storage
    if let Err(e) = certified_data.verify(&config.validator) {
        error!(
            "[AugDataStore] Corrupted certified aug data from storage for {:?}: {:?}. Skipping.",
            id, e
        );
        // Remove corrupted data from storage
        if let Err(rm_err) = db.remove_certified_aug_data(vec![certified_data.clone()]) {
            error!("[AugDataStore] Failed to remove corrupted data: {:?}", rm_err);
        }
        continue;
    }
    verified_certified_data.push((id, certified_data));
}

// Use verified data
for (_, certified_data) in &verified_certified_data {
    certified_data
        .data()
        .augment(&config, &fast_config, certified_data.author());
}
```

**Additional Defensive Measures:**

1. **Post-Save Verification**: After saving data, immediately read it back and verify integrity
2. **Checksums**: Add integrity checksums to detect corruption
3. **Graceful Error Handling**: Replace `.expect()` with proper error handling that logs and continues
4. **Storage Health Checks**: Periodic background verification of stored data integrity

## Proof of Concept

```rust
#[cfg(test)]
mod storage_corruption_test {
    use super::*;
    use crate::rand::rand_gen::storage::in_memory::InMemRandDb;
    use crate::rand::rand_gen::types::{AugmentedData, CertifiedAugData, AugData};
    
    #[test]
    #[should_panic(expected = "Add delta should succeed")]
    fn test_corrupted_storage_causes_panic() {
        // Setup: Create a valid CertifiedAugData
        let epoch = 5;
        let storage = Arc::new(InMemRandDb::<AugmentedData>::new());
        
        // Simulate: Save valid certified aug data
        let valid_certified_data = create_valid_certified_aug_data(epoch);
        storage.save_certified_aug_data(&valid_certified_data).unwrap();
        
        // Corrupt: Manually corrupt the delta in storage
        // (In real scenario, this would be caused by storage bug or filesystem corruption)
        let corrupted_certified_data = create_corrupted_certified_aug_data(epoch);
        storage.save_certified_aug_data(&corrupted_certified_data).unwrap();
        
        // Trigger: Create new AugDataStore which loads from storage
        // This will panic when it tries to augment with corrupted delta
        let _aug_data_store = AugDataStore::new(
            epoch,
            Arc::new(create_test_signer()),
            create_test_rand_config(),
            None,
            storage,
        );
        
        // Expected: Panic with "Add delta should succeed"
        // Actual: Validator crashes, cannot restart
    }
    
    fn create_corrupted_certified_aug_data(epoch: u64) -> CertifiedAugData<AugmentedData> {
        // Create CertifiedAugData with corrupted Delta that will fail pairing checks
        // Implementation details omitted for brevity
        unimplemented!()
    }
}
```

**Notes:**
- Storage is treated as trusted, but should be verified like network data
- The asymmetric trust model (verify network, trust storage) is a design flaw
- Multiple validators could be affected simultaneously if a common bug corrupts storage
- Manual intervention required for recovery, no automatic healing mechanism

### Citations

**File:** consensus/src/rand/rand_gen/network_messages.rs (L50-51)
```rust
            RandMessage::CertifiedAugData(certified_aug_data) => {
                certified_aug_data.verify(&epoch_state.verifier)
```

**File:** consensus/src/rand/rand_gen/aug_data_store.rs (L57-71)
```rust
        let all_certified_data = db.get_all_certified_aug_data().unwrap_or_default();
        let (to_remove, certified_data) =
            Self::filter_by_epoch(epoch, all_certified_data.into_iter());
        if let Err(e) = db.remove_certified_aug_data(to_remove) {
            error!(
                "[AugDataStore] failed to remove certified aug data: {:?}",
                e
            );
        }

        for (_, certified_data) in &certified_data {
            certified_data
                .data()
                .augment(&config, &fast_config, certified_data.author());
        }
```

**File:** consensus/src/rand/rand_gen/types.rs (L178-194)
```rust
    fn augment(
        &self,
        rand_config: &RandConfig,
        fast_rand_config: &Option<RandConfig>,
        author: &Author,
    ) {
        let AugmentedData { delta, fast_delta } = self;
        rand_config
            .add_certified_delta(author, delta.clone())
            .expect("Add delta should succeed");

        if let (Some(config), Some(fast_delta)) = (fast_rand_config, fast_delta) {
            config
                .add_certified_delta(author, fast_delta.clone())
                .expect("Add delta for fast path should succeed");
        }
    }
```

**File:** consensus/src/rand/rand_gen/types.rs (L656-665)
```rust
    fn derive_apk(&self, peer: &Author, delta: Delta) -> anyhow::Result<APK> {
        let apk = WVUF::augment_pubkey(&self.vuf_pp, self.get_pk_share(peer).clone(), delta)?;
        Ok(apk)
    }

    pub fn add_certified_delta(&self, peer: &Author, delta: Delta) -> anyhow::Result<()> {
        let apk = self.derive_apk(peer, delta)?;
        self.add_certified_apk(peer, apk)?;
        Ok(())
    }
```
