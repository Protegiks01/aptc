# Audit Report

## Title
Proof Verification Bypass in DbStateView.get_state_slot() via Silent Failure Fallback

## Summary
The `get_state_slot()` wrapper in `DbStateView` does not ensure proof verification occurred. When proof retrieval fails, verification is silently skipped and unverified data is returned, violating the security guarantee of "verified state views."

## Finding Description

The `get()` method in `DbStateView` implements a proof verification bypass through a silent failure mechanism. [1](#0-0) 

When `maybe_verify_against_state_root_hash` is set (via `verified_state_view_at_version()`), the code attempts to retrieve a Merkle proof and verify it. However, if `get_state_value_with_proof_by_version()` returns an error, the verification is silently skipped using the `if let Ok(...)` pattern. The function then proceeds to return unverified data from `get_state_value_with_version_by_version()`.

This creates a critical window where:
- The Merkle tree has been pruned (default: 100K transaction window) [2](#0-1) 
- The KV database still retains the values (default: 150M transaction window) [3](#0-2) 
- Proof verification is impossible but value retrieval succeeds

The two database backends use different implementations that query separate storage systems: [4](#0-3) [5](#0-4) 

This means there's a ~150M transaction window where proofs are unavailable but values exist, causing automatic proof bypass.

The `get_state_slot()` wrapper blindly trusts these results without indicating verification status: [6](#0-5) 

## Impact Explanation

**Severity: High**

This breaks the **State Consistency** invariant (#4): "State transitions must be atomic and verifiable via Merkle proofs."

When `verified_state_view_at_version()` is used, callers expect cryptographic proof that returned state values match the committed state root hash. [7](#0-6) 

By silently bypassing verification, the system violates this trust assumption. An attacker who can:
1. Manipulate database state during the pruning window
2. Corrupt KV database entries while Merkle tree is pruned
3. Exploit race conditions during state updates

Could cause validators or clients to accept invalid state without cryptographic verification, potentially leading to consensus divergence or state inconsistencies requiring manual intervention.

While current production usage appears limited to test contexts, the API is public and designed for verified state access, making this a **significant protocol violation** qualifying for High severity per the bug bounty criteria.

## Likelihood Explanation

**Likelihood: Medium to High**

This vulnerability automatically activates whenever:
1. State is requested at versions older than the Merkle pruning window (100K txns) but within the KV pruning window (150M txns)
2. The `verified_state_view_at_version()` API is used
3. Proof retrieval fails for any reason (pruning, corruption, buffered state)

The 150M transaction pruning gap is a standard configuration, making this exploitable on any production node with normal pruning settings. The TODO comments indicate this is a known limitation: [8](#0-7) 

## Recommendation

**Fix: Fail explicitly instead of silently bypassing verification**

Change the `get()` method to return an error when proof verification is required but proofs are unavailable:

```rust
fn get(&self, key: &StateKey) -> StateViewResult<Option<(Version, StateValue)>> {
    if let Some(version) = self.version {
        if let Some(root_hash) = self.maybe_verify_against_state_root_hash {
            // When verification is required, proof retrieval failure should be an error
            let (value, proof) = self.db.get_state_value_with_proof_by_version(key, version)?;
            proof.verify(root_hash, *key.crypto_hash_ref(), value.as_ref())?;
        }
        Ok(self
            .db
            .get_state_value_with_version_by_version(key, version)?)
    } else {
        Ok(None)
    }
}
```

Alternatively, return verification status to the caller so they can make informed decisions about whether to trust unverified data.

## Proof of Concept

```rust
// Reproduction steps:
// 1. Configure node with standard pruning (Merkle: 100K, KV: 150M)
// 2. Execute 200K transactions to trigger Merkle pruning
// 3. Request verified state view at version 50K (within KV window, outside Merkle window)
// 4. Call get_state_slot() - verification silently skipped, unverified data returned

use aptos_storage_interface::state_store::state_view::db_state_view::VerifiedStateViewAtVersion;

#[test]
fn test_proof_bypass_via_pruning() {
    let db = setup_test_db(); // Standard node with pruning enabled
    
    // Execute enough transactions to prune Merkle tree
    execute_transactions(db, 200_000);
    
    let ledger_info = db.get_latest_ledger_info().unwrap();
    
    // Request verified state at pruned version (within KV window)
    let state_view = db.verified_state_view_at_version(Some(50_000), &ledger_info).unwrap();
    
    // This should fail (proofs unavailable) but instead returns unverified data
    let state_slot = state_view.get_state_slot(&test_key).unwrap();
    
    // Unverified data returned without any indication verification was skipped
    assert!(state_slot.is_occupied()); // Passes, but data is unverified!
}
```

## Notes

The TODO comments acknowledge this is a known limitation for "buffered state," but the current implementation silently bypasses verification for ALL failure cases (pruning, corruption, errors), not just buffered state. This creates a much broader attack surface than intended and violates the security contract of "verified" state views.

### Citations

**File:** storage/storage-interface/src/state_store/state_view/db_state_view.rs (L21-23)
```rust
    /// DB doesn't support returning proofs for buffered state, so only optionally verify proof.
    /// TODO: support returning state proof for buffered state.
    maybe_verify_against_state_root_hash: Option<HashValue>,
```

**File:** storage/storage-interface/src/state_store/state_view/db_state_view.rs (L27-46)
```rust
    fn get(&self, key: &StateKey) -> StateViewResult<Option<(Version, StateValue)>> {
        if let Some(version) = self.version {
            if let Some(root_hash) = self.maybe_verify_against_state_root_hash {
                // TODO(aldenhu): sample-verify proof inside DB
                // DB doesn't support returning proofs for buffered state, so only optionally
                // verify proof.
                // TODO: support returning state proof for buffered state.
                if let Ok((value, proof)) =
                    self.db.get_state_value_with_proof_by_version(key, version)
                {
                    proof.verify(root_hash, *key.crypto_hash_ref(), value.as_ref())?;
                }
            }
            Ok(self
                .db
                .get_state_value_with_version_by_version(key, version)?)
        } else {
            Ok(None)
        }
    }
```

**File:** storage/storage-interface/src/state_store/state_view/db_state_view.rs (L62-64)
```rust
    fn get_state_slot(&self, state_key: &StateKey) -> StateViewResult<StateSlot> {
        Ok(StateSlot::from_db_get(self.get(state_key)?))
    }
```

**File:** storage/storage-interface/src/state_store/state_view/db_state_view.rs (L116-138)
```rust
    fn verified_state_view_at_version(
        &self,
        version: Option<Version>,
        ledger_info: &LedgerInfo,
    ) -> StateViewResult<DbStateView> {
        let db = self.clone();

        if let Some(version) = version {
            let txn_with_proof =
                db.get_transaction_by_version(version, ledger_info.version(), false)?;
            txn_with_proof.verify(ledger_info)?;

            let state_root_hash = txn_with_proof
                .proof
                .transaction_info
                .state_checkpoint_hash()
                .ok_or_else(|| StateViewError::NotFound("state_checkpoint_hash".to_string()))?;

            Ok(DbStateView {
                db,
                version: Some(version),
                maybe_verify_against_state_root_hash: Some(state_root_hash),
            })
```

**File:** storage/README.md (L100-103)
```markdown
      enable: true
      prune_window: 150000000
      batch_size: 500
      user_pruning_window_offset: 200000
```

**File:** storage/README.md (L107-110)
```markdown
    state_merkle_pruner_config:
      enable: true
      prune_window: 100000
      batch_size: 1000
```

**File:** storage/aptosdb/src/state_store/mod.rs (L175-182)
```rust
    fn get_state_value_with_version_by_version(
        &self,
        state_key: &StateKey,
        version: Version,
    ) -> Result<Option<(Version, StateValue)>> {
        self.state_kv_db
            .get_state_value_with_version_by_version(state_key, version)
    }
```

**File:** storage/aptosdb/src/state_store/mod.rs (L209-236)
```rust
    fn get_state_value_with_proof_by_version_ext(
        &self,
        key_hash: &HashValue,
        version: Version,
        root_depth: usize,
        use_hot_state: bool,
    ) -> Result<(Option<StateValue>, SparseMerkleProofExt)> {
        let db = if use_hot_state {
            if self.state_merkle_db.sharding_enabled() {
                self.hot_state_merkle_db
                    .as_ref()
                    .ok_or(AptosDbError::HotStateError)?
            } else {
                // Unsharded unit tests still rely on this.
                &self.state_merkle_db
            }
        } else {
            &self.state_merkle_db
        };
        let (leaf_data, proof) = db.get_with_proof_ext(key_hash, version, root_depth)?;
        Ok((
            match leaf_data {
                Some((_val_hash, (key, ver))) => Some(self.expect_value_by_version(&key, ver)?),
                None => None,
            },
            proof,
        ))
    }
```
