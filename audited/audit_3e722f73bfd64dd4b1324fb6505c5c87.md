# Audit Report

## Title
FaucetClient Indefinite Hang on Malicious Transaction Expiration - Client Denial of Service

## Summary
The `wait_for_signed_transaction` function in `FaucetClient` lacks an absolute timeout mechanism, allowing a malicious or misconfigured faucet service to cause indefinite client hangs by returning transactions with far-future expiration timestamps.

## Finding Description
The `FaucetClient.fund()` function calls `wait_for_signed_transaction()` on transactions returned by the faucet service without validating the transaction's expiration timestamp. [1](#0-0) 

The `wait_for_signed_transaction` implementation passes `None` for the `timeout_from_call` parameter, relying solely on transaction expiration-based timeouts. [2](#0-1) 

The underlying `wait_for_transaction_by_hash_inner` function contains an infinite loop that only exits when: (1) transaction succeeds, (2) transaction expires, or (3) server lag timeout triggers (expiration + 60 seconds). [3](#0-2) 

Since regular transactions using sequence numbers have no maximum expiration limit in the Aptos protocol (only orderless transactions are limited to 100 seconds), [4](#0-3)  a faucet service could return a transaction with expiration set to year 2038 or beyond, causing the client to wait for decades.

**Attack Scenario:**
1. Attacker operates malicious faucet service or compromises existing faucet
2. Client connects to faucet and requests funding
3. Faucet returns valid signed transaction with `expiration_timestamp_secs` set to 2147483647 (year 2038)
4. Client calls `wait_for_signed_transaction` which enters infinite polling loop
5. Client hangs for ~14 years (until expiration + 60s timeout)
6. Service using FaucetClient becomes unavailable

## Impact Explanation
This qualifies as **High severity** per the bug bounty criteria for "API crashes" and service availability issues. While not directly affecting blockchain consensus, this impacts:

- **Development tooling**: CLI tools and SDKs using FaucetClient become unresponsive
- **Test infrastructure**: CI/CD pipelines and automated testing hang indefinitely
- **Account creation services**: Production services relying on faucet for account provisioning experience DoS
- **API availability**: Any service integrating FaucetClient can be remotely disabled

The faucet service itself uses `submit_and_wait` internally, which also calls `wait_for_signed_transaction`, meaning a misconfigured faucet could DoS itself. [5](#0-4) 

## Likelihood Explanation
**Likelihood: Medium**

Requires either:
- **Malicious faucet operator**: Attacker runs fake faucet service with malicious transaction expiration times
- **Compromised faucet**: Legitimate faucet service is compromised
- **Configuration error**: Faucet misconfigured with extremely long `transaction_expiration_secs` (default is 25s) [6](#0-5) 

The attack is trivial to execute once attacker controls faucet endpoint. Many testnets allow anyone to run faucets, and users may connect to untrusted third-party faucets.

## Recommendation
Add an absolute maximum timeout for `wait_for_signed_transaction` calls in FaucetClient:

```rust
// In faucet.rs fund() function:
const MAX_FAUCET_WAIT_TIMEOUT: Duration = Duration::from_secs(120); // 2 minutes max

self.rest_client
    .wait_for_transaction_by_hash(
        txns[0].committed_hash(),
        txns[0].expiration_timestamp_secs(),
        Some(DEFAULT_MAX_SERVER_LAG_WAIT_DURATION),
        Some(MAX_FAUCET_WAIT_TIMEOUT), // Add absolute timeout
    )
    .await
    .map_err(FaucetClientError::unknown)?;
```

Additionally, validate transaction expiration timestamps before waiting:

```rust
// Validate expiration is reasonable (within next hour)
let max_acceptable_expiration = aptos_infallible::duration_since_epoch().as_secs() + 3600;
if txns[0].expiration_timestamp_secs() > max_acceptable_expiration {
    return Err(anyhow::anyhow!("Faucet returned transaction with unreasonable expiration time").into());
}
```

## Proof of Concept

```rust
// test_malicious_faucet_timeout.rs
#[tokio::test]
async fn test_malicious_faucet_expiration_dos() {
    use aptos_rest_client::FaucetClient;
    use aptos_types::transaction::{RawTransaction, SignedTransaction};
    use aptos_crypto::{ed25519::Ed25519PrivateKey, PrivateKey, Uniform};
    use std::time::Duration;
    use tokio::time::timeout;
    
    // Setup mock faucet server that returns transaction with far-future expiration
    let mock_server = httpmock::MockServer::start();
    let mock = mock_server.mock(|when, then| {
        when.method("POST").path("/mint");
        then.status(200)
            .body({
                // Create transaction with expiration in year 2038
                let future_expiration = 2147483647u64; 
                let key = Ed25519PrivateKey::generate_for_testing();
                let txn = RawTransaction::new(
                    AccountAddress::random(),
                    0,
                    TransactionPayload::Script(Script::new(vec![], vec![], vec![])),
                    100_000,
                    1,
                    future_expiration, // Far future expiration
                    ChainId::test(),
                );
                let signed = SignedTransaction::new(txn, key.public_key(), key.sign(&txn).unwrap());
                hex::encode(bcs::to_bytes(&vec![signed]).unwrap())
            });
    });
    
    let faucet_client = FaucetClient::new(
        mock_server.base_url().parse().unwrap(),
        "http://localhost:8080".parse().unwrap()
    );
    
    // This should timeout quickly but will hang for years without fix
    let result = timeout(
        Duration::from_secs(5),
        faucet_client.fund(AccountAddress::random(), 1000)
    ).await;
    
    // Without fix: result is Err(Elapsed) - timeout triggered because client hung
    // With fix: result is Err containing reasonable error about expiration
    assert!(result.is_err(), "Client should not hang indefinitely");
}
```

### Citations

**File:** crates/aptos-rest-client/src/faucet.rs (L103-107)
```rust
        self.rest_client
            .wait_for_signed_transaction(&txns[0])
            .await
            .map_err(FaucetClientError::unknown)?;

```

**File:** crates/aptos-rest-client/src/lib.rs (L663-669)
```rust
    pub async fn submit_and_wait(
        &self,
        txn: &SignedTransaction,
    ) -> AptosResult<Response<Transaction>> {
        self.submit(txn).await?;
        self.wait_for_signed_transaction(txn).await
    }
```

**File:** crates/aptos-rest-client/src/lib.rs (L711-723)
```rust
    pub async fn wait_for_signed_transaction(
        &self,
        transaction: &SignedTransaction,
    ) -> AptosResult<Response<Transaction>> {
        let expiration_timestamp = transaction.expiration_timestamp_secs();
        self.wait_for_transaction_by_hash(
            transaction.committed_hash(),
            expiration_timestamp,
            Some(DEFAULT_MAX_SERVER_LAG_WAIT_DURATION),
            None,
        )
        .await
    }
```

**File:** crates/aptos-rest-client/src/lib.rs (L767-871)
```rust
        loop {
            let mut chain_timestamp_usecs = None;
            match fetch(hash).await {
                Ok(WaitForTransactionResult::Success(result)) => {
                    return Ok(result);
                },
                Ok(WaitForTransactionResult::FailedExecution(vm_status)) => {
                    return Err(anyhow!(
                        "Transaction committed on chain, but failed execution: {}",
                        vm_status
                    ))?;
                },
                Ok(WaitForTransactionResult::Pending(state)) => {
                    reached_mempool = true;
                    if expiration_timestamp_secs <= state.timestamp_usecs / 1_000_000 {
                        return Err(anyhow!("Transaction expired. It is guaranteed it will not be committed on chain.").into());
                    }
                    chain_timestamp_usecs = Some(state.timestamp_usecs);
                },
                Ok(WaitForTransactionResult::NotFound(error)) => {
                    if let RestError::Api(aptos_error_response) = error {
                        if let Some(state) = aptos_error_response.state {
                            if expiration_timestamp_secs <= state.timestamp_usecs / 1_000_000 {
                                if reached_mempool {
                                    return Err(anyhow!("Used to be pending and now not found. Transaction expired. It is guaranteed it will not be committed on chain.").into());
                                } else {
                                    // We want to know whether we ever got Pending state from the mempool,
                                    // to warn in case we didn't.
                                    // Unless we are calling endpoint that is a very large load-balanced pool of nodes,
                                    // we should always see pending after submitting a transaction.
                                    // (i.e. if we hit the node we submitted a transaction to,
                                    // it shouldn't return NotFound on the first call)
                                    //
                                    // At the end, when the expiration happens, we might get NotFound or Pending
                                    // based on whether GC run on the full node to remove expired transaction,
                                    // so that information is not useful. So we need to keep this variable as state.
                                    return Err(anyhow!("Transaction expired, without being seen in mempool. It is guaranteed it will not be committed on chain.").into());
                                }
                            }
                            chain_timestamp_usecs = Some(state.timestamp_usecs);
                        }
                    } else {
                        return Err(error);
                    }
                    sample!(
                        SampleRate::Duration(Duration::from_secs(30)),
                        debug!(
                            "Cannot yet find transaction in mempool on {:?}, continuing to wait.",
                            self.path_prefix_string(),
                        )
                    );
                },
                Err(err) => {
                    debug!("Fetching error, will retry: {}", err);
                },
            }

            if let Some(max_server_lag_wait_duration) = max_server_lag_wait {
                if aptos_infallible::duration_since_epoch().as_secs()
                    > expiration_timestamp_secs + max_server_lag_wait_duration.as_secs()
                {
                    return Err(anyhow!(
                        "Ledger on endpoint ({}) is more than {}s behind current time, timing out waiting for the transaction. Warning, transaction ({}) might still succeed.",
                        self.path_prefix_string(),
                        max_server_lag_wait_duration.as_secs(),
                        hash,
                    ).into());
                }
            }

            let elapsed = start.elapsed();
            if let Some(timeout_duration) = timeout_from_call {
                if elapsed > timeout_duration {
                    return Err(anyhow!(
                        "Timeout of {}s after calling wait_for_transaction reached. Warning, transaction ({}) might still succeed.",
                        timeout_duration.as_secs(),
                        hash,
                    ).into());
                }
            }

            if elapsed.as_secs() > 30 {
                sample!(
                    SampleRate::Duration(Duration::from_secs(30)),
                    debug!(
                        "Continuing to wait for transaction {}, ledger on endpoint ({}) is {}",
                        hash,
                        self.path_prefix_string(),
                        if let Some(timestamp_usecs) = chain_timestamp_usecs {
                            format!(
                                "{}s behind current time",
                                aptos_infallible::duration_since_epoch()
                                    .saturating_sub(Duration::from_micros(timestamp_usecs))
                                    .as_secs()
                            )
                        } else {
                            "unreachable".to_string()
                        },
                    )
                );
            }

            tokio::time::sleep(DEFAULT_DELAY).await;
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/transaction_validation.move (L126-142)
```text
    fun prologue_common(
        sender: &signer,
        gas_payer: &signer,
        replay_protector: ReplayProtector,
        txn_authentication_key: Option<vector<u8>>,
        txn_gas_price: u64,
        txn_max_gas_units: u64,
        txn_expiration_time: u64,
        chain_id: u8,
        is_simulation: bool,
    ) {
        let sender_address = signer::address_of(sender);
        let gas_payer_address = signer::address_of(gas_payer);
        assert!(
            timestamp::now_seconds() < txn_expiration_time,
            error::invalid_argument(PROLOGUE_ETRANSACTION_EXPIRED),
        );
```

**File:** crates/aptos-faucet/core/src/funder/common.rs (L161-163)
```rust
    fn default_transaction_expiration_secs() -> u64 {
        25
    }
```
