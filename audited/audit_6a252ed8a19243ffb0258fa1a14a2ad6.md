# Audit Report

## Title
Message Size Limit Bypass via Fragment Assembly in Network Streaming Protocol

## Summary
The network streaming protocol fails to enforce the `max_message_size` limit during fragment assembly, allowing malicious peers to construct messages that exceed the configured maximum size by up to `max_frame_size` bytes. This violates the Resource Limits invariant and can lead to memory exhaustion attacks on validator nodes.

## Finding Description

The vulnerability exists in the fragment assembly logic of `InboundStream` where fragments are appended to the header message without validating the total assembled message size.

The network layer defines `max_message_size` (default 64 MiB) and `max_frame_size` (default 4 MiB) to limit message sizes. [1](#0-0) 

When a `Peer` is created, `max_fragments` is calculated as `max_message_size / max_frame_size`. [2](#0-1) 

During legitimate outbound streaming, `OutboundStream` validates that message size does not exceed `max_message_size` before streaming. [3](#0-2) 

However, on the inbound side, `InboundStream::new()` only validates that `num_fragments` does not exceed `max_fragments`, but does NOT validate the actual size of the header's raw data. [4](#0-3) 

When fragments are appended, the code mutates the message by appending raw data without any size checks. [5](#0-4) 

**Attack Scenario:**
1. Malicious authenticated peer sends a `StreamHeader` with `num_fragments = max_fragments` and raw data sized close to `max_frame_size` (constrained only by frame limits)
2. Header passes validation since `num_fragments <= max_fragments`
3. Attacker sends `max_fragments` fragments, each with raw data sized close to `max_frame_size`
4. Total assembled message size = `~max_frame_size + (max_fragments * ~max_frame_size) = ~(max_fragments + 1) * max_frame_size`
5. Since `max_fragments = max_message_size / max_frame_size`, the total becomes `~max_message_size + max_frame_size`

With default configuration:
- Header raw data: ~4 MiB
- 16 fragments Ã— ~4 MiB each = ~64 MiB
- **Total: ~68 MiB, exceeding the 64 MiB limit by 4 MiB**

The assembled message is then passed to handlers without re-validation. [6](#0-5) 

## Impact Explanation

This vulnerability has **Medium Severity** impact:

1. **Resource Exhaustion**: Malicious peers can force validator nodes to allocate memory exceeding configured limits, potentially causing out-of-memory conditions or degraded performance
2. **State Inconsistencies**: If downstream handlers assume messages respect `max_message_size`, oversized messages could trigger buffer overflows or undefined behavior
3. **DoS Vector**: Multiple connections sending oversized messages could amplify memory exhaustion

The impact is mitigated by:
- The excess is limited to `max_frame_size` (6.25% over limit with defaults)
- Attacker must be an authenticated peer (requires compromised validator or node key)
- Frame-level limits prevent unbounded growth

This violates the **Resource Limits** invariant: "All operations must respect gas, storage, and computational limits."

## Likelihood Explanation

**Likelihood: Medium**

Requirements for exploitation:
- Attacker must establish an authenticated Noise protocol connection (requires valid peer credentials)
- Attacker needs to be a compromised validator node, malicious full node, or holder of stolen peer keys
- Attack is easily automated and requires no complex timing or race conditions

The vulnerability is deterministic and reliably exploitable once an authenticated connection is established. However, the attacker barrier (requiring authentication) reduces likelihood compared to unauthenticated network attacks.

## Recommendation

Add total message size validation during fragment assembly. Modify `InboundStream` to track accumulated size and reject fragments that would exceed `max_message_size`:

```rust
pub struct InboundStream {
    request_id: u32,
    num_fragments: u8,
    received_fragment_id: u8,
    message: NetworkMessage,
    accumulated_size: usize,  // Add this field
    max_message_size: usize,  // Add this field
}

impl InboundStream {
    fn new(header: StreamHeader, max_fragments: usize, max_message_size: usize) -> anyhow::Result<Self> {
        // ... existing validation ...
        
        let initial_size = header_message.data_len();
        ensure!(
            initial_size <= max_message_size,
            "Header message size {} exceeds max message size {}!",
            initial_size,
            max_message_size
        );
        
        Ok(Self {
            request_id: header.request_id,
            num_fragments: header_num_fragments,
            received_fragment_id: 0,
            message: header_message,
            accumulated_size: initial_size,
            max_message_size,
        })
    }
    
    fn append_fragment(&mut self, mut fragment: StreamFragment) -> anyhow::Result<bool> {
        // ... existing fragment validation ...
        
        // Check that appending this fragment won't exceed max_message_size
        let new_size = self.accumulated_size.checked_add(fragment.raw_data.len())
            .ok_or_else(|| anyhow::anyhow!("Message size overflow"))?;
        ensure!(
            new_size <= self.max_message_size,
            "Fragment would cause message size {} to exceed max {}!",
            new_size,
            self.max_message_size
        );
        
        // Append the fragment data
        let raw_data = &mut fragment.raw_data;
        match &mut self.message {
            // ... existing append logic ...
        }
        
        self.accumulated_size = new_size;
        
        // ... existing completion check ...
    }
}
```

Update `InboundStreamBuffer::new()` to pass `max_message_size` parameter, and propagate it through the call chain from `Peer::new()`.

## Proof of Concept

```rust
#[cfg(test)]
mod test_size_bypass {
    use super::*;
    
    #[test]
    fn test_message_size_limit_bypass() {
        // Configuration mimicking production defaults
        let max_frame_size = 4 * 1024 * 1024; // 4 MiB
        let max_message_size = 64 * 1024 * 1024; // 64 MiB
        let max_fragments = max_message_size / max_frame_size; // = 16
        
        // Create header with maximum raw data (accounting for serialization overhead)
        let header_data_size = max_frame_size - 1024; // Leave room for metadata
        let mut inbound_stream_buffer = InboundStreamBuffer::new(max_fragments);
        
        let stream_header = StreamHeader {
            request_id: 1,
            num_fragments: max_fragments as u8,
            message: NetworkMessage::DirectSendMsg(DirectSendMsg {
                protocol_id: ProtocolId::ConsensusRpcBcs,
                priority: 0,
                raw_msg: vec![0u8; header_data_size],
            }),
        };
        
        // Header should be accepted (num_fragments = 16 <= max_fragments = 16)
        assert!(inbound_stream_buffer.new_stream(stream_header).is_ok());
        
        // Send maximum-sized fragments
        let fragment_data_size = max_frame_size - 1024;
        let mut total_size = header_data_size;
        
        for fragment_id in 1..=max_fragments as u8 {
            let fragment = StreamFragment {
                request_id: 1,
                fragment_id,
                raw_data: vec![0u8; fragment_data_size],
            };
            
            let result = inbound_stream_buffer.append_fragment(fragment);
            total_size += fragment_data_size;
            
            if fragment_id == max_fragments as u8 {
                // Stream should complete
                assert!(result.is_ok());
                let message = result.unwrap();
                assert!(message.is_some());
                
                // VULNERABILITY: Total size exceeds max_message_size
                assert!(total_size > max_message_size);
                println!("Assembled message size: {} bytes", total_size);
                println!("Exceeds limit by: {} bytes", total_size - max_message_size);
                // Expected output:
                // Assembled message size: ~68,157,440 bytes (68 MiB)
                // Exceeds limit by: ~4,157,440 bytes (4 MiB)
            }
        }
    }
}
```

This PoC demonstrates that with the current implementation, a malicious peer can construct messages exceeding `max_message_size` by up to `max_frame_size`, violating the configured resource limits and potentially causing memory exhaustion on validator nodes.

### Citations

**File:** config/src/config/network_config.rs (L49-50)
```rust
pub const MAX_FRAME_SIZE: usize = 4 * 1024 * 1024; /* 4 MiB large messages will be chunked into multiple frames and streamed */
pub const MAX_MESSAGE_SIZE: usize = 64 * 1024 * 1024; /* 64 MiB */
```

**File:** network/framework/src/peer/mod.rs (L168-168)
```rust
        let max_fragments = max_message_size / max_frame_size;
```

**File:** network/framework/src/peer/mod.rs (L551-554)
```rust
            StreamMessage::Fragment(fragment) => {
                if let Some(message) = self.inbound_stream.append_fragment(fragment)? {
                    self.handle_inbound_network_message(message)?;
                }
```

**File:** network/framework/src/protocols/stream/mod.rs (L144-153)
```rust
        // Verify the number of fragments specified in the header
        let header_num_fragments = header.num_fragments;
        ensure!(
            header_num_fragments > 0,
            "Stream header must specify at least one fragment!"
        );
        ensure!(
            (header_num_fragments as usize) <= max_fragments,
            "Stream header exceeds max fragments limit!"
        );
```

**File:** network/framework/src/protocols/stream/mod.rs (L200-209)
```rust
        // Append the fragment data to the message
        let raw_data = &mut fragment.raw_data;
        match &mut self.message {
            NetworkMessage::Error(_) => {
                panic!("StreamHeader for NetworkMessage::Error(_) should be rejected!")
            },
            NetworkMessage::RpcRequest(request) => request.raw_request.append(raw_data),
            NetworkMessage::RpcResponse(response) => response.raw_response.append(raw_data),
            NetworkMessage::DirectSendMsg(message) => message.raw_msg.append(raw_data),
        }
```

**File:** network/framework/src/protocols/stream/mod.rs (L266-273)
```rust
        // Verify that the message size is within limits
        let message_data_len = message.data_len();
        ensure!(
            message_data_len <= self.max_message_size,
            "Message length {} exceeds max message size {}!",
            message_data_len,
            self.max_message_size,
        );
```
