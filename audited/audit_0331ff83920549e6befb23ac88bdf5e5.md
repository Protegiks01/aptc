# Audit Report

## Title
Consensus Sync Request State Corruption via Arc Replacement Pattern Causing Lost Callback Responses

## Summary
The state sync driver uses an incorrect Arc replacement pattern when handling new consensus sync requests, causing previous request callbacks to be dropped without responses. This violates the consensus-state sync protocol invariant that every request receives exactly one response, degrading validator synchronization performance.

## Finding Description

The vulnerability exists in the `ConsensusNotificationHandler` which manages consensus sync request state. When a new sync request arrives, the code creates a completely new `Arc<Mutex<Option<ConsensusSyncRequest>>>` instead of updating the contents of the existing Arc. [1](#0-0) [2](#0-1) 

Each consensus sync request contains a oneshot callback channel that must receive exactly one response: [3](#0-2) [4](#0-3) 

**The Bug Flow:**

1. Consensus sends sync request Request_A with callback_A via `sync_to_target()` or `sync_for_duration()`
2. Driver calls `initialize_sync_target_request()` which creates `Arc_A = Arc::new(Mutex::new(Some(Request_A)))` at line 315 (or line 256 for duration)
3. Driver sets `self.consensus_sync_request = Arc_A`
4. Node begins syncing toward Request_A's target
5. Before completion, consensus sends Request_B with callback_B (during epoch transitions or observer handoffs)
6. Driver creates `Arc_B = Arc::new(Mutex::new(Some(Request_B)))`
7. **BUG**: Driver sets `self.consensus_sync_request = Arc_B`, completely replacing the reference to Arc_A
8. If no other component holds long-lived Arc_A references, it gets dropped
9. Request_A's callback_A (oneshot::Sender) is dropped without ever sending a response
10. Consensus awaiting callback_A receives `RecvError`, returned as `Error::UnexpectedErrorEncountered`

The handlers that receive these notifications do not check for existing active requests before creating new ones: [5](#0-4) [6](#0-5) 

The issue is compounded by the state checking logic in `check_sync_request_progress()` which retrieves the current Arc but then later calls `handle_satisfied_sync_request()` that locks `self.consensus_sync_request` - which may now point to a different Arc if replacement occurred between the check and response: [7](#0-6) 

When the oneshot sender is dropped, the receiver gets an error: [8](#0-7) 

## Impact Explanation

**High Severity** - This qualifies as "Validator Node Slowdowns" and "Significant protocol violations" under the Aptos bug bounty program:

1. **Protocol Violation**: Violates the fundamental consensus-state sync contract that every request receives exactly one proper response. Consensus receives unexpected `Error::UnexpectedErrorEncountered` instead of proper sync completion responses.

2. **Consensus Coordination Failure**: Breaks the synchronization mechanism between consensus and state sync. When consensus receives unexpected errors instead of completion confirmations, it may retry or enter degraded operation modes.

3. **Validator Performance Impact**: Can cause validators to fail proper sync coordination, leading to slowdowns and degraded block production performance.

4. **Cascading Failures**: If multiple validators experience this issue during critical periods (epoch transitions, network partitions), it could amplify consensus delays and reduce network throughput.

While this doesn't cause permanent fund loss or consensus safety violations (different state roots), it significantly degrades network performance and validator operation.

## Likelihood Explanation

**Medium Likelihood** during specific operational scenarios:

1. **Epoch Transitions**: During epoch changes, consensus may need to adjust sync targets as the validator set changes, potentially issuing new sync requests before previous ones complete.

2. **Consensus Observer Handoffs**: The driver handles notifications from both consensus and consensus observer, potentially creating overlapping requests during mode transitions.

3. **Network Partition Recovery**: When a validator rejoins after partition, rapid sync target updates may occur as it catches up.

4. **Fallback Mode Switches**: When switching between execution modes (transactions vs outputs), sync parameters may change mid-flight.

The vulnerability requires multiple sync requests to arrive before the first completes - not the common case, but plausible during network stress or state transitions.

## Recommendation

Instead of creating a new Arc on each sync request, update the contents of the existing Arc. Additionally, check for and properly respond to any existing active request before accepting a new one:

```rust
pub async fn initialize_sync_target_request(
    &mut self,
    sync_target_notification: ConsensusSyncTargetNotification,
    latest_pre_committed_version: Version,
    latest_synced_ledger_info: LedgerInfoWithSignatures,
) -> Result<(), Error> {
    // Check if there's an existing active request and respond to it with an error
    let mut sync_request_lock = self.consensus_sync_request.lock();
    if let Some(old_request) = sync_request_lock.take() {
        warn!("Replacing active sync request with new request");
        // Respond to old request with cancellation error
        match old_request {
            ConsensusSyncRequest::SyncTarget(old_notification) => {
                self.respond_to_sync_target_notification(
                    old_notification, 
                    Err(Error::UnexpectedErrorEncountered("Cancelled by new sync request".into()))
                )?;
            },
            ConsensusSyncRequest::SyncDuration(_, old_notification) => {
                self.respond_to_sync_duration_notification(
                    old_notification,
                    Err(Error::UnexpectedErrorEncountered("Cancelled by new sync request".into())),
                    None
                )?;
            }
        }
    }
    
    // Perform existing validation...
    
    // Update the contents of the existing Arc instead of replacing it
    let consensus_sync_request = ConsensusSyncRequest::new_with_target(sync_target_notification);
    *sync_request_lock = Some(consensus_sync_request);
    
    Ok(())
}
```

Apply similar logic to `initialize_sync_duration_request()`.

## Proof of Concept

A test case demonstrating the issue:

```rust
#[tokio::test]
async fn test_overlapping_sync_requests_drops_callback() {
    // Create consensus notifier and state sync driver
    let (consensus_notifier, mut consensus_listener) = 
        new_consensus_notifier_listener_pair(5000);
    
    // Send first sync request
    let target_1 = create_ledger_info_at_version(100);
    let sync_future_1 = consensus_notifier.sync_to_target(target_1.clone());
    
    // Allow first request to be received
    tokio::time::sleep(Duration::from_millis(100)).await;
    
    // Send second sync request before first completes (simulating epoch transition)
    let target_2 = create_ledger_info_at_version(200);
    let sync_future_2 = consensus_notifier.sync_to_target(target_2.clone());
    
    // The first callback should fail with RecvError when its Arc is dropped
    // This demonstrates the protocol violation
    let result_1 = sync_future_1.await;
    assert!(result_1.is_err()); // Should get UnexpectedErrorEncountered
    
    // Second request may succeed, but first one was never properly responded to
}
```

## Notes

**Minor Technical Clarification**: While the report describes consensus "timing out", the actual behavior for `sync_to_target()` and `sync_for_duration()` is that consensus receives an immediate `Error::UnexpectedErrorEncountered` when the oneshot sender is dropped (due to `RecvError`), rather than experiencing a timeout. Only `notify_new_commit()` has an explicit timeout wrapper. However, this doesn't diminish the severity - receiving an unexpected error instead of a proper response is still a protocol violation that degrades validator coordination.

The core vulnerability - dropped callbacks causing protocol violations - is valid and constitutes a High Severity issue affecting validator synchronization performance.

### Citations

**File:** state-sync/state-sync-driver/src/notification_handlers.rs (L245-259)
```rust
    /// Initializes the sync duration request received from consensus
    pub async fn initialize_sync_duration_request(
        &mut self,
        sync_duration_notification: ConsensusSyncDurationNotification,
    ) -> Result<(), Error> {
        // Get the current time
        let start_time = self.time_service.now();

        // Save the request so we can notify consensus once we've hit the duration
        let consensus_sync_request =
            ConsensusSyncRequest::new_with_duration(start_time, sync_duration_notification);
        self.consensus_sync_request = Arc::new(Mutex::new(Some(consensus_sync_request)));

        Ok(())
    }
```

**File:** state-sync/state-sync-driver/src/notification_handlers.rs (L261-318)
```rust
    /// Initializes the sync target request received from consensus
    pub async fn initialize_sync_target_request(
        &mut self,
        sync_target_notification: ConsensusSyncTargetNotification,
        latest_pre_committed_version: Version,
        latest_synced_ledger_info: LedgerInfoWithSignatures,
    ) -> Result<(), Error> {
        // Get the target sync version and latest committed version
        let sync_target_version = sync_target_notification
            .get_target()
            .ledger_info()
            .version();
        let latest_committed_version = latest_synced_ledger_info.ledger_info().version();

        // If the target version is old, return an error to consensus (something is wrong!)
        if sync_target_version < latest_committed_version
            || sync_target_version < latest_pre_committed_version
        {
            let error = Err(Error::OldSyncRequest(
                sync_target_version,
                latest_pre_committed_version,
                latest_committed_version,
            ));
            self.respond_to_sync_target_notification(sync_target_notification, error.clone())?;
            return error;
        }

        // If the committed version is at the target, return successfully
        if sync_target_version == latest_committed_version {
            info!(
                LogSchema::new(LogEntry::NotificationHandler).message(&format!(
                    "We're already at the requested sync target version: {} \
                (pre-committed version: {}, committed version: {})!",
                    sync_target_version, latest_pre_committed_version, latest_committed_version
                ))
            );
            let result = Ok(());
            self.respond_to_sync_target_notification(sync_target_notification, result.clone())?;
            return result;
        }

        // If the pre-committed version is already at the target, something has else gone wrong
        if sync_target_version == latest_pre_committed_version {
            let error = Err(Error::InvalidSyncRequest(
                sync_target_version,
                latest_pre_committed_version,
            ));
            self.respond_to_sync_target_notification(sync_target_notification, error.clone())?;
            return error;
        }

        // Save the request so we can notify consensus once we've hit the target
        let consensus_sync_request =
            ConsensusSyncRequest::new_with_target(sync_target_notification);
        self.consensus_sync_request = Arc::new(Mutex::new(Some(consensus_sync_request)));

        Ok(())
    }
```

**File:** state-sync/inter-component/consensus-notifications/src/lib.rs (L181-207)
```rust
    async fn sync_to_target(&self, target: LedgerInfoWithSignatures) -> Result<(), Error> {
        // Create a consensus sync target notification
        let (notification, callback_receiver) = ConsensusSyncTargetNotification::new(target);
        let sync_target_notification = ConsensusNotification::SyncToTarget(notification);

        // Send the notification to state sync
        if let Err(error) = self
            .notification_sender
            .clone()
            .send(sync_target_notification)
            .await
        {
            return Err(Error::NotificationError(format!(
                "Failed to notify state sync of sync target! Error: {:?}",
                error
            )));
        }

        // Process the response
        match callback_receiver.await {
            Ok(response) => response.get_result(),
            Err(error) => Err(Error::UnexpectedErrorEncountered(format!(
                "Sync to target failure: {:?}",
                error
            ))),
        }
    }
```

**File:** state-sync/inter-component/consensus-notifications/src/lib.rs (L360-379)
```rust
/// A notification for state sync to synchronize for the specified duration
#[derive(Debug)]
pub struct ConsensusSyncDurationNotification {
    duration: Duration,
    callback: oneshot::Sender<ConsensusNotificationResponse>,
}

impl ConsensusSyncDurationNotification {
    pub fn new(duration: Duration) -> (Self, oneshot::Receiver<ConsensusNotificationResponse>) {
        let (callback, callback_receiver) = oneshot::channel();
        let notification = ConsensusSyncDurationNotification { duration, callback };

        (notification, callback_receiver)
    }

    /// Returns the duration of the notification
    pub fn get_duration(&self) -> Duration {
        self.duration
    }
}
```

**File:** state-sync/inter-component/consensus-notifications/src/lib.rs (L381-402)
```rust
/// A notification for state sync to synchronize to the given target
#[derive(Debug)]
pub struct ConsensusSyncTargetNotification {
    target: LedgerInfoWithSignatures,
    callback: oneshot::Sender<ConsensusNotificationResponse>,
}

impl ConsensusSyncTargetNotification {
    pub fn new(
        target: LedgerInfoWithSignatures,
    ) -> (Self, oneshot::Receiver<ConsensusNotificationResponse>) {
        let (callback, callback_receiver) = oneshot::channel();
        let notification = ConsensusSyncTargetNotification { target, callback };

        (notification, callback_receiver)
    }

    /// Returns a reference to the target of the notification
    pub fn get_target(&self) -> &LedgerInfoWithSignatures {
        &self.target
    }
}
```

**File:** state-sync/state-sync-driver/src/driver.rs (L383-405)
```rust
    /// Handles a consensus or consensus observer request to sync for a specified duration
    async fn handle_consensus_sync_duration_notification(
        &mut self,
        sync_duration_notification: ConsensusSyncDurationNotification,
    ) -> Result<(), Error> {
        // Update the sync duration notification metrics
        let latest_synced_version = utils::fetch_pre_committed_version(self.storage.clone())?;
        info!(
            LogSchema::new(LogEntry::ConsensusNotification).message(&format!(
                "Received a consensus sync duration notification! Duration: {:?}. Latest synced version: {:?}",
                sync_duration_notification.get_duration(), latest_synced_version,
            ))
        );
        metrics::increment_counter(
            &metrics::DRIVER_COUNTERS,
            metrics::DRIVER_CONSENSUS_SYNC_DURATION_NOTIFICATION,
        );

        // Initialize a new sync request
        self.consensus_notification_handler
            .initialize_sync_duration_request(sync_duration_notification)
            .await
    }
```

**File:** state-sync/state-sync-driver/src/driver.rs (L407-442)
```rust
    /// Handles a consensus or consensus observer request to sync to a specified target
    async fn handle_consensus_sync_target_notification(
        &mut self,
        sync_target_notification: ConsensusSyncTargetNotification,
    ) -> Result<(), Error> {
        // Fetch the pre-committed and committed versions
        let latest_pre_committed_version =
            utils::fetch_pre_committed_version(self.storage.clone())?;
        let latest_synced_ledger_info =
            utils::fetch_latest_synced_ledger_info(self.storage.clone())?;
        let latest_committed_version = latest_synced_ledger_info.ledger_info().version();

        // Update the sync target notification logs and metrics
        info!(
            LogSchema::new(LogEntry::ConsensusNotification).message(&format!(
                "Received a consensus sync target notification! Target: {:?}. \
                Latest pre-committed version: {}. Latest committed version: {}.",
                sync_target_notification.get_target(),
                latest_pre_committed_version,
                latest_committed_version,
            ))
        );
        metrics::increment_counter(
            &metrics::DRIVER_COUNTERS,
            metrics::DRIVER_CONSENSUS_SYNC_TARGET_NOTIFICATION,
        );

        // Initialize a new sync request
        self.consensus_notification_handler
            .initialize_sync_target_request(
                sync_target_notification,
                latest_pre_committed_version,
                latest_synced_ledger_info,
            )
            .await
    }
```

**File:** state-sync/state-sync-driver/src/driver.rs (L535-609)
```rust
    /// Checks if the node has successfully reached the sync target or duration
    async fn check_sync_request_progress(&mut self) -> Result<(), Error> {
        // Check if the sync request has been satisfied
        let consensus_sync_request = self.consensus_notification_handler.get_sync_request();
        match consensus_sync_request.lock().as_ref() {
            Some(consensus_sync_request) => {
                let latest_synced_ledger_info =
                    utils::fetch_latest_synced_ledger_info(self.storage.clone())?;
                if !consensus_sync_request
                    .sync_request_satisfied(&latest_synced_ledger_info, self.time_service.clone())
                {
                    return Ok(()); // The sync request hasn't been satisfied yet
                }
            },
            None => {
                return Ok(()); // There's no active sync request
            },
        }

        // The sync request has been satisfied. Wait for the storage synchronizer
        // to drain. This prevents notifying consensus prematurely.
        while self.storage_synchronizer.pending_storage_data() {
            sample!(
                SampleRate::Duration(Duration::from_secs(PENDING_DATA_LOG_FREQ_SECS)),
                info!("Waiting for the storage synchronizer to handle pending data!")
            );

            // Yield to avoid starving the storage synchronizer threads.
            yield_now().await;
        }

        // If the request was to sync for a specified duration, we should only
        // stop syncing when the synced version and synced ledger info version match.
        // Otherwise, the DB will be left in an inconsistent state on handover.
        if let Some(sync_request) = consensus_sync_request.lock().as_ref() {
            if sync_request.is_sync_duration_request() {
                // Get the latest synced version and ledger info version
                let latest_synced_version =
                    utils::fetch_pre_committed_version(self.storage.clone())?;
                let latest_synced_ledger_info =
                    utils::fetch_latest_synced_ledger_info(self.storage.clone())?;
                let latest_ledger_info_version = latest_synced_ledger_info.ledger_info().version();

                // Check if the latest synced version matches the latest ledger info version
                if latest_synced_version != latest_ledger_info_version {
                    sample!(
                        SampleRate::Duration(Duration::from_secs(DRIVER_INFO_LOG_FREQ_SECS)),
                        info!(
                            "Waiting for state sync to sync to a ledger info! \
                            Latest synced version: {:?}, latest ledger info version: {:?}",
                            latest_synced_version, latest_ledger_info_version
                        )
                    );

                    return Ok(()); // State sync should continue to run
                }
            }
        }

        // Handle the satisfied sync request
        let latest_synced_ledger_info =
            utils::fetch_latest_synced_ledger_info(self.storage.clone())?;
        self.consensus_notification_handler
            .handle_satisfied_sync_request(latest_synced_ledger_info)
            .await?;

        // If the sync request was successfully handled, reset the continuous syncer
        // so that in the event another sync request occurs, we have fresh state.
        if !self.active_sync_request() {
            self.continuous_syncer.reset_active_stream(None).await?;
            self.storage_synchronizer.finish_chunk_executor(); // Consensus or consensus observer is now in control
        }

        Ok(())
    }
```
