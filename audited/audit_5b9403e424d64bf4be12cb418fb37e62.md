# Audit Report

## Title
Rate Limit Bypass via Error Code Conversion in Faucet Checker Pipeline

## Summary
The faucet's checker pipeline converts all errors from individual checkers to `CheckerError` (HTTP 500), regardless of their original error code. This allows attackers to bypass rate limiting by triggering client errors (4xx) in low-cost checkers that execute before rate limiters, preventing rate limit counters from being incremented while enabling unlimited malformed request spam.

## Finding Description

The vulnerability exists in the error handling logic of the faucet's request preprocessing flow. When checkers execute, their errors are unconditionally converted from their original error codes (like `InvalidRequest`/400 or `AuthTokenInvalid`/403) to `CheckerError` (HTTP 500). [1](#0-0) 

Checkers execute in order based on their `cost()` value (lower cost = earlier execution): [2](#0-1) 

Critical execution order:
- TapCaptchaChecker (cost 3) - can return `InvalidRequest` (400)
- GoogleCaptchaChecker (cost 10) - can return `InvalidRequest` (400)  
- MemoryRatelimitChecker (cost 20) - increments rate limit counter
- RedisRatelimitChecker (cost 100) - increments rate limit counter

When `TapCaptchaChecker` or `GoogleCaptchaChecker` receive malformed headers (non-UTF-8 bytes), they return `InvalidRequest`: [3](#0-2) [4](#0-3) [5](#0-4) 

The error code mapping shows `InvalidRequest` should be HTTP 400 (client error), not retryable: [6](#0-5) 

But `CheckerError` maps to HTTP 500 (server error), suggesting retry: [7](#0-6) 

**Attack Flow**:
1. Attacker sends POST request with malformed captcha header containing non-UTF-8 bytes
2. TapCaptchaChecker (cost 3) executes first, returns `Err(InvalidRequest)`
3. Error gets converted to `CheckerError` at the `map_err` call
4. Function returns immediately with HTTP 500 via the `?` operator
5. Rate limit checkers (cost 20, 100) **never execute** - no counter increment occurs
6. Attacker receives 500 error suggesting "retry due to server error"
7. Attacker repeats indefinitely, bypassing rate limits entirely

## Impact Explanation

This qualifies as **High Severity** per Aptos bug bounty criteria:

1. **API Crashes/Slowdowns**: Unlimited malformed requests bypass rate limiting and can overwhelm the faucet service, causing degradation or complete unavailability for legitimate testnet users.

2. **Rate Limiting Bypass**: The security control intended to prevent abuse (rate limiting) is completely bypassed for a trivial attack (malformed headers).

3. **Resource Exhaustion**: Each malformed request still consumes server resources (header parsing, checker execution, mutex locks) despite not counting against limits.

4. **Incorrect HTTP Semantics**: Converting 400-class errors to 500 violates HTTP standards and misleads clients/monitoring systems into thinking server failures are occurring when the issue is malformed client input.

## Likelihood Explanation

**Likelihood: Very High**

- **Trivial to Exploit**: Attacker only needs to send HTTP headers with non-UTF-8 bytes (e.g., raw binary data in `CAPTCHA_KEY` or `CAPTCHA_VALUE` headers)
- **No Prerequisites**: No authentication, account creation, or special access required
- **Automated Attack**: Can be scripted to send thousands of requests per second
- **Detection Difficulty**: Appears as legitimate 500 errors in logs, obscuring the attack
- **Public Service**: Faucet endpoints are publicly accessible on testnets/devnets

## Recommendation

Preserve original error codes from checkers instead of converting them all to `CheckerError`. Distinguish between:
- **Transient errors** (storage failures, network issues) → Return 500, don't increment counters
- **Client errors** (invalid input, auth failures) → Return 4xx, increment rejection counters to prevent spam

**Proposed Fix**:

```rust
for checker in &self.checkers {
    match checker.check(checker_data.clone(), dry_run).await {
        Ok(reasons) => {
            rejection_reasons.extend(reasons);
            if !rejection_reasons.is_empty() && self.return_rejections_early {
                break;
            }
        },
        Err(e) => {
            // Preserve original error code for client errors
            // Only convert infrastructure errors to CheckerError
            if matches!(
                e.error_code,
                AptosTapErrorCode::InvalidRequest 
                | AptosTapErrorCode::AuthTokenInvalid
                | AptosTapErrorCode::Rejected
            ) {
                // Client errors - return as-is, these should count as usage
                // Consider incrementing a "malformed request" counter here
                return Err(e);
            } else {
                // Infrastructure errors - convert to CheckerError
                return Err(AptosTapError::new_with_error_code(
                    e, 
                    AptosTapErrorCode::CheckerError
                ));
            }
        }
    }
}
```

Additionally, consider implementing a separate "malformed request" rate limiter that runs earlier in the pipeline to catch abuse.

## Proof of Concept

```rust
#[tokio::test]
async fn test_rate_limit_bypass_via_malformed_captcha() -> Result<()> {
    // Setup faucet server with TapCaptchaChecker and MemoryRatelimitChecker
    let config = RunConfig {
        checker_configs: vec![
            CheckerConfig::TapCaptcha(TapCaptchaCheckerConfig {}),
            CheckerConfig::MemoryRatelimit(MemoryRatelimitCheckerConfig {
                max_requests_per_day: 3,
                max_entries_in_map: NonZeroUsize::new(1000).unwrap(),
            }),
        ],
        // ... other config
    };
    let (port, _handle) = start_server(config).await?;

    let client = reqwest::Client::new();
    
    // Send 10 requests with malformed captcha header (non-UTF-8 bytes)
    for i in 0..10 {
        let response = client
            .post(format!("http://127.0.0.1:{}/fund", port))
            .json(&FundRequest {
                address: Some(AccountAddress::random().to_string()),
                ..Default::default()
            })
            .header("CAPTCHA_KEY", vec![0xFF, 0xFE, 0xFD]) // Invalid UTF-8
            .send()
            .await?;
        
        // All requests return 500 (not 400)
        assert_eq!(response.status(), reqwest::StatusCode::INTERNAL_SERVER_ERROR);
        
        let error: AptosTapError = response.json().await?;
        assert_eq!(error.error_code, AptosTapErrorCode::CheckerError);
    }
    
    // Now send valid request - should succeed because rate limiter never ran
    // Rate limit counter is still at 0 despite 10 previous requests
    let response = client
        .post(format!("http://127.0.0.1:{}/fund", port))
        .json(&FundRequest {
            address: Some(AccountAddress::random().to_string()),
            ..Default::default()
        })
        .header("CAPTCHA_KEY", "123") // Valid captcha
        .header("CAPTCHA_VALUE", "valid")
        .send()
        .await?;
    
    // This succeeds, proving rate limit was bypassed
    assert_eq!(response.status(), reqwest::StatusCode::OK);
    
    Ok(())
}
```

## Notes

This vulnerability affects all faucet deployments using checkers that can return non-500 errors (TapCaptcha, GoogleCaptcha, JWT-based Redis rate limiting). The issue is architectural - the error handling design assumes all checker failures are infrastructure issues rather than client errors. The fix requires distinguishing error types and handling them appropriately in the execution pipeline.

### Citations

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L263-266)
```rust
        for checker in &self.checkers {
            rejection_reasons.extend(checker.check(checker_data.clone(), dry_run).await.map_err(
                |e| AptosTapError::new_with_error_code(e, AptosTapErrorCode::CheckerError),
            )?);
```

**File:** crates/aptos-faucet/core/src/server/run.rs (L141-143)
```rust
        // Sort Checkers by cost, where lower numbers is lower cost, and lower
        // cost Checkers are at the start of the vec.
        checkers.sort_by_key(|a| a.cost());
```

**File:** crates/aptos-faucet/core/src/checkers/tap_captcha.rs (L56-60)
```rust
            Some(header_value) => match header_value
                .to_str()
                .map_err(|e| {
                    AptosTapError::new_with_error_code(e, AptosTapErrorCode::InvalidRequest)
                })?
```

**File:** crates/aptos-faucet/core/src/checkers/tap_captcha.rs (L79-82)
```rust
        let captcha_value = match data.headers.get(CAPTCHA_VALUE) {
            Some(header_value) => header_value.to_str().map_err(|e| {
                AptosTapError::new_with_error_code(e, AptosTapErrorCode::InvalidRequest)
            })?,
```

**File:** crates/aptos-faucet/core/src/checkers/google_captcha.rs (L65-68)
```rust
        let captcha_token = match data.headers.get(COMPLETED_CAPTCHA_TOKEN) {
            Some(header_value) => header_value.to_str().map_err(|e| {
                AptosTapError::new_with_error_code(e, AptosTapErrorCode::InvalidRequest)
            })?,
```

**File:** crates/aptos-faucet/core/src/endpoints/errors.rs (L172-176)
```rust
    pub fn status(&self) -> StatusCode {
        match self {
            AptosTapErrorCode::InvalidRequest
            | AptosTapErrorCode::AccountDoesNotExist
            | AptosTapErrorCode::EndpointNotEnabled => StatusCode::BAD_REQUEST,
```

**File:** crates/aptos-faucet/core/src/endpoints/errors.rs (L181-187)
```rust
            AptosTapErrorCode::AptosApiError
            | AptosTapErrorCode::TransactionTimedOut
            | AptosTapErrorCode::SerializationError
            | AptosTapErrorCode::BypasserError
            | AptosTapErrorCode::CheckerError
            | AptosTapErrorCode::StorageError
            | AptosTapErrorCode::InternalError => StatusCode::INTERNAL_SERVER_ERROR,
```
