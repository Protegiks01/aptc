# Audit Report

## Title
Non-Deterministic V2 Event Translation Causes Cross-Node Indexing Inconsistencies

## Summary
The V2-to-V1 event translation mechanism in the storage indexer reads blockchain state from `latest_state_checkpoint_view()` rather than the historical state at the event's version. This causes non-deterministic indexing where the same event can be translated differently depending on when indexing occurs, leading to inconsistent indexed data across nodes and different query results.

## Finding Description

The vulnerability exists in the event translation mechanism used during indexing. When processing V2 events in `process_a_batch()`, the system calls `translate_event_v2_to_v1()` which relies on `EventV2TranslationEngine` to derive V1 event handles from on-chain resources. [1](#0-0) 

The critical flaw is in how state is accessed during translation: [2](#0-1) 

The `get_state_value_bytes_for_resource()` method uses `latest_state_checkpoint_view()`, which returns the **latest** state available in the database, not the state at the version being indexed. This breaks deterministic execution because:

1. **Event Key Non-Determinism**: Translation derives event keys from resources (e.g., CoinStore, TokenStore). If a resource doesn't exist at indexing time but the event was emitted when it did exist (or vice versa), different event keys are used. [3](#0-2) 

2. **Timing-Dependent Behavior**: The same V2 event at version 100 will be translated differently if indexed when the latest state is at version 150 versus version 300.

3. **Cross-Node Inconsistency**: Different validator nodes indexing at different times will produce different translations for identical events, violating the deterministic execution invariant.

**Attack Scenario:**

At version 100, a `CoinDeposit` V2 event is emitted for Alice's account (her first deposit, CoinStore not yet initialized).

- **Node A indexes immediately** (latest state = v100): CoinStore doesn't exist, translation uses default key (creation_number=2, seq=0)
- **Node B indexes later** (latest state = v250): CoinStore now exists with actual event handle, translation uses resource key (different from default!)
- **Result**: Same event indexed with different keys, queries return different results on different nodes

During query execution, the code retrieves pre-computed translations: [4](#0-3) 

Since query time uses stored translations, the inconsistency manifests as:
- Different nodes returning different events for the same query
- Events not found on some nodes but present on others
- Re-indexing producing different results than original indexing

## Impact Explanation

This vulnerability constitutes a **High Severity** issue (potentially Critical depending on interpretation):

**High Severity Justification:**
- **API Inconsistency**: Different nodes return different results for identical queries, breaking client expectations and potentially causing application failures
- **Significant Protocol Violation**: Violates the deterministic execution invariant that all validators should produce identical derived state from identical blockchain data
- **Query Failures**: Events may be indexed with wrong keys or missing entirely, causing `NotFound` errors even when events exist in the main database

**Arguments for Critical Severity:**
- **Consensus/Safety Violation**: If indexed state is considered part of the node's consensus state, different nodes having different indexed data represents a safety violation
- **State Inconsistency**: Requires manual intervention (full re-indexing) to recover, and even then may produce different results depending on when re-indexing occurs
- **Non-Reproducible State**: Breaks the fundamental property that blockchain state should be reproducible from the same input data

The impact is limited by the fact that:
1. The main blockchain state and consensus remain unaffected
2. This only affects the event indexing layer, not transaction execution
3. No direct loss of funds occurs

However, applications relying on event queries could malfunction, and the non-determinism undermines trust in the system.

## Likelihood Explanation

**Likelihood: High**

This vulnerability occurs automatically under normal operation:
- No attacker interaction required
- Happens whenever nodes index at different times (which is the norm)
- Re-indexing (due to node restarts, database corruption, etc.) triggers the issue
- Cannot be avoided without code changes

The only requirement is that:
1. V2 events are emitted (common in modern Aptos transactions)
2. Resources referenced by events change state over time (inevitable)
3. Nodes index at different times (always true in distributed systems)

## Recommendation

**Fix the state access to use historical state at the event's version:**

Modify `EventV2TranslationEngine` to accept the target version and use historical state view instead of latest state:

```rust
pub fn get_state_value_bytes_for_resource(
    &self,
    address: &AccountAddress,
    struct_tag: &StructTag,
    version: Version,  // Add version parameter
) -> Result<Option<Bytes>> {
    // Use state at specific version, not latest
    let state_view = self
        .main_db_reader
        .state_view_at_version(Some(version))?;  // Changed from latest_state_checkpoint_view()
    let state_key = StateKey::resource(address, struct_tag)?;
    let maybe_state_value = state_view.get_state_value(&state_key)?;
    Ok(maybe_state_value.map(|state_value| state_value.bytes().clone()))
}
```

Update all translator calls to pass the event's version, and similarly update `get_state_value_bytes_for_object_group_resource()`.

**Alternative approach:** Cache the necessary resource state at transaction execution time and store it alongside events, eliminating the need for post-hoc state lookups.

## Proof of Concept

```rust
// Reproduction steps:
// 1. Start two validator nodes (Node A and Node B)
// 2. Execute transaction at version 100 emitting CoinDeposit V2 event for new account
// 3. Execute 100 more transactions (versions 101-200)
// 4. Node A indexes version 100 immediately (at v100)
// 5. Execute transaction at version 200 creating CoinStore for the account
// 6. Execute 50 more transactions (versions 201-250)
// 7. Node B indexes version 100 now (at v250)
//
// Expected behavior: Both nodes should have identical indexed event
// Actual behavior: Node A uses default key, Node B uses resource key
//
// Verification:
// Query event on Node A: Returns event with default key (creation_number=2)
// Query event on Node B: Returns event with resource key (different!)
// Query with original key fails on one node, succeeds on other

// Minimal test case structure:
#[test]
fn test_non_deterministic_event_translation() {
    // Setup: Create two indexer instances
    let indexer_a = create_indexer();
    let indexer_b = create_indexer();
    
    // At version 100: Emit CoinDeposit V2 event before CoinStore exists
    let event_v2_at_v100 = create_coin_deposit_event();
    
    // Node A indexes at version 100 (CoinStore doesn't exist yet)
    indexer_a.process_a_batch(100, 101);
    let result_a = indexer_a.get_events_by_event_key(&event_key, 0, Order::Ascending, 10, 100);
    
    // Execute version 200: Create CoinStore
    create_coin_store_at_v200();
    
    // Node B indexes version 100 now (CoinStore exists in latest state)
    indexer_b.process_a_batch(100, 101);
    let result_b = indexer_b.get_events_by_event_key(&event_key, 0, Order::Ascending, 10, 100);
    
    // Assertion fails: results differ between nodes
    assert_eq!(result_a, result_b); // FAILS - non-deterministic!
}
```

## Notes

This vulnerability affects all V2 event translators that read on-chain resources during translation, including: CoinDeposit, CoinWithdraw, CoinRegister, KeyRotation, Transfer, TokenMutation, CollectionMutation, Mint, Burn, and all token-related event types. The issue is systemic to the translation architecture, not specific to individual translators.

The query path itself is correct - it retrieves stored translations rather than re-translating. However, the stored translations are non-deterministic due to the indexing-time state dependency, making the entire event indexing system unreliable for cross-node consistency.

### Citations

**File:** storage/indexer/src/db_indexer.rs (L448-484)
```rust
                    if self.indexer_db.event_v2_translation_enabled() {
                        if let ContractEvent::V2(v2) = event {
                            if let Some(translated_v1_event) =
                                self.translate_event_v2_to_v1(v2).map_err(|e| {
                                    anyhow::anyhow!(
                                        "Failed to translate event: {:?}. Error: {}",
                                        v2,
                                        e
                                    )
                                })?
                            {
                                let key = *translated_v1_event.key();
                                let sequence_number = translated_v1_event.sequence_number();
                                self.event_v2_translation_engine
                                    .cache_sequence_number(&key, sequence_number);
                                event_keys.insert(key);
                                batch
                                    .put::<EventByKeySchema>(
                                        &(key, sequence_number),
                                        &(version, idx as u64),
                                    )
                                    .expect("Failed to put events by key to a batch");
                                batch
                                    .put::<EventByVersionSchema>(
                                        &(key, version, sequence_number),
                                        &(idx as u64),
                                    )
                                    .expect("Failed to put events by version to a batch");
                                batch
                                    .put::<TranslatedV1EventSchema>(
                                        &(version, idx as u64),
                                        &translated_v1_event,
                                    )
                                    .expect("Failed to put translated v1 events to a batch");
                            }
                        }
                    }
```

**File:** storage/indexer/src/db_indexer.rs (L692-704)
```rust
        let mut events_with_version = event_indices
            .into_iter()
            .map(|(seq, ver, idx)| {
                let event = match self
                    .main_db_reader
                    .get_event_by_version_and_index(ver, idx)?
                {
                    event @ ContractEvent::V1(_) => event,
                    ContractEvent::V2(_) => ContractEvent::V1(
                        self.indexer_db
                            .get_translated_v1_event_by_version_and_index(ver, idx)?,
                    ),
                };
```

**File:** storage/indexer/src/event_v2_translator.rs (L202-214)
```rust
    pub fn get_state_value_bytes_for_resource(
        &self,
        address: &AccountAddress,
        struct_tag: &StructTag,
    ) -> Result<Option<Bytes>> {
        let state_view = self
            .main_db_reader
            .latest_state_checkpoint_view()
            .expect("Failed to get state view");
        let state_key = StateKey::resource(address, struct_tag)?;
        let maybe_state_value = state_view.get_state_value(&state_key)?;
        Ok(maybe_state_value.map(|state_value| state_value.bytes().clone()))
    }
```

**File:** storage/indexer/src/event_v2_translator.rs (L238-274)
```rust
struct CoinDepositTranslator;
impl EventV2Translator for CoinDepositTranslator {
    fn translate_event_v2_to_v1(
        &self,
        v2: &ContractEventV2,
        engine: &EventV2TranslationEngine,
    ) -> Result<ContractEventV1> {
        let coin_deposit = CoinDeposit::try_from_bytes(v2.event_data())?;
        let struct_tag_str = format!("0x1::coin::CoinStore<{}>", coin_deposit.coin_type());
        let struct_tag = StructTag::from_str(&struct_tag_str)?;
        let (key, sequence_number) = if let Some(state_value_bytes) =
            engine.get_state_value_bytes_for_resource(coin_deposit.account(), &struct_tag)?
        {
            // We can use `DummyCoinType` as it does not affect the correctness of deserialization.
            let coin_store_resource: CoinStoreResource<DummyCoinType> =
                bcs::from_bytes(&state_value_bytes)?;
            let key = *coin_store_resource.deposit_events().key();
            let sequence_number = engine
                .get_next_sequence_number(&key, coin_store_resource.deposit_events().count())?;
            (key, sequence_number)
        } else {
            // The creation number of DepositEvent is deterministically 2.
            static DEPOSIT_EVENT_CREATION_NUMBER: u64 = 2;
            (
                EventKey::new(DEPOSIT_EVENT_CREATION_NUMBER, *coin_deposit.account()),
                0,
            )
        };
        let deposit_event = DepositEvent::new(coin_deposit.amount());
        Ok(ContractEventV1::new(
            key,
            sequence_number,
            DEPOSIT_EVENT_TYPE.clone(),
            bcs::to_bytes(&deposit_event)?,
        )?)
    }
}
```
