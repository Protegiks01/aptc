# Audit Report

## Title
Non-Atomic File Write in CLI Configuration Save Leading to Potential Private Key Loss

## Summary
The `CliConfig::save()` method in the Aptos CLI does not use atomic file writes, creating a window where power loss or system crashes during configuration saves can result in corrupted or empty configuration files, potentially causing permanent loss of user private keys stored in the configuration.

## Finding Description

The vulnerability exists in the configuration save operation used throughout the Aptos CLI tool. When examining the code path: [1](#0-0) 

The `config.save()` method is implemented as: [2](#0-1) 

This delegates to `write_to_user_only_file()`: [3](#0-2) 

Which ultimately calls `write_to_file_with_opts()`: [4](#0-3) 

The critical issue is that the file is opened with `.truncate(true)`, which immediately empties the existing file before any new content is written. If a power loss, system crash, or process termination occurs during the `write_all()` operation, the configuration file will be left in a corrupted state (either empty or partially written).

When the CLI attempts to load this corrupted configuration: [5](#0-4) 

The YAML deserialization will fail on corrupted data, making the configuration unrecoverable. Since the configuration contains private keys, users may permanently lose access to their accounts if they haven't backed up their keys.

The same vulnerability affects other configuration operations including key rotation and profile management: [6](#0-5) 

Notably, other parts of the Aptos codebase already implement atomic file writes correctly using the write-to-temporary-then-rename pattern: [7](#0-6) 

## Impact Explanation

This qualifies as **Medium Severity** per Aptos bug bounty criteria for the following reasons:

1. **Limited Funds Loss**: Users who experience corruption during configuration saves may lose access to their private keys, resulting in loss of access to funds. However, this only affects CLI users, not the blockchain itself.

2. **State Inconsistencies Requiring Intervention**: Corrupted configurations require manual recovery, which may not be possible if users haven't backed up their private keys.

The impact is limited to individual CLI users and does not affect blockchain consensus, validator operations, or on-chain state. However, for affected users, the loss can be permanent if private keys are not backed up elsewhere.

## Likelihood Explanation

The likelihood is **Medium** because:

1. **Common Occurrence Scenarios**: 
   - Power failures during laptop usage
   - System crashes during configuration operations
   - Process termination (Ctrl+C, kill signals) during save operations
   
2. **Multiple Exposure Points**: The vulnerability can be triggered during:
   - Initial CLI setup (`aptos init`)
   - Key rotation operations
   - Profile deletion or renaming
   - Any configuration modification

3. **Timing Window**: While the actual write operation is typically fast, the window exists on every configuration save, and users frequently modify configurations during setup and key management operations.

4. **No User Warning**: Users are not warned about the importance of backing up keys before operations that modify configuration.

## Recommendation

Implement atomic file writes using the write-to-temporary-then-rename pattern already used in other parts of the codebase. Modify `write_to_file_with_opts()` to:

1. Write content to a temporary file in the same directory
2. Flush and sync the temporary file to disk
3. Atomically rename the temporary file to the target filename

Example implementation pattern (adapt the existing OnDiskStorage pattern):

```rust
pub fn write_to_file_with_opts(
    path: &Path,
    name: &str,
    bytes: &[u8],
    opts: &mut OpenOptions,
) -> CliTypedResult<()> {
    // Create temporary file in same directory for atomic rename
    let temp_path = path.with_extension("tmp");
    
    let mut file = opts
        .write(true)
        .create(true)
        .truncate(true)
        .open(&temp_path)
        .map_err(|e| CliError::IO(name.to_string(), e))?;
    
    file.write_all(bytes)
        .map_err(|e| CliError::IO(name.to_string(), e))?;
    
    // Ensure data is flushed to disk
    file.sync_all()
        .map_err(|e| CliError::IO(name.to_string(), e))?;
    
    // Atomic rename
    std::fs::rename(&temp_path, path)
        .map_err(|e| CliError::IO(name.to_string(), e))?;
    
    Ok(())
}
```

Additionally, consider implementing automatic backup of the previous configuration before overwriting during critical operations like key rotation.

## Proof of Concept

```rust
#[cfg(test)]
mod test_config_corruption {
    use std::fs;
    use std::io::Write;
    use std::path::PathBuf;
    use tempfile::tempdir;

    #[test]
    fn test_non_atomic_write_corruption() {
        // Create temporary directory
        let temp_dir = tempdir().unwrap();
        let config_path = temp_dir.path().join("config.yaml");
        
        // Write initial valid config
        let initial_config = "profiles:\n  default:\n    private_key: \"0x1234\"\n";
        fs::write(&config_path, initial_config).unwrap();
        
        // Verify initial config is valid
        let content = fs::read_to_string(&config_path).unwrap();
        assert_eq!(content, initial_config);
        
        // Simulate non-atomic write with interruption
        // This demonstrates the vulnerability: file is truncated first
        let mut file = fs::OpenOptions::new()
            .write(true)
            .create(true)
            .truncate(true)  // File is now empty!
            .open(&config_path)
            .unwrap();
        
        // Write partial data then simulate crash (don't finish write)
        file.write_all(b"profiles:\n  default:\n").unwrap();
        // Simulate crash - don't complete the write or call sync
        drop(file);
        
        // Attempt to read corrupted config
        let corrupted_content = fs::read_to_string(&config_path).unwrap();
        
        // Config is now corrupted/incomplete
        assert_ne!(corrupted_content, initial_config);
        
        // Attempting to parse this as YAML would fail
        let result: Result<serde_yaml::Value, _> = serde_yaml::from_str(&corrupted_content);
        // This will likely fail or return incomplete data
        println!("Corrupted config: {}", corrupted_content);
        println!("Parse result: {:?}", result);
    }
}
```

## Notes

While this is a real data integrity issue that can lead to loss of private keys for CLI users, it's important to note that:

1. This affects the CLI tool, not the core blockchain consensus or validator operations
2. The vulnerability cannot be exploited by a malicious attacker - it requires environmental failures (power loss, crashes)
3. The issue has been correctly identified in the security question as Medium severity
4. The fix is straightforward using patterns already present in the codebase

### Citations

**File:** crates/aptos/src/common/init.rs (L333-333)
```rust
        config.save()?;
```

**File:** crates/aptos/src/common/types.rs (L370-390)
```rust
    pub fn load(mode: ConfigSearchMode) -> CliTypedResult<Self> {
        let folder = Self::aptos_folder(mode)?;

        let config_file = folder.join(CONFIG_FILE);
        let old_config_file = folder.join(LEGACY_CONFIG_FILE);
        if config_file.exists() {
            from_yaml(
                &String::from_utf8(read_from_file(config_file.as_path())?)
                    .map_err(CliError::from)?,
            )
        } else if old_config_file.exists() {
            from_yaml(
                &String::from_utf8(read_from_file(old_config_file.as_path())?)
                    .map_err(CliError::from)?,
            )
        } else {
            Err(CliError::ConfigNotFoundError(format!(
                "{}",
                config_file.display()
            )))
        }
```

**File:** crates/aptos/src/common/types.rs (L423-445)
```rust
    pub fn save(&self) -> CliTypedResult<()> {
        let aptos_folder = Self::aptos_folder(ConfigSearchMode::CurrentDir)?;

        // Create if it doesn't exist
        let no_dir = !aptos_folder.exists();
        create_dir_if_not_exist(aptos_folder.as_path())?;

        // If the `.aptos/` doesn't exist, we'll add a .gitignore in it to ignore the config file
        // so people don't save their credentials...
        if no_dir {
            write_to_user_only_file(
                aptos_folder.join(GIT_IGNORE).as_path(),
                GIT_IGNORE,
                APTOS_FOLDER_GIT_IGNORE.as_bytes(),
            )?;
        }

        // Save over previous config file
        let config_file = aptos_folder.join(CONFIG_FILE);
        let config_bytes = serde_yaml::to_string(&self).map_err(|err| {
            CliError::UnexpectedError(format!("Failed to serialize config {}", err))
        })?;
        write_to_user_only_file(&config_file, CONFIG_FILE, config_bytes.as_bytes())?;
```

**File:** crates/aptos/src/common/utils.rs (L224-228)
```rust
pub fn write_to_user_only_file(path: &Path, name: &str, bytes: &[u8]) -> CliTypedResult<()> {
    let mut opts = OpenOptions::new();
    #[cfg(unix)]
    opts.mode(0o600);
    write_to_file_with_opts(path, name, bytes, &mut opts)
```

**File:** crates/aptos/src/common/utils.rs (L232-245)
```rust
pub fn write_to_file_with_opts(
    path: &Path,
    name: &str,
    bytes: &[u8],
    opts: &mut OpenOptions,
) -> CliTypedResult<()> {
    let mut file = opts
        .write(true)
        .create(true)
        .truncate(true)
        .open(path)
        .map_err(|e| CliError::IO(name.to_string(), e))?;
    file.write_all(bytes)
        .map_err(|e| CliError::IO(name.to_string(), e))
```

**File:** crates/aptos/src/account/key_rotation.rs (L319-319)
```rust
        config.save()?;
```

**File:** secure/storage/src/on_disk.rs (L64-70)
```rust
    fn write(&self, data: &HashMap<String, Value>) -> Result<(), Error> {
        let contents = serde_json::to_vec(data)?;
        let mut file = File::create(self.temp_path.path())?;
        file.write_all(&contents)?;
        fs::rename(&self.temp_path, &self.file_path)?;
        Ok(())
    }
```
