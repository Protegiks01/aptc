# Audit Report

## Title
Silent Module Overwriting in ReleaseBundle During Genesis Due to Missing Cross-Package Duplicate Validation

## Summary
The `ReleaseBundle::code()` method combined with `publish_framework()` can silently overwrite modules when multiple packages in a release bundle contain modules with identical `ModuleId` (same address and name). This occurs because the genesis initialization path lacks the duplicate module validation present in runtime package publishing, allowing duplicate StateKeys to silently overwrite earlier entries in the BTreeMap.

## Finding Description

The vulnerability spans two files and manifests during genesis framework deployment:

**1. Vector Flattening Without Validation** [1](#0-0) 

The `code()` method flattens all module bytecode from all packages without checking for duplicate ModuleIds across packages.

**2. Silent Overwrite in publish_framework** [2](#0-1) 

In `publish_framework()`, module writes from each package are converted to `BTreeMap<StateKey, ModuleWrite<WriteOp>>` entries. The StateKey is derived from the ModuleId: [3](#0-2) 

When `writes.extend(package_writes.clone())` is called, Rust's `BTreeMap::extend()` silently overwrites any existing keys. If Package A and Package B both contain a module `0x1::foo`, only Package B's version will be published.

**3. Missing Validation in Genesis Path**

The critical difference is that runtime package publishing validates for duplicates via `check_coexistence`: [4](#0-3) 

Specifically, at line 200, `check_coexistence(old, &module_names)` is called for existing packages with different names to detect module name clashes: [5](#0-4) 

However, during genesis, the `initialize()` function is used instead: [6](#0-5) 

This function performs no validation for duplicate module names across packages - it simply adds the metadata to the registry.

**Exploitation Scenario:**
1. A malicious or misconfigured ReleaseBundle contains Package A and Package B
2. Both packages contain module `0x1::critical_module` at different versions
3. During genesis via `publish_framework()`:
   - Package A's module is converted to writes with StateKey for `0x1::critical_module`
   - Package B's module is converted to writes with the same StateKey
   - `BTreeMap::extend()` silently overwrites Package A's entry with Package B's
4. Genesis completes with only Package B's version deployed
5. No error or warning is generated; Package A's module is silently lost

## Impact Explanation

**Severity: Low** (as indicated in the security question)

This qualifies as a Low severity issue because:
- It only affects genesis/development-time bundle creation, not runtime operations
- Exploitation requires privileged access to generate genesis bundles
- Current framework packages are carefully curated to avoid overlapping modules
- No direct loss of funds or consensus break in normal operation

However, it could lead to:
- **Non-Deterministic Genesis**: If different nodes use bundles with different package ordering, they could have different genesis states
- **Wrong Module Deployment**: Critical framework modules could be deployed in incorrect versions
- **Silent Failures**: Expected functionality missing without error indication
- **Development Risk**: Future framework changes could introduce duplicates without detection

## Likelihood Explanation

**Likelihood: Low**

The vulnerability is unlikely to be exploited because:
1. Genesis bundles are generated by trusted Aptos core developers
2. Current framework packages (move-stdlib, aptos-stdlib, aptos-framework, etc.) are at different addresses or have distinct module names
3. The release process includes manual review
4. Genesis is a one-time event per network

However, likelihood increases if:
- Multiple teams independently develop framework packages
- Automated tooling generates bundles without validation
- Framework refactoring introduces module name collisions
- Test/development networks use ad-hoc bundle construction

## Recommendation

**Add validation to prevent duplicate module IDs across packages in a ReleaseBundle:**

**Option 1: Validate during ReleaseBundle construction**
Add validation in `ReleaseBundle::new()` or when building release bundles to detect duplicate ModuleIds:

```rust
pub fn new(packages: Vec<ReleasePackage>, source_dirs: Vec<String>) -> Result<Self, String> {
    // Validate no duplicate module IDs across packages
    let mut seen_modules = std::collections::HashSet::new();
    for (pkg_idx, package) in packages.iter().enumerate() {
        for (code_bytes, module) in package.sorted_code_and_modules() {
            let module_id = module.self_id();
            if !seen_modules.insert(module_id.clone()) {
                return Err(format!(
                    "Duplicate module {} found in package {} ({})",
                    module_id,
                    pkg_idx,
                    package.name()
                ));
            }
        }
    }
    Ok(Self { packages, source_dirs })
}
```

**Option 2: Validate during publish_framework**
Add validation before extending the writes BTreeMap:

```rust
fn publish_framework(...) -> (VMChangeSet, ModuleWriteSet) {
    let mut writes = BTreeMap::new();
    for pack in &framework.packages {
        // ... existing code ...
        let package_writes = code_to_writes_for_publishing(...)?;
        
        // Check for duplicate keys before merging
        for state_key in package_writes.keys() {
            if writes.contains_key(state_key) {
                panic!(
                    "Duplicate module detected in package `{}`: {:?}",
                    pack.package_metadata().name,
                    state_key
                );
            }
        }
        
        writes.extend(package_writes.clone());
        // ...
    }
    // ...
}
```

**Option 3: Add test coverage**
Create integration tests that verify duplicate detection:

```rust
#[test]
#[should_panic(expected = "Duplicate module")]
fn test_release_bundle_rejects_duplicate_modules() {
    // Create two packages with the same module ID
    // Attempt to create ReleaseBundle
    // Verify panic/error occurs
}
```

## Proof of Concept

```rust
// Test demonstrating the silent overwrite behavior
#[test]
fn test_duplicate_module_silent_overwrite() {
    use aptos_framework::{ReleaseBundle, ReleasePackage, BuiltPackage};
    use move_core_types::language_storage::ModuleId;
    use move_core_types::account_address::AccountAddress;
    use move_core_types::identifier::Identifier;
    
    // Build Package A with module 0x1::test_module (version 1)
    let package_a = create_test_package_with_module(
        "package_a",
        AccountAddress::ONE,
        "test_module",
        vec![0x01] // Version 1 bytecode
    );
    
    // Build Package B with module 0x1::test_module (version 2)
    let package_b = create_test_package_with_module(
        "package_b",
        AccountAddress::ONE,
        "test_module",
        vec![0x02] // Version 2 bytecode
    );
    
    // Create ReleaseBundle with both packages
    let bundle = ReleaseBundle::new(
        vec![package_a, package_b],
        vec![]
    );
    
    // Deploy via publish_framework
    let (change_set, module_write_set) = publish_framework(
        &genesis_vm,
        &runtime_env,
        HashValue::zero(),
        &bundle
    );
    
    // Verify: Only version 2 (from package_b) is present
    // Version 1 (from package_a) was silently overwritten
    let module_id = ModuleId::new(
        AccountAddress::ONE,
        Identifier::new("test_module").unwrap()
    );
    let state_key = StateKey::module_id(&module_id);
    
    let write = module_write_set.get(&state_key).unwrap();
    let bytes = write.write_op().bytes().unwrap();
    
    // This assertion fails because package_a's module was overwritten
    assert_eq!(bytes, &vec![0x01]); // Expected version 1
    assert_eq!(bytes, &vec![0x02]); // Actually version 2
}
```

## Notes

The vulnerability exists specifically in the genesis deployment path where `publish_framework` processes ReleaseBundle packages. Runtime package publishing through `publish_package` correctly validates for duplicate modules via `check_coexistence`. The current Aptos framework packages are properly structured to avoid this issue, but the lack of validation creates a latent risk for future development or custom framework deployments.

### Citations

**File:** aptos-move/framework/src/release_bundle.rs (L59-66)
```rust
    pub fn code(&self) -> Vec<&[u8]> {
        let mut result = vec![];
        for pack in &self.packages {
            let mut code = pack.code();
            result.append(&mut code);
        }
        result
    }
```

**File:** aptos-move/vm-genesis/src/lib.rs (L1165-1194)
```rust
    let mut writes = BTreeMap::new();
    for pack in &framework.packages {
        let modules = pack.sorted_code_and_modules();

        let addr = *modules.first().unwrap().1.self_id().address();
        let code = modules
            .into_iter()
            .map(|(c, _)| c.to_vec().into())
            .collect::<Vec<_>>();

        let package_writes = code_to_writes_for_publishing(
            genesis_runtime_environment,
            genesis_vm.genesis_features(),
            &state_view,
            addr,
            code,
        )
        .unwrap_or_else(|e| {
            panic!(
                "Failure publishing package `{}`: {:?}",
                pack.package_metadata().name,
                e
            )
        });

        // Add write ops so that we can later create a module write set. Also add them to the state
        // view so that modules in subsequent packages can link to them.
        writes.extend(package_writes.clone());
        state_view.add_module_write_ops(package_writes);
    }
```

**File:** aptos-move/aptos-vm/src/move_vm_ext/write_op_converter.rs (L85-108)
```rust
        for (module_id, bytes) in verified_module_bundle {
            let addr = module_id.address();
            let name = module_id.name();

            // INVARIANT:
            //   No need to charge for module metadata access because the write of a module must
            //   have been already charged for when processing module bundle. Here, it is used for
            //   conversion into a write op - if the metadata exists, it is a modification.
            let state_value_metadata =
                module_storage.unmetered_get_module_state_value_metadata(addr, name)?;
            let op = if state_value_metadata.is_some() {
                Op::Modify(bytes)
            } else {
                Op::New(bytes)
            };

            let write_op = self.convert(
                state_value_metadata,
                op,
                // For modules, creation is never a modification.
                false,
            )?;

            let state_key = StateKey::module_id(&module_id);
```

**File:** aptos-move/framework/aptos-framework/sources/code.move (L155-164)
```text
    fun initialize(aptos_framework: &signer, package_owner: &signer, metadata: PackageMetadata)
    acquires PackageRegistry {
        system_addresses::assert_aptos_framework(aptos_framework);
        let addr = signer::address_of(package_owner);
        if (!exists<PackageRegistry>(addr)) {
            move_to(package_owner, PackageRegistry { packages: vector[metadata] })
        } else {
            vector::push_back(&mut borrow_global_mut<PackageRegistry>(addr).packages, metadata)
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/code.move (L168-228)
```text
    public fun publish_package(owner: &signer, pack: PackageMetadata, code: vector<vector<u8>>) acquires PackageRegistry {
        check_code_publishing_permission(owner);
        // Disallow incompatible upgrade mode. Governance can decide later if this should be reconsidered.
        assert!(
            pack.upgrade_policy.policy > upgrade_policy_arbitrary().policy,
            error::invalid_argument(EINCOMPATIBLE_POLICY_DISABLED),
        );

        let addr = signer::address_of(owner);
        if (!exists<PackageRegistry>(addr)) {
            move_to(owner, PackageRegistry { packages: vector::empty() })
        };

        // Checks for valid dependencies to other packages
        let allowed_deps = check_dependencies(addr, &pack);

        // Check package against conflicts
        // To avoid prover compiler error on spec
        // the package need to be an immutable variable
        let module_names = get_module_names(&pack);
        let package_immutable = &borrow_global<PackageRegistry>(addr).packages;
        let len = vector::length(package_immutable);
        let index = len;
        let upgrade_number = 0;
        vector::enumerate_ref(package_immutable
        , |i, old| {
            let old: &PackageMetadata = old;
            if (old.name == pack.name) {
                upgrade_number = old.upgrade_number + 1;
                check_upgradability(old, &pack, &module_names);
                index = i;
            } else {
                check_coexistence(old, &module_names)
            };
        });

        // Assign the upgrade counter.
        pack.upgrade_number = upgrade_number;

        let packages = &mut borrow_global_mut<PackageRegistry>(addr).packages;
        // Update registry
        let policy = pack.upgrade_policy;
        if (index < len) {
            *vector::borrow_mut(packages, index) = pack
        } else {
            vector::push_back(packages, pack)
        };

        event::emit(PublishPackage {
            code_address: addr,
            is_upgrade: upgrade_number > 0
        });

        // Request publish
        if (features::code_dependency_check_enabled())
            request_publish_with_allowed_deps(addr, module_names, allowed_deps, code, policy.policy)
        else
        // The new `request_publish_with_allowed_deps` has not yet rolled out, so call downwards
        // compatible code.
            request_publish(addr, module_names, code, policy.policy)
    }
```

**File:** aptos-move/framework/aptos-framework/sources/code.move (L282-293)
```text
    fun check_coexistence(old_pack: &PackageMetadata, new_modules: &vector<String>) {
        // The modules introduced by each package must not overlap with `names`.
        vector::for_each_ref(&old_pack.modules, |old_mod| {
            let old_mod: &ModuleMetadata = old_mod;
            let j = 0;
            while (j < vector::length(new_modules)) {
                let name = vector::borrow(new_modules, j);
                assert!(&old_mod.name != name, error::already_exists(EMODULE_NAME_CLASH));
                j = j + 1;
            };
        });
    }
```
