# Audit Report

## Title
Type Substitution Divergence Between Execution and Async Type Checking for Native Function Closure Calls

## Summary
The async type checker performs type substitution on captured closure parameters for generic native functions, while the execution path does not. This divergence violates the documented invariant that "type substitution cannot fail [during async checking] and this has to be enforced at execution time," potentially causing async type checking to fail when execution succeeded.

## Finding Description
A critical divergence exists between the execution path and async type checking path when native functions are called via closures with captured parameters.

**Execution Path Behavior:** [1](#0-0) 

When a captured parameter is encountered (`mask.is_captured(i)` is true), the execution path clones the parameter type WITHOUT performing type substitution, regardless of whether type arguments exist.

**Async Checking Path Behavior:** [2](#0-1) 

When a captured parameter is encountered AND type arguments are present, the async checker DOES perform type substitution via `create_ty_with_subst`.

**Documented Invariant Violation:** [3](#0-2) 

The code explicitly documents that type substitution must not fail during async checking if it succeeded during execution. The async checker is performing a substitution operation that the execution path never performed.

**Type Substitution Failure Modes:** [4](#0-3) 

The `create_ty_with_subst` operation can fail with `TOO_MANY_TYPE_NODES` or `VM_MAX_TYPE_DEPTH_REACHED` errors when type size or depth limits are exceeded.

**Error Handling:** [5](#0-4) 

If type substitution fails during parameter checking, the error is propagated via the `?` operator, terminating async type checking.

**Failure Impact:** [6](#0-5) 

When async type checking fails, it triggers a `PanicError::CodeInvariantError`, forcing sequential execution fallback as a safety mechanism.

## Impact Explanation
**High Severity** - This vulnerability causes significant protocol violations and validator node performance degradation:

1. **Performance Degradation**: An attacker can force the parallel block executor to abandon parallelization and fall back to sequential execution by crafting transactions that trigger this divergence, severely degrading blockchain throughput.

2. **Code Invariant Violation**: Breaks the fundamental assumption that async type checking should never fail if execution succeeded, indicating a dangerous inconsistency in the Move VM's type system.

3. **Potential Consensus Risk**: If validators have different `TypeBuilder` configurations (different `max_ty_size` or `max_ty_depth` limits), they might diverge in their handling of these edge cases, though this is mitigated by the sequential fallback mechanism.

4. **Alert Storm**: Repeated exploitation triggers continuous alerts and sequential fallbacks, potentially masking other security issues.

This meets the **High Severity** criteria of "Validator node slowdowns" and "Significant protocol violations" from the Aptos bug bounty program.

## Likelihood Explanation
**Medium-to-Low Likelihood** with the following considerations:

1. **Requires Specific Conditions**: Exploitation requires:
   - A generic native function callable via closure mechanism
   - Ability to pack such functions into closures (unclear if Move compiler permits this for native functions)
   - Captured parameters with types that exceed limits when substituted

2. **Bytecode Verification Gap**: The bytecode verifier does not explicitly prevent packing closures over native functions, suggesting maliciously crafted bytecode could potentially exploit this.

3. **Limited Native Function Usage**: Native functions with both generic parameters and closure call patterns are relatively rare in the Aptos framework.

4. **Detection and Fallback**: The system has built-in detection (via alerts) and automatic fallback to sequential execution, limiting the severity of successful exploitation.

## Recommendation
**Immediate Fix**: Align the execution path with the async checker by performing type substitution for captured parameters when type arguments are present:

In `interpreter.rs`, modify the captured parameter handling (around line 1083):

```rust
} else {
    #[allow(clippy::collapsible_else_if)]
    if ty_args.is_empty() {
        arg_tys.push_front(expected_ty.clone())
    } else {
        let expected_ty = ty_builder.create_ty_with_subst(expected_ty, ty_args)?;
        arg_tys.push_front(expected_ty)
    }
}
```

**Additional Hardening**:
1. Add bytecode verifier check to explicitly reject `PackClosure` instructions over native functions if this was unintended behavior
2. Add defensive assertions in async type checker that the operations it performs mirror those in execution
3. Enhance monitoring to track async type check failures and identify potential exploitation attempts

## Proof of Concept
While a complete Move-language PoC cannot be provided without certainty about whether the Move compiler allows packing closures over native functions, the vulnerability can be demonstrated through the code divergence itself:

**Scenario**: Generic native function `native fun foo<T>(captured: T, arg: u64)` called via closure with `T` instantiated to a deeply nested type like `vector<vector<vector<...>>>` (depth approaching `max_ty_depth`).

**Execution Flow**:
1. Closure is created capturing the first parameter
2. During execution: captured parameter type is cloned without substitution (no `create_ty_with_subst` call)
3. During async checking: `create_ty_with_subst` is called on the captured parameter type with the deeply nested type argument
4. If the resulting type exceeds `max_ty_depth` or `max_ty_size`, async checking fails with `VM_MAX_TYPE_DEPTH_REACHED`
5. Sequential fallback is triggered despite execution having succeeded

The divergence is demonstrable by comparing:
- [1](#0-0) 
- [2](#0-1) 

## Notes
This vulnerability represents a fundamental inconsistency in how the Move VM handles type substitution between its execution and verification phases. While the practical exploitability depends on whether closures can be packed over native functions (which requires further investigation into Move compiler restrictions), the code divergence itself violates documented invariants and should be addressed regardless of immediate exploitability. The issue highlights the importance of maintaining perfect parity between execution and async checking code paths to preserve deterministic execution guarantees.

### Citations

**File:** third_party/move/move-vm/runtime/src/interpreter.rs (L1082-1084)
```rust
                } else {
                    arg_tys.push_front(expected_ty.clone())
                }
```

**File:** third_party/move/move-vm/runtime/src/runtime_type_checks_async.rs (L18-20)
```rust
//! done over fully-substituted types, it is important that type substitution cannot fail here and
//! this has to be enforced at execution time. Otherwise, user-defined code can fail checks because
//! of running into limits that were not done at regular execution time.
```

**File:** third_party/move/move-vm/runtime/src/runtime_type_checks_async.rs (L525-526)
```rust
                            self.ty_builder.create_ty_with_subst(expected_ty, ty_args)?;
                        ty.paranoid_check_assignable(&expected_ty)?;
```

**File:** third_party/move/move-vm/runtime/src/runtime_type_checks_async.rs (L531-537)
```rust
                    if ty_args.is_empty() {
                        arg_tys.push_front(expected_ty.clone())
                    } else {
                        let expected_ty =
                            self.ty_builder.create_ty_with_subst(expected_ty, ty_args)?;
                        arg_tys.push_front(expected_ty)
                    }
```

**File:** third_party/move/move-vm/types/src/loaded_data/runtime_types.rs (L1195-1223)
```rust
    fn check(&self, count: &mut u64, depth: u64) -> PartialVMResult<()> {
        if *count >= self.max_ty_size {
            return self.too_many_nodes_error();
        }
        if depth > self.max_ty_depth {
            return self.too_large_depth_error();
        }
        Ok(())
    }

    #[cold]
    fn too_many_nodes_error(&self) -> PartialVMResult<()> {
        Err(
            PartialVMError::new(StatusCode::TOO_MANY_TYPE_NODES).with_message(format!(
                "Type size is larger than maximum {}",
                self.max_ty_size
            )),
        )
    }

    #[cold]
    fn too_large_depth_error(&self) -> PartialVMResult<()> {
        Err(
            PartialVMError::new(StatusCode::VM_MAX_TYPE_DEPTH_REACHED).with_message(format!(
                "Type depth is larger than maximum {}",
                self.max_ty_depth
            )),
        )
    }
```

**File:** aptos-move/block-executor/src/executor.rs (L1244-1256)
```rust
            // In case of runtime type check errors, fallback to sequential execution. There errors
            // are supposed to be unlikely so this fallback is fine, and is mostly needed to make
            // sure transaction epilogue runs after failure, etc.
            if let Err(err) = result {
                alert!(
                    "Runtime type check failed during replay of transaction {}: {:?}",
                    txn_idx,
                    err
                );
                return Err(PanicError::CodeInvariantError(format!(
                    "Sequential fallback on type check failure for transaction {}: {:?}",
                    txn_idx, err
                )));
```
