# Audit Report

## Title
StateKvPrunerProgress Exceeds StateKvCommitProgress During TreeOnly State Restore Leading to Database Inconsistency

## Summary
During state restoration in TreeOnly mode, `finalize_state_snapshot()` writes `StateKvPrunerProgress` to the target version without updating `StateKvCommitProgress`, violating the critical invariant that pruner progress must never exceed commit progress. This creates a persistent database inconsistency that can lead to state corruption and node failure.

## Finding Description

The vulnerability exists in the state restoration flow where `StateKvPrunerProgress` can be set to a version higher than `StateKvCommitProgress`, breaking the fundamental invariant that pruner progress should reflect actual committed data.

**Root Cause:**

The `finalize_state_snapshot()` function unconditionally calls `save_min_readable_version(version)` regardless of the state restore mode used: [1](#0-0) 

This writes `StateKvPrunerProgress = version` via: [2](#0-1) 

Which calls: [3](#0-2) 

**The Problem:**

When using `StateSnapshotRestoreMode::TreeOnly`, the KV data is NOT written to the database: [4](#0-3) 

In TreeOnly mode, only `tree_fn()` is executed (line 248), which means `kv_fn()` is never called. Consequently, `write_kv_batch()` is never invoked, and `StateKvCommitProgress` is never updated: [5](#0-4) 

The `state_kv_db.commit()` at line 1278 (which writes `StateKvCommitProgress`) is only called when `kv_fn()` executes, which doesn't happen in TreeOnly mode.

**TreeOnly Mode Usage:**

TreeOnly mode is explicitly used during certain restore scenarios: [6](#0-5) 

**Attack Scenario:**

1. Initial state: Node has data up to version 1000, `StateKvCommitProgress = 1000`, `StateKvPrunerProgress = 500`
2. Operator initiates state restore to version 2000 using TreeOnly mode (common when `db_next_version > 0`)
3. `StateSnapshotReceiver` processes chunks in TreeOnly mode - only tree data is written, KV data is skipped
4. `StateKvCommitProgress` remains at 1000 (never updated)
5. `finalize_state_snapshot(2000, ...)` is called
6. `save_min_readable_version(2000)` writes `StateKvPrunerProgress = 2000`
7. **Result: `StateKvPrunerProgress (2000) > StateKvCommitProgress (1000)` by 1000 versions**

**Additional Evidence:**

The code expects `StateKvCommitProgress` to always have a value and uses assertions during startup: [7](#0-6) 

However, there is no validation that `StateKvPrunerProgress ≤ StateKvCommitProgress`, allowing this inconsistency to persist.

## Impact Explanation

**Severity: Critical** (meets criteria for $1,000,000 bounty category)

This vulnerability causes **State Consistency** violations (Invariant #4) with the following critical impacts:

1. **Database Corruption**: The gap between pruner and commit progress indicates the database is in an inconsistent state where the pruner believes it has processed versions that were never committed to the KV store.

2. **State Query Failures**: Attempts to read state at versions between `StateKvCommitProgress` and `StateKvPrunerProgress` will fail because the data doesn't exist in the KV store, breaking state read operations.

3. **Pruner Malfunction**: On restart, the pruner initializes from the persisted `StateKvPrunerProgress`: [8](#0-7) 

With an inflated progress value, the pruner may incorrectly calculate pruning windows, potentially deleting required data or failing to prune obsolete data.

4. **Node Restart Failures**: The inconsistency can cause assertion failures or unexpected behavior during node initialization when the system validates database integrity.

5. **Consensus Impact**: If different nodes have different `StateKvPrunerProgress` values due to this bug, they may have inconsistent views of which state data is available, potentially causing consensus failures.

This is a **permanent state corruption** that persists across restarts and requires manual intervention or a hardfork to resolve, meeting the Critical severity criteria.

## Likelihood Explanation

**Likelihood: Medium-High**

This vulnerability triggers in specific but realistic scenarios:

1. **TreeOnly Restore Operations**: Commonly used during backup restoration when `db_next_version > 0` and not in replay mode
2. **Operator-Initiated**: Triggered by legitimate operational procedures (state sync, backup restore)
3. **No Special Privileges Required**: Can occur during normal node operations without malicious intent
4. **Persistent Effect**: Once triggered, the corruption persists permanently until manually fixed
5. **Silent Failure**: The bug may not immediately manifest, making it difficult to detect until state queries fail

The vulnerability is likely to affect:
- Nodes performing state restoration from backups
- Nodes synchronizing state after being offline
- Archive nodes rebuilding historical state

## Recommendation

**Immediate Fix:**

Add validation in `finalize_state_snapshot()` to only update `StateKvPrunerProgress` when KV data was actually committed. Modify the function to track the restore mode or check `StateKvCommitProgress` before calling `save_min_readable_version()`:

```rust
fn finalize_state_snapshot(
    &self,
    version: Version,
    output_with_proof: TransactionOutputListWithProofV2,
    ledger_infos: &[LedgerInfoWithSignatures],
) -> Result<()> {
    // ... existing code ...
    
    // Only update pruner progress if KV data was actually committed
    // Check that StateKvCommitProgress >= version before updating pruner progress
    let state_kv_commit_progress = self.state_kv_db
        .metadata_db()
        .get::<DbMetadataSchema>(&DbMetadataKey::StateKvCommitProgress)?
        .map(|v| v.expect_version());
    
    if state_kv_commit_progress.is_some() && state_kv_commit_progress.unwrap() >= version {
        // Safe to update pruner progress
        self.state_store.state_kv_pruner.save_min_readable_version(version)?;
    } else {
        // Log warning: TreeOnly restore detected, not updating StateKvPrunerProgress
        warn!(
            "Skipping StateKvPrunerProgress update: StateKvCommitProgress ({:?}) < target version ({})",
            state_kv_commit_progress, version
        );
    }
    
    // ... rest of function ...
}
```

**Long-term Solution:**

1. Add invariant validation during node startup that asserts `StateKvPrunerProgress ≤ StateKvCommitProgress`
2. Modify `write_pruner_progress()` to validate the progress value before writing
3. Ensure TreeOnly restore explicitly handles pruner progress separately
4. Add integration tests that verify progress consistency across all restore modes

## Proof of Concept

The following scenario demonstrates the vulnerability:

**Setup:**
1. Initialize an AptosDB instance with committed data at version 1000
2. Verify `StateKvCommitProgress = 1000`, `StateKvPrunerProgress = 500`

**Trigger:**
```rust
// Simulate TreeOnly state restore to version 2000
let version = 2000;
let expected_root_hash = /* computed root hash */;

// Create StateSnapshotRestore in TreeOnly mode
let state_snapshot_receiver = storage.writer.get_state_snapshot_receiver(
    version,
    expected_root_hash
)?;

// Process state chunks (in TreeOnly mode, kv_fn is not called)
// state_snapshot_receiver.add_chunk() processes only tree data

// Finish the restore
state_snapshot_receiver.finish_box()?;

// Call finalize_state_snapshot - this triggers the bug
storage.writer.finalize_state_snapshot(
    version,
    output_with_proof,
    &ledger_infos
)?;

// Verify the bug: StateKvPrunerProgress exceeds StateKvCommitProgress
let state_kv_commit_progress = db.state_kv_db
    .metadata_db()
    .get::<DbMetadataSchema>(&DbMetadataKey::StateKvCommitProgress)?
    .unwrap()
    .expect_version();
    
let state_kv_pruner_progress = db.state_kv_db
    .metadata_db()
    .get::<DbMetadataSchema>(&DbMetadataKey::StateKvPrunerProgress)?
    .unwrap()
    .expect_version();

assert_eq!(state_kv_commit_progress, 1000); // Still at old value
assert_eq!(state_kv_pruner_progress, 2000); // Updated to new value
assert!(state_kv_pruner_progress > state_kv_commit_progress); // INVARIANT VIOLATED
```

**Verification:**
- Query state at version 1500: Should fail with "data not found" despite `StateKvPrunerProgress = 2000`
- Restart node: May fail assertions or exhibit undefined behavior due to inconsistent metadata
- Check database integrity: Will show gap between pruner and commit progress

This PoC can be implemented as a Rust integration test in the `aptosdb` test suite to verify the vulnerability and validate the fix.

### Citations

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L232-234)
```rust
            self.state_store
                .state_kv_pruner
                .save_min_readable_version(version)?;
```

**File:** storage/aptosdb/src/pruner/state_kv_pruner/state_kv_pruner_manager.rs (L57-66)
```rust
    fn save_min_readable_version(&self, min_readable_version: Version) -> Result<()> {
        self.min_readable_version
            .store(min_readable_version, Ordering::SeqCst);

        PRUNER_VERSIONS
            .with_label_values(&["state_kv_pruner", "min_readable"])
            .set(min_readable_version as i64);

        self.state_kv_db.write_pruner_progress(min_readable_version)
    }
```

**File:** storage/aptosdb/src/pruner/state_kv_pruner/state_kv_pruner_manager.rs (L94-95)
```rust
        let min_readable_version =
            pruner_utils::get_state_kv_pruner_progress(&state_kv_db).expect("Must succeed.");
```

**File:** storage/aptosdb/src/state_kv_db.rs (L217-222)
```rust
    pub(crate) fn write_pruner_progress(&self, version: Version) -> Result<()> {
        self.state_kv_metadata_db.put::<DbMetadataSchema>(
            &DbMetadataKey::StateKvPrunerProgress,
            &DbMetadataValue::Version(version),
        )
    }
```

**File:** storage/aptosdb/src/state_restore/mod.rs (L246-258)
```rust
        match self.restore_mode {
            StateSnapshotRestoreMode::KvOnly => kv_fn()?,
            StateSnapshotRestoreMode::TreeOnly => tree_fn()?,
            StateSnapshotRestoreMode::Default => {
                // We run kv_fn with TreeOnly to restore the usage of DB
                let (r1, r2) = IO_POOL.join(kv_fn, tree_fn);
                r1?;
                r2?;
            },
        }

        Ok(())
    }
```

**File:** storage/aptosdb/src/state_store/mod.rs (L430-436)
```rust
            let state_kv_commit_progress = state_kv_db
                .metadata_db()
                .get::<DbMetadataSchema>(&DbMetadataKey::StateKvCommitProgress)
                .expect("Failed to read state K/V commit progress.")
                .expect("State K/V commit progress cannot be None.")
                .expect_version();
            assert_ge!(state_kv_commit_progress, overall_commit_progress);
```

**File:** storage/aptosdb/src/state_store/mod.rs (L1242-1279)
```rust
impl StateValueWriter<StateKey, StateValue> for StateStore {
    // This already turns on sharded KV
    fn write_kv_batch(
        &self,
        version: Version,
        node_batch: &StateValueBatch,
        progress: StateSnapshotProgress,
    ) -> Result<()> {
        let _timer = OTHER_TIMERS_SECONDS.timer_with(&["state_value_writer_write_chunk"]);
        let mut batch = SchemaBatch::new();
        let mut sharded_schema_batch = self.state_kv_db.new_sharded_native_batches();

        batch.put::<DbMetadataSchema>(
            &DbMetadataKey::StateSnapshotKvRestoreProgress(version),
            &DbMetadataValue::StateSnapshotProgress(progress),
        )?;

        if self.internal_indexer_db.is_some()
            && self
                .internal_indexer_db
                .as_ref()
                .unwrap()
                .statekeys_enabled()
        {
            let keys = node_batch.keys().map(|key| key.0.clone()).collect();
            self.internal_indexer_db
                .as_ref()
                .unwrap()
                .write_keys_to_indexer_db(&keys, version, progress)?;
        }
        self.shard_state_value_batch(
            &mut sharded_schema_batch,
            node_batch,
            self.state_kv_db.enabled_sharding(),
        )?;
        self.state_kv_db
            .commit(version, Some(batch), sharded_schema_batch)
    }
```

**File:** storage/backup/backup-cli/src/coordinators/restore.rs (L318-323)
```rust
                let restore_mode_opt = if db_next_version > 0 {
                    if replay_all_mode {
                        None // the restore should already been done in the replay_all mode
                    } else {
                        Some(StateSnapshotRestoreMode::TreeOnly)
                    }
```
