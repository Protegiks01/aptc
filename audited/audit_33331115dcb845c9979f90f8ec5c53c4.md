# Audit Report

## Title
Round Index Corruption During Block Pruning When Multiple Blocks Exist for Same Round

## Summary
The `remove_block()` function unconditionally removes the round-to-block mapping when deleting a block, without verifying that the mapping actually points to the block being removed. When multiple blocks exist for the same round (due to equivocation or network delays), pruning the "wrong" block corrupts the round index, making legitimate blocks unreachable via round lookup. [1](#0-0) 

## Finding Description

The vulnerability occurs due to a mismatch between `insert_block()` and `remove_block()` logic when handling multiple blocks for the same round.

**Insert Logic:** When inserting a block, if a round mapping already exists, the code logs a warning but does NOT update the mapping. Only the first block for each round is stored in `round_to_ids`. [2](#0-1) 

**Remove Logic:** When removing a block, the code unconditionally deletes the round mapping without checking if the removed block is the one actually mapped. [1](#0-0) 

**Attack Scenario:**

1. Block A is inserted for round 100 → `round_to_ids[100] = A_id`
2. Block B (equivocating or fork) is inserted for round 100 → `round_to_ids[100]` remains `A_id` (only warning logged)
3. Both blocks exist in `id_to_block`, but only A is in the round index
4. During tree pruning, block B is on a non-canonical branch and gets pruned
5. `process_pruned_blocks()` calls `remove_block(B_id)`
6. The function removes `round_to_ids[100]`, deleting the mapping to A
7. Block A remains in the tree but `get_block_for_round(100)` now returns `None` [3](#0-2) 

**Downstream Impact:**

The corrupted round index affects critical consensus operations:

1. **Proposal validation** in `process_opt_proposal()` checks if a block exists for a round. With the corrupted index, it may incorrectly accept duplicate proposals. [4](#0-3) 

2. **Timeout computation** in `compute_timeout_reason()` uses round lookup to determine why a round timed out. A missing mapping causes incorrect `ProposalNotReceived` status when the block actually exists. [5](#0-4) 

## Impact Explanation

This vulnerability constitutes **HIGH severity** under Aptos bug bounty criteria:

- **Significant Protocol Violation**: Breaks the invariant that `round_to_ids` accurately reflects blocks in the tree, corrupting consensus state
- **Consensus State Inconsistency**: Nodes may have different views of which blocks exist for specific rounds
- **Incorrect Timeout Behavior**: Nodes may report incorrect timeout reasons, affecting consensus liveness
- **Potential Duplicate Round Acceptance**: In edge cases, the system might accept multiple proposals for the same round after pruning

While not a complete consensus safety break, this violates the integrity of the consensus state machine and could contribute to liveness issues or enable more complex attacks when combined with other factors.

## Likelihood Explanation

**Likelihood: MEDIUM to HIGH**

This bug triggers during normal consensus operations:

1. **Multiple blocks per round** occur naturally due to:
   - Network delays causing reordering
   - Byzantine validators sending equivocating blocks  
   - Proposal resends during network partitions

2. **Pruning is a regular operation** that happens on every commit via `commit_callback()` [6](#0-5) 

3. **No special privileges required** - this is triggered by normal consensus flow

The combination of equivocating blocks (which the code explicitly handles with warnings) and subsequent pruning creates a reproducible path to trigger this bug.

## Recommendation

Modify `remove_block()` to only remove the round mapping if it points to the block being removed:

```rust
fn remove_block(&mut self, block_id: HashValue) {
    // Remove the block from the store
    if let Some(block) = self.id_to_block.remove(&block_id) {
        let round = block.executed_block().round();
        // Only remove the round mapping if it points to this block
        if self.round_to_ids.get(&round) == Some(&block_id) {
            self.round_to_ids.remove(&round);
        }
    };
    self.id_to_quorum_cert.remove(&block_id);
}
```

This ensures that removing a non-indexed block (the second/third block for a round) doesn't corrupt the mapping to the indexed block.

## Proof of Concept

```rust
#[test]
fn test_round_index_corruption_on_pruning() {
    use aptos_consensus_types::block::Block;
    use aptos_consensus_types::pipelined_block::PipelinedBlock;
    use aptos_types::block_info::Round;
    use aptos_crypto::HashValue;
    
    // Setup: Create BlockTree with root
    let mut block_tree = create_test_block_tree();
    
    // Step 1: Insert block A for round 100 (canonical chain)
    let block_a = create_test_block(100, parent_id);
    let block_a_id = block_a.id();
    block_tree.insert_block(block_a).unwrap();
    
    // Verify A is in round index
    assert!(block_tree.get_block_for_round(100).is_some());
    
    // Step 2: Insert block B for round 100 (fork/equivocation)
    let block_b = create_test_block_different_hash(100, parent_id);
    let block_b_id = block_b.id();
    block_tree.insert_block(block_b).unwrap();
    
    // Verify both blocks exist but only A is indexed
    assert!(block_tree.get_block(&block_a_id).is_some());
    assert!(block_tree.get_block(&block_b_id).is_some());
    assert_eq!(block_tree.get_block_for_round(100).unwrap().id(), block_a_id);
    
    // Step 3: Simulate pruning of block B
    let mut pruned_blocks = VecDeque::new();
    pruned_blocks.push_back(block_b_id);
    block_tree.process_pruned_blocks(pruned_blocks);
    
    // BUG: Block A still exists but round 100 mapping is gone!
    assert!(block_tree.get_block(&block_a_id).is_some(), "Block A should still exist");
    assert!(block_tree.get_block_for_round(100).is_none(), "BUG: Round 100 mapping was incorrectly removed!");
}
```

**Notes:**
- This vulnerability is triggered by the interaction between equivocation handling and pruning logic
- The code comment at line 326 acknowledges the assumption of "unequivocal proposer election," but the implementation still allows multiple blocks per round (with warnings), creating this inconsistency
- The bug affects the `get_block_for_round()` API which is used throughout the consensus layer for round-based lookups

### Citations

**File:** consensus/src/block_storage/block_tree.rs (L174-181)
```rust
    fn remove_block(&mut self, block_id: HashValue) {
        // Remove the block from the store
        if let Some(block) = self.id_to_block.remove(&block_id) {
            let round = block.executed_block().round();
            self.round_to_ids.remove(&round);
        };
        self.id_to_quorum_cert.remove(&block_id);
    }
```

**File:** consensus/src/block_storage/block_tree.rs (L327-335)
```rust
            if let Some(old_block_id) = self.round_to_ids.get(&arc_block.round()) {
                warn!(
                    "Multiple blocks received for round {}. Previous block id: {}",
                    arc_block.round(),
                    old_block_id
                );
            } else {
                self.round_to_ids.insert(arc_block.round(), block_id);
            }
```

**File:** consensus/src/block_storage/block_tree.rs (L496-510)
```rust
    pub(super) fn process_pruned_blocks(&mut self, mut newly_pruned_blocks: VecDeque<HashValue>) {
        counters::NUM_BLOCKS_IN_TREE.sub(newly_pruned_blocks.len() as i64);
        // The newly pruned blocks are pushed back to the deque pruned_block_ids.
        // In case the overall number of the elements is greater than the predefined threshold,
        // the oldest elements (in the front of the deque) are removed from the tree.
        self.pruned_block_ids.append(&mut newly_pruned_blocks);
        if self.pruned_block_ids.len() > self.max_pruned_blocks_in_mem {
            let num_blocks_to_remove = self.pruned_block_ids.len() - self.max_pruned_blocks_in_mem;
            for _ in 0..num_blocks_to_remove {
                if let Some(id) = self.pruned_block_ids.pop_front() {
                    self.remove_block(id);
                }
            }
        }
    }
```

**File:** consensus/src/block_storage/block_tree.rs (L567-600)
```rust
    pub fn commit_callback(
        &mut self,
        storage: Arc<dyn PersistentLivenessStorage>,
        block_id: HashValue,
        block_round: Round,
        finality_proof: WrappedLedgerInfo,
        commit_decision: LedgerInfoWithSignatures,
        window_size: Option<u64>,
    ) {
        let current_round = self.commit_root().round();
        let committed_round = block_round;
        let commit_proof = finality_proof
            .create_merged_with_executed_state(commit_decision)
            .expect("Inconsistent commit proof and evaluation decision, cannot commit block");

        debug!(
            LogSchema::new(LogEvent::CommitViaBlock).round(current_round),
            committed_round = committed_round,
            block_id = block_id,
        );

        let window_root_id = self.find_window_root(block_id, window_size);
        let ids_to_remove = self.find_blocks_to_prune(window_root_id);

        if let Err(e) = storage.prune_tree(ids_to_remove.clone().into_iter().collect()) {
            // it's fine to fail here, as long as the commit succeeds, the next restart will clean
            // up dangling blocks, and we need to prune the tree to keep the root consistent with
            // executor.
            warn!(error = ?e, "fail to delete block");
        }
        self.process_pruned_blocks(ids_to_remove);
        self.update_window_root(window_root_id);
        self.update_highest_commit_cert(commit_proof);
    }
```

**File:** consensus/src/round_manager.rs (L844-850)
```rust
        ensure!(
            self.block_store
                .get_block_for_round(opt_block_data.round())
                .is_none(),
            "Proposal has already been processed for round: {}",
            opt_block_data.round()
        );
```

**File:** consensus/src/round_manager.rs (L973-982)
```rust
        match self.block_store.get_block_for_round(round) {
            None => RoundTimeoutReason::ProposalNotReceived,
            Some(block) => {
                if let Err(missing_authors) = self.block_store.check_payload(block.block()) {
                    RoundTimeoutReason::PayloadUnavailable { missing_authors }
                } else {
                    RoundTimeoutReason::Unknown
                }
            },
        }
```
