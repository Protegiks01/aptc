# Audit Report

## Title
Consensus-Time Validation Bypass for ObservedJWKUpdate Validator Transactions Enabling Proposer Griefing Attack

## Summary
A malicious validator acting as block proposer can inject arbitrary `ValidatorTransaction::ObservedJWKUpdate` transactions with invalid multi-signatures into their proposals. These transactions bypass cryptographic validation at consensus time because the `verify()` method unconditionally returns `Ok()` for JWK updates, deferring all validation to execution time. This allows a malicious proposer to fill per-block validator transaction limits with invalid transactions, causing computational waste across all validators and potentially delaying legitimate validator transactions. [1](#0-0) 

## Finding Description

The vulnerability exists in the asymmetric validation of validator transactions at consensus time:

**Vulnerable Code Path:**

1. **Block Proposal Creation**: When a validator proposes a block using `new_proposal_ext()`, validator transactions are included in the `BlockData` before signature generation: [2](#0-1) 

2. **Consensus-Time Validation**: When other validators receive the proposal, `process_proposal()` validates each validator transaction by calling `vtxn.verify()`: [3](#0-2) 

3. **Critical Asymmetry**: The `verify()` method performs cryptographic validation for `DKGResult` transactions but **unconditionally returns `Ok()` for `ObservedJWKUpdate`** without any validation: [1](#0-0) 

4. **Execution-Time Validation**: The actual multi-signature verification only happens during block execution in `AptosVM::process_jwk_update()`: [4](#0-3) 

**Attack Scenario:**

A malicious proposer can:
1. Create fake `QuorumCertifiedUpdate` objects with invalid multi-signatures: [5](#0-4) 

2. Add them to their validator transaction pool (no validation performed): [6](#0-5) 

3. Include them in block proposals up to the per-block limits: [7](#0-6) 

4. These transactions pass consensus validation and are accepted by all validators

5. During execution, all validators perform expensive multi-signature verification, which fails deterministically, and the transactions are discarded: [8](#0-7) 

This breaks the invariant that **"Transaction Validation: Prologue/epilogue checks must enforce all invariants"** by allowing invalid transactions to bypass consensus-time validation.

## Impact Explanation

**Severity: Medium** 

While this vulnerability does not cause consensus safety violations or fund loss, it enables bounded denial-of-service attacks:

1. **Computational Waste**: All validators must execute expensive multi-signature verification for invalid transactions that could have been rejected at consensus time

2. **Validator Transaction DoS**: A malicious proposer can fill their blocks' validator transaction slots with invalid JWK updates, preventing legitimate validator transactions (DKG results, valid JWK updates) from being included in those blocks, potentially delaying critical system updates

3. **Resource Exhaustion**: Though bounded by per-block limits, this wastes network bandwidth propagating invalid transactions and CPU cycles validating them

The impact is limited because:
- Only affects blocks proposed by the malicious validator
- Other honest proposers can include legitimate transactions
- Execution remains deterministic (no consensus split)
- Per-block limits prevent unbounded exploitation

This qualifies as **Medium severity** under the "State inconsistencies requiring intervention" category, as it could require manual intervention if a malicious validator consistently delays critical validator transactions.

## Likelihood Explanation

**Likelihood: Medium**

This attack requires:
- Malicious actor to be a validator (requires stake and validator set inclusion)
- Validator to be selected as proposer (probabilistic based on stake)
- JWK consensus feature to be enabled

However, once these conditions are met, exploitation is trivial:
- No complex cryptographic attacks needed
- Simple creation of fake `QuorumCertifiedUpdate` structures
- Guaranteed to bypass consensus validation

The attack provides limited benefit to the attacker (griefing only) but could be motivated by:
- Disrupting randomness generation (delaying DKG)
- Delaying JWK rotations
- General network disruption

## Recommendation

**Fix: Implement consensus-time validation for ObservedJWKUpdate transactions**

Add multi-signature verification at consensus time to match the DKGResult validation pattern:

```rust
pub fn verify(&self, verifier: &ValidatorVerifier) -> anyhow::Result<()> {
    match self {
        ValidatorTransaction::DKGResult(dkg_result) => dkg_result
            .verify(verifier)
            .context("DKGResult verification failed"),
        ValidatorTransaction::ObservedJWKUpdate(update) => {
            // Verify the multi-signature at consensus time
            verifier
                .verify_multi_signatures(&update.update, &update.multi_sig)
                .context("ObservedJWKUpdate multi-signature verification failed")
        },
    }
}
```

This ensures invalid JWK updates are rejected at consensus time rather than wasting resources during execution.

**Alternative**: If the asymmetry is intentional for performance reasons, add explicit rate-limiting or reputation penalties for proposers who include invalid validator transactions.

## Proof of Concept

```rust
// PoC: Malicious proposer injects invalid JWK update
use aptos_types::{
    validator_txn::ValidatorTransaction,
    jwks::{QuorumCertifiedUpdate, ProviderJWKs},
    aggregate_signature::AggregateSignature,
};
use aptos_validator_transaction_pool::VTxnPoolState;
use std::sync::Arc;

fn inject_fake_jwk_update(vtxn_pool: &VTxnPoolState) {
    // Create fake JWK update with invalid signature
    let fake_update = QuorumCertifiedUpdate {
        update: ProviderJWKs {
            issuer: b"https://fake.issuer".to_vec(),
            version: 999,
            jwks: vec![],
        },
        // Invalid/empty multi-signature that will fail verification
        multi_sig: AggregateSignature::empty(),
    };
    
    let vtxn = ValidatorTransaction::ObservedJWKUpdate(fake_update);
    
    // Add to pool without any validation
    let _guard = vtxn_pool.put(
        aptos_types::validator_txn::Topic::JWK_CONSENSUS(
            b"https://fake.issuer".to_vec()
        ),
        Arc::new(vtxn),
        None,
    );
    
    // This transaction will:
    // 1. Pass vtxn.verify() at consensus time (returns Ok())
    // 2. Be counted against per-block limits
    // 3. Fail multi-sig verification at execution time
    // 4. Waste computation on all validators
}
```

**Notes:**
- This vulnerability represents an asymmetry in validation design where DKG transcripts receive consensus-time cryptographic validation but JWK updates do not
- The deferred validation model may have been intentional for performance optimization, but creates a griefing vector
- The bounded nature of the attack (per-block limits, limited to malicious proposer's blocks) reduces but does not eliminate the security concern
- Consider whether the performance benefit of deferred validation outweighs the security cost of allowing invalid transactions through consensus

### Citations

**File:** types/src/validator_txn.rs (L45-52)
```rust
    pub fn verify(&self, verifier: &ValidatorVerifier) -> anyhow::Result<()> {
        match self {
            ValidatorTransaction::DKGResult(dkg_result) => dkg_result
                .verify(verifier)
                .context("DKGResult verification failed"),
            ValidatorTransaction::ObservedJWKUpdate(_) => Ok(()),
        }
    }
```

**File:** consensus/consensus-types/src/block.rs (L367-387)
```rust
    pub fn new_proposal_ext(
        validator_txns: Vec<ValidatorTransaction>,
        payload: Payload,
        round: Round,
        timestamp_usecs: u64,
        quorum_cert: QuorumCert,
        validator_signer: &ValidatorSigner,
        failed_authors: Vec<(Round, Author)>,
    ) -> anyhow::Result<Self> {
        let block_data = BlockData::new_proposal_ext(
            validator_txns,
            payload,
            validator_signer.author(),
            failed_authors,
            round,
            timestamp_usecs,
            quorum_cert,
        );

        Self::new_proposal_from_block_data(block_data, validator_signer)
    }
```

**File:** consensus/src/round_manager.rs (L1126-1136)
```rust
        if let Some(vtxns) = proposal.validator_txns() {
            for vtxn in vtxns {
                let vtxn_type_name = vtxn.type_name();
                ensure!(
                    is_vtxn_expected(&self.randomness_config, &self.jwk_consensus_config, vtxn),
                    "unexpected validator txn: {:?}",
                    vtxn_type_name
                );
                vtxn.verify(self.epoch_state.verifier.as_ref())
                    .context(format!("{} verify failed", vtxn_type_name))?;
            }
```

**File:** consensus/src/round_manager.rs (L1166-1177)
```rust
        ensure!(
            num_validator_txns <= vtxn_count_limit,
            "process_proposal failed with per-block vtxn count limit exceeded: limit={}, actual={}",
            self.vtxn_config.per_block_limit_txn_count(),
            num_validator_txns
        );
        ensure!(
            validator_txns_total_bytes <= vtxn_bytes_limit,
            "process_proposal failed with per-block vtxn bytes limit exceeded: limit={}, actual={}",
            self.vtxn_config.per_block_limit_total_bytes(),
            validator_txns_total_bytes
        );
```

**File:** aptos-move/aptos-vm/src/validator_txns/jwk.rs (L78-88)
```rust
            Err(Expected(failure)) => {
                // Pretend we are inside Move, and expected failures are like Move aborts.
                debug!("Processing dkg transaction expected failure: {:?}", failure);
                Ok((
                    VMStatus::MoveAbort {
                        location: AbortLocation::Script,
                        code: failure as u64,
                        message: None,
                    },
                    VMOutput::empty_with_status(TransactionStatus::Discard(StatusCode::ABORTED)),
                ))
```

**File:** aptos-move/aptos-vm/src/validator_txns/jwk.rs (L127-142)
```rust
        // Check version.
        if on_chain.version + 1 != observed.version {
            return Err(Expected(IncorrectVersion));
        }

        let authors = multi_sig.get_signers_addresses(&verifier.get_ordered_account_addresses());

        // Check voting power.
        verifier
            .check_voting_power(authors.iter(), true)
            .map_err(|_| Expected(NotEnoughVotingPower))?;

        // Verify multi-sig.
        verifier
            .verify_multi_signatures(&observed, &multi_sig)
            .map_err(|_| Expected(MultiSigVerificationFailed))?;
```

**File:** types/src/jwks/mod.rs (L302-317)
```rust
/// A JWK update in format of `ProviderJWKs` and a multi-signature of it as a quorum certificate.
#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize, CryptoHasher, BCSCryptoHash)]
pub struct QuorumCertifiedUpdate {
    pub update: ProviderJWKs,
    pub multi_sig: AggregateSignature,
}

impl QuorumCertifiedUpdate {
    #[cfg(any(test, feature = "fuzzing"))]
    pub fn dummy() -> Self {
        Self {
            update: ProviderJWKs::new(dummy_issuer()),
            multi_sig: AggregateSignature::empty(),
        }
    }
}
```

**File:** crates/validator-transaction-pool/src/lib.rs (L56-82)
```rust
    /// Append a txn to the pool.
    /// Return a txn guard that allows you to later delete the txn from the pool.
    pub fn put(
        &self,
        topic: Topic,
        txn: Arc<ValidatorTransaction>,
        pull_notification_tx: Option<aptos_channel::Sender<(), Arc<ValidatorTransaction>>>,
    ) -> TxnGuard {
        let mut pool = self.inner.lock();
        let seq_num = pool.next_seq_num;
        pool.next_seq_num += 1;

        pool.txn_queue.insert(seq_num, PoolItem {
            topic: topic.clone(),
            txn,
            pull_notification_tx,
        });

        if let Some(old_seq_num) = pool.seq_nums_by_topic.insert(topic.clone(), seq_num) {
            pool.txn_queue.remove(&old_seq_num);
        }

        TxnGuard {
            pool: self.inner.clone(),
            seq_num,
        }
    }
```
