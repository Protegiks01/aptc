# Audit Report

## Title
InMemoryStorage.available() Provides False Safety Confidence Enabling Consensus Safety Rule Violations After Process Restart

## Summary
The `available()` function in `InMemoryStorage` always returns `Ok(())`, providing false confidence that storage is reliable when the storage backend loses all data on process restart. This enables consensus safety rule violations in testnet/devnet environments where validators use InMemoryStorage and experience process crashes, potentially leading to double-voting and equivocation.

## Finding Description

The vulnerability lies in how `InMemoryStorage` reports its availability status versus its actual reliability guarantees. [1](#0-0) 

The `available()` function always returns success, but the implementation comment explicitly warns this is "intended for single threads" and "should not be used in production". [2](#0-1) 

The storage availability check is used as a critical safety gate in consensus initialization: [3](#0-2) 

When a validator process crashes and restarts, `InMemoryStorage` is completely empty (all data lost), but `available()` still returns `Ok(())`. The initialization logic then proceeds to create fresh `SafetyData`: [4](#0-3) 

This resets critical consensus safety state to initial values (epoch=1, last_voted_round=0), losing the actual voting history. [5](#0-4) 

The consensus safety rules rely on `last_voted_round` to prevent double-voting: [6](#0-5) 

**Attack Scenario:**
1. Testnet/devnet validator uses `InMemoryStorage` (allowed by config, blocked only on mainnet [7](#0-6) )
2. Validator votes on proposal at round 10 (`last_voted_round = 10`)
3. Process crashes (OOM, panic, hardware failure)
4. On restart, `available()` check passes (false confidence)
5. `SafetyData` is re-initialized with `last_voted_round = 0`
6. Validator can now vote on rounds 1-9 that it already voted on
7. This creates equivocation - two different votes from same validator in same epoch

## Impact Explanation

**Medium Severity** - This qualifies as "State inconsistencies requiring intervention" under the bug bounty criteria.

The vulnerability enables violation of Consensus Safety Invariant #2: "AptosBFT must prevent double-spending and chain splits under < 1/3 Byzantine". When validators lose safety state and can double-vote, it undermines the consensus protocol's safety guarantees.

However, impact is limited because:
- Config sanitizer blocks `InMemoryStorage` on mainnet validators
- Only affects testnet/devnet environments where it's explicitly allowed
- Requires accidental process crashes (not attacker-controlled)
- Does not directly lead to fund theft or network-wide failure

The false confidence from `available()` creates operational risk in pre-production environments used for testing protocol upgrades.

## Likelihood Explanation

**Medium Likelihood** in affected environments:
- Testnets/devnets commonly use `InMemoryStorage` for ease of setup
- Process crashes are common operational events (OOM, bugs, infrastructure issues)  
- Each crash+restart cycle resets safety state, enabling violations
- The `available()` check provides no warning that data was lost

**Low Likelihood** for mainnet exploitation:
- Explicitly blocked by configuration validator
- Would require validator operator to bypass safety checks

## Recommendation

Modify `available()` to verify that expected safety-critical data exists in storage, rather than always returning success:

```rust
impl KVStorage for InMemoryStorage {
    fn available(&self) -> Result<(), Error> {
        // For in-memory storage, verify critical keys exist if previously initialized
        if self.data.is_empty() {
            Ok(()) // Fresh storage is available
        } else {
            // Storage has data - verify critical consensus keys exist
            if self.data.contains_key(SAFETY_DATA) && 
               self.data.contains_key(WAYPOINT) {
                Ok(())
            } else {
                Err(Error::InternalError(
                    "InMemoryStorage has partial data - potential data loss detected".into()
                ))
            }
        }
    }
}
```

Alternatively, document that `InMemoryStorage` should **never** be used with consensus safety rules, even in test environments, and enforce this at the type system level or with runtime assertions.

## Proof of Concept

```rust
#[test]
fn test_in_memory_storage_false_availability_after_data_loss() {
    use aptos_secure_storage::{InMemoryStorage, KVStorage};
    use aptos_consensus_types::safety_data::SafetyData;
    use aptos_global_constants::SAFETY_DATA;
    
    // Step 1: Create storage and store safety data
    let mut storage = InMemoryStorage::new();
    let safety_data = SafetyData::new(1, 10, 8, 5, None, 0);
    storage.set(SAFETY_DATA, safety_data.clone()).unwrap();
    
    // Verify data exists
    let retrieved: SafetyData = storage.get(SAFETY_DATA).unwrap().value;
    assert_eq!(retrieved.last_voted_round, 10);
    
    // Step 2: Simulate process crash - create new InMemoryStorage instance
    let mut new_storage = InMemoryStorage::new();
    
    // Step 3: Check availability - THIS PASSES despite data loss!
    assert!(new_storage.available().is_ok(), "available() should warn about data loss");
    
    // Step 4: Try to read safety data - fails because data is lost
    let result = new_storage.get::<SafetyData>(SAFETY_DATA);
    assert!(result.is_err(), "Data should be lost after 'crash'");
    
    // Step 5: Re-initialize with fresh data (simulating restart logic)
    let fresh_data = SafetyData::new(1, 0, 0, 0, None, 0);
    new_storage.set(SAFETY_DATA, fresh_data).unwrap();
    
    // Step 6: Validator now has last_voted_round = 0, can vote on already-voted rounds
    let retrieved: SafetyData = new_storage.get(SAFETY_DATA).unwrap().value;
    assert_eq!(retrieved.last_voted_round, 0, 
        "Safety state reset - validator can now double-vote on rounds 1-10");
}
```

## Notes

While this vulnerability has real security implications for consensus safety, it requires validators to be misconfigured with `InMemoryStorage` (explicitly blocked on mainnet) and relies on process crashes rather than attacker-controlled exploitation. The core issue is that `available()` provides false confidence about storage reliability, masking data loss that leads to safety rule violations.

### Citations

**File:** secure/storage/src/in_memory.rs (L9-14)
```rust
/// InMemoryStorage represents a key value store that is purely in memory and intended for single
/// threads (or must be wrapped by a Arc<RwLock<>>). This provides no permission checks and simply
/// is a proof of concept to unblock building of applications without more complex data stores.
/// Internally, it retains all data, which means that it must make copies of all key material which
/// violates the code base. It violates it because the anticipation is that data stores would
/// securely handle key material. This should not be used in production.
```

**File:** secure/storage/src/in_memory.rs (L37-39)
```rust
    fn available(&self) -> Result<(), Error> {
        Ok(())
    }
```

**File:** consensus/safety-rules/src/safety_rules_manager.rs (L24-26)
```rust
    if let Err(error) = internal_storage.available() {
        panic!("Storage is not available: {:?}", error);
    }
```

**File:** consensus/safety-rules/src/safety_rules_manager.rs (L28-43)
```rust
    if let Some(test_config) = &config.test {
        let author = test_config.author;
        let consensus_private_key = test_config
            .consensus_key
            .as_ref()
            .expect("Missing consensus key in test config")
            .private_key();
        let waypoint = test_config.waypoint.expect("No waypoint in config");

        PersistentSafetyStorage::initialize(
            internal_storage,
            author,
            consensus_private_key,
            waypoint,
            config.enable_cached_safety_data,
        )
```

**File:** consensus/consensus-types/src/safety_data.rs (L8-21)
```rust
/// Data structure for safety rules to ensure consensus safety.
#[derive(Debug, Deserialize, Eq, PartialEq, Serialize, Clone, Default)]
pub struct SafetyData {
    pub epoch: u64,
    pub last_voted_round: u64,
    // highest 2-chain round, used for 3-chain
    pub preferred_round: u64,
    // highest 1-chain round, used for 2-chain
    #[serde(default)]
    pub one_chain_round: u64,
    pub last_vote: Option<Vote>,
    #[serde(default)]
    pub highest_timeout_round: u64,
}
```

**File:** consensus/safety-rules/src/safety_rules.rs (L213-232)
```rust
    pub(crate) fn verify_and_update_last_vote_round(
        &self,
        round: Round,
        safety_data: &mut SafetyData,
    ) -> Result<(), Error> {
        if round <= safety_data.last_voted_round {
            return Err(Error::IncorrectLastVotedRound(
                round,
                safety_data.last_voted_round,
            ));
        }

        safety_data.last_voted_round = round;
        trace!(
            SafetyLogSchema::new(LogEntry::LastVotedRound, LogEvent::Update)
                .last_voted_round(safety_data.last_voted_round)
        );

        Ok(())
    }
```

**File:** config/src/config/safety_rules_config.rs (L85-96)
```rust
        if let Some(chain_id) = chain_id {
            // Verify that the secure backend is appropriate for mainnet validators
            if chain_id.is_mainnet()
                && node_type.is_validator()
                && safety_rules_config.backend.is_in_memory()
            {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "The secure backend should not be set to in memory storage in mainnet!"
                        .to_string(),
                ));
            }
```
