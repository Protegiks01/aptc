# Audit Report

## Title
State Snapshot Metadata Lacks Validation Against Manifest Content Leading to Version Mismatch

## Summary
The `StateSnapshotBackupMeta` structure contains `version` and `epoch` fields along with a `manifest` FileHandle, but there is no validation during restore that the version/epoch in the metadata matches the actual version/epoch in the manifest file. This allows modified metadata to point to different snapshot data, causing state from one version to be restored and tagged as a different version in the database.

## Finding Description

The backup system stores state snapshot metadata in `StateSnapshotBackupMeta` which contains three public fields: `epoch`, `version`, and `manifest` (a FileHandle pointing to the actual manifest JSON file). [1](#0-0) 

When a state snapshot backup is created, both the metadata and manifest are created with matching version and epoch values: [2](#0-1) [3](#0-2) 

However, during restore, the `StateSnapshotRestoreOpt` is constructed using the metadata's `version` and `manifest` fields directly: [4](#0-3) 

The critical issue occurs in the restore controller where:
1. The manifest is loaded from the FileHandle
2. Cryptographic verification uses `manifest.version` (from the loaded manifest file)
3. The state restore receiver is created with `self.version` (from the metadata) [5](#0-4) 

**There is no validation that `self.version == manifest.version` or `self.epoch == manifest.epoch`.**

The state restore receiver then writes all key-value pairs to the database tagged with the metadata's version: [6](#0-5) 

**Attack Path:**
If an attacker gains write access to backup storage (through misconfiguration, compromised credentials, or insider access), they can:
1. Modify a `StateSnapshotBackupMeta` file
2. Change the `manifest` FileHandle to point to a different snapshot (e.g., from version 2000 instead of version 1000)
3. Keep `version: 1000` and `epoch: 10` in the metadata
4. During restore:
   - System reads metadata claiming version 1000, epoch 10
   - Loads manifest from modified FileHandle (actually containing version 2000, epoch 20 data)
   - Cryptographic proof validates successfully (using version 2000 from manifest)
   - State data from version 2000 is written to database tagged as version 1000
5. Result: Database contains incorrect state for version 1000, breaking ledger integrity

## Impact Explanation

**High Severity** - This breaks fundamental state consistency invariants:
- **State Consistency Violation**: The database would contain state from version Z tagged as version X, violating the invariant that "State transitions must be atomic and verifiable via Merkle proofs"
- **Consensus Divergence Risk**: Different validator nodes restoring from tampered vs. untampered metadata would have different states, potentially causing consensus failures
- **Ledger Integrity Compromise**: Historical state at a given version would not match what was actually committed, corrupting the ledger history

While this requires privileged access to backup storage, it represents a significant protocol violation because:
1. Backup/restore is critical for validator operations and disaster recovery
2. Different nodes could restore inconsistent states if metadata is tampered with
3. The system provides no defense-in-depth against storage compromise

Per Aptos bug bounty criteria, this qualifies as **High Severity** due to "Significant protocol violations" and potential "Validator node" issues from state inconsistencies.

## Likelihood Explanation

**Moderate-to-Low likelihood** but **High impact if exploited**:

**Prerequisites:**
- Attacker needs write access to backup storage (compromised credentials, misconfigured storage, or insider threat)
- This is a privileged access requirement, limiting the attack surface

**Realistic scenarios:**
- Misconfigured cloud storage buckets (publicly writable S3/GCS buckets)
- Stolen backup storage credentials
- Malicious insider with backup infrastructure access
- Compromised backup automation systems

While backup storage should be secured, defense-in-depth principles require integrity validation even for trusted storage.

## Recommendation

Add cryptographic integrity validation to prevent metadata tampering:

**Solution 1: Validate version/epoch consistency (immediate fix)**
```rust
// In StateSnapshotRestoreController::run_impl()
async fn run_impl(self) -> Result<()> {
    if self.version > self.target_version {
        // ... existing check ...
    }

    let manifest: StateSnapshotBackup =
        self.storage.load_json_file(&self.manifest_handle).await?;
    
    // ADD THIS VALIDATION
    ensure!(
        manifest.version == self.version,
        "Version mismatch: metadata claims version {}, but manifest contains version {}",
        self.version,
        manifest.version
    );
    
    ensure!(
        manifest.epoch == self.epoch, // need to add epoch field to StateSnapshotRestoreOpt
        "Epoch mismatch: metadata claims epoch {}, but manifest contains epoch {}",
        self.epoch,
        manifest.epoch
    );

    // ... rest of existing code ...
}
```

**Solution 2: Cryptographic integrity (comprehensive fix)**
Add hash/signature to metadata:
```rust
#[derive(Clone, Debug, Deserialize, Serialize, Eq, PartialEq, Ord, PartialOrd)]
pub struct StateSnapshotBackupMeta {
    pub epoch: u64,
    pub version: Version,
    pub manifest: FileHandle,
    pub manifest_hash: HashValue, // Hash of manifest file content
}
```

Verify hash during restore before loading manifest content.

## Proof of Concept

```rust
// Proof of Concept - Demonstrating the vulnerability
// This would be a test that shows no validation occurs

#[tokio::test]
async fn test_manifest_redirect_vulnerability() {
    // Setup: Create two different state snapshots
    let storage = Arc::new(create_test_storage());
    
    // Create snapshot 1 at version 1000
    let backup1 = create_state_snapshot(1000, 10, &storage).await;
    let manifest1_handle = backup1.manifest.clone();
    
    // Create snapshot 2 at version 2000 (different state)
    let backup2 = create_state_snapshot(2000, 20, &storage).await;
    let manifest2_handle = backup2.manifest.clone();
    
    // Create metadata claiming version 1000 but pointing to manifest 2
    let tampered_meta = StateSnapshotBackupMeta {
        epoch: 10,
        version: 1000,
        manifest: manifest2_handle, // Points to version 2000 manifest!
    };
    
    // Attempt restore
    let restore_opt = StateSnapshotRestoreOpt {
        manifest_handle: tampered_meta.manifest,
        version: tampered_meta.version,
        validate_modules: false,
        restore_mode: StateSnapshotRestoreMode::Default,
    };
    
    let controller = StateSnapshotRestoreController::new(
        restore_opt,
        create_global_opts(),
        storage,
        None,
    );
    
    // This should fail but currently succeeds!
    controller.run().await.expect("Should validate version mismatch");
    
    // Verify: DB now has state from version 2000 tagged as version 1000
    // This breaks ledger integrity!
}
```

**Note:** This vulnerability requires privileged access to backup storage infrastructure, which limits its exploitability to insider threats or compromised storage scenarios. However, it represents a valid defense-in-depth gap that should be addressed.

### Citations

**File:** storage/backup/backup-cli/src/metadata/mod.rs (L184-189)
```rust
#[derive(Clone, Debug, Deserialize, Serialize, Eq, PartialEq, Ord, PartialOrd)]
pub struct StateSnapshotBackupMeta {
    pub epoch: u64,
    pub version: Version,
    pub manifest: FileHandle,
}
```

**File:** storage/backup/backup-cli/src/backup_types/state_snapshot/backup.rs (L465-471)
```rust
        let manifest = StateSnapshotBackup {
            epoch: self.epoch,
            version: self.version(),
            root_hash: txn_info.transaction_info().ensure_state_checkpoint_hash()?,
            chunks,
            proof: proof_handle,
        };
```

**File:** storage/backup/backup-cli/src/backup_types/state_snapshot/backup.rs (L482-489)
```rust
        let metadata = Metadata::new_state_snapshot_backup(
            self.epoch,
            self.version(),
            manifest_handle.clone(),
        );
        self.storage
            .save_metadata_line(&metadata.name(), &metadata.to_text_line()?)
            .await?;
```

**File:** storage/backup/backup-cli/src/coordinators/restore.rs (L247-253)
```rust
                StateSnapshotRestoreController::new(
                    StateSnapshotRestoreOpt {
                        manifest_handle: kv_snapshot.manifest,
                        version: kv_snapshot.version,
                        validate_modules: false,
                        restore_mode: StateSnapshotRestoreMode::KvOnly,
                    },
```

**File:** storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs (L123-145)
```rust
        let manifest: StateSnapshotBackup =
            self.storage.load_json_file(&self.manifest_handle).await?;
        let (txn_info_with_proof, li): (TransactionInfoWithProof, LedgerInfoWithSignatures) =
            self.storage.load_bcs_file(&manifest.proof).await?;
        txn_info_with_proof.verify(li.ledger_info(), manifest.version)?;
        let state_root_hash = txn_info_with_proof
            .transaction_info()
            .ensure_state_checkpoint_hash()?;
        ensure!(
            state_root_hash == manifest.root_hash,
            "Root hash mismatch with that in proof. root hash: {}, expected: {}",
            manifest.root_hash,
            state_root_hash,
        );
        if let Some(epoch_history) = self.epoch_history.as_ref() {
            epoch_history.verify_ledger_info(&li)?;
        }

        let receiver = Arc::new(Mutex::new(Some(self.run_mode.get_state_restore_receiver(
            self.version,
            manifest.root_hash,
            self.restore_mode,
        )?)));
```

**File:** storage/aptosdb/src/state_restore/mod.rs (L117-120)
```rust
        let kv_batch: StateValueBatch<K, Option<V>> = chunk
            .into_iter()
            .map(|(k, v)| ((k, self.version), Some(v)))
            .collect();
```
