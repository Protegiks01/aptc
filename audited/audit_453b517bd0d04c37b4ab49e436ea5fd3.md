# Audit Report

## Title
GroupKeyRef Equivalence Violation Due to StateKey Pointer-Based Equality Breaking DashMap Lookups

## Summary
The `GroupKeyRef` Equivalent trait implementation can fail to find existing entries in DashMap when used with `StateKey` as the key type, due to StateKey's pointer-based equality (`Arc::ptr_eq`) conflicting with its content-based hashing. This violates the fundamental hash map invariant and can cause lookup failures, panics, and non-deterministic parallel execution behavior.

## Finding Description

The vulnerability exists in the interaction between three components:

1. **StateKey's inconsistent Eq/Hash implementation**: [1](#0-0) 

   StateKey uses `Arc::ptr_eq` for equality but content-based crypto hash for hashing. This violates the Eq/Hash contract that if `a == b`, then `hash(a) == hash(b)` must hold. More critically, it means two StateKeys with identical content but different Arc pointers will hash to the same value but compare as not equal.

2. **GroupKeyRef's Equivalent implementation**: [2](#0-1) 

   The equivalence check `self.group_key == &key.0` dereferences both sides and calls StateKey's `PartialEq`, which uses Arc pointer comparison, not content comparison.

3. **Production usage with StateKey**: [3](#0-2) 

   In production, `K = StateKey` and `T = StructTag`.

**Attack Scenario:**
1. Transaction T1 writes to resource group at StateKey instance `sk1` with content C
2. Tuple `(sk1, tag)` is stored in VersionedData's DashMap
3. T1 completes, dropping its reference to `sk1`
4. The Weak reference in StateKey's registry expires (no strong references remain)
5. Transaction T2 creates StateKey instance `sk2` with same content C
6. Registry returns a NEW Arc (old Weak expired) - `sk2` has different pointer than `sk1`
7. T2 calls `mark_estimate(&sk2, txn_idx, tags)` or `remove(&sk2, txn_idx, tags)`
8. GroupKeyRef is created with `group_key = &sk2`
9. DashMap lookup:
   - Hash matches: `hash(GroupKeyRef{sk2, tag}) == hash((sk1, tag))` âœ“
   - But equivalence fails: `GroupKeyRef.equivalent((sk1, tag))` returns `false` due to `sk2 != sk1` (different Arc pointers)
10. Operation panics with "Path must exist" or "Entry by the txn must exist" [4](#0-3) 

The panic occurs because the code expects the key to exist but the lookup fails due to pointer inequality despite content equality.

## Impact Explanation

**Medium Severity** - This vulnerability can cause:

1. **Validator node crashes**: Panics from failed assertions when paths/entries are expected to exist
2. **Non-deterministic execution**: Different validators may experience different timing of Weak reference expiration, leading to divergent behavior during parallel block execution
3. **State inconsistencies**: Failed mark_estimate/remove operations can corrupt the multi-version data structure's internal state
4. **Consensus impact**: If validators diverge due to timing-dependent lookup failures, this violates the Deterministic Execution invariant

The impact is limited to Medium rather than Critical because:
- Requires specific timing conditions (Weak reference expiration)
- Doesn't directly enable fund theft or permanent state corruption
- Can potentially be recovered through block re-execution
- Registry internment reduces likelihood in normal operation

However, it clearly breaks the **Deterministic Execution** invariant (#1) since validator behavior depends on garbage collection timing.

## Likelihood Explanation

**Medium Likelihood** in production scenarios:

**Factors Increasing Likelihood:**
- High transaction throughput increases GC pressure and Weak reference turnover
- Long-running blocks with many parallel transactions
- Resource groups that are accessed sporadically (references dropped between accesses)
- Memory pressure causing aggressive Arc cleanup

**Factors Decreasing Likelihood:**
- StateKey registry internment typically keeps Arc pointers stable
- MVHashMap likely holds strong references during transaction execution
- Most operations use the same StateKey instance throughout transaction lifecycle

The vulnerability is most likely to manifest during:
- Stress testing with high concurrency
- Edge cases in BlockSTM dependency tracking
- Validator restarts or state synchronization where StateKeys are recreated

## Recommendation

**Fix the Equivalence Implementation** to use content-based comparison instead of pointer-based:

```rust
impl<'a, K, T> Equivalent<(K, T)> for GroupKeyRef<'a, K, T>
where
    K: PartialEq,  // Change from Eq to PartialEq to support content comparison
    T: Eq,
{
    fn equivalent(&self, key: &(K, T)) -> bool {
        // Use PartialEq which works correctly for both &K and K
        self.group_key == &key.0 && self.tag == &key.1
    }
}
```

However, this alone is insufficient. The **root cause** is StateKey's violated Eq/Hash invariant. The proper fix requires ONE of:

**Option A: Fix StateKey's PartialEq** (recommended):
```rust
impl PartialEq for StateKey {
    fn eq(&self, other: &Self) -> bool {
        // Use content comparison instead of pointer comparison
        self.crypto_hash_ref() == other.crypto_hash_ref()
    }
}
```

**Option B: Fix StateKey's Hash** (alternative):
```rust
impl Hash for StateKey {
    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
        // Use pointer hash to match pointer-based equality
        Arc::as_ptr(&self.0).hash(state)
    }
}
```

Option A is strongly recommended as it aligns with semantic equality and fixes the root cause.

## Proof of Concept

```rust
#[test]
fn test_statekey_equivalence_violation() {
    use aptos_types::state_store::state_key::StateKey;
    use move_core_types::{account_address::AccountAddress, language_storage::StructTag};
    use dashmap::DashMap;
    
    // Create a StateKey
    let addr = AccountAddress::random();
    let struct_tag = StructTag {
        address: addr,
        module: "test".parse().unwrap(),
        name: "Resource".parse().unwrap(),
        type_args: vec![],
    };
    
    let key1 = StateKey::resource(&addr, &struct_tag).unwrap();
    let tag = struct_tag.clone();
    
    // Store in map
    let map: DashMap<(StateKey, StructTag), u32> = DashMap::new();
    map.insert((key1.clone(), tag.clone()), 42);
    
    // Force key1 to be dropped (in real scenario, transaction completes)
    drop(key1);
    
    // Force GC to potentially expire Weak reference
    // (In production, this happens naturally under memory pressure)
    std::thread::sleep(std::time::Duration::from_millis(100));
    
    // Create "equivalent" StateKey
    let key2 = StateKey::resource(&addr, &struct_tag).unwrap();
    
    // Verify they hash the same
    use std::hash::{Hash, Hasher};
    use std::collections::hash_map::DefaultHasher;
    let mut h1 = DefaultHasher::new();
    let mut h2 = DefaultHasher::new();
    key1_recovered.hash(&mut h1);
    key2.hash(&mut h2);
    assert_eq!(h1.finish(), h2.finish(), "Hashes should match");
    
    // But they're not equal
    assert_ne!(key1_recovered, key2, "Pointer equality fails");
    
    // Lookup with GroupKeyRef fails
    let key_ref = GroupKeyRef {
        group_key: &key2,
        tag: &tag,
    };
    
    // This will fail to find the entry despite matching hash
    assert!(map.get(&key_ref).is_none(), "Lookup fails due to pointer inequality");
}
```

**Notes:**
- The actual manifestation requires timing conditions where Weak references expire
- The test demonstrates the hash/equality mismatch that breaks DashMap's lookup invariant
- In production BlockSTM, this causes panics in `mark_estimate` and `remove` operations when expected entries aren't found

### Citations

**File:** types/src/state_store/state_key/mod.rs (L261-273)
```rust
impl PartialEq for StateKey {
    fn eq(&self, other: &Self) -> bool {
        Arc::ptr_eq(&self.0, &other.0)
    }
}

impl Eq for StateKey {}

impl Hash for StateKey {
    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
        state.write(self.crypto_hash_ref().as_ref())
    }
}
```

**File:** aptos-move/mvhashmap/src/versioned_group_data.rs (L103-111)
```rust
impl<'a, K, T> Equivalent<(K, T)> for GroupKeyRef<'a, K, T>
where
    K: Eq,
    T: Eq,
{
    fn equivalent(&self, key: &(K, T)) -> bool {
        self.group_key == &key.0 && self.tag == &key.1
    }
}
```

**File:** types/src/transaction/signature_verified_transaction.rs (L90-94)
```rust
impl BlockExecutableTransaction for SignatureVerifiedTransaction {
    type Event = ContractEvent;
    type Key = StateKey;
    type Tag = StructTag;
    type Value = WriteOp;
```

**File:** aptos-move/mvhashmap/src/versioned_data.rs (L434-445)
```rust
    pub fn mark_estimate<Q>(&self, key: &Q, txn_idx: TxnIndex)
    where
        Q: Equivalent<K> + Hash,
    {
        // Use dashmap's get method which accepts a reference when Borrow is implemented
        // The equivalent crate automatically implements the right traits.
        let v = self.values.get(key).expect("Path must exist");
        v.versioned_map
            .get(&ShiftedTxnIndex::new(txn_idx))
            .expect("Entry by the txn must exist to mark estimate")
            .mark_estimate();
    }
```
