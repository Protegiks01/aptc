# Audit Report

## Title
Version Fingerprinting via Peer Monitoring Service Exposes Vulnerable Validators to Targeted Attacks

## Summary
The Peer Monitoring Service exposes complete build information (commit hash, version tag, build time, etc.) to any connected peer through the `GetNodeInformation` request handler. This allows adversaries to fingerprint validator versions and identify nodes running outdated software with known vulnerabilities, enabling targeted exploitation.

## Finding Description
While the security question focuses on telemetry push frequency controlled by `NODE_BUILD_INFO_FREQ_SECS`, the actual vulnerability exists in a different system: the Peer Monitoring Service. This service exposes build information on-demand to any peer without access controls.

The `GetNodeInformation` handler in the Peer Monitoring Service returns complete build information to any connected peer: [1](#0-0) 

The build information includes sensitive version details: [2](#0-1) 

This includes: commit hash, branch name, tag (release version), build time, Rust version, and compilation profile. The `NodeInformationResponse` structure explicitly includes this as a public field: [3](#0-2) 

**Attack Scenario:**

1. An adversary connects to the Aptos network as a validator, VFN, or public fullnode
2. The Peer Monitoring Service is registered on ALL network types during node initialization: [4](#0-3) 

3. The adversary sends `PeerMonitoringServiceRequest::GetNodeInformation` to target validators
4. The service responds with complete build information including exact commit hash and version tag
5. The adversary correlates this with known CVE databases to identify vulnerable validators
6. Targeted attacks are launched against specific validators running outdated versions with known exploits

**Why This Breaks Security Invariants:**

This violates the principle of least privilege and operational security best practices. Validators should not expose their exact software versions to untrusted peers, as this enables reconnaissance for targeted attacks. During network upgrades when validators are transitioning between versions, this information allows adversaries to identify and exploit lagging validators with maximum efficiency.

## Impact Explanation
This is a **Medium Severity** vulnerability per the Aptos bug bounty criteria ($10,000 category: "Minor information leaks").

However, the impact extends beyond a simple information leak:

- **Reconnaissance Enabler**: Allows adversaries to build a complete map of validator versions across the network
- **Targeted Exploitation**: Enables focused attacks on validators running versions with known CVEs
- **Upgrade Window Attacks**: During network upgrades, adversaries can identify slow-to-upgrade validators and target them before they patch
- **Network Analysis**: Allows adversaries to understand network topology and validator upgrade patterns
- **Correlation with On-Chain Data**: Combined with on-chain staking data, adversaries can identify high-value targets running vulnerable software

While this doesn't directly cause fund loss or consensus violations, it significantly reduces the security posture of the network by enabling targeted attacks that could lead to:
- Validator node compromise
- Consensus manipulation if enough vulnerable validators are identified
- Denial of service attacks targeting specific version vulnerabilities

## Likelihood Explanation
**Likelihood: High**

This vulnerability is trivially exploitable:
- **No Authentication Required**: Any peer can send the request
- **Low Barrier to Entry**: An adversary only needs to run a fullnode to connect to the network
- **Zero Cost**: No stake or economic investment required
- **Automated Scanning**: Adversaries can programmatically scan all reachable validators
- **Immediate Information**: Response is returned synchronously, no timing attacks needed

The attack is feasible for:
- Competitors analyzing network security
- Nation-state actors targeting specific validators
- Security researchers (ethical disclosure)
- Malicious actors preparing targeted attacks

## Recommendation
Implement access controls on the Peer Monitoring Service's `GetNodeInformation` endpoint:

**Option 1: Remove Build Information from Response (Recommended)**
```rust
fn get_node_information(&self) -> Result<PeerMonitoringServiceResponse, Error> {
    // Get the node information - REMOVED: build_information
    let current_time: Instant = self.time_service.now();
    let uptime = current_time.duration_since(self.start_time);
    let (highest_synced_epoch, highest_synced_version) =
        self.storage.get_highest_synced_epoch_and_version()?;
    let ledger_timestamp_usecs = self.storage.get_ledger_timestamp_usecs()?;
    let lowest_available_version = self.storage.get_lowest_available_version()?;

    // Create and return the response WITHOUT sensitive build information
    let node_information_response = NodeInformationResponse {
        build_information: BTreeMap::new(), // Empty map instead of full build info
        highest_synced_epoch,
        highest_synced_version,
        ledger_timestamp_usecs,
        lowest_available_version,
        uptime,
    };
    Ok(PeerMonitoringServiceResponse::NodeInformation(
        node_information_response,
    ))
}
```

**Option 2: Sanitize Build Information**
Only expose non-sensitive fields like major/minor version without exact commit hashes:
```rust
fn get_sanitized_build_information() -> BTreeMap<String, String> {
    let mut sanitized = BTreeMap::new();
    sanitized.insert("major_version".to_string(), "1.0".to_string());
    // Omit: commit_hash, build_time, branch, exact tags
    sanitized
}
```

**Option 3: Restrict to Trusted Peers Only**
Implement authentication and only return full build information to explicitly trusted peers (e.g., same operator's nodes).

## Proof of Concept
```rust
use aptos_peer_monitoring_service_types::{
    request::PeerMonitoringServiceRequest,
    response::PeerMonitoringServiceResponse,
};

// Attacker code to fingerprint validators
async fn fingerprint_validator(network_client: &NetworkClient, target_peer: PeerId) {
    // Send GetNodeInformation request to target validator
    let request = PeerMonitoringServiceRequest::GetNodeInformation;
    
    match network_client.send_request(target_peer, request).await {
        Ok(PeerMonitoringServiceResponse::NodeInformation(response)) => {
            // Extract sensitive version information
            let commit_hash = response.build_information.get("build_commit_hash");
            let version_tag = response.build_information.get("build_tag");
            let build_time = response.build_information.get("build_time");
            
            println!("Target {} running:", target_peer);
            println!("  Commit: {:?}", commit_hash);
            println!("  Version: {:?}", version_tag);
            println!("  Built: {:?}", build_time);
            
            // Check against vulnerability database
            if is_vulnerable_version(version_tag) {
                println!("  [!] VULNERABLE - Exploitable CVE found!");
                launch_targeted_attack(target_peer, version_tag);
            }
        }
        _ => println!("Failed to fingerprint {}", target_peer),
    }
}

fn is_vulnerable_version(version: Option<&String>) -> bool {
    // Check if version has known CVEs
    // Example: versions before 1.8.0 had specific vulnerabilities
    match version {
        Some(v) if v.starts_with("aptos-node-v1.7") => true,
        Some(v) if v.starts_with("aptos-node-v1.6") => true,
        _ => false,
    }
}
```

**Testing Steps:**
1. Deploy two fullnodes on the same network
2. From Node A, send `GetNodeInformation` request to Node B
3. Observe that Node B returns complete build information including commit hash
4. Verify that no authentication is required
5. Demonstrate that this information can be correlated with CVE databases

## Notes
While the security question references `NODE_BUILD_INFO_FREQ_SECS` in the telemetry service, that constant controls periodic pushes to Aptos Labs' private telemetry servers and does not represent a security vulnerability. The actual vulnerability exists in the Peer Monitoring Service's on-demand exposure of build information to untrusted peers. This distinction is important: the telemetry system is secure (authenticated, private destination), but the peer monitoring service lacks these protections.

### Citations

**File:** peer-monitoring-service/server/src/lib.rs (L259-281)
```rust
    fn get_node_information(&self) -> Result<PeerMonitoringServiceResponse, Error> {
        // Get the node information
        let build_information = aptos_build_info::get_build_information();
        let current_time: Instant = self.time_service.now();
        let uptime = current_time.duration_since(self.start_time);
        let (highest_synced_epoch, highest_synced_version) =
            self.storage.get_highest_synced_epoch_and_version()?;
        let ledger_timestamp_usecs = self.storage.get_ledger_timestamp_usecs()?;
        let lowest_available_version = self.storage.get_lowest_available_version()?;

        // Create and return the response
        let node_information_response = NodeInformationResponse {
            build_information,
            highest_synced_epoch,
            highest_synced_version,
            ledger_timestamp_usecs,
            lowest_available_version,
            uptime,
        };
        Ok(PeerMonitoringServiceResponse::NodeInformation(
            node_information_response,
        ))
    }
```

**File:** crates/aptos-build-info/src/lib.rs (L59-105)
```rust
pub fn get_build_information() -> BTreeMap<String, String> {
    shadow!(build);

    let mut build_information = BTreeMap::new();

    // Get Git metadata from shadow_rs crate.
    // This is applicable for native builds where the cargo has
    // access to the .git directory.
    build_information.insert(BUILD_BRANCH.into(), build::BRANCH.into());
    build_information.insert(BUILD_CARGO_VERSION.into(), build::CARGO_VERSION.into());
    build_information.insert(BUILD_CLEAN_CHECKOUT.into(), build::GIT_CLEAN.to_string());
    build_information.insert(BUILD_COMMIT_HASH.into(), build::COMMIT_HASH.into());
    build_information.insert(BUILD_TAG.into(), build::TAG.into());
    build_information.insert(BUILD_TIME.into(), build::BUILD_TIME.into());
    build_information.insert(BUILD_OS.into(), build::BUILD_OS.into());
    build_information.insert(BUILD_RUST_CHANNEL.into(), build::RUST_CHANNEL.into());
    build_information.insert(BUILD_RUST_VERSION.into(), build::RUST_VERSION.into());

    // Compilation information
    build_information.insert(BUILD_IS_RELEASE_BUILD.into(), is_release().to_string());
    build_information.insert(BUILD_PROFILE_NAME.into(), get_build_profile_name());
    build_information.insert(
        BUILD_USING_TOKIO_UNSTABLE.into(),
        std::env!("USING_TOKIO_UNSTABLE").to_string(),
    );

    // Get Git metadata from environment variables set during build-time.
    // This is applicable for docker based builds  where the cargo cannot
    // access the .git directory, or to override shadow_rs provided info.
    if let Ok(git_sha) = std::env::var("GIT_SHA") {
        build_information.insert(BUILD_COMMIT_HASH.into(), git_sha);
    }

    if let Ok(git_branch) = std::env::var("GIT_BRANCH") {
        build_information.insert(BUILD_BRANCH.into(), git_branch);
    }

    if let Ok(git_tag) = std::env::var("GIT_TAG") {
        build_information.insert(BUILD_TAG.into(), git_tag);
    }

    if let Ok(build_date) = std::env::var("BUILD_DATE") {
        build_information.insert(BUILD_TIME.into(), build_date);
    }

    build_information
}
```

**File:** peer-monitoring-service/types/src/response.rs (L93-102)
```rust
/// A response for the node information request
#[derive(Clone, Debug, Default, Deserialize, Eq, PartialEq, Serialize)]
pub struct NodeInformationResponse {
    pub build_information: BTreeMap<String, String>, // The build information of the node
    pub highest_synced_epoch: u64,                   // The highest synced epoch of the node
    pub highest_synced_version: u64,                 // The highest synced version of the node
    pub ledger_timestamp_usecs: u64, // The latest timestamp of the blockchain (in microseconds)
    pub lowest_available_version: u64, // The lowest stored version of the node (in storage)
    pub uptime: Duration,            // The amount of time the peer has been running
}
```

**File:** aptos-node/src/network.rs (L370-378)
```rust
        // Register the peer monitoring service (both client and server) with the network
        let peer_monitoring_service_network_handle = register_client_and_service_with_network(
            &mut network_builder,
            network_id,
            &network_config,
            peer_monitoring_network_configuration(node_config),
            true,
        );
        peer_monitoring_service_network_handles.push(peer_monitoring_service_network_handle);
```
