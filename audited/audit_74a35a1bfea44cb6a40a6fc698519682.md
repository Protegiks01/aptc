# Audit Report

## Title
Panic in DKG Verification Can Crash Validators Due to Missing Runtime Length Validation

## Summary
The DKG transcript verification process contains a panic in the `g1_multi_exp()` function that will crash validator nodes if array lengths mismatch. While the current implementation theoretically prevents this through careful length calculations, the only safeguards are debug assertions that are compiled out in release builds, creating a defensive programming weakness.

## Finding Description

The PCS trait's `verify()` method correctly returns `anyhow::Result<()>` to allow proper error propagation. [1](#0-0) 

However, during DKG transcript verification, the execution path flows through several layers:

1. VM processes DKG transcript: [2](#0-1) 

2. Calls weighted transcript verification: [3](#0-2) 

3. Performs low degree test: [4](#0-3) 

4. Calls multi-exponentiation: [5](#0-4) 

5. **Critical Panic Point**: The `g1_multi_exp()` function contains an unconditional panic: [6](#0-5) 

The only protections against this panic are debug assertions: [7](#0-6) 

Debug assertions are compiled out in release builds, which validators run.

## Impact Explanation

This falls under **High Severity** per Aptos bug bounty criteria for "Validator node slowdowns" and "API crashes". If triggered:
- Validator process terminates with a panic during transaction validation
- Validator becomes unavailable until manually restarted
- During critical DKG periods, this could affect network liveness if multiple validators are affected

However, **critical caveat**: While the panic exists and the defensive code is insufficient, I cannot demonstrate a concrete exploit path showing how to trigger the length mismatch with a malicious transcript. The current implementation appears to maintain length invariants through careful calculation.

## Likelihood Explanation

**Current likelihood: Low to theoretical**
- The length calculations appear correct in the current implementation
- Sizes are validated through `check_sizes()`: [8](#0-7) 
- LDT parameters are deterministically derived from validated sizes

**Future risk: Medium**
- Code changes could introduce edge cases
- The developers' use of debug assertions suggests they recognized potential issues
- Lack of runtime validation creates fragility

## Recommendation

Add explicit runtime validation before calling `g1_multi_exp`:

```rust
pub fn low_degree_test_on_g1(self, evals: &Vec<G1Projective>) -> anyhow::Result<()> {
    if evals.len() != self.n {
        bail!("Expected {} evaluations; got {}", self.n, evals.len())
    }

    if self.t == self.n {
        return Ok(());
    }

    let v_times_f = self.dual_code_word();
    
    // Add runtime validation instead of just debug_assert
    if evals.len() != v_times_f.len() {
        bail!("Length mismatch in LDT: evals.len()={} != v_times_f.len()={}", 
              evals.len(), v_times_f.len());
    }

    let zero = g1_multi_exp(evals.as_ref(), v_times_f.as_slice());
    // ... rest of function
}
```

Alternatively, modify `g1_multi_exp()` to return `Result` instead of panicking.

## Proof of Concept

I cannot provide a working PoC that demonstrates the vulnerability because I cannot construct a malicious transcript that:
1. Successfully deserializes
2. Passes all size validation checks
3. Causes length mismatch in the LDT calculation

The current implementation's length calculations appear sound. This report identifies a **defensive programming weakness** rather than a directly exploitable vulnerability.

---

**Note**: Given the strict validation requirements and my inability to demonstrate concrete exploitability, this issue may be better classified as a code quality concern rather than a security vulnerability. The panic exists as a safety mechanism for library bugs, and the actual attack surface remains unproven.

### Citations

**File:** crates/aptos-dkg/src/pcs/traits.rs (L53-60)
```rust
    fn verify(
        vk: &Self::VerificationKey,
        com: Self::Commitment,
        challenge: Vec<Self::WitnessField>,
        eval: Self::WitnessField,
        proof: Self::Proof,
        trs: &mut merlin::Transcript,
    ) -> anyhow::Result<()>;
```

**File:** aptos-move/aptos-vm/src/validator_txns/dkg.rs (L111-112)
```rust
        DefaultDKG::verify_transcript(&pub_params, &transcript)
            .map_err(|_| Expected(TranscriptVerificationFailed))?;
```

**File:** types/src/dkg/real_dkg/mod.rs (L368-374)
```rust
        trx.main.verify(
            &params.pvss_config.wconfig,
            &params.pvss_config.pp,
            &spks,
            &all_eks,
            &aux,
        )?;
```

**File:** crates/aptos-dkg/src/pvss/das/weighted_protocol.rs (L311-318)
```rust
        let ldt = LowDegreeTest::random(
            &mut rng,
            sc.get_threshold_weight(),
            W + 1,
            true,
            sc.get_batch_evaluation_domain(),
        );
        ldt.low_degree_test_on_g1(&self.V)?;
```

**File:** crates/aptos-dkg/src/pvss/das/weighted_protocol.rs (L415-455)
```rust
    fn check_sizes(&self, sc: &WeightedConfigBlstrs) -> anyhow::Result<()> {
        let W = sc.get_total_weight();

        if self.V.len() != W + 1 {
            bail!(
                "Expected {} G_2 (polynomial) commitment elements, but got {}",
                W + 1,
                self.V.len()
            );
        }

        if self.V_hat.len() != W + 1 {
            bail!(
                "Expected {} G_2 (polynomial) commitment elements, but got {}",
                W + 1,
                self.V_hat.len()
            );
        }

        if self.R.len() != W {
            bail!(
                "Expected {} G_1 commitment(s) to ElGamal randomness, but got {}",
                W,
                self.R.len()
            );
        }

        if self.R_hat.len() != W {
            bail!(
                "Expected {} G_2 commitment(s) to ElGamal randomness, but got {}",
                W,
                self.R_hat.len()
            );
        }

        if self.C.len() != W {
            bail!("Expected C of length {}, but got {}", W, self.C.len());
        }

        Ok(())
    }
```

**File:** crates/aptos-dkg/src/pvss/low_degree_test.rs (L141-161)
```rust
    pub fn low_degree_test_on_g1(self, evals: &Vec<G1Projective>) -> anyhow::Result<()> {
        if evals.len() != self.n {
            bail!("Expected {} evaluations; got {}", self.n, evals.len())
        }

        if self.t == self.n {
            return Ok(());
        }

        let v_times_f = self.dual_code_word();

        debug_assert_eq!(evals.len(), v_times_f.len());
        let zero = g1_multi_exp(evals.as_ref(), v_times_f.as_slice());

        (zero == G1Projective::identity())
            .then_some(())
            .context(format!(
                "the LDT G1 multiexp should return zero, but instead returned {}",
                zero
            ))
    }
```

**File:** crates/aptos-dkg/src/utils/mod.rs (L58-72)
```rust
pub fn g1_multi_exp(bases: &[G1Projective], scalars: &[blstrs::Scalar]) -> G1Projective {
    if bases.len() != scalars.len() {
        panic!(
            "blstrs's multiexp has heisenbugs when the # of bases != # of scalars ({} != {})",
            bases.len(),
            scalars.len()
        );
    }

    match bases.len() {
        0 => G1Projective::identity(),
        1 => bases[0].mul(scalars[0]),
        _ => G1Projective::multi_exp(bases, scalars),
    }
}
```
