# Audit Report

## Title
Non-Deterministic Package Build Due to Unsorted File System Traversal

## Summary
The `find_filenames` function uses `walkdir::WalkDir` without sorting, causing non-deterministic file ordering that propagates through package compilation, resulting in different module ordering in `PackageMetadata` for the same source code built on different systems.

## Finding Description

The package build process in Aptos contains a determinism flaw in file discovery. The vulnerability chain is:

1. **File Discovery**: [1](#0-0) 
   Uses `walkdir::WalkDir` without sorting, yielding files in filesystem-dependent order.

2. **Source Collection**: [2](#0-1) 
   Calls `find_move_filenames` which returns unsorted file paths.

3. **Compilation Order**: [3](#0-2) 
   Root package sources are passed to compiler in unsorted order (note: dependencies ARE sorted via BTreeSet at lines 1057-1061, but root sources are NOT).

4. **Module Ordering**: [4](#0-3) 
   Compiled units populate `root_compiled_units` in compiler output order.

5. **Metadata Extraction**: [5](#0-4) 
   Creates `modules` vec by iterating `root_modules()` in the non-deterministic order.

6. **Serialization Impact**: [6](#0-5) 
   `PackageMetadata.modules` is a `Vec`, so BCS serialization is order-dependent.

The codebase is aware of this issue - other locations explicitly sort: [7](#0-6) 

## Impact Explanation

This is a **build reproducibility issue** rather than a direct runtime security vulnerability. While the non-determinism is real, it does NOT meet Critical/High/Medium severity criteria because:

1. **No Direct Consensus Break**: Validators execute pre-serialized transaction data, not build packages during consensus
2. **No Fund Loss**: Does not enable theft or minting
3. **No Network Partition**: Normal operations use pre-built binaries

However, it creates operational risks:
- **Framework Upgrade Governance**: Different proposal creators get different hashes for identical source
- **Package Verification**: Users cannot verify on-chain code matches source
- **Genesis Risk**: IF validators built genesis independently from source (not pre-built binaries), they'd have divergent genesis states

## Likelihood Explanation

**Low likelihood of causing actual security harm** because:
- Validators use pre-built binaries with embedded `cached-packages`
- Governance proposals are built once by proposal creators
- Runtime doesn't rebuild packages

The issue manifests only when:
- Multiple parties independently build the same source
- Verification tools attempt to match on-chain bytes against rebuilt packages
- Disaster recovery requires building from source

## Recommendation

Apply deterministic sorting in file discovery:

```rust
// In third_party/move/move-command-line-common/src/files.rs
pub fn find_filenames<Predicate: FnMut(&Path) -> bool>(
    paths: &[impl AsRef<Path>],
    mut is_file_desired: Predicate,
) -> anyhow::Result<Vec<String>> {
    let mut result = vec![];
    
    for s in paths {
        let path = s.as_ref();
        if !path.exists() {
            bail!("No such file or directory '{}'", path.to_string_lossy())
        }
        if path.is_file() && is_file_desired(path) {
            result.push(path_to_string(path)?);
            continue;
        }
        if !path.is_dir() {
            continue;
        }
        // ADD SORTING HERE
        for entry in walkdir::WalkDir::new(path)
            .follow_links(true)
            .sort_by_file_name()  // <-- FIX: Add deterministic sorting
            .into_iter()
            .filter_map(|e| e.ok())
        {
            let entry_path = entry.path();
            if !entry.file_type().is_file() || !is_file_desired(entry_path) {
                continue;
            }
            result.push(path_to_string(entry_path)?);
        }
    }
    Ok(result)
}
```

## Proof of Concept

```bash
# Build the same package on two systems with different filesystems
# System A (ext4):
cd aptos-move/framework/aptos-framework
aptos move compile --save-metadata

# System B (APFS/NTFS):
cd aptos-move/framework/aptos-framework  
aptos move compile --save-metadata

# Compare metadata:
diff build/AptosFramework/package-metadata.bcs <from_system_A> <from_system_B>
# Result: Files will differ due to module ordering in metadata
```

---

**Assessment**: While this is a **genuine bug affecting build reproducibility**, it fails the validation checklist requirement for "realistic attack path" and "clear security harm" meeting bounty severity criteria. The issue should be fixed for engineering quality, but does not constitute an exploitable security vulnerability under the stated criteria.

### Citations

**File:** third_party/move/move-command-line-common/src/files.rs (L80-83)
```rust
        for entry in walkdir::WalkDir::new(path)
            .follow_links(true)
            .into_iter()
            .filter_map(|e| e.ok())
```

**File:** third_party/move/tools/move-package/src/resolution/resolution_graph.rs (L758-768)
```rust
    pub fn get_sources(&self, config: &BuildConfig) -> Result<Vec<FileName>> {
        let places_to_look =
            ResolvingPackage::get_source_paths_for_config(&self.package_path, config)?
                .into_iter()
                .map(|p| p.to_string_lossy().to_string())
                .collect::<Vec<_>>();
        Ok(find_move_filenames(&places_to_look, false)?
            .into_iter()
            .map(Symbol::from)
            .collect())
    }
```

**File:** third_party/move/tools/move-package/src/compilation/compiled_package.rs (L686-709)
```rust
        for annot_unit in all_compiled_units {
            let source_path_str = file_map
                .get(&annot_unit.loc().file_hash())
                .ok_or_else(|| anyhow::anyhow!("invalid transaction script bytecode"))?
                .0
                .as_str();
            let source_path = PathBuf::from(source_path_str);
            let package_name = match &annot_unit {
                compiled_unit::CompiledUnitEnum::Module(m) => {
                    obtain_package_name(m.named_module.package_name, source_path_str)?
                },
                compiled_unit::CompiledUnitEnum::Script(s) => {
                    obtain_package_name(s.named_script.package_name, source_path_str)?
                },
            };
            let unit = CompiledUnitWithSource {
                unit: annot_unit.into_compiled_unit(),
                source_path,
            };
            if package_name == root_package_name {
                root_compiled_units.push(unit)
            } else {
                deps_compiled_units.push((package_name, unit))
            }
```

**File:** third_party/move/tools/move-package/src/compilation/compiled_package.rs (L1074-1079)
```rust
    let sources = root.get_sources(&resolution_graph.build_options)?;
    let source_package_paths = PackagePaths {
        name: Some(root.source_package.package.name),
        paths: sources,
        named_address_map: root_named_addrs,
    };
```

**File:** aptos-move/framework/src/built_package.rs (L532-551)
```rust
        let mut modules = vec![];
        for u in self.package.root_modules() {
            let name = u.unit.name().to_string();
            let source = if self.options.with_srcs {
                zip_metadata_str(&std::fs::read_to_string(&u.source_path)?)?
            } else {
                vec![]
            };
            let source_map = if self.options.with_source_maps {
                zip_metadata(&u.unit.serialize_source_map())?
            } else {
                vec![]
            };
            modules.push(ModuleMetadata {
                name,
                source,
                source_map,
                extension: None,
            })
        }
```

**File:** aptos-move/framework/src/natives/code.rs (L60-71)
```rust
#[derive(Clone, Debug, Serialize, Deserialize, Eq, PartialEq)]
pub struct PackageMetadata {
    pub name: String,
    pub upgrade_policy: UpgradePolicy,
    pub upgrade_number: u64,
    pub source_digest: String,
    #[serde(with = "serde_bytes")]
    pub manifest: Vec<u8>,
    pub modules: Vec<ModuleMetadata>,
    pub deps: Vec<PackageDep>,
    pub extension: Option<Any>,
}
```

**File:** third_party/move/move-stdlib/src/tests.rs (L109-119)
```rust
fn sorted_walk_dir<P: AsRef<Path>>(path: P) -> Result<walkdir::IntoIter, std::io::Error> {
    fn compare_by_file_name(a: &DirEntry, b: &DirEntry) -> Ordering {
        a.file_name().cmp(b.file_name())
    }

    let mut walkdir = WalkDir::new(path).sort_by(compare_by_file_name).into_iter();
    match walkdir.next() {
        Some(Err(e)) => Err(e.into()),
        _ => Ok(walkdir),
    }
}
```
