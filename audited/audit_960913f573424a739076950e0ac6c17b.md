# Audit Report

## Title
Indexer-GRPC Service Panic Due to Missing Error Handling on Optional IndexerReader Access

## Summary
The indexer-grpc-fullnode service contains a critical error handling deficiency where accessing `context.indexer_reader` uses `.expect()` instead of proper error handling, causing the service to panic when the indexer reader is unavailable. This creates a denial-of-service vulnerability where any client connecting to the service can trigger a service crash.

## Finding Description

The security question asks whether all uses of ServiceContext fields are wrapped in proper error handling. The investigation reveals **improper error handling** in the indexer-grpc transaction streaming coordinator.

**Vulnerable Code Location:** [1](#0-0) 

The code uses `.expect("Table info reader not set")` on the optional `indexer_reader` field, which will panic if the value is None. This panic occurs in the critical path when processing transaction batches requested by clients.

**Context Structure:** [2](#0-1) 

Note that `indexer_reader` is `Option<Arc<dyn IndexerReader>>` (line 83), meaning it can legitimately be None. However, `db` is `Arc<dyn DbReader>` (line 75), which is NOT an Option and therefore cannot be None.

**Initialization Path:** [3](#0-2) 

Both `bootstrap_indexer_table_info()` and `bootstrap_internal_indexer_db()` return `Option<...>`, and if both return None, the resulting `indexer_reader` passed to the GRPC service will be None.

**Configuration Sanitizer:** [4](#0-3) 

The sanitizer only validates that at least one indexer is *configured*, but doesn't prevent runtime initialization failures that could leave `indexer_reader` as None.

**Service Bootstrap:** [5](#0-4) 

The service starts regardless of whether `indexer_reader` is None, with no validation check.

## Impact Explanation

**Severity: High** - Per Aptos Bug Bounty criteria: "API crashes"

**Impact:**
1. **Denial of Service**: Any client connecting to the indexer-grpc service can trigger an immediate panic and service crash
2. **Service Unavailability**: The indexer-grpc service becomes unreliable and cannot serve external indexers
3. **Operational Disruption**: Node operators must manually restart the service after each crash

While this doesn't affect consensus or core blockchain functionality (the indexer-grpc is an auxiliary read-only service), it represents a critical availability issue for the indexing infrastructure.

## Likelihood Explanation

**Likelihood: Medium to High**

This vulnerability can manifest in two scenarios:

1. **Initialization Failures**: Both indexer components (`table_info_reader` and `db_indexer_reader`) fail to initialize at startup due to:
   - Database corruption
   - Disk space exhaustion  
   - Permission issues
   - Configuration inconsistencies

2. **Misconfiguration**: The config sanitizer only runs at certain validation points, but runtime conditions may differ from configuration expectations.

The vulnerability is **easily exploitable** once the service is in a vulnerable state - any client connecting to the GRPC endpoint and requesting transactions will trigger the panic.

## Recommendation

Replace the `.expect()` calls with proper error handling that returns errors to clients instead of panicking:

**Recommended Fix:**

```rust
pub fn set_highest_known_version(&mut self) -> anyhow::Result<()> {
    let info = self.context.get_latest_ledger_info_wrapped()?;
    
    // Replace expect() with proper error handling
    let indexer_reader = self
        .context
        .indexer_reader
        .as_ref()
        .ok_or_else(|| anyhow!("Indexer reader is not available"))?;
    
    let latest_table_info_version = indexer_reader
        .get_latest_table_info_ledger_version()?
        .ok_or_else(|| anyhow!("Table info ledger version not available"))?;

    self.highest_known_version =
        std::cmp::min(info.ledger_version.0, latest_table_info_version);

    Ok(())
}
```

**Additional Safeguards:**

1. Add a validation check in the bootstrap function to refuse starting the service if `indexer_reader` is None:

```rust
pub fn bootstrap(..., indexer_reader: Option<Arc<dyn IndexerReader>>, ...) -> Option<Runtime> {
    if !config.indexer_grpc.enabled {
        return None;
    }
    
    // Validate that indexer_reader is available
    if indexer_reader.is_none() {
        error!("Cannot start indexer-grpc service: indexer reader is not available");
        return None;
    }
    
    // ... rest of initialization
}
```

## Proof of Concept

**Reproduction Steps:**

1. Configure a node with `indexer_grpc.enabled = true` but cause both indexers to fail initialization (e.g., by corrupting the indexer database or setting incorrect paths)

2. The node starts with `context.indexer_reader = None`

3. Connect a client to the indexer-grpc service and send a `GetTransactionsFromNodeRequest`

4. The service processes the request, calling `process_next_batch()` → `ensure_highest_known_version()` → `set_highest_known_version()`

5. The service panics at line 538 with message: "Table info reader not set"

**Expected Result:** Service crashes with panic

**Desired Result:** Service returns a gRPC error to the client indicating the indexer is unavailable

## Notes

**Clarification on Question Premises:**

1. **context.db**: This field is `Arc<dyn DbReader>` (NOT an Option), so it can never be None and accessing it will never panic due to null/None values.

2. **"due to reconfiguration"**: No evidence found that Context fields can be mutated at runtime. The Context is created once during initialization and wrapped in Arc. The vulnerability occurs from initialization failures, not runtime reconfiguration.

3. **ServiceContext vs Context**: The ServiceContext struct itself only contains a reference to Context plus configuration parameters. The actual db and indexer_reader fields are in the Context struct.

The core issue remains valid: **improper error handling using .expect() instead of returning errors**, making the service vulnerable to panic-based denial of service.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/stream_coordinator.rs (L534-540)
```rust
        let latest_table_info_version = self
            .context
            .indexer_reader
            .as_ref()
            .expect("Table info reader not set")
            .get_latest_table_info_ledger_version()?
            .expect("Table info ledger version not set");
```

**File:** api/src/context.rs (L71-85)
```rust
// Context holds application scope context
#[derive(Clone)]
pub struct Context {
    chain_id: ChainId,
    pub db: Arc<dyn DbReader>,
    mp_sender: MempoolClientSender,
    pub node_config: Arc<NodeConfig>,
    gas_schedule_cache: Arc<RwLock<GasScheduleCache>>,
    gas_estimation_cache: Arc<RwLock<GasEstimationCache>>,
    gas_limit_cache: Arc<RwLock<GasLimitCache>>,
    view_function_stats: Arc<FunctionStats>,
    simulate_txn_stats: Arc<FunctionStats>,
    pub indexer_reader: Option<Arc<dyn IndexerReader>>,
    pub wait_for_hash_active_connections: Arc<AtomicUsize>,
}
```

**File:** aptos-node/src/services.rs (L72-98)
```rust
    let (indexer_table_info_runtime, indexer_async_v2) = match bootstrap_indexer_table_info(
        node_config,
        chain_id,
        db_rw.clone(),
        mempool_client_sender.clone(),
    ) {
        Some((runtime, indexer_v2)) => (Some(runtime), Some(indexer_v2)),
        None => (None, None),
    };

    let (db_indexer_runtime, txn_event_reader) = match bootstrap_internal_indexer_db(
        node_config,
        db_rw.clone(),
        internal_indexer_db,
        update_receiver,
    ) {
        Some((runtime, db_indexer)) => (Some(runtime), Some(db_indexer)),
        None => (None, None),
    };

    let indexer_readers = IndexerReaders::new(indexer_async_v2, txn_event_reader);

    // Create the API runtime
    let indexer_reader: Option<Arc<dyn IndexerReader>> = indexer_readers.map(|readers| {
        let trait_object: Arc<dyn IndexerReader> = Arc::new(readers);
        trait_object
    });
```

**File:** config/src/config/indexer_grpc_config.rs (L115-125)
```rust
        if !node_config.storage.enable_indexer
            && !node_config
                .indexer_table_info
                .table_info_service_mode
                .is_enabled()
        {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "storage.enable_indexer must be true or indexer_table_info.table_info_service_mode must be IndexingOnly if indexer_grpc.enabled is true".to_string(),
            ));
        }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/runtime.rs (L44-70)
```rust
    if !config.indexer_grpc.enabled {
        return None;
    }

    let runtime = aptos_runtimes::spawn_named_runtime("indexer-grpc".to_string(), None);

    let node_config = config.clone();

    let address = node_config.indexer_grpc.address;
    let use_data_service_interface = node_config.indexer_grpc.use_data_service_interface;
    let processor_task_count = node_config
        .indexer_grpc
        .processor_task_count
        .unwrap_or_else(|| get_default_processor_task_count(use_data_service_interface));
    let processor_batch_size = node_config.indexer_grpc.processor_batch_size;
    let output_batch_size = node_config.indexer_grpc.output_batch_size;
    let transaction_channel_size = node_config.indexer_grpc.transaction_channel_size;
    let max_transaction_filter_size_bytes =
        node_config.indexer_grpc.max_transaction_filter_size_bytes;

    runtime.spawn(async move {
        let context = Arc::new(Context::new(
            chain_id,
            db,
            mp_sender,
            node_config,
            indexer_reader,
```
