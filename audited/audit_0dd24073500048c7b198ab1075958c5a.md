# Audit Report

## Title
Missing Audit Logging in Configuration Endpoint Enables Undetected Reconnaissance

## Summary
The `handle_configuration_request()` function in the inspection service does not log access attempts to the `/configuration` endpoint. This allows attackers to repeatedly query sensitive node configuration data without leaving audit trails, impairing security monitoring and incident response capabilities.

## Finding Description
The inspection service exposes a `/configuration` endpoint that returns the entire node configuration when `expose_configuration` is enabled. [1](#0-0) 

The function directly returns configuration data without any access logging. The request routing in the server module also lacks logging for successful requests. [2](#0-1) 

The only logging present is for internal response generation errors, not for access attempts. [3](#0-2) 

In contrast, other Aptos services like the API and faucet implement comprehensive HTTP request logging with structured schemas that track client IP, method, path, status codes, user agents, and timing information. The inspection service uses raw Hyper without any logging middleware.

When `expose_configuration: true` is set (default for non-mainnet nodes), the endpoint exposes sensitive operational information including:
- Network topology (peer addresses, ports)
- Consensus parameters
- Storage paths
- API endpoint configurations
- Feature flags
- Service configurations

While private keys are protected by `SilentDebug` and `SilentDisplay` traits [4](#0-3) , the lack of audit logging means:

1. **No detection of reconnaissance**: Attackers can profile node configurations to identify attack vectors
2. **No rate limiting visibility**: Repeated queries cannot be detected or throttled
3. **No incident response data**: Security teams lack forensic evidence during investigations
4. **No compliance with security best practices**: Access to sensitive endpoints should always be logged

## Impact Explanation
This issue qualifies as **Medium severity** under the Aptos Bug Bounty program because it represents a significant security monitoring gap that enables information gathering attacks without detection.

According to the bounty criteria, Medium severity includes "state inconsistencies requiring intervention" - in this case, the inconsistency is in the security audit state where access to sensitive configuration data occurs without corresponding audit records. This impairs:

- **Security monitoring**: Cannot detect suspicious access patterns
- **Incident response**: No forensic data for investigation
- **Threat intelligence**: Cannot identify reconnaissance activities
- **Compliance**: Violates security logging best practices

While this doesn't directly lead to fund loss or consensus breaks (which would be Critical/High), it creates a security blind spot that attackers can exploit for reconnaissance before launching more serious attacks.

## Likelihood Explanation
**Likelihood: High**

The vulnerability is exploitable by any attacker with network access to the inspection service (typically exposed on port 9101). The attack requires:
- Simple HTTP GET requests to `/configuration`
- No authentication or authorization
- No special tools or expertise

For non-mainnet nodes, `expose_configuration` is automatically enabled by the config optimizer. [5](#0-4) 

Even for mainnet nodes where the sanitizer prevents validators from exposing configuration [6](#0-5) , fullnodes and other infrastructure may have it enabled for debugging purposes.

The complete absence of logging makes this trivially exploitable without risk of detection.

## Recommendation
Implement structured audit logging for all inspection service endpoints, particularly the configuration endpoint. Follow the same pattern used in other Aptos services:

1. **Add HTTP request logging middleware** using `aptos-logger` with structured schemas
2. **Log key request metadata**: client IP, timestamp, method, path, status code, user agent, elapsed time
3. **Implement log sampling** to prevent log flooding while maintaining security visibility
4. **Add rate limiting** based on client IP to prevent reconnaissance abuse
5. **Generate security alerts** for repeated configuration queries from the same source

Example implementation following the API service pattern:
- Log successful requests with INFO level sampling
- Log error responses at WARN level
- Include trace context for distributed tracing
- Track metrics for monitoring dashboards

Additionally, consider:
- Making `expose_configuration` require explicit opt-in even on testnets
- Adding authentication/authorization for sensitive endpoints
- Implementing IP allowlisting for configuration access

## Proof of Concept
```rust
// PoC: Undetected reconnaissance attack
// File: poc_undetected_config_access.rs

use reqwest;
use std::time::Duration;
use tokio::time::sleep;

#[tokio::main]
async fn main() {
    let inspection_service_url = "http://127.0.0.1:9101/configuration";
    let client = reqwest::Client::new();
    
    println!("[*] Starting undetected reconnaissance attack...");
    
    // Attacker repeatedly queries configuration without detection
    for i in 1..=100 {
        match client.get(inspection_service_url).send().await {
            Ok(response) => {
                if response.status().is_success() {
                    let config = response.text().await.unwrap();
                    println!("[+] Query #{}: Retrieved {} bytes of config data", i, config.len());
                    
                    // Extract sensitive information
                    if config.contains("validator_network") {
                        println!("[!] Found validator network configuration");
                    }
                    if config.contains("consensus") {
                        println!("[!] Found consensus configuration");
                    }
                    if config.contains("storage") {
                        println!("[!] Found storage paths");
                    }
                } else {
                    println!("[-] Query #{}: Endpoint disabled", i);
                    break;
                }
            },
            Err(e) => {
                println!("[-] Query #{}: Error: {}", i, e);
                break;
            }
        }
        
        sleep(Duration::from_millis(100)).await;
    }
    
    println!("\n[*] Attack complete. No audit logs generated.");
    println!("[*] Security monitoring systems have no record of this reconnaissance.");
}
```

Expected behavior:
- Attacker successfully queries configuration 100 times
- No log entries are generated in the node logs
- Security monitoring tools have no visibility into the access
- Incident response teams cannot detect or investigate the reconnaissance activity

**Notes**

The vulnerability is in the production code path, not in test files. The issue affects all nodes running with `expose_configuration: true`, which includes all testnet/devnet nodes by default and any mainnet fullnodes configured for debugging. The exploitation requires only standard HTTP client tools and can be performed remotely without any authentication. The security impact is real and measurable - the complete absence of audit trails for accessing sensitive configuration data violates fundamental security monitoring principles and creates a blind spot for threat detection.

### Citations

**File:** crates/aptos-inspection-service/src/server/configuration.rs (L13-29)
```rust
pub fn handle_configuration_request(node_config: &NodeConfig) -> (StatusCode, Body, String) {
    // Only return configuration if the endpoint is enabled
    let (status_code, body) = if node_config.inspection_service.expose_configuration {
        // We format the configuration using debug formatting. This is important to
        // prevent secret/private keys from being serialized and leaked (i.e.,
        // all secret keys are marked with SilentDisplay and SilentDebug).
        let encoded_configuration = format!("{:?}", node_config);
        (StatusCode::OK, Body::from(encoded_configuration))
    } else {
        (
            StatusCode::FORBIDDEN,
            Body::from(CONFIGURATION_DISABLED_MESSAGE),
        )
    };

    (status_code, body, CONTENT_TYPE_TEXT.into())
}
```

**File:** crates/aptos-inspection-service/src/server/mod.rs (L104-116)
```rust
async fn serve_requests(
    req: Request<Body>,
    node_config: NodeConfig,
    aptos_data_client: AptosDataClient,
    peers_and_metadata: Arc<PeersAndMetadata>,
) -> Result<Response<Body>, hyper::Error> {
    // Process the request and get the response components
    let (status_code, body, content_type) = match req.uri().path() {
        CONFIGURATION_PATH => {
            // /configuration
            // Exposes the node configuration
            configuration::handle_configuration_request(&node_config)
        },
```

**File:** crates/aptos-inspection-service/src/server/mod.rs (L188-197)
```rust
    // Return the processed response
    Ok(response.unwrap_or_else(|error| {
        // Log the internal error
        debug!("Error encountered when generating response: {:?}", error);

        // Return a failure response
        let mut response = Response::new(Body::from(UNEXPECTED_ERROR_MESSAGE));
        *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
        response
    }))
```

**File:** config/src/config/inspection_service_config.rs (L45-68)
```rust
impl ConfigSanitizer for InspectionServiceConfig {
    fn sanitize(
        node_config: &NodeConfig,
        node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();
        let inspection_service_config = &node_config.inspection_service;

        // Verify that mainnet validators do not expose the configuration
        if let Some(chain_id) = chain_id {
            if node_type.is_validator()
                && chain_id.is_mainnet()
                && inspection_service_config.expose_configuration
            {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "Mainnet validators should not expose the node configuration!".to_string(),
                ));
            }
        }

        Ok(())
    }
```

**File:** config/src/config/inspection_service_config.rs (L71-109)
```rust
impl ConfigOptimizer for InspectionServiceConfig {
    fn optimize(
        node_config: &mut NodeConfig,
        local_config_yaml: &Value,
        _node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<bool, Error> {
        let inspection_service_config = &mut node_config.inspection_service;
        let local_inspection_config_yaml = &local_config_yaml["inspection_service"];

        // Enable all endpoints for non-mainnet nodes (to aid debugging)
        let mut modified_config = false;
        if let Some(chain_id) = chain_id {
            if !chain_id.is_mainnet() {
                if local_inspection_config_yaml["expose_configuration"].is_null() {
                    inspection_service_config.expose_configuration = true;
                    modified_config = true;
                }

                if local_inspection_config_yaml["expose_identity_information"].is_null() {
                    inspection_service_config.expose_identity_information = true;
                    modified_config = true;
                }

                if local_inspection_config_yaml["expose_peer_information"].is_null() {
                    inspection_service_config.expose_peer_information = true;
                    modified_config = true;
                }

                if local_inspection_config_yaml["expose_system_information"].is_null() {
                    inspection_service_config.expose_system_information = true;
                    modified_config = true;
                }
            }
        }

        Ok(modified_config)
    }
}
```
