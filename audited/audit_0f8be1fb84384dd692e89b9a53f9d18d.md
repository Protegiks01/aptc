# Audit Report

## Title
Predictable Proposer Selection in V1 Leader Reputation Mode Enables Manipulation via State Reuse

## Summary
The `choose_index()` function in V1 leader reputation mode (ProposerAndVoter) uses a predictable state derived only from epoch and round numbers, creating exploitable patterns when the same state is evaluated with different weight vectors. This reduces randomness and enables targeted attacks when V1 mode is configured.

## Finding Description

The proposer selection mechanism has two modes defined in the consensus configuration: [1](#0-0) 

V1 mode (ProposerAndVoter) is explicitly documented as using a "simple (predictable) seed", while V2 uses an "unpredictable seed, based on root hash."

The core vulnerability exists in how the state is constructed for proposer selection: [2](#0-1) 

When `use_root_hash` is false (V1 mode), the state consists only of `epoch + round`, making it fully predictable and computable offline for any future round.

The `choose_index()` function then uses this state to generate a deterministic random value: [3](#0-2) 

The security issue arises because:

1. **State Predictability**: In V1 mode, an attacker can pre-compute `H = SHA3-256(epoch || round)` for any future round
2. **Correlated Outcomes**: When the same state is used with different weight vectors, the underlying hash value H remains constant, creating mathematical correlations: `chosen_weight = H % total_weight`
3. **Information Leakage**: Observing multiple proposer selections with different weight distributions leaks information about H
4. **Weight Manipulation**: An attacker who can influence validator reputation weights (through targeted DoS, selective block withholding, or strategic voting patterns) can bias proposer selection toward their preferred validator

**Attack Scenario:**
1. Attacker controls enough governance voting power to switch from V2 to V1 via on-chain proposal
2. Attacker pre-computes hash values for upcoming rounds: `H_round_N = SHA3-256(epoch || N)`
3. For each round, attacker can determine which weight distributions favor their controlled validator
4. Attacker manipulates weights by:
   - Launching targeted DoS attacks against specific validators to create failed proposals
   - Selectively withholding blocks to affect validator reputation scores
   - Strategic voting patterns to influence the reputation heuristic
5. Result: Biased proposer selection favoring attacker's validator, enabling:
   - Censorship of specific transactions
   - Increased MEV extraction opportunities
   - Preparation for targeted liveness attacks

## Impact Explanation

This vulnerability meets **Medium Severity** criteria per the Aptos bug bounty program:

- **State Inconsistencies**: During network partitions or when nodes have different chain views, the same predictable state with different weights leads to divergent proposer selections
- **Reduced Randomness**: The deterministic relationship between fixed state and correlated outcomes undermines the security guarantees of randomized leader election
- **Liveness Risk**: Pre-computed proposer schedules enable targeted DoS attacks on future leaders

The impact is limited to Medium rather than Critical/High because:
- V2 mode is the default configuration that mitigates this issue
- Exploitation requires either governance attack to enable V1 OR existing misconfiguration
- Does not directly cause fund loss or permanent consensus violations [4](#0-3) 

## Likelihood Explanation

**Likelihood: Low to Medium**

Requirements for exploitation:
1. **Configuration Requirement**: V1 mode must be enabled, either through:
   - On-chain governance proposal (requires significant voting power)
   - Misconfiguration during network setup
   - Legacy network still using V1
   
2. **Weight Manipulation Capability**: Attacker must be able to influence validator reputation scores through:
   - Network-level attacks (DoS, selective propagation)
   - Strategic validator behavior
   - This is feasible but requires resources

The on-chain governance system allows configuration changes with no validation preventing V1 usage: [5](#0-4) 

The validation only checks for non-empty config, not the specific security properties of the chosen mode.

## Recommendation

**Immediate Actions:**
1. **Deprecate V1 Mode**: Mark `ProposerAndVoter` as deprecated and add warnings against its use
2. **Add Governance Validation**: Implement checks in `consensus_config.move` to prevent switching from V2 to V1
3. **Enforce V2 by Default**: Ensure all new networks and upgrades use V2

**Long-term Solution:**
Remove V1 support entirely in a future release after ensuring all networks have migrated to V2.

**Code Fix Example** (in `consensus_config.move`):
```move
public fun set_for_next_epoch(account: &signer, config: vector<u8>) {
    system_addresses::assert_aptos_framework(account);
    assert!(vector::length(&config) > 0, error::invalid_argument(EINVALID_CONFIG));
    // Add validation to prevent V1 mode
    assert!(!is_v1_leader_reputation(config), error::invalid_argument(EV1_MODE_DEPRECATED));
    std::config_buffer::upsert<ConsensusConfig>(ConsensusConfig {config});
}
```

## Proof of Concept

```rust
// Demonstration of state reuse pattern exploitation
// File: consensus/src/liveness/proposer_election_test.rs (hypothetical)

#[test]
fn test_state_reuse_pattern_exploitation() {
    // Setup: Same state, different weight distributions
    let state = [1u64.to_le_bytes(), 100u64.to_le_bytes()].concat(); // epoch=1, round=100
    
    // Scenario 1: Equal weights
    let weights_equal = vec![1000u128, 1000u128, 1000u128];
    let chosen_1 = choose_index(weights_equal, state.clone());
    
    // Scenario 2: Manipulated weights favoring validator 2
    let weights_manipulated = vec![10u128, 10u128, 2980u128];
    let chosen_2 = choose_index(weights_manipulated, state.clone());
    
    // Both use same hash value H = SHA3-256(state)
    // But different total_weights lead to different proposer selections
    // Attacker who can compute H offline can predict outcomes for any weight distribution
    
    // Demonstration: Information leakage across multiple observations
    let hash = aptos_crypto::HashValue::sha3_256_of(&state);
    let hash_value = u128::from_le_bytes(/* first 16 bytes of hash */);
    
    // For weights_equal: total=3000, chosen_weight = hash_value % 3000
    // For weights_manipulated: total=3000, chosen_weight = hash_value % 3000 (SAME!)
    // This correlation enables prediction and manipulation
    
    println!("Equal weights selected: validator {}", chosen_1);
    println!("Manipulated weights selected: validator {}", chosen_2);
    // Attacker can bias selection toward validator 2 by manipulating weights
}
```

## Notes

**Critical Context:**
1. V2 mode is the current default and recommended configuration
2. V1's predictable seed limitation is explicitly documented in the codebase
3. The vulnerability only manifests when V1 is actively configured
4. No validation currently prevents switching from V2 back to V1 via governance

**Mitigation Status:**
- The issue was recognized and fixed in V2 by including root_hash in the state
- V1 remains supported for backward compatibility but should be deprecated
- Production networks should verify they are using V2 mode [6](#0-5)

### Citations

**File:** types/src/on_chain_config/consensus_config.rs (L481-505)
```rust
impl Default for ConsensusConfigV1 {
    fn default() -> Self {
        Self {
            decoupled_execution: true,
            back_pressure_limit: 10,
            exclude_round: 40,
            max_failed_authors_to_store: 10,
            proposer_election_type: ProposerElectionType::LeaderReputation(
                LeaderReputationType::ProposerAndVoterV2(ProposerAndVoterConfig {
                    active_weight: 1000,
                    inactive_weight: 10,
                    failed_weight: 1,
                    failure_threshold_percent: 10, // = 10%
                    // In each round we get stastics for the single proposer
                    // and large number of validators. So the window for
                    // the proposers needs to be significantly larger
                    // to have enough useful statistics.
                    proposer_window_num_validators_multiplier: 10,
                    voter_window_num_validators_multiplier: 1,
                    weight_by_voting_power: true,
                    use_history_from_previous_epoch_max_count: 5,
                }),
            ),
        }
    }
```

**File:** types/src/on_chain_config/consensus_config.rs (L527-538)
```rust
pub enum LeaderReputationType {
    // Proposer election based on whether nodes succeeded or failed
    // their proposer election rounds, and whether they voted.
    // Version 1:
    // * use reputation window from stale end
    // * simple (predictable) seed
    ProposerAndVoter(ProposerAndVoterConfig),
    // Version 2:
    // * use reputation window from recent end
    // * unpredictable seed, based on root hash
    ProposerAndVoterV2(ProposerAndVoterConfig),
}
```

**File:** types/src/on_chain_config/consensus_config.rs (L540-544)
```rust
impl LeaderReputationType {
    pub fn use_root_hash_for_seed(&self) -> bool {
        // all versions after V1 should use root hash
        !matches!(self, Self::ProposerAndVoter(_))
    }
```

**File:** consensus/src/liveness/leader_reputation.rs (L717-730)
```rust
        let state = if self.use_root_hash {
            [
                root_hash.to_vec(),
                self.epoch.to_le_bytes().to_vec(),
                round.to_le_bytes().to_vec(),
            ]
            .concat()
        } else {
            [
                self.epoch.to_le_bytes().to_vec(),
                round.to_le_bytes().to_vec(),
            ]
            .concat()
        };
```

**File:** consensus/src/liveness/proposer_election.rs (L49-69)
```rust
pub(crate) fn choose_index(mut weights: Vec<u128>, state: Vec<u8>) -> usize {
    let mut total_weight = 0;
    // Create cumulative weights vector
    // Since we own the vector, we can safely modify it in place
    for w in &mut weights {
        total_weight = total_weight
            .checked_add(w)
            .expect("Total stake shouldn't exceed u128::MAX");
        *w = total_weight;
    }
    let chosen_weight = next_in_range(state, total_weight);
    weights
        .binary_search_by(|w| {
            if *w <= chosen_weight {
                Ordering::Less
            } else {
                Ordering::Greater
            }
        })
        .expect_err("Comparison never returns equals, so it's always guaranteed to be error")
}
```

**File:** aptos-move/framework/aptos-framework/sources/configs/consensus_config.move (L52-56)
```text
    public fun set_for_next_epoch(account: &signer, config: vector<u8>) {
        system_addresses::assert_aptos_framework(account);
        assert!(vector::length(&config) > 0, error::invalid_argument(EINVALID_CONFIG));
        std::config_buffer::upsert<ConsensusConfig>(ConsensusConfig {config});
    }
```
