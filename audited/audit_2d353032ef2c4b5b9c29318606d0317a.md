# Audit Report

## Title
Transaction Data Loss Due to Stale Version Reference in Concurrent Cache Updates

## Summary
The `fetch_latest_data()` function in the indexer-grpc-data-service reads `end_version` once before entering its fetch loop, creating a race condition where concurrent cache updates can cause permanent transaction data loss. When cache eviction occurs during a fetch operation, transactions are silently rejected but the function reports success, causing subsequent fetches to skip transaction ranges that become permanently unavailable.

## Finding Description

The vulnerability exists in how `fetch_latest_data()` handles the `end_version` state variable during concurrent operations. [1](#0-0) 

The function reads `end_version` once at the start and stores it in a local variable `version`, which is then used throughout the fetch loop. This breaks the monotonicity guarantee because:

1. **Stale Version Capture**: The `version` variable captures a snapshot of `end_version` at line 67, before entering the loop at line 69.

2. **Concurrent Cache Eviction**: While one thread is fetching transactions based on this stale version, another concurrent operation can update the cache with newer transactions, triggering eviction logic. [2](#0-1) 

3. **Silent Rejection**: When `update_data` is called with the fetched transactions, they are rejected as "too old" if `end_version <= start_version`: [3](#0-2) 

4. **False Success Signal**: Despite rejection, `fetch_and_update_cache` returns the transaction count because it checks `len > 0` before calling `update_data`, not after: [4](#0-3) 

5. **Transaction Skip**: The next iteration of `continuously_fetch_latest_data` reads the updated `end_version` from the concurrent operation, permanently skipping the transaction range that was rejected.

**Exploitation Scenario:**
- Initial state: `start_version=1000`, `end_version=2000`, `num_slots=1000`
- Thread A: Reads `version=2000`, begins fetching
- Thread B: Updates cache with transactions [2000, 6000], causing eviction
- DataManager state becomes: `start_version=5000`, `end_version=6000`
- Thread A: Fetches transactions [2000, 2100], calls `update_data(2000, transactions)`
- Rejection: `2100 <= 5000` (start_version) evaluates true, data rejected as "too old"
- Thread A: Returns success (100 transactions) despite rejection
- Next iteration: Reads `version=6000`, permanently skipping [2100, 6000]

## Impact Explanation

This qualifies as **High Severity** under the Aptos bug bounty criteria for "Significant protocol violations" and "API crashes/data corruption":

1. **Data Integrity Violation**: The indexer-grpc-data-service's core guarantee is to provide continuous, gap-free transaction data. This bug creates permanent gaps in the historical data.

2. **Permanent Unavailability**: When clients request transactions in the skipped range via `get_data()`, they receive `None`: [5](#0-4) 

3. **Recovery Failure**: The `fetch_past_data` mechanism cannot recover these transactions because they will also be rejected as "too old", creating an unrecoverable state.

4. **Downstream Impact**: Applications relying on complete transaction history (wallets, explorers, analytics) will have missing data, potentially affecting funds tracking and state reconstruction.

## Likelihood Explanation

**High Likelihood** - This race condition occurs naturally during normal operation:

- The indexer-grpc-data-service is designed for concurrent access from multiple clients
- Cache eviction is a routine operation when the cache size limit is reached
- No attacker action is required; the bug manifests under normal load conditions
- The larger the cache thrashing (high transaction volume), the more frequent the occurrence

An attacker could also deliberately trigger this by sending concurrent requests to maximize cache eviction frequency, though it occurs naturally without malicious intent.

## Recommendation

The `fetch_latest_data()` function must re-read `end_version` on each loop iteration instead of capturing it once. Additionally, `fetch_and_update_cache` should verify that `update_data` succeeded:

```rust
async fn fetch_latest_data(&'a self) -> usize {
    loop {
        // Re-read end_version on EACH iteration
        let version = self.data_manager.read().await.end_version;
        info!("Fetching latest data starting from version {version}.");
        
        let num_transactions = {
            let _timer = TIMER
                .with_label_values(&["fetch_latest_data"])
                .start_timer();
            Self::fetch_and_update_cache(
                self.data_client.clone(),
                self.data_manager.clone(),
                version,
            )
            .await
        };
        
        if num_transactions != 0 {
            info!("Finished fetching latest data, got {num_transactions} transactions.");
            return num_transactions;
        }
        tokio::time::sleep(Duration::from_millis(200)).await;
    }
}
```

Additionally, modify `update_data` to return a `Result<(), Error>` indicating success/failure, and check this in `fetch_and_update_cache`:

```rust
async fn fetch_and_update_cache(
    data_client: Arc<DataClient>,
    data_manager: Arc<RwLock<DataManager>>,
    version: u64,
) -> usize {
    let transactions = data_client.fetch_transactions(version).await;
    let len = transactions.len();

    if len > 0 {
        let success = data_manager
            .write()
            .await
            .update_data(version, transactions);
        
        // Only return count if update succeeded
        if success {
            len
        } else {
            0 // Signal failure
        }
    } else {
        0
    }
}
```

## Proof of Concept

```rust
#[tokio::test]
async fn test_concurrent_cache_eviction_causes_data_loss() {
    use std::sync::Arc;
    use tokio::sync::RwLock;
    
    // Initialize cache with small slot size to trigger eviction
    let data_manager = Arc::new(RwLock::new(DataManager::new(
        1000, // end_version
        1000, // num_slots (small to trigger eviction)
        1_000_000, // size_limit_bytes
    )));
    
    // Simulate Thread A: fetch_latest_data reads version=1000
    let version_a = data_manager.read().await.end_version;
    assert_eq!(version_a, 1000);
    
    // Simulate Thread B: Large concurrent update causing eviction
    let transactions_b = create_dummy_transactions(4000); // [1000, 5000]
    data_manager.write().await.update_data(1000, transactions_b);
    
    // Verify eviction occurred
    let state = data_manager.read().await;
    assert_eq!(state.end_version, 5000);
    assert_eq!(state.start_version, 4000); // Evicted [1000, 4000]
    drop(state);
    
    // Thread A continues: Tries to update with [1000, 1100]
    let transactions_a = create_dummy_transactions(100);
    data_manager.write().await.update_data(1000, transactions_a);
    
    // Verify data was rejected but function appears successful
    let final_state = data_manager.read().await;
    assert_eq!(final_state.end_version, 5000); // Unchanged!
    
    // Next fetch_latest_data reads version=5000, skipping [1100, 5000]
    let version_next = final_state.end_version;
    assert_eq!(version_next, 5000);
    
    // Transactions [1100, 5000] are permanently lost
    for version in 1100..5000 {
        assert!(final_state.get_data(version).is_none());
    }
}

fn create_dummy_transactions(count: usize) -> Vec<Transaction> {
    // Create minimal valid transactions for testing
    (0..count).map(|_| Transaction::default()).collect()
}
```

**Notes:**

While `end_version` in `DataManager` itself maintains monotonicity and never decreases (enforced at line 89-90 of `data_manager.rs`), the bug manifests because the fetch loop uses a stale local copy of this value. The security question correctly identifies that the fetch loop can "behave incorrectly" due to this staleness combined with cache eviction, even though the underlying `end_version` field remains monotonic. The incorrect behavior is permanent data loss through transaction skipping, not through `end_version` decreasing.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/fetch_manager.rs (L48-64)
```rust
    async fn fetch_and_update_cache(
        data_client: Arc<DataClient>,
        data_manager: Arc<RwLock<DataManager>>,
        version: u64,
    ) -> usize {
        let transactions = data_client.fetch_transactions(version).await;
        let len = transactions.len();

        if len > 0 {
            data_manager
                .write()
                .await
                .update_data(version, transactions);
        }

        len
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/fetch_manager.rs (L66-87)
```rust
    async fn fetch_latest_data(&'a self) -> usize {
        let version = self.data_manager.read().await.end_version;
        info!("Fetching latest data starting from version {version}.");
        loop {
            let num_transactions = {
                let _timer = TIMER
                    .with_label_values(&["fetch_latest_data"])
                    .start_timer();
                Self::fetch_and_update_cache(
                    self.data_client.clone(),
                    self.data_manager.clone(),
                    version,
                )
                .await
            };
            if num_transactions != 0 {
                info!("Finished fetching latest data, got {num_transactions} num_transactions starting from version {version}.");
                return num_transactions;
            }
            tokio::time::sleep(Duration::from_millis(200)).await;
        }
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/data_manager.rs (L60-67)
```rust
        if end_version <= self.start_version {
            warn!(
                "The data is too old, cache start_version: {}, data end_version: {end_version}.",
                self.start_version
            );
            COUNTER.with_label_values(&["data_too_old"]).inc();
            return;
        }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/data_manager.rs (L107-117)
```rust
        if self.total_size >= self.size_limit_bytes {
            while self.total_size >= self.eviction_target {
                if let Some(transaction) =
                    self.data[self.start_version as usize % self.num_slots].take()
                {
                    self.total_size -= transaction.encoded_len();
                    drop(transaction);
                }
                self.start_version += 1;
            }
        }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/in_memory_cache.rs (L69-71)
```rust
            if starting_version < data_manager.start_version {
                return None;
            }
```
