# Audit Report

## Title
Clock Skew Attack Allows Byzantine Validators to Bypass minimum_batch_age_usecs Validation

## Summary
A Byzantine validator with a backdated system clock can exploit the `minimum_batch_age_usecs` validation in the batch proof queue by creating batches with artificially old expiration timestamps. This allows fresh batches to bypass the minimum age check designed to ensure network propagation, violating protocol fairness guarantees.

## Finding Description

The Aptos consensus quorum store implements a `minimum_batch_age_usecs` parameter (default: 50ms) to ensure batches are sufficiently old before being pulled into proposals, reducing the likelihood of inline fetches. However, this check relies on comparing timestamps from two unsynchronized clock sources:

1. **Batch creator's local system clock** - used to set the batch expiration timestamp
2. **Verifying validator's local system clock** - used to calculate whether the batch meets the minimum age requirement [1](#0-0) 

The vulnerability arises because:

**Batch Creation:** A Byzantine validator creates batches with expiration timestamps based on their local system clock: [2](#0-1) 

The `duration_since_epoch()` function uses the validator's local `SystemTime`: [3](#0-2) 

**Age Verification:** When pulling batches, honest validators calculate the batch creation timestamp by subtracting `batch_expiry_gap_when_init_usecs` (60 seconds) from the expiration, then check if it's old enough: [4](#0-3) 

**Attack Scenario:**

1. Byzantine validator V sets their system clock backward by X microseconds (where 50,000 ≤ X < 60,000,000)
2. At actual time T, V creates a batch with `expiration = (T - X) + 60,000,000`
3. Honest validator H receives this batch at time ≈T and calculates:
   - `batch_create_ts = expiration - 60,000,000 = (T - X) + 60,000,000 - 60,000,000 = T - X`
   - `max_create_ts = current_time - 50,000 = T - 50,000`
4. If X ≥ 50,000, then `batch_create_ts ≤ max_create_ts`, so the batch **passes** the age check
5. The batch appears to be X microseconds older than it actually is

**Bounds:** The attack is constrained by two checks:

- **Upper bound:** The `SignedBatchInfo::verify()` check ensures expiration isn't too far in the future: [5](#0-4) 

With default config, this allows X up to 60 seconds: [6](#0-5) 

- **Lower bound:** The batch must not appear expired: [7](#0-6) 

**Result:** A Byzantine validator can systematically make their batches appear 50ms to 60 seconds older than they actually are, bypassing the minimum age requirement intended to ensure network propagation.

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos bug bounty criteria as a "Significant protocol violation":

1. **Protocol Invariant Violation:** The minimum_batch_age_usecs check is designed to ensure batches have had sufficient time to propagate through the network before being included in proposals. Bypassing this check violates the protocol's fairness and efficiency guarantees.

2. **Unfair Batch Selection Advantage:** Byzantine validators can ensure their batches are always selected first within the fair rotation mechanism, crowding out honest validators' batches.

3. **Forced Inline Inclusion:** Fresh batches that haven't propagated may require inline inclusion (embedding full transaction data in proposals), increasing block size and propagation time: [8](#0-7) 

4. **Network Performance Degradation:** Systematically forcing inline batches could slow down block propagation across the network, potentially affecting validator performance metrics and consensus liveness.

While this does not directly cause fund loss or consensus safety violations, it represents a significant manipulation of the protocol's intended operation, allowing a Byzantine validator to gain unfair advantages.

## Likelihood Explanation

**Likelihood: High**

1. **Low Attack Complexity:** The attacker only needs to set their system clock backward, which is trivial for any validator operator with OS-level access.

2. **No Detection Required:** The protocol has no mechanism to detect or validate that batch timestamps correspond to actual creation times, as it relies solely on local system clocks.

3. **Persistent Advantage:** Once the clock is set backward, all subsequent batches created by the validator automatically exploit the vulnerability.

4. **No Coordination Needed:** A single Byzantine validator can execute this attack independently without coordination or collusion.

5. **Difficult to Attribute:** The attack is subtle and may appear as normal clock drift rather than malicious behavior, making it hard to detect through monitoring.

## Recommendation

Implement a trusted time source for batch age verification instead of relying on unsynchronized local system clocks. The recommended fix involves using the consensus-agreed blockchain timestamp:

**Option 1: Use Block Timestamp for Age Verification (Recommended)**

Modify the age check to use `latest_block_timestamp` (which comes from committed blocks) instead of `duration_since_epoch()`:

```rust
// In pull_internal(), replace lines 593-594:
let max_batch_creation_ts_usecs = min_batch_age_usecs
    .map(|min_age| self.latest_block_timestamp.saturating_sub(min_age));
```

This ensures all validators use the same reference time (the on-chain consensus time) for age verification, preventing clock skew attacks.

**Option 2: Add Timestamp Bounds Validation**

Add a check during batch insertion that rejects batches with expiration timestamps that are unreasonably far in the past relative to the current block timestamp:

```rust
// In insert_proof(), add after line 176:
const MIN_BATCH_EXPIRY_GAP_USECS: u64 = 30_000_000; // 30 seconds minimum
if proof.expiration() < self.latest_block_timestamp + MIN_BATCH_EXPIRY_GAP_USECS {
    counters::inc_rejected_pos_count(counters::POS_INVALID_TIMESTAMP_LABEL);
    return;
}
```

This would prevent batches from having expiration times that are too close to or in the past relative to the consensus time.

**Option 3: Hybrid Approach (Most Robust)**

Combine both approaches: use block timestamp for age verification AND add bounds checking on expiration timestamps to ensure they fall within reasonable ranges relative to consensus time.

## Proof of Concept

```rust
#[cfg(test)]
mod clock_skew_attack_poc {
    use super::*;
    use aptos_consensus_types::proof_of_store::{BatchInfo, BatchInfoExt};
    use aptos_types::PeerId;
    use std::time::Duration;

    #[test]
    fn test_clock_skew_bypass_minimum_batch_age() {
        // Setup: Create a batch proof queue
        let my_peer_id = PeerId::random();
        let batch_store = Arc::new(MockBatchStore::new());
        let batch_expiry_gap = 60_000_000u64; // 60 seconds in microseconds
        let mut queue = BatchProofQueue::new(my_peer_id, batch_store, batch_expiry_gap);
        
        // Simulate blockchain time
        let blockchain_time = 1_000_000_000u64; // Some timestamp
        queue.handle_updated_block_timestamp(blockchain_time);
        
        // ATTACK: Byzantine validator creates batch with backdated clock
        let clock_skew_usecs = 55_000u64; // 55ms backward skew
        let actual_creation_time = blockchain_time + 100_000; // 100ms after latest block
        let attacker_clock_time = actual_creation_time - clock_skew_usecs; // Backdated
        
        // Attacker creates batch with backdated expiration
        let batch_expiration = attacker_clock_time + batch_expiry_gap;
        let batch_info = BatchInfoExt::new_v1(
            PeerId::random(), // attacker
            BatchId::new(1),
            1, // epoch
            batch_expiration,
            HashValue::random(),
            10, // num_txns
            1000, // num_bytes
            0, // gas_bucket
        );
        
        // Create and insert proof
        let proof = ProofOfStore::new_dummy(batch_info);
        queue.insert_proof(proof.clone());
        
        // Now attempt to pull batches with minimum_batch_age requirement
        let min_batch_age_usecs = 50_000u64; // 50ms minimum age
        let current_time = actual_creation_time; // Pull happens right after creation
        
        // Calculate what the age check will compute:
        // batch_create_ts = batch_expiration - batch_expiry_gap
        //                 = (attacker_clock_time + batch_expiry_gap) - batch_expiry_gap  
        //                 = attacker_clock_time
        //                 = actual_creation_time - clock_skew_usecs
        //
        // max_create_ts = current_time - min_batch_age_usecs
        //               = actual_creation_time - 50_000
        //
        // Check: is batch_create_ts > max_create_ts?
        //        is (actual_creation_time - clock_skew_usecs) > (actual_creation_time - 50_000)?
        //        is -clock_skew_usecs > -50_000?
        //        is clock_skew_usecs < 50_000?
        // 
        // Since clock_skew_usecs = 55_000 >= 50_000, the batch PASSES the age check!
        
        let (batches, _, _) = queue.pull_batches(
            &HashSet::new(),
            &HashSet::new(),
            PayloadTxnsSize::new(1000, 1_000_000),
            1000,
            900,
            true,
            Duration::from_micros(current_time),
            Some(min_batch_age_usecs),
        );
        
        // VULNERABILITY: The batch should be rejected (too fresh), but it's accepted!
        assert_eq!(batches.len(), 1, "Batch bypassed minimum age check via clock skew");
        
        // Without clock skew, an honest validator's batch would be rejected:
        let honest_expiration = actual_creation_time + batch_expiry_gap;
        let honest_batch = BatchInfoExt::new_v1(
            PeerId::random(),
            BatchId::new(2),
            1,
            honest_expiration,
            HashValue::random(),
            10,
            1000,
            0,
        );
        let honest_proof = ProofOfStore::new_dummy(honest_batch);
        queue.insert_proof(honest_proof);
        
        let (honest_batches, _, _) = queue.pull_batches(
            &HashSet::new(),
            &HashSet::new(),
            PayloadTxnsSize::new(1000, 1_000_000),
            1000,
            900,
            true,
            Duration::from_micros(current_time),
            Some(min_batch_age_usecs),
        );
        
        // Honest batch is correctly rejected as too fresh
        assert_eq!(honest_batches.len(), 0, "Honest batch correctly rejected as too fresh");
    }
}
```

## Notes

This vulnerability demonstrates a fundamental design flaw in using unsynchronized local system clocks for distributed timestamp validation. The Aptos consensus already maintains a trusted blockchain timestamp through `latest_block_timestamp`, which should be used as the canonical time reference for all timestamp-based validations in the consensus layer.

The attack requires only OS-level clock manipulation by a validator operator, making it accessible to any Byzantine validator. While the immediate impact is limited to protocol fairness and performance, it represents a clear violation of the intended security guarantees of the minimum_batch_age_usecs mechanism.

### Citations

**File:** consensus/src/quorum_store/batch_proof_queue.rs (L176-179)
```rust
        if proof.expiration() <= self.latest_block_timestamp {
            counters::inc_rejected_pos_count(counters::POS_EXPIRED_LABEL);
            return;
        }
```

**File:** consensus/src/quorum_store/batch_proof_queue.rs (L515-559)
```rust
    pub fn pull_batches_with_transactions(
        &mut self,
        excluded_batches: &HashSet<BatchInfoExt>,
        max_txns: PayloadTxnsSize,
        max_txns_after_filtering: u64,
        soft_max_txns_after_filtering: u64,
        return_non_full: bool,
        block_timestamp: Duration,
    ) -> (
        Vec<(BatchInfoExt, Vec<SignedTransaction>)>,
        PayloadTxnsSize,
        u64,
    ) {
        let (batches, pulled_txns, unique_txns, is_full) = self.pull_batches_internal(
            excluded_batches,
            &HashSet::new(),
            max_txns,
            max_txns_after_filtering,
            soft_max_txns_after_filtering,
            return_non_full,
            block_timestamp,
            None,
        );
        let mut result = Vec::new();
        for batch in batches.into_iter() {
            if let Ok(mut persisted_value) = self.batch_store.get_batch_from_local(batch.digest()) {
                if let Some(txns) = persisted_value.take_payload() {
                    result.push((batch, txns));
                }
            } else {
                warn!(
                    "Couldn't find a batch in local storage while creating inline block: {:?}",
                    batch.digest()
                );
            }
        }

        if is_full || return_non_full {
            counters::CONSENSUS_PULL_NUM_UNIQUE_TXNS.observe_with(&["inline"], unique_txns as f64);
            counters::CONSENSUS_PULL_NUM_TXNS.observe_with(&["inline"], pulled_txns.count() as f64);
            counters::CONSENSUS_PULL_SIZE_IN_BYTES
                .observe_with(&["inline"], pulled_txns.size_in_bytes() as f64);
        }
        (result, pulled_txns, unique_txns)
    }
```

**File:** consensus/src/quorum_store/batch_proof_queue.rs (L593-594)
```rust
        let max_batch_creation_ts_usecs = min_batch_age_usecs
            .map(|min_age| aptos_infallible::duration_since_epoch().as_micros() as u64 - min_age);
```

**File:** consensus/src/quorum_store/batch_proof_queue.rs (L603-612)
```rust
                    let batch_create_ts_usecs =
                        item.info.expiration() - self.batch_expiry_gap_when_init_usecs;

                    // Ensure that the batch was created at least `min_batch_age_usecs` ago to
                    // reduce the chance of inline fetches.
                    if max_batch_creation_ts_usecs
                        .is_some_and(|max_create_ts| batch_create_ts_usecs > max_create_ts)
                    {
                        return None;
                    }
```

**File:** consensus/src/quorum_store/batch_generator.rs (L383-384)
```rust
        let expiry_time = aptos_infallible::duration_since_epoch().as_micros() as u64
            + self.config.batch_expiry_gap_when_init_usecs;
```

**File:** crates/aptos-infallible/src/time.rs (L9-13)
```rust
pub fn duration_since_epoch() -> Duration {
    SystemTime::now()
        .duration_since(SystemTime::UNIX_EPOCH)
        .expect("System time is before the UNIX_EPOCH")
}
```

**File:** consensus/consensus-types/src/proof_of_store.rs (L469-479)
```rust
        if self.expiration()
            > aptos_infallible::duration_since_epoch().as_micros() as u64
                + max_batch_expiry_gap_usecs
        {
            bail!(
                "Batch expiration too far in future: {} > {}",
                self.expiration(),
                aptos_infallible::duration_since_epoch().as_micros() as u64
                    + max_batch_expiry_gap_usecs
            );
        }
```

**File:** config/src/config/quorum_store_config.rs (L131-131)
```rust
            batch_expiry_gap_when_init_usecs: Duration::from_secs(60).as_micros() as u64,
```
