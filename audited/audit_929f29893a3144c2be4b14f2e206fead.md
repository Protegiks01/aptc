# Audit Report

## Title
Null Byte Injection in DNS Name Validation Enables DNS Truncation Attacks

## Summary
The `DnsName::validate()` function in the network address parser fails to check for null bytes in DNS names. This allows attackers to inject DNS names containing null bytes (e.g., `attacker.com\0.trusted.com`) which pass validation but get truncated at the null byte during DNS resolution, causing nodes to connect to attacker-controlled servers instead of intended peers.

## Finding Description
The vulnerability exists in the DNS name validation logic which only checks if the string is ASCII, but does not filter null bytes. [1](#0-0) 

When a malicious network address like `/dns/attacker.com\0.legitimate.com/tcp/6180/noise-ik/<key>/handshake/0` is configured as a seed peer, it passes all validation checks:
1. Not empty ✓
2. Length ≤ 255 bytes ✓  
3. No '/' characters ✓
4. `is_ascii()` returns true ✓ (null byte 0x00 IS a valid ASCII character)

The validated DNS name is later used in network operations. [2](#0-1) 

When `to_socket_addrs()` is called, it formats the DNS name as `"attacker.com\0.legitimate.com:6180"` and passes it to Rust's standard library, which ultimately calls the system's C-based DNS resolver (typically `getaddrinfo()`). Since C strings are null-terminated, the DNS resolver stops reading at the null byte and resolves only `"attacker.com"`.

The attack propagation path is:
1. Attacker provides malicious config or persuades operator to add malicious seed peer [3](#0-2) 
2. Malicious network address is parsed and stored in node configuration [4](#0-3) 
3. Node attempts to connect to seed peer during network initialization
4. DNS resolution via `to_socket_addrs()` truncates at null byte [5](#0-4) 
5. Node connects to attacker-controlled server instead of legitimate peer

## Impact Explanation
This is a **Medium** severity issue per Aptos bug bounty criteria:

**State inconsistencies requiring intervention**: A node with misconfigured seed peers will connect to malicious nodes, potentially leading to:
- Eclipse attacks (node isolation from honest network)
- Man-in-the-middle attacks on consensus messages
- False state synchronization data
- Network partition requiring manual intervention

While the Noise-IK protocol provides authenticated encryption and would reject connections where the public key doesn't match, this defense assumes the node operator correctly verified the public key in the configuration. An attacker who can inject the DNS name can also inject a matching public key for their malicious server.

The impact is limited to **Medium** rather than **High/Critical** because:
- Requires node operator to apply malicious configuration (not directly exploitable)
- Affects individual nodes, not network-wide consensus
- Does not directly lead to fund loss or consensus violations
- Requires manual intervention to exploit and remediate

## Likelihood Explanation
**Likelihood: Medium**

This vulnerability can be exploited through:
1. **Social engineering**: Attacker tricks node operator into using malicious config via phishing, compromised documentation, or malicious tutorials
2. **Supply chain attacks**: Compromised config templates in public repositories
3. **Copy-paste errors**: Operators copying configs from untrusted sources

Node operators frequently modify configuration files when setting up new nodes or adding seed peers. The attack requires no special privileges or technical sophistication once the malicious config is applied. However, it does require the victim to take an action (modifying config), preventing fully automated exploitation.

The codebase already demonstrates awareness of null byte issues in other contexts. [6](#0-5) 

## Recommendation
Add explicit null byte validation to `DnsName::validate()`:

```rust
impl DnsName {
    fn validate(s: &str) -> Result<(), ParseError> {
        if s.is_empty() {
            Err(ParseError::EmptyDnsNameString)
        } else if s.len() > MAX_DNS_NAME_SIZE {
            Err(ParseError::DnsNameTooLong(s.len()))
        } else if s.contains('/') {
            Err(ParseError::InvalidDnsNameCharacter)
        } else if s.contains('\0') {
            Err(ParseError::InvalidDnsNameCharacter)
        } else if !s.is_ascii() {
            Err(ParseError::DnsNameNonASCII(s.into()))
        } else {
            Ok(())
        }
    }
}
```

Additionally, consider validating that DNS names contain only printable ASCII characters (0x20-0x7E) to prevent other control character attacks.

## Proof of Concept

```rust
#[test]
fn test_dns_null_byte_injection() {
    use aptos_types::network_address::NetworkAddress;
    use std::str::FromStr;
    
    // Craft malicious DNS address with null byte
    let malicious_addr = "/dns/attacker.com\0.trusted-seed.aptoslabs.com/tcp/6180";
    
    // This should fail but currently passes validation
    let result = NetworkAddress::from_str(malicious_addr);
    
    // Verify the vulnerability exists
    match result {
        Ok(addr) => {
            println!("VULNERABILITY: Null byte passed validation!");
            println!("Address: {:?}", addr);
            
            // Demonstrate DNS truncation
            match addr.to_socket_addrs() {
                Ok(mut addrs) => {
                    if let Some(resolved) = addrs.next() {
                        println!("Resolved to: {}", resolved);
                        // This will resolve to attacker.com due to null byte truncation
                    }
                }
                Err(e) => println!("DNS resolution error: {}", e),
            }
        },
        Err(e) => {
            println!("SAFE: Validation correctly rejected null byte: {:?}", e);
        }
    }
}
```

Run with: `cargo test test_dns_null_byte_injection --package aptos-types -- --nocapture`

## Notes

This vulnerability represents a defense-in-depth failure. While the exploitation requires social engineering or compromised configuration access (which are nominally out of scope per the bug bounty rules), the insufficient validation creates unnecessary risk. The code should defensively reject null bytes regardless of how the configuration is obtained, as this is a well-known attack vector in systems that interface with C libraries. The existing test suite validates Unicode homograph prevention but lacks coverage for ASCII control characters. [7](#0-6)

### Citations

**File:** types/src/network_address/mod.rs (L470-486)
```rust
impl ToSocketAddrs for NetworkAddress {
    type Iter = std::vec::IntoIter<SocketAddr>;

    fn to_socket_addrs(&self) -> Result<Self::Iter, std::io::Error> {
        if let Some(((ipaddr, port), _)) = parse_ip_tcp(self.as_slice()) {
            Ok(vec![SocketAddr::new(ipaddr, port)].into_iter())
        } else if let Some(((ip_filter, dns_name, port), _)) = parse_dns_tcp(self.as_slice()) {
            format!("{}:{}", dns_name, port).to_socket_addrs().map(|v| {
                v.filter(|addr| ip_filter.matches(addr.ip()))
                    .collect::<Vec<_>>()
                    .into_iter()
            })
        } else {
            Ok(vec![].into_iter())
        }
    }
}
```

**File:** types/src/network_address/mod.rs (L666-679)
```rust
impl DnsName {
    fn validate(s: &str) -> Result<(), ParseError> {
        if s.is_empty() {
            Err(ParseError::EmptyDnsNameString)
        } else if s.len() > MAX_DNS_NAME_SIZE {
            Err(ParseError::DnsNameTooLong(s.len()))
        } else if s.contains('/') {
            Err(ParseError::InvalidDnsNameCharacter)
        } else if !s.is_ascii() {
            Err(ParseError::DnsNameNonASCII(s.into()))
        } else {
            Ok(())
        }
    }
```

**File:** types/src/network_address/mod.rs (L1059-1065)
```rust
        // The first `e` in `example.com` is a unicode character and not a regular `e`!
        let bad_address = "/dns6/еxample.com/tcp/123";
        assert_matches!(
            NetworkAddress::from_str(bad_address),
            Err(ParseError::DnsNameNonASCII(_))
        );
    }
```

**File:** config/src/config/config_optimizer.rs (L304-309)
```rust
    let network_address = NetworkAddress::from_str(network_address_str).map_err(|error| {
        Error::Unexpected(format!(
            "Failed to parse peer network address: {:?}. Error: {:?}",
            network_address_str, error
        ))
    })?;
```

**File:** config/src/config/network_config.rs (L99-101)
```rust
    pub seed_addrs: HashMap<PeerId, Vec<NetworkAddress>>,
    /// The initial peers to connect to prior to onchain discovery
    pub seeds: PeerSet,
```

**File:** network/framework/src/connectivity_manager/mod.rs (L1161-1170)
```rust
        let socket_addresses = match network_address.to_socket_addrs() {
            Ok(socket_addresses) => socket_addresses.collect::<Vec<_>>(),
            Err(error) => {
                warn!(
                    NetworkSchema::new(&network_context),
                    "Failed to resolve network address {:?}: {}", network_address, error
                );
                return;
            },
        };
```

**File:** crates/indexer/src/util.rs (L67-97)
```rust
pub fn remove_null_bytes<T: serde::Serialize + for<'de> serde::Deserialize<'de>>(input: &T) -> T {
    let mut txn_json = serde_json::to_value(input).unwrap();
    recurse_remove_null_bytes_from_json(&mut txn_json);
    serde_json::from_value::<T>(txn_json).unwrap()
}

fn recurse_remove_null_bytes_from_json(sub_json: &mut Value) {
    match sub_json {
        Value::Array(array) => {
            for item in array {
                recurse_remove_null_bytes_from_json(item);
            }
        },
        Value::Object(object) => {
            for (_key, value) in object {
                recurse_remove_null_bytes_from_json(value);
            }
        },
        Value::String(str) => {
            if !str.is_empty() {
                let replacement = string_null_byte_replacement(str);
                *str = replacement;
            }
        },
        _ => {},
    }
}

fn string_null_byte_replacement(value: &mut str) -> String {
    value.replace('\u{0000}', "").replace("\\u0000", "")
}
```
