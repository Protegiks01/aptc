# Audit Report

## Title
API Memory Exhaustion via Unbounded Aggregate Event Size in Events Endpoint

## Summary
While individual events are capped at 1 MB during creation, the API's `list()` function in `api/src/events.rs` lacks total response size limits. This allows attackers to cause memory exhaustion and API crashes by querying large numbers of maximum-sized events, leading to denial of service.

## Finding Description
The events API endpoint implements limits on individual event data size (1 MB per event via `max_bytes_per_event`) enforced at transaction execution time [1](#0-0) , and validated in the change set checks [2](#0-1) .

However, the `EventsApi::list()` function only limits the **number** of events returned (via `max_events_page_size`, default 100) [3](#0-2) [4](#0-3) , but does **not** limit the **total byte size** of the response.

The vulnerability occurs because all events are loaded into memory simultaneously as a `Vec<EventWithVersion>` [5](#0-4)  and then converted to `Vec<VersionedEvent>` [6](#0-5)  without streaming or size validation.

**Attack Path:**
1. Attacker submits transactions emitting events at maximum size (1 MB each, 10 events per transaction totaling 10 MB per transaction)
2. To create 100 queryable events: ~10 transactions. To create 10,000 events: ~1,000 transactions
3. Once events are on-chain, attacker (or anyone) queries: `/accounts/:address/events/:creation_number?limit=100` (or higher if operator increased `max_events_page_size`)
4. API server loads all events into memory: 100 events × 1 MB = **100 MB per request**
5. With concurrent requests: 100 concurrent requests × 100 MB = **10 GB total memory**
6. If operator configured `max_events_page_size=10000`: Single request loads **10 GB**

The API lacks response size limits - only request size limits exist for POST operations [7](#0-6) , not for GET responses.

## Impact Explanation
This qualifies as **High Severity** per the Aptos Bug Bounty program criteria: "API crashes". 

The vulnerability enables:
- **Memory exhaustion** on API nodes leading to crashes or severe slowdowns
- **Sustained denial of service** against the REST API, affecting all users
- **No per-request cost** after initial setup (events are permanent on-chain)
- **Amplification effect**: One-time transaction cost creates permanent DoS vector

Even with default configuration (100 events/request), concurrent API requests from multiple sources can exhaust available memory, causing API service degradation or crashes.

## Likelihood Explanation
**Likelihood: High**

- **Ease of exploitation**: Simple HTTP GET requests to public API endpoints
- **No authentication required**: Read endpoints are publicly accessible
- **Low initial cost**: ~10-1,000 transactions to set up, then free repeated queries
- **Operational reality**: Operators may increase `max_events_page_size` for legitimate use cases, exacerbating the issue
- **Concurrent exploitation**: Multiple attackers or users can unknowingly compound the memory pressure

The vulnerability breaks invariant #9: "Resource Limits: All operations must respect gas, storage, and computational limits" - while gas limits apply at transaction execution, no memory limits apply at the API query layer.

## Recommendation
Implement total response size validation in the events API:

1. **Add response size tracking** before loading events:
```rust
const MAX_RESPONSE_SIZE_BYTES: usize = 50 * 1024 * 1024; // 50 MB limit

fn list(...) -> BasicResultWith404<Vec<VersionedEvent>> {
    let events = self.context.get_events(...)?;
    
    // Calculate total size before processing
    let total_size: usize = events.iter()
        .map(|e| e.event.event_data().len())
        .sum();
    
    if total_size > MAX_RESPONSE_SIZE_BYTES {
        return Err(BasicErrorWith404::bad_request_with_code(
            format!("Response size {} exceeds maximum {}", total_size, MAX_RESPONSE_SIZE_BYTES),
            AptosErrorCode::InvalidInput,
            &latest_ledger_info
        ));
    }
    // ... continue with conversion
}
```

2. **Alternative: Implement streaming** for large event queries instead of loading all into memory

3. **Add configuration validation** to warn operators if `max_events_page_size × max_bytes_per_event` exceeds safe memory thresholds

## Proof of Concept

```rust
// Rust test demonstrating memory exhaustion potential
#[tokio::test]
async fn test_event_memory_exhaustion() {
    // Setup: Create account and emit maximum-sized events
    let mut context = new_test_context();
    let account = context.create_account().await;
    
    // Emit 100 events at 1 MB each (10 transactions × 10 events)
    for tx_idx in 0..10 {
        let mut events = vec![];
        for event_idx in 0..10 {
            // Create 1 MB event payload
            let large_data = vec![0u8; 1_048_576]; // 1 MB
            events.push(large_data);
        }
        context.emit_events(&account, events).await;
    }
    
    // Attack: Query all events - should load 100 MB into memory
    let response = context
        .get(&format!("/accounts/{}/events/0?limit=100", account.address()))
        .await;
    
    // In production with concurrent requests, this causes memory exhaustion
    assert_eq!(response.status(), 200);
    let events: Vec<VersionedEvent> = response.json().await;
    assert_eq!(events.len(), 100);
    
    // Memory usage: 100 events × ~1 MB each ≈ 100 MB per request
    // With 100 concurrent requests: 10 GB total
}
```

**Notes:**
- The 1 MB per-event limit exists and is enforced at transaction execution time
- However, this limit is **insufficient** to prevent memory exhaustion when multiple maximum-sized events are queried together
- The API should implement aggregate response size limits, not just count-based limits
- This vulnerability is exploitable with default configuration via concurrent requests, and severely worsened if operators increase `max_events_page_size` without considering memory implications

### Citations

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L164-167)
```rust
            max_bytes_per_event: NumBytes,
            { 5.. => "max_bytes_per_event" },
            1 << 20, // a single event is 1MB max
        ],
```

**File:** aptos-move/aptos-vm-types/src/storage/change_set_configs.rs (L115-125)
```rust
        let mut total_event_size = 0;
        for event in change_set.events_iter() {
            let size = event.event_data().len() as u64;
            if size > self.max_bytes_per_event {
                return storage_write_limit_reached(None);
            }
            total_event_size += size;
            if total_event_size > self.max_bytes_all_events_per_transaction {
                return storage_write_limit_reached(None);
            }
        }
```

**File:** config/src/config/api_config.rs (L99-99)
```rust
pub const DEFAULT_MAX_PAGE_SIZE: u16 = 100;
```

**File:** config/src/config/api_config.rs (L132-132)
```rust
            max_events_page_size: DEFAULT_MAX_PAGE_SIZE,
```

**File:** api/src/events.rs (L163-178)
```rust
        let events = self
            .context
            .get_events(
                &event_key,
                page.start_option(),
                page.limit(&latest_ledger_info)?,
                ledger_version,
            )
            .context(format!("Failed to find events by key {}", event_key))
            .map_err(|err| {
                BasicErrorWith404::internal_with_code(
                    err,
                    AptosErrorCode::InternalError,
                    &latest_ledger_info,
                )
            })?;
```

**File:** api/src/events.rs (L182-194)
```rust
                let events = self
                    .context
                    .latest_state_view_poem(&latest_ledger_info)?
                    .as_converter(self.context.db.clone(), self.context.indexer_reader.clone())
                    .try_into_versioned_events(&events)
                    .context("Failed to convert events from storage into response")
                    .map_err(|err| {
                        BasicErrorWith404::internal_with_code(
                            err,
                            AptosErrorCode::InternalError,
                            &latest_ledger_info,
                        )
                    })?;
```

**File:** api/src/check_size.rs (L44-46)
```rust
        if req.method() != Method::POST {
            return self.inner.call(req).await;
        }
```
