# Audit Report

## Title
Graph Construction Race Condition in Inlining Optimization Leads to Undetected Recursive Function Inlining

## Summary
The `find_cycles_in_call_graph()` function in the Move compiler v2's inlining optimization contains a graph construction gap that fails to detect recursion in functions outside the compilation target. This allows recursive functions from dependency modules to be incorrectly marked as safe to inline, potentially causing compiler resource exhaustion and incorrect bytecode generation.

## Finding Description

The vulnerability exists in how `find_cycles_in_call_graph()` constructs the call graph for cycle detection. [1](#0-0) 

The function first adds all functions from compilation targets as explicit nodes. [2](#0-1) 

However, it then collects the current nodes into a Vec and iterates over that snapshot. When processing edges, petgraph's `DiGraphMap::add_edge()` implicitly adds nodes for callees that aren't in the graph yet. Since the iteration uses a pre-collected Vec, these newly-added nodes are never processed for their own outgoing edges.

**Exploitation Scenario:**
1. User module `UserModule` (in compilation targets) contains function `main()`
2. Framework/dependency module `FrameworkModule` (NOT in targets) contains recursive function `helper()`  
3. `main()` calls `helper()`
4. `helper()` calls itself (recursive)

**What Happens:**
- Line 198: Only `main` is added as an explicit node (UserModule is in targets)
- Line 201: `graph.nodes().collect()` returns `[main]`
- Lines 203-213: When processing `main`, we find it calls `helper`
- Line 212: `graph.add_edge(main, helper, ())` implicitly adds `helper` as a node
- The loop ends without processing `helper`'s edges
- `helper`'s self-recursion is never detected
- `helper` is not added to `cycle_nodes`
- `helper` is considered safe to inline [3](#0-2) 

The `skip_functions` set (returned by `find_cycles_in_call_graph`) is used only to filter which caller functions should be processed for inlining their callees. [4](#0-3) 

Critically, the eligibility check for callees does NOT verify if the callee is in `skip_functions`. A recursive function from a dependency module will pass all checks and be marked for inlining. [5](#0-4) 

During the unroll loop, each iteration can inline the recursive call again, causing exponential code growth up to `UNROLL_DEPTH` iterations (default 10).

## Impact Explanation

**Severity: High** - This violates the Move compiler's safety guarantees and can cause:

1. **Compiler Resource Exhaustion**: Exponential code growth during inlining can consume excessive CPU and memory, causing compilation to hang or crash. For a recursive function with multiple self-calls, code size grows as O(branches^UNROLL_DEPTH).

2. **Bytecode Size Violations**: The resulting bytecode may exceed Move VM limits, causing module publication to fail unpredictably.

3. **Semantic Incorrectness**: Partial unrolling of recursive functions changes their semantics from potentially unbounded execution to exactly N iterations, breaking developer expectations and potentially violating invariants.

While this doesn't directly affect consensus or runtime execution (since compilation is off-chain), it represents a significant protocol violation in the Move compiler's correctness guarantees. If validators or infrastructure services use this compiler for module verification or compilation, this could enable targeted DoS attacks against the compilation pipeline.

## Likelihood Explanation

**Likelihood: Medium** - The vulnerability is triggered when:
1. A user module calls a recursive function from a dependency/framework module
2. The dependency module is not in the compilation target scope

This is a realistic scenario since:
- Users commonly call framework utility functions
- Framework modules are typically not in the user's compilation target
- Developers may write helper functions using recursion (especially in library code)

However, Move's design discourages recursion, and many common patterns avoid it. The actual frequency depends on coding practices in the ecosystem.

## Recommendation

Fix the graph construction to process all nodes, including those implicitly added during edge creation:

```rust
fn find_cycles_in_call_graph(
    env: &GlobalEnv,
    targets: &RewriteTargets,
) -> BTreeSet<QualifiedId<FunId>> {
    let mut graph = DiGraphMap::<QualifiedId<FunId>, ()>::new();
    let mut cycle_nodes = BTreeSet::new();
    
    // Add all target functions as nodes
    for target in targets.keys() {
        if let RewriteTarget::MoveFun(function) = target {
            graph.add_node(function);
        }
    }
    
    // Process all nodes iteratively until no new nodes are added
    let mut processed = BTreeSet::new();
    loop {
        let current_nodes: Vec<_> = graph.nodes()
            .filter(|n| !processed.contains(n))
            .collect();
        
        if current_nodes.is_empty() {
            break;
        }
        
        for caller in current_nodes {
            processed.insert(caller);
            let caller_env = env.get_function(caller);
            for callee in caller_env
                .get_used_functions()
                .expect("used functions must be computed")
            {
                if callee == &caller {
                    cycle_nodes.insert(caller);
                } else {
                    graph.add_edge(caller, *callee, ());
                }
            }
        }
    }
    
    // Find SCCs for mutual recursion
    for scc in kosaraju_scc(&graph) {
        if scc.len() > 1 {
            cycle_nodes.extend(scc.into_iter());
        }
    }
    cycle_nodes
}
```

Additionally, add a defensive check in `compute_call_sites_to_inline_and_new_function_size()` to verify callees are not recursive by checking if they're in a global skip list.

## Proof of Concept

```rust
// Test demonstrating the vulnerability
#[test]
fn test_recursive_dependency_not_detected() {
    // Setup: Create a global environment with two modules
    // Module A (in targets): function main() calls helper()
    // Module B (not in targets): recursive function helper() calls itself
    
    let mut env = GlobalEnv::new();
    
    // Create Module B with recursive helper
    let module_b = create_test_module(&mut env, "ModuleB", false, vec![
        create_recursive_function("helper") // helper() { helper(); }
    ]);
    
    // Create Module A that calls helper
    let module_a = create_test_module(&mut env, "ModuleA", true, vec![
        create_calling_function("main", module_b.helper_id) // main() { helper(); }
    ]);
    
    // Run the vulnerable function
    let targets = RewriteTargets::create(&env, RewritingScope::CompilationTarget);
    let skip_functions = find_cycles_in_call_graph(&env, &targets);
    
    // BUG: helper is NOT in skip_functions even though it's recursive
    assert!(!skip_functions.contains(&module_b.helper_id), 
            "Expected helper to not be detected as recursive (BUG)");
    
    // This means helper will be eligible for inlining
    // Run inlining optimization
    optimize(&mut env, false, false);
    
    // After optimization, main() should have inlined helper() multiple times
    // leading to exponential code growth
    let main_def = env.get_function(module_a.main_id).get_def().unwrap();
    let code_size = estimate_code_size(main_def);
    
    assert!(code_size > 1000, 
            "Code size should have grown exponentially due to incorrect inlining");
}
```

## Notes

This vulnerability specifically affects the Move compiler v2's optimization pipeline. The impact is primarily on compilation infrastructure rather than runtime blockchain execution, but it represents a correctness violation that could be exploited to DoS compilation services or produce unexpectedly large bytecode. The fix ensures all functions reachable from compilation targets have their recursion properly detected, regardless of whether they're in the initial target set.

### Citations

**File:** third_party/move/move-compiler-v2/src/env_pipeline/inlining_optimization.rs (L77-77)
```rust
    let skip_functions = find_cycles_in_call_graph(env, &targets);
```

**File:** third_party/move/move-compiler-v2/src/env_pipeline/inlining_optimization.rs (L105-110)
```rust
    for _ in 0..*UNROLL_DEPTH {
        if todo.is_empty() {
            break;
        }
        todo = inline_call_sites(env, &mut targets, todo, across_package);
    }
```

**File:** third_party/move/move-compiler-v2/src/env_pipeline/inlining_optimization.rs (L197-200)
```rust
        if let RewriteTarget::MoveFun(function) = target {
            graph.add_node(function);
        }
    }
```

**File:** third_party/move/move-compiler-v2/src/env_pipeline/inlining_optimization.rs (L201-214)
```rust
    for caller in graph.nodes().collect::<Vec<_>>() {
        let caller_env = env.get_function(caller);
        for callee in caller_env
            .get_used_functions()
            .expect("used functions must be computed")
        {
            if callee == &caller {
                // self-recursion is added to the solution directly
                cycle_nodes.insert(caller);
            } else {
                // non-self-recursion edges
                graph.add_edge(caller, *callee, ());
            }
        }
```

**File:** third_party/move/move-compiler-v2/src/env_pipeline/inlining_optimization.rs (L240-267)
```rust
    let inline_eligible_functions = callees
        .into_iter()
        .filter_map(|(callee, sites_and_loop_depth)| {
            let callee_env = env.get_function(callee);
            let callee_size = get_function_size_estimate(env, &callee);
            if callee_env.is_inline()
                || callee_env.is_native()
                || callee_size.code_size > *MAX_CALLEE_CODE_SIZE
                || has_explicit_return(&callee_env)
                || has_abort(&callee_env, caller_func_env)
                || has_privileged_operations(caller_mid, &callee_env)
                || has_invisible_calls(caller_module, &callee_env, across_package)
                || has_module_lock_attribute(&callee_env)
                || has_access_controls(&callee_env)
            {
                // won't inline if:
                // - callee is inline (should have been inlined already)
                // - callee is native (no body to inline)
                // - callee is too large (heuristic limit)
                // - callee has an explicit return (cannot inline safely without additional
                //   transformations)
                // - callee has privileged operations on structs/enums that the caller cannot
                //   perform directly
                // - callee has calls to functions that are not visible from the caller module
                // - callee has the `#[module_lock]` attribute
                // - callee has runtime access control checks
                // - callee has an abort expression
                None
```
