# Audit Report

## Title
Absolute Path Bypass in OnDiskStorageConfig Allows Arbitrary Filesystem Access

## Summary
The `OnDiskStorageConfig::path()` method bypasses the intended `data_dir` security restriction when provided with an absolute path, allowing arbitrary filesystem read/write operations. This enables an attacker who can influence the validator configuration to access files outside the designated data directory, potentially compromising consensus keys or system files.

## Finding Description

The vulnerability exists in the `OnDiskStorageConfig::path()` method: [1](#0-0) 

When a validator configuration specifies an absolute path in the `OnDiskStorage` backend, the `is_relative()` check returns false, causing the function to return the attacker-controlled absolute path directly without joining it with `data_dir`. This path is then used to create an `OnDiskStorage` instance for consensus SafetyRules: [2](#0-1) 

The `OnDiskStorage::new()` function accepts any `PathBuf` and creates a file at that location: [3](#0-2) 

The storage then performs unrestricted read/write operations: [4](#0-3) 

**Attack Scenario:**
An attacker who can influence the validator configuration (e.g., through config template injection, compromised CI/CD pipeline, Kubernetes ConfigMap manipulation with misconfigured RBAC, or supply chain attacks) modifies the `consensus.safety_rules.backend` section:

```yaml
consensus:
  safety_rules:
    backend:
      type: "on_disk_storage"
      path: "/etc/shadow"  # Attacker-controlled absolute path
```

The `set_data_dir()` call is ineffective because it only modifies the `data_dir` field, leaving the absolute `path` unchanged: [5](#0-4) [6](#0-5) 

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos Bug Bounty program for the following reasons:

1. **Consensus Component Compromise**: SafetyRules is the critical consensus safety component. Unauthorized access to its storage can lead to:
   - Reading private consensus keys
   - Manipulating voting state and causing safety violations
   - Corrupting validator identity data

2. **Arbitrary Filesystem Access**: In non-containerized or misconfigured deployments, this allows:
   - Reading sensitive system files (private keys, credentials)
   - Overwriting critical files, potentially causing validator crashes
   - Writing malicious data to arbitrary locations

3. **Limited by Container Security**: In production Kubernetes deployments with `readOnlyRootFilesystem: true`, the impact is reduced but not eliminated: [7](#0-6) 

The attacker can still:
- Read arbitrary files (information disclosure)
- Write to mounted volumes outside the intended `data_dir` restriction
- Cause denial of service by pointing to invalid paths

4. **No Validation**: Unlike `StorageConfig` which validates absolute paths are required in certain contexts, `OnDiskStorageConfig` has no sanitization preventing malicious absolute paths: [8](#0-7) 

## Likelihood Explanation

**Moderate to High Likelihood** depending on deployment practices:

1. **Config Generation Vulnerabilities**: Many organizations generate validator configs programmatically. Template injection vulnerabilities in config generation scripts could allow path manipulation.

2. **Kubernetes ConfigMap Access**: In Kubernetes deployments, configs are stored as ConfigMaps. Overly permissive RBAC policies or compromised service accounts could enable modification.

3. **Supply Chain Attacks**: Compromised config templates in version control, CI/CD pipelines, or Infrastructure-as-Code repositories could inject malicious paths.

4. **Defense-in-Depth Failure**: Even with container security, this represents a failure of the defense-in-depth principle. The `data_dir` mechanism should enforce its restriction regardless of deployment environment.

5. **Legitimate Use Case Confusion**: The `Token::FromDisk` variant explicitly documents that absolute paths are allowed, which may lead operators to believe absolute paths are safe: [9](#0-8) 

## Recommendation

Implement strict validation in the `SafetyRulesConfig` sanitizer to reject absolute paths or paths containing directory traversal sequences:

```rust
impl ConfigSanitizer for SafetyRulesConfig {
    fn sanitize(
        node_config: &NodeConfig,
        node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();
        let safety_rules_config = &node_config.consensus.safety_rules;

        // Existing validations...

        // NEW: Validate OnDiskStorage path
        if let SecureBackend::OnDiskStorage(config) = &safety_rules_config.backend {
            if config.path.is_absolute() {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    format!(
                        "OnDiskStorage path must be relative, got: {:?}. Absolute paths bypass data_dir security restrictions.",
                        config.path
                    ),
                ));
            }
            
            // Check for path traversal attempts
            for component in config.path.components() {
                if matches!(component, std::path::Component::ParentDir) {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "OnDiskStorage path must not contain '..' directory traversal".to_string(),
                    ));
                }
            }
        }

        Ok(())
    }
}
```

Additionally, update the `OnDiskStorageConfig::path()` method to log a warning or panic if an absolute path is detected in production builds.

## Proof of Concept

Create a malicious validator configuration:

```yaml
# malicious-validator.yaml
base:
  role: "validator"
  data_dir: "/opt/aptos/data"

consensus:
  safety_rules:
    service:
      type: "local"
    backend:
      type: "on_disk_storage"
      path: "/tmp/attacker-controlled.json"  # Absolute path bypassing data_dir
      namespace: ~
```

Create a Rust test demonstrating the bypass:

```rust
#[test]
fn test_absolute_path_bypass() {
    use std::path::PathBuf;
    use aptos_config::config::{OnDiskStorageConfig, SecureBackend};
    
    // Create config with absolute path
    let mut config = OnDiskStorageConfig {
        path: PathBuf::from("/tmp/attacker-controlled.json"),
        namespace: None,
        data_dir: PathBuf::from("/opt/aptos/data"),
    };
    
    // Even after setting data_dir, absolute path is returned unchanged
    config.set_data_dir(PathBuf::from("/opt/aptos/secure-data"));
    
    let resolved_path = config.path();
    
    // VULNERABILITY: Absolute path bypasses data_dir completely
    assert_eq!(resolved_path, PathBuf::from("/tmp/attacker-controlled.json"));
    assert_ne!(resolved_path, PathBuf::from("/opt/aptos/secure-data/attacker-controlled.json"));
    
    // This allows arbitrary filesystem access
    // OnDiskStorage will read/write to /tmp instead of the intended /opt/aptos/data
}
```

When a validator starts with this configuration, the SafetyRules storage will operate on `/tmp/attacker-controlled.json` instead of being confined to `/opt/aptos/data`, bypassing the intended security boundary.

### Citations

**File:** config/src/config/secure_backend_config.rs (L99-106)
```rust
/// Tokens can either be directly within this config or stored somewhere on disk.
#[derive(Clone, Debug, Deserialize, PartialEq, Eq, Serialize)]
#[serde(rename_all = "snake_case")]
pub enum Token {
    FromConfig(String),
    /// This is an absolute path and not relative to data_dir
    FromDisk(PathBuf),
}
```

**File:** config/src/config/secure_backend_config.rs (L140-146)
```rust
    pub fn path(&self) -> PathBuf {
        if self.path.is_relative() {
            self.data_dir.join(&self.path)
        } else {
            self.path.clone()
        }
    }
```

**File:** config/src/config/secure_backend_config.rs (L166-173)
```rust
            SecureBackend::OnDiskStorage(config) => {
                let storage = Storage::from(OnDiskStorage::new(config.path()));
                if let Some(namespace) = &config.namespace {
                    Storage::from(Namespaced::new(namespace, Box::new(storage)))
                } else {
                    storage
                }
            },
```

**File:** secure/storage/src/on_disk.rs (L30-51)
```rust
    pub fn new(file_path: PathBuf) -> Self {
        Self::new_with_time_service(file_path, TimeService::real())
    }

    fn new_with_time_service(file_path: PathBuf, time_service: TimeService) -> Self {
        if !file_path.exists() {
            File::create(&file_path)
                .unwrap_or_else(|_| panic!("Unable to create storage at path: {:?}", file_path));
        }

        // The parent will be one when only a filename is supplied. Therefore use the current
        // working directory provided by PathBuf::new().
        let file_dir = file_path
            .parent()
            .map_or_else(PathBuf::new, |p| p.to_path_buf());

        Self {
            file_path,
            temp_path: TempPath::new_with_temp_dir(file_dir),
            time_service,
        }
    }
```

**File:** secure/storage/src/on_disk.rs (L53-70)
```rust
    fn read(&self) -> Result<HashMap<String, Value>, Error> {
        let mut file = File::open(&self.file_path)?;
        let mut contents = String::new();
        file.read_to_string(&mut contents)?;
        if contents.is_empty() {
            return Ok(HashMap::new());
        }
        let data = serde_json::from_str(&contents)?;
        Ok(data)
    }

    fn write(&self, data: &HashMap<String, Value>) -> Result<(), Error> {
        let contents = serde_json::to_vec(data)?;
        let mut file = File::create(self.temp_path.path())?;
        file.write_all(&contents)?;
        fs::rename(&self.temp_path, &self.file_path)?;
        Ok(())
    }
```

**File:** config/src/config/node_config_loader.rs (L80-83)
```rust
        // Update the data directory. This needs to be done before
        // we optimize and sanitize the node configs (because some optimizers
        // rely on the data directory for file reading/writing).
        node_config.set_data_dir(node_config.get_data_dir().to_path_buf());
```

**File:** config/src/config/safety_rules_config.rs (L52-56)
```rust
    pub fn set_data_dir(&mut self, data_dir: PathBuf) {
        if let SecureBackend::OnDiskStorage(backend) = &mut self.backend {
            backend.set_data_dir(data_dir);
        }
    }
```

**File:** config/src/config/safety_rules_config.rs (L71-116)
```rust
impl ConfigSanitizer for SafetyRulesConfig {
    fn sanitize(
        node_config: &NodeConfig,
        node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();
        let safety_rules_config = &node_config.consensus.safety_rules;

        // If the node is not a validator, there's nothing to be done
        if !node_type.is_validator() {
            return Ok(());
        }

        if let Some(chain_id) = chain_id {
            // Verify that the secure backend is appropriate for mainnet validators
            if chain_id.is_mainnet()
                && node_type.is_validator()
                && safety_rules_config.backend.is_in_memory()
            {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "The secure backend should not be set to in memory storage in mainnet!"
                        .to_string(),
                ));
            }

            // Verify that the safety rules service is set to local for optimal performance
            if chain_id.is_mainnet() && !safety_rules_config.service.is_local() {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    format!("The safety rules service should be set to local in mainnet for optimal performance! Given config: {:?}", &safety_rules_config.service)
                ));
            }

            // Verify that the safety rules test config is not enabled in mainnet
            if chain_id.is_mainnet() && safety_rules_config.test.is_some() {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "The safety rules test config should not be used in mainnet!".to_string(),
                ));
            }
        }

        Ok(())
    }
```

**File:** terraform/helm/aptos-node/templates/validator.yaml (L193-203)
```yaml
        securityContext:
          {{- if $.Values.enablePrivilegedMode }}
          runAsUser: 0
          privileged: true
          {{- else }}
          readOnlyRootFilesystem: true
          allowPrivilegeEscalation: false
          capabilities:
            drop:
            - ALL
          {{- end }}
```
