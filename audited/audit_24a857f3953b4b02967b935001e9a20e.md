# Audit Report

## Title
Stale Quorum Certificate Returned After Block Pruning Leading to Node Crash and Liveness Failure

## Summary
The `highest_quorum_cert()` function can return a stale QC for a pruned block because `highest_certified_block_id` and `highest_quorum_cert` fields are never updated during block pruning. This causes validator node crashes when inserting new QCs and breaks proposal generation, leading to network liveness failures.

## Finding Description

The vulnerability exists in the block pruning logic where `highest_certified_block_id` and `highest_quorum_cert` are not updated when blocks are removed from the tree. [1](#0-0) 

These fields are only updated when a new QC is inserted: [2](#0-1) 

However, when blocks are pruned via `remove_block()`, these fields are never checked or updated: [3](#0-2) 

The pruning process in `commit_callback()` and `process_pruned_blocks()` also does not update these fields: [4](#0-3) 

This creates a critical vulnerability where:

1. **Node Crash via Panic**: When a new QC arrives after the highest certified block is pruned, `insert_quorum_cert()` calls `self.highest_certified_block().round()` to compare rounds. The `highest_certified_block()` function tries to get the pruned block and panics with "Highest certified block must exist": [5](#0-4) 

2. **Proposal Generation Failure**: When validators try to generate proposals, they call `ensure_highest_quorum_cert()` which returns the stale QC: [6](#0-5) 

The proposal then tries to extend from the pruned block, and `path_from_commit_root()` fails: [7](#0-6) 

3. **Misleading SyncInfo**: The stale QC is included in `sync_info()` sent to peers, causing incorrect synchronization state: [8](#0-7) 

**Attack Scenario**: This can occur when:
- A validator has block B at round R as the highest certified block
- A chain reorganization occurs (fork resolution, state sync, or epoch transition)  
- Block B gets pruned as it's not on the committed chain
- `highest_certified_block_id` still points to pruned block B
- New blocks on the main chain with higher rounds have been certified
- When a new QC arrives, the node crashes attempting to compare rounds
- Before the crash, proposal generation fails and stale sync info is broadcast

## Impact Explanation

**HIGH Severity** per Aptos Bug Bounty criteria:

1. **Validator Node Crash (DoS)**: When new QCs arrive after pruning, nodes panic and crash, removing validators from the consensus network. This reduces network security and can be repeatedly triggered.

2. **Liveness Failure**: Affected validators cannot generate proposals, breaking the consensus protocol's liveness guarantee. If multiple validators are affected simultaneously (e.g., during network partition recovery), the network may stall.

3. **Protocol Disruption**: Stale sync info misleads other validators, causing unnecessary block retrieval attempts and sync delays, further degrading network performance.

This qualifies as "Validator node slowdowns" and "Significant protocol violations" under High Severity, potentially escalating to "Total loss of liveness" under Critical Severity if enough validators are affected.

## Likelihood Explanation

**HIGH Likelihood**. This vulnerability can occur during normal network operations:

1. **Network Partitions**: When validators rejoin after temporary partitions, they may have stale highest certified blocks that get pruned during sync
2. **State Sync**: During fast-forward sync, validators reset their block tree and old highest certified blocks are pruned
3. **Chain Reorganizations**: When different forks are resolved, blocks on losing forks are pruned
4. **Epoch Transitions**: During epoch changes, block tree reorganization can trigger pruning

No Byzantine validators or malicious actions are required. The vulnerability is triggered by legitimate network events and consensus operations.

## Recommendation

Update `highest_certified_block_id` and `highest_quorum_cert` when pruning blocks to ensure they always point to valid blocks in the tree:

```rust
pub(super) fn process_pruned_blocks(&mut self, mut newly_pruned_blocks: VecDeque<HashValue>) {
    counters::NUM_BLOCKS_IN_TREE.sub(newly_pruned_blocks.len() as i64);
    
    // Check if highest certified block is being pruned
    if newly_pruned_blocks.contains(&self.highest_certified_block_id) {
        // Find the highest certified block still in the tree
        let mut max_round = 0;
        let mut new_highest_id = self.commit_root_id;
        let mut new_highest_qc = self.highest_quorum_cert.clone();
        
        for (block_id, qc) in self.id_to_quorum_cert.iter() {
            if !newly_pruned_blocks.contains(block_id) {
                if let Some(block) = self.get_block(block_id) {
                    if block.round() > max_round {
                        max_round = block.round();
                        new_highest_id = *block_id;
                        new_highest_qc = qc.clone();
                    }
                }
            }
        }
        
        self.highest_certified_block_id = new_highest_id;
        self.highest_quorum_cert = new_highest_qc;
    }
    
    self.pruned_block_ids.append(&mut newly_pruned_blocks);
    // ... rest of existing code
}
```

Additionally, add defensive checks in `highest_certified_block()` to gracefully handle missing blocks rather than panicking.

## Proof of Concept

```rust
#[tokio::test]
async fn test_stale_qc_after_pruning() {
    use crate::test_utils::{TreeInserter, consensus_runtime};
    use aptos_consensus_types::block::block_test_utils::certificate_for_genesis;
    
    let mut inserter = TreeInserter::default();
    let block_store = inserter.block_store();
    let genesis = block_store.ordered_root();
    
    // Create fork: Genesis -> A1 -> A2 and Genesis -> B1 -> B2 -> B3
    let a1 = inserter.insert_block_with_qc(certificate_for_genesis(), &genesis, 1).await;
    let a2 = inserter.insert_block(&a1, 2, None).await;
    
    // B chain becomes main chain
    let b1 = inserter.insert_block_with_qc(certificate_for_genesis(), &genesis, 1).await;
    let b2 = inserter.insert_block(&b1, 2, None).await;
    let b3 = inserter.insert_block(&b2, 3, None).await;
    
    // A2 is now highest certified block
    assert_eq!(block_store.highest_certified_block().id(), a2.id());
    let hqc_before = block_store.highest_quorum_cert();
    assert_eq!(hqc_before.certified_block().id(), a1.id());
    
    // Commit B3, which prunes A chain including A1 and A2
    block_store.prune_tree(b3.id());
    
    // Bug: highest_quorum_cert still returns QC for pruned block A1
    let hqc_after = block_store.highest_quorum_cert();
    assert_eq!(hqc_after.certified_block().id(), a1.id()); // Still points to pruned block!
    
    // Verify block A1 is actually pruned
    assert!(block_store.get_block(a1.id()).is_none());
    
    // Attempting to insert new QC will panic at highest_certified_block().round()
    let new_block = inserter.create_block(&b3, 4, None);
    let new_qc = inserter.create_qc_for_block(&new_block, None);
    
    // This will panic: "Highest certified block must exist"
    let result = std::panic::catch_unwind(|| {
        block_store.insert_single_quorum_cert(new_qc)
    });
    assert!(result.is_err()); // Node crashes!
}
```

**Notes**

This vulnerability breaks the consensus liveness invariant by preventing validators from generating proposals and processing new QCs after pruning. The issue is particularly severe because it can affect multiple validators simultaneously during network events like partitions or state sync, potentially halting the entire network. The fix requires maintaining consistency between the block tree and the highest certified block metadata during all pruning operations.

### Citations

**File:** consensus/src/block_storage/block_tree.rs (L83-86)
```rust
    highest_certified_block_id: HashValue,

    /// The quorum certificate of highest_certified_block
    highest_quorum_cert: Arc<QuorumCert>,
```

**File:** consensus/src/block_storage/block_tree.rs (L174-181)
```rust
    fn remove_block(&mut self, block_id: HashValue) {
        // Remove the block from the store
        if let Some(block) = self.id_to_block.remove(&block_id) {
            let round = block.executed_block().round();
            self.round_to_ids.remove(&round);
        };
        self.id_to_quorum_cert.remove(&block_id);
    }
```

**File:** consensus/src/block_storage/block_tree.rs (L208-211)
```rust
    pub(super) fn highest_certified_block(&self) -> Arc<PipelinedBlock> {
        self.get_block(&self.highest_certified_block_id)
            .expect("Highest cerfified block must exist")
    }
```

**File:** consensus/src/block_storage/block_tree.rs (L368-371)
```rust
                if block.round() > self.highest_certified_block().round() {
                    self.highest_certified_block_id = block.id();
                    self.highest_quorum_cert = Arc::clone(&qc);
                }
```

**File:** consensus/src/block_storage/block_tree.rs (L496-510)
```rust
    pub(super) fn process_pruned_blocks(&mut self, mut newly_pruned_blocks: VecDeque<HashValue>) {
        counters::NUM_BLOCKS_IN_TREE.sub(newly_pruned_blocks.len() as i64);
        // The newly pruned blocks are pushed back to the deque pruned_block_ids.
        // In case the overall number of the elements is greater than the predefined threshold,
        // the oldest elements (in the front of the deque) are removed from the tree.
        self.pruned_block_ids.append(&mut newly_pruned_blocks);
        if self.pruned_block_ids.len() > self.max_pruned_blocks_in_mem {
            let num_blocks_to_remove = self.pruned_block_ids.len() - self.max_pruned_blocks_in_mem;
            for _ in 0..num_blocks_to_remove {
                if let Some(id) = self.pruned_block_ids.pop_front() {
                    self.remove_block(id);
                }
            }
        }
    }
```

**File:** consensus/src/liveness/proposal_generator.rs (L575-578)
```rust
        let mut pending_blocks = self
            .block_store
            .path_from_commit_root(parent_id)
            .ok_or_else(|| format_err!("Parent block {} already pruned", parent_id))?;
```

**File:** consensus/src/liveness/proposal_generator.rs (L866-879)
```rust
    fn ensure_highest_quorum_cert(&self, round: Round) -> anyhow::Result<Arc<QuorumCert>> {
        let hqc = self.block_store.highest_quorum_cert();
        ensure!(
            hqc.certified_block().round() < round,
            "Given round {} is lower than hqc round {}",
            round,
            hqc.certified_block().round()
        );
        ensure!(
            !hqc.ends_epoch(),
            "The epoch has already ended,a proposal is not allowed to generated"
        );

        Ok(hqc)
```

**File:** consensus/src/block_storage/block_store.rs (L680-688)
```rust
    fn sync_info(&self) -> SyncInfo {
        SyncInfo::new_decoupled(
            self.highest_quorum_cert().as_ref().clone(),
            self.highest_ordered_cert().as_ref().clone(),
            self.highest_commit_cert().as_ref().clone(),
            self.highest_2chain_timeout_cert()
                .map(|tc| tc.as_ref().clone()),
        )
    }
```
