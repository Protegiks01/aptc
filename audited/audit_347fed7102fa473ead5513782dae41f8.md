# Audit Report

## Title
Silent Vote Deserialization Failure Causes Complete Loss of Validator Vote History on Restart

## Summary
A single malformed vote in persistent storage causes all votes (including valid ones) to be silently discarded during validator initialization, resulting in complete loss of vote tracking state without error logging or operator notification.

## Finding Description

The DAG consensus implementation loads persisted votes during `NodeBroadcastHandler` initialization to track which nodes the validator has already voted on. The error handling pattern silently discards all votes if any single vote fails to deserialize.

**Vulnerable Code Flow:** [1](#0-0) 

The `unwrap_or_default()` pattern silently catches all errors from `get_votes()` and returns an empty vector. The underlying issue is in the database iterator's "all-or-nothing" deserialization: [2](#0-1) 

The `get_all()` method uses `collect()` on an iterator that deserializes each vote. The iterator implementation shows the failure propagation: [3](#0-2) 

When `decode_value()` fails for any vote, the entire iterator collection fails. The vote deserialization is defined as: [4](#0-3) 

**Attack Scenario:**

1. Database corruption occurs (hardware failure, incomplete write during crash, storage bug)
2. A single vote becomes malformed in the `dag_vote` column family
3. Validator restarts and calls `read_votes_from_storage()`
4. `get_votes()` attempts to deserialize all votes
5. Iterator fails on the malformed vote, causing entire `get_all()` to return error
6. `unwrap_or_default()` silently catches error, returns empty vector
7. Validator initializes with empty `votes_by_round_peer` map
8. All valid vote history is lost without any error being logged

**Impact on Consensus:**

While the validator can continue voting on new nodes, the loss of vote history means:
- The validator cannot determine which nodes it already voted on during the current round
- Re-processing nodes will cause duplicate vote signatures to be created
- The vote deduplication check becomes ineffective: [5](#0-4) 

- Operators have no visibility into the corruption (silent failure)

## Impact Explanation

**Medium Severity** - This qualifies as "State inconsistencies requiring intervention" under the Aptos bug bounty criteria:

1. **State Inconsistency**: Vote tracking state is lost without notification
2. **Silent Failure**: No error logging means operators cannot detect or diagnose the issue
3. **Robustness Degradation**: System cannot handle partial database corruption gracefully
4. **Operational Impact**: Validators may exhibit inconsistent behavior after restarts without operators understanding why

This does NOT reach High/Critical severity because:
- No direct consensus safety violation (validators can still participate)
- No fund loss or theft
- Liveness is degraded but not completely lost
- Network continues to function

## Likelihood Explanation

**Medium Likelihood** due to:

1. **Multiple Trigger Conditions**:
   - Storage corruption from hardware failures (realistic in production)
   - Incomplete writes during crashes
   - Bugs in vote serialization code
   - Schema migration issues

2. **No Attacker Control Required**: This is a robustness bug, not requiring malicious exploitation

3. **Production Occurrence**: Database corruption events are not uncommon in distributed systems running on commodity hardware

4. **Amplified Impact**: A single corrupted byte affects ALL votes

## Recommendation

Replace the silent error swallowing with robust error handling that:
1. Logs deserialization errors with details
2. Skips individual malformed votes instead of failing completely  
3. Loads all valid votes
4. Alerts operators to corruption

**Recommended Fix:**

```rust
fn read_votes_from_storage(
    storage: &Arc<dyn DAGStorage>,
    epoch: u64,
) -> BTreeMap<u64, BTreeMap<Author, Vote>> {
    let mut votes_by_round_peer = BTreeMap::new();

    // Instead of unwrap_or_default, handle errors explicitly
    let all_votes = match storage.get_votes() {
        Ok(votes) => votes,
        Err(e) => {
            // Log critical error for operator visibility
            error!(
                error = ?e,
                "Failed to load votes from storage, starting with empty vote history. \
                 This may indicate database corruption."
            );
            // Consider using a metric/alert here
            vec![]
        }
    };
    
    // Rest of the function unchanged
    let mut to_delete = vec![];
    for (node_id, vote) in all_votes {
        if node_id.epoch() == epoch {
            votes_by_round_peer
                .entry(node_id.round())
                .or_insert_with(BTreeMap::new)
                .insert(*node_id.author(), vote);
        } else {
            to_delete.push(node_id);
        }
    }
    if let Err(err) = storage.delete_votes(to_delete) {
        error!("unable to clear old signatures: {}", err);
    }

    votes_by_round_peer
}
```

**Better Long-term Fix**: Modify `get_all()` to return partial results on deserialization errors, or implement per-item error handling in the iterator.

## Proof of Concept

```rust
#[cfg(test)]
mod test_vote_corruption {
    use super::*;
    use aptos_schemadb::{SchemaBatch, DB};
    
    #[test]
    fn test_malformed_vote_causes_total_loss() {
        // Setup: Create ConsensusDB with valid votes
        let tmpdir = aptos_temppath::TempPath::new();
        let db = ConsensusDB::new(&tmpdir);
        
        // Save valid votes
        let node_id1 = NodeId::new(1, 1, Author::random());
        let vote1 = create_valid_vote(); // helper function
        db.put::<DagVoteSchema>(&node_id1, &vote1).unwrap();
        
        let node_id2 = NodeId::new(1, 2, Author::random());
        let vote2 = create_valid_vote();
        db.put::<DagVoteSchema>(&node_id2, &vote2).unwrap();
        
        // Corrupt one vote by writing invalid BCS data directly
        let corrupt_node_id = NodeId::new(1, 3, Author::random());
        let mut batch = SchemaBatch::new();
        // Write malformed bytes that will fail BCS deserialization
        batch.put_raw::<DagVoteSchema>(
            &bcs::to_bytes(&corrupt_node_id).unwrap(),
            &vec![0xFF, 0xFF, 0xFF] // Invalid BCS data
        ).unwrap();
        db.commit(batch).unwrap();
        
        // Attempt to load votes - this should return ALL votes but will return NONE
        let result = db.get_all::<DagVoteSchema>();
        
        // Demonstrates the bug: get_all() fails completely instead of returning
        // the 2 valid votes and skipping the corrupted one
        assert!(result.is_err(), "get_all should fail on malformed vote");
        
        // Show that unwrap_or_default loses all data
        let votes = result.unwrap_or_default();
        assert_eq!(votes.len(), 0, "All valid votes are lost!");
        
        // Expected behavior: Should return 2 valid votes
        // Actual behavior: Returns 0 votes
    }
}
```

**Notes:**
- The vulnerability requires database corruption or encoding bugs to manifest, not direct attacker action
- Impact is limited to vote tracking state, not core consensus safety
- Silent failure is the primary concern - operators cannot detect or remediate
- Fix should prioritize error visibility and graceful degradation over perfect recovery

### Citations

**File:** consensus/src/dag/rb_handler.rs (L194-194)
```rust
    let all_votes = storage.get_votes().unwrap_or_default();
```

**File:** consensus/src/dag/rb_handler.rs (L239-247)
```rust
        if let Some(ack) = self
            .votes_by_round_peer
            .lock()
            .entry(node.round())
            .or_default()
            .get(node.author())
        {
            return Ok(ack.clone());
        }
```

**File:** consensus/src/consensusdb/mod.rs (L201-205)
```rust
    pub fn get_all<S: Schema>(&self) -> Result<Vec<(S::Key, S::Value)>, DbError> {
        let mut iter = self.db.iter::<S>()?;
        iter.seek_to_first();
        Ok(iter.collect::<Result<Vec<(S::Key, S::Value)>, AptosDbError>>()?)
    }
```

**File:** storage/schemadb/src/iterator.rs (L118-121)
```rust
        let key = <S::Key as KeyCodec<S>>::decode_key(raw_key);
        let value = <S::Value as ValueCodec<S>>::decode_value(raw_value);

        Ok(Some((key?, value?)))
```

**File:** consensus/src/consensusdb/schema/dag/mod.rs (L64-66)
```rust
    fn decode_value(data: &[u8]) -> Result<Self> {
        Ok(bcs::from_bytes(data)?)
    }
```
