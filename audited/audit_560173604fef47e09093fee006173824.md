# Audit Report

## Title
Unbounded Memory Exhaustion via Malicious JWK Consensus Requests in Per-Key Mode

## Summary
Byzantine validators can exhaust memory on honest validators by flooding them with `KeyLevelObservationRequest` messages containing arbitrary (issuer, kid) pairs. The `process_peer_request()` function creates unbounded HashMap entries without validation, rate limiting, or size constraints, enabling resource exhaustion that can crash validator nodes.

## Finding Description

The vulnerability exists in the JWK consensus per-key mode implementation within the `KeyLevelConsensusManager`. When a validator receives a `KeyLevelObservationRequest` from a peer, the `process_peer_request()` method processes it by unconditionally creating HashMap entries. [1](#0-0) 

The critical issue is the use of `.entry().or_default()` pattern without any bounds checking. This creates a new `ConsensusState::NotStarted` entry for every unique (issuer, kid) pair received, regardless of whether the pair is legitimate or malicious. [2](#0-1) 

Even though the function returns early for `NotStarted` states without sending a response, the HashMap entry has already been created and persists in memory.

The `states_by_key` field is an unbounded HashMap with no size limits: [3](#0-2) 

Both `Issuer` and `KID` are defined as unbounded `Vec<u8>` with no maximum size constraints: [4](#0-3) 

**Attack Flow:**
1. Byzantine validator crafts millions of unique `KeyLevelObservationRequest` messages with random (issuer, kid) pairs
2. Messages are forwarded through the epoch manager without validation
3. Each call to `process_peer_request()` creates a new HashMap entry via `.entry().or_default()`
4. The function returns early, but entries persist in `states_by_key`
5. Memory grows linearly with unique pairs until OOM occurs
6. Validator nodes crash, degrading network performance

**Cleanup Mechanism Failure:**

The `reset_with_on_chain_state()` method attempts cleanup but contains a critical bug: [5](#0-4) 

When an issuer doesn't exist in either the new on-chain state or the cached state (i.e., it's a bogus/malicious issuer), both `unwrap_or_default()` calls return `0` (the default for `u64`). The retain predicate evaluates to `0 == 0` (true), causing invalid entries to be retained instead of cleaned up.

**No Request Validation:**

The epoch manager forwards RPC requests without validating the (issuer, kid) contents: [6](#0-5) 

Only the epoch is validated; the (issuer, kid) pair is not checked against configured OIDC providers or any whitelist.

**No Rate Limiting:**

While channel size limits exist (e.g., 10 for RPC routing), these only limit queued messages, not the rate of HashMap entry creation or the total number of entries: [7](#0-6) 

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos Bug Bounty program criteria, specifically under the "Validator Node Slowdowns (High)" category which includes "DoS through resource exhaustion".

1. **Validator Node Crashes**: Memory exhaustion leads to OOM conditions and validator process termination
2. **Network Availability Impact**: Multiple simultaneous validator crashes degrade network consensus performance
3. **Low Barrier to Attack**: A single Byzantine validator (< 1/3 stake requirement) can execute the attack
4. **Protocol-Level Vulnerability**: Root cause is implementation bugs (missing bounds checking + broken cleanup logic), not pure network flooding

The attack exploits specific code flaws:
- Missing input validation on (issuer, kid) pairs
- Unbounded HashMap growth without size limits
- Logic error in cleanup mechanism (0 == 0 retains invalid entries)

## Likelihood Explanation

**Likelihood: High**

- **Attacker Requirements**: Single Byzantine validator with network access (within Aptos threat model of up to 1/3 Byzantine)
- **Complexity**: Trivialâ€”generate random byte arrays for (issuer, kid) and send `KeyLevelObservationRequest` messages
- **Detection**: No validation checks on incoming (issuer, kid) parameters
- **Cost**: Minimal computational cost for attacker (message serialization), significant memory cost for victims
- **Persistence**: The cleanup bug ensures malicious entries persist across epoch state resets
- **Execution**: Can be executed continuously with automated scripts

The vulnerability is trivially exploitable because:
1. No authentication required for the (issuer, kid) values
2. No bounds checking on HashMap size
3. Cleanup mechanism fails to remove bogus entries
4. Attack can continue indefinitely until validators crash

## Recommendation

**Immediate Fixes:**

1. **Add HashMap Size Limits**: Implement a maximum size for `states_by_key` and reject requests when capacity is reached

2. **Fix Cleanup Logic**: Correct the retain predicate to remove entries for issuers not present in the new on-chain state:

```rust
self.states_by_key.retain(|(issuer, _), _| {
    let new_version = new_onchain_jwks.get(issuer).map(|jwks| jwks.version);
    let old_version = self.onchain_jwks.get(issuer).map(|jwks| jwks.version);
    
    // Only retain if issuer exists in new state AND versions match
    match (new_version, old_version) {
        (Some(new_v), Some(old_v)) => new_v == old_v,
        _ => false, // Remove if issuer doesn't exist in new on-chain state
    }
});
```

3. **Add Input Validation**: Validate (issuer, kid) pairs against configured OIDC providers before creating HashMap entries

4. **Add Size Limits**: Define maximum sizes for `Issuer` and `KID` types (e.g., 256 bytes each)

5. **Add Rate Limiting**: Implement per-peer rate limiting on RPC request processing

## Proof of Concept

```rust
// Proof of concept demonstrating unbounded HashMap growth
#[test]
fn test_unbounded_memory_exhaustion() {
    // Setup: Create KeyLevelConsensusManager with minimal state
    let mut manager = setup_test_manager();
    
    // Attack: Send millions of unique (issuer, kid) pairs
    for i in 0..1_000_000 {
        let malicious_issuer = format!("bogus_issuer_{}", i).into_bytes();
        let malicious_kid = format!("bogus_kid_{}", i).into_bytes();
        
        let request = ObservedKeyLevelUpdateRequest {
            epoch: manager.epoch_state.epoch,
            issuer: malicious_issuer,
            kid: malicious_kid,
        };
        
        let rpc_req = create_test_rpc_request(request);
        
        // This creates a new HashMap entry each time
        manager.process_peer_request(rpc_req).unwrap();
    }
    
    // Verify: HashMap has grown unbounded
    assert_eq!(manager.states_by_key.len(), 1_000_000);
    
    // Verify cleanup bug: Reset with empty on-chain state
    manager.reset_with_on_chain_state(AllProvidersJWKs::default()).unwrap();
    
    // Bug: Entries are retained because 0 == 0 evaluates to true
    assert_eq!(manager.states_by_key.len(), 1_000_000); // Should be 0!
}
```

**Notes:**
- The vulnerability exploits implementation bugs in state management, not pure network flooding
- The cleanup logic bug (0 == 0 retention) is objectively incorrect and enables persistent memory leaks
- This qualifies as "DoS through resource exhaustion" (HIGH severity) rather than a network-level DoS attack
- Single Byzantine validator can execute without coordination or majority stake control

### Citations

**File:** crates/aptos-jwk-consensus/src/jwk_manager_per_key.rs (L59-59)
```rust
    states_by_key: HashMap<(Issuer, KID), ConsensusState<ObservedKeyLevelUpdate>>,
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager_per_key.rs (L244-254)
```rust
        self.states_by_key.retain(|(issuer, _), _| {
            new_onchain_jwks
                .get(issuer)
                .map(|jwks| jwks.version)
                .unwrap_or_default()
                == self
                    .onchain_jwks
                    .get(issuer)
                    .map(|jwks| jwks.version)
                    .unwrap_or_default()
        });
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager_per_key.rs (L274-277)
```rust
                let consensus_state = self
                    .states_by_key
                    .entry((issuer.clone(), kid.clone()))
                    .or_default();
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager_per_key.rs (L279-285)
```rust
                    ConsensusState::NotStarted => {
                        debug!(
                            issuer = String::from_utf8(issuer.clone()).ok(),
                            kid = String::from_utf8(kid.clone()).ok(),
                            "key-level jwk consensus not started"
                        );
                        return Ok(());
```

**File:** types/src/jwks/mod.rs (L36-38)
```rust
pub type Issuer = Vec<u8>;
/// Type for JWK Key ID.
pub type KID = Vec<u8>;
```

**File:** crates/aptos-jwk-consensus/src/epoch_manager.rs (L94-105)
```rust
    fn process_rpc_request(
        &mut self,
        peer_id: Author,
        rpc_request: IncomingRpcRequest,
    ) -> Result<()> {
        if Some(rpc_request.msg.epoch()) == self.epoch_state.as_ref().map(|s| s.epoch) {
            if let Some(tx) = &self.jwk_rpc_msg_tx {
                let _ = tx.push(peer_id, (peer_id, rpc_request));
            }
        }
        Ok(())
    }
```

**File:** crates/aptos-jwk-consensus/src/network.rs (L169-169)
```rust
        let (rpc_tx, rpc_rx) = aptos_channel::new(QueueStyle::FIFO, 10, None);
```
