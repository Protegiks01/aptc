# Audit Report

## Title
Consensus Timing and State Information Leakage via Unauthenticated Metrics Endpoint

## Summary
Aptos validators expose detailed consensus timing metrics and real-time consensus state information through an unauthenticated Prometheus metrics endpoint on port 9101. This includes critical information such as current round numbers, round timeout durations, whether the validator is the next proposer, and per-peer voting participation data. While this doesn't directly break consensus safety properties, it provides attackers with intelligence that could facilitate targeted attacks on consensus participants.

## Finding Description

The Aptos consensus layer exposes extensive timing and state information via Prometheus metrics that are served without authentication through the inspection service on port 9101. [1](#0-0) 

The `monitor!` macro wraps consensus operations with timing measurements: [2](#0-1) 

Critical consensus operations are monitored, exposing their execution timing: [3](#0-2) 

Most critically, the metrics reveal whether the current validator is the next proposer: [4](#0-3) 

Additional consensus state metrics expose real-time participation: [5](#0-4) 

These metrics are served without authentication via the inspection service: [6](#0-5) 

The metrics endpoint is exposed on port 9101 with Prometheus scraping annotations: [7](#0-6) [8](#0-7) 

## Impact Explanation

This issue is classified as **Low Severity** per the Aptos bug bounty program as a "minor information leak." While the exposed metrics do not directly break consensus safety properties (which would be Critical severity), they provide valuable reconnaissance information:

1. **Proposer identification**: The `is_next_proposer` label reveals when a validator will be the next proposer during timeout scenarios
2. **Consensus state visibility**: Real-time round numbers, timeout values, and voting participation
3. **Timing patterns**: Operation durations that could reveal network conditions or validator performance
4. **Participation tracking**: Which validators are actively voting in each round

This information could potentially facilitate targeted Denial-of-Service attacks against upcoming proposers or enable timing-based attacks, but it does not directly violate any of the critical invariants (consensus safety, deterministic execution, state consistency) that would warrant Medium or higher severity.

## Likelihood Explanation

**Likelihood: High** - The metrics endpoint is commonly exposed in production deployments for monitoring purposes. While infrastructure-level controls (HAProxy IP blocking, Kubernetes NetworkPolicies) may restrict access in some deployments, many validators expose metrics publicly or to monitoring services that could be compromised.

The information is continuously available and requires no special conditions to access - simply making HTTP GET requests to `http://<validator-ip>:9101/metrics`.

## Recommendation

Implement a multi-layered approach to protect consensus-critical metrics:

1. **Sanitize Sensitive Labels**: Remove or redact the `is_next_proposer` label from `AGGREGATED_ROUND_TIMEOUT_REASON`:

```rust
// In round_manager.rs, line 440-446
counters::AGGREGATED_ROUND_TIMEOUT_REASON
    .with_label_values(&[
        &reason.to_string(),
        prev_proposer.short_str().as_str(),
        "redacted", // Instead of &is_current_proposer.to_string()
    ])
    .inc();
```

2. **Add Authentication**: Implement optional authentication for the inspection service metrics endpoint:

```rust
// Add to InspectionServiceConfig
pub struct InspectionServiceConfig {
    // ... existing fields
    pub metrics_auth_token: Option<String>,
}

// In server/metrics.rs
pub fn handle_metrics_request(auth_header: Option<&str>, config: &InspectionServiceConfig) -> (StatusCode, Body, String) {
    if let Some(required_token) = &config.metrics_auth_token {
        if auth_header != Some(required_token) {
            return (StatusCode::UNAUTHORIZED, Body::from("Unauthorized"), CONTENT_TYPE_TEXT.into());
        }
    }
    // ... existing logic
}
```

3. **Metric Filtering**: Implement allow/deny lists for which metrics to expose publicly vs. require authentication.

4. **Documentation**: Update deployment documentation to emphasize the importance of restricting metrics endpoint access via firewall rules or network policies.

## Proof of Concept

1. **Setup**: Deploy an Aptos validator node with default configuration (metrics on port 9101)

2. **Access Metrics**: From any machine with network access to the validator:
```bash
# Query the metrics endpoint
curl http://<validator-ip>:9101/metrics

# Filter for consensus-critical metrics
curl http://<validator-ip>:9101/metrics | grep -E "aptos_consensus_current_round|is_next_proposer|consensus_duration"
```

3. **Extract Information**: Parse the Prometheus metrics to identify:
   - Current round number from `aptos_consensus_current_round`
   - Proposer status from `aptos_consensus_agg_round_timeout_reason{is_next_proposer="true"}`
   - Operation timing from `consensus_duration_sum` and `consensus_duration_count`
   - Voting participation from `aptos_consensus_current_round_voted_power{peer_id="..."}`

4. **Monitor Multiple Validators**: Script to continuously poll multiple validators' metrics endpoints and correlate the data to build a real-time view of consensus state across the network.

The vulnerability is confirmed when an external observer can determine which validators are current or upcoming proposers and monitor their consensus participation in real-time without any authentication.

---

**Notes**

While this information disclosure does not directly break consensus safety, it reduces defense-in-depth by providing attackers with actionable intelligence. Production deployments should restrict access to the metrics endpoint through network-level controls (firewall rules, VPNs, authentication proxies) until application-level authentication is implemented. The severity is correctly assessed as Low per the bug bounty criteria, as it does not meet the threshold for Medium severity (requires limited funds loss or state inconsistencies).

### Citations

**File:** consensus/src/counters.rs (L56-57)
```rust
pub static OP_COUNTERS: Lazy<aptos_metrics_core::op_counters::OpMetrics> =
    Lazy::new(|| aptos_metrics_core::op_counters::OpMetrics::new_and_registered("consensus"));
```

**File:** consensus/src/counters.rs (L556-614)
```rust
/// For the current ordering round, for each peer, whether they have voted, and for which hash_index
pub static CONSENSUS_CURRENT_ROUND_VOTED_POWER: Lazy<GaugeVec> = Lazy::new(|| {
    register_gauge_vec!(
        "aptos_consensus_current_round_voted_power",
        "Counter for consensus participation status, 0 means no participation and 1 otherwise",
        &["peer_id", "hash_index"]
    )
    .unwrap()
});

/// For the current ordering round, for each peer, whether they have voted for a timeout
pub static CONSENSUS_CURRENT_ROUND_TIMEOUT_VOTED_POWER: Lazy<GaugeVec> = Lazy::new(|| {
    register_gauge_vec!(
        "aptos_consensus_current_round_timeout_voted_power",
        "Counter for consensus participation status, 0 means no participation and 1 otherwise",
        &["peer_id"]
    )
    .unwrap()
});

/// Last vote seen for each of the peers
pub static CONSENSUS_LAST_VOTE_EPOCH: Lazy<IntGaugeVec> = Lazy::new(|| {
    register_int_gauge_vec!(
        "aptos_consensus_last_voted_epoch",
        "for each peer_id, last epoch we've seen consensus vote",
        &["peer_id"]
    )
    .unwrap()
});

/// Last vote seen for each of the peers
pub static CONSENSUS_LAST_VOTE_ROUND: Lazy<IntGaugeVec> = Lazy::new(|| {
    register_int_gauge_vec!(
        "aptos_consensus_last_voted_round",
        "for each peer_id, last round we've seen consensus vote",
        &["peer_id"]
    )
    .unwrap()
});

/// Last timeout vote seen for each of the peers
pub static CONSENSUS_LAST_TIMEOUT_VOTE_EPOCH: Lazy<IntGaugeVec> = Lazy::new(|| {
    register_int_gauge_vec!(
        "aptos_consensus_last_timeout_voted_epoch",
        "for each peer_id, last epoch we've seen consensus timeout vote",
        &["peer_id"]
    )
    .unwrap()
});

/// Last timeout vote seen for each of the peers
pub static CONSENSUS_LAST_TIMEOUT_VOTE_ROUND: Lazy<IntGaugeVec> = Lazy::new(|| {
    register_int_gauge_vec!(
        "aptos_consensus_last_timeout_voted_round",
        "for each peer_id, last round we've seen consensus timeout vote",
        &["peer_id"]
    )
    .unwrap()
});
```

**File:** consensus/src/lib.rs (L94-101)
```rust
macro_rules! monitor {
    ($name:literal, $fn:expr) => {{
        use $crate::{counters::OP_COUNTERS, IntGaugeGuard};
        let _timer = OP_COUNTERS.timer($name);
        let _guard = IntGaugeGuard::new(OP_COUNTERS.gauge(concat!($name, "_running")));
        $fn
    }};
}
```

**File:** consensus/src/round_manager.rs (L440-446)
```rust
                counters::AGGREGATED_ROUND_TIMEOUT_REASON
                    .with_label_values(&[
                        &reason.to_string(),
                        prev_proposer.short_str().as_str(),
                        &is_current_proposer.to_string(),
                    ])
                    .inc();
```

**File:** consensus/src/round_manager.rs (L2163-2180)
```rust
                        VerifiedEvent::VoteMsg(vote_msg) => {
                            monitor!("process_vote", self.process_vote_msg(*vote_msg).await)
                        }
                        VerifiedEvent::RoundTimeoutMsg(timeout_msg) => {
                            monitor!("process_round_timeout", self.process_round_timeout_msg(*timeout_msg).await)
                        }
                        VerifiedEvent::OrderVoteMsg(order_vote_msg) => {
                            monitor!("process_order_vote", self.process_order_vote_msg(*order_vote_msg).await)
                        }
                        VerifiedEvent::UnverifiedSyncInfo(sync_info) => {
                            monitor!(
                                "process_sync_info",
                                self.process_sync_info_msg(*sync_info, peer_id).await
                            )
                        }
                        VerifiedEvent::LocalTimeout(round) => monitor!(
                            "process_local_timeout",
                            self.process_local_timeout(round).await
```

**File:** crates/aptos-inspection-service/src/server/metrics.rs (L72-76)
```rust
/// Handles a new metrics request (with text encoding)
pub fn handle_metrics_request() -> (StatusCode, Body, String) {
    let buffer = utils::get_encoded_metrics(TextEncoder::new());
    (StatusCode::OK, Body::from(buffer), CONTENT_TYPE_TEXT.into())
}
```

**File:** terraform/helm/aptos-node/templates/validator.yaml (L31-34)
```yaml
  - name: metrics
    port: 9101
  - name: admin
    port: 9102
```

**File:** terraform/helm/aptos-node/templates/validator.yaml (L92-93)
```yaml
        prometheus.io/scrape: "true"
        prometheus.io/port: "9101"
```
