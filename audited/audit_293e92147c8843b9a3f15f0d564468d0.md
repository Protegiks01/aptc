# Audit Report

## Title
Move Assembler Bypasses Bytecode Verification Allowing Invalid Bytecode Generation

## Summary
The move-asm tool's `main()` function does not perform any post-generation bytecode verification before considering assembly successful. Generated bytecode is directly serialized and written to disk without invoking the Move bytecode verifier, allowing creation of modules that violate critical Move VM safety invariants including stack safety, type safety, and reference safety.

## Finding Description
The move-asm tool provides a low-level assembler for Move bytecode. The execution flow is: [1](#0-0) 

The `main()` function calls `run()`, which follows this sequence: [2](#0-1) 

The critical issue is visible in lines 84-110: after `assemble()` produces a `CompiledModule` or `CompiledScript`, the code immediately serializes the result (lines 97-109) and writes it to disk (lines 111-113) **without any verification**.

The Move ecosystem provides a comprehensive bytecode verifier that performs essential safety checks: [3](#0-2) 

The verifier performs multiple critical checks including: [4](#0-3) 

These checks enforce:
- **BoundsChecker**: All indices are within table bounds
- **FeatureVerifier**: Features are properly used
- **LimitsVerifier**: Resource limits are respected
- **InstructionConsistency**: Instructions are consistent
- **CodeUnitVerifier**: Stack safety, type safety, reference safety
- **RecursiveStructDefChecker**: No recursive structs
- **InstantiationLoopChecker**: No instantiation loops

A search for verification calls in the move-asm codebase reveals **zero invocations** of the bytecode verifier. The tool generates bytecode and writes it directly to disk, bypassing all safety checks that the Move VM depends on.

**Attack Scenario:**
1. Attacker crafts malicious `.masm` assembly that violates stack safety (e.g., pops from empty stack, incorrect stack heights across branches)
2. Runs `move-asm` to generate bytecode - succeeds without error
3. Deploys the invalid bytecode module to the blockchain
4. When validators execute transactions using this module, different outcomes occur:
   - Some validators might crash or abort execution
   - Others might produce different state roots due to undefined behavior
   - This breaks deterministic execution, causing consensus splits

## Impact Explanation
This is **HIGH severity** because it can cause:

1. **Consensus Safety Violations (Critical)**: Invalid bytecode can execute non-deterministically across validators. If different validators produce different state roots for the same block due to VM crashes or undefined behavior, this violates Aptos's fundamental consensus safety guarantee.

2. **Move VM Safety Violations (High)**: Bytecode that bypasses verification can violate gas limits, memory constraints, stack safety, and type safety - all critical invariants that the Move VM depends on for secure execution.

3. **Validator Node Crashes (High)**: Invalid bytecode can crash the Move VM during execution, causing validator downtime and network disruption.

While the move-asm tool is primarily a development utility, the generated bytecode files (.mv) can be deployed on-chain through standard transaction mechanisms. The lack of verification at assembly time creates a trust boundary gap - the VM expects all bytecode to have been verified, but move-asm produces unverified bytecode.

Per Aptos bug bounty criteria:
- **High Severity** ($50,000): "Validator node slowdowns, API crashes, Significant protocol violations"
- Potential escalation to **Critical** if consensus splits can be reliably triggered

## Likelihood Explanation
**Likelihood: Medium-to-High**

The attack requires:
1. Ability to craft malicious assembly (moderate skill level)
2. Ability to deploy bytecode modules (standard transaction)
3. No special privileges required

Mitigating factors:
- The Move compiler normally produces verified bytecode, so most modules are safe
- Validators may have additional verification layers during module loading
- However, the move-asm tool is officially maintained and used for low-level operations, creating a legitimate attack vector

The likelihood increases if:
- Developers use move-asm for production code generation
- Automated systems trust move-asm output without re-verification
- The bytecode is used in critical system modules

## Recommendation

**Immediate Fix**: Add bytecode verification to the `run()` function after assembly completes but before serialization:

```rust
pub fn run<W>(options: Options, error_writer: &mut W) -> anyhow::Result<()>
where
    W: Write + WriteColor,
{
    // ... existing code for parsing and assembly ...
    
    let result = match assemble(&options, &input, context_modules.iter()) {
        Ok(x) => x,
        Err(diags) => {
            let diag_file = SimpleFile::new(&input_path, &input);
            report_diags(error_writer, &diag_file, diags);
            bail!("exiting with errors")
        },
    };

    // ADD VERIFICATION HERE
    let verification_result = match &result {
        Either::Left(module) => {
            use move_bytecode_verifier::verifier::verify_module;
            verify_module(module)
        },
        Either::Right(script) => {
            use move_bytecode_verifier::verifier::verify_script;
            verify_script(script)
        },
    };
    
    if let Err(err) = verification_result {
        bail!("bytecode verification failed: {:?}", err);
    }

    // ... existing serialization code ...
}
```

**Additional Recommendations:**
1. Add a command-line flag `--skip-verification` for development purposes (default: verification enabled)
2. Update documentation to clarify that all assembled bytecode must pass verification
3. Add integration tests that verify invalid bytecode is rejected
4. Consider whether `ModuleBuilderOptions.validate` should also trigger bytecode verification

## Proof of Concept

Create a malicious assembly file `invalid_stack.masm`:

```move-asm
module 0x42::InvalidStack {
    // Function with stack safety violation
    public fun broken_stack() {
        // Push two values but only pop one
        // This creates stack height mismatch
        ld_u64 100
        ld_u64 200
        pop      // Only pop one value
        ret      // Return with incorrect stack height
    }
}
```

**Reproduction Steps:**

1. Create the malicious assembly file with the content above
2. Run the assembler:
```bash
cargo run -p move-asm -- invalid_stack.masm
```

3. The assembler will **succeed** and generate `invalid_stack.mv` without error

4. Attempt to verify the generated bytecode:
```rust
use move_binary_format::CompiledModule;
use move_bytecode_verifier::verifier::verify_module;
use std::fs;

fn main() {
    let bytes = fs::read("invalid_stack.mv").unwrap();
    let module = CompiledModule::deserialize(&bytes).unwrap();
    
    match verify_module(&module) {
        Ok(_) => println!("Module is valid"),
        Err(e) => println!("Verification failed: {:?}", e),
    }
}
```

5. The verification will **fail** with stack safety errors, proving the assembler generated invalid bytecode

This demonstrates that move-asm produces bytecode that violates Move VM invariants and would be rejected by proper verification, but the assembler itself reports success.

### Citations

**File:** third_party/move/tools/move-asm/src/main.rs (L8-15)
```rust
fn main() {
    let mut error_writer = StandardStream::stderr(ColorChoice::Auto);
    let options = Options::parse();
    if let Err(e) = run(options, &mut error_writer) {
        eprintln!("error: {:#}", e);
        std::process::exit(1)
    }
}
```

**File:** third_party/move/tools/move-asm/src/assembler.rs (L65-114)
```rust
pub fn run<W>(options: Options, error_writer: &mut W) -> anyhow::Result<()>
where
    W: Write + WriteColor,
{
    if options.inputs.len() != 1 {
        bail!("expected exactly one file name for the assembler source")
    }
    let input_path = options.inputs.first().unwrap();
    let input = fs::read_to_string(input_path)?;

    let context_modules = options
        .deps
        .iter()
        .map(|file| {
            let bytes = fs::read(file).map_err(|e| anyhow!(e))?;
            CompiledModule::deserialize(&bytes).map_err(|e| anyhow!(e))
        })
        .collect::<anyhow::Result<Vec<_>>>()?;

    let result = match assemble(&options, &input, context_modules.iter()) {
        Ok(x) => x,
        Err(diags) => {
            let diag_file = SimpleFile::new(&input_path, &input);
            report_diags(error_writer, &diag_file, diags);
            bail!("exiting with errors")
        },
    };

    let path = PathBuf::from(input_path).with_extension("mv");
    let mut out_path = PathBuf::from(options.output_dir);
    out_path.push(path.file_name().expect("file name available"));
    let mut bytes = vec![];
    match result {
        Either::Left(m) => m
            .serialize_for_version(
                Some(options.module_builder_options.bytecode_version),
                &mut bytes,
            )
            .expect("serialization succeeds"),
        Either::Right(s) => s
            .serialize_for_version(
                Some(options.module_builder_options.bytecode_version),
                &mut bytes,
            )
            .expect("serialization succeeds"),
    }
    if let Err(e) = fs::write(&out_path, &bytes) {
        bail!("failed to write result to `{}`: {}", out_path.display(), e);
    }
    Ok(())
```

**File:** third_party/move/move-bytecode-verifier/src/verifier.rs (L78-90)
```rust
/// Helper for a "canonical" verification of a module.
///
/// Clients that rely on verification should call the proper passes
/// internally rather than using this function.
///
/// This function is intended to provide a verification path for clients
/// that do not require full control over verification. It is advised to
/// call this umbrella function instead of each individual checkers to
/// minimize the code locations that need to be updated should a new checker
/// is introduced.
pub fn verify_module(module: &CompiledModule) -> VMResult<()> {
    verify_module_with_config(&VerifierConfig::default(), module)
}
```

**File:** third_party/move/move-bytecode-verifier/src/verifier.rs (L134-173)
```rust
pub fn verify_module_with_config(config: &VerifierConfig, module: &CompiledModule) -> VMResult<()> {
    if config.verify_nothing() {
        return Ok(());
    }
    let prev_state = move_core_types::state::set_state(VMState::VERIFIER);
    let result = std::panic::catch_unwind(|| {
        // Always needs to run bound checker first as subsequent passes depend on it
        BoundsChecker::verify_module(module).map_err(|e| {
            // We can't point the error at the module, because if bounds-checking
            // failed, we cannot safely index into module's handle to itself.
            e.finish(Location::Undefined)
        })?;
        FeatureVerifier::verify_module(config, module)?;
        LimitsVerifier::verify_module(config, module)?;
        DuplicationChecker::verify_module(module)?;

        signature_v2::verify_module(config, module)?;

        InstructionConsistency::verify_module(module)?;
        constants::verify_module(module)?;
        friends::verify_module(module)?;

        RecursiveStructDefChecker::verify_module(module)?;
        InstantiationLoopChecker::verify_module(module)?;
        CodeUnitVerifier::verify_module(config, module)?;

        // Add the failpoint injection to test the catch_unwind behavior.
        fail::fail_point!("verifier-failpoint-panic");

        script_signature::verify_module(module, no_additional_script_signature_checks)
    })
    .unwrap_or_else(|_| {
        Err(
            PartialVMError::new(StatusCode::VERIFIER_INVARIANT_VIOLATION)
                .finish(Location::Undefined),
        )
    });
    move_core_types::state::set_state(prev_state);
    result
}
```
