# Audit Report

## Title
State Tree Corruption via Proof Validation Bypass in Jellyfish Merkle Tree Restoration

## Summary
The `JellyfishMerkleRestore::add_chunk_impl()` function modifies critical in-memory tree state before validating the provided `SparseMerkleRangeProof`, creating a window for tree corruption. If proof validation fails after state modifications, no rollback occurs, leaving the tree in a corrupted state that persists across subsequent chunk processing operations.

## Finding Description

The vulnerability exists in the state snapshot restoration flow where Merkle tree chunks are processed during state synchronization.

**Attack Flow:**

1. During state sync, a node receives `StateValueChunkWithProof` data from network peers containing state key-value pairs and a `SparseMerkleRangeProof` [1](#0-0) 

2. The `StateSnapshotRestore::add_chunk()` method is called, which invokes `JellyfishMerkleRestore::add_chunk_impl()` with the chunk data and proof [2](#0-1) 

3. **Critical Issue:** In `add_chunk_impl()`, the function processes the entire chunk (lines 373-388) by calling `add_one()` for each key-value pair, which modifies:
   - `self.partial_nodes` (in-memory tree structure)
   - `self.previous_leaf` (last added leaf tracking)
   - `self.frozen_nodes` (nodes ready for storage)
   - `self.num_keys_received` (counter) [3](#0-2) 

4. **Only after all state modifications**, proof validation occurs at line 391 [4](#0-3) 

5. If `verify()` fails, the function returns an error, but **NO rollback mechanism exists** - the corrupted in-memory state persists

6. The `JellyfishMerkleRestore` object is stateful and created once per state sync session [5](#0-4) 

7. When `add_chunk()` fails, the error is only logged and sent to error handlers, but the receiver continues to exist with corrupted state [6](#0-5) 

8. Subsequent valid chunks are processed using this corrupted tree structure, leading to incorrect tree topology and potentially accepting an invalid final root hash

**Invariant Violation:**

This breaks the **State Consistency** invariant: "State transitions must be atomic and verifiable via Merkle proofs." The modification of tree state occurs non-atomically without proper validation, and failures leave partial state changes in place.

## Impact Explanation

**Severity: Critical**

This vulnerability enables multiple critical attacks:

1. **Consensus Divergence**: Different nodes may end up with different tree structures if they receive chunks in different orders or experience different proof validation failures. This leads to different root hashes for the same version, breaking consensus safety.

2. **Tree Corruption Acceptance**: An attacker can craft chunks with malicious key-value data but invalid proofs. Even though the proof validation fails, the malicious data is integrated into the tree structure, potentially allowing:
   - Acceptance of states that shouldn't exist
   - Incorrect parent-child relationships in the Jellyfish Merkle tree
   - Wrong hash computations for subsequent operations

3. **State Sync Manipulation**: A malicious peer can deliberately send corrupting chunks during state sync, causing the syncing node to:
   - Build an incorrect tree that diverges from the network
   - Fail to reach consensus with other validators
   - Require a full resync or manual intervention

4. **Non-Recoverable Without Restart**: Once the tree state is corrupted, there's no automatic recovery mechanism. The node continues with corrupted state until the entire state sync is restarted.

This qualifies as **Critical Severity** per Aptos bug bounty criteria: "Consensus/Safety violations" and "State inconsistencies requiring intervention."

## Likelihood Explanation

**Likelihood: High**

1. **Attack Surface**: Any network peer can send state chunks during state sync. No special privileges required.

2. **Ease of Exploitation**: An attacker only needs to:
   - Participate in the state sync protocol as a serving peer
   - Craft a chunk with valid-looking key-value pairs
   - Provide an invalid or mismatched `SparseMerkleRangeProof`
   - The victim node will process the chunk and corrupt its tree

3. **Detection Difficulty**: The corruption happens silently in memory. The error is logged but doesn't prevent further chunk processing with the corrupted state.

4. **Wide Impact**: This affects all nodes performing state sync, which is a common operation during:
   - Initial node bootstrapping
   - Catching up after downtime
   - Fast sync operations

## Recommendation

**Fix: Validate proof BEFORE modifying any state**

The proof validation must occur before any tree modifications. Here's the recommended fix:

```rust
pub fn add_chunk_impl(
    &mut self,
    mut chunk: Vec<(&K, HashValue)>,
    proof: SparseMerkleRangeProof,
) -> Result<()> {
    if self.finished {
        info!("State snapshot restore already finished, ignoring entire chunk.");
        return Ok(());
    }

    // Skip overlapping entries (existing deduplication logic)
    if let Some(prev_leaf) = &self.previous_leaf {
        let skip_until = chunk
            .iter()
            .find_position(|(key, _hash)| key.hash() > *prev_leaf.account_key());
        chunk = match skip_until {
            None => {
                info!("Skipping entire chunk.");
                return Ok(());
            },
            Some((0, _)) => chunk,
            Some((num_to_skip, next_leaf)) => {
                info!(
                    num_to_skip = num_to_skip,
                    next_leaf = next_leaf,
                    "Skipping leaves."
                );
                chunk.split_off(num_to_skip)
            },
        }
    };
    if chunk.is_empty() {
        return Ok(());
    }

    // NEW: Create a temporary leaf node for the last chunk entry to enable proof verification
    let (last_key, last_value_hash) = chunk.last().expect("Chunk is not empty");
    let last_hashed_key = last_key.hash();
    let temp_leaf = LeafNode::new(
        last_hashed_key,
        *last_value_hash,
        ((*last_key).clone(), self.version),
    );

    // NEW: Verify the proof BEFORE modifying any state
    self.verify_with_temp_leaf(proof, &temp_leaf)?;

    // Only proceed with state modifications AFTER proof validation succeeds
    for (key, value_hash) in chunk {
        let hashed_key = key.hash();
        if let Some(ref prev_leaf) = self.previous_leaf {
            ensure!(
                &hashed_key > prev_leaf.account_key(),
                "State keys must come in increasing order.",
            )
        }
        self.previous_leaf.replace(LeafNode::new(
            hashed_key,
            value_hash,
            (key.clone(), self.version),
        ));
        self.add_one(key, value_hash);
        self.num_keys_received += 1;
    }

    // Write the frozen nodes to storage
    if self.async_commit {
        self.wait_for_async_commit()?;
        let (tx, rx) = channel();
        self.async_commit_result = Some(rx);

        let mut frozen_nodes = HashMap::new();
        std::mem::swap(&mut frozen_nodes, &mut self.frozen_nodes);
        let store = self.store.clone();

        IO_POOL.spawn(move || {
            let res = store.write_node_batch(&frozen_nodes);
            tx.send(res).unwrap();
        });
    } else {
        self.store.write_node_batch(&self.frozen_nodes)?;
        self.frozen_nodes.clear();
    }

    Ok(())
}

// Helper function for verification with temporary leaf
fn verify_with_temp_leaf(&self, proof: SparseMerkleRangeProof, temp_leaf: &LeafNode<K>) -> Result<()> {
    let temp_key = temp_leaf.account_key();
    let mut left_siblings = vec![];
    let mut num_visited_right_siblings = 0;
    
    for (i, bit) in temp_key.iter_bits().enumerate() {
        if bit {
            let sibling = if i >= self.partial_nodes.len() * 4 {
                *SPARSE_MERKLE_PLACEHOLDER_HASH
            } else {
                Self::compute_left_sibling(
                    &self.partial_nodes[i / 4],
                    temp_key.get_nibble(i / 4),
                    (3 - i % 4) as u8,
                )
            };
            left_siblings.push(sibling);
        } else {
            num_visited_right_siblings += 1;
        }
    }
    
    ensure!(
        num_visited_right_siblings >= proof.right_siblings().len(),
        "Too many right siblings in the proof.",
    );
    
    for bit in temp_key.iter_bits().rev() {
        if bit {
            if *left_siblings.last().expect("This sibling must exist.")
                == *SPARSE_MERKLE_PLACEHOLDER_HASH
            {
                left_siblings.pop();
            } else {
                break;
            }
        } else if num_visited_right_siblings > proof.right_siblings().len() {
            num_visited_right_siblings -= 1;
        } else {
            break;
        }
    }
    
    left_siblings.reverse();
    
    proof
        .verify(
            self.expected_root_hash,
            SparseMerkleLeafNode::new(*temp_key, temp_leaf.value_hash()),
            left_siblings,
        )
        .map_err(Into::into)
}
```

Alternatively, implement a transaction-like mechanism with rollback capability, or create snapshots of the tree state before processing each chunk.

## Proof of Concept

```rust
#[cfg(test)]
mod proof_validation_attack_test {
    use super::*;
    use aptos_crypto::{hash::CryptoHash, HashValue};
    use aptos_jellyfish_merkle::{
        mock::MockTreeStore, 
        JellyfishMerkleTree,
        TestKey,
    };
    use aptos_types::proof::SparseMerkleRangeProof;
    
    #[test]
    fn test_proof_validation_bypass_corruption() {
        // Setup: Create a valid tree with initial state
        let db = MockTreeStore::default();
        let tree = JellyfishMerkleTree::new(&db);
        
        // Insert initial states
        let key1 = TestKey([1u8; 32]);
        let key2 = TestKey([2u8; 32]);
        let value1 = HashValue::random();
        let value2 = HashValue::random();
        
        let (_root_hash, batch) = tree
            .batch_put_value_set(
                vec![(key1.clone(), value1), (key2.clone(), value2)],
                None,
                0,
            )
            .unwrap();
        db.write_tree_update_batch(batch).unwrap();
        
        // Create restore instance
        let expected_root = tree.get_root_hash(0).unwrap();
        let mut restore = JellyfishMerkleRestore::new(
            Arc::new(db),
            1,
            expected_root,
            false,
        ).unwrap();
        
        // Attack: Send chunk with MALICIOUS key-value but INVALID proof
        let malicious_key = TestKey([100u8; 32]);
        let malicious_value = HashValue::random();
        let malicious_chunk = vec![(&malicious_key, malicious_value)];
        
        // Create an invalid proof (empty right siblings won't match)
        let invalid_proof = SparseMerkleRangeProof::new(vec![]);
        
        // Attempt to add malicious chunk with invalid proof
        let result = restore.add_chunk_impl(malicious_chunk, invalid_proof);
        
        // Expected: Error because proof is invalid
        assert!(result.is_err(), "Should fail proof validation");
        
        // VULNERABILITY: Tree state is now corrupted even though we got an error!
        // The previous_leaf was set to the malicious key
        assert_eq!(
            restore.previous_leaf.as_ref().unwrap().account_key(),
            &malicious_key.hash(),
            "Tree state corrupted: previous_leaf was modified despite proof failure"
        );
        
        // Now send a VALID chunk - it will build on corrupted state
        let valid_key = TestKey([101u8; 32]); // Must be > malicious_key for ordering
        let valid_value = HashValue::random();
        
        // This chunk will be processed on top of the corrupted tree state
        // leading to an incorrect final tree structure
        let (valid_proof, _) = tree.get_range_proof(valid_key.hash(), 1).unwrap();
        let valid_chunk = vec![(&valid_key, valid_value)];
        
        // This may succeed but produces a corrupted tree!
        let _ = restore.add_chunk_impl(valid_chunk, valid_proof);
        
        // The final tree structure is now inconsistent
        // Different from what it would be if processed cleanly
    }
}
```

**Notes:**

The core issue is architectural: the function follows a "process then validate" pattern instead of "validate then process." This is a classic atomicity violation where partial state changes persist after validation failures. The fix requires restructuring the validation to occur before any state mutations, or implementing proper transaction semantics with rollback capabilities.

### Citations

**File:** types/src/state_store/state_value.rs (L345-353)
```rust
pub struct StateValueChunkWithProof {
    pub first_index: u64,     // The first hashed state index in chunk
    pub last_index: u64,      // The last hashed state index in chunk
    pub first_key: HashValue, // The first hashed state key in chunk
    pub last_key: HashValue,  // The last hashed state key in chunk
    pub raw_values: Vec<(StateKey, StateValue)>, // The hashed state key and and raw state value.
    pub proof: SparseMerkleRangeProof, // The proof to ensure the chunk is in the hashed states
    pub root_hash: HashValue, // The root hash of the sparse merkle tree for this chunk
}
```

**File:** storage/aptosdb/src/state_restore/mod.rs (L228-244)
```rust
    fn add_chunk(&mut self, chunk: Vec<(K, V)>, proof: SparseMerkleRangeProof) -> Result<()> {
        let kv_fn = || {
            let _timer = OTHER_TIMERS_SECONDS.timer_with(&["state_value_add_chunk"]);
            self.kv_restore
                .lock()
                .as_mut()
                .unwrap()
                .add_chunk(chunk.clone())
        };

        let tree_fn = || {
            let _timer = OTHER_TIMERS_SECONDS.timer_with(&["jmt_add_chunk"]);
            self.tree_restore
                .lock()
                .as_mut()
                .unwrap()
                .add_chunk_impl(chunk.iter().map(|(k, v)| (k, v.hash())).collect(), proof)
```

**File:** storage/jellyfish-merkle/src/restore/mod.rs (L373-388)
```rust
        for (key, value_hash) in chunk {
            let hashed_key = key.hash();
            if let Some(ref prev_leaf) = self.previous_leaf {
                ensure!(
                    &hashed_key > prev_leaf.account_key(),
                    "State keys must come in increasing order.",
                )
            }
            self.previous_leaf.replace(LeafNode::new(
                hashed_key,
                value_hash,
                (key.clone(), self.version),
            ));
            self.add_one(key, value_hash);
            self.num_keys_received += 1;
        }
```

**File:** storage/jellyfish-merkle/src/restore/mod.rs (L390-391)
```rust
        // Verify what we have added so far is all correct.
        self.verify(proof)?;
```

**File:** state-sync/state-sync-driver/src/storage_synchronizer.rs (L856-860)
```rust
        // Create the snapshot receiver
        let mut state_snapshot_receiver = storage
            .writer
            .get_state_snapshot_receiver(version, expected_root_hash)
            .expect("Failed to initialize the state snapshot receiver!");
```

**File:** state-sync/state-sync-driver/src/storage_synchronizer.rs (L956-965)
```rust
                        Err(error) => {
                            let error =
                                format!("Failed to commit state value chunk! Error: {:?}", error);
                            send_storage_synchronizer_error(
                                error_notification_sender.clone(),
                                notification_id,
                                error,
                            )
                            .await;
                        },
```
