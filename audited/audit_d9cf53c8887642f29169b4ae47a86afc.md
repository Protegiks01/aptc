# Audit Report

## Title
Missing Ledger Info Enforcement for Epoch-Ending Transactions During Transaction Replay

## Summary
The `ExecutedChunk` structure does not enforce that `ledger_info_opt` must be present when `has_reconfiguration()` returns true during transaction replay operations. This violates the critical invariant that epoch-ending transactions must have corresponding epoch-ending ledger information persisted to the database.

## Finding Description

The system fails to enforce a critical invariant during transaction replay: when a chunk contains a reconfiguration (epoch-ending transaction), the corresponding epoch-ending ledger info with `next_epoch_state` must be persisted to maintain epoch continuity.

The vulnerability exists in the `ReplayChunkVerifier` implementation, which unconditionally returns `None` for ledger info regardless of whether the chunk contains a reconfiguration: [1](#0-0) 

This contrasts with `StateSyncChunkVerifier`, which properly enforces the invariant: [2](#0-1) 

The reconfiguration status is determined by checking if `next_epoch_state` is present: [3](#0-2) 

During the update_ledger phase, the `ledger_info_opt` is obtained from the chunk verifier and used to construct an `ExecutedChunk`: [4](#0-3) 

When this chunk is committed, if `ledger_info_opt` is `None`, the epoch-ending ledger info is never persisted: [5](#0-4) 

This causes failures when the system later attempts to retrieve epoch state, which requires the epoch-ending ledger info to contain `next_epoch_state`: [6](#0-5) 

## Impact Explanation

This is a **HIGH severity** issue based on Aptos bug bounty criteria:

**Protocol Violation**: The bug violates the fundamental protocol invariant that epoch-ending transactions must persist epoch-ending ledger information. This invariant is critical for:
- Epoch state continuity across the blockchain
- Validator set transitions between epochs
- Consensus operation which depends on epoch state retrieval

**Node Failure Scenarios**: When epoch-ending transactions are replayed without persisting ledger info:
1. `get_epoch_state(epoch)` queries fail with "Last LedgerInfo in epoch must carry next_epoch_state" errors
2. Consensus observers and participants cannot retrieve validator sets for epoch verification
3. State sync operations fail when trying to validate epoch boundaries
4. Database recovery operations result in inconsistent epoch state

**Operational Impact**: 
- Database recovery after corruption becomes unreliable if epoch-ending transactions are involved
- Historical transaction replay for verification purposes produces inconsistent database state
- Nodes in recovery mode may fail to rejoin the network due to missing epoch information

This meets the HIGH severity criteria of "Significant protocol violations" and can cause "Validator node slowdowns" or failures.

## Likelihood Explanation

**Moderate to High Likelihood** in specific operational scenarios:

1. **Database Recovery**: When a node's database becomes corrupted and needs to be rebuilt by replaying transactions from backups or archives, any epoch-ending transactions in the replay will not have their ledger info persisted.

2. **Transaction Verification**: When using the transaction replayer to verify historical execution correctness, epoch boundaries will be improperly handled.

3. **State Reconstruction**: Any scenario requiring reconstruction of blockchain state from transaction history will fail to properly preserve epoch information.

The likelihood is not rated as "always occurring" because:
- Normal consensus and state sync operations use `StateSyncChunkVerifier`, which has proper enforcement
- The vulnerability only manifests when `ReplayChunkVerifier` is used with epoch-ending transactions
- Most nodes operate normally without triggering replay scenarios

However, when it does occur, it causes deterministic failure and cannot be worked around without manual database intervention.

## Recommendation

Add enforcement in `ReplayChunkVerifier::maybe_select_chunk_ending_ledger_info` to validate that if `next_epoch_state` is present, appropriate ledger info must be provided or reconstructed.

**Option 1 - Validation Enforcement** (minimum fix):
```rust
fn maybe_select_chunk_ending_ledger_info(
    &self,
    ledger_update_output: &LedgerUpdateOutput,
    next_epoch_state: Option<&EpochState>,
) -> Result<Option<LedgerInfoWithSignatures>> {
    ensure!(
        next_epoch_state.is_none(),
        "Epoch-ending transactions during replay require epoch-ending LedgerInfo to be provided. \
         Transaction replay cannot persist epoch boundaries without corresponding LedgerInfoWithSignatures. \
         Version: {:?}",
        ledger_update_output.transaction_accumulator.num_leaves().checked_sub(1)
    );
    Ok(None)
}
```

**Option 2 - Proper Ledger Info Reconstruction** (complete fix):
The transaction replayer should be enhanced to either:
1. Accept pre-computed epoch-ending ledger infos as input alongside transactions
2. Reconstruct minimal ledger infos for epoch boundaries during replay
3. Validate that the replay source provides epoch-ending ledger infos when needed

Additionally, add a validation check in `ExecutedChunk` or during commit that enforces the invariant:
```rust
// In save_transactions or commit_ledger
if chunk.has_reconfiguration() {
    ensure!(
        ledger_info_with_sigs.is_some(),
        "Chunk with reconfiguration (next_epoch_state present) must have accompanying LedgerInfo"
    );
}
```

## Proof of Concept

The following Rust test demonstrates the vulnerability:

```rust
#[test]
fn test_replay_epoch_ending_missing_ledger_info() {
    use crate::chunk_executor::chunk_result_verifier::ReplayChunkVerifier;
    use aptos_types::epoch_state::EpochState;
    use aptos_executor_types::LedgerUpdateOutput;
    
    // Setup: Create a ReplayChunkVerifier
    let verifier = ReplayChunkVerifier {
        transaction_infos: vec![/* valid transaction infos */],
    };
    
    // Create a mock LedgerUpdateOutput
    let ledger_update_output = LedgerUpdateOutput { /* ... */ };
    
    // Create a mock EpochState (indicating reconfiguration occurred)
    let next_epoch_state = Some(EpochState { /* ... */ });
    
    // Call maybe_select_chunk_ending_ledger_info
    let result = verifier.maybe_select_chunk_ending_ledger_info(
        &ledger_update_output,
        next_epoch_state.as_ref()
    ).unwrap();
    
    // BUG: Returns None even though reconfiguration occurred
    assert!(result.is_none(), "Bug: Returns None despite epoch ending");
    
    // This ExecutedChunk would be created with ledger_info_opt = None
    // When committed, the epoch-ending ledger info would not be persisted
    // Later calls to get_epoch_state(next_epoch) would fail
}
```

To observe the full impact, construct a test that:
1. Creates a chunk with epoch-ending transaction
2. Replays it using ReplayChunkVerifier
3. Commits the resulting ExecutedChunk
4. Attempts to query `get_epoch_state()` for the new epoch
5. Observes the failure due to missing epoch-ending ledger info

### Citations

**File:** execution/executor/src/chunk_executor/chunk_result_verifier.rs (L119-123)
```rust
            ensure!(
                next_epoch_state.is_none(),
                "End of epoch chunk based on local computation but no EoE LedgerInfo provided. version: {:?}",
                txn_accumulator.num_leaves().checked_sub(1),
            );
```

**File:** execution/executor/src/chunk_executor/chunk_result_verifier.rs (L146-152)
```rust
    fn maybe_select_chunk_ending_ledger_info(
        &self,
        _ledger_update_output: &LedgerUpdateOutput,
        _next_epoch_state: Option<&EpochState>,
    ) -> Result<Option<LedgerInfoWithSignatures>> {
        Ok(None)
    }
```

**File:** execution/executor/src/types/partial_state_compute_result.rs (L57-59)
```rust
    pub fn has_reconfiguration(&self) -> bool {
        self.execution_output.next_epoch_state.is_some()
    }
```

**File:** execution/executor/src/chunk_executor/mod.rs (L367-379)
```rust
        let ledger_info_opt = chunk_verifier.maybe_select_chunk_ending_ledger_info(
            &ledger_update_output,
            output.execution_output.next_epoch_state.as_ref(),
        )?;
        output.set_state_checkpoint_output(state_checkpoint_output);
        output.set_ledger_update_output(ledger_update_output);

        let first_version = output.execution_output.first_version;
        let num_txns = output.execution_output.num_transactions_to_commit();
        let executed_chunk = ExecutedChunk {
            output,
            ledger_info_opt,
        };
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L99-101)
```rust
            if let Some(li) = ledger_info_with_sigs {
                self.check_and_put_ledger_info(version, li, &mut ledger_batch)?;
            }
```

**File:** storage/aptosdb/src/ledger_db/ledger_metadata_db.rs (L135-150)
```rust
    pub(crate) fn get_epoch_state(&self, epoch: u64) -> Result<EpochState> {
        ensure!(epoch > 0, "EpochState only queryable for epoch >= 1.",);

        let ledger_info_with_sigs =
            self.db
                .get::<LedgerInfoSchema>(&(epoch - 1))?
                .ok_or_else(|| {
                    AptosDbError::NotFound(format!("Last LedgerInfo of epoch {}", epoch - 1))
                })?;
        let latest_epoch_state = ledger_info_with_sigs
            .ledger_info()
            .next_epoch_state()
            .ok_or_else(|| {
                AptosDbError::Other(
                    "Last LedgerInfo in epoch must carry next_epoch_state.".to_string(),
                )
```
