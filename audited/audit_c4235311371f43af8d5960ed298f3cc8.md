# Audit Report

## Title
Permanent Leader Centralization via Non-Rotated Default Proposer in RoundProposer

## Summary
The `RoundProposer` election mechanism uses a static `default_proposer` (hardcoded to the first validator) for all rounds not explicitly mapped in the `round_proposers` HashMap. This allows a single validator to become the permanent block leader for unmapped rounds within an epoch, violating consensus decentralization principles and enabling transaction censorship.

## Finding Description

The vulnerability exists in the `RoundProposer` implementation used when the on-chain consensus configuration specifies `ProposerElectionType::RoundProposer`.

In the `create_proposer_election()` function, when creating a `RoundProposer`, the default proposer is hardcoded to the first validator in the ordered list: [1](#0-0) 

The `RoundProposer` struct stores this default proposer and returns it for any round not explicitly mapped in its HashMap: [2](#0-1) 

The `get_valid_proposer()` implementation returns the same `default_proposer` for all unmapped rounds: [3](#0-2) 

This test demonstrates the fallback behavior where round 3 (unmapped) uses the default proposer: [4](#0-3) 

**Attack Scenario:**

1. On-chain governance sets `ProposerElectionType::RoundProposer` with a sparse mapping (e.g., only rounds 1-100 mapped to different validators)
2. Consensus proceeds normally through mapped rounds
3. Once round 101 is reached, the system falls back to `default_proposer` (first validator)
4. For all subsequent rounds in the epoch (101, 102, 103, ...), the first validator remains the permanent leader
5. This validator can now:
   - Censor specific transactions by excluding them from blocks
   - Extract MEV by reordering transactions
   - Control which validator transactions are included
   - Potentially collude with external actors for profit

The on-chain consensus configuration can be set via governance proposals with no validation that the round mapping is complete: [5](#0-4) 

Epochs are time-bounded (default 2 hours) but have no hard limit on round count, meaning hundreds or thousands of rounds could use the default proposer: [6](#0-5) 

## Impact Explanation

This vulnerability meets **Medium Severity** criteria per the Aptos bug bounty program:

- **State inconsistencies requiring intervention**: A single validator controlling block production creates centralization that requires governance intervention to fix (updating the consensus config)
- **Limited funds loss or manipulation**: The permanent leader can extract MEV and censor transactions, potentially causing economic losses to users
- **Consensus fairness violation**: While this doesn't break consensus safety (no forks or double-spends), it violates the fundamental principle of distributed consensus where leadership should be rotated among validators
- **Transaction censorship**: The permanent leader can block specific transactions indefinitely until epoch reconfiguration

The impact is limited to one epoch's duration (default 2 hours) and doesn't cause permanent network damage, but enables significant centralization and potential for abuse.

## Likelihood Explanation

**Medium Likelihood:**

**Required conditions:**
1. Governance must configure `ProposerElectionType::RoundProposer` (not the default election type)
2. The `round_proposers` HashMap must be sparse or incomplete
3. Consensus must progress beyond the mapped rounds

**Why this could occur:**
- Accidental misconfiguration during governance proposals
- Intentional malicious configuration if governance is compromised
- The presence of this code path suggests it's intended for use in specific scenarios (e.g., network upgrades, testing), increasing the likelihood of misconfiguration

**Mitigating factors:**
- Most deployments likely use `LeaderReputation` or `RotatingProposer` election types
- Requires governance approval, which undergoes community review
- Limited to epoch duration before automatic reset

## Recommendation

Implement rotation for the default proposer to ensure no single validator can maintain permanent leadership. Multiple approaches are possible:

**Option 1: Round-robin rotation of default proposer**
```rust
impl ProposerElection for RoundProposer {
    fn get_valid_proposer(&self, round: Round) -> Author {
        match self.proposers.get(&round) {
            Some(round_proposer) => *round_proposer,
            None => {
                // Rotate through all proposers based on round number
                let index = (round as usize) % self.default_proposers.len();
                self.default_proposers[index]
            }
        }
    }
}
```

**Option 2: Reject sparse mappings at configuration time**
Add validation in the Move consensus_config module:
```move
public fun set_for_next_epoch(account: &signer, config: vector<u8>) {
    system_addresses::assert_aptos_framework(account);
    assert!(vector::length(&config) > 0, error::invalid_argument(EINVALID_CONFIG));
    
    // Add validation that RoundProposer configs have complete mappings
    // or use a different election type
    validate_consensus_config(&config);
    
    std::config_buffer::upsert<ConsensusConfig>(ConsensusConfig {config});
}
```

**Option 3: Use a weighted random selection for unmapped rounds**
Similar to `LeaderReputation`, use validator voting power to randomly select from all validators for unmapped rounds, preventing permanent single-validator leadership.

## Proof of Concept

```rust
#[test]
fn test_permanent_leader_vulnerability() {
    use crate::liveness::{
        proposer_election::ProposerElection, 
        round_proposer_election::RoundProposer,
    };
    use aptos_types::account_address::AccountAddress;
    use std::collections::HashMap;

    // Simulate 4 validators
    let validator1 = AccountAddress::from_hex_literal("0x1").unwrap();
    let validator2 = AccountAddress::from_hex_literal("0x2").unwrap();
    let validator3 = AccountAddress::from_hex_literal("0x3").unwrap();
    let validator4 = AccountAddress::from_hex_literal("0x4").unwrap();

    // Create sparse mapping for only first 10 rounds
    let mut round_proposers = HashMap::new();
    round_proposers.insert(1, validator1);
    round_proposers.insert(2, validator2);
    round_proposers.insert(3, validator3);
    round_proposers.insert(4, validator4);
    round_proposers.insert(5, validator1);
    round_proposers.insert(6, validator2);
    round_proposers.insert(7, validator3);
    round_proposers.insert(8, validator4);
    round_proposers.insert(9, validator1);
    round_proposers.insert(10, validator2);

    // Default proposer is validator1 (first in list)
    let proposer_election = RoundProposer::new(round_proposers, validator1);

    // Verify mapped rounds work as expected
    assert_eq!(proposer_election.get_valid_proposer(1), validator1);
    assert_eq!(proposer_election.get_valid_proposer(2), validator2);
    assert_eq!(proposer_election.get_valid_proposer(10), validator2);

    // VULNERABILITY: All unmapped rounds use the same default proposer
    // Simulating 100 rounds after the mapped ones
    for round in 11..111 {
        let proposer = proposer_election.get_valid_proposer(round);
        assert_eq!(
            proposer, validator1,
            "Round {} should use default proposer (validator1), but got {:?}",
            round, proposer
        );
    }

    // This demonstrates that validator1 becomes permanent leader for 100 consecutive rounds
    // enabling censorship, MEV extraction, and centralization
    println!("VULNERABILITY CONFIRMED: Validator {:?} is permanent leader for rounds 11-110", validator1);
}
```

This PoC demonstrates that once the mapped rounds are exhausted, the first validator becomes the permanent leader for all subsequent rounds in the epoch, confirming the centralization vulnerability.

**Notes**

The vulnerability is constrained by epoch boundaries (rounds reset each epoch), but within an epoch, the centralization can persist for extended periods. The issue fundamentally violates the decentralization principle of blockchain consensus, even though it doesn't break Byzantine fault tolerance safety guarantees. The fix should either enforce complete round mappings or implement rotation for the default proposer.

### Citations

**File:** consensus/src/epoch_manager.rs (L273-284)
```rust
    fn create_round_state(
        &self,
        time_service: Arc<dyn TimeService>,
        timeout_sender: aptos_channels::Sender<Round>,
    ) -> RoundState {
        let time_interval = Box::new(ExponentialTimeInterval::new(
            Duration::from_millis(self.config.round_initial_timeout_ms),
            self.config.round_timeout_backoff_exponent_base,
            self.config.round_timeout_backoff_max_exponent,
        ));
        RoundState::new(time_interval, time_service, timeout_sender)
    }
```

**File:** consensus/src/epoch_manager.rs (L396-405)
```rust
            ProposerElectionType::RoundProposer(round_proposers) => {
                // Hardcoded to the first proposer
                let default_proposer = proposers
                    .first()
                    .expect("INVARIANT VIOLATION: proposers is empty");
                Arc::new(RoundProposer::new(
                    round_proposers.clone(),
                    *default_proposer,
                ))
            },
```

**File:** consensus/src/liveness/round_proposer_election.rs (L9-24)
```rust
pub struct RoundProposer {
    // A pre-defined map specifying proposers per round
    proposers: HashMap<Round, Author>,
    // Default proposer to use if proposer for a round is unspecified.
    // We hardcode this to the first proposer
    default_proposer: Author,
}

impl RoundProposer {
    pub fn new(proposers: HashMap<Round, Author>, default_proposer: Author) -> Self {
        Self {
            proposers,
            default_proposer,
        }
    }
}
```

**File:** consensus/src/liveness/round_proposer_election.rs (L26-33)
```rust
impl ProposerElection for RoundProposer {
    fn get_valid_proposer(&self, round: Round) -> Author {
        match self.proposers.get(&round) {
            None => self.default_proposer,
            Some(round_proposer) => *round_proposer,
        }
    }
}
```

**File:** consensus/src/liveness/round_proposer_test.rs (L11-40)
```rust
#[test]
fn test_round_proposer() {
    let chosen_author_round1 = AccountAddress::random();
    let chosen_author_round2 = AccountAddress::random();
    let another_author = AccountAddress::random();

    // A map that specifies the proposer per round
    let mut round_proposers: HashMap<Round, Author> = HashMap::new();
    round_proposers.insert(1, chosen_author_round1);
    round_proposers.insert(2, chosen_author_round2);

    let pe = RoundProposer::new(round_proposers, chosen_author_round1);

    // Send a proposal from both chosen author and another author, the only winning proposals
    // follow the round-proposers mapping

    // In round 3, send a proposal from chosen_author_round1 (which is also the default proposer).
    // The proposal should win because the map doesn't specify proposer for round 3 hence
    // falling back on the default proposer

    assert!(pe.is_valid_proposer(chosen_author_round1, 1),);
    assert!(!pe.is_valid_proposer(another_author, 1));
    assert!(pe.is_valid_proposer(chosen_author_round2, 2));
    assert!(!pe.is_valid_proposer(another_author, 2));
    assert!(pe.is_valid_proposer(chosen_author_round1, 3));
    assert!(!pe.is_valid_proposer(another_author, 3));
    assert_eq!(pe.get_valid_proposer(1), chosen_author_round1);
    assert_eq!(pe.get_valid_proposer(2), chosen_author_round2);
    assert_eq!(pe.get_valid_proposer(3), chosen_author_round1);
}
```

**File:** aptos-move/framework/aptos-framework/sources/configs/consensus_config.move (L52-56)
```text
    public fun set_for_next_epoch(account: &signer, config: vector<u8>) {
        system_addresses::assert_aptos_framework(account);
        assert!(vector::length(&config) > 0, error::invalid_argument(EINVALID_CONFIG));
        std::config_buffer::upsert<ConsensusConfig>(ConsensusConfig {config});
    }
```
