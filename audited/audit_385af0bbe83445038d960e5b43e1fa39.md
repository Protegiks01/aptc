# Audit Report

## Title
Unvalidated BatchResponse::NotFound Enables Peer-Based DoS via Signature Verification Exhaustion

## Summary
The delayed verification of `BatchResponse::NotFound(ledger_info)` in the quorum store batch retrieval protocol lacks proper error handling when verification fails. When a malicious peer sends a `NotFound` response with invalid signatures or mismatched epoch, the receiving node silently continues without logging errors or penalizing the malicious peer, enabling resource exhaustion attacks.

## Finding Description

The vulnerability exists in a two-stage verification process for batch responses:

**Stage 1 - Network Layer** [1](#0-0) 

When receiving `BatchResponseV2`, the network layer only verifies the `Batch` variant but explicitly skips verification of `NotFound(ledger_info)`, deferring it to "later with a ValidatorVerifier".

**Stage 2 - Batch Requester** [2](#0-1) 

The "later verification" occurs in `request_batch()` where it checks three conditions before marking a batch as expired. However, if ANY condition fails (wrong epoch, timestamp not past expiration, or invalid signatures), the code silently continues without error handling.

**The Attack Vector:**

A malicious peer can flood batch requesters with crafted `NotFound` responses containing:
- Invalid `LedgerInfoWithSignatures` with forged signatures
- Mismatched epoch numbers
- Arbitrary timestamp values

For each invalid response, the victim node:
1. Receives the response without network-layer validation
2. Increments the `RECEIVED_BATCH_NOT_FOUND_COUNT` counter
3. Performs CPU-intensive signature verification via `verify_signatures()`
4. When verification fails, silently continues (lines 151-152 fall through)
5. No error logging, no peer reputation penalty, no defensive action

This differs from error responses [3](#0-2)  which at least increment an error counter and log the issue.

**Broken Invariant:**

This violates the **Resource Limits** invariant: "All operations must respect gas, storage, and computational limits." The missing validation allows unlimited signature verification attempts by malicious peers without rate limiting or reputation penalties.

## Impact Explanation

**Severity: High** - "Validator node slowdowns"

The vulnerability enables coordinated resource exhaustion attacks:

1. **CPU Exhaustion**: BLS signature verification via `verify_multi_signatures()` [4](#0-3)  is computationally expensive. Repeated invalid responses force continuous verification overhead.

2. **Delayed Batch Retrieval**: While the batch requester has retry limits [5](#0-4) , malicious peers can consume retry attempts, increasing latency for legitimate batch retrieval.

3. **No Peer Accountability**: Unlike state-sync which has peer reputation systems, the batch requester has no mechanism to identify or penalize malicious responders, allowing repeated attacks.

4. **Consensus Impact**: Delayed batch retrieval can slow proposal construction in the quorum store, indirectly impacting consensus throughput and validator performance.

## Likelihood Explanation

**Likelihood: Medium-High**

- **Attacker Requirements**: Any network peer can send batch responses. No special privileges required.
- **Attack Complexity**: Low - attacker simply crafts `BatchResponse::NotFound` with invalid signatures.
- **Detection Difficulty**: High - no logging or metrics track invalid NotFound responses specifically, making attacks hard to detect.
- **Network Position**: Attacker must be among the peers contacted for batch retrieval, which follows a round-robin selection with randomization, but over time all peers in the validator set will be contacted.

## Recommendation

Add comprehensive validation and error handling for invalid `NotFound` responses:

```rust
Ok(BatchResponse::NotFound(ledger_info)) => {
    counters::RECEIVED_BATCH_NOT_FOUND_COUNT.inc();
    
    // Validate epoch
    if ledger_info.commit_info().epoch() != epoch {
        warn!(
            "Received NotFound with mismatched epoch: {} != {}, digest:{}",
            ledger_info.commit_info().epoch(), epoch, digest
        );
        counters::RECEIVED_BATCH_NOT_FOUND_INVALID_EPOCH.inc();
        continue;
    }
    
    // Verify signatures before checking timestamp
    if let Err(e) = ledger_info.verify_signatures(&validator_verifier) {
        error!(
            SecurityEvent::InvalidBatchResponse,
            "Received NotFound with invalid signatures, digest:{}, error:{:?}",
            digest, e
        );
        counters::RECEIVED_BATCH_NOT_FOUND_INVALID_SIG.inc();
        // TODO: Implement peer reputation penalty here
        continue;
    }
    
    // Check expiration only after validation
    if ledger_info.commit_info().timestamp_usecs() > expiration {
        counters::RECEIVED_BATCH_EXPIRED_COUNT.inc();
        debug!("QS: batch request expired, digest:{}", digest);
        return Err(ExecutorError::CouldNotGetData);
    }
}
```

Additionally, implement peer reputation tracking similar to the state-sync data client to penalize validators sending invalid responses.

## Proof of Concept

```rust
#[tokio::test]
async fn test_invalid_notfound_response_dos() {
    // Setup: Create a batch requester with retry_limit=5
    let epoch = 10;
    let my_peer_id = PeerId::random();
    let retry_limit = 5;
    let validator_verifier = Arc::new(ValidatorVerifier::new(vec![]));
    
    // Create a malicious network sender that always returns NotFound with invalid signatures
    struct MaliciousNetworkSender;
    
    #[async_trait::async_trait]
    impl QuorumStoreSender for MaliciousNetworkSender {
        async fn request_batch(
            &self,
            _request: BatchRequest,
            _recipient: Author,
            _timeout: Duration,
        ) -> anyhow::Result<BatchResponse> {
            // Craft NotFound response with invalid LedgerInfoWithSignatures
            let invalid_ledger_info = LedgerInfoWithSignatures::new(
                LedgerInfo::new(
                    BlockInfo::new(
                        epoch,
                        0, // round
                        HashValue::zero(),
                        HashValue::zero(),
                        0, // version
                        u64::MAX, // future timestamp to pass expiration check
                        None,
                    ),
                    HashValue::zero(),
                ),
                AggregateSignature::empty(), // Invalid signatures
            );
            
            Ok(BatchResponse::NotFound(invalid_ledger_info))
        }
        // ... other methods ...
    }
    
    let batch_requester = BatchRequester::new(
        epoch,
        my_peer_id,
        3, // request_num_peers
        retry_limit,
        100, // retry_interval_ms
        1000, // rpc_timeout_ms
        MaliciousNetworkSender,
        validator_verifier,
    );
    
    let digest = HashValue::random();
    let expiration = 1000;
    let responders = Arc::new(Mutex::new(BTreeSet::from([
        PeerId::random(),
        PeerId::random(),
        PeerId::random(),
    ])));
    let (_tx, rx) = oneshot::channel();
    
    let start = std::time::Instant::now();
    
    // Attack: Request batch, should waste CPU on signature verification
    let result = batch_requester.request_batch(digest, expiration, responders, rx).await;
    
    let elapsed = start.elapsed();
    
    // Verify: Node wasted time on invalid responses without detecting malicious peer
    assert!(result.is_err()); // Eventually times out
    assert!(elapsed.as_millis() > retry_limit as u128 * 100); // Wasted retry_limit * retry_interval
    
    // Security Issue: No way to identify which peer sent invalid responses
    // No logging of invalid signatures
    // No peer reputation penalty applied
}
```

## Notes

The vulnerability is exacerbated by the lack of peer reputation tracking in the quorum store batch retrieval protocol. While state-sync has a peer scoring system [6](#0-5) , the batch requester has no equivalent mechanism, making it impossible to identify and avoid malicious responders systematically.

### Citations

**File:** consensus/src/network.rs (L577-583)
```rust
            ConsensusMsg::BatchResponseV2(maybe_batch) => {
                if let BatchResponse::Batch(batch) = maybe_batch.as_ref() {
                    batch.verify_with_digest(request_digest)?;
                }
                // Note BatchResponse::NotFound(ledger_info) is verified later with a ValidatorVerifier
                Ok(*maybe_batch)
            },
```

**File:** consensus/src/quorum_store/batch_requester.rs (L23-64)
```rust
struct BatchRequesterState {
    signers: Arc<Mutex<BTreeSet<PeerId>>>,
    next_index: usize,
    num_retries: usize,
    retry_limit: usize,
}

impl BatchRequesterState {
    fn new(signers: Arc<Mutex<BTreeSet<PeerId>>>, retry_limit: usize) -> Self {
        Self {
            signers,
            next_index: 0,
            num_retries: 0,
            retry_limit,
        }
    }

    fn next_request_peers(&mut self, num_peers: usize) -> Option<Vec<PeerId>> {
        let signers = self.signers.lock();
        if self.num_retries == 0 {
            let mut rng = rand::thread_rng();
            // make sure nodes request from the different set of nodes
            self.next_index = rng.r#gen::<usize>() % signers.len();
            counters::SENT_BATCH_REQUEST_COUNT.inc_by(num_peers as u64);
        } else {
            counters::SENT_BATCH_REQUEST_RETRY_COUNT.inc_by(num_peers as u64);
        }
        if self.num_retries < self.retry_limit {
            self.num_retries += 1;
            let ret = signers
                .iter()
                .cycle()
                .skip(self.next_index)
                .take(num_peers)
                .cloned()
                .collect();
            self.next_index = (self.next_index + num_peers) % signers.len();
            Some(ret)
        } else {
            None
        }
    }
```

**File:** consensus/src/quorum_store/batch_requester.rs (L142-152)
```rust
                            Ok(BatchResponse::NotFound(ledger_info)) => {
                                counters::RECEIVED_BATCH_NOT_FOUND_COUNT.inc();
                                if ledger_info.commit_info().epoch() == epoch
                                    && ledger_info.commit_info().timestamp_usecs() > expiration
                                    && ledger_info.verify_signatures(&validator_verifier).is_ok()
                                {
                                    counters::RECEIVED_BATCH_EXPIRED_COUNT.inc();
                                    debug!("QS: batch request expired, digest:{}", digest);
                                    return Err(ExecutorError::CouldNotGetData);
                                }
                            }
```

**File:** consensus/src/quorum_store/batch_requester.rs (L156-159)
```rust
                            Err(e) => {
                                counters::RECEIVED_BATCH_RESPONSE_ERROR_COUNT.inc();
                                debug!("QS: batch request error, digest:{}, error:{:?}", digest, e);
                            }
```

**File:** types/src/ledger_info.rs (L303-308)
```rust
    pub fn verify_signatures(
        &self,
        validator: &ValidatorVerifier,
    ) -> ::std::result::Result<(), VerifyError> {
        validator.verify_multi_signatures(self.ledger_info(), &self.signatures)
    }
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L1-50)
```rust
// Copyright (c) Aptos Foundation
// Licensed pursuant to the Innovation-Enabling Source Code License, available at https://github.com/aptos-labs/aptos-core/blob/main/LICENSE

use crate::{
    global_summary::{AdvertisedData, GlobalDataSummary, OptimalChunkSizes},
    interface::ResponseError,
    logging::{LogEntry, LogEvent, LogSchema},
    metrics,
};
use aptos_config::{
    config::AptosDataClientConfig,
    network_id::{NetworkId, PeerNetworkId},
};
use aptos_logger::prelude::*;
use aptos_storage_service_types::{
    requests::StorageServiceRequest, responses::StorageServerSummary,
};
use aptos_time_service::TimeService;
use dashmap::DashMap;
use std::{
    cmp::min,
    collections::{BTreeMap, HashSet},
    sync::Arc,
    time::Duration,
};

// Useful constants
const LOGS_FREQUENCY_SECS: u64 = 120; // 2 minutes
const METRICS_FREQUENCY_SECS: u64 = 15; // 15 seconds
const NUM_PEER_BUCKETS_FOR_METRICS: u8 = 4; // To avoid metric explosion, we bucket peers into groups

/// Scores for peer rankings based on preferences and behavior.
const MAX_SCORE: f64 = 100.0;
const MIN_SCORE: f64 = 0.0;
const STARTING_SCORE: f64 = 50.0;
/// Add this score on a successful response.
const SUCCESSFUL_RESPONSE_DELTA: f64 = 1.0;
/// Not necessarily a malicious response, but not super useful.
const NOT_USEFUL_MULTIPLIER: f64 = 0.95;
/// Likely to be a malicious response.
const MALICIOUS_MULTIPLIER: f64 = 0.8;
/// Ignore a peer when their score dips below this threshold.
const IGNORE_PEER_THRESHOLD: f64 = 25.0;

pub enum ErrorType {
    /// A response or error that's not actively malicious but also doesn't help
    /// us make progress, e.g., timeouts, remote errors, invalid data, etc...
    NotUseful,
    /// A response or error that appears to be actively hindering progress or
    /// attempting to deceive us, e.g., invalid proof.
```
