# Audit Report

## Title
Chain ID Spoofing via Genesis File Manipulation Bypasses Mandatory Mainnet Storage Safety Requirements

## Summary
A mainnet validator operator can bypass mandatory storage configuration safety checks by replacing the `genesis.blob` file with a crafted version containing a non-mainnet chain_id. For already-bootstrapped nodes, this causes `StorageConfig::optimize()` to skip critical mainnet-specific safety requirements (including mandatory storage sharding enforcement per AIP-97) while the node continues operating on mainnet using the chain_id stored in on-chain state.

## Finding Description

The Aptos node configuration loading process extracts the chain_id from the genesis transaction file to apply network-specific optimizations during startup. However, this process has a critical vulnerability:

1. **Unverified Genesis Loading**: The genesis transaction is loaded from disk and the chain_id is extracted without any integrity verification during config optimization: [1](#0-0) 

2. **Chain ID Extraction for Optimization**: The extracted chain_id is used to determine which network-specific optimizations to apply: [2](#0-1) 

3. **Critical Safety Checks Depend on Unverified Chain ID**: `StorageConfig::optimize()` uses this unverified chain_id to enforce mandatory mainnet/testnet requirements: [3](#0-2) 

The critical issue is at lines 664-668: if chain_id is NOT mainnet/testnet AND storage sharding is not explicitly enabled, the node will panic. However, if an attacker provides a fake genesis with chain_id=99, this check is bypassed entirely.

4. **Waypoint Verification Skipped for Bootstrapped Nodes**: For already-running validators, the waypoint verification that would catch a tampered genesis file is skipped because the database is already initialized: [4](#0-3) 

At line 56-58, if the database already has data, the function returns early without verifying the waypoint, allowing the node to start with the unsafe configuration.

5. **Runtime Chain ID from On-Chain State**: During actual operation, the node reads the chain_id from on-chain state (not from genesis.blob), so it continues processing mainnet transactions: [5](#0-4) 

**Attack Path:**
1. Mainnet validator operator crafts a fake `genesis.blob` with chain_id=99 (or any non-mainnet/testnet value)
2. Replaces the genesis file at the path specified by `execution.genesis_file_location`
3. Restarts the validator node
4. Config optimizer reads fake chain_id=99, skips mainnet safety checks (no panic, no rlimit enforcement)
5. Database bootstrap skips waypoint verification (DB already initialized)
6. Node starts successfully with unsafe configuration
7. Runtime uses correct mainnet chain_id from on-chain state, processes mainnet blocks normally
8. Validator operates on mainnet WITHOUT mandatory storage sharding or other safety requirements

## Impact Explanation

This vulnerability merits **High Severity** under the Aptos bug bounty program criteria:

**Primary Impact - Mandatory Safety Requirement Bypass:**
The storage sharding check (lines 664-668) explicitly enforces AIP-97 requirements for mainnet/testnet. The panic message references the official migration guide, indicating this is a hard requirement. Bypassing this allows validators to run with deprecated storage configurations that:
- May lead to database corruption under high load
- Could cause state divergence between validators
- Violates production deployment requirements

**Secondary Impacts:**
- `ensure_rlimit_nofile` not set to 999,999, risking file descriptor exhaustion
- `compute_root_hash` for hot state may be incorrectly configured, potentially causing state inconsistencies

**Why Not Critical:**
- Requires node operator file system access (not fully unprivileged)
- Affects single validator, not network-wide consensus
- No direct fund loss or theft
- Doesn't cause immediate consensus safety violation

**Why High (not Medium):**
- Bypasses explicit mandatory safety checks with panic enforcement
- Could lead to validator performance degradation or failures
- Violates documented production requirements (AIP-97)
- Affects network health and reliability

## Likelihood Explanation

**Likelihood: Medium to High**

**Attacker Requirements:**
- Access to validator node filesystem to modify `genesis.blob`
- Node operator level access or compromised validator infrastructure
- Already-bootstrapped validator database (common for operational validators)

**Ease of Exploitation:**
- Simple file replacement, no complex exploit chain
- No cryptographic bypass needed
- Works on every node restart after file modification
- No timing requirements or race conditions

**Likelihood Modifiers:**
- Most mainnet validators are already bootstrapped (high prevalence)
- Genesis file location is documented in config
- Node operators may not monitor genesis file integrity
- Some operators might intentionally use this to bypass sharding requirements

**Detection Difficulty:**
- Modified genesis.blob may go unnoticed without integrity monitoring
- Node logs would show chain_id extraction but not verification failure
- Configuration appears normal from external observation

## Recommendation

**Immediate Fix:**
Implement integrity verification of the genesis transaction against a known-good waypoint or hash before using it for configuration optimization. The genesis waypoint should be verified even when the database is already bootstrapped.

**Recommended Code Changes:**

In `config/src/config/node_config_loader.rs`, modify `get_chain_id()` to verify genesis integrity:

```rust
fn get_chain_id(node_config: &NodeConfig) -> Result<ChainId, Error> {
    let genesis_txn = get_genesis_txn(node_config).ok_or_else(|| {
        Error::InvariantViolation("The genesis transaction was not found!".to_string())
    })?;
    
    // NEW: Verify genesis against known waypoint before trusting it
    let expected_waypoint = node_config
        .execution
        .genesis_waypoint
        .as_ref()
        .unwrap_or(&node_config.base.waypoint)
        .genesis_waypoint();
    
    // Calculate waypoint from genesis transaction
    let calculated_waypoint = calculate_genesis_waypoint(genesis_txn)?;
    
    if calculated_waypoint != expected_waypoint {
        return Err(Error::InvariantViolation(format!(
            "Genesis transaction verification failed! Calculated waypoint {:?} does not match expected {:?}. \
            This may indicate genesis file tampering.",
            calculated_waypoint, expected_waypoint
        )));
    }
    
    // Extract chain ID from verified genesis
    match genesis_txn {
        Transaction::GenesisTransaction(WriteSetPayload::Direct(change_set)) => {
            // ... existing extraction logic ...
        }
        // ... rest of existing code ...
    }
}
```

**Additional Hardening:**
1. Add file integrity monitoring for `genesis.blob`
2. Log genesis waypoint verification results during config loading
3. Consider requiring explicit config flag to allow non-mainnet/testnet chain IDs in production builds
4. Add startup warning if genesis file modification time is recent

## Proof of Concept

```rust
// PoC: Demonstrating the vulnerability
// Place in config/src/config/tests/chain_id_spoofing_test.rs

#[cfg(test)]
mod chain_id_spoofing_poc {
    use super::*;
    use aptos_temppath::TempPath;
    use aptos_types::{
        chain_id::ChainId,
        transaction::{ChangeSet, Transaction, WriteSetPayload},
        write_set::WriteSetMut,
        on_chain_config::OnChainConfig,
        state_store::state_key::StateKey,
    };
    
    #[test]
    fn test_chain_id_spoofing_bypasses_mainnet_checks() {
        // Setup: Create a fake genesis with chain_id = 99
        let fake_chain_id = ChainId::new(99);
        let chain_id_state_key = StateKey::on_chain_config::<ChainId>().unwrap();
        
        // Create fake genesis transaction with wrong chain_id
        let mut write_set_mut = WriteSetMut::new(vec![]);
        let chain_id_bytes = bcs::to_bytes(&fake_chain_id).unwrap();
        write_set_mut.insert((
            chain_id_state_key,
            bcs::to_bytes(&chain_id_bytes).unwrap(),
        ));
        
        let fake_genesis = Transaction::GenesisTransaction(
            WriteSetPayload::Direct(ChangeSet::new(
                write_set_mut.freeze().unwrap(),
                vec![],
            ))
        );
        
        // Setup node config with fake genesis
        let temp_dir = TempPath::new();
        temp_dir.create_as_dir().unwrap();
        
        let mut node_config = NodeConfig::default();
        node_config.execution.genesis = Some(fake_genesis);
        node_config.set_data_dir(temp_dir.path().to_path_buf());
        
        // Create config yaml WITHOUT explicit storage sharding enabled
        let yaml = serde_yaml::from_str(
            r#"
            storage:
              # Note: enable_storage_sharding NOT set to true
            "#,
        ).unwrap();
        
        // VULNERABLE: This should panic for mainnet, but doesn't because
        // chain_id=99 bypasses the is_mainnet()/is_testnet() checks
        let result = StorageConfig::optimize(
            &mut node_config,
            &yaml,
            NodeType::Validator,
            Some(fake_chain_id),  // Using fake chain_id from unverified genesis
        );
        
        // Attack succeeds: No panic occurred, mainnet safety checks bypassed
        assert!(result.is_ok(), "Optimization should succeed with fake chain_id");
        
        // Verify the unsafe configuration was applied
        assert_eq!(node_config.storage.ensure_rlimit_nofile, 0, 
                   "ensure_rlimit_nofile should remain at default (not 999999)");
        
        // The critical storage sharding panic was bypassed!
        // In production, this node would run without mandatory AIP-97 compliance
    }
    
    #[test] 
    fn test_mainnet_chain_id_enforces_sharding() {
        // Control test: Real mainnet chain_id SHOULD panic without sharding
        let mut node_config = NodeConfig::default();
        let yaml = serde_yaml::from_str(r#"storage: {}"#).unwrap();
        
        let result = std::panic::catch_unwind(|| {
            StorageConfig::optimize(
                &mut node_config,
                &yaml,
                NodeType::Validator,
                Some(ChainId::mainnet()),  // Real mainnet chain_id
            )
        });
        
        // Should panic because storage sharding not enabled for mainnet
        assert!(result.is_err(), "Should panic for mainnet without sharding");
    }
}
```

**Reproduction Steps:**
1. Setup a mainnet validator with bootstrapped database
2. Create fake genesis.blob: 
   ```bash
   # Generate fake genesis with chain_id=99
   aptos-genesis set-chain-id --chain-id 99 --output fake_genesis.blob
   ```
3. Replace real genesis: `cp fake_genesis.blob /path/to/genesis.blob`
4. Restart validator node
5. Observe: Node starts successfully, no panic despite missing storage sharding
6. Verify: Check `node_config.storage.ensure_rlimit_nofile == 0` instead of 999999
7. Impact: Mainnet validator running without AIP-97 compliance

### Citations

**File:** config/src/config/execution_config.rs (L100-140)
```rust
    pub fn load_from_path(&mut self, root_dir: &RootPath) -> Result<(), Error> {
        if !self.genesis_file_location.as_os_str().is_empty() {
            // Ensure the genesis file exists
            let genesis_path = root_dir.full_path(&self.genesis_file_location);
            if !genesis_path.exists() {
                return Err(Error::Unexpected(format!(
                    "The genesis file could not be found! Ensure the given path is correct: {:?}",
                    genesis_path.display()
                )));
            }

            // Open the genesis file and read the bytes
            let mut file = File::open(&genesis_path).map_err(|error| {
                Error::Unexpected(format!(
                    "Failed to open the genesis file: {:?}. Error: {:?}",
                    genesis_path.display(),
                    error
                ))
            })?;
            let mut buffer = vec![];
            file.read_to_end(&mut buffer).map_err(|error| {
                Error::Unexpected(format!(
                    "Failed to read the genesis file into a buffer: {:?}. Error: {:?}",
                    genesis_path.display(),
                    error
                ))
            })?;

            // Deserialize the genesis file and store it
            let genesis = bcs::from_bytes(&buffer).map_err(|error| {
                Error::Unexpected(format!(
                    "Failed to BCS deserialize the genesis file: {:?}. Error: {:?}",
                    genesis_path.display(),
                    error
                ))
            })?;
            self.genesis = Some(genesis);
        }

        Ok(())
    }
```

**File:** config/src/config/node_config_loader.rs (L158-198)
```rust
fn get_chain_id(node_config: &NodeConfig) -> Result<ChainId, Error> {
    // TODO: can we make this less hacky?

    // Load the genesis transaction from disk
    let genesis_txn = get_genesis_txn(node_config).ok_or_else(|| {
        Error::InvariantViolation("The genesis transaction was not found!".to_string())
    })?;

    // Extract the chain ID from the genesis transaction
    match genesis_txn {
        Transaction::GenesisTransaction(WriteSetPayload::Direct(change_set)) => {
            let chain_id_state_key = StateKey::on_chain_config::<ChainId>()?;

            // Get the write op from the write set
            let write_set_mut = change_set.clone().write_set().clone().into_mut();
            let write_op = write_set_mut.get(&chain_id_state_key).ok_or_else(|| {
                Error::InvariantViolation(
                    "The genesis transaction does not contain the write op for the chain id!"
                        .into(),
                )
            })?;

            // Extract the chain ID from the write op
            let write_op_bytes = write_op.bytes().ok_or_else(|| Error::InvariantViolation(
                "The genesis transaction does not contain the correct write op for the chain ID!".into(),
            ))?;
            let chain_id = ChainId::deserialize_into_config(write_op_bytes).map_err(|error| {
                Error::InvariantViolation(format!(
                    "Failed to deserialize the chain ID: {:?}",
                    error
                ))
            })?;

            Ok(chain_id)
        },
        _ => Err(Error::InvariantViolation(format!(
            "The genesis transaction has the incorrect type: {:?}!",
            genesis_txn
        ))),
    }
}
```

**File:** config/src/config/storage_config.rs (L653-676)
```rust
        if let Some(chain_id) = chain_id {
            if (chain_id.is_testnet() || chain_id.is_mainnet())
                && config_yaml["ensure_rlimit_nofile"].is_null()
            {
                config.ensure_rlimit_nofile = 999_999;
                modified_config = true;
            }
            if chain_id.is_testnet() && config_yaml["assert_rlimit_nofile"].is_null() {
                config.assert_rlimit_nofile = true;
                modified_config = true;
            }
            if (chain_id.is_testnet() || chain_id.is_mainnet())
                && config_yaml["rocksdb_configs"]["enable_storage_sharding"].as_bool() != Some(true)
            {
                panic!("Storage sharding (AIP-97) is not enabled in node config. Please follow the guide to migration your node, and set storage.rocksdb_configs.enable_storage_sharding to true explicitly in your node config. https://aptoslabs.notion.site/DB-Sharding-Migration-Public-Full-Nodes-1978b846eb7280b29f17ceee7d480730");
            }
            // TODO(HotState): Hot state root hash computation is off by default in Mainnet unless
            // explicitly enabled.
            if chain_id.is_mainnet()
                && config_yaml["hot_state_config"]["compute_root_hash"].as_bool() != Some(true)
            {
                config.hot_state_config.compute_root_hash = false;
            }
        }
```

**File:** execution/executor/src/db_bootstrapper/mod.rs (L48-71)
```rust
pub fn maybe_bootstrap<V: VMBlockExecutor>(
    db: &DbReaderWriter,
    genesis_txn: &Transaction,
    waypoint: Waypoint,
) -> Result<Option<LedgerInfoWithSignatures>> {
    let ledger_summary = db.reader.get_pre_committed_ledger_summary()?;
    // if the waypoint is not targeted with the genesis txn, it may be either already bootstrapped, or
    // aiming for state sync to catch up.
    if ledger_summary.version().map_or(0, |v| v + 1) != waypoint.version() {
        info!(waypoint = %waypoint, "Skip genesis txn.");
        return Ok(None);
    }

    let committer = calculate_genesis::<V>(db, ledger_summary, genesis_txn)?;
    ensure!(
        waypoint == committer.waypoint(),
        "Waypoint verification failed. Expected {:?}, got {:?}.",
        waypoint,
        committer.waypoint(),
    );
    let ledger_info = committer.output.ledger_info_opt.clone();
    committer.commit()?;
    Ok(ledger_info)
}
```

**File:** aptos-node/src/utils.rs (L42-50)
```rust
pub fn fetch_chain_id(db: &DbReaderWriter) -> anyhow::Result<ChainId> {
    let db_state_view = db
        .reader
        .latest_state_checkpoint_view()
        .map_err(|err| anyhow!("[aptos-node] failed to create db state view {}", err))?;
    Ok(ChainIdResource::fetch_config(&db_state_view)
        .expect("[aptos-node] missing chain ID resource")
        .chain_id())
}
```
