# Audit Report

## Title
Gas Charging Bypass in Module Publishing via Invalid Bytecode Deserialization

## Summary
The `native_request_publish()` function charges only minimal gas (CODE_REQUEST_PUBLISH_BASE + 7 gas/byte) before module deserialization occurs. If an attacker submits invalid bytecode, deserialization fails after consuming validator resources, but the additional dependency gas charges (74460 + 42 gas/byte) are never applied. This allows attackers to cause expensive computational work while paying only ~14% of the intended gas cost, enabling validator resource exhaustion attacks.

## Finding Description

The gas charging for module publishing is split across two phases:

**Phase 1 - Native Function Gas Charging:** [1](#0-0) 

At this point, only 1838 + 7*bytecode_size gas units are charged.

**Phase 2 - Module Deserialization (Expensive Operation):** [2](#0-1) 

The deserialization calls `CompiledModule::deserialize_with_config()` which performs extensive parsing, validation, and data structure construction: [3](#0-2) 

If deserialization fails, the function returns immediately with `CODE_DESERIALIZATION_ERROR`.

**Phase 3 - Additional Dependency Gas Charging (Never Reached on Failure):** [4](#0-3) 

This charges an additional 74460 + 42*bytecode_size gas per module, but only if deserialization succeeds.

The gas parameters show this discrepancy: [5](#0-4) [6](#0-5) 

**Attack Scenario:**
1. Attacker generates 1MB of invalid bytecode (random bytes or subtly malformed data)
2. Calls `publish_package_txn()` with this bytecode
3. Native function charges: 1838 + 7*1,000,000 = 7,001,838 gas
4. Deserialization at line 1491 attempts to parse the invalid bytecode (expensive CPU work)
5. Deserialization fails, transaction aborts
6. Dependency gas charges (74460 + 42*1,000,000 = 42,074,460) are never applied
7. **Total paid: 7,001,838 gas (~14% of intended 49,076,298 gas)**

This breaks **Invariant #9** (Resource Limits) and **Invariant #3** (Move VM Safety - gas limits must be respected).

## Impact Explanation

**Severity: HIGH** per Aptos bug bounty criteria - "Validator node slowdowns"

An attacker can exploit this to exhaust validator computational resources:
- Cost per attack transaction: ~7M gas (~$0.07 at 1 gas = 100 octas, 1 APT = $10)
- Validator work: Deserialize 1MB of invalid bytecode (should cost ~49M gas)
- Cost multiplier: 7x reduction (86% savings)

**Resource Exhaustion Attack:**
- Attacker submits 100 transactions with 1MB invalid bytecode each
- Attacker cost: ~700M gas (~$70)
- Validator work: Deserialize 100MB (should cost ~4.9B gas or ~$490)
- Amplification: 7x cost savings for the attacker

This allows attackers to degrade validator performance and potentially cause denial-of-service conditions by flooding the network with under-priced computation.

## Likelihood Explanation

**Likelihood: HIGH**

- **No special privileges required**: Any user can call `publish_package_txn()`
- **Easy to exploit**: Simply submit random bytes as "bytecode"
- **Difficult to detect**: Appears as legitimate failed publish attempts
- **No rate limiting**: Can submit multiple transactions per block
- **Profitable for attackers**: Validator resource exhaustion at 14% of intended cost

The Move VM's type checking passes because the bytecode parameter has the correct type (`vector<vector<u8>>`). The invalidity is only discovered during deserialization, after minimal gas has been charged.

## Recommendation

**Solution: Charge dependency gas BEFORE deserialization, not after**

Restructure `resolve_pending_code_publish_and_finish_user_session()` to charge gas based on bytecode size before attempting deserialization:

```rust
fn resolve_pending_code_publish_and_finish_user_session(
    // ... parameters ...
) -> Result<UserSessionChangeSet, VMStatus> {
    let maybe_publish_request = session.execute(|session| session.extract_publish_request());
    if maybe_publish_request.is_none() {
        // ... existing code ...
    }

    let PublishRequest { destination, bundle, expected_modules, allowed_deps, check_compat: _ } = 
        maybe_publish_request.expect("Publish request exists");

    // **FIX: Charge gas for bundle size BEFORE deserialization**
    if self.gas_feature_version() >= RELEASE_V1_10 {
        for blob in bundle.iter() {
            gas_meter.charge_dependency(
                DependencyKind::New,
                &destination,
                ident_str!(""),  // name unknown before deserialization
                NumBytes::new(blob.code().len() as u64),
            ).map_err(|err| err.finish(Location::Undefined))?;
        }
    }

    // Now deserialize (attacker has already paid full gas)
    let modules = self.deserialize_module_bundle(&bundle)?;
    
    // ... rest of function ...
}
```

Alternatively, increase `CODE_REQUEST_PUBLISH_PER_BYTE` from 7 to at least 49 to cover the full deserialization cost in the native function.

## Proof of Concept

```move
// File: test_gas_bypass.move
module test_addr::gas_bypass_poc {
    use std::vector;
    use aptos_framework::code;
    use aptos_framework::account;

    /// Demonstrates gas charging bypass with invalid bytecode
    public entry fun exploit_gas_bypass(attacker: &signer) {
        // Create 1MB of invalid bytecode (random bytes)
        let invalid_bytecode = vector::empty<u8>();
        let i = 0;
        while (i < 1000000) {
            vector::push_back(&mut invalid_bytecode, (i % 256) as u8);
            i = i + 1;
        };

        // Wrap in vector<vector<u8>> for publish_package_txn
        let code_vec = vector::empty<vector<u8>>();
        vector::push_back(&mut code_vec, invalid_bytecode);

        // Create minimal metadata (will be deserialized but irrelevant)
        let metadata = vector::empty<u8>();
        
        // This call will:
        // 1. Charge ~7M gas in native function
        // 2. Attempt deserialization (expensive)
        // 3. Fail with CODE_DESERIALIZATION_ERROR
        // 4. Never charge the additional ~42M dependency gas
        code::publish_package_txn(attacker, metadata, code_vec);
        // Transaction aborts but attacker paid only 14% of intended cost
    }
}
```

**Expected Result:**
- Transaction fails with `CODE_DESERIALIZATION_ERROR`
- Gas consumed: ~7,001,838 units
- Expected gas for valid 1MB module: ~49,076,298 units
- Attacker savings: ~42,074,460 units (86%)

**Notes**

The vulnerability exists because gas charging is split across two locations with expensive deserialization occurring between them. The per-byte charge in the native function (7 gas/byte) was likely intended as a lightweight pre-charge, with the full dependency charge (42 gas/byte) applied later. However, if deserialization fails, the later charge never occurs, creating a gas bypass opportunity.

This pattern violates the principle that expensive operations should only occur AFTER adequate gas has been charged. The fix should either front-load all gas charging before deserialization, or make deserialization fast-fail for obviously invalid inputs before doing expensive parsing work.

### Citations

**File:** aptos-move/framework/src/natives/code.rs (L292-300)
```rust
    context.charge(CODE_REQUEST_PUBLISH_BASE)?;

    let policy = safely_pop_arg!(args, u8);
    let mut code = vec![];
    for module in safely_pop_arg!(args, Vec<Value>) {
        let module_code = module.value_as::<Vec<u8>>()?;

        context.charge(CODE_REQUEST_PUBLISH_PER_BYTE * NumBytes::new(module_code.len() as u64))?;
        code.push(module_code);
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1447-1457)
```rust
            match CompiledModule::deserialize_with_config(
                module_blob.code(),
                self.deserializer_config(),
            ) {
                Ok(module) => {
                    result.push(module);
                },
                Err(_err) => {
                    return Err(PartialVMError::new(StatusCode::CODE_DESERIALIZATION_ERROR)
                        .finish(Location::Undefined))
                },
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1491-1491)
```rust
        let modules = self.deserialize_module_bundle(&bundle)?;
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1526-1536)
```rust
            for (module, blob) in modules.iter().zip(bundle.iter()) {
                let addr = module.self_addr();
                let name = module.self_name();
                gas_meter
                    .charge_dependency(
                        DependencyKind::New,
                        addr,
                        name,
                        NumBytes::new(blob.code().len() as u64),
                    )
                    .map_err(|err| err.finish(Location::Undefined))?;
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/aptos_framework.rs (L320-321)
```rust
        [code_request_publish_base: InternalGas, "code.request_publish.base", 1838],
        [code_request_publish_per_byte: InternalGasPerByte, "code.request_publish.per_byte", 7],
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L241-248)
```rust
            dependency_per_module: InternalGas,
            { RELEASE_V1_10.. => "dependency_per_module" },
            74460,
        ],
        [
            dependency_per_byte: InternalGasPerByte,
            { RELEASE_V1_10.. => "dependency_per_byte" },
            42,
```
