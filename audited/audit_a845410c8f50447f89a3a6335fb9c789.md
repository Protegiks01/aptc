# Audit Report

## Title
Missing Validation of DKG Randomness Thresholds in Genesis Configuration Enables Cryptographic Security Bypass

## Summary
The `randomness_config_override` field in `GenesisInfo` accepts arbitrary DKG threshold values without validation, allowing weak parameters (e.g., 1% secrecy threshold) that violate the security requirements of threshold cryptography and enable small validator coalitions to compromise the randomness generation protocol.

## Finding Description

The genesis configuration system lacks validation for randomness DKG (Distributed Key Generation) threshold parameters, breaking the cryptographic correctness invariant required for secure randomness generation.

**Vulnerability Chain:**

1. **No Genesis Validation**: The `validate_genesis_config()` function does not validate `randomness_config_override` thresholds [1](#0-0) 

2. **No Move-Level Validation**: The Move module's `initialize()` and `new_v1()`/`new_v2()` functions accept any threshold values without bounds checking [2](#0-1) 

3. **Validation Bypass via Fallback**: While `DKGRounding::new()` contains security validations requiring `secrecy_threshold > 1/3` and `reconstruction_threshold <= 2/3`, when these checks fail, the code falls back to the `infallible()` method [3](#0-2) 

4. **Infallible Accepts Dangerous Values**: The `infallible()` method only clamps values to `min(1, value)` and ensures `reconstruction >= secrecy`, but does NOT enforce the security requirements [4](#0-3) 

**Security Invariant Broken:**

The DKG protocol requires `secrecy_threshold > 1/3` to prevent Byzantine coalitions from breaking threshold cryptography [5](#0-4) 

**Attack Scenario:**

An operator setting up a private Aptos network (or through accidental misconfiguration) sets:
- `secrecy_threshold = 0.01` (1%)  
- `reconstruction_threshold = 0.99` (99%)

This configuration passes through genesis unchecked [6](#0-5) , gets stored on-chain [7](#0-6) , and when DKG runs, the infallible fallback accepts these dangerous parameters.

Result: Any validator coalition controlling >1% stake can potentially reconstruct DKG secrets meant to require >33% stake, breaking the Byzantine fault tolerance assumption and enabling randomness prediction/manipulation.

## Impact Explanation

**Critical Severity** - This vulnerability enables consensus manipulation through cryptographic security bypass:

1. **Randomness Predictability**: Validators with minimal stake (>1%) can reconstruct randomness secrets, enabling front-running of randomness-dependent smart contracts and validator transaction manipulation

2. **DKG Security Compromise**: The threshold cryptography security model is fundamentally broken, allowing small coalitions to break assumptions that should require >33% Byzantine actors

3. **Consensus Integrity**: While randomness is optional in blocks, compromised randomness affects validator transaction ordering, DKG transcript validation [8](#0-7) , and can cause state divergence in randomness-dependent applications

This meets the "Consensus/Safety violations" criterion for Critical severity in the Aptos bug bounty program.

## Likelihood Explanation

**Likelihood: Medium-High for Private Networks, Low for Mainnet**

**Requirements:**
- Control over genesis configuration during network setup
- For mainnet: Requires insider threat (trusted Aptos core team)
- For private/test networks: Any operator setting up the network

**Realistic Scenarios:**
1. Accidental misconfiguration by operators unfamiliar with DKG security requirements
2. Intentional weakening of private network security for testing that persists to production
3. Malicious insider during mainnet genesis (low probability but catastrophic impact)
4. "Honeypot" private networks set up with weak parameters to exploit users

The lack of ANY validation makes accidental triggering highly plausible.

## Recommendation

Add validation for randomness threshold parameters at multiple layers:

**1. Genesis Validation Layer:**
```rust
fn validate_genesis_config(genesis_config: &GenesisConfiguration) {
    // ... existing validations ...
    
    // Validate randomness config if present
    if let Some(ref randomness_config) = genesis_config.randomness_config_override {
        validate_randomness_config(randomness_config);
    }
}

fn validate_randomness_config(config: &OnChainRandomnessConfig) {
    match config {
        OnChainRandomnessConfig::Off => {},
        OnChainRandomnessConfig::V1(v1) => {
            validate_thresholds(
                v1.secrecy_threshold.as_u64f64(),
                v1.reconstruction_threshold.as_u64f64(),
            );
        },
        OnChainRandomnessConfig::V2(v2) => {
            validate_thresholds(
                v2.secrecy_threshold.as_u64f64(),
                v2.reconstruction_threshold.as_u64f64(),
            );
            // Validate fast path threshold
            assert!(
                v2.fast_path_secrecy_threshold.as_u64f64() >= v2.secrecy_threshold.as_u64f64(),
                "Fast path secrecy threshold must be >= secrecy threshold"
            );
        },
    }
}

fn validate_thresholds(secrecy: U64F64, reconstruction: U64F64) {
    let one_third = U64F64::from_num(1) / U64F64::from_num(3);
    let two_thirds = U64F64::from_num(2) / U64F64::from_num(3);
    
    assert!(
        secrecy > one_third,
        "Secrecy threshold must be > 1/3 (got {}), required for Byzantine fault tolerance",
        secrecy
    );
    assert!(
        reconstruction <= two_thirds,
        "Reconstruction threshold must be <= 2/3 (got {}), required for liveness",
        reconstruction
    );
    assert!(
        secrecy < reconstruction,
        "Secrecy threshold must be < reconstruction threshold"
    );
}
```

**2. Move-Level Validation:**

Add validation in `randomness_config.move`:
```move
public fun new_v1(secrecy_threshold: FixedPoint64, reconstruction_threshold: FixedPoint64): RandomnessConfig {
    // Validate thresholds
    assert!(
        fixed_point64::greater(secrecy_threshold, fixed_point64::create_from_rational(1, 3)),
        EINVALID_SECRECY_THRESHOLD
    );
    assert!(
        !fixed_point64::greater(reconstruction_threshold, fixed_point64::create_from_rational(2, 3)),
        EINVALID_RECONSTRUCTION_THRESHOLD
    );
    assert!(
        fixed_point64::less(secrecy_threshold, reconstruction_threshold),
        EINVALID_THRESHOLD_RELATIONSHIP
    );
    // ... existing code ...
}
```

**3. Remove Infallible Fallback or Make it Fail-Safe:**

Either remove the infallible fallback entirely, or make it reject dangerous configurations rather than accepting them.

## Proof of Concept

```rust
#[test]
fn test_weak_randomness_config_bypass() {
    use aptos_genesis::builder::Builder;
    use aptos_types::on_chain_config::OnChainRandomnessConfig;
    use fixed::types::U64F64;
    
    // Create genesis with dangerously weak randomness parameters
    let weak_config = OnChainRandomnessConfig::new_v1(
        1,   // 1% secrecy threshold - should be > 33%!
        99,  // 99% reconstruction threshold - should be <= 66%!
    );
    
    let mut builder = Builder::new(temp_dir.path(), framework)
        .with_init_genesis_config(Some(Arc::new(move |genesis_config| {
            genesis_config.randomness_config_override = Some(weak_config.clone());
        })));
    
    // This should FAIL but currently SUCCEEDS due to missing validation
    let (root_key, genesis_txn, waypoint) = builder.build(rand::thread_rng()).unwrap();
    
    // When DKG runs, it will use these dangerous parameters via infallible() fallback
    // A coalition with >1% stake can now reconstruct secrets meant to require >33%
    
    // Verify the weak config was accepted
    // (In production, this would enable consensus manipulation)
}
```

## Notes

This vulnerability exists at the intersection of genesis configuration, Move on-chain storage, and Rust DKG implementation. The defense-in-depth principle is violatedâ€”no layer validates these critical security parameters. While mainnet is protected by the trusted Aptos core team controlling genesis, private networks and potential future governance-based reconfiguration remain vulnerable. The `infallible()` fallback mechanism, designed for robustness, paradoxically enables security bypasses by accepting invalid configurations instead of failing safely.

### Citations

**File:** aptos-move/vm-genesis/src/lib.rs (L325-336)
```rust
    let randomness_config = genesis_config
        .randomness_config_override
        .clone()
        .unwrap_or_else(OnChainRandomnessConfig::default_for_genesis);
    initialize_randomness_api_v0_config(&mut session, &module_storage, &mut traversal_context);
    initialize_randomness_config_seqnum(&mut session, &module_storage, &mut traversal_context);
    initialize_randomness_config(
        &mut session,
        &module_storage,
        &mut traversal_context,
        randomness_config,
    );
```

**File:** aptos-move/vm-genesis/src/lib.rs (L405-439)
```rust
fn validate_genesis_config(genesis_config: &GenesisConfiguration) {
    assert!(
        genesis_config.min_stake <= genesis_config.max_stake,
        "Min stake must be smaller than or equal to max stake"
    );
    assert!(
        genesis_config.epoch_duration_secs > 0,
        "Epoch duration must be > 0"
    );
    assert!(
        genesis_config.recurring_lockup_duration_secs > 0,
        "Recurring lockup duration must be > 0"
    );
    assert!(
        genesis_config.recurring_lockup_duration_secs >= genesis_config.epoch_duration_secs,
        "Recurring lockup duration must be at least as long as epoch duration"
    );
    assert!(
        genesis_config.rewards_apy_percentage > 0 && genesis_config.rewards_apy_percentage < 100,
        "Rewards APY must be > 0% and < 100%"
    );
    assert!(
        genesis_config.voting_duration_secs > 0,
        "On-chain voting duration must be > 0"
    );
    assert!(
        genesis_config.voting_duration_secs < genesis_config.recurring_lockup_duration_secs,
        "Voting duration must be strictly smaller than recurring lockup"
    );
    assert!(
        genesis_config.voting_power_increase_limit > 0
            && genesis_config.voting_power_increase_limit <= 50,
        "voting_power_increase_limit must be > 0 and <= 50"
    );
}
```

**File:** aptos-move/framework/aptos-framework/sources/configs/randomness_config.move (L45-50)
```text
    public fun initialize(framework: &signer, config: RandomnessConfig) {
        system_addresses::assert_aptos_framework(framework);
        if (!exists<RandomnessConfig>(@aptos_framework)) {
            move_to(framework, config)
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/randomness_config.move (L93-115)
```text
    public fun new_v1(secrecy_threshold: FixedPoint64, reconstruction_threshold: FixedPoint64): RandomnessConfig {
        RandomnessConfig {
            variant: copyable_any::pack( ConfigV1 {
                secrecy_threshold,
                reconstruction_threshold
            } )
        }
    }

    /// Create a `ConfigV2` variant.
    public fun new_v2(
        secrecy_threshold: FixedPoint64,
        reconstruction_threshold: FixedPoint64,
        fast_path_secrecy_threshold: FixedPoint64,
    ): RandomnessConfig {
        RandomnessConfig {
            variant: copyable_any::pack( ConfigV2 {
                secrecy_threshold,
                reconstruction_threshold,
                fast_path_secrecy_threshold,
            } )
        }
    }
```

**File:** types/src/dkg/real_dkg/rounding/mod.rs (L79-96)
```rust
        let (profile, rounding_error, rounding_method) = match DKGRoundingProfile::new(
            validator_stakes,
            total_weight_min,
            total_weight_max,
            secrecy_threshold_in_stake_ratio,
            reconstruct_threshold_in_stake_ratio,
            fast_secrecy_threshold_in_stake_ratio,
        ) {
            Ok(profile) => (profile, None, "binary_search".to_string()),
            Err(e) => {
                let profile = DKGRoundingProfile::infallible(
                    validator_stakes,
                    secrecy_threshold_in_stake_ratio,
                    reconstruct_threshold_in_stake_ratio,
                    fast_secrecy_threshold_in_stake_ratio,
                );
                (profile, Some(format!("{e}")), "infallible".to_string())
            },
```

**File:** types/src/dkg/real_dkg/rounding/mod.rs (L197-199)
```rust
        ensure!(secrecy_threshold_in_stake_ratio * U64F64::from_num(3) > U64F64::from_num(1));
        ensure!(secrecy_threshold_in_stake_ratio < reconstruct_threshold_in_stake_ratio);
        ensure!(reconstruct_threshold_in_stake_ratio * U64F64::from_num(3) <= U64F64::from_num(2));
```

**File:** types/src/dkg/real_dkg/rounding/mod.rs (L254-282)
```rust
    pub fn infallible(
        validator_stakes: &Vec<u64>,
        mut secrecy_threshold_in_stake_ratio: U64F64,
        mut reconstruct_threshold_in_stake_ratio: U64F64,
        fast_secrecy_threshold_in_stake_ratio: Option<U64F64>,
    ) -> Self {
        let one = U64F64::from_num(1);
        secrecy_threshold_in_stake_ratio = min(one, secrecy_threshold_in_stake_ratio);
        reconstruct_threshold_in_stake_ratio = min(one, reconstruct_threshold_in_stake_ratio);
        reconstruct_threshold_in_stake_ratio = max(
            secrecy_threshold_in_stake_ratio,
            reconstruct_threshold_in_stake_ratio,
        );

        let stake_total = U64F64::from_num(validator_stakes.clone().into_iter().sum::<u64>());

        let estimated_weight_total = total_weight_upper_bound(
            validator_stakes,
            reconstruct_threshold_in_stake_ratio,
            secrecy_threshold_in_stake_ratio,
        );
        let stake_per_weight = stake_total / U64F64::from_num(estimated_weight_total);
        compute_profile_fixed_point(
            validator_stakes,
            stake_per_weight,
            secrecy_threshold_in_stake_ratio,
            fast_secrecy_threshold_in_stake_ratio,
        )
    }
```

**File:** types/src/dkg/real_dkg/mod.rs (L199-224)
```rust
    fn new_public_params(dkg_session_metadata: &DKGSessionMetadata) -> RealDKGPublicParams {
        let randomness_config = dkg_session_metadata
            .randomness_config_derived()
            .unwrap_or_else(OnChainRandomnessConfig::default_enabled);
        let secrecy_threshold = randomness_config
            .secrecy_threshold()
            .unwrap_or_else(|| *rounding::DEFAULT_SECRECY_THRESHOLD);
        let reconstruct_threshold = randomness_config
            .reconstruct_threshold()
            .unwrap_or_else(|| *rounding::DEFAULT_RECONSTRUCT_THRESHOLD);
        let maybe_fast_path_secrecy_threshold = randomness_config.fast_path_secrecy_threshold();

        let pvss_config = build_dkg_pvss_config(
            dkg_session_metadata.dealer_epoch,
            secrecy_threshold,
            reconstruct_threshold,
            maybe_fast_path_secrecy_threshold,
            &dkg_session_metadata.target_validator_consensus_infos_cloned(),
        );
        let verifier = ValidatorVerifier::new(dkg_session_metadata.dealer_consensus_infos_cloned());
        RealDKGPublicParams {
            session_metadata: dkg_session_metadata.clone(),
            pvss_config,
            verifier: verifier.into(),
        }
    }
```
