# Audit Report

## Title
Byzantine Peer Can Redirect State Sync to Invalid Targets via Unverified Advertised Ledger Info

## Summary
A Byzantine peer can advertise a forged `synced_ledger_info` with an arbitrarily high version in its `StorageServerSummary`, causing honest nodes to select this invalid ledger info as their state sync target without signature verification. This leads to resource exhaustion, sync stalling, and denial of service, though consensus divergence is prevented by downstream proof verification.

## Finding Description

The state sync system collects `synced_ledger_info` from all peers' advertised `StorageServerSummary` into a global `AdvertisedData` structure without verifying the cryptographic signatures. The vulnerability exists across three critical locations:

**1. No Verification When Collecting Advertised Data:** [1](#0-0) 

When building the global data summary, `synced_ledger_info` from each peer is directly pushed into `advertised_data.synced_ledger_infos` without calling `verify_signatures()`.

**2. Unverified Target Selection:** [2](#0-1) 

The `select_target_ledger_info()` function selects the ledger info with the highest version from `advertised_data.highest_synced_ledger_info()` and uses it as the sync target without signature verification. [3](#0-2) 

The `highest_synced_ledger_info()` method simply returns the ledger info with the maximum version without validation.

**3. Verification Happens Too Late:** [4](#0-3) 

Signature verification via `verify_proof_ledger_info()` only occurs when processing actual data payloads, after the invalid target has already been selected and data requests have been issued.

**Attack Scenario:**

1. Byzantine peer constructs a `StorageServerSummary` with a forged `synced_ledger_info` containing:
   - Extremely high version (e.g., version 100,000,000)
   - Invalid/forged BLS signatures
   - Potentially for a non-existent or forked chain

2. Honest node receives this summary via polling: [5](#0-4) 

3. The forged ledger info becomes the sync target: [6](#0-5) 

4. The node creates data requests for the invalid target version and wastes resources attempting to sync.

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos bug bounty program:

- **Validator Node Slowdowns**: Nodes waste CPU cycles, network bandwidth, and memory attempting to sync to invalid targets. Repeated selection of Byzantine targets significantly degrades node performance.

- **Significant Protocol Violations**: The fundamental assumption that state sync targets are cryptographically verified is violated. Nodes can be redirected to sync toward non-existent chain states.

- **Liveness Impact**: If multiple Byzantine peers coordinate to advertise fake high-version ledger infos, honest nodes may repeatedly select invalid targets and fail to make forward progress, effectively stalling state synchronization.

While this does NOT cause consensus divergence (proof verification catches invalid proofs before state commitment), it constitutes a denial-of-service attack on node availability and violates the critical invariant that state synchronization should only target verified, canonical chain states.

## Likelihood Explanation

**High Likelihood:**

- **Low Attack Complexity**: Any Byzantine peer can advertise forged storage summaries without requiring validator privileges or stake.

- **No Cryptographic Requirements**: The attacker doesn't need to forge valid BLS signatures for the attack to redirect sync targets; invalid signatures are sufficient to waste resources.

- **Amplification Potential**: A single Byzantine peer can advertise one fake ledger info that affects all honest nodes that poll it. Multiple colluding Byzantine peers can amplify the impact.

- **Persistent Effect**: The attack persists until peer scoring eventually marks the Byzantine peer as ignored, but during that window, significant resources are wasted. [7](#0-6) 

## Recommendation

**Immediate Fix: Verify Advertised Ledger Info Signatures**

Before including `synced_ledger_info` in the global advertised data, verify its cryptographic signatures against the current or a known validator set:

```rust
// In peer_states.rs::calculate_global_data_summary()
if let Some(synced_ledger_info) = summary.data_summary.synced_ledger_info.as_ref() {
    // Verify signatures before trusting this ledger info
    // Note: Need access to appropriate EpochState/ValidatorVerifier
    // This may require passing additional context or caching validator sets
    if is_ledger_info_trustworthy(synced_ledger_info, &trusted_epoch_states) {
        advertised_data
            .synced_ledger_infos
            .push(synced_ledger_info.clone());
    } else {
        // Penalize peer for advertising unverifiable ledger info
        peer_states.update_score_error(peer, ErrorType::Malicious);
    }
}
```

**Additional Hardening:**

1. **Sanity Check Advertised Versions**: Reject ledger infos with versions unreasonably far ahead of the local synced version (e.g., more than a configurable threshold).

2. **Cross-Validate Against Multiple Peers**: Require multiple peers to advertise similar high versions before selecting as target.

3. **Prioritize Verified Peers**: Give preference to ledger infos from peers with consistently valid responses.

## Proof of Concept

```rust
// Proof of Concept: Malicious peer advertising forged ledger info
// This would be integrated into the test framework

use aptos_types::ledger_info::{LedgerInfo, LedgerInfoWithSignatures};
use aptos_storage_service_types::responses::{StorageServerSummary, DataSummary};
use aptos_crypto::bls12381::Signature as BLSSignature;

#[test]
fn test_byzantine_peer_forged_ledger_info_redirect() {
    // 1. Create a forged ledger info with very high version
    let forged_version = 100_000_000_u64;
    let forged_ledger_info = LedgerInfo::new(
        BlockInfo::new(
            /* epoch */ 10,
            /* round */ 1000,
            /* id */ HashValue::random(),
            /* executed_state_id */ HashValue::random(),
            forged_version,
            /* timestamp */ 0,
            /* next_epoch_state */ None,
        ),
        HashValue::zero(),
    );
    
    // 2. Create invalid/empty signatures (Byzantine peer doesn't have valid keys)
    let invalid_signatures = AggregateSignature::empty();
    let forged_ledger_info_with_sigs = LedgerInfoWithSignatures::new(
        forged_ledger_info,
        invalid_signatures,
    );
    
    // 3. Byzantine peer advertises this in StorageServerSummary
    let malicious_summary = StorageServerSummary {
        protocol_metadata: ProtocolMetadata::default(),
        data_summary: DataSummary {
            synced_ledger_info: Some(forged_ledger_info_with_sigs.clone()),
            epoch_ending_ledger_infos: None,
            transactions: None,
            transaction_outputs: None,
            states: None,
        },
    };
    
    // 4. Update peer storage summary (currently no verification)
    data_client.update_peer_storage_summary(byzantine_peer, malicious_summary);
    
    // 5. Update global summary
    data_client.update_global_summary_cache().unwrap();
    
    // 6. Get global data summary
    let global_summary = data_client.get_global_data_summary();
    
    // 7. Verify the forged ledger info was accepted (VULNERABILITY)
    let highest_advertised = global_summary
        .advertised_data
        .highest_synced_ledger_info()
        .unwrap();
    
    assert_eq!(highest_advertised.ledger_info().version(), forged_version);
    // This demonstrates that unverified, forged ledger info is accepted
    // and would be selected as the sync target, causing resource waste
}
```

**Notes:**

- The vulnerability allows resource exhaustion and sync stalling but does not cause consensus divergence due to downstream proof verification at lines 453-462 in `continuous_syncer.rs`.
- Byzantine peers are eventually penalized via peer scoring, but significant damage occurs before detection.
- The fix requires access to validator sets for signature verification, which may require architectural changes to make `EpochState` available in the global summary calculation context.

### Citations

**File:** state-sync/aptos-data-client/src/peer_states.rs (L152-160)
```rust
    fn is_ignored(&self) -> bool {
        // Only ignore peers if the config allows it
        if !self.data_client_config.ignore_low_score_peers {
            return false;
        }

        // Otherwise, ignore peers with a low score
        self.score <= IGNORE_PEER_THRESHOLD
    }
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L374-378)
```rust
            if let Some(synced_ledger_info) = summary.data_summary.synced_ledger_info.as_ref() {
                advertised_data
                    .synced_ledger_infos
                    .push(synced_ledger_info.clone());
            }
```

**File:** state-sync/data-streaming-service/src/stream_engine.rs (L523-529)
```rust
        if let Some(highest_synced_ledger_info) = advertised_data.highest_synced_ledger_info() {
            let (next_request_version, _) = self.next_request_version_and_epoch;
            if next_request_version > highest_synced_ledger_info.ledger_info().version() {
                Ok(None) // We're already at the highest synced ledger info. There's no known target.
            } else {
                Ok(Some(highest_synced_ledger_info))
            }
```

**File:** state-sync/data-streaming-service/src/stream_engine.rs (L1218-1220)
```rust
                            )))
                    );
                    self.current_target_ledger_info = Some(target_ledger_info);
```

**File:** state-sync/aptos-data-client/src/global_summary.rs (L184-198)
```rust
    pub fn highest_synced_ledger_info(&self) -> Option<LedgerInfoWithSignatures> {
        let highest_synced_position = self
            .synced_ledger_infos
            .iter()
            .map(|ledger_info_with_sigs| ledger_info_with_sigs.ledger_info().version())
            .position_max();

        if let Some(highest_synced_position) = highest_synced_position {
            self.synced_ledger_infos
                .get(highest_synced_position)
                .cloned()
        } else {
            None
        }
    }
```

**File:** state-sync/state-sync-driver/src/continuous_syncer.rs (L293-298)
```rust
        self.verify_proof_ledger_info(
            consensus_sync_request.clone(),
            notification_metadata.notification_id,
            &ledger_info_with_signatures,
        )
        .await?;
```

**File:** state-sync/aptos-data-client/src/poller.rs (L437-439)
```rust
        data_summary_poller
            .data_client
            .update_peer_storage_summary(peer, storage_summary);
```
