# Audit Report

## Title
Cross-Shard State Inconsistency Due to Empty Read/Write Hints for System Transactions in Sharded Execution

## Summary
System transactions (BlockMetadata, StateCheckpoint, ValidatorTransaction) return empty read/write hints, causing the sharded execution partitioner to miss critical cross-shard dependencies. This allows user transactions in different shards to read stale system state (timestamp, block height, validator info) instead of waiting for system transaction updates, violating deterministic execution guarantees.

## Finding Description

The vulnerability exists in the interaction between the transaction hint generation system and the sharded block executor's dependency tracking mechanism.

**Root Cause:**

At [1](#0-0) , the `get_read_write_hints()` function returns `empty_rw_set()` for all non-UserTransaction types, including BlockMetadata which actually modifies critical system state.

**Actual State Modifications by BlockMetadata:**

BlockMetadata transactions execute `block_prologue` which modifies:
- `BlockResource` at `@aptos_framework` [2](#0-1) 
- Validator performance statistics [3](#0-2) 
- Timestamp via reconfiguration checks [4](#0-3) 

**Dependency Chain Breakage:**

1. The partitioner initializes read/write sets from hints: [5](#0-4) 

2. Cross-shard dependencies are built by iterating over these sets: [6](#0-5) 

3. Since BlockMetadata has empty write_set, no dependent edges are created to transactions that read timestamp/block height.

4. The CrossShardStateView only initializes waiting state for keys in required_edges: [7](#0-6) 

5. When a user transaction in a different shard reads timestamp, it bypasses the cross-shard wait mechanism: [8](#0-7) 

**Exploitation Path:**

1. Sharded execution mode enabled with BlockMetadata in shard A
2. User transaction in shard B reads `timestamp::now_microseconds()` or `block::get_current_block_height()`
3. No cross-shard dependency exists due to empty hints
4. User transaction reads stale value from base state view instead of waiting for BlockMetadata's write
5. Different shards produce inconsistent state, violating deterministic execution

## Impact Explanation

**Critical Severity** - This vulnerability breaks fundamental blockchain invariants:

1. **Deterministic Execution Violation**: Different validator nodes using sharded execution could produce different state roots for identical blocks, as transactions in different shards read different timestamp/block height values.

2. **Consensus Safety Risk**: State root mismatches would cause validators to disagree on block validity, potentially causing chain halts or forks.

3. **State Consistency Breach**: The same transaction could execute differently depending on shard assignment, breaking the guarantee that transaction execution is independent of execution strategy.

This meets the **Critical** severity threshold per Aptos bug bounty criteria as it enables "Consensus/Safety violations" and breaks the atomic state transition guarantee.

## Likelihood Explanation

**Likelihood: Medium to High** (if sharded execution is enabled)

The vulnerability triggers automatically whenever:
- Sharded execution mode is active
- BlockMetadata is assigned to one shard
- Any user transaction reading system state (timestamp, block height) is assigned to a different shard
- No explicit cross-shard dependency was created due to empty hints

This is a systematic failure, not requiring attacker manipulation. However, likelihood depends on whether sharded execution is used in production deployments.

## Recommendation

**Immediate Fix:** Implement proper read/write hints for system transactions:

```rust
impl AnalyzedTransactionProvider for Transaction {
    fn get_read_write_hints(&self) -> (Vec<StorageLocation>, Vec<StorageLocation>) {
        match self {
            Transaction::UserTransaction(signed_txn) => {
                // existing user transaction logic
            },
            Transaction::BlockMetadata(_) | Transaction::BlockMetadataExt(_) => {
                // BlockMetadata writes to critical system resources
                let write_hints = vec![
                    StorageLocation::Specific(
                        StateKey::resource_typed::<BlockResource>(
                            &AccountAddress::ONE
                        ).unwrap()
                    ),
                    current_ts_location(),
                    // Add other system resources modified by block_prologue
                ];
                (vec![], write_hints)
            },
            Transaction::StateCheckpoint(_) => {
                // StateCheckpoint has no state modifications
                empty_rw_set()
            },
            Transaction::ValidatorTransaction(_) => {
                // Analyze specific validator transaction types
                todo!("Implement hints for validator transactions")
            },
            _ => empty_rw_set(),
        }
    }
}
```

**Alternative Mitigation:** Ensure system transactions are never partitioned across shards - always execute them in a designated "system shard" or globally before shard execution begins.

## Proof of Concept

```rust
// Reproduction in execution/block-partitioner/src/tests.rs

#[test]
fn test_system_transaction_cross_shard_dependency_missing() {
    let num_shards = 2;
    
    // Create BlockMetadata transaction at index 0
    let block_metadata = create_block_metadata_transaction();
    
    // Create user transaction that reads timestamp
    let user_txn = create_timestamp_reading_transaction();
    
    let transactions = vec![
        AnalyzedTransaction::from(Transaction::BlockMetadata(block_metadata)),
        AnalyzedTransaction::from(Transaction::UserTransaction(user_txn)),
    ];
    
    let partitioner = PartitionerV2::new(num_shards, /* config */);
    let partitioned = partitioner.partition(transactions);
    
    // Verify: If BlockMetadata and user_txn are in different shards,
    // there should be a cross-shard dependency, but there isn't!
    assert!(partitioned.sharded_txns[0][0].transactions[0]
        .cross_shard_dependencies
        .dependent_edges_iter()
        .count() == 0); // BUG: Should have dependent edge to user_txn
}
```

**Notes**

This vulnerability only affects deployments using sharded execution mode. Regular Block-STM execution is unaffected because it relies on dynamic read/write tracking via `CapturedReads` and `MVHashMap`, not pre-computed hints. The sharded execution partitioner, however, requires accurate hints to build cross-shard dependency graphs for correctness.

### Citations

**File:** types/src/transaction/analyzed_transaction.rs (L271-283)
```rust
        match self {
            Transaction::UserTransaction(signed_txn) => match signed_txn.payload().executable_ref()
            {
                Ok(TransactionExecutableRef::EntryFunction(func))
                    if !signed_txn.payload().is_multisig() =>
                {
                    process_entry_function(func, signed_txn.sender())
                },
                _ => todo!("Only entry function transactions are supported for now"),
            },
            _ => empty_rw_set(),
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/block.move (L178-191)
```text
        let block_metadata_ref = borrow_global_mut<BlockResource>(@aptos_framework);
        block_metadata_ref.height = event::counter(&block_metadata_ref.new_block_events);

        let new_block_event = NewBlockEvent {
            hash,
            epoch,
            round,
            height: block_metadata_ref.height,
            previous_block_votes_bitvec,
            proposer,
            failed_proposer_indices,
            time_microseconds: timestamp,
        };
        emit_new_block_event(vm, &mut block_metadata_ref.new_block_events, new_block_event);
```

**File:** aptos-move/framework/aptos-framework/sources/block.move (L195-195)
```text
        stake::update_performance_statistics(proposer_index, failed_proposer_indices);
```

**File:** aptos-move/framework/aptos-framework/sources/block.move (L215-217)
```text
        if (timestamp - reconfiguration::last_reconfiguration_time() >= epoch_interval) {
            reconfiguration::reconfigure();
        };
```

**File:** execution/block-partitioner/src/v2/init.rs (L28-44)
```rust
                    let reads = txn.read_hints.iter().map(|loc| (loc, false));
                    let writes = txn.write_hints.iter().map(|loc| (loc, true));
                    reads
                        .chain(writes)
                        .for_each(|(storage_location, is_write)| {
                            let key_idx = state.add_key(storage_location.state_key());
                            if is_write {
                                state.write_sets[ori_txn_idx]
                                    .write()
                                    .unwrap()
                                    .insert(key_idx);
                            } else {
                                state.read_sets[ori_txn_idx]
                                    .write()
                                    .unwrap()
                                    .insert(key_idx);
                            }
```

**File:** execution/block-partitioner/src/v2/state.rs (L302-321)
```rust
        let write_set = self.write_sets[ori_txn_idx].read().unwrap();
        let read_set = self.read_sets[ori_txn_idx].read().unwrap();
        for &key_idx in write_set.iter().chain(read_set.iter()) {
            let tracker_ref = self.trackers.get(&key_idx).unwrap();
            let tracker = tracker_ref.read().unwrap();
            if let Some(txn_idx) = tracker
                .finalized_writes
                .range(..ShardedTxnIndexV2::new(round_id, shard_id, 0))
                .last()
            {
                let src_txn_idx = ShardedTxnIndex {
                    txn_index: *self.final_idxs_by_pre_partitioned[txn_idx.pre_partitioned_txn_idx]
                        .read()
                        .unwrap(),
                    shard_id: txn_idx.shard_id(),
                    round_id: txn_idx.round_id(),
                };
                deps.add_required_edge(src_txn_idx, tracker.storage_location.clone());
            }
        }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/cross_shard_state_view.rs (L58-71)
```rust
    pub fn create_cross_shard_state_view(
        base_view: &'a S,
        transactions: &[TransactionWithDependencies<AnalyzedTransaction>],
    ) -> CrossShardStateView<'a, S> {
        let mut cross_shard_state_key = HashSet::new();
        for txn in transactions {
            for (_, storage_locations) in txn.cross_shard_dependencies.required_edges_iter() {
                for storage_location in storage_locations {
                    cross_shard_state_key.insert(storage_location.clone().into_state_key());
                }
            }
        }
        CrossShardStateView::new(cross_shard_state_key, base_view)
    }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/cross_shard_state_view.rs (L77-82)
```rust
    fn get_state_value(&self, state_key: &StateKey) -> Result<Option<StateValue>, StateViewError> {
        if let Some(value) = self.cross_shard_data.get(state_key) {
            return Ok(value.get_value());
        }
        self.base_view.get_state_value(state_key)
    }
```
