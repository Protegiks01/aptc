# Audit Report

## Title
Unauthenticated Quorum Store Transaction Enumeration Enables MEV Exploitation on Non-Mainnet Chains

## Summary
The admin service endpoint `/debug/consensus/quorumstoredb` exposes all pending quorum store batches including full transaction contents without authentication on testnet and devnet by default, enabling MEV exploitation through transaction front-running and back-running attacks.

## Finding Description
The `dump_quorum_store_db` function in the admin service allows complete enumeration of pending quorum store batches in two steps: [1](#0-0) 

When called without a digest parameter, the function returns all batch digests from the database. An attacker can then query each digest individually to retrieve the complete `PersistedValue<BatchInfo>` structure, which includes the `maybe_payload: Option<Vec<SignedTransaction>>` field containing full transaction details. [2](#0-1) 

The admin service is enabled by default on non-mainnet chains without authentication: [3](#0-2) 

The authentication check defaults to authenticated when no authentication configs are present: [4](#0-3) 

Batches persist full transaction payloads when created by the batch generator: [5](#0-4) 

The batch-to-persisted-value conversion preserves transaction payloads: [6](#0-5) 

**Attack Path:**
1. Attacker discovers validator/fullnode with admin service enabled (default on testnet/devnet)
2. Calls `GET http://<node>:9102/debug/consensus/quorumstoredb` to enumerate all pending batch digests
3. For each digest, calls `GET http://<node>:9102/debug/consensus/quorumstoredb?digest=<hash>` to retrieve full batch
4. Extracts transaction details (sender, sequence, payload, gas price) via Debug formatting
5. Front-runs profitable transactions or back-runs to extract MEV

## Impact Explanation
This vulnerability enables MEV exploitation by breaking transaction privacy before block inclusion. Attackers can:
- Front-run profitable DEX swaps and arbitrage opportunities
- Back-run transactions to extract value
- Selectively order transactions if they become block proposer
- Gain unfair informational advantage over other participants

While the sanitizer prevents this on mainnet requiring authentication, testnet and devnet chains are exposed by default. This undermines realistic testing environments and can impact projects testing on these networks. The severity is **Medium** as it enables "limited funds loss or manipulation" through MEV extraction in testing environments and creates state inconsistencies in transaction ordering expectations. [7](#0-6) 

## Likelihood Explanation
**High likelihood on testnet/devnet**: The admin service is enabled by default without authentication on all non-mainnet chains. The service binds to `0.0.0.0:9102`, making it accessible from any network interface if not firewalled. [8](#0-7) 

**Low likelihood on mainnet**: The optimizer disables the admin service by default, and the sanitizer enforces authentication requirements. However, misconfiguration remains possible during operations.

## Recommendation
1. **Require authentication on all chains**: Remove the chain-specific logic and enforce authentication universally
2. **Bind to localhost by default**: Change default address from `0.0.0.0` to `127.0.0.1`
3. **Strip transaction payloads from debug output**: Modify `dump_quorum_store_db` to only return batch metadata, not full transaction contents
4. **Add rate limiting**: Implement rate limits on admin endpoints to prevent rapid enumeration

**Proposed fix for `admin_service_config.rs`:**
```rust
impl Default for AdminServiceConfig {
    fn default() -> Self {
        Self {
            enabled: None,
            address: "127.0.0.1".to_string(),  // Changed from 0.0.0.0
            port: 9102,
            authentication_configs: vec![],
            malloc_stats_max_len: 2 * 1024 * 1024,
        }
    }
}
```

**Proposed fix for sanitizer:**
```rust
// Remove chain-specific logic, require authentication on all chains
if node_config.admin_service.enabled == Some(true)
    && node_config.admin_service.authentication_configs.is_empty()
{
    return Err(Error::ConfigSanitizerFailed(
        sanitizer_name,
        "Must enable authentication for AdminService on all chains.".into(),
    ));
}
```

## Proof of Concept
```bash
# On a testnet validator node with default configuration

# Step 1: Enumerate all pending batch digests
curl http://<testnet-validator>:9102/debug/consensus/quorumstoredb

# Output contains digests like:
# HashValue(0x123abc...):\n
# HashValue(0x456def...):\n

# Step 2: Query specific digest to get full batch with transactions
curl "http://<testnet-validator>:9102/debug/consensus/quorumstoredb?digest=0x123abc..."

# Output contains full PersistedValue with:
# PersistedValue { 
#   info: BatchInfo { author, batch_id, epoch, digest, ... },
#   maybe_payload: Some([
#     SignedTransaction { sender: 0xabc..., payload: EntryFunction {...}, gas_price: 100, ... },
#     SignedTransaction { sender: 0xdef..., payload: Script {...}, gas_price: 150, ... }
#   ])
# }

# Attacker now has complete visibility into pending transactions
```

**Notes:**
- This vulnerability affects testnet and devnet by default configuration
- Mainnet is protected by the sanitizer requiring authentication when enabled
- The root cause is the combination of: (1) default unauthenticated access on non-mainnet chains, (2) binding to all interfaces, and (3) exposing full transaction payloads in debug output
- Even if treated as a "debug feature," exposing transaction privacy undermines security testing and provides unfair advantages to attackers monitoring test networks

### Citations

**File:** crates/aptos-admin-service/src/server/consensus/mod.rs (L158-177)
```rust
fn dump_quorum_store_db(
    quorum_store_db: &dyn QuorumStoreStorage,
    digest: Option<HashValue>,
) -> anyhow::Result<String> {
    let mut body = String::new();

    if let Some(digest) = digest {
        body.push_str(&format!("{digest:?}:\n"));
        body.push_str(&format!(
            "{:?}",
            quorum_store_db.get_batch(&digest).map_err(Error::msg)?
        ));
    } else {
        for (digest, _batch) in quorum_store_db.get_all_batches()? {
            body.push_str(&format!("{digest:?}:\n"));
        }
    }

    Ok(body)
}
```

**File:** consensus/src/quorum_store/types.rs (L21-25)
```rust
#[derive(Clone, Eq, Deserialize, Serialize, PartialEq, Debug)]
pub struct PersistedValue<T> {
    info: T,
    maybe_payload: Option<Vec<SignedTransaction>>,
}
```

**File:** consensus/src/quorum_store/types.rs (L406-414)
```rust
impl<T: TBatchInfo> From<Batch<T>> for PersistedValue<T> {
    fn from(value: Batch<T>) -> Self {
        let Batch {
            batch_info,
            payload,
        } = value;
        PersistedValue::new(batch_info, Some(payload.into_transactions()))
    }
}
```

**File:** config/src/config/admin_service_config.rs (L41-51)
```rust
impl Default for AdminServiceConfig {
    fn default() -> Self {
        Self {
            enabled: None,
            address: "0.0.0.0".to_string(),
            port: 9102,
            authentication_configs: vec![],
            malloc_stats_max_len: 2 * 1024 * 1024,
        }
    }
}
```

**File:** config/src/config/admin_service_config.rs (L59-82)
```rust
impl ConfigSanitizer for AdminServiceConfig {
    fn sanitize(
        node_config: &NodeConfig,
        _node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();

        if node_config.admin_service.enabled == Some(true) {
            if let Some(chain_id) = chain_id {
                if chain_id.is_mainnet()
                    && node_config.admin_service.authentication_configs.is_empty()
                {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "Must enable authentication for AdminService on mainnet.".into(),
                    ));
                }
            }
        }

        Ok(())
    }
}
```

**File:** config/src/config/admin_service_config.rs (L84-107)
```rust
impl ConfigOptimizer for AdminServiceConfig {
    fn optimize(
        node_config: &mut NodeConfig,
        _local_config_yaml: &Value,
        _node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<bool, Error> {
        let mut modified_config = false;

        if node_config.admin_service.enabled.is_none() {
            // Only enable the admin service if the chain is not mainnet
            let admin_service_enabled = if let Some(chain_id) = chain_id {
                !chain_id.is_mainnet()
            } else {
                false // We cannot determine the chain ID, so we disable the admin service
            };
            node_config.admin_service.enabled = Some(admin_service_enabled);

            modified_config = true; // The config was modified
        }

        Ok(modified_config)
    }
}
```

**File:** crates/aptos-admin-service/src/server/mod.rs (L154-181)
```rust
        let mut authenticated = false;
        if context.config.authentication_configs.is_empty() {
            authenticated = true;
        } else {
            for authentication_config in &context.config.authentication_configs {
                match authentication_config {
                    AuthenticationConfig::PasscodeSha256(passcode_sha256) => {
                        let query = req.uri().query().unwrap_or("");
                        let query_pairs: HashMap<_, _> =
                            url::form_urlencoded::parse(query.as_bytes()).collect();
                        let passcode: Option<String> =
                            query_pairs.get("passcode").map(|p| p.to_string());
                        if let Some(passcode) = passcode {
                            if sha256::digest(passcode) == *passcode_sha256 {
                                authenticated = true;
                            }
                        }
                    },
                }
            }
        };

        if !authenticated {
            return Ok(reply_with_status(
                StatusCode::NETWORK_AUTHENTICATION_REQUIRED,
                format!("{} endpoint requires authentication.", req.uri().path()),
            ));
        }
```

**File:** consensus/src/quorum_store/batch_generator.rs (L486-492)
```rust
                            let persist_start = Instant::now();
                            let mut persist_requests = vec![];
                            for batch in batches.clone().into_iter() {
                                persist_requests.push(batch.into());
                            }
                            self.batch_writer.persist(persist_requests);
                            counters::BATCH_CREATION_PERSIST_LATENCY.observe_duration(persist_start.elapsed());
```
