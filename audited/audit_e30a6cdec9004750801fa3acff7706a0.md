# Audit Report

## Title
Lagrange Interpolation Attack via Unvalidated Player IDs in Secret Reconstruction

## Summary
The DKG secret reconstruction implementation lacks input validation on player IDs, allowing attackers to trigger out-of-bounds array access or reconstruct incorrect secrets by providing malicious player indices. This breaks the cryptographic security guarantees of the secret sharing scheme.

## Finding Description

The vulnerability exists in the interaction between three components:

1. **Player struct with public fields** [1](#0-0) 

The `Player` struct has a public `id` field, allowing arbitrary construction despite comments indicating this should be prevented. [2](#0-1) 

2. **Unvalidated Player ID usage in `reconstruct_secret_from_shares`** [3](#0-2) 

The function directly casts u64 player indices to `usize` and constructs `Player` objects without bounds validation, then passes them to reconstruction.

3. **Unchecked array indexing in `lagrange_coefficients`** [4](#0-3) 

The Lagrange coefficient calculation directly indexes into the `omegas` array using player IDs from the input slice without bounds checking. [5](#0-4) 

**Attack Vector:**

When `reconstruct_secret_from_shares` is called with malicious player indices:
- **Scenario 1 (DoS)**: Player IDs ≥ N cause out-of-bounds panic in lagrange_coefficients
- **Scenario 2 (Cryptographic break)**: Valid but mismatched player IDs (e.g., shares from players 0,1,2 with IDs claiming 5,7,9) cause Lagrange interpolation to use wrong evaluation points (ω^5, ω^7, ω^9 instead of ω^0, ω^1, ω^2), reconstructing an incorrect secret

The reconstruction flow extracts player IDs without validation: [6](#0-5) 

## Impact Explanation

**Critical Severity** - This vulnerability breaks fundamental cryptographic security:

1. **Consensus Safety Violation**: Incorrect secret reconstruction could lead to different nodes computing different randomness values, breaking consensus determinism
2. **Validator Node DoS**: Out-of-bounds access causes validator crashes, affecting network availability
3. **Cryptographic Correctness Violation**: Secret sharing schemes rely on correct interpolation points - using wrong points breaks the mathematical security guarantees

The impact depends on where `reconstruct_secret_from_shares` is exposed. If callable through VM operations or RPC endpoints, this enables unprivileged attackers to:
- Crash validators (High severity)
- Manipulate randomness generation (Critical severity)
- Break DKG protocol security (Critical severity)

## Likelihood Explanation

**Medium to High Likelihood:**

The validation checks in production code paths (e.g., consensus randomness) appear to validate player IDs before calling reconstruction functions. [7](#0-6) 

However, `reconstruct_secret_from_shares` is a public API function in the DKGTrait interface, making it susceptible to misuse if exposed through additional code paths or future features. The lack of defense-in-depth validation means any caller that fails to validate inputs will trigger the vulnerability.

## Recommendation

Implement input validation at multiple layers:

1. **Add bounds checking in `lagrange_coefficients`:**
```rust
pub fn lagrange_coefficients(
    dom: &BatchEvaluationDomain,
    T: &[usize],
    alpha: &Scalar,
) -> Vec<Scalar> {
    let N = dom.N();
    
    // Validate all player IDs are in valid range
    for &id in T {
        if id >= N {
            panic!("Player ID {} exceeds domain size {}", id, N);
        }
    }
    // ... rest of implementation
}
```

2. **Add validation in `reconstruct_secret_from_shares`:**
```rust
fn reconstruct_secret_from_shares(
    pub_params: &Self::PublicParams,
    input_player_share_pairs: Vec<(u64, Self::DealtSecretShare)>,
) -> anyhow::Result<Self::DealtSecret> {
    let n = pub_params.pvss_config.wconfig.get_total_num_players();
    
    // Validate all player indices
    for (player_idx, _) in &input_player_share_pairs {
        if *player_idx >= n as u64 {
            bail!("Invalid player index {} (max: {})", player_idx, n - 1);
        }
    }
    // ... rest of implementation
}
```

3. **Make Player::id field private** and provide validated construction methods only through `SecretSharingConfig`.

## Proof of Concept

```rust
// PoC demonstrating the vulnerability
use aptos_crypto::player::Player;
use aptos_dkg::pvss::dealt_secret_key::g1::DealtSecretKey;
use aptos_crypto::blstrs::threshold_config::ThresholdConfigBlstrs;

// Attacker constructs malicious player IDs
let malicious_player = Player { id: 999999 }; // Out of bounds

// Create share pairs with invalid player IDs
let malicious_shares = vec![
    (malicious_player, share1),
    (Player { id: 1000000 }, share2),
];

// This will panic with out-of-bounds in lagrange_coefficients
let _ = DealtSecretKey::reconstruct(&config, &malicious_shares);
// Expected: panic at omegas[999999] access
```

**Notes**

The vulnerability exists in the cryptographic primitive layer with insufficient input validation. While current production code paths appear to validate player IDs before reaching the vulnerable functions, the lack of defense-in-depth makes this a latent security issue that could be triggered by future code changes or API exposures.

### Citations

**File:** crates/aptos-crypto/src/player.rs (L21-24)
```rust
pub struct Player {
    /// A number from 0 to n-1.
    pub id: usize,
}
```

**File:** crates/aptos-crypto/src/player.rs (L26-28)
```rust
/// The point of Player is to provide type-safety: ensure nobody creates out-of-range player IDs.
/// So there is no `new()` method; only the SecretSharingConfig trait is allowed to create them.
// TODO: AFAIK the only way to really enforce this is to put both traits inside the same module (or use unsafe Rust)
```

**File:** types/src/dkg/real_dkg/mod.rs (L470-478)
```rust
    fn reconstruct_secret_from_shares(
        pub_params: &Self::PublicParams,
        input_player_share_pairs: Vec<(u64, Self::DealtSecretShare)>,
    ) -> anyhow::Result<Self::DealtSecret> {
        let player_share_pairs: Vec<_> = input_player_share_pairs
            .clone()
            .into_iter()
            .map(|(x, y)| (Player { id: x as usize }, y.main))
            .collect();
```

**File:** crates/aptos-crypto/src/blstrs/lagrange.rs (L177-181)
```rust
    let mut denominators = Vec::with_capacity(T.len());
    for i in 0..T.len() {
        debug_assert_ne!(Z[T[i]], Scalar::ZERO);
        denominators.push(Z[T[i]]);
    }
```

**File:** crates/aptos-crypto/src/blstrs/lagrange.rs (L195-202)
```rust
fn accumulator_poly_helper(dom: &BatchEvaluationDomain, T: &[usize]) -> Vec<Scalar> {
    let omegas = dom.get_all_roots_of_unity();

    // Build the subset of $\omega_i$'s for all $i\in T$.
    let mut set = Vec::with_capacity(T.len());
    for &s in T {
        set.push(omegas[s]);
    }
```

**File:** crates/aptos-dkg/src/pvss/dealt_secret_key.rs (L91-100)
```rust
            fn reconstruct(sc: &ThresholdConfigBlstrs, shares: &[ShamirShare<Self::ShareValue>]) -> anyhow::Result<Self> {
                assert_ge!(shares.len(), sc.get_threshold());
                assert_le!(shares.len(), sc.get_total_num_players());

                let ids = shares.iter().map(|(p, _)| p.id).collect::<Vec<usize>>();
                let lagr = lagrange_coefficients(
                    sc.get_batch_evaluation_domain(),
                    ids.as_slice(),
                    &Scalar::ZERO,
                );
```

**File:** consensus/src/rand/rand_gen/types.rs (L108-127)
```rust
            let id = rand_config
                .validator
                .address_to_validator_index()
                .get(share.author())
                .copied()
                .ok_or_else(|| {
                    anyhow!(
                        "Share::aggregate failed with invalid share author: {}",
                        share.author
                    )
                })?;
            let apk = rand_config
                .get_certified_apk(share.author())
                .ok_or_else(|| {
                    anyhow!(
                        "Share::aggregate failed with missing apk for share from {}",
                        share.author
                    )
                })?;
            apks_and_proofs.push((Player { id }, apk.clone(), share.share().share));
```
