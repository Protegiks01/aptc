# Audit Report

## Title
Missing Chain Compatibility Validation in State Sync Version Checker Allows Meaningless Fork Comparisons

## Summary
The `StateSyncVersionChecker` in `ecosystem/node-checker/src/checker/state_sync_version.rs` compares ledger versions between baseline and target nodes without validating they are on the same blockchain fork. During network partitions with incompatible forks, hard fork scenarios, or cross-network misconfigurations, version comparisons become meaningless as they compare ledger versions from entirely different, incompatible chains.

## Finding Description
The `check()` function retrieves ledger versions from both baseline and target nodes via the API index endpoint, which returns `IndexResponse` containing both `chain_id` and `ledger_version` fields. [1](#0-0) 

However, the checker only extracts and compares the `ledger_version` values without validating the `chain_id` field: [2](#0-1) 

The checker then performs arithmetic comparisons on these version numbers without any cryptographic verification: [3](#0-2) 

**Broken Invariant:** The checker violates the implicit invariant that version comparisons should only occur between nodes on the same blockchain fork with compatible state.

**Exploitation Scenarios:**

1. **Cross-Network Misconfiguration**: Baseline configured to mainnet (chain_id=1), target accidentally on testnet (chain_id=2). The checker reports "healthy" or "lagging by X versions" when they're on completely different networks. [4](#0-3) 

2. **Hard Fork Scenario**: During a contentious software upgrade, the network splits into incompatible forks. Both forks progress their ledger versions independently. A target node on fork B at version 10050 compared against baseline on fork A at version 10000 would report as "ahead" when they're actually on incompatible chains.

3. **Network Partition with Safety Violation**: In the hypothetical case of a consensus bug causing incompatible forks, the checker would fail to detect the fork divergence.

**Contrast with Proper Validation:**
The `TransactionCorrectnessChecker` demonstrates correct fork validation by comparing accumulator root hashes: [5](#0-4) 

The codebase's own fork detection implementation validates using cryptographic hashes: [6](#0-5) 

## Impact Explanation
This qualifies as **Medium severity** per the bug bounty criteria for the following reasons:

1. **State Inconsistencies Requiring Intervention**: Node operators relying on this checker during hard forks or network events would receive false health signals, potentially requiring manual intervention to identify they're on the wrong fork.

2. **Indirect Service Impact**: Nodes believing they're healthy while on a minority fork could:
   - Serve incorrect blockchain data to users via RPC
   - Accept transactions that won't be committed on the canonical chain
   - Provide false confirmation of transaction finality

3. **Operational Risk**: During critical network events (hard forks, major upgrades), this bug prevents proper detection of fork divergence, potentially leading to prolonged service disruption.

While this doesn't directly cause fund loss or consensus violations in the core protocol, it creates operational vulnerabilities that can lead to user-facing issues during exceptional network conditions.

## Likelihood Explanation
**Likelihood: Medium to High**

- **Cross-network misconfiguration**: Common operational error, especially during initial node setup or network migrations
- **Hard fork scenarios**: Occur during major protocol upgrades (happens periodically in blockchain networks)
- **Developer/operator dependency**: Node health monitoring is critical infrastructure that operators trust for production decisions

The node-checker is explicitly designed for monitoring node health, making this a high-impact bug in its intended use case during network stress events.

## Recommendation
Add chain compatibility validation to the `check()` function:

**Primary Fix**: Validate `chain_id` matches between baseline and target:
```rust
// After retrieving latest_baseline_version (line 161)
let latest_baseline_response = baseline_api_index_provider.provide().await?;
let latest_baseline_version = latest_baseline_response.ledger_version.0;
let baseline_chain_id = latest_baseline_response.chain_id;

// Get chain_id from target
let target_response = target_api_index_provider.provide().await?;
let target_chain_id = target_response.chain_id;

// Validate chain compatibility
if baseline_chain_id != target_chain_id {
    return Ok(vec![Self::build_result(
        "Chain ID mismatch detected".to_string(),
        0,
        format!(
            "Your node is on a different chain (chain_id: {}) than the baseline (chain_id: {}). \
            This could indicate a misconfiguration or that your node is on a different network/fork.",
            target_chain_id, baseline_chain_id
        ),
    )]);
}
```

**Enhanced Fix**: Additionally validate accumulator root hashes at a shared version (similar to `TransactionCorrectnessChecker`) to cryptographically verify fork compatibility.

## Proof of Concept
```rust
// Test demonstrating the vulnerability
#[tokio::test]
async fn test_cross_chain_comparison_not_detected() {
    // Setup: Create two providers pointing to different chains
    let mainnet_provider = create_api_index_provider("https://mainnet.aptoslabs.com"); // chain_id = 1
    let testnet_provider = create_api_index_provider("https://testnet.aptoslabs.com"); // chain_id = 2
    
    let providers = ProviderCollection {
        baseline_api_index_provider: Some(Box::new(mainnet_provider)),
        target_api_index_provider: Some(Box::new(testnet_provider)),
        ..Default::default()
    };
    
    let checker = StateSyncVersionChecker::new(StateSyncVersionCheckerConfig {
        common: CommonCheckerConfig::default(),
        version_delta_tolerance: 5000,
    });
    
    // Execute check - this should fail but currently doesn't validate chain_id
    let results = checker.check(&providers).await.unwrap();
    
    // Current behavior: Returns success/lag measurement even though chains are incompatible
    // Expected behavior: Should detect chain_id mismatch and fail
    assert!(results[0].score < 100, "Should detect cross-chain comparison");
}
```

**Notes:**
- The vulnerability is confirmed by examining the code logic and comparing it against proper fork detection implementations elsewhere in the codebase
- The IndexResponse contains necessary validation data (chain_id) but it's not utilized
- Similar checkers properly validate using cryptographic hashes, demonstrating the pattern this checker should follow

### Citations

**File:** api/types/src/index.rs (L14-29)
```rust
#[derive(Clone, Debug, Deserialize, PartialEq, Eq, PoemObject, Serialize)]
pub struct IndexResponse {
    /// Chain ID of the current chain
    pub chain_id: u8,
    pub epoch: U64,
    pub ledger_version: U64,
    pub oldest_ledger_version: U64,
    pub ledger_timestamp: U64,
    pub node_role: RoleType,
    pub oldest_block_height: U64,
    pub block_height: U64,
    // This must be optional to be backwards compatible
    /// Git hash of the build of the API endpoint.  Can be used to determine the exact
    /// software version used by the API endpoint.
    pub git_hash: Option<String>,
}
```

**File:** ecosystem/node-checker/src/checker/state_sync_version.rs (L68-85)
```rust
                // We convert to i64 to avoid potential overflow if the target is ahead of the baseline.
                let delta_from_baseline =
                    latest_baseline_version as i64 - latest_target_version as i64;
                if delta_from_baseline > self.config.version_delta_tolerance as i64 {
                    Self::build_result(
                        "Ledger version is lagging".to_string(),
                        50,
                        format!(
                            "Successfully pulled ledger version from your node twice \
                            and saw the version was increasing, but it is lagging {} versions \
                            behind the baseline node, more than the allowed lag of {}. \
                            Target version: {}. Baseline version: {}.",
                            delta_from_baseline,
                            self.config.version_delta_tolerance,
                            latest_target_version,
                            latest_baseline_version,
                        ),
                    )
```

**File:** ecosystem/node-checker/src/checker/state_sync_version.rs (L131-161)
```rust
        let previous_target_version = match target_api_index_provider.provide().await {
            Ok(response) => response.ledger_version.0,
            Err(err) => {
                return Ok(vec![Self::build_result(
                    "Failed to determine state sync status".to_string(),
                    0,
                    format!("There was an error querying your node's API: {:#}", err),
                )]);
            },
        };

        // Now wait.
        tokio::time::sleep(target_api_index_provider.config.common.check_delay()).await;

        // Get the target node ledger version x seconds later.
        let latest_target_version = match target_api_index_provider.provide().await {
            Ok(response) => response.ledger_version.0,
            Err(err) => {
                return Ok(vec![Self::build_result(
                    "Failed to determine state sync status".to_string(),
                    0,
                    format!("There was an error querying your node's API: {:#}", err),
                )]);
            },
        };

        // Get the latest version from the baseline node. In this case, if we
        // cannot find the value, we return an error instead of a negative evalution,
        // since this implies some issue with the baseline node / this code.
        let latest_baseline_response = baseline_api_index_provider.provide().await?;
        let latest_baseline_version = latest_baseline_response.ledger_version.0;
```

**File:** types/src/chain_id.rs (L11-24)
```rust
#[repr(u8)]
#[derive(Copy, Clone, Debug, Eq, PartialEq)]
pub enum NamedChain {
    /// Users might accidentally initialize the ChainId field to 0, hence reserving ChainId 0 for accidental
    /// initialization.
    /// MAINNET is the Aptos mainnet production chain and is reserved for 1
    MAINNET = 1,
    // Even though these CHAIN IDs do not correspond to MAINNET, changing them should be avoided since they
    // can break test environments for various organisations.
    TESTNET = 2,
    DEVNET = 3,
    TESTING = 4,
    PREMAINNET = 5,
}
```

**File:** ecosystem/node-checker/src/checker/transaction_correctness.rs (L192-220)
```rust
                        if middle_baseline_accumulator_root_hash
                            == middle_target_accumulator_root_hash
                        {
                            Self::build_result(
                                "Target node produced valid recent transaction".to_string(),
                                100,
                                format!(
                                    "We were able to pull the same transaction (version: {}) \
                                    from both your node and the baseline node. Great! This \
                                    implies that your node is returning valid transaction data.",
                                    middle_shared_version,
                                ),
                            )
                        } else {
                            Self::build_result(
                                "Target node produced recent transaction, but it was invalid"
                                    .to_string(),
                                0,
                                format!(
                                    "We were able to pull the same transaction (version: {}) \
                                    from both your node and the baseline node. However, the \
                                    transaction was invalid compared to the baseline as the \
                                    accumulator root hash of the transaction ({}) was different \
                                    compared to the baseline ({}).",
                                    middle_shared_version,
                                    middle_target_accumulator_root_hash,
                                    middle_baseline_accumulator_root_hash,
                                ),
                            )
```

**File:** testsuite/forge/src/interface/swarm.rs (L171-192)
```rust
    async fn are_root_hashes_equal_at_version(
        clients: &[RestClient],
        version: u64,
    ) -> Result<bool> {
        let root_hashes = try_join_all(
            clients
                .iter()
                .map(|node| node.get_transaction_by_version(version))
                .collect::<Vec<_>>(),
        )
        .await?
        .into_iter()
        .map(|r| {
            r.into_inner()
                .transaction_info()
                .unwrap()
                .accumulator_root_hash
        })
        .collect::<Vec<_>>();

        Ok(root_hashes.windows(2).all(|w| w[0] == w[1]))
    }
```
