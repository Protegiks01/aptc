# Audit Report

## Title
File Discovery Allows Unauthorized Peer Injection into Validator Network Trusted Peer Set

## Summary
The `DiscoveryMethod::File` implementation allows an attacker with write access to the discovery file to inject arbitrary malicious peers into the validator network's trusted peer set, bypassing on-chain validator set validation and enabling unauthorized participation in consensus messaging.

## Finding Description

The file-based peer discovery mechanism reads a YAML file at a configurable path and directly adds discovered peers to the trusted peer set without any cryptographic validation or security controls. [1](#0-0) 

The `FileStream` polls the file at regular intervals and deserializes the contents into a `PeerSet`. This peer set is then sent to the connectivity manager via `ConnectivityRequest::UpdateDiscoveredPeers`: [2](#0-1) 

The connectivity manager processes this request in `handle_update_discovered_peers`, which merges the discovered peers and updates the trusted peer set without validation: [3](#0-2) 

Critically, file discovery can be configured on validator networks, as demonstrated in the test suite: [4](#0-3) 

When a malicious peer added via file discovery attempts to connect, they authenticate using the Noise handshake. In mutual authentication mode (required for validator networks), the handshake validates peers against the trusted peer set: [5](#0-4) 

The authentication succeeds if the peer's public key is in the trusted peer set, which can be populated via file discovery: [6](#0-5) 

**Attack Scenario:**
1. A validator network is configured with `DiscoveryMethod::File` pointing to `/etc/aptos/peers.yaml`
2. An attacker gains write access to this file (via misconfigured permissions, shared filesystem, compromised process, or other vulnerability)
3. The attacker generates their own x25519 keypair
4. The attacker modifies the file to add a malicious peer entry with:
   - Their peer ID (derived from their public key)
   - Their public key
   - Network addresses they control
   - Role: `Validator` or other privileged role
5. The `FileStream` reads the modified file and sends `UpdateDiscoveredPeers` to the connectivity manager
6. The connectivity manager adds the malicious peer to `discovered_peers` and updates the `trusted_peers` set
7. The attacker connects from their address using their private key
8. The Noise handshake succeeds because the attacker's public key is now in the trusted peer set
9. The attacker is now a "trusted" peer on the validator network with the configured role

The configuration sanitizer enforces mutual authentication for validator networks but does not restrict file discovery: [7](#0-6) 

## Impact Explanation

This vulnerability is **High Severity** according to Aptos bug bounty criteria because it enables "Significant protocol violations":

1. **Consensus Disruption**: Malicious peers marked as validators can participate in consensus messaging, potentially:
   - Sending conflicting or invalid consensus messages
   - Disrupting block proposal and voting
   - Causing liveness failures by refusing to participate

2. **Trust Model Violation**: The vulnerability completely bypasses the on-chain validator set validation mechanism, which is the foundational trust anchor for the Aptos network.

3. **Network Security Compromise**: Unauthorized peers gain access to validator network communications, exposing sensitive protocol messages and network topology.

4. **No Detection Mechanism**: The system provides no audit logging or warning when peers are added via file discovery, making the attack difficult to detect.

While not reaching Critical severity (which requires direct fund loss or permanent network failure), this represents a severe protocol violation that undermines validator network security.

## Likelihood Explanation

**Likelihood: Medium**

The attack requires write access to the discovery file, but several realistic scenarios enable this:

1. **Misconfigured File Permissions**: Administrators may inadvertently set overly permissive file permissions (e.g., world-writable, group-writable with compromised group members)

2. **Shared Filesystems**: Deployments using NFS, SMB, or other shared filesystems may have inadequate access controls

3. **Container Security Issues**: In containerized deployments, volume mounts or shared storage may expose the file to other containers

4. **Privilege Escalation**: An attacker who compromises a less-privileged process on the same host may escalate to write access

5. **Supply Chain Attacks**: Compromised configuration management tools (Ansible, Chef, Puppet) could modify discovery files

The vulnerability is more likely in practice because:
- There is no documentation warning about the security implications of file discovery
- No cryptographic protection exists on file contents
- No audit logging alerts operators to trust set changes
- The file path is user-configurable, increasing misconfiguration risk

## Recommendation

Implement multiple defense-in-depth mechanisms:

1. **Add Cryptographic Validation**: Require file contents to be signed with a trusted key. Verify the signature before accepting peer updates.

2. **Implement Audit Logging**: Log all changes to the trusted peer set, especially from file discovery, with alerts for additions/removals.

3. **Restrict Discovery Sources**: Consider prohibiting file discovery on validator networks, or requiring explicit acknowledgment of security risks.

4. **Add Discovery Source Priority**: Ensure on-chain discovery takes precedence over file discovery and cannot be overridden.

5. **Validate Peer Roles**: Restrict file discovery from adding peers with privileged roles (Validator) without additional validation.

Example mitigation for signature verification:

```rust
// In FileDiscovery config
pub struct FileDiscovery {
    pub path: PathBuf,
    pub interval_secs: u64,
    pub signing_key: Option<x25519::PublicKey>, // New field
}

// In file.rs load_file function
fn load_file(path: &Path, signing_key: Option<&x25519::PublicKey>) -> Result<PeerSet, DiscoveryError> {
    let contents = std::fs::read_to_string(path).map_err(DiscoveryError::IO)?;
    
    // Parse signed wrapper if signing key is configured
    if let Some(key) = signing_key {
        let signed_data: SignedPeerSet = serde_yaml::from_str(&contents)
            .map_err(|err| DiscoveryError::Parsing(err.to_string()))?;
        
        // Verify signature
        signed_data.verify(key)?;
        Ok(signed_data.peer_set)
    } else {
        // Fallback to unsigned (with warning)
        warn!("Loading unsigned peer discovery file - this is insecure!");
        serde_yaml::from_str(&contents).map_err(|err| DiscoveryError::Parsing(err.to_string()))
    }
}
```

Additionally, add runtime checks:

```rust
// In connectivity_manager handle_update_discovered_peers
fn handle_update_discovered_peers(&mut self, src: DiscoverySource, new_discovered_peers: PeerSet) {
    // Log trust set changes for audit
    info!(
        NetworkSchema::new(&self.network_context),
        "Updating trusted peers from source {:?}: {} peers",
        src,
        new_discovered_peers.len()
    );
    
    // Warn if file discovery is used on validator network
    if src == DiscoverySource::File && self.network_context.network_id().is_validator_network() {
        warn!(
            NetworkSchema::new(&self.network_context),
            "WARNING: File-based discovery is being used on validator network - ensure file permissions are secure!"
        );
    }
    
    // Continue with existing logic...
}
```

## Proof of Concept

**Rust Reproduction Steps:**

1. Configure a validator network with file discovery:
```yaml
validator_network:
  discovery_methods:
    - onchain
    - file:
        path: /tmp/malicious_peers.yaml
        interval_secs: 5
  mutual_authentication: true
```

2. Create malicious peer file (`/tmp/malicious_peers.yaml`):
```rust
use aptos_config::config::{Peer, PeerRole, PeerSet};
use aptos_crypto::x25519;
use aptos_types::{account_address::from_identity_public_key, network_address::NetworkAddress};
use std::collections::HashSet;

// Attacker generates their own keypair
let attacker_private_key = x25519::PrivateKey::generate(&mut rand::rngs::OsRng);
let attacker_public_key = attacker_private_key.public_key();
let attacker_peer_id = from_identity_public_key(attacker_public_key);

// Create malicious peer entry
let mut keys = HashSet::new();
keys.insert(attacker_public_key);

let addresses = vec![
    "/ip4/192.168.1.100/tcp/6180".parse::<NetworkAddress>().unwrap()
];

let malicious_peer = Peer::new(addresses, keys, PeerRole::Validator);

let mut peer_set = PeerSet::new();
peer_set.insert(attacker_peer_id, malicious_peer);

// Write to file
let yaml = serde_yaml::to_string(&peer_set).unwrap();
std::fs::write("/tmp/malicious_peers.yaml", yaml).unwrap();
```

3. The validator node's `FileStream` will read this file within 5 seconds

4. The malicious peer will be added to the trusted peer set

5. The attacker can now connect from 192.168.1.100:6180 using their private key:
```rust
// Attacker's connection code
let noise_config = noise::NoiseConfig::new(attacker_private_key);
// ... establish connection to validator
// Handshake will succeed because attacker_public_key is in trusted_peers
```

6. Verification: Check the validator's peer connections:
```bash
curl http://validator:9101/metrics | grep aptos_network_peers
# Will show the malicious peer as connected and trusted
```

The attacker now has a trusted connection to the validator network and can send/receive protocol messages, including consensus messages if they specified `PeerRole::Validator`.

## Notes

This vulnerability exploits the lack of security controls in file-based peer discovery. While filesystem permissions are the first line of defense, defense-in-depth principles require that the code itself should not blindly trust file contents, especially for security-critical functionality like validator network peer authentication. The absence of cryptographic signatures, audit logging, and role restrictions makes this a significant security gap in the Aptos networking layer.

### Citations

**File:** network/discovery/src/file.rs (L49-53)
```rust
/// Loads a YAML configuration file
fn load_file(path: &Path) -> Result<PeerSet, DiscoveryError> {
    let contents = std::fs::read_to_string(path).map_err(DiscoveryError::IO)?;
    serde_yaml::from_str(&contents).map_err(|err| DiscoveryError::Parsing(err.to_string()))
}
```

**File:** network/discovery/src/lib.rs (L141-156)
```rust
        while let Some(update) = source_stream.next().await {
            if let Ok(update) = update {
                trace!(
                    NetworkSchema::new(&network_context),
                    "{} Sending update: {:?}",
                    network_context,
                    update
                );
                let request = ConnectivityRequest::UpdateDiscoveredPeers(discovery_source, update);
                if let Err(error) = update_channel.try_send(request) {
                    inc_by_with_context(&DISCOVERY_COUNTS, &network_context, "send_failure", 1);
                    warn!(
                        NetworkSchema::new(&network_context),
                        "{} Failed to send update {:?}", network_context, error
                    );
                }
```

**File:** network/framework/src/connectivity_manager/mod.rs (L886-1001)
```rust
    fn handle_update_discovered_peers(
        &mut self,
        src: DiscoverySource,
        new_discovered_peers: PeerSet,
    ) {
        // Log the update event
        info!(
            NetworkSchema::new(&self.network_context),
            "{} Received updated list of discovered peers! Source: {:?}, num peers: {:?}",
            self.network_context,
            src,
            new_discovered_peers.len()
        );

        // Remove peers that no longer have relevant network information
        let mut keys_updated = false;
        let mut peers_to_check_remove = Vec::new();
        for (peer_id, peer) in self.discovered_peers.write().peer_set.iter_mut() {
            let new_peer = new_discovered_peers.get(peer_id);
            let check_remove = if let Some(new_peer) = new_peer {
                if new_peer.keys.is_empty() {
                    keys_updated |= peer.keys.clear_src(src);
                }
                if new_peer.addresses.is_empty() {
                    peer.addrs.clear_src(src);
                }
                new_peer.addresses.is_empty() && new_peer.keys.is_empty()
            } else {
                keys_updated |= peer.keys.clear_src(src);
                peer.addrs.clear_src(src);
                true
            };
            if check_remove {
                peers_to_check_remove.push(*peer_id);
            }
        }

        // Remove peers that no longer have state
        for peer_id in peers_to_check_remove {
            self.discovered_peers.write().remove_peer_if_empty(&peer_id);
        }

        // Make updates to the peers accordingly
        for (peer_id, discovered_peer) in new_discovered_peers {
            // Don't include ourselves, because we don't need to dial ourselves
            if peer_id == self.network_context.peer_id() {
                continue;
            }

            // Create the new `DiscoveredPeer`, role is set when a `Peer` is first discovered
            let mut discovered_peers = self.discovered_peers.write();
            let peer = discovered_peers
                .peer_set
                .entry(peer_id)
                .or_insert_with(|| DiscoveredPeer::new(discovered_peer.role));

            // Update the peer's pubkeys
            let mut peer_updated = false;
            if peer.keys.update(src, discovered_peer.keys) {
                info!(
                    NetworkSchema::new(&self.network_context)
                        .remote_peer(&peer_id)
                        .discovery_source(&src),
                    "{} pubkey sets updated for peer: {}, pubkeys: {}",
                    self.network_context,
                    peer_id.short_str(),
                    peer.keys
                );
                keys_updated = true;
                peer_updated = true;
            }

            // Update the peer's addresses
            if peer.addrs.update(src, discovered_peer.addresses) {
                info!(
                    NetworkSchema::new(&self.network_context).remote_peer(&peer_id),
                    network_addresses = &peer.addrs,
                    "{} addresses updated for peer: {}, update src: {:?}, addrs: {}",
                    self.network_context,
                    peer_id.short_str(),
                    src,
                    &peer.addrs,
                );
                peer_updated = true;
            }

            // If we're currently trying to dial this peer, we reset their
            // dial state. As a result, we will begin our next dial attempt
            // from the first address (which might have changed) and from a
            // fresh backoff (since the current backoff delay might be maxed
            // out if we can't reach any of their previous addresses).
            if peer_updated {
                if let Some(dial_state) = self.dial_states.get_mut(&peer_id) {
                    *dial_state = DialState::new(self.backoff_strategy.clone());
                }
            }
        }

        // update eligible peers accordingly
        if keys_updated {
            // For each peer, union all of the pubkeys from each discovery source
            // to generate the new eligible peers set.
            let new_eligible = self.discovered_peers.read().get_eligible_peers();

            // Swap in the new eligible peers set
            if let Err(error) = self
                .peers_and_metadata
                .set_trusted_peers(&self.network_context.network_id(), new_eligible)
            {
                error!(
                    NetworkSchema::new(&self.network_context),
                    error = %error,
                    "Failed to update trusted peers set"
                );
            }
        }
```

**File:** testsuite/smoke-test/src/network.rs (L186-195)
```rust
            modify_network_config(config, &NetworkId::Validator, move |network| {
                network.discovery_method = DiscoveryMethod::None;
                network.discovery_methods = vec![
                    DiscoveryMethod::Onchain,
                    DiscoveryMethod::File(FileDiscovery {
                        path: discovery_file_for_closure2.path().to_path_buf(),
                        interval_secs: 1,
                    }),
                ];
            });
```

**File:** network/framework/src/noise/handshake.rs (L366-383)
```rust
        // if mutual auth mode, verify the remote pubkey is in our set of trusted peers
        let network_id = self.network_context.network_id();
        let peer_role = match &self.auth_mode {
            HandshakeAuthMode::Mutual {
                peers_and_metadata, ..
            } => {
                let trusted_peers = peers_and_metadata.get_trusted_peers(&network_id)?;
                let trusted_peer = trusted_peers.get(&remote_peer_id).cloned();
                match trusted_peer {
                    Some(peer) => {
                        Self::authenticate_inbound(remote_peer_short, &peer, &remote_public_key)
                    },
                    None => Err(NoiseHandshakeError::UnauthenticatedClient(
                        remote_peer_short,
                        remote_peer_id,
                    )),
                }
            },
```

**File:** network/framework/src/noise/handshake.rs (L488-500)
```rust
    fn authenticate_inbound(
        remote_peer_short: ShortHexStr,
        peer: &Peer,
        remote_public_key: &x25519::PublicKey,
    ) -> Result<PeerRole, NoiseHandshakeError> {
        if !peer.keys.contains(remote_public_key) {
            return Err(NoiseHandshakeError::UnauthenticatedClientPubkey(
                remote_peer_short,
                hex::encode(remote_public_key.as_slice()),
            ));
        }
        Ok(peer.role)
    }
```

**File:** config/src/config/config_sanitizer.rs (L191-197)
```rust
        // Ensure that mutual authentication is enabled
        if !validator_network_config.mutual_authentication {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "Mutual authentication must be enabled for the validator network!".into(),
            ));
        }
```
