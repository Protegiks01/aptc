> Searching codebase... [1](#0-0) [2](#0-1) [3](#0-2) [4](#0-3) [5](#0-4) [6](#0-5) [7](#0-6)

### Citations

**File:** consensus/src/liveness/rotating_proposer_election.rs (L10-39)
```rust
pub struct RotatingProposer {
    // Ordering of proposers to rotate through (all honest replicas must agree on this)
    proposers: Vec<Author>,
    // Number of contiguous rounds (i.e. round numbers increase by 1) a proposer is active
    // in a row
    contiguous_rounds: u32,
}

/// Choose a proposer that is going to be the single leader (relevant for a mock fixed proposer
/// election only).
pub fn choose_leader(peers: Vec<Author>) -> Author {
    // As it is just a tmp hack function, pick the min PeerId to be a proposer.
    peers.into_iter().min().expect("No trusted peers found!")
}

impl RotatingProposer {
    /// With only one proposer in the vector, it behaves the same as a fixed proposer strategy.
    pub fn new(proposers: Vec<Author>, contiguous_rounds: u32) -> Self {
        Self {
            proposers,
            contiguous_rounds,
        }
    }
}

impl ProposerElection for RotatingProposer {
    fn get_valid_proposer(&self, round: Round) -> Author {
        self.proposers
            [((round / u64::from(self.contiguous_rounds)) % self.proposers.len() as u64) as usize]
    }
```

**File:** consensus/src/liveness/proposal_generator.rs (L884-902)
```rust
    pub fn compute_failed_authors(
        &self,
        round: Round,
        previous_round: Round,
        include_cur_round: bool,
        proposer_election: Arc<dyn ProposerElection>,
    ) -> Vec<(Round, Author)> {
        let end_round = round + u64::from(include_cur_round);
        let mut failed_authors = Vec::new();
        let start = std::cmp::max(
            previous_round + 1,
            end_round.saturating_sub(self.max_failed_authors_to_store as u64),
        );
        for i in start..end_round {
            failed_authors.push((i, proposer_election.get_valid_proposer(i)));
        }

        failed_authors
    }
```

**File:** consensus/consensus-types/src/block.rs (L619-638)
```rust
    fn failed_authors_to_indices(
        validators: &[AccountAddress],
        failed_authors: &[(Round, Author)],
    ) -> Vec<u32> {
        failed_authors
            .iter()
            .map(|(_round, failed_author)| {
                validators
                    .iter()
                    .position(|&v| v == *failed_author)
                    .unwrap_or_else(|| {
                        panic!(
                            "Failed author {} not in validator list {:?}",
                            *failed_author, validators
                        )
                    })
            })
            .map(|index| u32::try_from(index).expect("Index is out of bounds for u32"))
            .collect()
    }
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1282-1332)
```text
    public(friend) fun update_performance_statistics(
        proposer_index: Option<u64>,
        failed_proposer_indices: vector<u64>
    ) acquires ValidatorPerformance {
        // Validator set cannot change until the end of the epoch, so the validator index in arguments should
        // match with those of the validators in ValidatorPerformance resource.
        let validator_perf = borrow_global_mut<ValidatorPerformance>(@aptos_framework);
        let validator_len = vector::length(&validator_perf.validators);

        spec {
            update ghost_valid_perf = validator_perf;
            update ghost_proposer_idx = proposer_index;
        };
        // proposer_index is an option because it can be missing (for NilBlocks)
        if (option::is_some(&proposer_index)) {
            let cur_proposer_index = option::extract(&mut proposer_index);
            // Here, and in all other vector::borrow, skip any validator indices that are out of bounds,
            // this ensures that this function doesn't abort if there are out of bounds errors.
            if (cur_proposer_index < validator_len) {
                let validator = vector::borrow_mut(&mut validator_perf.validators, cur_proposer_index);
                spec {
                    assume validator.successful_proposals + 1 <= MAX_U64;
                };
                validator.successful_proposals = validator.successful_proposals + 1;
            };
        };

        let f = 0;
        let f_len = vector::length(&failed_proposer_indices);
        while ({
            spec {
                invariant len(validator_perf.validators) == validator_len;
                invariant (option::is_some(ghost_proposer_idx) && option::borrow(
                    ghost_proposer_idx
                ) < validator_len) ==>
                    (validator_perf.validators[option::borrow(ghost_proposer_idx)].successful_proposals ==
                        ghost_valid_perf.validators[option::borrow(ghost_proposer_idx)].successful_proposals + 1);
            };
            f < f_len
        }) {
            let validator_index = *vector::borrow(&failed_proposer_indices, f);
            if (validator_index < validator_len) {
                let validator = vector::borrow_mut(&mut validator_perf.validators, validator_index);
                spec {
                    assume validator.failed_proposals + 1 <= MAX_U64;
                };
                validator.failed_proposals = validator.failed_proposals + 1;
            };
            f = f + 1;
        };
    }
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1661-1689)
```text
        let num_successful_proposals = cur_validator_perf.successful_proposals;

        let fee_pending_inactive = 0;
        let fee_active = 0;
        let fee_limit = if (exists<TransactionFeeConfig>(@aptos_framework)) {
            let TransactionFeeConfig::V0 { max_fee_octa_allowed_per_epoch_per_pool } = borrow_global<TransactionFeeConfig>(@aptos_framework);
            *max_fee_octa_allowed_per_epoch_per_pool
        } else {
            MAX_U64 as u64
        };

        if (exists<PendingTransactionFee>(@aptos_framework)) {
            let pending_fee_by_validator = &mut borrow_global_mut<PendingTransactionFee>(@aptos_framework).pending_fee_by_validator;
            if (pending_fee_by_validator.contains(&validator_index)) {
                let fee_octa = pending_fee_by_validator.remove(&validator_index).read();
                if (fee_octa > fee_limit) {
                    fee_octa = fee_limit;
                };
                let stake_active = (coin::value(&stake_pool.active) as u128);
                let stake_pending_inactive = (coin::value(&stake_pool.pending_inactive) as u128);
                fee_pending_inactive = (((fee_octa as u128) * stake_pending_inactive / (stake_active + stake_pending_inactive)) as u64);
                fee_active = fee_octa - fee_pending_inactive;
            }
        };

        spec {
            // The following addition should not overflow because `num_total_proposals` cannot be larger than 86400,
            // the maximum number of proposals in a day (1 proposal per second).
            assume cur_validator_perf.successful_proposals + cur_validator_perf.failed_proposals <= MAX_U64;
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1761-1784)
```text
    fun calculate_rewards_amount(
        stake_amount: u64,
        num_successful_proposals: u64,
        num_total_proposals: u64,
        rewards_rate: u64,
        rewards_rate_denominator: u64,
    ): u64 {
        spec {
            // The following condition must hold because
            // (1) num_successful_proposals <= num_total_proposals, and
            // (2) `num_total_proposals` cannot be larger than 86400, the maximum number of proposals
            //     in a day (1 proposal per second), and `num_total_proposals` is reset to 0 every epoch.
            assume num_successful_proposals * MAX_REWARDS_RATE <= MAX_U64;
        };
        // The rewards amount is equal to (stake amount * rewards rate * performance multiplier).
        // We do multiplication in u128 before division to avoid the overflow and minimize the rounding error.
        let rewards_numerator = (stake_amount as u128) * (rewards_rate as u128) * (num_successful_proposals as u128);
        let rewards_denominator = (rewards_rate_denominator as u128) * (num_total_proposals as u128);
        if (rewards_denominator > 0) {
            ((rewards_numerator / rewards_denominator) as u64)
        } else {
            0
        }
    }
```

**File:** types/src/on_chain_config/consensus_config.rs (L291-346)
```rust
            OnChainConsensusConfig::V2(_) => false,
            OnChainConsensusConfig::V3 { alg, .. }
            | OnChainConsensusConfig::V4 { alg, .. }
            | OnChainConsensusConfig::V5 { alg, .. } => alg.is_dag_enabled(),
        }
    }

    pub fn unwrap_dag_config_v1(&self) -> &DagConsensusConfigV1 {
        match &self {
            OnChainConsensusConfig::V1(_) | OnChainConsensusConfig::V2(_) => {
                unreachable!("not a dag config")
            },
            OnChainConsensusConfig::V3 { alg, .. }
            | OnChainConsensusConfig::V4 { alg, .. }
            | OnChainConsensusConfig::V5 { alg, .. } => alg.unwrap_dag_config_v1(),
        }
    }

    pub fn effective_validator_txn_config(&self) -> ValidatorTxnConfig {
        match self {
            OnChainConsensusConfig::V1(_) | OnChainConsensusConfig::V2(_) => {
                ValidatorTxnConfig::default_disabled()
            },
            OnChainConsensusConfig::V3 { vtxn, .. }
            | OnChainConsensusConfig::V4 { vtxn, .. }
            | OnChainConsensusConfig::V5 { vtxn, .. } => vtxn.clone(),
        }
    }

    pub fn is_vtxn_enabled(&self) -> bool {
        self.effective_validator_txn_config().enabled()
    }

    pub fn disable_validator_txns(&mut self) {
        match self {
            OnChainConsensusConfig::V1(_) | OnChainConsensusConfig::V2(_) => {
                // vtxn not supported. No-op.
            },
            OnChainConsensusConfig::V3 { vtxn, .. }
            | OnChainConsensusConfig::V4 { vtxn, .. }
            | OnChainConsensusConfig::V5 { vtxn, .. } => {
                *vtxn = ValidatorTxnConfig::V0;
            },
        }
    }

    pub fn enable_validator_txns(&mut self) {
        let new_self = match std::mem::take(self) {
            OnChainConsensusConfig::V1(config) => OnChainConsensusConfig::V5 {
                alg: ConsensusAlgorithmConfig::JolteonV2 {
                    main: config,
                    quorum_store_enabled: false,
                    order_vote_enabled: false,
                },
                vtxn: ValidatorTxnConfig::default_enabled(),
                window_size: DEFAULT_WINDOW_SIZE,
```
