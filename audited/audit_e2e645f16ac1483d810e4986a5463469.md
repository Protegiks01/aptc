# Audit Report

## Title
Byzantine Peer Behavior Misclassification in Peer Monitoring Service Allows Malicious Actors to Maintain Connectivity

## Summary
The peer monitoring service client fails to classify Byzantine peer behavior correctly, treating all errors uniformly as benign "request failures" rather than distinguishing malicious responses. This allows Byzantine peers to send malformed or invalid responses without being detected, scored as malicious, or disconnected, violating Byzantine Fault Tolerance guarantees.

## Finding Description

The peer monitoring service processes three types of requests: latency pings, network information, and node information. When a Byzantine peer responds with malformed data or errors, the client handles all failures identically through `handle_request_failure()`, which merely increments a consecutive failure counter.

**Critical Gap #1: No Error Classification** [1](#0-0) 

All errors—whether from network timeouts, service errors, or deliberately malformed Byzantine responses—are treated the same way. There is no distinction between `ErrorType::NotUseful` (benign) and `ErrorType::Malicious` (Byzantine) as exists in the state-sync data client. [2](#0-1) 

**Critical Gap #2: Invalid Response Validation Without Byzantine Classification** [3](#0-2) 

When network info validation detects invalid claims (e.g., peer claims distance 0 from validators but isn't a validator), it logs a warning and calls `handle_request_failure()`, treating it as a benign failure rather than Byzantine behavior.

**Critical Gap #3: Disconnection Not Implemented** [4](#0-3) 

Even when consecutive failures exceed the configured threshold (`max_latency_ping_failures`), the code only logs a warning. The TODO comment explicitly states disconnection should occur, but it is not implemented.

**Critical Gap #4: No Peer Scoring Integration** [5](#0-4) 

The request tracker only counts failures—it does not integrate with any peer scoring or reputation system that could identify and ban Byzantine actors.

**Attack Scenario:**

A Byzantine peer can:
1. Send `PeerMonitoringServiceError::InvalidRequest` or `InternalError` responses
2. Claim false network positions (e.g., distance 0 from validators when it's a malicious full node)
3. Return incorrect ping counters to disrupt latency measurements
4. Send invalid node information (false sync status, wrong version) [6](#0-5) 

Honest nodes will:
- Increment failure counters but never classify the behavior as malicious
- Never disconnect from the Byzantine peer (TODO not implemented)
- Never reduce the peer's reputation score
- Continue accepting monitoring data from the Byzantine actor
- Potentially make network topology decisions based on false data

## Impact Explanation

**Severity: High**

This vulnerability represents a **significant protocol violation** of Byzantine Fault Tolerance principles. While it does not directly compromise consensus safety or cause fund loss, it enables several harmful scenarios:

1. **Network Topology Manipulation**: Byzantine peers can falsely advertise being close to validators, causing honest nodes to prefer malicious connections over legitimate ones.

2. **Monitoring Data Pollution**: Honest nodes build their understanding of network health and topology from peer monitoring data. Byzantine actors can inject false information without detection.

3. **Resource Exhaustion**: Without proper disconnection, honest nodes waste resources repeatedly querying Byzantine peers that provide no useful data.

4. **Weakened Byzantine Resistance**: The system is designed to operate under <1/3 Byzantine assumption, but failure to detect and isolate Byzantine peers weakens this guarantee in practice.

This meets the **High Severity** criteria of "Significant protocol violations" as it violates fundamental Byzantine Fault Tolerance assumptions that the network should detect and isolate malicious actors.

## Likelihood Explanation

**Likelihood: High**

The attack is trivially exploitable:
- Any peer can run a malicious monitoring service
- No authentication or proof-of-work required
- Server code allows arbitrary error responses
- No client-side validation prevents malicious behavior
- Attack can be sustained indefinitely (no disconnection)

An attacker needs only to:
1. Connect to the network as a peer
2. Implement a malicious monitoring service that returns invalid data
3. Wait for honest nodes to query them

## Recommendation

Implement proper Byzantine peer detection and disconnection:

**1. Add Error Classification:**
```rust
// In peer-monitoring-service/client/src/error.rs
pub enum ErrorSeverity {
    Benign,      // Network timeouts, temporary issues
    Malicious,   // Invalid data, proof violations, false claims
}

impl Error {
    pub fn get_severity(&self) -> ErrorSeverity {
        match self {
            Error::NetworkError(_) | Error::RpcError(_) => ErrorSeverity::Benign,
            Error::PeerMonitoringServiceError(PeerMonitoringServiceError::InvalidRequest(_)) => 
                ErrorSeverity::Malicious,
            Error::UnexpectedError(_) => ErrorSeverity::Malicious,
            _ => ErrorSeverity::Benign,
        }
    }
}
```

**2. Implement Disconnection Logic:** [7](#0-6) 

Replace the TODO with actual disconnection:
```rust
fn handle_request_failure(&self, peer_network_id: &PeerNetworkId, severity: ErrorSeverity) {
    self.request_tracker.write().record_response_failure();
    
    let num_consecutive_failures = self.request_tracker.read().get_num_consecutive_failures();
    
    // Disconnect for malicious behavior or excessive failures
    if matches!(severity, ErrorSeverity::Malicious) || 
       num_consecutive_failures >= self.latency_monitoring_config.max_latency_ping_failures {
        // Trigger peer disconnection through network layer
        disconnect_peer(peer_network_id, DisconnectReason::MaliciousBehavior);
    }
}
```

**3. Integrate with Peer Scoring:**

Connect peer monitoring failures to the state-sync peer scoring system to ensure Byzantine actors are ignored network-wide, not just in monitoring.

**4. Enhanced Validation:**

Add cryptographic proofs or multi-peer verification for critical claims like distance from validators.

## Proof of Concept

```rust
// Malicious peer monitoring server that always returns invalid data
use aptos_peer_monitoring_service_types::*;

pub struct MaliciousPeerMonitoringServer;

impl MaliciousPeerMonitoringServer {
    pub fn handle_request(&self, request: PeerMonitoringServiceRequest) 
        -> Result<PeerMonitoringServiceResponse> {
        match request {
            PeerMonitoringServiceRequest::GetNetworkInformation => {
                // Falsely claim to be a validator (distance 0)
                Ok(PeerMonitoringServiceResponse::NetworkInformation(
                    NetworkInformationResponse {
                        connected_peers: HashMap::new(),
                        distance_from_validators: 0, // FALSE CLAIM
                    }
                ))
            },
            PeerMonitoringServiceRequest::LatencyPing(req) => {
                // Return wrong ping counter
                Ok(PeerMonitoringServiceResponse::LatencyPing(
                    LatencyPingResponse {
                        ping_counter: req.ping_counter + 999, // INCORRECT
                    }
                ))
            },
            _ => Err(PeerMonitoringServiceError::InternalError(
                "Malicious error".to_string()
            ))
        }
    }
}

// Test demonstrating that honest nodes don't disconnect
#[tokio::test]
async fn test_byzantine_peer_not_disconnected() {
    let malicious_server = MaliciousPeerMonitoringServer;
    let honest_client = create_honest_peer_monitoring_client();
    
    // Send 100 requests to malicious peer
    for _ in 0..100 {
        let _ = honest_client.request_network_info(malicious_peer_id).await;
    }
    
    // Verify malicious peer is still connected (VULNERABILITY)
    assert!(honest_client.is_peer_connected(malicious_peer_id));
    // Verify failure counter increased but no action taken
    assert_eq!(get_failure_count(malicious_peer_id), 100);
}
```

## Notes

This vulnerability specifically affects Byzantine Fault Tolerance by allowing malicious peers to remain connected and pollute monitoring data. The peer monitoring service is a critical component for network health assessment, and its failure to detect Byzantine behavior weakens the overall security posture of the Aptos network.

### Citations

**File:** peer-monitoring-service/client/src/peer_states/node_info.rs (L108-122)
```rust
    fn handle_monitoring_service_response_error(
        &mut self,
        peer_network_id: &PeerNetworkId,
        error: Error,
    ) {
        // Handle the failure
        self.handle_request_failure();

        // Log the error
        warn!(LogSchema::new(LogEntry::NodeInfoRequest)
            .event(LogEvent::ResponseError)
            .message("Error encountered when requesting node information from the peer!")
            .peer(peer_network_id)
            .error(&error));
    }
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L45-63)
```rust
pub enum ErrorType {
    /// A response or error that's not actively malicious but also doesn't help
    /// us make progress, e.g., timeouts, remote errors, invalid data, etc...
    NotUseful,
    /// A response or error that appears to be actively hindering progress or
    /// attempting to deceive us, e.g., invalid proof.
    Malicious,
}

impl From<ResponseError> for ErrorType {
    fn from(error: ResponseError) -> Self {
        match error {
            ResponseError::InvalidData | ResponseError::InvalidPayloadDataType => {
                ErrorType::NotUseful
            },
            ResponseError::ProofVerificationError => ErrorType::Malicious,
        }
    }
}
```

**File:** peer-monitoring-service/client/src/peer_states/network_info.rs (L116-154)
```rust
        // Sanity check the response depth from the peer metadata
        let network_id = peer_network_id.network_id();
        let is_valid_depth = match network_info_response.distance_from_validators {
            0 => {
                // Verify the peer is a validator and has the correct network id
                let peer_is_validator = peer_metadata.get_connection_metadata().role.is_validator();
                let peer_has_correct_network = match self.base_config.role {
                    RoleType::Validator => network_id.is_validator_network(), // We're a validator
                    RoleType::FullNode => network_id.is_vfn_network(),        // We're a VFN
                };
                peer_is_validator && peer_has_correct_network
            },
            1 => {
                // Verify the peer is a VFN and has the correct network id
                let peer_is_vfn = peer_metadata.get_connection_metadata().role.is_vfn();
                let peer_has_correct_network = match self.base_config.role {
                    RoleType::Validator => network_id.is_vfn_network(), // We're a validator
                    RoleType::FullNode => network_id.is_public_network(), // We're a VFN or PFN
                };
                peer_is_vfn && peer_has_correct_network
            },
            distance_from_validators => {
                // The distance must be less than or equal to the max
                distance_from_validators <= MAX_DISTANCE_FROM_VALIDATORS
            },
        };

        // If the depth did not pass our sanity checks, handle a failure
        if !is_valid_depth {
            warn!(LogSchema::new(LogEntry::NetworkInfoRequest)
                .event(LogEvent::InvalidResponse)
                .peer(peer_network_id)
                .message(&format!(
                    "Peer returned invalid depth from validators: {}",
                    network_info_response.distance_from_validators
                )));
            self.handle_request_failure();
            return;
        }
```

**File:** peer-monitoring-service/client/src/peer_states/latency_info.rs (L59-72)
```rust
    /// Handles a ping failure for the specified peer
    fn handle_request_failure(&self, peer_network_id: &PeerNetworkId) {
        // Update the number of ping failures for the request tracker
        self.request_tracker.write().record_response_failure();

        // TODO: If the number of ping failures is too high, disconnect from the node
        let num_consecutive_failures = self.request_tracker.read().get_num_consecutive_failures();
        if num_consecutive_failures >= self.latency_monitoring_config.max_latency_ping_failures {
            warn!(LogSchema::new(LogEntry::LatencyPing)
                .event(LogEvent::TooManyPingFailures)
                .peer(peer_network_id)
                .message("Too many ping failures occurred for the peer!"));
        }
    }
```

**File:** peer-monitoring-service/client/src/peer_states/request_tracker.rs (L101-104)
```rust
    /// Records a failure for the request
    pub fn record_response_failure(&mut self) {
        self.num_consecutive_request_failures += 1;
    }
```

**File:** peer-monitoring-service/server/src/lib.rs (L186-203)
```rust
            Err(error) => {
                // Log the error and update the counters
                increment_counter(
                    &metrics::PEER_MONITORING_ERRORS_ENCOUNTERED,
                    network_id,
                    error.get_label(),
                );
                error!(LogSchema::new(LogEntry::PeerMonitoringServiceError)
                    .error(&error)
                    .request(&request));

                // Return an appropriate response to the client
                match error {
                    Error::InvalidRequest(error) => {
                        Err(PeerMonitoringServiceError::InvalidRequest(error))
                    },
                    error => Err(PeerMonitoringServiceError::InternalError(error.to_string())),
                }
```
