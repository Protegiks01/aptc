# Audit Report

## Title
Memory Ordering Race Condition Allows Transactions to Commit Without Fulfilled Validation Requirements

## Summary
A critical race condition in `cold_validation.rs`'s `is_commit_blocked()` function allows transactions to be committed before their deferred module validation requirements are fulfilled. This occurs due to incorrect use of Relaxed memory ordering combined with non-monotonic access patterns, violating the function's stated monotonic assumption and breaking consensus determinism.

## Finding Description

The `is_commit_blocked()` function contains a fundamental flaw in its memory ordering semantics that allows it to incorrectly report a transaction as unblocked when validation requirements are still pending. [1](#0-0) 

The function relies on checking two atomic variables with Relaxed ordering: `min_idx_with_unprocessed_validation_requirement` and `deferred_requirements_status[txn_idx]`. The code comment claims that checking in opposite order to the write order ensures correctness "even w. Relaxed ordering": [2](#0-1) 

**This claim is incorrect.** Relaxed memory ordering does NOT provide ordering guarantees across different atomic variables. The validation worker writes:
1. `deferred_requirements_status[txn_idx] = blocked` (Relaxed)
2. `min_idx = txn_idx + 1` (Relaxed) [3](#0-2) [4](#0-3) 

However, the commit thread can observe these writes in reverse order, reading `min_idx = txn_idx + 1` (new value) but `deferred_requirements_status[txn_idx] = 0` (old value), causing it to incorrectly conclude the transaction is not blocked.

The monotonic assumption is violated by the implementation. The commit thread in a loop repeatedly calls `start_commit()` until it returns `None`: [5](#0-4) 

When `is_commit_blocked()` returns `true`, `start_commit()` returns `None` without incrementing `next_to_commit_idx`, causing the next iteration to check the same transaction index again. This creates a larger race window.

**Attack Scenario:**

1. Transaction 4 commits with published Module M, recording validation requirements for transactions 5-9
2. Transaction 5 finishes executing; status changes from `Executing` to `Executed`
3. Validation worker processes requirement for txn 5:
   - Calls `defer_module_validation(5, 1, {M})` - adds M to status
   - Sets `deferred_requirements_status[5] = blocked_incarnation_status(1)` (Relaxed write)
   - Sets `min_idx = 6` (Relaxed write)
4. Commit thread checks txn 5:
   - Reads `min_idx = 6` (observes new value)
   - Reads `deferred_requirements_status[5] = 0` (observes old value due to Relaxed reordering)
   - Concludes NOT blocked
5. **Transaction 5 commits before its deferred module validation is performed**
6. Later validation would fail, but transaction is already committed to blockchain

This breaks the critical invariant that all committed transactions must be fully validated.

## Impact Explanation

**Critical Severity - Consensus/Safety Violation**

This vulnerability allows transactions to be committed without fulfilling their validation requirements, breaking consensus determinism. Different validator nodes experiencing different race condition timings could commit different sets of transactions for the same block, leading to:

1. **Chain splits**: Validators disagree on which transactions are valid
2. **State divergence**: Different validators compute different state roots
3. **Byzantine fault amplification**: Non-Byzantine nodes behave inconsistently
4. **Potential for double-spending**: Invalid transactions could be committed

This directly violates the "Deterministic Execution" invariant: "All validators must produce identical state roots for identical blocks." It also violates the "Transaction Validation" invariant that prologue/epilogue checks must enforce all invariants.

Per Aptos bug bounty criteria, this qualifies as **Critical Severity** ($1,000,000 tier) under "Consensus/Safety violations."

## Likelihood Explanation

**High Likelihood** - This race condition occurs during normal operation whenever:
1. Any transaction publishes Move modules (common during upgrades)
2. Higher-indexed transactions are executing in parallel
3. Timing aligns for the memory reordering

The vulnerability requires no special privileges - any user can publish modules through governance or framework upgrades. The race window is significant because:
- Module publishing is sequential (commit hook)
- Validation processing is asynchronous
- Commit checking is continuous in tight loops
- No synchronization exists between these operations

In high-throughput scenarios with many parallel workers, this race becomes increasingly likely.

## Recommendation

Replace all Relaxed memory orderings with appropriate synchronization:

```rust
pub(crate) fn is_commit_blocked(&self, txn_idx: TxnIndex, incarnation: Incarnation) -> bool {
    // Use Acquire ordering to ensure we see all writes that happened-before
    // the min_idx write
    self.min_idx_with_unprocessed_validation_requirement
        .load(Ordering::Acquire)  // Changed from Relaxed
        <= txn_idx
        || self.deferred_requirements_status[txn_idx as usize].load(Ordering::Acquire)  // Changed from Relaxed
            == blocked_incarnation_status(incarnation)
}
```

And in `validation_requirement_processed`:

```rust
if validation_still_needed {
    self.deferred_requirements_status[txn_idx as usize]
        .fetch_max(blocked_incarnation_status(incarnation), Ordering::Release);  // Changed from Relaxed
}
// ...
self.min_idx_with_unprocessed_validation_requirement
    .store(txn_idx + 1, Ordering::Release);  // Changed from Relaxed
```

And in `record_requirements`:

```rust
let prev_min_idx = self
    .min_idx_with_unprocessed_validation_requirement
    .swap(calling_txn_idx + 1, Ordering::Release);  // Changed from Relaxed
```

This establishes proper Release-Acquire synchronization where:
- Writes use Release ordering (publishes all prior writes)
- Reads use Acquire ordering (observes all prior writes that happened-before the release)

**Alternative:** Enforce true monotonic checking by ensuring `next_to_commit_idx` only increases, and add assertions to detect violations of the monotonic assumption.

## Proof of Concept

The race condition can be demonstrated with a stress test (pseudo-code outline):

```rust
#[test]
fn test_race_condition_commit_without_validation() {
    // Setup: Create scheduler with multiple workers
    let scheduler = SchedulerV2::new(100, 8);
    let statuses = ExecutionStatuses::new(100);
    
    // Thread 1: Execute and finish txn 5
    thread::spawn(|| {
        // Txn 5 executes with module reads
        scheduler.finish_execution(/* txn 5 */);
        // Status is now Executed
    });
    
    // Thread 2: Txn 4 commits with module publish
    thread::spawn(|| {
        scheduler.record_requirements(2, 4, 10, modules);
        // Sets min_idx = 5
    });
    
    // Thread 3: Validation worker processes
    thread::spawn(|| {
        let req = scheduler.get_validation_requirement_to_process(2, 100, &statuses);
        // Sets deferred_status[5] = blocked
        // Sets min_idx = 6
        scheduler.validation_requirement_processed(2, 5, 1, true);
    });
    
    // Thread 4: Commit thread (tight loop)
    thread::spawn(|| {
        loop {
            if let Some((idx, inc)) = scheduler.start_commit() {
                if idx == 5 && !validation_completed {
                    // BUG: Committed txn 5 before validation!
                    panic!("Committed without validation");
                }
            }
        }
    });
    
    // With proper timing, Thread 4 observes:
    // - min_idx = 6 (from Thread 3)
    // - deferred_status[5] = 0 (old value)
    // - Commits txn 5 prematurely
}
```

The test would require careful timing or use of memory ordering analysis tools like Loom to reliably reproduce the race.

---

**Notes:**

This vulnerability demonstrates that the comment's assumption about Relaxed ordering providing ordering guarantees across different atomics is fundamentally flawed. The monotonic assumption stated in the code cannot be relied upon in the current implementation, as parallel execution naturally causes repeated checks of the same transaction index. The combination of incorrect memory ordering and violated monotonic assumptions creates a critical consensus vulnerability.

### Citations

**File:** aptos-move/block-executor/src/cold_validation.rs (L371-374)
```rust
            // min_idx_with_unprocessed_validation_requirement may be increased below, after
            // deferred status is already updated. When checking if txn can be committed, the
            // access order is opposite, ensuring that if minimum index is higher, we will
            // also observe the incremented count below (even w. Relaxed ordering).
```

**File:** aptos-move/block-executor/src/cold_validation.rs (L379-380)
```rust
            self.deferred_requirements_status[txn_idx as usize]
                .fetch_max(blocked_incarnation_status(incarnation), Ordering::Relaxed);
```

**File:** aptos-move/block-executor/src/cold_validation.rs (L399-400)
```rust
                self.min_idx_with_unprocessed_validation_requirement
                    .store(txn_idx + 1, Ordering::Relaxed);
```

**File:** aptos-move/block-executor/src/cold_validation.rs (L418-431)
```rust
    /// Correctness of this method relies on the assumption that calls are for monotonically
    /// increasing txn_idx, which holds for BlockSTMv2 as the method is used to check if the
    /// next idx can be committed.
    pub(crate) fn is_commit_blocked(&self, txn_idx: TxnIndex, incarnation: Incarnation) -> bool {
        // The order of checks is important to avoid a concurrency bugs (since recording
        // happens in the opposite order). We first check that there are no unscheduled
        // requirements below (incl.) the given index, and then that there are no scheduled
        // but yet unfulfilled (validated) requirements for the index.
        self.min_idx_with_unprocessed_validation_requirement
            .load(Ordering::Relaxed)
            <= txn_idx
            || self.deferred_requirements_status[txn_idx as usize].load(Ordering::Relaxed)
                == blocked_incarnation_status(incarnation)
    }
```

**File:** aptos-move/block-executor/src/executor.rs (L1455-1472)
```rust
            while scheduler.commit_hooks_try_lock() {
                // Perform sequential commit hooks.
                while let Some((txn_idx, incarnation)) = scheduler.start_commit()? {
                    self.prepare_and_queue_commit_ready_txn(
                        txn_idx,
                        incarnation,
                        num_txns,
                        executor,
                        block,
                        num_workers as usize,
                        runtime_environment,
                        scheduler_wrapper,
                        shared_sync_params,
                    )?;
                }

                scheduler.commit_hooks_unlock();
            }
```
