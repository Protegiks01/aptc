# Audit Report

## Title
Missing PersistedAuxiliaryInfo Auto-Fill Masks Database Corruption and Enables Consensus Divergence

## Summary
The `get_persisted_auxiliary_info_iter` function automatically fills missing auxiliary information with `PersistedAuxiliaryInfo::None` instead of failing, allowing verification to continue with incorrect metadata. This masks database corruption and can cause consensus divergence when transactions use the `monotonically_increasing_counter` feature, as different validators may produce different execution results depending on their auxiliary info state.

## Finding Description

The vulnerability exists in the interaction between three components:

**1. Auto-Fill Behavior in Database Layer** [1](#0-0) 

When auxiliary info is missing from the database (e.g., due to corruption or incomplete commit), the iterator silently fills gaps with `PersistedAuxiliaryInfo::None` rather than returning an error.

**2. Non-Atomic Parallel Commit** [2](#0-1) [3](#0-2) 

The commit process writes auxiliary info in parallel with other transaction data without atomic guarantees. The TODO comment explicitly acknowledges the inconsistency risk during crashes.

**3. Verification Using Corrupted Data** [4](#0-3) [5](#0-4) 

The replay verification tool extracts the auto-filled `PersistedAuxiliaryInfo::None` and uses it for re-execution, which affects transactions using the transaction index.

**4. Production Feature Dependency** [6](#0-5) 

The `monotonically_increasing_counter_internal` native function requires valid transaction index. When `PersistedAuxiliaryInfo::None` is used, it converts to `TransactionIndexKind::NotAvailable` and causes the transaction to abort. [7](#0-6) 

This feature is used in production by the trading/order book module for generating unique order IDs.

**Exploitation Scenario:**

1. A validator node crashes during the parallel commit phase
2. Transaction data is written to disk but auxiliary info is not (non-atomic)
3. Node restarts and appears to have complete data
4. When executing new transactions that call `monotonically_increasing_counter`:
   - Validator with corrupted DB: Uses auto-filled `None`, transaction aborts
   - Validator with intact DB: Uses correct auxiliary info, transaction succeeds
5. Different execution results → different state roots → consensus failure

**Invariant Violations:**

- **Deterministic Execution**: Different validators produce different results for identical transactions
- **State Consistency**: Missing metadata is not detected, allowing corrupted state to persist
- **Data Integrity**: Database corruption is masked rather than reported

## Impact Explanation

**Severity: HIGH**

This qualifies as **"Significant protocol violations"** under the High severity category because:

1. **Consensus Divergence**: If validators have different auxiliary info states due to corruption, they will produce different execution results for transactions using `monotonically_increasing_counter`. This breaks the fundamental consensus safety property.

2. **Silent Data Corruption**: The auto-fill behavior masks database integrity issues. Verification passes for transactions that don't use the feature, giving false confidence in data integrity.

3. **Production Feature Impact**: The trading/order book module uses this feature. Corrupted auxiliary info would cause order placement transactions to fail unexpectedly or behave differently across validators.

4. **Misleading Error Messages**: When verification fails, the error indicates execution mismatch rather than missing auxiliary info, making debugging difficult.

While this doesn't reach Critical severity (no direct fund loss or RCE), it represents a significant fault tolerance and data integrity weakness that can lead to consensus issues.

## Likelihood Explanation

**Likelihood: MEDIUM-LOW**

The vulnerability requires specific conditions:

1. **Database crash during commit**: The parallel write operations must be interrupted at a point where some databases are written but auxiliary info is not. This is acknowledged as possible by the TODO comment in the codebase.

2. **Transactions using affected feature**: Only transactions calling `monotonically_increasing_counter` will exhibit different behavior. Currently this is limited to experimental trading modules, but usage may expand.

3. **No immediate detection**: The corrupted state must not be detected during restart, allowing the node to continue operating.

However, database crashes are realistic operational scenarios, and the TODO comment indicates the developers are aware this inconsistency can occur.

## Recommendation

**Primary Fix: Fail Fast on Missing Data**

Modify `get_persisted_auxiliary_info_iter` to only auto-fill `None` for versions before a known "auxiliary info start version", and return an error for missing data after that point:

```rust
pub(crate) fn get_persisted_auxiliary_info_iter(
    &self,
    start_version: Version,
    num_persisted_auxiliary_info: usize,
) -> Result<Box<dyn Iterator<Item = Result<PersistedAuxiliaryInfo>> + '_>> {
    let first_persisted_version = self.get_first_persisted_version()?;
    
    // Only allow auto-fill for versions before auxiliary info was introduced
    if start_version >= first_persisted_version {
        // After this point, all auxiliary info MUST exist
        let iter = self.db.iter::<PersistedAuxiliaryInfoSchema>()?;
        iter.seek(&start_version)?;
        Ok(Box::new(iter.expect_continuous_versions(start_version, num_persisted_auxiliary_info)?))
    } else {
        // Existing auto-fill logic for backward compatibility
        // ... (current implementation)
    }
}
```

**Secondary Fix: Atomic Commit**

Implement proper atomic commit across all databases as indicated by the TODO: [2](#0-1) 

Use a two-phase commit protocol or single atomic batch write to ensure all transaction data (including auxiliary info) is written together or not at all.

**Tertiary Fix: Better Error Reporting**

In `replay_on_archive.rs`, explicitly check for `PersistedAuxiliaryInfo::None` and report it as a data integrity issue:

```rust
if persisted_aux_info == PersistedAuxiliaryInfo::None {
    warn!("Missing auxiliary info at version {}, database may be corrupted", version);
}
```

## Proof of Concept

**Reproduction Steps:**

1. Set up a test validator node with auxiliary info feature enabled
2. Execute transactions using `monotonically_increasing_counter` (e.g., trading order placement)
3. During execution, simulate a crash by killing the process during the commit phase
4. Restart the node and check database consistency
5. Attempt to replay transactions using the db-tool
6. Observe that verification either:
   - Passes silently for transactions not using the feature (masking corruption)
   - Fails with execution mismatch error for transactions using the feature (unclear root cause)

**Expected Behavior:** Database tool should detect missing auxiliary info and report "Data integrity error: Missing PersistedAuxiliaryInfo at version X"

**Actual Behavior:** Auto-fills with `None`, masks corruption for some transactions, gives misleading errors for others

**Notes**

This vulnerability represents a data integrity and fault tolerance issue rather than a direct attack vector. However, it violates the critical "Deterministic Execution" invariant and can lead to consensus divergence in production scenarios. The explicit TODO comment acknowledging the inconsistency risk, combined with production usage of the dependent feature, makes this a valid HIGH severity finding that requires remediation to ensure blockchain reliability and consensus safety.

### Citations

**File:** storage/aptosdb/src/ledger_db/persisted_auxiliary_info_db.rs (L80-84)
```rust
        let num_none = std::cmp::min(
            num_persisted_auxiliary_info,
            version.saturating_sub(start_version) as usize,
        );
        let none_iter = itertools::repeat_n(Ok(PersistedAuxiliaryInfo::None), num_none);
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L272-275)
```rust
            // TODO(grao): Write progress for each of the following databases, and handle the
            // inconsistency at the startup time.
            //
            // TODO(grao): Consider propagating the error instead of panic, if necessary.
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L300-305)
```rust
            s.spawn(|_| {
                self.ledger_db
                    .persisted_auxiliary_info_db()
                    .commit_auxiliary_info(chunk.first_version, chunk.persisted_auxiliary_infos)
                    .unwrap()
            });
```

**File:** storage/db-tool/src/replay_on_archive.rs (L270-276)
```rust
            let (
                input_txn,
                persisted_aux_info,
                expected_txn_info,
                expected_event,
                expected_writeset,
            ) = item?;
```

**File:** storage/db-tool/src/replay_on_archive.rs (L370-373)
```rust
            cur_persisted_aux_info
                .iter()
                .map(|info| AuxiliaryInfo::new(*info, None))
                .collect(),
```

**File:** aptos-move/framework/src/natives/transaction_context.rs (L192-204)
```rust
        let (reserved_byte, transaction_index) = match transaction_index_kind {
            TransactionIndexKind::BlockExecution { transaction_index } => {
                (0u128, transaction_index)
            },
            TransactionIndexKind::ValidationOrSimulation { transaction_index } => {
                (1u128, transaction_index)
            },
            TransactionIndexKind::NotAvailable => {
                return Err(SafeNativeError::Abort {
                    abort_code: error::invalid_state(abort_codes::ETRANSACTION_INDEX_NOT_AVAILABLE),
                });
            },
        };
```

**File:** aptos-move/framework/aptos-experimental/sources/trading/order_book/order_book_types.move (L75-78)
```text
    public fun next_order_id(): OrderIdType {
        // reverse bits to make order ids random, so indices on top of them are shuffled.
        OrderIdType { order_id: reverse_bits(transaction_context::monotonically_increasing_counter()) }
    }
```
