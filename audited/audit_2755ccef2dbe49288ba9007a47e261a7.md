# Audit Report

## Title
Missing Cryptographic Verification in Epoch Ending Backup Allows Invalid Waypoint Creation

## Summary
The `get_waypoint()` function in the epoch ending backup process deserializes BCS-encoded data as `LedgerInfoWithSignatures` without performing any cryptographic signature verification. This allows an attacker who can control the backup service response (via MITM or compromised server) to inject malicious data that creates invalid waypoints, which can later bypass signature verification during restore operations. [1](#0-0) 

## Finding Description

The backup process fetches epoch-ending ledger infos from a backup service and deserializes them using BCS without verifying their cryptographic signatures. The data source is an HTTP connection (default `http://localhost:6186`) that can be configured to point to remote servers. [2](#0-1) 

During backup, for each received ledger info:
1. BCS bytes are deserialized as `LedgerInfoWithSignatures`
2. Only the epoch number is validated against the expected value
3. A waypoint is created via `Waypoint::new_epoch_boundary()` 
4. **No signature verification occurs** [3](#0-2) 

The created waypoints are stored in the backup manifest and can later be used as trusted waypoints during restore. When a trusted waypoint is provided during restore, signature verification is explicitly skipped: [4](#0-3) 

**Attack Path:**
1. Attacker performs MITM on HTTP connection to backup service OR compromises the backup service
2. Attacker crafts malicious BCS bytes that deserialize as `LedgerInfoWithSignatures` with attacker-controlled fields (state root, epoch state, version, etc.)
3. Backup process creates waypoints from this malicious data without verification
4. Waypoints are stored in the manifest
5. Victim later performs restore using `--trust-waypoint` with one of these malicious waypoints
6. Invalid ledger info is restored to database, bypassing signature verification
7. Node operates with corrupted state (wrong state roots, invalid validator sets)

Since BCS is schema-less and doesn't include type information in serialized data, an attacker can craft arbitrary bytes that successfully deserialize as the expected type structure, regardless of whether they represent legitimate blockchain data.

## Impact Explanation

This vulnerability constitutes a **High Severity** issue under the Aptos bug bounty criteria for "Significant protocol violations."

The impact includes:
- **Consensus Safety Violation**: Different nodes restoring from compromised backups will have inconsistent state, violating the "Deterministic Execution" invariant
- **State Corruption**: Invalid state roots, transaction accumulators, and epoch states (validator sets) can be injected into the database
- **Validator Set Manipulation**: Malicious epoch states can alter which validators are considered active
- **Chain Fork Risk**: If multiple validators restore from the same compromised backup with trusted waypoints, they may diverge from the canonical chain

The vulnerability breaks critical invariants:
1. **Consensus Safety** - nodes may accept invalid ledger infos as trusted
2. **Deterministic Execution** - different nodes may restore different states
3. **Cryptographic Correctness** - signature verification is bypassed

## Likelihood Explanation

**Likelihood: Medium**

The attack requires specific conditions:
- Backup service must be configured to a remote server (common in cloud deployments) OR attacker must have local network access
- Connection must be HTTP without additional security (default configuration)
- Victim must later perform restore with `--trust-waypoint` using the compromised manifest

While the default configuration uses localhost, production deployments often configure remote backup services for redundancy. The lack of HTTPS enforcement or any signature verification makes this attack feasible for attackers with network access.

The HTTP client is created without TLS configuration: [5](#0-4) 

## Recommendation

Implement cryptographic verification of `LedgerInfoWithSignatures` during the backup process before creating waypoints:

```rust
fn get_waypoint(record: &[u8], epoch: u64, verifier: &ValidatorVerifier) -> Result<Waypoint> {
    let li: LedgerInfoWithSignatures = bcs::from_bytes(record)?;
    ensure!(
        li.ledger_info().epoch() == epoch,
        "Epoch not expected. expected: {}, actual: {}.",
        li.ledger_info().epoch(),
        epoch,
    );
    // Add signature verification
    li.verify_signatures(verifier)?;
    Waypoint::new_epoch_boundary(li.ledger_info())
}
```

Additionally:
1. Enforce HTTPS for remote backup service connections
2. Add certificate pinning or validation for remote backup services
3. Document the trust assumptions for backup service connections
4. Consider adding a warning when backup service is not localhost

## Proof of Concept

```rust
// PoC demonstrating the vulnerability
use bcs;
use aptos_types::{
    ledger_info::{LedgerInfo, LedgerInfoWithSignatures, LedgerInfoWithV0},
    block_info::BlockInfo,
    aggregate_signature::AggregateSignature,
    waypoint::Waypoint,
};
use aptos_crypto::hash::HashValue;

fn main() {
    // Attacker crafts malicious LedgerInfo with chosen values
    let malicious_ledger_info = LedgerInfo::new(
        BlockInfo::new(
            999,                    // Chosen epoch
            10000,                  // Arbitrary round
            HashValue::zero(),      // Chosen state root (invalid)
            HashValue::zero(),      // Arbitrary executed state
            100000,                 // Chosen version
            1000000,                // Arbitrary timestamp
            Some(EpochState::empty()), // Manipulated validator set
        ),
        HashValue::zero(),
    );
    
    // Create with empty/invalid signatures (not checked during backup)
    let malicious_li_with_sigs = LedgerInfoWithSignatures::V0(
        LedgerInfoWithV0::new(
            malicious_ledger_info,
            AggregateSignature::empty(),
        )
    );
    
    // Serialize to BCS
    let malicious_bcs = bcs::to_bytes(&malicious_li_with_sigs).unwrap();
    
    // This will deserialize successfully in get_waypoint()
    // and create an invalid waypoint without signature verification
    let deserialized: LedgerInfoWithSignatures = bcs::from_bytes(&malicious_bcs).unwrap();
    let waypoint = Waypoint::new_epoch_boundary(deserialized.ledger_info()).unwrap();
    
    println!("Malicious waypoint created: {}", waypoint);
    // This waypoint can now be used with --trust-waypoint to bypass verification
}
```

## Notes

The vulnerability exists because the backup process assumes the backup service is a trusted source. However, the configurable nature of the backup service address combined with the lack of HTTPS enforcement and signature verification creates an exploitable attack surface. The issue is exacerbated by the trusted waypoint mechanism in restore, which explicitly bypasses signature verification when waypoints are provided.

### Citations

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/backup.rs (L84-109)
```rust
            .client
            .get_epoch_ending_ledger_infos(self.start_epoch, self.end_epoch)
            .await?;
        let mut current_epoch: u64 = self.start_epoch;
        let mut chunk_first_epoch: u64 = self.start_epoch;

        while let Some(record_bytes) = ledger_infos_file.read_record_bytes().await? {
            if should_cut_chunk(&chunk_bytes, &record_bytes, self.max_chunk_size) {
                let chunk = self
                    .write_chunk(
                        &backup_handle,
                        &chunk_bytes,
                        chunk_first_epoch,
                        current_epoch - 1,
                    )
                    .await?;
                chunks.push(chunk);
                chunk_bytes = vec![];
                chunk_first_epoch = current_epoch;
            }

            waypoints.push(Self::get_waypoint(&record_bytes, current_epoch)?);
            chunk_bytes.extend((record_bytes.len() as u32).to_be_bytes());
            chunk_bytes.extend(&record_bytes);
            current_epoch += 1;
        }
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/backup.rs (L140-149)
```rust
    fn get_waypoint(record: &[u8], epoch: u64) -> Result<Waypoint> {
        let li: LedgerInfoWithSignatures = bcs::from_bytes(record)?;
        ensure!(
            li.ledger_info().epoch() == epoch,
            "Epoch not expected. expected: {}, actual: {}.",
            li.ledger_info().epoch(),
            epoch,
        );
        Waypoint::new_epoch_boundary(li.ledger_info())
    }
```

**File:** storage/backup/backup-cli/src/utils/backup_service_client.rs (L23-31)
```rust
pub struct BackupServiceClientOpt {
    #[clap(
        long = "backup-service-address",
        default_value = "http://localhost:6186",
        help = "Backup service address. By default a Aptos Node runs the backup service serving \
        on tcp port 6186 to localhost only."
    )]
    pub address: String,
}
```

**File:** storage/backup/backup-cli/src/utils/backup_service_client.rs (L45-53)
```rust
    pub fn new(address: String) -> Self {
        Self {
            address,
            client: reqwest::Client::builder()
                .no_proxy()
                .build()
                .expect("Http client should build."),
        }
    }
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L129-147)
```rust
                if let Some(wp_trusted) = self.trusted_waypoints.get(&wp_li.version()) {
                    ensure!(
                        *wp_trusted == wp_li,
                        "Waypoints don't match. In backup: {}, trusted: {}",
                        wp_li,
                        wp_trusted,
                    );
                } else if let Some(pre_li) = previous_li {
                    pre_li
                        .ledger_info()
                        .next_epoch_state()
                        .ok_or_else(|| {
                            anyhow!(
                                "Next epoch state not found from LI at epoch {}.",
                                pre_li.ledger_info().epoch()
                            )
                        })?
                        .verify(&li)?;
                }
```
