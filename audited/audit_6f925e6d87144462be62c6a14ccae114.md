# Audit Report

## Title
Schema Derive Macro Bypasses #[serde(skip)] Privacy Controls Leading to Sensitive Field Leakage in Logs

## Summary
The `Schema` procedural macro in `aptos-log-derive` does not respect `#[serde(skip)]` attributes on struct fields, causing sensitive data marked for serialization exclusion to be logged anyway. This creates a developer expectation mismatch that could lead to accidental disclosure of sensitive information in node logs.

## Finding Description

The `derive(Schema)` procedural macro generates logging implementations for structs but does not check for or respect serde privacy attributes like `#[serde(skip)]` or `#[serde(skip_serializing)]`. [1](#0-0) 

The macro iterates over ALL fields in a struct and generates visitor code for each field without filtering based on serde attributes: [2](#0-1) 

When `from_serde()` is called on a field value, it wraps that individual field for later serialization during logging: [3](#0-2) 

The logging system then serializes each field individually: [4](#0-3) 

**The Vulnerability**: A developer might create a struct with both `Serialize` and `Schema` derives, mark sensitive fields with `#[serde(skip)]` expecting them to be excluded from all serialization contexts including logs, but the Schema implementation will log them anyway because it accesses fields directly rather than through serde's serialization of the parent struct.

Example scenario:
```rust
#[derive(Serialize, Schema)]
struct AuthConfig {
    username: String,
    #[serde(skip)]
    password: String,
}
```

When logged via Schema, the `password` field will be included in logs despite the `#[serde(skip)]` attribute.

## Impact Explanation

This is a **Medium severity** information disclosure issue per Aptos bug bounty criteria. While there are no current instances of this pattern in the production codebase, the design flaw creates a dangerous developer footgun:

1. **Information Disclosure**: Sensitive data (passwords, private keys, tokens) could be leaked into node logs
2. **Principle of Least Surprise Violation**: Developers reasonably expect `#[serde(skip)]` to apply to all serialization contexts
3. **Defense-in-Depth Failure**: The logging system should respect serialization privacy controls

The codebase shows awareness of this issue through alternative patterns like custom `Debug` implementations and `SilentDebug`/`SilentDisplay` derives for cryptographic keys, but the Schema derive lacks this protection.

## Likelihood Explanation

**Likelihood: Medium** - This vulnerability requires developer error to trigger:
- A developer must add both `Serialize` and `Schema` derives to the same struct
- The struct must contain sensitive fields marked with `#[serde(skip)]`
- The struct must be logged using the Schema implementation

However, the likelihood increases because:
- The pattern is natural when building config/state structs that need both serialization and logging
- The error is non-obvious and would not be caught in code review
- Logs are often collected centrally, amplifying the disclosure impact

## Recommendation

Modify the Schema derive macro to check for and respect serde skip attributes:

```rust
fn should_skip_field(attrs: &[Attribute]) -> bool {
    for attr in attrs {
        if let Ok(Meta::List(MetaList { path, nested, .. })) = attr.parse_meta() {
            if path.segments.iter().any(|s| s.ident == "serde") {
                for meta in nested {
                    if let NestedMeta::Meta(Meta::Path(path)) = meta {
                        if path.segments.first().map(|s| s.ident.to_string()) == Some("skip".to_string()) {
                            return true;
                        }
                    }
                }
            }
        }
    }
    false
}

// In the derive function, filter fields:
let fields: Vec<StructField> = fields
    .iter()
    .filter(|f| !should_skip_field(&f.attrs))
    .map(|f| { /* existing logic */ })
    .collect();
```

Alternatively, introduce a Schema-specific attribute like `#[schema(skip)]` and document that serde attributes are not automatically respected.

## Proof of Concept

```rust
// File: test_serde_skip_bypass.rs
use aptos_log_derive::Schema;
use aptos_logger::{info, AptosData};
use serde::Serialize;

#[derive(Serialize, Schema)]
struct SensitiveConfig {
    pub api_endpoint: String,
    #[serde(skip)]
    pub api_secret: String,
}

#[test]
fn test_serde_skip_is_bypassed() {
    AptosData::init_for_testing();
    
    let config = SensitiveConfig {
        api_endpoint: "https://api.example.com".to_string(),
        api_secret: "super_secret_token_12345".to_string(),
    };
    
    // When serialized via serde, api_secret is skipped
    let json = serde_json::to_string(&config).unwrap();
    assert!(!json.contains("super_secret_token"));
    
    // But when logged via Schema, api_secret is included
    info!(config);  // This WILL log the api_secret field
    
    // Expected: api_secret should not appear in logs
    // Actual: api_secret appears in logs
}
```

**Notes**

This vulnerability represents a design flaw in the interaction between two independent serialization systems. While the current codebase does not exhibit exploitable instances, the framework design permits dangerous usage patterns. The cryptographic key types properly use `SilentDebug`/`SilentDisplay` to prevent logging, demonstrating that the codebase is aware of sensitive data protection needs, but the Schema derive lacks this protection mechanism.

The fix should either make Schema respect serde attributes or clearly document the independence of these systems and provide Schema-specific skip attributes.

### Citations

**File:** crates/aptos-log-derive/src/lib.rs (L27-41)
```rust
    let fields: Vec<StructField> = fields
        .iter()
        .map(|f| {
            let ty = f.ty.clone();
            let value_type = extract_attr(&f.attrs);

            let inner_ty = extract_internal_type(&ty).cloned();
            StructField {
                value_type,
                ident: f.ident.clone(),
                ty: f.ty.clone(),
                inner_ty,
            }
        })
        .collect();
```

**File:** crates/aptos-log-derive/src/lib.rs (L70-90)
```rust
    let visits = fields.iter().map(|f| {
        let ident = f.ident.as_ref().unwrap();
        let ident_str = ident.to_string();

        let from_fn = match f.value_type {
            Some(ValueType::Display) => &from_display,
            Some(ValueType::Debug) => &from_debug,
            Some(ValueType::Serde) | None => &from_serde,
        };
        if f.inner_ty.is_some() {
            quote! {
                if let Some(#ident) = &self.#ident {
                    #visitor.visit_pair(#key_new(#ident_str), #from_fn(#ident));
                }
            }
        } else {
            quote! {
                #visitor.visit_pair(#key_new(#ident_str), #from_fn(&self.#ident));
            }
        }
    });
```

**File:** crates/aptos-logger/src/kv.rs (L57-59)
```rust
    pub fn from_serde<T: serde::Serialize>(value: &'v T) -> Self {
        Value::Serde(value)
    }
```

**File:** crates/aptos-logger/src/aptos_logger.rs (L167-187)
```rust
        impl Visitor for JsonVisitor<'_> {
            fn visit_pair(&mut self, key: Key, value: Value<'_>) {
                let v = match value {
                    Value::Debug(d) => serde_json::Value::String(
                        TruncatedLogString::from(format!("{:?}", d)).into(),
                    ),
                    Value::Display(d) => {
                        serde_json::Value::String(TruncatedLogString::from(d.to_string()).into())
                    },
                    Value::Serde(s) => match serde_json::to_value(s) {
                        Ok(value) => value,
                        Err(e) => {
                            // Log and skip the value that can't be serialized
                            eprintln!("error serializing structured log: {} for key {:?}", e, key);
                            return;
                        },
                    },
                };

                self.0.insert(key, v);
            }
```
