# Audit Report

## Title
Unbounded Per-Block Module Cache Allows Memory Exhaustion via Unmetered Module Metadata Access

## Summary
The `unmetered_get_module_state_value_metadata` method can trigger unbounded module loading into the per-block module cache during transaction execution. When processing blocks with multiple module publications, repeated unmetered calls accumulate modules in the per-block cache (`SyncModuleCache`/`UnsyncModuleCache`) without any size limit enforcement, potentially causing validator node memory exhaustion and OOM crashes.

## Finding Description
The vulnerability exists in the interaction between the `unmetered_get_module_state_value_metadata` method and the per-block module caching mechanism: [1](#0-0) 

When `LatestView` implements this trait method, it calls `get_module_or_build_with`: [2](#0-1) 

This triggers the `build` method which loads modules from storage: [3](#0-2) 

The loaded modules are then inserted into the per-block cache (`SyncModuleCache`), which has no size limit: [4](#0-3) [5](#0-4) 

The primary call site is in write operation conversion, which happens after transaction execution: [6](#0-5) 

**Attack Scenario:**
1. Attacker publishes many large modules (e.g., 100KB each) to the blockchain over time
2. These modules eventually get evicted from the global module cache or are never cached
3. Attacker submits a block containing numerous transactions that republish these existing modules
4. For each module republication, `convert_modules_into_write_ops` calls `unmetered_get_module_state_value_metadata`
5. This loads the existing (old) version of each module from storage into the per-block cache to determine if the write is a modification
6. Since the per-block cache has no size limit, it grows unboundedly during block execution
7. Combined with the global cache (which can also exceed its 1GB limit during block execution since the limit is only enforced between blocks), total memory consumption can exceed available RAM
8. Validator node crashes with OOM error

The global cache size limit is only checked between blocks, not during execution: [7](#0-6) 

## Impact Explanation
This vulnerability qualifies as **High Severity** under the Aptos Bug Bounty program criteria:

- **Validator node slowdowns**: Memory pressure causes performance degradation
- **API crashes**: OOM crashes terminate the validator process
- **Significant protocol violations**: Breaks the "Resource Limits" invariant (#9) and "Move VM Safety" invariant (#3)

If exploited successfully:
- Affected validators crash and cannot participate in consensus
- Network liveness is degraded if multiple validators are affected
- Block execution fails, requiring node restart
- Repeated attacks could cause persistent availability issues

While not reaching Critical severity (no permanent state corruption or fund loss), the impact on network availability and validator stability is significant.

## Likelihood Explanation
**Likelihood: Medium-High**

The attack is feasible because:
- Any user can publish modules (costs gas but no special privileges required)
- Block capacity allows thousands of transactions
- Module publications are legitimate operations
- No runtime checks prevent per-block cache growth

**Constraints that reduce likelihood:**
- Publishing large modules costs significant gas
- Block gas limits constrain total modules per block
- Most framework modules are already cached (small and frequently used)
- Requires coordinating many transactions in a single block

**Realistic scenario:**
- Attacker publishes 5,000 modules of 100KB each over multiple blocks (~500MB total)
- Waits for global cache flush or targets uncached modules
- Submits block with 5,000 transactions republishing these modules
- Per-block cache accumulates ~500MB + global cache ~1GB = ~1.5GB
- On memory-constrained validators, this triggers OOM

## Recommendation
Implement size limits and eviction policies for the per-block module cache:

1. **Add per-block cache size limit:** Track total size of modules in `SyncModuleCache`/`UnsyncModuleCache` and enforce a maximum (e.g., 256MB)

2. **Fail gracefully:** When the limit is reached, either:
   - Return an error causing transaction to abort with gas charge
   - Use LRU eviction to remove least-recently-used modules

3. **Charge gas for unmetered calls:** While called "unmetered", these calls should still have an implicit cost tied to module size to prevent abuse

4. **Enforce global cache limit during block execution:** Check global cache size periodically during block execution, not just between blocks

**Proposed fix (pseudocode):**
```rust
impl SyncModuleCache {
    fn get_module_or_build_with(...) -> VMResult<...> {
        // Check if adding would exceed limit
        if let Some(module) = builder.build(key)? {
            let module_size = module.extension().size_in_bytes();
            if self.total_size() + module_size > MAX_PER_BLOCK_CACHE_SIZE {
                return Err(PartialVMError::new(
                    StatusCode::MEMORY_LIMIT_EXCEEDED
                ).finish(Location::Undefined));
            }
            // Insert and track size
            self.insert_and_track_size(key, module);
        }
    }
}
```

## Proof of Concept
```rust
// Proof of Concept demonstrating the vulnerability
// This would be a Rust test in aptos-move/block-executor/src/code_cache.rs

#[test]
fn test_per_block_cache_memory_exhaustion() {
    use aptos_types::state_store::MockStateView;
    use move_core_types::language_storage::ModuleId;
    use move_core_types::account_address::AccountAddress;
    use move_core_types::identifier::Identifier;
    
    // Setup: Create a state view with many large modules
    let mut state_data = HashMap::new();
    let large_module_bytes = vec![0u8; 100_000]; // 100KB module
    
    // Add 10,000 large modules to state
    for i in 0..10_000 {
        let module_id = ModuleId::new(
            AccountAddress::random(),
            Identifier::new(format!("module_{}", i)).unwrap()
        );
        let state_key = StateKey::module_id(&module_id);
        let state_value = StateValue::new_legacy(large_module_bytes.clone().into());
        state_data.insert(state_key, state_value);
    }
    
    let state_view = MockStateView::new(state_data);
    let env = AptosEnvironment::new(&state_view);
    let mut guard = AptosModuleCacheManagerGuard::none_for_state_view(&state_view);
    
    let global_cache = guard.module_cache();
    let versioned_map = MVHashMap::new(); // Per-block cache
    
    // Simulate block execution with many module metadata accesses
    for i in 0..10_000 {
        let module_id = ModuleId::new(
            AccountAddress::random(),
            Identifier::new(format!("module_{}", i)).unwrap()
        );
        
        // This call loads each module into per-block cache
        let latest_view = LatestView::new(
            /* base_view */ &state_view,
            /* versioned_cache */ &versioned_map,
            /* global_cache */ global_cache,
            /* environment */ &env,
        );
        
        // Unmetered call that loads module
        let _metadata = latest_view.unmetered_get_module_state_value_metadata(
            module_id.address(),
            module_id.name()
        ).unwrap();
    }
    
    // Assert: Per-block cache now contains ~1GB of modules
    let cache_size = versioned_map.module_cache().num_modules();
    assert_eq!(cache_size, 10_000);
    // Expected memory: 10,000 * 100KB = 1GB in per-block cache alone
}
```

## Notes
This vulnerability demonstrates a critical oversight in resource management where "unmetered" operations can still cause resource exhaustion. The fix requires balancing between:
- Performance (caching improves execution speed)
- Security (preventing unbounded memory growth)
- User experience (avoiding spurious failures for legitimate operations)

The per-block cache serves an important purpose for transaction validation and parallel execution, so any fix must preserve its functionality while adding necessary bounds checking.

### Citations

**File:** aptos-move/aptos-vm-types/src/module_and_script_storage/module_storage.rs (L15-19)
```rust
    fn unmetered_get_module_state_value_metadata(
        &self,
        address: &AccountAddress,
        module_name: &IdentStr,
    ) -> PartialVMResult<Option<StateValueMetadata>>;
```

**File:** aptos-move/block-executor/src/code_cache.rs (L52-74)
```rust
    fn build(
        &self,
        key: &Self::Key,
    ) -> VMResult<Option<ModuleCode<Self::Deserialized, Self::Verified, Self::Extension>>> {
        let constructed_key = T::Key::from_address_and_module_name(key.address(), key.name());
        self.get_raw_base_value(&constructed_key)
            .map_err(|err| err.finish(Location::Undefined))?
            .map(|mut state_value| {
                // TODO: remove this once framework on mainnet is using the new option module
                if let Some(bytes) = self
                    .runtime_environment()
                    .get_module_bytes_override(key.address(), key.name())
                {
                    state_value.set_bytes(bytes);
                }
                let extension = Arc::new(AptosModuleExtension::new(state_value));
                let compiled_module = self
                    .runtime_environment()
                    .deserialize_into_compiled_module(extension.bytes())?;
                Ok(ModuleCode::from_deserialized(compiled_module, extension))
            })
            .transpose()
    }
```

**File:** aptos-move/block-executor/src/code_cache.rs (L199-221)
```rust
    fn unmetered_get_module_state_value_metadata(
        &self,
        address: &AccountAddress,
        module_name: &IdentStr,
    ) -> PartialVMResult<Option<StateValueMetadata>> {
        let id = ModuleId::new(*address, module_name.to_owned());
        let result = self
            .get_module_or_build_with(&id, self)
            .map_err(|err| err.to_partial())?;

        // In order to test the module cache with combinatorial tests, we embed the version
        // information into the state value metadata (execute_transaction has access via
        // AptosModuleStorage trait only).
        #[cfg(test)]
        fail_point!("module_test", |_| {
            Ok(result.clone().map(|(_, version)| {
                let v = version.unwrap_or(u32::MAX) as u64;
                StateValueMetadata::legacy(v, &CurrentTimeMicroseconds { microseconds: v })
            }))
        });

        Ok(result.map(|(module, _)| module.extension().state_value_metadata().clone()))
    }
```

**File:** third_party/move/move-vm/types/src/code/cache/module_cache.rs (L366-380)
```rust
pub struct SyncModuleCache<K, DC, VC, E, V> {
    module_cache: DashMap<K, CachePadded<VersionedModuleCode<DC, VC, E, V>>>,
}

impl<K, DC, VC, E, V> SyncModuleCache<K, DC, VC, E, V>
where
    K: Eq + Hash + Clone,
    VC: Deref<Target = Arc<DC>>,
    V: Clone + Default + Ord,
{
    /// Returns a new empty module cache.
    pub fn empty() -> Self {
        Self {
            module_cache: DashMap::new(),
        }
```

**File:** third_party/move/move-vm/types/src/code/cache/module_cache.rs (L487-518)
```rust
    fn get_module_or_build_with(
        &self,
        key: &Self::Key,
        builder: &dyn ModuleCodeBuilder<
            Key = Self::Key,
            Deserialized = Self::Deserialized,
            Verified = Self::Verified,
            Extension = Self::Extension,
        >,
    ) -> VMResult<
        Option<(
            Arc<ModuleCode<Self::Deserialized, Self::Verified, Self::Extension>>,
            Self::Version,
        )>,
    > {
        use dashmap::mapref::entry::Entry::*;

        if let Some(v) = self.module_cache.get(key).as_deref() {
            return Ok(Some(v.as_module_code_and_version()));
        }

        Ok(match self.module_cache.entry(key.clone()) {
            Occupied(entry) => Some(entry.get().as_module_code_and_version()),
            Vacant(entry) => builder.build(key)?.map(|module| {
                entry
                    .insert(CachePadded::new(
                        VersionedModuleCode::new_with_default_version(module),
                    ))
                    .as_module_code_and_version()
            }),
        })
    }
```

**File:** aptos-move/aptos-vm/src/move_vm_ext/write_op_converter.rs (L79-128)
```rust
    pub(crate) fn convert_modules_into_write_ops(
        &self,
        module_storage: &impl AptosModuleStorage,
        verified_module_bundle: impl Iterator<Item = (ModuleId, Bytes)>,
    ) -> PartialVMResult<BTreeMap<StateKey, ModuleWrite<WriteOp>>> {
        let mut writes = BTreeMap::new();
        for (module_id, bytes) in verified_module_bundle {
            let addr = module_id.address();
            let name = module_id.name();

            // INVARIANT:
            //   No need to charge for module metadata access because the write of a module must
            //   have been already charged for when processing module bundle. Here, it is used for
            //   conversion into a write op - if the metadata exists, it is a modification.
            let state_value_metadata =
                module_storage.unmetered_get_module_state_value_metadata(addr, name)?;
            let op = if state_value_metadata.is_some() {
                Op::Modify(bytes)
            } else {
                Op::New(bytes)
            };

            let write_op = self.convert(
                state_value_metadata,
                op,
                // For modules, creation is never a modification.
                false,
            )?;

            let state_key = StateKey::module_id(&module_id);

            // Enforce read-before-write:
            //   Modules can live in global cache, and so the DB may not see a module read even
            //   when it gets republished. This violates read-before-write property. Here, we on
            //   purpose enforce this by registering a read to the DB directly.
            //   Note that we also do it here so that in case of storage errors, only a  single
            //   transaction fails (e.g., if doing this read before commit in block executor we
            //   have no way to alter the transaction outputs at that point).
            self.remote.read_state_value(&state_key).map_err(|err| {
                let msg = format!(
                    "Error when enforcing read-before-write for module {}::{}: {:?}",
                    addr, name, err
                );
                PartialVMError::new(StatusCode::STORAGE_ERROR).with_message(msg)
            })?;

            writes.insert(state_key, ModuleWrite::new(module_id, write_op));
        }
        Ok(writes)
    }
```

**File:** aptos-move/block-executor/src/code_cache_global_manager.rs (L168-175)
```rust
        let module_cache_size_in_bytes = self.module_cache.size_in_bytes();
        GLOBAL_MODULE_CACHE_SIZE_IN_BYTES.set(module_cache_size_in_bytes as i64);
        GLOBAL_MODULE_CACHE_NUM_MODULES.set(self.module_cache.num_modules() as i64);

        // If module cache stores too many modules, flush it as well.
        if module_cache_size_in_bytes > config.max_module_cache_size_in_bytes {
            self.module_cache.flush();
        }
```
