# Audit Report

## Title
Mempool Permanent Freeze via Mutex Poisoning - Critical Liveness Failure

## Summary
The Aptos mempool uses `aptos-infallible::Mutex` which explicitly does not handle poisoned locks. If any panic occurs while the mempool lock is held, the mutex becomes poisoned and all subsequent lock acquisition attempts will panic, causing permanent mempool freeze and total loss of liveness for the affected node.

## Finding Description

The mempool's core data structure is protected by `Arc<Mutex<CoreMempool>>` where `Mutex` is from `aptos-infallible`. [1](#0-0) 

This mutex wrapper's `lock()` implementation explicitly panics on poisoned locks: [2](#0-1) 

In Rust's standard library, when a thread panics while holding a mutex, the mutex becomes "poisoned" to indicate potential data corruption. Subsequent `lock()` calls return `Err(PoisonError)`. However, the `aptos-infallible::Mutex` wrapper calls `.expect()` on this result, converting any poison error into an immediate panic.

**Critical Lock Acquisition Points:**

1. **Transaction validation and insertion** - holds lock while calling `mempool.add_txn()`: [3](#0-2) 

2. **Consensus batch requests** - holds lock while getting transactions for consensus: [4](#0-3) 

3. **Committed transaction processing** - holds lock while removing committed transactions: [5](#0-4) 

4. **Rejected transaction processing** - holds lock while handling rejections: [6](#0-5) 

5. **Garbage collection** - periodic cleanup operations: [7](#0-6) 

**Panic Sources Within Locked Sections:**

The codebase contains several `.expect()` calls that execute while the lock is held:

- Expects account sequence number for sequence number transactions: [8](#0-7) 

- Another expect in the ready transaction processing: [9](#0-8) 

- Expect in transaction readiness check: [10](#0-9) 

- Unreachable macro that panics if reached: [11](#0-10) 

While these panic sites have defensive checks earlier in the code flow, any future code changes, unexpected edge cases, or logical bugs could trigger these panics while the lock is held.

**Attack Scenario:**

If ANY condition causes a panic while processing a transaction with the mempool lock held (e.g., hitting an `unreachable!()`, an assertion failure, an unexpected `.expect()` failure, stack overflow, or OOM), the following cascade occurs:

1. Thread panics while holding `mempool` lock → standard Rust mutex becomes poisoned
2. Next operation attempts `mempool.lock()` → receives `Err(PoisonError)`  
3. `.expect("Cannot currently handle a poisoned lock")` panics
4. **Every subsequent thread** attempting to lock the mempool panics
5. Node can no longer:
   - Accept new transactions
   - Provide transactions to consensus
   - Process committed transactions  
   - Perform garbage collection
6. **Total loss of liveness** - node becomes permanently non-functional

## Impact Explanation

This vulnerability meets **Critical Severity** criteria under "Total loss of liveness/network availability":

- **Complete Node Failure**: The affected validator node cannot process any transactions
- **Consensus Participation Loss**: Node cannot provide transactions to consensus or process committed blocks
- **Permanent State**: Requires node restart to recover; if the panic-inducing condition persists, the node will repeatedly fail
- **Network-Wide Risk**: If multiple validators encounter the same panic condition, significant portion of network could lose liveness
- **No Automatic Recovery**: Unlike transient errors, mutex poisoning is permanent until process restart

The invariant violated is **"Total loss of liveness/network availability"** from the Critical Severity category.

## Likelihood Explanation

**Moderate to High Likelihood:**

- **Existing Panic Sites**: Multiple `.expect()` and `unreachable!()` calls exist within the locked code paths
- **Future Code Changes**: Any new code that adds panics while holding the lock would trigger this
- **Edge Cases**: Unexpected transaction inputs or state conditions could trigger defensive panics
- **Resource Exhaustion**: OOM or stack overflow during transaction processing would poison the lock
- **No Redundancy**: Single point of failure with no fallback mechanism

While the existing code has defensive checks to prevent reaching the panic sites under normal conditions, the fragile design means any logical bug or unexpected condition leads to catastrophic failure.

## Recommendation

**Immediate Fix**: Replace `aptos-infallible::Mutex` with a poison-handling wrapper that can recover from panics:

```rust
pub struct ResilientMutex<T>(StdMutex<T>);

impl<T> ResilientMutex<T> {
    pub fn new(t: T) -> Self {
        Self(StdMutex::new(t))
    }

    pub fn lock(&self) -> MutexGuard<'_, T> {
        match self.0.lock() {
            Ok(guard) => guard,
            Err(poisoned) => {
                // Log the poison event for debugging
                error!("Mutex was poisoned, recovering by clearing poison flag");
                counters::MEMPOOL_MUTEX_POISONED.inc();
                // Return the guard, clearing the poison flag
                poisoned.into_inner()
            }
        }
    }
}
```

**Alternative**: Use `parking_lot::Mutex` which doesn't poison on panic (it just continues working with potentially inconsistent data).

**Long-term**: Eliminate all potential panic sources within locked sections:
- Replace `.expect()` with proper error handling that returns `Result`
- Replace `unreachable!()` with defensive error returns
- Add resource limit checks before operations that could panic
- Use `catch_unwind` barriers around external code

## Proof of Concept

```rust
#[test]
fn test_mempool_mutex_poisoning() {
    use std::sync::Arc;
    use std::thread;
    use aptos_infallible::Mutex;
    
    // Simulate mempool with mutex
    let mempool = Arc::new(Mutex::new(0));
    let mempool_clone = mempool.clone();
    
    // Thread 1: Panic while holding lock
    let handle1 = thread::spawn(move || {
        let mut guard = mempool_clone.lock();
        *guard = 1;
        panic!("Simulated transaction processing panic");
    });
    
    // Wait for thread 1 to panic
    let _ = handle1.join();
    
    // Thread 2: Try to acquire lock - this will panic due to poison
    let mempool_clone2 = mempool.clone();
    let handle2 = thread::spawn(move || {
        // This will panic with "Cannot currently handle a poisoned lock"
        let _guard = mempool_clone2.lock();
    });
    
    // This join will return Err because thread 2 panicked
    assert!(handle2.join().is_err());
    
    // All future lock attempts will panic - mempool is permanently frozen
}
```

**Notes**

This is a **critical design flaw** rather than a traditional exploitable bug. While I cannot demonstrate a specific malicious transaction that triggers a panic under current code, the architectural decision to use non-poison-handling mutexes creates a single point of failure. Any panic while holding the lock—whether from a bug, unexpected edge case, resource exhaustion, or future code change—results in permanent node failure requiring manual intervention. This violates the liveness guarantee essential for blockchain consensus participation.

### Citations

**File:** mempool/src/shared_mempool/types.rs (L50-50)
```rust
    pub mempool: Arc<Mutex<CoreMempool>>,
```

**File:** crates/aptos-infallible/src/mutex.rs (L19-23)
```rust
    pub fn lock(&self) -> MutexGuard<'_, T> {
        self.0
            .lock()
            .expect("Cannot currently handle a poisoned lock")
    }
```

**File:** mempool/src/shared_mempool/tasks.rs (L506-506)
```rust
        let mut mempool = smp.mempool.lock();
```

**File:** mempool/src/shared_mempool/tasks.rs (L654-654)
```rust
                let mut mempool = smp.mempool.lock();
```

**File:** mempool/src/shared_mempool/tasks.rs (L719-719)
```rust
    let mut pool = mempool.lock();
```

**File:** mempool/src/shared_mempool/tasks.rs (L749-749)
```rust
    let mut pool = mempool.lock();
```

**File:** mempool/src/shared_mempool/coordinator.rs (L453-453)
```rust
        mempool.lock().gc();
```

**File:** mempool/src/core_mempool/transaction_store.rs (L297-299)
```rust
            let acc_seq_num = account_sequence_number.expect(
                "Account sequence number is always provided for transactions with sequence number",
            );
```

**File:** mempool/src/core_mempool/transaction_store.rs (L361-361)
```rust
                self.process_ready_seq_num_based_transactions(&address, account_sequence_number.expect("Account sequence number is always provided for transactions with sequence number"));
```

**File:** mempool/src/core_mempool/transaction_store.rs (L476-476)
```rust
                let account_sequence_number = account_sequence_number.expect("Account sequence number is always provided for transactions with sequence number");
```

**File:** mempool/src/core_mempool/transaction_store.rs (L479-481)
```rust
                } else if tx_sequence_number == 0 {
                    // shouldn't really get here because filtering out old txn sequence numbers happens earlier in workflow
                    unreachable!("[mempool] already committed txn detected, cannot be checked for readiness upon insertion");
```
