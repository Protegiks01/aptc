# Audit Report

## Title
Move Assembler EOF Handling Allows Creation of Unverified Modules with Invalid Function Definitions

## Summary
The Move assembler's EOF (End-of-File) validation in `syntax.rs` allows incomplete function definitions to bypass bytecode verification. When a `.masm` file terminates prematurely during function body parsing, the assembler creates functions with no code (`code: None`), which the bytecode verifier incorrectly treats as native functions, skipping all safety checks. These malformed modules can be published to the blockchain and cause runtime failures.

## Finding Description

The vulnerability exists in the interaction between the Move assembler's parser and the bytecode verifier:

**Parser EOF Handling:** In the `expect_newline()` function, `Token::End` (EOF) is treated as a valid newline without being consumed. [1](#0-0) 

When parsing a function in `fun()`, if EOF is encountered after the function signature but before the body, the instruction parsing loop exits immediately because we're already at `Token::End`, resulting in a `Fun` AST node with an empty `instrs` vector. [2](#0-1) 

**Assembler Code Generation:** During compilation, `define_fun()` only generates function code if `!fun.instrs.is_empty()`. [3](#0-2) 

If instructions are empty, the function definition remains with `code: None` as set during declaration. [4](#0-3) 

**Verification Bypass:** The bytecode verifier determines if a function is native solely by checking if `code.is_none()`. [5](#0-4) 

Functions with `code: None` bypass all verification checks and return immediately. [6](#0-5) 

**Runtime Failure:** At runtime, when such a function is called, the VM attempts to resolve the native function implementation, which fails with `MISSING_DEPENDENCY` error because no actual native implementation exists. [7](#0-6) 

**Attack Path:**
1. Attacker creates a `.masm` file: `module 0x1::Malicious\nfun exploit()`
2. File is assembled successfully, creating a `CompiledModule` with a function having `code: None`
3. Module passes bytecode verification (function treated as native, skipping all checks)
4. Module is published to the blockchain
5. When any contract calls `exploit()`, it receives `MISSING_DEPENDENCY` error, causing transaction failures and DoS

## Impact Explanation

This is a **Medium Severity** vulnerability per Aptos bug bounty criteria because it enables:

1. **State Inconsistencies Requiring Intervention:** Invalid modules with broken functions can be published to the blockchain, polluting the module storage with entries that pass verification but fail at runtime. This requires manual intervention or hardfork to clean up.

2. **Limited DoS Potential:** Attackers can publish malicious modules that cause dependent contracts to fail when they attempt to call the broken functions. While this doesn't cause total network unavailability, it can disrupt specific applications.

3. **Verification Bypass:** The vulnerability allows bypassing all bytecode safety checks (stack safety, type safety, reference safety, resource safety) for certain functions, violating the Move VM Safety invariant.

The issue does not qualify for Critical or High severity because:
- It does not enable fund theft or minting
- It does not cause consensus violations or network partitions
- It does not allow arbitrary code execution
- The runtime check prevents actual execution of malicious logic

## Likelihood Explanation

The likelihood is **Medium** because:

**Factors Increasing Likelihood:**
- The assembler is part of the official Aptos toolchain and used in testing infrastructure
- Creating a malicious `.masm` file requires minimal effort (just incomplete syntax)
- No special privileges are needed to publish modules
- The vulnerability is easy to trigger accidentally during development

**Factors Decreasing Likelihood:**
- Most production modules use the Move compiler, not the assembler directly
- Developers typically test modules before deployment, which would reveal the runtime error
- The assembler is primarily a development/testing tool

However, the vulnerability represents a weakness in the trusted computing base where verification can be bypassed through specially crafted input.

## Recommendation

**Immediate Fix:** Add explicit validation in the assembler to reject functions with empty instruction bodies:

In `third_party/move/tools/move-asm/src/assembler.rs`, modify `define_fun()` to verify that non-native functions have code:

```rust
fn define_fun(&mut self, def_idx: FunctionDefinitionIndex, fun: &Fun) {
    if fun.instrs.is_empty() {
        // Reject functions with no body - these should be explicitly marked as native
        self.error(fun.loc, "function has no implementation; use 'native' keyword for native functions");
        return;
    }
    // ... rest of existing code
}
```

**Secondary Fix:** Enhance the bytecode verifier to detect and reject non-native functions with `code: None`:

In verification pipeline, add a check that ensures functions without code are explicitly marked as native in the module metadata, rather than inferring native status solely from `code.is_none()`.

**Long-term Fix:** Add native function syntax support to the assembler to make the distinction explicit.

## Proof of Concept

```rust
// File: malicious.masm
module 0x1::Malicious

fun broken_function()
// EOF - file ends here, no function body provided

// Test that demonstrates the vulnerability:
use std::fs;
use move_asm::assembler;
use move_bytecode_verifier::verify_module;

#[test]
fn test_incomplete_function_bypass() {
    // Create malicious .masm file
    let source = "module 0x1::Malicious\n\nfun exploit()";
    
    // Assemble the module
    let options = assembler::Options::default();
    let result = assembler::assemble(&options, source, std::iter::empty());
    
    assert!(result.is_ok(), "Assembly should succeed");
    let module = match result.unwrap() {
        either::Either::Left(m) => m,
        _ => panic!("Expected module"),
    };
    
    // Verify that the module passes verification despite having broken function
    let verify_result = verify_module(&module);
    assert!(verify_result.is_ok(), "Verification should pass (incorrectly)");
    
    // Verify that function has no code
    let func_def = &module.function_defs()[0];
    assert!(func_def.code.is_none(), "Function should have no code");
    
    // When this module is published and the function is called,
    // it will fail at runtime with MISSING_DEPENDENCY error
}
```

## Notes

This vulnerability demonstrates a gap between parser error handling and security validation. The assembler's lenient EOF handling combined with the verifier's assumption that `code: None` implies a legitimate native function creates a bypass that violates module integrity invariants.

### Citations

**File:** third_party/move/tools/move-asm/src/syntax.rs (L326-337)
```rust
    fn expect_newline(&mut self) -> AsmResult<()> {
        if self.is_tok(&Token::End) {
            // End of file can serve as newline, but is not consumed
            return Ok(());
        }
        self.expect(&Token::Newline)?;
        // Skip empty lines.
        while self.is_tok(&Token::Newline) {
            self.advance()?
        }
        Ok(())
    }
```

**File:** third_party/move/tools/move-asm/src/syntax.rs (L818-852)
```rust
        self.expect_newline()?;
        let mut locals = vec![];
        let mut instrs = vec![];
        while self.is_indent() || self.is_ident() && self.lookahead_special(":") {
            if self.is_indent() {
                self.advance()?
            }
            if self.is_soft_kw("local") {
                if !instrs.is_empty() {
                    return Err(error(
                        self.next_loc,
                        "local declarations must precede instructions",
                    ));
                }
                self.advance()?;
                let local = self.decl()?;
                locals.push(local);
            } else {
                instrs.push(self.instr()?)
            }
            self.expect_newline()?
        }
        Ok(Fun {
            loc,
            name,
            visibility,
            is_entry,
            attributes,
            type_params,
            params,
            locals,
            result,
            acquires,
            instrs,
        })
```

**File:** third_party/move/tools/move-asm/src/assembler.rs (L356-417)
```rust
    fn define_fun(&mut self, def_idx: FunctionDefinitionIndex, fun: &Fun) {
        if !fun.instrs.is_empty() {
            self.setup_fun(fun);
            let mut open_branches = BTreeMap::new();
            let mut label_defs = BTreeMap::new();
            let mut code = vec![];
            let mut has_errors = false;
            for (offs, instr) in fun.instrs.iter().enumerate() {
                if let Some(label) = instr.label.as_ref() {
                    label_defs.insert(label.clone(), offs as CodeOffset);
                }
                if let Some(bc) = self.build_instr(
                    instr,
                    offs as CodeOffset,
                    &mut open_branches,
                    &mut label_defs,
                ) {
                    code.push(bc)
                } else {
                    // else error reported
                    has_errors = true
                }
            }
            if !has_errors {
                // Link forward pointing branch targets
                for (offs, (use_loc, label)) in open_branches {
                    if let Some(target_offs) = label_defs.get(&label) {
                        match &mut code[offs as usize] {
                            Bytecode::Branch(open)
                            | Bytecode::BrTrue(open)
                            | Bytecode::BrFalse(open) => *open = *target_offs,
                            _ => panic!("unexpected bytecode"),
                        };
                    } else {
                        self.error(use_loc, format!("unbound branch label `{}`", label))
                    }
                }
                // Define locals signature.
                let locals_start = fun.params.len();
                let mut locals: Vec<(LocalIndex, SignatureToken)> = self
                    .require_resolution_context()
                    .local_map
                    .clone()
                    .into_iter()
                    .filter_map(|(_, r)| {
                        if r.0 as usize >= locals_start {
                            Some(r)
                        } else {
                            None
                        }
                    })
                    .collect();
                locals.sort_by(|e1, e2| e1.0.cmp(&e2.0));
                let res = self
                    .builder
                    .signature_index(locals.into_iter().map(|(_, ty)| ty).collect());
                if let Some(sign_index) = self.add_diags(fun.loc, res) {
                    self.builder.define_fun_code(def_idx, sign_index, code)
                }
            }
        }
    }
```

**File:** third_party/move/tools/move-asm/src/module_builder.rs (L383-395)
```rust
        let fdef = FunctionDefinition {
            function: fhdl_idx,
            visibility,
            is_entry,
            acquires_global_resources,
            code: None,
        };
        let new_idx = self.module.borrow().function_defs.len();
        self.bounds_check(new_idx, TableIndex::MAX, "function definition index")?;
        let fidx = FunctionDefinitionIndex(new_idx as TableIndex);
        self.module.borrow_mut().function_defs.push(fdef);
        Ok(fidx)
    }
```

**File:** third_party/move/move-binary-format/src/file_format.rs (L735-738)
```rust
    /// Returns whether the FunctionDefinition is native.
    pub fn is_native(&self) -> bool {
        self.code.is_none()
    }
```

**File:** third_party/move/move-bytecode-verifier/src/code_unit_verifier.rs (L131-135)
```rust
        // nothing to verify for native function
        let code = match &function_definition.code {
            Some(code) => code,
            None => return Ok(0),
        };
```

**File:** third_party/move/move-vm/runtime/src/loader/function.rs (L772-777)
```rust
    pub(crate) fn get_native(&self) -> PartialVMResult<&UnboxedNativeFunction> {
        self.native.as_deref().ok_or_else(|| {
            PartialVMError::new(StatusCode::MISSING_DEPENDENCY)
                .with_message(format!("Missing Native Function `{}`", self.name))
        })
    }
```
