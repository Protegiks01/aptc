# Audit Report

## Title
IP Header Spoofing in Aptos Faucet Allows Complete Bypass of Rate Limiting and IP Blocklists

## Summary
The Aptos faucet service uses `poem::web::RealIp` to extract client IP addresses from HTTP proxy headers (`X-Forwarded-For`, `X-Real-IP`, `Forwarded`) without validating the trustworthiness of the source. When the faucet is deployed directly to the internet (as documented in its README), attackers can trivially spoof these headers to bypass IP-based rate limiting and blocklists, enabling unlimited fund requests and exhausting faucet resources.

## Finding Description

The vulnerability exists in how the faucet determines the client's source IP address for security checks. [1](#0-0) 

The `RealIp` extractor automatically parses proxy headers to determine the client IP: [2](#0-1) 

This extracted IP is then used by all security checkers without validation: [3](#0-2) 

The IP blocklist checker trusts this value directly: [4](#0-3) 

The rate limiter also relies on the spoofable IP: [5](#0-4) 

**Critical Context**: The faucet README explicitly states it has "Built in rate limiting... **eliminating the need for something like haproxy in front of the faucet**": [6](#0-5) 

This design intention means the faucet can be directly exposed to the internet. In this deployment scenario, there is **no trusted proxy** between clients and the faucet. Without a middleware or configuration to specify trusted proxy IPs, the Poem framework's `RealIp` extractor will accept proxy headers from **any client**, allowing trivial spoofing.

**Attack Path:**
1. Attacker sends POST request to `/fund` with header `X-Forwarded-For: 1.2.3.4`
2. `RealIp::from_request()` extracts `1.2.3.4` as source IP
3. All security checks (IP blocklist, rate limiting) use this fake IP
4. Attacker rotates through unlimited fake IPs to bypass all limits
5. Faucet funds are exhausted through unlimited requests

The server configuration shows no trusted proxy configuration: [7](#0-6) 

## Impact Explanation

This vulnerability allows complete bypass of the faucet's primary security controls. However, the impact is limited to **testnet environments** where the faucet distributes test tokens with no economic value. 

While this represents a **critical authentication bypass** from a software security perspective, it does not affect:
- Mainnet blockchain security or consensus
- Real economic value or user funds
- Any of the 10 critical blockchain invariants (deterministic execution, consensus safety, Move VM safety, etc.)
- Core blockchain components (consensus, execution, storage, governance, staking)

The faucet is an auxiliary testnet utility service, not part of the core blockchain protocol. Therefore, this finding falls outside the primary scope of critical blockchain security vulnerabilities defined in the audit criteria.

Per the Aptos bug bounty categories, this would potentially qualify as **Low Severity** (minor service disruption) rather than Critical/High/Medium, as it involves test token distribution rather than mainnet funds, consensus violations, or protocol security.

## Likelihood Explanation

**Exploitation Likelihood: Very High**

The attack requires only basic HTTP knowledge and can be executed with a simple curl command. No special access, credentials, or complex setup is needed. However, the practical impact is limited to disrupting testnet token distribution.

## Recommendation

Implement one of these solutions:

**Option 1**: Always deploy behind a trusted reverse proxy (recommended)
- Deploy faucet behind HAProxy/nginx configured to set trusted proxy headers
- Document this as a mandatory security requirement
- Remove the claim that the faucet "eliminates the need for haproxy"

**Option 2**: Add trusted proxy configuration to Poem
- Configure `poem::middleware::RemoteAddr` with trusted proxy IPs
- Only parse proxy headers from configured trusted sources
- Reject proxy headers from untrusted clients

**Option 3**: Disable proxy header parsing entirely
- Use only the direct TCP connection IP address
- Accept that this breaks deployment behind legitimate reverse proxies
- Requires load balancer to use PROXY protocol instead of HTTP headers

## Proof of Concept

```bash
# Normal request - gets rate limited after N requests
curl -X POST http://faucet.testnet.aptos.dev/fund \
  -H "Content-Type: application/json" \
  -d '{"address":"0x1234..."}'

# Bypass rate limit by spoofing different IPs
for i in {1..1000}; do
  curl -X POST http://faucet.testnet.aptos.dev/fund \
    -H "Content-Type: application/json" \
    -H "X-Forwarded-For: 10.0.0.$i" \
    -d '{"address":"0x1234..."}'
done

# Bypass IP blocklist 
curl -X POST http://faucet.testnet.aptos.dev/fund \
  -H "Content-Type: application/json" \
  -H "X-Real-IP: 8.8.8.8" \
  -d '{"address":"0x1234..."}'
```

## Notes

While this represents a valid software security vulnerability in the faucet service, it does not meet the **Critical/High/Medium severity criteria** for the blockchain security audit as it:

1. Only affects testnet auxiliary services, not core blockchain components
2. Involves test tokens with no economic value, not mainnet funds
3. Does not break any of the 10 critical blockchain invariants
4. Falls outside the primary audit scope (consensus, execution, storage, governance, staking)

The vulnerability is real and should be fixed to ensure fair testnet token distribution, but it represents operational/service-level risk rather than blockchain protocol security risk.

### Citations

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L105-110)
```rust
        asset: poem_openapi::param::Query<Option<String>>,
        // This automagically uses FromRequest to get this data from the request.
        // It takes into things like X-Forwarded-IP and X-Real-IP.
        source_ip: RealIp,
        // Same thing, this uses FromRequest.
        header_map: &HeaderMap,
```

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L237-242)
```rust
        let checker_data = CheckerData {
            receiver,
            source_ip,
            headers: Arc::new(header_map.clone()),
            time_request_received_secs: get_current_time_secs(),
        };
```

**File:** crates/aptos-faucet/core/src/middleware/log.rs (L25-28)
```rust
    let source_ip = RealIp::from_request(&request, &mut RequestBody::default())
        .await
        .map(|ip| ip.0)
        .unwrap_or(None);
```

**File:** crates/aptos-faucet/core/src/checkers/ip_blocklist.rs (L32-39)
```rust
        match &data.source_ip {
            IpAddr::V4(source_ip) => {
                if self.manager.ipv4_list.contains(source_ip) {
                    return Ok(vec![RejectionReason::new(
                        format!("IP {} is in blocklist", source_ip),
                        RejectionReasonCode::IpInBlocklist,
                    )]);
                }
```

**File:** crates/aptos-faucet/core/src/checkers/memory_ratelimit.rs (L75-88)
```rust
        let mut ip_to_requests_today = self.ip_to_requests_today.lock().await;

        let requests_today = ip_to_requests_today.get_or_insert_mut(data.source_ip, || 1);
        if *requests_today >= self.max_requests_per_day {
            return Ok(vec![RejectionReason::new(
                format!(
                    "IP {} has exceeded the daily limit of {} requests",
                    data.source_ip, self.max_requests_per_day
                ),
                RejectionReasonCode::UsageLimitExhausted,
            )]);
        } else if !dry_run {
            *requests_today += 1;
        }
```

**File:** crates/aptos-faucet/README.md (L23-23)
```markdown
- Built in rate limiting, e.g. with a [Redis](https://redis.io/) backend, eliminating the need for something like haproxy in front of the faucet. These are also just checkers.
```

**File:** crates/aptos-faucet/core/src/server/run.rs (L207-220)
```rust
        let api_server_future = Server::new_with_acceptor(TcpAcceptor::from_tokio(listener)?).run(
            Route::new()
                .nest(
                    &self.server_config.api_path_base,
                    Route::new()
                        .nest("", api_service)
                        .catch_all_error(convert_error),
                )
                .at("/spec.json", spec_json)
                .at("/spec.yaml", spec_yaml)
                .at("/mint", poem::post(mint.data(fund_api_components)))
                .with(cors)
                .around(middleware_log),
        );
```
