# Audit Report

## Title
Keyless Gas Charge Bypass via Ed25519 Backup Key Authentication

## Summary
The keyless authentication gas charging mechanism can be bypassed by adding an Ed25519 backup key to a keyless account and then using Ed25519 signatures for subsequent transactions, avoiding the 32M gas charge while maintaining the account's keyless-derived address and properties.

## Finding Description

The vulnerability exists in the gas charging logic for keyless authentication. The system charges 32M gas units when `is_keyless()` returns true, which is determined by detecting keyless authenticators in the transaction. [1](#0-0) 

The detection relies on `get_authenticators()` which only identifies keyless authenticators when BOTH the public key AND signature are keyless types: [2](#0-1) 

However, the Aptos framework provides `upsert_ed25519_backup_key_on_keyless_account` which allows keyless accounts to add an Ed25519 backup key: [3](#0-2) 

This creates a MultiKey with threshold 1, meaning EITHER key can authenticate. When a MultiKey authenticator is processed, only the signatures actually used (per the bitmap) are extracted: [4](#0-3) 

**Attack Path:**
1. User creates keyless account (pays 32M gas charge)
2. User calls `upsert_ed25519_backup_key_on_keyless_account` (pays 32M gas charge once more)
3. Account auth key is rotated to MultiKey(keyless_pk, ed25519_pk, threshold=1)
4. For subsequent transactions, user signs with Ed25519 key only (bitmap indicates index 1)
5. `to_single_key_authenticators()` extracts only Ed25519 SingleKeyAuthenticator
6. `get_authenticators()` returns empty (Ed25519 doesn't match keyless pattern)
7. `is_keyless` becomes false, no 32M gas charge applied [5](#0-4) 

The user continues to use an account with keyless-derived address and properties but pays only standard gas costs equivalent to Ed25519 authentication.

## Impact Explanation

**Severity Assessment: Medium**

While this bypasses the 32M keyless gas charge, the actual computational impact is limited because:
- When using Ed25519 signatures, validators perform standard Ed25519 verification (cheap)
- No expensive Groth16 ZK proof verification occurs when Ed25519 is used
- The 32M charge is designed to cover keyless verification costs, which aren't incurred when using Ed25519

However, this violates the **Resource Limits invariant** (gas must accurately reflect computational cost) in a subtle way:
- The backup key feature is intended for recovery, not as a permanent cheaper alternative
- Users can exploit this to reduce long-term gas costs after initial keyless account setup
- Economic model assumes consistent gas charges for account types
- May encourage unintended usage patterns where users create keyless accounts only to immediately switch to Ed25519

This constitutes a protocol violation where the designed gas economics for keyless accounts can be circumvented.

## Likelihood Explanation

**Likelihood: High**

- Attack requires no special privileges or validator access
- Uses documented, public API functions (`upsert_ed25519_backup_key_on_keyless_account`)
- Attack path is straightforward and easily discoverable
- Economic incentive exists (save 32M gas per transaction after initial 2x32M investment)
- For high-frequency account users, savings quickly exceed initial cost

## Recommendation

**Option 1: Account-Level Keyless Tracking**
Store a permanent marker in the Account resource indicating keyless origin, and charge the keyless base cost for all transactions from such accounts regardless of authenticator used:

```rust
// In transaction_metadata.rs
pub fn new(txn: &SignedTransaction, auxiliary_info: &AuxiliaryInfo) -> Self {
    let is_keyless_account = check_if_account_is_keyless_origin(txn.sender());
    let has_keyless_auth = aptos_types::keyless::get_authenticators(txn)
        .map(|res| !res.is_empty())
        .unwrap_or(false);
    
    Self {
        // ...
        is_keyless: is_keyless_account || has_keyless_auth,
        // ...
    }
}
```

**Option 2: Restrict MultiKey Authentication for Keyless Accounts**
Prevent keyless accounts from rotating to MultiKey configurations that allow non-keyless authentication, or require all keys in the MultiKey to be keyless variants.

**Option 3: Differential Gas Pricing**
Charge based on account creation method - reduced ongoing charge for Ed25519 authentication from keyless accounts, but higher than pure Ed25519 accounts to reflect the initial keyless setup costs.

## Proof of Concept

```move
#[test_only]
module test_addr::keyless_gas_bypass_poc {
    use std::vector;
    use aptos_framework::account;
    use aptos_std::ed25519;
    use aptos_std::multi_key;
    
    #[test(user = @0x123)]
    public fun test_keyless_to_ed25519_bypass(user: &signer) {
        // Step 1: Create keyless account (assume keyless_pk is provided)
        let keyless_pk_bytes = x"..."; // Keyless public key
        
        // Step 2: Add Ed25519 backup key
        let (ed25519_sk, ed25519_pk) = ed25519::generate_keys();
        let ed25519_pk_bytes = ed25519::validated_public_key_to_bytes(&ed25519_pk);
        
        // Create rotation proof
        let challenge = account::create_rotation_challenge(...);
        let signature = ed25519::sign_struct(&ed25519_sk, challenge);
        
        // This creates MultiKey(keyless, ed25519, threshold=1)
        account::upsert_ed25519_backup_key_on_keyless_account(
            user,
            keyless_pk_bytes,
            ed25519_pk_bytes,
            ed25519::signature_to_bytes(&signature)
        );
        
        // Step 3: Future transactions use Ed25519 signature
        // Transaction authenticator will be MultiKey with only Ed25519 bit set in bitmap
        // Result: is_keyless = false, no 32M gas charge
        // But account still has keyless-derived address and properties
    }
}
```

**Notes:**

The exploitation depends on whether the design intent is to charge keyless gas for all transactions from keyless-origin accounts versus charging only when keyless authentication is actually used. The current implementation charges based on authenticator type, not account origin, which may or may not align with the intended economic model. The backup key feature appears designed for recovery scenarios, not as a permanent gas optimization strategy.

### Citations

**File:** aptos-move/aptos-vm/src/transaction_metadata.rs (L80-82)
```rust
            is_keyless: aptos_types::keyless::get_authenticators(txn)
                .map(|res| !res.is_empty())
                .unwrap_or(false),
```

**File:** types/src/keyless/mod.rs (L455-475)
```rust
        match (authenticator.public_key(), authenticator.signature()) {
            (AnyPublicKey::Keyless { public_key }, AnySignature::Keyless { signature }) => {
                authenticators.push((
                    AnyKeylessPublicKey::Normal(public_key.clone()),
                    signature.clone(),
                ))
            },
            (
                AnyPublicKey::FederatedKeyless { public_key },
                AnySignature::Keyless { signature },
            ) => authenticators.push((
                AnyKeylessPublicKey::Federated(FederatedKeylessPublicKey {
                    jwk_addr: public_key.jwk_addr,
                    pk: public_key.pk.clone(),
                }),
                signature.clone(),
            )),
            _ => {
                // ignore.
            },
        }
```

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L520-556)
```text
    entry fun upsert_ed25519_backup_key_on_keyless_account(account: &signer, keyless_public_key: vector<u8>, backup_public_key: vector<u8>, backup_key_proof: vector<u8>) acquires Account {
        // Check that the provided public key is a keyless public key
        let keyless_single_key = single_key::new_public_key_from_bytes(keyless_public_key);
        assert!(single_key::is_keyless_or_federated_keyless_public_key(&keyless_single_key), error::invalid_argument(ENOT_A_KEYLESS_PUBLIC_KEY));

        let addr = signer::address_of(account);
        let account_resource = &mut Account[addr];
        let old_auth_key = account_resource.authentication_key;

        // Check that the provided public key is original public key of the account by comparing
        // its authentication key to the account address.
        assert!(
            bcs::to_bytes(&addr) == keyless_single_key.to_authentication_key(),
            error::invalid_argument(ENOT_THE_ORIGINAL_PUBLIC_KEY)
        );

        let curr_auth_key_as_address = from_bcs::to_address(old_auth_key);
        let challenge = RotationProofChallenge {
            sequence_number: account_resource.sequence_number,
            originator: addr,
            current_auth_key: curr_auth_key_as_address,
            new_public_key: backup_public_key,
        };

        // Assert the challenges signed by the provided backup key is valid
        assert_valid_rotation_proof_signature_and_get_auth_key(
            ED25519_SCHEME,
            backup_public_key,
            backup_key_proof,
            &challenge
        );

        // Get the backup key as a single key
        let backup_key_ed25519 = ed25519::new_unvalidated_public_key_from_bytes(backup_public_key);
        let backup_key_as_single_key = single_key::from_ed25519_public_key_unvalidated(backup_key_ed25519);

        let new_public_key = multi_key::new_multi_key_from_single_keys(vector[keyless_single_key, backup_key_as_single_key], 1);
```

**File:** types/src/transaction/authenticator.rs (L1080-1111)
```rust
    pub fn to_single_key_authenticators(&self) -> Result<Vec<SingleKeyAuthenticator>> {
        ensure!(
            self.signatures_bitmap.last_set_bit().is_some(),
            "There were no signatures set in the bitmap."
        );

        ensure!(
            (self.signatures_bitmap.last_set_bit().unwrap() as usize) < self.public_keys.len(),
            "Mismatch in the position of the last signature and the number of PKs, {} >= {}.",
            self.signatures_bitmap.last_set_bit().unwrap(),
            self.public_keys.len(),
        );
        ensure!(
            self.signatures_bitmap.count_ones() as usize == self.signatures.len(),
            "Mismatch in number of signatures and the number of bits set in the signatures_bitmap, {} != {}.",
            self.signatures_bitmap.count_ones(),
            self.signatures.len(),
        );
        ensure!(
            self.signatures.len() >= self.public_keys.signatures_required() as usize,
            "Not enough signatures for verification, {} < {}.",
            self.signatures.len(),
            self.public_keys.signatures_required(),
        );
        let authenticators: Vec<SingleKeyAuthenticator> =
            std::iter::zip(self.signatures_bitmap.iter_ones(), self.signatures.iter())
                .map(|(idx, sig)| SingleKeyAuthenticator {
                    public_key: self.public_keys.public_keys[idx].clone(),
                    signature: sig.clone(),
                })
                .collect();
        Ok(authenticators)
```

**File:** aptos-move/aptos-gas-meter/src/meter.rs (L617-625)
```rust
    fn charge_keyless(&mut self) -> VMResult<()> {
        if self.feature_version() < RELEASE_V1_12 {
            return Ok(());
        }

        self.algebra
            .charge_execution(KEYLESS_BASE_COST)
            .map_err(|e| e.finish(Location::Undefined))
    }
```
