# Audit Report

## Title
Missing SIGTERM Handler Causes Docker Resource Leaks in Workspace Server

## Summary
The `aptos-workspace-server` only handles SIGINT (Ctrl-C) for graceful shutdown but does not handle SIGTERM signals. When terminated via SIGTERM (the default signal used by Docker, systemd, and most process managers), the server exits immediately without cleaning up Docker containers and volumes, leaving them orphaned on the host system.

## Finding Description

The workspace server's shutdown mechanism has two critical issues: [1](#0-0) 

**Issue 1: No SIGTERM Handler**
The code only registers a handler for `tokio::signal::ctrl_c()` which listens exclusively for SIGINT signals. SIGTERM, the standard signal for requesting process termination used by `docker stop`, `systemctl stop`, `kill`, and Kubernetes, is completely unhandled. When SIGTERM is received, the Rust runtime terminates immediately without executing cleanup logic. [2](#0-1) 

When cleanup DOES run (on SIGINT only), it executes:
- `fut_indexer_api_clean_up`: Stops and removes the Hasura indexer API container
- `fut_postgres_clean_up`: Stops and removes the PostgreSQL container and its volume

**Issue 2: Docker Network Never Cleaned Up** [3](#0-2) [4](#0-3) 

The Docker network is created as "permanent" with no cleanup future ever returned or awaited. Even during graceful SIGINT shutdown, this network persists indefinitely.

**Exploitation Scenario:**

1. Developer starts workspace server: `aptos-workspace-server run`
2. Services start: node, faucet, postgres container, indexer-api container, docker network "aptos-workspace"
3. Process manager sends SIGTERM to stop the server (or `docker stop` on containerized deployment)
4. Process exits immediately without running cleanup code
5. Docker resources remain orphaned:
   - Container `aptos-workspace-{uuid}-postgres` running and consuming memory
   - Container `aptos-workspace-{uuid}-indexer-api` running and consuming memory  
   - Volume `aptos-workspace-{uuid}-postgres` consuming disk space
   - Network `aptos-workspace` persists
   - Bound ports remain occupied by running containers

**Repeated execution accumulates orphaned resources**, eventually exhausting system resources (ports, memory, disk space).

## Impact Explanation

This qualifies as **Low Severity** per Aptos bug bounty criteria: "Non-critical implementation bugs"

**Rationale:**
- Affects development tooling, not production validator infrastructure
- Does not impact consensus, funds, or blockchain state
- Resources can be manually cleaned with `docker ps -a`, `docker rm`, `docker volume rm`
- Docker daemon restart will stop containers (but volumes persist)
- Limited scope: typically 2 containers + 1 volume + 1 network per run

**However, real harm occurs:**
- Developers in CI/CD pipelines will accumulate dozens of orphaned containers
- Exhausts available ports (each run consumes 4-5 random ports)
- Disk space exhaustion from volume accumulation
- Memory pressure from running containers
- Confusing debugging: "port already in use" errors on subsequent runs

## Likelihood Explanation

**High likelihood** because:
- SIGTERM is the **default** termination signal in most environments:
  - `docker stop` sends SIGTERM then SIGKILL
  - `systemctl stop` sends SIGTERM
  - Kubernetes sends SIGTERM for pod termination
  - `kill <pid>` (without flags) sends SIGTERM
  - CI/CD systems (GitHub Actions, GitLab CI) send SIGTERM for job cleanup

**Only SIGINT (Ctrl-C) is handled**, which is used primarily in interactive terminal sessions. Production-like environments almost always use SIGTERM.

## Recommendation

**Add SIGTERM handling alongside SIGINT:**

```rust
// In lib.rs, around line 107
let shutdown = CancellationToken::new();
{
    let shutdown = shutdown.clone();
    tokio::spawn(async move {
        #[cfg(unix)]
        {
            use tokio::signal::unix::{signal, SignalKind};
            let mut sigterm = signal(SignalKind::terminate()).unwrap();
            let mut sigint = signal(SignalKind::interrupt()).unwrap();
            
            tokio::select! {
                _ = sigterm.recv() => {
                    no_panic_println!("\nSIGTERM received. Shutting down services. This may take a while.\n");
                }
                _ = sigint.recv() => {
                    no_panic_println!("\nCtrl-C received. Shutting down services. This may take a while.\n");
                }
                _ = tokio::time::sleep(Duration::from_secs(timeout)) => {
                    no_panic_println!("\nTimeout reached. Shutting down services. This may take a while.\n");
                }
            }
        }
        
        #[cfg(not(unix))]
        {
            tokio::select! {
                res = tokio::signal::ctrl_c() => {
                    res.unwrap();
                    no_panic_println!("\nCtrl-C received. Shutting down services. This may take a while.\n");
                }
                _ = tokio::time::sleep(Duration::from_secs(timeout)) => {
                    no_panic_println!("\nTimeout reached. Shutting down services. This may take a while.\n");
                }
            }
        }
        
        shutdown.cancel();
    });
}
```

**Add Docker network cleanup:**

Modify `create_docker_network_permanent` to return a cleanup future, or create the network using the existing `create_docker_network` function which already provides cleanup. [5](#0-4) 

Use this instead of `create_docker_network_permanent`, and await the cleanup future in `clean_up_all`.

## Proof of Concept

```bash
#!/bin/bash
# Demonstrates resource leak on SIGTERM

# Start the workspace server in background
aptos-workspace-server run &
SERVER_PID=$!

# Wait for services to start (adjust timing as needed)
sleep 10

echo "=== Docker resources BEFORE SIGTERM ==="
docker ps --filter "name=aptos-workspace"
docker volume ls --filter "name=aptos-workspace"
docker network ls --filter "name=aptos-workspace"

# Send SIGTERM (this is what docker stop / systemctl stop / kill do)
kill -TERM $SERVER_PID
wait $SERVER_PID

# Give Docker a moment to process
sleep 2

echo "=== Docker resources AFTER SIGTERM (should be cleaned but aren't) ==="
docker ps --filter "name=aptos-workspace"  # Shows running containers
docker volume ls --filter "name=aptos-workspace"  # Shows volumes
docker network ls --filter "name=aptos-workspace"  # Shows network

# Manual cleanup required:
# docker stop $(docker ps -q --filter "name=aptos-workspace")
# docker rm $(docker ps -aq --filter "name=aptos-workspace")
# docker volume rm $(docker volume ls -q --filter "name=aptos-workspace")
# docker network rm aptos-workspace
```

**Expected Result:** Orphaned containers, volumes, and network remain after SIGTERM.

**After Fix:** All Docker resources should be cleaned up automatically.

## Notes

This vulnerability is scoped to the development tooling and does not affect production Aptos validator nodes or consensus. The `aptos-workspace-server` is used for local testing and development environments. While the impact is limited to development workflows, the high likelihood of encountering SIGTERM signals in automated environments (CI/CD, containerized deployments) makes this a real operational issue that will frustrate developers and consume system resources unnecessarily.

### Citations

**File:** aptos-move/aptos-workspace-server/src/lib.rs (L107-119)
```rust
        tokio::spawn(async move {
            tokio::select! {
                res = tokio::signal::ctrl_c() => {
                    res.unwrap();
                    no_panic_println!("\nCtrl-C received. Shutting down services. This may take a while.\n");
                }
                _ = tokio::time::sleep(Duration::from_secs(timeout)) => {
                    no_panic_println!("\nTimeout reached. Shutting down services. This may take a while.\n");
                }
            }

            shutdown.cancel();
        });
```

**File:** aptos-move/aptos-workspace-server/src/lib.rs (L146-151)
```rust
    let docker_network_name = "aptos-workspace".to_string();
    let fut_docker_network = make_shared(create_docker_network_permanent(
        shutdown.clone(),
        fut_docker.clone(),
        docker_network_name,
    ));
```

**File:** aptos-move/aptos-workspace-server/src/lib.rs (L192-196)
```rust
    let clean_up_all = async move {
        no_panic_eprintln!("Running shutdown steps");
        fut_indexer_api_clean_up.await;
        fut_postgres_clean_up.await;
    };
```

**File:** aptos-move/aptos-workspace-server/src/services/docker_common.rs (L22-23)
```rust
/// Creates a permanent docker network which does not need to be cleaned up.
pub async fn create_docker_network_permanent(
```

**File:** aptos-move/aptos-workspace-server/src/services/docker_common.rs (L85-92)
```rust
pub fn create_docker_network(
    shutdown: CancellationToken,
    fut_docker: impl Future<Output = Result<Docker, ArcError>> + Clone + Send + 'static,
    name: String,
) -> (
    impl Future<Output = Result<String, ArcError>> + Clone,
    impl Future<Output = ()>,
) {
```
