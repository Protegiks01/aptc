# Audit Report

## Title
EpochRetrievalRequest Missing Type-Level Epoch Ordering Validation Enables Resource Exhaustion Attack

## Summary
The `EpochRetrievalRequest` struct lacks type-level validation ensuring `start_epoch <= end_epoch`, allowing Byzantine peers to send inverted epoch values that pass deserialization and consume validator resources through multiple processing layers before failing validation in the storage layer.

## Finding Description

The `EpochRetrievalRequest` struct is defined with no constraints on epoch ordering: [1](#0-0) 

A Byzantine peer can craft a malicious request with `start_epoch > end_epoch` (e.g., `start_epoch=100, end_epoch=1`). This malformed request propagates through the system as follows:

1. **Network Layer**: The message is deserialized via serde with no validation [2](#0-1) 

2. **Epoch Manager Reception**: The request passes the first validation check (only verifying `end_epoch <= self.epoch()`): [3](#0-2) 

3. **Epoch Manager Processing**: The request is logged and forwarded to storage: [4](#0-3) 

4. **Storage Layer Validation**: Only at this deep layer is the epoch ordering validated: [5](#0-4) 

When validation finally fails, the error is simply logged with no consequences for the malicious peer: [6](#0-5) 

The system has **no rate limiting or peer banning mechanism** for invalid epoch retrieval requests, allowing a Byzantine peer to repeatedly flood validators with malformed requests.

## Impact Explanation

This qualifies as **Medium Severity** per Aptos bug bounty criteria due to resource exhaustion that can degrade validator performance:

**Resources Wasted Per Invalid Request:**
- Network bandwidth for message transmission and serialization
- CPU cycles for BCS deserialization (serde)
- Channel/queue processing through consensus layer
- Logging operations (both on receipt and error)
- Function call overhead through epoch_manager → storage → aptosdb layers

**Attack Scalability:**
A Byzantine peer can amplify the attack by:
- Sending thousands of invalid requests per second
- Using varied epoch values to bypass simple deduplication
- Targeting multiple validators simultaneously
- Maintaining the attack indefinitely without detection or blocking

This breaks the **Resource Limits** invariant: "All operations must respect gas, storage, and computational limits" by allowing unbounded resource consumption from unvalidated peer requests.

## Likelihood Explanation

**Likelihood: High**

- **No Authentication Required**: Any network peer can send consensus messages
- **Trivial Exploitation**: Crafting invalid requests requires only basic BCS serialization
- **No Detection**: The current implementation only logs errors without tracking malicious peers
- **No Defense**: There is no rate limiting, peer scoring, or blocking mechanism for this specific attack vector

The `RequestModerator` that provides rate limiting in state-sync is not applied to consensus layer epoch retrieval requests: [7](#0-6) 

## Recommendation

**Fix 1: Add Type-Level Validation**

Create a validated constructor for `EpochRetrievalRequest`:

```rust
impl EpochRetrievalRequest {
    pub fn new(start_epoch: u64, end_epoch: u64) -> Result<Self, EpochRetrievalError> {
        if start_epoch > end_epoch {
            return Err(EpochRetrievalError::InvalidEpochRange {
                start_epoch,
                end_epoch,
            });
        }
        Ok(Self { start_epoch, end_epoch })
    }
}
```

Make fields private to enforce validation:
```rust
pub struct EpochRetrievalRequest {
    start_epoch: u64,
    end_epoch: u64,
}
```

**Fix 2: Add Early Validation in Epoch Manager**

Validate immediately after deserialization: [3](#0-2) 

Add validation before processing:
```rust
ConsensusMsg::EpochRetrievalRequest(request) => {
    ensure!(
        request.start_epoch <= request.end_epoch,
        "[EpochManager] Invalid epoch range: start {} > end {}",
        request.start_epoch,
        request.end_epoch
    );
    ensure!(
        request.end_epoch <= self.epoch(),
        "[EpochManager] Received EpochRetrievalRequest beyond what we have locally"
    );
    monitor!(
        "process_epoch_retrieval",
        self.process_epoch_retrieval(*request, peer_id)
    )?;
}
```

**Fix 3: Add Rate Limiting**

Implement peer tracking for invalid epoch retrieval requests:
```rust
struct EpochManager {
    // existing fields...
    invalid_epoch_requests: HashMap<AccountAddress, (u64, Instant)>,
    max_invalid_requests_per_peer: u64,
}
```

## Proof of Concept

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use aptos_consensus_types::epoch_retrieval::EpochRetrievalRequest;
    use aptos_network::protocols::network::Event;
    
    #[test]
    fn test_inverted_epoch_retrieval_bypasses_early_validation() {
        // Create malicious request with inverted epochs
        let malicious_request = EpochRetrievalRequest {
            start_epoch: 100,
            end_epoch: 1,  // Invalid: end < start
        };
        
        // Serialize using BCS (as Byzantine peer would)
        let serialized = bcs::to_bytes(&malicious_request).unwrap();
        
        // Deserialize successfully (no validation)
        let deserialized: EpochRetrievalRequest = 
            bcs::from_bytes(&serialized).unwrap();
        
        // Verification: deserialization succeeds despite invalid data
        assert_eq!(deserialized.start_epoch, 100);
        assert_eq!(deserialized.end_epoch, 1);
        
        // This message would now propagate through network → consensus → storage
        // before validation failure, wasting validator resources
        
        // The validation only fails deep in storage layer:
        // get_epoch_ending_ledger_infos_impl() -> check_epoch_ending_ledger_infos_request()
    }
    
    #[tokio::test]
    async fn test_resource_exhaustion_attack() {
        // Simulate Byzantine peer flooding with invalid requests
        let mut invalid_requests = Vec::new();
        
        for i in 0..1000 {
            invalid_requests.push(EpochRetrievalRequest {
                start_epoch: 50 + i,
                end_epoch: 1,  // All invalid
            });
        }
        
        // Each request wastes resources:
        // - Network transmission
        // - Deserialization
        // - Epoch manager processing  
        // - Logging
        // - Storage layer calls
        // - Error logging
        
        // With no rate limiting, this attack can continue indefinitely
        assert_eq!(invalid_requests.len(), 1000);
    }
}
```

## Notes

The vulnerability exists because validation is deferred to the storage layer rather than performed at the type level or immediately upon receipt. This violates the principle of **fail-fast validation** and enables resource exhaustion attacks. The lack of rate limiting or peer reputation tracking for consensus-layer epoch retrieval requests compounds the issue, as there is no mechanism to detect or throttle malicious peers exploiting this weakness.

### Citations

**File:** consensus/consensus-types/src/epoch_retrieval.rs (L9-12)
```rust
pub struct EpochRetrievalRequest {
    pub start_epoch: u64,
    pub end_epoch: u64,
}
```

**File:** consensus/src/network.rs (L869-900)
```rust
                        | ConsensusMsg::EpochRetrievalRequest(_)
                        | ConsensusMsg::EpochChangeProof(_)) => {
                            if let ConsensusMsg::ProposalMsg(proposal) = &consensus_msg {
                                observe_block(
                                    proposal.proposal().timestamp_usecs(),
                                    BlockStage::NETWORK_RECEIVED,
                                );
                                info!(
                                    LogSchema::new(LogEvent::NetworkReceiveProposal)
                                        .remote_peer(peer_id),
                                    block_round = proposal.proposal().round(),
                                    block_hash = proposal.proposal().id(),
                                );
                            }
                            if let ConsensusMsg::OptProposalMsg(proposal) = &consensus_msg {
                                observe_block(
                                    proposal.timestamp_usecs(),
                                    BlockStage::NETWORK_RECEIVED,
                                );
                                observe_block(
                                    proposal.timestamp_usecs(),
                                    BlockStage::NETWORK_RECEIVED_OPT_PROPOSAL,
                                );
                                info!(
                                    LogSchema::new(LogEvent::NetworkReceiveOptProposal)
                                        .remote_peer(peer_id),
                                    block_author = proposal.proposer(),
                                    block_epoch = proposal.epoch(),
                                    block_round = proposal.round(),
                                );
                            }
                            Self::push_msg(peer_id, consensus_msg, &self.consensus_messages_tx);
```

**File:** consensus/src/epoch_manager.rs (L451-476)
```rust
    fn process_epoch_retrieval(
        &mut self,
        request: EpochRetrievalRequest,
        peer_id: AccountAddress,
    ) -> anyhow::Result<()> {
        debug!(
            LogSchema::new(LogEvent::ReceiveEpochRetrieval)
                .remote_peer(peer_id)
                .epoch(self.epoch()),
            "[EpochManager] receive {}", request,
        );
        let proof = self
            .storage
            .aptos_db()
            .get_epoch_ending_ledger_infos(request.start_epoch, request.end_epoch)
            .map_err(DbError::from)
            .context("[EpochManager] Failed to get epoch proof")?;
        let msg = ConsensusMsg::EpochChangeProof(Box::new(proof));
        if let Err(err) = self.network_sender.send_to(peer_id, msg) {
            warn!(
                "[EpochManager] Failed to send epoch proof to {}, with error: {:?}",
                peer_id, err,
            );
        }
        Ok(())
    }
```

**File:** consensus/src/epoch_manager.rs (L1677-1686)
```rust
            ConsensusMsg::EpochRetrievalRequest(request) => {
                ensure!(
                    request.end_epoch <= self.epoch(),
                    "[EpochManager] Received EpochRetrievalRequest beyond what we have locally"
                );
                monitor!(
                    "process_epoch_retrieval",
                    self.process_epoch_retrieval(*request, peer_id)
                )?;
            },
```

**File:** consensus/src/epoch_manager.rs (L1933-1935)
```rust
                    if let Err(e) = self.process_message(peer, msg).await {
                        error!(epoch = self.epoch(), error = ?e, kind = error_kind(&e));
                    });
```

**File:** storage/aptosdb/src/db/aptosdb_reader.rs (L1007-1017)
```rust
    fn check_epoch_ending_ledger_infos_request(
        &self,
        start_epoch: u64,
        end_epoch: u64,
    ) -> Result<()> {
        ensure!(
            start_epoch <= end_epoch,
            "Bad epoch range [{}, {})",
            start_epoch,
            end_epoch,
        );
```

**File:** state-sync/storage-service/server/src/moderator.rs (L47-69)
```rust
    /// Increments the invalid request count for the peer and marks
    /// the peer to be ignored if it has sent too many invalid requests.
    /// Note: we only ignore peers on the public network.
    pub fn increment_invalid_request_count(&mut self, peer_network_id: &PeerNetworkId) {
        // Increment the invalid request count
        self.invalid_request_count += 1;

        // If the peer is a PFN and has sent too many invalid requests, start ignoring it
        if self.ignore_start_time.is_none()
            && peer_network_id.network_id().is_public_network()
            && self.invalid_request_count >= self.max_invalid_requests
        {
            // TODO: at some point we'll want to terminate the connection entirely

            // Start ignoring the peer
            self.ignore_start_time = Some(self.time_service.now());

            // Log the fact that we're now ignoring the peer
            warn!(LogSchema::new(LogEntry::RequestModeratorIgnoredPeer)
                .peer_network_id(peer_network_id)
                .message("Ignoring peer due to too many invalid requests!"));
        }
    }
```
