# Audit Report

## Title
BIBECiphertext Replay Attack Enabling Resource Exhaustion and Duplicate Transaction Execution

## Summary
The `BIBECiphertext` structure can be replayed across multiple transactions with different sequence numbers, bypassing all replay protection mechanisms. This occurs because ciphertext verification only validates the sender address (not sequence number), and encrypted payloads cannot use nonce-based replay protection due to a bug in the `replay_protection_nonce()` method. An attacker can copy a ciphertext from a previously executed encrypted transaction and submit it in new transactions, causing resource exhaustion from redundant decryption operations and duplicate execution of the same transaction payload.

## Finding Description

The vulnerability exists across multiple components in the encrypted transaction processing pipeline:

**1. Ciphertext Verification Uses Incomplete Associated Data**

The `PayloadAssociatedData` struct only contains the sender address, not the sequence number or any transaction-specific identifier: [1](#0-0) 

When encrypted payloads are verified, the ciphertext signature is checked against this associated data: [2](#0-1) 

This verification calls into the batch encryption ciphertext verification: [3](#0-2) 

Since the associated data only includes the sender address, a ciphertext that was valid for one transaction remains valid for all subsequent transactions from the same sender.

**2. Encrypted Payloads Cannot Use Nonce-Based Replay Protection**

The `TransactionPayload::replay_protection_nonce()` method explicitly returns `None` for encrypted payloads: [4](#0-3) 

This forces encrypted transactions to use sequence number-based replay protection, even though `EncryptedPayload` has an `extra_config` field that contains `replay_protection_nonce`: [5](#0-4) 

The `RawTransaction::replay_protector()` method relies on this broken `replay_protection_nonce()` call: [6](#0-5) 

**3. Transaction Deduplication Uses Sequence Number**

The transaction deduplicator uses `(sender, replay_protector)` as the key for identifying duplicates: [7](#0-6) 

Since encrypted transactions use `ReplayProtector::SequenceNumber`, transactions with the same ciphertext but different sequence numbers are treated as distinct and both allowed through.

**4. No Validation of Decryption Nonce**

The decryption pipeline extracts the `decryption_nonce` from the encrypted payload: [8](#0-7) 

However, there is no validation to check if this `decryption_nonce` has been used before. The nonce is stored in the `Decrypted` variant but never checked for replay: [9](#0-8) 

**Attack Scenario:**

1. User Alice creates encrypted transaction T1 with sequence number 100, containing ciphertext C
2. T1 is included in a block, decrypted to reveal (executable E, decryption_nonce N), and executed successfully
3. Attacker observes ciphertext C from the blockchain
4. Attacker creates transaction T2 with the SAME ciphertext C but sequence number 101
5. T2 passes verification (sender matches), bypasses deduplication (different sequence number), gets included in a block
6. T2 is decrypted, revealing the SAME (executable E, decryption_nonce N)
7. Transaction E executes again, causing duplicate execution

## Impact Explanation

This vulnerability qualifies as **Medium Severity** per the Aptos bug bounty criteria:

**Resource Exhaustion:** Each replayed ciphertext forces validators to perform expensive cryptographic operations including:
- Digest computation over all ciphertexts in the block
- Derivation of decryption key shares  
- Threshold secret reconstruction
- Individual ciphertext decryption using pairing operations

These operations are computationally intensive as shown in the decryption pipeline: [10](#0-9) 

**Duplicate Transaction Execution:** The same transaction executes multiple times with incrementing sequence numbers. If the transaction transfers funds, this could lead to:
- Unintended repeated fund transfers
- Account balance manipulation
- Limited funds loss

**State Inconsistencies:** Multiple executions of the same transaction payload with different sequence numbers create state inconsistencies that may require manual intervention to resolve.

The impact matches the "Limited funds loss or manipulation" and "State inconsistencies requiring intervention" criteria for Medium severity.

## Likelihood Explanation

**Likelihood: High**

The attack is trivially executable:
1. All encrypted transactions are publicly visible on the blockchain
2. Anyone can copy a ciphertext from a prior transaction
3. No special privileges or validator access required
4. No cryptographic knowledge needed beyond basic transaction construction
5. The attack works deterministically - every replayed ciphertext will pass all checks

The only prerequisite is that encrypted transaction submission must be enabled via the `allow_encrypted_txns_submission` configuration flag: [11](#0-10) 

## Recommendation

**Fix 1: Include Sequence Number in Associated Data**

Modify `PayloadAssociatedData` to include the sequence number:

```rust
#[derive(Clone, Debug, Hash, Eq, PartialEq, Serialize, Deserialize)]
pub struct PayloadAssociatedData {
    sender: AccountAddress,
    sequence_number: u64,  // ADD THIS
}
```

And update the encryption and verification flows to pass the sequence number.

**Fix 2: Enable Nonce-Based Replay Protection for Encrypted Payloads**

Update `TransactionPayload::replay_protection_nonce()` to handle encrypted payloads:

```rust
pub fn replay_protection_nonce(&self) -> Option<u64> {
    match self {
        Self::Payload(TransactionPayloadInner::V1 { extra_config, .. }) => {
            extra_config.replay_protection_nonce()
        },
        Self::EncryptedPayload(encrypted_payload) => {
            encrypted_payload.extra_config().replay_protection_nonce()  // ADD THIS
        },
        _ => None,
    }
}
```

**Fix 3: Validate Decryption Nonce for Replay**

Add validation in the transaction prologue or VM to track used `decryption_nonce` values and reject duplicates, similar to the existing nonce validation mechanism: [12](#0-11) 

**Recommended Solution:** Implement Fix 2 (enable nonce-based replay protection) as it leverages existing infrastructure and provides the strongest replay protection for encrypted transactions.

## Proof of Concept

**Step 1:** Create and submit an encrypted transaction:
```rust
// User creates encrypted transaction with sequence number 100
let plaintext = DecryptedPayload { 
    executable: transfer_100_coins_to_attacker(),
    decryption_nonce: 42 
};
let ciphertext = encryption_key.encrypt(&mut rng, &plaintext, &sender_address);
let tx1 = SignedTransaction::new(
    RawTransaction {
        sender: alice_address,
        sequence_number: 100,
        payload: TransactionPayload::EncryptedPayload(EncryptedPayload::Encrypted {
            ciphertext: ciphertext.clone(),  // Save ciphertext for replay
            extra_config: TransactionExtraConfig::default(),
            payload_hash: hash(&plaintext),
        }),
        // ... other fields
    },
    alice_signature
);
// tx1 is executed successfully
```

**Step 2:** Replay the same ciphertext with different sequence number:
```rust
// Attacker copies ciphertext from tx1 and creates tx2
let tx2 = SignedTransaction::new(
    RawTransaction {
        sender: alice_address,
        sequence_number: 101,  // DIFFERENT sequence number
        payload: TransactionPayload::EncryptedPayload(EncryptedPayload::Encrypted {
            ciphertext: ciphertext,  // SAME ciphertext as tx1
            extra_config: TransactionExtraConfig::default(),
            payload_hash: hash(&plaintext),
        }),
        // ... other fields
    },
    alice_signature
);
// tx2 passes all checks and executes the SAME transaction again
```

**Expected Result:** Both transactions execute successfully, transferring 100 coins twice (total 200 coins) to the attacker.

**Notes**

The vulnerability stems from architectural decisions that treated encrypted payloads as a special case without fully integrating them into the existing replay protection mechanisms. The ciphertext verification system was designed to be transaction-agnostic (only binding to sender address), which creates a security gap when combined with sequence number-based replay protection. The bug in `replay_protection_nonce()` that ignores encrypted payloads further compounds the issue by preventing users from opting into stronger nonce-based protection even if they wanted to.

### Citations

**File:** types/src/transaction/encrypted_payload.rs (L28-39)
```rust
#[derive(Clone, Debug, Hash, Eq, PartialEq, Serialize, Deserialize)]
pub struct PayloadAssociatedData {
    sender: AccountAddress,
}

impl PayloadAssociatedData {
    fn new(sender: AccountAddress) -> Self {
        Self { sender }
    }
}

impl AssociatedData for PayloadAssociatedData {}
```

**File:** types/src/transaction/encrypted_payload.rs (L41-64)
```rust
#[derive(Clone, Debug, Hash, Eq, PartialEq, Serialize, Deserialize)]
pub enum EncryptedPayload {
    Encrypted {
        ciphertext: Ciphertext,
        extra_config: TransactionExtraConfig,
        payload_hash: HashValue,
    },
    FailedDecryption {
        ciphertext: Ciphertext,
        extra_config: TransactionExtraConfig,
        payload_hash: HashValue,
        eval_proof: EvalProof,
    },
    Decrypted {
        ciphertext: Ciphertext,
        extra_config: TransactionExtraConfig,
        payload_hash: HashValue,
        eval_proof: EvalProof,

        // decrypted things
        executable: TransactionExecutable,
        decryption_nonce: u64,
    },
}
```

**File:** types/src/transaction/encrypted_payload.rs (L147-150)
```rust
    pub fn verify(&self, sender: AccountAddress) -> anyhow::Result<()> {
        let associated_data = PayloadAssociatedData::new(sender);
        self.ciphertext().verify(&associated_data)
    }
```

**File:** crates/aptos-batch-encryption/src/shared/ciphertext/mod.rs (L111-132)
```rust
    pub fn verify(&self, associated_data: &impl AssociatedData) -> Result<()> {
        let hashed_id = Id::from_verifying_key(&self.vk);

        (self.bibe_ct.id() == hashed_id).then_some(()).ok_or(
            BatchEncryptionError::CTVerifyError(CTVerifyError::IdDoesNotMatchHashedVK),
        )?;
        (self.associated_data_bytes == bcs::to_bytes(associated_data)?)
            .then_some(())
            .ok_or(BatchEncryptionError::CTVerifyError(
                CTVerifyError::AssociatedDataDoesNotMatch,
            ))?;

        let to_verify = (&self.bibe_ct, &self.associated_data_bytes);

        self.vk
            .verify(&bcs::to_bytes(&to_verify)?, &self.signature)
            .map_err(|e| {
                BatchEncryptionError::CTVerifyError(CTVerifyError::SigVerificationFailed(e))
            })?;

        Ok(())
    }
```

**File:** types/src/transaction/mod.rs (L579-585)
```rust
    pub fn replay_protector(&self) -> ReplayProtector {
        if let Some(nonce) = self.payload.replay_protection_nonce() {
            ReplayProtector::Nonce(nonce)
        } else {
            ReplayProtector::SequenceNumber(self.sequence_number)
        }
    }
```

**File:** types/src/transaction/mod.rs (L801-808)
```rust
    pub fn replay_protection_nonce(&self) -> Option<u64> {
        match self {
            Self::Payload(TransactionPayloadInner::V1 { extra_config, .. }) => {
                extra_config.replay_protection_nonce()
            },
            _ => None,
        }
    }
```

**File:** consensus/src/txn_hash_and_authenticator_deduper.rs (L39-59)
```rust
    fn dedup(&self, transactions: Vec<SignedTransaction>) -> Vec<SignedTransaction> {
        let _timer = TXN_DEDUP_SECONDS.start_timer();
        let mut seen = HashMap::new();
        let mut is_possible_duplicate = false;
        let mut possible_duplicates = vec![false; transactions.len()];
        for (i, txn) in transactions.iter().enumerate() {
            match seen.get(&(txn.sender(), txn.replay_protector())) {
                None => {
                    seen.insert((txn.sender(), txn.replay_protector()), i);
                },
                Some(first_index) => {
                    is_possible_duplicate = true;
                    possible_duplicates[*first_index] = true;
                    possible_duplicates[i] = true;
                },
            }
        }
        if !is_possible_duplicate {
            TXN_DEDUP_FILTERED.observe(0 as f64);
            return transactions;
        }
```

**File:** consensus/src/pipeline/decryption_pipeline_builder.rs (L90-119)
```rust
        // TODO(ibalajiarun): Consider using commit block height to reduce trusted setup size
        let encryption_round = block.round();
        let (digest, proofs_promise) =
            FPTXWeighted::digest(&digest_key, &txn_ciphertexts, encryption_round)?;

        let metadata = SecretShareMetadata::new(
            block.epoch(),
            block.round(),
            block.timestamp_usecs(),
            block.id(),
            digest.clone(),
        );

        let derived_key_share = FPTXWeighted::derive_decryption_key_share(&msk_share, &digest)?;
        derived_self_key_share_tx
            .send(Some(SecretShare::new(
                author,
                metadata.clone(),
                derived_key_share,
            )))
            .expect("must send properly");

        // TODO(ibalajiarun): improve perf
        let proofs = FPTXWeighted::eval_proofs_compute_all(&proofs_promise, &digest_key);

        let maybe_decryption_key = secret_shared_key_rx
            .await
            .expect("decryption key should be available");
        // TODO(ibalajiarun): account for the case where decryption key is not available
        let decryption_key = maybe_decryption_key.expect("decryption key should be available");
```

**File:** consensus/src/pipeline/decryption_pipeline_builder.rs (L121-148)
```rust
        let decrypted_txns = encrypted_txns
            .into_par_iter()
            .zip(txn_ciphertexts)
            .map(|(mut txn, ciphertext)| {
                let eval_proof = proofs.get(&ciphertext.id()).expect("must exist");
                if let Ok(payload) = FPTXWeighted::decrypt_individual::<DecryptedPayload>(
                    &decryption_key.key,
                    &ciphertext,
                    &digest,
                    &eval_proof,
                ) {
                    let (executable, nonce) = payload.unwrap();
                    txn.payload_mut()
                        .as_encrypted_payload_mut()
                        .map(|p| {
                            p.into_decrypted(eval_proof, executable, nonce)
                                .expect("must happen")
                        })
                        .expect("must exist");
                } else {
                    txn.payload_mut()
                        .as_encrypted_payload_mut()
                        .map(|p| p.into_failed_decryption(eval_proof).expect("must happen"))
                        .expect("must exist");
                }
                txn
            })
            .collect();
```

**File:** api/src/transactions.rs (L1323-1347)
```rust
            TransactionPayload::EncryptedPayload(payload) => {
                if !self.context.node_config.api.allow_encrypted_txns_submission {
                    return Err(SubmitTransactionError::bad_request_with_code(
                        "Encrypted Transaction submission is not allowed yet",
                        AptosErrorCode::InvalidInput,
                        ledger_info,
                    ));
                }

                if !payload.is_encrypted() {
                    return Err(SubmitTransactionError::bad_request_with_code(
                        "Encrypted transaction must be in encrypted state",
                        AptosErrorCode::InvalidInput,
                        ledger_info,
                    ));
                }

                if let Err(e) = payload.verify(signed_transaction.sender()) {
                    return Err(SubmitTransactionError::bad_request_with_code(
                        e.context("Encrypted transaction payload could not be verified"),
                        AptosErrorCode::InvalidInput,
                        ledger_info,
                    ));
                }
            },
```

**File:** aptos-move/framework/aptos-framework/sources/nonce_validation.move (L129-165)
```text
    public(friend) fun check_and_insert_nonce(
        sender_address: address,
        nonce: u64,
        txn_expiration_time: u64,
    ): bool acquires NonceHistory {
        assert!(exists<NonceHistory>(@aptos_framework), error::invalid_state(E_NONCE_HISTORY_DOES_NOT_EXIST));
        // Check if the transaction expiration time is too far in the future.
        assert!(txn_expiration_time <= timestamp::now_seconds() + NONCE_REPLAY_PROTECTION_OVERLAP_INTERVAL_SECONDS, error::invalid_argument(ETRANSACTION_EXPIRATION_TOO_FAR_IN_FUTURE));
        let nonce_history = &mut NonceHistory[@aptos_framework];
        let nonce_key = NonceKey {
            sender_address,
            nonce,
        };
        let bucket_index = sip_hash_from_value(&nonce_key) % NUM_BUCKETS;
        let current_time = timestamp::now_seconds();
        if (!nonce_history.nonce_table.contains(bucket_index)) {
            nonce_history.nonce_table.add(
                bucket_index,
                empty_bucket(false)
            );
        };
        let bucket = table::borrow_mut(&mut nonce_history.nonce_table, bucket_index);

        let existing_exp_time = bucket.nonce_to_exp_time_map.get(&nonce_key);
        if (existing_exp_time.is_some()) {
            let existing_exp_time = existing_exp_time.extract();

            // If the existing (address, nonce) pair has not expired, return false.
            if (existing_exp_time >= current_time) {
                return false;
            };

            // We maintain an invariant that two transaction with the same (address, nonce) pair cannot be stored
            // in the nonce history if their transaction expiration times are less than `NONCE_REPLAY_PROTECTION_OVERLAP_INTERVAL_SECONDS`
            // seconds apart.
            if (txn_expiration_time <= existing_exp_time + NONCE_REPLAY_PROTECTION_OVERLAP_INTERVAL_SECONDS) {
                return false;
```
