# Audit Report

## Title
Unbounded String Fields in NFT Metadata Crawler Database Allow Resource Exhaustion

## Summary
The `ParsedAssetUrisQuery` struct and related database models in the NFT metadata crawler accept unbounded string fields (`raw_image_uri`, `raw_animation_uri`, etc.) extracted from external JSON metadata. An attacker can create tokens with metadata URIs pointing to malicious JSON containing multi-megabyte URI strings, which are stored without length validation, leading to database bloat and potential memory exhaustion.

## Finding Description
The NFT metadata crawler extracts NFT metadata from external sources and stores it in a PostgreSQL database. While on-chain token URIs are limited to 512 characters by Move smart contract validation [1](#0-0) , the strings extracted from external JSON metadata have no such constraints.

The vulnerability exists in the following data flow:

1. **Database Schema**: The `parsed_asset_uris` table uses `Varchar` type without explicit size constraints [2](#0-1) . In PostgreSQL, unbounded VARCHAR fields can accept strings up to ~1GB.

2. **JSON Parsing**: The `JSONParser::parse()` function downloads JSON metadata files up to 15MB [3](#0-2)  and extracts "image" and "animation_url" fields as strings without length validation [4](#0-3) .

3. **Storage**: These unbounded strings are stored directly in the database [5](#0-4)  via the `upsert_uris()` function [6](#0-5)  without any length checks.

4. **Query Loading**: When queried, these large strings are loaded into memory [7](#0-6) .

**Attack Scenario**:
1. Attacker creates a token with a 512-character `asset_uri` pointing to attacker-controlled server
2. Server returns a 15MB JSON file containing "image" and "animation_url" fields with ~7MB URI strings each
3. Parser downloads JSON, extracts these multi-megabyte strings, and stores them unbounded in the database
4. With multiple such tokens, database bloat occurs and queries loading these records cause memory exhaustion

## Impact Explanation
This is a **Medium severity** issue affecting the NFT metadata crawler ecosystem service. While it does not directly impact consensus, validator operations, or on-chain funds, it can cause:

- **Database resource exhaustion**: Multi-megabyte strings per record cause significant database bloat
- **Query performance degradation**: Loading records with large VARCHAR fields degrades performance
- **Memory exhaustion**: Batch queries or table scans could exhaust available memory
- **Service degradation**: The metadata crawler service becomes unreliable for legitimate users

This does not meet Critical or High severity as it affects an off-chain indexing service rather than core blockchain components (consensus, execution, storage, governance, or staking).

## Likelihood Explanation
**High likelihood** due to:
- Any user can create tokens with custom metadata URIs (no privileged access required)
- Creating malicious JSON metadata is trivial
- No rate limiting on token creation beyond gas costs
- No validation exists in the code path
- Attack is economically viable (minimal gas cost per token)

## Recommendation
Implement length validation for all URI fields extracted from external sources:

1. Add a constant for maximum URI length (e.g., 2048 characters):
```rust
// In ecosystem/nft-metadata-crawler/src/utils/constants.rs
pub const MAX_EXTERNAL_URI_LENGTH: usize = 2048;
```

2. Validate and truncate extracted URIs in `JSONParser::parse()`:
```rust
// In ecosystem/nft-metadata-crawler/src/utils/json_parser.rs
use crate::utils::constants::MAX_EXTERNAL_URI_LENGTH;

let raw_image_uri = parsed_json["image"]
    .as_str()
    .map(|s| s.chars().take(MAX_EXTERNAL_URI_LENGTH).collect::<String>());
let raw_animation_uri = parsed_json["animation_url"]
    .as_str()
    .map(|s| s.chars().take(MAX_EXTERNAL_URI_LENGTH).collect::<String>());
```

3. Add database-level constraints by updating the migration schema to use `VARCHAR(2048)` instead of unbounded `VARCHAR`.

## Proof of Concept
```rust
// Proof of Concept demonstrating the vulnerability

#[cfg(test)]
mod tests {
    use super::*;
    
    #[tokio::test]
    async fn test_unbounded_uri_storage() {
        // Create a 5MB string (within 15MB JSON limit)
        let malicious_image_uri = "https://evil.com/".to_string() 
            + &"a".repeat(5_000_000);
        
        // Construct JSON with massive URI
        let json = serde_json::json!({
            "image": malicious_image_uri,
            "animation_url": "https://evil.com/" + &"b".repeat(5_000_000)
        });
        
        // This JSON would be accepted by JSONParser::parse()
        // since it checks file size but not individual field lengths
        let json_str = serde_json::to_string(&json).unwrap();
        assert!(json_str.len() < 15_000_000); // Under MAX_FILE_SIZE_BYTES
        
        // The extracted URIs would be stored unbounded in the database
        let raw_image_uri = json["image"].as_str().unwrap();
        assert!(raw_image_uri.len() > 5_000_000); // Multi-MB string
        
        // This demonstrates the vulnerability: massive strings
        // are extracted and stored without validation
    }
}
```

To reproduce:
1. Create a token on-chain with `uri` pointing to `https://attacker.com/metadata.json`
2. Host JSON at that URL containing multi-megabyte "image" and "animation_url" strings
3. Wait for NFT metadata crawler to process the token
4. Observe database contains multi-megabyte VARCHAR entries
5. Query the database and observe memory consumption

### Citations

**File:** aptos-move/framework/aptos-token/sources/token.move (L34-34)
```text
    const MAX_URI_LENGTH: u64 = 512;
```

**File:** ecosystem/nft-metadata-crawler/src/schema.rs (L29-34)
```rust
            asset_uri -> Varchar,
            raw_image_uri -> Nullable<Varchar>,
            raw_animation_uri -> Nullable<Varchar>,
            cdn_json_uri -> Nullable<Varchar>,
            cdn_image_uri -> Nullable<Varchar>,
            cdn_animation_uri -> Nullable<Varchar>,
```

**File:** ecosystem/nft-metadata-crawler/src/utils/constants.rs (L23-23)
```rust
pub const DEFAULT_MAX_FILE_SIZE_BYTES: u32 = 15_000_000;
```

**File:** ecosystem/nft-metadata-crawler/src/utils/json_parser.rs (L71-73)
```rust
                let raw_image_uri = parsed_json["image"].as_str().map(|s| s.to_string());
                let raw_animation_uri =
                    parsed_json["animation_url"].as_str().map(|s| s.to_string());
```

**File:** ecosystem/nft-metadata-crawler/src/parser/worker.rs (L136-137)
```rust
            self.model.set_raw_image_uri(raw_image_uri);
            self.model.set_raw_animation_uri(raw_animation_uri);
```

**File:** ecosystem/nft-metadata-crawler/src/utils/database.rs (L36-59)
```rust
pub fn upsert_uris(
    conn: &mut PooledConnection<ConnectionManager<PgConnection>>,
    entry: &ParsedAssetUris,
    ltv: i64,
) -> anyhow::Result<usize> {
    use schema::nft_metadata_crawler::parsed_asset_uris::dsl::*;

    let query = diesel::insert_into(schema::nft_metadata_crawler::parsed_asset_uris::table)
        .values(entry)
        .on_conflict(asset_uri)
        .do_update()
        .set((
            raw_image_uri.eq(excluded(raw_image_uri)),
            raw_animation_uri.eq(excluded(raw_animation_uri)),
            cdn_json_uri.eq(excluded(cdn_json_uri)),
            cdn_image_uri.eq(excluded(cdn_image_uri)),
            cdn_animation_uri.eq(excluded(cdn_animation_uri)),
            image_optimizer_retry_count.eq(excluded(image_optimizer_retry_count)),
            json_parser_retry_count.eq(excluded(json_parser_retry_count)),
            animation_optimizer_retry_count.eq(excluded(animation_optimizer_retry_count)),
            inserted_at.eq(excluded(inserted_at)),
            do_not_parse.eq(excluded(do_not_parse)),
            last_transaction_version.eq(ltv),
        ));
```

**File:** ecosystem/nft-metadata-crawler/src/models/parsed_asset_uris_query.rs (L20-25)
```rust
    pub asset_uri: String,
    pub raw_image_uri: Option<String>,
    pub raw_animation_uri: Option<String>,
    pub cdn_json_uri: Option<String>,
    pub cdn_image_uri: Option<String>,
    pub cdn_animation_uri: Option<String>,
```
