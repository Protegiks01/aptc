# Audit Report

## Title
Identifier Validation Bypass in TypeTag Deserialization Leading to Malformed Canonical Strings

## Summary
The `Identifier` type validates characters during construction via `Identifier::new()` but skips validation during deserialization (BCS/JSON), allowing attackers to craft `StructTag` objects with invalid identifiers containing special characters (`:`, `<`, `>`, `,`). This produces malformed canonical strings that violate format assumptions and could lead to type confusion or parsing errors in security-critical contexts.

## Finding Description

The Move type system enforces strict validation on identifiers: they can only contain characters `[a-zA-Z0-9_$]` and must follow specific naming rules. [1](#0-0) 

However, this validation is only enforced in the `Identifier::new()` constructor [2](#0-1)  and is completely bypassed during deserialization because `Identifier` derives `Deserialize` without custom validation. [3](#0-2) 

This is a **documented limitation** that developers are aware of, as evidenced by test code that explicitly demonstrates the bypass: [4](#0-3) 

The security impact arises when these malicious `StructTag` objects with invalid identifiers generate canonical strings via `to_canonical_string()`. [5](#0-4) 

The canonical string format assumes identifiers are well-formed and uses `::`, `<>`, and `,` as delimiters. When identifiers contain these delimiter characters, the canonical string becomes ambiguous. For example:
- A StructTag with module `"fake::real_module"` and name `"Struct"` produces: `"0x1::fake::real_module::Struct"`
- This could be misparsed as module `"real_module"` instead of `"fake::real_module"`

**Attack Vector:**
1. Attacker crafts a malicious transaction with an `EntryFunction` containing a `StructTag` with invalid identifiers
2. This is done by directly serializing invalid `Identifier` objects via BCS, bypassing `Identifier::new()` validation
3. When type checking occurs, `to_canonical_string()` generates a malformed canonical string
4. Security checks comparing canonical strings may behave incorrectly due to unexpected delimiter characters

**Critical Security Check Example:**
The Aptos Framework uses canonical string comparison for type identification: [6](#0-5) 

While this specific check would fail-closed (rejecting malformed strings), other code that parses or pattern-matches canonical strings could be vulnerable to confusion attacks.

## Impact Explanation

**Severity: Medium** 

This vulnerability falls under **Medium Severity** ($10,000) for the following reasons:

1. **State Inconsistencies**: Malformed canonical strings could cause parsing errors or incorrect type identification in systems that process these strings, requiring manual intervention to resolve.

2. **Type Confusion Risk**: Although the direct `is_apt()` check fails-closed, there may be other code paths that:
   - Parse canonical strings by splitting on `"::"` 
   - Use prefix/suffix matching on canonical strings
   - Store canonical strings in databases and later query them
   - Compare canonical strings in ways that could be confused by embedded delimiters

3. **Limited Exploitability**: The impact is reduced because:
   - Native functions like `type_info::type_name<T>()` work with type parameters from validated bytecode, not user-supplied data
   - Transaction validation likely rejects obviously malformed identifiers
   - Most security checks fail-closed rather than being bypassed

4. **Not Critical**: This does not directly enable:
   - Fund theft or minting
   - Consensus violations
   - Validator node crashes
   - Network partitions

## Likelihood Explanation

**Likelihood: Medium-High**

1. **Ease of Exploitation**: The bypass is trivial to execute - attackers can serialize malicious `Identifier` objects via BCS/JSON without any validation. [7](#0-6) 

2. **Known Limitation**: The fact that test code explicitly documents this bypass suggests it's a recognized issue that hasn't been prioritized for fixing.

3. **Attack Surface**: Any code path that:
   - Deserializes `TypeTag`/`StructTag` from untrusted input
   - Generates canonical strings for comparison, storage, or parsing
   - Makes security decisions based on canonical string content

4. **Mitigation Barriers**: Transaction validation and bytecode verification provide partial protection, but deserialized type tags from other sources (storage, APIs, cross-chain messages) may not be validated.

## Recommendation

**Implement validation during deserialization:**

Add a custom `Deserialize` implementation for `Identifier` that validates the deserialized string:

```rust
impl<'de> Deserialize<'de> for Identifier {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let s = Box::<str>::deserialize(deserializer)?;
        if !is_valid(&s) {
            return Err(serde::de::Error::custom(format!(
                "Invalid identifier '{}': contains disallowed characters",
                s
            )));
        }
        Ok(Self(s))
    }
}
```

**Apply the same validation to `StructTag` deserialization:**

Add validation in `StructTag` deserialization or implement a separate validated deserialization path for security-critical contexts.

**Alternative: Sanitize canonical strings:**

If backward compatibility prevents fixing deserialization, sanitize canonical strings before use in security checks by rejecting any that contain unexpected character patterns.

## Proof of Concept

The vulnerability is already demonstrated in the existing test code: [4](#0-3) 

This test shows how to bypass identifier validation and create invalid identifiers like `"transfer::what::what"` that contain the delimiter `"::"`.

**Extended PoC demonstrating malformed canonical strings:**

```rust
use move_core_types::{
    identifier::Identifier,
    language_storage::{StructTag, TypeTag},
    account_address::AccountAddress,
};

#[test]
fn test_malformed_canonical_string() {
    // Bypass Identifier validation via deserialization
    #[derive(serde::Serialize)]
    struct HackStruct(pub Box<str>);
    
    // Create identifier with embedded :: delimiter
    let malicious_module: Identifier = serde_json::from_str(
        &serde_json::to_string(&HackStruct("fake::aptos_coin".into())).unwrap()
    ).unwrap();
    
    let malicious_struct_tag = StructTag {
        address: AccountAddress::from_hex_literal("0x1").unwrap(),
        module: malicious_module,
        name: Identifier::new("AptosCoin").unwrap(),
        type_args: vec![],
    };
    
    // Generate malformed canonical string
    let canonical = malicious_struct_tag.to_canonical_string();
    println!("Malformed canonical string: {}", canonical);
    // Output: "0x1::fake::aptos_coin::AptosCoin"
    
    // This could be misparsed as module="aptos_coin" instead of "fake::aptos_coin"
    assert!(canonical.contains("::aptos_coin::"));
}
```

This PoC demonstrates that malicious canonical strings can be generated that contain ambiguous delimiters, potentially causing type confusion in code that parses these strings.

---

**Notes:**
- This vulnerability violates the documented invariant that canonical strings follow a well-defined format with unambiguous delimiters
- The test code comments explicitly acknowledge this limitation, suggesting it's a known issue that requires attention
- While the immediate impact on the `is_apt()` check is limited (it fails-closed), other uses of canonical strings throughout the codebase may be vulnerable to parsing confusion or type identification errors

### Citations

**File:** third_party/move/move-core/types/src/identifier.rs (L44-47)
```rust
#[inline]
pub const fn is_valid_identifier_char(c: char) -> bool {
    matches!(c, '_' | '$' | 'a'..='z' | 'A'..='Z' | '0'..='9')
}
```

**File:** third_party/move/move-core/types/src/identifier.rs (L109-114)
```rust
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, Deserialize)]
#[cfg_attr(
    any(test, feature = "fuzzing"),
    derive(arbitrary::Arbitrary, dearbitrary::Dearbitrary)
)]
pub struct Identifier(Box<str>);
```

**File:** third_party/move/move-core/types/src/identifier.rs (L117-126)
```rust
impl Identifier {
    /// Creates a new `Identifier` instance.
    pub fn new(s: impl Into<Box<str>>) -> Result<Self> {
        let s = s.into();
        if Self::is_valid(&s) {
            Ok(Self(s))
        } else {
            bail!("Invalid identifier '{}'", s);
        }
    }
```

**File:** api/src/tests/transactions_test.rs (L486-496)
```rust
    // This is a way to get around the Identifier checks!
    #[derive(serde::Serialize)]
    struct HackStruct(pub Box<str>);

    // Identifiers check when you call new, but they don't check when you deserialize, surprise!
    let module_id: Identifier =
        serde_json::from_str(&serde_json::to_string(&HackStruct("coin".into())).unwrap()).unwrap();
    let func: Identifier = serde_json::from_str(
        &serde_json::to_string(&HackStruct("transfer::what::what".into())).unwrap(),
    )
    .unwrap();
```

**File:** third_party/move/move-core/types/src/language_storage.rs (L267-291)
```rust
    pub fn to_canonical_string(&self) -> String {
        let generics = if self.type_args.is_empty() {
            "".to_string()
        } else {
            format!(
                "<{}>",
                self.type_args
                    .iter()
                    .map(|t| t.to_canonical_string())
                    .collect::<Vec<_>>()
                    .join(", ")
            )
        };
        format!(
            // Note:
            //   For historical reasons, we convert addresses as strings using 0x... and trimming
            //   leading zeroes. This cannot be changed easily because 0x1::any::Any relies on that
            //   and may store bytes of these strings on-chain.
            "0x{}::{}::{}{}",
            self.address.short_str_lossless(),
            self.module,
            self.name,
            generics
        )
    }
```

**File:** aptos-move/framework/aptos-framework/sources/coin.move (L321-323)
```text
    inline fun is_apt<CoinType>(): bool {
        type_info::type_name<CoinType>() == string::utf8(b"0x1::aptos_coin::AptosCoin")
    }
```
