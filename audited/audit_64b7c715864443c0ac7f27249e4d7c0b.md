# Audit Report

## Title
OrderVote Equivocation: Missing Safety Check Allows Validators to Sign Multiple OrderVotes for Same Round with Different Transaction Sets

## Summary
The `guarded_construct_and_sign_order_vote()` function in SafetyRules lacks equivocation prevention, allowing malicious validators to sign multiple OrderVotes for the same round with different transaction sets. Unlike regular votes which store and check `last_vote`, OrderVotes have no equivalent protection, violating consensus safety guarantees.

## Finding Description

The Aptos 2-chain consensus protocol uses OrderVotes to certify transaction ordering after a block receives a QuorumCert. The safety rules implementation for OrderVotes is critically flawed compared to regular votes.

**Regular Vote Protection (Present):** [1](#0-0) 

Regular votes check if the validator already voted on this round and return the cached vote, preventing equivocation. [2](#0-1) 

The vote is stored in `safety_data.last_vote` for future checks.

**OrderVote Protection (Missing):** [3](#0-2) 

The `guarded_construct_and_sign_order_vote()` function has NO check to prevent signing multiple OrderVotes for the same round. It only validates:
1. The OrderVoteProposal structure
2. That `round > highest_timeout_round` via `safe_for_order_vote()` [4](#0-3) 

The `safe_for_order_vote()` check only prevents OrderVotes for rounds at or below the highest timeout round, providing no protection against equivocation.

**Critical Missing Field:** [5](#0-4) 

SafetyData stores `last_vote: Option<Vote>` but has NO `last_order_vote` field. This architectural gap allows unlimited OrderVote signing for the same round.

**Block ID Includes Transactions:** [6](#0-5) 

The block hash (ID) includes the payload (transactions) through BCS serialization. Different transaction sets produce different block IDs, allowing distinct OrderVotes for the same round.

**Aggregation Permits Multiple Certificates:** [7](#0-6) 

OrderVotes are aggregated by LedgerInfo digest (which includes block_id). Different transaction sets create separate aggregation buckets, enabling multiple conflicting certificates for the same round.

**Attack Path:**
1. Malicious validator receives OrderVoteProposal for round R with block containing transactions T1
2. Calls `construct_and_sign_order_vote()` → gets signed OrderVote for block_id_1 (hash of T1)
3. Same validator constructs OrderVoteProposal for round R with different transactions T2
4. Calls `construct_and_sign_order_vote()` again → gets signed OrderVote for block_id_2 (hash of T2)
5. Both signatures are valid; no safety rule prevents this
6. Different nodes may receive different OrderVotes, potentially forming conflicting quorum certificates

**About retry():** [8](#0-7) 

The `retry()` mechanism only retries on initialization errors. While it doesn't directly enable the attack, it also provides no additional protection. The vulnerability exists in the underlying safety rules implementation.

## Impact Explanation

**HIGH Severity** - This constitutes a significant protocol violation meeting the Aptos bug bounty criteria:

1. **Consensus Safety Violation**: Validators can equivocate on transaction ordering, breaking the fundamental safety guarantee that all honest validators agree on the same ordered transaction sequence
2. **Deterministic Execution Broken**: Different nodes receiving different OrderVotes could execute different transaction sets, violating Invariant #1
3. **Network Inconsistency**: If enough validators equivocate, nodes could form different OrderVote quorum certificates for the same round, causing state divergence
4. **No Automatic Recovery**: Unlike transient network issues, signed equivocal OrderVotes persist and could propagate through the network

This directly violates the documented invariant: **"Consensus Safety: AptosBFT must prevent double-spending and chain splits under < 1/3 Byzantine"**. While preventing equivocation is the safety rules' primary responsibility, the implementation fails for OrderVotes.

## Likelihood Explanation

**Medium-High Likelihood:**

**Requires:**
- Malicious or compromised validator node
- Modified consensus client to call `construct_and_sign_order_vote()` multiple times
- No collusion needed - single malicious validator sufficient

**Mitigating Factors:**
- Validators are trusted operators with strong incentives for honest behavior
- Requires deliberately malicious action, not accidental misconfiguration
- Network monitoring could detect equivocation if comparing OrderVote messages

**Aggravating Factors:**
- Safety rules SHOULD prevent this even for malicious validators - that's their purpose
- No cryptographic or protocol-level prevention once safety rules are bypassed
- Single compromised validator can inject conflicting OrderVotes into the network
- The vulnerability is structural, not a transient state issue

## Recommendation

Add equivocation prevention for OrderVotes matching the existing protection for regular votes:

**1. Extend SafetyData:**
```rust
// In consensus/consensus-types/src/safety_data.rs
pub struct SafetyData {
    pub epoch: u64,
    pub last_voted_round: u64,
    pub preferred_round: u64,
    pub one_chain_round: u64,
    pub last_vote: Option<Vote>,
    pub last_order_vote: Option<OrderVote>,  // ADD THIS FIELD
    pub highest_timeout_round: u64,
}
```

**2. Add Equivocation Check:**
```rust
// In consensus/safety-rules/src/safety_rules_2chain.rs
pub(crate) fn guarded_construct_and_sign_order_vote(
    &mut self,
    order_vote_proposal: &OrderVoteProposal,
) -> Result<OrderVote, Error> {
    self.signer()?;
    self.verify_order_vote_proposal(order_vote_proposal)?;
    let proposed_block = order_vote_proposal.block();
    let mut safety_data = self.persistent_storage.safety_data()?;
    
    // ADD THIS CHECK: If already signed OrderVote for this round, return it
    if let Some(last_order_vote) = safety_data.last_order_vote.clone() {
        if last_order_vote.ledger_info().round() == proposed_block.round() {
            return Ok(last_order_vote);
        }
    }
    
    self.observe_qc(order_vote_proposal.quorum_cert(), &mut safety_data);
    self.safe_for_order_vote(proposed_block, &safety_data)?;
    
    let author = self.signer()?.author();
    let ledger_info = LedgerInfo::new(
        order_vote_proposal.block_info().clone(),
        HashValue::zero()
    );
    let signature = self.sign(&ledger_info)?;
    let order_vote = OrderVote::new_with_signature(
        author,
        ledger_info.clone(),
        signature
    );
    
    // ADD THIS: Store the OrderVote
    safety_data.last_order_vote = Some(order_vote.clone());
    self.persistent_storage.set_safety_data(safety_data)?;
    Ok(order_vote)
}
```

**3. Clear OrderVote on Epoch/Round Progression:**
Ensure `last_order_vote` is cleared appropriately when advancing to new epochs or when the round advances beyond the OrderVote's relevance, similar to how `last_vote` is managed.

## Proof of Concept

```rust
#[cfg(test)]
mod order_vote_equivocation_test {
    use super::*;
    use aptos_consensus_types::{
        block::Block,
        block_data::BlockData,
        order_vote_proposal::OrderVoteProposal,
        quorum_cert::QuorumCert,
        common::Payload,
    };
    use aptos_types::block_info::BlockInfo;
    use std::sync::Arc;
    
    #[test]
    fn test_order_vote_equivocation_vulnerability() {
        // Setup: Create validator with safety rules
        let (mut safety_rules, validator_signer) = create_test_safety_rules();
        
        // Create two different blocks for the same round with different payloads
        let round = 10;
        let qc = QuorumCert::dummy();
        
        // Block 1 with payload T1
        let payload1 = Payload::empty(false, true);
        let block1 = Block::new_proposal(
            payload1,
            round,
            100,
            qc.clone(),
            &validator_signer,
            vec![]
        ).unwrap();
        
        // Block 2 with different payload T2  
        let payload2 = Payload::DirectMempool(vec![/* different txns */]);
        let block2 = Block::new_proposal(
            payload2,
            round, // SAME ROUND
            100,
            qc.clone(),
            &validator_signer,
            vec![]
        ).unwrap();
        
        // Create OrderVoteProposals for both blocks
        let block_info1 = block1.gen_block_info(HashValue::zero(), 0, None);
        let proposal1 = OrderVoteProposal::new(
            block1,
            block_info1,
            Arc::new(qc.clone())
        );
        
        let block_info2 = block2.gen_block_info(HashValue::zero(), 0, None);
        let proposal2 = OrderVoteProposal::new(
            block2,
            block_info2,
            Arc::new(qc.clone())
        );
        
        // VULNERABILITY: Both calls succeed, signing different OrderVotes for same round
        let order_vote1 = safety_rules
            .construct_and_sign_order_vote(&proposal1)
            .expect("First OrderVote should succeed");
        
        let order_vote2 = safety_rules
            .construct_and_sign_order_vote(&proposal2)
            .expect("Second OrderVote should succeed"); // SHOULD FAIL OR RETURN order_vote1
        
        // Verify equivocation: same round, different block IDs
        assert_eq!(order_vote1.ledger_info().round(), order_vote2.ledger_info().round());
        assert_ne!(
            order_vote1.ledger_info().consensus_block_id(),
            order_vote2.ledger_info().consensus_block_id()
        );
        
        // Both are validly signed by the same validator
        assert_eq!(order_vote1.author(), order_vote2.author());
        
        println!("VULNERABILITY CONFIRMED: Validator signed two different OrderVotes for round {}", round);
    }
}
```

## Notes

The security question explicitly asks about malicious validator behavior ("Can validators maliciously exclude specific transactions"), which places this vulnerability in scope. Safety rules exist precisely to constrain malicious validators from breaking consensus safety, even when running modified code. The failure to prevent OrderVote equivocation represents a critical gap in the safety rules architecture that could be exploited during consensus attacks or validator compromise scenarios.

### Citations

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L70-74)
```rust
        if let Some(vote) = safety_data.last_vote.clone() {
            if vote.vote_data().proposed().round() == proposed_block.round() {
                return Ok(vote);
            }
        }
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L91-91)
```rust
        safety_data.last_vote = Some(vote.clone());
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L97-119)
```rust
    pub(crate) fn guarded_construct_and_sign_order_vote(
        &mut self,
        order_vote_proposal: &OrderVoteProposal,
    ) -> Result<OrderVote, Error> {
        // Exit early if we cannot sign
        self.signer()?;
        self.verify_order_vote_proposal(order_vote_proposal)?;
        let proposed_block = order_vote_proposal.block();
        let mut safety_data = self.persistent_storage.safety_data()?;

        // Record 1-chain data
        self.observe_qc(order_vote_proposal.quorum_cert(), &mut safety_data);

        self.safe_for_order_vote(proposed_block, &safety_data)?;
        // Construct and sign order vote
        let author = self.signer()?.author();
        let ledger_info =
            LedgerInfo::new(order_vote_proposal.block_info().clone(), HashValue::zero());
        let signature = self.sign(&ledger_info)?;
        let order_vote = OrderVote::new_with_signature(author, ledger_info.clone(), signature);
        self.persistent_storage.set_safety_data(safety_data)?;
        Ok(order_vote)
    }
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L168-178)
```rust
    fn safe_for_order_vote(&self, block: &Block, safety_data: &SafetyData) -> Result<(), Error> {
        let round = block.round();
        if round > safety_data.highest_timeout_round {
            Ok(())
        } else {
            Err(Error::NotSafeForOrderVote(
                round,
                safety_data.highest_timeout_round,
            ))
        }
    }
```

**File:** consensus/consensus-types/src/safety_data.rs (L9-21)
```rust
#[derive(Debug, Deserialize, Eq, PartialEq, Serialize, Clone, Default)]
pub struct SafetyData {
    pub epoch: u64,
    pub last_voted_round: u64,
    // highest 2-chain round, used for 3-chain
    pub preferred_round: u64,
    // highest 1-chain round, used for 2-chain
    #[serde(default)]
    pub one_chain_round: u64,
    pub last_vote: Option<Vote>,
    #[serde(default)]
    pub highest_timeout_round: u64,
}
```

**File:** consensus/consensus-types/src/block_data.rs (L105-134)
```rust
impl CryptoHash for BlockData {
    type Hasher = BlockDataHasher;

    fn hash(&self) -> HashValue {
        let mut state = Self::Hasher::default();
        if self.is_opt_block() {
            #[derive(Serialize)]
            struct OptBlockDataForHash<'a> {
                epoch: u64,
                round: Round,
                timestamp_usecs: u64,
                quorum_cert_vote_data: &'a VoteData,
                block_type: &'a BlockType,
            }

            let opt_block_data_for_hash = OptBlockDataForHash {
                epoch: self.epoch,
                round: self.round,
                timestamp_usecs: self.timestamp_usecs,
                quorum_cert_vote_data: self.quorum_cert.vote_data(),
                block_type: &self.block_type,
            };
            bcs::serialize_into(&mut state, &opt_block_data_for_hash)
                .expect("OptBlockDataForHash must be serializable");
        } else {
            bcs::serialize_into(&mut state, &self).expect("BlockData must be serializable");
        }
        state.finish()
    }
}
```

**File:** consensus/src/pending_order_votes.rs (L61-81)
```rust
    pub fn insert_order_vote(
        &mut self,
        order_vote: &OrderVote,
        validator_verifier: &ValidatorVerifier,
        verified_quorum_cert: Option<QuorumCert>,
    ) -> OrderVoteReceptionResult {
        // derive data from order vote
        let li_digest = order_vote.ledger_info().hash();

        // obtain the ledger info with signatures associated to the order vote's ledger info
        let (quorum_cert, status) = self.li_digest_to_votes.entry(li_digest).or_insert_with(|| {
            // if the ledger info with signatures doesn't exist yet, create it
            (
                verified_quorum_cert.expect(
                    "Quorum Cert is expected when creating a new entry in pending order votes",
                ),
                OrderVoteStatus::NotEnoughVotes(SignatureAggregator::new(
                    order_vote.ledger_info().clone(),
                )),
            )
        });
```

**File:** consensus/src/metrics_safety_rules.rs (L71-85)
```rust
    fn retry<T, F: FnMut(&mut Box<dyn TSafetyRules + Send + Sync>) -> Result<T, Error>>(
        &mut self,
        mut f: F,
    ) -> Result<T, Error> {
        let result = f(&mut self.inner);
        match result {
            Err(Error::NotInitialized(_))
            | Err(Error::IncorrectEpoch(_, _))
            | Err(Error::WaypointOutOfDate(_, _, _, _)) => {
                self.perform_initialize()?;
                f(&mut self.inner)
            },
            _ => result,
        }
    }
```
