# Audit Report

## Title
Public Exposure of Sensitive Validator Metrics via Unauthenticated Inspection Service Endpoints

## Summary
The Aptos inspection service exposes sensitive validator operational metrics through unauthenticated HTTP endpoints (`/forge_metrics`, `/json_metrics`, `/metrics`) that bind to `0.0.0.0:9101` by default. These endpoints leak validator identities, voting power distribution, real-time consensus participation patterns, and network topology information that should be restricted to authenticated monitoring systems only.

## Finding Description

The `get_all_metrics()` function gathers ALL Prometheus metrics from the node and exposes them via public HTTP endpoints without any application-level access controls. [1](#0-0) 

These metrics are exposed through three endpoints that lack any authentication or authorization checks: [2](#0-1) 

The service binds to all network interfaces by default: [3](#0-2) 

**Sensitive Information Exposed:**

1. **Validator Identity Mapping** - The metrics expose validator addresses as labels in multiple metrics, including `ALL_VALIDATORS_VOTING_POWER` which maps every validator's address to their voting power: [4](#0-3) [5](#0-4) 

2. **Real-time Voting Patterns** - Metrics track which validators voted in each round: [6](#0-5) [7](#0-6) 

3. **Network Topology** - Connection status between validators is exposed via peer_id labels: [8](#0-7) 

**Lack of Access Controls:**

Unlike other sensitive endpoints (`/configuration`, `/identity_information`, `/peer_information`) which have `expose_*` configuration flags: [9](#0-8) 

The metrics endpoints have NO such protection and are always publicly accessible: [10](#0-9) 

**Infrastructure vs Application-Level Security:**

While Kubernetes deployments use NetworkPolicy to restrict access, the Docker Compose configuration reveals the intended behavior - metrics should bind to localhost only: [11](#0-10) 

However, the application code itself provides no such protection, creating a defense-in-depth failure. Nodes deployed on bare metal, VMs, or with misconfigured firewalls will expose metrics publicly.

## Impact Explanation

This constitutes a **High Severity** information disclosure vulnerability that enables targeted attacks against the Aptos validator network:

1. **Validator Deanonymization** - Attackers can correlate on-chain addresses with real-time operational metrics to identify and profile specific validator operators.

2. **Network Intelligence** - Real-time visibility into which validators are voting, their connection patterns, and participation rates enables sophisticated attack planning including eclipse attacks and targeted network disruptions.

3. **Consensus Monitoring** - External parties can monitor internal consensus state (current round, voting patterns, timeout votes) to gain strategic advantages or detect vulnerabilities in real-time.

4. **Operational Security Breach** - The exposed metrics reveal internal debugging information about node performance, resource utilization, and state that should be restricted to authorized operators only.

While this doesn't directly cause consensus violations or fund loss, it provides critical intelligence that significantly lowers the barrier for subsequent attacks. The Docker Compose configuration binding to `127.0.0.1` demonstrates that developers recognized metrics should NOT be public, but failed to implement application-level controls.

## Likelihood Explanation

**Very High Likelihood** - This vulnerability is automatically exploitable on any Aptos node that:
- Is deployed outside Kubernetes (bare metal, VMs, Docker without custom networking)
- Has misconfigured Kubernetes NetworkPolicy
- Has misconfigured firewall rules
- Uses the default configuration without infrastructure-level restrictions

No authentication, authorization, or special access is required - simply making an HTTP GET request to `http://<node-ip>:9101/forge_metrics` returns all sensitive metrics in JSON format.

## Recommendation

Implement application-level access controls for metrics endpoints:

1. **Add Configuration Flags** - Introduce `expose_metrics` flag in `InspectionServiceConfig` (defaulting to `false` for production):

```rust
pub struct InspectionServiceConfig {
    pub address: String,
    pub port: u16,
    pub expose_configuration: bool,
    pub expose_identity_information: bool,
    pub expose_peer_information: bool,
    pub expose_system_information: bool,
    pub expose_metrics: bool,  // NEW: default to false
}
```

2. **Enforce Access Control** - Modify metrics handlers to check the flag:

```rust
pub fn handle_forge_metrics(node_config: &NodeConfig) -> (StatusCode, Body, String) {
    if !node_config.inspection_service.expose_metrics {
        return (
            StatusCode::FORBIDDEN,
            Body::from("Metrics endpoint is disabled for security"),
            CONTENT_TYPE_TEXT.into(),
        );
    }
    // existing logic...
}
```

3. **Bind to Localhost by Default** - Change default address to `"127.0.0.1"` instead of `"0.0.0.0"` to prevent accidental public exposure.

4. **Add Authentication** - Consider implementing token-based authentication for metrics endpoints in production environments.

## Proof of Concept

```bash
# Exploit: Query publicly exposed metrics endpoint
curl -s http://<aptos-node-ip>:9101/forge_metrics | jq '.' | head -50

# Expected output (sensitive data):
# {
#   "aptos_all_validators_voting_power{peer_id=\"0x1a2b3c...\"}": "100000000",
#   "aptos_all_validators_voting_power{peer_id=\"0x4d5e6f...\"}": "95000000",
#   "aptos_consensus_current_round_voted_power{peer_id=\"0x1a2b3c...\",hash_index=\"0\"}": "100000000",
#   "aptos_network_peer_connected{role_type=\"validator\",network_id=\"Validator\",peer_id=\"0x1a2b3c...\",remote_peer_id=\"0x4d5e6f...\"}": "1",
#   ...
# }

# Demonstrates:
# 1. All validator addresses exposed (peer_id labels)
# 2. Voting power for each validator
# 3. Which validators voted in current round
# 4. Network connection topology between validators
# 5. No authentication required - completely public
```

**Validation:**
- Deploy Aptos node on VM/bare metal with default config
- Ensure port 9101 is network-accessible
- Execute curl command from external machine
- Observe full metrics dump containing sensitive validator information

## Notes

This vulnerability represents a critical defense-in-depth failure. While infrastructure-level mitigations (Kubernetes NetworkPolicy, Docker localhost binding) exist in reference deployments, the application code itself lacks proper access controls. This violates the principle of defense-in-depth and creates severe risks for operators who:

- Deploy on non-Kubernetes infrastructure
- Use custom deployment configurations
- Have firewall misconfigurations

The inconsistency between protected endpoints (`/configuration` with `expose_configuration` flag) and unprotected metrics endpoints suggests this was an oversight rather than intentional design. The Docker Compose configuration explicitly binding metrics to `127.0.0.1` confirms metrics should not be publicly accessible.

### Citations

**File:** crates/aptos-inspection-service/src/server/utils.rs (L25-29)
```rust
/// A simple utility function that returns all metrics as a HashMap
pub fn get_all_metrics() -> HashMap<String, String> {
    let metric_families = get_metric_families();
    get_metrics_map(metric_families)
}
```

**File:** crates/aptos-inspection-service/src/server/metrics.rs (L50-64)
```rust
/// Handles a new forge metrics request
pub fn handle_forge_metrics() -> (StatusCode, Body, String) {
    // Get and encode the metrics
    let metrics = utils::get_all_metrics();
    let encoded_metrics = match serde_json::to_string(&metrics) {
        Ok(encoded_metrics) => encoded_metrics,
        Err(error) => format!("Failed to get forge metrics! Error: {}", error),
    };

    (
        StatusCode::OK,
        Body::from(encoded_metrics),
        CONTENT_TYPE_JSON.into(),
    )
}
```

**File:** config/src/config/inspection_service_config.rs (L26-36)
```rust
impl Default for InspectionServiceConfig {
    fn default() -> InspectionServiceConfig {
        InspectionServiceConfig {
            address: "0.0.0.0".to_string(),
            port: 9101,
            expose_configuration: false,
            expose_identity_information: true,
            expose_peer_information: true,
            expose_system_information: true,
        }
    }
```

**File:** consensus/src/counters.rs (L537-545)
```rust
/// Emits voting power for all validators in the current epoch.
pub static ALL_VALIDATORS_VOTING_POWER: Lazy<IntGaugeVec> = Lazy::new(|| {
    register_int_gauge_vec!(
        "aptos_all_validators_voting_power",
        "Voting power for all validators in current epoch",
        &["peer_id"]
    )
    .unwrap()
});
```

**File:** consensus/src/counters.rs (L556-564)
```rust
/// For the current ordering round, for each peer, whether they have voted, and for which hash_index
pub static CONSENSUS_CURRENT_ROUND_VOTED_POWER: Lazy<GaugeVec> = Lazy::new(|| {
    register_gauge_vec!(
        "aptos_consensus_current_round_voted_power",
        "Counter for consensus participation status, 0 means no participation and 1 otherwise",
        &["peer_id", "hash_index"]
    )
    .unwrap()
});
```

**File:** consensus/src/epoch_manager.rs (L790-798)
```rust
        epoch_state
            .verifier
            .get_ordered_account_addresses_iter()
            .for_each(|peer_id| {
                counters::ALL_VALIDATORS_VOTING_POWER
                    .with_label_values(&[&peer_id.to_string()])
                    .set(epoch_state.verifier.get_voting_power(&peer_id).unwrap_or(0) as i64)
            });
    }
```

**File:** consensus/src/pending_votes.rs (L347-357)
```rust
        if !vote.is_timeout() {
            counters::CONSENSUS_CURRENT_ROUND_VOTED_POWER
                .with_label_values(&[&vote.author().to_string(), &hash_index_to_str(*hash_index)])
                .set(validator_voting_power as f64);
            counters::CONSENSUS_LAST_VOTE_EPOCH
                .with_label_values(&[&vote.author().to_string()])
                .set(cur_epoch);
            counters::CONSENSUS_LAST_VOTE_ROUND
                .with_label_values(&[&vote.author().to_string()])
                .set(cur_round);
        }
```

**File:** network/framework/src/counters.rs (L86-106)
```rust
pub static APTOS_NETWORK_PEER_CONNECTED: Lazy<IntGaugeVec> = Lazy::new(|| {
    register_int_gauge_vec!(
        "aptos_network_peer_connected",
        "Indicates if we are connected to a particular peer",
        &["role_type", "network_id", "peer_id", "remote_peer_id"]
    )
    .unwrap()
});

pub fn peer_connected(network_context: &NetworkContext, remote_peer_id: &PeerId, v: i64) {
    if network_context.network_id().is_validator_network() {
        APTOS_NETWORK_PEER_CONNECTED
            .with_label_values(&[
                network_context.role().as_str(),
                network_context.network_id().as_str(),
                network_context.peer_id().short_str().as_str(),
                remote_peer_id.short_str().as_str(),
            ])
            .set(v)
    }
}
```

**File:** crates/aptos-inspection-service/src/server/configuration.rs (L12-26)
```rust
/// Handles a new configuration request
pub fn handle_configuration_request(node_config: &NodeConfig) -> (StatusCode, Body, String) {
    // Only return configuration if the endpoint is enabled
    let (status_code, body) = if node_config.inspection_service.expose_configuration {
        // We format the configuration using debug formatting. This is important to
        // prevent secret/private keys from being serialized and leaked (i.e.,
        // all secret keys are marked with SilentDisplay and SilentDebug).
        let encoded_configuration = format!("{:?}", node_config);
        (StatusCode::OK, Body::from(encoded_configuration))
    } else {
        (
            StatusCode::FORBIDDEN,
            Body::from(CONFIGURATION_DISABLED_MESSAGE),
        )
    };
```

**File:** crates/aptos-inspection-service/src/server/mod.rs (L122-146)
```rust
        FORGE_METRICS_PATH => {
            // /forge_metrics
            // Exposes forge encoded metrics
            metrics::handle_forge_metrics()
        },
        IDENTITY_INFORMATION_PATH => {
            // /identity_information
            // Exposes the identity information of the node
            identity_information::handle_identity_information_request(&node_config)
        },
        INDEX_PATH => {
            // /
            // Exposes the index and list of available endpoints
            index::handle_index_request()
        },
        JSON_METRICS_PATH => {
            // /json_metrics
            // Exposes JSON encoded metrics
            metrics::handle_json_metrics_request()
        },
        METRICS_PATH => {
            // /metrics
            // Exposes text encoded metrics
            metrics::handle_metrics_request()
        },
```

**File:** docker/compose/aptos-node/docker-compose.yaml (L31-33)
```yaml
      # Preface these with 127 to only expose them locally
      - "127.0.0.1:9101:9101"
      - "127.0.0.1:9102:9102"
```
