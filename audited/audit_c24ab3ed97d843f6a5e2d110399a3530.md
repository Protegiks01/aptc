# Audit Report

## Title
UserTransactionPayloadFilter Bypass via Script and WriteSet Payloads in Indexer-GRPC Data Service

## Summary
The `UserTransactionPayloadFilter` in the indexer-grpc transaction filtering system only filters EntryFunctionPayload types while silently allowing Script and WriteSet payloads to bypass filtering, potentially defeating emergency stripping mechanisms used to prevent data service degradation.

## Finding Description

The `UserTransactionPayloadFilter` struct contains only a single field for filtering entry functions: [1](#0-0) 

When the filter's `matches` method is invoked on transactions, it extracts entry function payloads using the helper function `get_entry_function_payload_from_transaction_payload`: [2](#0-1) 

The helper function only extracts EntryFunctionPayload from EntryFunction and Multisig transaction types, returning `None` for Script and WriteSet payloads: [3](#0-2) 

The critical vulnerability occurs when a payload filter is configured but the transaction contains a Script or WriteSet payload. In this case, `get_entry_function_payload_from_transaction_payload` returns `None`, the inner `if let Some(payload)` block is skipped, and the function returns `true` (line 114), allowing the transaction through.

The indexer-grpc data service uses this filter mechanism for emergency stripping of problematic transactions: [4](#0-3) 

The `strip_transactions` function removes payloads, signatures, events, and writesets from transactions that match the filter: [5](#0-4) 

**Attack Scenario:**
1. Operator configures filter to strip transactions from module `0x1234::large_module::*` due to size issues causing data service problems
2. Attacker submits Script payload transactions that invoke the same problematic module
3. Script payloads bypass the filter (return `true` instead of matching against the filter criteria)
4. Script transactions are NOT stripped, defeating the emergency mitigation
5. Data service continues to experience degradation from large payloads

## Impact Explanation

This qualifies as **Medium severity** under the Aptos bug bounty criteria for the following reasons:

**State Inconsistencies:** The filtering mechanism creates data inconsistency where EntryFunction transactions from a module are stripped but Script transactions from the same module bypass filtering. This leads to incomplete data stripping and unpredictable indexer behavior.

**Service Availability:** The emergency stripping mechanism documented in the config is designed to prevent data service issues when "txns related to a certain module are too large and are causing issues for the data service." Script payload bypass defeats this protection, potentially allowing continued service degradation.

While this affects indexer infrastructure rather than core consensus, the indexer-grpc data service is production infrastructure serving blockchain data to wallets, explorers, and other critical downstream consumers. The documented use case is emergency response to service issues, making the bypass a significant operational security concern.

## Likelihood Explanation

**Likelihood: Medium**

The vulnerability is likely to be exploited in the following scenarios:

1. **Emergency Response Failure:** When operators deploy filters during service incidents, attackers could bypass filters by using Script payloads, prolonging the incident
2. **Unintentional Bypass:** Legitimate users submitting Script transactions may inadvertently bypass intended filtering policies
3. **Script Transaction Availability:** Script payloads are fully supported in the Aptos protocol and can be submitted by any user without special privileges

The barrier to exploitation is low - any user can submit Script payload transactions through the standard transaction submission API.

## Recommendation

**Fix 1: Explicit Handling of Non-Entry-Function Payloads**

Modify the `matches` method to explicitly reject transactions with non-entry-function payloads when a payload filter is set: [2](#0-1) 

The logic should be changed to:
```rust
if let Some(payload_filter) = &self.payload {
    let entry_function_payload = user_request
        .payload
        .as_ref()
        .and_then(get_entry_function_payload_from_transaction_payload);
    
    // If a payload filter is set but no entry function payload exists,
    // reject the transaction (return false) instead of allowing it through
    if let Some(payload) = entry_function_payload {
        if !payload_filter.matches(payload) {
            return false;
        }
    } else {
        // Non-entry-function payload when filter is set - reject
        return false;
    }
}
```

**Fix 2: Extend Filter to Support All Payload Types**

Add explicit filter support for Script and WriteSet payloads by extending `UserTransactionPayloadFilter` to include optional filters for these payload types, allowing operators to explicitly control filtering behavior for all transaction types.

## Proof of Concept

```rust
#[cfg(test)]
mod script_bypass_poc {
    use super::*;
    use aptos_protos::transaction::v1::{
        transaction::TxnData,
        transaction_payload::Payload,
        MoveScriptBytecode, ScriptPayload, EntryFunctionPayload,
        EntryFunctionId, MoveModuleId, Transaction, 
        UserTransaction, UserTransactionRequest, TransactionPayload,
    };
    use aptos_transaction_filter::{
        boolean_transaction_filter::APIFilter,
        filters::UserTransactionFilterBuilder,
        EntryFunctionFilterBuilder, UserTransactionPayloadFilterBuilder,
    };

    #[test]
    fn test_script_payload_bypasses_entry_function_filter() {
        const MODULE_ADDRESS: &str = "0x1234";
        const MODULE_NAME: &str = "problematic_module";
        const FUNCTION_NAME: &str = "large_function";

        // Create filter to strip transactions from problematic module
        let filter = BooleanTransactionFilter::new_or(vec![
            BooleanTransactionFilter::from(APIFilter::UserTransactionFilter(
                UserTransactionFilterBuilder::default()
                    .payload(
                        UserTransactionPayloadFilterBuilder::default()
                            .function(
                                EntryFunctionFilterBuilder::default()
                                    .address(MODULE_ADDRESS.to_string())
                                    .module(MODULE_NAME.to_string())
                                    .build()
                                    .unwrap(),
                            )
                            .build()
                            .unwrap(),
                    )
                    .build()
                    .unwrap(),
            ))
        ]);

        // Create EntryFunction transaction - SHOULD be stripped
        let entry_function_txn = Transaction {
            version: 1,
            txn_data: Some(TxnData::User(UserTransaction {
                request: Some(UserTransactionRequest {
                    payload: Some(TransactionPayload {
                        r#type: 1,
                        payload: Some(Payload::EntryFunctionPayload(EntryFunctionPayload {
                            function: Some(EntryFunctionId {
                                module: Some(MoveModuleId {
                                    address: MODULE_ADDRESS.to_string(),
                                    name: MODULE_NAME.to_string(),
                                }),
                                name: FUNCTION_NAME.to_string(),
                            }),
                            ..Default::default()
                        })),
                        ..Default::default()
                    }),
                    ..Default::default()
                }),
                ..Default::default()
            })),
            ..Default::default()
        };

        // Create Script transaction - BYPASSES filter
        let script_txn = Transaction {
            version: 2,
            txn_data: Some(TxnData::User(UserTransaction {
                request: Some(UserTransactionRequest {
                    payload: Some(TransactionPayload {
                        r#type: 2,
                        payload: Some(Payload::ScriptPayload(ScriptPayload {
                            code: Some(MoveScriptBytecode {
                                bytecode: vec![0x42], // Dummy bytecode
                                ..Default::default()
                            }),
                            ..Default::default()
                        })),
                        ..Default::default()
                    }),
                    ..Default::default()
                }),
                ..Default::default()
            })),
            ..Default::default()
        };

        let (filtered_txns, num_stripped) = 
            strip_transactions(vec![entry_function_txn, script_txn], &filter);

        // VULNERABILITY: Only 1 transaction is stripped (EntryFunction)
        // Script transaction BYPASSES the filter
        assert_eq!(num_stripped, 1, "Expected 1 txn stripped, but got {}", num_stripped);
        assert_eq!(filtered_txns.len(), 2);
        
        // First transaction (EntryFunction) should be stripped
        let txn1 = &filtered_txns[0];
        assert!(matches!(txn1.txn_data, Some(TxnData::User(_))));
        if let Some(TxnData::User(user)) = &txn1.txn_data {
            assert!(user.request.as_ref().unwrap().payload.is_none(), 
                "EntryFunction payload should be stripped");
        }
        
        // Second transaction (Script) should NOT be stripped but IS (bypass)
        let txn2 = &filtered_txns[1];
        assert!(matches!(txn2.txn_data, Some(TxnData::User(_))));
        if let Some(TxnData::User(user)) = &txn2.txn_data {
            assert!(user.request.as_ref().unwrap().payload.is_some(), 
                "Script payload should be stripped but bypasses filter!");
        }
    }
}
```

## Notes

While the README.md documentation acknowledges "we only support the entry function payload" [6](#0-5) , this limitation creates a security vulnerability when non-entry-function payloads silently bypass configured filters rather than being explicitly handled or rejected. The emergency use case for transaction stripping documented in the config file [7](#0-6)  is defeated by this bypass, as Script payloads from problematic modules would continue affecting the data service despite operator intervention.

### Citations

**File:** ecosystem/indexer-grpc/transaction-filter/src/filters/user_transaction.rs (L100-115)
```rust
        if let Some(payload_filter) = &self.payload {
            // Get the entry_function_payload from both UserPayload and MultisigPayload
            let entry_function_payload = user_request
                .payload
                .as_ref()
                .and_then(get_entry_function_payload_from_transaction_payload);
            if let Some(payload) = entry_function_payload {
                // Here we have an actual EntryFunctionPayload
                if !payload_filter.matches(payload) {
                    return false;
                }
            }
        }

        true
    }
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/filters/user_transaction.rs (L229-236)
```rust
#[derive(Clone, Debug, Default, Deserialize, PartialEq, Serialize)]
#[serde(deny_unknown_fields)]
#[derive(derive_builder::Builder)]
#[builder(setter(strip_option), default)]
pub struct UserTransactionPayloadFilter {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub function: Option<EntryFunctionFilter>,
}
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/filters/user_transaction.rs (L274-295)
```rust
/// Get the entry_function_payload from both UserPayload and MultisigPayload
fn get_entry_function_payload_from_transaction_payload(
    payload: &TransactionPayload,
) -> Option<&EntryFunctionPayload> {
    if let Some(payload) = &payload.payload {
        match payload {
            transaction_payload::Payload::EntryFunctionPayload(ef_payload) => Some(ef_payload),
            transaction_payload::Payload::MultisigPayload(ms_payload) => ms_payload
                .transaction_payload
                .as_ref()
                .and_then(|tp| tp.payload.as_ref())
                .map(|payload| match payload {
                    multisig_transaction_payload::Payload::EntryFunctionPayload(ef_payload) => {
                        ef_payload
                    },
                }),
            _ => None,
        }
    } else {
        None
    }
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service/src/config.rs (L73-84)
```rust
    /// Any transaction that matches this filter will be stripped. This means we remove
    /// the payload, signature, events, and writesets from it before sending it
    /// downstream. This should only be used in an emergency situation, e.g. when txns
    /// related to a certain module are too large and are causing issues for the data
    /// service. Learn more here:
    ///
    /// https://www.notion.so/aptoslabs/Runbook-c006a37259394ac2ba904d6b54d180fa?pvs=4#171c210964ec42a89574fc80154f9e85
    ///
    /// Generally you will want to start with this with an OR, and then list out
    /// separate filters that describe each type of txn we want to strip.
    #[serde(default = "IndexerGrpcDataServiceConfig::default_txns_to_strip_filter")]
    pub txns_to_strip_filter: BooleanTransactionFilter,
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service/src/service.rs (L919-954)
```rust
/// This function strips transactions that match the given filter. Stripping means we
/// remove the payload, signature, events, and writesets. Note, the filter can be
/// composed of many conditions, see `BooleanTransactionFilter` for more.
///
/// This returns the mutated txns and the number of txns that were stripped.
fn strip_transactions(
    transactions: Vec<Transaction>,
    txns_to_strip_filter: &BooleanTransactionFilter,
) -> (Vec<Transaction>, usize) {
    let mut stripped_count = 0;

    let stripped_transactions: Vec<Transaction> = transactions
        .into_iter()
        .map(|mut txn| {
            // Note: `is_allowed` means the txn matches the filter, in which case
            // we strip it.
            if txns_to_strip_filter.matches(&txn) {
                stripped_count += 1;
                if let Some(info) = txn.info.as_mut() {
                    info.changes = vec![];
                }
                if let Some(TxnData::User(user_transaction)) = txn.txn_data.as_mut() {
                    user_transaction.events = vec![];
                    if let Some(utr) = user_transaction.request.as_mut() {
                        // Wipe the payload and signature.
                        utr.payload = None;
                        utr.signature = None;
                    }
                }
            }
            txn
        })
        .collect();

    (stripped_transactions, stripped_count)
}
```

**File:** ecosystem/indexer-grpc/transaction-filter/README.md (L20-20)
```markdown
    - Payload: we only support the entry function payload
```
