# Audit Report

## Title
Client-Side Infinite Pagination Loop Enables Resource Exhaustion via Malicious Cursor Values

## Summary
The `paginate_with_cursor()` function in the Aptos REST client lacks safeguards against infinite pagination loops. A malicious or compromised API server can exploit this by continuously returning non-null cursor values, causing unbounded memory consumption and client-side denial of service.

## Finding Description

The pagination implementation in the REST client contains a critical flaw in its loop termination logic. [1](#0-0) 

The loop only exits when `cursor.is_none()` at line 1877. The cursor value is extracted from the server's HTTP response headers without any validation. [2](#0-1) 

**Attack Flow:**

1. **Normal Operation**: The server-side implementation returns `next_state_key` as `None` when pagination completes. [3](#0-2) 

2. **Malicious Operation**: An attacker controlling an API endpoint (via compromised node, DNS hijacking, or MITM) can:
   - Always return a non-null cursor in the `X-APTOS-CURSOR` header
   - Return the same cursor repeatedly or different cursor values
   - Serve valid-looking responses that pass deserialization

3. **Client Exploitation**: The vulnerable client will:
   - Continue requesting pages indefinitely (line 1868-1885)
   - Accumulate results in an unbounded vector (line 1864, 1883)
   - Eventually exhaust available memory
   - Consume CPU cycles processing responses
   - Generate excessive network traffic

The vulnerability affects critical user-facing tools. [4](#0-3) 

**Missing Protections:**
- No maximum iteration limit
- No duplicate cursor detection
- No cumulative timeout for pagination operations
- No memory limit on result accumulation
- Individual request timeout [5](#0-4)  does not prevent the infinite loop issue

## Impact Explanation

This vulnerability represents a **Medium Severity** client-side resource exhaustion attack based on the following assessment:

**Affected Components:**
- Aptos CLI tool users (`aptos account list --query resources/modules`)
- Developer tools and scripts using the REST client library
- Automated monitoring or indexing systems built on the client

**Direct Impacts:**
- **Client Denial of Service**: Memory exhaustion leading to application crash
- **Resource Consumption**: Unbounded CPU and network usage
- **Operational Disruption**: Services depending on the client become unavailable
- **State Inconsistency Risk**: If the client is part of critical infrastructure (indexers, monitoring systems), service disruption could lead to operational issues requiring manual intervention

While this does not directly affect blockchain consensus or validators, it meets the Medium severity threshold of "State inconsistencies requiring intervention" when considering client-side infrastructure that relies on the REST client for operational continuity.

**Scope Limitations:**
- Does not affect validator nodes (they use non-paginated endpoints for discovery [6](#0-5) )
- Does not compromise consensus safety
- Does not enable fund theft or manipulation

## Likelihood Explanation

**Likelihood: Medium**

The attack requires:
1. **Attacker Control**: Malicious actor must control or compromise an API endpoint
2. **User Interaction**: Victim must connect their client to the malicious endpoint

**Attack Vectors:**
- **DNS Hijacking**: Redirect API queries to malicious server
- **Man-in-the-Middle**: Intercept and modify responses
- **Compromised Node Operator**: Malicious or hacked node serving bad cursors
- **User Misconfiguration**: Intentionally pointing to untrusted endpoint
- **Software Bug**: Legitimate node with bug causing cursor loop

**Exploit Complexity: Low** - Once the attacker controls the endpoint, exploitation is trivial (simply return non-null cursors indefinitely).

**Detection Difficulty: High** - The attack appears as normal pagination traffic until resource exhaustion occurs.

## Recommendation

Implement multiple defense layers in `paginate_with_cursor()`:

1. **Maximum Iteration Limit**: Cap total pagination requests
2. **Duplicate Cursor Detection**: Track seen cursors and abort on repetition  
3. **Result Size Limit**: Enforce maximum accumulated result size
4. **Cumulative Timeout**: Add overall timeout for entire pagination operation
5. **Cursor Validation**: Implement server-side cursor signing/verification

**Suggested Code Fix:**

```rust
pub async fn paginate_with_cursor<T: for<'a> Deserialize<'a>>(
    &self,
    base_path: &str,
    limit_per_request: u64,
    ledger_version: Option<u64>,
) -> AptosResult<Response<Vec<T>>> {
    const MAX_PAGINATION_ITERATIONS: usize = 1000;
    const MAX_RESULT_SIZE: usize = 100_000;
    const PAGINATION_TIMEOUT: Duration = Duration::from_secs(300);
    
    let mut result = Vec::new();
    let mut cursor: Option<String> = None;
    let mut seen_cursors = HashSet::new();
    let mut iteration_count = 0;
    let start_time = Instant::now();

    loop {
        // Check iteration limit
        if iteration_count >= MAX_PAGINATION_ITERATIONS {
            bail!("Pagination exceeded maximum iteration limit");
        }
        
        // Check timeout
        if start_time.elapsed() > PAGINATION_TIMEOUT {
            bail!("Pagination exceeded timeout limit");
        }
        
        // Check result size
        if result.len() >= MAX_RESULT_SIZE {
            bail!("Pagination result exceeded maximum size");
        }
        
        // Check for cursor repetition
        if let Some(ref c) = cursor {
            if !seen_cursors.insert(c.clone()) {
                bail!("Detected cursor repetition, possible malicious server");
            }
        }
        
        let url = self.build_url_for_pagination(/*...*/)?;
        let raw_response = self.inner.get(url).send().await?;
        let response: Response<Vec<T>> = self.json(raw_response).await?;
        
        cursor.clone_from(&response.state().cursor);
        iteration_count += 1;
        
        if cursor.is_none() {
            break Ok(response.map(|mut v| {
                result.append(&mut v);
                result
            }));
        } else {
            result.extend(response.into_inner());
        }
    }
}
```

Apply the same fix to `paginate_with_cursor_bcs()`.

## Proof of Concept

**Malicious Server Simulation:**

```rust
use axum::{Router, routing::get, Json};
use axum::http::HeaderMap;
use aptos_api_types::X_APTOS_CURSOR;

#[tokio::test]
async fn test_infinite_pagination_exploit() {
    // Malicious server that always returns a cursor
    async fn malicious_resources_endpoint() -> (HeaderMap, Json<Vec<serde_json::Value>>) {
        let mut headers = HeaderMap::new();
        // Always return a cursor (can be same or different each time)
        headers.insert(X_APTOS_CURSOR, "malicious_cursor_123".parse().unwrap());
        headers.insert("x-aptos-chain-id", "1".parse().unwrap());
        headers.insert("x-aptos-ledger-version", "1000".parse().unwrap());
        headers.insert("x-aptos-ledger-timestamp", "1234567890".parse().unwrap());
        headers.insert("x-aptos-epoch", "1".parse().unwrap());
        headers.insert("x-aptos-ledger-oldest-version", "0".parse().unwrap());
        headers.insert("x-aptos-block-height", "100".parse().unwrap());
        headers.insert("x-aptos-oldest-block-height", "0".parse().unwrap());
        
        (headers, Json(vec![]))
    }
    
    let app = Router::new()
        .route("/v1/accounts/:addr/resources", get(malicious_resources_endpoint));
    
    // Start malicious server
    let listener = tokio::net::TcpListener::bind("127.0.0.1:0").await.unwrap();
    let addr = listener.local_addr().unwrap();
    
    tokio::spawn(async move {
        axum::serve(listener, app).await.unwrap();
    });
    
    // Victim client connects to malicious server
    let client = aptos_rest_client::Client::new(
        url::Url::parse(&format!("http://{}", addr)).unwrap()
    );
    
    // This will loop infinitely and exhaust memory
    // In practice, you'd need to add a timeout to make this testable
    let result = tokio::time::timeout(
        Duration::from_secs(5),
        client.get_account_resources(AccountAddress::ONE)
    ).await;
    
    // Should timeout because of infinite loop
    assert!(result.is_err(), "Client should have timed out due to infinite pagination");
}
```

**Notes:**
- The PoC demonstrates that a malicious server returning persistent cursors causes unbounded pagination
- In production, this would continue until memory exhaustion
- The fix involves adding limits as shown in the Recommendation section

### Citations

**File:** crates/aptos-rest-client/src/lib.rs (L1867-1886)
```rust
        loop {
            let url = self.build_url_for_pagination(
                base_path,
                limit_per_request,
                ledger_version,
                &cursor,
            )?;
            let raw_response = self.inner.get(url).send().await?;
            let response: Response<Vec<T>> = self.json(raw_response).await?;
            cursor.clone_from(&response.state().cursor);
            if cursor.is_none() {
                break Ok(response.map(|mut v| {
                    result.append(&mut v);
                    result
                }));
            } else {
                result.extend(response.into_inner());
            }
        }
    }
```

**File:** crates/aptos-rest-client/src/state.rs (L52-55)
```rust
        let cursor = headers
            .get(X_APTOS_CURSOR)
            .and_then(|h| h.to_str().ok())
            .map(|s| s.to_string());
```

**File:** api/src/context.rs (L553-558)
```rust
        let next_key = if let Some((struct_tag, _v)) = resource_iter.next().transpose()? {
            Some(StateKey::resource(&address, &struct_tag)?)
        } else {
            None
        };
        Ok((kvs, next_key))
```

**File:** crates/aptos/src/account/list.rs (L96-105)
```rust
            ListQuery::Modules => client
                .get_account_modules(account)
                .await?
                .into_inner()
                .into_iter()
                .map(|module| json!(module.try_parse_abi().unwrap()))
                .collect::<Vec<serde_json::Value>>(),
            ListQuery::Resources => client
                .get_account_resources(account)
                .await?
```

**File:** crates/aptos-rest-client/src/client_builder.rs (L54-54)
```rust
            timeout: Duration::from_secs(10), // Default to 10 seconds
```

**File:** network/discovery/src/rest.rs (L48-51)
```rust
        let response = block_on(self.rest_client.get_account_resource_bcs::<ValidatorSet>(
            AccountAddress::ONE,
            "0x1::stake::ValidatorSet",
        ));
```
