# Audit Report

## Title
JWK Consensus Transaction Loss via Premature TxnGuard Drop During On-Chain State Reset

## Summary
The JWK consensus manager's `reset_with_on_chain_state()` function can prematurely drop `TxnGuard` instances, causing validator transactions to be permanently removed from the pool before they are included in any block. This results in silent transaction loss that breaks the JWK consensus protocol.

## Finding Description

The validator transaction pool uses a RAII-based guard pattern where transactions remain in the pool only while their associated `TxnGuard` is alive. When the guard is dropped, the transaction is immediately and permanently removed from the pool. [1](#0-0) [2](#0-1) 

The JWK consensus manager stores these guards in a `HashMap` keyed by `(issuer, kid)` pairs. When a quorum-certified JWK update is received, it creates a transaction and stores the guard: [3](#0-2) 

However, when the on-chain JWK state is updated (e.g., when a JWK update from another validator is committed), the `reset_with_on_chain_state()` function is called: [4](#0-3) 

This function uses `retain()` to discard state entries where the on-chain version has changed: [5](#0-4) 

**The vulnerability:** When a state entry in `Finished` status is removed by `retain()`, its `TxnGuard` is dropped, triggering the Drop implementation that removes the transaction from the pool. If this happens **before** the transaction is pulled into a block by consensus, the transaction is permanently lost.

**Attack Path:**
1. Validator A completes JWK consensus for (issuer1, kid1) and stores transaction with guard in `ConsensusState::Finished`
2. Validator B's JWK update for (issuer1, kid2) gets committed to chain first
3. This triggers `ObservedJWKsUpdated` event on Validator A
4. `reset_with_on_chain_state()` is called, on-chain version for issuer1 has changed
5. Validator A's state entry for (issuer1, kid1) is removed via `retain()`
6. Guard is dropped, transaction is removed from pool via `try_delete()`
7. Validator A's consensus-ready transaction is permanently lost [6](#0-5) 

The `pull()` operation only reads from the pool and does not remove transactions, so once deleted, the transaction can never be recovered: [7](#0-6) 

## Impact Explanation

This is a **High Severity** vulnerability per Aptos bug bounty criteria:

1. **Protocol Violation**: Breaks the JWK consensus protocol by silently losing validator transactions that achieved quorum certification
2. **Liveness Impact**: Can cause JWK updates to fail to propagate, potentially breaking OIDC authentication flows
3. **Silent Failure**: Transactions are lost without any error or recovery mechanism, making debugging extremely difficult
4. **No Recovery Path**: Once the guard is dropped and transaction removed, there is no mechanism to re-add it to the pool

While this doesn't directly cause fund loss or consensus safety violations, it represents a "Significant protocol violation" causing degraded system functionality, qualifying as High Severity.

## Likelihood Explanation

**High Likelihood** - This can occur during normal operation:

1. Multiple validators independently observe and propose JWK updates
2. Network timing variations mean different validators' updates may be committed in different orders
3. The time window between transaction creation and block inclusion provides opportunity for race conditions
4. No special attacker privileges required - happens through normal protocol operation
5. Frequency increases with number of active JWK providers and update frequency

The vulnerability is deterministic once the timing conditions are met - it's not a probabilistic exploit.

## Recommendation

**Solution:** Separate transaction lifecycle management from on-chain state synchronization. Guards should only be dropped when:
1. The transaction has been successfully included in a committed block, OR
2. The epoch changes (intentional cleanup)

**Recommended Fix:**

```rust
pub fn reset_with_on_chain_state(&mut self, on_chain_state: AllProvidersJWKs) -> Result<()> {
    let new_onchain_jwks = on_chain_state.indexed()?;
    
    // Instead of dropping guards, transition them to a "committed" state
    // or verify transaction was included before cleanup
    self.states_by_key.retain(|(issuer, _), state| {
        let version_matches = new_onchain_jwks
            .get(issuer)
            .map(|jwks| jwks.version)
            .unwrap_or_default()
            == self.onchain_jwks.get(issuer).map(|jwks| jwks.version).unwrap_or_default();
        
        // Only drop guards if transaction was already committed
        if !version_matches {
            if let ConsensusState::Finished { .. } = state {
                // Check if transaction was included in committed blocks
                // before dropping guard
                warn!("Dropping uncommitted JWK transaction due to version mismatch");
            }
        }
        
        version_matches
    });
    
    self.onchain_jwks = new_onchain_jwks;
    Ok(())
}
```

Alternatively, redesign the guard pattern to track transaction commitment status before allowing cleanup.

## Proof of Concept

```rust
// Reproduction scenario (conceptual - would require test harness)
#[tokio::test]
async fn test_jwk_transaction_loss_on_state_reset() {
    // Setup: Create JWK manager with validator transaction pool
    let vtxn_pool = VTxnPoolState::default();
    let mut jwk_manager = KeyLevelConsensusManager::new(...);
    
    // Step 1: Complete JWK consensus for (issuer1, kid1)
    let update = /* create JWK update */;
    jwk_manager.initiate_key_level_consensus(update).await.unwrap();
    // ... consensus completes ...
    let qc_update = /* quorum certified update */;
    jwk_manager.process_quorum_certified_update(qc_update).unwrap();
    
    // Verify transaction is in pool
    let txns_before = vtxn_pool.pull(Instant::now() + Duration::from_secs(1), 10, 1024*1024, TransactionFilter::empty());
    assert_eq!(txns_before.len(), 1);
    
    // Step 2: Simulate on-chain state change (different version)
    let new_on_chain_state = /* updated state with incremented version */;
    jwk_manager.reset_with_on_chain_state(new_on_chain_state).unwrap();
    
    // Step 3: Verify transaction is now GONE from pool
    let txns_after = vtxn_pool.pull(Instant::now() + Duration::from_secs(1), 10, 1024*1024, TransactionFilter::empty());
    assert_eq!(txns_after.len(), 0); // Transaction lost!
}
```

**Notes**

The vulnerability exists because the guard lifecycle is coupled to the on-chain state synchronization logic rather than to the transaction commitment status. The `retain()` operation doesn't distinguish between states where the transaction was already committed versus states where the transaction is still pending in the pool.

### Citations

**File:** crates/validator-transaction-pool/src/lib.rs (L126-129)
```rust
/// Returned for `txn` when you call `PoolState::put(txn, ...)`.
/// If this is dropped, `txn` will be deleted from the pool (if it has not been).
///
/// This allows the pool to be emptied on epoch boundaries.
```

**File:** crates/validator-transaction-pool/src/lib.rs (L145-150)
```rust
    fn try_delete(&mut self, seq_num: u64) {
        if let Some(item) = self.txn_queue.remove(&seq_num) {
            let seq_num_another = self.seq_nums_by_topic.remove(&item.topic);
            assert_eq!(Some(seq_num), seq_num_another);
        }
    }
```

**File:** crates/validator-transaction-pool/src/lib.rs (L152-199)
```rust
    pub fn pull(
        &mut self,
        deadline: Instant,
        mut max_items: u64,
        mut max_bytes: u64,
        filter: TransactionFilter,
    ) -> Vec<ValidatorTransaction> {
        let mut ret = vec![];
        let mut seq_num_lower_bound = 0;

        // Check deadline at the end of every iteration to ensure validator txns get a chance no matter what current proposal delay is.
        while max_items >= 1 && max_bytes >= 1 {
            // Find the seq_num of the first txn that satisfies the quota.
            if let Some(seq_num) = self
                .txn_queue
                .range(seq_num_lower_bound..)
                .filter(|(_, item)| {
                    item.txn.size_in_bytes() as u64 <= max_bytes
                        && !filter.should_exclude(&item.txn)
                })
                .map(|(seq_num, _)| *seq_num)
                .next()
            {
                // Update the quota usage.
                // Send the pull notification if requested.
                let PoolItem {
                    txn,
                    pull_notification_tx,
                    ..
                } = self.txn_queue.get(&seq_num).unwrap();
                if let Some(tx) = pull_notification_tx {
                    let _ = tx.push((), txn.clone());
                }
                max_items -= 1;
                max_bytes -= txn.size_in_bytes() as u64;
                seq_num_lower_bound = seq_num + 1;
                ret.push(txn.as_ref().clone());

                if Instant::now() >= deadline {
                    break;
                }
            } else {
                break;
            }
        }

        ret
    }
```

**File:** crates/validator-transaction-pool/src/lib.rs (L202-206)
```rust
impl Drop for TxnGuard {
    fn drop(&mut self) {
        self.pool.lock().try_delete(self.seq_num);
    }
}
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager_per_key.rs (L243-254)
```rust
        // for an existing state entry (iss, kid) -> state, discard it unless `new_onchain_jwks[iss].version == self.onchain_jwks[iss].version`.
        self.states_by_key.retain(|(issuer, _), _| {
            new_onchain_jwks
                .get(issuer)
                .map(|jwks| jwks.version)
                .unwrap_or_default()
                == self
                    .onchain_jwks
                    .get(issuer)
                    .map(|jwks| jwks.version)
                    .unwrap_or_default()
        });
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager_per_key.rs (L334-346)
```rust
        match state {
            ConsensusState::InProgress { my_proposal, .. } => {
                let topic = Topic::JWK_CONSENSUS_PER_KEY_MODE {
                    issuer: issuer.clone(),
                    kid: kid.clone(),
                };
                let txn = ValidatorTransaction::ObservedJWKUpdate(issuer_level_repr.clone());
                let vtxn_guard = self.vtxn_pool.put(topic, Arc::new(txn), None);
                *state = ConsensusState::Finished {
                    vtxn_guard,
                    my_proposal: my_proposal.clone(),
                    quorum_certified: issuer_level_repr,
                };
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager/mod.rs (L140-142)
```rust
                jwk_updated = jwk_updated_rx.select_next_some() => {
                    let ObservedJWKsUpdated { jwks, .. } = jwk_updated;
                    this.reset_with_on_chain_state(jwks)
```
