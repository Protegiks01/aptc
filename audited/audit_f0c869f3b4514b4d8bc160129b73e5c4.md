# Audit Report

## Title
Non-Atomic State Sync Initialization Allows API to Serve Inconsistent State During Bootstrap

## Summary
The Aptos node initialization process starts the REST API, node inspection service, and mempool **before** state sync bootstrapping completes, creating a window where external clients can query partially-synchronized blockchain state and submit transactions based on stale data.

## Finding Description

The node startup sequence in `setup_environment_and_start_node` violates initialization atomicity by starting client-facing services before state sync completes: [1](#0-0) 

State sync is started but not awaited. Immediately after, critical services begin: [2](#0-1) [3](#0-2) [4](#0-3) 

Only **after** all these services are running does the code wait for state sync initialization: [5](#0-4) 

During the bootstrapping window, the API serves requests by reading from the database: [6](#0-5) 

The health check endpoint does not verify bootstrap completion: [7](#0-6) 

It only checks ledger timestamp freshness, not whether the node has completed initial synchronization.

**Attack Scenario:**
1. Attacker monitors network for new nodes joining
2. New validator/fullnode starts bootstrapping from waypoint
3. API becomes available within seconds (before bootstrap completes)
4. Health check returns 200 OK (ledger info exists)
5. Attacker queries `/accounts/{address}` or `/transactions/by_version/{version}`
6. API returns data from partially-synced database (hours/days behind)
7. External applications/clients receive stale state believing it's current
8. Load balancers route production traffic to non-ready nodes

## Impact Explanation

**Severity: Medium**

This issue creates operational risks and state inconsistencies requiring intervention:

1. **Client Confusion**: Applications querying newly-started nodes receive stale blockchain state without clear indication the node is bootstrapping
2. **Transaction Failures**: Clients submitting transactions based on stale state may use incorrect sequence numbers or reference non-existent data
3. **Load Balancer Issues**: Health checks pass for nodes that aren't fully synced, routing traffic prematurely
4. **State Inconsistency Window**: A bootstrapping node appears ready externally but returns data from incomplete synchronization

While no funds are directly at risk and consensus is not violated (consensus explicitly waits for bootstrap completion), this violates operational expectations that services should not accept requests until fully initialized.

## Likelihood Explanation

**Likelihood: High**

This occurs on **every node startup** when bootstrapping from waypoint:
- New validators joining the network
- Fullnodes recovering from crashes
- Fresh deployments in production environments
- Any node syncing from genesis or snapshot

The vulnerability window can last minutes to hours depending on:
- Network conditions during bootstrap
- Amount of history to sync
- Available bandwidth from peers

The issue is deterministic and reproducible on every fresh node deployment.

## Recommendation

Implement a bootstrap readiness gate that blocks API startup until state sync completes:

**Option 1: Wait for bootstrap before starting API**

```rust
// In setup_environment_and_start_node, move these lines AFTER the state sync wait:

// Wait until state sync has been initialized
debug!("Waiting until state sync is initialized!");
state_sync_runtimes.block_until_initialized();
debug!("State sync initialization complete.");

// NOW start client-facing services:
services::start_node_inspection_service(...);
let (...) = services::bootstrap_api_and_indexer(...)?;
```

**Option 2: Add bootstrap status to health check**

Enhance the health check to verify bootstrap completion:

```rust
// In api/src/basic.rs, add bootstrap check:
async fn healthy(&self, ...) -> HealthCheckResult<HealthCheckSuccess> {
    // Check if state sync has completed bootstrapping
    if !self.context.is_bootstrapped() {
        return Err(HealthCheckError::service_unavailable_with_code(
            "Node is still bootstrapping".to_string(),
            AptosErrorCode::HealthCheckFailed,
            &ledger_info,
        ));
    }
    // ... existing health check logic
}
```

**Option 3: Add explicit readiness endpoint**

Create separate `/ready` endpoint that checks bootstrap status, distinct from liveness check.

## Proof of Concept

```rust
// Reproduction steps:

// 1. Start a fresh Aptos node with waypoint:
// cargo run -p aptos-node -- -f config.yaml

// 2. In parallel terminal, immediately query API:
// curl http://localhost:8080/v1/

// Expected: 503 Service Unavailable (node bootstrapping)
// Actual: 200 OK with stale ledger info

// 3. Check health endpoint:
// curl http://localhost:8080/-/healthy

// Expected: 503 Service Unavailable (not ready)
// Actual: 200 OK (node reports healthy during bootstrap)

// 4. Detailed test showing race condition:
use tokio::time::{sleep, Duration};

#[tokio::test]
async fn test_api_available_during_bootstrap() {
    // Start node (this triggers bootstrap)
    let node_handle = start_test_node();
    
    // API is immediately available
    sleep(Duration::from_millis(100)).await;
    let response = reqwest::get("http://localhost:8080/v1/").await.unwrap();
    assert_eq!(response.status(), 200); // API responds immediately
    
    // But state sync hasn't completed
    let ledger_info: LedgerInfo = response.json().await.unwrap();
    assert!(ledger_info.ledger_version < EXPECTED_SYNCED_VERSION);
    
    // Health check also passes
    let health = reqwest::get("http://localhost:8080/-/healthy").await.unwrap();
    assert_eq!(health.status(), 200); // False positive - not actually ready
}
```

## Notes

While consensus correctly waits for bootstrap completion, the premature availability of client-facing services violates the principle of atomic initialization. External clients cannot reliably distinguish between "syncing from scratch" and "normal operation slight behind" without checking ledger timestamps against wall-clock time. Production deployments using automated health checks will incorrectly route traffic to bootstrapping nodes.

### Citations

**File:** aptos-node/src/lib.rs (L762-769)
```rust
    let (aptos_data_client, state_sync_runtimes, mempool_listener, consensus_notifier) =
        state_sync::start_state_sync_and_get_notification_handles(
            &node_config,
            storage_service_network_interfaces,
            genesis_waypoint,
            event_subscription_service,
            db_rw.clone(),
        )?;
```

**File:** aptos-node/src/lib.rs (L772-776)
```rust
    services::start_node_inspection_service(
        &node_config,
        aptos_data_client,
        peers_and_metadata.clone(),
    );
```

**File:** aptos-node/src/lib.rs (L779-795)
```rust
    let (
        mempool_client_receiver,
        api_runtime,
        indexer_table_info_runtime,
        indexer_runtime,
        indexer_grpc_runtime,
        internal_indexer_db_runtime,
        mempool_client_sender,
    ) = services::bootstrap_api_and_indexer(
        &node_config,
        db_rw.clone(),
        chain_id,
        indexer_db_opt,
        update_receiver,
        api_port_tx,
        indexer_grpc_port_tx,
    )?;
```

**File:** aptos-node/src/lib.rs (L801-810)
```rust
    let (mempool_runtime, consensus_to_mempool_sender) =
        services::start_mempool_runtime_and_get_consensus_sender(
            &mut node_config,
            &db_rw,
            mempool_reconfig_subscription,
            mempool_network_interfaces,
            mempool_listener,
            mempool_client_receiver,
            peers_and_metadata,
        );
```

**File:** aptos-node/src/lib.rs (L824-827)
```rust
    // Wait until state sync has been initialized
    debug!("Waiting until state sync is initialized!");
    state_sync_runtimes.block_until_initialized();
    debug!("State sync initialization complete.");
```

**File:** api/src/context.rs (L271-278)
```rust
    pub fn get_latest_ledger_info<E: ServiceUnavailableError>(&self) -> Result<LedgerInfo, E> {
        if let Some(indexer_reader) = self.indexer_reader.as_ref() {
            if indexer_reader.is_internal_indexer_enabled() {
                return self.get_latest_internal_indexer_ledger_info();
            }
        }
        self.get_latest_storage_ledger_info()
    }
```

**File:** api/src/basic.rs (L151-191)
```rust
    async fn healthy(
        &self,
        accept_type: AcceptType,
        /// Threshold in seconds that the server can be behind to be considered healthy
        ///
        /// If not provided, the healthcheck will always succeed
        duration_secs: Query<Option<u32>>,
    ) -> HealthCheckResult<HealthCheckSuccess> {
        let context = self.context.clone();
        let ledger_info = api_spawn_blocking(move || context.get_latest_ledger_info()).await?;

        // If we have a duration, check that it's close to the current time, otherwise it's ok
        if let Some(max_skew) = duration_secs.0 {
            let ledger_timestamp = Duration::from_micros(ledger_info.timestamp());
            let skew_threshold = SystemTime::now()
                .sub(Duration::from_secs(max_skew as u64))
                .duration_since(UNIX_EPOCH)
                .context("Failed to determine absolute unix time based on given duration")
                .map_err(|err| {
                    HealthCheckError::internal_with_code(
                        err,
                        AptosErrorCode::InternalError,
                        &ledger_info,
                    )
                })?;

            if ledger_timestamp < skew_threshold {
                return Err(HealthCheckError::service_unavailable_with_code(
                    format!("The latest ledger info timestamp is {:?}, which is beyond the allowed skew ({}s).", ledger_timestamp, max_skew),
                    AptosErrorCode::HealthCheckFailed,
                    &ledger_info,
                ));
            }
        }
        HealthCheckResponse::try_from_rust_value((
            HealthCheckSuccess::new(),
            &ledger_info,
            HealthCheckResponseStatus::Ok,
            &accept_type,
        ))
    }
```
