# Audit Report

## Title
Bytecode Version Feature Flag Coordination Failure Can Cause Consensus Divergence

## Summary
The VM_BINARY_FORMAT_V* feature flags are coordinated through on-chain governance, but the actual bytecode format support (VERSION_MAX) is hardcoded in validator node software. This creates a critical coordination dependency that, if violated, can cause validators running different software versions to accept/reject the same bytecode differently, breaking consensus safety and potentially causing chain splits.

## Finding Description

The Aptos blockchain has two parallel versioning systems that must be coordinated:

1. **On-chain feature flags** (VM_BINARY_FORMAT_V6 through V10) that control which bytecode versions are allowed on-chain, managed via governance proposals [1](#0-0) 

2. **Hardcoded bytecode support** (VERSION_MAX constant) in validator node software that defines the maximum bytecode version the VM implementation can actually handle [2](#0-1) 

The vulnerability lies in the bytecode deserialization check: [3](#0-2) 

This check uses `u32::min(max_version, VERSION_MAX)` where:
- `max_version` comes from the on-chain Features resource via `get_max_binary_format_version()` [4](#0-3) 
- `VERSION_MAX` is a compile-time constant in the node software

**Attack Scenario:**

1. Governance passes a proposal to enable VM_BINARY_FORMAT_V10, setting the on-chain `max_version` to 10
2. The feature flag is buffered in PendingFeatures and applied at epoch boundary [5](#0-4) 
3. Most validators (say 70%) have upgraded to node software with VERSION_MAX=10
4. Some validators (30%) haven't upgraded yet and still run software with VERSION_MAX=9
5. A developer publishes a module compiled with bytecode version 10
6. Validators with VERSION_MAX=10: `min(10, 10) = 10`, version check passes, module accepted
7. Validators with VERSION_MAX=9: `min(10, 9) = 9`, version 10 > 9, returns UNKNOWN_VERSION error, module rejected
8. The two validator groups produce different state roots for the same block → **consensus divergence**

This breaks the fundamental "Deterministic Execution" invariant: all validators must produce identical state roots for identical blocks.

## Impact Explanation

**Critical Severity** - This vulnerability causes:

1. **Consensus Safety Violation**: Different validators produce different state roots for the same transactions, violating the core AptosBFT safety guarantee
2. **Potential Chain Split**: If the validator split is significant, this could cause a permanent chain fork requiring a hard fork to resolve
3. **State Root Mismatch**: Validators cannot agree on the canonical state, breaking state synchronization

Per the Aptos bug bounty criteria, this qualifies as **Critical Severity** because it causes "Consensus/Safety violations" and potentially "Non-recoverable network partition (requires hardfork)".

The language feature gates (`lang_feature_versions`) mentioned in the security question are compile-time constants used during compilation, not runtime checks. However, they feed into the bytecode version selection via `infer_bytecode_version()` [6](#0-5) , which determines what bytecode version is embedded in compiled modules. The real coordination problem occurs at runtime when validators with different VERSION_MAX constants process the same bytecode.

## Likelihood Explanation

**Likelihood: Medium to High** during version upgrades

This vulnerability manifests during the window when:
1. A new bytecode version feature flag is enabled via governance
2. Not all validators have upgraded their node software to support it

The likelihood increases when:
- Validator upgrade coordination is poor
- Governance proposals are executed before validator readiness is verified  
- The validator set is large and geographically distributed (harder to coordinate)
- Emergency feature flag changes are needed

While proper operational procedures should prevent this, the codebase provides no programmatic safeguards against this scenario, making it dependent on perfect offline coordination.

## Recommendation

Add a validation mechanism that checks all validators support a bytecode version before allowing it to be enabled:

1. **Add capability reporting**: Validators should report their supported bytecode versions (VERSION_MAX) as part of their validator metadata

2. **Add pre-activation check**: Before applying feature flag changes in `on_new_epoch()`, verify that all active validators in the current epoch support the new bytecode version:

```move
// In features.move, before line 839
public fun on_new_epoch(framework: &signer) acquires Features, PendingFeatures {
    ensure_framework_signer(framework);
    if (exists<PendingFeatures>(@std)) {
        let PendingFeatures { features } = move_from<PendingFeatures>(@std);
        
        // NEW: Verify validator readiness for bytecode version changes
        let max_version = get_max_binary_format_version_from_features(&features);
        assert!(
            validator_capabilities::all_validators_support_bytecode_version(max_version),
            error::invalid_state(EVALIDATORS_NOT_READY)
        );
        
        if (exists<Features>(@std)) {
            Features[@std].features = features;
        } else {
            move_to(framework, Features { features })
        }
    }
}
```

3. **Alternative approach**: Add a minimum software version check that blocks validator participation if their VERSION_MAX is below the on-chain requirement, preventing them from participating in consensus rather than causing divergence.

## Proof of Concept

While a full PoC requires a multi-node testnet setup, the divergence can be demonstrated by analyzing the code path:

**Step 1**: Validator A with VERSION_MAX=10 receives block with bytecode version 10 module
- Deserializer calls `VersionedBinary::new(binary, 10, max_id_size)` with max_version=10 from on-chain config
- Check: `version=10 > min(10, 10) = 10`? No, passes [7](#0-6) 
- Module accepted, transaction succeeds

**Step 2**: Validator B with VERSION_MAX=9 receives same block
- Deserializer calls `VersionedBinary::new(binary, 10, max_id_size)` with max_version=10 from on-chain config  
- Check: `version=10 > min(10, 9) = 9`? Yes, fails with UNKNOWN_VERSION
- Module rejected, transaction fails

**Result**: Two validators produce different outcomes for the same transaction → different state roots → consensus divergence.

The critical code locations:
- Feature flag coordination: [8](#0-7) 
- Runtime version check: [9](#0-8) 
- Max version computation: [4](#0-3) 

## Notes

The `lang_feature_versions` constants are purely compile-time gates that control which features developers can use when writing Move code [10](#0-9) . They are not coordinated through governance at all. However, they indirectly affect the bytecode version through `infer_bytecode_version()`, creating a dependency chain: language version → bytecode version → runtime acceptance. The real vulnerability is at the runtime acceptance layer where VERSION_MAX and on-chain feature flags must be synchronized across all validators.

### Citations

**File:** aptos-move/framework/move-stdlib/sources/configs/features.move (L804-844)
```text
    /// Enable and disable features for the next epoch.
    public fun change_feature_flags_for_next_epoch(
        framework: &signer,
        enable: vector<u64>,
        disable: vector<u64>
    ) acquires PendingFeatures, Features {
        assert!(signer::address_of(framework) == @std, error::permission_denied(EFRAMEWORK_SIGNER_NEEDED));

        // Figure out the baseline feature vec that the diff will be applied to.
        let new_feature_vec = if (exists<PendingFeatures>(@std)) {
            // If there is a buffered feature vec, use it as the baseline.
            let PendingFeatures { features } = move_from<PendingFeatures>(@std);
            features
        } else if (exists<Features>(@std)) {
            // Otherwise, use the currently effective feature flag vec as the baseline, if it exists.
            Features[@std].features
        } else {
            // Otherwise, use an empty feature vec.
            vector[]
        };

        // Apply the diff and save it to the buffer.
        apply_diff(&mut new_feature_vec, enable, disable);
        move_to(framework, PendingFeatures { features: new_feature_vec });
    }

    /// Apply all the pending feature flag changes. Should only be used at the end of a reconfiguration with DKG.
    ///
    /// While the scope is public, it can only be usd in system transactions like `block_prologue` and governance proposals,
    /// who have permission to set the flag that's checked in `extract()`.
    public fun on_new_epoch(framework: &signer) acquires Features, PendingFeatures {
        ensure_framework_signer(framework);
        if (exists<PendingFeatures>(@std)) {
            let PendingFeatures { features } = move_from<PendingFeatures>(@std);
            if (exists<Features>(@std)) {
                Features[@std].features = features;
            } else {
                move_to(framework, Features { features })
            }
        }
    }
```

**File:** third_party/move/move-binary-format/src/file_format_common.rs (L562-565)
```rust
pub const VERSION_MIN: u32 = VERSION_5;

/// Mark which version is the latest version.
pub const VERSION_MAX: u32 = VERSION_10;
```

**File:** third_party/move/move-binary-format/src/file_format_common.rs (L594-630)
```rust
        fn new(
            binary: &'a [u8],
            max_version: u32,
            max_identifier_size: u64,
        ) -> BinaryLoaderResult<(Self, Cursor<&'a [u8]>)> {
            let mut cursor = Cursor::<&'a [u8]>::new(binary);
            let mut magic = [0u8; BinaryConstants::MOVE_MAGIC_SIZE];
            if let Ok(count) = cursor.read(&mut magic) {
                if count != BinaryConstants::MOVE_MAGIC_SIZE || magic != BinaryConstants::MOVE_MAGIC
                {
                    return Err(PartialVMError::new(StatusCode::BAD_MAGIC));
                }
            } else {
                return Err(PartialVMError::new(StatusCode::MALFORMED)
                    .with_message("Bad binary header".to_string()));
            }
            let version = match read_u32(&mut cursor) {
                Ok(v) => v & !APTOS_BYTECODE_VERSION_MASK,
                Err(_) => {
                    return Err(PartialVMError::new(StatusCode::MALFORMED)
                        .with_message("Bad binary header".to_string()));
                },
            };
            if version == 0 || version > u32::min(max_version, VERSION_MAX) {
                Err(PartialVMError::new(StatusCode::UNKNOWN_VERSION)
                    .with_message(format!("bytecode version {} unsupported", version)))
            } else {
                Ok((
                    Self {
                        version,
                        max_identifier_size,
                        binary,
                    },
                    cursor,
                ))
            }
        }
```

**File:** types/src/on_chain_config/aptos_features.rs (L485-499)
```rust
    pub fn get_max_binary_format_version(&self) -> u32 {
        if self.is_enabled(FeatureFlag::VM_BINARY_FORMAT_V10) {
            file_format_common::VERSION_10
        } else if self.is_enabled(FeatureFlag::VM_BINARY_FORMAT_V9) {
            file_format_common::VERSION_9
        } else if self.is_enabled(FeatureFlag::VM_BINARY_FORMAT_V8) {
            file_format_common::VERSION_8
        } else if self.is_enabled(FeatureFlag::VM_BINARY_FORMAT_V7) {
            file_format_common::VERSION_7
        } else if self.is_enabled(FeatureFlag::VM_BINARY_FORMAT_V6) {
            file_format_common::VERSION_6
        } else {
            file_format_common::VERSION_5
        }
    }
```

**File:** third_party/move/move-model/src/metadata.rs (L29-38)
```rust
pub mod lang_feature_versions {
    use crate::LanguageVersion;
    /// This version guards built-in constant `__COMPILE_FOR_TESTING__`,
    /// which is set to `true` when the code is compiled for testing purposes.
    pub const LANGUAGE_VERSION_FOR_COMPILE_FOR_TESTING: LanguageVersion = LanguageVersion::V2_2;
    pub const LANGUAGE_VERSION_FOR_SINT: LanguageVersion = LanguageVersion::V2_3;
    pub const LANGUAGE_VERSION_FOR_PUBLIC_STRUCT: LanguageVersion = LanguageVersion::V2_4;
    pub const LANGUAGE_VERSION_FOR_RAC: LanguageVersion =
        crate::metadata::LATEST_LANGUAGE_VERSION_VALUE;
}
```

**File:** third_party/move/move-model/src/metadata.rs (L317-326)
```rust
    pub fn infer_bytecode_version(&self, version: Option<u32>) -> u32 {
        env::get_bytecode_version_from_env(version).unwrap_or(match self {
            LanguageVersion::V1 => VERSION_DEFAULT,
            LanguageVersion::V2_0
            | LanguageVersion::V2_1
            | LanguageVersion::V2_2
            | LanguageVersion::V2_3 => VERSION_DEFAULT,
            LanguageVersion::V2_4 | LanguageVersion::V2_5 => VERSION_DEFAULT_LANG_V2_4,
        })
    }
```
