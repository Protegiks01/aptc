# Audit Report

## Title
Faucet Denial of Service via Google Captcha API Failure

## Summary
The `GoogleCaptchaChecker` implementation lacks timeout configuration, retry logic, and graceful error handling when communicating with Google's reCAPTCHA verification API. When Google's API is unavailable, slow, or unreachable, all captcha-protected faucet requests fail with HTTP 500 errors, causing a complete denial of service for the faucet.

## Finding Description

The `GoogleCaptchaChecker` makes an HTTP request to Google's captcha verification API without proper error resilience. [1](#0-0) 

When the HTTP request fails for any reason (network timeout, DNS failure, Google API downtime, or slow responses), the error is converted to an `AptosTapError` with `AptosTapErrorCode::CheckerError`. [2](#0-1) 

This error propagates through the checker validation flow, where it's caught and immediately returned to the client. [3](#0-2) 

The `CheckerError` code maps to `StatusCode::INTERNAL_SERVER_ERROR` (HTTP 500). [4](#0-3) 

Critical issues:
1. **No timeout configured**: `reqwest::Client::new()` creates a client with default settings (no timeout), meaning requests can hang indefinitely until TCP timeout
2. **No retry logic**: Single request failure immediately fails the entire faucet request
3. **No fallback mechanism**: No alternative validation path when Google's API is unavailable
4. **Poor error classification**: Network/external API failures return HTTP 500 (internal server error) instead of HTTP 503 (service unavailable)

**Attack Scenario:**
1. Attacker monitors Google's reCAPTCHA API status or waits for natural outages
2. When Google's API is experiencing issues (which happens periodically), the attacker can cause resource exhaustion by sending multiple requests
3. All legitimate users are denied service with HTTP 500 errors
4. Alternatively, if the attacker can manipulate network routing between the faucet and Google (MITM, BGP hijacking), they can cause request failures

## Impact Explanation

This vulnerability qualifies as **Medium severity** per Aptos bug bounty criteria due to causing service availability issues for a critical developer tool. While the faucet is not part of the core blockchain consensus or execution layer, it is essential infrastructure for:
- Developer onboarding to testnet/devnet
- Integration testing requiring funded accounts
- Third-party application development

The impact includes:
- Complete denial of service for all captcha-protected faucet requests
- Poor user experience (HTTP 500 suggests server fault rather than external dependency failure)
- Potential resource exhaustion if requests hang without timeout

However, this vulnerability does **not**:
- Affect blockchain consensus, execution, or state
- Compromise validator operations or staking
- Lead to fund theft or unauthorized minting on mainnet
- Break any of the 10 critical blockchain invariants

## Likelihood Explanation

**Likelihood: Medium to High**

Factors increasing likelihood:
- Google's APIs have documented outage history (several incidents per year)
- No attacker sophistication required - vulnerability triggers on natural Google API failures
- No timeout means even slow responses cause degraded service
- Single point of failure for all captcha-protected requests

Factors decreasing likelihood:
- Requires Google's API to be down/slow (external dependency)
- Limited to faucet service, not core blockchain
- Faucet operators can potentially switch to alternative captcha solutions (TapCaptcha)

## Recommendation

Implement resilient error handling with the following changes:

1. **Add timeout configuration**:
```rust
let client = reqwest::Client::builder()
    .timeout(Duration::from_secs(5))
    .build()
    .map_err(|e| AptosTapError::new_with_error_code(e, AptosTapErrorCode::CheckerError))?;

let verify_result = client
    .post(GOOGLE_CAPTCHA_ENDPOINT)
    .form::<VerifyRequest>(&VerifyRequest { /* ... */ })
    .send()
    .await;
```

2. **Implement retry logic with exponential backoff** for transient failures

3. **Add graceful degradation**:
```rust
.map_err(|e| {
    AptosTapError::new_with_error_code(
        format!("Captcha verification service temporarily unavailable: {}", e),
        AptosTapErrorCode::StorageError // or create new ServiceUnavailable code
    )
})?;
```

4. **Return HTTP 503 instead of 500** for external dependency failures by mapping the error code appropriately: [5](#0-4) 

5. **Consider fallback validation** (e.g., temporarily disable captcha during Google outages with rate limiting, or failover to TapCaptcha)

## Proof of Concept

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use poem::http::HeaderMap;
    use std::sync::Arc;
    
    #[tokio::test]
    async fn test_google_api_timeout_causes_500_error() {
        // Create a GoogleCaptchaChecker with invalid endpoint to simulate failure
        let mut config = GoogleCaptchaCheckerConfig {
            google_captcha_api_key: KeyString("test_key".to_string()),
        };
        
        // This test would require mocking the HTTP client or using a test server
        // that simulates timeout/failure. For demonstration:
        
        // 1. Start a test HTTP server that delays responses beyond timeout
        // 2. Configure GoogleCaptchaChecker to point to this server
        // 3. Make a request with valid captcha token
        // 4. Assert that the error returned is CheckerError (HTTP 500)
        // 5. Verify that the faucet request fails completely
        
        // Expected behavior: HTTP 500 error
        // Desired behavior: HTTP 503 with retry-after header
    }
}
```

To reproduce in integration testing:
1. Configure faucet with GoogleCaptchaChecker enabled
2. Use network manipulation (iptables, firewall rules) to block access to `www.google.com`
3. Submit funding request with valid captcha token
4. Observe HTTP 500 response instead of graceful degradation
5. Verify all subsequent captcha-protected requests fail until network access restored

## Notes

This vulnerability represents a **resilience failure** rather than a core security vulnerability. While it enables denial of service of the faucet, it does not affect the Aptos blockchain's consensus, execution, storage, or any critical invariants. The faucet is a development/testing utility separate from core validator infrastructure.

The severity assessment assumes the faucet is considered critical infrastructure for developer onboarding. If the faucet is viewed purely as a convenience tool, this issue may be classified as Low severity or out of scope for the security audit.

### Citations

**File:** crates/aptos-faucet/core/src/checkers/google_captcha.rs (L77-87)
```rust
        let verify_result = reqwest::Client::new()
            .post(GOOGLE_CAPTCHA_ENDPOINT)
            // Google captcha API only accepts form encoded payload, lol
            .form::<VerifyRequest>(&VerifyRequest {
                secret: self.config.google_captcha_api_key.0.clone(),
                response: captcha_token.to_string(),
                remoteip: data.source_ip.to_string(),
            })
            .send()
            .await
            .map_err(|e| AptosTapError::new_with_error_code(e, AptosTapErrorCode::CheckerError))?;
```

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L264-266)
```rust
            rejection_reasons.extend(checker.check(checker_data.clone(), dry_run).await.map_err(
                |e| AptosTapError::new_with_error_code(e, AptosTapErrorCode::CheckerError),
            )?);
```

**File:** crates/aptos-faucet/core/src/endpoints/errors.rs (L185-187)
```rust
            | AptosTapErrorCode::CheckerError
            | AptosTapErrorCode::StorageError
            | AptosTapErrorCode::InternalError => StatusCode::INTERNAL_SERVER_ERROR,
```

**File:** crates/aptos-faucet/core/src/endpoints/errors.rs (L188-190)
```rust
            AptosTapErrorCode::ServerOverloaded | AptosTapErrorCode::FunderAccountProblem => {
                StatusCode::SERVICE_UNAVAILABLE
            },
```
