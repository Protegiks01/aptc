# Audit Report

## Title
Validator Peer Identity Exposure and Consensus Behavior Correlation via Public Metrics and Telemetry

## Summary
The Aptos node inspection service exposes a Prometheus metrics endpoint that reveals peer_ids of ALL validators in the current epoch (not just the local node), combined with the telemetry system that transmits detailed consensus behavior metrics (proposals, timeouts, committed rounds) tagged with peer_ids to a centralized service. This enables malicious actors to correlate on-chain validator identities with real-time consensus behavior patterns, facilitating targeted attacks and voting pattern prediction.

## Finding Description
The vulnerability exists across multiple components that together create an information correlation attack vector:

**1. All-Validator Peer ID Exposure via Metrics Endpoint:**

The consensus metrics expose ALL validators' peer_ids through a gauge metric with peer_id labels: [1](#0-0) 

This metric is populated for every validator in the epoch, not just the local node: [2](#0-1) 

**2. Public Accessibility of Metrics Endpoint:**

The inspection service binds to all network interfaces by default and exposes these metrics: [3](#0-2) 

The metrics are served via the `/metrics` endpoint: [4](#0-3) 

**3. Consensus-Sensitive Telemetry with Peer ID:**

The telemetry system collects and transmits consensus behavior metrics: [5](#0-4) 

These metrics are sent to the telemetry service with the validator's peer_id explicitly included: [6](#0-5) 

**4. Correlation Attack Path:**

A malicious validator or network observer can:
1. Query any validator's public `/metrics` endpoint to obtain the complete list of validator peer_ids and their voting power
2. Observe consensus network messages (ProposalMsg, VoteMsg, RoundTimeoutMsg) which include author PeerIds
3. If telemetry service access is obtained (via compromise or insider access), correlate real-time behavior metrics (PROPOSALS_COUNT, TIMEOUT_COUNT, LAST_COMMITTED_ROUND) with observed consensus activity
4. Track which validators timeout frequently, identify validators with network issues, predict voting patterns based on historical behavior

This breaks the security expectation that validator operational metrics should remain private to prevent strategic targeting.

## Impact Explanation
This qualifies as **Medium Severity** under the Aptos bug bounty criteria for the following reasons:

1. **Information Disclosure**: Exposes operational behavior patterns of all validators, not just public identities
2. **Enables Strategic Attacks**: Attackers can identify validators with:
   - High timeout rates (network connectivity issues)
   - Low proposal counts (performance problems)
   - Lag in committed rounds (synchronization delays)
3. **Facilitates Targeted Exploitation**: Knowledge of validator weaknesses enables:
   - Selective DoS attacks against unreliable validators
   - Strategic consensus manipulation by timing attacks during predictable validator behavior
   - Social engineering attacks against operators of identified problematic validators

While this does not directly cause fund loss or consensus violations, it provides actionable intelligence that significantly lowers the barrier for more serious attacks, fitting the "State inconsistencies requiring intervention" or "Minor information leaks" category depending on how the intelligence is weaponized.

## Likelihood Explanation
**Likelihood: MEDIUM to HIGH**

**Factors increasing likelihood:**
1. Many validators expose metrics endpoints for legitimate monitoring purposes (Prometheus scraping, Grafana dashboards)
2. Default configuration binds to `0.0.0.0` making the endpoint network-accessible if not firewalled
3. Consensus messages are observable by any validator participant
4. Telemetry service compromise provides high-value correlation data for strategic attacks
5. The attack requires no specialized tools - standard Prometheus client and network observation

**Factors that may reduce exploitability:**
1. Validators may firewall the metrics port (though many don't for monitoring)
2. Telemetry service access requires compromise or insider access
3. Mainnet validators have configuration sanitization that discourages exposure of sensitive endpoints

However, the core issue remains that even a single accessible metrics endpoint reveals ALL validators' peer_ids, creating a systemic disclosure.

## Recommendation

**Immediate Mitigations:**

1. **Remove All-Validator Metrics from Public Endpoint:**
   Modify the metrics collection to only expose the local node's peer_id, not all validators:

```rust
// In consensus/src/epoch_manager.rs
// Instead of iterating all validators:
// ONLY set the local node's voting power metric
counters::LOCAL_VALIDATOR_VOTING_POWER.set(
    epoch_state.verifier.get_voting_power(&self_peer_id).unwrap_or(0) as i64
);
```

2. **Restrict Metrics Endpoint Binding:**
   Change the default to bind to localhost only:

```yaml
# In config/src/config/inspection_service_config.rs
fn default() -> InspectionServiceConfig {
    InspectionServiceConfig {
        address: "127.0.0.1".to_string(),  // Changed from "0.0.0.0"
        port: 9101,
        // ...
    }
}
```

3. **Add Peer ID Scrubbing to Telemetry:**
   Consider hashing or anonymizing peer_ids in telemetry for privacy-preserving analytics while maintaining correlation capability for operators.

4. **Implement Access Control:**
   Add authentication to the metrics endpoint or document firewall requirements explicitly in validator deployment guides.

## Proof of Concept

**Step 1: Query a validator's metrics endpoint**
```bash
# Query the inspection service metrics endpoint
curl http://validator-node:9101/metrics | grep aptos_all_validators_voting_power

# Output will show ALL validators:
# aptos_all_validators_voting_power{peer_id="0x1"} 100
# aptos_all_validators_voting_power{peer_id="0x2"} 150
# aptos_all_validators_voting_power{peer_id="0x3"} 200
# ... (complete validator set exposed)
```

**Step 2: Observe consensus messages**
```rust
// As a validator, observe incoming consensus messages
// ProposalMsg, VoteMsg, etc. all contain author field with PeerId
match consensus_msg {
    ConsensusMsg::ProposalMsg(proposal) => {
        let author_peer_id = proposal.proposer();
        // Match this against the list from Step 1
    },
    ConsensusMsg::RoundTimeoutMsg(timeout) => {
        let timeout_peer_id = timeout.author();
        // Identify which validator is timing out
    },
    // ...
}
```

**Step 3: Correlate with telemetry (if accessible)**
```bash
# If telemetry service is compromised, query metrics by peer_id
# Example Prometheus query:
aptos_consensus_timeout_count{peer_id="0x2"}

# Reveals that validator 0x2 has high timeout count
# Combined with observed consensus behavior, enables targeted attacks
```

## Notes

This vulnerability represents a systemic privacy leak where the design choice to expose all validator peer_ids via metrics (likely for monitoring dashboards) creates an unintended correlation attack surface when combined with the telemetry system's peer-tagged behavior metrics. While validators' account addresses are already public on-chain, the real-time operational behavior metrics should remain private to prevent strategic exploitation. The fix requires careful consideration of monitoring requirements while minimizing information disclosure to potential adversaries.

### Citations

**File:** consensus/src/counters.rs (L537-545)
```rust
/// Emits voting power for all validators in the current epoch.
pub static ALL_VALIDATORS_VOTING_POWER: Lazy<IntGaugeVec> = Lazy::new(|| {
    register_int_gauge_vec!(
        "aptos_all_validators_voting_power",
        "Voting power for all validators in current epoch",
        &["peer_id"]
    )
    .unwrap()
});
```

**File:** consensus/src/epoch_manager.rs (L790-797)
```rust
        epoch_state
            .verifier
            .get_ordered_account_addresses_iter()
            .for_each(|peer_id| {
                counters::ALL_VALIDATORS_VOTING_POWER
                    .with_label_values(&[&peer_id.to_string()])
                    .set(epoch_state.verifier.get_voting_power(&peer_id).unwrap_or(0) as i64)
            });
```

**File:** config/src/config/inspection_service_config.rs (L26-36)
```rust
impl Default for InspectionServiceConfig {
    fn default() -> InspectionServiceConfig {
        InspectionServiceConfig {
            address: "0.0.0.0".to_string(),
            port: 9101,
            expose_configuration: false,
            expose_identity_information: true,
            expose_peer_information: true,
            expose_system_information: true,
        }
    }
```

**File:** crates/aptos-inspection-service/src/server/metrics.rs (L72-76)
```rust
/// Handles a new metrics request (with text encoding)
pub fn handle_metrics_request() -> (StatusCode, Body, String) {
    let buffer = utils::get_encoded_metrics(TextEncoder::new());
    (StatusCode::OK, Body::from(buffer), CONTENT_TYPE_TEXT.into())
}
```

**File:** crates/aptos-telemetry/src/core_metrics.rs (L67-83)
```rust
/// Collects the consensus metrics and appends it to the given map
fn collect_consensus_metrics(core_metrics: &mut BTreeMap<String, String>) {
    core_metrics.insert(
        CONSENSUS_PROPOSALS_COUNT.into(),
        aptos_consensus::counters::PROPOSALS_COUNT.get().to_string(),
    );
    core_metrics.insert(
        CONSENSUS_LAST_COMMITTED_ROUND.into(),
        aptos_consensus::counters::LAST_COMMITTED_ROUND
            .get()
            .to_string(),
    );
    core_metrics.insert(
        CONSENSUS_TIMEOUT_COUNT.into(),
        aptos_consensus::counters::TIMEOUT_COUNT.get().to_string(),
    );
    //TODO(joshlind): add block tracing and back pressure!
```

**File:** crates/aptos-telemetry/src/service.rs (L460-471)
```rust
    // Create and send the telemetry dump
    let event_name = telemetry_event.name.clone();
    let timestamp_micros = match SystemTime::now().duration_since(UNIX_EPOCH) {
        Ok(duration) => duration.as_micros().to_string(),
        Err(_) => UNKNOWN_METRIC_VALUE.into(),
    };
    let telemetry_dump = TelemetryDump {
        client_id: Uuid::new_v4().to_string(), // We generate a random client id for each request
        user_id: peer_id,
        timestamp_micros,
        events: vec![telemetry_event],
    };
```
