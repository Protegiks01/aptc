# Audit Report

## Title
Missing Epoch Monotonicity Validation in EpochChangeProof Verification Allows Non-Strictly-Increasing Epoch Sequences

## Summary
The `EpochChangeProof::verify()` function does not enforce strict epoch monotonicity (epoch_n+1 > epoch_n). While it verifies signatures and checks that each ledger info's epoch matches the current verifier's epoch, it fails to validate that the `next_epoch_state.epoch` field is exactly `current_epoch + 1`, allowing acceptance of epoch change proofs with equal, backwards, or arbitrarily-jumping epoch numbers.

## Finding Description

The vulnerability exists in the epoch change verification logic. [1](#0-0) 

The verification flow operates as follows:

1. The function iterates through ledger infos in the proof, starting with an initial trusted verifier at epoch N
2. For each ledger info, it calls `verifier_ref.verify(ledger_info_with_sigs)` which only validates that the ledger info's epoch equals the verifier's current epoch [2](#0-1) 
3. It then extracts `next_epoch_state` from the ledger info and updates the verifier reference [3](#0-2) 
4. **CRITICAL MISSING CHECK**: There is no validation that `next_epoch_state.epoch == current_epoch + 1`

The code comment states the intention: "Try to verify each (epoch -> epoch + 1) jump in the EpochChangeProof" [4](#0-3)  but this invariant is never enforced.

**Attack Scenario:**

While the Move framework's `reconfigure()` function correctly increments epochs by exactly 1 [5](#0-4) , the verification code must defensively validate this invariant. If either:

1. A Byzantine majority (2f+1 validators) colludes to sign a malicious ledger info with incorrect `next_epoch_state.epoch`, OR
2. A bug in the Move reconfiguration logic produces incorrect epoch values in `ConfigurationResource` [6](#0-5) 

Then the verification will accept proofs with:
- **Same epoch**: epoch 5 → 5 → 5 (no progress)
- **Backwards epochs**: epoch 5 → 4 → 3 (regression)
- **Skipped epochs**: epoch 5 → 7 → 9 (discontinuity)

This breaks the fundamental consensus invariant that epochs must increase monotonically and strictly.

## Impact Explanation

**Severity: HIGH** (per Aptos Bug Bounty criteria - "Significant protocol violations")

This vulnerability enables:

1. **State Confusion**: Different nodes could accept different epoch change proofs, leading to divergent views of the current epoch
2. **Consensus Safety Violation**: Breaks the invariant that all honest validators must agree on epoch progression
3. **Liveness Issues**: Nodes stuck at incorrect epochs cannot properly participate in consensus
4. **Defense-in-Depth Failure**: The verification layer fails to catch bugs or attacks from the execution layer

While exploitation requires either Byzantine majority or a bug in trusted Move code, defense-in-depth is a critical security principle. The verification layer should validate all invariants independently rather than trusting the execution layer unconditionally.

## Likelihood Explanation

**Likelihood: MEDIUM**

Exploitation requires one of two conditions:

1. **Byzantine Majority (Lower Probability)**: Requires 2f+1 validators to collude, which approaches the 1/3 Byzantine fault assumption boundary
2. **Move Framework Bug (Higher Probability)**: Complex smart contract code in `reconfiguration.move` could contain edge cases or bugs that produce incorrect epoch values

The second scenario is more realistic - bugs in complex state transition logic are common, and the verification layer should catch such issues rather than propagating them throughout the network.

## Recommendation

Add explicit epoch monotonicity validation in `EpochChangeProof::verify()`:

```rust
// In types/src/epoch_change.rs, modify the verify loop:

for ledger_info_with_sigs in self.ledger_info_with_sigs.iter()
    .skip_while(|&ledger_info_with_sigs| {
        verifier.is_ledger_info_stale(ledger_info_with_sigs.ledger_info())
    })
{
    let current_epoch = match verifier_ref {
        v if v.epoch_change_verification_required(u64::MAX) => {
            // Extract epoch from verifier
            ledger_info_with_sigs.ledger_info().epoch()
        },
        _ => ledger_info_with_sigs.ledger_info().epoch()
    };
    
    verifier_ref.verify(ledger_info_with_sigs)?;
    
    let next_epoch_state = ledger_info_with_sigs
        .ledger_info()
        .next_epoch_state()
        .ok_or_else(|| format_err!("LedgerInfo doesn't carry a ValidatorSet"))?;
    
    // ADDED: Enforce strict epoch monotonicity
    ensure!(
        next_epoch_state.epoch == current_epoch + 1,
        "Epoch monotonicity violation: next_epoch_state.epoch ({}) must equal current_epoch + 1 ({})",
        next_epoch_state.epoch,
        current_epoch + 1
    );
    
    verifier_ref = next_epoch_state;
}
```

## Proof of Concept

```rust
#[test]
fn test_epoch_monotonicity_violation_rejected() {
    use crate::{ledger_info::LedgerInfo, validator_verifier::random_validator_verifier};
    use aptos_crypto::hash::HashValue;
    use std::sync::Arc;

    // Create validator set for epoch 5
    let (current_signers, current_verifier) = random_validator_verifier(5, None, true);
    let current_verifier = Arc::new(current_verifier);
    let current_epoch = 5u64;
    
    // Create epoch ending ledger info for epoch 5
    // BUT with next_epoch_state pointing to epoch 5 (same) instead of 6
    let (_, next_verifier) = random_validator_verifier(5, None, true);
    let malicious_epoch_state = EpochState {
        epoch: 5,  // WRONG! Should be 6
        verifier: Arc::new(next_verifier),
    };
    
    let ledger_info = LedgerInfo::new(
        BlockInfo::new(
            current_epoch,
            0,
            HashValue::zero(),
            HashValue::zero(),
            100,
            0,
            Some(malicious_epoch_state),
        ),
        HashValue::zero(),
    );
    
    // Sign with 2f+1 validators
    let partial_signatures = PartialSignatures::new(
        current_signers
            .iter()
            .map(|s| (s.author(), s.sign(&ledger_info).unwrap()))
            .collect(),
    );
    
    let aggregated_signature = current_verifier
        .aggregate_signatures(partial_signatures.signatures_iter())
        .unwrap();
    
    let malicious_li = LedgerInfoWithSignatures::new(
        ledger_info,
        aggregated_signature,
    );
    
    // Create proof with malicious ledger info
    let proof = EpochChangeProof::new(vec![malicious_li], false);
    
    // Verification should FAIL due to epoch monotonicity violation
    // But currently it PASSES (vulnerability)
    let verifier = EpochState {
        epoch: current_epoch,
        verifier: current_verifier,
    };
    
    let result = proof.verify(&verifier);
    
    // With fix: should return error about epoch monotonicity violation
    // Without fix: incorrectly returns Ok
    assert!(result.is_err(), "Should reject non-monotonic epoch sequence");
}
```

## Notes

This is a defense-in-depth issue where the verification layer trusts the execution layer's epoch values without validation. While the Move framework is designed to always increment epochs correctly, the verification code should independently validate this critical invariant to catch bugs, state corruption, or Byzantine attacks at the execution layer.

### Citations

**File:** types/src/epoch_change.rs (L66-118)
```rust
    pub fn verify(&self, verifier: &dyn Verifier) -> Result<&LedgerInfoWithSignatures> {
        ensure!(
            !self.ledger_info_with_sigs.is_empty(),
            "The EpochChangeProof is empty"
        );
        ensure!(
            !verifier
                .is_ledger_info_stale(self.ledger_info_with_sigs.last().unwrap().ledger_info()),
            "The EpochChangeProof is stale as our verifier is already ahead \
             of the entire EpochChangeProof"
        );
        let mut verifier_ref = verifier;

        for ledger_info_with_sigs in self
            .ledger_info_with_sigs
            .iter()
            // Skip any stale ledger infos in the proof prefix. Note that with
            // the assertion above, we are guaranteed there is at least one
            // non-stale ledger info in the proof.
            //
            // It's useful to skip these stale ledger infos to better allow for
            // concurrent client requests.
            //
            // For example, suppose the following:
            //
            // 1. My current trusted state is at epoch 5.
            // 2. I make two concurrent requests to two validators A and B, who
            //    live at epochs 9 and 11 respectively.
            //
            // If A's response returns first, I will ratchet my trusted state
            // to epoch 9. When B's response returns, I will still be able to
            // ratchet forward to 11 even though B's EpochChangeProof
            // includes a bunch of stale ledger infos (for epochs 5, 6, 7, 8).
            //
            // Of course, if B's response returns first, we will reject A's
            // response as it's completely stale.
            .skip_while(|&ledger_info_with_sigs| {
                verifier.is_ledger_info_stale(ledger_info_with_sigs.ledger_info())
            })
        {
            // Try to verify each (epoch -> epoch + 1) jump in the EpochChangeProof.
            verifier_ref.verify(ledger_info_with_sigs)?;
            // While the original verification could've been via waypoints,
            // all the next epoch changes are verified using the (already
            // trusted) validator sets.
            verifier_ref = ledger_info_with_sigs
                .ledger_info()
                .next_epoch_state()
                .ok_or_else(|| format_err!("LedgerInfo doesn't carry a ValidatorSet"))?;
        }

        Ok(self.ledger_info_with_sigs.last().unwrap())
    }
```

**File:** types/src/epoch_state.rs (L41-50)
```rust
    fn verify(&self, ledger_info: &LedgerInfoWithSignatures) -> anyhow::Result<()> {
        ensure!(
            self.epoch == ledger_info.ledger_info().epoch(),
            "LedgerInfo has unexpected epoch {}, expected {}",
            ledger_info.ledger_info().epoch(),
            self.epoch
        );
        ledger_info.verify_signatures(&self.verifier)?;
        Ok(())
    }
```

**File:** aptos-move/framework/aptos-framework/sources/reconfiguration.move (L142-142)
```text
        config_ref.epoch = config_ref.epoch + 1;
```

**File:** execution/executor/src/workflow/do_get_execution_output.rs (L520-540)
```rust
    fn ensure_next_epoch_state(to_commit: &TransactionsWithOutput) -> Result<EpochState> {
        let last_write_set = to_commit
            .transaction_outputs
            .last()
            .ok_or_else(|| anyhow!("to_commit is empty."))?
            .write_set();

        let write_set_view = WriteSetStateView {
            write_set: last_write_set,
        };

        let validator_set = ValidatorSet::fetch_config(&write_set_view)
            .ok_or_else(|| anyhow!("ValidatorSet not touched on epoch change"))?;
        let configuration = ConfigurationResource::fetch_config(&write_set_view)
            .ok_or_else(|| anyhow!("Configuration resource not touched on epoch change"))?;

        Ok(EpochState::new(
            configuration.epoch(),
            (&validator_set).into(),
        ))
    }
```
