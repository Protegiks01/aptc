# Audit Report

## Title
Non-Canonical JSON Serialization in UnsupportedJWK Causes JWK Consensus Failure and Potential Hash Divergence

## Summary
When OIDC providers use non-RSA JWK types (e.g., ES256 elliptic curve keys), validators convert them to `UnsupportedJWK` objects without canonical JSON serialization. Since JSON key ordering is non-deterministic across HTTP responses, different validators construct `UnsupportedJWK` objects with different payload bytes and SHA3-256 hash IDs. This prevents quorum formation during signature aggregation, completely breaking JWK consensus and the keyless authentication system.

## Finding Description

The vulnerability exists in the JWK observation and consensus mechanism. When validators observe JWKs from OIDC providers, they fetch JSON via HTTP and convert it to JWK objects. [1](#0-0) 

For non-RSA key types, the conversion falls back to creating `UnsupportedJWK` objects. [2](#0-1) 

The critical flaw is in the `UnsupportedJWK::from` implementation, which uses non-canonical JSON serialization with an explicit TODO comment acknowledging the issue. [3](#0-2) 

The `serde_json::Value::to_string()` method preserves whatever key ordering was present during JSON parsing, which depends on the OIDC provider's HTTP response. Since the JSON specification does not guarantee object key ordering, different validators may receive responses with different key orderings at different times.

**Attack Path:**
1. OIDC provider deploys ES256 elliptic curve keys (explicitly supported by the system design)
2. Provider's JWKS endpoint returns JSON with non-deterministic key ordering
3. Validator A fetches JWKs at time T1, receives: `{"kty":"EC","kid":"key1","crv":"P-256",...}`
4. Validator B fetches JWKs at time T2, receives: `{"kid":"key1","kty":"EC","crv":"P-256",...}`
5. Both create `UnsupportedJWK` with different `payload` bytes (line 53)
6. Both compute different SHA3-256 hash IDs (line 55)
7. JWKs are sorted by these divergent IDs [4](#0-3) 
8. Each validator constructs a different `ProviderJWKs` object and signs it [5](#0-4) 
9. During signature aggregation, the strict equality check fails [6](#0-5) 
10. Signatures are rejected because `local_view != peer_view`
11. Quorum cannot be reached (requires 2f+1 validators to sign identical bytes)
12. No `QuorumCertifiedUpdate` is produced
13. JWK update fails permanently until manual intervention

The validator transaction processing verifies multi-signatures against the exact `observed` object. [7](#0-6)  When validators construct different `observed` objects due to JSON non-determinism, they cannot form a valid quorum certificate.

## Impact Explanation

**Severity: Critical**

This vulnerability qualifies for Critical severity under Aptos bug bounty criteria:

1. **Total Loss of Liveness for Keyless Authentication**: When triggered, JWK updates cannot progress, completely breaking the keyless authentication feature system-wide. This matches the Critical criterion: "Total loss of liveness/network availability" for a critical system component. Users cannot authenticate using OIDC providers, effectively disabling this authentication method.

2. **Non-Recoverable Without Manual Intervention**: The system cannot self-heal. Once validators diverge on JWK representations, consensus cannot be reached through normal protocol operation. The validator transaction pool's `should_exclude` filtering operates on transaction hashes [8](#0-7) , but the issue prevents any `ValidatorTransaction` from being created in the first place during the pre-consensus signature aggregation phase.

3. **Consensus Invariant Violation**: Breaks the deterministic execution invariant - validators cannot agree on identical state for logically identical inputs (the same OIDC provider JWKs). This violates fundamental blockchain consensus guarantees.

## Likelihood Explanation

**Current Likelihood: Low to Medium**
- Requires OIDC providers to use non-RSA key types (ES256/ES384 elliptic curve keys)
- These key types are explicitly supported by the system architecture through `UnsupportedJWK` [9](#0-8) 
- JSON specification RFC 8259 does not guarantee object key ordering
- Many HTTP servers and JSON libraries produce non-deterministic key orders
- The TODO comment indicates developers are aware but haven't prioritized fixing it

**Future Likelihood: High**
- ES256/ES384 elliptic curve keys are increasingly adopted for security and performance
- As the Aptos ecosystem grows, more OIDC providers will integrate
- The system is architecturally designed to support these key types, making the trigger path inevitable

**Triggering Conditions:**
- No malicious actor required - occurs naturally
- No special privileges needed
- No validator collusion required
- Happens deterministically when conditions are met

## Recommendation

Implement canonical JSON serialization when constructing `UnsupportedJWK` payloads. Replace the non-canonical `to_string()` method with a canonical JSON serializer that produces deterministic output regardless of input key ordering.

**Suggested Fix:**
```rust
impl From<serde_json::Value> for UnsupportedJWK {
    fn from(json_value: serde_json::Value) -> Self {
        // Use canonical JSON serialization (e.g., sort keys alphabetically)
        let payload = canonical_json_serialize(&json_value).into_bytes();
        Self {
            id: HashValue::sha3_256_of(payload.as_slice()).to_vec(),
            payload,
        }
    }
}
```

Implement a canonical JSON serialization function that:
1. Recursively traverses the JSON structure
2. Sorts all object keys alphabetically
3. Produces deterministic output for any given JSON semantic content
4. Ensures all validators compute identical payload bytes and IDs

Alternative: Use JCS (JSON Canonicalization Scheme) RFC 8785 or a similar standardized canonical JSON format.

## Proof of Concept

The vulnerability is demonstrated through code analysis rather than executable PoC, as it requires:
1. OIDC provider infrastructure with ES256 keys
2. Multiple validator nodes
3. Non-deterministic JSON responses from the provider

However, the vulnerability can be verified by:
1. Examining the non-canonical JSON serialization at [10](#0-9) 
2. Confirming the strict equality check at [11](#0-10) 
3. Creating two `serde_json::Value` objects with identical semantic content but different key orderings, converting both to `UnsupportedJWK`, and observing different IDs

The TODO comment explicitly acknowledges this as a known design flaw requiring resolution.

---

**Notes:**

This vulnerability represents a critical consensus failure mechanism in the JWK observation system. While currently unexploited due to limited ES256 key adoption, the system's explicit design to support non-RSA keys through `UnsupportedJWK` makes this trigger path inevitable as the ecosystem evolves. The TODO comment indicates awareness but lack of prioritization, suggesting this could be exploited as ES256 adoption increases.

### Citations

**File:** crates/jwk-utils/src/lib.rs (L21-37)
```rust
/// Given a JWK URL, fetch its JWKs.
///
/// Optionally, if an address is given, send it as the cookie payload.
/// The optional logic is only used in smoke tests, e.g., `jwk_consensus_basic`.
pub async fn fetch_jwks_from_jwks_uri(
    my_addr: Option<AccountAddress>,
    jwks_uri: &str,
) -> Result<Vec<JWK>> {
    let client = reqwest::Client::new();
    let mut request_builder = client.get(jwks_uri);
    if let Some(addr) = my_addr {
        request_builder = request_builder.header(COOKIE, addr.to_hex());
    }
    let JWKsResponse { keys } = request_builder.send().await?.json().await?;
    let jwks = keys.into_iter().map(JWK::from).collect();
    Ok(jwks)
}
```

**File:** types/src/jwks/jwk/mod.rs (L80-90)
```rust
impl From<serde_json::Value> for JWK {
    fn from(value: serde_json::Value) -> Self {
        match RSA_JWK::try_from(&value) {
            Ok(rsa) => Self::RSA(rsa),
            Err(_) => {
                let unsupported = UnsupportedJWK::from(value);
                Self::Unsupported(unsupported)
            },
        }
    }
}
```

**File:** types/src/jwks/unsupported/mod.rs (L51-59)
```rust
impl From<serde_json::Value> for UnsupportedJWK {
    fn from(json_value: serde_json::Value) -> Self {
        let payload = json_value.to_string().into_bytes(); //TODO: canonical to_string.
        Self {
            id: HashValue::sha3_256_of(payload.as_slice()).to_vec(),
            payload,
        }
    }
}
```

**File:** crates/aptos-jwk-consensus/src/jwk_observer.rs (L70-84)
```rust
        loop {
            tokio::select! {
                _ = interval.tick().fuse() => {
                    let timer = Instant::now();
                    let result = fetch_jwks(open_id_config_url.as_str(), my_addr).await;
                    debug!(issuer = issuer, "observe_result={:?}", result);
                    let secs = timer.elapsed().as_secs_f64();
                    if let Ok(mut jwks) = result {
                        OBSERVATION_SECONDS.with_label_values(&[issuer.as_str(), "ok"]).observe(secs);
                        jwks.sort();
                        let _ = observation_tx.push((), (issuer.as_bytes().to_vec(), jwks));
                    } else {
                        OBSERVATION_SECONDS.with_label_values(&[issuer.as_str(), "err"]).observe(secs);
                    }
                },
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager_per_key.rs (L179-231)
```rust
    fn maybe_start_consensus(&mut self, update: KeyLevelUpdate) -> Result<()> {
        let consensus_already_started = match self
            .states_by_key
            .get(&(update.issuer.clone(), update.kid.clone()))
            .cloned()
        {
            Some(ConsensusState::InProgress { my_proposal, .. })
            | Some(ConsensusState::Finished { my_proposal, .. }) => {
                my_proposal.observed.to_upsert == update.to_upsert
            },
            _ => false,
        };

        if consensus_already_started {
            return Ok(());
        }

        let issuer_level_repr = update
            .try_as_issuer_level_repr()
            .context("initiate_key_level_consensus failed at repr conversion")?;
        let signature = self
            .consensus_key
            .sign(&issuer_level_repr)
            .context("crypto material error occurred during signing")?;

        let update_translated = update
            .try_as_issuer_level_repr()
            .context("maybe_start_consensus failed at update translation")?;
        let abort_handle = self
            .update_certifier
            .start_produce(
                self.epoch_state.clone(),
                update_translated,
                self.qc_update_tx.clone(),
            )
            .context("maybe_start_consensus failed at update_certifier.start_produce")?;

        self.states_by_key.insert(
            (update.issuer.clone(), update.kid.clone()),
            ConsensusState::InProgress {
                my_proposal: ObservedKeyLevelUpdate {
                    author: self.my_addr,
                    observed: update,
                    signature,
                },
                abort_handle_wrapper: QuorumCertProcessGuard {
                    handle: abort_handle,
                },
            },
        );

        Ok(())
    }
```

**File:** crates/aptos-jwk-consensus/src/observation_aggregation/mod.rs (L81-84)
```rust
        ensure!(
            self.local_view == peer_view,
            "adding peer observation failed with mismatched view"
        );
```

**File:** aptos-move/aptos-vm/src/validator_txns/jwk.rs (L139-143)
```rust
        // Verify multi-sig.
        verifier
            .verify_multi_signatures(&observed, &multi_sig)
            .map_err(|_| Expected(MultiSigVerificationFailed))?;

```

**File:** crates/validator-transaction-pool/src/lib.rs (L30-34)
```rust
    pub fn should_exclude(&self, txn: &ValidatorTransaction) -> bool {
        match self {
            TransactionFilter::PendingTxnHashSet(set) => set.contains(&txn.hash()),
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L68-73)
```text
    /// An JWK variant that represents the JWKs which were observed but not yet supported by Aptos.
    /// Observing `UnsupportedJWK`s means the providers adopted a new key type/format, and the system should be updated.
    struct UnsupportedJWK has copy, drop, store {
        id: vector<u8>,
        payload: vector<u8>,
    }
```
