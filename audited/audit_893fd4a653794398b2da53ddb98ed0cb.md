# Audit Report

## Title
Epoch History Bypass in Oneoff State Snapshot Restore Allows Unverified State Restoration

## Summary
The `db-tool` oneoff state snapshot restore command passes `None` for `epoch_history`, completely bypassing cryptographic signature verification of the `LedgerInfoWithSignatures`. This allows restoration of state snapshots with fabricated ledger info that lacks valid validator signatures, potentially enabling malicious actors to corrupt node databases with unverified state.

## Finding Description

When restoring a state snapshot via the oneoff command path, the code explicitly passes `None` for the `epoch_history` parameter: [1](#0-0) 

This `None` value causes the critical signature verification to be skipped in the state snapshot restore process: [2](#0-1) 

The `epoch_history.verify_ledger_info()` method is responsible for verifying that the `LedgerInfoWithSignatures` has valid signatures from the validator set: [3](#0-2) 

Without this verification, the only checks performed are:
1. Internal Merkle proof consistency (transaction info is in the accumulator)
2. Root hash matches between manifest and proof [4](#0-3) 

These checks only verify internal consistency, **not** that the data is cryptographically authenticated by the validator set.

The `TransactionInfoWithProof.verify()` method only verifies Merkle proofs against the ledger info but does not validate the ledger info's signatures: [5](#0-4) 

**Attack Scenario:**
1. Attacker creates malicious state snapshot backup files with fabricated `LedgerInfoWithSignatures` (no valid signatures)
2. Attacker constructs matching transaction proofs and state values to maintain internal consistency
3. Attacker distributes these files (e.g., via compromised backup service, social engineering)
4. Node operator runs `db-tool restore oneoff state-snapshot` with these files
5. State is restored without signature verification
6. Node database now contains unverified state that may diverge from the legitimate blockchain

The proper restore path (`BootstrapDB`) creates the epoch history through the `RestoreCoordinator`: [6](#0-5) 

This epoch history is then passed to state snapshot restore for verification. However, the oneoff path completely bypasses this.

## Impact Explanation

This vulnerability qualifies as **Medium to High Severity** under Aptos bug bounty criteria:

- **State inconsistencies requiring intervention**: A node restoring from malicious backup files will have corrupted state requiring complete re-synchronization
- **Significant protocol violations**: Bypasses fundamental cryptographic verification that state comes from the legitimate validator set
- **Potential for widespread impact**: If multiple operators use the same compromised backup source, multiple nodes could be affected simultaneously

While the corrupted node would likely fail to participate in consensus (due to state root mismatches), the immediate impact is node corruption requiring manual intervention. If used by validators during restoration, this could temporarily affect network health.

The vulnerability breaks critical security invariants:
- **State Consistency**: "State transitions must be atomic and verifiable via Merkle proofs" - while Merkle proofs are checked, they're verified against an unauthenticated ledger info
- **Cryptographic Correctness**: "BLS signatures, VRF, and hash operations must be secure" - signature verification is completely skipped

## Likelihood Explanation

**Moderate Likelihood** due to:

**Enabling Factors:**
- The oneoff command is a legitimate operational tool that operators might use
- No prominent warning indicates this bypasses security checks
- Operators may not understand the security implications
- Documentation comment suggests trusted waypoints aren't verified in oneoff restores: [7](#0-6) 

**Mitigating Factors:**
- Requires operator to explicitly use oneoff command instead of BootstrapDB
- Operator must use untrusted backup source
- Node startup waypoint checks may catch some discrepancies (though oneoff flow doesn't enforce this)
- The proper BootstrapDB restoration path is secure

## Recommendation

**Short-term fixes:**

1. Add a mandatory `--trust-unverified-backup` flag to oneoff state-snapshot restore with a clear warning:
```rust
#[clap(
    long,
    help = "WARNING: This skips cryptographic signature verification. Only use with backups from a trusted source. Malicious backups can corrupt your database."
)]
require_trust_flag: bool,
```

2. Require epoch_history or trusted waypoints for production restores:
```rust
Oneoff::StateSnapshot {
    storage,
    opt,
    global,
} => {
    // Require at least one form of verification
    if global.trusted_waypoints.is_empty() {
        warn!("No trusted waypoints provided. State snapshot will be restored without \
               signature verification. Only use this with backups from a trusted source.");
    }
    
    StateSnapshotRestoreController::new(
        opt,
        global.try_into()?,
        storage.init_storage().await?,
        None, /* epoch_history - consider requiring this */
    )
    .run()
    .await?;
},
```

**Long-term fix:**

Restore epoch history even for oneoff commands, or remove the oneoff state-snapshot command entirely and require use of the secure BootstrapDB path for production restores.

## Proof of Concept

```rust
// Demonstrate that oneoff restore bypasses signature verification
// This would be a Rust integration test

#[tokio::test]
async fn test_oneoff_restore_bypasses_signature_verification() {
    // 1. Create malicious backup files with:
    //    - Valid internal Merkle proofs
    //    - Matching root hashes
    //    - INVALID signatures (or no signatures)
    
    let malicious_ledger_info = LedgerInfoWithSignatures::new(
        LedgerInfo::new(...), // Contains fabricated state
        AggregateSignature::empty(), // No valid signatures!
    );
    
    // 2. Create state snapshot manifest pointing to malicious data
    let manifest = StateSnapshotBackup {
        version: 1000,
        root_hash: malicious_state_root,
        chunks: vec![...],
        proof: proof_handle, // Contains malicious_ledger_info
    };
    
    // 3. Run oneoff restore
    let result = StateSnapshotRestoreController::new(
        opt,
        global_opt,
        storage,
        None, // epoch_history = None bypasses verification!
    )
    .run()
    .await;
    
    // 4. Restore succeeds despite invalid signatures
    assert!(result.is_ok()); // This should fail but doesn't!
    
    // 5. Verify the malicious state was written to DB
    let restored_state = db.get_state_value(...);
    assert_eq!(restored_state, malicious_state_value);
}
```

**Notes**

This vulnerability appears to be partially intentional design for debugging scenarios, as indicated by the comment that LedgerInfos are "NOT checked at all when doing one-shot restoring." However, the lack of prominent warnings and the availability of this command in production builds creates a significant security risk. The proper BootstrapDB restore path includes full verification and should be the recommended approach for production use.

### Citations

**File:** storage/db-tool/src/restore.rs (L88-95)
```rust
                        StateSnapshotRestoreController::new(
                            opt,
                            global.try_into()?,
                            storage.init_storage().await?,
                            None, /* epoch_history */
                        )
                        .run()
                        .await?;
```

**File:** storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs (L125-136)
```rust
        let (txn_info_with_proof, li): (TransactionInfoWithProof, LedgerInfoWithSignatures) =
            self.storage.load_bcs_file(&manifest.proof).await?;
        txn_info_with_proof.verify(li.ledger_info(), manifest.version)?;
        let state_root_hash = txn_info_with_proof
            .transaction_info()
            .ensure_state_checkpoint_hash()?;
        ensure!(
            state_root_hash == manifest.root_hash,
            "Root hash mismatch with that in proof. root hash: {}, expected: {}",
            manifest.root_hash,
            state_root_hash,
        );
```

**File:** storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs (L137-139)
```rust
        if let Some(epoch_history) = self.epoch_history.as_ref() {
            epoch_history.verify_ledger_info(&li)?;
        }
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L276-312)
```rust
    pub fn verify_ledger_info(&self, li_with_sigs: &LedgerInfoWithSignatures) -> Result<()> {
        let epoch = li_with_sigs.ledger_info().epoch();
        ensure!(!self.epoch_endings.is_empty(), "Empty epoch history.",);
        if epoch > self.epoch_endings.len() as u64 {
            // TODO(aldenhu): fix this from upper level
            warn!(
                epoch = epoch,
                epoch_history_until = self.epoch_endings.len(),
                "Epoch is too new and can't be verified. Previous chunks are verified and node \
                won't be able to start if this data is malicious."
            );
            return Ok(());
        }
        if epoch == 0 {
            ensure!(
                li_with_sigs.ledger_info() == &self.epoch_endings[0],
                "Genesis epoch LedgerInfo info doesn't match.",
            );
        } else if let Some(wp_trusted) = self
            .trusted_waypoints
            .get(&li_with_sigs.ledger_info().version())
        {
            let wp_li = Waypoint::new_any(li_with_sigs.ledger_info());
            ensure!(
                *wp_trusted == wp_li,
                "Waypoints don't match. In backup: {}, trusted: {}",
                wp_li,
                wp_trusted,
            );
        } else {
            self.epoch_endings[epoch as usize - 1]
                .next_epoch_state()
                .ok_or_else(|| anyhow!("Shouldn't contain non- epoch bumping LIs."))?
                .verify(li_with_sigs)?;
        };
        Ok(())
    }
```

**File:** types/src/proof/mod.rs (L40-61)
```rust
fn verify_transaction_info(
    ledger_info: &LedgerInfo,
    transaction_version: Version,
    transaction_info: &TransactionInfo,
    ledger_info_to_transaction_info_proof: &TransactionAccumulatorProof,
) -> Result<()> {
    ensure!(
        transaction_version <= ledger_info.version(),
        "Transaction version {} is newer than LedgerInfo version {}.",
        transaction_version,
        ledger_info.version(),
    );

    let transaction_info_hash = transaction_info.hash();
    ledger_info_to_transaction_info_proof.verify(
        ledger_info.transaction_accumulator_hash(),
        transaction_info_hash,
        transaction_version,
    )?;

    Ok(())
}
```

**File:** storage/backup/backup-cli/src/coordinators/restore.rs (L219-231)
```rust
        let epoch_history = if !self.skip_epoch_endings {
            Some(Arc::new(
                EpochHistoryRestoreController::new(
                    epoch_handles,
                    self.global_opt.clone(),
                    self.storage.clone(),
                )
                .run()
                .await?,
            ))
        } else {
            None
        };
```

**File:** storage/backup/backup-cli/src/utils/mod.rs (L341-343)
```rust
        N.B. LedgerInfos are verified only when restoring / verifying the epoch ending backups, \
        i.e. they are NOT checked at all when doing one-shot restoring of the transaction \
        and state backups."
```
