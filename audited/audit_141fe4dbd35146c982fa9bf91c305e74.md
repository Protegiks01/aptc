# Audit Report

## Title
Validator DoS via Zero-Gas Prologue Execution When StateView Fails to Load Gas Schedules

## Summary
When StateView returns None for gas schedule configurations, the VM environment falls back to zero gas parameters for native functions while still attempting to execute transaction prologue code. This allows expensive cryptographic operations (Ed25519 signature verification, ECDSA recovery, etc.) to execute without gas charges during account abstraction authentication before the transaction is ultimately discarded. While validators eventually halt transaction processing via a later gas parameters check, the window of zero-gas execution creates a DoS attack surface if StateView corruption can be induced.

## Finding Description

The vulnerability exists in the gas parameter initialization flow: [1](#0-0) 

When `GasScheduleV2` and `GasSchedule` both return None from StateView, the system returns an error but this occurs AFTER attempting initialization. [2](#0-1) 

The critical flaw: when gas_params is Err, the code falls back to `NativeGasParameters::zeros()` and `MiscGasParameters::zeros()` which are embedded into the RuntimeEnvironment via SafeNativeBuilder. These zero parameters mean all native operations cost 0 gas. [3](#0-2) 

During transaction execution, the prologue runs BEFORE the gas parameter error check: [4](#0-3) 

Account abstraction authentication in the prologue calls expensive native functions: [5](#0-4) 

These authentication functions invoke cryptographic natives like Ed25519 signature verification: [6](#0-5) 

With zero gas parameters, all the `context.charge()` calls at lines 108, 110, 119, and 132 charge 0 gas, allowing expensive cryptographic operations to execute for free.

Only after prologue execution does the gas_params check fail: [7](#0-6) 

The transaction is then discarded: [8](#0-7) 

## Impact Explanation

**High Severity** - Validator node slowdowns (up to $50,000)

This breaks invariant #9: "All operations must respect gas, storage, and computational limits."

While StateView corruption is required as a precondition, once it occurs, attackers can:
1. Submit account abstraction transactions with complex authentication functions
2. Force validators to execute expensive cryptographic operations (Ed25519 verify, ECDSA recovery, hash computations) during prologue
3. These operations consume CPU cycles but charge 0 gas
4. The validator must process these for every transaction before discarding them
5. This creates a CPU exhaustion DoS vector

The impact is amplified because:
- Account abstraction allows arbitrary authentication logic
- Native crypto operations are computationally expensive (signature verification)
- The prologue executes for EVERY transaction submitted
- No gas payment is required since transactions are discarded

## Likelihood Explanation

**Medium-Low Likelihood**

The vulnerability requires StateView to fail loading gas schedules while still functioning for other state reads. This could occur through:
- Partial database corruption affecting only on-chain config storage
- Storage implementation bugs causing selective read failures  
- Race conditions during epoch transitions or upgrades
- Malicious validator software modifications

While not easily triggered by external attackers, the consequences are severe enough to warrant fixing. The code comment at line 241-245 explicitly acknowledges this is a known TODO item that needs cleanup. [9](#0-8) 

## Recommendation

The system should HALT immediately when gas parameters cannot be loaded, rather than continuing with dangerous zero defaults:

```rust
let (gas_params, storage_gas_params, gas_feature_version) =
    get_gas_parameters(&mut sha3_256, &features, state_view);

// FAIL FAST - do not continue with zero gas parameters
let native_gas_params = gas_params
    .as_ref()
    .map(|gp| gp.natives.clone())
    .map_err(|e| panic!("FATAL: Cannot initialize VM without gas parameters: {}", e))?;

let misc_gas_params = gas_params
    .as_ref()
    .map(|gp| gp.vm.misc.clone())
    .map_err(|e| panic!("FATAL: Cannot initialize VM without gas parameters: {}", e))?;

let ty_builder = aptos_prod_ty_builder(gas_feature_version, gas_params.as_ref().unwrap());
```

Alternatively, refuse to create the Environment entirely if gas parameters cannot be loaded, forcing the validator to halt rather than process transactions with incorrect gas accounting.

## Proof of Concept

```rust
#[test]
fn test_zero_gas_prologue_execution() {
    use aptos_types::state_store::MockStateView;
    use aptos_move_vm_environment::AptosEnvironment;
    
    // Create StateView that returns None for all on-chain configs
    let broken_state_view = MockStateView::empty();
    
    // Create environment - will use zero gas parameters
    let env = AptosEnvironment::new(&broken_state_view);
    
    // Verify gas_params returns error
    assert!(env.gas_params().is_err());
    
    // However, the RuntimeEnvironment was created with zeros
    // Native functions will charge 0 gas during prologue execution
    // before the gas_params check fails
    
    // An attacker can submit account abstraction transactions
    // that execute expensive Ed25519 signature verifications
    // during prologue with 0 gas cost before being discarded
}
```

## Notes

While the transaction is ultimately discarded and state changes are not committed, the CPU resources consumed during prologue execution with zero gas are not recoverable. This violates the fundamental security principle that all computational work must be properly metered and paid for. The vulnerability is particularly concerning for account abstraction where custom authentication logic can invoke arbitrary native function calls.

### Citations

**File:** aptos-move/aptos-vm-environment/src/gas.rs (L23-46)
```rust
fn get_gas_config_from_storage(
    sha3_256: &mut Sha3_256,
    state_view: &impl StateView,
) -> (Result<AptosGasParameters, String>, u64) {
    match GasScheduleV2::fetch_config_and_bytes(state_view) {
        Some((gas_schedule, bytes)) => {
            sha3_256.update(&bytes);
            let feature_version = gas_schedule.feature_version;
            let map = gas_schedule.into_btree_map();
            (
                AptosGasParameters::from_on_chain_gas_schedule(&map, feature_version),
                feature_version,
            )
        },
        None => match GasSchedule::fetch_config_and_bytes(state_view) {
            Some((gas_schedule, bytes)) => {
                sha3_256.update(&bytes);
                let map = gas_schedule.into_btree_map();
                (AptosGasParameters::from_on_chain_gas_schedule(&map, 0), 0)
            },
            None => (Err("Neither gas schedule v2 nor v1 exists.".to_string()), 0),
        },
    }
}
```

**File:** aptos-move/aptos-vm-environment/src/environment.rs (L241-245)
```rust
        // TODO(Gas):
        //   Right now, we have to use some dummy values for gas parameters if they are not found
        //   on-chain. This only happens in a edge case that is probably related to write set
        //   transactions or genesis, which logically speaking, shouldn't be handled by the VM at
        //   all. We should clean up the logic here once we get that refactored.
```

**File:** aptos-move/aptos-vm-environment/src/environment.rs (L246-265)
```rust
        let (gas_params, storage_gas_params, gas_feature_version) =
            get_gas_parameters(&mut sha3_256, &features, state_view);
        let (native_gas_params, misc_gas_params, ty_builder) = match &gas_params {
            Ok(gas_params) => {
                let ty_builder = aptos_prod_ty_builder(gas_feature_version, gas_params);
                (
                    gas_params.natives.clone(),
                    gas_params.vm.misc.clone(),
                    ty_builder,
                )
            },
            Err(_) => {
                let ty_builder = aptos_default_ty_builder();
                (
                    NativeGasParameters::zeros(),
                    MiscGasParameters::zeros(),
                    ty_builder,
                )
            },
        };
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/mod.rs (L181-188)
```rust
impl NativeGasParameters {
    pub fn zeros() -> Self {
        Self {
            move_stdlib: MoveStdlibGasParameters::zeros(),
            table: TableGasParameters::zeros(),
            aptos_framework: AptosFrameworkGasParameters::zeros(),
        }
    }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L176-189)
```rust
macro_rules! unwrap_or_discard {
    ($res:expr) => {
        match $res {
            Ok(s) => s,
            Err(e) => {
                // covers both VMStatus itself and VMError which can convert to VMStatus
                let s: VMStatus = e.into();

                let o = discarded_output(s.status_code());
                return (s, o);
            },
        }
    };
}
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1999-2020)
```rust
        let mut prologue_session = PrologueSession::new(self, &txn_data, resolver);
        let initial_gas = gas_meter.balance();
        let serialized_signers = unwrap_or_discard!(prologue_session.execute(|session| {
            self.validate_signed_transaction(
                session,
                code_storage,
                txn,
                &txn_data,
                log_context,
                is_approved_gov_script,
                &mut traversal_context,
                gas_meter,
            )
        }));

        if self.features().is_account_abstraction_enabled()
            || self.features().is_derivable_account_abstraction_enabled()
        {
            let max_aa_gas = unwrap_or_discard!(self.gas_params(log_context))
                .vm
                .txn
                .max_aa_gas;
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L3400-3424)
```rust
fn dispatchable_authenticate(
    session: &mut SessionExt<impl AptosMoveResolver>,
    gas_meter: &mut impl GasMeter,
    account: AccountAddress,
    function_info: FunctionInfo,
    auth_data: &AbstractAuthenticationData,
    traversal_context: &mut TraversalContext,
    module_storage: &impl ModuleStorage,
) -> VMResult<Vec<u8>> {
    let auth_data = bcs::to_bytes(auth_data).expect("from rust succeeds");
    let mut params = serialize_values(&vec![
        MoveValue::Signer(account),
        function_info.as_move_value(),
    ]);
    params.push(auth_data);
    session
        .execute_function_bypass_visibility(
            &ACCOUNT_ABSTRACTION_MODULE,
            AUTHENTICATE,
            vec![],
            params,
            gas_meter,
            traversal_context,
            module_storage,
        )
```

**File:** aptos-move/framework/src/natives/cryptography/ed25519.rs (L96-135)
```rust
fn native_signature_verify_strict(
    context: &mut SafeNativeContext,
    _ty_args: &[Type],
    mut arguments: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    debug_assert!(_ty_args.is_empty());
    debug_assert!(arguments.len() == 3);

    let msg = safely_pop_arg!(arguments, Vec<u8>);
    let pubkey = safely_pop_arg!(arguments, Vec<u8>);
    let signature = safely_pop_arg!(arguments, Vec<u8>);

    context.charge(ED25519_BASE)?;

    context.charge(ED25519_PER_PUBKEY_DESERIALIZE * NumArgs::one())?;

    let pk = match ed25519::Ed25519PublicKey::try_from(pubkey.as_slice()) {
        Ok(pk) => pk,
        Err(_) => {
            return Ok(smallvec![Value::bool(false)]);
        },
    };

    context.charge(ED25519_PER_SIG_DESERIALIZE * NumArgs::one())?;

    let sig = match ed25519::Ed25519Signature::try_from(signature.as_slice()) {
        Ok(sig) => sig,
        Err(_) => {
            return Ok(smallvec![Value::bool(false)]);
        },
    };

    // NOTE(Gas): hashing the message to the group and a size-2 multi-scalar multiplication
    let hash_then_verify_cost = ED25519_PER_SIG_STRICT_VERIFY * NumArgs::one()
        + ED25519_PER_MSG_HASHING_BASE * NumArgs::one()
        + ED25519_PER_MSG_BYTE_HASHING * NumBytes::new(msg.len() as u64);
    context.charge(hash_then_verify_cost)?;

    let verify_result = sig.verify_arbitrary_msg(msg.as_slice(), &pk).is_ok();
    Ok(smallvec![Value::bool(verify_result)])
```

**File:** aptos-move/aptos-vm/src/errors.rs (L307-309)
```rust
pub(crate) fn discarded_output(status_code: StatusCode) -> VMOutput {
    VMOutput::empty_with_status(TransactionStatus::Discard(status_code))
}
```
