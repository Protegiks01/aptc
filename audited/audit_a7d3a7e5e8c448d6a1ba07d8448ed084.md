# Audit Report

## Title
Filter Bypass via Batch and Transaction Matcher Rule Ordering in Quorum Store Transaction Filtering

## Summary
The `BatchTransactionFilter` allows filter bypass when Batch matchers and Transaction matchers are placed in separate rules with Batch-based Allow rules preceding Transaction-based Deny rules. This occurs because Batch matchers operate at batch granularity (matching all transactions in a batch) while Transaction matchers operate at transaction granularity, and the first-match-wins rule evaluation allows batch-wide Allow rules to bypass transaction-specific Deny rules.

## Finding Description

The vulnerability exists in the rule evaluation logic of `BatchTransactionFilter::allows_transaction()`. [1](#0-0) 

The critical flaw is in how rules are evaluated with first-match-wins semantics. When a `BatchTransactionRule` contains only Batch matchers (e.g., `BatchMatcher::BatchAuthor`), the rule matching logic checks only batch-level properties and ignores transaction-specific properties. [2](#0-1) 

When `BatchTransactionMatcher::matches()` is called with a Batch variant, it only evaluates batch metadata (batch_id, batch_author, batch_digest) and completely ignores the transaction parameter. [3](#0-2) 

**Attack Scenario:**

1. Administrator configures filters with this pattern (common when wanting to trust specific validators):
   - Rule 1: `Allow([Batch(BatchAuthor(TrustedValidator))])`
   - Rule 2: `Deny([Transaction(Sender(MaliciousAddress))])`

2. Administrator's intention:
   - Allow all batches from trusted validators (assuming they run proper filters)
   - Block all transactions from known malicious addresses

3. Actual behavior when a transaction from `MaliciousAddress` appears in a batch from `TrustedValidator`:
   - Rule 1 evaluation: `Batch(BatchAuthor(TrustedValidator))` matches (checks only `batch_author == TrustedValidator`, ignores transaction sender)
   - Rule 1 matches â†’ **ALLOW** and return immediately
   - Rule 2 is **never evaluated**
   - Malicious transaction is accepted

This is used in the consensus quorum store's `BatchCoordinator`, which filters incoming batches from other validators. [4](#0-3) 

**Exploitation:**
1. Malicious sender submits transaction to network mempool
2. `TrustedValidator` (with weaker/no local filter, or misconfiguration) includes the transaction in their batch
3. Other validators receive the batch and apply their filters
4. Due to Rule 1 matching first, they accept the entire batch including the malicious transaction
5. Malicious transaction enters consensus and gets committed to the blockchain

## Impact Explanation

**Medium Severity** - This vulnerability allows filter bypasses that can result in:

1. **Transaction Validation Bypass**: Filters intended to block specific malicious senders, entry functions, or transaction types can be completely bypassed if the transactions are included in batches from validators matching Allow rules with Batch matchers.

2. **State Inconsistencies**: If different validators have inconsistent filter configurations (some with this vulnerable pattern, some without), they may accept different sets of transactions, potentially causing state divergence or requiring manual intervention.

3. **Consensus Impact**: While not directly breaking consensus safety, this can allow unwanted transactions to enter the consensus pipeline and be committed to blocks, violating the intended security policy.

4. **Limited Scope**: The impact is limited to Medium severity because:
   - It requires specific filter misconfiguration
   - Does not directly cause fund loss or consensus safety violations
   - Requires at least one validator to include the malicious transaction in their batch
   - Does not affect cryptographic security or protocol correctness

This aligns with the **Medium Severity** category: "State inconsistencies requiring intervention" and represents a significant protocol violation in transaction filtering.

## Likelihood Explanation

**Medium-High Likelihood:**

1. **Common Configuration Pattern**: The vulnerable pattern is intuitive and likely to be configured:
   - Administrators naturally want to trust batches from specific validators
   - They also want to block known malicious addresses
   - The API makes it easy to add these rules separately via `add_batch_author_filter()` and `add_sender_filter()`

2. **No Warning or Validation**: The code provides no warnings about this semantic mismatch. [5](#0-4) 

3. **No Test Coverage**: There are no tests covering the interaction between Batch and Transaction matchers in separate rules, indicating this edge case was not considered during development. [6](#0-5) 

4. **Unprivileged Exploitation**: The attacker only needs to:
   - Submit a transaction to the network (standard user capability)
   - Wait for any validator to include it in a batch (natural network behavior)
   - No special access or collusion required

## Recommendation

**Fix 1: Add validation to prevent problematic rule orderings**

Add a validation function that warns or rejects configurations where Batch-only Allow rules precede Transaction-specific Deny rules:

```rust
impl BatchTransactionFilter {
    pub fn validate_rules(&self) -> Result<(), String> {
        let mut seen_batch_allow = false;
        for rule in &self.batch_transaction_rules {
            match rule {
                BatchTransactionRule::Allow(matchers) if matchers.iter().all(|m| matches!(m, BatchTransactionMatcher::Batch(_))) => {
                    seen_batch_allow = true;
                },
                BatchTransactionRule::Deny(matchers) if seen_batch_allow && matchers.iter().any(|m| matches!(m, BatchTransactionMatcher::Transaction(_))) => {
                    return Err("Transaction-level Deny rules after Batch-level Allow rules may be bypassed. Consider reordering rules or combining matchers.".to_string());
                },
                _ => {}
            }
        }
        Ok(())
    }
}
```

**Fix 2: Documentation improvement**

Add clear documentation warning about this semantic mismatch in rule ordering.

**Fix 3: Consider alternative semantics**

For more robust behavior, consider evaluating ALL Deny rules before ANY Allow rules, or introducing rule priorities.

## Proof of Concept

```rust
#[cfg(test)]
mod test {
    use super::*;
    use aptos_crypto::{ed25519::Ed25519PrivateKey, HashValue, PrivateKey, SigningKey, Uniform};
    use aptos_types::{
        chain_id::ChainId,
        transaction::{RawTransaction, Script, SignedTransaction, TransactionPayload},
        PeerId,
    };
    use move_core_types::account_address::AccountAddress;

    #[test]
    fn test_batch_transaction_matcher_bypass() {
        // Setup: Create identities
        let trusted_validator = PeerId::random();
        let malicious_sender = AccountAddress::random();
        
        // Setup: Create a transaction from the malicious sender
        let raw_transaction = RawTransaction::new(
            malicious_sender,
            0,
            TransactionPayload::Script(Script::new(vec![], vec![], vec![])),
            0,
            0,
            0,
            ChainId::new(10),
        );
        let private_key = Ed25519PrivateKey::generate_for_testing();
        let signature = private_key.sign(&raw_transaction).unwrap();
        let signed_transaction = SignedTransaction::new(
            raw_transaction,
            private_key.public_key(),
            signature,
        );

        // Setup: Create batch metadata
        let batch_id = BatchId::new_for_test(1);
        let batch_digest = HashValue::random();

        // Vulnerable configuration: Allow trusted validator's batches, then deny malicious sender
        let filter = BatchTransactionFilter::empty()
            .add_batch_author_filter(true, trusted_validator)  // Rule 1: Allow
            .add_sender_filter(false, malicious_sender);        // Rule 2: Deny

        // Attack: Transaction from malicious sender in batch from trusted validator
        let result = filter.allows_transaction(
            batch_id,
            trusted_validator,
            &batch_digest,
            &signed_transaction,
        );

        // Vulnerability: Transaction is ALLOWED despite deny rule
        assert!(result, "BUG: Transaction from malicious sender should be denied but is allowed due to batch author allow rule taking precedence");

        // Correct behavior: If rules are swapped, transaction is correctly denied
        let correct_filter = BatchTransactionFilter::empty()
            .add_sender_filter(false, malicious_sender)        // Rule 1: Deny
            .add_batch_author_filter(true, trusted_validator); // Rule 2: Allow

        let correct_result = correct_filter.allows_transaction(
            batch_id,
            trusted_validator,
            &batch_digest,
            &signed_transaction,
        );

        assert!(!correct_result, "Transaction is correctly denied when deny rule comes first");
    }
}
```

**Notes:**

The vulnerability stems from the semantic mismatch between batch-granularity and transaction-granularity matchers combined with first-match-wins evaluation. While the current behavior is documented, it creates an unintuitive and dangerous configuration pattern that administrators are likely to create. The filter system is used in critical consensus components (quorum store batch coordination), making this a genuine security concern that should be addressed through validation, documentation, and potentially API design changes.

### Citations

**File:** crates/aptos-transaction-filters/src/batch_transaction_filter.rs (L11-20)
```rust
/// A batch transaction filter that applies a set of rules to determine
/// if a transaction in a batch should be allowed or denied.
///
/// Rules are applied in the order they are defined, and the first
/// matching rule determines the outcome for the transaction.
/// If no rules match, the transaction is allowed by default.
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
pub struct BatchTransactionFilter {
    batch_transaction_rules: Vec<BatchTransactionRule>,
}
```

**File:** crates/aptos-transaction-filters/src/batch_transaction_filter.rs (L30-58)
```rust
    pub fn allows_transaction(
        &self,
        batch_id: BatchId,
        batch_author: PeerId,
        batch_digest: &HashValue,
        signed_transaction: &SignedTransaction,
    ) -> bool {
        // If the filter is empty, allow the transaction by default
        if self.is_empty() {
            return true;
        }

        // Check if any rule matches the batch transaction
        for batch_transaction_rule in &self.batch_transaction_rules {
            if batch_transaction_rule.matches(
                batch_id,
                batch_author,
                batch_digest,
                signed_transaction,
            ) {
                return match batch_transaction_rule {
                    BatchTransactionRule::Allow(_) => true,
                    BatchTransactionRule::Deny(_) => false,
                };
            }
        }

        true // No rules match (allow the batch transaction by default)
    }
```

**File:** crates/aptos-transaction-filters/src/batch_transaction_filter.rs (L148-165)
```rust
impl BatchTransactionRule {
    /// Returns true iff the rule matches the given batch transaction. This
    /// requires that all matchers in the rule match the batch transaction.
    pub fn matches(
        &self,
        batch_id: BatchId,
        batch_author: PeerId,
        batch_digest: &HashValue,
        signed_transaction: &SignedTransaction,
    ) -> bool {
        let batch_transaction_matchers = match self {
            BatchTransactionRule::Allow(matchers) => matchers,
            BatchTransactionRule::Deny(matchers) => matchers,
        };
        batch_transaction_matchers.iter().all(|matcher| {
            matcher.matches(batch_id, batch_author, batch_digest, signed_transaction)
        })
    }
```

**File:** crates/aptos-transaction-filters/src/batch_transaction_filter.rs (L175-192)
```rust
impl BatchTransactionMatcher {
    /// Returns true iff the matcher matches the given batch transaction
    pub fn matches(
        &self,
        batch_id: BatchId,
        batch_author: PeerId,
        batch_digest: &HashValue,
        signed_transaction: &SignedTransaction,
    ) -> bool {
        match self {
            BatchTransactionMatcher::Batch(batch_matcher) => {
                batch_matcher.matches(batch_id, batch_author, batch_digest)
            },
            BatchTransactionMatcher::Transaction(transaction_matcher) => {
                transaction_matcher.matches(signed_transaction)
            },
        }
    }
```

**File:** crates/aptos-transaction-filters/src/batch_transaction_filter.rs (L236-299)
```rust
mod test {
    use super::*;

    #[test]
    fn test_matches_batch_id() {
        // Create a batch ID
        let batch_id = BatchId::new_for_test(1000);

        // Verify that the batch ID matches itself
        verify_matches_batch_id(batch_id, &batch_id, true);

        // Verify that a different batch ID does not match
        let different_batch_id = BatchId::new_for_test(122);
        verify_matches_batch_id(batch_id, &different_batch_id, false);
    }

    #[test]
    fn test_matches_batch_author() {
        // Create a batch author
        let batch_author = PeerId::random();

        // Verify that the batch author matches itself
        verify_matches_batch_author(batch_author, &batch_author, true);

        // Verify that a different batch author does not match
        let different_batch_author = PeerId::random();
        verify_matches_batch_author(batch_author, &different_batch_author, false);
    }

    #[test]
    fn test_matches_batch_digest() {
        // Create a batch digest
        let batch_digest = HashValue::random();

        // Verify that the batch digest matches itself
        verify_matches_batch_digest(&batch_digest, &batch_digest, true);

        // Verify that a different batch digest does not match
        let different_batch_digest = HashValue::random();
        verify_matches_batch_digest(&batch_digest, &different_batch_digest, false);
    }

    /// Verifies that the batch ID matches the target batch ID
    fn verify_matches_batch_id(batch_id: BatchId, target_batch_id: &BatchId, matches: bool) {
        let result = matches_batch_id(batch_id, target_batch_id);
        assert_eq!(matches, result);
    }

    /// Verifies that the batch author matches the target author
    fn verify_matches_batch_author(batch_author: PeerId, target_author: &PeerId, matches: bool) {
        let result = matches_batch_author(batch_author, target_author);
        assert_eq!(matches, result);
    }

    /// Verifies that the batch digest matches the target digest
    fn verify_matches_batch_digest(
        batch_digest: &HashValue,
        target_digest: &HashValue,
        matches: bool,
    ) {
        let result = matches_batch_digest(batch_digest, target_digest);
        assert_eq!(matches, result);
    }
}
```

**File:** consensus/src/quorum_store/batch_coordinator.rs (L191-213)
```rust
        if self.transaction_filter_config.is_enabled() {
            let transaction_filter = &self.transaction_filter_config.batch_transaction_filter();
            for batch in batches.iter() {
                for transaction in batch.txns() {
                    if !transaction_filter.allows_transaction(
                        batch.batch_info().batch_id(),
                        batch.author(),
                        batch.digest(),
                        transaction,
                    ) {
                        error!(
                            "Transaction {}, in batch {}, from {}, was rejected by the filter. Dropping {} batches!",
                            transaction.committed_hash(),
                            batch.batch_info().batch_id(),
                            author.short_str().as_str(),
                            batches.len()
                        );
                        counters::RECEIVED_BATCH_REJECTED_BY_FILTER.inc();
                        return;
                    }
                }
            }
        }
```
