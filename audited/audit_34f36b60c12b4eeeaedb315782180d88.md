# Audit Report

## Title
View Function Visibility Bypass Allows Unauthorized Access to Private Module Functions

## Summary
The view function execution path does not validate function visibility, allowing external callers to invoke private or friend view functions via the REST API, bypassing Move's access control model.

## Finding Description

The `validate_view_function()` in [1](#0-0)  performs the following checks when a view function is invoked:

1. Verifies the function is marked with the `#[view]` attribute
2. Confirms the function returns values  
3. Validates argument construction

However, it does **not** check the function's visibility modifier (public, private, or friend). The execution flow in [2](#0-1)  loads and executes the function without visibility validation.

Move's visibility model is designed to restrict function access:
- **Private functions**: Only callable within the same module
- **Friend functions**: Only callable by declared friend modules  
- **Public functions**: Callable by anyone

The test suite confirms that private view functions are allowed at compile time. In [3](#0-2) , a private view function (without the `public` keyword) successfully compiles and deploys.

While `LoadedFunction` provides visibility checking methods [4](#0-3) , these are only used for cross-module call validation during execution, not for the initial view function invocation.

**Attack Scenario:**
A module developer creates a private view function intended only for internal helper logic or to be called by the module's public API with access controls:

```move
module 0x42::sensitive {
    struct InternalState has key { secret: u64 }
    
    // Private helper - developer expects this is internal only
    #[view]
    fun get_internal_secret(addr: address): u64 acquires InternalState {
        borrow_global<InternalState>(addr).secret
    }
    
    // Public API with access control
    public fun get_secret_authorized(caller: &signer, addr: address): u64 
        acquires InternalState {
        // ... access control logic ...
        get_internal_secret(addr)
    }
}
```

An attacker directly calls the private view function via the REST API:
```json
POST /v1/view
{
  "function": "0x42::sensitive::get_internal_secret",
  "arguments": ["0x123"],
  "type_arguments": []
}
```

The API successfully executes the private function, bypassing the intended access control in `get_secret_authorized`.

## Impact Explanation

**Severity: Medium**

This violates Move's access control model and the principle of least privilege. While blockchain state is inherently readable by full node operators, the view API is a public-facing interface that module developers may reasonably expect to respect visibility modifiers.

The impact includes:
- **Information Disclosure**: Exposure of internal module state through private helper functions
- **Access Control Violation**: Bypasses developer-intended restrictions on function access
- **Security Model Inconsistency**: View functions behave differently than normal function calls regarding visibility

This qualifies as a "Significant protocol violation" under High severity criteria, though the actual security impact depends on whether Aptos framework or third-party modules contain private view functions that expose sensitive information.

## Likelihood Explanation

**Likelihood: High**

- Trivial to exploit - requires only a REST API call
- No authentication or special privileges required  
- Affects any module with private or friend view functions
- Easy to discover through API exploration or code inspection

The main limiting factor is whether exploitable private view functions exist in deployed modules. However, the capability to bypass visibility is inherent to the implementation.

## Recommendation

Add visibility validation in `validate_view_function()`:

```rust
pub(crate) fn validate_view_function(
    session: &mut SessionExt<impl AptosMoveResolver>,
    loader: &impl Loader,
    gas_meter: &mut impl GasMeter,
    traversal_context: &mut TraversalContext,
    args: Vec<Vec<u8>>,
    fun_name: &IdentStr,
    func: &LoadedFunction,
    module_metadata: Option<&RuntimeModuleMetadataV1>,
    struct_constructors_feature: bool,
) -> PartialVMResult<Vec<Vec<u8>>> {
    // Existing checks...
    let is_view = determine_is_view(module_metadata, fun_name);
    if !is_view {
        return Err(
            PartialVMError::new(StatusCode::INVALID_MAIN_FUNCTION_SIGNATURE)
                .with_message("function not marked as view function".to_string()),
        );
    }

    // ADD THIS CHECK:
    if !func.is_public() {
        return Err(
            PartialVMError::new(StatusCode::INVALID_MAIN_FUNCTION_SIGNATURE)
                .with_message("view function must have public visibility".to_string()),
        );
    }

    // Continue with existing validation...
}
```

Alternatively, document this behavior clearly if it's intentional, and add compile-time warnings for non-public view functions in [5](#0-4) .

## Proof of Concept

**Step 1: Create a Move module with a private view function**

```move
module 0xCAFE::test {
    struct Secret has key { value: u64 }
    
    // Private view function
    #[view]
    fun private_view(addr: address): u64 acquires Secret {
        borrow_global<Secret>(addr).value
    }
    
    public fun init(account: &signer) {
        move_to(account, Secret { value: 42 });
    }
}
```

**Step 2: Deploy the module to a test network**

**Step 3: Call the private view function via REST API**

```bash
curl -X POST https://fullnode.testnet.aptoslabs.com/v1/view \
  -H "Content-Type: application/json" \
  -d '{
    "function": "0xCAFE::test::private_view",
    "arguments": ["0xCAFE"],
    "type_arguments": []
  }'
```

**Expected Result (Current Behavior)**: The API executes the private function and returns the secret value.

**Expected Result (After Fix)**: The API returns an error indicating the function must have public visibility.

## Notes

The vulnerability is confirmed by examining the validation code path which lacks visibility checks, combined with test evidence that private view functions compile successfully. The actual security impact depends on whether deployed modules rely on visibility restrictions for access control of view functions.

### Citations

**File:** aptos-move/aptos-vm/src/verifier/view_function.rs (L35-92)
```rust
pub(crate) fn validate_view_function(
    session: &mut SessionExt<impl AptosMoveResolver>,
    loader: &impl Loader,
    gas_meter: &mut impl GasMeter,
    traversal_context: &mut TraversalContext,
    args: Vec<Vec<u8>>,
    fun_name: &IdentStr,
    func: &LoadedFunction,
    module_metadata: Option<&RuntimeModuleMetadataV1>,
    struct_constructors_feature: bool,
) -> PartialVMResult<Vec<Vec<u8>>> {
    // Must be marked as view function.
    let is_view = determine_is_view(module_metadata, fun_name);
    if !is_view {
        return Err(
            PartialVMError::new(StatusCode::INVALID_MAIN_FUNCTION_SIGNATURE)
                .with_message("function not marked as view function".to_string()),
        );
    }

    // Must return values.
    if func.return_tys().is_empty() {
        return Err(
            PartialVMError::new(StatusCode::INVALID_MAIN_FUNCTION_SIGNATURE)
                .with_message("view function must return values".to_string()),
        );
    }

    let allowed_structs = get_allowed_structs(struct_constructors_feature);
    let result = if loader.is_lazy_loading_enabled() {
        transaction_arg_validation::construct_args(
            session,
            loader,
            gas_meter,
            traversal_context,
            func.param_tys(),
            args,
            func.ty_args(),
            allowed_structs,
            true,
        )
    } else {
        let traversal_storage = TraversalStorage::new();
        transaction_arg_validation::construct_args(
            session,
            loader,
            // No metering with eager loading.
            &mut UnmeteredGasMeter,
            &mut TraversalContext::new(&traversal_storage),
            func.param_tys(),
            args,
            func.ty_args(),
            allowed_structs,
            true,
        )
    };
    result.map_err(|e| PartialVMError::new(e.status_code()))
}
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L2739-2791)
```rust
    fn execute_view_function_in_vm(
        session: &mut SessionExt<impl AptosMoveResolver>,
        vm: &AptosVM,
        module_id: ModuleId,
        func_name: Identifier,
        ty_args: Vec<TypeTag>,
        arguments: Vec<Vec<u8>>,
        gas_meter: &mut impl AptosGasMeter,
        traversal_context: &mut TraversalContext,
        module_storage: &impl AptosModuleStorage,
    ) -> Result<Vec<Vec<u8>>, VMError> {
        dispatch_loader!(module_storage, loader, {
            let func = loader.load_instantiated_function(
                &LegacyLoaderConfig::unmetered(),
                gas_meter,
                traversal_context,
                &module_id,
                &func_name,
                &ty_args,
            )?;

            let metadata = get_metadata(&func.owner_as_module()?.metadata);

            let arguments = view_function::validate_view_function(
                session,
                &loader,
                gas_meter,
                traversal_context,
                arguments,
                func_name.as_ident_str(),
                &func,
                metadata.as_ref().map(Arc::as_ref),
                vm.features().is_enabled(FeatureFlag::STRUCT_CONSTRUCTORS),
            )
            .map_err(|e| e.finish(Location::Module(module_id)))?;

            let result = session.execute_loaded_function(
                func,
                arguments,
                gas_meter,
                traversal_context,
                &loader,
                // No need to record any traces for view functions.
                &mut NoOpTraceRecorder,
            )?;

            Ok(result
                .return_values
                .into_iter()
                .map(|(bytes, _ty)| bytes)
                .collect::<Vec<_>>())
        })
    }
```

**File:** aptos-move/e2e-move-tests/src/tests/attributes.rs (L18-35)
```rust
#[test]
fn test_view_attribute() {
    let mut h = MoveHarness::new();
    let account = h.new_account_at(AccountAddress::from_hex_literal("0xf00d").unwrap());

    let mut builder = PackageBuilder::new("Package");
    builder.add_source(
        "m.move",
        r#"
        module 0xf00d::M {
            #[view]
            fun view(value: u64): u64 { value }
        }
        "#,
    );
    let path = builder.write_to_temp().unwrap();
    assert_success!(h.publish_package(&account, path.path()));
}
```

**File:** third_party/move/move-vm/runtime/src/loader/function.rs (L756-766)
```rust
    pub fn is_public(&self) -> bool {
        matches!(self.visibility, Visibility::Public)
    }

    pub fn is_friend(&self) -> bool {
        matches!(self.visibility, Visibility::Friend)
    }

    pub fn is_private(&self) -> bool {
        matches!(self.visibility, Visibility::Private)
    }
```

**File:** aptos-move/framework/src/extended_checks.rs (L689-741)
```rust
    fn check_and_record_view_functions(&mut self, module: &ModuleEnv) {
        for ref fun in module.get_functions() {
            if !self.has_attribute(fun, VIEW_FUN_ATTRIBUTE) {
                continue;
            }
            self.check_transaction_args(&fun.get_parameters());
            if fun.get_return_count() == 0 {
                self.env
                    .error(&fun.get_id_loc(), "`#[view]` function must return values")
            }

            fun.get_parameters()
                .iter()
                .for_each(
                    |Parameter(_sym, parameter_type, param_loc)| match parameter_type {
                        Type::Primitive(inner) => {
                            if inner == &PrimitiveType::Signer {
                                self.env.error(
                                    param_loc,
                                    "`#[view]` function cannot use a `signer` parameter",
                                )
                            }
                        },
                        Type::Reference(mutability, inner) => {
                            if let Type::Primitive(inner) = inner.as_ref() {
                                if inner == &PrimitiveType::Signer
                                // Avoid a redundant error message for `&mut signer`, which is
                                // always disallowed for transaction entries, not just for
                                // `#[view]`.
                                    && mutability == &ReferenceKind::Immutable
                                {
                                    self.env.error(
                                        param_loc,
                                        "`#[view]` function cannot use the `&signer` parameter",
                                    )
                                }
                            }
                        },
                        _ => (),
                    },
                );

            // Remember the runtime info that this is a view function
            let module_id = self.get_runtime_module_id(module);
            self.output
                .entry(module_id)
                .or_default()
                .fun_attributes
                .entry(fun.get_simple_name_string().to_string())
                .or_default()
                .push(KnownAttribute::view_function());
        }
    }
```
