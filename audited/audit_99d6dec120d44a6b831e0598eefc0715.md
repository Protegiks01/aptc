# Audit Report

## Title
Module-Only Write Transactions Bypass Block Gas Limit Conflict Detection

## Summary
Transactions that only write modules (publish/upgrade Move modules) completely bypass the conflict detection mechanism used by `BlockGasLimitProcessor` for computing conflict multipliers and enforcing block gas limits. This occurs because the `get_write_summary()` method omits module writes from the returned write set, allowing module-publishing transactions to evade proper gas accounting.

## Finding Description

The `BeforeMaterializationGuard::get_write_summary()` method is responsible for collecting all writes that should be tracked for conflict detection in parallel execution. This write summary is used by `BlockGasLimitProcessor::compute_conflict_multiplier()` to detect read-write conflicts between transactions and apply gas penalties. [1](#0-0) 

The method iterates over `resource_write_set()` and `delayed_field_change_set()`, but completely ignores `module_write_set()`. Module writes are accessible via the `module_write_set()` method, but are never added to the write summary: [2](#0-1) 

The `InputOutputKey` enum used for tracking writes only supports three variants: `Resource`, `Group`, and `DelayedField` - there is no variant for module writes: [3](#0-2) 

This write summary is critical for block gas limit enforcement. The `BlockGasLimitProcessor` uses it to compute conflict multipliers that increase effective block gas: [4](#0-3) 

The conflict detection checks if current transaction's reads intersect with previous transaction's writes: [5](#0-4) 

Critically, while module writes are omitted, module reads ARE included in read summaries: [6](#0-5) 

**Exploitation Path:**

1. An attacker submits multiple transactions that only publish or upgrade Move modules (no resource writes)
2. These transactions have write summaries without module writes since `get_write_summary()` omits them
3. Subsequent transactions that read these modules won't trigger conflict detection in the gas limit processor
4. The conflict multiplier remains artificially low, not accounting for module-related conflicts
5. This allows more transactions to fit in a block than intended, potentially exceeding resource limits

The on-chain configuration includes a `use_module_publishing_block_conflict` flag intended to address this, but it is explicitly marked as "NOTE: Currently not supported": [7](#0-6) 

The configuration accessor method exists but no code actually uses it to add module writes to conflict detection: [8](#0-7) 

While module correctness is maintained through separate validation mechanisms, the gas accounting bypass violates the resource limit invariant.

## Impact Explanation

This vulnerability breaks **Invariant #9: Resource Limits** - "All operations must respect gas, storage, and computational limits."

The impact qualifies as **Medium Severity** per Aptos bug bounty criteria:
- **State inconsistencies requiring intervention**: Blocks can accept more transactions than the conflict-aware gas limits should allow
- **Limited resource manipulation**: The gas accounting bypass allows circumventing proper block resource controls

The issue does NOT reach High or Critical severity because:
- Transaction correctness is preserved (module validation still occurs separately)
- No consensus split occurs (all validators compute the same incorrect gas values deterministically)
- No direct funds loss or safety violation
- Module publishing is relatively infrequent compared to regular transactions

However, exploitation could cause:
- Resource exhaustion on validator nodes from oversized blocks
- Performance degradation from excessive module publishing
- Unfair transaction ordering advantages for module publishers

## Likelihood Explanation

Likelihood is **Medium** because:

**Ease of Exploitation:**
- Any user can publish Move modules (no special privileges required)
- Attack requires only submitting module publishing transactions
- No coordination with validators needed
- The bypass is deterministic and affects all validators equally

**Limiting Factors:**
- Module publishing has separate gas costs that still apply
- Module publishing is less common than resource operations
- Other block limits (output size, total gas) still enforce some constraints
- The separate module validation system prevents correctness issues

The vulnerability is consistently exploitable - any block with module-only write transactions will bypass conflict detection for gas limit purposes.

## Recommendation

Add a `Module` variant to the `InputOutputKey` enum and update `get_write_summary()` to include module writes:

1. Update `InputOutputKey` enum in `aptos-move/block-executor/src/types.rs`:
```rust
pub enum InputOutputKey<K, T> {
    Resource(K),
    Group(K, T),
    DelayedField(DelayedFieldID),
    Module(K),  // Add this variant
}
```

2. Update `get_write_summary()` in `aptos-move/aptos-vm/src/block_executor/mod.rs` to include module writes:
```rust
fn get_write_summary(&self) -> HashSet<InputOutputKey<StateKey, StructTag>> {
    let mut writes = HashSet::new();
    
    // Existing resource/group/delayed field logic...
    
    // Add module writes
    for (state_key, _module_write) in self.guard.module_write_set() {
        writes.insert(InputOutputKey::Module(state_key.clone()));
    }
    
    writes
}
```

3. Implement the `use_module_publishing_block_conflict` configuration flag to conditionally enable this behavior.

4. Update `collapse_resource_group_conflicts()` and other methods to handle the new `Module` variant.

## Proof of Concept

A PoC would involve:
1. Creating multiple transactions that publish Move modules
2. Creating subsequent transactions that read those modules
3. Observing that the conflict multiplier does not increase despite the read-write conflicts
4. Demonstrating that more transactions fit in a block than would be allowed if module conflicts were properly tracked

The vulnerability is evident from code inspection - the `get_write_summary()` method demonstrably omits module writes while `get_read_summary()` includes module reads, creating an asymmetry in conflict detection.

## Notes

This is a valid security vulnerability representing an unimplemented feature that has security implications. The presence of the `use_module_publishing_block_conflict` configuration flag marked as "Currently not supported" indicates this was a known limitation that the developers intended to address but has not been implemented. The gap between module read tracking (implemented) and module write tracking (not implemented) creates an exploitable bypass of block gas limit enforcement mechanisms.

### Citations

**File:** aptos-move/aptos-vm/src/block_executor/mod.rs (L140-168)
```rust
    fn get_write_summary(&self) -> HashSet<InputOutputKey<StateKey, StructTag>> {
        let mut writes = HashSet::new();

        for (state_key, write) in self.guard.resource_write_set() {
            match write {
                AbstractResourceWriteOp::Write(_)
                | AbstractResourceWriteOp::WriteWithDelayedFields(_) => {
                    writes.insert(InputOutputKey::Resource(state_key.clone()));
                },
                AbstractResourceWriteOp::WriteResourceGroup(write) => {
                    for tag in write.inner_ops().keys() {
                        writes.insert(InputOutputKey::Group(state_key.clone(), tag.clone()));
                    }
                },
                AbstractResourceWriteOp::InPlaceDelayedFieldChange(_)
                | AbstractResourceWriteOp::ResourceGroupInPlaceDelayedFieldChange(_) => {
                    // No conflicts on resources from in-place delayed field changes.
                    // Delayed fields conflicts themselves are handled via
                    // delayed_field_change_set below.
                },
            }
        }

        for identifier in self.guard.delayed_field_change_set().keys() {
            writes.insert(InputOutputKey::DelayedField(*identifier));
        }

        writes
    }
```

**File:** aptos-move/aptos-vm/src/block_executor/mod.rs (L288-290)
```rust
    fn module_write_set(&self) -> &BTreeMap<StateKey, ModuleWrite<WriteOp>> {
        self.guard.module_write_set()
    }
```

**File:** aptos-move/block-executor/src/types.rs (L11-16)
```rust
#[derive(Eq, Hash, PartialEq, Debug)]
pub enum InputOutputKey<K, T> {
    Resource(K),
    Group(K, T),
    DelayedField(DelayedFieldID),
}
```

**File:** aptos-move/block-executor/src/types.rs (L31-33)
```rust
    pub fn conflicts_with_previous(&self, previous: &Self) -> bool {
        !self.reads.is_disjoint(&previous.writes)
    }
```

**File:** aptos-move/block-executor/src/limit_processor.rs (L175-203)
```rust
    fn compute_conflict_multiplier(&self, conflict_overlap_length: usize) -> u64 {
        let start = self
            .txn_read_write_summaries
            .len()
            .saturating_sub(conflict_overlap_length);
        let end = self.txn_read_write_summaries.len() - 1;

        let mut conflict_count = 0;
        let current = &self.txn_read_write_summaries[end];
        for prev in &self.txn_read_write_summaries[start..end] {
            if current.conflicts_with_previous(prev) {
                if self.print_conflicts_info {
                    println!(
                        "Conflicts with previous: {:?}",
                        current.find_conflicts(prev)
                    );
                }
                conflict_count += 1;
            }
        }
        if self.print_conflicts_info {
            println!(
                "Number of conflicts: {} out of {}",
                conflict_count, conflict_overlap_length
            );
        }
        assert_le!(conflict_count + 1, conflict_overlap_length);
        (conflict_count + 1) as u64
    }
```

**File:** aptos-move/block-executor/src/captured_reads.rs (L1222-1225)
```rust
        for key in self.module_reads.keys() {
            let key = T::Key::from_address_and_module_name(key.address(), key.name());
            ret.insert(InputOutputKey::Resource(key));
        }
```

**File:** types/src/on_chain_config/execution_config.rs (L296-300)
```rust
        /// Module publishing today fallbacks to sequential execution,
        /// even though there is no read-write conflict.
        /// When enabled, this flag allows us to account for that conflict.
        /// NOTE: Currently not supported.
        use_module_publishing_block_conflict: bool,
```

**File:** types/src/on_chain_config/execution_config.rs (L376-384)
```rust
    pub fn use_module_publishing_block_conflict(&self) -> bool {
        match self {
            BlockGasLimitType::NoLimit => false,
            BlockGasLimitType::Limit(_) => false,
            BlockGasLimitType::ComplexLimitV1 {
                use_module_publishing_block_conflict,
                ..
            } => *use_module_publishing_block_conflict,
        }
```
