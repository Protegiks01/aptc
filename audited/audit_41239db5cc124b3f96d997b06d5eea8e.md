# Audit Report

## Title
Compiler Panic Due to Missing Lower Bound Validation in BigInt to u64 Conversions

## Summary
The Move compiler v2's test plan builder contains insufficient validation when converting `BigInt` values to `u64` in test attributes. While upper bounds are checked, negative values are not rejected, causing a compiler panic when `to_u64().unwrap()` is called on negative `BigInt` values.

## Finding Description
The `plan_builder.rs` file processes test attributes including abort codes and status codes, converting `BigInt` values to `u64`. The conversion logic only validates the upper bound: [1](#0-0) [2](#0-1) [3](#0-2) 

The check `u <= BigInt::from(u64::MAX)` passes for negative values (since any negative number is less than `u64::MAX`), but `BigInt::to_u64()` returns `None` for negative numbers, causing `.unwrap()` to panic.

Move allows negative number literals in attributes through the `InferredNegNum` variant: [4](#0-3) 

An attacker can write a test file with a negative abort code like `#[expected_failure(abort_code=-1)]`, which gets parsed as `InferredNegNum`, converted to a negative `BigInt`, and eventually triggers the panic during test plan construction.

## Impact Explanation
This is a **Low Severity** issue per Aptos bug bounty criteria. It causes a compiler crash during test code compilation, not a runtime vulnerability. It does NOT affect:
- Consensus safety or blockchain state
- Live validator nodes or network availability  
- Production bytecode execution or gas metering
- On-chain funds, governance, or staking

The impact is limited to a denial-of-service against developers attempting to compile malicious test code.

## Likelihood Explanation
The likelihood is **Low** because:
1. Only affects test compilation, not production code paths
2. Requires a developer to intentionally write malformed test attributes
3. The crash is immediately visible and easily diagnosed
4. Does not propagate to deployed bytecode or runtime execution

## Recommendation
Add lower bound validation before calling `.unwrap()`. Compare with the safer pattern used in `bytecode_generator.rs`: [5](#0-4) 

The fix should check both bounds:
```rust
if u >= &BigInt::zero() && u <= &BigInt::from(u64::MAX) {
    Some((loc, u.to_u64().unwrap()))
} else {
    env.error(&loc, "Value must be a non-negative u64");
    None
}
```

Or use `.unwrap_or_default()` with appropriate error reporting.

## Proof of Concept
Create a Move test file `malicious_test.move`:
```move
module 0x1::TestModule {
    #[test]
    #[expected_failure(abort_code=-1)]
    fun test_negative_abort_code() {
        abort 42
    }
}
```

Compile with Move compiler v2:
```bash
move-compiler-v2 --test malicious_test.move
```

Expected result: Compiler panics with "called `Option::unwrap()` on a `None` value" when processing the negative abort code attribute.

**Note:** While this is a real implementation bug that should be fixed, it does not meet the **Critical/High/Medium** severity threshold required for a security vulnerability report per the validation criteria. It is a compile-time correctness issue, not a runtime security vulnerability affecting consensus, funds, or network operation.

### Citations

**File:** third_party/move/move-compiler-v2/src/plan_builder.rs (L604-605)
```rust
                if u <= BigInt::from(u64::MAX) {
                    return Some((vloc, mod_id, u.to_u64().unwrap()));
```

**File:** third_party/move/move-compiler-v2/src/plan_builder.rs (L618-619)
```rust
                if u <= BigInt::from(u64::MAX) {
                    return Some((vloc, mod_id, u.to_u64().unwrap()));
```

**File:** third_party/move/move-compiler-v2/src/plan_builder.rs (L672-673)
```rust
            if u <= &BigInt::from(u64::MAX) {
                Some((loc, u.to_u64().unwrap()))
```

**File:** third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/translate.rs (L2946-2947)
```rust
        PV::Num(s) if s.starts_with("-") => match parse_i256(&s) {
            Ok(i) => EV::InferredNegNum(i),
```

**File:** third_party/move/move-compiler-v2/src/bytecode_generator.rs (L580-581)
```rust
                Type::Primitive(PrimitiveType::U64) => {
                    Constant::U64(x.to_u64().unwrap_or_default())
```
