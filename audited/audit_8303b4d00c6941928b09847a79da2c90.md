# Audit Report

## Title
Validator Network Topology Disclosure via Unauthenticated Inspection Service Endpoint

## Summary
The Aptos node inspection service exposes a `/peer_information` endpoint that reveals complete validator network topology, including all connected peers, their roles, connection metadata, and trusted validator sets. This endpoint is enabled by default and binds to all network interfaces (0.0.0.0) without authentication, allowing any attacker with network access to port 9101 to build a comprehensive map of validator network topology.

## Finding Description

While the security question focuses on triggering connection events to force logging, investigation reveals a more direct information disclosure vulnerability: the inspection service's peer information endpoint.

The default configuration in `InspectionServiceConfig` sets `expose_peer_information: true`: [1](#0-0) 

The inspection service binds to all network interfaces (`0.0.0.0:9101`) by default: [2](#0-1) 

The `/peer_information` endpoint is accessible via HTTP GET without authentication and returns extensive network topology data when `expose_peer_information` is enabled: [3](#0-2) 

The endpoint exposes:
1. All connected peers with their PeerNetworkIds
2. Connection metadata including addresses, roles, and connection states
3. Complete list of trusted peers (validators) for each network
4. Detailed monitoring metadata and internal client states
5. State sync metadata including priority and regular peers [4](#0-3) [5](#0-4) 

The configuration optimizer only disables this for mainnet validators if explicitly configured, but leaves the default `true` value intact otherwise: [6](#0-5) 

**Attack Path:**
1. Attacker identifies validator nodes in the Aptos network
2. Attacker attempts HTTP GET request to `http://<validator-ip>:9101/peer_information`
3. If port 9101 is accessible (misconfigured firewall or internal network access), the endpoint returns complete topology information
4. Attacker repeats for multiple validators to build comprehensive network map
5. Attacker identifies critical consensus participants, network structure, and potential attack targets

This bypasses any need to trigger connection events or access logs—the topology is directly queryable.

## Impact Explanation

This vulnerability falls under **Medium Severity** per Aptos bug bounty criteria as it represents a significant information disclosure that aids targeted attacks:

- **Information Disclosure**: Complete validator network topology, including which validators connect to which other validators, their roles, addresses, and connection states
- **Attack Surface Expansion**: Enables targeted attacks by identifying critical consensus participants and network bottlenecks
- **Eclipse Attack Facilitation**: Understanding network topology is a prerequisite for eclipse attacks where attackers isolate validators from the honest network
- **Targeted DoS**: Attackers can identify and target the most connected or critical validators

While not directly causing loss of funds or consensus violations, this information disclosure materially weakens the network's security posture by revealing strategic information to adversaries.

## Likelihood Explanation

**Moderate to High Likelihood** depending on operational security:

**Factors Increasing Likelihood:**
- Default configuration enables the vulnerability (`expose_peer_information: true`)
- Service binds to all interfaces (`0.0.0.0`) by default
- No authentication mechanism on the endpoint
- Non-mainnet nodes explicitly have this enabled by the optimizer

**Factors Decreasing Likelihood:**
- Production validators typically deploy with strict firewall rules blocking external access to port 9101
- Requires network-level access to the inspection service port
- Experienced operators may explicitly disable the endpoint in configuration

However, misconfigurations occur, internal network compromises happen, and the default-enabled nature significantly increases risk.

## Recommendation

**Immediate Fixes:**

1. **Change default to disable peer information exposure for all production networks:**

```rust
impl Default for InspectionServiceConfig {
    fn default() -> InspectionServiceConfig {
        InspectionServiceConfig {
            address: "127.0.0.1".to_string(), // Bind to localhost only by default
            port: 9101,
            expose_configuration: false,
            expose_identity_information: false,
            expose_peer_information: false,  // Change default to false
            expose_system_information: false,
        }
    }
}
```

2. **Update the sanitizer to prevent mainnet validators from exposing peer information:** [7](#0-6) 

Add check for `expose_peer_information`:

```rust
// Verify that mainnet validators do not expose peer information
if node_type.is_validator()
    && chain_id.is_mainnet()
    && inspection_service_config.expose_peer_information
{
    return Err(Error::ConfigSanitizerFailed(
        sanitizer_name,
        "Mainnet validators should not expose peer information!".to_string(),
    ));
}
```

3. **Add authentication to inspection service endpoints** exposing sensitive information
4. **Bind to 127.0.0.1 by default** instead of 0.0.0.0
5. **Add clear warnings in documentation** about the security implications of enabling these endpoints

## Proof of Concept

**Exploitation Steps:**

1. Identify validator node (assume IP: 10.0.0.1)
2. Execute HTTP request:
```bash
curl http://10.0.0.1:9101/peer_information
```

3. If port 9101 is accessible and `expose_peer_information: true`, response contains:
```
Peer information summary:
    - Number of peers: 150
    - Registered networks: [Validator, Vfn]
    - Peers and network IDs: [...]

Connection metadata for each peer:
    - Peer: 0xabc123/Validator, connection state: Connected, connection metadata: {"remote_peer_id":"0xabc123","addr":"...","role":"Validator",...}
    ...

Trusted peers (validator set & seeds):
    - Network: Validator
        - Peer: 0xdef456, peer information: {...}
        - Peer: 0x789abc, peer information: {...}
    ...
```

4. Parse response to extract:
   - All validator peer IDs
   - Connection graph (who connects to whom)
   - Network addresses
   - Validator roles and priorities

5. Repeat for multiple accessible validators to build complete topology graph

This PoC demonstrates direct topology disclosure without triggering any connection events or requiring log access.

**Notes**

While the security question specifically asks about triggering connection events to force logging, this audit identifies a more direct and severe vulnerability: the inspection service endpoint that explicitly exposes network topology without requiring any event triggering or log access. The endpoint is enabled by default, requires no authentication, and provides comprehensive topology information that would enable the exact attack scenario described in the security question—mapping validator network topology and identifying critical consensus participants.

The connection event logging mechanism mentioned in the question would only expose topology if an attacker already has log access (local file access or telemetry service access), and even then, connection limits mitigate spam attacks. The inspection service endpoint is the more practical and exploitable vulnerability for achieving topology reconnaissance.

### Citations

**File:** config/src/config/inspection_service_config.rs (L26-36)
```rust
impl Default for InspectionServiceConfig {
    fn default() -> InspectionServiceConfig {
        InspectionServiceConfig {
            address: "0.0.0.0".to_string(),
            port: 9101,
            expose_configuration: false,
            expose_identity_information: true,
            expose_peer_information: true,
            expose_system_information: true,
        }
    }
```

**File:** config/src/config/inspection_service_config.rs (L45-68)
```rust
impl ConfigSanitizer for InspectionServiceConfig {
    fn sanitize(
        node_config: &NodeConfig,
        node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();
        let inspection_service_config = &node_config.inspection_service;

        // Verify that mainnet validators do not expose the configuration
        if let Some(chain_id) = chain_id {
            if node_type.is_validator()
                && chain_id.is_mainnet()
                && inspection_service_config.expose_configuration
            {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "Mainnet validators should not expose the node configuration!".to_string(),
                ));
            }
        }

        Ok(())
    }
```

**File:** config/src/config/inspection_service_config.rs (L71-108)
```rust
impl ConfigOptimizer for InspectionServiceConfig {
    fn optimize(
        node_config: &mut NodeConfig,
        local_config_yaml: &Value,
        _node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<bool, Error> {
        let inspection_service_config = &mut node_config.inspection_service;
        let local_inspection_config_yaml = &local_config_yaml["inspection_service"];

        // Enable all endpoints for non-mainnet nodes (to aid debugging)
        let mut modified_config = false;
        if let Some(chain_id) = chain_id {
            if !chain_id.is_mainnet() {
                if local_inspection_config_yaml["expose_configuration"].is_null() {
                    inspection_service_config.expose_configuration = true;
                    modified_config = true;
                }

                if local_inspection_config_yaml["expose_identity_information"].is_null() {
                    inspection_service_config.expose_identity_information = true;
                    modified_config = true;
                }

                if local_inspection_config_yaml["expose_peer_information"].is_null() {
                    inspection_service_config.expose_peer_information = true;
                    modified_config = true;
                }

                if local_inspection_config_yaml["expose_system_information"].is_null() {
                    inspection_service_config.expose_system_information = true;
                    modified_config = true;
                }
            }
        }

        Ok(modified_config)
    }
```

**File:** crates/aptos-inspection-service/src/server/peer_information.rs (L21-38)
```rust
pub fn handle_peer_information_request(
    node_config: &NodeConfig,
    aptos_data_client: AptosDataClient,
    peers_and_metadata: Arc<PeersAndMetadata>,
) -> (StatusCode, Body, String) {
    // Only return peer information if the endpoint is enabled
    let (status_code, body) = if node_config.inspection_service.expose_peer_information {
        let peer_information = get_peer_information(aptos_data_client, peers_and_metadata);
        (StatusCode::OK, Body::from(peer_information))
    } else {
        (
            StatusCode::FORBIDDEN,
            Body::from(PEER_INFO_DISABLED_MESSAGE),
        )
    };

    (status_code, body, CONTENT_TYPE_TEXT.into())
}
```

**File:** crates/aptos-inspection-service/src/server/peer_information.rs (L148-168)
```rust
/// Displays connection metadata for each peer
fn display_peer_connection_metadata(
    peer_information_output: &mut Vec<String>,
    all_peers: &Vec<PeerNetworkId>,
    peers_and_metadata: &PeersAndMetadata,
) {
    peer_information_output.push("Connection metadata for each peer:".into());

    // Fetch and display the connection metadata for each peer
    for peer in all_peers {
        if let Ok(peer_metadata) = peers_and_metadata.get_metadata_for_peer(*peer) {
            let connection_metadata = peer_metadata.get_connection_metadata();
            peer_information_output.push(format!(
                "\t- Peer: {}, connection state: {:?}, connection metadata: {}",
                peer,
                peer_metadata.get_connection_state(),
                serde_json::to_string(&connection_metadata).unwrap_or_default()
            ));
        }
    }
}
```

**File:** crates/aptos-inspection-service/src/server/peer_information.rs (L273-300)
```rust
/// Displays the entire set of trusted peers
fn display_trusted_peers(
    peer_information_output: &mut Vec<String>,
    registered_networks: Vec<NetworkId>,
    peers_and_metadata: &PeersAndMetadata,
) {
    peer_information_output.push("Trusted peers (validator set & seeds):".into());

    // Fetch and display the trusted peers for each network
    for network in registered_networks {
        peer_information_output.push(format!("\t- Network: {}", network));
        if let Ok(trusted_peers) = peers_and_metadata.get_trusted_peers(&network) {
            // Sort the peers before displaying them
            let mut sorted_trusted_peers = BTreeMap::new();
            for (peer_id, peer_info) in trusted_peers {
                sorted_trusted_peers.insert(peer_id, peer_info);
            }

            // Display the trusted peers
            for (peer_id, peer_info) in sorted_trusted_peers {
                peer_information_output.push(format!(
                    "\t\t- Peer: {:?}, peer information: {:?}",
                    peer_id, peer_info
                ));
            }
        }
    }
}
```
