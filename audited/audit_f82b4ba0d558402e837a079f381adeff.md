# Audit Report

## Title
Mempool Denial of Service via Ready Transaction Flooding Bypassing Parking Lot Eviction

## Summary
The mempool eviction mechanism in `check_is_full_after_eviction()` only evicts transactions from the parking lot when mempool reaches capacity. An attacker can fill the mempool with "ready" transactions that are never stored in the parking lot, causing eviction to fail and preventing legitimate transactions from being accepted, resulting in a persistent mempool denial of service.

## Finding Description

The mempool uses a parking lot to store "non-ready" sequence number transactions (transactions with sequence numbers greater than the current account sequence number). When the mempool becomes full and a new ready transaction arrives, the eviction logic attempts to free space by removing transactions from the parking lot. [1](#0-0) 

However, the parking lot **only** contains non-ready sequence number transactions. Two types of transactions are never stored in the parking lot:

1. **Ready sequence number transactions** (where `seq_num == account_sequence_number`)
2. **Nonce-based (orderless) transactions** (explicitly excluded from parking lot) [2](#0-1) 

The `get_poppable()` function returns `None` when the parking lot is empty, causing the eviction loop to exit immediately without freeing any space. [3](#0-2) 

**Attack Scenario:**

1. Attacker controls multiple accounts (to bypass per-user limits)
2. For each account, attacker submits:
   - 100 ready sequence number transactions (seq_num = current account seq_num), OR
   - 1,000 nonce-based transactions
3. These transactions fill mempool to capacity (default: 2,000,000 transactions)
4. None of these transactions are stored in the parking lot (all are "ready")
5. When a legitimate user submits a transaction:
   - `check_is_full_after_eviction()` is triggered
   - Parking lot is empty
   - `get_poppable()` returns `None`
   - Eviction loop exits without freeing space
   - Legitimate transaction rejected with `MempoolIsFull` [4](#0-3) 

**Configuration Details:** [5](#0-4) 

With default config: `capacity = 2,000,000`, `capacity_per_user = 100`, attacker needs only 20,000 accounts to fill mempool. For nonce-based transactions with `orderless_txn_capacity_per_user = 1000`, only 2,000 accounts needed.

## Impact Explanation

This vulnerability qualifies as **CRITICAL** severity under the Aptos bug bounty program for the following reasons:

1. **Total loss of liveness/network availability**: The mempool becomes unable to accept new transactions from legitimate users. While the blockchain continues processing existing transactions, new transaction submission is effectively blocked until the attacker's transactions expire or are committed.

2. **Persistent DoS**: Periodic garbage collection runs every 60 seconds, but the attacker can use valid expiration times (up to 600 seconds) and continuously resubmit transactions to maintain the DoS. [6](#0-5) 

3. **Network-wide impact**: This affects all nodes in the network, as mempool synchronization spreads the attacker's transactions across the entire network.

4. **Low-cost attack**: With minimum gas prices and the ability to reuse accounts, the attack is economically viable for a motivated adversary.

## Likelihood Explanation

**Likelihood: HIGH**

1. **No privileged access required**: Any user can submit transactions to mempool
2. **Simple execution**: Attacker needs basic scripting to submit transactions from multiple accounts
3. **Account creation**: While creating 2,000-20,000 accounts requires gas, this is a one-time cost that can be amortized
4. **Detection difficulty**: "Ready" transactions appear legitimate and follow normal transaction patterns
5. **No cryptographic complexity**: No need to break signatures or exploit complex consensus logic

The only barrier is the initial cost of creating accounts and maintaining minimum gas fees, which is economically feasible for a serious attack.

## Recommendation

Implement a multi-tiered eviction strategy that can evict ready transactions when parking lot eviction is insufficient:

```rust
fn check_is_full_after_eviction(
    &mut self,
    txn: &MempoolTransaction,
    account_sequence_number: Option<u64>,
) -> bool {
    if self.is_full() && self.check_txn_ready(txn, account_sequence_number) {
        let now = Instant::now();
        let mut evicted_txns = 0;
        let mut evicted_bytes = 0;
        
        // Phase 1: Try to evict from parking lot (existing logic)
        while let Some(txn_pointer) = self.parking_lot_index.get_poppable() {
            if let Some(txn) = self
                .transactions
                .get_mut(&txn_pointer.sender)
                .and_then(|txns| txns.remove(&txn_pointer.replay_protector))
            {
                evicted_bytes += txn.get_estimated_bytes() as u64;
                evicted_txns += 1;
                self.index_remove(&txn);
                if !self.is_full() {
                    break;
                }
            } else {
                break;
            }
        }
        
        // Phase 2: If still full, evict lowest-priority ready transactions
        if self.is_full() {
            // Get transactions with lowest gas ranking score from priority index
            for txn_key in self.priority_index.iter().rev() {
                // Skip if new txn has lower priority
                if txn.ranking_score <= txn_key.gas_ranking_score {
                    break;
                }
                
                if let Some(existing_txn) = self
                    .transactions
                    .get_mut(&txn_key.address)
                    .and_then(|txns| txns.remove(&txn_key.replay_protector))
                {
                    evicted_bytes += existing_txn.get_estimated_bytes() as u64;
                    evicted_txns += 1;
                    self.index_remove(&existing_txn);
                    if !self.is_full() {
                        break;
                    }
                }
            }
        }
        
        if evicted_txns > 0 {
            counters::CORE_MEMPOOL_PARKING_LOT_EVICTED_COUNT.observe(evicted_txns as f64);
            counters::CORE_MEMPOOL_PARKING_LOT_EVICTED_BYTES.observe(evicted_bytes as f64);
            counters::CORE_MEMPOOL_PARKING_LOT_EVICTED_LATENCY
                .observe(now.elapsed().as_secs_f64());
        }
    }
    self.is_full()
}
```

Additionally, consider implementing per-account rate limiting or reputation scoring to prevent single actors from dominating mempool capacity.

## Proof of Concept

```rust
#[test]
fn test_mempool_dos_via_ready_transactions() {
    let mut config = NodeConfig::generate_random_config();
    config.mempool.capacity = 1000; // Smaller for testing
    config.mempool.capacity_per_user = 10;
    config.mempool.orderless_txn_capacity_per_user = 100;
    
    let mut pool = CoreMempool::new(&config);
    
    // Attacker fills mempool with ready nonce-based transactions
    // (never stored in parking lot)
    let num_attacker_accounts = 10;
    for account_id in 0..num_attacker_accounts {
        for nonce in 0..100 {
            let result = add_txn(
                &mut pool,
                TestTransaction::new(
                    account_id,
                    ReplayProtector::Nonce(nonce),
                    1, // Low gas price
                ),
            );
            if result.is_err() {
                break;
            }
        }
    }
    
    // Verify mempool is full
    assert_eq!(pool.transactions.system_ttl_index.size(), 1000);
    
    // Verify parking lot is empty (all transactions are ready)
    assert_eq!(pool.get_parking_lot_size(), 0);
    
    // Legitimate user tries to submit high-priority transaction
    let legitimate_txn = TestTransaction::new(
        999, // Different account
        ReplayProtector::Nonce(0),
        1000, // High gas price
    ).make_signed_transaction();
    
    let status = pool.add_txn(
        legitimate_txn,
        1000,
        None,
        TimelineState::NotReady,
        false,
        None,
        Some(BroadcastPeerPriority::Primary),
    );
    
    // Legitimate transaction is rejected despite having higher priority
    assert_eq!(status.code, MempoolStatusCode::MempoolIsFull);
    
    // Eviction failed because parking lot was empty
    assert_eq!(pool.get_parking_lot_size(), 0);
}
```

## Notes

The vulnerability arises from a design assumption that the parking lot will always contain evictable transactions when mempool is full. This assumption fails when attackers strategically submit only "ready" transactions. The fix requires implementing priority-based eviction of ready transactions when parking lot eviction is insufficient, ensuring higher-priority transactions can always displace lower-priority ones regardless of their parking lot status.

### Citations

**File:** mempool/src/core_mempool/transaction_store.rs (L311-317)
```rust
        if self.check_is_full_after_eviction(&txn, account_sequence_number) {
            return MempoolStatus::new(MempoolStatusCode::MempoolIsFull).with_message(format!(
                "Mempool is full. Mempool size: {}, Capacity: {}",
                self.system_ttl_index.size(),
                self.capacity,
            ));
        }
```

**File:** mempool/src/core_mempool/transaction_store.rs (L415-456)
```rust
    fn check_is_full_after_eviction(
        &mut self,
        txn: &MempoolTransaction,
        account_sequence_number: Option<u64>,
    ) -> bool {
        if self.is_full() && self.check_txn_ready(txn, account_sequence_number) {
            let now = Instant::now();
            // try to free some space in Mempool from ParkingLot by evicting non-ready txns
            let mut evicted_txns = 0;
            let mut evicted_bytes = 0;
            while let Some(txn_pointer) = self.parking_lot_index.get_poppable() {
                if let Some(txn) = self
                    .transactions
                    .get_mut(&txn_pointer.sender)
                    .and_then(|txns| txns.remove(&txn_pointer.replay_protector))
                {
                    debug!(
                        LogSchema::new(LogEntry::MempoolFullEvictedTxn).txns(TxnsLog::new_txn(
                            txn.get_sender(),
                            txn.get_replay_protector()
                        ))
                    );
                    evicted_bytes += txn.get_estimated_bytes() as u64;
                    evicted_txns += 1;
                    self.index_remove(&txn);
                    if !self.is_full() {
                        break;
                    }
                } else {
                    error!("Transaction not found in mempool while evicting from parking lot");
                    break;
                }
            }
            if evicted_txns > 0 {
                counters::CORE_MEMPOOL_PARKING_LOT_EVICTED_COUNT.observe(evicted_txns as f64);
                counters::CORE_MEMPOOL_PARKING_LOT_EVICTED_BYTES.observe(evicted_bytes as f64);
                counters::CORE_MEMPOOL_PARKING_LOT_EVICTED_LATENCY
                    .observe(now.elapsed().as_secs_f64());
            }
        }
        self.is_full()
    }
```

**File:** mempool/src/core_mempool/index.rs (L547-588)
```rust
    pub(crate) fn insert(&mut self, txn: &mut MempoolTransaction) {
        // Orderless transactions are always in the "ready" state and are not stored in the parking lot.
        match txn.get_replay_protector() {
            ReplayProtector::SequenceNumber(sequence_number) => {
                if txn.insertion_info.park_time.is_none() {
                    txn.insertion_info.park_time = Some(SystemTime::now());
                }
                txn.was_parked = true;

                let sender = &txn.txn.sender();
                let hash = txn.get_committed_hash();
                let is_new_entry = match self.account_indices.get(sender) {
                    Some(index) => {
                        if let Some((_account, seq_nums)) = self.data.get_mut(*index) {
                            seq_nums.insert((sequence_number, hash))
                        } else {
                            counters::CORE_MEMPOOL_INVARIANT_VIOLATION_COUNT.inc();
                            error!(
                                LogSchema::new(LogEntry::InvariantViolated),
                                "Parking lot invariant violated: for account {}, account index exists but missing entry in data",
                                sender
                            );
                            return;
                        }
                    },
                    None => {
                        let entry = [(sequence_number, hash)]
                            .iter()
                            .cloned()
                            .collect::<BTreeSet<_>>();
                        self.data.push((*sender, entry));
                        self.account_indices.insert(*sender, self.data.len() - 1);
                        true
                    },
                };
                if is_new_entry {
                    self.size += 1;
                }
            },
            ReplayProtector::Nonce(_) => {},
        }
    }
```

**File:** mempool/src/core_mempool/index.rs (L636-646)
```rust
    /// Returns a random "non-ready" transaction (with highest sequence number for that account).
    pub(crate) fn get_poppable(&self) -> Option<TxnPointer> {
        let mut rng = rand::thread_rng();
        self.data.choose(&mut rng).and_then(|(sender, txns)| {
            txns.iter().next_back().map(|(seq_num, hash)| TxnPointer {
                sender: *sender,
                replay_protector: ReplayProtector::SequenceNumber(*seq_num),
                hash: *hash,
            })
        })
    }
```

**File:** config/src/config/mempool_config.rs (L121-123)
```rust
            capacity: 2_000_000,
            capacity_bytes: 2 * 1024 * 1024 * 1024,
            capacity_per_user: 100,
```

**File:** config/src/config/mempool_config.rs (L129-130)
```rust
            system_transaction_timeout_secs: 600,
            system_transaction_gc_interval_ms: 60_000,
```
