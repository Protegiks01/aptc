# Audit Report

## Title
Consensus Split Risk from Mutable Git Branch Dependencies in Cryptographic Deserialization Code

## Summary
The Aptos Core codebase uses arkworks cryptography libraries (`ark-ec`, `ark-serialize`) via git branch references rather than pinned commits in the `[patch.crates-io]` section of `Cargo.toml`. These libraries provide the `PrimeGroup` and `CanonicalDeserialize` traits used in consensus-critical deserialization of BLS12-381 and BN254 cryptographic elements. Updates to the referenced git branch could introduce behavioral changes in deserialization logic, causing validators building at different times to disagree on block validity, resulting in network partition.

## Finding Description

The arkworks dependencies are declared with semantic versioning in the workspace `Cargo.toml`, but are overridden by a `[patch.crates-io]` section that references a **mutable git branch**: [1](#0-0) 

This patch replaces the crates.io versions with code from the `fix-fft-parallelism-cutoff` branch in the Aptos fork of the algebra repository. The `CanonicalDeserialize` trait from `ark-serialize` is used extensively for consensus-critical deserialization operations: [2](#0-1) [3](#0-2) 

The `deserialize_internal` function uses this trait to deserialize cryptographic elements for BLS12-381 and BN254 curves, which are fundamental to transaction verification and consensus: [4](#0-3) 

Critical generator constants are also initialized using `deserialize_uncompressed` from this trait: [5](#0-4) 

**Attack Scenario:**

1. Validator A builds their node using the current state of the git branch (commit X in `Cargo.lock`)
2. The `fix-fft-parallelism-cutoff` branch in `aptos-labs/algebra` is updated with changes to deserialization behavior (either accidentally during maintenance or maliciously if the repository is compromised)
3. Validator B performs a fresh build or runs `cargo update`, pulling commit Y with modified deserialization logic
4. A transaction containing BLS signatures or cryptographic proofs is submitted
5. Validators A and B deserialize the same bytes differently due to behavioral changes in `CanonicalDeserialize::deserialize_uncompressed`
6. The validators disagree on block validity, creating incompatible state roots
7. Network splits into two partitions, violating the **Deterministic Execution** invariant

While `Cargo.lock` pins to a specific commit, this protection is lost when:
- New validators join the network and build from scratch after branch updates
- Existing validators run `cargo update` in their CI/CD pipelines
- The `Cargo.lock` file is regenerated for any reason

## Impact Explanation

This issue maps to **Critical Severity** under the Aptos bug bounty criteria:

- **"Non-recoverable network partition (requires hardfork)"**: If validators disagree on deserialization behavior, they will produce different state roots for identical blocks. This creates incompatible blockchain forks that cannot self-heal through normal consensus mechanisms. Recovery would require manual intervention, potentially including a hard fork to force all validators onto the same version.

- **"Consensus/Safety violations"**: Violates the core invariant that "All validators must produce identical state roots for identical blocks." Different deserialization outcomes mean validators cannot reach agreement on the canonical chain state.

The impact is consensus-critical because cryptographic deserialization affects:
- BLS signature verification for validator consensus
- Elliptic curve operations in zero-knowledge proofs
- State transitions involving cryptographic primitives
- Transaction validation that depends on cryptographic elements

## Likelihood Explanation

**Likelihood: Medium**

The vulnerability requires specific circumstances but is realistic:

**Factors Increasing Likelihood:**
- Git branches are inherently mutable and designed to receive updates
- The algebra fork could legitimately receive bug fixes or optimizations
- Different validators building at different times is normal in a decentralized network
- CI/CD systems commonly run dependency updates
- New validator onboarding happens continuously

**Factors Decreasing Likelihood:**
- Aptos controls the `aptos-labs/algebra` fork and reviews changes
- `Cargo.lock` provides protection when consistently used
- Breaking changes would likely be caught in testing before deployment
- The specific branch may be stable and rarely updated

**Historical Context:**
The patch itself indicates this branch was created to fix an issue (`fix-fft-parallelism-cutoff`), showing that updates to the algebra fork do occur. Any future fix or optimization could introduce behavioral changes.

## Recommendation

**Immediate Fix: Pin to Specific Commit Hash**

Replace the mutable branch references with immutable commit references in the `[patch.crates-io]` section:

```toml
[patch.crates-io]
ark-ec = { git = "https://github.com/aptos-labs/algebra", rev = "2cacd5efad67bce331aec780b6fcfa4a45f44306" }
ark-ff = { git = "https://github.com/aptos-labs/algebra", rev = "2cacd5efad67bce331aec780b6fcfa4a45f44306" }
ark-ff-macros = { git = "https://github.com/aptos-labs/algebra", rev = "2cacd5efad67bce331aec780b6fcfa4a45f44306" }
ark-ff-asm = { git = "https://github.com/aptos-labs/algebra", rev = "2cacd5efad67bce331aec780b6fcfa4a45f44306" }
ark-poly = { git = "https://github.com/aptos-labs/algebra", rev = "2cacd5efad67bce331aec780b6fcfa4a45f44306" }
ark-serialize = { git = "https://github.com/aptos-labs/algebra", rev = "2cacd5efad67bce331aec780b6fcfa4a45f44306" }
```

Using `rev` instead of `branch` ensures all builds use the exact same code, regardless of when they occur.

**Long-term Improvements:**

1. **Use Tagged Releases**: Create versioned tags in the algebra fork (e.g., `aptos-v0.5.0-1`) and reference those instead of commits
2. **Formalize Update Process**: Establish a governance process for updating cryptographic dependencies with mandatory security review
3. **Add Verification**: Implement runtime checks that verify cryptographic operation results match expected test vectors across all validators
4. **Document Critical Dependencies**: Mark consensus-critical dependencies in documentation and require elevated review for changes

## Proof of Concept

The following demonstrates the vulnerability conceptually (cannot be executed without access to modify the algebra fork):

**Step 1: Current State**
```bash
# Validator A builds with current Cargo.lock
git clone https://github.com/aptos-labs/aptos-core
cd aptos-core
cargo build --release
# Uses algebra commit 2cacd5efad67bce331aec780b6fcfa4a45f44306
```

**Step 2: Algebra Branch Updated**
```bash
# In aptos-labs/algebra repository (hypothetical malicious/accidental change)
cd algebra
git checkout fix-fft-parallelism-cutoff
# Modify ark-serialize/src/lib.rs to change deserialization behavior
# For example: change how infinity points are handled or edge case validation
git commit -m "Fix edge case in deserialization"
git push origin fix-fft-parallelism-cutoff
```

**Step 3: Validator B Builds**
```bash
# Validator B builds fresh after the update
git clone https://github.com/aptos-labs/aptos-core
cd aptos-core
cargo build --release
# Now uses new commit from algebra with modified behavior
```

**Step 4: Consensus Split**
```bash
# Both validators process the same block containing cryptographic elements
# Validator A deserializes using old behavior
# Validator B deserializes using new behavior
# Result: Different state roots, network partition
```

**Verification of Current Configuration:** [6](#0-5) 

The `Cargo.lock` shows the dependency is sourced from git with a specific commit, but the `Cargo.toml` patch uses a branch reference, creating the vulnerability when the lock file is regenerated.

## Notes

- The issue exists even though `Cargo.lock` currently pins to a specific commit, because the branch reference in `Cargo.toml` means any lock file regeneration could pull different code
- This is a **supply chain security** issue specific to consensus-critical cryptographic operations
- The vulnerability is particularly concerning because behavioral changes in deserialization might not cause compilation failures but would cause runtime consensus divergence
- The `PrimeGroup` trait usage is less concerning than `CanonicalDeserialize` since group operations are typically deterministic algebraic operations, but the same versioning risk applies

### Citations

**File:** Cargo.toml (L975-980)
```text
ark-ec = { git = "https://github.com/aptos-labs/algebra", branch = "fix-fft-parallelism-cutoff" }
ark-ff = { git = "https://github.com/aptos-labs/algebra", branch = "fix-fft-parallelism-cutoff" }
ark-ff-macros = { git = "https://github.com/aptos-labs/algebra", branch = "fix-fft-parallelism-cutoff" }
ark-ff-asm = { git = "https://github.com/aptos-labs/algebra", branch = "fix-fft-parallelism-cutoff" }
ark-poly = { git = "https://github.com/aptos-labs/algebra", branch = "fix-fft-parallelism-cutoff" }
ark-serialize = { git = "https://github.com/aptos-labs/algebra", branch = "fix-fft-parallelism-cutoff" }
```

**File:** aptos-move/framework/src/natives/cryptography/algebra/mod.rs (L27-27)
```rust
use ark_serialize::CanonicalDeserialize;
```

**File:** aptos-move/framework/src/natives/cryptography/algebra/mod.rs (L308-311)
```rust
static BLS12381_GT_GENERATOR: Lazy<ark_bls12_381::Fq12> = Lazy::new(|| {
    let buf = hex::decode("b68917caaa0543a808c53908f694d1b6e7b38de90ce9d83d505ca1ef1b442d2727d7d06831d8b2a7920afc71d8eb50120f17a0ea982a88591d9f43503e94a8f1abaf2e4589f65aafb7923c484540a868883432a5c60e75860b11e5465b1c9a08873ec29e844c1c888cb396933057ffdd541b03a5220eda16b2b3a6728ea678034ce39c6839f20397202d7c5c44bb68134f93193cec215031b17399577a1de5ff1f5b0666bdd8907c61a7651e4e79e0372951505a07fa73c25788db6eb8023519a5aa97b51f1cad1d43d8aabbff4dc319c79a58cafc035218747c2f75daf8f2fb7c00c44da85b129113173d4722f5b201b6b4454062e9ea8ba78c5ca3cadaf7238b47bace5ce561804ae16b8f4b63da4645b8457a93793cbd64a7254f150781019de87ee42682940f3e70a88683d512bb2c3fb7b2434da5dedbb2d0b3fb8487c84da0d5c315bdd69c46fb05d23763f2191aabd5d5c2e12a10b8f002ff681bfd1b2ee0bf619d80d2a795eb22f2aa7b85d5ffb671a70c94809f0dafc5b73ea2fb0657bae ... (truncated)
    ark_bls12_381::Fq12::deserialize_uncompressed(buf.as_slice()).unwrap()
});
```

**File:** aptos-move/framework/src/natives/cryptography/algebra/serialization.rs (L22-22)
```rust
use ark_serialize::{CanonicalDeserialize, CanonicalSerialize};
```

**File:** aptos-move/framework/src/natives/cryptography/algebra/serialization.rs (L336-348)
```rust
pub fn deserialize_internal(
    context: &mut SafeNativeContext,
    ty_args: &[Type],
    mut args: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    assert_eq!(2, ty_args.len());
    let structure_opt = structure_from_ty_arg!(context, &ty_args[0]);
    let format_opt = format_from_ty_arg!(context, &ty_args[1]);
    abort_unless_serialization_format_enabled!(context, format_opt);
    let vector_ref = safely_pop_arg!(args, VectorRef);
    let bytes_ref = vector_ref.as_bytes_ref();
    let bytes = bytes_ref.as_slice();
    match (structure_opt, format_opt) {
```

**File:** Cargo.lock (L5447-5457)
```text
name = "ark-serialize"
version = "0.5.0"
source = "git+https://github.com/aptos-labs/algebra?branch=fix-fft-parallelism-cutoff#2cacd5efad67bce331aec780b6fcfa4a45f44306"
dependencies = [
 "ark-serialize-derive 0.5.0",
 "ark-std 0.5.0",
 "arrayvec 0.7.4",
 "digest 0.10.7",
 "num-bigint 0.4.4",
 "rayon",
]
```
