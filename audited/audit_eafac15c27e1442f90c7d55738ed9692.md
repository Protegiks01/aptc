# Audit Report

## Title
Missing BatchEnd Version Validation Allows Data Gaps in Indexer File Storage

## Summary
The indexer-grpc-file-store-backfiller fails to validate the `start_version` and `end_version` fields provided in `BatchEnd` status messages from the gRPC stream. When combined with BTreeMap's `pop_first()` operation, this allows non-sequential transaction versions (if delivered by a buggy or compromised server) to be processed and uploaded to file storage with gaps, violating the data completeness guarantee of the archival system.

## Finding Description

The gRPC stream protocol specifies that each `BatchEnd` status message includes `start_version` and `end_version` fields to allow the client to validate there are no gaps in received data. [1](#0-0) 

The server implementation correctly sends these version fields in every BatchEnd signal: [2](#0-1) 

However, the backfiller client completely ignores these validation fields. When processing a `BatchEnd` status, it only checks the signal type and then blindly pops the first 1000 transactions from the buffer: [3](#0-2) 

The vulnerability manifests when the server (due to a bug or data corruption) sends non-sequential transaction versions:

1. Transactions are inserted into a BTreeMap buffer keyed by version number [4](#0-3) 

2. Upon receiving BatchEnd, the code uses `pop_first()` which returns transactions in ascending version order [5](#0-4) 

3. If the buffer contains versions [0-999, 2000-2999] (a 1000-transaction gap), two iterations would occur:
   - First: pops versions 0-999 → sent to worker → validated (0 % 1000 == 0, sequential within batch) → uploaded
   - Second: pops versions 2000-2999 → sent to worker → validated (2000 % 1000 == 0, sequential within batch) → uploaded

4. Both batches pass the worker's validation [6](#0-5)  because each batch is internally sequential and starts at a version divisible by 1000.

5. File storage now permanently contains batches 0 and 2000 with a gap at batch 1000. The progress tracker would stop at version 1000 [7](#0-6) , but if the underlying data source has the same gap, it persists indefinitely.

## Impact Explanation

This issue affects the **indexer ecosystem component**, not core consensus or execution layers. The impact is **Medium severity** per Aptos bug bounty criteria as it causes "state inconsistencies requiring intervention" in the archival/indexing system.

While this doesn't affect consensus safety, validator operations, or funds, it breaks the data completeness guarantee of the indexer file storage, which downstream systems rely on for historical queries, analytics, and auditing. The gap would require manual intervention to detect and potentially re-backfill the missing data.

However, this vulnerability has significant limitations:
- Requires the gRPC server to send non-sequential transactions (the server normally guarantees sequential ordering via explicit sorting)
- Affects only the off-chain indexing/archival system
- Does not impact blockchain consensus or state

## Likelihood Explanation

**Likelihood: Low to Medium**

The server implementation explicitly sorts transactions by version before streaming them. [8](#0-7) 

For this vulnerability to be triggered, one of the following must occur:
1. A bug in the server's transaction fetching or sorting logic
2. Data corruption in the underlying AptosDB storage layer causing gaps
3. A compromised or malicious fullnode

The lack of client-side validation represents a defense-in-depth failure. The protocol specification explicitly provides version information for validation purposes, but the client doesn't use it.

## Recommendation

Add validation of the BatchEnd version range against the buffered transactions before processing:

```rust
Response::Status(signal) => {
    if signal.r#type() != StatusType::BatchEnd {
        anyhow::bail!("Unexpected status signal type");
    }
    
    // Validate we have the expected transactions
    if let Some(end_version) = signal.end_version {
        let expected_start = signal.start_version;
        let expected_count = (end_version - expected_start + 1) as usize;
        
        // Verify buffer contains expected range
        ensure!(
            transactions_buffer.len() == expected_count,
            "Buffer size mismatch: expected {}, got {}",
            expected_count,
            transactions_buffer.len()
        );
        
        // Verify version continuity
        if let Some((&first_version, _)) = transactions_buffer.first_key_value() {
            ensure!(
                first_version == expected_start,
                "Version gap detected: expected start {}, got {}",
                expected_start,
                first_version
            );
        }
    }
    
    while transactions_buffer.len() >= 1000 {
        let mut transactions = Vec::new();
        for _ in 0..1000 {
            let (_, txn) = transactions_buffer.pop_first().unwrap();
            transactions.push(txn);
        }
        sender.send(transactions).await?;
    }
},
```

## Proof of Concept

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use aptos_protos::transaction::v1::Transaction;
    
    #[tokio::test]
    async fn test_gap_detection() {
        // Simulate server sending non-sequential transactions
        let mut buffer = BTreeMap::new();
        
        // Add transactions 0-999
        for v in 0..1000 {
            let mut txn = Transaction::default();
            txn.version = v;
            buffer.insert(v, txn);
        }
        
        // Add transactions 2000-2999 (gap of 1000)
        for v in 2000..3000 {
            let mut txn = Transaction::default();
            txn.version = v;
            buffer.insert(v, txn);
        }
        
        // Current code would process both batches successfully
        assert_eq!(buffer.len(), 2000);
        
        // Pop first 1000
        let mut batch1 = Vec::new();
        for _ in 0..1000 {
            let (v, txn) = buffer.pop_first().unwrap();
            batch1.push(txn);
            assert!(v < 1000); // Confirms we got 0-999
        }
        
        // Pop next 1000
        let mut batch2 = Vec::new();
        for _ in 0..1000 {
            let (v, txn) = buffer.pop_first().unwrap();
            batch2.push(txn);
            assert!(v >= 2000); // Confirms we got 2000-2999, skipping 1000-1999
        }
        
        // Gap of 1000 transactions (1000-1999) was silently accepted
        // This demonstrates the vulnerability
    }
}
```

## Notes

This vulnerability is classified as a **defense-in-depth issue** rather than a critical exploit. While the server implementation currently guarantees sequential transaction delivery, the client should validate the BatchEnd version information as specified in the protocol to detect:
- Server implementation bugs
- Database corruption or gaps
- Potential future changes that might relax ordering guarantees

The protocol designers explicitly included version validation fields in the BatchEnd message for this purpose, but the client implementation doesn't utilize them. Adding this validation would improve robustness and early detection of upstream data integrity issues.

### Citations

**File:** protos/proto/aptos/internal/fullnode/v1/fullnode_data.proto (L31-34)
```text
  // Required. Start version of current batch/stream, inclusive.
  uint64 start_version = 2;
  // End version of current *batch*, inclusive.
  optional uint64 end_version = 3 [jstype = JS_STRING];
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/fullnode_data_service.rs (L160-168)
```rust
                // send end batch message (each batch) upon success of the entire batch
                // client can use the start and end version to ensure that there are no gaps
                // end loop if this message fails to send because otherwise the client can't validate
                let batch_end_status = get_status(
                    StatusType::BatchEnd,
                    coordinator.current_version,
                    Some(max_version),
                    ledger_chain_id,
                );
```

**File:** ecosystem/indexer-grpc/indexer-grpc-file-store-backfiller/src/processor.rs (L189-199)
```rust
                        ensure!(transactions.len() == 1000, "Unexpected transaction count");
                        ensure!(
                            transactions[0].version % 1000 == 0,
                            "Unexpected starting version"
                        );
                        for (ide, t) in transactions.iter().enumerate() {
                            ensure!(
                                t.version == transactions[0].version + ide as u64,
                                "Unexpected version"
                            );
                        }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-file-store-backfiller/src/processor.rs (L226-234)
```rust
                        loop {
                            if finished_starting_versions.contains(&next_version_to_process) {
                                finished_starting_versions.remove(&next_version_to_process);
                                next_version_to_process += 1000;
                                need_to_update = true;
                            } else {
                                break;
                            }
                        }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-file-store-backfiller/src/processor.rs (L280-284)
```rust
                    for txn in transactions {
                        let version = txn.version;
                        // Partial batch may be received; split and insert into buffer.
                        transactions_buffer.insert(version, txn);
                    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-file-store-backfiller/src/processor.rs (L286-300)
```rust
                Response::Status(signal) => {
                    if signal.r#type() != StatusType::BatchEnd {
                        anyhow::bail!("Unexpected status signal type");
                    }
                    while transactions_buffer.len() >= 1000 {
                        // Take the first 1000 transactions.
                        let mut transactions = Vec::new();
                        // Pop the first 1000 transactions from buffer.
                        for _ in 0..1000 {
                            let (_, txn) = transactions_buffer.pop_first().unwrap();
                            transactions.push(txn);
                        }
                        sender.send(transactions).await?;
                    }
                },
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/stream_coordinator.rs (L263-267)
```rust
        transactions_from_storage
            .into_iter()
            .flatten()
            .sorted_by(|a, b| a.version.cmp(&b.version))
            .map(|txn| {
```
