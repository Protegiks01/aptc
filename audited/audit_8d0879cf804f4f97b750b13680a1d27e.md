# Audit Report

## Title
Reputation Manipulation via Selective Voting Enables Transaction Censorship by Validator Coalition

## Summary
A coalition of validators controlling >1/3 of voting power can manipulate the leader reputation system by selectively withholding votes from honest validators' proposals. This causes honest validators to accumulate failed proposals, triggering reputation penalties that reduce their proposer selection weight from 1000 to 1. Over time, the coalition dominates proposer selection, enabling transaction censorship and control over proposal ordering.

## Finding Description

The Aptos consensus protocol uses a reputation-based leader election system implemented in `LeaderReputation` that assigns weights to validators based on their historical performance. The system penalizes validators whose proposal failure rate exceeds 10% by reducing their selection weight from `active_weight` (1000) to `failed_weight` (1). [1](#0-0) 

The quorum requirement for block commitment is 2f+1 (>2/3 of voting power), meaning validators with >1/3 voting power are necessary to reach quorum when honest validators alone cannot achieve it. [2](#0-1) 

**Attack Execution:**

1. **Coalition Formation**: Validators controlling >1/3 but <2/3 of total voting power collude (e.g., 40% coalition, 60% honest validators).

2. **Selective Voting**: The coalition uses `get_valid_proposer(round)` to identify each round's proposer. When an honest validator is selected as proposer, coalition members withhold their votes. When a coalition member is proposer, they vote normally. [3](#0-2) 

3. **Quorum Prevention**: With 60% honest votes < 67% quorum threshold, honest validators' blocks fail to achieve quorum and their rounds fail.

4. **Reputation Damage**: Failed rounds are tracked in `ValidatorPerformance` and used in reputation calculations. Even a single failure without prior successes triggers the penalty (1 * 100 > (0 + 1) * 10 = 100 > 10). [4](#0-3) 

5. **Weight Manipulation**: After accumulating failures, honest validators' weights drop from 1000 to 1, reducing their proposer selection probability by 1000x while coalition members maintain weight 1000.

6. **Censorship Capability**: With coalition members dominating proposer selection, they control which transactions are included in blocks, enabling systematic transaction censorship.

**Why Coalition Remains Unpunished:**

Coalition members who vote selectively (only for coalition proposals) still accumulate `cur_votes > 0` over the evaluation window, maintaining `active_weight = 1000` status. [5](#0-4) 

## Impact Explanation

This vulnerability qualifies as **High Severity** per Aptos bug bounty criteria:

- **Significant Protocol Violations**: Breaks the fairness assumption of Byzantine Fault Tolerant consensus by allowing <2/3 coalition to control proposal ordering
- **Transaction Censorship**: Enables selective exclusion of specific transactions from blocks
- **Liveness Degradation**: Reduces effective validator participation and increases failed rounds

While not reaching Critical severity (no direct fund theft or safety violations under <1/3 Byzantine assumption), this attack significantly compromises the protocol's censorship resistance and degrades network performance.

## Likelihood Explanation

**Likelihood: Medium-High**

**Requirements:**
- Coalition controlling >1/3 voting power (realistic for coordinated validators)
- No technical sophistication required (simple vote withholding)
- Attack is sustainable over multiple epochs

**Feasibility:**
- Validators can easily identify current proposer through public `ProposerElection` interface
- No forced voting mechanism prevents selective participation
- Reputation system amplifies initial advantage into sustained dominance

**Detection:**
- Attack may be detected through analysis of voting patterns
- However, coalition can claim network issues or legitimate disagreements
- No automatic enforcement against non-voting validators beyond reputation penalties

## Recommendation

**Short-term Mitigation:**

1. **Implement Minimum Voting Requirements**: Track individual validators' voting participation rates and apply penalties (inactive_weight or removal) for sustained non-participation below a threshold (e.g., <80% voting rate).

2. **Adjust Failure Threshold**: Increase `failure_threshold_percent` from 10% to 30-40% to require more sustained failures before triggering penalties, making the attack more expensive.

3. **Hybrid Election**: Combine reputation-based selection with stake-weighted random selection to ensure baseline diversity in proposer selection even with manipulated reputations.

**Long-term Solution:**

Implement proposer reputation with voting accountability:

```rust
// Track both proposal success/failure AND individual voting participation
pub struct ValidatorMetrics {
    pub successful_proposals: u32,
    pub failed_proposals: u32,
    pub votes_cast: u32,
    pub votes_expected: u32,  // Based on participation opportunities
}

// Penalize low voting participation separately
fn get_weights(&self, ...) -> Vec<u64> {
    // ... existing logic ...
    let voting_rate = cur_votes as f64 / expected_votes as f64;
    
    if voting_rate < MINIMUM_VOTING_RATE {
        self.failed_weight  // Penalize non-voters
    } else if cur_failed_proposals * 100 > ... {
        self.failed_weight  // Existing failure penalty
    } else {
        self.active_weight
    }
}
```

## Proof of Concept

**Conceptual PoC (Integration Test Outline):**

```rust
// Setup: 10 validators, coalition has 4 (40%), honest has 6 (60%)
// Each validator has equal stake initially

#[tokio::test]
async fn test_reputation_manipulation_attack() {
    let mut swarm = SwarmBuilder::new_local(10)
        .with_aptos()
        .build()
        .await;
    
    // Identify coalition (validators 0-3) and honest (validators 4-9)
    let coalition_validators = vec![0, 1, 2, 3];
    let honest_validators = vec![4, 5, 6, 7, 8, 9];
    
    // Configure coalition to selectively vote
    for epoch in 0..3 {
        for round in 0..100 {
            let proposer = get_proposer_for_round(round);
            
            if honest_validators.contains(&proposer) {
                // Coalition withholds votes - honest block fails
                coalition_validators.iter().for_each(|v| {
                    swarm.validator(*v).pause_voting();
                });
            } else {
                // Coalition votes normally - coalition block succeeds
                coalition_validators.iter().for_each(|v| {
                    swarm.validator(*v).resume_voting();
                });
            }
            
            swarm.wait_for_round(round).await;
        }
        
        // After epoch, verify reputation damage
        let metrics = swarm.get_validator_metrics().await;
        
        // Honest validators accumulate failures
        for honest_id in &honest_validators {
            assert!(metrics[*honest_id].failed_proposals > 
                    metrics[*honest_id].successful_proposals);
        }
        
        // Coalition maintains good reputation
        for coalition_id in &coalition_validators {
            assert!(metrics[*coalition_id].failed_proposals < 
                    metrics[*coalition_id].successful_proposals * 10 / 100);
        }
    }
    
    // Verify coalition dominates proposer selection in final epoch
    let proposer_counts = count_proposers_in_epoch(&swarm, 3).await;
    let coalition_proposals: u32 = coalition_validators.iter()
        .map(|v| proposer_counts[*v])
        .sum();
    
    // Coalition with 40% stake controls >70% of proposals due to reputation
    assert!(coalition_proposals as f64 / 100.0 > 0.70);
}
```

**Notes:**
- This attack exploits the reputation system's asymmetric penalties: proposers are penalized for failures they cannot control (lack of quorum), while voters face minimal consequences for selective non-participation
- The design assumes Byzantine validators would vote randomly or consistently, not strategically based on proposer identity
- Current implementation lacks voting accountability mechanisms beyond reputation-based weight adjustments
- Attack becomes self-reinforcing: initial reputation damage → reduced selection probability → fewer recovery opportunities → sustained low reputation

### Citations

**File:** consensus/src/liveness/leader_reputation.rs (L541-550)
```rust
                if cur_failed_proposals * 100
                    > (cur_proposals + cur_failed_proposals) * self.failure_threshold_percent
                {
                    self.failed_weight
                } else if cur_proposals > 0 || cur_votes > 0 {
                    self.active_weight
                } else {
                    self.inactive_weight
                }
            })
```

**File:** consensus/src/liveness/leader_reputation.rs (L710-732)
```rust
        // Multiply weights by voting power:
        let stake_weights: Vec<u128> = weights
            .iter_mut()
            .enumerate()
            .map(|(i, w)| *w as u128 * self.voting_powers[i] as u128)
            .collect();

        let state = if self.use_root_hash {
            [
                root_hash.to_vec(),
                self.epoch.to_le_bytes().to_vec(),
                round.to_le_bytes().to_vec(),
            ]
            .concat()
        } else {
            [
                self.epoch.to_le_bytes().to_vec(),
                round.to_le_bytes().to_vec(),
            ]
            .concat()
        };

        let chosen_index = choose_index(stake_weights, state);
```

**File:** consensus/src/liveness/proposer_election.rs (L14-20)
```rust
    fn is_valid_proposer(&self, author: Author, round: Round) -> bool {
        self.get_valid_proposer(round) == author
    }

    /// Return the valid proposer for a given round (this information can be
    /// used by e.g., voters for choosing the destinations for sending their votes to).
    fn get_valid_proposer(&self, round: Round) -> Author;
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1660-1691)
```text
        let cur_validator_perf = vector::borrow(&validator_perf.validators, validator_index);
        let num_successful_proposals = cur_validator_perf.successful_proposals;

        let fee_pending_inactive = 0;
        let fee_active = 0;
        let fee_limit = if (exists<TransactionFeeConfig>(@aptos_framework)) {
            let TransactionFeeConfig::V0 { max_fee_octa_allowed_per_epoch_per_pool } = borrow_global<TransactionFeeConfig>(@aptos_framework);
            *max_fee_octa_allowed_per_epoch_per_pool
        } else {
            MAX_U64 as u64
        };

        if (exists<PendingTransactionFee>(@aptos_framework)) {
            let pending_fee_by_validator = &mut borrow_global_mut<PendingTransactionFee>(@aptos_framework).pending_fee_by_validator;
            if (pending_fee_by_validator.contains(&validator_index)) {
                let fee_octa = pending_fee_by_validator.remove(&validator_index).read();
                if (fee_octa > fee_limit) {
                    fee_octa = fee_limit;
                };
                let stake_active = (coin::value(&stake_pool.active) as u128);
                let stake_pending_inactive = (coin::value(&stake_pool.pending_inactive) as u128);
                fee_pending_inactive = (((fee_octa as u128) * stake_pending_inactive / (stake_active + stake_pending_inactive)) as u64);
                fee_active = fee_octa - fee_pending_inactive;
            }
        };

        spec {
            // The following addition should not overflow because `num_total_proposals` cannot be larger than 86400,
            // the maximum number of proposals in a day (1 proposal per second).
            assume cur_validator_perf.successful_proposals + cur_validator_perf.failed_proposals <= MAX_U64;
        };
        let num_total_proposals = cur_validator_perf.successful_proposals + cur_validator_perf.failed_proposals;
```
