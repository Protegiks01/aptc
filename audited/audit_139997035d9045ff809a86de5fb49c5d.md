# Audit Report

## Title
reCAPTCHA v3 Score Validation Bypass in Aptos Faucet Allows Bot Exploitation

## Summary
The Google Captcha checker in the Aptos faucet fails to distinguish between reCAPTCHA v2 and v3, and does not validate the `score` field returned by reCAPTCHA v3. This allows bots to obtain valid low-score tokens that bypass the captcha check, enabling automated faucet drainage.

## Finding Description

The `check()` function in the Google Captcha checker only validates the `success` field from Google's reCAPTCHA API response: [1](#0-0) 

According to Google's reCAPTCHA documentation, there are critical differences between v2 and v3 responses:

**reCAPTCHA v2 Response:**
- `success`: boolean indicating whether the challenge was passed
- If `success=true`, the interaction is verified as human

**reCAPTCHA v3 Response:**
- `success`: boolean indicating whether the token is valid (NOT whether it's human)
- `score`: float from 0.0 (very likely bot) to 1.0 (very likely human)
- `action`: string that should match the client-side action

The vulnerability exists because the implementation only checks `resp["success"]`, which is insufficient for v3. In reCAPTCHA v3, `success=true` merely indicates the token was validly issued by Google, NOT that the interaction was legitimate. A bot can receive `success=true` with `score=0.1` (indicating 90% confidence it's a bot).

**Attack Scenario:**

1. Faucet operator configures the system with reCAPTCHA v3 keys (common practice due to better UX - no visible challenge)
2. Attacker creates automated bot to request faucet funds
3. Bot obtains reCAPTCHA v3 tokens with low scores (e.g., 0.1-0.3)
4. These tokens have `success=true` because they're technically valid
5. Faucet accepts them without checking the score
6. Bot repeatedly drains faucet resources

Additionally, the `action` field is not validated, allowing potential token replay attacks across different actions.

The configuration structure lacks any fields for version detection or score thresholds: [2](#0-1) 

## Impact Explanation

This qualifies as **Medium Severity** per Aptos bug bounty criteria for the following reasons:

1. **Limited Resource Loss**: The faucet can be systematically drained by automated bots, causing operational disruption and preventing legitimate users from obtaining test funds.

2. **No Direct Consensus Impact**: While this doesn't affect blockchain consensus or core protocol security, it compromises an important auxiliary service that supports developer onboarding and testing.

3. **Requires Specific Configuration**: The vulnerability only manifests when operators configure the faucet with reCAPTCHA v3 keys, not v2. However, v3 is increasingly common due to its invisible nature and better user experience.

4. **Operational Impact**: A compromised faucet requires manual intervention to restore service and may require rate limiting or temporary shutdown, affecting the developer ecosystem.

This aligns with Medium Severity: "Limited funds loss or manipulation" - the faucet's test tokens can be systematically drained by bots.

## Likelihood Explanation

**Likelihood: High**

1. **No Barriers to Exploitation**: Any attacker can exploit this with basic scripting knowledge and HTTP requests. No special privileges or insider access required.

2. **Common Configuration**: reCAPTCHA v3 is increasingly adopted due to its frictionless UX (no visible challenge), making vulnerable configurations likely.

3. **Automated Exploitation**: Bots can continuously poll the faucet service with low-score tokens until resources are exhausted.

4. **Clear Attacker Motivation**: 
   - Economic: Obtaining large amounts of test tokens for various testing purposes
   - Malicious: Denying service to legitimate developers
   - Competitive: Disrupting competitor testing environments

5. **Easily Discoverable**: The faucet API is public, and the captcha implementation can be analyzed through API responses.

## Recommendation

Implement version-aware captcha validation with configurable score thresholds:

```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct GoogleCaptchaCheckerConfig {
    pub google_captcha_api_key: KeyString,
    /// reCAPTCHA version: "v2" or "v3"
    #[serde(default = "default_version")]
    pub version: String,
    /// Minimum acceptable score for v3 (0.0-1.0). Recommended: 0.5
    #[serde(default = "default_min_score")]
    pub min_score_v3: f64,
    /// Expected action for v3 validation (optional)
    pub expected_action_v3: Option<String>,
}

fn default_version() -> String {
    "v2".to_string()
}

fn default_min_score_v3() -> f64 {
    0.5
}
```

Update the `check()` function to validate v3 responses:

```rust
// After parsing the response
if resp["success"].as_bool().unwrap_or(false) {
    // For reCAPTCHA v3, validate score and action
    if self.config.version == "v3" {
        let score = resp["score"].as_f64().unwrap_or(0.0);
        if score < self.config.min_score_v3 {
            debug!(
                message = "reCAPTCHA v3 score too low",
                score = score,
                threshold = self.config.min_score_v3,
                source_ip = data.source_ip
            );
            return Ok(vec![RejectionReason::new(
                format!("Captcha score {} below threshold {}", score, self.config.min_score_v3),
                RejectionReasonCode::CaptchaInvalid,
            )]);
        }
        
        // Validate action if configured
        if let Some(expected_action) = &self.config.expected_action_v3 {
            let action = resp["action"].as_str().unwrap_or("");
            if action != expected_action {
                debug!(
                    message = "reCAPTCHA v3 action mismatch",
                    expected = expected_action,
                    actual = action
                );
                return Ok(vec![RejectionReason::new(
                    "Captcha action validation failed".to_string(),
                    RejectionReasonCode::CaptchaInvalid,
                )]);
            }
        }
    }
    return Ok(vec![]);
}
```

## Proof of Concept

**Setup**: Configure Aptos faucet with reCAPTCHA v3 keys (simulated scenario)

**Step 1**: Attacker obtains low-score token from Google reCAPTCHA v3:
```bash
# Simulate bot interaction with Google's reCAPTCHA v3
# Returns a valid token with score 0.1 (very likely bot)
BOT_TOKEN="03AGdBq27..."
```

**Step 2**: Submit fund request to faucet:
```bash
curl -X POST http://faucet-url/fund \
  -H "Content-Type: application/json" \
  -H "COMPLETED_CAPTCHA_TOKEN: $BOT_TOKEN" \
  -d '{
    "address": "0x1234567890abcdef",
    "amount": 1000000000
  }'
```

**Expected Result (Current Behavior)**: 
- Faucet verifies token with Google
- Google returns: `{"success": true, "score": 0.1, "action": "fund"}`
- Faucet checks only `success` field
- Request is approved despite 0.1 score indicating bot
- Funds are disbursed

**Expected Result (After Fix)**:
- Faucet verifies token with Google
- Google returns: `{"success": true, "score": 0.1, "action": "fund"}`
- Faucet checks `success` AND `score` fields
- Score 0.1 is below threshold 0.5
- Request is rejected with "Captcha score 0.1 below threshold 0.5"

**Automated Exploitation Script** (pseudocode):
```rust
// This demonstrates how an attacker could automate exploitation
async fn exploit_faucet() {
    for _ in 0..1000 {
        // Get low-score v3 token (bot-like behavior)
        let token = get_recaptcha_v3_token_with_bot();
        
        // Submit fund request
        let response = client.post("http://faucet/fund")
            .header("COMPLETED_CAPTCHA_TOKEN", token)
            .json(&FundRequest {
                address: generate_new_address(),
                amount: max_amount,
            })
            .send()
            .await;
            
        // Token with score 0.1 will pass current implementation
        assert!(response.status().is_success());
    }
    // Faucet is now drained
}
```

## Notes

This vulnerability specifically affects deployments using reCAPTCHA v3 keys. Organizations using v2 keys are not affected by the score validation issue, though they may still benefit from explicit version configuration for clarity.

The fix requires backward compatibility consideration - existing deployments should default to v2 behavior unless explicitly configured otherwise.

Additionally, Google recommends different score thresholds for different use cases:
- 0.5-1.0: Likely legitimate, allow without challenge
- 0.3-0.5: Suspicious, consider additional verification
- 0.0-0.3: Likely bot, reject or require strong additional verification

For a faucet service distributing valuable test resources, a threshold of 0.5 is recommended as a reasonable balance between security and user experience.

### Citations

**File:** crates/aptos-faucet/core/src/checkers/google_captcha.rs (L32-35)
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct GoogleCaptchaCheckerConfig {
    pub google_captcha_api_key: KeyString,
}
```

**File:** crates/aptos-faucet/core/src/checkers/google_captcha.rs (L106-114)
```rust
            if resp["success"].as_bool().unwrap_or(false) {
                return Ok(vec![]);
            } else {
                debug!(
                    message = "Invalid captcha token",
                    source_ip = data.source_ip,
                    resp = resp
                );
            }
```
