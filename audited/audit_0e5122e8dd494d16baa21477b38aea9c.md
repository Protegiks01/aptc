# Audit Report

## Title
Backup Verification Complete Bypass via Parameter Manipulation

## Summary
The `aptos-db-tool backup verify` command allows an attacker with CLI access to completely bypass all verification steps (transactions, state snapshots, and epoch endings) while still receiving successful verification results and metrics, creating a false sense of security about backup integrity.

## Finding Description

The `Command::Verify` execution path in `aptos-core/storage/db-tool/src/backup.rs` contains a critical verification bypass vulnerability where an attacker can manipulate `VerifyOpt` parameters to skip all verification steps while the system still reports successful verification.

**Attack Vector:**

An attacker (or misconfigured automated system) can set three CLI parameters simultaneously: [1](#0-0) 

When these parameters are set to:
- `--start-version max` (documented to skip transaction verification)
- `--state-snapshot-before-version 0` (documented to disable state snapshot verification)  
- `--skip-epoch-endings` (documented to skip epoch ending verification)

**Execution Flow:**

1. In `VerifyCoordinator::run_impl()`, the parameters cause: [2](#0-1) 

   - `select_state_snapshot(0)` returns `None` (no snapshot exists at version 0)
   - `select_transaction_backups(Version::MAX, Version::MAX)` returns empty vector
   - Epoch endings are selected but then discarded

2. Epoch ending verification is completely skipped: [3](#0-2) 

3. State snapshot verification is skipped silently (no warning logged): [4](#0-3) 

4. Transaction verification receives empty manifest list: [5](#0-4) 

5. The critical bypass occurs in `TransactionRestoreBatchController::run_impl()`: [6](#0-5) 

6. Verification reports success with NO indication that verification was skipped: [7](#0-6) 

**Security Guarantee Broken:**

The backup verification system's fundamental invariant is violated: **A successful verification result MUST indicate that backup integrity has been cryptographically validated**. This implementation allows successful verification without checking any data integrity.

## Impact Explanation

While this vulnerability is in operational tooling rather than the core consensus protocol, it creates **MEDIUM severity impact** due to potential state inconsistencies:

1. **Backup Integrity Compromise**: Corrupt or malicious backups can be marked as "verified" in backup inventories
2. **Data Loss Risk**: During disaster recovery, relying on falsely-verified backups could lead to inability to restore node state
3. **Compliance Violations**: Systems claiming backups are cryptographically verified when they're not
4. **Automated System Deception**: Monitoring systems checking verification metrics (`VERIFY_COORDINATOR_SUCC_TS`) would incorrectly report healthy backups

In scenarios where this is the only backup available and later proves unrestorable, validators could face:
- Inability to rejoin network after node failure
- Extended downtime while obtaining alternate state synchronization
- Potential slashing if unable to participate in consensus

This aligns with **Medium Severity**: "State inconsistencies requiring intervention"â€”a falsely-verified backup discovered during restore would require manual intervention and alternate recovery methods.

## Likelihood Explanation

**Likelihood: MEDIUM**

The vulnerability is exploitable in these realistic scenarios:

1. **Malicious Insider**: Operator with access to backup systems intentionally creates false verification records
2. **Misconfigured Automation**: Automated backup verification scripts accidentally configured with all skip flags
3. **Compromised Backup System**: Attacker who compromised backup infrastructure manipulates verification parameters
4. **Testing Misuse**: Development/testing flags accidentally used in production verification

The flags are explicitly documented in help text, suggesting intentional design for selective verification, but no safeguards prevent combining them to skip ALL verification.

## Recommendation

Implement safeguards to prevent complete verification bypass and provide clear warnings:

```rust
// In VerifyCoordinator::run_impl(), after line 96:
let has_state_snapshot = state_snapshot.is_some();
let has_transactions = !transactions.is_empty();
let has_epoch_endings = !self.skip_epoch_endings;

if !has_state_snapshot && !has_transactions && !has_epoch_endings {
    return Err(anyhow!(
        "Verification aborted: All verification types are disabled. \
         This would result in no actual verification being performed. \
         At least one of (transactions, state snapshots, epoch endings) must be verified."
    ));
}

if !has_state_snapshot {
    warn!("State snapshot verification DISABLED");
}
if !has_transactions {
    warn!("Transaction verification DISABLED (start_version >= all available versions)");
}
if !has_epoch_endings {
    warn!("Epoch ending verification DISABLED");
}
```

Additionally, modify success logging to indicate partial verification:

```rust
// In VerifyCoordinator::run(), replace line 78:
info!(
    "Verify coordinator exiting with success. Verified: {} snapshots, {} transactions, {} epoch_endings",
    if has_state_snapshot { "YES" } else { "NO" },
    if has_transactions { "YES" } else { "NO" },
    if has_epoch_endings { "YES" } else { "NO" }
);
```

## Proof of Concept

```bash
# Create a backup verification command that bypasses all checks
aptos-db-tool backup verify \
    --start-version max \
    --state-snapshot-before-version 0 \
    --skip-epoch-endings \
    --metadata-cache-dir /tmp/cache \
    --storage-backend local:///path/to/backup

# Expected (current behavior):
# "Verify coordinator started."
# "Verify coordinator exiting with success."
# VERIFY_COORDINATOR_SUCC_TS metric set
# Exit code: 0

# Expected (with fix):
# Error: "Verification aborted: All verification types are disabled..."
# Exit code: 1
```

**Notes**

This vulnerability exists at the intersection of operational tooling and security guarantees. While the `aptos-db-tool` is not part of the core consensus protocol, backup verification is a critical security control for disaster recovery. The flags appear intentionally designed for selective verification, but the absence of safeguards against complete bypass represents a security design flaw that could lead to state inconsistencies requiring manual intervention during recovery scenarios.

### Citations

**File:** storage/db-tool/src/backup.rs (L134-154)
```rust
    #[clap(
        long,
        value_parser = parse_maxable_u64,
        help = "The first transaction version required to be verified. Pass \"max\" to skip \
        transaction verification. [Defaults to 0]"
    )]
    start_version: Option<Version>,
    #[clap(
        long,
        help = "The last transaction version required to be verified (if present \
        in the backup). [Defaults to the latest version available]"
    )]
    end_version: Option<Version>,
    #[clap(
        long,
        help = "Verify the last state snapshot strictly before this version. Pass 0 to disable \
        state snapshot verification. [Defaults to the latest snapshot]"
    )]
    state_snapshot_before_version: Option<Version>,
    #[clap(long, help = "Skip verifying epoch ending info.")]
    skip_epoch_endings: bool,
```

**File:** storage/backup/backup-cli/src/coordinators/verify.rs (L77-79)
```rust
        } else {
            info!("Verify coordinator exiting with success.");
            VERIFY_COORDINATOR_SUCC_TS.set(unix_timestamp_sec());
```

**File:** storage/backup/backup-cli/src/coordinators/verify.rs (L92-96)
```rust
        let state_snapshot =
            metadata_view.select_state_snapshot(self.state_snapshot_before_version)?;
        let transactions =
            metadata_view.select_transaction_backups(self.start_version, self.end_version)?;
        let epoch_endings = metadata_view.select_epoch_ending_backups(ver_max)?;
```

**File:** storage/backup/backup-cli/src/coordinators/verify.rs (L106-121)
```rust
        let epoch_history = if self.skip_epoch_endings {
            None
        } else {
            Some(Arc::new(
                EpochHistoryRestoreController::new(
                    epoch_endings
                        .into_iter()
                        .map(|backup| backup.manifest)
                        .collect(),
                    global_opt.clone(),
                    self.storage.clone(),
                )
                .run()
                .await?,
            ))
        };
```

**File:** storage/backup/backup-cli/src/coordinators/verify.rs (L123-142)
```rust
        if let Some(backup) = state_snapshot {
            info!(
                epoch = backup.epoch,
                version = backup.version,
                "State snapshot selected for verification."
            );
            StateSnapshotRestoreController::new(
                StateSnapshotRestoreOpt {
                    manifest_handle: backup.manifest,
                    version: backup.version,
                    validate_modules: self.validate_modules,
                    restore_mode: StateSnapshotRestoreMode::Default,
                },
                global_opt.clone(),
                Arc::clone(&self.storage),
                epoch_history.clone(),
            )
            .run()
            .await?;
        }
```

**File:** storage/backup/backup-cli/src/coordinators/verify.rs (L144-156)
```rust
        let txn_manifests = transactions.into_iter().map(|b| b.manifest).collect();
        TransactionRestoreBatchController::new(
            global_opt,
            self.storage,
            txn_manifests,
            None,
            None, /* replay_from_version */
            epoch_history,
            VerifyExecutionMode::NoVerify,
            self.output_transaction_analysis,
        )
        .run()
        .await?;
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L300-303)
```rust
    async fn run_impl(self) -> Result<()> {
        if self.manifest_handles.is_empty() {
            return Ok(());
        }
```
