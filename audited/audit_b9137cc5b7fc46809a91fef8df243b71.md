# Audit Report

## Title
Race Condition Between Layout Cache and Module Cache Invalidation Causes Consensus Divergence

## Summary
A critical race condition exists between `mark_overridden()` and `flush_layout_cache()` during module publishing in parallel block execution. This allows transactions to use stale struct layouts computed from old module versions while validation believes they read new module versions, breaking the deterministic execution invariant and potentially causing consensus divergence across validators.

## Finding Description

The vulnerability exists in the module publishing flow during parallel block execution (Block-STM). When a transaction publishes a new version of a Move module, the system must invalidate both the module cache and the layout cache. However, these operations are not atomic, creating a race condition window.

**The vulnerable sequence:** [1](#0-0) 

The code marks modules as overridden inside the loop (via `add_module_write_to_module_cache`), then flushes the layout cache afterward: [2](#0-1) 

Within `add_module_write_to_module_cache`, the module is marked as overridden at line 317, but the layout cache flush happens later in the caller function. During this window, a concurrent transaction can:

1. Call `load_layout_from_cache()` and retrieve a stale layout computed from the old module: [3](#0-2) 

2. The layout is retrieved from the global cache (line 209), which still contains the old layout because `flush_layout_cache()` hasn't been called yet.

3. Then iterate through defining modules and call `charge_module()` (lines 211-218), which loads the module: [4](#0-3) 

4. This calls `get_module_or_build_with()` which checks the global cache first: [5](#0-4) 

5. Since the module is marked as overridden, the global cache returns `None` (line 156), so the system loads from the per-block cache (lines 166-174), which contains the NEW module version.

6. The transaction captures a module read showing it read the new module version from per-block cache.

7. Validation only checks module version consistency, not layout coherency: [6](#0-5) 

8. For per-block cache reads, validation passes if the version matches (lines 1062-1066), which it does.

**Result**: Transaction commits with a stale layout computed from old module but validation shows it read the new module. If struct field layouts changed between versions, this causes memory corruption during deserialization and non-deterministic execution results.

## Impact Explanation

This is **Critical Severity** ($1,000,000 impact category) because it violates the **Deterministic Execution** invariant: "All validators must produce identical state roots for identical blocks."

The race condition timing can vary between validators due to:
- Different CPU scheduling of parallel threads
- Different load conditions
- Hardware timing variations

If validators experience different race timings for the same transaction:
- Validator A executes transaction before module publish completes → uses old layout
- Validator B executes transaction after module publish completes → uses new layout
- Both validators produce **different state roots** for the same block → **consensus divergence**

Additional impacts:
- **Memory corruption**: Incompatible layouts cause deserialization to wrong field offsets
- **Data corruption**: Values interpreted incorrectly based on wrong field layouts
- **Non-recoverable state**: Requires hard fork to resolve consensus split

## Likelihood Explanation

**High likelihood** of occurrence:

1. **Frequent module publishing**: The Aptos framework supports runtime module upgrades, which are common during protocol upgrades and DApp deployments.

2. **Block-STM is default**: Parallel execution is enabled by default on Aptos validators for performance.

3. **Race window is significant**: The window between `mark_overridden()` (line 317) and `flush_layout_cache()` (line 574) spans multiple function calls and includes processing all module writes in a loop.

4. **No synchronization**: The layout cache is a `DashMap` accessed concurrently without additional synchronization between the module override flag and layout cache operations: [7](#0-6) 

5. **Exploitable without privileges**: Any transaction that publishes a module triggers the vulnerable code path. No validator access or collusion required.

## Recommendation

**Immediate Fix**: Make layout cache flush atomic with module override marking by moving `flush_layout_cache()` inside the module write loop before marking modules as overridden:

```rust
for write in output_before_guard.module_write_set().values() {
    published = true;
    if scheduler.is_v2() {
        module_ids_for_v2.insert(write.module_id().clone());
    }
    
    // FIXED: Flush layout cache BEFORE marking module as overridden
    // This ensures no transaction can read stale layouts after module invalidation
    global_module_cache.flush_layout_cache();
    
    add_module_write_to_module_cache::<T>(
        write,
        txn_idx,
        runtime_environment,
        global_module_cache,
        versioned_cache.module_cache(),
    )?;
}
if published {
    scheduler.record_validation_requirements(txn_idx, module_ids_for_v2)?;
}
```

**Better Long-term Fix**: Introduce atomic cache invalidation or add layout cache version validation:

1. Store a generation counter in `GlobalModuleCache` that increments on any module publish
2. Include the generation counter in `LayoutCacheEntry`
3. During `load_layout_from_cache()`, validate that the generation counter matches current state
4. If mismatch, treat as cache miss and recompute layout

This ensures layout-module coherency is validated, not just module versions.

## Proof of Concept

```rust
// Reproduction scenario for integration test

// Setup: Deploy module M v1 with struct S { field_a: u64 }
// Transaction T1 (index 5): Use struct S from module M
// Transaction T2 (index 10): Publish module M v2 with struct S { field_b: address, field_a: u64 }
// 
// Race condition execution:
// 1. T1 starts execution, calls type_to_type_layout_with_delayed_fields(S)
// 2. T1 reads layout L1 from cache (field_a at offset 0, size 8 bytes)
// 3. T2 commits, calls mark_overridden(M) 
// 4. T1 calls charge_module(M), loads M v2 from per-block cache
// 5. T1 captures ModuleRead::PerBlockCache(M, 10)
// 6. T2 calls flush_layout_cache()
// 7. T1 deserializes value with layout L1 (expecting u64 at offset 0)
//    but actual data is M v2 format (address at offset 0, u64 at offset 32)
// 8. Memory corruption: T1 reads 32-byte address as 8-byte u64
// 9. T1 validation passes (module version check succeeds)
// 10. T1 commits with corrupted data
//
// Different validators experiencing different timing would compute different state roots

// This can be reproduced by:
// 1. Instrumenting the code with artificial delays between mark_overridden and flush_layout_cache
// 2. Running Block-STM with two transactions as above
// 3. Observing different execution results based on race timing
```

**Notes**

The vulnerability is rooted in the design decision to cache layouts separately from modules. While the comment in `load_layout_from_cache()` states "so that transaction gets invalidated on module publish," the implementation fails to achieve this guarantee when modules are read from per-block cache after being marked overridden in global cache. The validation system only verifies module version consistency, creating a false sense of security while layout-module coherency is violated.

### Citations

**File:** aptos-move/block-executor/src/txn_last_input_output.rs (L557-577)
```rust
        let mut published = false;
        let mut module_ids_for_v2 = BTreeSet::new();
        for write in output_before_guard.module_write_set().values() {
            published = true;
            if scheduler.is_v2() {
                module_ids_for_v2.insert(write.module_id().clone());
            }
            add_module_write_to_module_cache::<T>(
                write,
                txn_idx,
                runtime_environment,
                global_module_cache,
                versioned_cache.module_cache(),
            )?;
        }
        if published {
            // Record validation requirements after the modules are published.
            global_module_cache.flush_layout_cache();
            scheduler.record_validation_requirements(txn_idx, module_ids_for_v2)?;
        }
        Ok(published)
```

**File:** aptos-move/block-executor/src/code_cache_global.rs (L86-97)
```rust
/// A global cache for verified code and derived information (such as layouts) that is concurrently
/// accessed during the block execution. Module cache is read-only, and modified safely only at
/// block boundaries. Layout cache can be modified during execution of the block.
pub struct GlobalModuleCache<K, D, V, E> {
    /// Module cache containing the verified code.
    module_cache: HashMap<K, Entry<D, V, E>>,
    /// Sum of serialized sizes (in bytes) of all cached modules.
    size: usize,
    /// Cached layouts of structs or enums. This cache stores roots only and is invalidated when
    /// modules are published.
    struct_layouts: DashMap<StructKey, LayoutCacheEntry>,
}
```

**File:** aptos-move/block-executor/src/code_cache_global.rs (L272-319)
```rust
pub(crate) fn add_module_write_to_module_cache<T: BlockExecutableTransaction>(
    write: &ModuleWrite<T::Value>,
    txn_idx: TxnIndex,
    runtime_environment: &RuntimeEnvironment,
    global_module_cache: &GlobalModuleCache<ModuleId, CompiledModule, Module, AptosModuleExtension>,
    per_block_module_cache: &impl ModuleCache<
        Key = ModuleId,
        Deserialized = CompiledModule,
        Verified = Module,
        Extension = AptosModuleExtension,
        Version = Option<TxnIndex>,
    >,
) -> Result<(), PanicError> {
    let state_value = write
        .write_op()
        .as_state_value()
        .ok_or_else(|| PanicError::CodeInvariantError("Modules cannot be deleted".to_string()))?;

    // Since we have successfully serialized the module when converting into this transaction
    // write, the deserialization should never fail.
    let compiled_module = runtime_environment
        .deserialize_into_compiled_module(state_value.bytes())
        .map_err(|err| {
            let msg = format!("Failed to construct the module from state value: {:?}", err);
            PanicError::CodeInvariantError(msg)
        })?;
    let extension = Arc::new(AptosModuleExtension::new(state_value));

    per_block_module_cache
        .insert_deserialized_module(
            write.module_id().clone(),
            compiled_module,
            extension,
            Some(txn_idx),
        )
        .map_err(|err| {
            let msg = format!(
                "Failed to insert code for module {}::{} at version {} to module cache: {:?}",
                write.module_address(),
                write.module_name(),
                txn_idx,
                err
            );
            PanicError::CodeInvariantError(msg)
        })?;
    global_module_cache.mark_overridden(write.module_id());
    Ok(())
}
```

**File:** third_party/move/move-vm/runtime/src/storage/loader/lazy.rs (L55-77)
```rust
    fn charge_module(
        &self,
        gas_meter: &mut impl DependencyGasMeter,
        traversal_context: &mut TraversalContext,
        module_id: &ModuleId,
    ) -> PartialVMResult<()> {
        if traversal_context.visit_if_not_special_module_id(module_id) {
            let addr = module_id.address();
            let name = module_id.name();

            let size = self
                .module_storage
                .unmetered_get_existing_module_size(addr, name)
                .map_err(|err| err.to_partial())?;
            gas_meter.charge_dependency(
                DependencyKind::Existing,
                addr,
                name,
                NumBytes::new(size as u64),
            )?;
        }
        Ok(())
    }
```

**File:** third_party/move/move-vm/runtime/src/storage/loader/lazy.rs (L203-221)
```rust
    fn load_layout_from_cache(
        &self,
        gas_meter: &mut impl DependencyGasMeter,
        traversal_context: &mut TraversalContext,
        key: &StructKey,
    ) -> Option<PartialVMResult<LayoutWithDelayedFields>> {
        let entry = self.module_storage.get_struct_layout(key)?;
        let (layout, modules) = entry.unpack();
        for module_id in modules.iter() {
            // Re-read all modules for this layout, so that transaction gets invalidated
            // on module publish. Also, we re-read them in exactly the same way as they
            // were traversed during layout construction, so gas charging should be exactly
            // the same as on the cache miss.
            if let Err(err) = self.charge_module(gas_meter, traversal_context, module_id) {
                return Some(Err(err));
            }
        }
        Some(Ok(layout))
    }
```

**File:** aptos-move/block-executor/src/code_cache.rs (L148-175)
```rust
        match &self.latest_view {
            ViewState::Sync(state) => {
                // Check the transaction-level cache with already read modules first.
                if let CacheRead::Hit(read) = state.captured_reads.borrow().get_module_read(key) {
                    return Ok(read);
                }

                // Otherwise, it is a miss. Check global cache.
                if let Some(module) = self.global_module_cache.get(key) {
                    state
                        .captured_reads
                        .borrow_mut()
                        .capture_global_cache_read(key.clone(), module.clone());
                    return Ok(Some((module, Self::Version::default())));
                }

                // If not global cache, check per-block cache.
                let _timer = GLOBAL_MODULE_CACHE_MISS_SECONDS.start_timer();
                let read = state
                    .versioned_map
                    .module_cache()
                    .get_module_or_build_with(key, builder)?;
                state
                    .captured_reads
                    .borrow_mut()
                    .capture_per_block_cache_read(key.clone(), read.clone());
                Ok(read)
            },
```

**File:** aptos-move/block-executor/src/captured_reads.rs (L1060-1067)
```rust
        let validate = |key: &K, read: &ModuleRead<DC, VC, S>| match read {
            ModuleRead::GlobalCache(_) => global_module_cache.contains_not_overridden(key),
            ModuleRead::PerBlockCache(previous) => {
                let current_version = per_block_module_cache.get_module_version(key);
                let previous_version = previous.as_ref().map(|(_, version)| *version);
                current_version == previous_version
            },
        };
```
