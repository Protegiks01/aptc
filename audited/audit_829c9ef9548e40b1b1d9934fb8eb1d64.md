# Audit Report

## Title
Critical State Integrity Bypass in Cross-Shard Execution: Missing Merkle Proof Verification Allows Byzantine Executor Shards to Inject Arbitrary State Values

## Summary
The `get_state_value()` function in `CrossShardStateView` returns cross-shard state values without verifying them against Merkle proofs or state roots, allowing compromised executor shard processes to inject arbitrary state data that executing transactions will accept as authentic, violating the "State Consistency" and "Deterministic Execution" invariants.

## Finding Description

The sharded block executor architecture allows validators to parallelize block execution across multiple executor shards. In remote execution mode, these shards run as separate processes communicating via `NetworkController`. When a transaction in one shard writes to state that another shard needs to read, the writing shard sends a `RemoteTxnWriteMsg` containing the state key and write operation. [1](#0-0) 

The receiving shard accepts this message and directly stores the value in its `CrossShardStateView` without any cryptographic verification: [2](#0-1) 

When transactions later request this state via `get_state_value()`, the unverified value is returned directly: [3](#0-2) 

**Contrast with Normal Execution:**

In the standard execution path using `DbStateView`, state values retrieved from storage are optionally verified against Merkle proofs: [4](#0-3) 

The cross-shard messages contain no such proof information: [5](#0-4) 

And the `NetworkController` used for inter-process communication provides no authentication or message verification: [6](#0-5) 

**Attack Scenario:**

If a validator uses remote executor mode with executor shards as separate processes, and an attacker gains control of one executor shard process OR performs a man-in-the-middle attack on the internal network:

1. Shard A executes a transaction writing state key K with value V
2. Attacker intercepts or modifies the `RemoteTxnWriteMsg` to contain malicious value V'
3. Shard B receives and stores V' via `set_value()` without verification
4. Transactions in Shard B read K and receive the malicious value V'
5. Shard B executes with incorrect state, producing wrong `TransactionOutput`
6. The validator computes an incorrect state root from aggregated outputs
7. In consensus, this validator's vote contains the wrong state root hash

While a single compromised validator's incorrect vote would be in the minority, this vulnerability completely bypasses the state integrity guarantees that should protect even Byzantine participants from accepting unauthenticated state data.

## Impact Explanation

**Severity: Critical** (Consensus/Safety violations category)

This vulnerability breaks two critical invariants:

1. **Invariant 1 - Deterministic Execution**: "All validators must produce identical state roots for identical blocks" - A compromised executor shard can cause non-deterministic execution by injecting different state values, leading to different state roots.

2. **Invariant 4 - State Consistency**: "State transitions must be atomic and verifiable via Merkle proofs" - Cross-shard state values are accepted WITHOUT Merkle proof verification, completely bypassing state integrity guarantees.

While the attack requires compromising a validator's executor infrastructure (not exploitable by completely external attackers), it represents a fundamental architectural flaw where state authenticity verification - a core security property - is entirely absent from a critical code path. In properly architected systems, even Byzantine components should not be able to bypass cryptographic verification of state data.

## Likelihood Explanation

**Likelihood: Medium**

The attack requires:
- Validator using remote executor mode (separate processes)
- Compromise of one executor shard process OR network MITM capability
- Knowledge of the cross-shard messaging protocol

However, the vulnerability is **architectural** - there is zero cryptographic verification of cross-shard state, making exploitation trivial once the attacker has the required access. Any validator using remote executor mode is vulnerable.

## Recommendation

Add Merkle proof verification to cross-shard state value transmission. The fix should:

1. **Modify `RemoteTxnWrite` to include proof**:
   - Include `SparseMerkleProofExt` alongside the state value
   - Include the expected state root hash from the writing shard

2. **Verify on receipt**:
   - In `CrossShardCommitReceiver::start()`, verify the proof before calling `set_value()`
   - Reject messages with invalid proofs

3. **Alternative lightweight approach**:
   - Sign cross-shard messages with the validator's private key
   - Verify signatures before accepting values
   - This ensures messages originated from the validator's own shards

Example fix structure:

```rust
// In messages.rs
pub struct RemoteTxnWrite {
    state_key: StateKey,
    write_op: Option<WriteOp>,
    proof: Option<SparseMerkleProofExt>,  // ADD THIS
    state_root: HashValue,                 // ADD THIS
}

// In cross_shard_client.rs - CrossShardCommitReceiver::start()
match msg {
    RemoteTxnWriteMsg(txn_commit_msg) => {
        let (state_key, write_op, proof, root) = txn_commit_msg.take_with_proof();
        
        // VERIFY PROOF BEFORE ACCEPTING
        if let Some(proof_data) = proof {
            proof_data.verify(root, *state_key.crypto_hash_ref(), 
                            write_op.as_ref().and_then(|w| w.as_state_value()))?;
        }
        
        cross_shard_state_view.set_value(&state_key, 
            write_op.and_then(|w| w.as_state_value()));
    },
    // ...
}
```

## Proof of Concept

This vulnerability can be demonstrated by:

1. Setting up a validator with remote executor mode (2+ shard processes)
2. Modifying one executor shard to send crafted `RemoteTxnWriteMsg` with arbitrary state values
3. Observing that the receiving shard accepts and uses these values without verification
4. Confirming divergent execution outputs compared to correct execution

```rust
// PoC: Modify CrossShardCommitSender to inject malicious state
impl TransactionCommitHook for MaliciousCommitSender {
    fn on_transaction_committed(&self, txn_idx: TxnIndex, _output: &OnceCell<TransactionOutput>) {
        // Instead of sending actual write_op, send arbitrary malicious value
        let malicious_value = StateValue::from(b"INJECTED_BY_ATTACKER".to_vec());
        let message = RemoteTxnWriteMsg(RemoteTxnWrite::new(
            target_state_key.clone(),
            Some(WriteOp::legacy_modification(malicious_value.bytes().clone())),
        ));
        self.cross_shard_client.send_cross_shard_msg(target_shard, round, message);
    }
}
```

The receiving shard will accept this malicious value and use it for transaction execution, demonstrating the complete absence of state integrity verification.

**Notes:**

This vulnerability is architectural - cross-shard state transmission lacks fundamental cryptographic verification that exists in every other state access path. While exploitation requires validator infrastructure access (not external attackers), the missing security control violates core blockchain state integrity principles and could enable sophisticated attacks in multi-tenant or cloud-hosted validator environments.

### Citations

**File:** aptos-move/aptos-vm/src/sharded_block_executor/cross_shard_client.rs (L32-44)
```rust
            let msg = cross_shard_client.receive_cross_shard_msg(round);
            match msg {
                RemoteTxnWriteMsg(txn_commit_msg) => {
                    let (state_key, write_op) = txn_commit_msg.take();
                    cross_shard_state_view
                        .set_value(&state_key, write_op.and_then(|w| w.as_state_value()));
                },
                CrossShardMsg::StopMsg => {
                    trace!("Cross shard commit receiver stopped for round {}", round);
                    break;
                },
            }
        }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/cross_shard_state_view.rs (L49-56)
```rust
    pub fn set_value(&self, state_key: &StateKey, state_value: Option<StateValue>) {
        self.cross_shard_data
            .get(state_key)
            .unwrap()
            .set_value(state_value);
        // uncomment the following line to debug waiting count
        // trace!("waiting count for shard id {} is {}", self.shard_id, self.waiting_count());
    }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/cross_shard_state_view.rs (L77-82)
```rust
    fn get_state_value(&self, state_key: &StateKey) -> Result<Option<StateValue>, StateViewError> {
        if let Some(value) = self.cross_shard_data.get(state_key) {
            return Ok(value.get_value());
        }
        self.base_view.get_state_value(state_key)
    }
```

**File:** storage/storage-interface/src/state_store/state_view/db_state_view.rs (L27-46)
```rust
    fn get(&self, key: &StateKey) -> StateViewResult<Option<(Version, StateValue)>> {
        if let Some(version) = self.version {
            if let Some(root_hash) = self.maybe_verify_against_state_root_hash {
                // TODO(aldenhu): sample-verify proof inside DB
                // DB doesn't support returning proofs for buffered state, so only optionally
                // verify proof.
                // TODO: support returning state proof for buffered state.
                if let Ok((value, proof)) =
                    self.db.get_state_value_with_proof_by_version(key, version)
                {
                    proof.verify(root_hash, *key.crypto_hash_ref(), value.as_ref())?;
                }
            }
            Ok(self
                .db
                .get_state_value_with_version_by_version(key, version)?)
        } else {
            Ok(None)
        }
    }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/messages.rs (L7-31)
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
pub enum CrossShardMsg {
    RemoteTxnWriteMsg(RemoteTxnWrite),
    StopMsg,
}

#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct RemoteTxnWrite {
    state_key: StateKey,
    // The write op is None if the transaction is aborted.
    write_op: Option<WriteOp>,
}

impl RemoteTxnWrite {
    pub fn new(state_key: StateKey, write_op: Option<WriteOp>) -> Self {
        Self {
            state_key,
            write_op,
        }
    }

    pub fn take(self) -> (StateKey, Option<WriteOp>) {
        (self.state_key, self.write_op)
    }
}
```

**File:** secure/net/src/network_controller/mod.rs (L56-70)
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
#[allow(dead_code)]
pub struct Message {
    pub data: Vec<u8>,
}

impl Message {
    pub fn new(data: Vec<u8>) -> Self {
        Self { data }
    }

    pub fn to_bytes(self) -> Vec<u8> {
        self.data
    }
}
```
