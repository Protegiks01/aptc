# Audit Report

## Title
IPv4-Mapped IPv6 Address Bypass in Faucet IP Blocklist Checker

## Summary
The IP blocklist checker in the Aptos faucet fails to normalize IPv4-mapped IPv6 addresses (e.g., `::ffff:192.0.2.1`) before performing blocklist checks. This allows attackers whose IPv4 addresses are blocklisted to bypass the restriction by connecting via IPv4-mapped IPv6 addresses, enabling them to repeatedly drain faucet funds.

## Finding Description

The faucet's `IpBlocklistChecker` maintains separate blocklists for IPv4 and IPv6 addresses. When checking if a source IP is blocklisted, it performs a simple type-based dispatch: IPv4 addresses are checked against the IPv4 blocklist, and IPv6 addresses are checked against the IPv6 blocklist. [1](#0-0) 

The underlying `IpRangeManager` also performs this same type-based separation: [2](#0-1) [3](#0-2) 

The vulnerability arises because IPv4-mapped IPv6 addresses (format `::ffff:<IPv4-address>`) are represented as `IpAddr::V6` in Rust's standard library. When a request arrives from such an address:

1. An administrator blocks the IPv4 address `192.0.2.1` by adding it to the IPv4 blocklist file
2. The attacker connects using the IPv4-mapped IPv6 address `::ffff:192.0.2.1`
3. The source IP is extracted and passed directly to checkers without normalization: [4](#0-3) 

4. The checker sees `IpAddr::V6(::ffff:192.0.2.1)` and checks only the IPv6 blocklist
5. Since the IPv6 blocklist doesn't contain this address, the check passes
6. The attacker successfully bypasses the IPv4 blocklist and can drain faucet funds

This vulnerability breaks the security invariant that blocklisted IP addresses should be denied access to faucet resources.

## Impact Explanation

This vulnerability allows attackers to bypass IP-based access controls on the faucet service, enabling:

1. **Repeated fund drainage**: Attackers whose IPs are blocklisted can continue requesting funds by using IPv4-mapped IPv6 addresses
2. **Rate limit bypass**: IP-based rate limiting is similarly defeated
3. **Resource exhaustion**: Malicious actors can deplete faucet funds faster than intended

According to the Aptos bug bounty program, this constitutes **High Severity** as it represents a "Significant protocol violation" for the faucet service, potentially falling under "API crashes" or service disruption if funds are depleted. It could also be classified as **Medium Severity** under "Limited funds loss or manipulation" depending on faucet fund limits and deployment configuration.

The actual exploitability depends on the server's network configuration:
- **Highly exploitable** when the faucet runs on a dual-stack socket (IPv6 socket with `IPV6_V6ONLY=false`)
- **Moderately exploitable** when behind reverse proxies that forward IPv4 connections as IPv4-mapped IPv6 addresses
- **Exploitable** in any configuration where the Poem framework's `RealIp` extractor can receive IPv4-mapped IPv6 addresses

## Likelihood Explanation

**Likelihood: Medium to High**

The likelihood depends on deployment configuration:

1. **Common dual-stack configurations**: Many modern servers accept both IPv4 and IPv6 connections on a single socket. In these configurations, IPv4 connections are often represented internally as IPv4-mapped IPv6 addresses.

2. **Reverse proxy behavior**: Load balancers and reverse proxies (nginx, HAProxy, etc.) may normalize or preserve IPv4-mapped IPv6 addresses when forwarding requests.

3. **Attacker control**: Attackers can control whether they connect via IPv4 or IPv6 (if both are available to them), and the server's network stack will determine the address representation.

4. **Real-world precedent**: IPv4-mapped IPv6 bypass vulnerabilities have been discovered in various systems' IP filtering implementations, making this a known attack vector.

The vulnerability is **definitely exploitable** in certain network configurations, and given that many modern deployments use dual-stack networking, the likelihood of exploitation in production environments is significant.

## Recommendation

Normalize IPv4-mapped IPv6 addresses to their IPv4 equivalents before performing blocklist checks. Rust's standard library provides the `to_ipv4_mapped()` method for this purpose.

**Fixed code for `ip_blocklist.rs`:**

```rust
#[async_trait]
impl CheckerTrait for IpBlocklistChecker {
    async fn check(
        &self,
        data: CheckerData,
        _dry_run: bool,
    ) -> Result<Vec<RejectionReason>, AptosTapError> {
        // Normalize IPv4-mapped IPv6 addresses to IPv4
        let normalized_ip = match &data.source_ip {
            IpAddr::V6(v6) => {
                if let Some(v4) = v6.to_ipv4_mapped() {
                    IpAddr::V4(v4)
                } else {
                    data.source_ip
                }
            },
            IpAddr::V4(_) => data.source_ip,
        };

        match normalized_ip {
            IpAddr::V4(source_ip) => {
                if self.manager.ipv4_list.contains(&source_ip) {
                    return Ok(vec![RejectionReason::new(
                        format!("IP {} is in blocklist", source_ip),
                        RejectionReasonCode::IpInBlocklist,
                    )]);
                }
            },
            IpAddr::V6(source_ip) => {
                if self.manager.ipv6_list.contains(&source_ip) {
                    return Ok(vec![RejectionReason::new(
                        format!("IP {} is in blocklist", source_ip),
                        RejectionReasonCode::IpInBlocklist,
                    )]);
                }
            },
        }
        Ok(vec![])
    }

    fn cost(&self) -> u8 {
        1
    }
}
```

**Alternative approach**: Normalize at the source IP extraction point in `fund.rs` before creating `CheckerData`, ensuring all checkers benefit from normalized addresses.

## Proof of Concept

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use crate::common::IpRangeManagerConfig;
    use std::io::Write;
    use std::net::{Ipv4Addr, Ipv6Addr};
    use tempfile::NamedTempFile;

    #[tokio::test]
    async fn test_ipv4_mapped_ipv6_bypass() {
        // Create a temporary blocklist file with an IPv4 address
        let mut file = NamedTempFile::new().unwrap();
        writeln!(file, "192.0.2.1/32").unwrap();
        file.flush().unwrap();

        // Create the IP blocklist checker
        let config = IpRangeManagerConfig {
            file: file.path().to_path_buf(),
        };
        let checker = IpBlocklistChecker::new(config).unwrap();

        // Test 1: Direct IPv4 address should be blocked
        let ipv4_addr = IpAddr::V4(Ipv4Addr::new(192, 0, 2, 1));
        let checker_data = CheckerData {
            time_request_received_secs: 0,
            receiver: AccountAddress::from_hex_literal("0x1").unwrap(),
            source_ip: ipv4_addr,
            headers: Arc::new(HeaderMap::new()),
        };
        
        let result = checker.check(checker_data, false).await.unwrap();
        assert!(!result.is_empty(), "IPv4 address should be blocked");

        // Test 2: IPv4-mapped IPv6 address bypasses the blocklist (VULNERABILITY)
        let ipv4_mapped = IpAddr::V6(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc000, 0x0201)); // ::ffff:192.0.2.1
        let checker_data = CheckerData {
            time_request_received_secs: 0,
            receiver: AccountAddress::from_hex_literal("0x1").unwrap(),
            source_ip: ipv4_mapped,
            headers: Arc::new(HeaderMap::new()),
        };
        
        let result = checker.check(checker_data, false).await.unwrap();
        assert!(result.is_empty(), "IPv4-mapped IPv6 bypasses the blocklist - VULNERABILITY!");
    }
}
```

This test demonstrates that while the direct IPv4 address `192.0.2.1` is correctly blocked, the IPv4-mapped IPv6 representation `::ffff:192.0.2.1` bypasses the blocklist check entirely.

## Notes

- This vulnerability also affects any other IP-based checkers in the faucet that rely on similar type-based dispatch without normalization (e.g., rate limiting by IP)
- The fix should be applied consistently across all IP-based security checks in the codebase
- Consider also normalizing at the earliest possible point (request preprocessing) rather than in each individual checker
- IPv4-mapped IPv6 addresses are a well-known source of security bypasses in IP filtering systems and should always be normalized before security checks

### Citations

**File:** crates/aptos-faucet/core/src/checkers/ip_blocklist.rs (L32-49)
```rust
        match &data.source_ip {
            IpAddr::V4(source_ip) => {
                if self.manager.ipv4_list.contains(source_ip) {
                    return Ok(vec![RejectionReason::new(
                        format!("IP {} is in blocklist", source_ip),
                        RejectionReasonCode::IpInBlocklist,
                    )]);
                }
            },
            IpAddr::V6(source_ip) => {
                if self.manager.ipv6_list.contains(source_ip) {
                    return Ok(vec![RejectionReason::new(
                        format!("IP {} is in blocklist", source_ip),
                        RejectionReasonCode::IpInBlocklist,
                    )]);
                }
            },
        }
```

**File:** crates/aptos-faucet/core/src/common/ip_range_manager.rs (L18-21)
```rust
pub struct IpRangeManager {
    pub ipv4_list: IpRange<Ipv4Net>,
    pub ipv6_list: IpRange<Ipv6Net>,
}
```

**File:** crates/aptos-faucet/core/src/common/ip_range_manager.rs (L55-60)
```rust
    pub fn contains_ip(&self, ip: &IpAddr) -> bool {
        match ip {
            IpAddr::V4(ipv4) => self.ipv4_list.contains(ipv4),
            IpAddr::V6(ipv6) => self.ipv6_list.contains(ipv6),
        }
    }
```

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L217-242)
```rust
        let source_ip = match source_ip.0 {
            Some(ip) => ip,
            None => {
                return Err(AptosTapError::new(
                    "No source IP found in the request".to_string(),
                    AptosTapErrorCode::SourceIpMissing,
                ))
            },
        };

        let receiver = match fund_request.receiver() {
            Some(receiver) => receiver,
            None => {
                return Err(AptosTapError::new(
                    "Account address, auth key, or pub key must be provided and valid".to_string(),
                    AptosTapErrorCode::InvalidRequest,
                ))
            },
        };

        let checker_data = CheckerData {
            receiver,
            source_ip,
            headers: Arc::new(header_map.clone()),
            time_request_received_secs: get_current_time_secs(),
        };
```
