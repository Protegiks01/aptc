# Audit Report

## Title
Protocol Fragmentation Attack: Malicious Validators Can Force Excessive CPU Usage Through Protocol Diversity

## Summary
Malicious validators can advertise support for only a single consensus protocol each, forcing honest validators to serialize broadcast messages multiple times (up to 3x) during consensus operations. This increases CPU usage and degrades node performance, particularly when compression protocols are involved.

## Finding Description

The `to_bytes_by_protocol` function in the network interface serializes messages based on each peer's preferred protocol. [1](#0-0)  The function groups peers by protocol and serializes once per unique protocol group.

Consensus defines three supported protocols in priority order: ConsensusDirectSendCompressed, ConsensusDirectSendBcs, and ConsensusDirectSendJson. [2](#0-1) 

During network handshake, validators exchange their supported protocols via `HandshakeMsg`. [3](#0-2)  The protocol negotiation accepts any subset of protocols that intersect with the local node's preferences. There is no requirement or validation that validators must support all standard protocols.

**Attack Path:**
1. Attacker controls multiple validators (< 1/3 stake, within Byzantine tolerance)
2. Each malicious validator modifies their code to advertise only ONE consensus protocol:
   - Validator A: Only ConsensusDirectSendJson
   - Validator B: Only ConsensusDirectSendBcs  
   - Validator C: Only ConsensusDirectSendCompressed
3. When honest validators broadcast via reliable broadcast, the `group_peers_by_protocol` function creates three separate protocol groups [4](#0-3) 
4. The message is serialized three times, once per protocol group
5. ConsensusDirectSendCompressed involves expensive LZ4 compression operations that block execution [5](#0-4) 

Reliable broadcast uses this function for all consensus messages including commit votes and decisions. [6](#0-5)  While `spawn_blocking` is used to prevent blocking the async runtime, the CPU overhead still accumulates with each broadcast operation.

The validators list for broadcast comes from the epoch's validator verifier. [7](#0-6)  This includes all active validators, including those controlled by attackers.

## Impact Explanation

This qualifies as **Medium severity** under the Aptos bug bounty program's "Validator node slowdowns" category. The attack causes:

1. **3x CPU overhead** for message serialization during broadcasts
2. **Compression amplification** - ConsensusDirectSendCompressed uses blocking LZ4 operations
3. **Frequent occurrence** - broadcasts happen for every commit vote, proposal, and decision in consensus
4. **Cumulative degradation** - in high-throughput scenarios, this accumulates across many blocks per second

While the issue doesn't cause consensus safety violations or fund loss, it measurably degrades validator performance and could slow block production, affecting network throughput.

## Likelihood Explanation

**High Likelihood:**
- Requires < 1/3 validators to be malicious (acceptable under Byzantine fault model)
- Trivial to implement - validator operators simply modify protocol configuration
- Passive attack - no special timing or coordination beyond initial setup
- No detection mechanism exists - protocol diversity appears as normal network heterogeneity
- No on-chain enforcement of protocol requirements

The barrier to exploitation is low: any validator operator can modify their node software to advertise restricted protocol support.

## Recommendation

**Short-term mitigation:**
Implement protocol diversity limits in the peer manager to detect and disconnect peers that advertise suspiciously restrictive protocol sets.

**Long-term fix:**
Add protocol requirement validation during handshake and peer admission:

```rust
// In network/framework/src/protocols/wire/handshake/v1/mod.rs
pub fn validate_protocol_requirements(
    protocols: &ProtocolIdSet,
    required_protocols: &[ProtocolId],
) -> Result<(), HandshakeError> {
    for required_protocol in required_protocols {
        if !protocols.contains(*required_protocol) {
            return Err(HandshakeError::InsufficientProtocolSupport);
        }
    }
    Ok(())
}
```

Enforce that all validators must support at least one protocol from each encoding type (BCS, Compressed, JSON) to prevent complete fragmentation.

Alternatively, deprecate protocol diversity and standardize on a single high-performance protocol (e.g., ConsensusDirectSendCompressed) across all validators.

## Proof of Concept

**Setup:**
1. Deploy modified validator nodes that restrict protocol advertising
2. Configure 3 validators with single-protocol support each
3. Monitor CPU usage on honest validators during broadcast operations

**Modified validator configuration:**
```rust
// In aptos-node/src/network.rs - Modified by attacker
pub fn consensus_network_configuration(node_config: &NodeConfig) -> NetworkApplicationConfig {
    // Attacker restricts to single protocol
    let direct_send_protocols: Vec<ProtocolId> = vec![
        ProtocolId::ConsensusDirectSendJson  // Only JSON, no compression
    ];
    let rpc_protocols: Vec<ProtocolId> = aptos_consensus::network_interface::RPC.into();
    
    // Rest unchanged...
}
```

**Measurement:**
Monitor serialization metrics during reliable broadcast operations. With protocol fragmentation, observe 3x increase in `to_bytes_by_protocol` execution time and corresponding CPU usage spikes during consensus broadcasts.

## Notes

The vulnerability is mitigated but not eliminated by `spawn_blocking` usage in reliable broadcast. While this prevents blocking the async runtime, the underlying CPU cost still impacts node performance. The issue is most severe during high-throughput periods when broadcasts are frequent. The attack leverages the lack of protocol homogeneity requirements in the handshake protocol, exploiting the flexibility designed for backward compatibility.

### Citations

**File:** network/framework/src/application/interface.rs (L160-191)
```rust
    fn group_peers_by_protocol(
        &self,
        peers: Vec<PeerNetworkId>,
    ) -> HashMap<ProtocolId, Vec<PeerNetworkId>> {
        // Sort peers by protocol
        let mut peers_per_protocol = HashMap::new();
        let mut peers_without_a_protocol = vec![];
        for peer in peers {
            match self
                .get_preferred_protocol_for_peer(&peer, &self.direct_send_protocols_and_preferences)
            {
                Ok(protocol) => peers_per_protocol
                    .entry(protocol)
                    .or_insert_with(Vec::new)
                    .push(peer),
                Err(_) => peers_without_a_protocol.push(peer),
            }
        }

        // We only periodically log any unavailable peers (to prevent log spamming)
        if !peers_without_a_protocol.is_empty() {
            sample!(
                SampleRate::Duration(Duration::from_secs(10)),
                warn!(
                    "[sampled] Unavailable peers (without a common network protocol): {:?}",
                    peers_without_a_protocol
                )
            );
        }

        peers_per_protocol
    }
```

**File:** network/framework/src/application/interface.rs (L288-304)
```rust
    fn to_bytes_by_protocol(
        &self,
        peers: Vec<PeerNetworkId>,
        message: Message,
    ) -> anyhow::Result<HashMap<PeerNetworkId, Bytes>> {
        let peers_per_protocol = self.group_peers_by_protocol(peers);
        // Convert to bytes per protocol
        let mut bytes_per_peer = HashMap::new();
        for (protocol_id, peers) in peers_per_protocol {
            let bytes: Bytes = protocol_id.to_bytes(&message)?.into();
            for peer in peers {
                bytes_per_peer.insert(peer, bytes.clone());
            }
        }

        Ok(bytes_per_peer)
    }
```

**File:** consensus/src/network_interface.rs (L164-168)
```rust
pub const DIRECT_SEND: &[ProtocolId] = &[
    ProtocolId::ConsensusDirectSendCompressed,
    ProtocolId::ConsensusDirectSendBcs,
    ProtocolId::ConsensusDirectSendJson,
];
```

**File:** network/framework/src/protocols/wire/handshake/v1/mod.rs (L196-222)
```rust
    pub fn to_bytes<T: Serialize>(&self, value: &T) -> anyhow::Result<Vec<u8>> {
        // Start the serialization timer
        let serialization_timer = start_serialization_timer(*self, SERIALIZATION_LABEL);

        // Serialize the message
        let result = match self.encoding() {
            Encoding::Bcs(limit) => self.bcs_encode(value, limit),
            Encoding::CompressedBcs(limit) => {
                let compression_client = self.get_compression_client();
                let bcs_bytes = self.bcs_encode(value, limit)?;
                aptos_compression::compress(
                    bcs_bytes,
                    compression_client,
                    MAX_APPLICATION_MESSAGE_SIZE,
                )
                .map_err(|e| anyhow!("{:?}", e))
            },
            Encoding::Json => serde_json::to_vec(value).map_err(|e| anyhow!("{:?}", e)),
        };

        // Only record the duration if serialization was successful
        if result.is_ok() {
            serialization_timer.observe_duration();
        }

        result
    }
```

**File:** network/framework/src/protocols/wire/handshake/v1/mod.rs (L431-465)
```rust
    pub fn perform_handshake(
        &self,
        other: &HandshakeMsg,
    ) -> Result<(MessagingProtocolVersion, ProtocolIdSet), HandshakeError> {
        // verify that both peers are on the same chain
        if self.chain_id != other.chain_id {
            return Err(HandshakeError::InvalidChainId(
                other.chain_id,
                self.chain_id,
            ));
        }

        // verify that both peers are on the same network
        if self.network_id != other.network_id {
            return Err(HandshakeError::InvalidNetworkId(
                other.network_id,
                self.network_id,
            ));
        }

        // find the greatest common MessagingProtocolVersion where we both support
        // at least one common ProtocolId.
        for (our_handshake_version, our_protocols) in self.supported_protocols.iter().rev() {
            if let Some(their_protocols) = other.supported_protocols.get(our_handshake_version) {
                let common_protocols = our_protocols.intersect(their_protocols);

                if !common_protocols.is_empty() {
                    return Ok((*our_handshake_version, common_protocols));
                }
            }
        }

        // no intersection found
        Err(HandshakeError::NoCommonProtocols)
    }
```

**File:** crates/reliable-broadcast/src/lib.rs (L130-135)
```rust
            let protocols = Arc::new(
                tokio::task::spawn_blocking(move || {
                    sender.to_bytes_by_protocol(peers, message_clone)
                })
                .await??,
            );
```

**File:** consensus/src/pipeline/buffer_manager.rs (L227-235)
```rust
            reliable_broadcast: ReliableBroadcast::new(
                author,
                epoch_state.verifier.get_ordered_account_addresses(),
                commit_msg_tx.clone(),
                rb_backoff_policy,
                TimeService::real(),
                Duration::from_millis(COMMIT_VOTE_BROADCAST_INTERVAL_MS),
                executor.clone(),
            ),
```
