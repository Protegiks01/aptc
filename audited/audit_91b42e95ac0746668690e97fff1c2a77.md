# Audit Report

## Title
Compilation Metadata Bypass Allows Deployment of Unstable Language Features on Mainnet

## Summary
The `reject_unstable_bytecode()` function in AptosVM only validates compilation metadata when it is present. An attacker can compile Move modules using `set_latest_language()` to enable experimental language features (V2_4/V2_5), manually strip the `CompilationMetadata` from the bytecode, and deploy to mainnet, bypassing the unstable bytecode rejection mechanism designed to prevent unaudited experimental features in production.

## Finding Description
The security control preventing unstable bytecode deployment relies on `CompilationMetadata` being embedded in compiled modules. When `set_latest_language()` is called, it sets the language version to `LanguageVersion::latest()` (V2_5) and bytecode version to `VERSION_MAX`. [1](#0-0) 

This triggers the compiler to mark the compilation as unstable since V2_4 and V2_5 are experimental versions: [2](#0-1) 

The `CompilationMetadata` is embedded during compilation: [3](#0-2) 

During module publishing on mainnet, `reject_unstable_bytecode()` is called to check for unstable compilation: [4](#0-3) 

However, the validation logic only rejects modules **if metadata is present**: [5](#0-4) 

The critical flaw is on line 1745: `if let Some(metadata) = get_compilation_metadata(module)`. If `get_compilation_metadata()` returns `None` (no metadata found), the entire unstable check is skipped and the function returns `Ok(())`.

The `get_compilation_metadata()` function simply returns `None` when the metadata key is not found: [6](#0-5) 

**Attack Path:**
1. Developer/attacker compiles Move code using `BuildOptions::set_latest_language()` to enable experimental V2_4/V2_5 features (public structs, access specifiers)
2. The compilation succeeds with experimental features and embeds `CompilationMetadata` with `unstable: true`
3. Attacker deserializes the compiled bytecode using `CompiledModule::deserialize()`
4. Attacker clears the metadata vector: `compiled_module.metadata = vec![];` or removes only the compilation metadata entry
5. Attacker re-serializes the module using `compiled_module.serialize()`
6. Attacker deploys to mainnet via `code::publish_package_txn()`
7. The VM's `reject_unstable_bytecode()` check receives `None` from `get_compilation_metadata()` and skips validation
8. Module with experimental, unaudited language features is deployed on mainnet

This breaks the invariant that "mainnet only executes audited, stable Move language features" as documented in the language version system: [7](#0-6) 

## Impact Explanation
**Medium Severity** - This vulnerability allows an attacker to bypass a security control designed to prevent deployment of experimental, unaudited language features on mainnet. 

The impact is limited to the specific experimental features available in V2_4/V2_5:
- **Public structs** - Cross-module struct/enum field access
- **Access specifiers** - Read/write access control mechanisms

While these features themselves may not directly cause consensus breaks or fund loss, they have not been fully audited for production use. The experimental nature means:
1. These features may contain undiscovered bugs that could lead to state inconsistencies
2. The VM's handling of these features may not be fully tested for adversarial inputs
3. Future security issues in these features could affect already-deployed mainnet modules

This qualifies as **Medium severity** per Aptos bug bounty criteria: "State inconsistencies requiring intervention" - modules deployed with experimental features could cause unexpected behavior requiring manual intervention or future hardforks to remediate.

The VERSION_10 bytecode format is already enabled on mainnet, so the bytecode itself is accepted: [8](#0-7) [9](#0-8) 

## Likelihood Explanation
**High Likelihood** - The attack requires:
1. Knowledge of Move compilation tooling (accessible to any developer)
2. Basic bytecode manipulation (deserialize/serialize) using standard Move binary format libraries
3. No special privileges or validator access
4. No cryptographic bypasses or complex timing attacks

The fuzzer code even demonstrates that metadata manipulation is straightforward: [10](#0-9) 

Any motivated attacker with Move development experience could execute this attack. The lack of cryptographic protection on metadata makes it trivial to modify once the bytecode is obtained.

## Recommendation
**Add mandatory compilation metadata validation** that requires all modules published to mainnet (after a certain governance-activated feature flag) to have valid `CompilationMetadata`. Reject modules with missing metadata on mainnet.

Recommended fix in `aptos-move/aptos-vm/src/aptos_vm.rs`:

```rust
fn reject_unstable_bytecode(&self, modules: &[CompiledModule]) -> VMResult<()> {
    if self.chain_id().is_mainnet() {
        for module in modules {
            // NEW: Require compilation metadata on mainnet
            let metadata = get_compilation_metadata(module).ok_or_else(|| {
                PartialVMError::new(StatusCode::CONSTRAINT_NOT_SATISFIED)
                    .with_message(
                        "compilation metadata required for mainnet deployment".to_string()
                    )
                    .finish(Location::Undefined)
            })?;
            
            // Existing check
            if metadata.unstable {
                return Err(PartialVMError::new(StatusCode::UNSTABLE_BYTECODE_REJECTED)
                    .with_message(
                        "code marked unstable is not published on mainnet".to_string()
                    )
                    .finish(Location::Undefined));
            }
        }
    }
    Ok(())
}
```

Additionally, create a feature flag `REQUIRE_COMPILATION_METADATA` that must be enabled before enforcing this requirement to avoid breaking existing mainnet modules that may lack metadata.

## Proof of Concept

```rust
use aptos_framework::{BuildOptions, BuiltPackage};
use aptos_package_builder::PackageBuilder;
use move_binary_format::CompiledModule;
use aptos_types::account_address::AccountAddress;

#[test]
fn test_metadata_stripping_bypass() {
    // Step 1: Compile with unstable language version
    let mut builder = PackageBuilder::new("TestPackage");
    builder.add_source(
        "module.move",
        r#"
        module 0xCAFE::TestModule {
            public fun test_function(): u64 { 42 }
        }
        "#,
    );
    let path = builder.write_to_temp().unwrap();
    
    // Use set_latest_language() to enable experimental features
    let package = BuiltPackage::build(
        path.path().to_path_buf(),
        BuildOptions::default().set_latest_language()
    ).expect("compilation succeeds");
    
    // Step 2: Extract and deserialize bytecode
    let original_code = package.extract_code();
    let mut module = CompiledModule::deserialize(&original_code[0]).unwrap();
    
    // Step 3: Verify metadata is present and marked unstable
    let metadata_before = get_compilation_metadata(&module);
    assert!(metadata_before.is_some());
    assert!(metadata_before.unwrap().unstable);
    
    // Step 4: Strip compilation metadata
    module.metadata.retain(|m| m.key != COMPILATION_METADATA_KEY.to_vec());
    
    // Step 5: Re-serialize
    let mut stripped_code = vec![];
    module.serialize(&mut stripped_code).unwrap();
    
    // Step 6: Verify metadata is gone
    let module_check = CompiledModule::deserialize(&stripped_code).unwrap();
    let metadata_after = get_compilation_metadata(&module_check);
    assert!(metadata_after.is_none());
    
    // Step 7: Deploy to mainnet (simulated)
    // In a real attack, this stripped bytecode would be deployed via:
    // code::publish_package_txn(package_metadata, vec![stripped_code])
    // The reject_unstable_bytecode() check would return Ok(()) 
    // because metadata is None, bypassing the unstable check
}
```

**Notes:**
- The vulnerability exists in the `reject_unstable_bytecode()` conditional check that treats missing metadata as valid
- The experimental language features in V2_4/V2_5 (public structs, access specifiers) have not been fully audited for mainnet security
- This breaks the documented security guarantee that unstable language versions "should not be allowed on production networks"
- The fix requires making compilation metadata mandatory for mainnet deployments, with appropriate feature flag gating to avoid breaking existing modules

### Citations

**File:** aptos-move/framework/src/built_package.rs (L165-171)
```rust
    pub fn set_latest_language(self) -> Self {
        BuildOptions {
            language_version: Some(LanguageVersion::latest()),
            bytecode_version: Some(file_format_common::VERSION_MAX),
            ..self
        }
    }
```

**File:** third_party/move/move-model/src/metadata.rs (L17-20)
```rust
pub const LATEST_LANGUAGE_VERSION_VALUE: LanguageVersion = LanguageVersion::V2_5;

/// Only stable versions are allowed on production networks
pub const LATEST_STABLE_LANGUAGE_VERSION_VALUE: LanguageVersion = LanguageVersion::V2_3;
```

**File:** third_party/move/move-model/src/metadata.rs (L288-294)
```rust
    pub const fn unstable(self) -> bool {
        use LanguageVersion::*;
        match self {
            V1 | V2_0 | V2_1 | V2_2 | V2_3 => false,
            V2_4 | V2_5 => true,
        }
    }
```

**File:** third_party/move/move-compiler-v2/src/file_format_generator/module_generator.rs (L165-174)
```rust
        let compilation_metadata = CompilationMetadata::new(compiler_version, language_version);
        let metadata = Metadata {
            key: COMPILATION_METADATA_KEY.to_vec(),
            value: bcs::to_bytes(&compilation_metadata)
                .expect("Serialization of CompilationMetadata should succeed"),
        };
        let module = move_binary_format::CompiledModule {
            version: file_format_common::VERSION_MAX,
            self_module_handle_idx: FF::ModuleHandleIndex(0),
            metadata: vec![metadata],
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1689-1689)
```rust
        self.reject_unstable_bytecode(modules)?;
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1742-1757)
```rust
    fn reject_unstable_bytecode(&self, modules: &[CompiledModule]) -> VMResult<()> {
        if self.chain_id().is_mainnet() {
            for module in modules {
                if let Some(metadata) = get_compilation_metadata(module) {
                    if metadata.unstable {
                        return Err(PartialVMError::new(StatusCode::UNSTABLE_BYTECODE_REJECTED)
                            .with_message(
                                "code marked unstable is not published on mainnet".to_string(),
                            )
                            .finish(Location::Undefined));
                    }
                }
            }
        }
        Ok(())
    }
```

**File:** types/src/vm/module_metadata.rs (L311-317)
```rust
pub fn get_compilation_metadata(code: &impl CompiledCodeMetadata) -> Option<CompilationMetadata> {
    if let Some(data) = find_metadata(code.metadata(), COMPILATION_METADATA_KEY) {
        bcs::from_bytes::<CompilationMetadata>(&data.value).ok()
    } else {
        None
    }
}
```

**File:** types/src/on_chain_config/aptos_features.rs (L165-165)
```rust
    VM_BINARY_FORMAT_V10 = 106,
```

**File:** types/src/on_chain_config/aptos_features.rs (L274-274)
```rust
            FeatureFlag::VM_BINARY_FORMAT_V10,
```

**File:** testsuite/fuzzer/fuzz/fuzz_targets/move/aptosvm_publish.rs (L41-43)
```rust
    for m in input.dep_modules.iter_mut() {
        // m.metadata = vec![]; // we could optimize metadata to only contain aptos metadata
        // m.version = VERSION_MAX;
```
