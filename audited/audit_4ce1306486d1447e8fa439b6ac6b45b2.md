# Audit Report

## Title
Unbounded PatchedJWKs Size Causes Validator Memory Pressure and Performance Degradation

## Summary
The `set_patches` function in the JWKs module lacks explicit size validation on the `PatchedJWKs` resource, allowing governance proposals to create JWK configurations up to 1 MB in size. Unlike `FederatedJWKs` which has a 2 KiB size limit, `PatchedJWKs` is only constrained by the generic storage write limit. Every keyless transaction must read and deserialize the entire `PatchedJWKs` structure during validation, causing memory pressure and validator slowdowns when the resource is large.

## Finding Description
The vulnerability exists in the governance-controlled JWK patch management system. When `jwks::set_patches()` is called via a governance proposal, it updates the `Patches` resource and regenerates `PatchedJWKs` without enforcing any explicit size limit: [1](#0-0) 

In contrast, federated JWKs (user-controlled) have an explicit size check: [2](#0-1) [3](#0-2) 

The comment explicitly acknowledges that large JWKs waste validator resources for transaction validation. However, `PatchedJWKs` only has the generic `max_bytes_per_write_op` limit (1 MB): [4](#0-3) [5](#0-4) 

**Attack Vector:**

1. An attacker with sufficient governance voting power creates a proposal with numerous `PatchUpsertJWK` patches
2. Each patch can contain large issuer strings and JWK data (e.g., RSA_JWK with large `e` and `n` parameters)
3. The proposal is voted and approved through normal governance
4. Upon execution, `regenerate_patched_jwks` applies all patches and stores a `PatchedJWKs` resource approaching 1 MB
5. Every subsequent keyless transaction must read this entire structure: [6](#0-5) 

6. The `fetch_config` deserialization happens outside transaction memory quota tracking: [7](#0-6) 

7. With many concurrent keyless transactions, validators experience significant memory allocation overhead for repeatedly deserializing the large `PatchedJWKs` structure

## Impact Explanation
This vulnerability qualifies as **High Severity** under the Aptos bug bounty program criteria: "Validator node slowdowns."

**Specific Impacts:**
- **Memory Pressure**: If `PatchedJWKs` is 1 MB and there are 100 concurrent keyless transactions being validated, that's 100 MB of transient memory allocation just for JWK deserialization
- **Performance Degradation**: Repeated deserialization of a 1 MB structure adds significant latency to every keyless transaction
- **Consensus Slowdown**: Validator performance degradation can indirectly affect consensus timing and block production rates
- **Persistent Effect**: Once set via governance, the large `PatchedJWKs` affects all validators until reversed by another governance proposal

The impact affects all validators equally and persists until governance intervention.

## Likelihood Explanation
**Likelihood: Medium-Low** due to governance approval requirement, but the impact is severe and persistent once exploited.

**Factors Increasing Likelihood:**
- No explicit validation prevents this - it's a silent vulnerability
- Well-intentioned governance could accidentally create large JWK sets without realizing the performance impact
- The 1 MB limit is much larger than the 2 KiB limit for federated JWKs, suggesting a design oversight

**Factors Decreasing Likelihood:**
- Requires governance approval with sufficient voting power
- Would be visible in governance proposal review (though the performance impact may not be obvious)
- Aptos governance typically involves technical review before approval

## Recommendation
Add an explicit size limit for `PatchedJWKs` similar to the `MAX_FEDERATED_JWKS_SIZE_BYTES` limit for federated JWKs. The limit should be significantly smaller than 1 MB to prevent validator resource exhaustion.

**Recommended Fix:**

```move
// In jwks.move, add a constant near line 33
const MAX_PATCHED_JWKS_SIZE_BYTES: u64 = 100 * 1024; // 100 KiB

// In set_patches function, add validation after regenerate_patched_jwks:
public fun set_patches(fx: &signer, patches: vector<Patch>) acquires Patches, PatchedJWKs, ObservedJWKs {
    system_addresses::assert_aptos_framework(fx);
    borrow_global_mut<Patches>(@aptos_framework).patches = patches;
    regenerate_patched_jwks();
    
    // Add size validation
    let patched_jwks = borrow_global<PatchedJWKs>(@aptos_framework);
    let num_bytes = vector::length(&bcs::to_bytes(patched_jwks));
    assert!(num_bytes < MAX_PATCHED_JWKS_SIZE_BYTES, error::invalid_argument(EPATCHED_JWKS_TOO_LARGE));
}
```

Add the error constant:
```move
const EPATCHED_JWKS_TOO_LARGE: u64 = 10;
```

This ensures governance proposals cannot create excessively large JWK configurations that degrade validator performance.

## Proof of Concept
```move
#[test(aptos_framework = @aptos_framework)]
#[expected_failure(abort_code = 0x10000A)] // EPATCHED_JWKS_TOO_LARGE
fun test_large_patches_dos(aptos_framework: signer) acquires Patches, PatchedJWKs, ObservedJWKs {
    initialize_for_test(&aptos_framework);
    
    // Create many large patches to exceed size limit
    let patches = vector::empty<Patch>();
    let i = 0;
    while (i < 2000) {
        // Create large issuer string
        let issuer = b"https://very-long-issuer-name-that-takes-up-space.com/";
        // Pad to make it larger
        vector::append(&mut issuer, b"additional-padding-to-increase-size-");
        
        // Create RSA JWK with large modulus
        let large_n = utf8(b"very-large-modulus-value-repeated-many-times-to-increase-size");
        let jwk = new_rsa_jwk(
            utf8(b"kid"),
            utf8(b"RS256"),
            utf8(b"AQAB"),
            large_n
        );
        
        vector::push_back(&mut patches, new_patch_upsert_jwk(issuer, jwk));
        i = i + 1;
    };
    
    // This should fail due to size limit
    set_patches(&aptos_framework, patches);
}
```

**Notes:**
- The actual test requires the recommended fix to be implemented first
- Without the fix, this test would pass but would create a large `PatchedJWKs` that degrades validator performance
- The test demonstrates that 2000 moderately-sized patches could create a structure exceeding safe limits

### Citations

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L31-33)
```text
    /// We limit the size of a `PatchedJWKs` resource installed by a dapp owner for federated keyless accounts.
    /// Note: If too large, validators waste work reading it for invalid TXN signatures.
    const MAX_FEDERATED_JWKS_SIZE_BYTES: u64 = 2 * 1024; // 2 KiB
```

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L200-202)
```text
        // TODO: Can we check the size more efficiently instead of serializing it via BCS?
        let num_bytes = vector::length(&bcs::to_bytes(fed_jwks));
        assert!(num_bytes < MAX_FEDERATED_JWKS_SIZE_BYTES, error::invalid_argument(EFEDERATED_JWKS_TOO_LARGE));
```

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L379-383)
```text
    public fun set_patches(fx: &signer, patches: vector<Patch>) acquires Patches, PatchedJWKs, ObservedJWKs {
        system_addresses::assert_aptos_framework(fx);
        borrow_global_mut<Patches>(@aptos_framework).patches = patches;
        regenerate_patched_jwks();
    }
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L154-156)
```rust
            max_bytes_per_write_op: NumBytes,
            { 5.. => "max_bytes_per_write_op" },
            1 << 20, // a single state item is 1MB max
```

**File:** aptos-move/aptos-vm-types/src/storage/change_set_configs.rs (L105-106)
```rust
                if write_op_size > self.max_bytes_per_write_op {
                    return storage_write_limit_reached(None);
```

**File:** aptos-move/aptos-vm/src/keyless_validation.rs (L220-220)
```rust
    let patched_jwks = get_jwks_onchain(resolver)?;
```

**File:** types/src/on_chain_config/mod.rs (L176-192)
```rust
    fn fetch_config<T>(storage: &T) -> Option<Self>
    where
        T: ConfigStorage + ?Sized,
    {
        Some(Self::fetch_config_and_bytes(storage)?.0)
    }

    /// Same as [Self::fetch_config], but also returns the underlying bytes that were used to
    /// deserialize into config.
    fn fetch_config_and_bytes<T>(storage: &T) -> Option<(Self, Bytes)>
    where
        T: ConfigStorage + ?Sized,
    {
        let state_key = StateKey::on_chain_config::<Self>().ok()?;
        let bytes = storage.fetch_config_bytes(&state_key)?;
        let config = Self::deserialize_into_config(&bytes).ok()?;
        Some((config, bytes))
```
