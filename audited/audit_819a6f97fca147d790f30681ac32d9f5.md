# Audit Report

## Title
Client-Side Sequence Number Desynchronization Due to Missing Gas Parameter Validation

## Summary
The SDK's `get_signed_transfer_txn()` function in `coin_client.rs` does not validate gas parameters before incrementing the client's local sequence number. When invalid gas values are provided, transactions are guaranteed to fail blockchain-side validation, but the client's sequence number has already been incremented, causing state desynchronization that requires manual intervention to resolve.

## Finding Description

The vulnerability exists in the transaction signing flow where the SDK prematurely increments the local sequence number before gas parameters are validated:

**Step 1: No Client-Side Validation** [1](#0-0) 

The `TransferOptions` gas parameters are directly passed to the transaction builder without any validation. [2](#0-1) 

The `TransactionBuilder` provides setter methods for gas parameters but performs no validation.

**Step 2: Premature Sequence Number Increment** [3](#0-2) 

When `sign_with_transaction_builder()` is called, it increments the local sequence number (line 364) BEFORE the transaction is submitted to the blockchain. [4](#0-3) 

**Step 3: Blockchain Rejection** [5](#0-4) 

The blockchain validates gas parameters in `check_gas()` and rejects invalid values with specific error codes. [6](#0-5) 

**Step 4: Blockchain Validation Occurs Before Sequence Number Increment** [7](#0-6) 

The `check_gas()` function is called during mempool validation, before the prologue runs. [8](#0-7) 

The blockchain only increments its sequence number in the epilogue after successful execution. Failed transactions never reach the epilogue.

**Result:** The client's local sequence number is X+1, but the blockchain's sequence number remains X. All subsequent transactions from this client will fail with `SEQUENCE_NUMBER_TOO_NEW` error until manually corrected.

## Impact Explanation

This issue qualifies as **Medium Severity** based on the Aptos bug bounty criteria:
- **State inconsistencies requiring intervention**: The client's local state becomes desynchronized from the blockchain state, requiring manual intervention via `set_sequence_number()` or `decrement_sequence_number()` to restore functionality.
- **Account Availability Impact**: The affected SDK instance cannot submit any further transactions until the sequence number is manually corrected, causing temporary account unavailability.
- **Not Direct Funds Loss**: While funds are not lost, this creates a user experience failure that could lead to failed critical transactions in production systems.

However, it's important to note this is a **client-side SDK issue**, not a blockchain protocol vulnerability. The blockchain behaves correctly by rejecting invalid transactions.

## Likelihood Explanation

**High Likelihood** of occurrence:
- Developers commonly customize gas parameters for cost optimization
- No warnings or documentation about the consequences
- No client-side validation or bounds checking
- Easy to trigger accidentally with misconfigured parameters (e.g., `max_gas_amount: 0` or extremely low values)
- The SDK's default `TransferOptions` provide safe defaults, but custom options are common in production

## Recommendation

Add client-side gas parameter validation before incrementing the sequence number. The validation should mirror the blockchain's `check_gas()` logic:

```rust
// In sdk/src/coin_client.rs or sdk/src/transaction_builder.rs
fn validate_gas_parameters(
    max_gas_amount: u64,
    gas_unit_price: u64,
    transaction_size: usize,
) -> Result<(), String> {
    // Validate max_gas_amount bounds
    if max_gas_amount > MAX_GAS_AMOUNT {
        return Err(format!(
            "max_gas_amount {} exceeds maximum {}",
            max_gas_amount, MAX_GAS_AMOUNT
        ));
    }
    
    // Validate minimum gas for transaction size
    let min_gas = calculate_intrinsic_gas(transaction_size);
    if max_gas_amount < min_gas {
        return Err(format!(
            "max_gas_amount {} below minimum {} for transaction size {}",
            max_gas_amount, min_gas, transaction_size
        ));
    }
    
    // Validate gas_unit_price bounds
    if gas_unit_price < MIN_GAS_UNIT_PRICE {
        return Err(format!(
            "gas_unit_price {} below minimum {}",
            gas_unit_price, MIN_GAS_UNIT_PRICE
        ));
    }
    if gas_unit_price > MAX_GAS_UNIT_PRICE {
        return Err(format!(
            "gas_unit_price {} above maximum {}",
            gas_unit_price, MAX_GAS_UNIT_PRICE
        ));
    }
    
    Ok(())
}
```

Call this validation in `get_signed_transfer_txn()` before calling `sign_with_transaction_builder()`.

## Proof of Concept

```rust
use aptos_sdk::{
    coin_client::{CoinClient, TransferOptions},
    rest_client::Client,
    types::LocalAccount,
};

#[tokio::test]
async fn test_gas_validation_sequence_number_desync() {
    let rest_client = Client::new(Url::parse("https://fullnode.devnet.aptoslabs.com").unwrap());
    let mut account = LocalAccount::generate(&mut rand::rngs::OsRng);
    
    // Fund the account
    // ... (funding code)
    
    let initial_seq = account.sequence_number();
    println!("Initial sequence number: {}", initial_seq);
    
    let coin_client = CoinClient::new(&rest_client);
    
    // Attempt transfer with invalid gas parameters
    let invalid_options = TransferOptions {
        max_gas_amount: 0,  // Invalid: below minimum
        gas_unit_price: 100,
        timeout_secs: 10,
        coin_type: "0x1::aptos_coin::AptosCoin",
    };
    
    let result = coin_client.transfer(
        &mut account,
        AccountAddress::from_hex_literal("0x1").unwrap(),
        1000,
        Some(invalid_options),
    ).await;
    
    // Transaction should fail
    assert!(result.is_err());
    
    let current_seq = account.sequence_number();
    println!("Current sequence number: {}", current_seq);
    
    // BUG: Sequence number was incremented despite transaction failure
    assert_eq!(current_seq, initial_seq + 1);
    
    // Next transaction will fail with SEQUENCE_NUMBER_TOO_NEW
    let result2 = coin_client.transfer(
        &mut account,
        AccountAddress::from_hex_literal("0x1").unwrap(),
        1000,
        None,  // Use valid defaults
    ).await;
    
    assert!(result2.is_err());
    // Error will be SEQUENCE_NUMBER_TOO_NEW (1003)
}
```

## Notes

While this is a legitimate design flaw in the SDK, it's important to classify this correctly: this is a **client-side usability bug** rather than a blockchain protocol security vulnerability. The blockchain itself behaves correctly by rejecting invalid transactions before incrementing the on-chain sequence number. The issue only affects the client's local state management. Users can recover by manually synchronizing the sequence number or creating a new SDK instance that queries the current blockchain state.

### Citations

**File:** sdk/src/coin_client.rs (L94-95)
```rust
        .max_gas_amount(options.max_gas_amount)
        .gas_unit_price(options.gas_unit_price);
```

**File:** sdk/src/transaction_builder.rs (L58-65)
```rust
    pub fn max_gas_amount(mut self, max_gas_amount: u64) -> Self {
        self.max_gas_amount = max_gas_amount;
        self
    }

    pub fn gas_unit_price(mut self, gas_unit_price: u64) -> Self {
        self.gas_unit_price = gas_unit_price;
        self
```

**File:** sdk/src/types.rs (L354-368)
```rust
    pub fn sign_with_transaction_builder(&self, builder: TransactionBuilder) -> SignedTransaction {
        let raw_txn = if builder.has_nonce() {
            // Do not increment sequence number for orderless transactions.
            builder
                .sender(self.address())
                .sequence_number(u64::MAX)
                .build()
        } else {
            builder
                .sender(self.address())
                .sequence_number(self.increment_sequence_number())
                .build()
        };
        self.sign_transaction(raw_txn)
    }
```

**File:** sdk/src/types.rs (L546-548)
```rust
    pub fn increment_sequence_number(&self) -> u64 {
        self.sequence_number.fetch_add(1, Ordering::SeqCst)
    }
```

**File:** aptos-move/aptos-vm/src/gas.rs (L126-138)
```rust
    if txn_metadata.max_gas_amount() > txn_gas_params.maximum_number_of_gas_units {
        speculative_warn!(
            log_context,
            format!(
                "[VM] Gas unit error; max {}, submitted {}",
                txn_gas_params.maximum_number_of_gas_units,
                txn_metadata.max_gas_amount()
            ),
        );
        return Err(VMStatus::error(
            StatusCode::MAX_GAS_UNITS_EXCEEDS_MAX_GAS_UNITS_BOUND,
            None,
        ));
```

**File:** aptos-move/aptos-vm/src/gas.rs (L178-207)
```rust
    let below_min_bound = txn_metadata.gas_unit_price() < txn_gas_params.min_price_per_gas_unit;
    if below_min_bound {
        speculative_warn!(
            log_context,
            format!(
                "[VM] Gas unit error; min {}, submitted {}",
                txn_gas_params.min_price_per_gas_unit,
                txn_metadata.gas_unit_price()
            ),
        );
        return Err(VMStatus::error(
            StatusCode::GAS_UNIT_PRICE_BELOW_MIN_BOUND,
            None,
        ));
    }

    // The submitted gas price is greater than the maximum gas unit price set by the VM.
    if txn_metadata.gas_unit_price() > txn_gas_params.max_price_per_gas_unit {
        speculative_warn!(
            log_context,
            format!(
                "[VM] Gas unit error; max {}, submitted {}",
                txn_gas_params.max_price_per_gas_unit,
                txn_metadata.gas_unit_price()
            ),
        );
        return Err(VMStatus::error(
            StatusCode::GAS_UNIT_PRICE_ABOVE_MAX_BOUND,
            None,
        ));
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L2805-2814)
```rust
        check_gas(
            self.gas_params(log_context)?,
            self.gas_feature_version(),
            session.resolver,
            module_storage,
            txn_data,
            self.features(),
            is_approved_gov_script,
            log_context,
        )?;
```

**File:** aptos-move/framework/aptos-framework/sources/transaction_validation.move (L629-632)
```text
        // Increment sequence number
        let addr = signer::address_of(&account);
        account::increment_sequence_number(addr);
    }
```
