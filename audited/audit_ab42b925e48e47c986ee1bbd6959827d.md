# Audit Report

## Title
Node Health Check Bypass: TPS Validator Accepts Nodes with High Transaction Failure Rates

## Summary
The TPS checker in the node health validation system allows nodes to pass health checks even when they accept transactions but fail to execute the vast majority of them. The validation logic only verifies that committed transactions meet the minimum threshold without checking the success rate (committed/submitted ratio), enabling dysfunctional nodes to appear healthy.

## Finding Description

The `TpsChecker::check()` function validates node performance by measuring transactions per second, but contains a critical flaw in its success criteria. [1](#0-0) 

The checker first validates that submitted transactions meet the minimum threshold to avoid configuration errors, then evaluates node health solely based on whether committed transactions meet the minimum. [2](#0-1) 

**The Flaw**: There is no validation that the commit rate is proportional to the submission rate. A node exhibiting the following behavior would pass:

- **Submitted**: 1000 TPS (accepts transactions via REST API)
- **Committed**: 105 TPS (only 10.5% success rate)  
- **Minimum Required**: 100 TPS
- **Result**: ✅ PASS with score 100

The `submitted` counter is incremented when transactions are sent to the node's REST API, while `committed` is incremented only after transactions are verified as executed on-chain. [3](#0-2) [4](#0-3) 

This masks nodes with:
- Execution engine failures (Move VM bugs, gas calculation errors)
- Storage bottlenecks (AptosDB performance issues)
- Consensus participation problems (slow block commitment)
- Mempool saturation or transaction dropping
- Deliberate malicious behavior (accepting but not processing transactions)

## Impact Explanation

**Medium Severity** - This qualifies as "state inconsistencies requiring intervention" per the Aptos bug bounty program:

1. **Validator Set Quality Degradation**: If the node-checker is used to validate nodes before joining the validator set, poorly performing nodes could be admitted, causing validator slowdowns (which would escalate to High severity in practice).

2. **Operational Monitoring Bypass**: Nodes experiencing genuine technical issues (storage failures, VM bugs, consensus lag) would pass health checks, requiring manual investigation to identify actual problems.

3. **User Impact**: Users submitting transactions to nodes that pass this check but have 90%+ failure rates would experience:
   - Transactions accepted (HTTP 200 OK) but never committed
   - Silent transaction drops without proper error reporting
   - Loss of confidence in network reliability

4. **Network Quality**: If multiple such nodes operate, overall network throughput and reliability degrade while monitoring systems report healthy status.

## Likelihood Explanation

**High Likelihood**:

- **Natural Occurrence**: Nodes experiencing legitimate performance issues (inadequate hardware, storage bottlenecks, network latency) naturally exhibit this pattern without malicious intent.

- **No Detection**: The current check provides positive feedback ("Transaction processing speed is sufficient") even for nodes with severe execution problems.

- **Operational Pressure**: Node operators under pressure to meet uptime/performance SLAs might not notice their nodes are silently failing 80-90% of transactions.

- **Validator Admission**: If this is part of the validator onboarding process, the incentive to pass checks creates pressure that could lead to poorly configured nodes being admitted.

## Recommendation

Add validation for the transaction success rate (committed/submitted ratio). The check should fail if committed transactions are significantly lower than submitted transactions:

```rust
// After line 163 in tps.rs, add success rate validation:

let success_rate = if rate.submitted > 0.0 {
    rate.committed / rate.submitted
} else {
    0.0
};

// Require at least 95% success rate (configurable threshold)
const MIN_SUCCESS_RATE: f64 = 0.95;

if success_rate < MIN_SUCCESS_RATE {
    return Ok(vec![Self::build_result(
        "Transaction success rate too low".to_string(),
        0,
        format!(
            "Your node only committed {:.1}% of submitted transactions ({} committed out of {} submitted). \
            Minimum required success rate is {:.1}%. This indicates execution, storage, or consensus issues.",
            success_rate * 100.0,
            rate.committed,
            rate.submitted,
            MIN_SUCCESS_RATE * 100.0
        ),
    )
    .links(vec![NODE_REQUIREMENTS_LINK.to_string()])]);
}
```

Additionally, add `minimum_success_rate` as a configurable parameter in `TpsCheckerConfig` to allow different thresholds for different deployment scenarios.

## Proof of Concept

```rust
// Test demonstrating the vulnerability
// Place in ecosystem/node-checker/src/checker/tps.rs tests module

#[cfg(test)]
mod vulnerability_poc {
    use super::*;
    use aptos_transaction_emitter_lib::TxnStats;
    use std::time::Duration;

    #[test]
    fn test_node_passes_despite_high_failure_rate() {
        // Simulate a node that accepts 1000 TPS but only commits 105 TPS
        let stats = TxnStats {
            submitted: 1000,      // Accepted many transactions
            committed: 105,       // Only committed minimum + 5
            expired: 895,         // Most transactions expired
            failed_submission: 0,
            latency: 50000,
            latency_samples: 105,
            latency_buckets: Default::default(),
            lasted: Duration::from_secs(1),
        };

        let rate = stats.rate();
        let minimum_tps = 100;

        // Current check logic (VULNERABLE):
        assert!(rate.submitted >= minimum_tps as f64); // ✓ passes
        assert!(rate.committed >= minimum_tps as f64);  // ✓ passes
        
        // Success rate is only 10.5%!
        let success_rate = rate.committed / rate.submitted;
        assert_eq!(success_rate, 0.105);
        
        // Node would receive score 100 (PASS) despite 89.5% failure rate
        // This is the vulnerability: no validation of success rate
        
        println!("VULNERABILITY: Node passes with only {:.1}% success rate!", 
                 success_rate * 100.0);
    }
}
```

## Notes

The same validation flaw exists in the Forge testing framework's `SuccessCriteria::check_tps()` function, which also only validates that committed TPS meets the minimum without checking the committed/submitted ratio. [5](#0-4) 

The issue is particularly concerning because the description message acknowledges both metrics ("your node hit: X out of Y transactions submitted") but the pass/fail logic ignores the ratio. [6](#0-5)

### Citations

**File:** ecosystem/node-checker/src/checker/tps.rs (L154-160)
```rust
        if rate.submitted < (self.config.minimum_tps as f64) {
            return Err(TpsCheckerError::InsufficientSubmittedTransactionsError(
                rate.submitted as u64,
                self.config.minimum_tps,
            )
            .into());
        }
```

**File:** ecosystem/node-checker/src/checker/tps.rs (L162-163)
```rust
        let mut description = format!("The minimum TPS (transactions per second) \
            required of nodes is {}, your node hit: {} (out of {} transactions submitted per second).", self.config.minimum_tps, rate.committed, rate.submitted);
```

**File:** ecosystem/node-checker/src/checker/tps.rs (L164-176)
```rust
        let evaluation_result = if rate.committed >= (self.config.minimum_tps as f64) {
            if stats.committed == stats.submitted {
                description.push_str(
                    " Your node could theoretically hit \
                even higher TPS, the evaluation suite only tests to check \
                your node meets the minimum requirements.",
                );
            }
            Self::build_result(
                "Transaction processing speed is sufficient".to_string(),
                100,
                description,
            )
```

**File:** crates/transaction-emitter-lib/src/emitter/submission_worker.rs (L353-356)
```rust
        if num_committed > 0 {
            loop_stats
                .committed
                .fetch_add(num_committed as u64, Ordering::Relaxed);
```

**File:** crates/transaction-emitter-lib/src/emitter/submission_worker.rs (L499-501)
```rust
    stats
        .submitted
        .fetch_add(txns.len() as u64, Ordering::Relaxed);
```

**File:** testsuite/forge/src/success_criteria.rs (L618-639)
```rust
    pub fn check_tps(
        min_avg_tps: f64,
        stats_rate: &TxnStatsRate,
        traffic_name_addition: &String,
    ) -> anyhow::Result<()> {
        let avg_tps = stats_rate.committed;
        if avg_tps < min_avg_tps {
            bail!(
                "TPS requirement{} failed. Average TPS {}, minimum TPS requirement {}. Full stats: {}",
                traffic_name_addition,
                avg_tps,
                min_avg_tps,
                stats_rate,
            )
        } else {
            info!(
                "TPS is {} and is within limit of {}",
                stats_rate.committed, min_avg_tps
            );
            Ok(())
        }
    }
```
