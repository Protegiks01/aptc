# Audit Report

## Title
Epoch Boundary Validation Bypass in Backup Restore Allows Invalid Validator Set Injection

## Summary
Transaction chunks spanning epoch boundaries during backup restoration do not validate that the `next_epoch_state` computed from write sets matches the expected validator set from `EpochHistory`. This allows a malicious backup to inject arbitrary validator sets into the restored database, compromising consensus safety.

## Finding Description

The Aptos backup/restore system fails to validate epoch transitions when replaying transaction chunks that span epoch boundaries. 

The `TransactionChunk` structure lacks explicit epoch boundary constraints: [1](#0-0) 

During restoration, `LoadedChunk::load()` verifies only the chunk's final `LedgerInfoWithSignatures` against `EpochHistory`: [2](#0-1) 

The `EpochHistory::verify_ledger_info()` method validates signatures but does NOT check intermediate epoch changes within a chunk: [3](#0-2) 

During replay, `ChunkExecutorInner::enqueue_chunks()` detects epoch boundaries by scanning events: [4](#0-3) 

For replay operations, a `ReplayChunkVerifier` is used which does NOT validate epoch change ledger infos: [5](#0-4) 

When epoch-ending transactions are executed, the `next_epoch_state` is extracted from write sets without validation: [6](#0-5) 

**Attack Scenario:**

1. Attacker creates a malicious backup with a `TransactionChunk` spanning epochs N to N+1
2. The chunk contains an epoch-ending transaction with a **manipulated** `ValidatorSet` in its write set (e.g., adding unauthorized validators, removing legitimate ones, or altering voting power)
3. All cryptographic hashes (transaction hashes, write set hashes, state hashes) are computed consistently to pass integrity checks
4. The chunk's final `LedgerInfoWithSignatures` is at a version in epoch N+1 or later, signed by **legitimate** validators from the real epoch history
5. During restore:
   - Only the final ledger info is validated against `EpochHistory` â†’ PASSES (correct signatures)
   - The chunk is split at epoch boundaries during replay
   - Write sets containing the manipulated validator set are applied to the database
   - The `next_epoch_state` is extracted from these manipulated write sets without validation against `EpochHistory`
6. The restored database now contains an incorrect validator set for epoch N+1

## Impact Explanation

This is a **CRITICAL** severity vulnerability per Aptos bug bounty criteria:

- **Consensus Safety Violation**: A restored node with an incorrect validator set will accept blocks signed by unauthorized validators or reject legitimate blocks, potentially causing chain forks
- **Validator Set Manipulation**: Completely compromises the validator set integrity for affected epochs
- **State Inconsistency**: The restored database state diverges from the legitimate blockchain state, breaking Critical Invariant #4 (State Consistency)

If multiple nodes restore from the same malicious backup, it could create a non-recoverable network partition requiring a hardfork to resolve.

## Likelihood Explanation

**Likelihood: MEDIUM**

Requirements for exploitation:
- Attacker must control or compromise a backup source
- Operator must restore from this malicious backup
- Attacker needs technical capability to craft internally-consistent backup data

However:
- Backup/restore is a common operational procedure
- Operators may use untrusted backup sources (cloud storage, third-party services)
- The attack is silent - no obvious errors during restoration
- Multiple nodes restoring from the same backup amplifies impact

## Recommendation

Add epoch transition validation during backup replay. When `ChunkExecutorInner::enqueue_chunks()` detects an epoch boundary, validate that the computed `next_epoch_state` matches the expected validator set from `EpochHistory`.

**Proposed Fix:**

In `execution/executor/src/chunk_executor/mod.rs`, modify `remove_and_replay_epoch()` to accept and validate against `EpochHistory`:

```rust
fn remove_and_replay_epoch(
    &self,
    transactions: &mut Vec<Transaction>,
    persisted_aux_info: &mut Vec<PersistedAuxiliaryInfo>,
    transaction_infos: &mut Vec<TransactionInfo>,
    write_sets: &mut Vec<WriteSet>,
    event_vecs: &mut Vec<Vec<ContractEvent>>,
    begin_version: Version,
    end_version: Version,
    verify_execution_mode: &VerifyExecutionMode,
    epoch_history: Option<&Arc<EpochHistory>>, // ADD THIS
) -> Result<usize> {
    // ... existing code ...
    
    // After applying epoch-ending transaction, validate next_epoch_state
    if is_epoch_ending && epoch_history.is_some() {
        let next_epoch_state = /* extract from write_set */;
        let expected_epoch = /* compute from version */;
        
        // Validate against epoch history
        if expected_epoch < epoch_history.epoch_endings.len() {
            let expected_next_epoch_state = &epoch_history.epoch_endings[expected_epoch]
                .next_epoch_state()
                .ok_or_else(|| anyhow!("Expected epoch ending"))?;
            
            ensure!(
                next_epoch_state == expected_next_epoch_state,
                "Validator set mismatch at epoch transition. Expected: {:?}, Got: {:?}",
                expected_next_epoch_state,
                next_epoch_state
            );
        }
    }
    
    // ... rest of existing code ...
}
```

Pass `epoch_history` from `TransactionRestoreBatchController` through to `enqueue_chunks()` and `remove_and_replay_epoch()`.

## Proof of Concept

```rust
// Rust test demonstrating the vulnerability
#[tokio::test]
async fn test_epoch_boundary_validator_set_bypass() {
    // 1. Create a legitimate backup with epoch N to N+1
    let legitimate_backup = create_backup_with_epoch_transition(/* ... */);
    
    // 2. Craft malicious backup with same structure but manipulated ValidatorSet
    let mut malicious_backup = legitimate_backup.clone();
    let epoch_ending_txn = find_epoch_ending_transaction(&mut malicious_backup);
    
    // 3. Replace ValidatorSet in write_set with unauthorized validators
    replace_validator_set_in_write_set(
        epoch_ending_txn,
        create_malicious_validator_set(/* attacker-controlled validators */)
    );
    
    // 4. Recompute all hashes consistently
    recompute_transaction_info_hashes(&mut malicious_backup);
    recompute_chunk_proof(&mut malicious_backup);
    
    // 5. Keep final LedgerInfo signed by legitimate validators (from later version)
    // This passes EpochHistory validation
    
    // 6. Restore from malicious backup
    let restored_db = restore_from_backup(malicious_backup).await.unwrap();
    
    // 7. Verify the database contains the malicious validator set
    let validator_set_in_db = restored_db.get_validator_set(epoch_n_plus_1);
    assert!(validator_set_in_db.contains_unauthorized_validators());
    
    // 8. Node accepting blocks signed by unauthorized validators
    let malicious_block = create_block_signed_by_unauthorized_validator();
    assert!(restored_db.would_accept_block(malicious_block)); // VULNERABILITY
}
```

**Notes:**

This vulnerability exists because backup replay uses `ReplayChunkVerifier` instead of `StateSyncChunkVerifier`. The latter includes epoch change validation: [7](#0-6) 

The fix should ensure that epoch transitions in backups receive the same validation as live state sync operations, validating computed `next_epoch_state` against the trusted `EpochHistory`.

### Citations

**File:** storage/backup/backup-cli/src/backup_types/transaction/manifest.rs (L17-34)
```rust
/// A chunk of a transaction backup manifest to represent the
/// [`first_version`, `last_version`] range (right side inclusive).
#[derive(Clone, Deserialize, Serialize, Debug)]
pub struct TransactionChunk {
    pub first_version: Version,
    pub last_version: Version,
    /// Repeated `len(record) + record`, where `record` is BCS serialized tuple
    /// `(Transaction, TransactionInfo)`
    pub transactions: FileHandle,
    /// BCS serialized `(TransactionAccumulatorRangeProof, LedgerInfoWithSignatures)`.
    /// The `TransactionAccumulatorRangeProof` links the transactions to the
    /// `LedgerInfoWithSignatures`, and the `LedgerInfoWithSignatures` can be verified by the
    /// signatures it carries, against the validator set in the epoch. (Hence proper
    /// `EpochEndingBackup` is needed for verification.)
    pub proof: FileHandle,
    #[serde(default = "default_to_v0")]
    pub format: TransactionChunkFormat,
}
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L152-154)
```rust
        if let Some(epoch_history) = epoch_history {
            epoch_history.verify_ledger_info(&ledger_info)?;
        }
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L276-312)
```rust
    pub fn verify_ledger_info(&self, li_with_sigs: &LedgerInfoWithSignatures) -> Result<()> {
        let epoch = li_with_sigs.ledger_info().epoch();
        ensure!(!self.epoch_endings.is_empty(), "Empty epoch history.",);
        if epoch > self.epoch_endings.len() as u64 {
            // TODO(aldenhu): fix this from upper level
            warn!(
                epoch = epoch,
                epoch_history_until = self.epoch_endings.len(),
                "Epoch is too new and can't be verified. Previous chunks are verified and node \
                won't be able to start if this data is malicious."
            );
            return Ok(());
        }
        if epoch == 0 {
            ensure!(
                li_with_sigs.ledger_info() == &self.epoch_endings[0],
                "Genesis epoch LedgerInfo info doesn't match.",
            );
        } else if let Some(wp_trusted) = self
            .trusted_waypoints
            .get(&li_with_sigs.ledger_info().version())
        {
            let wp_li = Waypoint::new_any(li_with_sigs.ledger_info());
            ensure!(
                *wp_trusted == wp_li,
                "Waypoints don't match. In backup: {}, trusted: {}",
                wp_li,
                wp_trusted,
            );
        } else {
            self.epoch_endings[epoch as usize - 1]
                .next_epoch_state()
                .ok_or_else(|| anyhow!("Shouldn't contain non- epoch bumping LIs."))?
                .verify(li_with_sigs)?;
        };
        Ok(())
    }
```

**File:** execution/executor/src/chunk_executor/mod.rs (L461-473)
```rust
        // Find epoch boundaries.
        let mut epochs = Vec::new();
        let mut epoch_begin = chunk_begin; // epoch begin version
        for (version, events) in multizip((chunk_begin..chunk_end, event_vecs.iter())) {
            let is_epoch_ending = events.iter().any(ContractEvent::is_new_epoch_event);
            if is_epoch_ending {
                epochs.push((epoch_begin, version + 1));
                epoch_begin = version + 1;
            }
        }
        if epoch_begin < chunk_end {
            epochs.push((epoch_begin, chunk_end));
        }
```

**File:** execution/executor/src/chunk_executor/chunk_result_verifier.rs (L89-117)
```rust
        } else if let Some(epoch_change_li) = &self.epoch_change_li {
            // If the epoch change LI is present, it must match the version of the chunk:
            let li = epoch_change_li.ledger_info();

            // Verify that the given ledger info corresponds to the new accumulator.
            ensure!(
                li.transaction_accumulator_hash() == txn_accumulator.root_hash(),
                "Root hash of a given epoch LI does not match local computation. {:?} vs {:?}",
                li,
                txn_accumulator,
            );
            ensure!(
                li.version() + 1 == txn_accumulator.num_leaves(),
                "Version of a given epoch LI does not match local computation. {:?} vs {:?}",
                li,
                txn_accumulator,
            );
            ensure!(
                li.ends_epoch(),
                "Epoch change LI does not carry validator set. version:{}",
                li.version(),
            );
            ensure!(
                li.next_epoch_state() == next_epoch_state,
                "New validator set of a given epoch LI does not match local computation. {:?} vs {:?}",
                li.next_epoch_state(),
                next_epoch_state,
            );
            Ok(Some(epoch_change_li.clone()))
```

**File:** execution/executor/src/chunk_executor/chunk_result_verifier.rs (L146-152)
```rust
    fn maybe_select_chunk_ending_ledger_info(
        &self,
        _ledger_update_output: &LedgerUpdateOutput,
        _next_epoch_state: Option<&EpochState>,
    ) -> Result<Option<LedgerInfoWithSignatures>> {
        Ok(None)
    }
```

**File:** execution/executor/src/workflow/do_get_execution_output.rs (L520-540)
```rust
    fn ensure_next_epoch_state(to_commit: &TransactionsWithOutput) -> Result<EpochState> {
        let last_write_set = to_commit
            .transaction_outputs
            .last()
            .ok_or_else(|| anyhow!("to_commit is empty."))?
            .write_set();

        let write_set_view = WriteSetStateView {
            write_set: last_write_set,
        };

        let validator_set = ValidatorSet::fetch_config(&write_set_view)
            .ok_or_else(|| anyhow!("ValidatorSet not touched on epoch change"))?;
        let configuration = ConfigurationResource::fetch_config(&write_set_view)
            .ok_or_else(|| anyhow!("Configuration resource not touched on epoch change"))?;

        Ok(EpochState::new(
            configuration.epoch(),
            (&validator_set).into(),
        ))
    }
```
