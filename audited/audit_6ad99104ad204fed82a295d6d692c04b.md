# Audit Report

## Title
Missing Quorum Certificate Validation in Epoch Ending Restore Allows Forged Ledger Infos in Backup System

## Summary
The `EpochEndingRestoreController::preheat_impl()` function fails to validate quorum certificates for the first epoch ending ledger info when no trusted waypoint is provided. This allows an attacker to inject forged `LedgerInfoWithSignatures` with invalid signatures into the database during restoration, which are then served as authentic by `BackupHandler::get_transaction_range_proof()`, compromising backup authenticity and potentially causing consensus safety violations.

## Finding Description
The vulnerability exists in the epoch ending restore verification logic. When restoring epoch ending ledger infos, the code attempts to verify signatures through two mechanisms: trusted waypoints or cryptographic verification against the previous epoch's validator set. [1](#0-0) 

For the **first** ledger info in a restore operation (typically epoch 0), the variable `previous_li` is initialized as `None`. If the user does not provide a trusted waypoint for that specific version, both branches of the if-else statement are skipped, resulting in **zero cryptographic verification** of the quorum certificate. [2](#0-1) 

The unverified ledger info is then added to the collection and subsequently saved to the database: [3](#0-2) [4](#0-3) 

The database storage occurs without any signature validation in the storage layer: [5](#0-4) [6](#0-5) 

Once stored, these forged ledger infos are served by the backup handler without any verification: [7](#0-6) 

**Attack Scenario:**
1. Attacker crafts a malicious epoch 0 backup with a `LedgerInfoWithSignatures` containing forged BLS signatures that do not represent a valid quorum
2. Victim performs database restoration without providing a trusted waypoint for epoch 0 (common in disaster recovery or new node bootstrap scenarios)
3. The forged ledger info passes all checks in `preheat_impl()` because signature verification is skipped
4. The forged ledger info is saved to the database via `restore_handler.save_ledger_infos()`
5. When creating new backups or serving transaction range proofs, `BackupHandler::get_transaction_range_proof()` retrieves and returns this forged ledger info
6. Other nodes restoring from these compromised backups accept the forged state as valid (if they also skip verification)
7. This can lead to chain forks, consensus failures, and acceptance of invalid blockchain state

This breaks the **Consensus Safety** invariant (AptosBFT must prevent chain splits) and the **Cryptographic Correctness** invariant (signatures must be verified).

## Impact Explanation
**Critical Severity** - This vulnerability meets multiple critical impact categories:

1. **Consensus/Safety Violations**: Forged ledger infos with invalid quorum certificates can cause different nodes to accept different blockchain states, violating the fundamental safety property of BFT consensus that prevents chain splits under < 1/3 Byzantine validators.

2. **Backup Authenticity Compromise**: The entire backup/restore system's security model assumes that `LedgerInfoWithSignatures` objects have been properly validated. By injecting unverified ledger infos, an attacker undermines this trust, allowing propagation of invalid state throughout the network.

3. **Potential for Network Partition**: If a significant number of nodes restore from compromised backups, the network could split into groups accepting different ledger histories, potentially requiring a hard fork to resolve.

The attack requires **no privileged access**—only the ability to provide a malicious backup file, making it particularly dangerous for public backup sources or compromised storage systems.

## Likelihood Explanation
**High Likelihood** of exploitation:

1. **Common Scenario**: Restoring without trusted waypoints is a legitimate use case, especially during:
   - Disaster recovery operations
   - New validator node bootstrapping
   - Database migrations
   - Testing and development environments

2. **Low Attack Complexity**: The attacker only needs to:
   - Generate a malicious backup file with forged signatures
   - Host it where victims might use it (compromised backup storage, malicious backup service, etc.)
   - Wait for victims to restore without providing trusted waypoints

3. **Silent Failure**: The vulnerability produces no warnings or errors—the forged data is silently accepted and stored, making detection difficult until consensus failures occur.

## Recommendation
Implement mandatory quorum certificate validation for **all** epoch ending ledger infos during restore, regardless of whether trusted waypoints are provided. The fix should enforce that the first ledger info is always verified through a trusted waypoint.

**Recommended Fix:**

```rust
// In preheat_impl(), after line 128, add mandatory first epoch verification:
if previous_li.is_none() {
    // First ledger info MUST be verified via trusted waypoint
    let wp_trusted = self.trusted_waypoints.get(&wp_li.version())
        .ok_or_else(|| anyhow!(
            "Trusted waypoint required for first epoch ending (epoch {}). \
            Provide via --trusted-waypoint flag to ensure backup authenticity.",
            li.ledger_info().epoch()
        ))?;
    ensure!(
        *wp_trusted == wp_li,
        "First epoch waypoint verification failed. Expected: {}, got: {}",
        wp_trusted,
        wp_li
    );
} else if let Some(wp_trusted) = self.trusted_waypoints.get(&wp_li.version()) {
    // Existing trusted waypoint verification
    ensure!(...);
} else if let Some(pre_li) = previous_li {
    // Existing signature verification
    pre_li.ledger_info().next_epoch_state()...
}
```

Additionally, consider:
1. Adding explicit documentation warnings about the security implications of restoring without trusted waypoints
2. Implementing signature verification in `BackupHandler::get_transaction_range_proof()` as defense-in-depth
3. Adding metrics/logging when ledger infos are stored without signature verification

## Proof of Concept

```rust
// Test demonstrating the vulnerability
#[tokio::test]
async fn test_forged_epoch_zero_bypass() {
    use aptos_crypto::bls12381;
    use aptos_types::ledger_info::LedgerInfoWithSignatures;
    use aptos_types::aggregate_signature::AggregateSignature;
    
    // 1. Create a legitimate epoch 0 ledger info
    let mut ledger_info = LedgerInfo::new(
        BlockInfo::empty(),
        HashValue::zero()
    );
    ledger_info.set_epoch(0);
    
    // 2. Create FORGED signatures (invalid - not from actual validators)
    let fake_private_key = bls12381::PrivateKey::generate_for_testing();
    let fake_signature = fake_private_key.sign(&ledger_info);
    
    // 3. Create LedgerInfoWithSignatures with forged signatures
    let forged_li_with_sigs = LedgerInfoWithSignatures::new(
        ledger_info.clone(),
        AggregateSignature::new(vec![(0, fake_signature)]) // Invalid signature
    );
    
    // 4. Create backup manifest without trusted waypoints
    let manifest = create_backup_manifest(vec![forged_li_with_sigs.clone()]);
    
    // 5. Attempt restoration WITHOUT trusted waypoints
    let restore_controller = EpochEndingRestoreController::new(
        EpochEndingRestoreOpt { manifest_handle: manifest },
        GlobalRestoreOptions {
            trusted_waypoints: Arc::new(HashMap::new()), // EMPTY - no waypoints!
            ...
        },
        storage
    );
    
    // 6. Restoration succeeds despite invalid signatures!
    let result = restore_controller.run(None).await;
    assert!(result.is_ok(), "Forged epoch 0 was accepted without verification!");
    
    // 7. Verify the forged ledger info is now in the database
    let db_ledger_info = restore_handler.aptosdb
        .ledger_db
        .metadata_db()
        .get_latest_ledger_info_in_epoch(0)
        .unwrap();
    
    assert_eq!(db_ledger_info, forged_li_with_sigs);
    
    // 8. Backup handler serves the forged ledger info without verification
    let backup_handler = BackupHandler::new(...);
    let (proof, served_ledger_info) = backup_handler
        .get_transaction_range_proof(0, 0)
        .unwrap();
    
    // The forged ledger info is served as if it were valid!
    assert_eq!(served_ledger_info, forged_li_with_sigs);
    println!("VULNERABILITY CONFIRMED: Forged ledger info served by backup handler!");
}
```

**Notes:**
- The vulnerability affects the integrity of the entire backup/restore system
- It can be exploited silently without any validator privileges
- The impact cascades through the network as compromised backups are shared
- This represents a fundamental break in the chain of trust for Aptos backup authenticity

### Citations

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L88-89)
```rust
        let mut previous_li: Option<&LedgerInfoWithSignatures> = None;
        let mut ledger_infos = Vec::new();
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L129-147)
```rust
                if let Some(wp_trusted) = self.trusted_waypoints.get(&wp_li.version()) {
                    ensure!(
                        *wp_trusted == wp_li,
                        "Waypoints don't match. In backup: {}, trusted: {}",
                        wp_li,
                        wp_trusted,
                    );
                } else if let Some(pre_li) = previous_li {
                    pre_li
                        .ledger_info()
                        .next_epoch_state()
                        .ok_or_else(|| {
                            anyhow!(
                                "Next epoch state not found from LI at epoch {}.",
                                pre_li.ledger_info().epoch()
                            )
                        })?
                        .verify(&li)?;
                }
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L148-149)
```rust
                ledger_infos.push(li);
                previous_li = ledger_infos.last();
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L247-250)
```rust
        match self.controller.run_mode.as_ref() {
            RestoreRunMode::Restore { restore_handler } => {
                restore_handler.save_ledger_infos(&preheat_data.ledger_infos)?;

```

**File:** storage/aptosdb/src/backup/restore_utils.rs (L41-58)
```rust
pub(crate) fn save_ledger_infos(
    ledger_metadata_db: &LedgerMetadataDb,
    ledger_infos: &[LedgerInfoWithSignatures],
    existing_batch: Option<&mut SchemaBatch>,
) -> Result<()> {
    ensure!(!ledger_infos.is_empty(), "No LedgerInfos to save.");

    if let Some(existing_batch) = existing_batch {
        save_ledger_infos_impl(ledger_metadata_db, ledger_infos, existing_batch)?;
    } else {
        let mut batch = SchemaBatch::new();
        save_ledger_infos_impl(ledger_metadata_db, ledger_infos, &mut batch)?;
        ledger_metadata_db.write_schemas(batch)?;
        update_latest_ledger_info(ledger_metadata_db, ledger_infos)?;
    }

    Ok(())
}
```

**File:** storage/aptosdb/src/backup/restore_utils.rs (L179-190)
```rust
fn save_ledger_infos_impl(
    ledger_metadata_db: &LedgerMetadataDb,
    ledger_infos: &[LedgerInfoWithSignatures],
    batch: &mut SchemaBatch,
) -> Result<()> {
    ledger_infos
        .iter()
        .map(|li| ledger_metadata_db.put_ledger_info(li, batch))
        .collect::<Result<Vec<_>>>()?;

    Ok(())
}
```

**File:** storage/aptosdb/src/backup/backup_handler.rs (L113-137)
```rust
    pub fn get_transaction_range_proof(
        &self,
        first_version: Version,
        last_version: Version,
    ) -> Result<(TransactionAccumulatorRangeProof, LedgerInfoWithSignatures)> {
        ensure!(
            last_version >= first_version,
            "Bad transaction range: [{}, {}]",
            first_version,
            last_version
        );
        let num_transactions = last_version - first_version + 1;
        let ledger_metadata_db = self.ledger_db.metadata_db();
        let epoch = ledger_metadata_db.get_epoch(last_version)?;
        let ledger_info = ledger_metadata_db.get_latest_ledger_info_in_epoch(epoch)?;
        let accumulator_proof = self
            .ledger_db
            .transaction_accumulator_db()
            .get_transaction_range_proof(
                Some(first_version),
                num_transactions,
                ledger_info.ledger_info().version(),
            )?;
        Ok((accumulator_proof, ledger_info))
    }
```
