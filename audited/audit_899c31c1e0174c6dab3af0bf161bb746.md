# Audit Report

## Title
Unvalidated State Snapshot Metadata Fields Leading to Potential State Corruption

## Summary
The `handle_snapshot_commit_notification` function in `driver.rs` destructures `CommittedStateSnapshot` without validating the `version` and `last_committed_state_index` fields. More critically, these values originate from unvalidated peer-provided data (`StateValueChunkWithProof.last_index`) and are persisted to metadata storage before the driver receives them. This creates a vulnerability where malicious peers can manipulate the state sync resume point, potentially causing nodes to skip state values on restart.

## Finding Description

The vulnerability exists across two layers:

**Layer 1: Driver Notification Handling (driver.rs)** [1](#0-0) 

The function destructures the notification without any validation. The `version` and `last_committed_state_index` fields are only logged but never checked against actual storage state.

**Layer 2: Upstream Metadata Persistence (storage_synchronizer.rs)** [2](#0-1) 

The root cause: `last_committed_state_index` is extracted directly from peer-provided `StateValueChunkWithProof.last_index` without validation. This untrusted value is then persisted to metadata storage. [3](#0-2) 

**Attack Vector:**
1. Malicious peer sends `StateValueChunkWithProof` with valid cryptographic proof (passes Merkle validation)
2. But includes manipulated `last_index` field (e.g., claiming more state synced than reality)
3. Storage synchronizer extracts: `last_committed_state_index = states_with_proof.last_index` 
4. Unvalidated index persisted to metadata storage [4](#0-3) 

5. Node crashes before completing full sync
6. On restart, node resumes from corrupted index, potentially skipping state values

**Why This Bypasses Validation:**

The `StateValueChunkWithProof` structure contains indices as metadata fields separate from the cryptographically validated proof: [5](#0-4) 

The `SparseMerkleRangeProof` validates state keys and values, but NOT the index sequence numbers.

## Impact Explanation

**Severity: HIGH** (up to $50,000)

This vulnerability violates the **State Consistency** invariant and can cause:

1. **State Corruption**: Nodes may believe they have complete state when they don't, leading to execution failures
2. **Node Availability Issues**: Affected nodes must manually detect and resync, causing downtime
3. **Consensus Impact**: If multiple nodes are affected, could cause temporary consensus disruptions when executing transactions requiring missing state

While not reaching Critical severity (no direct fund loss or permanent chain split), this represents a "Significant protocol violation" per the High severity criteria, as it compromises state synchronization correctness.

## Likelihood Explanation

**Likelihood: MEDIUM**

- **Attacker Requirements**: Must be selected as state sync peer (moderate difficulty)
- **Technical Complexity**: Low - simply modify `last_index` field in `StateValueChunkWithProof`
- **Detection**: Difficult to detect until node restart exposes missing state
- **Mitigation**: Nodes eventually detect incomplete state and resync, but only after operational impact

## Recommendation

**Immediate Fix - Add Validation in Driver:**
```rust
async fn handle_snapshot_commit_notification(
    &mut self,
    commit_notification: CommitNotification,
) {
    let CommitNotification::CommittedStateSnapshot(committed_snapshot) = commit_notification;
    
    // ADDED: Validate snapshot fields against storage
    let actual_version = match utils::fetch_pre_committed_version(self.storage.clone()) {
        Ok(v) => v,
        Err(e) => {
            error!("Failed to fetch version for validation: {:?}", e);
            return;
        }
    };
    
    if committed_snapshot.version != actual_version {
        error!(
            "Snapshot version mismatch! Notification: {}, Storage: {}",
            committed_snapshot.version, actual_version
        );
        return;
    }
    
    // Original logging and processing...
}
```

**Root Cause Fix - Validate in Storage Synchronizer:** [6](#0-5) 

Before line 875, add validation that `states_with_proof.last_index` is consistent with previous chunks and doesn't exceed expected bounds.

## Proof of Concept

**Reproduction Steps:**

1. Setup state sync from malicious peer
2. Peer sends `StateValueChunkWithProof` with:
   - Valid `raw_values` and `proof` (passes Merkle verification)
   - Inflated `last_index` (e.g., 1000 when only 500 values sent)
3. Node accepts chunk, persists wrong index to metadata
4. Trigger node crash (e.g., kill process)
5. Restart node - observes it resumes from index 1000
6. Node skips values 500-999, has incomplete state
7. Subsequent transaction execution fails on missing state

**Test Code Structure (Rust integration test):**
```rust
#[tokio::test]
async fn test_malicious_last_index_corruption() {
    // Create test node with state sync enabled
    // Setup malicious peer returning crafted StateValueChunkWithProof
    // Verify metadata storage contains inflated last_index
    // Simulate restart and verify state inconsistency
}
```

## Notes

The vulnerability has two manifestations:
1. **Driver-level** (line 474): Lacks validation but limited direct impact since fields aren't used
2. **Storage Synchronizer-level** (line 875): Root cause where unvalidated peer data corrupts persistent metadata

Both should be fixed, but the storage synchronizer fix is more critical for preventing exploitation.

### Citations

**File:** state-sync/state-sync-driver/src/driver.rs (L470-492)
```rust
    async fn handle_snapshot_commit_notification(
        &mut self,
        commit_notification: CommitNotification,
    ) {
        let CommitNotification::CommittedStateSnapshot(committed_snapshot) = commit_notification;
        info!(
            LogSchema::new(LogEntry::SynchronizerNotification).message(&format!(
                "Received a state snapshot commit notification from the storage synchronizer. \
                        Snapshot version: {:?}. Last committed index: {:?}.",
                committed_snapshot.version, committed_snapshot.last_committed_state_index,
            ))
        );

        // Handle the committed transactions and events
        utils::handle_committed_transactions(
            committed_snapshot.committed_transaction,
            self.storage.clone(),
            self.mempool_notification_handler.clone(),
            self.event_subscription_service.clone(),
            self.storage_service_notification_handler.clone(),
        )
        .await;
    }
```

**File:** state-sync/state-sync-driver/src/storage_synchronizer.rs (L870-892)
```rust
            // Commit the state value chunk
            match storage_data_chunk {
                StorageDataChunk::States(notification_id, states_with_proof) => {
                    // Commit the state value chunk
                    let all_states_synced = states_with_proof.is_last_chunk();
                    let last_committed_state_index = states_with_proof.last_index;
                    let num_state_values = states_with_proof.raw_values.len();

                    let result = state_snapshot_receiver.add_chunk(
                        states_with_proof.raw_values,
                        states_with_proof.proof.clone(),
                    );

                    // Handle the commit result
                    match result {
                        Ok(()) => {
                            // Update the logs and metrics
                            info!(
                                LogSchema::new(LogEntry::StorageSynchronizer).message(&format!(
                                    "Committed a new state value chunk! Chunk size: {:?}, last persisted index: {:?}",
                                    num_state_values,
                                    last_committed_state_index
                                ))
```

**File:** state-sync/state-sync-driver/src/storage_synchronizer.rs (L909-927)
```rust
                            if !all_states_synced {
                                // Update the metadata storage with the last committed state index
                                if let Err(error) = metadata_storage
                                    .clone()
                                    .update_last_persisted_state_value_index(
                                        &target_ledger_info,
                                        last_committed_state_index,
                                        all_states_synced,
                                    )
                                {
                                    let error = format!("Failed to update the last persisted state index at version: {:?}! Error: {:?}", version, error);
                                    send_storage_synchronizer_error(
                                        error_notification_sender.clone(),
                                        notification_id,
                                        error,
                                    )
                                    .await;
                                }
                                decrement_pending_data_chunks(pending_data_chunks.clone());
```

**File:** state-sync/state-sync-driver/src/metadata_storage.rs (L201-227)
```rust
    fn update_last_persisted_state_value_index(
        &self,
        target_ledger_info: &LedgerInfoWithSignatures,
        last_persisted_state_value_index: u64,
        snapshot_sync_completed: bool,
    ) -> Result<(), Error> {
        // Ensure that if any previous snapshot progress exists, it has the same target
        if let Some(snapshot_progress) = self.get_snapshot_progress()? {
            if target_ledger_info != &snapshot_progress.target_ledger_info {
                return Err(Error::StorageError(format!("Failed to update the last persisted state value index! \
                The given target does not match the previously stored target. Given target: {:?}, stored target: {:?}",
                    target_ledger_info, snapshot_progress.target_ledger_info
                )));
            }
        }

        // Create the key/value pair
        let metadata_key = MetadataKey::StateSnapshotSync;
        let metadata_value = MetadataValue::StateSnapshotSync(StateSnapshotProgress {
            last_persisted_state_value_index,
            snapshot_sync_completed,
            target_ledger_info: target_ledger_info.clone(),
        });

        // Insert the new key/value pair
        self.commit_key_value(metadata_key, metadata_value)
    }
```

**File:** types/src/state_store/state_value.rs (L345-353)
```rust
pub struct StateValueChunkWithProof {
    pub first_index: u64,     // The first hashed state index in chunk
    pub last_index: u64,      // The last hashed state index in chunk
    pub first_key: HashValue, // The first hashed state key in chunk
    pub last_key: HashValue,  // The last hashed state key in chunk
    pub raw_values: Vec<(StateKey, StateValue)>, // The hashed state key and and raw state value.
    pub proof: SparseMerkleRangeProof, // The proof to ensure the chunk is in the hashed states
    pub root_hash: HashValue, // The root hash of the sparse merkle tree for this chunk
}
```
