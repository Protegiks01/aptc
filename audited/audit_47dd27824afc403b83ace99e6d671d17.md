# Audit Report

## Title
State Sync Metadata Storage Lacks Version Compatibility for Downgrades

## Summary
The state sync metadata storage uses BCS-serialized enums without version markers or compatibility handling. If a future version adds new enum variants and a node is subsequently downgraded, the downgraded node will fail to deserialize the metadata, causing bootstrap failure and rendering the node non-functional.

## Finding Description

The `PersistentMetadataStorage` in `state-sync/state-sync-driver/src/metadata_storage.rs` stores metadata using BCS-serialized enums `MetadataKey` and `MetadataValue`. [1](#0-0) 

Both enums currently have only one variant (`StateSnapshotSync`), but use `#[repr(u8)]` which provides no forward/backward compatibility guarantees. BCS serialization includes the variant discriminant, and deserialization will fail if an unknown discriminant is encountered.

**Failure Scenario:**

1. Future version N+1 adds new enum variants (e.g., `MetadataKey::NewFeature`)
2. Node operator upgrades to N+1, which writes the new variants to RocksDB
3. Operator downgrades to version N for any reason (rollback, bug, etc.)
4. On startup, `PersistentMetadataStorage::new()` opens the database successfully [2](#0-1) 
5. The bootstrapper calls `previous_snapshot_sync_target()` during initialization [3](#0-2) 
6. This triggers `get_snapshot_progress()` which reads from the database [4](#0-3) 
7. The `decode_value()` method calls `bcs::from_bytes::<MetadataValue>(data)` [5](#0-4) 
8. BCS deserialization fails with an error like "unknown variant index: 1"
9. The error propagates as `StorageError` [6](#0-5) 
10. The driver catches and logs the error but continues retrying indefinitely [7](#0-6) 

The node enters an infinite error loop, unable to bootstrap, making it non-functional for state synchronization and consensus participation.

## Impact Explanation

This qualifies as **High Severity** under the Aptos bug bounty criteria for "Validator node slowdowns" and "Significant protocol violations":

- **Node Availability**: Downgraded nodes cannot start properly, entering a permanent failure state
- **Validator Impact**: If a validator downgrades, it cannot participate in consensus, reducing network liveness
- **Manual Intervention Required**: Operators must either re-upgrade or delete the `state_sync_db` directory
- **No Data Corruption**: The data remains intact; it's simply unreadable by the older version
- **Not Critical**: This is recoverable and doesn't require a hardfork

The issue affects operational availability rather than causing fund loss or consensus safety violations.

## Likelihood Explanation

**Moderate to Low Likelihood:**

- Requires a future version to add new enum variants to `MetadataKey` or `MetadataValue` (hasn't happened yet)
- Requires node operators to perform downgrades, which is uncommon in production
- Most operators upgrade and stay on the new version
- Downgrades typically only occur during critical bug rollbacks

However, when it does occur, the impact is severe (complete node failure), making this a valid concern for production systems.

## Recommendation

Implement version-aware metadata storage with forward/backward compatibility:

**Option 1: Add Version Wrapper**
```rust
#[derive(Debug, Deserialize, Serialize)]
pub struct VersionedMetadata {
    version: u8,
    data: MetadataValue,
}
```

**Option 2: Use Tagged Union with Unknown Variant Handler**
```rust
#[derive(Debug, Deserialize, Serialize)]
pub enum MetadataValue {
    StateSnapshotSync(StateSnapshotProgress),
    #[serde(other)]
    Unknown, // Gracefully handle unknown variants
}
```

**Option 3: Database Migration on Startup**
Check metadata format version during `PersistentMetadataStorage::new()` and either:
- Migrate incompatible data to a compatible format
- Clear incompatible metadata with a warning
- Prevent startup with a clear error message

**Recommended Implementation:**
Add a version check and graceful degradation:
```rust
fn get_snapshot_progress(&self) -> Result<Option<StateSnapshotProgress>, Error> {
    let metadata_key = MetadataKey::StateSnapshotSync;
    let maybe_metadata_value = self.database
        .get::<MetadataSchema>(&metadata_key)
        .map_err(|error| {
            // Check if deserialization failed due to unknown variant
            if error.to_string().contains("unknown variant") {
                warn!("Incompatible metadata format detected. Clearing metadata.");
                return Error::UnexpectedError("Metadata format incompatible, cleared".into());
            }
            Error::StorageError(format!("Failed to read metadata value: {:?}", error))
        })?;
    // ... rest of implementation
}
```

## Proof of Concept

This vulnerability cannot be fully demonstrated in the current codebase because it requires future enum variants. However, here's a reproduction approach:

**Step 1: Simulate Future Version**
```rust
// In a modified version of metadata_storage.rs
#[derive(Debug, Deserialize, Eq, PartialEq, Serialize)]
#[repr(u8)]
pub enum MetadataKey {
    StateSnapshotSync,
    NewFeature, // Simulate future variant
}

#[derive(Debug, Deserialize, Eq, PartialEq, Serialize)]
#[repr(u8)]
pub enum MetadataValue {
    StateSnapshotSync(StateSnapshotProgress),
    NewFeature(u64), // Simulate future variant
}
```

**Step 2: Write New Variant**
```rust
#[test]
fn test_downgrade_compatibility() {
    let tmp_dir = TempPath::new();
    let metadata_storage = PersistentMetadataStorage::new(tmp_dir.path());
    
    // Write using "new" variant
    metadata_storage.commit_key_value(
        MetadataKey::NewFeature,
        MetadataValue::NewFeature(12345)
    ).unwrap();
    
    drop(metadata_storage);
    
    // Revert enum to only StateSnapshotSync
    // Reopen database - this would fail with deserialization error
    let metadata_storage = PersistentMetadataStorage::new(tmp_dir.path());
    let result = metadata_storage.get_snapshot_progress();
    
    // This will fail with "unknown variant" error
    assert!(result.is_err());
}
```

**Notes:**
The same vulnerability pattern exists in the main `DbMetadataSchema` [8](#0-7)  which has many more enum variants and could face similar issues during downgrades.

### Citations

**File:** state-sync/state-sync-driver/src/metadata_storage.rs (L66-95)
```rust
    pub fn new<P: AsRef<Path> + Clone>(db_root_path: P) -> Self {
        // Set the options to create the database if it's missing
        let mut options = Options::default();
        options.create_if_missing(true);
        options.create_missing_column_families(true);

        // Open the database
        let state_sync_db_path = db_root_path.as_ref().join(STATE_SYNC_DB_NAME);
        let instant = Instant::now();
        let database = DB::open(
            state_sync_db_path.clone(),
            "state_sync",
            vec![METADATA_CF_NAME],
            &options,
        )
        .unwrap_or_else(|error| {
            panic!(
                "Failed to open/create the state sync database at: {:?}. Error: {:?}",
                state_sync_db_path, error
            )
        });
        info!(
            "Opened the state sync database at: {:?}, in {:?} ms",
            state_sync_db_path,
            instant.elapsed().as_millis()
        );

        let database = Arc::new(database);
        Self { database }
    }
```

**File:** state-sync/state-sync-driver/src/metadata_storage.rs (L98-116)
```rust
    fn get_snapshot_progress(&self) -> Result<Option<StateSnapshotProgress>, Error> {
        let metadata_key = MetadataKey::StateSnapshotSync;
        let maybe_metadata_value =
            self.database
                .get::<MetadataSchema>(&metadata_key)
                .map_err(|error| {
                    Error::StorageError(format!(
                        "Failed to read metadata value for key: {:?}. Error: {:?}",
                        metadata_key, error
                    ))
                })?;
        match maybe_metadata_value {
            Some(metadata_value) => {
                let MetadataValue::StateSnapshotSync(snapshot_progress) = metadata_value;
                Ok(Some(snapshot_progress))
            },
            None => Ok(None),
        }
    }
```

**File:** state-sync/state-sync-driver/src/metadata_storage.rs (L254-263)
```rust
    pub enum MetadataKey {
        StateSnapshotSync, // A state snapshot sync that was started
    }

    /// A metadata value that can be inserted into the database
    #[derive(Debug, Deserialize, Eq, PartialEq, Serialize)]
    #[repr(u8)]
    pub enum MetadataValue {
        StateSnapshotSync(StateSnapshotProgress), // A state snapshot sync progress marker
    }
```

**File:** state-sync/state-sync-driver/src/metadata_storage.rs (L298-306)
```rust
        fn decode_value(data: &[u8]) -> Result<Self> {
            bcs::from_bytes::<MetadataValue>(data).map_err(|error| {
                anyhow!(
                    "Failed to decode metadata value: {:?}. Error: {:?}",
                    data,
                    error
                )
            })
        }
```

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L522-522)
```rust
            if let Some(target) = self.metadata_storage.previous_snapshot_sync_target()? {
```

**File:** state-sync/state-sync-driver/src/driver.rs (L711-719)
```rust
        } else if let Err(error) = self.bootstrapper.drive_progress(&global_data_summary).await {
            sample!(
                    SampleRate::Duration(Duration::from_secs(DRIVER_ERROR_LOG_FREQ_SECS)),
                    warn!(LogSchema::new(LogEntry::Driver)
                        .error(&error)
                        .message("Error found when checking the bootstrapper progress!"));
            );
            metrics::increment_counter(&metrics::BOOTSTRAPPER_ERRORS, error.get_label());
        };
```

**File:** storage/aptosdb/src/schema/db_metadata/mod.rs (L74-99)
```rust
define_schema!(
    DbMetadataSchema,
    DbMetadataKey,
    DbMetadataValue,
    DB_METADATA_CF_NAME
);

impl KeyCodec<DbMetadataSchema> for DbMetadataKey {
    fn encode_key(&self) -> Result<Vec<u8>> {
        Ok(bcs::to_bytes(self)?)
    }

    fn decode_key(data: &[u8]) -> Result<Self> {
        Ok(bcs::from_bytes(data)?)
    }
}

impl ValueCodec<DbMetadataSchema> for DbMetadataValue {
    fn encode_value(&self) -> Result<Vec<u8>> {
        Ok(bcs::to_bytes(self)?)
    }

    fn decode_value(data: &[u8]) -> Result<Self> {
        Ok(bcs::from_bytes(data)?)
    }
}
```
