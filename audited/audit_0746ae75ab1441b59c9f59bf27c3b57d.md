# Audit Report

## Title
Mempool DoS via Sponsored Transactions from Non-Existent Accounts

## Summary
When the `sponsored_automatic_account_creation` feature is enabled, the transaction validation logic bypasses sender account existence checks for sponsored transactions with sequence number 0. This allows an attacker to flood the mempool with transactions from unlimited non-existent sender addresses, causing mempool exhaustion and denial of service for legitimate transactions.

## Finding Description

The vulnerability exists in the transaction validation flow where sponsored account creation bypasses critical sender validation checks. The attack exploits the interaction between three components:

**1. Validation Bypass in Prologue** [1](#0-0) 

The `check_for_replay_protection_regular_txn` function contains a conditional bypass: when a transaction is sponsored (sender ≠ gas_payer), the account doesn't exist, the `sponsored_automatic_account_creation` feature is enabled, and sequence number is 0, the sender account existence check is **completely skipped**. The else branch (lines 242-249) only validates that sequence number equals 0, without verifying the sender account exists.

**2. Authentication Key Check Bypass** [2](#0-1) 

The authentication key validation in `prologue_common` also bypasses verification for sponsored account creation scenarios (lines 151-160). When the sender address doesn't exist and it's a sponsored transaction, no authentication key check is performed.

**3. Mempool Per-Sender Tracking** [3](#0-2) 

The mempool tracks transactions by sender address (line 241) and enforces per-sender capacity limits. Since each non-existent sender address is tracked separately, an attacker can bypass the per-user transaction limit by using different sender addresses.

**Attack Path:**

1. Attacker controls one funded account (fee_payer)
2. Attacker generates N unique addresses (sender₁, sender₂, ..., senderₙ) that don't exist on-chain
3. For each sender_i, attacker creates a transaction with:
   - `sender` = sender_i (non-existent)
   - `fee_payer` = attacker's funded account  
   - `sequence_number` = 0
   - Minimal `gas_price` and `max_gas_units` to reduce costs
   - Any valid payload (e.g., empty entry function)
4. All transactions pass validation via the bypass described above
5. Mempool accepts all N transactions since each sender_i has only 1 transaction (under the 100 per-user limit)
6. Mempool becomes saturated with transactions from non-existent accounts
7. Legitimate user transactions are rejected with `MempoolIsFull` or `TooManyTransactions` errors [4](#0-3) 

## Impact Explanation

**High Severity** per Aptos bug bounty criteria:
- **Validator node slowdowns**: Processing and maintaining thousands of invalid transactions in mempool increases CPU and memory usage across all validator nodes
- **Network-wide denial of service**: Legitimate transactions cannot enter the mempool when capacity is exhausted, preventing normal network operation
- **Mempool resource exhaustion**: The attack consumes mempool capacity that should be reserved for valid transactions

The vulnerability violates the documented invariant: "Resource Limits: All operations must respect gas, storage, and computational limits." By bypassing sender validation, the system allows unbounded mempool pollution from non-existent accounts.

## Likelihood Explanation

**High Likelihood:**
- Attack requires only one funded account (low barrier to entry)
- No special permissions or validator access required
- When `sponsored_automatic_account_creation` feature is enabled (likely on mainnet to support sponsored onboarding), the bypass is always active
- Attack can be executed repeatedly as old transactions expire or are executed
- Economic cost to attacker is relatively low (can use minimal gas prices and let transactions expire)

## Recommendation

Implement a mempool-level validation that checks if the sender account exists before accepting transactions, even for sponsored account creation scenarios. This prevents mempool pollution while preserving the sponsored account creation feature for legitimate use cases.

**Proposed Fix:**

Add an early validation check in the mempool admission logic before VM validation:

```rust
// In mempool/src/shared_mempool/tasks.rs or similar
fn pre_validate_transaction(
    txn: &SignedTransaction,
    state_view: &impl StateView,
    features: &Features,
) -> Result<(), MempoolStatusCode> {
    // For sponsored account creation, verify fee payer relationship
    if features.is_enabled(FeatureFlag::SPONSORED_AUTOMATIC_ACCOUNT_V1_CREATION) {
        if let Some(fee_payer) = txn.fee_payer() {
            let sender = txn.sender();
            if sender != fee_payer && txn.sequence_number() == 0 {
                // Limit sponsored account creation to pre-registered whitelist or
                // implement rate limiting per fee_payer for non-existent senders
                if !account_exists(state_view, &sender) {
                    // Count towards fee_payer's transaction limit, not sender's
                    // OR require sender to be pre-registered somehow
                    return Err(MempoolStatusCode::InvalidAccountAuth);
                }
            }
        }
    }
    Ok(())
}
```

Alternatively, track sponsored transactions for non-existent accounts by **fee_payer** address in mempool capacity calculations, not by sender address.

## Proof of Concept

```rust
#[test]
fn test_mempool_dos_via_sponsored_nonexistent_accounts() {
    // Setup: Enable sponsored account creation feature
    let mut features = Features::default();
    features.enable(FeatureFlag::SPONSORED_AUTOMATIC_ACCOUNT_V1_CREATION);
    
    // Create one funded account (attacker's fee payer)
    let fee_payer = generate_funded_account(1_000_000_000); // 1000 APT
    
    // Generate 1000 non-existent sender addresses
    let non_existent_senders: Vec<AccountAddress> = (0..1000)
        .map(|i| AccountAddress::random())
        .collect();
    
    // Create transactions from each non-existent sender
    let mut transactions = vec![];
    for sender in non_existent_senders {
        let txn = create_sponsored_transaction(
            sender,           // non-existent sender
            fee_payer.address(), // funded fee payer
            0,                // sequence number
            vec![],          // empty payload
            1,               // minimal gas price
            1000,            // minimal max gas units
        );
        transactions.push(txn);
    }
    
    // Submit all transactions to mempool
    let mempool = setup_mempool();
    let mut accepted = 0;
    for txn in transactions {
        // These should all pass validation due to the bypass
        if let Ok(_) = mempool.add_transaction(txn, state_view, module_storage) {
            accepted += 1;
        }
    }
    
    // Verify mempool is saturated with transactions from non-existent accounts
    assert!(accepted > 900, "Most transactions should be accepted");
    
    // Attempt to submit a legitimate transaction
    let legitimate_user = generate_funded_account(1_000_000);
    let legitimate_txn = create_user_transaction(legitimate_user);
    
    // Should be rejected due to mempool being full
    assert_eq!(
        mempool.add_transaction(legitimate_txn, state_view, module_storage),
        Err(MempoolStatusCode::MempoolIsFull)
    );
}
```

### Citations

**File:** aptos-move/framework/aptos-framework/sources/transaction_validation.move (L148-167)
```text
        // Check if the authentication key is valid
        if (!skip_auth_key_check(is_simulation, &txn_authentication_key)) {
            if (option::is_some(&txn_authentication_key)) {
                if (
                    sender_address == gas_payer_address ||
                    account::exists_at(sender_address) ||
                    !features::sponsored_automatic_account_creation_enabled()
                ) {
                    assert!(
                        txn_authentication_key == option::some(account::get_authentication_key(sender_address)),
                        error::invalid_argument(PROLOGUE_EINVALID_ACCOUNT_AUTH_KEY),
                    );
                };
            } else {
                assert!(
                    allow_missing_txn_authentication_key(sender_address),
                    error::invalid_argument(PROLOGUE_EINVALID_ACCOUNT_AUTH_KEY)
                );
            };
        };
```

**File:** aptos-move/framework/aptos-framework/sources/transaction_validation.move (L215-250)
```text
    fun check_for_replay_protection_regular_txn(
        sender_address: address,
        gas_payer_address: address,
        txn_sequence_number: u64,
    ) {
        if (
            sender_address == gas_payer_address
                || account::exists_at(sender_address)
                || !features::sponsored_automatic_account_creation_enabled()
                || txn_sequence_number > 0
        ) {
            assert!(account::exists_at(sender_address), error::invalid_argument(PROLOGUE_EACCOUNT_DOES_NOT_EXIST));
            let account_sequence_number = account::get_sequence_number(sender_address);
            assert!(
                txn_sequence_number < (1u64 << 63),
                error::out_of_range(PROLOGUE_ESEQUENCE_NUMBER_TOO_BIG)
            );

            assert!(
                txn_sequence_number >= account_sequence_number,
                error::invalid_argument(PROLOGUE_ESEQUENCE_NUMBER_TOO_OLD)
            );

            assert!(
                txn_sequence_number == account_sequence_number,
                error::invalid_argument(PROLOGUE_ESEQUENCE_NUMBER_TOO_NEW)
            );
        } else {
            // In this case, the transaction is sponsored and the account does not exist, so ensure
            // the default values match.
            assert!(
                txn_sequence_number == 0,
                error::invalid_argument(PROLOGUE_ESEQUENCE_NUMBER_TOO_NEW)
            );
        };
    }
```

**File:** mempool/src/core_mempool/transaction_store.rs (L234-250)
```rust
    pub(crate) fn insert(
        &mut self,
        txn: MempoolTransaction,
        // For orderless transactions, account_sequence_number is None
        // For sequence number transactions, account_sequence_number is Some(u64)
        account_sequence_number: Option<u64>,
    ) -> MempoolStatus {
        let address = txn.get_sender();
        let txn_replay_protector = txn.get_replay_protector();

        let account_sequence_number = account_sequence_number.map(|seq_num| {
            max(
                seq_num,
                self.get_account_sequence_number(&address).map_or(0, |v| *v),
            )
        });

```

**File:** mempool/src/core_mempool/transaction_store.rs (L311-317)
```rust
        if self.check_is_full_after_eviction(&txn, account_sequence_number) {
            return MempoolStatus::new(MempoolStatusCode::MempoolIsFull).with_message(format!(
                "Mempool is full. Mempool size: {}, Capacity: {}",
                self.system_ttl_index.size(),
                self.capacity,
            ));
        }
```
