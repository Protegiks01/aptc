# Audit Report

## Title
Netbench Protocol Abuse Enables Validator Resource Exhaustion via Automatic Traffic Generation

## Summary
The netbench service automatically spawns resource-intensive benchmark traffic sender tasks for every connected peer without proper access control or runtime enforcement, enabling resource exhaustion attacks on validators if the feature is misconfigured in production environments.

## Finding Description

The netbench feature is designed as a network benchmarking tool but contains a critical design flaw: when enabled, it automatically spawns continuous traffic generation tasks for every peer that establishes a network connection, without verifying whether that peer consented to participate in benchmarking or whether the feature should be active in a production environment.

The vulnerability manifests through three attack vectors:

**Attack Vector 1: Weak Protection Mechanism**

The only protection against enabling netbench in production is a configuration sanitizer that can be bypassed: [1](#0-0) 

This sanitizer only prevents netbench on testnet/mainnet ChainIds and can be completely disabled: [2](#0-1) 

**Attack Vector 2: Automatic Resource Consumption**

When netbench is enabled, it registers on ALL networks (validator and fullnode): [3](#0-2) 

The netbench service's connection listener automatically spawns sender tasks for every new peer: [4](#0-3) 

These sender tasks run in infinite loops, continuously generating traffic at configurable rates: [5](#0-4) 

**Attack Vector 3: Bidirectional Traffic Amplification**

Not only does the victim node automatically send benchmark traffic to connected peers, but it also processes incoming netbench messages without additional rate limiting: [6](#0-5) 

**Exploitation Path:**

1. Validator operator misconfigures node with netbench enabled (either by setting `skip_config_sanitizer = true` or running on a non-testnet/mainnet network)
2. Attacker establishes an authenticated network connection to the validator
3. Victim validator automatically spawns `direct_sender()` and/or `rpc_sender()` tasks
4. These tasks continuously send messages (default: 1,000 messages/sec Ã— 100 KB = ~100 MB/sec per peer)
5. Attacker can simultaneously send netbench messages to the victim, which are processed and replied to
6. Resources consumed: network bandwidth, CPU (serialization/deserialization), memory (message buffers), dedicated thread pool

This breaks **Invariant #9 (Resource Limits)**: "All operations must respect gas, storage, and computational limits" - the netbench service spawns unbounded traffic generation tasks without proper access control or resource limits.

## Impact Explanation

This vulnerability qualifies as **HIGH severity** under the Aptos Bug Bounty criteria:

- **Validator node slowdowns**: The automatic generation of continuous benchmark traffic (up to 100 MB/sec with default settings) can exhaust network bandwidth and CPU resources, directly degrading validator performance
- **Consensus impact**: Resource exhaustion can delay block processing, proposal generation, and vote propagation, potentially affecting network liveness
- **Amplification attack**: Multiple malicious peers can connect simultaneously, multiplying the resource consumption

The default configuration sends 1,000 messages per second with 100 KB payloads per message type (direct send + RPC), resulting in ~200 MB/sec of outbound traffic per connected peer. With multiple peers, this can saturate validator network links and CPU capacity.

## Likelihood Explanation

The likelihood is **MEDIUM** for the following reasons:

**Factors Increasing Likelihood:**
- The sanitizer can be bypassed by setting a single configuration flag (`skip_config_sanitizer = true`)
- The sanitizer only checks for specific ChainIds (testnet/mainnet), not all production environments
- Custom networks, devnets, or staging environments could run with netbench enabled
- No runtime enforcement mechanism exists beyond the bypassable sanitizer
- The automatic spawning behavior is not obvious to operators and may be enabled unknowingly

**Factors Decreasing Likelihood:**
- Requires operator misconfiguration to enable netbench
- Sanitizer provides warnings for testnet/mainnet
- Documentation likely warns against production use
- Attacker needs network-level authentication (though this varies by network type)

## Recommendation

Implement multi-layered runtime protection for the netbench feature:

**1. Add Runtime Chain ID Check**
```rust
pub async fn run_netbench_service(
    node_config: NodeConfig,
    network_client: NetworkClient<NetbenchMessage>,
    network_requests: NetworkServiceEvents<NetbenchMessage>,
    time_service: TimeService,
) {
    // Add runtime check that cannot be bypassed
    let chain_id = /* get current chain_id from network context */;
    if chain_id.is_testnet() || chain_id.is_mainnet() {
        warn!("Netbench service disabled: production environment detected");
        return;
    }
    
    // ... rest of implementation
}
```

**2. Require Mutual Opt-In for Benchmarking**
Add a handshake protocol where both peers must explicitly agree to participate in benchmarking before sender tasks are spawned.

**3. Add Per-Protocol Rate Limiting**
Implement rate limiting specifically for netbench messages, independent of global network rate limits:

```rust
pub fn netbench_network_configuration(
    node_config: &NodeConfig,
) -> Option<NetworkApplicationConfig> {
    let cfg = node_config.netbench?;
    if !cfg.enabled {
        return None;
    }
    
    // Add rate limiting config
    let rate_limit_config = Some(RateLimitConfig {
        ip_byte_bucket_rate: 102400, // 100 KB/sec max
        ip_byte_bucket_size: 102400,
    });
    
    // ... rest of configuration
}
```

**4. Remove Automatic Sender Task Spawning**
Modify the connection listener to require explicit requests before spawning sender tasks, rather than automatically starting them for all peers.

## Proof of Concept

```rust
// Reproduction steps (requires Rust test environment):

#[tokio::test]
async fn test_netbench_resource_exhaustion() {
    // 1. Create a node configuration with netbench enabled
    let mut node_config = NodeConfig::default();
    node_config.netbench = Some(NetbenchConfig {
        enabled: true,
        enable_direct_send_testing: true,
        enable_rpc_testing: true,
        direct_send_per_second: 1000,
        direct_send_data_size: 100 * 1024, // 100 KB
        rpc_per_second: 1000,
        rpc_data_size: 100 * 1024,
        ..Default::default()
    });
    
    // 2. Bypass the sanitizer (demonstrating the vulnerability)
    node_config.node_startup.skip_config_sanitizer = true;
    
    // 3. Set up validator network with netbench
    let chain_id = ChainId::test(); // Not testnet/mainnet, bypasses sanitizer
    let peers_and_metadata = create_peers_and_metadata(&node_config);
    
    // 4. Start the network services
    let (runtimes, _, _, _, _, _, _, _) = setup_networks_and_get_interfaces(
        &node_config,
        chain_id,
        peers_and_metadata.clone(),
        &mut EventSubscriptionService::new(),
    );
    
    // 5. Simulate attacker connecting as a peer
    // The victim node will automatically spawn sender tasks that:
    // - Send 1000 direct_send messages/sec * 100 KB = ~100 MB/sec
    // - Send 1000 RPC messages/sec * 100 KB = ~100 MB/sec
    // - Total: ~200 MB/sec of continuous traffic per connected peer
    
    // 6. Monitor resource consumption
    tokio::time::sleep(Duration::from_secs(10)).await;
    
    // Verify that bandwidth exhaustion occurs without proper rate limiting
    // Verify that CPU usage increases significantly
    // Verify that multiple peers can amplify the attack
}
```

**Notes**

The vulnerability exists because the netbench feature violates the principle of least privilege - it automatically initiates resource-intensive operations for all connected peers without explicit authorization. While the configuration sanitizer attempts to prevent production deployment, it provides insufficient protection through multiple bypass mechanisms and limited scope checking. The automatic spawning of benchmark traffic generators represents an access control failure that could be exploited on misconfigured validators, particularly on custom networks or environments where the sanitizer's testnet/mainnet checks don't apply. This is distinct from generic network-level DoS attacks as it exploits an application-layer protocol feature that lacks proper runtime enforcement and authorization controls.

### Citations

**File:** config/src/config/netbench_config.rs (L46-78)
```rust
impl ConfigSanitizer for NetbenchConfig {
    fn sanitize(
        node_config: &NodeConfig,
        _node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();

        // If no netbench config is specified, there's nothing to do
        if node_config.netbench.is_none() {
            return Ok(());
        }

        // If netbench is disabled, there's nothing to do
        let netbench_config = node_config.netbench.unwrap();
        if !netbench_config.enabled {
            return Ok(());
        }

        // Otherwise, verify that netbench is not enabled in testnet or mainnet
        if let Some(chain_id) = chain_id {
            if chain_id.is_testnet() || chain_id.is_mainnet() {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "The netbench application should not be enabled in testnet or mainnet!"
                        .to_string(),
                ));
            }
        }

        Ok(())
    }
}
```

**File:** config/src/config/config_sanitizer.rs (L40-70)
```rust
    fn sanitize(
        node_config: &NodeConfig,
        node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        // If config sanitization is disabled, don't do anything!
        if node_config.node_startup.skip_config_sanitizer {
            return Ok(());
        }

        // Sanitize all of the sub-configs
        AdminServiceConfig::sanitize(node_config, node_type, chain_id)?;
        ApiConfig::sanitize(node_config, node_type, chain_id)?;
        BaseConfig::sanitize(node_config, node_type, chain_id)?;
        ConsensusConfig::sanitize(node_config, node_type, chain_id)?;
        DagConsensusConfig::sanitize(node_config, node_type, chain_id)?;
        ExecutionConfig::sanitize(node_config, node_type, chain_id)?;
        sanitize_failpoints_config(node_config, node_type, chain_id)?;
        sanitize_fullnode_network_configs(node_config, node_type, chain_id)?;
        IndexerGrpcConfig::sanitize(node_config, node_type, chain_id)?;
        InspectionServiceConfig::sanitize(node_config, node_type, chain_id)?;
        LoggerConfig::sanitize(node_config, node_type, chain_id)?;
        MempoolConfig::sanitize(node_config, node_type, chain_id)?;
        NetbenchConfig::sanitize(node_config, node_type, chain_id)?;
        StateSyncConfig::sanitize(node_config, node_type, chain_id)?;
        StorageConfig::sanitize(node_config, node_type, chain_id)?;
        InternalIndexerDBConfig::sanitize(node_config, node_type, chain_id)?;
        sanitize_validator_network_config(node_config, node_type, chain_id)?;

        Ok(()) // All configs passed validation
    }
```

**File:** aptos-node/src/network.rs (L390-400)
```rust
        // Register the network benchmark test service
        if let Some(app_config) = netbench_network_configuration(node_config) {
            let netbench_handle = register_client_and_service_with_network(
                &mut network_builder,
                network_id,
                &network_config,
                app_config,
                true,
            );
            netbench_handles.push(netbench_handle);
        }
```

**File:** network/benchmark/src/lib.rs (L92-140)
```rust
async fn handle_direct(
    network_client: &NetworkClient<NetbenchMessage>,
    network_id: NetworkId,
    peer_id: AccountAddress,
    msg_wrapper: NetbenchMessage,
    time_service: TimeService,
    shared: Arc<RwLock<NetbenchSharedState>>,
) {
    match msg_wrapper {
        NetbenchMessage::DataSend(send) => {
            let reply = NetbenchDataReply {
                request_counter: send.request_counter,
                send_micros: time_service.now_unix_time().as_micros() as u64,
                request_send_micros: send.send_micros,
            };
            let result = network_client.send_to_peer(
                NetbenchMessage::DataReply(reply),
                PeerNetworkId::new(network_id, peer_id),
            );
            if let Err(err) = result {
                direct_messages("reply_err");
                info!(
                    "netbench ds [{}] could not reply: {}",
                    send.request_counter, err
                );
            }
        },
        NetbenchMessage::DataReply(reply) => {
            let receive_time = time_service.now_unix_time().as_micros() as u64;
            let rec = {
                let reader = shared.read().await;
                reader.find(reply.request_counter)
            };
            if rec.request_counter == reply.request_counter {
                let micros = receive_time - rec.send_micros;
                direct_messages("ok");
                direct_micros("ok", micros);
                direct_bytes("ok", rec.bytes_sent as u64);
            } else {
                direct_messages("late");
                info!(
                    "netbench ds [{}] unknown bytes in > {} micros",
                    reply.request_counter,
                    receive_time - rec.send_micros
                )
            }
        },
    }
}
```

**File:** network/benchmark/src/lib.rs (L282-338)
```rust
async fn connection_listener(
    node_config: NodeConfig,
    network_client: NetworkClient<NetbenchMessage>,
    time_service: TimeService,
    shared: Arc<RwLock<NetbenchSharedState>>,
    handle: Handle,
) {
    let config = node_config.netbench.unwrap();
    let peers_and_metadata = network_client.get_peers_and_metadata();
    let mut connected_peers = HashSet::new();
    let mut connection_notifications = peers_and_metadata.subscribe();
    loop {
        match connection_notifications.recv().await {
            None => {
                info!("netbench connection_listener exit");
                return;
            },
            Some(note) => match note {
                ConnectionNotification::NewPeer(meta, network_id) => {
                    let peer_network_id = PeerNetworkId::new(network_id, meta.remote_peer_id);
                    if connected_peers.contains(&peer_network_id) {
                        continue;
                    }
                    info!(
                        "netbench connection_listener new {:?} {:?}",
                        meta, network_id
                    );
                    if config.enable_direct_send_testing {
                        handle.spawn(direct_sender(
                            node_config.clone(),
                            network_client.clone(),
                            time_service.clone(),
                            network_id,
                            meta.remote_peer_id,
                            shared.clone(),
                        ));
                    }
                    if config.enable_rpc_testing {
                        handle.spawn(rpc_sender(
                            node_config.clone(),
                            network_client.clone(),
                            time_service.clone(),
                            network_id,
                            meta.remote_peer_id,
                            shared.clone(),
                        ));
                    }
                    connected_peers.insert(peer_network_id);
                },
                ConnectionNotification::LostPeer(meta, network_id) => {
                    let peer_network_id = PeerNetworkId::new(network_id, meta.remote_peer_id);
                    connected_peers.remove(&peer_network_id);
                },
            },
        }
    }
}
```

**File:** network/benchmark/src/lib.rs (L343-408)
```rust
pub async fn direct_sender(
    node_config: NodeConfig,
    network_client: NetworkClient<NetbenchMessage>,
    time_service: TimeService,
    network_id: NetworkId,
    peer_id: PeerId,
    shared: Arc<RwLock<NetbenchSharedState>>,
) {
    let config = node_config.netbench.unwrap();
    let interval = Duration::from_nanos(1_000_000_000 / config.direct_send_per_second);
    let ticker = time_service.interval(interval);
    futures::pin_mut!(ticker);
    let data_size = config.direct_send_data_size;
    let mut rng = OsRng;
    let mut blob = Vec::<u8>::with_capacity(data_size);

    // random payload filler
    for _ in 0..data_size {
        blob.push(rng.r#gen());
    }

    let mut counter: u64 = rng.r#gen();

    loop {
        ticker.next().await;

        counter += 1;
        {
            // tweak the random payload a little on every send
            let counter_bytes: [u8; 8] = counter.to_le_bytes();
            let (dest, _) = blob.deref_mut().split_at_mut(8);
            dest.copy_from_slice(&counter_bytes);
        }

        let nowu = time_service.now_unix_time().as_micros() as u64;
        let msg = NetbenchDataSend {
            request_counter: counter,
            send_micros: nowu,
            data: blob.clone(),
        };
        {
            shared.write().await.set(SendRecord {
                request_counter: counter,
                send_micros: nowu,
                bytes_sent: blob.len(),
            })
        }
        let wrapper = NetbenchMessage::DataSend(msg);
        let result = network_client.send_to_peer(wrapper, PeerNetworkId::new(network_id, peer_id));
        if let Err(err) = result {
            direct_messages("serr");
            info!(
                "netbench [{},{}] direct send err: {}",
                network_id, peer_id, err
            );
            return;
        } else {
            direct_messages("sent");
        }

        sample!(
            SampleRate::Duration(Duration::from_millis(BLAB_MILLIS)),
            info!("netbench ds counter={}", counter)
        );
    }
}
```
