# Audit Report

## Title
Weight Bypass in Secret Sharing Causes Denial of Service for Encrypted Transaction Processing

## Summary
The `get_peer_weight()` function in `SecretShareConfig` always returns 1 regardless of the peer's actual validator stake, while the threshold calculation uses weighted values from the underlying `FPTXWeighted` configuration. This mismatch causes the secret sharing aggregation to never complete, resulting in a denial of service when encrypted transactions are present in consensus blocks.

## Finding Description

The vulnerability lies in a critical mismatch between weight accumulation and threshold checking in the secret sharing protocol used for encrypted transaction decryption.

**Root Cause:**

The `get_peer_weight()` function hardcodes a return value of 1: [1](#0-0) 

However, the `threshold()` method returns the weighted threshold from the underlying `FPTXWeighted` configuration: [2](#0-1) 

The underlying `WeightedConfig` is created with actual validator stakes as weights, and the threshold `t` represents a weighted value (e.g., 2/3 of total stake): [3](#0-2) 

**Attack Path:**

1. During DKG setup, validator stakes are converted to weights (e.g., validators with stakes [100, 100, 100, 1] get corresponding weights): [4](#0-3) 

2. The weighted threshold is calculated (e.g., 201 for 2/3 of total weight 302): [5](#0-4) 

3. When shares arrive in `SecretShareStore::add_share()`, each peer's weight is retrieved as 1: [6](#0-5) 

4. Shares are added to the aggregator with weight 1: [7](#0-6) 

5. The aggregation check compares accumulated weight (at most N validators) against the weighted threshold (e.g., 201): [8](#0-7) 

6. With 4 validators, `total_weight` will be at most 4, but `threshold()` returns 201. The check `4 < 201` always fails, preventing aggregation.

7. The decryption pipeline waits indefinitely for the secret shared key and eventually panics: [9](#0-8) 

**Invariant Violations:**

This breaks the **Cryptographic Correctness** invariant (#10) by preventing proper threshold secret reconstruction, and the **Consensus Safety** invariant (#2) by causing node crashes during block processing.

## Impact Explanation

**Severity: HIGH** (per Aptos bug bounty categories: "Validator node slowdowns" / "Significant protocol violations")

The vulnerability causes:

1. **Complete Failure of Secret Sharing Protocol**: When encrypted transactions are present, the secret sharing never completes because the weight accumulation can never reach the weighted threshold.

2. **Validator Node Crashes**: The decryption pipeline explicitly expects the key to be available and panics when it's not: [10](#0-9) 

3. **Denial of Service**: All validators in the network are affected simultaneously when processing blocks with encrypted transactions, as they all experience the same threshold mismatch.

4. **Network-Wide Impact**: Unlike a single node issue, this affects the entire network's ability to process encrypted transactions, which is a core feature of the protocol.

This qualifies as HIGH severity because it causes significant protocol violations and can lead to validator node crashes, affecting network availability.

## Likelihood Explanation

**Likelihood: HIGH**

This vulnerability triggers automatically under normal network conditions:

1. **No Attacker Required**: The bug manifests whenever encrypted transactions are submitted and validators have non-uniform stakes, which is the standard configuration for production networks.

2. **Common Scenario**: The DKG setup specifically computes weighted thresholds based on validator stakes, meaning any realistic validator set will trigger this: [11](#0-10) 

3. **Automated Trigger**: Any user submitting encrypted transactions will trigger the bug without needing to understand the vulnerability.

4. **Already Acknowledged**: The codebase contains a TODO comment acknowledging the incomplete implementation: [12](#0-11) 

The only scenario where this doesn't trigger is if:
- Secret sharing is disabled (`secret_share_config.is_none()`)
- No encrypted transactions are submitted
- All validators have exactly equal stakes (extremely unlikely)

## Recommendation

Implement `get_peer_weight()` to return actual validator weights from the underlying weighted configuration, following the pattern used in `RandConfig`: [13](#0-12) 

**Recommended Fix:**

```rust
pub fn get_peer_weight(&self, peer: &Author) -> u64 {
    let player = Player {
        id: self.get_id(peer),
    };
    self.config.get_player_weight(&player) as u64
}
```

Additionally, populate the `weights` HashMap during construction to support the `get_peer_weights()` method:

```rust
pub fn new(
    author: Author,
    epoch: u64,
    validator: Arc<ValidatorVerifier>,
    digest_key: DigestKey,
    msk_share: MasterSecretKeyShare,
    verification_keys: Vec<VerificationKey>,
    config: <FPTXWeighted as BatchThresholdEncryption>::ThresholdConfig,
    encryption_key: EncryptionKey,
) -> Self {
    let weights: HashMap<Author, u64> = validator
        .get_ordered_account_addresses_iter()
        .enumerate()
        .map(|(idx, addr)| {
            let player = Player { id: idx };
            (addr, config.get_player_weight(&player) as u64)
        })
        .collect();
    
    Self {
        _author: author,
        _epoch: epoch,
        validator,
        digest_key,
        msk_share,
        verification_keys,
        config,
        encryption_key,
        weights,
    }
}
```

## Proof of Concept

**Scenario Setup:**
- 4 validators with stakes: [100, 100, 100, 1]
- Total stake: 301
- Reconstruction threshold: 2/3 = 201 (weighted)

**Reproduction Steps:**

1. Initialize DKG with non-uniform validator stakes
2. Create `SecretShareConfig` with the resulting `WeightedConfigArkworks`
3. Submit a block containing encrypted transactions
4. Each validator derives their secret share and broadcasts it

**Expected Behavior:**
When 2 validators (combined weight ≥ 201) submit shares, aggregation should complete.

**Actual Behavior:**
- Validator 1 share arrives: `total_weight = 1` (should be 100)
- Validator 2 share arrives: `total_weight = 2` (should be 200)
- Validator 3 share arrives: `total_weight = 3` (should be 300)
- Validator 4 share arrives: `total_weight = 4` (should be 301)
- Check: `4 < 201` → aggregation never triggers
- Decryption pipeline blocks waiting for key
- Node panics at `.expect("decryption key should be available")`

**Rust Test to Demonstrate:**

```rust
#[test]
fn test_weight_mismatch_dos() {
    use aptos_types::secret_sharing::{SecretShareConfig, SecretShare};
    use consensus::rand::secret_sharing::secret_share_store::{SecretShareStore, SecretShareAggregator};
    
    // Setup: 4 validators with non-uniform stakes
    let stakes = vec![100u64, 100, 100, 1];
    let total_stake: u64 = stakes.iter().sum(); // 301
    let threshold_weight = (total_stake * 2) / 3; // 200.67 → 201
    
    // Create weighted config with actual stakes
    let wconfig = WeightedConfigArkworks::new(
        threshold_weight as usize,
        stakes.clone().into_iter().map(|s| s as usize).collect()
    ).unwrap();
    
    // Create SecretShareConfig (will have hardcoded weight=1)
    let config = create_secret_share_config_with_wconfig(wconfig);
    
    // Verify the mismatch
    assert_eq!(config.threshold(), 201); // weighted threshold
    assert_eq!(config.get_peer_weight(&validator1), 1); // BUG: should be 100
    assert_eq!(config.get_peer_weight(&validator2), 1); // BUG: should be 100
    
    // Create aggregator and add shares from all validators
    let mut aggregator = SecretShareAggregator::new(validator1);
    aggregator.add_share(share1, config.get_peer_weight(&validator1));
    aggregator.add_share(share2, config.get_peer_weight(&validator2));
    aggregator.add_share(share3, config.get_peer_weight(&validator3));
    aggregator.add_share(share4, config.get_peer_weight(&validator4));
    
    // Verify DoS: total_weight = 4, but threshold = 201
    assert_eq!(aggregator.total_weight, 4);
    assert!(aggregator.total_weight < config.threshold()); // Always true!
    
    // Aggregation will never succeed, causing DoS
}
```

**Notes**

The vulnerability is confirmed by multiple indicators in the codebase:
1. The explicit TODO comment acknowledging incomplete weighted config implementation
2. The parallel `RandConfig` implementation that correctly retrieves weights
3. The weights HashMap field that exists but is never populated or used
4. The mismatch between weight-based threshold calculation and count-based weight accumulation

This is a genuine HIGH severity vulnerability that breaks the secret sharing protocol for encrypted transactions when validators have non-uniform stakes, which is the standard production configuration.

### Citations

**File:** types/src/secret_sharing.rs (L188-190)
```rust
    pub fn threshold(&self) -> u64 {
        self.config.get_threshold_config().t as u64
    }
```

**File:** types/src/secret_sharing.rs (L196-198)
```rust
    pub fn get_peer_weight(&self, _peer: &Author) -> u64 {
        1
    }
```

**File:** types/src/dkg/real_dkg/rounding/mod.rs (L98-106)
```rust
        let wconfig = WeightedConfigBlstrs::new(
            profile.reconstruct_threshold_in_weights as usize,
            profile
                .validator_weights
                .iter()
                .map(|w| *w as usize)
                .collect(),
        )
        .unwrap();
```

**File:** types/src/dkg/real_dkg/mod.rs (L104-117)
```rust
    let validator_stakes: Vec<u64> = next_validators.iter().map(|vi| vi.voting_power).collect();
    let timer = Instant::now();
    let DKGRounding {
        profile,
        wconfig,
        fast_wconfig,
        rounding_error,
        rounding_method,
    } = DKGRounding::new(
        &validator_stakes,
        secrecy_threshold,
        reconstruct_threshold,
        maybe_fast_path_secrecy_threshold,
    );
```

**File:** crates/aptos-crypto/src/weighted_config.rs (L96-96)
```rust
        let tc = TC::new(threshold_weight, W)?;
```

**File:** consensus/src/rand/secret_sharing/secret_share_store.rs (L32-35)
```rust
    pub fn add_share(&mut self, share: SecretShare, weight: u64) {
        if self.shares.insert(share.author, share).is_none() {
            self.total_weight += weight;
        }
```

**File:** consensus/src/rand/secret_sharing/secret_share_store.rs (L44-46)
```rust
        if self.total_weight < secret_share_config.threshold() {
            return Either::Left(self);
        }
```

**File:** consensus/src/rand/secret_sharing/secret_share_store.rs (L260-260)
```rust
        let weight = self.secret_share_config.get_peer_weight(share.author());
```

**File:** consensus/src/pipeline/decryption_pipeline_builder.rs (L115-119)
```rust
        let maybe_decryption_key = secret_shared_key_rx
            .await
            .expect("decryption key should be available");
        // TODO(ibalajiarun): account for the case where decryption key is not available
        let decryption_key = maybe_decryption_key.expect("decryption key should be available");
```

**File:** consensus/src/rand/secret_sharing/types.rs (L99-101)
```rust
    pub fn get_peer_weight(&self, _peer: &Author) -> u64 {
        // daniel todo: use weighted config
        1
```

**File:** consensus/src/rand/rand_gen/types.rs (L676-681)
```rust
    pub fn get_peer_weight(&self, peer: &Author) -> u64 {
        let player = Player {
            id: self.get_id(peer),
        };
        self.wconfig.get_player_weight(&player) as u64
    }
```
