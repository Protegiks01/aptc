# Audit Report

## Title
Race Condition in Indexer-gRPC Cache Management Causes Permanent Transaction Data Loss

## Summary
A critical race condition exists between the FileStoreUploader and DataManager's garbage collection mechanism. The cache optimistically updates `file_store_version` before data is persisted to file store, allowing GC to remove transactions that haven't been uploaded yet. If upload fails, these transactions are permanently lost, causing the indexer to serve inconsistent transaction sets or fail client requests.

## Finding Description

The vulnerability stems from optimistic concurrency control without rollback mechanisms in the indexer-grpc-manager's data management layer.

**The Race Condition:**

The `Cache::get_transactions()` function increments `file_store_version` when called with `update_file_store_version=true`, assuming the upload will succeed: [1](#0-0) 

The FileStoreUploader calls this function to retrieve transactions for upload: [2](#0-1) 

Meanwhile, DataManager's GC loop runs concurrently and removes transactions from cache based on `file_store_version`: [3](#0-2) 

**Attack Scenario:**

1. **Initial state**: Cache contains transactions [1000-3000], `file_store_version=1000`, file store has data up to version 999
2. **FileStoreUploader** (concurrent task): Calls `get_transactions_from_cache(1000, ..., true)`, receives [1000-1050], cache increments `file_store_version` to 1050
3. **DataManager GC** (concurrent task): Triggered by cache pressure, sees `file_store_version=1050`, removes transactions [1000-1050] from cache
4. **FileStoreUploader upload fails**: Network error, crash, or any failure occurs before actual upload completes
5. **Result**: Transactions [1000-1050] are lost - not in cache, not in file store

When clients request these transactions, the indexer attempts to read from file store which doesn't have them: [4](#0-3) 

Both tasks run concurrently with no synchronization preventing this race: [5](#0-4) 

The upload operation uses `.unwrap()` which panics on failure, but by then data is already lost: [6](#0-5) 

**Invariant Broken**: The fundamental guarantee that transaction data exists in either cache OR file store is violated. Data can be in neither location.

## Impact Explanation

**Severity: High (potentially Critical for production mainnet indexers)**

This vulnerability causes:

1. **Permanent Data Loss**: Transaction history is lost with no recovery mechanism
2. **API Failures**: Client requests for affected version ranges fail with errors
3. **Inconsistent State**: Cache and file store serve different transaction ranges
4. **Cascading Failures**: Wallets, explorers, analytics tools depending on indexer receive incomplete data

Per Aptos bug bounty criteria:
- **High Severity**: API crashes, significant protocol violations - the indexer API will fail for affected transaction ranges and serve inconsistent data
- **Potential Critical**: If considered "state inconsistencies requiring hardfork" level intervention for mainnet recovery

The indexer-grpc service is critical infrastructure for the Aptos ecosystem, serving transaction data to all client applications.

## Likelihood Explanation

**Likelihood: High**

This vulnerability will occur in production under normal operating conditions:

1. **Natural Triggers**: Cache pressure from high transaction volume naturally triggers GC frequently
2. **Concurrent Design**: FileStoreUploader and DataManager run as independent async tasks by design
3. **No Synchronization**: No locks prevent GC from running between version increment and upload completion
4. **Network Failures**: Any upload delay or failure (network issues, S3/GCS errors) increases the race window
5. **Attacker Amplification**: Malicious clients can trigger cache pressure by requesting large amounts of historical data, forcing frequent GC cycles

The race window is significant because:
- Upload involves network I/O to cloud storage (S3/GCS)
- GC checks happen in tight loops during cache pressure
- No atomic transaction semantics guarantee upload-then-GC ordering

## Recommendation

Implement transactional semantics for the file store version update:

**Solution 1: Update version AFTER successful upload**

Move the `file_store_version` increment to happen only after `do_upload()` succeeds, not during `get_transactions_from_cache()`. The FileStoreUploader should:
1. Get transactions without updating version
2. Upload successfully
3. Then increment version to mark data as persisted

**Solution 2: Add version rollback on failure**

If maintaining current architecture, add compensation logic:
1. Track pending uploads with their version ranges
2. On upload failure, revert `file_store_version` using `fetch_min`
3. Prevent GC from removing transactions in pending upload ranges

**Solution 3: Two-phase commit protocol**

Implement proper two-phase commit:
1. Phase 1: Mark transactions as "pending upload" (lock from GC)
2. Phase 2: Upload, then mark as "committed" (update version, allow GC)

**Recommended Fix (Solution 1 - simplest and safest):**

Modify `get_transactions_from_cache` to never update file_store_version (remove the parameter). Instead, add a new function `mark_uploaded(version_range)` that FileStoreUploader calls AFTER successful upload to update the version atomically.

## Proof of Concept

**Stress Test to Reproduce:**

```rust
// Run this test against a running indexer-grpc-manager instance
#[tokio::test]
async fn test_race_condition_data_loss() {
    // Setup: Create indexer with small cache size
    // Step 1: Fill cache to near max capacity
    // Step 2: Spawn concurrent tasks:
    //   - Task A: Continuously request data (triggers GC)
    //   - Task B: Monitor FileStoreUploader progress
    // Step 3: Inject network delay/failure into upload path
    // Step 4: Observe GC removing data before upload completes
    // Step 5: Verify data loss by requesting affected versions
    // Expected: Requests fail with "not found" errors
}

// Simplified reproduction steps:
// 1. Start indexer-grpc-manager with MAX_CACHE_SIZE=100MB
// 2. Stream 200MB of transactions to fill cache
// 3. Introduce network latency to S3/GCS (use toxiproxy)
// 4. Observe metrics: CACHE_START_VERSION jumps ahead of FILE_STORE_VERSION
// 5. Kill process during upload (or let network timeout fail it)
// 6. Restart indexer
// 7. Request transactions in the gap - observe errors
```

**Notes**

This vulnerability is specific to the master node configuration where FileStoreUploader runs. Non-master nodes that only read from file store are not directly affected but will serve inconsistent data if the master loses transactions.

The issue is exacerbated by the use of `AtomicU64::fetch_max` in `update_file_store_version_in_cache`, which prevents the version from ever decreasing even during recovery scenarios where it should.

Recovery requires manual intervention to re-stream lost transactions from a fullnode and rebuild the affected portion of the file store.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/data_manager.rs (L63-74)
```rust
    fn maybe_gc(&mut self) -> bool {
        if self.cache_size <= self.max_cache_size {
            return true;
        }

        while self.start_version < self.file_store_version.load(Ordering::SeqCst)
            && self.cache_size > self.target_cache_size
        {
            let transaction = self.transactions.pop_front().unwrap();
            self.cache_size -= transaction.encoded_len();
            self.start_version += 1;
        }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/data_manager.rs (L127-135)
```rust
        if update_file_store_version {
            if !transactions.is_empty() {
                let old_version = self
                    .file_store_version
                    .fetch_add(transactions.len() as u64, Ordering::SeqCst);
                let new_version = old_version + transactions.len() as u64;
                FILE_STORE_VERSION_IN_CACHE.set(new_version as i64);
                info!("Updated file_store_version in cache to {new_version}.");
            }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/data_manager.rs (L354-371)
```rust
        if let Some((transactions, _, _, range)) = rx.recv().await {
            debug!(
                "Transactions returned from filestore: [{}, {}].",
                range.0, range.1
            );
            let first_version = transactions.first().unwrap().version;
            ensure!(
                first_version == start_version,
                "Version doesn't match, something is wrong."
            );
            Ok(transactions)
        } else {
            let error_msg = "Failed to fetch transactions from filestore, either filestore is not available, or data is corrupted.";
            // TODO(grao): Consider downgrade this to warn! if this happens too frequently when
            // filestore is unavailable.
            error!(error_msg);
            bail!(error_msg);
        }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/file_store_uploader.rs (L141-143)
```rust
                    self.do_upload(transactions, batch_metadata, end_batch)
                        .await
                        .unwrap();
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/file_store_uploader.rs (L157-163)
```rust
                        data_manager
                            .get_transactions_from_cache(
                                next_version,
                                MAX_SIZE_PER_FILE,
                                /*update_file_store_version=*/ true,
                            )
                            .await
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/grpc_manager.rs (L111-120)
```rust
            s.spawn(async move { self.data_manager.start(self.is_master, rx).await });
            if self.is_master {
                s.spawn(async move {
                    self.file_store_uploader
                        .lock()
                        .await
                        .start(self.data_manager.clone(), tx)
                        .await
                        .unwrap();
                });
```
