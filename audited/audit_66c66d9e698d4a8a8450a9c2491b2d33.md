# Audit Report

## Title
Genesis Framework Supply Chain Vulnerability: Unauthenticated ReleaseBundle Deployment

## Summary
The `ReleaseBundle::new()` constructor and associated genesis initialization code accept arbitrary framework packages without cryptographic verification of authenticity or origin. An attacker who compromises the genesis git repository or performs a man-in-the-middle attack could inject a malicious framework that would be deployed with system-level privileges during network initialization.

## Finding Description

The vulnerability exists across multiple components of the genesis initialization flow:

1. **Unauthenticated Package Constructor**: The `ReleaseBundle::new()` function accepts arbitrary `ReleasePackage` objects without any verification. [1](#0-0) 

2. **Unauthenticated Deserialization**: The `ReleaseBundle::read()` function deserializes bundles from files without signature or hash verification. [2](#0-1) 

3. **Unverified Git Repository Loading**: The genesis generation process loads the framework from git repositories (local or GitHub) without verifying authenticity. [3](#0-2) 

4. **Direct Deployment to Genesis**: The mainnet genesis accepts this unverified framework and deploys it with system privileges. [4](#0-3) 

5. **Framework Publishing Without Origin Check**: The `publish_framework()` function deploys packages to genesis without verifying their source. [5](#0-4) 

**Attack Scenario:**

An attacker who compromises the genesis git repository or performs a supply chain attack could:

1. Create malicious but syntactically valid Move modules (e.g., with backdoors allowing unauthorized fund transfers)
2. Bundle them into a `ReleasePackage` and `ReleaseBundle`
3. Place the malicious bundle in the git repository used by validators
4. Validators unknowingly load this framework via `client.get_framework()`
5. The malicious framework is deployed to genesis with full system privileges
6. The compromised blockchain launches with backdoored core functionality

**Broken Invariants:**
- **Invariant 8 (Access Control)**: System addresses can be compromised through malicious framework code
- **Invariant 1 (Deterministic Execution)**: If different validators use different frameworks (one legitimate, one malicious), they will produce different state roots, causing consensus failure
- **Invariant 5 (Governance Integrity)**: Malicious framework could manipulate voting power calculations

## Impact Explanation

**Critical Severity** - This vulnerability enables complete blockchain compromise:

- **Loss of Funds**: Malicious framework code could allow unauthorized withdrawals from any account
- **Consensus/Safety Violations**: Different framework versions deployed by different validators would cause immediate consensus divergence
- **System Privilege Escalation**: Framework code runs at system addresses (@aptos_framework, @core_resources) with unrestricted access
- **Non-recoverable Compromise**: If malicious framework is deployed to mainnet genesis, recovery requires a hard fork and complete relaunch
- **Governance Bypass**: Malicious framework could manipulate on-chain governance, voting power, or validator selection

The PackageMetadata structure includes a `source_digest` field intended for verification, but this digest is never cryptographically validated against the actual bytecode. [6](#0-5) 

## Likelihood Explanation

**Medium-High Likelihood** given the attack requirements:

**Attack Vectors:**
1. **Git Repository Compromise**: Attacker compromises the official Aptos genesis repository or infrastructure
2. **Supply Chain Attack**: Attacker compromises build systems or distribution channels
3. **Man-in-the-Middle**: Attacker intercepts validators' connections when fetching framework (if using GitHub client)
4. **Social Engineering**: Attacker tricks validators into using a malicious repository URL

**Mitigating Factors:**
- Validators would presumably review framework code during genesis ceremony
- Out-of-band communication between validators might detect discrepancies
- Multiple validators must unknowingly use the same malicious framework

**Aggravating Factors:**
- No cryptographic verification exists at any layer
- Validators must trust the git repository completely
- Bytecode verification only checks syntactic validity, not authenticity
- Test mode allows arbitrary framework injection, which could be exploited if misconfigured

## Recommendation

Implement multi-layered framework authentication:

### 1. Framework Hash Verification
Hardcode the expected hash of official framework releases and verify loaded bundles:

```rust
// In aptos-move/framework/src/release_bundle.rs
impl ReleaseBundle {
    pub const OFFICIAL_FRAMEWORK_HASHES: &'static [&'static str] = &[
        "expected_mainnet_framework_sha256_hash",
        // Add hashes for each official release
    ];
    
    pub fn verify_authenticity(&self) -> Result<(), Error> {
        let bundle_bytes = bcs::to_bytes(self)?;
        let hash = sha256(&bundle_bytes);
        let hash_str = hex::encode(hash);
        
        if !Self::OFFICIAL_FRAMEWORK_HASHES.contains(&hash_str.as_str()) {
            return Err(Error::UntrustedFramework(hash_str));
        }
        Ok(())
    }
    
    pub fn read(file: PathBuf) -> anyhow::Result<ReleaseBundle> {
        let content = std::fs::read(&file)
            .with_context(|| format!("while reading `{}`", file.display()))?;
        let bundle = bcs::from_bytes::<ReleaseBundle>(&content)?;
        
        // Verify authenticity before returning
        bundle.verify_authenticity()
            .context("Framework authenticity verification failed")?;
        
        Ok(bundle)
    }
}
```

### 2. Cryptographic Signatures
Implement signature verification using Aptos Foundation signing keys:

```rust
pub struct SignedReleaseBundle {
    pub bundle: ReleaseBundle,
    pub signature: Ed25519Signature,
    pub signing_key: Ed25519PublicKey,
}

impl SignedReleaseBundle {
    pub const TRUSTED_PUBLIC_KEYS: &'static [Ed25519PublicKey] = &[
        // Aptos Foundation framework signing keys
    ];
    
    pub fn verify(&self) -> Result<ReleaseBundle, Error> {
        if !Self::TRUSTED_PUBLIC_KEYS.contains(&self.signing_key) {
            return Err(Error::UntrustedSigningKey);
        }
        
        let message = bcs::to_bytes(&self.bundle)?;
        self.signature.verify(&message, &self.signing_key)
            .map_err(|_| Error::InvalidFrameworkSignature)?;
        
        Ok(self.bundle.clone())
    }
}
```

### 3. Source Digest Validation
Actually validate the `source_digest` field against computed bytecode hashes:

```rust
impl ReleasePackage {
    pub fn verify_source_digest(&self) -> Result<(), Error> {
        let computed_digest = self.compute_source_digest();
        if computed_digest != self.metadata.source_digest {
            return Err(Error::SourceDigestMismatch {
                expected: self.metadata.source_digest.clone(),
                actual: computed_digest,
            });
        }
        Ok(())
    }
}
```

### 4. Update Genesis Flow
Integrate verification into the genesis initialization: [7](#0-6) 

```rust
// In fetch_mainnet_genesis_info
let framework = client.get_framework()?;
framework.verify_authenticity()
    .context("Framework failed authenticity check")?;
```

## Proof of Concept

```rust
// Demonstration of malicious framework injection
use aptos_framework::ReleaseBundle;
use aptos_move_framework::natives::code::PackageMetadata;

#[test]
fn test_malicious_framework_injection() {
    // Step 1: Create a malicious Move module with backdoor
    let malicious_bytecode = vec![
        // Compiled Move bytecode that allows unauthorized withdrawals
        // (simplified for PoC - actual exploit would be valid Move bytecode)
    ];
    
    // Step 2: Create a ReleasePackage with malicious code
    let malicious_package = ReleasePackage {
        metadata: PackageMetadata {
            name: "aptos-framework".to_string(),
            upgrade_policy: UpgradePolicy::immutable(),
            upgrade_number: 1,
            source_digest: "fake_digest".to_string(), // No validation!
            manifest: vec![],
            modules: vec![],
            deps: vec![],
            extension: None,
        },
        code: vec![malicious_bytecode],
    };
    
    // Step 3: Create ReleaseBundle - NO VERIFICATION OCCURS
    let malicious_bundle = ReleaseBundle::new(
        vec![malicious_package],
        vec![]
    );
    
    // Step 4: Save to file
    let path = PathBuf::from("/tmp/malicious_framework.mrb");
    malicious_bundle.write(path.clone()).unwrap();
    
    // Step 5: Load back - STILL NO VERIFICATION
    let loaded = ReleaseBundle::read(path).unwrap();
    
    // Step 6: This malicious bundle would be deployed to genesis
    // with full system privileges if used during genesis generation
    assert_eq!(loaded.packages.len(), 1);
    
    // VULNERABILITY: No authenticity check prevented this malicious bundle
    // from being created, saved, loaded, and prepared for deployment
}

// Test showing genesis accepts unverified framework
#[test] 
fn test_genesis_accepts_unverified_framework() {
    use aptos_genesis::mainnet::MainnetGenesisInfo;
    
    // Create malicious bundle (as above)
    let malicious_bundle = create_malicious_bundle();
    
    // Genesis accepts it without verification!
    let genesis_info = MainnetGenesisInfo::new(
        ChainId::test(),
        vec![], // accounts
        vec![], // employee vesting
        vec![], // validators  
        malicious_bundle, // <-- MALICIOUS FRAMEWORK ACCEPTED
        &GenesisConfiguration::default(),
    ).unwrap();
    
    // The malicious framework would be deployed when genesis is generated
    let genesis_txn = genesis_info.get_genesis();
    
    // VULNERABILITY: No protection against malicious framework deployment
}
```

## Notes

**Critical Context:**

1. **Bytecode Verification Is Insufficient**: While `StagingModuleStorage::create()` performs bytecode verification during framework deployment, this only validates that modules are syntactically correct Move bytecode - it does NOT verify the code is the authentic Aptos framework. [8](#0-7) 

2. **Test Mode Exposure**: The `--genesis-framework` flag allows arbitrary framework injection in test mode, which could be accidentally used in production if misconfigured. [9](#0-8) 

3. **No Defense in Depth**: Multiple layers accept unverified bundles without any authentication at any stage of the pipeline.

4. **Supply Chain Attack Surface**: The complete trust in git repositories creates a single point of failure for the entire blockchain's security foundation.

This vulnerability represents a critical gap in Aptos's security architecture where the most privileged code (the framework) has the weakest authentication requirements.

### Citations

**File:** aptos-move/framework/src/release_bundle.rs (L37-42)
```rust
    pub fn new(packages: Vec<ReleasePackage>, source_dirs: Vec<String>) -> Self {
        Self {
            packages,
            source_dirs,
        }
    }
```

**File:** aptos-move/framework/src/release_bundle.rs (L45-49)
```rust
    pub fn read(file: PathBuf) -> anyhow::Result<ReleaseBundle> {
        let content =
            std::fs::read(&file).with_context(|| format!("while reading `{}`", file.display()))?;
        Ok(bcs::from_bytes::<ReleaseBundle>(&content)?)
    }
```

**File:** crates/aptos/src/genesis/git.rs (L230-246)
```rust
    pub fn get_framework(&self) -> CliTypedResult<ReleaseBundle> {
        match self {
            Client::Local(local_repository_path) => {
                let path = local_repository_path.join(FRAMEWORK_NAME);
                if !path.exists() {
                    return Err(CliError::UnableToReadFile(
                        path.display().to_string(),
                        "File not found".to_string(),
                    ));
                }
                Ok(ReleaseBundle::read(path)?)
            },
            Client::Github(client) => {
                let bytes = base64::decode(client.get_file(FRAMEWORK_NAME)?)?;
                Ok(bcs::from_bytes::<ReleaseBundle>(&bytes)?)
            },
        }
```

**File:** crates/aptos-genesis/src/mainnet.rs (L71-94)
```rust
    pub fn new(
        chain_id: ChainId,
        accounts: Vec<AccountBalance>,
        employee_vesting_accounts: Vec<EmployeePool>,
        validators: Vec<ValidatorConfiguration>,
        framework: ReleaseBundle,
        genesis_config: &GenesisConfiguration,
    ) -> anyhow::Result<MainnetGenesisInfo> {
        let employee_vesting_start = genesis_config
            .employee_vesting_start
            .expect("Employee vesting start time (in secs) needs to be provided");
        let employee_vesting_period_duration = genesis_config
            .employee_vesting_period_duration
            .expect("Employee vesting period duration (in secs) needs to be provided");

        Ok(MainnetGenesisInfo {
            chain_id,
            accounts,
            employee_vesting_accounts,
            validators: validators
                .into_iter()
                .map(|v| ValidatorWithCommissionRate::try_from(v).unwrap())
                .collect(),
            framework,
```

**File:** aptos-move/vm-genesis/src/lib.rs (L1128-1150)
```rust
fn code_to_writes_for_publishing(
    genesis_runtime_environment: &RuntimeEnvironment,
    genesis_features: &Features,
    genesis_state_view: &GenesisStateView,
    addr: AccountAddress,
    code: Vec<Bytes>,
) -> VMResult<BTreeMap<StateKey, ModuleWrite<WriteOp>>> {
    let module_storage = genesis_state_view.as_aptos_code_storage(genesis_runtime_environment);
    let resolver = genesis_state_view.as_move_resolver();

    let module_storage_with_staged_modules =
        StagingModuleStorage::create(&addr, &module_storage, code)?;
    let verified_module_bundle =
        module_storage_with_staged_modules.release_verified_module_bundle();

    convert_modules_into_write_ops(
        &resolver,
        genesis_features,
        &module_storage,
        verified_module_bundle,
    )
    .map_err(|e| e.finish(Location::Undefined))
}
```

**File:** aptos-move/vm-genesis/src/lib.rs (L1155-1194)
```rust
fn publish_framework(
    genesis_vm: &GenesisMoveVm,
    genesis_runtime_environment: &RuntimeEnvironment,
    hash_value: HashValue,
    framework: &ReleaseBundle,
) -> (VMChangeSet, ModuleWriteSet) {
    // Reset state view to be empty, to make sure all module write ops are creations.
    let mut state_view = GenesisStateView::new();

    // First, publish modules.
    let mut writes = BTreeMap::new();
    for pack in &framework.packages {
        let modules = pack.sorted_code_and_modules();

        let addr = *modules.first().unwrap().1.self_id().address();
        let code = modules
            .into_iter()
            .map(|(c, _)| c.to_vec().into())
            .collect::<Vec<_>>();

        let package_writes = code_to_writes_for_publishing(
            genesis_runtime_environment,
            genesis_vm.genesis_features(),
            &state_view,
            addr,
            code,
        )
        .unwrap_or_else(|e| {
            panic!(
                "Failure publishing package `{}`: {:?}",
                pack.package_metadata().name,
                e
            )
        });

        // Add write ops so that we can later create a module write set. Also add them to the state
        // view so that modules in subsequent packages can link to them.
        writes.extend(package_writes.clone());
        state_view.add_module_write_ops(package_writes);
    }
```

**File:** aptos-move/framework/src/natives/code.rs (L60-71)
```rust
#[derive(Clone, Debug, Serialize, Deserialize, Eq, PartialEq)]
pub struct PackageMetadata {
    pub name: String,
    pub upgrade_policy: UpgradePolicy,
    pub upgrade_number: u64,
    pub source_digest: String,
    #[serde(with = "serde_bytes")]
    pub manifest: Vec<u8>,
    pub modules: Vec<ModuleMetadata>,
    pub deps: Vec<PackageDep>,
    pub extension: Option<Any>,
}
```

**File:** crates/aptos/src/genesis/mod.rs (L236-242)
```rust
    let framework = client.get_framework()?;
    Ok(MainnetGenesisInfo::new(
        layout.chain_id,
        accounts,
        employee_vesting_accounts,
        validators,
        framework,
```

**File:** aptos-node/src/lib.rs (L142-147)
```rust
            // Set the genesis framework
            let genesis_framework = if let Some(path) = self.genesis_framework {
                ReleaseBundle::read(path).unwrap()
            } else {
                aptos_cached_packages::head_release_bundle().clone()
            };
```
