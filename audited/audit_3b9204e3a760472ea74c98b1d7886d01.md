# Audit Report

## Title
WebAuthn Authenticator Data Validation Missing: User Presence and Verification Flags Not Enforced

## Summary
The WebAuthn signature verification implementation in Aptos Core fails to validate critical authenticator data fields mandated by the W3C WebAuthn specification. The implementation treats authenticator data as an opaque byte array without parsing or checking the User Present (UP) and User Verified (UV) flags, allowing transactions to be accepted without enforcing user presence requirements.

## Finding Description

The WebAuthn verification logic in Aptos Core violates the W3C WebAuthn specification Section 7.2 by not validating the authenticator data structure. According to the specification, verification must include checking that the User Present (UP) bit in the flags byte is set.

The `generate_verification_data` function simply concatenates raw authenticator data bytes without inspecting their internal structure. [1](#0-0) 

The `verify` function performs only three checks:
1. Challenge matches the transaction hash
2. Verification data construction
3. Signature verification cryptographically

However, it completely omits parsing and validating the authenticator data structure. [2](#0-1) 

According to the WebAuthn specification, authenticator data has the following structure:
- Bytes 0-31: RP ID hash (32 bytes)
- Byte 32: Flags byte (UP bit 0, UV bit 2)
- Bytes 33-36: Signature counter (4 bytes)

The code never validates any of these fields. While test data shows proper flags (byte 32 = 0x1D = UP=1, UV=1), the production code never validates this. [3](#0-2) 

**Attack Scenario:**
1. Attacker uses malicious client software or non-compliant software authenticator
2. Creates authenticator data with UP=0 (user not present) or UV=0 (user not verified)
3. Signs transaction with private key over (authenticator_data || SHA256(client_data_json))
4. Submits transaction to blockchain via normal transaction submission flow
5. Transaction is accepted despite lacking user presence/verification attestation

This breaks the WebAuthn security model where user presence is a critical defense against automated malware-driven transaction signing.

## Impact Explanation

**Medium Severity** - This constitutes a significant protocol violation per Aptos bug bounty criteria:

1. **Specification Violation**: Direct violation of W3C WebAuthn specification Section 7.2 verification requirements that the blockchain claims to implement

2. **Security Guarantee Bypass**: Users who choose WebAuthn specifically for its user presence requirement receive no enforcement of this critical security property

3. **State Inconsistency**: The blockchain accepts and commits transactions that were not properly authorized according to the WebAuthn specification, creating state inconsistencies where transactions exist without proper user presence attestation

4. **Weakened Authentication Model**: Malicious software authenticators can sign transactions without user interaction, and the blockchain will accept them

While this does not directly lead to fund theft (the attacker still needs access to the private key), it represents a "Limited Protocol Violation" with "State inconsistencies" as defined in the Medium severity criteria of the Aptos bug bounty program.

## Likelihood Explanation

**Moderate Likelihood:**

- **Exploitability**: Any user can exploit this by using malicious client software or a non-compliant WebAuthn authenticator implementation
- **No Special Privileges**: Attack requires no validator access, governance participation, or special privileges
- **Realistic Attack Vector**: Software-based authenticators or compromised browser extensions could be manipulated to set UP=0/UV=0
- **User Expectation Violation**: Users selecting WebAuthn expect the W3C specification to be followed, including user presence enforcement
- **Hardware vs Software**: While hardware authenticators (YubiKey, etc.) correctly set flags, the blockchain cannot verify this independently, and software authenticators are more susceptible to manipulation

## Recommendation

Implement proper authenticator data validation according to W3C WebAuthn specification Section 7.2:

```rust
fn validate_authenticator_data(authenticator_data: &[u8]) -> Result<()> {
    if authenticator_data.len() < 37 {
        return Err(anyhow!("Authenticator data too short"));
    }
    
    // Extract flags byte (byte 32)
    let flags = authenticator_data[32];
    
    // Check User Present (bit 0)
    if (flags & 0x01) == 0 {
        return Err(anyhow!("User Present flag not set"));
    }
    
    // Optionally check User Verified (bit 2) based on policy
    // if (flags & 0x04) == 0 {
    //     return Err(anyhow!("User Verified flag not set"));
    // }
    
    Ok(())
}
```

Integrate this validation into the `verify` function before signature verification:

```rust
pub fn verify<T: Serialize + CryptoHash>(
    &self,
    message: &T,
    public_key: &AnyPublicKey,
) -> Result<()> {
    // Existing challenge validation...
    
    // Add authenticator data validation
    validate_authenticator_data(&self.authenticator_data)?;
    
    // Continue with signature verification...
}
```

## Proof of Concept

```rust
#[test]
fn test_webauthn_accepts_up_flag_zero() {
    // Create authenticator data with UP=0 (byte 32 = 0x1C instead of 0x1D)
    let bad_authenticator_data: Vec<u8> = vec![
        73, 150, 13, 229, 136, 14, 140, 104, 116, 52, 23, 15, 100, 118, 96, 91, 
        143, 228, 174, 185, 162, 134, 50, 199, 153, 92, 243, 186, 131, 29, 151, 99,
        0x1C, // Byte 32: flags with UP=0 (0x1C = 0b00011100)
        0, 0, 0, 0,
    ];
    
    // Create valid signature over this data
    let raw_txn = get_test_raw_transaction();
    let collected_client_data = get_collected_client_data(&raw_txn);
    let client_data_json = serde_json::to_vec(&collected_client_data).unwrap();
    
    let private_key = PrivateKey::generate_for_testing();
    let public_key = private_key.public_key();
    
    let signature_material = [bad_authenticator_data.as_slice(), 
                             &sha256(&client_data_json)].concat();
    let signature = private_key.sign_arbitrary_message(&signature_material);
    
    let paar = PartialAuthenticatorAssertionResponse::new(
        AssertionSignature::Secp256r1Ecdsa { signature },
        bad_authenticator_data,
        client_data_json,
    );
    
    let any_public_key = AnyPublicKey::Secp256r1Ecdsa { public_key };
    
    // This should FAIL but currently PASSES
    let result = paar.verify(&raw_txn, &any_public_key);
    assert!(result.is_ok()); // Demonstrates vulnerability: accepts UP=0
}
```

This test demonstrates that the current implementation accepts WebAuthn signatures with the User Present flag set to 0, violating the W3C WebAuthn specification requirement that this flag must be checked during verification.

## Notes

This vulnerability affects the core WebAuthn authentication implementation used for both standalone WebAuthn accounts and as ephemeral signatures in keyless accounts. The missing validation applies to all WebAuthn signature verification paths in the codebase. While hardware authenticators like YubiKey correctly set these flags, the blockchain's failure to verify them means it cannot distinguish between properly authorized transactions and those signed by malicious software authenticators that bypass user presence requirements.

### Citations

**File:** types/src/transaction/webauthn.rs (L19-29)
```rust
fn generate_verification_data(authenticator_data_bytes: &[u8], client_data_json: &[u8]) -> Vec<u8> {
    // Let hash be the result of computing a hash over the clientData using SHA-256.
    let client_data_json_hash = sha256(client_data_json);
    // Binary concatenation of authData and hash.
    // Note: This is compatible with signatures generated by FIDO U2F
    // authenticators. See ยง6.1.2 FIDO U2F Signature Format Compatibility
    // See <https://www.w3.org/TR/webauthn-3/#sctn-fido-u2f-sig-format-compat>
    [authenticator_data_bytes, &client_data_json_hash]
        .concat()
        .to_vec()
}
```

**File:** types/src/transaction/webauthn.rs (L134-165)
```rust
    pub fn verify<T: Serialize + CryptoHash>(
        &self,
        message: &T,
        public_key: &AnyPublicKey,
    ) -> Result<()> {
        let collected_client_data: CollectedClientData =
            serde_json::from_slice(self.client_data_json.as_slice())?;
        let challenge_bytes = Bytes::try_from(collected_client_data.challenge.as_str())
            .map_err(|e| anyhow!("Failed to decode challenge bytes {:?}", e))?;

        // Check if expected challenge and actual challenge match. If there's no match, throw error
        verify_expected_challenge_from_message_matches_actual(message, challenge_bytes.as_slice())?;

        // Generates binary concatenation of authenticator_data and hash(client_data_json)
        let verification_data = generate_verification_data(
            self.authenticator_data.as_slice(),
            self.client_data_json.as_slice(),
        );

        // Note: We must call verify_arbitrary_msg instead of verify here. We do NOT want to
        // use verify because it BCS serializes and prefixes the message with a hash
        // via the signing_message function invocation
        match (&public_key, &self.signature) {
            (
                AnyPublicKey::Secp256r1Ecdsa { public_key },
                AssertionSignature::Secp256r1Ecdsa { signature },
            ) => signature.verify_arbitrary_msg(&verification_data, public_key),
            _ => Err(anyhow!(
                "WebAuthn verification failure, invalid key, signature pairing"
            )),
        }
    }
```

**File:** types/src/transaction/webauthn.rs (L320-323)
```rust
    static AUTHENTICATOR_DATA: &[u8] = &[
        73, 150, 13, 229, 136, 14, 140, 104, 116, 52, 23, 15, 100, 118, 96, 91, 143, 228, 174, 185,
        162, 134, 50, 199, 153, 92, 243, 186, 131, 29, 151, 99, 29, 0, 0, 0, 0,
    ];
```
