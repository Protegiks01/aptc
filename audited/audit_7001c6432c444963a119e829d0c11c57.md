# Audit Report

## Title
Missing Validator Authorization Check in `send_to()` Allows Consensus Messages to Non-Validator Peers

## Summary
The `send_to()` function in `consensus/src/network_interface.rs` does not validate that the destination peer is an authorized validator before sending consensus messages. This allows consensus-related information to be sent to peers that are no longer in the active validator set, particularly during epoch transitions.

## Finding Description

The `send_to()` function accepts an arbitrary `PeerId` and sends consensus messages without verifying that the peer is in the current validator set. [1](#0-0) 

The function simply converts the `PeerId` to a `PeerNetworkId` and delegates to the network layer without any authorization check: [2](#0-1) 

This becomes exploitable when:

1. **Epoch Retrieval Requests**: The `check_epoch()` function processes `EpochRetrievalRequest` messages without signature verification: [3](#0-2) 

2. **Response Without Validation**: The `process_epoch_retrieval()` function responds using `send_to()` with the requesting peer's ID, without checking if that peer is in the current validator set: [4](#0-3) 

**Attack Scenario**:
- Peer P is a validator in epoch N and establishes connections
- Epoch transitions to N+1, where P is no longer a validator
- Before `close_stale_connections()` executes, P sends an `EpochRetrievalRequest`
- The validator responds with `EpochChangeProof` via `send_to(P_peer_id, ...)` without validating P's current authorization
- P receives sensitive consensus information despite no longer being an authorized validator

The connectivity manager does eventually close stale connections: [5](#0-4) 

However, there's a race condition window during epoch transitions where removed validators maintain active connections and can request/receive consensus messages.

## Impact Explanation

This vulnerability represents a **Medium Severity** issue per the Aptos bug bounty criteria:

- **Information Leakage**: Unauthorized peers can receive `EpochChangeProof` and other consensus messages during the epoch transition window
- **Access Control Violation**: Breaks the invariant that only authorized validators should receive consensus-related information
- **State Inconsistency**: During epoch transitions, the validator set in `NetworkSender.validators` may be updated before network connections are closed, creating a timing window where the two are inconsistent

While this doesn't directly cause consensus safety violations or fund loss, it violates defense-in-depth principles and could leak strategic consensus information to removed validators.

## Likelihood Explanation

**Likelihood: Medium to High**

- **Triggering Condition**: Epoch changes occur regularly (every few hours in mainnet)
- **Attacker Requirements**: Must have been a validator in a previous epoch or have compromised a validator's connection credentials
- **Window of Opportunity**: The race condition exists between validator set update and connection closure
- **No Signature Required**: `EpochRetrievalRequest` doesn't require signature verification, making it trivial to exploit once connected

The attack is realistic and requires minimal sophistication once the attacker has an authenticated connection from a previous epoch.

## Recommendation

Add validator authorization validation in `send_to()` or its callers:

**Option 1**: Validate in `send_to()` itself:
```rust
pub fn send_to(&self, peer: PeerId, message: ConsensusMsg) -> Result<(), Error> {
    // Validate peer is in current validator set
    if !self.validators.contains(&peer) {
        return Err(Error::UnauthorizedPeer(peer));
    }
    
    let peer_network_id = self.get_peer_network_id_for_peer(peer);
    self.network_client.send_to_peer(message, peer_network_id)
}
```

**Option 2**: Validate before calling `send_to()` in `process_epoch_retrieval()`:
```rust
fn process_epoch_retrieval(
    &mut self,
    request: EpochRetrievalRequest,
    peer_id: AccountAddress,
) -> anyhow::Result<()> {
    // Validate peer is in current validator set
    if let Some(epoch_state) = &self.epoch_state {
        ensure!(
            epoch_state.verifier.get_voting_power(&peer_id).is_some(),
            "Peer {} is not in current validator set",
            peer_id
        );
    }
    
    // ... rest of function
}
```

**Recommended Approach**: Implement both for defense in depth - validate at the application layer (Option 2) for early rejection, and add a safety check in `send_to()` (Option 1) to prevent other code paths from bypassing validation.

Additionally, ensure `close_stale_connections()` is called immediately upon epoch state changes, before processing any messages in the new epoch.

## Proof of Concept

```rust
// Test demonstrating the vulnerability
#[tokio::test]
async fn test_send_to_non_validator() {
    // Setup: Create a NetworkSender with validator set containing only validator_1
    let validator_1 = create_test_peer(1);
    let validator_2 = create_test_peer(2); // Will be removed
    let removed_validator = create_test_peer(3); // Not in validator set
    
    let mut validators = ValidatorVerifier::new(vec![
        (validator_1, 1),
        (validator_2, 1),
    ]);
    
    let network_sender = create_network_sender(validators);
    
    // Epoch changes - validator_2 is removed, but connection still active
    validators = ValidatorVerifier::new(vec![
        (validator_1, 1),
    ]);
    // Note: validator_2 still has active connection
    
    // validator_2 sends EpochRetrievalRequest
    let request = EpochRetrievalRequest {
        start_epoch: 1,
        end_epoch: 2,
    };
    
    // Process the request - this will call send_to(validator_2, response)
    // WITHOUT validating that validator_2 is in current validator set
    epoch_manager.process_epoch_retrieval(request, validator_2).await;
    
    // VULNERABILITY: EpochChangeProof was sent to validator_2 despite
    // not being in the current validator set
    assert!(message_sent_to_unauthorized_peer);
}
```

**Note**: This PoC requires access to Aptos consensus testing infrastructure. The vulnerability can be verified by:
1. Starting a test network with multiple validators
2. Triggering an epoch change that removes a validator
3. Having the removed validator send an `EpochRetrievalRequest` before connection closure
4. Observing that the response is sent without authorization validation

---

**Notes**

While the network layer provides mutual authentication at connection establishment, the consensus layer should implement defense-in-depth by validating peer authorization at the application level. The `NetworkSender` already maintains a `validators` field containing the current validator set, but `send_to()` does not utilize it for validation. This creates a security gap during epoch transitions where the timing of validator set updates, message processing, and connection management can become misaligned.

### Citations

**File:** consensus/src/network_interface.rs (L177-180)
```rust
    pub fn send_to(&self, peer: PeerId, message: ConsensusMsg) -> Result<(), Error> {
        let peer_network_id = self.get_peer_network_id_for_peer(peer);
        self.network_client.send_to_peer(message, peer_network_id)
    }
```

**File:** consensus/src/network_interface.rs (L235-237)
```rust
    fn get_peer_network_id_for_peer(&self, peer: PeerId) -> PeerNetworkId {
        PeerNetworkId::new(NetworkId::Validator, peer)
    }
```

**File:** consensus/src/epoch_manager.rs (L451-476)
```rust
    fn process_epoch_retrieval(
        &mut self,
        request: EpochRetrievalRequest,
        peer_id: AccountAddress,
    ) -> anyhow::Result<()> {
        debug!(
            LogSchema::new(LogEvent::ReceiveEpochRetrieval)
                .remote_peer(peer_id)
                .epoch(self.epoch()),
            "[EpochManager] receive {}", request,
        );
        let proof = self
            .storage
            .aptos_db()
            .get_epoch_ending_ledger_infos(request.start_epoch, request.end_epoch)
            .map_err(DbError::from)
            .context("[EpochManager] Failed to get epoch proof")?;
        let msg = ConsensusMsg::EpochChangeProof(Box::new(proof));
        if let Err(err) = self.network_sender.send_to(peer_id, msg) {
            warn!(
                "[EpochManager] Failed to send epoch proof to {}, with error: {:?}",
                peer_id, err,
            );
        }
        Ok(())
    }
```

**File:** consensus/src/epoch_manager.rs (L1677-1686)
```rust
            ConsensusMsg::EpochRetrievalRequest(request) => {
                ensure!(
                    request.end_epoch <= self.epoch(),
                    "[EpochManager] Received EpochRetrievalRequest beyond what we have locally"
                );
                monitor!(
                    "process_epoch_retrieval",
                    self.process_epoch_retrieval(*request, peer_id)
                )?;
            },
```

**File:** network/framework/src/connectivity_manager/mod.rs (L484-530)
```rust
    async fn close_stale_connections(&mut self) {
        if let Some(trusted_peers) = self.get_trusted_peers() {
            // Identify stale peer connections
            let stale_peers = self
                .connected
                .iter()
                .filter(|(peer_id, _)| !trusted_peers.contains_key(peer_id))
                .filter_map(|(peer_id, metadata)| {
                    // If we're using server only auth, we need to not evict unknown peers
                    // TODO: We should prevent `Unknown` from discovery sources
                    if !self.mutual_authentication
                        && metadata.origin == ConnectionOrigin::Inbound
                        && (metadata.role == PeerRole::ValidatorFullNode
                            || metadata.role == PeerRole::Unknown)
                    {
                        None
                    } else {
                        Some(*peer_id) // The peer is stale
                    }
                });

            // Close existing connections to stale peers
            for stale_peer in stale_peers {
                info!(
                    NetworkSchema::new(&self.network_context).remote_peer(&stale_peer),
                    "{} Closing stale connection to peer {}",
                    self.network_context,
                    stale_peer.short_str()
                );

                if let Err(disconnect_error) = self
                    .connection_reqs_tx
                    .disconnect_peer(stale_peer, DisconnectReason::StaleConnection)
                    .await
                {
                    info!(
                        NetworkSchema::new(&self.network_context)
                            .remote_peer(&stale_peer),
                        error = %disconnect_error,
                        "{} Failed to close stale connection to peer {}, error: {}",
                        self.network_context,
                        stale_peer.short_str(),
                        disconnect_error
                    );
                }
            }
        }
```
