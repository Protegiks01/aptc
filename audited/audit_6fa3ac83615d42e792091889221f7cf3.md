# Audit Report

## Title
Distance Metadata Spoofing in State Sync Peer Selection Enables Preferential Selection and Denial of Service

## Summary
The state sync peer selection mechanism in `choose_random_peers_by_distance_and_latency()` relies on self-reported `distance_from_validators` metadata to prioritize peers. For peers reporting distance ≥ 2, validation only checks if the distance is below the maximum threshold (100), without verifying the claimed distance is authentic. This allows malicious peers to falsely claim proximity to validators (e.g., distance 2 instead of actual distance 10), ensuring preferential selection for state sync requests regardless of their actual network position.

## Finding Description

The vulnerability exists in the interaction between three components:

**1. Peer Selection Logic** [1](#0-0) 

The peer selection function groups peers by distance in a BTreeMap (sorted ascending) and processes them in order, explicitly prioritizing distance over latency. Peers with lower reported distances are selected first.

**2. Distance Calculation on Server** [2](#0-1) 

Each peer calculates its own `distance_from_validators` by finding the minimum distance among its connected peers and adding 1. This self-calculated value is returned in `NetworkInformationResponse` responses without cryptographic proof or third-party verification.

**3. Insufficient Validation** [3](#0-2) 

The validation logic has a critical gap: for distances ≥ 2, it only checks `distance_from_validators <= MAX_DISTANCE_FROM_VALIDATORS` without verifying peer role or distance authenticity. This contrasts with strict checks for distance 0 (must be validator) and distance 1 (must be VFN).

**Attack Execution:**

1. Attacker runs a malicious node with modified peer monitoring service
2. The modified server's `get_network_information()` function returns a hardcoded low distance value (e.g., 2) instead of calculating it honestly
3. When legitimate nodes query the attacker for network information, they receive `distance_from_validators = 2`
4. The validation passes because distance 2 ≥ 2 only requires `distance <= 100` [4](#0-3) 
5. During state sync, the attacker is placed in an earlier BTreeMap group than legitimate peers at higher distances
6. The attacker gets selected preferentially for state sync requests [5](#0-4) 

**Regarding Latency Manipulation:**

While latency itself is measured by the requester (not self-reported) [6](#0-5) , an attacker could respond quickly to latency ping requests while being slow or non-responsive to actual data requests. However, the distance manipulation alone is sufficient to ensure preferential selection due to the BTreeMap ordering.

## Impact Explanation

**Severity: High** (per Aptos Bug Bounty criteria)

This vulnerability enables multiple attack vectors:

1. **Denial of Service**: Multiple attackers claiming distance 2 can crowd out legitimate nearby peers, monopolizing state sync requests. If they respond slowly or not at all, they degrade state sync performance across the network, causing "validator node slowdowns."

2. **Network Degradation**: Nodes performing initial state sync or catching up after being offline will preferentially connect to attackers, slowing their synchronization and potentially preventing them from rejoining the network effectively.

3. **Observation Attacks**: Attackers gain visibility into state sync patterns, timing, and request frequencies, potentially revealing network topology or validator behavior.

4. **Targeted DoS**: Attackers can selectively serve data to specific nodes while being unresponsive to others, enabling targeted disruption of specific validators or full nodes.

While data integrity should be protected by Merkle proof verification in higher layers, the preferential selection itself is a significant protocol violation that affects network availability and reliability.

## Likelihood Explanation

**Likelihood: High**

The attack has minimal barriers to execution:

- **No Special Access Required**: Any node can connect to the network and run modified server code
- **No Cryptographic Challenges**: Distance values are self-asserted without signatures or proofs
- **Easy Detection Evasion**: The validation gap for distance ≥ 2 means false claims pass all checks
- **Low Resource Requirements**: A single modified node can affect multiple victims
- **Persistent Effect**: Once distance metadata is stored, it continues to influence peer selection until updated

The trust model assumes peers honestly report their network position, but provides no mechanism to verify this assumption for distance ≥ 2.

## Recommendation

Implement strict validation for all distance values, not just 0 and 1. The validation should verify the claimed distance is consistent with the peer's role and network context:

**For distance = 2:**
- Peer should typically be a PFN (Public Full Node) or disconnected VFN
- Peer should NOT be on validator or VFN networks unless they're disconnected from validator set
- Add role-based validation similar to distance 0 and 1 checks

**For distance ≥ 3:**
- Consider adding reputation scoring based on historical accuracy
- Implement cross-validation: query multiple peers about network topology and detect inconsistencies
- Add penalties for peers whose claimed distance deviates significantly from peer-reported views

**Enhanced validation example** (modify `network_info.rs`):

```rust
// Current vulnerable code at lines 137-140
distance_from_validators => {
    // The distance must be less than or equal to the max
    distance_from_validators <= MAX_DISTANCE_FROM_VALIDATORS
}

// Recommended fix
distance_from_validators => {
    // Check maximum distance
    if distance_from_validators > MAX_DISTANCE_FROM_VALIDATORS {
        return false;
    }
    
    // Additional validation for distance >= 2
    if distance_from_validators >= 2 {
        let peer_role = peer_metadata.get_connection_metadata().role;
        let network_id = peer_network_id.network_id();
        
        // If on validator/VFN network with distance >= 2, peer should be disconnected/unknown
        if network_id.is_validator_network() || network_id.is_vfn_network() {
            // On these networks, high distance implies peer is not properly connected
            // This is suspicious and should be treated cautiously
            !peer_role.is_validator() && !peer_role.is_vfn()
        } else {
            // On public network, allow but consider implementing reputation tracking
            true
        }
    } else {
        true
    }
}
```

Additionally, consider implementing distance verification through:
- Cryptographic attestations from validators about their immediate neighbors
- Consensus on network topology through validator agreement
- Reputation scoring that penalizes peers whose claimed distances are frequently contradicted

## Proof of Concept

```rust
// Malicious peer monitoring server modification
// File: peer-monitoring-service/server/src/lib.rs

// ATTACK: Modified get_network_information to always return low distance
fn get_network_information(&self) -> Result<PeerMonitoringServiceResponse, Error> {
    // Get the connected peers (normal behavior)
    let connected_peers_and_metadata =
        self.peers_and_metadata.get_connected_peers_and_metadata()?;
    let connected_peers = connected_peers_and_metadata
        .into_iter()
        .map(|(peer, metadata)| {
            let connection_metadata = metadata.get_connection_metadata();
            (
                peer,
                ConnectionMetadata::new(
                    connection_metadata.addr,
                    connection_metadata.remote_peer_id,
                    connection_metadata.role,
                ),
            )
        })
        .collect();

    // ATTACK: Instead of calculating honest distance, return false value
    // Original: let distance_from_validators = get_distance_from_validators(&self.base_config, self.peers_and_metadata.clone());
    let distance_from_validators = 2u64; // MALICIOUS: Always claim distance 2

    // Create and return the response with falsified distance
    let network_information_response = NetworkInformationResponse {
        connected_peers,
        distance_from_validators,
    };
    Ok(PeerMonitoringServiceResponse::NetworkInformation(
        network_information_response,
    ))
}
```

**Test Scenario:**
1. Deploy modified node claiming distance = 2 (actual distance ≥ 5)
2. Legitimate node queries attacker's network information
3. Attacker returns distance = 2
4. Validation passes (only checks `2 <= 100`)
5. During state sync peer selection, attacker is placed in BTreeMap group with key = 2
6. Attacker is selected before legitimate peers at distances 3, 4, 5, etc.
7. Attacker can now delay/drop requests, observe patterns, or serve incorrect data

This demonstrates the validation gap allows arbitrary distance claims ≥ 2, breaking the assumption that peer selection accurately prioritizes network proximity.

## Notes

While the focus is on distance manipulation, the title question asks about "simultaneous" manipulation of both distance and latency. Latency cannot be directly spoofed since it's measured by the requester, not self-reported. However, an attacker could optimize responses to latency pings while being slow with actual data, creating a mismatch between measured ping latency and real data transfer performance. The distance spoofing alone is sufficient for preferential selection due to the explicit prioritization: "We prioritize distance over latency" [7](#0-6) .

### Citations

**File:** state-sync/aptos-data-client/src/utils.rs (L23-25)
```rust
/// Chooses peers weighted by distance from the validator set
/// and latency. We prioritize distance over latency as we want
/// to avoid close but not up-to-date peers.
```

**File:** state-sync/aptos-data-client/src/utils.rs (L26-64)
```rust
pub fn choose_random_peers_by_distance_and_latency(
    peers: HashSet<PeerNetworkId>,
    peers_and_metadata: Arc<PeersAndMetadata>,
    num_peers_to_choose: usize,
) -> HashSet<PeerNetworkId> {
    // Group peers and latency weights by validator distance, i.e., distance -> [(peer, latency weight)]
    let mut peers_and_latencies_by_distance = BTreeMap::new();
    for peer in peers {
        if let Some((distance, latency)) =
            get_distance_and_latency_for_peer(&peers_and_metadata, peer)
        {
            let latency_weight = convert_latency_to_weight(latency);
            peers_and_latencies_by_distance
                .entry(distance)
                .or_insert_with(Vec::new)
                .push((peer, latency_weight));
        }
    }

    // Select the peers by distance and latency weights. Note: BTreeMaps are
    // sorted by key, so the entries will be sorted by distance in ascending order.
    let mut selected_peers = HashSet::new();
    for (_, peers_and_latencies) in peers_and_latencies_by_distance {
        // Select the peers by latency weights
        let num_peers_remaining = num_peers_to_choose.saturating_sub(selected_peers.len()) as u64;
        let peers = choose_random_peers_by_weight(num_peers_remaining, peers_and_latencies);

        // Add the peers to the entire set
        selected_peers.extend(peers);

        // If we have selected enough peers, return early
        if selected_peers.len() >= num_peers_to_choose {
            return selected_peers;
        }
    }

    // Return the selected peers
    selected_peers
}
```

**File:** peer-monitoring-service/server/src/lib.rs (L296-340)
```rust
/// Returns the distance from the validators using the given base config
/// and the peers and metadata information.
fn get_distance_from_validators(
    base_config: &BaseConfig,
    peers_and_metadata: Arc<PeersAndMetadata>,
) -> u64 {
    // Get the connected peers and metadata
    let connected_peers_and_metadata = match peers_and_metadata.get_connected_peers_and_metadata() {
        Ok(connected_peers_and_metadata) => connected_peers_and_metadata,
        Err(error) => {
            warn!(LogSchema::new(LogEntry::PeerMonitoringServiceError).error(&error.into()));
            return MAX_DISTANCE_FROM_VALIDATORS;
        },
    };

    // If we're a validator and we have active validator peers, we're in the validator set.
    // TODO: figure out if we need to deal with validator set forks here.
    if base_config.role.is_validator() {
        for peer_metadata in connected_peers_and_metadata.values() {
            if peer_metadata.get_connection_metadata().role.is_validator() {
                return 0;
            }
        }
    }

    // Otherwise, go through our peers, find the min, and return a distance relative to the min
    let mut min_peer_distance_from_validators = MAX_DISTANCE_FROM_VALIDATORS;
    for peer_metadata in connected_peers_and_metadata.values() {
        if let Some(ref latest_network_info_response) = peer_metadata
            .get_peer_monitoring_metadata()
            .latest_network_info_response
        {
            min_peer_distance_from_validators = min(
                min_peer_distance_from_validators,
                latest_network_info_response.distance_from_validators,
            );
        }
    }

    // We're one hop away from the peer
    min(
        MAX_DISTANCE_FROM_VALIDATORS,
        min_peer_distance_from_validators + 1,
    )
}
```

**File:** peer-monitoring-service/client/src/peer_states/network_info.rs (L116-154)
```rust
        // Sanity check the response depth from the peer metadata
        let network_id = peer_network_id.network_id();
        let is_valid_depth = match network_info_response.distance_from_validators {
            0 => {
                // Verify the peer is a validator and has the correct network id
                let peer_is_validator = peer_metadata.get_connection_metadata().role.is_validator();
                let peer_has_correct_network = match self.base_config.role {
                    RoleType::Validator => network_id.is_validator_network(), // We're a validator
                    RoleType::FullNode => network_id.is_vfn_network(),        // We're a VFN
                };
                peer_is_validator && peer_has_correct_network
            },
            1 => {
                // Verify the peer is a VFN and has the correct network id
                let peer_is_vfn = peer_metadata.get_connection_metadata().role.is_vfn();
                let peer_has_correct_network = match self.base_config.role {
                    RoleType::Validator => network_id.is_vfn_network(), // We're a validator
                    RoleType::FullNode => network_id.is_public_network(), // We're a VFN or PFN
                };
                peer_is_vfn && peer_has_correct_network
            },
            distance_from_validators => {
                // The distance must be less than or equal to the max
                distance_from_validators <= MAX_DISTANCE_FROM_VALIDATORS
            },
        };

        // If the depth did not pass our sanity checks, handle a failure
        if !is_valid_depth {
            warn!(LogSchema::new(LogEntry::NetworkInfoRequest)
                .event(LogEvent::InvalidResponse)
                .peer(peer_network_id)
                .message(&format!(
                    "Peer returned invalid depth from validators: {}",
                    network_info_response.distance_from_validators
                )));
            self.handle_request_failure();
            return;
        }
```

**File:** peer-monitoring-service/client/src/peer_states/latency_info.rs (L76-97)
```rust
    pub fn record_new_latency_and_reset_failures(
        &mut self,
        latency_ping_counter: u64,
        latency_ping_time_secs: f64,
    ) {
        // Update the request tracker with a successful response
        self.request_tracker.write().record_response_success();

        // Save the latency ping time
        self.recorded_latency_ping_durations_secs
            .insert(latency_ping_counter, latency_ping_time_secs);

        // Perform garbage collection on the recorded latency pings
        let max_num_latency_pings_to_retain = self
            .latency_monitoring_config
            .max_num_latency_pings_to_retain;
        if self.recorded_latency_ping_durations_secs.len() > max_num_latency_pings_to_retain {
            // We only need to pop a single element because insertion only happens in this method.
            // Thus, the size can only ever grow to be 1 greater than the max.
            let _ = self.recorded_latency_ping_durations_secs.pop_first();
        }
    }
```
