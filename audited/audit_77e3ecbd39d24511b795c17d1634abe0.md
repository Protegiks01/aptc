# Audit Report

## Title
Aptos Faucet IP Validation Bypass via Private/Local IP Ranges Allows Rate Limiting Evasion

## Summary
The Aptos faucet service's `preprocess_request()` function does not validate that source IP addresses are from public, routable ranges. Attackers on internal networks or those who can spoof proxy headers with private IP addresses (127.0.0.0/8, 10.0.0.0/8, 192.168.0.0/16, 172.16.0.0/12) can bypass IP-based rate limiting by cycling through different private IPs, each treated as a unique client.

## Finding Description
The vulnerability exists in the IP extraction and validation flow within the faucet service: [1](#0-0) 

The `preprocess_request()` function extracts the source IP from the `RealIp` parameter (which reads X-Forwarded-For and X-Real-IP headers) and directly uses it without validating whether the IP is from a private or loopback range. The extracted IP is then stored in `CheckerData`: [2](#0-1) 

This `source_ip` is subsequently used by rate limiting checkers such as `MemoryRatelimitChecker`: [3](#0-2) 

The rate limiter tracks requests per IP address, treating each unique IP as a separate client. However, there is no validation that rejects private IP ranges.

The `IpBlocklistChecker` only blocks IP ranges explicitly configured in an external file: [4](#0-3) 

A grep search of the entire faucet codebase confirms no usage of Rust's standard IP validation methods (`is_global()`, `is_private()`, `is_loopback()`) to filter private ranges.

**Attack Scenario:**

1. Attacker gains access to internal network where faucet is deployed (e.g., docker network 172.16.1.0/24 as shown in deployment configs) [5](#0-4) 

2. OR attacker can spoof X-Forwarded-For headers if the reverse proxy doesn't sanitize them properly

3. Attacker cycles through private IPs:
   - 10.0.0.1, 10.0.0.2, ... 10.0.0.N
   - 192.168.1.1, 192.168.1.2, ... 192.168.1.N
   - 127.0.0.1, 127.0.0.2, ... 127.0.0.N

4. Each IP is treated as a unique client, bypassing the per-IP rate limit of `max_requests_per_day`

5. Attacker can drain faucet funds by making N Ã— `max_requests_per_day` requests instead of being limited to `max_requests_per_day`

## Impact Explanation
This vulnerability qualifies as **Medium Severity** per the Aptos bug bounty program criteria:

- **Limited funds loss**: An attacker can drain testnet faucet funds faster than intended, impacting legitimate users' ability to obtain test tokens
- **State inconsistencies requiring intervention**: Faucet rate limiting state becomes unreliable, requiring manual intervention to block malicious actors
- **Service availability impact**: Legitimate users may be unable to access faucet funds if attackers deplete them

The impact is limited because:
- Only affects testnet faucets, not mainnet funds
- Does not compromise validator consensus or blockchain security
- Does not allow theft from user accounts
- Requires either internal network access or proxy misconfiguration

## Likelihood Explanation
The likelihood is **MEDIUM to HIGH** depending on deployment configuration:

**High Likelihood Scenarios:**
- Faucet deployed using `run-simple` mode without reverse proxy [6](#0-5) 
- Faucet accessible from internal networks (common in testnet environments)
- Reverse proxy not configured to sanitize X-Forwarded-For headers from untrusted sources

**Attack Requirements:**
- Network access to faucet endpoint (either internal or external with header spoofing)
- Ability to make multiple HTTP requests
- No special privileges or validator access needed

**Complexity:** Low - attack can be automated with simple scripts

## Recommendation
Implement defense-in-depth validation to reject private and loopback IP ranges in `preprocess_request()`:

```rust
// In crates/aptos-faucet/core/src/endpoints/fund.rs
async fn preprocess_request(
    &self,
    fund_request: &FundRequest,
    source_ip: RealIp,
    header_map: &HeaderMap,
    dry_run: bool,
) -> poem::Result<(CheckerData, bool, Option<SemaphorePermit<'_>>), AptosTapError> {
    // ... existing permit acquisition code ...

    let source_ip = match source_ip.0 {
        Some(ip) => {
            // Reject private and loopback IP ranges
            if !is_public_ip(&ip) {
                return Err(AptosTapError::new(
                    format!("Source IP {} is from a private/local range and is not allowed", ip),
                    AptosTapErrorCode::InvalidSourceIp,
                ));
            }
            ip
        },
        None => {
            return Err(AptosTapError::new(
                "No source IP found in the request".to_string(),
                AptosTapErrorCode::SourceIpMissing,
            ))
        },
    };
    
    // ... rest of function ...
}

fn is_public_ip(ip: &IpAddr) -> bool {
    match ip {
        IpAddr::V4(ipv4) => {
            // Reject loopback (127.0.0.0/8)
            // Reject private (10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16)
            // Reject link-local (169.254.0.0/16)
            // Reject multicast and broadcast
            !ipv4.is_loopback() 
                && !ipv4.is_private() 
                && !ipv4.is_link_local()
                && !ipv4.is_multicast()
                && !ipv4.is_broadcast()
        }
        IpAddr::V6(ipv6) => {
            // Reject loopback (::1)
            // Reject unique local addresses (fc00::/7)
            // Reject link-local (fe80::/10)
            // Reject multicast
            !ipv6.is_loopback() 
                && !ipv6.is_multicast()
                && !(ipv6.segments()[0] & 0xfe00 == 0xfc00) // unique local
        }
    }
}
```

**Additional Recommendations:**
1. Configure reverse proxies (HAProxy/nginx) to strip X-Forwarded-For headers from untrusted sources
2. Add IP range validation to `IpRangeManager` as an optional built-in checker
3. Document deployment best practices requiring private IP rejection at the proxy layer
4. Consider adding a configuration option to enable/disable private IP validation for development vs production

## Proof of Concept

```rust
#[cfg(test)]
mod private_ip_bypass_test {
    use super::*;
    use poem::http::HeaderMap;
    use poem::web::RealIp;
    use std::net::IpAddr;

    #[tokio::test]
    async fn test_private_ip_bypass_rate_limiting() {
        // Setup faucet with memory rate limiting (max 3 requests per day)
        let config = MemoryRatelimitCheckerConfig {
            max_requests_per_day: 3,
            max_entries_in_map: NonZeroUsize::new(1000).unwrap(),
        };
        let checker = MemoryRatelimitChecker::new(config);
        
        // Simulate requests from private IP range 10.0.0.x
        for i in 1..=10 {
            let private_ip: IpAddr = format!("10.0.0.{}", i).parse().unwrap();
            let checker_data = CheckerData {
                receiver: AccountAddress::random(),
                source_ip: private_ip,
                headers: Arc::new(HeaderMap::new()),
                time_request_received_secs: 1000,
            };
            
            // Each private IP should be treated as unique, bypassing the limit
            let result = checker.check(checker_data, false).await;
            assert!(result.is_ok());
            assert!(result.unwrap().is_empty(), "Request from {} should succeed", private_ip);
        }
        
        // With proper validation, these should all be rejected after 3 requests
        // But currently 10 requests succeed (one per unique private IP)
    }

    #[tokio::test]
    async fn test_loopback_ip_bypass() {
        let config = MemoryRatelimitCheckerConfig {
            max_requests_per_day: 1,
            max_entries_in_map: NonZeroUsize::new(1000).unwrap(),
        };
        let checker = MemoryRatelimitChecker::new(config);
        
        // Simulate requests from loopback range 127.0.0.x
        for i in 1..=5 {
            let loopback_ip: IpAddr = format!("127.0.0.{}", i).parse().unwrap();
            let checker_data = CheckerData {
                receiver: AccountAddress::random(),
                source_ip: loopback_ip,
                headers: Arc::new(HeaderMap::new()),
                time_request_received_secs: 1000,
            };
            
            let result = checker.check(checker_data, false).await;
            assert!(result.is_ok());
            // All 5 requests succeed despite max_requests_per_day = 1
        }
    }
}
```

**Notes:**
- This vulnerability represents a defense-in-depth failure where the faucet service trusts IP addresses from potentially untrusted sources without validation
- While proper reverse proxy configuration can mitigate this issue, the faucet code should not assume perfect proxy configuration
- The vulnerability is particularly relevant for development/testnet deployments where security configurations may be relaxed
- The issue does not affect mainnet validator security or consensus, but impacts testnet service availability and fund management

### Citations

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L217-225)
```rust
        let source_ip = match source_ip.0 {
            Some(ip) => ip,
            None => {
                return Err(AptosTapError::new(
                    "No source IP found in the request".to_string(),
                    AptosTapErrorCode::SourceIpMissing,
                ))
            },
        };
```

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L237-242)
```rust
        let checker_data = CheckerData {
            receiver,
            source_ip,
            headers: Arc::new(header_map.clone()),
            time_request_received_secs: get_current_time_secs(),
        };
```

**File:** crates/aptos-faucet/core/src/checkers/memory_ratelimit.rs (L67-91)
```rust
impl CheckerTrait for MemoryRatelimitChecker {
    async fn check(
        &self,
        data: CheckerData,
        dry_run: bool,
    ) -> Result<Vec<RejectionReason>, AptosTapError> {
        self.clear_if_new_day().await;

        let mut ip_to_requests_today = self.ip_to_requests_today.lock().await;

        let requests_today = ip_to_requests_today.get_or_insert_mut(data.source_ip, || 1);
        if *requests_today >= self.max_requests_per_day {
            return Ok(vec![RejectionReason::new(
                format!(
                    "IP {} has exceeded the daily limit of {} requests",
                    data.source_ip, self.max_requests_per_day
                ),
                RejectionReasonCode::UsageLimitExhausted,
            )]);
        } else if !dry_run {
            *requests_today += 1;
        }

        Ok(vec![])
    }
```

**File:** crates/aptos-faucet/core/src/checkers/ip_blocklist.rs (L26-51)
```rust
impl CheckerTrait for IpBlocklistChecker {
    async fn check(
        &self,
        data: CheckerData,
        _dry_run: bool,
    ) -> Result<Vec<RejectionReason>, AptosTapError> {
        match &data.source_ip {
            IpAddr::V4(source_ip) => {
                if self.manager.ipv4_list.contains(source_ip) {
                    return Ok(vec![RejectionReason::new(
                        format!("IP {} is in blocklist", source_ip),
                        RejectionReasonCode::IpInBlocklist,
                    )]);
                }
            },
            IpAddr::V6(source_ip) => {
                if self.manager.ipv6_list.contains(source_ip) {
                    return Ok(vec![RejectionReason::new(
                        format!("IP {} is in blocklist", source_ip),
                        RejectionReasonCode::IpInBlocklist,
                    )]);
                }
            },
        }
        Ok(vec![])
    }
```

**File:** docker/compose/validator-testnet/docker-compose.yaml (L80-84)
```yaml
  shared:
    name: "aptos-docker-compose-shared"
    ipam:
      config:
        - subnet: 172.16.1.0/24
```

**File:** crates/aptos-faucet/README.md (L32-41)
```markdown
To run the faucet, the simplest way to start is with this command:
```
cargo run -p aptos-faucet-service -- run-simple --key <private_key> --node-url <api_url> --chain-id TESTING
```

Another example, running alongside a localnet (without `--use-faucet`):
```
cargo run -p aptos -- node run-local-testnet --force-restart --assume-yes
cargo run -p aptos-faucet-service -- run-simple --key ~/.aptos/testnet/mint.key --node-url http://127.0.0.1:8080 --chain-id TESTING
```
```
