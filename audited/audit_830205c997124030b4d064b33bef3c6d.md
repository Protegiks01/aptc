# Audit Report

## Title
Lack of Issuer Canonicalization in JWK Consensus Enables Consensus Session Fragmentation

## Summary
The JWK consensus system does not canonicalize issuer strings before using them as consensus session keys. Different byte representations of the same logical issuer (e.g., "https://example.com" vs "https://example.com/") create separate consensus sessions, enabling consensus fragmentation attacks and resource exhaustion.

## Finding Description

Line 26 in `new_rb_request()` does NOT ensure issuer bytes are in canonical form. The function directly clones the raw issuer bytes from the payload without any normalization: [1](#0-0) 

The `Issuer` type is defined as a raw byte vector with no canonicalization: [2](#0-1) 

The issuer is used directly as the consensus session key: [3](#0-2) 

And stored in a HashMap where byte equality determines uniqueness: [4](#0-3) 

When processing peer requests, the system uses `or_default()` to create new states for unknown issuers: [5](#0-4) 

The Move governance code allows multiple OIDC providers with non-canonical issuer variants to coexist because it uses byte equality: [6](#0-5) 

**Attack Scenario:**

1. OIDC provider configured with issuer `b"https://accounts.google.com"`
2. Malicious (or accidental) governance proposal adds same provider with `b"https://accounts.google.com/"` (trailing slash)
3. Both configurations pass Move validation since `b"https://accounts.google.com" != b"https://accounts.google.com/"`
4. Validators spawn TWO JWKObservers for the same logical provider
5. Each creates separate entries in `states_by_issuer` HashMap
6. Validator A broadcasts `ObservedUpdateRequest` with issuer `b"https://accounts.google.com"`
7. Validator B receives request but only has state for `b"https://accounts.google.com/"`
8. Line 302 creates a NEW empty state for the unknown issuer variant
9. Validator B responds with "observed update unavailable" error since new state is `NotStarted`
10. Reliable broadcast consensus fails to reach quorum
11. This breaks the **Consensus Safety** invariant

## Impact Explanation

**HIGH Severity** - This qualifies as a "Significant protocol violation" under the bug bounty program:

- **Consensus Fragmentation**: Multiple consensus sessions run simultaneously for the same logical OIDC provider, preventing validators from reaching agreement
- **Resource Exhaustion**: Each issuer variant spawns separate JWKObservers, consensus sessions, and network messages
- **DoS Vector**: Malicious actor could propose many issuer variants (with/without trailing slashes, different capitalizations if case-sensitive, etc.) to overwhelm the JWK consensus system
- **Liveness Impact**: JWK updates fail to be certified, breaking keyless account authentication
- **State Inconsistency**: Different validators may process updates for different issuer variants, leading to inconsistent on-chain JWK state

## Likelihood Explanation

**Medium-High Likelihood**:

- **Easy to Trigger**: Only requires a governance proposal with a non-canonical issuer string
- **Natural Occurrence**: Honest mistakes during governance proposals (copy-paste errors, different URL formatting conventions) can trigger this without malicious intent
- **No Validation**: System has zero canonicalization or validation of issuer format
- **Observable Impact**: Once triggered, consensus failures are immediate and visible in validator logs
- **Difficult to Detect**: The root cause (non-canonical issuer) may not be immediately obvious to node operators

## Recommendation

Implement issuer canonicalization at multiple layers:

**1. Move Layer - Reject non-canonical issuers:**

Add validation in `upsert_oidc_provider_for_next_epoch()` to normalize issuer strings (remove trailing slashes, enforce lowercase for domain, etc.) or reject non-canonical formats.

**2. Rust Layer - Canonicalize before use:**

Create a canonicalization function:
```rust
fn canonicalize_issuer(issuer: &[u8]) -> Result<Vec<u8>> {
    let s = String::from_utf8(issuer.to_vec())?;
    let url = url::Url::parse(&s)?;
    // Remove trailing slash, normalize scheme/host
    let canonical = url.as_str().trim_end_matches('/');
    Ok(canonical.as_bytes().to_vec())
}
```

Apply in `new_rb_request()`:
```rust
fn new_rb_request(epoch: u64, payload: &ProviderJWKs) -> anyhow::Result<ObservedUpdateRequest> {
    Ok(ObservedUpdateRequest {
        epoch,
        issuer: canonicalize_issuer(&payload.issuer)?,
    })
}
```

**3. Prevent duplicate logical issuers:**

Add validation in `remove_oidc_provider_internal()` to check canonical equivalence, not just byte equality.

## Proof of Concept

```move
#[test(aptos_framework = @aptos_framework)]
fun test_issuer_canonicalization_vulnerability(aptos_framework: signer) {
    // Initialize JWK system
    jwks::initialize(&aptos_framework);
    
    // Configure OIDC provider without trailing slash
    jwks::upsert_oidc_provider(
        &aptos_framework,
        b"https://accounts.google.com",
        b"https://accounts.google.com/.well-known/openid-configuration"
    );
    
    // Malicious proposal: Add same provider WITH trailing slash
    // This should be rejected but currently is accepted
    jwks::upsert_oidc_provider(
        &aptos_framework,
        b"https://accounts.google.com/",  // Note trailing slash
        b"https://accounts.google.com/.well-known/openid-configuration"
    );
    
    // Verify both issuers coexist (they shouldn't!)
    let providers = borrow_global<SupportedOIDCProviders>(@aptos_framework);
    assert!(vector::length(&providers.providers) == 2, 0); // BUG: Should be 1
    
    // This creates two separate consensus sessions for the same logical provider
    // Leading to consensus fragmentation and resource waste
}
```

**Rust PoC demonstrating HashMap fragmentation:**
```rust
#[test]
fn test_issuer_variants_create_separate_sessions() {
    let mut states_by_issuer: HashMap<Issuer, PerProviderState> = HashMap::new();
    
    let issuer1 = b"https://example.com".to_vec();
    let issuer2 = b"https://example.com/".to_vec(); // With trailing slash
    
    states_by_issuer.insert(issuer1.clone(), PerProviderState::default());
    states_by_issuer.insert(issuer2.clone(), PerProviderState::default());
    
    // BUG: Both issuers create separate entries
    assert_eq!(states_by_issuer.len(), 2); // Should be 1 with canonicalization
    
    // When validator receives request for issuer1 but only has issuer2
    let request_issuer = issuer1;
    let state = states_by_issuer.entry(request_issuer).or_default();
    
    // Creates third entry! (or_default behavior)
    assert_eq!(states_by_issuer.len(), 3); // Demonstrates the fragmentation
}
```

## Notes

This vulnerability is particularly dangerous because:
1. It can be triggered accidentally through normal governance operations
2. The impact compounds over time as more issuer variants accumulate
3. No validation exists at any layer to prevent or detect this issue
4. The URL standard (RFC 3986) explicitly allows trailing slashes, making this a realistic edge case
5. Different OIDC providers may have different conventions for their issuer strings

### Citations

**File:** crates/aptos-jwk-consensus/src/mode/per_issuer.rs (L11-11)
```rust
    type ConsensusSessionKey = Issuer;
```

**File:** crates/aptos-jwk-consensus/src/mode/per_issuer.rs (L26-26)
```rust
            issuer: payload.issuer.clone(),
```

**File:** types/src/jwks/mod.rs (L36-36)
```rust
pub type Issuer = Vec<u8>;
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager/mod.rs (L54-54)
```rust
    states_by_issuer: HashMap<Issuer, PerProviderState>,
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager/mod.rs (L302-302)
```rust
                let state = self.states_by_issuer.entry(request.issuer).or_default();
```

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L447-447)
```text
            provider.name == name
```
