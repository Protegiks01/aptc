# Audit Report

## Title
Empty Proof Acceptance Vulnerability in PinkasWUF verify_proof() Bypasses Threshold Requirement

## Summary
The `verify_proof()` function in `PinkasWUF` (Aptos's production WVUF implementation for on-chain randomness) silently accepts empty proofs without validating that the minimum threshold weight requirement is met. This allows an attacker to bypass the distributed randomness generation mechanism by providing zero proof shares, which produces a predictable identity element as the evaluation, completely breaking the unpredictability guarantee of the Verifiable Unpredictable Function. [1](#0-0) 

## Finding Description

The vulnerability exists in the `PinkasWUF::verify_proof()` implementation, which is Aptos's production Weighted Verifiable Unpredictable Function used for on-chain randomness generation. [2](#0-1) 

**Root Cause Analysis:**

The verification function only checks that `proof.len() < apks.len()`, which prevents having more proof shares than total validators but **does not enforce any minimum threshold**: [1](#0-0) 

When an empty proof is provided (`proof.len() == 0`):

1. The check `0 >= apks.len()` evaluates to false (doesn't bail)
2. The `taus` vector becomes empty (powers of tau for 0 elements)
3. The `shares` vector becomes empty
4. The `pis` vector becomes empty (the for loop at line 235 doesn't execute)
5. `sum_of_taus` equals `Scalar::ZERO` [3](#0-2) 

The multi-pairing check then computes:
- LHS: `[pp.g_neg]` (one element)  
- RHS: `[h.mul(0)]` = `[G2::identity()]`

By pairing bilinearity, `e(pp.g_neg, G2::identity()) = Gt::identity()`, so the verification check becomes:

```rust
if Gt::identity() != Gt::identity() { bail!(...) }  // false, doesn't bail
``` [4](#0-3) 

The function returns `Ok(())`, **accepting the empty proof as valid**.

**Exploitation Path:**

When `derive_eval()` is called with this empty proof: [5](#0-4) 

The `collect_lagrange_coeffs_shares_and_rks()` function returns empty vectors since the proof is empty: [6](#0-5) 

The `multi_pairing` with empty inputs returns `Gt::identity()`, making the **evaluation completely predictable**:

```
evaluation = Gt::identity()
randomness_seed = SHA3_256(bcs_serialize(Gt::identity()))
```

This is a **deterministic, predictable value** instead of unpredictable randomness, completely breaking the VUF's security guarantee.

**Invariant Violations:**

1. **Cryptographic Correctness**: The threshold signature scheme requires at least threshold weight of validators to contribute, but zero validators can produce a "valid" proof
2. **Consensus Safety**: Predictable randomness can be exploited to manipulate leader election, breaking consensus liveness and fairness
3. **Deterministic Execution**: Different validators might derive different randomness if they accept/reject empty proofs inconsistently

The weighted config defines a threshold requirement: [7](#0-6) 

But `verify_proof()` never checks that the total weight of proof contributors meets this threshold.

## Impact Explanation

**Severity: CRITICAL** (Consensus/Safety Violation + Randomness Predictability)

This vulnerability breaks multiple critical security guarantees:

1. **On-Chain Randomness Predictability**: An attacker can force the randomness to be `SHA3_256(bcs_serialize(Gt::identity()))`, a completely predictable value. This breaks applications relying on unpredictable randomness for fairness.

2. **Consensus Manipulation**: Aptos uses on-chain randomness for leader election. Predictable randomness allows attackers to know future leaders in advance, enabling targeted denial-of-service attacks or censorship.

3. **Threshold Security Bypass**: The entire DKG system is designed around a threshold assumption (e.g., 2/3+ honest validators needed). This vulnerability allows bypassing that threshold entirely with zero validators contributing.

4. **Protocol Invariant Violation**: The WVUF is supposed to require threshold participation, but empty proofs violate this fundamental assumption.

This meets **Critical Severity** criteria:
- Consensus/Safety violation: Leader election can be manipulated
- Protocol violation: Threshold security bypassed
- Affects all nodes: All validators would accept the invalid randomness

## Likelihood Explanation

**Likelihood: HIGH**

The attack is trivially exploitable:

1. **No special privileges required**: Any actor can submit an empty proof
2. **No cryptographic complexity**: Just submit `proof = Vec::new()`
3. **Deterministic success**: The verification logic guarantees acceptance
4. **No resource requirements**: No computational cost or stake needed

The only requirement is access to the randomness submission mechanism, which is part of the normal consensus protocol flow.

## Recommendation

Add a check in `verify_proof()` to ensure the proof contains sufficient weight to meet the threshold requirement. However, the current function signature doesn't have access to the `WeightedConfig`, so this requires either:

**Option 1: Add WeightedConfig parameter to verify_proof()**

Modify the trait to include the weighted config:

```rust
fn verify_proof(
    wc: &WeightedConfigBlstrs,  // Add this parameter
    pp: &Self::PublicParameters,
    pk: &Self::PubKey,
    apks: &[Option<Self::AugmentedPubKeyShare>],
    msg: &[u8],
    proof: &Self::Proof,
) -> anyhow::Result<()>;
```

Then add validation:

```rust
// Calculate total weight from proof contributors
let mut total_weight = 0;
for (player, _) in proof {
    total_weight += wc.get_player_weight(player);
}

// Enforce threshold requirement
let threshold = wc.get_threshold_weight();
if total_weight < threshold {
    bail!(
        "Insufficient proof weight: got {}, need at least {}",
        total_weight,
        threshold
    );
}

// Also reject empty proofs explicitly
if proof.is_empty() {
    bail!("Empty proof is not allowed");
}
```

**Option 2: Simpler immediate fix - reject empty proofs**

As a minimal fix, add before line 218:

```rust
if proof.is_empty() {
    bail!("Empty proof contains no validator contributions");
}
```

This prevents the immediate vulnerability but doesn't fully enforce threshold requirements. The proper fix requires access to the weighted config to validate total contributed weight.

## Proof of Concept

```rust
#[test]
fn test_empty_proof_vulnerability() {
    use aptos_dkg::{
        pvss::{test_utils, WeightedConfigBlstrs, traits::Transcript},
        weighted_vuf::{pinkas::PinkasWUF, traits::WeightedVUF},
    };
    use rand::{rngs::StdRng, SeedableRng};
    use aptos_crypto::blstrs::random_scalar;
    
    let mut rng = thread_rng();
    let seed = random_scalar(&mut rng);
    let mut rng = StdRng::from_seed(seed.to_bytes_le());
    
    // Setup weighted config with threshold
    let wc = WeightedConfigBlstrs::new(10, vec![3, 5, 3, 4, 2, 1, 1, 7]).unwrap();
    let d = test_utils::setup_dealing::<pvss::das::WeightedTranscript, _>(&wc, &mut rng);
    
    let vuf_pp = <PinkasWUF as WeightedVUF>::PublicParameters::from(&d.pp);
    let msg = b"test message";
    
    // Decrypt shares and create augmented keys
    let apks: Vec<Option<_>> = (0..wc.get_total_num_players())
        .map(|p| {
            let player = wc.get_player(p);
            let (sk, pk) = trx.decrypt_own_share(&wc, &player, &d.dks[p], &d.pp);
            let (_, apk) = PinkasWUF::augment_key_pair(&vuf_pp, sk, pk, &mut rng);
            Some(apk)
        })
        .collect();
    
    // VULNERABILITY: Create empty proof
    let empty_proof: Vec<(Player, G2Projective)> = Vec::new();
    
    // This should FAIL but actually SUCCEEDS
    let result = PinkasWUF::verify_proof(
        &vuf_pp,
        &d.dpk,
        &apks[..],
        msg,
        &empty_proof
    );
    
    assert!(result.is_ok(), "VULNERABILITY: Empty proof passes verification!");
    
    // The derived evaluation is predictable
    let pool = spawn_rayon_thread_pool("test".to_string(), Some(1));
    let eval = PinkasWUF::derive_eval(&wc, &vuf_pp, msg, &apks[..], &empty_proof, &pool)
        .expect("derive_eval succeeds with empty proof");
    
    // The evaluation is the identity element (predictable!)
    assert_eq!(eval, Gt::identity(), "VULNERABILITY: Evaluation is predictable identity!");
}
```

This PoC demonstrates:
1. Empty proof passes `verify_proof()` without error
2. The derived evaluation is the predictable identity element
3. The threshold requirement (10 weight needed) is completely bypassed with 0 weight

## Notes

The vulnerability also affects `BlsWUF::verify_proof()` which has a similar pattern, though `PinkasWUF` is the production implementation per the type alias in `types/src/randomness.rs`. [8](#0-7) 

The test suite doesn't cover the empty proof edge case: [9](#0-8) 

The random eligible subset used in tests always contains at least one player, masking this vulnerability.

### Citations

**File:** crates/aptos-dkg/src/weighted_vuf/pinkas/mod.rs (L192-208)
```rust
    fn derive_eval(
        wc: &WeightedConfigBlstrs,
        _pp: &Self::PublicParameters,
        _msg: &[u8],
        apks: &[Option<Self::AugmentedPubKeyShare>],
        proof: &Self::Proof,
        thread_pool: &ThreadPool,
    ) -> anyhow::Result<Self::Evaluation> {
        let (rhs, rks, lagr, ranges) =
            Self::collect_lagrange_coeffs_shares_and_rks(wc, apks, proof)?;

        // Compute the RK multiexps in parallel
        let lhs = Self::rk_multiexps(proof, rks, &lagr, &ranges, thread_pool);

        // Interpolate the WVUF evaluation in parallel
        Ok(Self::multi_pairing(lhs, rhs, thread_pool))
    }
```

**File:** crates/aptos-dkg/src/weighted_vuf/pinkas/mod.rs (L218-220)
```rust
        if proof.len() >= apks.len() {
            bail!("Number of proof shares ({}) exceeds number of APKs ({}) when verifying aggregated WVUF proof", proof.len(), apks.len());
        }
```

**File:** crates/aptos-dkg/src/weighted_vuf/pinkas/mod.rs (L227-254)
```rust
        let shares = proof
            .iter()
            .map(|(_, share)| share)
            .zip(taus.iter())
            .map(|(share, tau)| share.mul(tau))
            .collect::<Vec<G2Projective>>();

        let mut pis = Vec::with_capacity(proof.len());
        for (player, _) in proof {
            if player.id >= apks.len() {
                bail!(
                    "Player index {} falls outside APK vector of length {}",
                    player.id,
                    apks.len()
                );
            }

            pis.push(
                apks[player.id]
                    .as_ref()
                    .ok_or_else(|| anyhow!("Missing APK for player {}", player.get_id()))?
                    .0
                    .pi,
            );
        }

        let h = Self::hash_to_curve(msg);
        let sum_of_taus: Scalar = taus.iter().sum();
```

**File:** crates/aptos-dkg/src/weighted_vuf/pinkas/mod.rs (L256-264)
```rust
        if multi_pairing(
            pis.iter().chain([pp.g_neg].iter()),
            shares.iter().chain([h.mul(sum_of_taus)].iter()),
        ) != Gt::identity()
        {
            bail!("Multipairing check in batched aggregate verification failed");
        }

        Ok(())
```

**File:** crates/aptos-dkg/src/weighted_vuf/pinkas/mod.rs (L292-313)
```rust
        let mut k = 0;
        for (player, share) in proof {
            for j in 0..wc.get_player_weight(player) {
                sub_player_ids.push(wc.get_virtual_player(player, j).id);
            }

            let apk = apks[player.id]
                .as_ref()
                .ok_or_else(|| anyhow!("Missing APK for player {}", player.get_id()))?;

            rks.push(&apk.0.rks);
            shares.push(share);

            let w = wc.get_player_weight(player);
            ranges.push(k..k + w);
            k += w;
        }

        // Compute the Lagrange coefficients associated with those evaluation points
        let batch_dom = wc.get_batch_evaluation_domain();
        let lagr = lagrange_coefficients(batch_dom, &sub_player_ids[..], &Scalar::ZERO);
        Ok((shares, rks, lagr, ranges))
```

**File:** types/src/randomness.rs (L11-11)
```rust
pub type WVUF = weighted_vuf::pinkas::PinkasWUF;
```

**File:** crates/aptos-crypto/src/weighted_config.rs (L152-155)
```rust
    /// Returns the threshold weight required to reconstruct the secret.
    pub fn get_threshold_weight(&self) -> usize {
        self.tc.get_threshold()
    }
```

**File:** crates/aptos-dkg/src/weighted_vuf/bls/mod.rs (L156-174)
```rust
    fn verify_proof(
        pp: &Self::PublicParameters,
        pk: &Self::PubKey,
        _apks: &[Option<Self::AugmentedPubKeyShare>],
        msg: &[u8],
        proof: &Self::Proof,
    ) -> anyhow::Result<()> {
        let hash = Self::hash_to_curve(msg);

        if multi_pairing(
            [&hash, proof].into_iter(),
            [pk.as_group_element(), &pp.g.neg()].into_iter(),
        ) != Gt::identity()
        {
            bail!("BlsWVUF Proof failed to verify.");
        }

        Ok(())
    }
```

**File:** crates/aptos-dkg/tests/weighted_vuf.rs (L147-166)
```rust
    let apks_and_proofs = wc
        .get_random_eligible_subset_of_players(rng)
        .into_iter()
        .map(|p| {
            let ask = &augmented_key_pairs[p.id].0;
            let apk = augmented_key_pairs[p.id].1.clone();

            let proof = WVUF::create_share(ask, msg);
            WVUF::verify_share(&vuf_pp, &apk, msg, &proof).expect("WVUF proof share should verify");

            (p, apk, proof)
        })
        .collect::<Vec<(Player, WVUF::AugmentedPubKeyShare, WVUF::ProofShare)>>();

    // Aggregate the VUF from the subset of capable players
    let proof = WVUF::aggregate_shares(&wc, &apks_and_proofs);

    // Make sure the aggregated proof is valid
    WVUF::verify_proof(&vuf_pp, pk, &apks[..], msg, &proof)
        .expect("WVUF aggregated proof should verify");
```
