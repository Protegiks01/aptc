# Audit Report

## Title
Non-Deterministic Access Control Due to Interned Module ID in StructIdentifier Comparison

## Summary
The `StructIdentifier` type includes a cached `interned_module_id` field in its equality and ordering comparisons. When validators have different module interning pool states (e.g., after cache flushes at different times, state sync, or restarts), they assign different `InternedModuleId` values to the same modules. This causes `AccessSpecifier::enables()` to return different results for identical resource access requests, violating the deterministic execution invariant and potentially causing consensus failures.

## Finding Description
The `StructIdentifier` struct is defined with derived `PartialEq`, `Eq`, `PartialOrd`, and `Ord` traits that compare all fields including `interned_module_id`: [1](#0-0) 

The `interned_module_id` field stores an index into the `InternedModuleIdPool`, assigned sequentially based on insertion order: [2](#0-1) 

During access control checks, `ResourceSpecifier::matches()` uses equality comparison on `StructIdentifier`: [3](#0-2) 

The interning pool can be flushed when size limits are exceeded: [4](#0-3) 

**Attack Scenario:**
1. Validator A processes many transactions, reaches flush threshold at block 5000, flushes module ID pool
2. Validator B was offline, syncs state up to block 5000 via different code path, has different cache state
3. Both execute transaction T in block 5001 that accesses resource `0x1::coin::Coin`
4. Validator A (post-flush): creates `StructIdentifier { module: 0x1::coin, interned_module_id: 42, name: "Coin" }`
5. Validator B (no flush): creates `StructIdentifier { module: 0x1::coin, interned_module_id: 8675, name: "Coin" }`
6. Access specifier loaded from function bytecode contains `StructIdentifier` with `interned_module_id: 42`
7. Validator A: comparison succeeds (`42 == 42`), access allowed
8. Validator B: comparison fails (`8675 != 42`), access denied
9. Different execution outcomes → different state roots → **consensus failure**

The vulnerability exists because `interned_module_id` is a cache implementation detail that should NOT affect semantic equality, but the derived traits treat it as part of the value's identity.

## Impact Explanation
**Critical Severity** - This breaks the fundamental "Deterministic Execution" invariant (invariant #1). When validators reach different `enables()` decisions:
- Transactions abort on some validators but succeed on others
- State roots diverge
- Validators cannot achieve consensus on block validity
- Chain splits occur, requiring manual intervention or hard fork
- Network availability is compromised until resolved

This meets the Critical severity criteria for "Consensus/Safety violations" and "Non-recoverable network partition (requires hardfork)".

## Likelihood Explanation
**Medium-High Likelihood**: While validators executing identical transaction sequences should maintain synchronized cache states, several scenarios can cause divergence:

1. **State Sync Divergence**: Validators syncing via state sync may build caches differently than validators that executed all transactions
2. **Restart Recovery**: Validators restarting from different checkpoints or snapshots may have different initial cache states
3. **Non-Deterministic Flush Timing**: If any code path differences cause validators to call `check_ready()` with slightly different cache sizes, they flush at different points
4. **Parallel Execution Variations**: Different scheduling in parallel transaction execution could theoretically affect module loading order

The vulnerability is latent - it won't manifest until cache states diverge, which may be rare but is not prevented by current code architecture.

## Recommendation
The `StructIdentifier` comparison should exclude the `interned_module_id` field. Implement custom `PartialEq`, `Eq`, `PartialOrd`, and `Ord` that only compare semantically meaningful fields:

```rust
impl PartialEq for StructIdentifier {
    fn eq(&self, other: &Self) -> bool {
        self.module == other.module && self.name == other.name
    }
}

impl Eq for StructIdentifier {}

impl PartialOrd for StructIdentifier {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        Some(self.cmp(other))
    }
}

impl Ord for StructIdentifier {
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        (&self.module, &self.name).cmp(&(&other.module, &other.name))
    }
}

impl Hash for StructIdentifier {
    fn hash<H: Hasher>(&self, state: &mut H) {
        self.module.hash(state);
        self.name.hash(state);
    }
}
```

The `interned_module_id` should remain for performance optimization in internal lookups but must not affect equality semantics.

## Proof of Concept

```rust
#[test]
fn test_struct_identifier_determinism_violation() {
    use move_vm_types::loaded_data::runtime_types::StructIdentifier;
    use move_vm_types::module_id_interner::InternedModuleIdPool;
    use move_core_types::{account_address::AccountAddress, identifier::Identifier, language_storage::ModuleId};
    
    // Simulate two validators with different interning pool states
    let pool_validator_a = InternedModuleIdPool::new();
    let pool_validator_b = InternedModuleIdPool::new();
    
    // Validator A interns modules in order [coin, framework]
    let coin_module = ModuleId::new(AccountAddress::ONE, Identifier::new("coin").unwrap());
    pool_validator_a.intern_by_ref(&coin_module);  // Gets InternedModuleId(0)
    
    let framework_module = ModuleId::new(AccountAddress::ONE, Identifier::new("framework").unwrap());
    pool_validator_a.intern_by_ref(&framework_module);  // Gets InternedModuleId(1)
    
    // Validator B interns modules in order [framework, coin] (different order due to state sync)
    pool_validator_b.intern_by_ref(&framework_module);  // Gets InternedModuleId(0)
    pool_validator_b.intern_by_ref(&coin_module);  // Gets InternedModuleId(1)
    
    // Both create StructIdentifier for the same struct: 0x1::coin::Coin
    let coin_struct_a = StructIdentifier::new(
        &pool_validator_a,
        coin_module.clone(),
        Identifier::new("Coin").unwrap()
    );
    
    let coin_struct_b = StructIdentifier::new(
        &pool_validator_b,
        coin_module,
        Identifier::new("Coin").unwrap()
    );
    
    // VULNERABILITY: These represent the SAME struct but compare as DIFFERENT
    // due to different interned_module_id values (0 vs 1)
    assert_ne!(coin_struct_a, coin_struct_b, 
        "CONSENSUS FAILURE: Same struct compares as different due to interning pool divergence");
    
    // This would cause different enables() decisions in access control
}
```

## Notes
The test in `runtime_access_specifiers_prop_tests.rs` validates functional correctness but doesn't test cross-validator determinism with different cache states, which is the exact scenario highlighted in the security question. The property test generates random `AccessInstance` values but all use the same `TEST_MODULE_ID_POOL`: [5](#0-4) 

This masks the determinism issue because all test instances share the same interning pool state.

### Citations

**File:** third_party/move/move-vm/types/src/loaded_data/runtime_types.rs (L262-267)
```rust
#[derive(Debug, Clone, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct StructIdentifier {
    module: ModuleId,
    interned_module_id: InternedModuleId,
    name: Identifier,
}
```

**File:** third_party/move/move-vm/types/src/interner.rs (L157-163)
```rust
        unsafe {
            let r = inner.alloc(val);
            inner.vec.push(r);
            let idx = inner.vec.len() - 1;
            inner.map.insert(r, idx);
            idx
        }
```

**File:** third_party/move/move-vm/types/src/loaded_data/runtime_access_specifier.rs (L213-215)
```rust
            ResourceInstantiation(enabled_struct_id, enabled_type_inst) => {
                enabled_struct_id == struct_id && enabled_type_inst == type_inst
            },
```

**File:** aptos-move/block-executor/src/code_cache_global_manager.rs (L162-166)
```rust
        if num_interned_module_ids > config.max_interned_module_ids {
            runtime_environment.module_id_pool().flush();
            runtime_environment.struct_name_index_map().flush();
            self.module_cache.flush();
        }
```

**File:** third_party/move/move-vm/types/src/loaded_data/runtime_access_specifiers_prop_tests.rs (L118-121)
```rust
fn struct_id_strategy() -> impl Strategy<Value = StructIdentifier> {
    (module_id_strategy(), identifier_strategy())
        .prop_map(|(module, name)| StructIdentifier::new(&TEST_MODULE_ID_POOL, module, name))
}
```
