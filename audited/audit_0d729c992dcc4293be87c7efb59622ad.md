# Audit Report

## Title
Unvalidated ProviderJWKs in ObservationAggregationState Causes JWK Consensus Denial of Service

## Summary
The `ObservationAggregationState::new()` function accepts a `ProviderJWKs` parameter without validation, allowing malformed or inconsistent JWK data to cause all peer observations to be rejected during consensus aggregation. This leads to denial of service for JWK consensus affecting keyless account availability for specific OIDC providers.

## Finding Description

The `ObservationAggregationState::new()` function stores the `local_view` parameter without any validation of the issuer validity or JWK well-formedness: [1](#0-0) 

During observation aggregation, the `add()` function performs a strict equality check between `local_view` and incoming peer observations: [2](#0-1) 

This check occurs BEFORE signature verification: [3](#0-2) 

The `local_view` originates from JWKs fetched by `JWKObserver` from external OIDC providers and is constructed without validation: [4](#0-3) 

The `UpdateCertifier` passes this unvalidated data directly to `ObservationAggregationState::new()`: [5](#0-4) 

**Critical Issue - Non-Canonical Serialization:**

For non-RSA JWKs (or malformed JWKs), the conversion uses non-canonical `to_string()` as explicitly noted in the TODO comment: [6](#0-5) 

This means semantically equivalent JSON objects from different OIDC provider responses can produce different byte representations, causing the equality check to fail even when JWKs are functionally identical.

**Attack Scenarios:**

1. **Network Timing Attack**: Different validators fetch JWKs at slightly different times when an OIDC provider is rotating keys, resulting in different `local_view` values across validators.

2. **Malicious OIDC Provider**: An attacker controlling an OIDC provider (or exploiting load balancer/CDN caching) serves different JWK responses to different validators, causing permanent consensus failure for that issuer.

3. **Non-Canonical JSON**: OIDC providers return semantically equivalent but textually different JSON (different field ordering, whitespace, additional fields), causing different UnsupportedJWK payloads due to non-canonical serialization.

When validators have inconsistent `local_view` values, the equality check at line 82-84 rejects all peer observations with "mismatched view" error, preventing quorum from being reached and blocking JWK updates for affected OIDC providers.

## Impact Explanation

This vulnerability qualifies as **Medium Severity** ($10,000 tier) based on Aptos bug bounty criteria:

- **State Inconsistencies Requiring Intervention**: When JWK consensus fails due to inconsistent views, keyless accounts for affected OIDC providers become unavailable, requiring manual intervention to reset consensus state.

- **Limited Availability Impact**: The vulnerability doesn't affect the main blockchain consensus, fund security, or validator operations. It specifically targets the JWK consensus subsystem used for keyless authentication.

- **Feature-Specific Denial of Service**: Only keyless accounts for specific OIDC providers are affected, not the entire network.

The vulnerability breaks the **deterministic execution invariant** for JWK consensus - validators observing the same logical state should reach consensus, but non-canonical serialization and lack of validation prevent this.

## Likelihood Explanation

**Likelihood: Medium to High**

This vulnerability can occur naturally without malicious actors:

1. **OIDC Key Rotation**: Most OIDC providers (Google, Facebook, etc.) periodically rotate their JWKs. During rotation, different validators fetching at different times observe different key sets.

2. **CDN/Load Balancer Caching**: Large OIDC providers use CDNs and load balancers that may serve stale cached JWK responses, causing validators to see inconsistent data.

3. **Non-Canonical JSON**: Even with identical JWKs, JSON field ordering or formatting differences from OIDC providers cause different UnsupportedJWK payloads due to the non-canonical `to_string()` conversion.

4. **Network Conditions**: Validators in different geographic regions may experience different response times and observe state at different moments during OIDC provider updates.

The vulnerability requires no privileged access or validator collusion - it can occur through normal network behavior or be intentionally triggered by a malicious OIDC provider operator.

## Recommendation

Add validation in `ObservationAggregationState::new()` to verify `local_view` correctness:

```rust
pub fn new(epoch_state: Arc<EpochState>, local_view: ProviderJWKs) -> anyhow::Result<Self> {
    // Validate issuer is valid UTF-8
    String::from_utf8(local_view.issuer.clone())
        .context("local_view issuer must be valid UTF-8")?;
    
    // Validate all JWKs are well-formed by converting to indexed format
    local_view.indexed()
        .context("local_view contains malformed JWKs")?;
    
    // Additional validation: ensure non-empty issuer
    ensure!(!local_view.issuer.is_empty(), "local_view issuer cannot be empty");
    
    Ok(Self {
        epoch_state,
        local_view,
        inner_state: Mutex::new(PartialSignatures::empty()),
        _phantom: Default::default(),
    })
}
```

Additionally, fix the non-canonical serialization issue in `UnsupportedJWK`:

```rust
impl From<serde_json::Value> for UnsupportedJWK {
    fn from(json_value: serde_json::Value) -> Self {
        // Use canonical JSON serialization
        let payload = serde_json::to_vec(&json_value)
            .expect("JSON value serialization cannot fail");
        Self {
            id: HashValue::sha3_256_of(payload.as_slice()).to_vec(),
            payload,
        }
    }
}
```

Use canonical JSON serialization library (e.g., `canonical_json` crate) to ensure deterministic serialization regardless of field ordering or whitespace.

## Proof of Concept

```rust
#[test]
fn test_malformed_local_view_rejection() {
    use crate::{
        mode::per_issuer::PerIssuerMode,
        observation_aggregation::ObservationAggregationState,
        types::{ObservedUpdate, ObservedUpdateResponse},
    };
    use aptos_crypto::{bls12381, SigningKey, Uniform};
    use aptos_reliable_broadcast::BroadcastStatus;
    use aptos_types::{
        epoch_state::EpochState,
        jwks::{
            jwk::{JWKMoveStruct, JWK},
            unsupported::UnsupportedJWK,
            ProviderJWKs,
        },
        validator_verifier::{ValidatorConsensusInfo, ValidatorVerifier},
    };
    use std::sync::Arc;

    let num_validators = 3;
    let epoch = 999;
    let addrs: Vec<_> = (0..num_validators).map(|_| AccountAddress::random()).collect();
    let private_keys: Vec<_> = (0..num_validators)
        .map(|_| bls12381::PrivateKey::generate_for_testing())
        .collect();
    let public_keys: Vec<_> = (0..num_validators)
        .map(|i| bls12381::PublicKey::from(&private_keys[i]))
        .collect();
    let validator_infos: Vec<_> = (0..num_validators)
        .map(|i| ValidatorConsensusInfo::new(addrs[i], public_keys[i].clone(), 1))
        .collect();
    let verifier = ValidatorVerifier::new(validator_infos);
    let epoch_state = Arc::new(EpochState::new(epoch, verifier));

    // Validator 0 has local_view with "payload1"
    let local_view_v0 = ProviderJWKs {
        issuer: b"https://example.com".to_vec(),
        version: 1,
        jwks: vec![JWKMoveStruct::from(JWK::Unsupported(
            UnsupportedJWK::new_for_testing("kid1", "payload1"),
        ))],
    };

    // Validator 1 has observed view with "payload2" (different from v0)
    let observed_view_v1 = ProviderJWKs {
        issuer: b"https://example.com".to_vec(),
        version: 1,
        jwks: vec![JWKMoveStruct::from(JWK::Unsupported(
            UnsupportedJWK::new_for_testing("kid1", "payload2"),
        ))],
    };

    let agg_state = Arc::new(ObservationAggregationState::<PerIssuerMode>::new(
        epoch_state.clone(),
        local_view_v0.clone(),
    ));

    // Validator 1's observation with different view should be rejected
    let result = agg_state.add(
        addrs[1],
        ObservedUpdateResponse {
            epoch,
            update: ObservedUpdate {
                author: addrs[1],
                observed: observed_view_v1.clone(),
                signature: private_keys[1].sign(&observed_view_v1).unwrap(),
            },
        },
    );

    // This should fail with "mismatched view" despite valid signature
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("mismatched view"));
}
```

This PoC demonstrates that even with valid signatures, observations are rejected when `local_view` differs from peer views, causing consensus failure for JWK updates.

### Citations

**File:** crates/aptos-jwk-consensus/src/observation_aggregation/mod.rs (L32-39)
```rust
    pub fn new(epoch_state: Arc<EpochState>, local_view: ProviderJWKs) -> Self {
        Self {
            epoch_state,
            local_view,
            inner_state: Mutex::new(PartialSignatures::empty()),
            _phantom: Default::default(),
        }
    }
```

**File:** crates/aptos-jwk-consensus/src/observation_aggregation/mod.rs (L81-84)
```rust
        ensure!(
            self.local_view == peer_view,
            "adding peer observation failed with mismatched view"
        );
```

**File:** crates/aptos-jwk-consensus/src/observation_aggregation/mod.rs (L86-89)
```rust
        // Verify peer signature.
        self.epoch_state
            .verifier
            .verify(sender, &peer_view, &signature)?;
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager/mod.rs (L197-201)
```rust
            let observed = ProviderJWKs {
                issuer: issuer.clone(),
                version: state.on_chain_version() + 1,
                jwks,
            };
```

**File:** crates/aptos-jwk-consensus/src/update_certifier.rs (L63-66)
```rust
        let agg_state = Arc::new(ObservationAggregationState::<ConsensusMode>::new(
            epoch_state,
            payload,
        ));
```

**File:** types/src/jwks/unsupported/mod.rs (L51-58)
```rust
impl From<serde_json::Value> for UnsupportedJWK {
    fn from(json_value: serde_json::Value) -> Self {
        let payload = json_value.to_string().into_bytes(); //TODO: canonical to_string.
        Self {
            id: HashValue::sha3_256_of(payload.as_slice()).to_vec(),
            payload,
        }
    }
```
