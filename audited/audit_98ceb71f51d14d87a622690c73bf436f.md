# Audit Report

## Title
Gas Metering Bypass via Lazy Loader Config Ignore in Function Loading

## Summary
The lazy loader ignores `LegacyLoaderConfig` parameters that control transitive dependency gas charging, allowing transactions to bypass gas limits established in gas feature versions RELEASE_V1_10 (dependency charging) and RELEASE_V1_27 (type tag dependency charging), resulting in undercharging for module loading operations.

## Finding Description

The `LazyLoader::load_instantiated_function()` completely ignores the `LegacyLoaderConfig` parameter despite it being configured based on gas feature version: [1](#0-0) 

The config contains two critical security controls introduced in specific gas versions: [2](#0-1) 

In production, this config is set based on gas feature version to enforce dependency charging: [3](#0-2) [4](#0-3) 

The gas feature versions mandate these charges: [5](#0-4) 

However, when lazy loading is enabled (now default per feature flag #95), the eager loader's transitive dependency charging is replaced with lazy loader's on-demand charging:

**Eager Loader** charges entire transitive closure: [6](#0-5) 

**Lazy Loader** only charges accessed modules: [7](#0-6) 

This differential is explicitly tested and confirmed: [8](#0-7) 

In package publishing, lazy loading only charges immediate dependencies instead of transitive closure: [9](#0-8) 

## Impact Explanation

**Severity: High** (Gas Metering Bypass)

This violates **Resource Limits** invariant (#9): "All operations must respect gas, storage, and computational limits."

An attacker can:
1. Deploy modules with deep dependency chains (e.g., A→B→C→...→Z with 26 modules)
2. Execute functions that only access immediate dependencies (A→B)
3. Pay gas only for 2 modules instead of all 26 in the transitive closure
4. Bypass the `max_num_dependencies` and `max_total_dependency_size` limits that would trigger with eager loading: [10](#0-9) 

This undermines the gas feature versioning system designed to enforce resource limits progressively.

## Likelihood Explanation

**Likelihood: High**

- Lazy loading is enabled by default on mainnet (feature flag #95 in default features): [11](#0-10) 

- Every transaction loading a function with dependencies is affected
- No special privileges required - any user can publish modules and execute functions
- The test suite explicitly demonstrates this behavior is exploitable

## Recommendation

The lazy loader should respect the `LegacyLoaderConfig` to maintain consistency with gas feature version semantics. Modify `LazyLoader::load_instantiated_function()` to conditionally charge for transitive dependencies when `config.charge_for_dependencies` is enabled, similar to how package publishing could implement transitive charging for lazy mode.

Alternatively, if the different charging model is intentional, the gas feature version checks should explicitly account for lazy loading mode and document that dependency charging semantics differ when lazy loading is active.

## Proof of Concept

The existing test demonstrates the exploit: [12](#0-11) 

This test shows that with lazy loading enabled, module p3 (depending on p2→p1 chain) successfully publishes even when dependency limits would prevent it in eager mode. Running this test with `enable_lazy_loading=true` and `change_max_num_dependencies=true` demonstrates successful bypass of the `max_num_dependencies=2` limit.

## Notes

While lazy loading is an intentional design choice per AIP-127, the complete bypass of gas feature version controls creates a discrepancy where the same transaction costs different gas depending on the loader mode. This undermines the versioned gas schedule's purpose of progressively enforcing resource limits. The security impact is that resource exhaustion protections introduced in RELEASE_V1_10 can be bypassed through lazy loading's on-demand charging model.

### Citations

**File:** third_party/move/move-vm/runtime/src/storage/loader/lazy.rs (L55-77)
```rust
    fn charge_module(
        &self,
        gas_meter: &mut impl DependencyGasMeter,
        traversal_context: &mut TraversalContext,
        module_id: &ModuleId,
    ) -> PartialVMResult<()> {
        if traversal_context.visit_if_not_special_module_id(module_id) {
            let addr = module_id.address();
            let name = module_id.name();

            let size = self
                .module_storage
                .unmetered_get_existing_module_size(addr, name)
                .map_err(|err| err.to_partial())?;
            gas_meter.charge_dependency(
                DependencyKind::Existing,
                addr,
                name,
                NumBytes::new(size as u64),
            )?;
        }
        Ok(())
    }
```

**File:** third_party/move/move-vm/runtime/src/storage/loader/lazy.rs (L299-313)
```rust
    fn load_instantiated_function(
        &self,
        // For lazy loading, not used!
        _config: &LegacyLoaderConfig,
        gas_meter: &mut impl DependencyGasMeter,
        traversal_context: &mut TraversalContext,
        module_id: &ModuleId,
        function_name: &IdentStr,
        ty_args: &[TypeTag],
    ) -> VMResult<LoadedFunction> {
        let (module, function) =
            self.load_function_definition(gas_meter, traversal_context, module_id, function_name)?;

        self.build_instantiated_function(gas_meter, traversal_context, module, function, ty_args)
    }
```

**File:** third_party/move/move-vm/runtime/src/storage/loader/traits.rs (L106-121)
```rust
pub struct LegacyLoaderConfig {
    /// If true, charge gas for transitive dependencies of a function or a script.
    pub charge_for_dependencies: bool,
    /// If true, charge gas for all modules used in type arguments (tags) of a function / script.
    pub charge_for_ty_tag_dependencies: bool,
}

impl LegacyLoaderConfig {
    /// Returns config which does not charge for anything.
    pub fn unmetered() -> Self {
        Self {
            charge_for_dependencies: false,
            charge_for_ty_tag_dependencies: false,
        }
    }
}
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L905-908)
```rust
            let legacy_loader_config = LegacyLoaderConfig {
                charge_for_dependencies: self.gas_feature_version() >= RELEASE_V1_10,
                charge_for_ty_tag_dependencies: self.gas_feature_version() >= RELEASE_V1_27,
            };
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L956-959)
```rust
            let legacy_loader_config = LegacyLoaderConfig {
                charge_for_dependencies: self.gas_feature_version() >= RELEASE_V1_10,
                charge_for_ty_tag_dependencies: self.gas_feature_version() >= RELEASE_V1_27,
            };
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1633-1655)
```rust
        // Lazy loading otherwise.

        // With lazy loading, we will check only immediate dependencies for linking checks,
        // not the whole dependencies closure, so charge gas here for them.
        for (dep_addr, dep_name) in modules
            .iter()
            .flat_map(|module| module.immediate_dependencies_iter())
            .filter(|addr_and_name| !module_ids_in_bundle.contains(addr_and_name))
        {
            if traversal_context.visit_if_not_special_address(dep_addr, dep_name) {
                let size = module_storage
                    .unmetered_get_existing_module_size(dep_addr, dep_name)
                    .map(|v| v as u64)?;
                gas_meter
                    .charge_dependency(
                        DependencyKind::Existing,
                        dep_addr,
                        dep_name,
                        NumBytes::new(size),
                    )
                    .map_err(|err| err.finish(Location::Undefined))?;
            }
        }
```

**File:** aptos-move/aptos-gas-schedule/src/ver.rs (L10-32)
```rust
/// Change log:
/// - V41:
///    - Gas charging for SLH-DSA-SHA2-128s signature verification
/// - V31:
///    - Gas charging for modules used in type tags
/// - V22
///    - Gas parameters for enums
///    - Gas parameters for new native function `bcs::serialized_size`
/// - V21
///   - Fix type to type tag conversion in MoveVM
/// - V20
///   - Limits for bounding MoveVM type sizes
/// - V19
///   - Gas for aggregator_v2::is_at_least native function
/// - V18
///   - Separate limits for governance scripts
///   - Function info & dispatchable token gas params
/// - V17
///   - Gas for keyless
/// - V16
///   - IO Gas for the transaction itself and events in the transaction output
/// - V15
///   - Gas & limits for dependencies
```

**File:** third_party/move/move-vm/runtime/src/storage/loader/eager.rs (L281-302)
```rust
        if config.charge_for_dependencies {
            // Charge gas for function code loading.
            let arena_id = traversal_context
                .referenced_module_ids
                .alloc(module_id.clone());
            check_dependencies_and_charge_gas(
                self.module_storage,
                gas_meter,
                traversal_context,
                [(arena_id.address(), arena_id.name())],
            )?;
        }

        if config.charge_for_ty_tag_dependencies {
            // Charge gas for code loading of modules used by type arguments.
            check_type_tag_dependencies_and_charge_gas(
                self.module_storage,
                gas_meter,
                traversal_context,
                ty_args,
            )?;
        }
```

**File:** aptos-move/e2e-move-tests/src/tests/dependencies.rs (L24-85)
```rust
#[test_case(true, true)]
#[test_case(true, false)]
#[test_case(false, true)]
#[test_case(false, false)]
fn exceeding_max_num_dependencies_on_publish(
    enable_lazy_loading: bool,
    change_max_num_dependencies: bool,
) {
    let mut h = MoveHarness::new_with_lazy_loading(enable_lazy_loading);
    let acc = h.new_account_at(AccountAddress::from_hex_literal("0xcafe").unwrap());

    if change_max_num_dependencies {
        h.modify_gas_schedule(|gas_params| {
            gas_params.vm.txn.max_num_dependencies = 2.into();
        });
    } else {
        // Enough to cover for 2 modules combined: p1 and p2 or p2 and p3.
        h.modify_gas_schedule(|gas_params| {
            gas_params.vm.txn.max_total_dependency_size = 330.into();
        });
    }

    assert_success!(
        h.publish_package_cache_building(&acc, &common::test_dir_path("dependencies.data/p1"))
    );
    assert_success!(
        h.publish_package_cache_building(&acc, &common::test_dir_path("dependencies.data/p2"))
    );

    // Since lazy loading only checks immediate dependencies, and p3 depends on p2 only, publishing
    // should succeed.
    let res =
        h.publish_package_cache_building(&acc, &common::test_dir_path("dependencies.data/p3"));
    if enable_lazy_loading {
        assert_success!(res);
    } else {
        assert_dependency_limit_reached(res);

        // Publishing should succeed if we increase the limit.
        if change_max_num_dependencies {
            h.modify_gas_schedule(|gas_params| {
                gas_params.vm.txn.max_num_dependencies = 3.into();
            });
        } else {
            h.modify_gas_schedule(|gas_params| {
                gas_params.vm.txn.max_total_dependency_size = 1000000.into();
            });
        }

        assert_success!(
            h.publish_package_cache_building(&acc, &common::test_dir_path("dependencies.data/p3"))
        );
    }

    // Should be able to use module in both cases.
    assert_success!(h.run_entry_function(
        &acc,
        str::parse("0xcafe::m3::noop").unwrap(),
        vec![],
        vec![],
    ));
}
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L251-259)
```rust
            max_num_dependencies: NumModules,
            { RELEASE_V1_10.. => "max_num_dependencies" },
            768,
        ],
        [
            max_total_dependency_size: NumBytes,
            { RELEASE_V1_10.. => "max_total_dependency_size" },
            1024 * 1024 * 18 / 10, // 1.8 MB
        ],
```

**File:** types/src/on_chain_config/aptos_features.rs (L266-266)
```rust
            FeatureFlag::ENABLE_LAZY_LOADING,
```
