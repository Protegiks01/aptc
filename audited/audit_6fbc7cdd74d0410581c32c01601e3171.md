# Audit Report

## Title
Bytecode Version Mismatch in `move_2()` Allows Compilation of Invalid Bytecode Causing Validator Deserialization Failures

## Summary
The `move_2()` function hardcodes `bytecode_version` to `VERSION_DEFAULT` (9) while using `latest_stable()` language version. This creates a critical version mismatch vulnerability where language features requiring bytecode version 10 can be compiled with version 9 headers, causing validators to reject the bytecode with MALFORMED errors during deserialization.

## Finding Description
The vulnerability exists in the version inference logic of the Move compilation pipeline: [1](#0-0) 

The `move_2()` function explicitly sets `bytecode_version: Some(VERSION_DEFAULT)` where `VERSION_DEFAULT` equals 9: [2](#0-1) 

The critical flaw occurs in the bytecode version inference mechanism: [3](#0-2) 

When `bytecode_version` is explicitly set, the environment variable check bypasses the language version logic: [4](#0-3) 

The `infer_bytecode_version()` method is designed to map language versions to appropriate bytecode versions, but when `from_input` is `Some(9)`, it returns immediately without consulting the language version requirements: [5](#0-4) 

**The Attack Path:**

1. Language version V2_4 introduces `abort(vector<u8>)` syntax that requires the `ABORT_MSG` opcode: [6](#0-5) 

2. When V2_4 becomes stable and `latest_stable()` returns V2_4, or when manually setting language version to V2_4 with `move_2()` options, the compiler allows V2_4 features but serializes with bytecode version 9.

3. The serializer writes `ABORT_MSG` opcodes without version validation: [7](#0-6) 

4. The serializer ONLY validates VERSION_6 features, not VERSION_9/10 features: [8](#0-7) 

5. During deserialization, validators check version compatibility and reject `ABORT_MSG` in bytecode version 9: [9](#0-8) 

6. The module publishing flow catches this as a MALFORMED error: [10](#0-9) 

This breaks the **Deterministic Execution** invariant because validators receiving malformed bytecode will fail to deserialize modules, causing transaction failures and potential consensus divergence if some validators have different version configurations.

## Impact Explanation
**High Severity** per Aptos bug bounty criteria:

1. **Validator Node Impact**: When malformed bytecode is published on-chain, all validators attempting to execute transactions involving these modules will encounter MALFORMED deserialization errors, causing transaction execution failures.

2. **Protocol Violations**: The mismatch violates the bytecode versioning protocol, where the version header must accurately reflect the opcodes used in the module body. This is a significant protocol violation.

3. **Consensus Risk**: If different validators have different `max_binary_format_version` configurations in their DeserializerConfig, they may handle the malformed bytecode differently, potentially leading to state divergence.

4. **Availability Impact**: Published modules become unusable, effectively freezing any functionality depending on them until a network upgrade or manual intervention occurs.

## Likelihood Explanation
**Current: Low (but non-zero)** - Requires developers to explicitly use language version V2_4 with `move_2()` or manually configure incompatible versions.

**Future: High** - When `LATEST_STABLE_LANGUAGE_VERSION_VALUE` is updated from V2_3 to V2_4: [11](#0-10) 

All code using `move_2()` will automatically trigger this vulnerability without any code changes required by developers.

The function is used throughout the codebase in test frameworks, transaction generators, and potentially production build scripts, increasing the attack surface significantly once V2_4 becomes stable.

## Recommendation
**Fix 1: Remove hardcoded bytecode version from `move_2()`**

```rust
pub fn move_2() -> Self {
    BuildOptions {
        bytecode_version: None,  // Let inference handle it
        language_version: Some(LanguageVersion::latest_stable()),
        compiler_version: Some(CompilerVersion::latest_stable()),
        ..Self::default()
    }
}
```

**Fix 2: Add validation in serializer for version-specific opcodes**

Add version checks in `serialize_instruction_inner()` for all version-gated opcodes:

```rust
fn serialize_instruction_inner(
    major_version: u32,
    binary: &mut BinaryData,
    opcode: &Bytecode,
) -> Result<()> {
    match opcode {
        // Existing VERSION_6 check...
        
        // Add VERSION_9 check
        Bytecode::LdI8(_) | Bytecode::LdI16(_) | Bytecode::LdI32(_) 
        | Bytecode::LdI64(_) | Bytecode::LdI128(_) | Bytecode::LdI256(_)
        | Bytecode::CastI8 | Bytecode::CastI16 | Bytecode::CastI32
        | Bytecode::CastI64 | Bytecode::CastI128 | Bytecode::CastI256
        | Bytecode::Negate
            if (major_version < VERSION_9) =>
        {
            return Err(anyhow!(
                "Signed integer operations not supported in bytecode version {}",
                major_version
            ));
        },
        
        // Add VERSION_10 check
        Bytecode::AbortMsg
            if (major_version < VERSION_10) =>
        {
            return Err(anyhow!(
                "Abort with message not supported in bytecode version {}",
                major_version
            ));
        },
        _ => (),
    };
    // ... rest of serialization
}
```

**Fix 3: Add validation in `create_build_config()`**

```rust
pub fn create_build_config(options: &BuildOptions) -> anyhow::Result<BuildConfig> {
    let inferred_version = options.inferred_bytecode_version();
    let language_version = options.language_version.unwrap_or_default();
    let expected_version = language_version.infer_bytecode_version(None);
    
    if inferred_version < expected_version {
        bail!(
            "Bytecode version {} is incompatible with language version {} which requires version {}",
            inferred_version,
            language_version,
            expected_version
        );
    }
    // ... rest of function
}
```

## Proof of Concept

```rust
// File: test_version_mismatch.rs
use aptos_framework::built_package::BuildOptions;
use move_binary_format::file_format_common::VERSION_DEFAULT;
use move_model::metadata::LanguageVersion;
use std::path::PathBuf;

#[test]
fn test_version_mismatch_vulnerability() {
    // Create a Move package with abort(vector<u8>) syntax
    let package_source = r#"
        module 0x1::test_abort {
            public entry fun abort_with_message() {
                abort b"This is an error message"
            }
        }
    "#;
    
    // Configure with mismatched versions
    let mut options = BuildOptions {
        bytecode_version: Some(VERSION_DEFAULT), // Force version 9
        language_version: Some(LanguageVersion::V2_4), // Use V2_4 features
        compiler_version: Some(CompilerVersion::latest_stable()),
        ..BuildOptions::default()
    };
    
    // This will compile successfully with compiler v2
    let built_package = BuiltPackage::build(
        PathBuf::from("test_package"),
        options
    ).expect("Compilation should succeed");
    
    // Extract bytecode
    let bytecode = built_package.extract_code();
    
    // Attempt to deserialize with strict validator config
    let deserializer_config = DeserializerConfig::new(VERSION_DEFAULT, IDENTIFIER_SIZE_MAX);
    
    for module_bytes in bytecode {
        let result = CompiledModule::deserialize_with_config(
            &module_bytes,
            &deserializer_config
        );
        
        // This will fail with MALFORMED error because ABORT_MSG is in version 9 bytecode
        assert!(result.is_err());
        let err = result.unwrap_err();
        assert_eq!(err.major_status(), StatusCode::MALFORMED);
        println!("Validator deserialization failed: {:?}", err);
    }
}
```

## Notes
This vulnerability represents a critical gap in the versioning validation logic. The hardcoded `VERSION_DEFAULT` in `move_2()` bypasses the carefully designed inference mechanism, creating a time bomb that will trigger network-wide issues once language version 2.4 becomes stable. The lack of opcode-level version validation in the serializer compounds this issue by allowing incompatible bytecode to be generated without warnings or errors during compilation.

### Citations

**File:** aptos-move/framework/src/built_package.rs (L145-152)
```rust
    pub fn move_2() -> Self {
        BuildOptions {
            bytecode_version: Some(VERSION_DEFAULT),
            language_version: Some(LanguageVersion::latest_stable()),
            compiler_version: Some(CompilerVersion::latest_stable()),
            ..Self::default()
        }
    }
```

**File:** aptos-move/framework/src/built_package.rs (L154-158)
```rust
    pub fn inferred_bytecode_version(&self) -> u32 {
        self.language_version
            .unwrap_or_default()
            .infer_bytecode_version(self.bytecode_version)
    }
```

**File:** third_party/move/move-binary-format/src/file_format_common.rs (L571-571)
```rust
pub const VERSION_DEFAULT: u32 = VERSION_9;
```

**File:** third_party/move/move-command-line-common/src/env.rs (L19-29)
```rust
pub fn get_bytecode_version_from_env(from_input: Option<u32>) -> Option<u32> {
    // This allows for bytecode version to come from command line flags and
    // other input locations, falls back to bytecode version if not provided
    if from_input.is_some() {
        from_input
    } else {
        std::env::var(BYTECODE_VERSION_ENV_VAR)
            .ok()
            .and_then(|s| s.parse::<u32>().ok())
    }
}
```

**File:** third_party/move/move-model/src/metadata.rs (L20-20)
```rust
pub const LATEST_STABLE_LANGUAGE_VERSION_VALUE: LanguageVersion = LanguageVersion::V2_3;
```

**File:** third_party/move/move-model/src/metadata.rs (L317-326)
```rust
    pub fn infer_bytecode_version(&self, version: Option<u32>) -> u32 {
        env::get_bytecode_version_from_env(version).unwrap_or(match self {
            LanguageVersion::V1 => VERSION_DEFAULT,
            LanguageVersion::V2_0
            | LanguageVersion::V2_1
            | LanguageVersion::V2_2
            | LanguageVersion::V2_3 => VERSION_DEFAULT,
            LanguageVersion::V2_4 | LanguageVersion::V2_5 => VERSION_DEFAULT_LANG_V2_4,
        })
    }
```

**File:** third_party/move/move-model/src/builder/exp_builder.rs (L6051-6051)
```rust
                self.check_language_version(&loc, "abort(vector<u8>)", LanguageVersion::V2_4)?;
```

**File:** third_party/move/move-binary-format/src/serializer.rs (L980-995)
```rust
    match opcode {
        Bytecode::LdU16(_)
        | Bytecode::LdU32(_)
        | Bytecode::LdU256(_)
        | Bytecode::CastU16
        | Bytecode::CastU32
        | Bytecode::CastU256
            if (major_version < VERSION_6) =>
        {
            return Err(anyhow!(
                "Loading or casting u16, u32, u256 integers not supported in bytecode version {}",
                major_version
            ));
        },
        _ => (),
    };
```

**File:** third_party/move/move-binary-format/src/serializer.rs (L1171-1171)
```rust
        Bytecode::AbortMsg => binary.push(Opcodes::ABORT_MSG as u8),
```

**File:** third_party/move/move-binary-format/src/deserializer.rs (L1834-1841)
```rust
            Opcodes::ABORT_MSG if cursor.version() < VERSION_10 => {
                return Err(
                    PartialVMError::new(StatusCode::MALFORMED).with_message(format!(
                        "aborting with message not available before bytecode version {}",
                        VERSION_10
                    )),
                );
            },
```

**File:** third_party/move/move-vm/runtime/src/storage/publishing.rs (L143-152)
```rust
            let compiled_module =
                CompiledModule::deserialize_with_config(&module_bytes, deserializer_config)
                    .map(Arc::new)
                    .map_err(|err| {
                        err.append_message_with_separator(
                            '\n',
                            "[VM] module deserialization failed".to_string(),
                        )
                        .finish(Location::Undefined)
                    })?;
```
