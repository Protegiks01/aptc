# Audit Report

## Title
State Corruption in Consensus Observer: Stale `highest_committed_epoch_round` After Block Clearing Causes Valid Commit Decisions to be Dropped

## Summary
The `clear_all_ordered_blocks()` function clears the ordered blocks map but fails to reset the `highest_committed_epoch_round` field, creating an inconsistent state where the system tracks a committed epoch/round but has no corresponding blocks. This causes subsequent valid commit decisions to be incorrectly rejected, leading to consensus observer liveness failures.

## Finding Description

The vulnerability exists in the `OrderedBlockStore` implementation where `clear_all_ordered_blocks()` only clears the block storage without resetting the commit tracking metadata. [1](#0-0) 

The `OrderedBlockStore` maintains two critical state fields:
- `ordered_blocks`: A BTreeMap storing actual block data
- `highest_committed_epoch_round`: An Option tracking the highest committed block position [2](#0-1) 

When `clear_all_ordered_blocks()` is invoked, only `ordered_blocks` is cleared while `highest_committed_epoch_round` retains its stale value. This function is called during block data clearing operations: [3](#0-2) 

This clearing operation occurs when subscription checks fail or when entering fallback mode: [4](#0-3) 

The inconsistent state manifests when processing new commit decisions. The system queries the stale `highest_committed_epoch_round` and incorrectly drops valid commit decisions: [5](#0-4) [6](#0-5) 

**Attack Scenario:**
1. Observer tracks blocks up to epoch 10, round 100 with `highest_committed_epoch_round = Some((10, 100))`
2. Subscription failure triggers `clear_pending_block_state()`
3. `clear_all_ordered_blocks()` executes, clearing blocks but leaving `highest_committed_epoch_round = Some((10, 100))`
4. System resets to root at epoch 10, round 5
5. Valid commit decision arrives for epoch 10, round 50
6. Check `(10, 50) <= (10, 100)` evaluates to true
7. Valid commit decision is dropped as "already seen"
8. Observer cannot progress and may repeatedly fail

## Impact Explanation

This vulnerability falls under **High Severity** per Aptos bug bounty criteria for "Significant protocol violations" and potential "Validator node slowdowns." 

The bug causes consensus observers to:
- Reject valid commit decisions due to stale state comparisons
- Fail to track network consensus progress properly
- Potentially enter repeated failure/recovery cycles
- Experience liveness issues requiring manual intervention

While this doesn't affect consensus safety (validators continue operating normally), it degrades the reliability of consensus observer nodes which are critical for monitoring and observability infrastructure.

## Likelihood Explanation

This bug will trigger whenever:
1. A consensus observer experiences subscription failures (network partitions, peer timeouts, connection issues)
2. The observer has previously tracked blocks beyond its current root position
3. The system attempts to recover by clearing state

This is a **high likelihood** scenario in production environments with:
- Network instability or congestion
- Peer churn or connectivity issues
- Observer nodes recovering from failures

The bug does not require malicious intent—it occurs during legitimate operational conditions. Given that subscription failures are expected in distributed systems, this vulnerability will manifest regularly in production deployments.

## Recommendation

Add a method to reset the `highest_committed_epoch_round` field when clearing all blocks. The fix should be:

```rust
/// Clears all ordered blocks and resets commit tracking
pub fn clear_all_ordered_blocks(&mut self) {
    self.ordered_blocks.clear();
    self.highest_committed_epoch_round = None;
}
```

This ensures that after clearing blocks, the system no longer references a stale committed position and will correctly fall back to the root ledger info when queried via `get_highest_committed_epoch_round()`. [5](#0-4) 

The fallback logic already handles the `None` case properly by returning the root epoch/round, which is the correct behavior after a state clear.

## Proof of Concept

```rust
#[test]
fn test_clear_all_ordered_blocks_state_corruption() {
    use aptos_consensus_types::{
        block::Block,
        block_data::{BlockData, BlockType},
        pipelined_block::{OrderedBlockWindow, PipelinedBlock},
        quorum_cert::QuorumCert,
    };
    use aptos_crypto::HashValue;
    use aptos_types::{
        aggregate_signature::AggregateSignature,
        block_info::BlockInfo,
        ledger_info::LedgerInfo,
        transaction::Version,
    };
    
    // Create ordered block store
    let mut store = OrderedBlockStore::new(ConsensusObserverConfig::default());
    
    // Add blocks and commit decision for epoch 10, round 100
    let epoch = 10;
    let round = 100;
    let block_info = BlockInfo::new(epoch, round, HashValue::random(), 
                                    HashValue::random(), 0, 0, None);
    let block_data = BlockData::new_for_testing(epoch, round, 0, 
                                                QuorumCert::dummy(), BlockType::Genesis);
    let block = Block::new_for_testing(block_info.id(), block_data, None);
    let pipelined_block = Arc::new(PipelinedBlock::new_ordered(
        block, OrderedBlockWindow::empty()));
    
    let ordered_block = OrderedBlock::new(
        vec![pipelined_block],
        LedgerInfoWithSignatures::new(
            LedgerInfo::new(block_info.clone(), HashValue::random()),
            AggregateSignature::empty(),
        ),
    );
    let observed = ObservedOrderedBlock::new_for_testing(ordered_block);
    store.insert_ordered_block(observed);
    
    // Update commit decision
    let commit = CommitDecision::new(LedgerInfoWithSignatures::new(
        LedgerInfo::new(block_info, HashValue::random()),
        AggregateSignature::empty(),
    ));
    store.update_commit_decision(&commit);
    
    // Verify state before clear
    assert_eq!(store.get_highest_committed_epoch_round(), Some((epoch, round)));
    assert!(!store.ordered_blocks.is_empty());
    
    // Clear all blocks (simulating subscription failure recovery)
    store.clear_all_ordered_blocks();
    
    // BUG: highest_committed_epoch_round is still stale!
    assert!(store.ordered_blocks.is_empty()); // Blocks cleared
    assert_eq!(store.get_highest_committed_epoch_round(), Some((epoch, round))); // STALE!
    
    // This demonstrates the inconsistent state:
    // - No blocks exist in storage
    // - But system thinks it committed to (10, 100)
    // - New commits for rounds 5-99 would be incorrectly rejected
}
```

**Notes**

This vulnerability specifically affects the consensus observer component which monitors and propagates consensus updates. The bug creates a critical invariant violation: the system maintains commit tracking metadata without corresponding block data, leading to incorrect decision-making during recovery operations. The fix is straightforward—reset the commit tracking field when clearing blocks—but the impact is significant as it affects observer node reliability and may cause cascading failures during network instability.

### Citations

**File:** consensus/src/consensus_observer/observer/ordered_blocks.rs (L23-29)
```rust
    // The highest committed block (epoch and round)
    highest_committed_epoch_round: Option<(u64, Round)>,

    // Ordered blocks. The key is the epoch and round of the last block in the
    // ordered block. Each entry contains the block and the commit decision (if any).
    ordered_blocks: BTreeMap<(u64, Round), (ObservedOrderedBlock, Option<CommitDecision>)>,
}
```

**File:** consensus/src/consensus_observer/observer/ordered_blocks.rs (L40-43)
```rust
    /// Clears all ordered blocks
    pub fn clear_all_ordered_blocks(&mut self) {
        self.ordered_blocks.clear();
    }
```

**File:** consensus/src/consensus_observer/observer/block_data.rs (L93-105)
```rust
    pub fn clear_block_data(&mut self) -> LedgerInfoWithSignatures {
        // Clear the payload store
        self.block_payload_store.clear_all_payloads();

        // Clear the ordered blocks
        self.ordered_block_store.clear_all_ordered_blocks();

        // Clear the pending blocks
        self.pending_block_store.clear_missing_blocks();

        // Return the root ledger info
        self.root()
    }
```

**File:** consensus/src/consensus_observer/observer/block_data.rs (L132-141)
```rust
    pub fn get_highest_committed_epoch_round(&self) -> (u64, Round) {
        if let Some(epoch_round) = self.ordered_block_store.get_highest_committed_epoch_round() {
            // Return the highest committed epoch and round
            epoch_round
        } else {
            // Return the root epoch and round
            let root_block_info = self.root.commit_info().clone();
            (root_block_info.epoch(), root_block_info.round())
        }
    }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L216-234)
```rust
    /// Clears the pending block state (this is useful for changing
    /// subscriptions, where we want to wipe all state and restart).
    async fn clear_pending_block_state(&self) {
        // Clear the observer block data
        let root = self.observer_block_data.lock().clear_block_data();

        // Reset the execution pipeline for the root
        if let Err(error) = self.execution_client.reset(&root).await {
            error!(
                LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                    "Failed to reset the execution pipeline for the root! Error: {:?}",
                    error
                ))
            );
        }

        // Increment the cleared block state counter
        metrics::increment_counter_without_labels(&metrics::OBSERVER_CLEARED_BLOCK_STATE);
    }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L452-461)
```rust
        // If the commit message is behind our highest committed block, ignore it
        let get_highest_committed_epoch_round = self
            .observer_block_data
            .lock()
            .get_highest_committed_epoch_round();
        if (commit_epoch, commit_round) <= get_highest_committed_epoch_round {
            // Update the metrics for the dropped commit decision
            update_metrics_for_dropped_commit_decision_message(peer_network_id, &commit_decision);
            return;
        }
```
