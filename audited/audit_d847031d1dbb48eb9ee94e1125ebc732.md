# Audit Report

## Title
Byzantine Validators Can Evade Exclusion Through Window Size Exploitation in OptQS Failure Tracker

## Summary
The `ExponentialWindowFailureTracker` in the consensus layer uses a dynamic `window` size to track validator failures for Optimistic Quorum Store (OptQS) exclusion. However, the `get_exclude_authors()` method only examines the most recent `window` entries from a `BoundedVecDeque` that can hold up to `max_window` (100) entries. Byzantine validators can exploit this discrepancy by strategically timing their `PayloadUnavailable` failures to remain in the historical queue but outside the active tracking window, allowing them to evade exclusion and continue causing liveness degradation.

## Finding Description

The vulnerability exists in the interaction between the failure tracking window and the exclusion mechanism. [1](#0-0) 

The `ExponentialWindowFailureTracker` maintains a `BoundedVecDeque` with capacity set to `max_window` (hardcoded to 100) to store recent round statuses. [2](#0-1) 

The tracking window starts at 2 and doubles on each `PayloadUnavailable` failure up to the maximum of 100. [3](#0-2) 

However, the window only resets to 2 when ALL entries in the queue are consecutive successes—a condition that requires 100 consecutive successful rounds. [4](#0-3) 

The critical flaw lies in `get_exclude_authors()`, which only examines the most recent `window` entries when determining which validators to exclude from OptQS. [5](#0-4) 

**Exploitation Path:**

1. Byzantine validator causes a `PayloadUnavailable` timeout by withholding batch data, window doubles (e.g., 2→4)
2. Validator behaves correctly for the next `window` rounds (4 successful rounds)
3. The failure remains in the `BoundedVecDeque` but is now at position 5 from the end
4. `get_exclude_authors()` only checks the last 4 entries (the current `window` size)
5. The failure at position 5 is invisible to the exclusion logic
6. The validator is not excluded despite having a recent failure in the tracking history
7. Window remains at 4 because `last_consecutive_success_count` < queue length (no reset) and most recent round is success (no growth)
8. Validator can repeat this pattern indefinitely

This breaks the security guarantee that validators causing `PayloadUnavailable` failures should be excluded from OptQS operations until they demonstrate sustained reliability.

## Impact Explanation

This is **High Severity** per the Aptos bug bounty criteria. Byzantine validators can exploit this to cause persistent liveness degradation:

- **Validator Node Slowdowns**: Repeated `PayloadUnavailable` timeouts force the network into fallback modes, degrading throughput
- **Protocol Violations**: The exponential backoff mechanism designed to protect against unreliable validators is circumvented
- **Consensus Liveness Impact**: While not breaking safety (requires >1/3 Byzantine validators), up to 1/3 of validators could exploit this to cause periodic timeouts

The OptQS exclusion mechanism is designed to identify and isolate unreliable validators. [6](#0-5)  By evading exclusion, Byzantine validators can remain in the OptQS participant set and continue causing failures that trigger timeout-based consensus rounds instead of optimistic ones.

## Likelihood Explanation

**Likelihood: High** for networks with Byzantine validators who understand the consensus implementation.

**Attacker Requirements:**
- Must be an active validator in the validator set
- Knowledge of the window size algorithm and timing
- Ability to selectively withhold payload batches

**Attack Complexity: Low** once the validator understands the mechanism:
- The window algorithm is deterministic and observable through round outcomes
- Timing failures requires only counting rounds and controlling batch availability
- No cryptographic breaks or race conditions needed

Byzantine validators are assumed in the threat model for consensus protocols. Any validator can observe the exponential backoff behavior through metrics and logs, making the exploitation strategy discoverable.

## Recommendation

**Option 1 (Minimal Change):** Make `get_exclude_authors()` examine all entries in the queue, not just the last `window` entries:

```rust
fn get_exclude_authors(&self) -> HashSet<Author> {
    let mut exclude_authors = HashSet::new();
    
    // Check ALL entries in the queue, not just the window
    for round_reason in self.past_round_statuses.iter() {
        if let NewRoundReason::Timeout(RoundTimeoutReason::PayloadUnavailable {
            missing_authors,
        }) = round_reason
        {
            for author_idx in missing_authors.iter_ones() {
                if let Some(author) = self.ordered_authors.get(author_idx) {
                    exclude_authors.insert(*author);
                }
            }
        }
    }
    
    exclude_authors
}
```

**Option 2 (Better Design):** Decouple the exclusion tracking window from the OptQS enablement window. Maintain a separate, longer-lived exclusion list that persists based on absolute failure counts or time-based expiry rather than the dynamic exponential window.

**Option 3 (Most Robust):** Track per-validator failure rates over a fixed lookback window and use reputation scores rather than binary exclusion, preventing gaming through timing.

## Proof of Concept

```rust
#[cfg(test)]
mod vulnerability_poc {
    use super::*;
    use aptos_bitvec::BitVec;
    use aptos_types::validator_verifier::random_validator_verifier;

    #[test]
    fn test_byzantine_validator_evades_exclusion() {
        let (_signers, verifier) = random_validator_verifier(4, None, false);
        let ordered_authors = verifier.get_ordered_account_addresses();
        let byzantine_validator_idx = 0;
        
        let mut tracker = ExponentialWindowFailureTracker::new(100, ordered_authors.clone());
        
        // Initial state: window = 2
        assert_eq!(tracker.window, 2);
        
        // Byzantine validator causes a failure
        let mut missing_authors = BitVec::with_num_bits(4);
        missing_authors.set(byzantine_validator_idx);
        tracker.push(NewRoundReason::Timeout(
            RoundTimeoutReason::PayloadUnavailable { missing_authors: missing_authors.clone() }
        ));
        
        // Window doubles to 4
        assert_eq!(tracker.window, 4);
        
        // Byzantine validator succeeds for exactly 4 rounds (window size)
        for _ in 0..4 {
            tracker.push(NewRoundReason::QCReady);
        }
        
        // Window stays at 4 (doesn't reset because queue length > consecutive successes)
        assert_eq!(tracker.window, 4);
        assert_eq!(tracker.last_consecutive_success_count, 4);
        
        // The failure is now at position 5 from the end (outside the window of 4)
        // get_exclude_authors() should NOT include the byzantine validator
        let excluded = tracker.get_exclude_authors();
        
        // VULNERABILITY: Despite having a failure in the queue, the validator is not excluded
        assert!(
            !excluded.contains(&ordered_authors[byzantine_validator_idx]),
            "Byzantine validator evaded exclusion! Failure at position 5 but window is only 4"
        );
        
        // Verify the failure is still in the queue
        assert_eq!(tracker.past_round_statuses.len(), 5);
        let mut found_failure = false;
        for status in tracker.past_round_statuses.iter() {
            if matches!(status, NewRoundReason::Timeout(RoundTimeoutReason::PayloadUnavailable { .. })) {
                found_failure = true;
            }
        }
        assert!(found_failure, "The failure should still be in the queue");
        
        // Byzantine validator can now participate in OptQS again
        // They can cause another failure, and repeat the pattern
    }
}
```

## Notes

This vulnerability is specific to the `ExponentialWindowFailureTracker` used for OptQS exclusion decisions. [7](#0-6)  The same `BoundedVecDeque` pattern is used elsewhere in consensus (DAG driver, leader reputation) but those usages do not have the same security-critical exclusion logic that depends on accurate failure tracking within a dynamic window.

The fundamental issue is the mismatch between the historical data retention (100 rounds) and the active checking window (2-100 rounds dynamically), combined with the window reset condition requiring ALL entries to be successes rather than just the most recent window.

### Citations

**File:** crates/aptos-collections/src/bounded_vec_deque.rs (L10-22)
```rust
pub struct BoundedVecDeque<T> {
    inner: VecDeque<T>,
    capacity: usize,
}

impl<T> BoundedVecDeque<T> {
    pub fn new(capacity: usize) -> Self {
        assert!(capacity > 0);
        Self {
            inner: VecDeque::with_capacity(capacity),
            capacity,
        }
    }
```

**File:** consensus/src/epoch_manager.rs (L901-904)
```rust
        let failures_tracker = Arc::new(Mutex::new(ExponentialWindowFailureTracker::new(
            100,
            epoch_state.verifier.get_ordered_account_addresses(),
        )));
```

**File:** consensus/src/liveness/proposal_status_tracker.rs (L30-46)
```rust
pub struct ExponentialWindowFailureTracker {
    window: usize,
    max_window: usize,
    past_round_statuses: BoundedVecDeque<NewRoundReason>,
    last_consecutive_success_count: usize,
    ordered_authors: Vec<Author>,
}

impl ExponentialWindowFailureTracker {
    pub(crate) fn new(max_window: usize, ordered_authors: Vec<Author>) -> Self {
        Self {
            window: 2,
            max_window,
            past_round_statuses: BoundedVecDeque::new(max_window),
            last_consecutive_success_count: 0,
            ordered_authors,
        }
```

**File:** consensus/src/liveness/proposal_status_tracker.rs (L65-78)
```rust
    fn compute_failure_window(&mut self) {
        self.last_consecutive_success_count = self.last_consecutive_statuses_matching(|reason| {
            !matches!(
                reason,
                NewRoundReason::Timeout(RoundTimeoutReason::PayloadUnavailable { .. })
            )
        });
        if self.last_consecutive_success_count == 0 {
            self.window *= 2;
            self.window = self.window.min(self.max_window);
        } else if self.last_consecutive_success_count == self.past_round_statuses.len() {
            self.window = 2;
        }
    }
```

**File:** consensus/src/liveness/proposal_status_tracker.rs (L80-98)
```rust
    fn get_exclude_authors(&self) -> HashSet<Author> {
        let mut exclude_authors = HashSet::new();

        let limit = self.window;
        for round_reason in self.past_round_statuses.iter().rev().take(limit) {
            if let NewRoundReason::Timeout(RoundTimeoutReason::PayloadUnavailable {
                missing_authors,
            }) = round_reason
            {
                for author_idx in missing_authors.iter_ones() {
                    if let Some(author) = self.ordered_authors.get(author_idx) {
                        exclude_authors.insert(*author);
                    }
                }
            }
        }

        exclude_authors
    }
```

**File:** consensus/src/liveness/proposal_status_tracker.rs (L128-161)
```rust
    fn get_params(&self) -> Option<OptQSPayloadPullParams> {
        if !self.enable_opt_qs {
            return None;
        }

        let tracker = self.failure_tracker.lock();

        counters::OPTQS_LAST_CONSECUTIVE_SUCCESS_COUNT
            .observe(tracker.last_consecutive_success_count as f64);
        if tracker.last_consecutive_success_count < tracker.window {
            warn!(
                "Skipping OptQS: (last_consecutive_successes) {} < {} (window)",
                tracker.last_consecutive_success_count, tracker.window
            );
            return None;
        }

        let exclude_authors = tracker.get_exclude_authors();
        if !exclude_authors.is_empty() {
            let exclude_authors_str: Vec<_> =
                exclude_authors.iter().map(|a| a.short_str()).collect();
            for author in &exclude_authors_str {
                counters::OPTQS_EXCLUDE_AUTHORS_COUNT
                    .with_label_values(&[author.as_str()])
                    .inc();
            }
            warn!("OptQS exclude authors: {:?}", exclude_authors_str);
        }
        Some(OptQSPayloadPullParams {
            exclude_authors,
            minimum_batch_age_usecs: self.minimum_batch_age_usecs,
        })
    }
}
```
