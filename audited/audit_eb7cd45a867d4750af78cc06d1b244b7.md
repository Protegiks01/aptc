# Audit Report

## Title
Chain Halt via Unvalidated ChangeSetConfigs Parameters Allowing Zero-Value Storage Limits

## Summary
The `ChangeSetConfigs` parameters loaded from on-chain gas schedule lack consistency validation, allowing governance to set storage limit parameters to zero or logically inconsistent values. This causes all user transactions to fail during prologue validation, resulting in complete chain halt requiring a hard fork to recover.

## Finding Description

The vulnerability exists in the gas schedule configuration system where `ChangeSetConfigs` parameters are loaded from on-chain storage without any validation of their values or logical consistency.

**Root Cause - Missing Validation:**

The on-chain gas schedule can be updated via governance without validating parameter consistency: [1](#0-0) [2](#0-1) [3](#0-2) 

The gas schedule update functions only validate feature version, not parameter consistency: [4](#0-3) 

When gas parameters are loaded from on-chain storage, no value validation occurs: [5](#0-4) 

The `ChangeSetConfigs` constructor accepts arbitrary values without validation: [6](#0-5) 

**Critical Validation Point:**

The validation logic in `check_change_set` does not check if limits are zero before comparison: [7](#0-6) 

Note that `max_write_ops_per_transaction` has a zero-check (line 95), but `max_bytes_per_write_op` (line 105) and `max_bytes_all_write_ops_per_transaction` (line 110) do not.

**Attack Vector:**

Every user transaction must pass through prologue validation, which validates the prologue's change set: [8](#0-7) 

The `SystemSessionChangeSet::new` constructor enforces validation: [9](#0-8) 

**Exploitation Path:**

1. Malicious or buggy governance proposal sets `max_bytes_per_write_op = 0` or `max_bytes_all_write_ops_per_transaction = 0` through `set_for_next_epoch`
2. Proposal passes governance voting
3. During epoch transition, the invalid config is applied
4. Any subsequent transaction that performs write operations (which includes the prologue's gas deduction and sequence number update) triggers validation
5. Since any write operation size > 0 exceeds the zero limit, validation fails with `STORAGE_WRITE_LIMIT_REACHED`
6. **All user transactions fail**, including governance transactions to fix the config
7. The chain is completely halted with no recovery path except hard fork

**Broken Invariants:**
- **Resource Limits**: The system fails to enforce valid resource limits by allowing zero limits
- **Transaction Validation**: Prologue checks incorrectly reject all valid transactions
- **Liveness**: Total loss of network availability for user transactions

## Impact Explanation

This vulnerability meets **Critical Severity** criteria per Aptos bug bounty program:

- **Total loss of liveness/network availability**: All user transactions fail to execute, completely halting the chain for normal operations
- **Non-recoverable network partition (requires hardfork)**: Even governance transactions to fix the configuration would fail with the same validation error, making recovery through normal on-chain mechanisms impossible
- **Affected nodes**: All validator nodes and the entire network
- **Permanent condition**: Once applied, the misconfiguration cannot be reverted through normal transactions

The impact is catastrophic because:
1. No user transactions can execute (all fail at prologue validation)
2. No governance fix can be applied (governance transactions also fail)
3. Block metadata transactions might continue but this doesn't restore user transaction functionality
4. The only recovery path is a coordinated hard fork by all validators

## Likelihood Explanation

**Likelihood: Medium**

**Enabling Factors:**
- Governance has legitimate authority to update gas schedules
- No technical validation prevents setting zero or inconsistent values
- The TODO comments in the codebase explicitly acknowledge this validation gap has existed since implementation
- A buggy upgrade script or malicious proposal could easily introduce invalid values

**Mitigating Factors:**
- Requires a governance proposal to pass (multi-step process with voting)
- Aptos governance participants would likely review proposals carefully
- The Aptos team maintains gas schedule update tooling that generates correct values under normal circumstances

However, the lack of any technical safeguard means a single oversight in proposal review or a compromised proposal could trigger this catastrophic failure. The risk is real and unmitigated at the code level.

## Recommendation

Implement validation in two layers:

**1. On-chain validation in gas_schedule.move:**

```move
public fun set_for_next_epoch(aptos_framework: &signer, gas_schedule_blob: vector<u8>) acquires GasScheduleV2 {
    system_addresses::assert_aptos_framework(aptos_framework);
    assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));
    let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
    
    // Add validation here
    validate_gas_schedule_consistency(&new_gas_schedule);
    
    if (exists<GasScheduleV2>(@aptos_framework)) {
        let cur_gas_schedule = borrow_global<GasScheduleV2>(@aptos_framework);
        assert!(
            new_gas_schedule.feature_version >= cur_gas_schedule.feature_version,
            error::invalid_argument(EINVALID_GAS_FEATURE_VERSION)
        );
    };
    config_buffer::upsert(new_gas_schedule);
}

fun validate_gas_schedule_consistency(schedule: &GasScheduleV2) {
    // Validate critical storage limits are non-zero and consistent
    // This requires parsing the entries map to extract specific parameters
    // and validate: max_bytes_per_write_op > 0 && 
    //               max_bytes_per_write_op <= max_bytes_all_write_ops_per_transaction
}
```

**2. Runtime validation in ChangeSetConfigs constructor:**

```rust
impl ChangeSetConfigs {
    fn new_impl(
        gas_feature_version: u64,
        max_bytes_per_write_op: u64,
        max_bytes_all_write_ops_per_transaction: u64,
        max_bytes_per_event: u64,
        max_bytes_all_events_per_transaction: u64,
        max_write_ops_per_transaction: u64,
    ) -> Self {
        // Validate consistency
        if max_bytes_per_write_op > 0 && max_bytes_all_write_ops_per_transaction > 0 {
            assert!(
                max_bytes_per_write_op <= max_bytes_all_write_ops_per_transaction,
                "max_bytes_per_write_op must be <= max_bytes_all_write_ops_per_transaction"
            );
        }
        if max_bytes_per_event > 0 && max_bytes_all_events_per_transaction > 0 {
            assert!(
                max_bytes_per_event <= max_bytes_all_events_per_transaction,
                "max_bytes_per_event must be <= max_bytes_all_events_per_transaction"
            );
        }
        
        Self {
            gas_feature_version,
            max_bytes_per_write_op,
            max_bytes_all_write_ops_per_transaction,
            max_bytes_per_event,
            max_bytes_all_events_per_transaction,
            max_write_ops_per_transaction,
        }
    }
}
```

**3. Add explicit zero-checks in validation:**

```rust
pub fn check_change_set(&self, change_set: &impl ChangeSetInterface) -> Result<(), VMStatus> {
    // ... existing code ...
    
    for (key, op_size) in change_set.write_set_size_iter() {
        if let Some(len) = op_size.write_len() {
            let write_op_size = len + (key.size() as u64);
            if self.max_bytes_per_write_op > 0 && write_op_size > self.max_bytes_per_write_op {
                return storage_write_limit_reached(None);
            }
            write_set_size += write_op_size;
        }
        if self.max_bytes_all_write_ops_per_transaction > 0 
            && write_set_size > self.max_bytes_all_write_ops_per_transaction {
            return storage_write_limit_reached(None);
        }
    }
    // ... rest of validation ...
}
```

## Proof of Concept

```rust
#[test]
#[should_panic(expected = "STORAGE_WRITE_LIMIT_REACHED")]
fn test_zero_config_causes_chain_halt() {
    use aptos_vm_types::storage::change_set_configs::ChangeSetConfigs;
    use aptos_gas_schedule::AptosGasParameters;
    
    // Simulate malicious governance setting params to zero
    let mut gas_params = AptosGasParameters::initial();
    gas_params.vm.txn.max_bytes_per_write_op = 0.into();
    gas_params.vm.txn.max_bytes_all_write_ops_per_transaction = 0.into();
    
    // Create change set configs from malicious params
    let configs = ChangeSetConfigs::from_gas_params(5, &gas_params);
    
    // Simulate a normal prologue that writes gas deduction and sequence number
    // This would be any transaction's prologue change set
    let mut change_set = VMChangeSet::empty();
    // Add a minimal write operation (gas deduction, sequence update, etc.)
    // Even 1 byte would exceed the 0 limit
    
    // This validation would fail, halting all transactions
    configs.check_change_set(&change_set).unwrap(); // PANICS
}
```

## Notes

This vulnerability is explicitly acknowledged in the codebase through TODO comments but remains unimplemented. The lack of validation at both the governance level (Move code) and runtime level (Rust code) creates a critical failure mode where the blockchain can be permanently halted through a single malicious or buggy governance proposal. The fix requires implementing the validation that the TODO comments indicate was always intended but never completed.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L47-47)
```text
        // TODO(Gas): check if gas schedule is consistent
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L67-67)
```text
            // TODO(Gas): check if gas schedule is consistent
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L75-75)
```text
            // TODO(Gas): check if gas schedule is consistent
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L91-103)
```text
    public fun set_for_next_epoch(aptos_framework: &signer, gas_schedule_blob: vector<u8>) acquires GasScheduleV2 {
        system_addresses::assert_aptos_framework(aptos_framework);
        assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));
        let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
        if (exists<GasScheduleV2>(@aptos_framework)) {
            let cur_gas_schedule = borrow_global<GasScheduleV2>(@aptos_framework);
            assert!(
                new_gas_schedule.feature_version >= cur_gas_schedule.feature_version,
                error::invalid_argument(EINVALID_GAS_FEATURE_VERSION)
            );
        };
        config_buffer::upsert(new_gas_schedule);
    }
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/macros.rs (L34-45)
```rust
            fn from_on_chain_gas_schedule(gas_schedule: &std::collections::BTreeMap<String, u64>, feature_version: u64) -> Result<Self, String> {
                let mut params = $params_name::zeros();

                $(
                    if let Some(key) = $crate::gas_schedule::macros::define_gas_parameters_extract_key_at_version!($key_bindings, feature_version) {
                        let name = format!("{}.{}", $prefix, key);
                        params.$name = gas_schedule.get(&name).cloned().ok_or_else(|| format!("Gas parameter {} does not exist. Feature version: {}.", name, feature_version))?.into();
                    }
                )*

                Ok(params)
            }
```

**File:** aptos-move/aptos-vm-types/src/storage/change_set_configs.rs (L41-57)
```rust
    fn new_impl(
        gas_feature_version: u64,
        max_bytes_per_write_op: u64,
        max_bytes_all_write_ops_per_transaction: u64,
        max_bytes_per_event: u64,
        max_bytes_all_events_per_transaction: u64,
        max_write_ops_per_transaction: u64,
    ) -> Self {
        Self {
            gas_feature_version,
            max_bytes_per_write_op,
            max_bytes_all_write_ops_per_transaction,
            max_bytes_per_event,
            max_bytes_all_events_per_transaction,
            max_write_ops_per_transaction,
        }
    }
```

**File:** aptos-move/aptos-vm-types/src/storage/change_set_configs.rs (L101-113)
```rust
        let mut write_set_size = 0;
        for (key, op_size) in change_set.write_set_size_iter() {
            if let Some(len) = op_size.write_len() {
                let write_op_size = len + (key.size() as u64);
                if write_op_size > self.max_bytes_per_write_op {
                    return storage_write_limit_reached(None);
                }
                write_set_size += write_op_size;
            }
            if write_set_size > self.max_bytes_all_write_ops_per_transaction {
                return storage_write_limit_reached(None);
            }
        }
```

**File:** aptos-move/aptos-vm/src/move_vm_ext/session/user_transaction_sessions/prologue.rs (L68-74)
```rust
            let change_set = session.finish_with_squashed_change_set(
                change_set_configs,
                module_storage,
                false,
            )?;
            let prologue_session_change_set =
                SystemSessionChangeSet::new(change_set.clone(), change_set_configs)?;
```

**File:** aptos-move/aptos-vm/src/move_vm_ext/session/user_transaction_sessions/session_change_sets.rs (L75-82)
```rust
    pub(crate) fn new(
        change_set: VMChangeSet,
        change_set_configs: &ChangeSetConfigs,
    ) -> Result<Self, VMStatus> {
        let system_session_change_set = Self { change_set };
        change_set_configs.check_change_set(&system_session_change_set)?;
        Ok(system_session_change_set)
    }
```
