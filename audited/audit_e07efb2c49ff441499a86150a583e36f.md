# Audit Report

## Title
Consensus Divergence via Inconsistent Storage Backend Error Handling in SafetyRules

## Summary
Storage backend implementations (VaultStorage, OnDiskStorage) handle permission/access errors inconsistently during consensus-critical operations. VaultStorage panics on `PermissionDenied` errors while OnDiskStorage returns recoverable errors for equivalent permission failures. This causes validators using different storage backends to diverge in behavior during voting operations, violating the deterministic execution invariant and potentially causing liveness failures.

## Finding Description

The Aptos consensus SafetyRules component uses secure storage backends to persist voting state during block consensus. Three storage backends are supported: VaultStorage (HashiCorp Vault), OnDiskStorage (file-based), and InMemoryStorage (testing only). Mainnet validators can use either VaultStorage or OnDiskStorage. [1](#0-0) 

**The Core Issue:**

When storage backends encounter permission/access errors, they return different error types:

**VaultStorage**: HTTP 403 errors from Vault are converted to `Error::PermissionDenied` [2](#0-1) 

**OnDiskStorage**: File I/O permission errors are converted to `Error::InternalError` [3](#0-2) 

**Critical Divergence in Error Handling:**

The SafetyRules error conversion explicitly panics on `PermissionDenied`: [4](#0-3) 

This means that during consensus voting operations when reading or writing SafetyData: [5](#0-4) [6](#0-5) 

**Divergent Behavior Scenario:**

1. **Validator A (VaultStorage)**: Vault token expires or gets 403 → `PermissionDenied` → **PANIC** → Node crashes
2. **Validator B (OnDiskStorage)**: File permissions issue → `io::Error` → `InternalError` → `SecureStorageUnexpectedError` → Error returned, node continues

This happens in the critical voting path called by RoundManager: [7](#0-6) 

## Impact Explanation

**Severity: HIGH**

This qualifies as **High Severity** under Aptos bug bounty criteria:
- **Validator node crashes**: VaultStorage-based validators panic and crash
- **Significant protocol violations**: Violates Deterministic Execution invariant - validators using different storage backends exhibit different failure modes for equivalent errors

**Consensus Impact:**
- **Liveness Degradation**: If multiple VaultStorage validators experience token expiration during active consensus rounds, they crash while OnDiskStorage validators continue, reducing active validator set
- **Operational Inconsistency**: Network operators cannot predict failure behavior based on storage backend choice
- **Recovery Complexity**: Crashed validators require manual intervention while others self-recover from transient errors

**Violated Invariants:**
1. **Deterministic Execution**: Validators must behave identically for identical logical conditions. Permission denied errors are logically equivalent whether from Vault HTTP 403 or filesystem permissions, but handling differs drastically.

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH**

This occurs naturally in production environments without attacker intervention:

**Common Triggers:**
- **Vault token expiration**: Tokens have TTLs and can expire during operations despite renewal attempts
- **Vault service temporary 403s**: Network issues, Vault upgrades, or policy changes
- **Filesystem permission changes**: Accidental `chmod`, SELinux policy updates, or container permission issues
- **Storage backend transitions**: Validators migrating between storage types experience different error modes

**Production Reality:**
- Validators legitimately use different storage backends based on operational preferences
- Token/permission issues are common operational events, not rare edge cases
- The panic happens during active consensus (voting path), maximizing impact

## Recommendation

**Unified Error Handling Strategy:**

Remove the panic on `PermissionDenied` and treat all storage backend errors consistently. Storage permission errors should be treated as recoverable errors that allow graceful degradation rather than immediate crashes.

**Recommended Fix:**

Modify the error conversion in `consensus/safety-rules/src/error.rs`:

```rust
impl From<aptos_secure_storage::Error> for Error {
    fn from(error: aptos_secure_storage::Error) -> Self {
        match error {
            aptos_secure_storage::Error::PermissionDenied => {
                // Log the error at ERROR level but don't panic
                // This allows the validator to continue operating and potentially recover
                error!("Storage permission denied: {:?}. Storage may need token renewal or permission fix.", error);
                Self::SecureStorageUnexpectedError(error.to_string())
            },
            aptos_secure_storage::Error::KeyVersionNotFound(_, _)
            | aptos_secure_storage::Error::KeyNotSet(_) => {
                Self::SecureStorageMissingDataError(error.to_string())
            },
            _ => Self::SecureStorageUnexpectedError(error.to_string()),
        }
    }
}
```

**Additional Recommendations:**
1. Add metrics/alerting for `PermissionDenied` errors to trigger operator notifications
2. Implement automatic token renewal backoff retry logic
3. Document storage backend operational characteristics for validator operators
4. Consider circuit breaker pattern for storage operations

## Proof of Concept

**Operational Test to Reproduce:**

```rust
// Test file: consensus/safety-rules/src/tests/storage_error_divergence.rs

#[cfg(test)]
mod storage_error_divergence_tests {
    use super::*;
    use aptos_secure_storage::{Storage, VaultStorage, OnDiskStorage};
    use aptos_consensus_types::vote_proposal::VoteProposal;
    
    #[test]
    #[should_panic(expected = "permission error")]
    fn test_vault_permission_denied_panics() {
        // Setup VaultStorage with expired/invalid token
        let vault_config = create_vault_config_with_invalid_token();
        let mut storage = Storage::from(VaultStorage::new(/*...*/));
        
        // Initialize SafetyRules with VaultStorage
        let mut safety_rules = SafetyRules::new(
            PersistentSafetyStorage::new(storage, true),
            false
        );
        
        // Attempt to vote - this will try to read/write SafetyData
        let vote_proposal = create_test_vote_proposal();
        
        // This PANICS due to PermissionDenied from Vault 403
        let _vote = safety_rules.construct_and_sign_vote_two_chain(
            &vote_proposal,
            None
        );
        // Test passes because panic occurred
    }
    
    #[test]
    fn test_ondisk_permission_denied_returns_error() {
        // Setup OnDiskStorage with file lacking permissions
        let readonly_path = create_readonly_storage_file();
        let mut storage = Storage::from(OnDiskStorage::new(readonly_path));
        
        // Initialize SafetyRules with OnDiskStorage
        let mut safety_rules = SafetyRules::new(
            PersistentSafetyStorage::new(storage, true),
            false
        );
        
        // Attempt to vote
        let vote_proposal = create_test_vote_proposal();
        
        // This returns an Error instead of panicking
        let result = safety_rules.construct_and_sign_vote_two_chain(
            &vote_proposal,
            None
        );
        
        // Verify it's an error, not a panic
        assert!(result.is_err());
        assert!(matches!(result.unwrap_err(), 
            Error::SecureStorageUnexpectedError(_)));
        // Test passes - no panic occurred
    }
}
```

**Manual Reproduction Steps:**

1. Deploy two validators: one with VaultStorage, one with OnDiskStorage
2. During active consensus, simulate permission failure:
   - VaultStorage: Revoke/expire Vault token or return 403
   - OnDiskStorage: `chmod 000` on storage file
3. Observe divergent behavior:
   - VaultStorage validator: Process panics with "permission error" message
   - OnDiskStorage validator: Logs error, returns error to consensus, continues running
4. Result: Validators exhibit non-deterministic failure modes for logically equivalent errors

## Notes

This vulnerability represents a **protocol design flaw** rather than a traditional exploit. It violates the fundamental consensus requirement that all validators must behave deterministically. While not exploitable by external attackers, it creates operational fragility and can cause liveness issues during routine maintenance events that affect storage backend permissions.

The issue is particularly concerning because:
- It affects **production mainnet validators** using legitimate storage configurations
- The divergence occurs in **consensus-critical code paths** (voting)
- The failure mode is **catastrophic** for one backend (panic) but **recoverable** for another
- Operators have no visibility into this divergence until failures occur

### Citations

**File:** config/src/config/safety_rules_config.rs (L86-96)
```rust
            // Verify that the secure backend is appropriate for mainnet validators
            if chain_id.is_mainnet()
                && node_type.is_validator()
                && safety_rules_config.backend.is_in_memory()
            {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "The secure backend should not be set to in memory storage in mainnet!"
                        .to_string(),
                ));
            }
```

**File:** secure/storage/src/error.rs (L38-42)
```rust
impl From<io::Error> for Error {
    fn from(error: io::Error) -> Self {
        Self::InternalError(format!("{}", error))
    }
}
```

**File:** secure/storage/src/error.rs (L56-64)
```rust
impl From<aptos_vault_client::Error> for Error {
    fn from(error: aptos_vault_client::Error) -> Self {
        match error {
            aptos_vault_client::Error::NotFound(_, key) => Self::KeyNotSet(key),
            aptos_vault_client::Error::HttpError(403, _, _) => Self::PermissionDenied,
            _ => Self::InternalError(format!("{}", error)),
        }
    }
}
```

**File:** consensus/safety-rules/src/error.rs (L78-98)
```rust
impl From<aptos_secure_storage::Error> for Error {
    fn from(error: aptos_secure_storage::Error) -> Self {
        match error {
            aptos_secure_storage::Error::PermissionDenied => {
                // If a storage error is thrown that indicates a permission failure, we
                // want to panic immediately to alert an operator that something has gone
                // wrong. For example, this error is thrown when a storage (e.g., vault)
                // token has expired, so it makes sense to fail fast and require a token
                // renewal!
                panic!(
                    "A permission error was thrown: {:?}. Maybe the storage token needs to be renewed?",
                    error
                );
            },
            aptos_secure_storage::Error::KeyVersionNotFound(_, _)
            | aptos_secure_storage::Error::KeyNotSet(_) => {
                Self::SecureStorageMissingDataError(error.to_string())
            },
            _ => Self::SecureStorageUnexpectedError(error.to_string()),
        }
    }
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L66-66)
```rust
        let mut safety_data = self.persistent_storage.safety_data()?;
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L92-92)
```rust
        self.persistent_storage.set_safety_data(safety_data)?;
```

**File:** consensus/src/round_manager.rs (L1520-1523)
```rust
        let vote_result = self.safety_rules.lock().construct_and_sign_vote_two_chain(
            &vote_proposal,
            self.block_store.highest_2chain_timeout_cert().as_deref(),
        );
```
