# Audit Report

## Title
Multi-Step Governance Proposals Lack Atomicity Validation Enabling Permanent Inconsistent State

## Summary
The Aptos governance multi-step proposal mechanism does not validate that all steps complete successfully before applying configuration changes. Once a step executes, its changes are permanent and on-chain, even if subsequent steps fail or are never executed. This can leave critical system configurations in an inconsistent state indefinitely, with no rollback mechanism.

## Finding Description
The multi-step proposal system in Aptos governance allows splitting large governance actions across multiple transaction steps. Each step calls `resolve_multi_step_proposal` which updates the approved execution hash to the next step, then executes configuration changes. [1](#0-0) 

The critical flaw is that each step is executed atomically in its own transaction, but there is no validation that subsequent steps will complete. Once a step succeeds:

1. The configuration changes from that step are permanently applied
2. The `IS_MULTI_STEP_PROPOSAL_IN_EXECUTION_KEY` flag is set to `true`, blocking further voting
3. The approved execution hash is updated to point to the next step [2](#0-1) 

However, if subsequent steps are never executed (due to technical failure, political disagreement, or malicious blocking), the system remains in a partially-executed state indefinitely. The flag stays `true` and the proposal is never marked as fully resolved, but the changes from completed steps remain active. [3](#0-2) 

In the specific case of execution config updates, a multi-step proposal could contain:
- Step 1: Update execution config (changing transaction shuffler type)
- Step 2: Update gas schedule  
- Step 3: Update consensus config [4](#0-3) 

If Step 1 succeeds but Steps 2-3 fail, the network has a new execution config but old gas/consensus configs, potentially creating incompatible system state.

The code confirms no rollback mechanism exists: [5](#0-4) 

Each step's validation is atomic, but cross-step atomicity is not enforced. There is no timeout mechanism forcing step completion:

The proposal's `expiration_secs` only applies to the voting period, not to step execution timing. Once approved, steps can be executed at any time without deadline.

## Impact Explanation
This qualifies as **Medium Severity** under Aptos bug bounty criteria: "State inconsistencies requiring intervention."

**Specific Impacts:**
1. **System Configuration Inconsistency**: Execution config, gas schedule, consensus config, and feature flags may be mutually dependent. Partial updates could cause:
   - Transaction processing behavior mismatches between validators
   - Unexpected gas calculation with new execution parameters
   - Consensus protocol incompatibilities

2. **Governance System Deadlock**: The `IS_MULTI_STEP_PROPOSAL_IN_EXECUTION_KEY` flag remains permanently `true` for abandoned proposals, marking them as "in execution" indefinitely with no cleanup path.

3. **Network Intervention Required**: Manual governance action would be needed to:
   - Create new proposals to revert or complete changes
   - No automated recovery mechanism exists

The severity is Medium rather than High/Critical because:
- Does not directly cause fund loss or consensus safety violation
- Requires governance proposal to pass first (social layer protection)
- Can be manually recovered through new governance proposals
- Does not affect already-committed blocks or consensus history

## Likelihood Explanation
**Likelihood: Medium-High**

This vulnerability is likely to occur because:

1. **Multi-step proposals are standard practice**: The example configuration shows production usage of multi-step proposals combining execution, consensus, and gas changes. [6](#0-5) 

2. **No technical enforcement of completion**: Steps can be executed days or weeks apart with no deadline.

3. **Multiple failure scenarios**:
   - **Political**: Governance community decides not to execute later steps after seeing effects of early steps
   - **Technical**: Transaction size limits, gas issues, or bugs in later steps
   - **Malicious**: Proposer intentionally creates multi-step proposal knowing later steps won't pass, to apply partial changes

4. **No warnings or safeguards**: The code has no comments warning about this risk, and no validation that dependent configs are compatible.

## Recommendation

**Option 1: Add Atomic Execution Validation (Recommended)**
Implement a two-phase commit pattern where:
1. All steps must be "staged" before any execute
2. Validation ensures all steps are ready to execute
3. All steps execute in sequence within a time-bounded window
4. If any step fails, all changes are reverted

**Option 2: Add Execution Deadline**
Add per-step execution deadlines to the proposal metadata:
```move
// In voting.move, add to Proposal struct metadata:
const STEP_EXECUTION_DEADLINE_KEY: vector<u8> = b"STEP_EXECUTION_DEADLINE";

// In resolve_proposal_v2, validate deadline:
if (is_multi_step && !next_execution_hash_is_empty) {
    let deadline = get_step_deadline(&proposal.metadata);
    assert!(timestamp::now_seconds() < deadline, ESTEP_EXECUTION_DEADLINE_EXCEEDED);
}
```

**Option 3: Add Rollback Capability**
Create a governance function to rollback abandoned multi-step proposals:
```move
public entry fun rollback_abandoned_multi_step_proposal(
    proposal_id: u64,
    rollback_script_hash: vector<u8>
) acquires ApprovedExecutionHashes {
    // Verify proposal is abandoned (in execution for > X days)
    // Allow governance to execute rollback script
    // Reset IS_MULTI_STEP_PROPOSAL_IN_EXECUTION_KEY to false
}
```

**Option 4: Enhance Validation** (Minimal Change)
Add explicit validation in `generate_execution_config_upgrade_proposal` to ensure all related configs are updated in a single atomic step rather than split across multiple steps:

```rust
// In execution_config.rs
pub fn generate_execution_config_upgrade_proposal(
    execution_config: &OnChainExecutionConfig,
    is_testnet: bool,
    next_execution_hash: Option<HashValue>,
    is_multi_step: bool,
) -> Result<Vec<(String, String)>> {
    // Add validation
    if is_multi_step && next_execution_hash.is_some() {
        // Warn: Execution config should be atomic
        log::warn!("Execution config update in multi-step proposal may cause inconsistency");
    }
    // ... rest of implementation
}
```

## Proof of Concept

```move
#[test_only]
module aptos_framework::test_multi_step_inconsistency {
    use aptos_framework::aptos_governance;
    use aptos_framework::voting;
    use aptos_framework::execution_config;
    use aptos_framework::gas_schedule;
    
    #[test(aptos_framework = @aptos_framework, proposer = @0x123)]
    fun test_abandoned_multi_step_leaves_inconsistent_state(
        aptos_framework: &signer,
        proposer: &signer,
    ) {
        // Setup: Create multi-step proposal with execution config in step 1, gas in step 2
        let execution_config_v2 = create_new_execution_config();
        let new_gas_schedule = create_new_gas_schedule();
        
        // Create proposal with 2 steps
        let proposal_id = aptos_governance::create_proposal_v2_impl(
            proposer,
            execution_config_v2,
            hash_of_step_1,
            b"update configs",
            b"", 
            true // is_multi_step
        );
        
        // Vote and pass the proposal
        vote_to_pass(proposal_id);
        
        // Execute Step 1: Apply new execution config
        aptos_governance::resolve_multi_step_proposal(
            proposal_id,
            @aptos_framework,
            hash_of_step_2 // next step hash
        );
        
        // Verify execution config was updated
        let current_exec_config = execution_config::get();
        assert!(current_exec_config == execution_config_v2, 0);
        
        // Verify proposal is marked as "in execution"
        assert!(voting::is_multi_step_proposal_in_execution(@aptos_framework, proposal_id), 1);
        
        // VULNERABILITY: Step 2 never executes (simulating abandonment)
        // Gas schedule remains at old version while execution config is new
        
        advance_time_by_months(6); // 6 months pass
        
        // System is now in inconsistent state:
        // - Execution config is new (step 1 applied)
        // - Gas schedule is old (step 2 never executed)  
        // - Proposal still marked as "in execution"
        // - No rollback mechanism available
        // - No timeout to force completion
        
        let current_gas = gas_schedule::get();
        assert!(current_gas != new_gas_schedule, 2); // Gas not updated!
        
        // Proposal cannot be voted on again
        assert!(voting::is_multi_step_proposal_in_execution(@aptos_framework, proposal_id), 3);
    }
}
```

## Notes

The vulnerability is confirmed through analysis of the codebase showing:
1. No atomicity guarantees across multi-step proposal steps
2. No rollback mechanism for partially-executed proposals  
3. No execution deadline enforcement beyond initial voting period
4. Production examples combining dependent configs in multi-step proposals
5. No validation that dependent configurations are compatible

This represents a genuine governance system design flaw that can lead to state inconsistencies requiring manual intervention.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L644-661)
```text
    public fun resolve_multi_step_proposal(
        proposal_id: u64,
        signer_address: address,
        next_execution_hash: vector<u8>
    ): signer acquires GovernanceResponsbility, ApprovedExecutionHashes {
        voting::resolve_proposal_v2<GovernanceProposal>(@aptos_framework, proposal_id, next_execution_hash);
        // If the current step is the last step of this multi-step proposal,
        // we will remove the execution hash from the ApprovedExecutionHashes map.
        if (vector::length(&next_execution_hash) == 0) {
            remove_approved_hash(proposal_id);
        } else {
            // If the current step is not the last step of this proposal,
            // we replace the current execution hash with the next execution hash
            // in the ApprovedExecutionHashes map.
            add_approved_script_hash(proposal_id)
        };
        get_signer(signer_address)
    }
```

**File:** aptos-move/framework/aptos-framework/sources/voting.move (L524-566)
```text
        // Update the IS_MULTI_STEP_PROPOSAL_IN_EXECUTION_KEY key to indicate that the multi-step proposal is in execution.
        let multi_step_in_execution_key = utf8(IS_MULTI_STEP_PROPOSAL_IN_EXECUTION_KEY);
        if (simple_map::contains_key(&proposal.metadata, &multi_step_in_execution_key)) {
            let is_multi_step_proposal_in_execution_value = simple_map::borrow_mut(
                &mut proposal.metadata,
                &multi_step_in_execution_key
            );
            *is_multi_step_proposal_in_execution_value = to_bytes(&true);
        };

        let multi_step_key = utf8(IS_MULTI_STEP_PROPOSAL_KEY);
        let is_multi_step = simple_map::contains_key(&proposal.metadata, &multi_step_key) && from_bcs::to_bool(
            *simple_map::borrow(&proposal.metadata, &multi_step_key)
        );
        let next_execution_hash_is_empty = vector::length(&next_execution_hash) == 0;

        // Assert that if this proposal is single-step, the `next_execution_hash` parameter is empty.
        assert!(
            is_multi_step || next_execution_hash_is_empty,
            error::invalid_argument(ESINGLE_STEP_PROPOSAL_CANNOT_HAVE_NEXT_EXECUTION_HASH)
        );

        // If the `next_execution_hash` parameter is empty, it means that either
        // - this proposal is a single-step proposal, or
        // - this proposal is multi-step and we're currently resolving the last step in the multi-step proposal.
        // We can mark that this proposal is resolved.
        if (next_execution_hash_is_empty) {
            proposal.is_resolved = true;
            proposal.resolution_time_secs = timestamp::now_seconds();

            // Set the `IS_MULTI_STEP_PROPOSAL_IN_EXECUTION_KEY` value to false upon successful resolution of the last step of a multi-step proposal.
            if (is_multi_step) {
                let is_multi_step_proposal_in_execution_value = simple_map::borrow_mut(
                    &mut proposal.metadata,
                    &multi_step_in_execution_key
                );
                *is_multi_step_proposal_in_execution_value = to_bytes(&false);
            };
        } else {
            // If the current step is not the last step,
            // update the proposal's execution hash on-chain to the execution hash of the next step.
            proposal.execution_hash = next_execution_hash;
        };
```

**File:** aptos-move/aptos-release-builder/data/example.yaml (L31-69)
```yaml
    update_sequence:
      - FeatureFlag:
          enabled:
            - code_dependency_check
            - treat_friend_as_private
            - sha512_and_ripe_md160_natives
            - aptos_std_chain_id_natives
            - v_m_binary_format_v6
            - multi_ed25519_pk_validate_v2_natives
            - blake2b256_native
            - resource_groups
            - multisig_accounts
            - delegation_pools
            - ed25519_pubkey_validate_return_false_wrong_length
            - struct_constructors
            - cryptography_algebra_natives
            - bls12381_structures
          disabled: []
      - Consensus:
          V1:
            decoupled_execution: true
            back_pressure_limit: 10
            exclude_round: 40
            proposer_election_type:
              leader_reputation:
                proposer_and_voter_v2:
                  active_weight: 1000
                  inactive_weight: 10
                  failed_weight: 1
                  failure_threshold_percent: 10
                  proposer_window_num_validators_multiplier: 10
                  voter_window_num_validators_multiplier: 1
                  weight_by_voting_power: true
                  use_history_from_previous_epoch_max_count: 5
            max_failed_authors_to_store: 10
      - Execution:
          V1:
            transaction_shuffler_type: no_shuffling
      - RawScript: data/example_proposals/empty_multi_step.move
```

**File:** aptos-move/aptos-release-builder/src/components/mod.rs (L656-678)
```rust
            let mut result: Vec<(String, String)> = vec![];
            if let ExecutionMode::MultiStep = &proposal.execution_mode {
                for entry in proposal.update_sequence.iter().rev() {
                    entry
                        .generate_release_script(
                            client.as_ref(),
                            &mut result,
                            proposal.execution_mode,
                        )
                        .await?;
                }
                result.reverse();
            } else {
                for entry in proposal.update_sequence.iter() {
                    entry
                        .generate_release_script(
                            client.as_ref(),
                            &mut result,
                            proposal.execution_mode,
                        )
                        .await?;
                }
            }
```

**File:** aptos-move/aptos-release-builder/src/components/mod.rs (L770-814)
```rust
            proposals: vec![
                Proposal {
                    execution_mode: ExecutionMode::MultiStep,
                    metadata: ProposalMetadata::default(),
                    name: "framework".to_string(),
                    update_sequence: vec![ReleaseEntry::Framework(FrameworkReleaseConfig {
                        bytecode_version: VERSION_DEFAULT,
                        git_hash: None,
                    })],
                },
                Proposal {
                    execution_mode: ExecutionMode::MultiStep,
                    metadata: ProposalMetadata::default(),
                    name: "gas".to_string(),
                    update_sequence: vec![ReleaseEntry::Gas {
                        old: None,
                        new: GasScheduleLocator::Current,
                    }],
                },
                Proposal {
                    execution_mode: ExecutionMode::MultiStep,
                    metadata: ProposalMetadata::default(),
                    name: "feature_flags".to_string(),
                    update_sequence: vec![
                        ReleaseEntry::FeatureFlag(Features {
                            enabled: AptosFeatureFlag::default_features()
                                .into_iter()
                                .map(crate::components::feature_flags::FeatureFlag::from)
                                .collect(),
                            disabled: vec![],
                        }),
                        ReleaseEntry::Consensus(OnChainConsensusConfig::default()),
                        ReleaseEntry::Execution(OnChainExecutionConfig::V1(ExecutionConfigV1 {
                            transaction_shuffler_type:
                                TransactionShufflerType::DeprecatedSenderAwareV1(32),
                        })),
                        //ReleaseEntry::RawScript(PathBuf::from(
                        //    "data/proposals/empty_multi_step.move",
                        //)),
                    ],
                },
            ],
        }
    }
}
```
