# Audit Report

## Title
State View Version Mismatch in Events API Causes Type Confusion and API Inconsistency

## Summary
The Events API retrieves events at a specific ledger version but deserializes them using the latest state checkpoint's type information, creating a version mismatch that causes API failures and potential data corruption when Move modules are upgraded between these operations.

## Finding Description

The vulnerability exists in the event conversion flow within `api/src/events.rs`. The execution path is:

1. The events endpoint calls `Account::new()` which captures the current ledger state [1](#0-0) 

2. This retrieves `latest_ledger_info` at a specific version [2](#0-1) 

3. The `list()` function extracts this version and retrieves events at that specific version [3](#0-2) 

4. **Critical Bug**: The code then calls `latest_state_view_poem()` to get a state view for type conversion [4](#0-3) 

5. This function **ignores** the `ledger_info` parameter's version and always retrieves the LATEST state checkpoint [5](#0-4) 

6. The implementation calls `latest_state_checkpoint_view()` which gets the latest checkpoint version, not the version from the ledger_info [6](#0-5) 

7. This state view is used by `try_into_versioned_events()` to deserialize event data using Move type layouts [7](#0-6) 

The correct approach is demonstrated elsewhere in the API codebase, where `state_view_at_version()` is used to get state at a specific version [8](#0-7) 

**Exploitation Scenario:**

When a Move module is upgraded between event retrieval and type deserialization, the following issues occur:

- **Incompatible type layouts**: Deserialization fails, causing the API to return InternalError responses
- **Compatible but semantically different layouts**: Events deserialize successfully but with wrong field names/mappings, returning corrupted data to clients

This breaks the API's consistency guarantee that all data in a response corresponds to a single ledger version.

## Impact Explanation

This is a **High Severity** vulnerability per the Aptos bug bounty criteria for "API Crashes (High)":

1. **API Availability**: When type layouts are incompatible between versions, deserialization fails and the API returns errors instead of valid event data

2. **Data Integrity**: When type layouts are compatible but semantically different (e.g., field names changed), the API returns events with incorrect field mappings, potentially causing client applications to make wrong decisions based on corrupted data

3. **Protocol Violation**: The API guarantees consistent data at a specific ledger version, but this bug mixes type information from different versions, violating this fundamental consistency guarantee

## Likelihood Explanation

**Likelihood: HIGH**

This vulnerability triggers during normal blockchain operation:

- Occurs naturally whenever Move modules are upgraded via governance (regular occurrence on Aptos mainnet)
- The timing window exists between `Account::new()` capturing the version and `list()` executing in a spawned blocking task [9](#0-8) 
- No attacker sophistication required - just normal blockchain progression
- Affects any API user querying events during or shortly after module upgrades
- No special permissions needed

## Recommendation

Replace `latest_state_view_poem()` with `state_view_at_version()` to ensure the state view matches the version at which events were retrieved:

```rust
let state_view = self
    .context
    .state_view_at_version(ledger_version)
    .map_err(|err| {
        BasicErrorWith404::internal_with_code(
            err,
            AptosErrorCode::InternalError,
            &latest_ledger_info,
        )
    })?;
```

This approach is already used correctly in other parts of the API [10](#0-9) 

## Proof of Concept

A PoC would require:
1. Deploy a Move module with an event struct
2. Emit events from that module
3. Upgrade the module changing the event struct layout
4. Query historical events via the API during/after the upgrade
5. Observe either API errors or incorrect field mappings in the JSON response

## Notes

This vulnerability also affects other API endpoints using `latest_state_view_poem()` including the transactions API [11](#0-10) , suggesting a systematic issue with state view management across the API layer.

### Citations

**File:** api/src/events.rs (L78-87)
```rust
        api_spawn_blocking(move || {
            let account = Account::new(api.context.clone(), address.0, None, None, None)?;
            api.list(
                account.latest_ledger_info,
                accept_type,
                page,
                EventKey::new(creation_number.0 .0, address.0.into()),
            )
        })
        .await
```

**File:** api/src/events.rs (L162-170)
```rust
        let ledger_version = latest_ledger_info.version();
        let events = self
            .context
            .get_events(
                &event_key,
                page.start_option(),
                page.limit(&latest_ledger_info)?,
                ledger_version,
            )
```

**File:** api/src/events.rs (L182-194)
```rust
                let events = self
                    .context
                    .latest_state_view_poem(&latest_ledger_info)?
                    .as_converter(self.context.db.clone(), self.context.indexer_reader.clone())
                    .try_into_versioned_events(&events)
                    .context("Failed to convert events from storage into response")
                    .map_err(|err| {
                        BasicErrorWith404::internal_with_code(
                            err,
                            AptosErrorCode::InternalError,
                            &latest_ledger_info,
                        )
                    })?;
```

**File:** api/src/accounts.rs (L243-246)
```rust
        let (latest_ledger_info, requested_version) = context
            .get_latest_ledger_info_and_verify_lookup_version(
                requested_ledger_version.map(|inner| inner.0),
            )?;
```

**File:** api/src/context.rs (L160-168)
```rust
    pub fn latest_state_view_poem<E: InternalError>(
        &self,
        ledger_info: &LedgerInfo,
    ) -> Result<DbStateView, E> {
        self.db
            .latest_state_checkpoint_view()
            .context("Failed to read latest state checkpoint from DB")
            .map_err(|e| E::internal_with_code(e, AptosErrorCode::InternalError, ledger_info))
    }
```

**File:** api/src/context.rs (L177-191)
```rust
    pub fn state_view<E: StdApiError>(
        &self,
        requested_ledger_version: Option<u64>,
    ) -> Result<(LedgerInfo, u64, DbStateView), E> {
        let (latest_ledger_info, requested_ledger_version) =
            self.get_latest_ledger_info_and_verify_lookup_version(requested_ledger_version)?;

        let state_view = self
            .state_view_at_version(requested_ledger_version)
            .map_err(|err| {
                E::internal_with_code(err, AptosErrorCode::InternalError, &latest_ledger_info)
            })?;

        Ok((latest_ledger_info, requested_ledger_version, state_view))
    }
```

**File:** storage/storage-interface/src/state_store/state_view/db_state_view.rs (L81-91)
```rust
impl LatestDbStateCheckpointView for Arc<dyn DbReader> {
    fn latest_state_checkpoint_view(&self) -> StateViewResult<DbStateView> {
        Ok(DbStateView {
            db: self.clone(),
            version: self
                .get_latest_state_checkpoint_version()
                .map_err(Into::<StateViewError>::into)?,
            maybe_verify_against_state_root_hash: None,
        })
    }
}
```

**File:** api/types/src/convert.rs (L612-624)
```rust
    pub fn try_into_versioned_events(
        &self,
        events: &[EventWithVersion],
    ) -> Result<Vec<VersionedEvent>> {
        let mut ret = vec![];
        for event in events {
            let data = self
                .inner
                .view_value(event.event.type_tag(), event.event.event_data())?;
            ret.push((event, MoveValue::try_from(data)?.json()?).into());
        }
        Ok(ret)
    }
```

**File:** api/src/view_function.rs (L105-113)
```rust
    let state_view = context
        .state_view_at_version(requested_version)
        .map_err(|err| {
            BasicErrorWith404::bad_request_with_code(
                err,
                AptosErrorCode::InternalError,
                &ledger_info,
            )
        })?;
```

**File:** api/src/transactions.rs (L1015-1040)
```rust
        match accept_type {
            AcceptType::Json => {
                let state_view = self.context.latest_state_view_poem(ledger_info)?;
                let transaction = match transaction_data {
                    TransactionData::OnChain(txn) => {
                        let timestamp =
                            self.context.get_block_timestamp(ledger_info, txn.version)?;
                        state_view
                            .as_converter(
                                self.context.db.clone(),
                                self.context.indexer_reader.clone(),
                            )
                            .try_into_onchain_transaction(timestamp, txn)
                            .context("Failed to convert on chain transaction to Transaction")
                            .map_err(|err| {
                                BasicErrorWith404::internal_with_code(
                                    err,
                                    AptosErrorCode::InternalError,
                                    ledger_info,
                                )
                            })?
                    },
                    TransactionData::Pending(txn) => state_view
                        .as_converter(self.context.db.clone(), self.context.indexer_reader.clone())
                        .try_into_pending_transaction(*txn)
                        .context("Failed to convert on pending transaction to Transaction")
```
