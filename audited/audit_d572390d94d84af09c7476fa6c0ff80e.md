# Audit Report

## Title
Consensus Observer DoS via Unchecked BlockInfo-Payload Mismatch in BlockPayload Messages

## Summary
The `ConsensusObserverMessage::new_block_payload_message()` function creates `BlockPayload` messages without validating that the `BlockInfo` corresponds to the `transaction_payload`. Specifically, the `BlockInfo.timestamp_usecs` field is used during payload digest verification to determine batch expiration, but an attacker can provide an incorrect timestamp. This causes consensus observers to store payloads verified with wrong expiry logic, leading to rejection of valid ordered blocks and denial of service against the observer network. [1](#0-0) 

## Finding Description

The vulnerability exists in the consensus observer protocol's payload verification flow. When a consensus observer receives a `BlockPayload` message, it undergoes two-phase verification:

**Phase 1: Initial Payload Verification**
The `verify_payload_digests()` method reconstructs transaction batches and verifies their cryptographic digests. Critically, it uses `block_info.timestamp_usecs()` to determine which batches have expired and should be skipped: [2](#0-1) 

**Phase 2: Ordered Block Verification**
When the ordered block arrives later, `verify_payloads_against_ordered_block()` compares the stored transaction payload against the ordered block's payload structure: [3](#0-2) 

**The Attack Vector:**

1. An attacker sends a malicious `BlockPayload` message with:
   - `BlockInfo` with **incorrect** `timestamp_usecs` (e.g., artificially early/late)
   - Valid `transaction_payload` with correct batch digests

2. The observer receives this and calls `verify_payload_digests()`: [4](#0-3) 

3. Because the timestamp is wrong, the expiry check at line 996 uses incorrect logic:
   - If timestamp too early → non-expired batches appear expired → batches incorrectly skipped
   - If timestamp too late → expired batches appear valid → batches incorrectly included

4. The payload is stored indexed by `(epoch, round)`: [5](#0-4) 

5. When the legitimate `OrderedBlock` arrives (with correct timestamp), the system retrieves the stored payload and calls `verify_against_ordered_payload()`: [6](#0-5) 

6. **Verification fails** because the batch structure doesn't match (due to different expiry logic applied during Phase 1)

7. The valid ordered block is **rejected**: [7](#0-6) 

**Invariant Violation:**
This breaks the consensus observer protocol's fundamental guarantee that observers can reliably follow the blockchain by receiving and verifying block payloads before ordered blocks arrive.

## Impact Explanation

**Severity: High** - Significant Protocol Violations

This vulnerability enables an attacker to perform denial of service attacks against the consensus observer network:

1. **Observer Network Disruption**: Consensus observers unable to follow the blockchain, breaking the observer protocol
2. **API Service Degradation**: Applications relying on observer nodes would experience service disruptions
3. **Cascade Failures**: Multiple observers could be attacked simultaneously, affecting ecosystem-wide services
4. **No Validator Privileges Required**: Any network peer can send crafted `BlockPayload` messages

While this doesn't directly compromise consensus safety among validators, it violates the "Significant protocol violations" category under High Severity ($50,000) in the Aptos Bug Bounty program. The consensus observer protocol is a critical component for non-validator nodes to follow the chain, and breaking this functionality affects network reliability and user experience.

## Likelihood Explanation

**Likelihood: Medium-High**

The attack is feasible with moderate complexity:

**Attacker Requirements:**
- Network connectivity to consensus observers (standard peer-to-peer access)
- Ability to construct valid `BlockPayload` messages with manipulated timestamps
- Timing to send malicious payloads before legitimate ordered blocks arrive

**Enabling Factors:**
- No cryptographic validation that `BlockInfo` matches `transaction_payload` in `new_block_payload_message()`
- Payload stored by `(epoch, round)` only, not validated against block ID
- No re-verification with correct timestamp when ordered block arrives
- Network message propagation delays provide attack window

**Mitigating Factors:**
- Observers may have fallback mechanisms to switch publishers
- Attack must be timed before ordered block arrival
- Requires sustained effort to cause prolonged disruption

## Recommendation

**Immediate Fix: Validate BlockInfo Against Payload**

Add validation in `verify_payload_digests()` to ensure the `BlockInfo` actually corresponds to the transaction payload. Specifically:

1. **Defer timestamp-dependent validation until ordered block arrives**
2. **Add BlockInfo.id validation against computed block hash**
3. **Re-verify with correct timestamp during ordered block processing**

**Recommended Code Changes:**

```rust
// In consensus/src/consensus_observer/observer/payload_store.rs
// Modify verify_payloads_against_ordered_block() to re-verify digests

pub fn verify_payloads_against_ordered_block(
    &mut self,
    ordered_block: &OrderedBlock,
) -> Result<(), Error> {
    for ordered_block in ordered_block.blocks() {
        let block_epoch = ordered_block.epoch();
        let block_round = ordered_block.round();

        match self.block_payloads.lock().entry((block_epoch, block_round)) {
            Entry::Occupied(entry) => {
                let block_payload = match entry.get() {
                    BlockPayloadStatus::AvailableAndVerified(bp) => bp,
                    // ... error handling
                };

                // NEW: Validate BlockInfo matches ordered block
                if block_payload.block().id() != ordered_block.id() {
                    return Err(Error::InvalidMessageError(format!(
                        "BlockInfo ID mismatch! Stored: {:?}, Ordered: {:?}",
                        block_payload.block().id(), ordered_block.id()
                    )));
                }

                // NEW: Re-verify digests with correct timestamp
                // (or store unverified and verify here)
                block_payload.verify_payload_digests()?;

                let transaction_payload = block_payload.transaction_payload();
                let ordered_block_payload = ordered_block.block().payload()
                    .ok_or_else(|| Error::InvalidMessageError(...))?;
                    
                transaction_payload.verify_against_ordered_payload(ordered_block_payload)?;
            },
            // ... vacancy handling
        }
    }
    Ok(())
}
```

**Alternative Approach:**
Store `BlockPayload` in unverified state initially, only verify digests when the matching `OrderedBlock` arrives with authoritative `BlockInfo`.

## Proof of Concept

```rust
#[test]
fn test_block_payload_timestamp_mismatch_dos() {
    // Setup: Create a consensus observer and mock network
    let mut observer = create_test_consensus_observer();
    let peer_id = create_mock_peer();
    
    // Create a valid ordered block for epoch=1, round=10
    let real_block = create_test_block(1, 10, 1000000); // timestamp=1000000
    let real_payload = create_test_payload_with_batches(vec![
        create_batch(expiration=500000), // Expired batch
        create_batch(expiration=1500000), // Valid batch
    ]);
    
    // Attacker constructs malicious BlockPayload with WRONG timestamp
    let malicious_block_info = BlockInfo::new(
        1, // epoch
        10, // round  
        real_block.id(),
        HashValue::zero(),
        0,
        100000, // WRONG: timestamp much earlier than real block
        None,
    );
    
    // Create BlockPayload with mismatched data
    let malicious_payload = ConsensusObserverMessage::new_block_payload_message(
        malicious_block_info,
        real_payload.clone(),
    );
    
    // Observer receives and processes malicious payload
    // Due to wrong timestamp (100000), batch with expiration=500000 
    // appears non-expired and gets verified
    observer.process_message(peer_id, malicious_payload).await;
    
    // Now the real ordered block arrives
    let ordered_block = create_ordered_block(real_block);
    
    // This should FAIL verification because:
    // 1. Stored payload was verified with timestamp=100000 (batch included)
    // 2. Real block has timestamp=1000000 (batch should be excluded)
    // 3. Batch structure mismatch → verification fails
    let result = observer.process_ordered_block(peer_id, ordered_block).await;
    
    // Assert: Valid ordered block was incorrectly rejected
    assert!(result.is_err());
    assert!(observer.get_last_ordered_block().round() < 10);
    
    // Impact: Observer cannot progress beyond this block (DoS)
}
```

## Notes

The root cause is the lack of coupling between `BlockInfo` and `BlockTransactionPayload` in the `new_block_payload_message()` constructor. The block ID (hash) should cryptographically bind to the payload, but this relationship is never validated. The `BlockInfo.timestamp_usecs` field becomes a trust boundary that an attacker can manipulate to cause batch expiry logic divergence between initial verification and ordered block verification phases.

This is distinct from network-level DoS (out of scope) as it exploits a protocol logic flaw requiring understanding of the two-phase verification architecture and batch expiration semantics.

### Citations

**File:** consensus/src/consensus_observer/network/observer_message.rs (L57-63)
```rust
    pub fn new_block_payload_message(
        block: BlockInfo,
        transaction_payload: BlockTransactionPayload,
    ) -> ConsensusObserverDirectSend {
        let block_payload = BlockPayload::new(block, transaction_payload);
        ConsensusObserverDirectSend::BlockPayload(block_payload)
    }
```

**File:** consensus/src/consensus_observer/network/observer_message.rs (L647-717)
```rust
    /// Verifies the transaction payload against the given ordered block payload
    pub fn verify_against_ordered_payload(
        &self,
        ordered_block_payload: &Payload,
    ) -> Result<(), Error> {
        match ordered_block_payload {
            Payload::DirectMempool(_) => {
                return Err(Error::InvalidMessageError(
                    "Direct mempool payloads are not supported for consensus observer!".into(),
                ));
            },
            Payload::InQuorumStore(proof_with_data) => {
                // Verify the batches in the requested block
                self.verify_batches(&proof_with_data.proofs)?;
            },
            Payload::InQuorumStoreWithLimit(proof_with_data) => {
                // Verify the batches in the requested block
                self.verify_batches(&proof_with_data.proof_with_data.proofs)?;

                // Verify the transaction limit
                self.verify_transaction_limit(proof_with_data.max_txns_to_execute)?;
            },
            Payload::QuorumStoreInlineHybrid(
                inline_batches,
                proof_with_data,
                max_txns_to_execute,
            ) => {
                // Verify the batches in the requested block
                self.verify_batches(&proof_with_data.proofs)?;

                // Verify the inline batches
                self.verify_inline_batches(inline_batches)?;

                // Verify the transaction limit
                self.verify_transaction_limit(*max_txns_to_execute)?;
            },
            Payload::QuorumStoreInlineHybridV2(
                inline_batches,
                proof_with_data,
                execution_limits,
            ) => {
                // Verify the batches in the requested block
                self.verify_batches(&proof_with_data.proofs)?;

                // Verify the inline batches
                self.verify_inline_batches(inline_batches)?;

                // Verify the transaction limit
                self.verify_transaction_limit(execution_limits.max_txns_to_execute())?;

                // TODO: verify the block gas limit?
            },
            Payload::OptQuorumStore(OptQuorumStorePayload::V1(p)) => {
                // Verify the batches in the requested block
                self.verify_batches(p.proof_with_data())?;

                // Verify optQS and inline batches
                self.verify_optqs_and_inline_batches(p.opt_batches(), p.inline_batches())?;

                // Verify the transaction limit
                self.verify_transaction_limit(p.max_txns_to_execute())?;
            },
            Payload::OptQuorumStore(OptQuorumStorePayload::V2(_p)) => {
                return Err(Error::InvalidMessageError(
                    "OptQuorumStorePayload V2 is not supproted".into(),
                ));
            },
        }

        Ok(())
    }
```

**File:** consensus/src/consensus_observer/network/observer_message.rs (L987-998)
```rust
fn reconstruct_batch(
    block_info: &BlockInfo,
    transactions_iter: &mut IntoIter<SignedTransaction>,
    expected_batch_info: &BatchInfo,
    skip_expired_batches: bool,
) -> Result<Option<Vec<SignedTransaction>>, Error> {
    // If the batch is expired we should skip reconstruction (as the
    // transactions for the expired batch won't be sent in the payload).
    // Note: this should only be required for QS batches (not inline batches).
    if skip_expired_batches && block_info.timestamp_usecs() > expected_batch_info.expiration() {
        return Ok(None);
    }
```

**File:** consensus/src/consensus_observer/observer/payload_store.rs (L98-109)
```rust
        let epoch_and_round = (block_payload.epoch(), block_payload.round());
        let payload_status = if verified_payload_signatures {
            BlockPayloadStatus::AvailableAndVerified(block_payload)
        } else {
            BlockPayloadStatus::AvailableAndUnverified(block_payload)
        };

        // Insert the new payload status
        self.block_payloads
            .lock()
            .insert(epoch_and_round, payload_status);
    }
```

**File:** consensus/src/consensus_observer/observer/payload_store.rs (L158-213)
```rust
    pub fn verify_payloads_against_ordered_block(
        &mut self,
        ordered_block: &OrderedBlock,
    ) -> Result<(), Error> {
        // Verify each of the blocks in the ordered block
        for ordered_block in ordered_block.blocks() {
            // Get the block epoch and round
            let block_epoch = ordered_block.epoch();
            let block_round = ordered_block.round();

            // Fetch the block payload
            match self.block_payloads.lock().entry((block_epoch, block_round)) {
                Entry::Occupied(entry) => {
                    // Get the block transaction payload
                    let transaction_payload = match entry.get() {
                        BlockPayloadStatus::AvailableAndVerified(block_payload) => {
                            block_payload.transaction_payload()
                        },
                        BlockPayloadStatus::AvailableAndUnverified(_) => {
                            // The payload should have already been verified
                            return Err(Error::InvalidMessageError(format!(
                                "Payload verification failed! Block payload for epoch: {:?} and round: {:?} is unverified.",
                                ordered_block.epoch(),
                                ordered_block.round()
                            )));
                        },
                    };

                    // Get the ordered block payload
                    let ordered_block_payload = match ordered_block.block().payload() {
                        Some(payload) => payload,
                        None => {
                            return Err(Error::InvalidMessageError(format!(
                                "Payload verification failed! Missing block payload for epoch: {:?} and round: {:?}",
                                ordered_block.epoch(),
                                ordered_block.round()
                            )));
                        },
                    };

                    // Verify the transaction payload against the ordered block payload
                    transaction_payload.verify_against_ordered_payload(ordered_block_payload)?;
                },
                Entry::Vacant(_) => {
                    // The payload is missing (this should never happen)
                    return Err(Error::InvalidMessageError(format!(
                        "Payload verification failed! Missing block payload for epoch: {:?} and round: {:?}",
                        ordered_block.epoch(),
                        ordered_block.round()
                    )));
                },
            }
        }

        Ok(())
    }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L385-397)
```rust
        // Verify the block payload digests
        if let Err(error) = block_payload.verify_payload_digests() {
            // Log the error and update the invalid message counter
            error!(
                LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                    "Failed to verify block payload digests! Ignoring block: {:?}, from peer: {:?}. Error: {:?}",
                    block_payload.block(), peer_network_id,
                    error
                ))
            );
            increment_invalid_message_counter(&peer_network_id, metrics::BLOCK_PAYLOAD_LABEL);
            return;
        }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L754-771)
```rust
        // Verify the block payloads against the ordered block
        if let Err(error) = self
            .observer_block_data
            .lock()
            .verify_payloads_against_ordered_block(&ordered_block)
        {
            // Log the error and update the invalid message counter
            error!(
                LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                    "Failed to verify block payloads against ordered block! Ignoring: {:?}, from peer: {:?}. Error: {:?}",
                    ordered_block.proof_block_info(),
                    peer_network_id,
                    error
                ))
            );
            increment_invalid_message_counter(&peer_network_id, metrics::ORDERED_BLOCK_LABEL);
            return;
        }
```
