# Audit Report

## Title
Desynchronization Between LedgerPrunerManager.min_readable_version and Actual Pruning Progress Causes Incorrect API Responses

## Summary
The `LedgerPrunerManager` sets its `min_readable_version` optimistically to the target pruning version before actual pruning completes, while `LedgerMetadataPruner` updates the persisted `DbMetadataSchema::LedgerPrunerProgress` incrementally. This desynchronization causes `error_if_ledger_pruned()` to reject API queries for historical data that still exists in the database, breaking the deterministic execution invariant for read operations across validators.

## Finding Description

The vulnerability exists in the interaction between three progress tracking mechanisms:

1. **LedgerPrunerManager.min_readable_version** (in-memory `AtomicVersion`): Set optimistically when pruning is triggered [1](#0-0) 

2. **DbMetadataSchema::LedgerPrunerProgress** (persisted): Updated incrementally as actual pruning completes [2](#0-1) 

3. **LedgerPruner.progress** (in-memory `AtomicVersion`): Updated after each batch [3](#0-2) 

**Attack Scenario:**

When `set_pruner_target_db_version(latest_version=1000)` is called with `prune_window=100`:
- Line 164 calculates `min_readable_version = 900`
- Lines 165-166 store this value in the `AtomicVersion` **without persisting to disk**
- The pruner then executes in batches (e.g., 500 versions at a time)
- After the first batch, only versions 0-499 are actually pruned
- `DbMetadataSchema::LedgerPrunerProgress = 500`
- But `LedgerPrunerManager.min_readable_version = 900`

During this desynchronization window, `error_if_ledger_pruned()` reads the optimistic value: [4](#0-3) 

This causes queries for versions 500-899 to be rejected with "data is pruned" errors, even though the data exists: [5](#0-4) 

Additionally, `get_first_txn_version()` returns the incorrect min_readable_version: [6](#0-5) 

This breaks **Deterministic Execution**: Different validators with different pruning progress return different results for identical queries, and state sync reports incorrect data availability ranges: [7](#0-6) 

## Impact Explanation

This qualifies as **High Severity** under "Significant protocol violations" because:

1. **API Consistency Violation**: Different validator nodes return different responses to identical historical queries based on pruning timing, violating the deterministic read guarantee
2. **State Sync Failures**: Nodes advertise incorrect data ranges via `fetch_transaction_range()`, causing unnecessary state sync failures when syncing nodes could actually retrieve the data
3. **Non-Deterministic Behavior**: The in-memory `min_readable_version` depends on timing of pruning execution, creating race conditions where the same query succeeds or fails based on when it's executed

While this doesn't affect consensus voting on current blocks, it breaks the deterministic execution invariant for historical data access, which is critical for:
- API reliability and consistency across the network
- State synchronization correctness
- Archive node functionality

## Likelihood Explanation

**Very High** - This occurs automatically during normal operation:
- Triggered every time pruning is initiated after sufficient new blocks
- The desynchronization window lasts for the duration of batch pruning (potentially minutes for large prune operations)
- Affects all validator nodes running with pruning enabled
- No attacker action required - it's a design flaw in the progress tracking mechanism

## Recommendation

Modify `set_pruner_target_db_version()` to NOT update `min_readable_version` optimistically. Instead, let it be updated only when actual pruning completes:

**Option 1**: Remove the optimistic update entirely and rely on the persisted progress:
- Remove lines 165-170 from `set_pruner_target_db_version()`
- Have the pruner manager periodically read actual progress from the pruner

**Option 2**: Add a callback mechanism where the pruner notifies the manager after completing each batch:
- After `record_progress()` in `LedgerPruner::prune()`, call back to the manager
- Manager updates `min_readable_version` only after confirming actual completion

**Option 3**: Use the persisted value for read validation:
- Modify `get_min_readable_version()` to read from `DbMetadataSchema::LedgerPrunerProgress` instead of the `AtomicVersion`
- Keep the `AtomicVersion` only for internal pruner coordination

The safest fix is Option 3, as it ensures `min_readable_version` always reflects actual pruned state on disk.

## Proof of Concept

```rust
#[test]
fn test_pruner_progress_desync() {
    // Setup: Create AptosDB with pruning enabled, prune_window=100, batch_size=50
    let tmpdir = TempPath::new();
    let db = AptosDB::new_for_test_with_pruning(&tmpdir, 100);
    
    // Commit 200 transactions
    for i in 0..200 {
        let txn = create_test_transaction(i);
        db.save_transactions(&[txn], i, &[]).unwrap();
    }
    
    // Trigger pruning - this will set min_readable_version = 100 optimistically
    db.ledger_pruner_manager.maybe_set_pruner_target_db_version(200);
    
    // Query min_readable_version immediately (before pruning completes)
    let min_readable = db.ledger_pruner_manager.get_min_readable_version();
    assert_eq!(min_readable, 100); // Returns 100
    
    // Query actual pruned progress from disk
    let actual_progress = db.ledger_db.metadata_db().get_pruner_progress().unwrap();
    assert_eq!(actual_progress, 0); // Still 0!
    
    // Try to read transaction at version 50 - this should succeed but will fail
    let result = db.get_transaction_by_version(50);
    assert!(result.is_err()); // ERROR: "Transaction at version 50 is pruned"
    
    // But the data actually exists!
    let raw_data = db.ledger_db.transaction_db().get_transaction(50).unwrap();
    assert!(raw_data.is_some()); // Data is there!
    
    // This demonstrates the desynchronization: min_readable_version says data
    // is pruned, but it actually exists in the database
}
```

### Citations

**File:** storage/aptosdb/src/pruner/ledger_pruner/ledger_pruner_manager.rs (L162-176)
```rust
    fn set_pruner_target_db_version(&self, latest_version: Version) {
        assert!(self.pruner_worker.is_some());
        let min_readable_version = latest_version.saturating_sub(self.prune_window);
        self.min_readable_version
            .store(min_readable_version, Ordering::SeqCst);

        PRUNER_VERSIONS
            .with_label_values(&["ledger_pruner", "min_readable"])
            .set(min_readable_version as i64);

        self.pruner_worker
            .as_ref()
            .unwrap()
            .set_target_db_version(min_readable_version);
    }
```

**File:** storage/aptosdb/src/pruner/ledger_pruner/ledger_metadata_pruner.rs (L42-56)
```rust
    pub(in crate::pruner) fn prune(
        &self,
        current_progress: Version,
        target_version: Version,
    ) -> Result<()> {
        let mut batch = SchemaBatch::new();
        for version in current_progress..target_version {
            batch.delete::<VersionDataSchema>(&version)?;
        }
        batch.put::<DbMetadataSchema>(
            &DbMetadataKey::LedgerPrunerProgress,
            &DbMetadataValue::Version(target_version),
        )?;
        self.ledger_metadata_db.write_schemas(batch)
    }
```

**File:** storage/aptosdb/src/pruner/ledger_pruner/mod.rs (L109-114)
```rust
    fn record_progress(&self, progress: Version) {
        self.progress.store(progress, Ordering::SeqCst);
        PRUNER_VERSIONS
            .with_label_values(&["ledger_pruner", "progress"])
            .set(progress as i64);
    }
```

**File:** storage/aptosdb/src/db/aptosdb_internal.rs (L261-271)
```rust
    pub(super) fn error_if_ledger_pruned(&self, data_type: &str, version: Version) -> Result<()> {
        let min_readable_version = self.ledger_pruner.get_min_readable_version();
        ensure!(
            version >= min_readable_version,
            "{} at version {} is pruned, min available version is {}.",
            data_type,
            version,
            min_readable_version
        );
        Ok(())
    }
```

**File:** storage/aptosdb/src/db/aptosdb_reader.rs (L103-108)
```rust
        gauged_api("get_transaction_auxiliary_data_by_version", || {
            self.error_if_ledger_pruned("Transaction", version)?;
            self.ledger_db
                .transaction_auxiliary_data_db()
                .get_transaction_auxiliary_data(version)
        })
```

**File:** storage/aptosdb/src/db/aptosdb_reader.rs (L329-333)
```rust
    fn get_first_txn_version(&self) -> Result<Option<Version>> {
        gauged_api("get_first_txn_version", || {
            Ok(Some(self.ledger_pruner.get_min_readable_version()))
        })
    }
```

**File:** state-sync/storage-service/server/src/storage.rs (L179-192)
```rust
    fn fetch_transaction_range(
        &self,
        latest_version: Version,
    ) -> aptos_storage_service_types::Result<Option<CompleteDataRange<Version>>, Error> {
        let first_transaction_version = self.storage.get_first_txn_version()?;
        if let Some(first_transaction_version) = first_transaction_version {
            let transaction_range =
                CompleteDataRange::new(first_transaction_version, latest_version)
                    .map_err(|error| Error::UnexpectedErrorEncountered(error.to_string()))?;
            Ok(Some(transaction_range))
        } else {
            Ok(None)
        }
    }
```
