# Audit Report

## Title
Baseline Node Information Disclosure Through Error Message Correlation in Node-Checker

## Summary
The node-checker service exposes baseline node configuration and state information through error messages in multiple checker implementations, allowing attackers to fingerprint and potentially identify the baseline node by correlating data across multiple `/check` API invocations.

## Finding Description
The node-checker ecosystem component provides a `/check` endpoint that evaluates target nodes against configured baseline nodes. When mismatches occur during health checks, several checker implementations include baseline node information in their error messages.

**Affected Checkers:**

1. **NodeIdentityChecker** - Exposes baseline's `chain_id` and `role_type`: [1](#0-0) 

2. **StateSyncVersionChecker** - Exposes baseline's `ledger_version`: [2](#0-1) [3](#0-2) 

3. **BuildVersionChecker** - Exposes baseline's `build_commit_hash`: [4](#0-3) 

**Attack Scenario:**

An attacker can repeatedly call the `/check` endpoint with intentionally misconfigured target nodes (wrong chain_id, outdated version, etc.) to extract baseline information through error messages: [5](#0-4) 

By correlating the time-varying `ledger_version` values across multiple invocations, an attacker can fingerprint the baseline node's synchronization pattern and potentially identify which specific node in the network is being used as the baseline reference.

## Impact Explanation
This qualifies as **Low Severity** per the Aptos bug bounty program criteria - specifically "Minor information leaks" (up to $1,000).

The disclosed information enables:
- **Baseline node fingerprinting**: The `ledger_version` changes every few seconds with a node-specific synchronization pattern that can be correlated with publicly observable nodes
- **Configuration mapping**: Reveals baseline's `chain_id`, `role_type` (Validator vs FullNode), and exact software version (`build_commit_hash`)
- **Potential targeting**: If the baseline is a private/internal node, this leaks its existence and configuration; if correlated to a known node, enables targeted attacks

However, the impact is limited because:
- This is information disclosure only, not affecting consensus, funds, or availability
- If the baseline is already a public node, much of this information may be accessible via its API
- No direct exploit path to consensus violations or monetary loss

## Likelihood Explanation
**Likelihood: HIGH**

The vulnerability triggers automatically whenever there's a mismatch between target and baseline configurations, which is normal during node health checks. An attacker needs no special privileges - only the ability to call the public `/check` endpoint with arbitrary parameters.

The `/check` endpoint is designed to be publicly accessible for node operators to validate their configurations: [6](#0-5) 

## Recommendation
Implement one or more of the following mitigations:

1. **Redact baseline-specific values from error messages**: Only show that a mismatch occurred without revealing the baseline's actual value:
```rust
// Instead of:
format!("... while the baseline reported {}.", baseline_value)

// Use:
format!("... which does not match the expected baseline value for this network.")
```

2. **Rate limiting**: Implement rate limiting on the `/check` endpoint per IP/client to prevent rapid correlation attempts

3. **Abstract baseline information**: Replace specific values with categorical descriptions (e.g., "baseline is ahead" instead of showing exact version numbers)

4. **Configuration option**: Add a configuration flag to control whether baseline values are exposed in error messages, allowing operators to choose based on their deployment model (public vs private baseline)

## Proof of Concept
```bash
#!/bin/bash
# PoC: Fingerprint baseline node by correlating ledger versions

BASELINE_CONFIG="devnet_fullnode"
NODE_CHECKER_URL="http://node-checker.example.com"

# Call /check multiple times with an intentionally old target
for i in {1..10}; do
  echo "=== Invocation $i at $(date +%s) ==="
  
  # Use a target node that will definitely be behind
  curl -s "${NODE_CHECKER_URL}/check?baseline_configuration_id=${BASELINE_CONFIG}&node_url=http://old-node.example.com&api_port=8080" \
    | jq '.check_results[] | select(.checker_name == "StateSyncVersionChecker") | .explanation' \
    | grep -oP 'Baseline version: \K\d+'
  
  sleep 2
done

# Output will show baseline's ledger_version incrementing over time
# Example output:
# === Invocation 1 at 1234567890 ===
# 123456789
# === Invocation 2 at 1234567892 ===
# 123456802
# === Invocation 3 at 1234567894 ===
# 123456815
# ...
# This progression pattern can fingerprint the specific baseline node
```

## Notes
While this is a valid information disclosure vulnerability, it does **not** meet the Critical, High, or Medium severity thresholds. The node-checker is an ecosystem tool for node operators, not a core consensus or execution component. The leaked information could aid in reconnaissance but does not directly enable attacks on blockchain security invariants such as consensus safety, state consistency, or access control.

The baseline configuration ID (e.g., "devnet_fullnode") is already exposed via the `/configurations` endpoint, suggesting the baseline's general identity may be semi-public by design: [7](#0-6)

### Citations

**File:** ecosystem/node-checker/src/checker/node_identity.rs (L46-60)
```rust
        } else {
            (
                format!(
                    "{} reported by the target does not match the baseline",
                    attribute_str
                ),
                0,
                format!(
                    "The node under investigation reported the {} {} while the \
                baseline reported {}. These values should match. Confirm that \
                the baseline you're using is appropriate for the node you're testing.",
                    attribute_str, target_value, baseline_value
                ),
            )
        };
```

**File:** ecosystem/node-checker/src/checker/state_sync_version.rs (L72-85)
```rust
                    Self::build_result(
                        "Ledger version is lagging".to_string(),
                        50,
                        format!(
                            "Successfully pulled ledger version from your node twice \
                            and saw the version was increasing, but it is lagging {} versions \
                            behind the baseline node, more than the allowed lag of {}. \
                            Target version: {}. Baseline version: {}.",
                            delta_from_baseline,
                            self.config.version_delta_tolerance,
                            latest_target_version,
                            latest_baseline_version,
                        ),
                    )
```

**File:** ecosystem/node-checker/src/checker/state_sync_version.rs (L87-103)
```rust
                    Self::build_result(
                        "Ledger version is increasing".to_string(),
                        100,
                        format!(
                            "NHC pulled ledger version from your node twice, \
                            saw that the version is increasing (it increased by {} over \
                            {} seconds), and saw that it is within tolerance of the \
                            baseline node. The baseline ledger version is {} and your node's \
                            ledger version is {}, which is within the allowed lag of {} versions.",
                            target_progress,
                            delay_secs,
                            latest_baseline_version,
                            latest_target_version,
                            self.config.version_delta_tolerance
                        ),
                    )
                }
```

**File:** ecosystem/node-checker/src/checker/build_version.rs (L115-135)
```rust
                check_results.push({
                    if baseline_build_commit_hash == target_build_commit_hash {
                        Self::build_result(
                            "Build commit hashes match".to_string(),
                            100,
                            format!(
                                "The build commit hash from the target node ({}) matches the build commit hash from the baseline node ({}).",
                                target_build_commit_hash, baseline_build_commit_hash
                            ),
                        )
                    } else {
                        Self::build_result(
                            "Build commit hash mismatch".to_string(),
                            50,
                            format!(
                                "The build commit hash from the target node ({}) does not match the build commit hash from the baseline node ({}).",
                                target_build_commit_hash, baseline_build_commit_hash
                            ),
                        )
                    }
                });
```

**File:** ecosystem/node-checker/src/server/api.rs (L24-28)
```rust
    /// Check the health of a given target node. You must specify a baseline
    /// node configuration to use for the evaluation and the URL of your node,
    /// without including any port or endpoints. All other parameters are optional.
    /// For example, if your node's API port is open but the rest are closed, only
    /// set the `api_port`.
```

**File:** ecosystem/node-checker/src/server/api.rs (L29-45)
```rust
    #[oai(path = "/check", method = "get")]
    async fn check(
        &self,
        /// The ID of the baseline node configuration to use for the evaluation, e.g. devnet_fullnode
        baseline_configuration_id: Query<String>,
        /// The URL of the node to check, e.g. http://44.238.19.217 or http://fullnode.mysite.com
        node_url: Query<Url>,
        /// If given, we will assume the metrics service is available at the given port.
        metrics_port: Query<Option<u16>>,
        /// If given, we will assume the API is available at the given port.
        api_port: Query<Option<u16>>,
        /// If given, we will assume that clients can communicate with your node via noise at the given port.
        noise_port: Query<Option<u16>>,
        /// A public key for the node, e.g. 0x44fd1324c66371b4788af0b901c9eb8088781acb29e6b8b9c791d5d9838fbe1f.
        /// This is only necessary for certain checkers, e.g. HandshakeChecker.
        public_key: Query<Option<String>>,
    ) -> poem::Result<Json<CheckSummary>> {
```

**File:** ecosystem/node-checker/src/server/api.rs (L114-126)
```rust
    #[oai(path = "/configurations", method = "get")]
    async fn configurations(&self) -> Json<Vec<ConfigurationDescriptor>> {
        Json(
            self.baseline_configurations
                .0
                .iter()
                .map(|(k, v)| ConfigurationDescriptor {
                    id: k.clone(),
                    pretty_name: v.configuration.configuration_name.clone(),
                })
                .collect(),
        )
    }
```
