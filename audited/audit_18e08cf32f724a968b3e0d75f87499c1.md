# Audit Report

## Title
Race Condition in Reconfiguration Notification Processing Causes Validators to Use Wrong On-Chain Configs for Epochs

## Summary
A race condition in `EventSubscriptionService::read_on_chain_configs()` allows validators to receive on-chain configuration data from an incorrect blockchain version when processing reconfiguration events. When multiple reconfigurations occur in rapid succession, state sync may fetch the latest storage version (which has advanced beyond the event's version) instead of the version where the reconfiguration event was actually emitted, causing validators to operate with mismatched epoch configurations.

## Finding Description

The vulnerability exists in the event notification flow between consensus and state sync components: [1](#0-0) 

The `ConsensusCommitNotification` struct **does not include version information** - only transactions and subscribable events. [2](#0-1) 

When consensus notifies state sync of committed transactions, it sends events without specifying their version. [3](#0-2) 

State sync independently queries storage to determine the "latest synced version" when processing notifications. [4](#0-3) 

This latest version is then used to read on-chain configs: [5](#0-4) [6](#0-5) 

The function reads the `ConfigurationResource` and creates a `DbBackedOnChainConfig` at the version passed in. However, if multiple blocks are committed before a notification is processed, this version will be **newer** than the version where the events actually occurred.

**Attack Scenario:**

1. **T0**: Consensus commits Block B1 (version 100) containing reconfiguration event R1 that sets `ValidatorSet = {V1, V2, V3}` for epoch 2
2. **T1**: Consensus sends notification N1 with events=[R1] via async channel
3. **T2**: Consensus commits Block B2 (version 105) containing reconfiguration event R2 that sets `ValidatorSet = {V1, V2, V3, V4}` for epoch 3  
4. **T3**: Consensus sends notification N2 with events=[R2]
5. **T4**: State sync driver processes N1:
   - Calls `fetch_pre_committed_version(storage)` → returns **105** (not 100!)
   - Calls `notify_events(version=105, events=[R1])`
   - Detects R1 is a reconfiguration event
   - Calls `read_on_chain_configs(version=105)`
   - Reads `ConfigurationResource` at version 105 → gets **epoch 3**
   - Reads `ValidatorSet` at version 105 → gets **{V1, V2, V3, V4}** (for epoch 3!)
   - Creates `OnChainConfigPayload(epoch=3, configs_from_v105)`
   - Sends notification to consensus/validators [7](#0-6) 

6. **T5**: Validators receive the notification and extract epoch 3 configs when they should be processing epoch 2 configs. They use the wrong `ValidatorSet` for consensus operations.

This breaks the **Deterministic Execution** invariant because validators would operate with different epoch configurations than intended, and violates **Consensus Safety** by potentially causing incorrect quorum formation with the wrong validator set.

## Impact Explanation

**Critical Severity** - This is a consensus safety violation that can cause:

1. **Validator Set Mismatch**: Validators use the wrong validator set for an epoch, breaking quorum formation
2. **Epoch Confusion**: Validators may skip epochs entirely (jumping from epoch 2 to epoch 3 in the example)
3. **Block Signature Verification Failures**: Blocks signed by the correct validator set for epoch 2 would fail verification by validators using epoch 3's validator set
4. **Consensus Liveness Loss**: Validators operating with mismatched configurations cannot reach consensus
5. **Potential Chain Split**: Different validators processing notifications at different times could end up on different epochs

While the attack window is narrow, **no attacker action is required** - this can occur naturally during back-to-back governance proposals or rapid epoch transitions. The impact affects all validators network-wide.

## Likelihood Explanation

**Medium to High Likelihood**:

1. **No Synchronization**: There is no synchronization between notification creation and processing. Notifications are sent via async channels and processed independently. [8](#0-7) 

2. **Sequential Processing**: While state sync processes notifications sequentially, commits can continue happening in consensus, advancing storage state. [9](#0-8) 

3. **Natural Occurrence**: This doesn't require malicious activity - rapid governance proposals or back-to-back epoch changes trigger this naturally.

4. **Small But Real Window**: The timing window is small but non-zero, especially under high load or if state sync processing is delayed.

## Recommendation

**Include version information in consensus commit notifications:**

Modify `ConsensusCommitNotification` to include the committed version:

```rust
pub struct ConsensusCommitNotification {
    version: Version,  // ADD THIS FIELD
    transactions: Vec<Transaction>,
    subscribable_events: Vec<ContractEvent>,
    callback: oneshot::Sender<ConsensusNotificationResponse>,
}
```

Update state sync to use the version from the notification instead of querying storage:

```rust
pub async fn handle_committed_transactions<M: MempoolNotificationSender, S: StorageServiceNotificationSender>(
    committed_transactions: CommittedTransactions,
    committed_version: Version,  // Pass version from notification
    storage: Arc<dyn DbReader>,
    // ... other parameters
) {
    // Use committed_version instead of fetch_pre_committed_version()
    CommitNotification::handle_transaction_notification(
        committed_transactions.events,
        committed_transactions.transactions,
        committed_version,  // Use the version from notification
        // ...
    )
}
```

This ensures configs are always read from the correct version where events actually occurred.

## Proof of Concept

```rust
// Pseudo-code demonstrating the race condition
// This would be implemented as a Rust integration test in state-sync/state-sync-driver/src/tests/

#[tokio::test]
async fn test_reconfig_version_race_condition() {
    // Setup: Initialize storage, executor, and state sync components
    let (storage, executor, event_service) = setup_test_environment();
    
    // Step 1: Commit Block B1 at version 100 with reconfig event R1 for epoch 2
    let block_b1 = create_block_with_reconfig(100, epoch: 2, validator_set: vec![V1, V2, V3]);
    executor.execute_and_commit(block_b1).await;
    
    // Step 2: Send notification N1 (goes into async queue)
    let notification_n1 = create_notification(transactions: block_b1.txns, events: [R1]);
    consensus_notifier.notify_new_commit(notification_n1).await;
    
    // Step 3: BEFORE N1 is processed, commit Block B2 at version 105 with R2 for epoch 3
    let block_b2 = create_block_with_reconfig(105, epoch: 3, validator_set: vec![V1, V2, V3, V4]);
    executor.execute_and_commit(block_b2).await;
    
    // Step 4: Now process N1 - it will read configs from version 105 (B2) instead of 100 (B1)
    let reconfig_notification = await_reconfig_notification(&event_service).await;
    
    // Assertion: The notification should have epoch 2 configs but actually has epoch 3 configs
    assert_eq!(reconfig_notification.on_chain_configs.epoch(), 3);  // WRONG! Should be 2
    let validator_set: ValidatorSet = reconfig_notification.on_chain_configs.get().unwrap();
    assert_eq!(validator_set.validators.len(), 4);  // WRONG! Should be 3 for epoch 2
    
    // This proves validators receive wrong configs for the epoch
}
```

## Notes

The vulnerability is particularly severe because:
1. It affects **all validators** network-wide when it occurs
2. It requires **no malicious activity** - normal operations can trigger it
3. The configs include critical consensus parameters (`ValidatorSet`, `OnChainConsensusConfig`, `OnChainRandomnessConfig`)
4. Validators have no way to detect the mismatch since events don't carry version information

The root cause is the architectural decision to send notifications without version context, forcing state sync to query storage state that may have advanced beyond the events' origin version.

### Citations

**File:** state-sync/inter-component/consensus-notifications/src/lib.rs (L294-298)
```rust
pub struct ConsensusCommitNotification {
    transactions: Vec<Transaction>,
    subscribable_events: Vec<ContractEvent>,
    callback: oneshot::Sender<ConsensusNotificationResponse>,
}
```

**File:** consensus/src/pipeline/pipeline_builder.rs (L1165-1171)
```rust
        let txns = compute_result.transactions_to_commit().to_vec();
        let subscribable_events = compute_result.subscribable_events().to_vec();
        if let Err(e) = monitor!(
            "notify_state_sync",
            state_sync_notifier
                .notify_new_commit(txns, subscribable_events)
                .await
```

**File:** state-sync/state-sync-driver/src/utils.rs (L336-353)
```rust
    let (latest_synced_version, latest_synced_ledger_info) =
        match fetch_pre_committed_version(storage.clone()) {
            Ok(latest_synced_version) => match fetch_latest_synced_ledger_info(storage.clone()) {
                Ok(latest_synced_ledger_info) => (latest_synced_version, latest_synced_ledger_info),
                Err(error) => {
                    error!(LogSchema::new(LogEntry::SynchronizerNotification)
                        .error(&error)
                        .message("Failed to fetch latest synced ledger info!"));
                    return;
                },
            },
            Err(error) => {
                error!(LogSchema::new(LogEntry::SynchronizerNotification)
                    .error(&error)
                    .message("Failed to fetch latest synced version!"));
                return;
            },
        };
```

**File:** state-sync/state-sync-driver/src/notification_handlers.rs (L107-109)
```rust
        event_subscription_service
            .lock()
            .notify_events(latest_synced_version, events)?;
```

**File:** state-sync/inter-component/event-notifications/src/lib.rs (L269-272)
```rust
        let new_configs = self.read_on_chain_configs(version)?;
        for (_, reconfig_subscription) in self.reconfig_subscriptions.iter_mut() {
            reconfig_subscription.notify_subscriber_of_configs(version, new_configs.clone())?;
        }
```

**File:** state-sync/inter-component/event-notifications/src/lib.rs (L285-306)
```rust
        let db_state_view = &self
            .storage
            .read()
            .reader
            .state_view_at_version(Some(version))
            .map_err(|error| {
                Error::UnexpectedErrorEncountered(format!(
                    "Failed to create account state view {:?}",
                    error
                ))
            })?;
        let epoch = ConfigurationResource::fetch_config(&db_state_view)
            .ok_or_else(|| {
                Error::UnexpectedErrorEncountered("Configuration resource does not exist!".into())
            })?
            .epoch();

        // Return the new on-chain config payload (containing all found configs at this version).
        Ok(OnChainConfigPayload::new(
            epoch,
            DbBackedOnChainConfig::new(self.storage.read().reader.clone(), version),
        ))
```

**File:** consensus/src/consensus_observer/observer/epoch_state.rs (L146-154)
```rust
    // Extract the epoch state from the reconfiguration notification
    let on_chain_configs = reconfig_notification.on_chain_configs;
    let validator_set: ValidatorSet = on_chain_configs
        .get()
        .expect("Failed to get the validator set from the on-chain configs!");
    let epoch_state = Arc::new(EpochState::new(
        on_chain_configs.epoch(),
        (&validator_set).into(),
    ));
```

**File:** state-sync/state-sync-driver/src/driver.rs (L221-239)
```rust
        loop {
            ::futures::select! {
                notification = self.client_notification_listener.select_next_some() => {
                    self.handle_client_notification(notification).await;
                },
                notification = self.commit_notification_listener.select_next_some() => {
                    self.handle_snapshot_commit_notification(notification).await;
                }
                notification = self.consensus_notification_handler.select_next_some() => {
                    self.handle_consensus_or_observer_notification(notification).await;
                }
                notification = self.error_notification_listener.select_next_some() => {
                    self.handle_error_notification(notification).await;
                }
                _ = progress_check_interval.select_next_some() => {
                    self.drive_progress().await;
                }
            }
        }
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L46-53)
```rust
            // Pre-committing and committing in concurrency is allowed but not pre-committing at the
            // same time from multiple threads, the same for committing.
            // Consensus and state sync must hand over to each other after all pending execution and
            // committing complete.
            let _lock = self
                .pre_commit_lock
                .try_lock()
                .expect("Concurrent committing detected.");
```
