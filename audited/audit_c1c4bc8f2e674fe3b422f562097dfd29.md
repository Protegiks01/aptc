# Audit Report

## Title
Encrypted Transactions Bypass Block Transaction Filter Validation Leading to Potential Consensus Splits

## Summary
The `check_denied_inline_transactions()` function in the consensus layer cannot validate encrypted transactions because their payloads are not yet decrypted at proposal-time. This allows encrypted transactions to bypass validator deny rules configured via `BlockTransactionFilterConfig`, potentially causing consensus safety violations when validators have different execution-time filter configurations.

## Finding Description

The vulnerability exists in the transaction filtering mechanism used during block proposal validation. The flow is:

1. **Proposal-time validation** (`check_denied_inline_transactions()` at consensus layer):
   - Called in `RoundManager::process_proposal()` BEFORE transaction decryption
   - Uses `consensus_filter` from `BlockTransactionFilterConfig`
   - Transactions are inspected to determine if they match deny rules [1](#0-0) 

2. **Transaction matcher inspection** attempts to extract payload details:
   - For `EncryptedPayload` transactions, calls `executable_ref()` to inspect contents
   - This method only succeeds if payload is in `Decrypted` state [2](#0-1) 

3. **Critical failure point** - encrypted payloads return error:
   - `executable_ref()` returns `Err` for `Encrypted` and `FailedDecryption` states
   - When error occurs, matchers return `false` (doesn't match deny rule)
   - Transaction bypasses the filter check [3](#0-2) 

4. **Separate execution-time filtering**:
   - Decryption occurs in pipeline AFTER proposal validation
   - Different config (`execution_filter`) used during `prepare_block()`
   - These are SEPARATE configs from different sources [4](#0-3) [5](#0-4) 

**Attack Scenario:**

1. Validator A configures `consensus_filter` to deny transactions calling module `0x1::attack::exploit`
2. Attacker submits an encrypted transaction that, when decrypted, calls `0x1::attack::exploit`
3. During `process_proposal()`, the transaction is still encrypted
4. `check_denied_inline_transactions()` cannot inspect it → filter check passes
5. Validator A votes on the block (would have rejected if transaction was unencrypted)
6. Block gets committed to chain with 2f+1 votes
7. During execution:
   - If Validator A has same deny rule in `execution_filter`: transaction gets filtered out
   - If Validator B doesn't have the rule in `execution_filter`: transaction executes
8. Validators produce different state roots → **consensus break**

## Impact Explanation

This is a **Critical severity** vulnerability that violates the core consensus safety invariant:

**Broken Invariant:** "Deterministic Execution: All validators must produce identical state roots for identical blocks"

**Impact:**
- **Consensus Safety Violation**: Different validators can execute different transaction sets from the same committed block, producing different state roots
- **Chain Split Potential**: Validators will disagree on state and cannot reach consensus on subsequent blocks, requiring a hard fork to recover
- **Validator Deception**: Validators can be tricked into voting on blocks containing transactions they explicitly configured to deny
- **Non-recoverable Network Partition**: If validators split on state, the network cannot recover without manual intervention

This meets the Aptos Bug Bounty **Critical Severity** criteria:
- "Consensus/Safety violations"
- "Non-recoverable network partition (requires hardfork)"

The severity is amplified by the fact that:
1. Validators use local, non-coordinated filter configurations
2. No mechanism ensures `consensus_filter` and `execution_filter` are identical
3. Encrypted transactions are a legitimate feature, making this exploitable in production

## Likelihood Explanation

**Likelihood: HIGH**

**Exploitability Requirements:**
- Attacker must be able to submit encrypted transactions (standard feature, no special privileges needed)
- Network must have validators using `BlockTransactionFilterConfig` with deny rules (legitimate use case for validator operators)
- No requirement for validator collusion or insider access

**Feasibility:**
- Encrypted transaction submission is a supported feature in Aptos
- Validators commonly configure filters to deny spam or malicious transactions
- The vulnerability is in the core consensus path, executed for every block proposal
- Attack requires no special timing or race conditions

**Real-world scenarios where this could occur:**
1. Validators configure filters to block specific smart contract exploits
2. Governance actions to emergency-block certain transaction types
3. Validators attempting to enforce local compliance rules

The two-config system (`consensus_filter` vs `execution_filter`) significantly increases likelihood, as validators may:
- Configure only one filter but not the other
- Use different rules in each filter
- Disable one filter while keeping the other enabled

## Recommendation

**Immediate Fix:** Reject blocks containing encrypted transactions when `BlockTransactionFilterConfig` is enabled and non-empty.

**Implementation:**

In `direct_mempool_payload_manager.rs`, modify `check_denied_inline_transactions()`:

```rust
pub fn check_denied_inline_transactions(
    &self,
    block: &Block,
    block_txn_filter_config: &BlockTransactionFilterConfig,
) -> anyhow::Result<()> {
    // If the filter is disabled, return early
    if !block_txn_filter_config.is_enabled() {
        return Ok(());
    }

    // Get the inline transactions for the block proposal
    let (inline_transactions, _, _) = get_transactions_from_block(block)?;
    if inline_transactions.is_empty() {
        return Ok(());
    }

    // NEW: Check if any transactions are encrypted
    let has_encrypted_txns = inline_transactions.iter().any(|txn| {
        matches!(txn.payload(), TransactionPayload::EncryptedPayload(_))
    });
    
    if has_encrypted_txns {
        return Err(anyhow::anyhow!(
            "Block contains encrypted transactions which cannot be validated against filter rules. \
             Encrypted transactions are not supported when BlockTransactionFilterConfig is enabled."
        ));
    }

    // Continue with existing validation...
    let block_id = block.id();
    let block_author = block.author();
    let block_epoch = block.epoch();
    let block_timestamp = block.timestamp_usecs();

    let block_transaction_filter = block_txn_filter_config.block_transaction_filter();
    let denied_inline_transactions = block_transaction_filter.get_denied_block_transactions(
        block_id,
        block_author,
        block_epoch,
        block_timestamp,
        inline_transactions,
    );
    
    if !denied_inline_transactions.is_empty() {
        return Err(anyhow::anyhow!(
            "Inline transactions for DirectMempoolPayload denied by block transaction filter: {:?}",
            denied_inline_transactions
        ));
    }

    Ok(())
}
```

**Alternative Long-term Fix:** 
1. Enforce that `consensus_filter` and `execution_filter` must be identical at the configuration level
2. Implement post-decryption re-validation before execution
3. Add on-chain coordination mechanism for filter rules to ensure all validators use same configuration

## Proof of Concept

```rust
// Integration test demonstrating the bypass
#[test]
fn test_encrypted_transaction_bypasses_proposal_filter() {
    // Setup: Create validator with consensus_filter that denies specific entry function
    let denied_module = AccountAddress::from_hex_literal("0x1").unwrap();
    let denied_function = "exploit".to_string();
    
    let consensus_filter = BlockTransactionFilter::empty()
        .add_multiple_matchers_filter(
            false, // deny
            vec![BlockTransactionMatcher::Transaction(
                TransactionMatcher::EntryFunction(
                    denied_module,
                    "attack".to_string(),
                    denied_function.clone(),
                )
            )]
        );
    
    let filter_config = BlockTransactionFilterConfig::new(true, consensus_filter);
    
    // Create encrypted transaction that, when decrypted, calls the denied function
    let encrypted_payload = EncryptedPayload::Encrypted {
        ciphertext: /* encrypted call to 0x1::attack::exploit */,
        extra_config: TransactionExtraConfig::V1 {
            multisig_address: None,
            replay_protection_nonce: None,
        },
        payload_hash: HashValue::random(),
    };
    
    let encrypted_txn = create_signed_transaction_with_payload(
        TransactionPayload::EncryptedPayload(encrypted_payload)
    );
    
    // Create block with encrypted transaction
    let block = create_block_with_transactions(vec![encrypted_txn]);
    
    // VULNERABILITY: check_denied_inline_transactions passes even though
    // the transaction will call denied function after decryption
    let result = payload_manager.check_denied_inline_transactions(
        &block,
        &filter_config
    );
    
    assert!(result.is_ok()); // Filter check passes (WRONG!)
    
    // After decryption, the transaction would execute the denied function
    // Different validators with different execution_filter configs would
    // produce different state roots, breaking consensus
}
```

**Notes:**

The vulnerability demonstrates a fundamental incompleteness in the transaction validation logic: the system assumes all transaction types can be inspected at proposal time, but encrypted transactions violate this assumption. The pattern matching is technically complete (all enum variants are covered), but the semantic validation is incomplete because encrypted payloads cannot be inspected before decryption. This creates a timing-based bypass where the contents are validated at the wrong stage of the consensus pipeline, after validators have already committed to voting on the block.

### Citations

**File:** consensus/src/round_manager.rs (L1204-1214)
```rust
        if let Err(error) = self
            .block_store
            .check_denied_inline_transactions(&proposal, &self.block_txn_filter_config)
        {
            counters::REJECTED_PROPOSAL_DENY_TXN_COUNT.inc();
            bail!(
                "[RoundManager] Proposal for block {} contains denied inline transactions: {}. Dropping proposal!",
                proposal.id(),
                error
            );
        }
```

**File:** crates/aptos-transaction-filters/src/transaction_filter.rs (L362-374)
```rust
        TransactionPayload::EncryptedPayload(payload) => {
            if let Ok(executable) = payload.executable_ref() {
                match executable {
                    TransactionExecutableRef::Script(_) | TransactionExecutableRef::Empty => false,
                    TransactionExecutableRef::EntryFunction(entry_function) => {
                        compare_entry_function(entry_function, address, module_name, function)
                    },
                }
            } else {
                false
            }
        },
    }
```

**File:** types/src/transaction/encrypted_payload.rs (L82-87)
```rust
    pub fn executable_ref(&self) -> Result<TransactionExecutableRef<'_>> {
        let Self::Decrypted { executable, .. } = self else {
            bail!("Transaction is encrypted");
        };
        Ok(executable.as_ref())
    }
```

**File:** consensus/src/consensus_provider.rs (L65-72)
```rust
    let execution_proxy = ExecutionProxy::new(
        Arc::new(BlockExecutor::<AptosVMBlockExecutor>::new(aptos_db)),
        txn_notifier,
        state_sync_notifier,
        node_config.transaction_filters.execution_filter.clone(),
        node_config.consensus.enable_pre_commit,
        None,
    );
```

**File:** config/src/config/transaction_filters_config.rs (L12-18)
```rust
pub struct TransactionFiltersConfig {
    pub api_filter: TransactionFilterConfig, // Filter for the API (e.g., txn simulation)
    pub consensus_filter: BlockTransactionFilterConfig, // Filter for consensus (e.g., proposal voting)
    pub execution_filter: BlockTransactionFilterConfig, // Filter for execution (e.g., block execution)
    pub mempool_filter: TransactionFilterConfig,        // Filter for mempool (e.g., txn submission)
    pub quorum_store_filter: BatchTransactionFilterConfig, // Filter for quorum store (e.g., batch voting)
}
```
