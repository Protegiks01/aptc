# Audit Report

## Title
Missing Description Length Validation in Token Collection Creation Enables Intentional State Bloat

## Summary
The `create_collection` and `mutate_collection_description` functions in the Token V1 framework lack length validation for the `description` field, unlike the validated `name` (128 bytes) and `uri` (512 bytes) fields. This inconsistency allows attackers to store large descriptions (up to ~60 KB per transaction) in collection metadata, potentially enabling intentional state bloat attacks.

## Finding Description

The Token V1 module defines explicit length constraints for collection metadata fields but fails to enforce them consistently: [1](#0-0) 

In the `create_collection` function, only `name` and `uri` lengths are validated: [2](#0-1) 

The `description` parameter is used without any length check and stored directly in the `CollectionData` struct: [3](#0-2) 

Similarly, `mutate_collection_description` lacks validation while `mutate_collection_uri` enforces the 512-byte limit: [4](#0-3) 

An attacker can exploit this by:
1. Creating collections with maximum transaction payload size (~64 KB) dedicated to the description field
2. Setting `maximum = 0` to create untracked collections that are never automatically deleted
3. Repeating across multiple transactions to accumulate large amounts of on-chain data

The storage fees ARE properly charged at 40 octas/byte + 40,000 octas/slot: [5](#0-4) 

However, the economic analysis reveals a critical limitation:

**For a 60 KB description:**
- Storage fee: ~2,470,000 octas (0.0247 APT)
- IO gas: ~1,075 octas
- **Total cost: ~0.0247 APT per 60 KB**

This equals approximately **412 octas per KB** or **0.000412 APT/KB**. At scale (1 GB of bloat), an attacker pays only ~412 APT, which may be economically viable for well-resourced attackers seeking to increase validator storage burden.

## Impact Explanation

While storage fees are charged correctly, this issue qualifies as **Medium severity** under "State inconsistencies requiring intervention" because:

1. **Validation Inconsistency:** Creates an exploitable gap in input validation that contradicts the design pattern established for `name` and `uri`
2. **Intent Violation:** The description field is designed for human-readable metadata, not arbitrary data storage
3. **Permanent State Bloat:** Collections with `maximum = 0` can never be automatically deleted, making the storage burden permanent
4. **Economic Viability:** The one-time storage fee may not adequately compensate for perpetual storage across all validators, especially as the network scales

The event data is also affected but gets pruned according to retention policies: [6](#0-5) 

## Likelihood Explanation

**Likelihood: Medium**

The attack is easily executable by any user without special permissions. The transaction size limit (64 KB) provides a natural cap per transaction, but there's no limit on the number of collections a user can create. While the storage fees provide economic deterrence, they may not be sufficient for determined attackers, especially those seeking to disrupt the network rather than profit.

## Recommendation

Add consistent length validation for the `description` field. Define a reasonable maximum description length constant and enforce it in all relevant functions:

```move
// Add to constants section
const MAX_DESCRIPTION_LENGTH: u64 = 2048; // 2 KB, reasonable for descriptions

// Update create_collection function
public fun create_collection(
    creator: &signer,
    name: String,
    description: String,
    uri: String,
    maximum: u64,
    mutate_setting: vector<bool>
) acquires Collections {
    assert!(name.length() <= MAX_COLLECTION_NAME_LENGTH, error::invalid_argument(ECOLLECTION_NAME_TOO_LONG));
    assert!(description.length() <= MAX_DESCRIPTION_LENGTH, error::invalid_argument(EDESCRIPTION_TOO_LONG)); // ADD THIS
    assert!(uri.length() <= MAX_URI_LENGTH, error::invalid_argument(EURI_TOO_LONG));
    // ... rest of function
}

// Update mutate_collection_description function
public fun mutate_collection_description(
    creator: &signer, 
    collection_name: String, 
    description: String
) acquires Collections {
    assert!(description.length() <= MAX_DESCRIPTION_LENGTH, error::invalid_argument(EDESCRIPTION_TOO_LONG)); // ADD THIS
    // ... rest of function
}
```

Also add the corresponding error constant:
```move
const EDESCRIPTION_TOO_LONG: u64 = 41; // New error code
```

## Proof of Concept

```move
#[test_only]
module test_addr::description_bloat_test {
    use std::string;
    use std::vector;
    use aptos_token::token;
    
    #[test(creator = @0xCAFE)]
    public fun test_large_description_attack(creator: &signer) {
        // Create a description near the maximum transaction size
        let large_description_bytes = vector::empty<u8>();
        let i = 0;
        while (i < 60000) { // 60 KB description
            vector::push_back(&mut large_description_bytes, 0x41); // 'A'
            i = i + 1;
        };
        let large_description = string::utf8(large_description_bytes);
        
        // This call succeeds despite the massive description
        token::create_collection(
            creator,
            string::utf8(b"Attack Collection"),
            large_description,
            string::utf8(b"https://example.com"),
            0, // maximum = 0, untracked collection (never auto-deleted)
            vector[false, false, false]
        );
        
        // The collection now contains 60 KB of arbitrary data
        // Storage fees are charged, but the data remains permanently on-chain
        // Attacker can create multiple such collections to bloat state
    }
}
```

## Notes

The vulnerability stems from an inconsistency in the validation logic rather than a complete absence of economic protections. The storage fee mechanism (DiskSpacePricing V2) does charge appropriately per byte, but the missing validation contradicts the design principles evident in the name and URI length checks. This allows the description field to be repurposed beyond its intended use case, enabling state bloat attacks that, while economically constrained, may still be viable for sufficiently motivated attackers.

### Citations

**File:** aptos-move/framework/aptos-token/sources/token.move (L32-34)
```text
    const MAX_COLLECTION_NAME_LENGTH: u64 = 128;
    const MAX_NFT_NAME_LENGTH: u64 = 128;
    const MAX_URI_LENGTH: u64 = 512;
```

**File:** aptos-move/framework/aptos-token/sources/token.move (L766-787)
```text
    public fun mutate_collection_description(creator: &signer, collection_name: String, description: String) acquires Collections {
        let creator_address = signer::address_of(creator);
        assert_collection_exists(creator_address, collection_name);
        let collection_data = Collections[creator_address].collection_data.borrow_mut(
            collection_name
        );
        assert!(collection_data.mutability_config.description, error::permission_denied(EFIELD_NOT_MUTABLE));
        token_event_store::emit_collection_description_mutate_event(creator, collection_name, collection_data.description, description);
        collection_data.description = description;
    }

    public fun mutate_collection_uri(creator: &signer, collection_name: String, uri: String) acquires Collections {
        assert!(uri.length() <= MAX_URI_LENGTH, error::invalid_argument(EURI_TOO_LONG));
        let creator_address = signer::address_of(creator);
        assert_collection_exists(creator_address, collection_name);
        let collection_data = Collections[creator_address].collection_data.borrow_mut(
            collection_name
        );
        assert!(collection_data.mutability_config.uri, error::permission_denied(EFIELD_NOT_MUTABLE));
        token_event_store::emit_collection_uri_mutate_event(creator, collection_name, collection_data.uri , uri);
        collection_data.uri = uri;
    }
```

**File:** aptos-move/framework/aptos-token/sources/token.move (L1161-1170)
```text
    public fun create_collection(
        creator: &signer,
        name: String,
        description: String,
        uri: String,
        maximum: u64,
        mutate_setting: vector<bool>
    ) acquires Collections {
        assert!(name.length() <= MAX_COLLECTION_NAME_LENGTH, error::invalid_argument(ECOLLECTION_NAME_TOO_LONG));
        assert!(uri.length() <= MAX_URI_LENGTH, error::invalid_argument(EURI_TOO_LONG));
```

**File:** aptos-move/framework/aptos-token/sources/token.move (L1193-1200)
```text
        let collection = CollectionData {
            description,
            name,
            uri,
            supply: 0,
            maximum,
            mutability_config
        };
```

**File:** aptos-move/framework/aptos-token/sources/token.move (L1215-1224)
```text
            event::emit_event<CreateCollectionEvent>(
                &mut collection_handle.create_collection_events,
                CreateCollectionEvent {
                    creator: account_addr,
                    collection_name: name,
                    uri,
                    description,
                    maximum,
                }
            );
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L184-199)
```rust
            storage_fee_per_state_slot: FeePerSlot,
            { 14.. => "storage_fee_per_state_slot" },
            // 0.8 million APT for 2 billion state slots
            40_000,
        ],
        [
            legacy_storage_fee_per_excess_state_byte: FeePerByte,
            { 7..=13 => "storage_fee_per_excess_state_byte", 14.. => "legacy_storage_fee_per_excess_state_byte" },
            50,
        ],
        [
            storage_fee_per_state_byte: FeePerByte,
            { 14.. => "storage_fee_per_state_byte" },
            // 0.8 million APT for 2 TB state bytes
            40,
        ],
```
