# Audit Report

## Title
SafetyRules Initialization Accepts Epoch Change Proofs Without Signature Verification (Consensus Safety Violation)

## Summary
The `TSafetyRules::initialize()` implementation accepts `EpochChangeProof` with invalid or missing signatures when verifying against a Waypoint. The first epoch-ending `LedgerInfoWithSignatures` in the proof is verified only by hash matching, bypassing cryptographic signature verification required by the AptosBFT consensus protocol. This allows malicious actors to present unsigned epoch change proofs that violate the 2f+1 validator signature requirement.

## Finding Description

The vulnerability exists in the epoch change verification flow during SafetyRules initialization. The interface defines `initialize()` to accept an `EpochChangeProof`: [1](#0-0) 

The primary implementation in `SafetyRules::guarded_initialize()` verifies the proof using a Waypoint verifier: [2](#0-1) 

The `EpochChangeProof::verify()` method iterates through epoch changes and calls the verifier's `verify()` method on each ledger info: [3](#0-2) 

**The Critical Flaw**: When a `Waypoint` is used as the initial verifier, its `verify()` implementation only checks hash and version matching, **not cryptographic signatures**: [4](#0-3) [5](#0-4) 

In contrast, when an `EpochState` is used as verifier, signature verification **is** performed: [6](#0-5) 

**Attack Scenario**:
1. Attacker obtains a node's waypoint (public configuration)
2. Attacker constructs a `LedgerInfoWithSignatures` that matches the waypoint's hash/version but with empty or forged signatures using `AggregateSignature::empty()`
3. Attacker creates an `EpochChangeProof` starting with this unsigned ledger info
4. Node's `SafetyRules::initialize()` accepts the proof because `Waypoint::verify()` only validates hash matching
5. The epoch change is accepted without cryptographic proof of 2f+1 validator consensus

The existing test suite demonstrates that invalid signatures are rejected **only** when using `EpochState` as verifier, but no test exists for Waypoint-based verification with invalid signatures: [7](#0-6) 

## Impact Explanation

**Severity: Critical** (Consensus/Safety Violation - up to $1,000,000)

This vulnerability breaks the fundamental consensus invariant that epoch changes must be approved by 2f+1 validators through BLS signature aggregation. The security guarantees violated include:

1. **Consensus Safety**: Epoch transitions can occur without cryptographic proof of validator consensus
2. **Cryptographic Correctness**: Signature verification is bypassed for epoch-ending ledger infos
3. **State Consistency**: Nodes can be initialized into epochs based on unverified proofs

While the waypoint's hash commitment prevents modification of the epoch state content (including the next validator set), the **absence of signature verification** means:
- No cryptographic proof that 2f+1 validators actually approved the epoch change
- Violation of AptosBFT's safety requirements
- Potential for replay attacks using old waypoints with stripped signatures
- Undermines trust assumptions about epoch boundaries

## Likelihood Explanation

**Likelihood: High**

The vulnerability is highly likely to be exploitable because:

1. **Easy to trigger**: Any node performing initialization or state recovery uses this code path
2. **Public information**: Waypoints are publicly shared configuration values
3. **Simple exploit**: Attacker only needs to construct a `LedgerInfoWithSignatures` with matching content but empty signatures
4. **No special privileges required**: Any network peer can send malicious epoch change proofs
5. **Real-world scenario**: Nodes regularly initialize during startup, crash recovery, or state synchronization

The attack complexity is low - the attacker needs only:
- Knowledge of the target waypoint (public)
- Ability to construct BCS-serialized `EpochChangeProof` messages
- Network access to send the proof to the target node

## Recommendation

Add explicit signature verification for Waypoint-based epoch change proofs. The fix should verify that the first epoch-ending ledger info in the proof has valid 2f+1 validator signatures **before** accepting the epoch state.

**Recommended Fix**:

Modify `EpochChangeProof::verify()` to require signature verification even when starting from a Waypoint:

```rust
pub fn verify(&self, verifier: &dyn Verifier) -> Result<&LedgerInfoWithSignatures> {
    ensure!(
        !self.ledger_info_with_sigs.is_empty(),
        "The EpochChangeProof is empty"
    );
    ensure!(
        !verifier.is_ledger_info_stale(self.ledger_info_with_sigs.last().unwrap().ledger_info()),
        "The EpochChangeProof is stale"
    );
    
    let mut verifier_ref = verifier;
    let mut first_ledger_info = true;

    for ledger_info_with_sigs in self.ledger_info_with_sigs.iter()
        .skip_while(|&ledger_info_with_sigs| {
            verifier.is_ledger_info_stale(ledger_info_with_sigs.ledger_info())
        })
    {
        // For Waypoint verifiers, verify hash matching
        verifier_ref.verify(ledger_info_with_sigs)?;
        
        // ADDED: For the first ledger info, also verify signatures using embedded epoch state
        if first_ledger_info {
            if let Some(prev_epoch_state) = ledger_info_with_sigs.ledger_info().commit_info().prev_epoch_state() {
                ledger_info_with_sigs.verify_signatures(&prev_epoch_state.verifier)?;
            }
            first_ledger_info = false;
        }
        
        verifier_ref = ledger_info_with_sigs
            .ledger_info()
            .next_epoch_state()
            .ok_or_else(|| format_err!("LedgerInfo doesn't carry a ValidatorSet"))?;
    }

    Ok(self.ledger_info_with_sigs.last().unwrap())
}
```

**Alternative**: Require that `Waypoint::verify()` implementations must also check signatures by accessing the validator set from the previous epoch state stored in the ledger info.

## Proof of Concept

```rust
#[test]
fn test_waypoint_accepts_invalid_signatures() {
    use crate::{
        epoch_change::EpochChangeProof,
        ledger_info::{LedgerInfo, LedgerInfoWithSignatures},
        block_info::BlockInfo,
        epoch_state::EpochState,
        waypoint::Waypoint,
        aggregate_signature::AggregateSignature,
        validator_verifier::random_validator_verifier,
    };
    use aptos_crypto::hash::HashValue;
    
    // Create a legitimate epoch-ending ledger info with valid signatures
    let (signers, verifier) = random_validator_verifier(4, None, true);
    let verifier = Arc::new(verifier);
    
    let next_epoch_state = EpochState {
        epoch: 2,
        verifier: verifier.clone(),
    };
    
    let ledger_info = LedgerInfo::new(
        BlockInfo::new(
            1, // epoch
            0, // round
            HashValue::zero(),
            HashValue::zero(),
            100, // version
            0,
            Some(next_epoch_state.clone()),
        ),
        HashValue::zero(),
    );
    
    // Create a waypoint from this ledger info
    let waypoint = Waypoint::new_epoch_boundary(&ledger_info).unwrap();
    
    // ATTACK: Create a LedgerInfoWithSignatures with the SAME ledger info
    // but with EMPTY/INVALID signatures
    let malicious_li_with_sigs = LedgerInfoWithSignatures::new(
        ledger_info.clone(),
        AggregateSignature::empty(), // No valid signatures!
    );
    
    // Create an EpochChangeProof with the unsigned ledger info
    let malicious_proof = EpochChangeProof::new(
        vec![malicious_li_with_sigs],
        false,
    );
    
    // VULNERABILITY: This verification PASSES even though signatures are invalid!
    let result = malicious_proof.verify(&waypoint);
    assert!(result.is_ok(), "Waypoint accepted proof without valid signatures!");
    
    // This demonstrates that epoch changes can be accepted without 
    // cryptographic proof of 2f+1 validator consensus
}
```

## Notes

This vulnerability specifically affects the initialization path when using Waypoint-based verification. The interface `TSafetyRules::initialize()` does not mandate signature verification, allowing implementations to bypass this critical security check. While subsequent epoch changes in the proof (after the first) are verified using `EpochState` which does check signatures, the initial epoch change is vulnerable. This represents a fundamental breach of AptosBFT consensus safety requirements.

### Citations

**File:** consensus/safety-rules/src/t_safety_rules.rs (L29-29)
```rust
    fn initialize(&mut self, proof: &EpochChangeProof) -> Result<(), Error>;
```

**File:** consensus/safety-rules/src/safety_rules.rs (L265-269)
```rust
    fn guarded_initialize(&mut self, proof: &EpochChangeProof) -> Result<(), Error> {
        let waypoint = self.persistent_storage.waypoint()?;
        let last_li = proof
            .verify(&waypoint)
            .map_err(|e| Error::InvalidEpochChangeProof(format!("{}", e)))?;
```

**File:** types/src/epoch_change.rs (L106-114)
```rust
            // Try to verify each (epoch -> epoch + 1) jump in the EpochChangeProof.
            verifier_ref.verify(ledger_info_with_sigs)?;
            // While the original verification could've been via waypoints,
            // all the next epoch changes are verified using the (already
            // trusted) validator sets.
            verifier_ref = ledger_info_with_sigs
                .ledger_info()
                .next_epoch_state()
                .ok_or_else(|| format_err!("LedgerInfo doesn't carry a ValidatorSet"))?;
```

**File:** types/src/epoch_change.rs (L256-269)
```rust
        // Test proof with invalid signatures will fail
        let proof_6 = EpochChangeProof::new(
            vec![LedgerInfoWithSignatures::new(
                valid_ledger_info[0].ledger_info().clone(),
                AggregateSignature::empty(),
            )],
            /* more = */ false,
        );
        assert!(proof_6
            .verify(&EpochState {
                epoch: all_epoch[0],
                verifier: validator_verifier[0].clone(),
            })
            .is_err());
```

**File:** types/src/waypoint.rs (L62-79)
```rust
    pub fn verify(&self, ledger_info: &LedgerInfo) -> Result<()> {
        ensure!(
            ledger_info.version() == self.version(),
            "Waypoint version mismatch: waypoint version = {}, given version = {}",
            self.version(),
            ledger_info.version()
        );
        let converter = Ledger2WaypointConverter::new(ledger_info);
        ensure!(
            converter.hash() == self.value(),
            format!(
                "Waypoint value mismatch: waypoint value = {}, given value = {}",
                self.value().to_hex(),
                converter.hash().to_hex()
            )
        );
        Ok(())
    }
```

**File:** types/src/waypoint.rs (L82-85)
```rust
impl Verifier for Waypoint {
    fn verify(&self, ledger_info: &LedgerInfoWithSignatures) -> Result<()> {
        self.verify(ledger_info.ledger_info())
    }
```

**File:** types/src/epoch_state.rs (L40-50)
```rust
impl Verifier for EpochState {
    fn verify(&self, ledger_info: &LedgerInfoWithSignatures) -> anyhow::Result<()> {
        ensure!(
            self.epoch == ledger_info.ledger_info().epoch(),
            "LedgerInfo has unexpected epoch {}, expected {}",
            ledger_info.ledger_info().epoch(),
            self.epoch
        );
        ledger_info.verify_signatures(&self.verifier)?;
        Ok(())
    }
```
