# Audit Report

## Title
Event Spam Attack: Insufficient Gas Cost for Batch UriMutationEvent Emissions

## Summary
The `mutate_tokendata_uri` function in the legacy token system allows attackers to emit thousands of `UriMutationEvent` instances in a single transaction at extremely low marginal cost per event, enabling economically viable event spam attacks that can degrade indexer performance and bloat event logs.

## Finding Description

The `UriMutationEvent` emission occurs through the `mutate_tokendata_uri` function which lacks rate limiting or cooldown mechanisms. An attacker can exploit this by: [1](#0-0) 

The gas cost structure for events consists of:

1. **Native execution gas**: Base cost of 20,006 plus 61 per abstract value unit [2](#0-1) 

2. **IO gas**: 89 internal gas units per byte [3](#0-2) 

3. **Storage fee**: Returns 0 in DiskSpacePricingV2 (version 13+) [4](#0-3) 

For a typical 150-byte `UriMutationEvent`, the total cost is approximately 42,500 internal gas units. With transaction limits allowing: [5](#0-4) 

An attacker can emit approximately 17,000-20,000 events per transaction (limited by the 920 million execution gas ceiling). The critical vulnerability lies in the **marginal cost structure**: once a transaction pays the fixed storage read/write costs for the Collections resource, each additional event emission only costs ~42,500 gas, with no per-token or per-transaction rate limits.

The attack vector involves creating a custom Move script that loops and repeatedly calls `mutate_tokendata_uri` on a single token with mutable URI configuration, alternating between two URI values to emit events continuously. [6](#0-5) 

## Impact Explanation

This qualifies as **Medium severity** under the Aptos bug bounty program's "State inconsistencies requiring intervention" category because:

1. **Indexer resource exhaustion**: Event spam forces indexers to process and store millions of low-value events, degrading query performance and requiring database cleanup interventions
2. **Legitimate event discovery degradation**: Users querying token URI mutation history cannot efficiently find genuine mutations among spam
3. **Economic attack viability**: At ~0.000001 APT per event, an attacker can emit 1 million spam events for approximately $11-30 USD, making large-scale attacks economically feasible

While this doesn't directly violate consensus safety, it breaks the **Resource Limits** invariant (#9) by allowing disproportionate event generation relative to gas costs, and creates operational burden requiring manual intervention.

## Likelihood Explanation

**Likelihood: HIGH**

The attack requires:
- Minimal setup: Create ONE token with `uri` mutability enabled
- Low technical barrier: Write a simple Move script with a loop
- Minimal cost: ~$30 to spam 1 million events
- No special privileges: Any user can execute

The only constraint is the 10 MB event size limit per transaction, which still permits ~69,000 small events if execution gas weren't the bottleneck. [7](#0-6) 

## Recommendation

Implement per-token mutation rate limiting at the Move framework level:

```move
// Add to TokenData struct
struct TokenData {
    // ... existing fields
    last_uri_mutation_timestamp: u64,
}

// Add rate limit check in mutate_tokendata_uri
public fun mutate_tokendata_uri(
    creator: &signer,
    token_data_id: TokenDataId,
    uri: String
) acquires Collections {
    assert!(uri.length() <= MAX_URI_LENGTH, error::invalid_argument(EURI_TOO_LONG));
    assert_tokendata_exists(creator, token_data_id);
    
    let all_token_data = &mut Collections[token_data_id.creator].token_data;
    let token_data = all_token_data.borrow_mut(token_data_id);
    assert!(token_data.mutability_config.uri, error::permission_denied(EFIELD_NOT_MUTABLE));
    
    // NEW: Enforce minimum time between mutations (e.g., 1 second)
    let current_time = timestamp::now_seconds();
    assert!(
        current_time >= token_data.last_uri_mutation_timestamp + 1,
        error::resource_exhausted(EMUTATION_RATE_LIMIT_EXCEEDED)
    );
    
    token_event_store::emit_token_uri_mutate_event(
        creator, token_data_id.collection, token_data_id.name, token_data.uri, uri
    );
    token_data.uri = uri;
    token_data.last_uri_mutation_timestamp = current_time;
}
```

Alternatively, add a per-transaction event emission counter that enforces a maximum (e.g., 100 events per transaction) at the VM level.

## Proof of Concept

```move
script {
    use aptos_token::token::{Self, TokenDataId};
    use std::string;
    use std::signer;

    fun spam_uri_events(attacker: signer) {
        // Prerequisite: attacker has created a token with mutable URI
        let token_data_id = token::create_token_data_id(
            signer::address_of(&attacker),
            string::utf8(b"SpamCollection"),
            string::utf8(b"SpamToken")
        );
        
        // Spam loop: emit ~17,000 events in single transaction
        let i = 0;
        while (i < 17000) {
            // Alternate between two URIs to trigger mutations
            let uri = if (i % 2 == 0) {
                string::utf8(b"https://spam.example.com/uri1")
            } else {
                string::utf8(b"https://spam.example.com/uri2")
            };
            
            token::mutate_tokendata_uri(&attacker, token_data_id, uri);
            i = i + 1;
        };
        // Cost: ~2M gas units = 0.02 APT = ~$0.20 for 17,000 spam events
    }
}
```

**Expected Result**: Transaction succeeds, emitting 17,000 `UriMutationEvent` instances, demonstrating the economic viability of event spam attacks.

## Notes

This vulnerability is specific to the legacy token system (`0x3::token`). The newer Token Objects system (`0x4::token`) may have different event emission patterns. The attack exploits the batching efficiency where fixed storage costs are amortized across many event emissions within a single transaction, making the marginal cost per event extremely low compared to the value of degrading indexer infrastructure.

### Citations

**File:** aptos-move/framework/aptos-token/sources/token.move (L816-829)
```text
    public fun mutate_tokendata_uri(
        creator: &signer,
        token_data_id: TokenDataId,
        uri: String
    ) acquires Collections {
        assert!(uri.length() <= MAX_URI_LENGTH, error::invalid_argument(EURI_TOO_LONG));
        assert_tokendata_exists(creator, token_data_id);

        let all_token_data = &mut Collections[token_data_id.creator].token_data;
        let token_data = all_token_data.borrow_mut(token_data_id);
        assert!(token_data.mutability_config.uri, error::permission_denied(EFIELD_NOT_MUTABLE));
        token_event_store::emit_token_uri_mutate_event(creator, token_data_id.collection, token_data_id.name, token_data.uri ,uri);
        token_data.uri = uri;
    }
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/aptos_framework.rs (L323-325)
```rust
        [event_write_to_event_store_base: InternalGas, "event.write_to_event_store.base", 20006],
        // TODO(Gas): the on-chain name is wrong...
        [event_write_to_event_store_per_abstract_value_unit: InternalGasPerAbstractValueUnit, "event.write_to_event_store.per_abstract_memory_unit", 61],
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L133-136)
```rust
            storage_io_per_event_byte_write: InternalGasPerByte,
            { RELEASE_V1_11.. => "storage_io_per_event_byte_write" },
            89,
        ],
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L169-172)
```rust
            max_bytes_all_events_per_transaction: NumBytes,
            { 5.. => "max_bytes_all_events_per_transaction"},
            10 << 20, // all events from a single transaction are 10MB max
        ],
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L211-214)
```rust
            max_execution_gas: InternalGas,
            { 7.. => "max_execution_gas" },
            920_000_000, // 92ms of execution at 10k gas per ms
        ],
```

**File:** aptos-move/aptos-vm-types/src/storage/space_pricing.rs (L58-69)
```rust
    pub fn legacy_storage_fee_per_event(
        &self,
        params: &TransactionGasParameters,
        event: &ContractEvent,
    ) -> Fee {
        match self {
            Self::V1 => {
                NumBytes::new(event.size() as u64) * params.legacy_storage_fee_per_event_byte
            },
            Self::V2 => 0.into(),
        }
    }
```

**File:** aptos-move/framework/aptos-token/sources/token_event_store.move (L335-369)
```text
    friend fun emit_token_uri_mutate_event(
        creator: &signer,
        collection: String,
        token: String,
        old_uri: String,
        new_uri: String,
    ) acquires TokenEventStoreV1 {
        let creator_addr = signer::address_of(creator);

        let event = UriMutationEvent {
            creator: creator_addr,
            collection,
            token,
            old_uri,
            new_uri,
        };

        initialize_token_event_store(creator);
        let token_event_store = &mut TokenEventStoreV1[creator_addr];
        if (std::features::module_event_migration_enabled()) {
            event::emit(
                UriMutation {
                    creator: creator_addr,
                    collection,
                    token,
                    old_uri,
                    new_uri,
                });
        } else {
            event::emit_event<UriMutationEvent>(
                &mut token_event_store.uri_mutate_events,
                event,
            );
        };
    }
```
