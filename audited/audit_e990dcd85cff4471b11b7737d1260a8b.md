# Audit Report

## Title
Hot State Memory Exhaustion via Large StateValue Exploitation

## Summary
The hot state LRU cache in AptosDB enforces only item count limits but not total byte size limits. An attacker can craft transactions writing state values at the maximum allowed size (1MB), causing the hot state cache to consume up to 4TB of memory (2000× the designed 2GB), leading to validator OOM crashes and denial of service.

## Finding Description

The hot state cache is an in-memory LRU cache designed to accelerate access to frequently-used blockchain state. The configuration explicitly states a design expectation of approximately 2GB RAM consumption: [1](#0-0) 

The default configuration allows 250,000 items per shard across 16 shards (4 million items total): [2](#0-1) 

However, a critical architectural mismatch exists between transaction-level validation and hot state memory management:

**1. Transaction-level validation allows large values:**

The system permits state values up to 1MB (1,048,576 bytes): [3](#0-2) 

This validation is enforced during transaction execution: [4](#0-3) 

**2. Hot state cache tracks byte size but doesn't use it for eviction:**

The `Committer` tracks `total_value_bytes` by calculating the size of each `StateSlot`: [5](#0-4) 

The `StateSlot::size()` method returns the actual byte length: [6](#0-5) 

Which delegates to `StateValue::size()`: [7](#0-6) 

However, `total_value_bytes` is only used for metrics reporting, not eviction: [8](#0-7) 

**3. LRU eviction is purely count-based:**

The critical flaw is that eviction only checks item count against capacity: [9](#0-8) 

**Attack Scenario:**
1. Attacker submits transactions creating/updating state values at ~1MB each
2. Each transaction passes validation (within the 1MB limit)
3. Values are committed and loaded into hot state cache
4. Cache accepts up to 4 million items (250K × 16 shards)
5. Worst case memory consumption: 4M items × 1MB = **4TB**
6. This is 2000× the designed 2GB, causing validator OOM crashes

The system violates resource limit invariants because hot state memory consumption is unbounded beyond item count, despite the design assumption of ~500 bytes per item.

## Impact Explanation

**HIGH Severity** per Aptos Bug Bounty criteria: "Validator Node Slowdowns" and "DoS through resource exhaustion"

This vulnerability enables denial of service attacks against validator nodes:

- **Direct Impact**: Validators experience extreme memory pressure leading to:
  - Severe performance degradation from disk swapping
  - OOM kills requiring node restarts
  - Potential consensus participation failures during memory exhaustion

- **Attack Cost vs Damage**: While attackers pay storage fees, they can cause disproportionate harm. Storage fees for 4M items at 1MB each would be approximately 1.6M APT, but this could disable multiple validators.

- **Persistence**: Large values remain in hot state until evicted by LRU (count-based), so effects persist across blocks.

- **Network Impact**: Multiple validators could experience simultaneous memory exhaustion, threatening network liveness.

This meets HIGH severity as it causes "Validator Node Slowdowns" through "DoS via resource exhaustion" (explicitly listed as HIGH in the framework), though it doesn't reach CRITICAL as it doesn't directly cause fund loss or permanent network damage.

## Likelihood Explanation

**MEDIUM Likelihood**

**Attacker Requirements:**
- APT tokens for storage fees (~1.6M APT for full exploitation)
- Ability to craft large state value transactions (trivial)
- No special privileges required

**Exploitation Complexity:**
- Low technical complexity: write large Move resources
- Can be sustained by creating new values or refreshing existing ones
- Default configuration is vulnerable

**Mitigating Factors:**
- High economic cost (1.6M APT for full cache fill)
- Storage fees provide economic barrier
- LRU eventually evicts inactive values
- Requires sustained effort

**Amplifying Factors:**
- No byte-size monitoring or alerting
- Multiple attackers could coordinate
- Once values are hot, they persist until evicted

While the economic cost is substantial, a well-funded attacker could execute this attack to cause temporary validator degradation.

## Recommendation

Implement byte-size aware eviction in addition to count-based limits:

1. **Add byte limit to HotStateConfig:**
   - Add `max_bytes_per_shard: usize` field (e.g., 128MB per shard = 2GB total)

2. **Modify HotStateLRU::maybe_evict():**
   - Track `total_bytes` alongside `num_items`
   - Evict when either `num_items > capacity` OR `total_bytes > byte_capacity`
   - Eviction logic should consider both constraints

3. **Add monitoring:**
   - Alert when hot state byte usage exceeds thresholds (e.g., 75% of limit)
   - Track per-shard byte usage metrics

4. **Consider dynamic limits:**
   - Adjust `max_items_per_shard` based on average value sizes
   - Prevent pathological cases where all values are maximum size

## Proof of Concept

```rust
// Simplified PoC demonstrating the vulnerability
// In a real exploit, submit transactions via API creating large state values

use aptos_types::state_store::{StateKey, StateValue};
use bytes::Bytes;

fn create_large_state_values() {
    let max_size = 1 << 20; // 1MB
    let values_per_shard = 250_000;
    let num_shards = 16;
    
    // Create maximum-sized values
    let large_value = StateValue::new_legacy(Bytes::from(vec![0u8; max_size]));
    
    // Calculate worst-case memory
    let total_items = values_per_shard * num_shards;
    let worst_case_bytes = total_items * max_size;
    
    println!("Hot state cache capacity: {} items", total_items);
    println!("Max value size: {} bytes", max_size);
    println!("Worst case memory: {} bytes ({} GB)", 
             worst_case_bytes, 
             worst_case_bytes / (1 << 30));
    
    // Output: Worst case memory: 4398046511104 bytes (4096 GB) = 4TB
    // Design expectation: 2GB
    // Discrepancy: 2048×
}
```

**Notes:**

The vulnerability is confirmed through code analysis showing:
1. Design comment explicitly expects ~2GB RAM consumption
2. Implementation allows 4M items × 1MB = 4TB maximum
3. Eviction is count-based only, ignoring byte size
4. `total_value_bytes` is tracked but only for metrics, not eviction decisions

This architectural mismatch creates a 2000× memory discrepancy between design intent and actual behavior, enabling resource exhaustion attacks against validators.

### Citations

**File:** config/src/config/storage_config.rs (L24-24)
```rust
// Lru cache will consume about 2G RAM based on this default value.
```

**File:** config/src/config/storage_config.rs (L259-259)
```rust
            max_items_per_shard: 250_000,
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L154-157)
```rust
            max_bytes_per_write_op: NumBytes,
            { 5.. => "max_bytes_per_write_op" },
            1 << 20, // a single state item is 1MB max
        ],
```

**File:** aptos-move/aptos-vm-types/src/storage/change_set_configs.rs (L104-107)
```rust
                let write_op_size = len + (key.size() as u64);
                if write_op_size > self.max_bytes_per_write_op {
                    return storage_write_limit_reached(None);
                }
```

**File:** storage/aptosdb/src/state_store/hot_state.rs (L201-201)
```rust
            GAUGE.set_with(&["hot_state_value_bytes"], self.total_value_bytes as i64);
```

**File:** storage/aptosdb/src/state_store/hot_state.rs (L248-251)
```rust
                    self.total_value_bytes += slot.size();
                    if let Some(old_slot) = self.base.shards[shard_id].insert(key, slot) {
                        self.total_key_bytes -= key_size;
                        self.total_value_bytes -= old_slot.size();
```

**File:** types/src/state_store/state_slot.rs (L153-158)
```rust
    pub fn size(&self) -> usize {
        match self {
            ColdVacant | HotVacant { .. } => 0,
            ColdOccupied { value, .. } | HotOccupied { value, .. } => value.size(),
        }
    }
```

**File:** types/src/state_store/state_value.rs (L272-274)
```rust
    pub fn size(&self) -> usize {
        self.bytes().len()
    }
```

**File:** storage/storage-interface/src/state_store/hot_state.rs (L92-92)
```rust
        while self.num_items > self.capacity.get() {
```
