# Audit Report

## Title
Consensus Equivocation: Validator Can Send Both Vote and RoundTimeout for Same Round

## Summary

When the `enable_round_timeout_msg` feature flag is enabled, a validator can simultaneously have both `vote_sent` and `timeout_sent` set to `Some` for the same consensus round in `RoundState`. This allows a validator to broadcast both a Vote for a specific block AND a separate RoundTimeout message for the same round, violating the fundamental BFT consensus invariant that validators should make exactly one choice per round. This constitutes equivocation and enables double-counting of voting power in certificate aggregation.

## Finding Description

The vulnerability exists in the consensus round state management when `enable_round_timeout_msg` is enabled. The core issue is that `RoundState` tracks both `vote_sent: Option<Vote>` and `timeout_sent: Option<RoundTimeout>` independently without enforcing mutual exclusivity. [1](#0-0) 

**Attack Path:**

1. **Validator votes on a proposal**: When a validator receives and votes on a proposal in round R, `process_verified_proposal` calls `record_vote()`, setting `vote_sent = Some(vote)` where the vote has no timeout attached. [2](#0-1) 

2. **Local timeout fires**: Before the round advances, the local timeout for round R fires, triggering `process_local_timeout()`. The `is_timeout_sent()` check evaluates to false because it checks if `vote_sent` is a timeout vote (which it isn't - it's a normal vote) OR if `timeout_sent` exists (which it doesn't yet). [3](#0-2) 

3. **Separate RoundTimeout created**: When `enable_round_timeout_msg` is true, the code creates a new `RoundTimeout` and records it via `record_round_timeout()`, setting `timeout_sent = Some(timeout)`. Critically, this does NOT check whether `vote_sent` is already Some. [4](#0-3) 

4. **Double-counting in aggregation**: The validator broadcasts both messages. Other validators process the Vote through `insert_vote()` (which tracks it in `author_to_vote` and contributes to QC aggregation) and the RoundTimeout through `insert_round_timeout()` (which does NOT check `author_to_vote` and contributes to TC aggregation). [5](#0-4) 

**Root Cause in SafetyRules:**

The SafetyRules module permits this behavior. When signing a timeout for round R where the validator already voted in round R, the check `timeout.round() < safety_data.last_voted_round` is false (R is not less than R), so it proceeds to sign the timeout. [6](#0-5) 

**Protocol Invariant Violated:**

In BFT consensus, validators must make ONE choice per round: either vote for a specific block OR timeout indicating inability to make progress. This implementation allows both, which is a form of equivocation. There is even an acknowledgment of this issue in a TODO comment. [7](#0-6) 

## Impact Explanation

This vulnerability represents a **Medium to High severity** consensus protocol violation:

**Protocol-Level Impact:**
- **Equivocation**: The validator makes two contradictory statements about the same round (supporting a block AND claiming inability to progress)
- **Voting power double-counting**: The validator's voting power contributes to both QC and TC aggregation, violating the assumption that each validator participates in only one certificate per round
- **Consensus confusion**: Different validators may have inconsistent views of whether a validator supported a proposal or timed out

**Attack Scenarios:**
1. **Liveness manipulation**: A Byzantine validator can strategically vote and timeout to keep the network in states where neither QC nor TC can form cleanly
2. **Certificate aggregation confusion**: The protocol's certificate aggregation logic assumes mutual exclusivity between voting and timing out, which this violates
3. **State tracking inconsistency**: The `RoundState` tracks contradictory information about validator actions

This qualifies as **Medium Severity** ($10,000 range) under the bug bounty program's "State inconsistencies requiring intervention" category, potentially **High Severity** if it can be shown to cause significant protocol violations affecting liveness or creating consensus confusion across the network.

## Likelihood Explanation

**Likelihood: Medium to High**

This vulnerability can occur **without malicious intent** through normal network conditions:

1. **Race condition in normal operation**: Under network delays, a validator can vote on a proposal, then have the local timeout fire before receiving enough votes to form a QC or advance rounds. This is a natural occurrence in distributed systems.

2. **Feature flag enabled**: The vulnerability only manifests when `enable_round_timeout_msg` is true. This is a configuration option that operators may enable.

3. **No access control required**: Any validator experiencing the timing conditions can trigger this state, making it a systemic issue rather than requiring specific attacker capabilities.

4. **Persistent state**: Once both `vote_sent` and `timeout_sent` are set, the inconsistent state persists until the next round starts, allowing the contradictory messages to be processed by other validators.

## Recommendation

**Fix 1: Enforce Mutual Exclusivity in RoundState**

Add validation in `record_round_timeout()` to prevent recording a timeout if a vote was already sent (and vice versa):

```rust
pub fn record_round_timeout(&mut self, timeout: RoundTimeout) {
    if timeout.round() == self.current_round {
        // Enforce mutual exclusivity: cannot timeout if already voted
        if self.vote_sent.is_some() {
            warn!("Cannot record timeout for round {} - already voted", self.current_round);
            return;
        }
        self.timeout_sent = Some(timeout)
    }
}

pub fn record_vote(&mut self, vote: Vote) {
    if vote.vote_data().proposed().round() == self.current_round {
        // Enforce mutual exclusivity: cannot vote if already timed out
        if self.timeout_sent.is_some() {
            warn!("Cannot record vote for round {} - already timed out", self.current_round);
            return;
        }
        self.vote_sent = Some(vote);
    }
}
```

**Fix 2: Strengthen SafetyRules Check**

In SafetyRules, prevent signing a timeout for the same round as a vote:

```rust
pub(crate) fn guarded_sign_timeout_with_qc(
    &mut self,
    timeout: &TwoChainTimeout,
    timeout_cert: Option<&TwoChainTimeoutCertificate>,
) -> Result<bls12381::Signature, Error> {
    // ... existing checks ...
    
    // Prevent timing out in the same round as a vote
    if timeout.round() == safety_data.last_voted_round {
        return Err(Error::CannotTimeoutAfterVoting(
            timeout.round(),
            safety_data.last_voted_round,
        ));
    }
    
    // ... rest of implementation ...
}
```

**Fix 3: Add Cross-Checking in PendingVotes**

In `insert_round_timeout()`, check if the author already voted before adding their timeout to aggregation:

```rust
pub fn insert_round_timeout(
    &mut self,
    round_timeout: &RoundTimeout,
    validator_verifier: &ValidatorVerifier,
) -> VoteReceptionResult {
    // Check if author already voted - prevent double-counting
    if self.author_to_vote.contains_key(&round_timeout.author()) {
        warn!("Author {} already voted, ignoring timeout", round_timeout.author());
        return VoteReceptionResult::DuplicateVote;
    }
    
    // ... rest of implementation ...
}
```

## Proof of Concept

```rust
// Rust test demonstrating the vulnerability
#[tokio::test]
async fn test_vote_and_timeout_inconsistency() {
    // Setup: Create a RoundState with enable_round_timeout_msg = true
    let time_interval = Box::new(ExponentialTimeInterval::fixed(Duration::from_secs(1)));
    let time_service = Arc::new(SimulatedTimeService::new());
    let (timeout_sender, _timeout_receiver) = aptos_channels::new_test(10);
    let mut round_state = RoundState::new(time_interval, time_service, timeout_sender);
    
    // Start a new round
    let sync_info = create_sync_info_for_round(5);
    let validator_verifier = create_validator_verifier();
    round_state.process_certificates(sync_info, &validator_verifier);
    
    // Step 1: Record a vote for round 5
    let vote = create_vote_for_round(5, false); // normal vote, not timeout
    round_state.record_vote(vote.clone());
    
    // Verify vote is recorded
    assert!(round_state.vote_sent().is_some());
    assert!(round_state.timeout_sent().is_none());
    
    // Step 2: Simulate local timeout for the same round 5
    // Note: is_timeout_sent() returns false because vote_sent is not a timeout vote
    assert!(!round_state.is_timeout_sent());
    
    // Step 3: Record a timeout for round 5 (simulating process_local_timeout path)
    let timeout = create_round_timeout_for_round(5);
    round_state.record_round_timeout(timeout.clone());
    
    // VULNERABILITY: Both vote_sent and timeout_sent are now Some for the same round!
    assert!(round_state.vote_sent().is_some());
    assert!(round_state.timeout_sent().is_some());
    
    // This violates the invariant that validators make ONE choice per round
    println!("VULNERABILITY CONFIRMED: Both vote_sent and timeout_sent are Some for round 5");
    println!("vote_sent: {:?}", round_state.vote_sent());
    println!("timeout_sent: {:?}", round_state.timeout_sent());
}
```

**Notes**

- This vulnerability is specific to the `enable_round_timeout_msg` feature path. When this flag is false, timeouts are attached to votes rather than sent separately, which has different (but related) issues.
- The TODO comment in `vote.rs` at line 152 acknowledges a related concern but doesn't fully address this RoundState tracking issue.
- The vulnerability can manifest during normal network operation without requiring malicious validator behavior, making it a systemic design flaw rather than just an attack vector.
- The fix requires coordination between multiple layers: RoundState tracking, SafetyRules signing logic, and PendingVotes aggregation logic.

### Citations

**File:** consensus/src/liveness/round_state.rs (L160-163)
```rust
    // Vote sent locally for the current round.
    vote_sent: Option<Vote>,
    // Timeout sent locally for the current round.
    timeout_sent: Option<RoundTimeout>,
```

**File:** consensus/src/liveness/round_state.rs (L217-219)
```rust
    pub fn is_timeout_sent(&self) -> bool {
        self.vote_sent.as_ref().is_some_and(|v| v.is_timeout()) || self.timeout_sent.is_some()
    }
```

**File:** consensus/src/round_manager.rs (L1005-1033)
```rust
        if self.local_config.enable_round_timeout_msg {
            let timeout = if let Some(timeout) = self.round_state.timeout_sent() {
                timeout
            } else {
                let timeout = TwoChainTimeout::new(
                    self.epoch_state.epoch,
                    round,
                    self.block_store.highest_quorum_cert().as_ref().clone(),
                );
                let signature = self
                    .safety_rules
                    .lock()
                    .sign_timeout_with_qc(
                        &timeout,
                        self.block_store.highest_2chain_timeout_cert().as_deref(),
                    )
                    .context("[RoundManager] SafetyRules signs 2-chain timeout")?;

                let timeout_reason = self.compute_timeout_reason(round);

                RoundTimeout::new(
                    timeout,
                    self.proposal_generator.author(),
                    timeout_reason,
                    signature,
                )
            };

            self.round_state.record_round_timeout(timeout.clone());
```

**File:** consensus/src/round_manager.rs (L1399-1400)
```rust
        let vote = self.create_vote(proposal).await?;
        self.round_state.record_vote(vote.clone());
```

**File:** consensus/src/pending_votes.rs (L189-232)
```rust
    /// Insert a RoundTimeout and return a TimeoutCertificate if it can be formed
    pub fn insert_round_timeout(
        &mut self,
        round_timeout: &RoundTimeout,
        validator_verifier: &ValidatorVerifier,
    ) -> VoteReceptionResult {
        //
        // Let's check if we can create a TC
        //

        let timeout = round_timeout.two_chain_timeout();
        let signature = round_timeout.signature();

        let validator_voting_power = validator_verifier
            .get_voting_power(&round_timeout.author())
            .unwrap_or(0);
        if validator_voting_power == 0 {
            warn!(
                "Received vote with no voting power, from {}",
                round_timeout.author()
            );
        }
        let cur_epoch = round_timeout.epoch();
        let cur_round = round_timeout.round();

        counters::CONSENSUS_CURRENT_ROUND_TIMEOUT_VOTED_POWER
            .with_label_values(&[&round_timeout.author().to_string()])
            .set(validator_voting_power as f64);
        counters::CONSENSUS_LAST_TIMEOUT_VOTE_EPOCH
            .with_label_values(&[&round_timeout.author().to_string()])
            .set(cur_epoch as i64);
        counters::CONSENSUS_LAST_TIMEOUT_VOTE_ROUND
            .with_label_values(&[&round_timeout.author().to_string()])
            .set(cur_round as i64);

        let two_chain_votes = self
            .maybe_2chain_timeout_votes
            .get_or_insert_with(|| TwoChainTimeoutVotes::new(timeout.clone()));
        two_chain_votes.add(
            round_timeout.author(),
            timeout.clone(),
            signature.clone(),
            round_timeout.reason().clone(),
        );
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L37-45)
```rust
        if timeout.round() < safety_data.last_voted_round {
            return Err(Error::IncorrectLastVotedRound(
                timeout.round(),
                safety_data.last_voted_round,
            ));
        }
        if timeout.round() > safety_data.last_voted_round {
            self.verify_and_update_last_vote_round(timeout.round(), &mut safety_data)?;
        }
```

**File:** consensus/consensus-types/src/vote.rs (L152-152)
```rust
        // TODO(ibalajiarun): Ensure timeout is None if RoundTimeoutMsg is enabled.
```
