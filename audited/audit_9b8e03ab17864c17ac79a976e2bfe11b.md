# Audit Report

## Title
JWK Consensus Session Key Collision Enables State Inconsistency and Update Loss

## Summary
The JWK consensus mechanism suffers from a race condition where multiple consensus sessions for the same session key can produce QuorumCertifiedUpdates that cause state inconsistency. The `session_key_from_qc()` function can return duplicate keys for different updates, and due to async timing, aborted sessions can still complete and push their QCs to the channel. This causes newer updates to be rejected while older updates are accepted, leading to stale on-chain JWK state.

## Finding Description

The vulnerability exists in the interaction between three components:

1. **Session Key Extraction** [1](#0-0) 
   In PerIssuerMode, `session_key_from_qc()` returns only the issuer, meaning different versions for the same issuer produce the same session key.

2. **QC Push to Channel** [2](#0-1) 
   After `rb.broadcast()` completes, the QC is pushed to the channel using the session key. The task is wrapped in `Abortable`, but if the broadcast completes before abort is processed, the push still executes.

3. **Channel Queue Behavior** [3](#0-2) 
   The channel uses `PerKeyQueue` which maintains a queue per key with max size 1 and `QueueStyle::KLAST`.

4. **Missing Validation in Receiver** [4](#0-3) 
   `process_quorum_certified_update()` checks only if state is `InProgress`, but doesn't validate that the received QC matches the current `my_proposal`.

**Attack Scenario:**

1. Observer detects issuer "https://accounts.google.com" has JWKs at version 1
2. Session 1 starts for version 1 [5](#0-4) 
3. Session 1 reaches reliable broadcast phase
4. Observer detects version 2 for the same issuer
5. Session 2 starts for version 2, replacing the state and dropping the old `QuorumCertProcessGuard` [6](#0-5) 
6. Session 1's abort handle is triggered, but `rb.broadcast()` has already completed
7. Session 1 pushes QC (version 1) to channel with key = issuer
8. Session 2 completes and pushes QC (version 2) to channel with same key
9. Due to timing, QC (version 1) is popped first and processed successfully
10. State becomes `Finished` with QC (version 1)
11. QC (version 2) arrives but is rejected because state is not `InProgress`
12. Newer version 2 is lost; blockchain has stale version 1

The same vulnerability exists in PerKeyMode [7](#0-6)  where session key is `(Issuer, KID)`, but different versions/updates for the same key can still collide.

## Impact Explanation

**Severity: HIGH** (per Aptos Bug Bounty criteria)

This constitutes a "Significant protocol violation" causing:

1. **JWK State Inconsistency**: The on-chain JWK state becomes stale, containing outdated keys
2. **Authentication Failures**: Users authenticating with OIDC providers may fail verification if validators have stale JWKs
3. **Data Loss**: Newer JWK updates are silently dropped without recovery mechanism
4. **State Mismatch**: Internal manager state can have mismatched `my_proposal` (version N+1) and `quorum_certified` (version N) fields

This breaks the **State Consistency** invariant: "State transitions must be atomic and verifiable." The validator transaction pool receives an older update while the consensus manager believes a newer one is in progress.

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH**

This is realistic in production because:

1. **OIDC Key Rotation**: Providers like Google, Apple, Microsoft rotate JWKs periodically (hours to days)
2. **Network Delays**: Different validators observe updates at different times
3. **Async Race Window**: The window between `rb.broadcast()` completion and abort signal processing is non-deterministic
4. **Automatic Trigger**: No attacker action required—normal OIDC provider operations trigger this
5. **Multiple Observations**: Rapid key rotations (e.g., security incident forcing emergency rotation) increase collision probability

The vulnerability requires no special privileges and occurs through normal protocol operation under realistic timing conditions.

## Recommendation

Implement validation to ensure received QCs match the current in-progress session:

```rust
// In jwk_manager/mod.rs process_quorum_certified_update()
pub fn process_quorum_certified_update(&mut self, update: QuorumCertifiedUpdate) -> Result<()> {
    let issuer = update.update.issuer.clone();
    let state = self.states_by_issuer.entry(issuer.clone()).or_default();
    
    match &state.consensus_state {
        ConsensusState::InProgress { my_proposal, .. } => {
            // VALIDATION: Ensure the QC matches our current proposal
            if my_proposal.observed.version != update.update.version {
                return Err(anyhow!(
                    "QC version mismatch: expected {}, got {}",
                    my_proposal.observed.version,
                    update.update.version
                ));
            }
            
            // Proceed with existing logic...
```

Additional mitigations:
1. Include version/hash in session key to prevent collisions
2. Implement proper abort waiting before starting new sessions
3. Add metrics to detect dropped updates
4. Consider single-session-per-key enforcement at the channel level

## Proof of Concept

```rust
#[tokio::test]
async fn test_session_key_collision_race() {
    use aptos_jwk_consensus::{
        jwk_manager::IssuerLevelConsensusManager,
        update_certifier::UpdateCertifier,
    };
    use aptos_types::jwks::{ProviderJWKs, jwk::JWKMoveStruct};
    
    // Setup manager with test configuration
    let manager = setup_test_manager();
    
    // Simulate rapid observations for same issuer
    let issuer = b"https://accounts.google.com".to_vec();
    let jwks_v1 = vec![JWKMoveStruct::new_unsupported_for_test()];
    let jwks_v2 = vec![JWKMoveStruct::new_unsupported_for_test()];
    
    // Start session 1 (version 1)
    manager.process_new_observation(issuer.clone(), jwks_v1.clone()).unwrap();
    
    // Immediately start session 2 (version 2) before session 1 completes
    // This aborts session 1 but it may still push its QC
    tokio::time::sleep(Duration::from_millis(10)).await;
    manager.process_new_observation(issuer.clone(), jwks_v2.clone()).unwrap();
    
    // Wait for both sessions to potentially complete
    tokio::time::sleep(Duration::from_millis(100)).await;
    
    // Check state - should have version 2, but due to race may have version 1
    let state = manager.states_by_issuer.get(&issuer).unwrap();
    match &state.consensus_state {
        ConsensusState::Finished { my_proposal, quorum_certified, .. } => {
            // BUG: my_proposal.version may be 2 but quorum_certified.version may be 1
            assert_eq!(
                my_proposal.observed.version,
                quorum_certified.update.version,
                "Version mismatch demonstrates the vulnerability"
            );
        }
        _ => panic!("Expected Finished state"),
    }
}
```

**Notes:**
- The vulnerability affects both PerIssuerMode and PerKeyMode consensus managers
- The race window depends on `rb.broadcast()` completion timing relative to abort signal propagation
- Production scenarios with frequent key rotations (security incidents, compliance requirements) significantly increase exploitation probability
- No special network access or validator privileges required—normal OIDC operations trigger this

### Citations

**File:** crates/aptos-jwk-consensus/src/mode/per_issuer.rs (L39-41)
```rust
    fn session_key_from_qc(qc: &QuorumCertifiedUpdate) -> anyhow::Result<Issuer> {
        Ok(qc.update.issuer.clone())
    }
```

**File:** crates/aptos-jwk-consensus/src/update_certifier.rs (L67-79)
```rust
        let task = async move {
            let qc_update = rb.broadcast(req, agg_state).await.expect("cannot fail");
            ConsensusMode::log_certify_done(epoch, &qc_update);
            let session_key = ConsensusMode::session_key_from_qc(&qc_update);
            match session_key {
                Ok(key) => {
                    let _ = qc_update_tx.push(key, qc_update);
                },
                Err(e) => {
                    error!("JWK update QCed but could not identify the session key: {e}");
                },
            }
        };
```

**File:** crates/channel/src/message_queues.rs (L112-152)
```rust
    pub(crate) fn push(&mut self, key: K, message: T) -> Option<T> {
        if let Some(c) = self.counters.as_ref() {
            c.with_label_values(&["enqueued"]).inc();
        }

        let key_message_queue = self
            .per_key_queue
            .entry(key.clone())
            // Only allocate a small initial queue for a new key. Previously, we
            // allocated a queue with all `max_queue_size_per_key` entries;
            // however, this breaks down when we have lots of transient peers.
            // For example, many of our queues have a max capacity of 1024. To
            // handle a single rpc from a transient peer, we would end up
            // allocating ~ 96 b * 1024 ~ 64 Kib per queue.
            .or_insert_with(|| VecDeque::with_capacity(1));

        // Add the key to our round-robin queue if it's not already there
        if key_message_queue.is_empty() {
            self.round_robin_queue.push_back(key);
        }

        // Push the message to the actual key message queue
        if key_message_queue.len() >= self.max_queue_size.get() {
            if let Some(c) = self.counters.as_ref() {
                c.with_label_values(&["dropped"]).inc();
            }
            match self.queue_style {
                // Drop the newest message for FIFO
                QueueStyle::FIFO => Some(message),
                // Drop the oldest message for LIFO
                QueueStyle::LIFO | QueueStyle::KLAST => {
                    let oldest = key_message_queue.pop_front();
                    key_message_queue.push_back(message);
                    oldest
                },
            }
        } else {
            key_message_queue.push_back(message);
            None
        }
    }
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager/mod.rs (L206-223)
```rust
            let abort_handle = self
                .update_certifier
                .start_produce(
                    self.epoch_state.clone(),
                    observed.clone(),
                    self.qc_update_tx.clone(),
                )
                .context(
                    "process_new_observation failed with update_certifier.start_produce failure",
                )?;
            state.consensus_state = ConsensusState::InProgress {
                my_proposal: ObservedUpdate {
                    author: self.my_addr,
                    observed: observed.clone(),
                    signature,
                },
                abort_handle_wrapper: QuorumCertProcessGuard::new(abort_handle),
            };
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager/mod.rs (L323-357)
```rust
    pub fn process_quorum_certified_update(&mut self, update: QuorumCertifiedUpdate) -> Result<()> {
        let issuer = update.update.issuer.clone();
        info!(
            epoch = self.epoch_state.epoch,
            issuer = String::from_utf8(issuer.clone()).ok(),
            version = update.update.version,
            "JWKManager processing certified update."
        );
        let state = self.states_by_issuer.entry(issuer.clone()).or_default();
        match &state.consensus_state {
            ConsensusState::InProgress { my_proposal, .. } => {
                //TODO: counters
                let txn = ValidatorTransaction::ObservedJWKUpdate(update.clone());
                let vtxn_guard =
                    self.vtxn_pool
                        .put(Topic::JWK_CONSENSUS(issuer.clone()), Arc::new(txn), None);
                state.consensus_state = ConsensusState::Finished {
                    vtxn_guard,
                    my_proposal: my_proposal.clone(),
                    quorum_certified: update.clone(),
                };
                info!(
                    epoch = self.epoch_state.epoch,
                    issuer = String::from_utf8(issuer).ok(),
                    version = update.update.version,
                    "certified update accepted."
                );
                Ok(())
            },
            _ => Err(anyhow!(
                "qc update not expected for issuer {:?} in state {}",
                String::from_utf8(issuer.clone()),
                state.consensus_state.name()
            )),
        }
```

**File:** crates/aptos-jwk-consensus/src/types.rs (L96-101)
```rust
impl Drop for QuorumCertProcessGuard {
    fn drop(&mut self) {
        let QuorumCertProcessGuard { handle } = self;
        handle.abort();
    }
}
```

**File:** crates/aptos-jwk-consensus/src/mode/per_key.rs (L59-64)
```rust
    fn session_key_from_qc(qc: &QuorumCertifiedUpdate) -> anyhow::Result<(Issuer, KID)> {
        let KeyLevelUpdate { issuer, kid, .. } =
            KeyLevelUpdate::try_from_issuer_level_repr(&qc.update)
                .context("session_key_from_qc failed with repr translation")?;
        Ok((issuer, kid))
    }
```
