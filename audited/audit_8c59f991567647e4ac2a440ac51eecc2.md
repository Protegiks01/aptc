# Audit Report

## Title
Quorum Store V2 Messages Silently Dropped Due to Unhandled Message Types in NetworkTask

## Summary
The `NetworkTask::start()` function's Event::Message handler does not match the V2 variants of quorum store messages (BatchMsgV2, SignedBatchInfoMsgV2, ProofOfStoreMsgV2), causing them to fall through to the default case where they are silently dropped with only a warning. This breaks quorum store functionality when V2 batches are enabled, leading to consensus liveness failures.

## Finding Description
The vulnerability exists in the message routing logic of the consensus network layer. The ConsensusMsg enum contains V2 variants for quorum store messages to support the extended BatchInfoExt type: [1](#0-0) 

However, the NetworkTask::start() function's Event::Message handler only matches the V1 variants: [2](#0-1) 

The V2 variants (BatchMsgV2, SignedBatchInfoMsgV2, ProofOfStoreMsgV2) are not included in this pattern match. When these messages are received, they fall through to the default case which simply logs a warning and drops the message: [3](#0-2) 

This is problematic because production code actively sends these V2 messages via broadcast when the enable_batch_v2 configuration flag is enabled: [4](#0-3) 

Similarly, V2 proof of store messages are sent when batches use the V2 format: [5](#0-4) 

And V2 signed batch info messages are sent when persisting V2 batches: [6](#0-5) 

The network sender implementations correctly broadcast these messages: [7](#0-6) [8](#0-7) [9](#0-8) 

**Attack Path**: This vulnerability bypasses all validation because the V2 messages never reach the quorum_store_messages_tx channel where they would be processed. When enable_batch_v2 is enabled:
1. Batch generator creates V2 batches and broadcasts BatchMsgV2
2. Receiving validators' NetworkTask receives these messages
3. Messages fail to match any pattern in Event::Message handler
4. Messages hit default case and are silently dropped
5. Validators never receive batch data, breaking quorum store protocol
6. Consensus cannot progress without functioning quorum store

## Impact Explanation
This is a **High Severity** vulnerability that causes significant protocol violations:

1. **Consensus Liveness Failure**: When V2 batches are enabled, validators cannot receive batch information, signed batch info, or proofs of store. This breaks the quorum store protocol which is critical for consensus operation, leading to inability to create or commit blocks.

2. **Protocol Violation**: The issue violates the consensus safety invariant that "all validators must be able to participate in the consensus protocol." Validators that enable V2 support effectively become unable to participate because they cannot exchange quorum store messages.

3. **Network Partition Risk**: If only some validators enable V2 support while others don't, this creates a de-facto network partition where V2-enabled nodes cannot communicate quorum store data with each other, potentially requiring intervention to restore.

This meets the High Severity criteria per the Aptos bug bounty program: "Validator node slowdowns" and "Significant protocol violations." While it doesn't directly cause fund loss, it breaks consensus liveness which is a critical system function.

## Likelihood Explanation
**Likelihood: High**

This vulnerability will automatically trigger whenever:
1. The `enable_batch_v2` configuration flag is enabled (which is the intended upgrade path)
2. Any validator creates V2 batches (checked via `batch_info().is_v2()`)

The issue is not an edge case but a systematic failure in the message routing code. Every V2 quorum store message sent will be silently dropped. This is highly likely to occur during:
- Testing of V2 batch support
- Gradual rollout of V2 batches
- Any environment where V2 is enabled

The code shows this is production-ready functionality (not experimental) with explicit configuration flags, making the likelihood of occurrence very high once V2 support is enabled.

## Recommendation
Add the V2 quorum store message variants to the pattern match in NetworkTask::start():

**Fix**: In `consensus/src/network.rs`, line 823, update the pattern to include V2 variants:

```rust
quorum_store_msg @ (ConsensusMsg::SignedBatchInfo(_)
| ConsensusMsg::BatchMsg(_)
| ConsensusMsg::ProofOfStoreMsg(_)
| ConsensusMsg::SignedBatchInfoMsgV2(_)
| ConsensusMsg::BatchMsgV2(_)
| ConsensusMsg::ProofOfStoreMsgV2(_)) => {
    Self::push_msg(
        peer_id,
        quorum_store_msg,
        &self.quorum_store_messages_tx,
    );
},
```

This ensures V2 messages are routed to the same quorum_store_messages channel as V1 messages, where they will be properly processed and validated by the quorum store subsystem.

## Proof of Concept
The vulnerability can be demonstrated by:

1. Enable V2 batch support in node configuration:
```rust
// In consensus config
config.enable_batch_v2 = true;
```

2. Start two validator nodes with this configuration

3. Observe logs showing "Unexpected direct send msg" warnings when V2 messages are received: [3](#0-2) 

4. Verify that quorum store metrics show no V2 batches being received despite being sent:
   - Check `counters::CONSENSUS_RECEIVED_MSGS` - will show messages received
   - Check quorum store processing metrics - will show zero V2 messages processed

5. Observe consensus unable to progress because validators cannot exchange batch data

The bug is deterministic and will occur 100% of the time when V2 messages are sent, making it trivial to reproduce by simply enabling the enable_batch_v2 configuration flag and monitoring network message handling.

### Citations

**File:** consensus/src/network_interface.rs (L97-102)
```rust
    BatchMsgV2(Box<BatchMsg<BatchInfoExt>>),
    /// Quorum Store: Send a signed batch digest with BatchInfoExt. This is a vote for the batch and a promise that
    /// the batch of transactions was received and will be persisted until batch expiration.
    SignedBatchInfoMsgV2(Box<SignedBatchInfoMsg<BatchInfoExt>>),
    /// Quorum Store: Broadcast a certified proof of store (a digest that received 2f+1 votes) with BatchInfoExt.
    ProofOfStoreMsgV2(Box<ProofOfStoreMsg<BatchInfoExt>>),
```

**File:** consensus/src/network.rs (L599-608)
```rust
    async fn send_signed_batch_info_msg_v2(
        &self,
        signed_batch_infos: Vec<SignedBatchInfo<BatchInfoExt>>,
        recipients: Vec<Author>,
    ) {
        fail_point!("consensus::send::signed_batch_info", |_| ());
        let msg = ConsensusMsg::SignedBatchInfoMsgV2(Box::new(SignedBatchInfoMsg::new(
            signed_batch_infos,
        )));
        self.send(msg, recipients).await
```

**File:** consensus/src/network.rs (L617-620)
```rust
    async fn broadcast_batch_msg_v2(&mut self, batches: Vec<Batch<BatchInfoExt>>) {
        fail_point!("consensus::send::broadcast_batch", |_| ());
        let msg = ConsensusMsg::BatchMsgV2(Box::new(BatchMsg::new(batches)));
        self.broadcast(msg).await
```

**File:** consensus/src/network.rs (L629-632)
```rust
    async fn broadcast_proof_of_store_msg_v2(&mut self, proofs: Vec<ProofOfStore<BatchInfoExt>>) {
        fail_point!("consensus::send::proof_of_store", |_| ());
        let msg = ConsensusMsg::ProofOfStoreMsgV2(Box::new(ProofOfStoreMsg::new(proofs)));
        self.broadcast(msg).await
```

**File:** consensus/src/network.rs (L823-830)
```rust
                        quorum_store_msg @ (ConsensusMsg::SignedBatchInfo(_)
                        | ConsensusMsg::BatchMsg(_)
                        | ConsensusMsg::ProofOfStoreMsg(_)) => {
                            Self::push_msg(
                                peer_id,
                                quorum_store_msg,
                                &self.quorum_store_messages_tx,
                            );
```

**File:** consensus/src/network.rs (L937-940)
```rust
                        _ => {
                            warn!(remote_peer = peer_id, "Unexpected direct send msg");
                            continue;
                        },
```

**File:** consensus/src/quorum_store/batch_generator.rs (L494-500)
```rust
                            if self.config.enable_batch_v2 {
                                network_sender.broadcast_batch_msg_v2(batches).await;
                            } else {
                                let batches = batches.into_iter().map(|batch| {
                                    batch.try_into().expect("Cannot send V2 batch with flag disabled")
                                }).collect();
                                network_sender.broadcast_batch_msg(batches).await;
```

**File:** consensus/src/quorum_store/proof_coordinator.rs (L485-493)
```rust
                                    if proofs_iter.peek().is_some_and(|p| p.info().is_v2()) {
                                        let proofs: Vec<_> = proofs_iter.collect();
                                        network_sender.broadcast_proof_of_store_msg_v2(proofs).await;
                                    } else {
                                        let proofs: Vec<_> = proofs_iter.map(|proof| {
                                            let (info, sig) = proof.unpack();
                                            ProofOfStore::new(info.info().clone(), sig)
                                        }).collect();
                                        network_sender.broadcast_proof_of_store_msg(proofs).await;
```

**File:** consensus/src/quorum_store/batch_coordinator.rs (L102-110)
```rust
            if persist_requests[0].batch_info().is_v2() {
                let signed_batch_infos = batch_store.persist(persist_requests);
                if !signed_batch_infos.is_empty() {
                    if approx_created_ts_usecs > 0 {
                        observe_batch(approx_created_ts_usecs, peer_id, BatchStage::SIGNED);
                    }
                    network_sender
                        .send_signed_batch_info_msg_v2(signed_batch_infos, vec![peer_id])
                        .await;
```
