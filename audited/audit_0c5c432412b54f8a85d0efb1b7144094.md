# Audit Report

## Title
State Sync Request Overwrite Vulnerability Causing Lost Consensus Notifications

## Summary
The `initialize_sync_duration_request()` function unconditionally replaces the active sync request without checking for or responding to existing pending requests. When consensus issues multiple sync requests (either duration or target based) in quick succession, earlier requests are silently dropped with their notification callbacks never being invoked, causing consensus to receive unexpected errors and potentially hang.

## Finding Description

The vulnerability exists in the state sync notification handler where sync requests are stored and managed. [1](#0-0) 

When consensus or consensus observer sends a sync request, it includes a oneshot channel callback that expects a response. [2](#0-1) 

The consensus component awaits this callback to know when the sync operation completes. [3](#0-2) 

**Attack Scenario:**

1. Consensus sends `sync_for_duration(duration1)` creating notification with `callback1`, then awaits the response
2. State sync receives it and calls `initialize_sync_duration_request()` which stores the request containing `callback1` in `self.consensus_sync_request`
3. **Before duration1 expires**, consensus sends another sync request (either `sync_for_duration(duration2)` or `sync_to_target()`) with `callback2`
4. State sync calls `initialize_sync_duration_request()` or `initialize_sync_target_request()` again
5. The function creates a **brand new** `Arc<Mutex<Option<ConsensusSyncRequest>>>` and **replaces** the old one entirely
6. The old Arc containing the first notification with `callback1` is dropped
7. When the oneshot sender (`callback1`) is dropped without being used, consensus receives a channel cancellation error on `callback_receiver1`
8. Consensus interprets this as an unexpected failure even though state sync is functioning normally [4](#0-3) 

The same issue exists in `initialize_sync_target_request()` - it also unconditionally replaces the sync request without handling the previous one.

When the sync request is eventually satisfied, only the **latest** notification gets a response. [5](#0-4) 

## Impact Explanation

This is a **High Severity** vulnerability according to Aptos bug bounty criteria:

- **Validator node slowdowns**: When consensus receives unexpected errors, it may retry, timeout, or enter error handling paths that slow down block production
- **Significant protocol violations**: Breaks the fundamental invariant that all consensus notifications must receive responses
- **Liveness impact**: Could cause consensus to hang or repeatedly fail sync operations, affecting the validator's ability to participate in consensus

The bug affects the critical path between consensus and state sync. When consensus cannot reliably synchronize state, it impacts the validator's ability to:
- Execute blocks correctly
- Participate in voting
- Maintain consistency with the network

While this doesn't directly cause safety violations (chain splits), it significantly impacts liveness and validator operations.

## Likelihood Explanation

**Moderate to High likelihood** during certain network conditions:

1. **Normal operation edge cases**: Consensus may legitimately issue a new sync request if:
   - Previous request is taking too long
   - Network conditions change requiring sync target adjustment
   - Consensus observer switches between targets

2. **Network instability**: During network partitions or slowdowns:
   - State sync may be delayed in satisfying requests
   - Consensus may timeout and issue new requests
   - Multiple rapid requests become more likely

3. **Epoch transitions**: During validator set changes or reconfigurations, multiple sync requests may occur

The vulnerability requires no malicious behavior - it's a protocol-level race condition that can occur during normal but suboptimal operating conditions.

## Recommendation

**Fix:** Check for existing sync requests and either reject the new request or properly respond to the old one before accepting the new one.

```rust
pub async fn initialize_sync_duration_request(
    &mut self,
    sync_duration_notification: ConsensusSyncDurationNotification,
) -> Result<(), Error> {
    // Check if there's already an active sync request
    let mut sync_request_lock = self.consensus_sync_request.lock();
    if let Some(existing_request) = sync_request_lock.take() {
        // Respond to the existing request with an error indicating it was superseded
        match existing_request {
            ConsensusSyncRequest::SyncDuration(_, old_notification) => {
                warn!("Existing sync duration request superseded by new request");
                let _ = self.respond_to_sync_duration_notification(
                    old_notification,
                    Err(Error::UnexpectedErrorEncountered(
                        "Sync request superseded by new request".into()
                    )),
                    None,
                );
            },
            ConsensusSyncRequest::SyncTarget(old_notification) => {
                warn!("Existing sync target request superseded by new sync duration request");
                let _ = self.respond_to_sync_target_notification(
                    old_notification,
                    Err(Error::UnexpectedErrorEncountered(
                        "Sync request superseded by new request".into()
                    )),
                );
            },
        }
    }
    drop(sync_request_lock);

    // Get the current time
    let start_time = self.time_service.now();

    // Save the new request
    let consensus_sync_request =
        ConsensusSyncRequest::new_with_duration(start_time, sync_duration_notification);
    *self.consensus_sync_request.lock() = Some(consensus_sync_request);

    Ok(())
}
```

Apply the same fix to `initialize_sync_target_request()`.

## Proof of Concept

```rust
#[tokio::test]
async fn test_multiple_sync_requests_lose_first_callback() {
    use aptos_consensus_notifications::{
        new_consensus_notifier_listener_pair, ConsensusNotificationSender,
    };
    use aptos_time_service::TimeService;
    use std::time::Duration;

    // Create consensus notifier and state sync handler
    let (consensus_notifier, consensus_listener) = 
        new_consensus_notifier_listener_pair(5000);
    let time_service = TimeService::mock();
    let mut handler = ConsensusNotificationHandler::new(
        consensus_listener,
        time_service.clone(),
    );

    // Send first sync request
    let notifier_clone = consensus_notifier.clone();
    let first_request = tokio::spawn(async move {
        notifier_clone.sync_for_duration(Duration::from_secs(10)).await
    });

    // Give it time to be received
    tokio::time::sleep(Duration::from_millis(100)).await;

    // Process the first notification
    if let Some(notification) = handler.select_next_some().now_or_never() {
        if let ConsensusNotification::SyncForDuration(sync_notif) = notification {
            // Initialize first sync request
            handler.initialize_sync_duration_request(sync_notif).await.unwrap();
        }
    }

    // Send second sync request BEFORE first completes
    let second_request = tokio::spawn(async move {
        consensus_notifier.sync_for_duration(Duration::from_secs(5)).await
    });

    // Give it time to be received
    tokio::time::sleep(Duration::from_millis(100)).await;

    // Process the second notification - this OVERWRITES the first
    if let Some(notification) = handler.select_next_some().now_or_never() {
        if let ConsensusNotification::SyncForDuration(sync_notif) = notification {
            handler.initialize_sync_duration_request(sync_notif).await.unwrap();
        }
    }

    // The first request will receive an error because its callback was dropped
    let first_result = first_request.await.unwrap();
    assert!(first_result.is_err(), "First request should fail with dropped callback");
    
    // This demonstrates the bug: consensus receives an error for the first request
    // even though state sync is functioning normally
}
```

**Notes**

This vulnerability specifically affects the consensus-state sync interface and validator operations. While it cannot be directly triggered by external attackers without validator access, it represents a significant protocol correctness issue that can occur during normal network conditions. The bug violates the critical invariant that all consensus notifications must receive proper responses, potentially causing validator slowdowns and liveness issues as classified in the High severity category of the Aptos bug bounty program.

### Citations

**File:** state-sync/state-sync-driver/src/notification_handlers.rs (L246-259)
```rust
    pub async fn initialize_sync_duration_request(
        &mut self,
        sync_duration_notification: ConsensusSyncDurationNotification,
    ) -> Result<(), Error> {
        // Get the current time
        let start_time = self.time_service.now();

        // Save the request so we can notify consensus once we've hit the duration
        let consensus_sync_request =
            ConsensusSyncRequest::new_with_duration(start_time, sync_duration_notification);
        self.consensus_sync_request = Arc::new(Mutex::new(Some(consensus_sync_request)));

        Ok(())
    }
```

**File:** state-sync/state-sync-driver/src/notification_handlers.rs (L261-318)
```rust
    /// Initializes the sync target request received from consensus
    pub async fn initialize_sync_target_request(
        &mut self,
        sync_target_notification: ConsensusSyncTargetNotification,
        latest_pre_committed_version: Version,
        latest_synced_ledger_info: LedgerInfoWithSignatures,
    ) -> Result<(), Error> {
        // Get the target sync version and latest committed version
        let sync_target_version = sync_target_notification
            .get_target()
            .ledger_info()
            .version();
        let latest_committed_version = latest_synced_ledger_info.ledger_info().version();

        // If the target version is old, return an error to consensus (something is wrong!)
        if sync_target_version < latest_committed_version
            || sync_target_version < latest_pre_committed_version
        {
            let error = Err(Error::OldSyncRequest(
                sync_target_version,
                latest_pre_committed_version,
                latest_committed_version,
            ));
            self.respond_to_sync_target_notification(sync_target_notification, error.clone())?;
            return error;
        }

        // If the committed version is at the target, return successfully
        if sync_target_version == latest_committed_version {
            info!(
                LogSchema::new(LogEntry::NotificationHandler).message(&format!(
                    "We're already at the requested sync target version: {} \
                (pre-committed version: {}, committed version: {})!",
                    sync_target_version, latest_pre_committed_version, latest_committed_version
                ))
            );
            let result = Ok(());
            self.respond_to_sync_target_notification(sync_target_notification, result.clone())?;
            return result;
        }

        // If the pre-committed version is already at the target, something has else gone wrong
        if sync_target_version == latest_pre_committed_version {
            let error = Err(Error::InvalidSyncRequest(
                sync_target_version,
                latest_pre_committed_version,
            ));
            self.respond_to_sync_target_notification(sync_target_notification, error.clone())?;
            return error;
        }

        // Save the request so we can notify consensus once we've hit the target
        let consensus_sync_request =
            ConsensusSyncRequest::new_with_target(sync_target_notification);
        self.consensus_sync_request = Arc::new(Mutex::new(Some(consensus_sync_request)));

        Ok(())
    }
```

**File:** state-sync/state-sync-driver/src/notification_handlers.rs (L322-365)
```rust
    pub async fn handle_satisfied_sync_request(
        &mut self,
        latest_synced_ledger_info: LedgerInfoWithSignatures,
    ) -> Result<(), Error> {
        // Remove the active sync request
        let mut sync_request_lock = self.consensus_sync_request.lock();
        let consensus_sync_request = sync_request_lock.take();

        // Notify consensus of the satisfied request
        match consensus_sync_request {
            Some(ConsensusSyncRequest::SyncDuration(_, sync_duration_notification)) => {
                self.respond_to_sync_duration_notification(
                    sync_duration_notification,
                    Ok(()),
                    Some(latest_synced_ledger_info),
                )?;
            },
            Some(ConsensusSyncRequest::SyncTarget(sync_target_notification)) => {
                // Get the sync target version and latest synced version
                let sync_target = sync_target_notification.get_target();
                let sync_target_version = sync_target.ledger_info().version();
                let latest_synced_version = latest_synced_ledger_info.ledger_info().version();

                // Check if we've synced beyond the target. If so, notify consensus with an error.
                if latest_synced_version > sync_target_version {
                    let error = Err(Error::SyncedBeyondTarget(
                        latest_synced_version,
                        sync_target_version,
                    ));
                    self.respond_to_sync_target_notification(
                        sync_target_notification,
                        error.clone(),
                    )?;
                    return error;
                }

                // Otherwise, notify consensus that the target has been reached
                self.respond_to_sync_target_notification(sync_target_notification, Ok(()))?;
            },
            None => { /* Nothing needs to be done */ },
        }

        Ok(())
    }
```

**File:** state-sync/inter-component/consensus-notifications/src/lib.rs (L140-179)
```rust
    async fn sync_for_duration(
        &self,
        duration: Duration,
    ) -> Result<LedgerInfoWithSignatures, Error> {
        // Create a consensus sync duration notification
        let (notification, callback_receiver) = ConsensusSyncDurationNotification::new(duration);
        let sync_duration_notification = ConsensusNotification::SyncForDuration(notification);

        // Send the notification to state sync
        if let Err(error) = self
            .notification_sender
            .clone()
            .send(sync_duration_notification)
            .await
        {
            return Err(Error::NotificationError(format!(
                "Failed to notify state sync of sync duration! Error: {:?}",
                error
            )));
        }

        // Process the response
        match callback_receiver.await {
            Ok(response) => match response.get_result() {
                Ok(_) => response.get_latest_synced_ledger_info().ok_or_else(|| {
                    Error::UnexpectedErrorEncountered(
                        "Sync for duration returned an empty latest synced ledger info!".into(),
                    )
                }),
                Err(error) => Err(Error::UnexpectedErrorEncountered(format!(
                    "Sync for duration returned an error: {:?}",
                    error
                ))),
            },
            Err(error) => Err(Error::UnexpectedErrorEncountered(format!(
                "Sync for duration failure: {:?}",
                error
            ))),
        }
    }
```

**File:** state-sync/inter-component/consensus-notifications/src/lib.rs (L361-379)
```rust
#[derive(Debug)]
pub struct ConsensusSyncDurationNotification {
    duration: Duration,
    callback: oneshot::Sender<ConsensusNotificationResponse>,
}

impl ConsensusSyncDurationNotification {
    pub fn new(duration: Duration) -> (Self, oneshot::Receiver<ConsensusNotificationResponse>) {
        let (callback, callback_receiver) = oneshot::channel();
        let notification = ConsensusSyncDurationNotification { duration, callback };

        (notification, callback_receiver)
    }

    /// Returns the duration of the notification
    pub fn get_duration(&self) -> Duration {
        self.duration
    }
}
```
