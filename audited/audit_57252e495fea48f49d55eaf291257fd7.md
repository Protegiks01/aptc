# Audit Report

## Title
Critical Consensus Algorithm Mismatch: Silent Fallback During OnChainConsensusConfig Deserialization Enables DAG/Jolteon Split

## Summary
Validators running different software versions can disagree on `is_dag_enabled()` during epoch transitions, causing some validators to run DAG consensus while others run Jolteon consensus. This occurs because the consensus config loading code silently falls back to a default configuration (with DAG disabled) when deserialization fails, without halting or preventing the epoch transition. The result is a fundamental consensus algorithm mismatch that causes complete network failure.

## Finding Description

The vulnerability exists in the epoch transition code path where validators load the on-chain consensus configuration. The critical flaw is at: [1](#0-0) 

When starting a new epoch, each validator attempts to deserialize `OnChainConsensusConfig` from the on-chain state. If deserialization fails (returns an `Err`), the code logs a warning but then silently falls back to the default configuration using `unwrap_or_default()`.

The default configuration is defined as: [2](#0-1) 

Which uses: [3](#0-2) 

This default configuration has `is_dag_enabled()` returning **false** (Jolteon mode): [4](#0-3) 

The critical branching point where validators select their consensus algorithm is: [5](#0-4) 

**Attack Scenario:**

1. **Initial State**: Network runs on OnChainConsensusConfig V4 with all validators on software version 1.x (supporting V1-V4 configs)

2. **Rolling Upgrade Begins**: Some validators upgrade to software version 2.x (supporting V1-V5 configs), while others remain on 1.x

3. **Governance Proposal**: A governance proposal updates the on-chain config to V5 with DAG enabled:
   ```
   OnChainConsensusConfig::V5 {
       alg: ConsensusAlgorithmConfig::DAG(DagConsensusConfigV1::default()),
       vtxn: ValidatorTxnConfig::default_disabled(),
       window_size: DEFAULT_WINDOW_SIZE,
       rand_check_enabled: true,
   }
   ```

4. **Epoch Transition Triggered**: The config change triggers a reconfiguration event and new epoch

5. **Divergent Deserialization**:
   - **Validators on version 2.x**: Successfully deserialize V5, extract `alg: DAG(...)`, `is_dag_enabled()` returns **true**
   - **Validators on version 1.x**: BCS deserialization fails (unknown enum variant V5), fall back to default config, `is_dag_enabled()` returns **false**

6. **Consensus Algorithm Split**:
   - Version 2.x validators execute `start_new_epoch_with_dag()` and run DAG consensus
   - Version 1.x validators execute `start_new_epoch_with_jolteon()` and run Jolteon consensus

7. **Complete Network Failure**:
   - DAG validators send DAG-specific messages (DAG certificates, anchor blocks)
   - Jolteon validators send Jolteon-specific messages (block proposals, votes)
   - Message formats and protocols are incompatible
   - Neither group can form quorum with the other
   - **Consensus halts, no new blocks are committed**

The on-chain config uses double BCS deserialization: [6](#0-5) 

When an older validator encounters an unknown enum variant (e.g., V5), BCS deserialization will fail and return an error. The error is consumed by `unwrap_or_default()` without preventing the epoch transition.

This same vulnerable pattern exists in multiple locations: [7](#0-6) [8](#0-7) 

## Impact Explanation

**Critical Severity** - This vulnerability meets multiple critical impact categories from the Aptos bug bounty:

1. **Consensus/Safety Violations**: Different validators run fundamentally incompatible consensus algorithms (DAG vs Jolteon), violating the consensus safety invariant that all honest validators must agree on block ordering.

2. **Total Loss of Liveness/Network Availability**: When validators split between DAG and Jolteon modes, neither group can achieve the required quorum (2f+1 votes). Block production halts completely. No transactions can be processed.

3. **Non-Recoverable Network Partition (Requires Hardfork)**: Recovery requires:
   - Emergency coordination among all validators
   - Manual config rollback or forced upgrade of all validators
   - Potentially a hardfork if the split persists for multiple epochs
   - Loss of validator rewards during downtime
   - Potential loss of finality if different groups commit different blocks

The vulnerability breaks the fundamental invariant: **"All validators must produce identical state roots for identical blocks"** - validators cannot even agree on what blocks to produce.

Unlike temporary network issues or Byzantine faults, this is a deterministic split caused by a code-level incompatibility that will persist until manual intervention.

## Likelihood Explanation

**High Likelihood** during rolling upgrades:

1. **Rolling Upgrades Are Standard Practice**: Major blockchain networks perform rolling upgrades to minimize downtime. Validators upgrade incrementally rather than all at once.

2. **Config Updates Are Normal Operations**: Governance proposals to modify consensus configurations (enabling new features like DAG) are legitimate operational procedures.

3. **Silent Failure Mode**: The vulnerability is particularly dangerous because:
   - No validator crashes or refuses to start
   - Only a warning is logged (easily missed in production logs)
   - Operators won't realize the split until block production stops
   - No pre-flight validation prevents the misconfiguration

4. **No Version Coordination**: The code does not verify that all validators support the proposed config version before allowing the upgrade to proceed.

5. **Unintentional Trigger**: This doesn't require malicious intent - a well-meaning governance participant could trigger this by proposing a V5 config update during a rolling upgrade, not realizing some validators haven't upgraded yet.

6. **Multiple Vulnerable Code Paths**: The same `unwrap_or_default()` pattern appears in consensus, consensus observer, and DKG epoch managers, increasing the attack surface.

## Recommendation

**Immediate Fix**: Replace silent fallback with explicit failure that prevents epoch transition when config deserialization fails.

```rust
// In consensus/src/epoch_manager.rs, replace lines 1178-1201 with:

let onchain_consensus_config: anyhow::Result<OnChainConsensusConfig> = payload.get();
let consensus_config = match onchain_consensus_config {
    Ok(config) => config,
    Err(error) => {
        error!(
            epoch = payload.epoch(),
            error = ?error,
            "CRITICAL: Failed to deserialize on-chain consensus config. \
             This validator may be running incompatible software. \
             Refusing to start epoch to prevent consensus split."
        );
        // Panic to prevent starting epoch with incompatible config
        panic!(
            "Failed to load consensus config for epoch {}: {}. \
             Upgrade your validator software before this epoch starts.",
            payload.epoch(),
            error
        );
    }
};
```

**Long-Term Solutions**:

1. **Pre-Flight Validation**: Before applying a config version upgrade, verify all validators in the active set support the new version:
   - Add validator software version to on-chain validator info
   - Governance proposals must check all validators support the proposed config version
   - Reject proposals that would cause version mismatches

2. **Explicit Version Signaling**: Add a version compatibility check in the reconfiguration flow:
   - Each validator advertises supported config versions
   - Config updates require 2f+1 validators to signal support
   - Automatic rollback if quorum cannot be achieved

3. **Graceful Degradation Path**: Instead of panicking, validators could:
   - Refuse to participate in consensus for that epoch
   - Enter "observer mode" until upgraded
   - Alert operators via monitoring systems

4. **Test Coverage**: Add integration tests for:
   - Mixed-version validator scenarios
   - Config deserialization failure handling
   - Epoch transitions during rolling upgrades

## Proof of Concept

```rust
// Proof of Concept demonstrating the vulnerability
// Place in consensus/src/epoch_manager_tests.rs

#[test]
fn test_consensus_config_version_mismatch_causes_dag_jolteon_split() {
    use aptos_types::on_chain_config::{
        ConsensusAlgorithmConfig, DagConsensusConfigV1, OnChainConsensusConfig,
        ValidatorTxnConfig, DEFAULT_WINDOW_SIZE,
    };
    use bcs;

    // Simulate V5 config with DAG enabled (as it would be stored on-chain)
    let v5_dag_config = OnChainConsensusConfig::V5 {
        alg: ConsensusAlgorithmConfig::DAG(DagConsensusConfigV1::default()),
        vtxn: ValidatorTxnConfig::default_disabled(),
        window_size: DEFAULT_WINDOW_SIZE,
        rand_check_enabled: true,
    };
    
    // Serialize to bytes (double-serialization as required by on-chain format)
    let inner_bytes = bcs::to_bytes(&v5_dag_config).unwrap();
    let outer_bytes = bcs::to_bytes(&inner_bytes).unwrap();

    // Validator with V5 support: Successfully deserializes
    let result_v5_validator: Result<OnChainConsensusConfig, _> = 
        OnChainConsensusConfig::deserialize_into_config(&outer_bytes);
    assert!(result_v5_validator.is_ok());
    let config_v5 = result_v5_validator.unwrap();
    assert!(config_v5.is_dag_enabled()); // TRUE - will run DAG consensus

    // Simulate older validator that only knows V1-V4 by attempting to 
    // deserialize and failing, then using default (as epoch_manager does)
    // In reality, the BCS deserialization would fail for unknown variant V5
    
    // Demonstrate the fallback behavior
    let config_old_validator = OnChainConsensusConfig::default();
    assert!(!config_old_validator.is_dag_enabled()); // FALSE - will run Jolteon

    // CRITICAL: Different validators now have different values for is_dag_enabled()!
    // This causes them to branch to different consensus implementations:
    // - if consensus_config.is_dag_enabled() => start_new_epoch_with_dag()
    // - else => start_new_epoch_with_jolteon()
    
    println!("VULNERABILITY DEMONSTRATED:");
    println!("  V5-capable validator: is_dag_enabled() = {}", config_v5.is_dag_enabled());
    println!("  V4-only validator:    is_dag_enabled() = {}", config_old_validator.is_dag_enabled());
    println!("  Result: CONSENSUS ALGORITHM MISMATCH - Network halt!");
}
```

**Notes:**

This vulnerability represents a critical design flaw in the epoch transition logic. The silent fallback mechanism was likely intended to provide resilience against missing configs, but it creates a catastrophic failure mode during version upgrades. The lack of explicit version compatibility checks allows the network to enter an unrecoverable split state.

The fix must be deployed before any V5 config upgrade is attempted, and should include comprehensive testing of rolling upgrade scenarios. Given the critical nature, all similar `unwrap_or_default()` patterns in epoch transition code should be audited and fixed.

### Citations

**File:** consensus/src/epoch_manager.rs (L1178-1201)
```rust
        let onchain_consensus_config: anyhow::Result<OnChainConsensusConfig> = payload.get();
        let onchain_execution_config: anyhow::Result<OnChainExecutionConfig> = payload.get();
        let onchain_randomness_config_seq_num: anyhow::Result<RandomnessConfigSeqNum> =
            payload.get();
        let randomness_config_move_struct: anyhow::Result<RandomnessConfigMoveStruct> =
            payload.get();
        let onchain_jwk_consensus_config: anyhow::Result<OnChainJWKConsensusConfig> = payload.get();
        let dkg_state = payload.get::<DKGState>();

        if let Err(error) = &onchain_consensus_config {
            warn!("Failed to read on-chain consensus config {}", error);
        }

        if let Err(error) = &onchain_execution_config {
            warn!("Failed to read on-chain execution config {}", error);
        }

        if let Err(error) = &randomness_config_move_struct {
            warn!("Failed to read on-chain randomness config {}", error);
        }

        self.epoch_state = Some(epoch_state.clone());

        let consensus_config = onchain_consensus_config.unwrap_or_default();
```

**File:** consensus/src/epoch_manager.rs (L1293-1329)
```rust
        if consensus_config.is_dag_enabled() {
            warn!("DAG doesn't support secret sharing");
            self.start_new_epoch_with_dag(
                epoch_state,
                loaded_consensus_key.clone(),
                consensus_config,
                execution_config,
                onchain_randomness_config,
                jwk_consensus_config,
                network_sender,
                payload_client,
                payload_manager,
                rand_config,
                fast_rand_config,
                rand_msg_rx,
                secret_share_manager_rx,
            )
            .await
        } else {
            self.start_new_epoch_with_jolteon(
                loaded_consensus_key.clone(),
                epoch_state,
                consensus_config,
                execution_config,
                onchain_randomness_config,
                jwk_consensus_config,
                network_sender,
                payload_client,
                payload_manager,
                rand_config,
                fast_rand_config,
                rand_msg_rx,
                secret_share_manager_rx,
            )
            .await
        }
    }
```

**File:** types/src/on_chain_config/consensus_config.rs (L46-52)
```rust
    pub fn default_if_missing() -> Self {
        Self::JolteonV2 {
            main: ConsensusConfigV1::default(),
            quorum_store_enabled: true,
            order_vote_enabled: false,
        }
    }
```

**File:** types/src/on_chain_config/consensus_config.rs (L77-83)
```rust
    pub fn is_dag_enabled(&self) -> bool {
        match self {
            ConsensusAlgorithmConfig::Jolteon { .. }
            | ConsensusAlgorithmConfig::JolteonV2 { .. } => false,
            ConsensusAlgorithmConfig::DAG(_) => true,
        }
    }
```

**File:** types/src/on_chain_config/consensus_config.rs (L443-451)
```rust
impl Default for OnChainConsensusConfig {
    fn default() -> Self {
        OnChainConsensusConfig::V4 {
            alg: ConsensusAlgorithmConfig::default_if_missing(),
            vtxn: ValidatorTxnConfig::default_if_missing(),
            window_size: DEFAULT_WINDOW_SIZE,
        }
    }
}
```

**File:** types/src/on_chain_config/consensus_config.rs (L464-469)
```rust
    fn deserialize_into_config(bytes: &[u8]) -> Result<Self> {
        let raw_bytes: Vec<u8> = bcs::from_bytes(bytes)?;
        bcs::from_bytes(&raw_bytes)
            .map_err(|e| format_err!("[on-chain config] Failed to deserialize into config: {}", e))
    }
}
```

**File:** consensus/src/consensus_observer/observer/epoch_state.rs (L157-166)
```rust
    let onchain_consensus_config: anyhow::Result<OnChainConsensusConfig> = on_chain_configs.get();
    if let Err(error) = &onchain_consensus_config {
        error!(
            LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                "Failed to read on-chain consensus config! Error: {:?}",
                error
            ))
        );
    }
    let consensus_config = onchain_consensus_config.unwrap_or_default();
```

**File:** dkg/src/epoch_manager.rs (L192-196)
```rust
        let onchain_consensus_config: anyhow::Result<OnChainConsensusConfig> = payload.get();
        if let Err(error) = &onchain_consensus_config {
            error!("Failed to read on-chain consensus config {}", error);
        }
        let consensus_config = onchain_consensus_config.unwrap_or_default();
```
