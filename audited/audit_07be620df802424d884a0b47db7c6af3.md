# Audit Report

## Title
Missing Security Audit Logging for Cryptographic Key Operations

## Summary
The `CryptoStorage` trait implementations in the Aptos secure storage module lack any security audit logging for critical cryptographic key operations (create, rotate, export, sign). This creates a significant forensic and incident response gap that violates key management best practices.

## Finding Description

The `CryptoStorage` trait defines critical cryptographic key management operations for Ed25519 keys. All implementations of this trait completely lack security audit logging: [1](#0-0) 

The `create_key` operation generates new cryptographic keys with no logging. [2](#0-1) 

The `rotate_key` operation performs key rotation without any audit trail. [3](#0-2) 

The `export_private_key` operation exposes private key material with no logging - a critical security gap. [4](#0-3) 

The `sign` operation performs cryptographic signing without logging.

The production `VaultStorage` implementation also lacks logging: [5](#0-4) [6](#0-5) [7](#0-6) 

These operations are used for security-critical purposes including network identity keys: [8](#0-7) 

The codebase provides security event logging infrastructure that should be used: [9](#0-8) 

The secure coding guidelines explicitly reference OWASP Key Management best practices requiring lifecycle tracking: [10](#0-9) 

## Impact Explanation

This issue qualifies as **Medium severity** per the audit scope marking. While it doesn't directly enable consensus breaks or fund theft, it creates significant security operational risks:

1. **Undetectable Key Compromise**: If an attacker gains access to the storage backend, they can export private keys without leaving any audit trail
2. **Insider Threat Blindness**: Malicious insiders can perform unauthorized key operations undetected
3. **Forensic Analysis Impossible**: After a security incident, investigators cannot determine what key operations occurred
4. **Compliance Violation**: Fails OWASP Key Management Cheat Sheet requirements for lifecycle tracking

However, this does NOT directly break critical invariants like consensus safety or deterministic execution, limiting its severity.

## Likelihood Explanation

This issue affects **all deployments** using the secure storage module (100% occurrence rate). However, exploitation requires:
- Pre-existing access to the storage backend or node
- Insider threat or prior system compromise

It's not directly exploitable by external attackers but significantly impairs detection and response capabilities when breaches do occur.

## Recommendation

Add structured security audit logging to all cryptographic operations using the existing `aptos-logger` infrastructure. Critical: ensure logs contain operation metadata (timestamp, key name, operation type) but NEVER log sensitive key material.

Recommended implementation approach:
1. Import `aptos_logger::{info, warn, SecurityEvent}`
2. Add logging calls to each operation in trait implementations
3. Log: operation type, key name, timestamp, success/failure
4. Never log: private keys, signatures, or cryptographic material

Example pattern for `create_key`:
```rust
info!(
    "key_operation" = "create",
    "key_name" = name,
    "timestamp" = time_service.now_secs(),
);
```

## Proof of Concept

The vulnerability can be demonstrated by examining the absence of logging:

1. Create a new `InMemoryStorage` instance
2. Call `create_key("test_key")`  
3. Call `rotate_key("test_key")`
4. Call `export_private_key("test_key")`
5. Call `sign("test_key", message)`
6. Examine logs: NO security events are recorded

This can be verified by adding trace instrumentation to the test suite in: [11](#0-10) 

Run the existing test suite and confirm zero security audit events are emitted despite numerous cryptographic operations being performed.

## Notes

This finding addresses a security observability and defense-in-depth gap rather than a directly exploitable code vulnerability. While it meets the audit question's scope (marked as Medium), it represents a **security posture weakness** that enables other attacks to operate undetected rather than being an exploit vector itself. The lack of logging violates industry best practices but does not directly compromise consensus, execution determinism, or state consistency - the core critical invariants of the Aptos blockchain.

### Citations

**File:** secure/storage/src/crypto_kv_storage.rs (L19-24)
```rust
    fn create_key(&mut self, name: &str) -> Result<Ed25519PublicKey, Error> {
        // Generate and store the new named key pair
        let (private_key, public_key) = new_ed25519_key_pair();
        self.import_private_key(name, private_key)?;
        Ok(public_key)
    }
```

**File:** secure/storage/src/crypto_kv_storage.rs (L26-28)
```rust
    fn export_private_key(&self, name: &str) -> Result<Ed25519PrivateKey, Error> {
        self.get(name).map(|v| v.value)
    }
```

**File:** secure/storage/src/crypto_kv_storage.rs (L80-86)
```rust
    fn rotate_key(&mut self, name: &str) -> Result<Ed25519PublicKey, Error> {
        let private_key: Ed25519PrivateKey = self.get(name)?.value;
        let (new_private_key, new_public_key) = new_ed25519_key_pair();
        self.set(&get_previous_version_name(name), private_key)?;
        self.set(name, new_private_key)?;
        Ok(new_public_key)
    }
```

**File:** secure/storage/src/crypto_kv_storage.rs (L88-97)
```rust
    fn sign<U: CryptoHash + Serialize>(
        &self,
        name: &str,
        message: &U,
    ) -> Result<Ed25519Signature, Error> {
        let private_key = self.export_private_key(name)?;
        private_key
            .sign(message)
            .map_err(|err| Error::SerializationError(err.to_string()))
    }
```

**File:** secure/storage/src/vault.rs (L194-204)
```rust
    fn create_key(&mut self, name: &str) -> Result<Ed25519PublicKey, Error> {
        let ns_name = self.crypto_name(name);
        match self.get_public_key(name) {
            Ok(_) => return Err(Error::KeyAlreadyExists(ns_name)),
            Err(Error::KeyNotSet(_)) => (/* Expected this for new keys! */),
            Err(e) => return Err(e),
        }

        self.client().create_ed25519_key(&ns_name, true)?;
        self.get_public_key(name).map(|v| v.public_key)
    }
```

**File:** secure/storage/src/vault.rs (L206-209)
```rust
    fn export_private_key(&self, name: &str) -> Result<Ed25519PrivateKey, Error> {
        let name = self.crypto_name(name);
        Ok(self.client().export_ed25519_key(&name, None)?)
    }
```

**File:** secure/storage/src/vault.rs (L268-272)
```rust
    fn rotate_key(&mut self, name: &str) -> Result<Ed25519PublicKey, Error> {
        let ns_name = self.crypto_name(name);
        self.client().rotate_key(&ns_name)?;
        Ok(self.client().trim_key_versions(&ns_name)?)
    }
```

**File:** config/src/config/network_config.rs (L187-206)
```rust
    pub fn identity_key(&self) -> x25519::PrivateKey {
        let key = match &self.identity {
            Identity::FromConfig(config) => Some(config.key.private_key()),
            Identity::FromStorage(config) => {
                let storage: Storage = (&config.backend).into();
                let key = storage
                    .export_private_key(&config.key_name)
                    .expect("Unable to read key");
                let key = x25519::PrivateKey::from_ed25519_private_bytes(&key.to_bytes())
                    .expect("Unable to convert key");
                Some(key)
            },
            Identity::FromFile(config) => {
                let identity_blob: IdentityBlob = IdentityBlob::from_file(&config.path).unwrap();
                Some(identity_blob.network_private_key)
            },
            Identity::None => None,
        };
        key.expect("identity key should be present")
    }
```

**File:** crates/aptos-logger/src/security.rs (L23-88)
```rust
#[derive(Clone, Copy, Debug, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum SecurityEvent {
    //
    // Mempool
    //
    /// Mempool received a transaction from another peer with an invalid signature
    InvalidTransactionMempool,

    /// Mempool received an invalid network event
    InvalidNetworkEventMempool,

    // Consensus
    // ---------
    /// Consensus received an invalid message (not well-formed, invalid vote data or incorrect signature)
    ConsensusInvalidMessage,

    /// Consensus received an equivocating vote
    ConsensusEquivocatingVote,

    /// Consensus received an equivocating order vote
    ConsensusEquivocatingOrderVote,

    /// Consensus received an invalid proposal
    InvalidConsensusProposal,

    /// Consensus received an invalid new round message
    InvalidConsensusRound,

    /// Consensus received an invalid sync info message
    InvalidSyncInfoMsg,

    /// A received block is invalid
    InvalidRetrievedBlock,

    /// A block being committed or executed is invalid
    InvalidBlock,

    // State-Sync
    // ----------
    /// Invalid chunk of transactions received
    StateSyncInvalidChunk,

    // Health Checker
    // --------------
    /// HealthChecker received an invalid network event
    InvalidNetworkEventHC,

    /// HealthChecker received an invalid message
    InvalidHealthCheckerMsg,

    // Network
    // -------
    /// Network received an invalid message from a remote peer
    InvalidNetworkEvent,

    /// A failed noise handshake that's either a clear bug or indicates some
    /// security issue.
    NoiseHandshake,
}

impl Schema for SecurityEvent {
    fn visit(&self, visitor: &mut dyn Visitor) {
        visitor.visit_pair(Key::new("security-event"), Value::from_serde(self))
    }
}
```

**File:** RUST_SECURE_CODING.md (L139-141)
```markdown
### Cryptographic Material Management

Adhere strictly to established protocols for generating, storing, and managing cryptographic keys. This includes using secure random sources for key generation, ensuring keys are stored in protected environments, and implementing robust management practices to handle key lifecycle events like rotation and revocation [Key Management Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Key_Management_Cheat_Sheet.html).
```

**File:** secure/storage/src/tests/suite.rs (L1-50)
```rust
// Copyright (c) Aptos Foundation
// Licensed pursuant to the Innovation-Enabling Source Code License, available at https://github.com/aptos-labs/aptos-core/blob/main/LICENSE

use crate::{CryptoStorage, Error, KVStorage, Storage};
use aptos_crypto::{
    ed25519::Ed25519PrivateKey, test_utils::TestAptosCrypto, HashValue, PrivateKey, Signature,
    Uniform,
};

/// This suite contains tests for secure storage backends. We test the correct functionality
/// of both key/value and cryptographic operations for storage implementations. All storage backend
/// implementations should be tested using the tests in this suite.

/// This holds the canonical list of secure storage tests. It allows different callers
/// of the test suite to ensure they're executing all tests.
/// Note: this is required because: (i) vault tests cannot be run in the usual fashion (i.e., vault
/// tests rely on first running the vault docker script in `docker/testutils/start_vault_container.sh`); and (ii) vault
/// tests cannot currently be run in parallel, as each test uses the same vault instance.
const STORAGE_TESTS: &[fn(&mut Storage)] = &[
    test_set_reset_get,
    test_create_and_get_non_existent_version,
    test_create_get_key_pair,
    test_create_key_pair_and_perform_rotations,
    test_create_sign_rotate_sign,
    test_ensure_storage_is_available,
    test_get_non_existent,
    test_get_public_key_previous_version,
    test_get_set,
    test_get_uncreated_key_pair,
    test_hash_value,
    test_incremental_timestamp,
    test_import_key,
    test_verify_incorrect_value_types,
];

/// Storage data constants for testing purposes.
const CRYPTO_KEY: &str = "Private_Key";
const U64_KEY: &str = "U64_Key";
const CRYPTO_NAME: &str = "Test_Key_Name";

/// Executes all storage tests on a given storage backend.
pub fn execute_all_storage_tests(storage: &mut Storage) {
    storage.reset_and_clear().unwrap();
    for test in STORAGE_TESTS.iter() {
        test(storage);
        storage.reset_and_clear().unwrap();
    }
}

/// This test tries to set a key, reset the storage and then retrieve its
```
