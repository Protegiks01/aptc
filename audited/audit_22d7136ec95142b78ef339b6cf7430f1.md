# Audit Report

## Title
Epoch-Based Staleness Check Allows Acceptance of Stale LedgerInfo Proofs, Violating Version Monotonicity and Enabling Consensus Safety Breaks

## Summary
The `Verifier` trait has inconsistent `is_ledger_info_stale()` implementations: `EpochState` checks only epoch while `Waypoint` checks version. When `EpochChangeProof::verify()` is called with an `EpochState` verifier (as done in `EpochManager::initiate_new_epoch()`), an attacker can bypass staleness validation by providing proofs with newer epochs but older versions, violating the fundamental blockchain invariant that versions must be monotonically increasing. This enables consensus safety violations and potential chain forks.

## Finding Description

The vulnerability stems from an inconsistency in how different `Verifier` implementations determine if a `LedgerInfo` is stale:

**EpochState implementation** [1](#0-0) 

This only checks if the ledger info's epoch is less than the verifier's epoch, completely ignoring the version field.

**Waypoint implementation** [2](#0-1) 

This checks if the ledger info's version is less than the waypoint's version.

**The vulnerability is triggered in EpochChangeProof::verify()** [3](#0-2) 

At lines 72-76, the code checks if the LAST ledger info in the proof is stale. When the verifier is an `EpochState`, this only validates the epoch, not the version.

**Critical usage in consensus layer** [4](#0-3) 

The `EpochManager::initiate_new_epoch()` function calls `proof.verify(self.epoch_state())` where `self.epoch_state()` returns an `EpochState` [5](#0-4) 

**Attack path:**

1. Attacker observes validator node is at epoch 6, version 200
2. Validator receives epoch change notification and updates to epoch 7, version 250
3. Attacker crafts malicious `EpochChangeProof` containing:
   - LedgerInfo A: epoch 6, version 150 (end-of-epoch, validly signed by epoch 6 validators from historical data)
   - LedgerInfo B: epoch 7, version 170 (validly signed by epoch 7 validators from historical data)
4. Attacker sends this proof via network message [6](#0-5) 

**Exploitation steps:**

1. Line 72-76 check: `!verifier.is_ledger_info_stale(LedgerInfo B)` where verifier is at epoch 7
   - `is_ledger_info_stale()` checks: `7 < 7` → FALSE (not stale)
   - **BUT** version 170 < 250, so it IS actually stale!

2. Line 102-104: skip_while stale ledger infos
   - Check LedgerInfo A: `6 < 7` → TRUE (skipped)
   - Actually processes LedgerInfo B

3. Verification succeeds with stale version 170, violating monotonicity

4. The execution client sync at line 558-565 will either:
   - Reject it (causing validator panic per line 557 comment) → Denial of Service
   - Accept it (if state sync has similar bug) → Consensus fork

## Impact Explanation

**Critical Severity** - This vulnerability enables:

1. **Consensus Safety Violation**: Validators can be forced to accept stale state, causing them to diverge from honest nodes and creating chain forks. This directly violates the "Consensus Safety" invariant that "AptosBFT must prevent double-spending and chain splits under < 1/3 Byzantine."

2. **Version Monotonicity Violation**: The fundamental blockchain invariant that transaction versions must monotonically increase is broken. A validator at version 250 can be rewound to version 170.

3. **Validator DoS**: If the state sync layer correctly rejects the stale version, the validator will panic (per the code comment expecting sync to always succeed), causing immediate denial of service.

4. **Network Partition Risk**: If multiple validators are targeted simultaneously with different stale proofs, the network could fragment into incompatible states requiring a hard fork to recover.

This meets the Critical Severity criteria: "Consensus/Safety violations" and potentially "Non-recoverable network partition (requires hardfork)".

## Likelihood Explanation

**High Likelihood:**

1. **No special privileges required**: Any network peer can send `ConsensusMsg::EpochChangeProof` messages to validator nodes.

2. **Historical data is public**: Valid ledger infos with proper signatures from past epochs are publicly available on-chain and can be replayed.

3. **Common operation**: Epoch changes happen regularly in Aptos (every few hours typically), providing frequent attack windows.

4. **Automatic triggering**: The vulnerable code path executes automatically when receiving epoch change messages [7](#0-6) 

5. **No cryptographic breaking required**: Attack uses validly signed historical data, not forged signatures.

The only barrier is the epoch check at line 1663 requiring `msg_epoch == self.epoch()`, but this is easily satisfied by the attacker who can observe the target's current epoch through public APIs.

## Recommendation

**Immediate Fix**: Make `EpochState::is_ledger_info_stale()` check both epoch AND version by storing the last seen version in `EpochState`:

```rust
// In types/src/epoch_state.rs
pub struct EpochState {
    pub epoch: u64,
    pub verifier: Arc<ValidatorVerifier>,
    pub version: Version,  // ADD THIS FIELD
}

impl Verifier for EpochState {
    fn is_ledger_info_stale(&self, ledger_info: &LedgerInfo) -> bool {
        // Check BOTH epoch and version
        ledger_info.epoch() < self.epoch || 
        (ledger_info.epoch() == self.epoch && ledger_info.version() <= self.version)
    }
}
```

**Additional safeguards:**

1. Add explicit version checks in `EpochChangeProof::verify()` before line 76:
```rust
ensure!(
    self.ledger_info_with_sigs.last().unwrap().ledger_info().version() > 
        verifier.version(), // Add version() method to Verifier trait
    "The EpochChangeProof has stale version"
);
```

2. Store version in `EpochManager` and validate before accepting proofs.

3. Add version validation in state sync to gracefully reject stale proofs instead of panicking.

## Proof of Concept

```rust
// Test demonstrating the vulnerability
#[test]
fn test_stale_version_accepted_with_epoch_state() {
    use crate::{
        epoch_change::EpochChangeProof,
        epoch_state::EpochState,
        ledger_info::LedgerInfoWithSignatures,
        validator_verifier::random_validator_verifier,
        block_info::BlockInfo,
        ledger_info::LedgerInfo,
    };
    use aptos_crypto::hash::HashValue;
    use std::sync::Arc;

    // Validator is at epoch 6, version 200
    let (_, verifier_epoch6) = random_validator_verifier(6, None, true);
    let current_epoch_state = EpochState {
        epoch: 6,
        verifier: Arc::new(verifier_epoch6.clone()),
    };

    // Create stale but valid epoch change proof
    // LedgerInfo at epoch 6, version 150 (STALE - older than current 200)
    let (signers_epoch6, _) = random_validator_verifier(6, None, true);
    let (_, verifier_epoch7) = random_validator_verifier(7, None, true);
    
    let epoch6_to_7 = LedgerInfo::new(
        BlockInfo::new(
            6, // epoch
            0,
            HashValue::zero(),
            HashValue::zero(),
            150, // version - STALE!
            0,
            Some(EpochState {
                epoch: 7,
                verifier: Arc::new(verifier_epoch7.clone()),
            }),
        ),
        HashValue::zero(),
    );

    let partial_sigs = signers_epoch6
        .iter()
        .map(|s| (s.author(), s.sign(&epoch6_to_7).unwrap()))
        .collect();
    
    let agg_sig = verifier_epoch6
        .aggregate_signatures(&partial_sigs)
        .unwrap();

    let ledger_info_with_sigs = LedgerInfoWithSignatures::new(
        epoch6_to_7,
        agg_sig,
    );

    let proof = EpochChangeProof::new(vec![ledger_info_with_sigs], false);

    // This SHOULD fail because version 150 < 200
    // But it succeeds due to epoch-only staleness check!
    let result = proof.verify(&current_epoch_state);
    
    // Currently passes (BUG!) - should fail
    assert!(result.is_ok(), "Stale proof was accepted!");
}
```

**Notes**

This vulnerability represents a fundamental design flaw in the staleness checking logic. The `Verifier` trait abstraction hides the fact that different implementations have incompatible notions of "staleness" - epoch-based vs. version-based. When `EpochState` is used as a verifier in security-critical consensus code paths, it fails to enforce the version monotonicity invariant that is essential for blockchain safety. The issue is exacerbated because historical ledger infos with valid signatures exist on-chain and can be weaponized without any cryptographic attacks. This is a textbook example of an abstraction violation leading to a consensus-layer vulnerability.

### Citations

**File:** types/src/epoch_state.rs (L56-58)
```rust
    fn is_ledger_info_stale(&self, ledger_info: &LedgerInfo) -> bool {
        ledger_info.epoch() < self.epoch
    }
```

**File:** types/src/waypoint.rs (L91-93)
```rust
    fn is_ledger_info_stale(&self, ledger_info: &LedgerInfo) -> bool {
        ledger_info.version() < self.version()
    }
```

**File:** types/src/epoch_change.rs (L66-76)
```rust
    pub fn verify(&self, verifier: &dyn Verifier) -> Result<&LedgerInfoWithSignatures> {
        ensure!(
            !self.ledger_info_with_sigs.is_empty(),
            "The EpochChangeProof is empty"
        );
        ensure!(
            !verifier
                .is_ledger_info_stale(self.ledger_info_with_sigs.last().unwrap().ledger_info()),
            "The EpochChangeProof is stale as our verifier is already ahead \
             of the entire EpochChangeProof"
        );
```

**File:** consensus/src/epoch_manager.rs (L263-267)
```rust
    fn epoch_state(&self) -> &EpochState {
        self.epoch_state
            .as_ref()
            .expect("EpochManager not started yet")
    }
```

**File:** consensus/src/epoch_manager.rs (L544-547)
```rust
    async fn initiate_new_epoch(&mut self, proof: EpochChangeProof) -> anyhow::Result<()> {
        let ledger_info = proof
            .verify(self.epoch_state())
            .context("[EpochManager] Invalid EpochChangeProof")?;
```

**File:** consensus/src/epoch_manager.rs (L1655-1664)
```rust
            ConsensusMsg::EpochChangeProof(proof) => {
                let msg_epoch = proof.epoch()?;
                debug!(
                    LogSchema::new(LogEvent::ReceiveEpochChangeProof)
                        .remote_peer(peer_id)
                        .epoch(self.epoch()),
                    "Proof from epoch {}", msg_epoch,
                );
                if msg_epoch == self.epoch() {
                    monitor!("process_epoch_proof", self.initiate_new_epoch(*proof).await)?;
```
