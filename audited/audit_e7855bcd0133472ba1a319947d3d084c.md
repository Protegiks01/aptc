# Audit Report

## Title
Consensus Safety Violation via Optimistic Signature Verification Bypass in CommitVote Processing

## Summary
A critical vulnerability in the consensus pipeline allows a malicious validator to inject CommitVotes with signatures valid for manipulated LedgerInfo fields (specifically `consensus_data_hash`) that differ from the canonical LedgerInfo, bypassing signature verification in the aggregation process and creating invalid commit proofs that violate consensus safety guarantees.

## Finding Description

The vulnerability exists in the interaction between three components:

**1. Signature Verification Logic**

When a `CommitVote` is received, it undergoes verification where the signature is checked against the `LedgerInfo` contained **within the vote itself**: [1](#0-0) 

This verification uses `optimistic_verify`, which marks the signature as verified if it passes: [2](#0-1) 

**2. Vote Acceptance Logic**

When adding signatures to the aggregator in `Executed` or `Signed` buffer states, the code only validates that the `commit_info` matches, **not the full LedgerInfo**: [3](#0-2) [4](#0-3) 

Since `LedgerInfo` contains both `commit_info` (BlockInfo) and `consensus_data_hash`, a malicious validator can create a CommitVote with the correct `commit_info` but a manipulated `consensus_data_hash`.

**3. Invalid Signature Filtering Bypass**

When `aggregate_and_verify` fails due to mismatched signatures, `filter_invalid_signatures` is called to remove bad signatures. However, it has a critical flaw: [5](#0-4) 

At line 298, signatures already marked as "verified" are **not re-verified** against the current message. Since the malicious signature was verified against a different LedgerInfo (with wrong `consensus_data_hash`) but shares the verification status via `Arc<AtomicBool>`, it passes this check.

**4. Unverified Aggregation**

After filtering, `aggregate_and_verify` creates a new aggregated signature without verification: [6](#0-5) 

At line 532, `try_aggregate` creates an aggregated signature including the invalid signature, and line 533 returns `Ok()` **without verifying** the new aggregated signature.

**Attack Path:**

1. Malicious validator creates `LedgerInfo_malicious = LedgerInfo(commit_info=X, consensus_data_hash=EVIL_HASH)` where `EVIL_HASH ≠ CORRECT_HASH`
2. Malicious validator signs `LedgerInfo_malicious` and sends `CommitVote(ledger_info=LedgerInfo_malicious, signature)`
3. Honest node verifies signature against `LedgerInfo_malicious` → succeeds, marks `is_verified() = true`
4. Honest node's `add_signature_if_matched` checks only `commit_info` → matches, adds signature to `SignatureAggregator` containing `LedgerInfo_correct`
5. `aggregate_and_verify` aggregates signatures for different LedgerInfos → verification fails
6. `filter_invalid_signatures` keeps malicious signature because `is_verified() == true`
7. `try_aggregate` creates invalid aggregated signature → returns `Ok()` without verification
8. Invalid `LedgerInfoWithSignatures` is created and advanced to `Aggregated` state
9. Invalid commit proof is persisted and potentially broadcast

## Impact Explanation

This vulnerability constitutes a **Critical** severity consensus safety violation:

**Consensus Safety Violation**: The fundamental invariant that all honest validators agree on the same commit proof is broken. A node creates and accepts a commit proof with an invalid aggregated signature, believing it to be valid.

**Network Disruption**: When the invalid commit proof is broadcast to other validators or consensus observers, they will reject it upon verification, causing consensus disruption and potential liveness failures.

**State Divergence Risk**: If multiple nodes independently create different invalid commit proofs, the network could experience state divergence requiring manual intervention or hard fork to resolve.

**Bypasses BFT Guarantees**: The attack succeeds with a single Byzantine validator, undermining the safety guarantees of the BFT consensus protocol.

This meets the **Critical Severity** criteria: "Consensus/Safety violations" worth up to $1,000,000 in the Aptos Bug Bounty program.

## Likelihood Explanation

**Likelihood: High**

- **Attacker Requirements**: A single malicious validator with standard consensus participation capabilities
- **Complexity**: Low - the attacker simply signs a different `consensus_data_hash` value
- **Detection**: Low probability of detection before impact, as the malicious vote passes signature verification
- **Reproducibility**: Deterministic - the vulnerability triggers reliably when the conditions are met

The attack does not require:
- Collusion between validators
- Stake majority
- Network-level attacks
- Exploitation of timing windows

## Recommendation

**Fix 1: Re-verify signatures in filter_invalid_signatures**

Modify `filter_invalid_signatures` to always verify signatures against the current message, regardless of verification status:

```rust
pub fn filter_invalid_signatures<T: Send + Sync + Serialize + CryptoHash>(
    &self,
    message: &T,
    signatures: BTreeMap<AccountAddress, SignatureWithStatus>,
) -> BTreeMap<AccountAddress, SignatureWithStatus> {
    signatures
        .into_iter()
        .collect_vec()
        .into_par_iter()
        .with_min_len(4)
        .filter_map(|(account_address, signature)| {
            // REMOVED: if signature.is_verified() ||
            if self
                .verify(account_address, message, signature.signature())
                .is_ok()
            {
                signature.set_verified();
                Some((account_address, signature))
            } else {
                self.add_pessimistic_verify_set(account_address);
                None
            }
        })
        .collect()
}
```

**Fix 2: Verify full LedgerInfo in add_signature_if_matched**

Modify `add_signature_if_matched` to verify the complete `LedgerInfo` matches, not just `commit_info`:

```rust
Self::Executed(executed) => {
    // Compare full LedgerInfo, not just commit_info
    if executed.partial_commit_proof.data() == vote.ledger_info() {
        executed
            .partial_commit_proof
            .add_signature(author, signature);
        return Ok(());
    }
},
```

**Fix 3: Verify aggregated signature before returning**

Add verification after line 532 in `aggregate_and_verify`:

```rust
Err(_) => {
    self.filter_invalid_signatures(verifier);
    let aggregated_sig = self.try_aggregate(verifier)?;
    // ADD: Verify before returning
    verifier.verify_multi_signatures(&self.data, &aggregated_sig)?;
    Ok((self.data.clone(), aggregated_sig))
},
```

**Recommended approach**: Implement all three fixes for defense in depth.

## Proof of Concept

```rust
// Rust test demonstrating the vulnerability
#[test]
fn test_consensus_data_hash_manipulation() {
    use aptos_types::{
        block_info::BlockInfo,
        ledger_info::LedgerInfo,
        validator_verifier::ValidatorVerifier,
    };
    use aptos_crypto::{bls12381::Signature, HashValue};
    use aptos_consensus_types::pipeline::commit_vote::CommitVote;
    
    // Setup: 4 validators
    let (validator_signers, validator_verifier) = 
        random_validator_verifier(4, None, true);
    
    // Create commit_info
    let commit_info = BlockInfo::new(
        1, // epoch
        10, // round
        HashValue::random(),
        HashValue::random(),
        100, // version
        1000000, // timestamp
        None,
    );
    
    // Honest nodes expect this LedgerInfo
    let correct_ledger_info = LedgerInfo::new(
        commit_info.clone(),
        HashValue::zero(), // correct consensus_data_hash
    );
    
    // Malicious validator creates different LedgerInfo
    let malicious_ledger_info = LedgerInfo::new(
        commit_info.clone(),
        HashValue::random(), // MANIPULATED consensus_data_hash
    );
    
    // Malicious validator signs the manipulated LedgerInfo
    let malicious_sig = validator_signers[0]
        .sign(&malicious_ledger_info)
        .unwrap();
    
    // Create CommitVote with manipulated LedgerInfo but valid signature
    let malicious_vote = CommitVote::new_with_signature(
        validator_signers[0].author(),
        malicious_ledger_info, // Wrong LedgerInfo
        malicious_sig,
    );
    
    // Verify against the vote's own LedgerInfo - PASSES
    assert!(malicious_vote
        .verify(validator_signers[0].author(), &validator_verifier)
        .is_ok()
    );
    
    // But commit_info matches, so add_signature_if_matched would accept it
    assert_eq!(malicious_vote.commit_info(), &commit_info);
    
    // When added to SignatureAggregator for correct_ledger_info,
    // it will pass add_signature_if_matched check but create invalid proof
}
```

**Notes:**
- This vulnerability breaks the consensus safety invariant that signatures must match the canonical LedgerInfo
- The `consensus_data_hash` field is critical for linking commits to the ordering phase
- Manipulating it allows Byzantine validators to create confusion about which block is being committed
- The optimistic verification optimization introduced this regression by not re-verifying signatures when messages change

### Citations

**File:** consensus/consensus-types/src/pipeline/commit_vote.rs (L103-113)
```rust
    pub fn verify(&self, sender: Author, validator: &ValidatorVerifier) -> anyhow::Result<()> {
        ensure!(
            self.author() == sender,
            "Commit vote author {:?} doesn't match with the sender {:?}",
            self.author(),
            sender
        );
        validator
            .optimistic_verify(self.author(), &self.ledger_info, &self.signature)
            .context("Failed to verify Commit Vote")
    }
```

**File:** types/src/validator_verifier.rs (L269-285)
```rust
    pub fn optimistic_verify<T: Serialize + CryptoHash>(
        &self,
        author: AccountAddress,
        message: &T,
        signature_with_status: &SignatureWithStatus,
    ) -> std::result::Result<(), VerifyError> {
        if self.get_public_key(&author).is_none() {
            return Err(VerifyError::UnknownAuthor);
        }
        if (!self.optimistic_sig_verification || self.pessimistic_verify_set.contains(&author))
            && !signature_with_status.is_verified()
        {
            self.verify(author, message, signature_with_status.signature())?;
            signature_with_status.set_verified();
        }
        Ok(())
    }
```

**File:** types/src/validator_verifier.rs (L287-311)
```rust
    pub fn filter_invalid_signatures<T: Send + Sync + Serialize + CryptoHash>(
        &self,
        message: &T,
        signatures: BTreeMap<AccountAddress, SignatureWithStatus>,
    ) -> BTreeMap<AccountAddress, SignatureWithStatus> {
        signatures
            .into_iter()
            .collect_vec()
            .into_par_iter()
            .with_min_len(4) // At least 4 signatures are verified in each task
            .filter_map(|(account_address, signature)| {
                if signature.is_verified()
                    || self
                        .verify(account_address, message, signature.signature())
                        .is_ok()
                {
                    signature.set_verified();
                    Some((account_address, signature))
                } else {
                    self.add_pessimistic_verify_set(account_address);
                    None
                }
            })
            .collect()
    }
```

**File:** consensus/src/pipeline/buffer_item.rs (L393-399)
```rust
            Self::Executed(executed) => {
                if executed.commit_info == *target_commit_info {
                    executed
                        .partial_commit_proof
                        .add_signature(author, signature);
                    return Ok(());
                }
```

**File:** consensus/src/pipeline/buffer_item.rs (L401-405)
```rust
            Self::Signed(signed) => {
                if signed.partial_commit_proof.data().commit_info() == target_commit_info {
                    signed.partial_commit_proof.add_signature(author, signature);
                    return Ok(());
                }
```

**File:** types/src/ledger_info.rs (L517-536)
```rust
    pub fn aggregate_and_verify(
        &mut self,
        verifier: &ValidatorVerifier,
    ) -> Result<(T, AggregateSignature), VerifyError> {
        let aggregated_sig = self.try_aggregate(verifier)?;

        match verifier.verify_multi_signatures(&self.data, &aggregated_sig) {
            Ok(_) => {
                // We are not marking all the signatures as "verified" here, as two malicious
                // voters can collude and create a valid aggregated signature.
                Ok((self.data.clone(), aggregated_sig))
            },
            Err(_) => {
                self.filter_invalid_signatures(verifier);

                let aggregated_sig = self.try_aggregate(verifier)?;
                Ok((self.data.clone(), aggregated_sig))
            },
        }
    }
```
