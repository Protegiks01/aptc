# Audit Report

## Title
Diagnostic Suppression via Interior Mutability in External Checkers Allows Compilation of Invalid Move Code

## Summary
External checkers implementing the `ExpChecker` trait can suppress compiler errors by clearing or manipulating diagnostics through `GlobalEnv`'s interior mutability pattern. This allows code with security violations (access control, type safety, resource safety) to compile successfully, bypassing critical compiler validations.

## Finding Description

The Move compiler v2 allows external checkers to examine expressions during compilation via the `ExpChecker` trait. [1](#0-0) 

These external checkers receive an immutable reference to `FunctionEnv`, but can access `GlobalEnv` through the public `env()` method. [2](#0-1) 

The `GlobalEnv` structure uses `RefCell` for interior mutability on its diagnostics field, allowing mutation through immutable references. [3](#0-2) 

The `clear_diag()` method is publicly accessible and clears all accumulated diagnostics. [4](#0-3) 

The compilation pipeline runs external checkers **after** critical security checks (access control, type checking, etc.) but **before** error validation. [5](#0-4) 

After the pipeline runs, `check_errors()` validates diagnostics using `has_errors()`, which relies on counting error diagnostics. [6](#0-5) 

If diagnostics are cleared, `has_errors()` returns false even when security violations occurred. [7](#0-6) 

**Attack Path:**
1. Attacker creates malicious external checker implementing `ExternalChecks`
2. Victim includes malicious checker via compiler options or dependency
3. During compilation, checker's `visit_expr_pre()` is invoked on every expression
4. Checker calls `function.env().clear_diag()` to suppress accumulated errors
5. Security violations (access control, type safety) are not caught
6. Invalid code compiles successfully and can be deployed

This breaks multiple Aptos invariants:
- **Access Control**: Private functions become callable from outside modules
- **Move VM Safety**: Type errors and resource safety violations are suppressed
- **Transaction Validation**: Invalid prologue/epilogue checks pass compilation

## Impact Explanation

**Severity: HIGH** (per Aptos Bug Bounty: up to $50,000 - "Significant protocol violations")

This vulnerability enables:
- **Compiler Security Bypass**: Critical security checks can be suppressed
- **Smart Contract Vulnerabilities**: Compiled contracts may violate access controls, type safety, or resource safety
- **Supply Chain Attack Vector**: Malicious dependencies/linters can compromise compilation
- **Potential Loss of Funds**: Deployed contracts with suppressed security errors could be exploited

While this doesn't directly cause loss of funds or consensus violations, it's a significant protocol violation that undermines the compiler's security guarantees. The Move language relies on compile-time checks to enforce safety invariants; bypassing these checks breaks the security model.

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH**

**Attacker Requirements:**
- Ability to provide external checker (via malicious dependency or custom linter)
- Victim must compile with the malicious checker enabled
- No special privileges or validator access required

**Realistic Scenarios:**
- Supply chain attack via compromised linter package
- Malicious dependency including custom checker
- Insider threat (developer with malicious intent)

**Factors Increasing Likelihood:**
- External checkers are a legitimate feature for custom lint rules
- Developers routinely use third-party linters and tools
- No sandboxing or permission model for external checkers
- RefCell pattern allows mutation without obvious warning

## Recommendation

**Solution 1: Remove Public Access to Diagnostic Mutation**

Make `clear_diag()` and other diagnostic mutation methods `pub(crate)` or remove them entirely. Only allow adding diagnostics, not clearing/filtering.

**Solution 2: Checkpoint-Based Error Validation**

Create diagnostic checkpoints before running external checkers, then validate that critical errors weren't removed:

```rust
// In lib.rs env_check_and_transform_pipeline
let checkpoint = env.get_diag_checkpoint();
env_pipeline.add("model AST lints", model_ast_lints::checker);
env.verify_diag_checkpoint(checkpoint); // Fails if critical errors removed
```

**Solution 3: Sandbox External Checkers**

Provide external checkers with a restricted `GlobalEnv` view that doesn't expose diagnostic mutation:

```rust
pub trait ExpChecker {
    fn visit_expr_pre(&mut self, _function: &RestrictedFunctionEnv, _expr: &ExpData) {}
}

pub struct RestrictedFunctionEnv<'env> {
    function_env: FunctionEnv<'env>,
}

impl<'env> RestrictedFunctionEnv<'env> {
    // Expose read-only methods only
    pub fn get_name(&self) -> Symbol {
        self.function_env.get_name()
    }
    // Do NOT expose env() or any method returning GlobalEnv
}
```

**Recommended Fix: Combination of Solutions 1 + 3**

## Proof of Concept

```rust
// malicious_checker.rs
use move_compiler_v2::external_checks::{ExternalChecks, ExpChecker};
use move_model::ast::ExpData;
use move_model::model::FunctionEnv;

pub struct MaliciousChecker;

impl ExpChecker for MaliciousChecker {
    fn get_name(&self) -> String {
        "malicious_checker".to_string()
    }
    
    fn visit_expr_pre(&mut self, function: &FunctionEnv, _expr: &ExpData) {
        // Suppress all compiler errors!
        let env = function.env();
        env.clear_diag();
        
        // Or selectively suppress specific errors:
        // env.diags.borrow_mut().retain(|(diag, _)| {
        //     !diag.message.contains("cannot access")
        // });
    }
}

pub struct MaliciousExternalChecks;

impl ExternalChecks for MaliciousExternalChecks {
    fn get_exp_checkers(&self) -> Vec<Box<dyn ExpChecker>> {
        vec![Box::new(MaliciousChecker)]
    }
    
    fn get_stackless_bytecode_checkers(&self) -> Vec<Box<dyn StacklessBytecodeChecker>> {
        vec![]
    }
}

// Usage:
// let options = Options {
//     external_checks: vec![Arc::new(MaliciousExternalChecks)],
//     ..Default::default()
// };
// 
// Compile invalid Move code (e.g., calling private function from outside)
// The malicious checker will suppress the error
// Invalid code compiles successfully!
```

**Test Case:**
1. Create Move module with private function
2. Create second module that illegally calls the private function
3. Without malicious checker: Compilation fails with access error
4. With malicious checker: Error is suppressed, compilation succeeds
5. Deployed code violates access control invariant

## Notes

Additional security concerns identified but of lower severity:

1. **Specification Tampering**: `FunctionData.spec: RefCell<Spec>` allows modification of Move Prover specifications [8](#0-7) , but limited impact since the Move Prover creates a fresh model without external checkers. [9](#0-8) 

2. **Expression Info Mutation**: `GlobalEnv.exp_info: RefCell<BTreeMap<NodeId, ExpInfo>>` could be modified [10](#0-9) , but occurs after type checking, limiting exploitation potential.

The diagnostic suppression vulnerability is the critical issue requiring immediate attention.

### Citations

**File:** third_party/move/move-compiler-v2/src/external_checks.rs (L52-68)
```rust
pub trait ExpChecker {
    /// Name of the expression checker.
    fn get_name(&self) -> String;

    /// Examine `expr` before any of its children have been visited.
    /// Potentially emit reports using `self.report()`.
    fn visit_expr_pre(&mut self, _function: &FunctionEnv, _expr: &ExpData) {}

    /// Examine `expr` after all its children have been visited.
    /// Potentially emit reports using `self.report()`.
    fn visit_expr_post(&mut self, _function: &FunctionEnv, _expr: &ExpData) {}

    /// Report the `msg` highlighting the `loc`.
    fn report(&self, env: &GlobalEnv, loc: &Loc, msg: &str) {
        report(env, loc, msg, self.get_name().as_str());
    }
}
```

**File:** third_party/move/move-model/src/model.rs (L569-571)
```rust
    /// Accumulated diagnosis. In a RefCell so we can add to it without needing a mutable GlobalEnv.
    /// The boolean indicates whether the diag was reported.
    pub(crate) diags: RefCell<Vec<(Diagnostic<FileId>, bool)>>,
```

**File:** third_party/move/move-model/src/model.rs (L577-577)
```rust
    pub(crate) exp_info: RefCell<BTreeMap<NodeId, ExpInfo>>,
```

**File:** third_party/move/move-model/src/model.rs (L1091-1094)
```rust
    /// Clear all accumulated diagnosis.
    pub fn clear_diag(&self) {
        self.diags.borrow_mut().clear();
    }
```

**File:** third_party/move/move-model/src/model.rs (L1228-1244)
```rust
    pub fn has_errors(&self) -> bool {
        self.error_count() > 0
    }

    /// Returns the number of diagnostics.
    pub fn diag_count(&self, min_severity: Severity) -> usize {
        self.diags
            .borrow()
            .iter()
            .filter(|(d, _)| d.severity >= min_severity)
            .count()
    }

    /// Returns the number of errors.
    pub fn error_count(&self) -> usize {
        self.diag_count(Severity::Error)
    }
```

**File:** third_party/move/move-model/src/model.rs (L4593-4594)
```rust
    /// Specification associated with this function.
    pub(crate) spec: RefCell<Spec>,
```

**File:** third_party/move/move-model/src/model.rs (L4672-4676)
```rust
impl<'env> FunctionEnv<'env> {
    /// Shortcut to access the env
    pub fn env(&self) -> &GlobalEnv {
        self.module_env.env
    }
```

**File:** third_party/move/move-compiler-v2/src/lib.rs (L358-381)
```rust
    if options.experiment_on(Experiment::ACCESS_CHECK) {
        env_pipeline.add(
            "access and use check before inlining",
            |env: &mut GlobalEnv| function_checker::check_access_and_use(env, true),
        );
    }

    let check_seqs_in_binops = !options
        .language_version
        .unwrap_or_default()
        .is_at_least(LanguageVersion::V2_0)
        && options.experiment_on(Experiment::SEQS_IN_BINOPS_CHECK);
    if check_seqs_in_binops {
        env_pipeline.add("binop side effect check", |env| {
            // This check should be done before inlining.
            seqs_in_binop_checker::checker(env)
        });
    }

    if options.experiment_on(Experiment::LINT_CHECKS) {
        // Perform all the model AST lint checks before inlining, to be closer "in form"
        // to the user code.
        env_pipeline.add("model AST lints", model_ast_lints::checker);
    }
```

**File:** third_party/move/move-compiler-v2/src/diagnostics/mod.rs (L53-65)
```rust
    fn check_diag(
        &mut self,
        global_env: &GlobalEnv,
        report_severity: Severity,
        msg: &str,
    ) -> anyhow::Result<()> {
        self.report_diag(global_env, report_severity);
        if global_env.has_errors() {
            bail!("exiting with {}", msg);
        } else {
            Ok(())
        }
    }
```

**File:** third_party/move/move-prover/src/lib.rs (L77-77)
```rust
        external_checks: vec![],
```
