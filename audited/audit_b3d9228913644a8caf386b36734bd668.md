# Audit Report

## Title
IPv4/IPv6 Dual-Stack Bypass in Faucet IP Range Manager

## Summary
The Aptos Faucet's `IpRangeManager` maintains separate blocklists for IPv4 and IPv6 addresses without cross-protocol validation. An attacker whose IPv4 address is blocklisted can bypass the restriction by connecting via IPv6 (or vice versa) in dual-stack network configurations, allowing them to circumvent IP-based rate limiting and blocklists.

## Finding Description

The `IpRangeManager` struct maintains two separate IP range lists: [1](#0-0) 

The `contains_ip()` function checks only the corresponding list for each IP version: [2](#0-1) 

This separate-list architecture creates a bypass vulnerability. When an administrator blocks an IPv4 address (e.g., `192.0.2.100/32`), it is added only to `ipv4_list`. An attacker with dual-stack connectivity can simply connect via their IPv6 address, and the check against `ipv6_list` will pass since their IPv6 address is not blocklisted.

The `IpBlocklistChecker` uses this function to reject requests: [3](#0-2) 

Similarly, the `IpAllowlistBypasser` uses it to grant bypass privileges: [4](#0-3) 

**Attack Scenario:**
1. Attacker requests tokens from faucet using IPv4 address `203.0.113.50`
2. Faucet administrator detects abuse and adds `203.0.113.50/32` to blocklist
3. Attacker switches to IPv6 connectivity (e.g., `2001:db8::abcd:1234`)
4. The `contains_ip()` check only queries `ipv6_list`, which doesn't contain the attacker's IPv6 address
5. Attacker successfully bypasses the blocklist and continues draining faucet funds

The codebase contains no IPv4-mapped IPv6 address handling (no `to_ipv4_mapped` conversions exist), and there is no cross-protocol validation mechanism.

## Impact Explanation

This vulnerability allows attackers to:
- **Bypass IP-based rate limiting**: Attackers can exceed per-IP rate limits by alternating between IPv4 and IPv6
- **Evade blocklists**: Once blocklisted on one protocol, attackers can continue abuse via the other protocol
- **Drain faucet resources**: Repeated requests can exhaust testnet token supplies

However, **this vulnerability does NOT meet Critical, High, or Medium severity criteria** per the Aptos Bug Bounty program because:

1. **No mainnet funds at risk**: The faucet only distributes testnet/devnet tokens
2. **No consensus impact**: Does not affect AptosBFT protocol, validator operations, or blockchain state
3. **No protocol violation**: Does not break any core blockchain invariants
4. **Utility service only**: The faucet is a testnet utility, not part of the core blockchain protocol

The impact is limited to testnet resource exhaustion, which falls under **network-level DoS attacks** that are explicitly **out of scope** per bug bounty rules.

## Likelihood Explanation

While the technical likelihood is **High** (many users have dual-stack connectivity, and switching protocols requires no special tools), the **security significance is Low** because:
- Only affects test token distribution on testnets
- Faucet operators can implement application-level mitigations
- Does not threaten mainnet operations or protocol security

## Recommendation

To prevent this bypass, the `IpRangeManager` should normalize IPv4-mapped IPv6 addresses and check both lists when applicable:

```rust
pub fn contains_ip(&self, ip: &IpAddr) -> bool {
    match ip {
        IpAddr::V4(ipv4) => self.ipv4_list.contains(ipv4),
        IpAddr::V6(ipv6) => {
            // Check IPv6 list first
            if self.ipv6_list.contains(ipv6) {
                return true;
            }
            // Check if this is an IPv4-mapped IPv6 address
            if let Some(ipv4) = ipv6.to_ipv4_mapped() {
                return self.ipv4_list.contains(&ipv4);
            }
            false
        }
    }
}
```

Alternatively, maintain a unified address mapping that tracks all addresses associated with a connection session.

## Proof of Concept

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};
    use tempfile::NamedTempFile;
    use std::io::Write;

    #[test]
    fn test_ipv4_ipv6_bypass() {
        // Create blocklist with only IPv4 address
        let mut blocklist_file = NamedTempFile::new().unwrap();
        writeln!(blocklist_file, "203.0.113.50/32").unwrap();
        blocklist_file.flush().unwrap();

        let config = IpRangeManagerConfig {
            file: blocklist_file.path().to_path_buf(),
        };
        let manager = IpRangeManager::new(config).unwrap();

        // IPv4 address is blocked
        let ipv4 = IpAddr::V4(Ipv4Addr::new(203, 0, 113, 50));
        assert!(manager.contains_ip(&ipv4), "IPv4 should be blocked");

        // But corresponding IPv6 address (even IPv4-mapped) bypasses the check
        let ipv6_mapped = IpAddr::V6(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xcb00, 0x7132));
        assert!(!manager.contains_ip(&ipv6_mapped), "IPv6-mapped should bypass blocklist");

        // Any other IPv6 address also bypasses
        let ipv6 = IpAddr::V6(Ipv6Addr::new(0x2001, 0xdb8, 0, 0, 0, 0, 0, 1));
        assert!(!manager.contains_ip(&ipv6), "IPv6 should bypass blocklist");
    }
}
```

## Notes

**Important Clarification**: While this is a genuine implementation vulnerability in the faucet component, it **does not meet the security audit scope** defined in the mission brief. The audit specifically targets:

- Consensus vulnerabilities (AptosBFT protocol)
- Move VM implementation bugs
- State management attacks
- On-chain governance security
- Validator staking subsystems

The faucet is a **testnet utility service**, not a core blockchain protocol component. The documented critical invariants (deterministic execution, consensus safety, Move VM safety, state consistency, governance integrity, etc.) are all focused on the blockchain protocol itself, not auxiliary testing tools.

Per the exclusions: "Network-level DoS attacks are out of scope per bug bounty rules" - faucet resource exhaustion falls into this category.

This finding would be more appropriately reported as an **operational security issue** for testnet infrastructure rather than a protocol-level vulnerability eligible for the Aptos Core bug bounty program.

### Citations

**File:** crates/aptos-faucet/core/src/common/ip_range_manager.rs (L18-21)
```rust
pub struct IpRangeManager {
    pub ipv4_list: IpRange<Ipv4Net>,
    pub ipv6_list: IpRange<Ipv6Net>,
}
```

**File:** crates/aptos-faucet/core/src/common/ip_range_manager.rs (L55-60)
```rust
    pub fn contains_ip(&self, ip: &IpAddr) -> bool {
        match ip {
            IpAddr::V4(ipv4) => self.ipv4_list.contains(ipv4),
            IpAddr::V6(ipv6) => self.ipv6_list.contains(ipv6),
        }
    }
```

**File:** crates/aptos-faucet/core/src/checkers/ip_blocklist.rs (L32-49)
```rust
        match &data.source_ip {
            IpAddr::V4(source_ip) => {
                if self.manager.ipv4_list.contains(source_ip) {
                    return Ok(vec![RejectionReason::new(
                        format!("IP {} is in blocklist", source_ip),
                        RejectionReasonCode::IpInBlocklist,
                    )]);
                }
            },
            IpAddr::V6(source_ip) => {
                if self.manager.ipv6_list.contains(source_ip) {
                    return Ok(vec![RejectionReason::new(
                        format!("IP {} is in blocklist", source_ip),
                        RejectionReasonCode::IpInBlocklist,
                    )]);
                }
            },
        }
```

**File:** crates/aptos-faucet/core/src/bypasser/ip_allowlist.rs (L26-28)
```rust
    async fn request_can_bypass(&self, data: CheckerData) -> Result<bool> {
        Ok(self.manager.contains_ip(&data.source_ip))
    }
```
