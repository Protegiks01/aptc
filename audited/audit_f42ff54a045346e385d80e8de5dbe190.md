# Audit Report

## Title
Offer Events Assigned Incorrect Sequence Numbers Due to Latest State Checkpoint Usage During Event V2 Translation

## Summary
The Event V2 translation system reads the `PendingClaimsResource` from the latest state checkpoint rather than the historical state at the time each event was emitted. This causes Offer events (and other token transfer events) to be assigned incorrect sequence numbers when the indexer processes historical transactions, resulting in out-of-order event display and incorrect pending claims state shown to users.

## Finding Description
When the internal indexer processes transactions and translates V2 events to V1 events for backward compatibility, the `OfferTranslator` (and similar translators) read on-chain resources to determine the correct `EventKey` and sequence number for each translated event. [1](#0-0) 

The critical flaw occurs in the `get_state_value_bytes_for_resource` method, which is called by all event translators to read on-chain state: [2](#0-1) 

This method uses `latest_state_checkpoint_view()` to retrieve state, which returns the state at the most recent checkpoint version, not the state at the transaction version being processed: [3](#0-2) 

**Exploitation Scenario:**

1. Main DB is at version 10,000 (latest checkpoint)
2. Indexer is catching up, processing transactions 900-910 in a batch
3. Transaction 905: Account 0xA makes a token offer
   - At version 905, `PendingClaims.offer_events.count` was 5
   - Translator reads from version 10,000 where count is now 100
   - Event gets assigned sequence number 101 (should be 5)
4. Transaction 908: Account 0xA makes another offer
   - At version 908, count was 6
   - Translator still reads from version 10,000 where count is 100
   - Cached sequence is now 101, so event gets 102 (should be 6)

The batch processing flow in `DBIndexer::process_a_batch` iterates through transactions sequentially but translates each event using the latest state: [4](#0-3) 

This violates the **State Consistency** invariant (#4) which requires that "state transitions must be atomic and verifiable." The indexed events represent a state transition that never actually occurred at those sequence numbers, creating an inconsistent view of the blockchain state.

## Impact Explanation
This issue meets **Medium Severity** criteria per the Aptos bug bounty program:

- **State inconsistencies requiring intervention**: The indexed event data is inconsistent with the actual blockchain state. Events have incorrect sequence numbers that don't match their historical on-chain state.

- **Incorrect user-facing state**: Users querying the indexer will see:
  - Offer events with wrong sequence numbers
  - Events appearing in incorrect chronological order
  - Gaps in sequence number series
  - Incorrect pending claims state for accounts

- **Scope**: Affects all nodes running the internal indexer during:
  - Initial sync from genesis
  - Catchup after downtime
  - Re-indexing operations
  - Any scenario where processed transaction versions lag behind the latest checkpoint

This does not reach High or Critical severity because:
- No funds are at risk (on-chain state is correct)
- No consensus violations (consensus layer is unaffected)
- The issue is in the indexer's derived state, not canonical blockchain state

## Likelihood Explanation
**Likelihood: Very High**

This bug triggers automatically whenever:
1. **Node startup**: Every node starting from genesis or a snapshot processes historical transactions while the main DB advances
2. **Catchup scenarios**: Nodes that fall behind (due to network issues, maintenance, etc.) exhibit this behavior when catching up
3. **Re-indexing**: Intentional re-indexing operations trigger the bug systematically

The internal indexer service continuously processes transactions in batches: [5](#0-4) 

Every time `start_version < target_version`, the indexer processes a batch and reads from the latest checkpoint, causing incorrect sequence number assignment for all affected event types (Offer, CancelOffer, Claim, and other V2 events).

## Recommendation
The event translation engine should read state at the specific transaction version being processed, not the latest checkpoint. Modify the `EventV2TranslationEngine` to accept and use a version parameter:

**Fix Approach:**
1. Pass the transaction version to `translate_event_v2_to_v1` 
2. Modify `EventV2TranslationEngine` to use `state_view_at_version(version)` instead of `latest_state_checkpoint_view()`
3. Update all translator implementations to receive and use the versioned state view

The infrastructure for versioned state views already exists: [6](#0-5) 

**Recommended Code Changes:**

In `db_indexer.rs`, pass the version when translating:
```rust
// Line 450-457: Pass version to translator
if let Some(translated_v1_event) =
    self.translate_event_v2_to_v1(v2, version).map_err(|e| { ... })?
```

In `event_v2_translator.rs`, modify the trait and engine:
```rust
pub trait EventV2Translator: Send + Sync {
    fn translate_event_v2_to_v1(
        &self,
        v2: &ContractEventV2,
        engine: &EventV2TranslationEngine,
        version: Version, // Add version parameter
    ) -> Result<ContractEventV1>;
}

impl EventV2TranslationEngine {
    pub fn get_state_value_bytes_for_resource(
        &self,
        address: &AccountAddress,
        struct_tag: &StructTag,
        version: Version, // Add version parameter
    ) -> Result<Option<Bytes>> {
        let state_view = self
            .main_db_reader
            .state_view_at_version(Some(version))? // Use versioned state
        // ... rest of implementation
    }
}
```

## Proof of Concept

**Reproduction Steps:**

1. Set up a test Aptos node with internal indexer enabled
2. Generate a sequence of token offer transactions from the same account
3. Let the main DB advance to version N + 100
4. Restart the indexer to process from version N
5. Query the indexed events and compare sequence numbers with on-chain PendingClaims resource at each historical version

**Expected Behavior:** 
- Event at version N should have sequence number matching the counter at version N-1

**Actual Behavior:**
- Event at version N has sequence number based on counter at version N+100

**Verification Query:**
```rust
// Query indexed event sequence numbers
let indexed_events = indexer.get_events_by_event_key(&event_key, 0, Order::Ascending, 100, version)?;

// For each event, verify against historical state
for event in indexed_events {
    let state_at_version = db.state_view_at_version(Some(event.version))?;
    let pending_claims = get_resource::<PendingClaimsResource>(&state_at_version, account)?;
    let expected_seq = pending_claims.offer_events().count();
    assert_eq!(event.sequence_number(), expected_seq); // This will fail
}
```

**Note:** This vulnerability affects all V2 event types that read on-chain resources during translation, including but not limited to:
- Offer events (token_transfers module)
- CancelOffer events
- Claim events  
- CoinDeposit/CoinWithdraw events
- Token mint/burn events
- All other events translated via the EventV2TranslationEngine

## Notes

The root cause is an architectural design flaw in the event translation system. While the caching mechanism (`event_sequence_number_cache`) helps maintain sequential ordering within a single batch, it cannot correct the initial offset error introduced by reading from the wrong state version.

This issue demonstrates a violation of temporal consistency: the indexer creates a derived view of blockchain history that doesn't accurately reflect the state transitions as they occurred. While this doesn't affect consensus or on-chain operations, it breaks the fundamental guarantee that indexer data should faithfully represent historical blockchain state.

### Citations

**File:** storage/indexer/src/event_v2_translator.rs (L202-214)
```rust
    pub fn get_state_value_bytes_for_resource(
        &self,
        address: &AccountAddress,
        struct_tag: &StructTag,
    ) -> Result<Option<Bytes>> {
        let state_view = self
            .main_db_reader
            .latest_state_checkpoint_view()
            .expect("Failed to get state view");
        let state_key = StateKey::resource(address, struct_tag)?;
        let maybe_state_value = state_view.get_state_value(&state_key)?;
        Ok(maybe_state_value.map(|state_value| state_value.bytes().clone()))
    }
```

**File:** storage/indexer/src/event_v2_translator.rs (L878-914)
```rust
struct OfferTranslator;
impl EventV2Translator for OfferTranslator {
    fn translate_event_v2_to_v1(
        &self,
        v2: &ContractEventV2,
        engine: &EventV2TranslationEngine,
    ) -> Result<ContractEventV1> {
        let offer = Offer::try_from_bytes(v2.event_data())?;
        let struct_tag = StructTag::from_str("0x3::token_transfers::PendingClaims")?;
        let (key, sequence_number) = if let Some(state_value_bytes) =
            engine.get_state_value_bytes_for_resource(offer.account(), &struct_tag)?
        {
            let object_resource: PendingClaimsResource = bcs::from_bytes(&state_value_bytes)?;
            let key = *object_resource.offer_events().key();
            let sequence_number =
                engine.get_next_sequence_number(&key, object_resource.offer_events().count())?;
            (key, sequence_number)
        } else {
            // If the PendingClaims resource is not found, we skip the event translation to
            // avoid panic because the creation number cannot be decided.
            return Err(AptosDbError::from(anyhow::format_err!(
                "PendingClaims resource not found"
            )));
        };
        let offer_event = TokenOfferEvent::new(
            *offer.to_address(),
            offer.token_id().clone(),
            offer.amount(),
        );
        Ok(ContractEventV1::new(
            key,
            sequence_number,
            TOKEN_OFFER_EVENT_TYPE.clone(),
            bcs::to_bytes(&offer_event)?,
        )?)
    }
}
```

**File:** storage/storage-interface/src/state_store/state_view/db_state_view.rs (L81-91)
```rust
impl LatestDbStateCheckpointView for Arc<dyn DbReader> {
    fn latest_state_checkpoint_view(&self) -> StateViewResult<DbStateView> {
        Ok(DbStateView {
            db: self.clone(),
            version: self
                .get_latest_state_checkpoint_version()
                .map_err(Into::<StateViewError>::into)?,
            maybe_verify_against_state_root_hash: None,
        })
    }
}
```

**File:** storage/storage-interface/src/state_store/state_view/db_state_view.rs (L93-105)
```rust
pub trait DbStateViewAtVersion {
    fn state_view_at_version(&self, version: Option<Version>) -> StateViewResult<DbStateView>;
}

impl DbStateViewAtVersion for Arc<dyn DbReader> {
    fn state_view_at_version(&self, version: Option<Version>) -> StateViewResult<DbStateView> {
        Ok(DbStateView {
            db: self.clone(),
            version,
            maybe_verify_against_state_root_hash: None,
        })
    }
}
```

**File:** storage/indexer/src/db_indexer.rs (L448-487)
```rust
                    if self.indexer_db.event_v2_translation_enabled() {
                        if let ContractEvent::V2(v2) = event {
                            if let Some(translated_v1_event) =
                                self.translate_event_v2_to_v1(v2).map_err(|e| {
                                    anyhow::anyhow!(
                                        "Failed to translate event: {:?}. Error: {}",
                                        v2,
                                        e
                                    )
                                })?
                            {
                                let key = *translated_v1_event.key();
                                let sequence_number = translated_v1_event.sequence_number();
                                self.event_v2_translation_engine
                                    .cache_sequence_number(&key, sequence_number);
                                event_keys.insert(key);
                                batch
                                    .put::<EventByKeySchema>(
                                        &(key, sequence_number),
                                        &(version, idx as u64),
                                    )
                                    .expect("Failed to put events by key to a batch");
                                batch
                                    .put::<EventByVersionSchema>(
                                        &(key, version, sequence_number),
                                        &(idx as u64),
                                    )
                                    .expect("Failed to put events by version to a batch");
                                batch
                                    .put::<TranslatedV1EventSchema>(
                                        &(version, idx as u64),
                                        &translated_v1_event,
                                    )
                                    .expect("Failed to put translated v1 events to a batch");
                            }
                        }
                    }
                    Ok::<(), AptosDbError>(())
                })?;
            }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-table-info/src/internal_indexer_db_service.rs (L167-199)
```rust
    pub async fn run(&mut self, node_config: &NodeConfig) -> Result<()> {
        let mut start_version = self.get_start_version(node_config).await?;
        let mut target_version = self.db_indexer.main_db_reader.ensure_synced_version()?;
        let mut step_timer = std::time::Instant::now();

        loop {
            if target_version <= start_version {
                match self.update_receiver.changed().await {
                    Ok(_) => {
                        (step_timer, target_version) = *self.update_receiver.borrow();
                    },
                    Err(e) => {
                        panic!("Failed to get update from update_receiver: {}", e);
                    },
                }
            }
            let next_version = self.db_indexer.process(start_version, target_version)?;
            INDEXER_DB_LATENCY.set(step_timer.elapsed().as_millis() as i64);
            log_grpc_step(
                SERVICE_TYPE,
                IndexerGrpcStep::InternalIndexerDBProcessed,
                Some(start_version as i64),
                Some(next_version as i64),
                None,
                None,
                Some(step_timer.elapsed().as_secs_f64()),
                None,
                Some((next_version - start_version) as i64),
                None,
            );
            start_version = next_version;
        }
    }
```
