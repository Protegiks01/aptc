# Audit Report

## Title
Player ID Mismatch in Secret Share Verification Allows Decryption Key Reconstruction Corruption

## Summary
The secret sharing verification process fails to validate that the `Player` field in a `DecryptionKeyShare` matches the claimed `Author`, allowing attackers to inject shares with manipulated Player IDs. This causes Shamir secret sharing reconstruction to use incorrect Lagrange coefficients, producing a corrupted decryption key and causing denial of service on encrypted transaction processing.

## Finding Description

The Aptos consensus layer uses threshold secret sharing for encrypted transaction decryption. The `SecretShare` struct contains two identity fields: [1](#0-0) 

When a share is received and verified, the system only checks the BLS signature but **does not validate consistency between `author` and the `Player` ID embedded in the `share` tuple**: [2](#0-1) 

The verification looks up the verification key using `self.author()`, but never checks if `self.share().player()` corresponds to that author. The underlying BLS verification only validates the cryptographic signature over the elliptic curve point, not the Player ID: [3](#0-2) 

During share derivation, the Player ID is included in the output tuple but **not** included in the signature computation: [4](#0-3) 

When reconstruction occurs, the Player IDs from shares are directly used to compute Lagrange interpolation coefficients **without re-verification**: [5](#0-4) 

The reconstruction process extracts Player IDs and uses them for coefficient calculation: [6](#0-5) 

**Attack Path:**

1. Malicious validator or network attacker intercepts/creates a valid share from Validator A with `Player(0)`
2. Modifies the serialized share to change `Player(0)` to `Player(X)` while keeping the `author` field as Validator A
3. Other validators receive and deserialize the modified share
4. Verification uses Validator A's verification key (looked up via `author`)
5. BLS signature verification passes (signature is independent of Player ID)
6. Modified share is stored with wrong Player ID
7. During aggregation, reconstruction uses `Player(X)` for Lagrange coefficient calculation
8. Coefficients computed for wrong indices → **corrupted decryption key**
9. Decryption of encrypted transactions fails → **Denial of Service**

## Impact Explanation

This vulnerability meets **High Severity** criteria per Aptos bug bounty:
- **Significant protocol violation**: The threshold cryptography protocol is compromised
- **Validator node impact**: Encrypted transaction processing fails, potentially causing slowdowns or halts
- **Network availability**: If encrypted transactions are critical to consensus, this could cause **Critical Severity** total loss of liveness

The attack corrupts the shared decryption key reconstruction, breaking the fundamental security guarantee that `t` honest shares should reconstruct the correct key. Even with all honest validators providing legitimate shares, a single malicious share with a tampered Player ID corrupts the entire reconstruction.

## Likelihood Explanation

**High likelihood** of exploitation:
- **Low attacker requirements**: Requires either (a) compromising one validator node, or (b) man-in-the-middle capability on validator network traffic
- **No privileged access needed**: Any network-level attacker can inject malicious messages
- **Simple attack**: Only requires modifying one field in serialized data
- **No cryptographic break needed**: Exploits missing validation logic, not cryptographic weakness
- **Immediate impact**: Successfully injected malicious shares immediately corrupt next reconstruction attempt

The vulnerability is particularly severe because the protocol **should** detect this tampering through cryptographic verification, but the design flaw (not including Player ID in signature) allows it to slip through.

## Recommendation

**Add Player ID consistency validation** in the verification process:

```rust
pub fn verify(&self, config: &SecretShareConfig) -> anyhow::Result<()> {
    let index = config.get_id(self.author());
    let decryption_key_share = self.share().clone();
    
    // NEW: Validate Player ID matches expected index
    ensure!(
        decryption_key_share.player().get_id() == index,
        "Player ID mismatch: share claims player {} but author maps to index {}",
        decryption_key_share.player().get_id(),
        index
    );
    
    config.verification_keys[index]
        .verify_decryption_key_share(&self.metadata.digest, &decryption_key_share)?;
    Ok(())
}
```

**Alternative (stronger)**: Include Player ID in the BLS signature by modifying the signature computation to hash the Player ID along with the digest.

## Proof of Concept

```rust
// Demonstrates the vulnerability: tampering with Player ID passes verification
use aptos_batch_encryption::schemes::fptx_weighted::FPTXWeighted;
use aptos_batch_encryption::traits::BatchThresholdEncryption;
use aptos_crypto::player::Player;
use aptos_types::secret_sharing::{SecretShare, SecretShareMetadata, SecretShareConfig};

#[test]
fn test_player_id_tampering_vulnerability() {
    // Setup: Create threshold config with 4 validators, threshold 3
    let (ek, dk, vks, msk_shares) = FPTXWeighted::setup_for_testing(
        42, 100, 10, &threshold_config
    ).unwrap();
    
    // Validator 0 derives their legitimate share
    let digest = /* create digest */;
    let metadata = SecretShareMetadata::new(1, 100, 0, block_id, digest);
    let legitimate_share = FPTXWeighted::derive_decryption_key_share(&msk_shares[0], &digest).unwrap();
    
    // ATTACK: Create malicious share with tampered Player ID
    let mut tampered_share = legitimate_share.clone();
    tampered_share.0 = Player { id: 3 }; // Change from Player(0) to Player(3)
    
    let malicious_secret_share = SecretShare::new(
        author_0, // Still claim to be from Validator 0
        metadata.clone(),
        tampered_share
    );
    
    // VULNERABILITY: Verification passes even with wrong Player ID!
    assert!(malicious_secret_share.verify(&config).is_ok());
    
    // Collect shares for reconstruction
    let shares = vec![malicious_secret_share, share_1, share_2];
    
    // Reconstruction uses wrong Player ID (3 instead of 0)
    let reconstructed_key = SecretShare::aggregate(shares.iter(), &config).unwrap();
    
    // Decryption with corrupted key produces wrong results or errors
    let decrypted = FPTXWeighted::decrypt(&reconstructed_key, &prepared_cts);
    assert!(decrypted.is_err()); // Decryption fails due to corrupted key
}
```

## Notes

The TODO comment in the verification code hints at awareness of index validation issues, but the specific Player ID consistency check is missing: [7](#0-6) 

This vulnerability demonstrates a critical principle: **cryptographic verification must cover all security-relevant fields**. The Player ID is directly used in cryptographic operations (Lagrange interpolation) but is not authenticated, creating an exploitable gap between the authenticated data and the data used in computation.

### Citations

**File:** types/src/secret_sharing.rs (L59-64)
```rust
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct SecretShare {
    pub author: Author,
    pub metadata: SecretShareMetadata,
    pub share: SecretKeyShare,
}
```

**File:** types/src/secret_sharing.rs (L75-82)
```rust
    pub fn verify(&self, config: &SecretShareConfig) -> anyhow::Result<()> {
        let index = config.get_id(self.author());
        let decryption_key_share = self.share().clone();
        // TODO(ibalajiarun): Check index out of bounds
        config.verification_keys[index]
            .verify_decryption_key_share(&self.metadata.digest, &decryption_key_share)?;
        Ok(())
    }
```

**File:** types/src/secret_sharing.rs (L84-99)
```rust
    pub fn aggregate<'a>(
        dec_shares: impl Iterator<Item = &'a SecretShare>,
        config: &SecretShareConfig,
    ) -> anyhow::Result<DecryptionKey> {
        let threshold = config.threshold();
        let shares: Vec<SecretKeyShare> = dec_shares
            .map(|dec_share| dec_share.share.clone())
            .take(threshold as usize)
            .collect();
        let decryption_key =
            <FPTXWeighted as BatchThresholdEncryption>::reconstruct_decryption_key(
                &shares,
                &config.config,
            )?;
        Ok(decryption_key)
    }
```

**File:** crates/aptos-batch-encryption/src/shared/key_derivation.rs (L107-115)
```rust
    pub fn derive_decryption_key_share(&self, digest: &Digest) -> Result<BIBEDecryptionKeyShare> {
        let hashed_encryption_key: G1Affine = symmetric::hash_g2_element(self.mpk_g2)?;

        Ok((self.player, BIBEDecryptionKeyShareValue {
            signature_share_eval: G1Affine::from(
                (digest.as_g1() + hashed_encryption_key) * self.shamir_share_eval,
            ),
        }))
    }
```

**File:** crates/aptos-batch-encryption/src/shared/key_derivation.rs (L136-150)
```rust
    pub fn verify_decryption_key_share(
        &self,
        digest: &Digest,
        decryption_key_share: &BIBEDecryptionKeyShare,
    ) -> Result<()> {
        verify_bls(
            self.vk_g2,
            digest,
            self.mpk_g2,
            decryption_key_share.1.signature_share_eval,
        )
        .map_err(|_| BatchEncryptionError::DecryptionKeyShareVerifyError)?;

        Ok(())
    }
```

**File:** crates/aptos-crypto/src/arkworks/shamir.rs (L309-330)
```rust
    fn reconstruct(
        sc: &ShamirThresholdConfig<T::Scalar>,
        shares: &[ShamirShare<Self::ShareValue>],
    ) -> Result<Self> {
        if shares.len() < sc.t {
            Err(anyhow!(
                "Incorrect number of shares provided, received {} but expected at least {}",
                shares.len(),
                sc.t
            ))
        } else {
            let (roots_of_unity_indices, bases): (Vec<usize>, Vec<Self::ShareValue>) = shares
                [..sc.t]
                .iter()
                .map(|(p, g_y)| (p.get_id(), g_y))
                .collect();

            let lagrange_coeffs = sc.lagrange_for_subset(&roots_of_unity_indices);

            Ok(T::weighted_sum(&bases, &lagrange_coeffs))
        }
    }
```
