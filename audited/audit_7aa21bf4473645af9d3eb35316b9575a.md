# Audit Report

## Title
Node Checker Service Crash via Malformed URL Schemes in NodeAddress Configuration

## Summary
The `validate_configuration()` function in the node-checker service fails to validate that the optional `node_address` field uses URL schemes compatible with port assignment. This allows malformed URLs with schemes like `mailto:`, `data:`, or `file:` to bypass validation during configuration loading, causing runtime panics when the service attempts to set ports on these URLs, resulting in service crashes.

## Finding Description

The vulnerability exists across multiple components of the node-checker service: [1](#0-0) 

The `validate_configuration()` function only validates that checkers can be built but performs no validation on the `node_address` field itself, even though it's a critical configuration parameter. [2](#0-1) 

The `BaselineConfiguration` struct contains an optional `node_address` field of type `Option<NodeAddress>`. During deserialization from YAML/JSON configuration files, the `url::Url` type accepts any valid URL syntax, including schemes that don't support port modification. [3](#0-2) 

The `get_api_url()` method calls `url.set_port().unwrap()`, which panics if the URL scheme is "cannot-be-a-base" (like `mailto:`, `data:`, `javascript:`) or doesn't support ports (like `file:`). [4](#0-3) 

Similarly, `get_metrics_url()` contains the same vulnerability pattern with `.unwrap()` on `set_port()`. [5](#0-4) 

The `get_api_client()` method calls `get_api_url()`, which triggers the panic before the Result can be returned. [6](#0-5) 

During runtime execution, both the baseline configuration initialization and target node checking paths invoke these methods, causing the service to crash when processing any configuration containing incompatible URL schemes.

**Attack Path:**
1. Attacker provides or influences a node-checker configuration file (YAML/JSON)
2. Configuration contains `node_address` with URL like `"mailto:admin@example.com"` or `"data:text/plain,test"`
3. Configuration deserialization succeeds (valid URL syntax)
4. `validate_configuration()` passes (no URL scheme validation)
5. Service attempts to build API/metrics clients for baseline or target nodes
6. `get_api_url()` or `get_metrics_url()` is called
7. `url.set_port()` returns `Err(())` for incompatible scheme
8. `.unwrap()` panics, crashing the service

## Impact Explanation

This vulnerability constitutes a **Medium Severity** issue. While the node-checker is not a consensus-critical component, it is part of the Aptos ecosystem infrastructure used for node health monitoring. The impact includes:

- **Service Availability**: The node-checker API service crashes when processing malformed configurations, requiring manual restart
- **Operational Disruption**: Organizations relying on automated node health checks experience monitoring failures
- **Configuration Attack Surface**: If configuration files can be influenced through supply chain attacks or misconfiguration, attackers can reliably crash the service

This does not meet High/Critical severity because:
- No impact on blockchain consensus, validator operations, or fund security
- No impact on core Aptos blockchain availability
- Limited to ecosystem tooling, not core protocol components

However, it qualifies for Medium severity as it represents "state inconsistencies requiring intervention" (service crash requiring restart) and demonstrates a clear implementation bug with security implications.

## Likelihood Explanation

**Likelihood: Medium**

The vulnerability requires:
- Ability to provide or influence node-checker configuration files
- Configurations are typically loaded at service startup or validation time
- Attack is deterministic and 100% reliable once malformed configuration is loaded

Realistic scenarios include:
1. **Misconfiguration**: Operators accidentally using wrong URL formats
2. **Supply Chain**: Compromised configuration templates or deployment scripts
3. **Dynamic Configuration**: If configurations are loaded from external sources

The attack complexity is LOW - simply providing a YAML/JSON file with an incompatible URL scheme triggers the crash.

## Recommendation

Add explicit URL scheme validation in the `validate_configuration()` function and replace `.unwrap()` with proper error handling:

**Validation Enhancement:**
Add to `validate_configuration()` in `validate.rs`:
```rust
pub fn validate_configuration(node_configuration: &BaselineConfiguration) -> Result<()> {
    // Validate node_address if present
    if let Some(node_address) = &node_configuration.node_address {
        validate_node_address(node_address)?;
    }
    
    build_checkers(&node_configuration.checkers).context("Failed to build Checkers")?;
    Ok(())
}

fn validate_node_address(node_address: &NodeAddress) -> Result<()> {
    let scheme = node_address.url.scheme();
    if !["http", "https"].contains(&scheme) {
        bail!("node_address URL must use http or https scheme, got: {}", scheme);
    }
    
    // Test that ports can be set
    let mut test_url = node_address.url.clone();
    test_url.set_port(Some(8080))
        .map_err(|_| anyhow!("node_address URL scheme {} does not support port assignment", scheme))?;
    
    Ok(())
}
```

**Error Handling Fix:**
In `node_address.rs`, replace `.unwrap()` calls:
```rust
pub fn get_api_url(&self) -> Result<Url> {
    let mut url = self.url.clone();
    url.set_port(Some(
        self.api_port.context("Can't build API URL without an API port")?,
    ))
    .map_err(|_| anyhow!("URL scheme {} does not support port assignment", url.scheme()))?;
    Ok(url)
}

pub fn get_metrics_url(&self, path: &str) -> Result<Url> {
    let mut url = self.url.clone();
    url.set_port(Some(
        self.api_port.context("Can't build metrics URL without a metrics port")?,
    ))
    .map_err(|_| anyhow!("URL scheme {} does not support port assignment", url.scheme()))?;
    url.set_path(path);
    Ok(url)
}
```

## Proof of Concept

**Malicious Configuration File (config_crash.yaml):**
```yaml
node_address:
  url: "mailto:attacker@example.com"
  api_port: 8080
  metrics_port: 9101

configuration_id: "test_config"
configuration_name: "Test Configuration"
checkers: []
```

**Reproduction Steps:**
```bash
# 1. Create malicious configuration
cat > /tmp/config_crash.yaml << 'EOF'
node_address:
  url: "mailto:attacker@example.com"
  api_port: 8080
  metrics_port: 9101

configuration_id: "crash_test"
configuration_name: "Crash Test Config"
checkers: []
EOF

# 2. Attempt to validate configuration
cargo run -p aptos-node-checker -- configuration validate --path /tmp/config_crash.yaml

# Expected: Validation passes (BUG)
# Then on actual use: Service crashes with panic in set_port().unwrap()
```

**Alternative PoC schemes that trigger the bug:**
- `data:text/plain,hello` 
- `javascript:alert('test')`
- `file:///etc/passwd` (on some platforms)

The panic occurs because `Url::set_port()` returns `Result<(), ()>` and returns `Err(())` when the URL is cannot-be-a-base or the scheme doesn't support ports.

## Notes

This vulnerability is limited to the node-checker ecosystem component and does not affect core Aptos blockchain consensus, execution, or state management. The node-checker is a peripheral health-checking service, not a validator-critical component. While the bug is real and exploitable, its impact is confined to service availability of the monitoring infrastructure rather than blockchain security.

### Citations

**File:** ecosystem/node-checker/src/configuration/validate.rs (L24-27)
```rust
pub fn validate_configuration(node_configuration: &BaselineConfiguration) -> Result<()> {
    build_checkers(&node_configuration.checkers).context("Failed to build Checkers")?;
    Ok(())
}
```

**File:** ecosystem/node-checker/src/configuration/types.rs (L11-16)
```rust
pub struct BaselineConfiguration {
    /// The address of the baseline node to use for this configuration. This is
    /// only necessary if this baseline configuration uses a Checker that
    /// requires information from a baseline node to operate.
    pub node_address: Option<NodeAddress>,

```

**File:** ecosystem/node-checker/src/configuration/node_address.rs (L73-81)
```rust
    pub fn get_api_url(&self) -> Result<Url> {
        let mut url = self.url.clone();
        url.set_port(Some(
            self.api_port
                .context("Can't build API URL without an API port")?,
        ))
        .unwrap();
        Ok(url)
    }
```

**File:** ecosystem/node-checker/src/configuration/node_address.rs (L83-92)
```rust
    pub fn get_metrics_url(&self, path: &str) -> Result<Url> {
        let mut url = self.url.clone();
        url.set_port(Some(
            self.api_port
                .context("Can't build metrics URL without a metrics port")?,
        ))
        .unwrap();
        url.set_path(path);
        Ok(url)
    }
```

**File:** ecosystem/node-checker/src/configuration/node_address.rs (L107-115)
```rust
    pub fn get_api_client(&self, timeout: Duration) -> Result<AptosRestClient> {
        let client = reqwest::ClientBuilder::new()
            .timeout(timeout)
            .cookie_provider(self.cookie_store.clone())
            .build()
            .unwrap();

        Ok(AptosRestClient::from((client, self.get_api_url()?)))
    }
```

**File:** ecosystem/node-checker/src/runner/sync_runner.rs (L104-123)
```rust
        if let Ok(metrics_client) = target_node_address.get_metrics_client(Duration::from_secs(4)) {
            let metrics_client = Arc::new(metrics_client);
            provider_collection.target_metrics_provider = Some(MetricsProvider::new(
                self.provider_configs.metrics.clone(),
                metrics_client.clone(),
                target_node_address.url.clone(),
                target_node_address.get_metrics_port().unwrap(),
            ));
            provider_collection.target_system_information_provider =
                Some(SystemInformationProvider::new(
                    self.provider_configs.system_information.clone(),
                    metrics_client,
                    target_node_address.url.clone(),
                    target_node_address.get_metrics_port().unwrap(),
                ));
        }

        // Build the ApiIndexProvider for the target node.
        if let Ok(api_client) = target_node_address.get_api_client(Duration::from_secs(4)) {
            let api_index_provider = Arc::new(ApiIndexProvider::new(
```
