# Audit Report

## Title
Lack of Runtime Range Validation for Native Gas Parameters Enables Consensus Divergence via Validator Misconfiguration

## Summary
The Aptos VM loads native function gas parameters from on-chain storage without any runtime range validation beyond checking parameter existence. Combined with saturating arithmetic in gas calculations, this allows validators running with misconfigured gas parameters to produce different `gas_used` values for identical transactions, breaking the deterministic execution invariant and causing consensus divergence.

## Finding Description

The `aptos_natives()` function in `natives.rs` creates a native function table using gas parameters loaded from on-chain configuration: [1](#0-0) 

These parameters are passed to `SafeNativeBuilder::new()` without any validation: [2](#0-1) 

The gas parameters are loaded via `from_on_chain_gas_schedule()`, which only validates parameter **existence**, not **values**: [3](#0-2) 

When native functions charge gas, the arithmetic uses **saturating operations**: [4](#0-3) [5](#0-4) 

The `gas_used` value is calculated as `max_gas_amount - gas_meter.balance()`: [6](#0-5) 

Critically, this `gas_used` value is included in `TransactionInfo`, which is hashed for consensus: [7](#0-6) 

**The Attack Path:**

1. **Validator Misconfiguration**: A validator operator accidentally or maliciously runs a node with modified gas parameters (e.g., using test values, outdated configuration, or corrupted storage)
2. **Divergent Gas Calculation**: When executing native functions, the misconfigured validator computes different gas amounts due to different parameter values
3. **Different gas_used**: The final `gas_used` value differs from correctly configured validators
4. **Consensus Break**: Different `gas_used` → different `TransactionInfo` hash → different transaction accumulator root → different block execution result → consensus divergence

**Why Existing Validations Don't Help:**

The `check_gas()` function only validates **transaction** gas parameters: [8](#0-7) 

It does NOT validate the **native function** gas parameters stored in `NativeGasParameters`.

## Impact Explanation

**Severity: High** (Validator node operational issues causing liveness degradation)

This vulnerability can cause:

1. **Consensus Liveness Failure**: Misconfigured validators produce different state roots, causing block proposals to be rejected by correctly configured validators
2. **Network Partition Risk**: If multiple validators are misconfigured identically, the network could split into two consensus groups
3. **No Detection Mechanism**: There are no runtime assertions or monitoring to detect when validators compute different gas amounts
4. **Silent Failure**: Saturating arithmetic masks overflow conditions that could indicate misconfiguration

While this doesn't meet "Critical" severity (as it requires validator misconfiguration rather than being exploitable by unprivileged attackers), it represents a significant **defense-in-depth failure** that can cause network disruption.

## Likelihood Explanation

**Likelihood: Medium**

While validators are expected to load gas parameters from the same on-chain state, misconfiguration scenarios include:

1. **Operational Errors**: Validator operators running outdated binaries, test configurations in production, or corrupted storage
2. **Epoch Transitions**: Race conditions during gas parameter updates via governance could cause temporary divergence
3. **Software Bugs**: Bugs in gas parameter loading logic could cause validators to deserialize values differently
4. **Manual Intervention**: Emergency patches or manual overrides during incidents

The impact is HIGH because there's no safety net - the system has no runtime checks to prevent or detect this condition.

## Recommendation

Add runtime validation for native gas parameters with reasonable bounds:

```rust
impl NativeGasParameters {
    pub fn validate(&self) -> Result<(), String> {
        // Define maximum reasonable values (example: 1M internal gas units)
        const MAX_REASONABLE_GAS: u64 = 1_000_000;
        
        // Validate all gas parameters are within bounds
        for param in self.all_parameters() {
            if param > MAX_REASONABLE_GAS {
                return Err(format!(
                    "Native gas parameter {} exceeds maximum: {} > {}",
                    param.name(), param.value(), MAX_REASONABLE_GAS
                ));
            }
        }
        Ok(())
    }
}
```

Then call this validation when creating the native function table:

```rust
pub fn aptos_natives(
    gas_feature_version: u64,
    native_gas_params: NativeGasParameters,
    misc_gas_params: MiscGasParameters,
    timed_features: TimedFeatures,
    features: Features,
) -> NativeFunctionTable {
    // Validate gas parameters are within expected ranges
    native_gas_params.validate()
        .expect("Native gas parameters validation failed");
    
    let mut builder = SafeNativeBuilder::new(
        gas_feature_version,
        native_gas_params,
        misc_gas_params,
        timed_features,
        features,
        None,
    );

    aptos_natives_with_builder(&mut builder, false)
}
```

Additionally, add logging/metrics when gas calculations saturate to detect potential issues.

## Proof of Concept

```rust
#[test]
fn test_misconfigured_gas_causes_divergence() {
    // Validator A: Correctly configured
    let correct_params = NativeGasParameters::initial();
    
    // Validator B: Misconfigured with extreme value
    let mut misconfigured_params = NativeGasParameters::initial();
    misconfigured_params.move_stdlib.bcs_to_bytes.base = u64::MAX.into();
    
    // Execute same transaction on both configurations
    let txn = create_bcs_serialization_transaction();
    
    let gas_used_a = execute_with_params(&txn, correct_params);
    let gas_used_b = execute_with_params(&txn, misconfigured_params);
    
    // Validators compute different gas amounts
    assert_ne!(gas_used_a, gas_used_b);
    
    // This leads to different TransactionInfo hashes
    let info_a = TransactionInfo::new(/* ... gas_used_a ... */);
    let info_b = TransactionInfo::new(/* ... gas_used_b ... */);
    
    assert_ne!(info_a.hash(), info_b.hash());
    // Consensus divergence!
}
```

## Notes

While all validators **should** load identical gas parameters from on-chain storage, the lack of validation creates a defense-in-depth gap. The system cannot detect or prevent misconfiguration, and saturating arithmetic silently masks potential bugs. This violates the principle that critical infrastructure should validate all assumptions at runtime.

### Citations

**File:** aptos-move/aptos-vm/src/natives.rs (L142-159)
```rust
pub fn aptos_natives(
    gas_feature_version: u64,
    native_gas_params: NativeGasParameters,
    misc_gas_params: MiscGasParameters,
    timed_features: TimedFeatures,
    features: Features,
) -> NativeFunctionTable {
    let mut builder = SafeNativeBuilder::new(
        gas_feature_version,
        native_gas_params,
        misc_gas_params,
        timed_features,
        features,
        None,
    );

    aptos_natives_with_builder(&mut builder, false)
}
```

**File:** aptos-move/aptos-native-interface/src/builder.rs (L38-60)
```rust
    /// Creates a new safe native builder.
    ///
    /// The configurations provided will be accessible by all native functions created later.
    pub fn new(
        gas_feature_version: u64,
        native_gas_params: NativeGasParameters,
        misc_gas_params: MiscGasParameters,
        timed_features: TimedFeatures,
        features: Features,
        gas_hook: Option<Arc<dyn Fn(DynamicExpression) + Send + Sync>>,
    ) -> Self {
        Self {
            data: Arc::new(SharedData {
                gas_feature_version,
                native_gas_params,
                misc_gas_params,
                timed_features,
                features,
            }),
            enable_incremental_gas_charging: true,
            gas_hook,
        }
    }
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/macros.rs (L34-45)
```rust
            fn from_on_chain_gas_schedule(gas_schedule: &std::collections::BTreeMap<String, u64>, feature_version: u64) -> Result<Self, String> {
                let mut params = $params_name::zeros();

                $(
                    if let Some(key) = $crate::gas_schedule::macros::define_gas_parameters_extract_key_at_version!($key_bindings, feature_version) {
                        let name = format!("{}.{}", $prefix, key);
                        params.$name = gas_schedule.get(&name).cloned().ok_or_else(|| format!("Gas parameter {} does not exist. Feature version: {}.", name, feature_version))?.into();
                    }
                )*

                Ok(params)
            }
```

**File:** third_party/move/move-core/types/src/gas_algebra.rs (L205-211)
```rust
impl<U> Add<GasQuantity<U>> for GasQuantity<U> {
    type Output = Self;

    fn add(self, rhs: Self) -> Self::Output {
        Self::new(self.val.saturating_add(rhs.val))
    }
}
```

**File:** third_party/move/move-core/types/src/gas_algebra.rs (L229-231)
```rust
fn mul_impl<U1, U2>(x: GasQuantity<U2>, y: GasQuantity<UnitDiv<U1, U2>>) -> GasQuantity<U1> {
    GasQuantity::new(x.val.saturating_mul(y.val))
}
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L2732-2737)
```rust
    fn gas_used(max_gas_amount: Gas, gas_meter: &impl AptosGasMeter) -> u64 {
        max_gas_amount
            .checked_sub(gas_meter.balance())
            .expect("Balance should always be less than or equal to max gas amount")
            .into()
    }
```

**File:** types/src/transaction/mod.rs (L2025-2072)
```rust
pub struct TransactionInfoV0 {
    /// The amount of gas used.
    gas_used: u64,

    /// The vm status. If it is not `Executed`, this will provide the general error class. Execution
    /// failures and Move abort's receive more detailed information. But other errors are generally
    /// categorized with no status code or other information
    status: ExecutionStatus,

    /// The hash of this transaction.
    transaction_hash: HashValue,

    /// The root hash of Merkle Accumulator storing all events emitted during this transaction.
    event_root_hash: HashValue,

    /// The hash value summarizing all changes caused to the world state by this transaction.
    /// i.e. hash of the output write set.
    state_change_hash: HashValue,

    /// The root hash of the Sparse Merkle Tree describing the world state at the end of this
    /// transaction. Depending on the protocol configuration, this can be generated periodical
    /// only, like per block.
    state_checkpoint_hash: Option<HashValue>,

    /// The hash value summarizing PersistedAuxiliaryInfo.
    auxiliary_info_hash: Option<HashValue>,
}

impl TransactionInfoV0 {
    pub fn new(
        transaction_hash: HashValue,
        state_change_hash: HashValue,
        event_root_hash: HashValue,
        state_checkpoint_hash: Option<HashValue>,
        gas_used: u64,
        status: ExecutionStatus,
        auxiliary_info_hash: Option<HashValue>,
    ) -> Self {
        Self {
            gas_used,
            status,
            transaction_hash,
            event_root_hash,
            state_change_hash,
            state_checkpoint_hash,
            auxiliary_info_hash,
        }
    }
```

**File:** aptos-move/aptos-vm/src/gas.rs (L70-79)
```rust
pub(crate) fn check_gas(
    gas_params: &AptosGasParameters,
    gas_feature_version: u64,
    resolver: &impl AptosMoveResolver,
    module_storage: &impl ModuleStorage,
    txn_metadata: &TransactionMetadata,
    features: &Features,
    is_approved_gov_script: bool,
    log_context: &AdapterLogSchema,
) -> Result<(), VMStatus> {
```
