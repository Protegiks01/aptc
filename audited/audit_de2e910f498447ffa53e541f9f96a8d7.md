# Audit Report

## Title
Memory Exhaustion via Unbounded HTTP Request Headers in Inspection Service

## Summary
The Aptos inspection service lacks request size limits for HTTP headers and bodies, allowing unprivileged attackers to exhaust validator node memory through specially crafted requests. This can cause validator slowdowns or crashes, affecting network participation and consensus liveness.

## Finding Description

The inspection service uses hyper 0.14.18 to handle HTTP requests but does not configure any limits on request header sizes or body sizes. [1](#0-0) 

The service binds to `0.0.0.0` by default, exposing it to external networks: [2](#0-1) 

Unlike other HTTP services in the codebase, the inspection service has no size limit configuration. The API service explicitly defines an 8MB content length limit: [3](#0-2) [4](#0-3) 

The telemetry service defines a 1MB limit: [5](#0-4) 

And actively enforces it using warp's content_length_limit: [6](#0-5) 

The inspection service has no such configuration in its config struct: [7](#0-6) 

**Attack Vector:**
An attacker can send HTTP requests with:
1. Extremely large headers (e.g., 1000 custom headers of 8KB each = 8MB per request)
2. Large request bodies (even though GET/HEAD ignore bodies, memory is consumed during parsing)
3. Multiple concurrent requests to amplify memory exhaustion

The vulnerability exists because hyper 0.14.18 (workspace dependency): [8](#0-7)  does not impose strict limits by default, and the codebase does not configure `http1_max_buf_size()` or similar restrictions.

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos bug bounty program ("Validator node slowdowns"). 

The inspection service runs in the same process as the validator node. Memory exhaustion attacks can cause:
- **Validator Performance Degradation**: OOM pressure forces garbage collection, slowing block processing
- **Missed Consensus Rounds**: Slowdowns may cause the validator to miss proposal deadlines
- **Node Crashes**: Severe memory exhaustion can terminate the entire validator process
- **Network Liveness Impact**: If multiple validators are attacked simultaneously, network liveness could be degraded

This breaks the **Resource Limits** invariant (#9): "All operations must respect gas, storage, and computational limits."

## Likelihood Explanation

**Likelihood: High**

- The inspection service is exposed on `0.0.0.0:9101` by default, accepting connections from any network interface
- No authentication is required for endpoints like `/metrics`, `/peer_information`, `/system_information`
- Attack requires only standard HTTP clients (curl, custom scripts)
- Multiple endpoints can amplify the attack: [9](#0-8) 
- No rate limiting or request throttling is implemented

## Recommendation

Add request size limits to the inspection service configuration and enforce them using hyper's builder methods.

**1. Add configuration fields:**
```rust
// In config/src/config/inspection_service_config.rs
pub struct InspectionServiceConfig {
    // ... existing fields ...
    pub max_request_header_size: Option<u64>,
    pub max_request_body_size: Option<u64>,
}

const DEFAULT_MAX_HEADER_SIZE: u64 = 16 * 1024; // 16KB
const DEFAULT_MAX_BODY_SIZE: u64 = 1024 * 1024; // 1MB
```

**2. Configure hyper server with limits:**
```rust
// In crates/aptos-inspection-service/src/server/mod.rs
use hyper::server::conn::Http;

let server = Server::bind(&address)
    .http1_max_buf_size(max_header_size)
    .serve(make_service);
```

**3. Add explicit body size checking in serve_requests:**
```rust
async fn serve_requests(...) -> Result<Response<Body>, hyper::Error> {
    // Check Content-Length header before processing
    if let Some(content_length) = req.headers().get(hyper::header::CONTENT_LENGTH) {
        if let Ok(length_str) = content_length.to_str() {
            if let Ok(length) = length_str.parse::<u64>() {
                if length > max_body_size {
                    return Ok(Response::builder()
                        .status(StatusCode::PAYLOAD_TOO_LARGE)
                        .body(Body::from("Request body too large"))
                        .unwrap());
                }
            }
        }
    }
    // ... existing request handling ...
}
```

## Proof of Concept

```rust
// Test file: crates/aptos-inspection-service/src/server/test_dos.rs
#[tokio::test]
async fn test_large_header_request() {
    use hyper::{Client, Request, Body, header::HeaderValue};
    
    // Start inspection service on localhost
    let node_config = NodeConfig::default();
    start_inspection_service(node_config, aptos_data_client, peers_and_metadata);
    
    // Create client
    let client = Client::new();
    
    // Build request with 1000 large custom headers (8KB each = 8MB total)
    let mut request_builder = Request::builder()
        .method("GET")
        .uri("http://127.0.0.1:9101/metrics");
    
    for i in 0..1000 {
        let header_name = format!("X-Custom-Header-{}", i);
        let header_value = "A".repeat(8192); // 8KB
        request_builder = request_builder.header(
            header_name.as_str(),
            HeaderValue::from_str(&header_value).unwrap()
        );
    }
    
    let request = request_builder.body(Body::empty()).unwrap();
    
    // Send request - should either be rejected or cause memory spike
    let response = client.request(request).await;
    
    // Without limits, this succeeds and consumes ~8MB memory per request
    // With limits, this should return 431 (Request Header Fields Too Large)
    assert!(response.is_err() || response.unwrap().status() == 431);
}

#[tokio::test] 
async fn test_concurrent_large_requests() {
    // Send 100 concurrent requests with large headers
    // Without limits: causes significant memory exhaustion (800MB+)
    // With limits: requests are rejected, memory usage remains bounded
    let mut handles = vec![];
    
    for _ in 0..100 {
        let handle = tokio::spawn(async {
            test_large_header_request().await;
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.await.unwrap();
    }
}
```

## Notes

This vulnerability affects not just the inspection service, but also:
- **Admin Service**: Uses identical pattern without size limits [10](#0-9) 
- **Pepper Service**: Actively reads request bodies without size checks [11](#0-10) 

All three services should be patched with appropriate size limits. The inspection service is highest priority due to default exposure on validator nodes.

### Citations

**File:** crates/aptos-inspection-service/src/server/mod.rs (L32-41)
```rust
// The list of endpoints offered by the inspection service
pub const CONFIGURATION_PATH: &str = "/configuration";
pub const CONSENSUS_HEALTH_CHECK_PATH: &str = "/consensus_health_check";
pub const FORGE_METRICS_PATH: &str = "/forge_metrics";
pub const IDENTITY_INFORMATION_PATH: &str = "/identity_information";
pub const INDEX_PATH: &str = "/";
pub const JSON_METRICS_PATH: &str = "/json_metrics";
pub const METRICS_PATH: &str = "/metrics";
pub const PEER_INFORMATION_PATH: &str = "/peer_information";
pub const SYSTEM_INFORMATION_PATH: &str = "/system_information";
```

**File:** crates/aptos-inspection-service/src/server/mod.rs (L94-99)
```rust
        runtime
            .block_on(async {
                let server = Server::bind(&address).serve(make_service);
                server.await
            })
            .unwrap();
```

**File:** config/src/config/inspection_service_config.rs (L15-24)
```rust
#[derive(Clone, Debug, Deserialize, PartialEq, Eq, Serialize)]
#[serde(default, deny_unknown_fields)]
pub struct InspectionServiceConfig {
    pub address: String,
    pub port: u16,
    pub expose_configuration: bool,
    pub expose_identity_information: bool,
    pub expose_peer_information: bool,
    pub expose_system_information: bool,
}
```

**File:** config/src/config/inspection_service_config.rs (L26-36)
```rust
impl Default for InspectionServiceConfig {
    fn default() -> InspectionServiceConfig {
        InspectionServiceConfig {
            address: "0.0.0.0".to_string(),
            port: 9101,
            expose_configuration: false,
            expose_identity_information: true,
            expose_peer_information: true,
            expose_system_information: true,
        }
    }
```

**File:** config/src/config/api_config.rs (L29-31)
```rust
    /// A maximum limit to the body of a POST request in bytes
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub content_length_limit: Option<u64>,
```

**File:** config/src/config/api_config.rs (L97-97)
```rust
const DEFAULT_REQUEST_CONTENT_LENGTH_LIMIT: u64 = 8 * 1024 * 1024; // 8 MB
```

**File:** crates/aptos-telemetry-service/src/constants.rs (L4-5)
```rust
/// The maximum content length to accept in the http body.
pub const MAX_CONTENT_LENGTH: u64 = 1024 * 1024;
```

**File:** crates/aptos-telemetry-service/src/log_ingest.rs (L35-35)
```rust
        .and(warp::body::content_length_limit(MAX_CONTENT_LENGTH))
```

**File:** Cargo.toml (L654-654)
```text
hyper = { version = "0.14.18", features = ["full"] }
```

**File:** crates/aptos-admin-service/src/server/mod.rs (L136-136)
```rust
            let server = Server::bind(&address).serve(make_service);
```

**File:** keyless/pepper/service/src/request_handler.rs (L88-95)
```rust
    let request_body = request.into_body();
    let request_bytes = match hyper::body::to_bytes(request_body).await {
        Ok(request_bytes) => request_bytes,
        Err(error) => {
            error!("Failed to get request body bytes: {}", error);
            return generate_internal_server_error_response(origin);
        },
    };
```
