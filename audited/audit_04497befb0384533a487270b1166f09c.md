# Audit Report

## Title
Unhandled Panic Propagation in Native Hash Functions Leading to Validator Node Crash

## Summary
The native hash functions in `aptos-move/framework/src/natives/hash.rs` lack panic handling at the execution layer. If any underlying hash library panics during transaction execution, the panic will propagate through the Move VM and trigger the crash handler, causing the entire validator node process to terminate via `process::exit(12)`. This creates a potential denial-of-service vector that can halt transaction processing network-wide.

## Finding Description

The Aptos VM implements panic handling for bytecode verification and module deserialization using `std::panic::catch_unwind`, but **does not** implement panic handling for native function execution. This architectural inconsistency creates a vulnerability where panics in native hash functions cause validator node crashes.

### Panic Propagation Path

1. **Native hash functions** are called during Move bytecode execution [1](#0-0) 

2. **Native function invocation** occurs in the interpreter without panic guards [2](#0-1) 

3. **Native function wrapper** in SafeNativeBuilder lacks `catch_unwind` protection [3](#0-2) 

4. **Crash handler** terminates the process when VMState is not VERIFIER or DESERIALIZER [4](#0-3) 

### Architectural Inconsistency

The codebase has explicit panic handling in:
- **Bytecode verification**: Uses `catch_unwind` [5](#0-4) 
- **Module deserialization**: Uses `catch_unwind` [6](#0-5) 
- **Transaction validation**: Uses `catch_unwind` [7](#0-6) 

But **no panic handling** exists for transaction execution, including native function calls.

### Breaking Invariants

This vulnerability breaks multiple critical invariants:

1. **Deterministic Execution**: If a panic is non-deterministic (e.g., due to race conditions or environment-specific conditions), different validators may crash at different times, creating consensus divergence.

2. **Liveness**: A transaction that triggers a panic in a hash function will cause all validators processing that transaction to crash, halting the network.

3. **Move VM Safety**: The VM should gracefully handle all errors during execution, but panics bypass error handling and terminate the process.

## Impact Explanation

**Severity: High** (per Aptos Bug Bounty criteria: "Validator node slowdowns" / "API crashes" / "Significant protocol violations")

### Impact Scenarios

1. **Single Validator Crash**: If a transaction triggers a panic on one validator, that node crashes and exits via `process::exit(12)`, removing it from the validator set temporarily.

2. **Network-Wide Halt**: If a transaction that triggers a panic is included in a block, all validators attempting to execute that block will crash, causing total network liveness failure.

3. **Consensus Split**: If the panic is non-deterministic (only triggers under certain environmental conditions), some validators may crash while others continue, potentially causing a chain split.

4. **Transaction Processing Halt**: Until the crashed nodes are manually restarted, transaction processing on those nodes is completely halted.

The crash handler explicitly terminates the process when a panic occurs outside of verification/deserialization contexts [8](#0-7) 

## Likelihood Explanation

**Likelihood: Low-to-Medium**

While triggering a panic in well-tested cryptographic libraries (siphasher, tiny_keccak, sha2, sha3, blake2_rfc, ripemd) is unlikely under normal circumstances, several factors increase the likelihood:

1. **No Explicit Panic Safety**: Rust crates are not required to be panic-free. Even well-tested libraries can have edge cases or bugs.

2. **Transitive Dependencies**: Hash libraries depend on other crates that could introduce panics.

3. **Future Updates**: Library updates could introduce panics or change behavior.

4. **Memory Allocation**: The `.to_vec()` conversions in hash functions could panic on memory allocation failures [9](#0-8) 

5. **Architectural Vulnerability**: The lack of defensive programming (no panic guards) means any unexpected panic immediately crashes the node.

The vulnerability exists even if current exploitation is difficult, because the system lacks the defense-in-depth that exists in other VM components.

## Recommendation

Add `catch_unwind` protection to native function execution, consistent with the approach used for verification and deserialization.

### Recommended Fix

Modify `SafeNativeBuilder::make_native` to wrap native function calls with panic handling:

```rust
// In aptos-move/aptos-native-interface/src/builder.rs
pub fn make_native<F>(&self, native: F) -> NativeFunction
where
    F: for<'a> Fn(...) -> SafeNativeResult<SmallVec<[Value; 1]>>
        + Send + Sync + 'static + std::panic::UnwindSafe,
{
    let data = Arc::clone(&self.data);
    let hook = self.gas_hook.clone();
    let enable_incremental_gas_charging = self.enable_incremental_gas_charging;

    let closure = move |context: &mut NativeContext, ty_args: &[Type], args| {
        use SafeNativeError::*;

        let mut context = SafeNativeContext { /* ... */ };

        // Add panic catching similar to verifier
        let res: Result<SmallVec<[Value; 1]>, SafeNativeError> = 
            std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
                native(&mut context, ty_args, args)
            }))
            .unwrap_or_else(|_| {
                Err(SafeNativeError::InvariantViolation(
                    PartialVMError::new(StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR)
                        .with_message("Native function panicked".to_string())
                ))
            });

        // ... rest of error handling
    };

    Arc::new(closure)
}
```

This ensures that panics in native functions are caught and converted to VM errors rather than crashing the node.

## Proof of Concept

While I cannot provide a concrete PoC that triggers a panic in the current hash library implementations (as they are well-tested and designed to handle arbitrary input), the vulnerability can be demonstrated by showing the panic propagation path:

```rust
// Hypothetical scenario: If a hash library has a bug that panics
// Example: Suppose blake2_rfc panics on a specific input pattern

#[test]
fn test_hash_panic_propagation() {
    // This would require injecting a panic into a hash library
    // to demonstrate the propagation path
    
    // 1. Create a transaction that calls a hash function
    // 2. The hash function panics
    // 3. No catch_unwind exists in the execution path
    // 4. Panic propagates to crash handler
    // 5. process::exit(12) is called
    // 6. Validator node terminates
}
```

The architectural vulnerability is evident from the code structure: panic handling exists for verification and deserialization but not for execution [10](#0-9) 

## Notes

This is an **architectural security vulnerability** rather than a directly exploitable bug. The issue is the **absence of defensive programming** (panic guards) in the native function execution path, creating a potential attack surface. While current hash libraries are unlikely to panic, the lack of protection violates defense-in-depth principles and creates unnecessary risk.

The inconsistency is clear: other critical VM paths have panic protection, but native function execution does not. This should be remedied to match the security posture of verification and deserialization components.

### Citations

**File:** aptos-move/framework/src/natives/hash.rs (L24-176)
```rust
fn native_sip_hash(
    context: &mut SafeNativeContext,
    mut _ty_args: &[Type],
    mut args: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    debug_assert!(_ty_args.is_empty());
    debug_assert!(args.len() == 1);

    let bytes = safely_pop_arg!(args, Vec<u8>);

    let cost = HASH_SIP_HASH_BASE + HASH_SIP_HASH_PER_BYTE * NumBytes::new(bytes.len() as u64);
    context.charge(cost)?;

    // SipHash of the serialized bytes
    let mut hasher = siphasher::sip::SipHasher::new();
    hasher.write(&bytes);
    let hash = hasher.finish();

    Ok(smallvec![Value::u64(hash)])
}

fn native_keccak256(
    context: &mut SafeNativeContext,
    mut _ty_args: &[Type],
    mut args: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    debug_assert!(_ty_args.is_empty());
    debug_assert!(args.len() == 1);

    let bytes = safely_pop_arg!(args, Vec<u8>);

    let cost = HASH_KECCAK256_BASE + HASH_KECCAK256_PER_BYTE * NumBytes::new(bytes.len() as u64);
    context.charge(cost)?;

    let mut hasher = Keccak::v256();
    hasher.update(&bytes);
    let mut output = [0u8; 32];
    hasher.finalize(&mut output);

    Ok(smallvec![Value::vector_u8(output)])
}

fn native_sha2_512(
    context: &mut SafeNativeContext,
    mut _ty_args: &[Type],
    mut args: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    debug_assert!(_ty_args.is_empty());
    debug_assert!(args.len() == 1);

    let bytes = safely_pop_arg!(args, Vec<u8>);

    let cost = HASH_SHA2_512_BASE + HASH_SHA2_512_PER_BYTE * NumBytes::new(bytes.len() as u64);
    context.charge(cost)?;

    let mut hasher = sha2::Sha512::new();
    hasher.update(&bytes);
    let output = hasher.finalize().to_vec();

    Ok(smallvec![Value::vector_u8(output)])
}

fn native_sha3_512(
    context: &mut SafeNativeContext,
    mut _ty_args: &[Type],
    mut args: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    debug_assert!(_ty_args.is_empty());
    debug_assert!(args.len() == 1);

    let bytes = safely_pop_arg!(args, Vec<u8>);

    let cost = HASH_SHA3_512_BASE + HASH_SHA3_512_PER_BYTE * NumBytes::new(bytes.len() as u64);
    context.charge(cost)?;

    let mut hasher = sha3::Sha3_512::new();
    hasher.update(&bytes);
    let output = hasher.finalize().to_vec();

    Ok(smallvec![Value::vector_u8(output)])
}

#[derive(Debug, Clone)]
pub struct Blake2B256HashGasParameters {
    pub base: InternalGas,
    pub per_byte: InternalGasPerByte,
}

fn native_blake2b_256(
    context: &mut SafeNativeContext,
    mut _ty_args: &[Type],
    mut args: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    safely_assert_eq!(_ty_args.len(), 0);
    safely_assert_eq!(args.len(), 1);

    let bytes = safely_pop_arg!(args, Vec<u8>);

    context.charge(
        HASH_BLAKE2B_256_BASE + HASH_BLAKE2B_256_PER_BYTE * NumBytes::new(bytes.len() as u64),
    )?;

    let output = blake2_rfc::blake2b::blake2b(32, &[], &bytes)
        .as_bytes()
        .to_vec();

    Ok(smallvec![Value::vector_u8(output)])
}

#[derive(Debug, Clone)]
pub struct Ripemd160HashGasParameters {
    pub base: InternalGas,
    pub per_byte: InternalGasPerByte,
}

fn native_ripemd160(
    context: &mut SafeNativeContext,
    mut _ty_args: &[Type],
    mut args: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    debug_assert!(_ty_args.is_empty());
    debug_assert!(args.len() == 1);

    let bytes = safely_pop_arg!(args, Vec<u8>);

    let cost = HASH_RIPEMD160_BASE + HASH_RIPEMD160_PER_BYTE * NumBytes::new(bytes.len() as u64);
    context.charge(cost)?;

    let mut hasher = ripemd::Ripemd160::new();
    hasher.update(&bytes);
    let output = hasher.finalize().to_vec();

    Ok(smallvec![Value::vector_u8(output)])
}

/***************************************************************************************************
 * module
 *
 **************************************************************************************************/
pub fn make_all(
    builder: &SafeNativeBuilder,
) -> impl Iterator<Item = (String, NativeFunction)> + '_ {
    let natives = [
        ("sip_hash", native_sip_hash as RawSafeNative),
        ("keccak256", native_keccak256),
        ("sha2_512_internal", native_sha2_512),
        ("sha3_512_internal", native_sha3_512),
        ("ripemd160_internal", native_ripemd160),
        ("blake2b_256_internal", native_blake2b_256),
    ];

    builder.make_named_natives(natives)
}
```

**File:** third_party/move/move-vm/runtime/src/interpreter.rs (L1106-1106)
```rust
        let result = native_function(&mut native_context, ty_args, args)?;
```

**File:** aptos-move/aptos-native-interface/src/builder.rs (L98-118)
```rust
        let closure = move |context: &mut NativeContext, ty_args: &[Type], args| {
            use SafeNativeError::*;

            let mut context = SafeNativeContext {
                inner: context,

                timed_features: &data.timed_features,
                features: &data.features,
                gas_feature_version: data.gas_feature_version,
                native_gas_params: &data.native_gas_params,
                misc_gas_params: &data.misc_gas_params,

                legacy_gas_used: 0.into(),
                legacy_enable_incremental_gas_charging: enable_incremental_gas_charging,
                legacy_heap_memory_usage: 0,

                gas_hook: hook.as_deref(),
            };

            let res: Result<SmallVec<[Value; 1]>, SafeNativeError> =
                native(&mut context, ty_args, args);
```

**File:** crates/crash-handler/src/lib.rs (L52-57)
```rust
    if state::get_state() == VMState::VERIFIER || state::get_state() == VMState::DESERIALIZER {
        return;
    }

    // Kill the process
    process::exit(12);
```

**File:** third_party/move/move-bytecode-verifier/src/verifier.rs (L139-160)
```rust
    let result = std::panic::catch_unwind(|| {
        // Always needs to run bound checker first as subsequent passes depend on it
        BoundsChecker::verify_module(module).map_err(|e| {
            // We can't point the error at the module, because if bounds-checking
            // failed, we cannot safely index into module's handle to itself.
            e.finish(Location::Undefined)
        })?;
        FeatureVerifier::verify_module(config, module)?;
        LimitsVerifier::verify_module(config, module)?;
        DuplicationChecker::verify_module(module)?;

        signature_v2::verify_module(config, module)?;

        InstructionConsistency::verify_module(module)?;
        constants::verify_module(module)?;
        friends::verify_module(module)?;

        RecursiveStructDefChecker::verify_module(module)?;
        InstantiationLoopChecker::verify_module(module)?;
        CodeUnitVerifier::verify_module(config, module)?;

        // Add the failpoint injection to test the catch_unwind behavior.
```

**File:** third_party/move/move-binary-format/src/deserializer.rs (L57-57)
```rust
        let result = std::panic::catch_unwind(|| {
```

**File:** vm-validator/src/vm_validator.rs (L155-169)
```rust
        let result = std::panic::catch_unwind(move || {
            let vm_validator_locked = vm_validator.lock().unwrap();

            use aptos_vm::VMValidator;
            let vm = AptosVM::new(&vm_validator_locked.state.environment);
            vm.validate_transaction(
                txn,
                &vm_validator_locked.state.state_view,
                &vm_validator_locked.state,
            )
        });
        if let Err(err) = &result {
            error!("VMValidator panicked: {:?}", err);
        }
        result.map_err(|_| anyhow::anyhow!("panic validating transaction"))
```
