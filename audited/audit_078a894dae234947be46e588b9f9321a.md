# Audit Report

## Title
Missing Cryptographic Signature Verification in Database Integrity Checker Allows Tampered LedgerInfo to Pass Validation

## Summary
The `check_range_proof` database debugging tool retrieves LedgerInfo entries from the database and verifies range proofs against them without validating the cryptographic signatures on the LedgerInfo. This allows tampered or corrupted LedgerInfo entries with incorrect root hashes to pass verification, defeating the tool's purpose of detecting database inconsistencies.

## Finding Description

The `check_range_proof.rs` tool is designed to verify database integrity by checking transaction accumulator range proofs against LedgerInfo entries for each epoch. However, it fails to verify the cryptographic authenticity of the LedgerInfo entries themselves. [1](#0-0) 

At line 49, the tool retrieves a LedgerInfo using `get_latest_ledger_info_in_epoch(epoch)`. This method simply reads from the database without any signature verification: [2](#0-1) 

The `LedgerInfoWithSignatures` structure contains both the ledger information AND BLS aggregate signatures from validators, but these signatures are never verified by the tool. [3](#0-2) 

The `range_proof.verify()` call only validates the mathematical consistency of the Merkle proof against the provided root hash. It does NOT verify that the root hash itself comes from a legitimate, properly-signed LedgerInfo: [4](#0-3) 

This verify method only checks that the computed Merkle root matches the `expected_root_hash` parameter. It has no knowledge of cryptographic signatures.

**Contrast with Proper Verification:**

Throughout the Aptos codebase, LedgerInfo entries are properly verified using the `verify_signatures()` method before being trusted: [5](#0-4) 

In consensus code: [6](#0-5) 

In state synchronization: [7](#0-6) 

**Attack Scenario:**

If an attacker gains write access to database files (or tampers with a backup before restoration), or if database corruption occurs, they could:

1. Modify transaction info entries in the database
2. Create a fake LedgerInfo with a root hash that matches the modified transaction data
3. Insert this fake LedgerInfo into the database (bypassing signature creation since signatures are never checked)
4. Run `check_range_proof` tool
5. The tool retrieves the fake LedgerInfo without verifying signatures
6. The range proof verification succeeds because the proof is mathematically valid for the fake root hash
7. **The tampering/corruption is NOT detected**, giving operators false confidence in database integrity

## Impact Explanation

This qualifies as **Medium Severity** per Aptos bug bounty criteria: "State inconsistencies requiring intervention."

The vulnerability breaks the **State Consistency** invariant (#4): "State transitions must be atomic and verifiable via Merkle proofs." While the tool checks Merkle proof validity, it fails to verify the authenticity of the state root itself, allowing inconsistent state to go undetected.

**Specific harms:**
1. **False sense of security**: Operators using this tool to verify database integrity will receive "all checks passed" messages even when the database contains tampered/corrupted LedgerInfo entries
2. **Undetected corruption**: Non-malicious database corruption could result in invalid LedgerInfo entries that the tool fails to detect, leading to nodes continuing operation with corrupted state
3. **Backup validation failure**: Tampered database backups would pass verification checks, potentially propagating corrupted state across the network when restored
4. **Debugging ineffectiveness**: The tool's stated purpose is to verify database integrity, but it fails to detect an entire class of database inconsistencies

While this is a debugging tool rather than core consensus logic, its failure represents a significant operational security issue that could lead to state inconsistencies requiring manual intervention.

## Likelihood Explanation

**Likelihood: Medium**

The vulnerability can manifest in several realistic scenarios:

1. **Database corruption (non-malicious)**: Hardware failures, filesystem corruption, or software bugs could corrupt both LedgerInfo entries and transaction data. The tool would fail to detect this corruption if it's "self-consistent."

2. **Backup/restore tampering**: Attackers with access to database backups could modify them before restoration. Organizations often store backups in less-secured locations than live systems.

3. **Malicious validator with local access**: A compromised validator node operator could tamper with local database files. While they have privileged access, the tool should still detect such tampering.

The attack requires database write access, limiting exploitability to insider threats or compromised systems. However, the tool is specifically designed for integrity verification scenarios where such threats are the concern, making the omission significant.

## Recommendation

Add cryptographic signature verification before trusting LedgerInfo entries retrieved from the database. The tool should:

1. Retrieve the appropriate `ValidatorVerifier` for the epoch being checked
2. Call `verify_signatures()` on each LedgerInfo before using it for range proof verification
3. Fail verification if signatures are invalid or missing (except for genesis)

**Proposed fix for `check_range_proof.rs`:**

```rust
pub fn run(self) -> Result<()> {
    let ledger_db = Arc::new(self.db_dir.open_ledger_db()?);
    let ledger_metadata_db = ledger_db.metadata_db();
    let ledger_info = ledger_metadata_db.get_latest_ledger_info()?;
    println!("Latest LedgerInfo: {:?}", ledger_info);

    println!("Checking Range proof...");

    let txn_infos: Vec<_> = ledger_db
        .transaction_info_db()
        .get_transaction_info_iter(self.start_version, self.num_versions)?
        .collect::<Result<_>>()?;
    ensure!(
        txn_infos.len() == self.num_versions,
        "expecting {} txns, got {}",
        self.num_versions,
        txn_infos.len(),
    );
    let txn_info_hashes: Vec<_> = txn_infos.iter().map(CryptoHash::hash).collect();

    let last_version = self.start_version + self.num_versions as u64 - 1;
    let last_version_epoch = ledger_metadata_db.get_epoch(last_version)?;
    
    for epoch in last_version_epoch..=ledger_info.ledger_info().epoch() {
        println!("Check against epoch {} LedgerInfo.", epoch);
        let li = ledger_metadata_db.get_latest_ledger_info_in_epoch(epoch)?;
        
        // NEW: Verify signatures on the LedgerInfo before trusting it
        // Skip signature verification only for genesis (round 0)
        if li.ledger_info().round() > 0 {
            // Get validator verifier for this epoch
            let epoch_state = if epoch == 0 {
                // For epoch 0, use genesis epoch state
                ledger_info.ledger_info().next_epoch_state()
                    .ok_or_else(|| anyhow::anyhow!("Genesis missing epoch state"))?
            } else {
                // Get the epoch-ending LedgerInfo from previous epoch
                let prev_epoch_li = ledger_metadata_db.get_latest_ledger_info_in_epoch(epoch - 1)?;
                prev_epoch_li.ledger_info().next_epoch_state()
                    .ok_or_else(|| anyhow::anyhow!("Missing epoch state for epoch {}", epoch))?
            };
            
            // Verify signatures
            li.verify_signatures(&epoch_state.verifier)
                .context(format!("Failed to verify signatures for epoch {} LedgerInfo", epoch))?;
            println!("    âœ“ Signatures verified for epoch {}", epoch);
        }
        
        println!(
            "    Root hash: {:?}",
            li.ledger_info().transaction_accumulator_hash()
        );
        let range_proof = ledger_db
            .transaction_accumulator_db()
            .get_transaction_range_proof(
                Some(self.start_version),
                self.num_versions as u64,
                li.ledger_info().version(),
            )?;
        range_proof.verify(
            li.ledger_info().transaction_accumulator_hash(),
            Some(self.start_version),
            &txn_info_hashes,
        )?;
    }

    println!("Done.");
    Ok(())
}
```

## Proof of Concept

The following Rust test demonstrates the vulnerability by showing that a tampered LedgerInfo with incorrect signatures passes the current verification:

```rust
#[cfg(test)]
mod test {
    use super::*;
    use aptos_crypto::hash::{CryptoHash, HashValue};
    use aptos_types::{
        block_info::BlockInfo,
        ledger_info::{LedgerInfo, LedgerInfoWithSignatures},
        aggregate_signature::AggregateSignature,
        transaction::{TransactionInfo, Version},
    };
    use aptos_accumulator::MerkleAccumulator;
    use aptos_storage_interface::AptosDbError;

    #[test]
    fn test_tampered_ledger_info_passes_verification() {
        // This test demonstrates that the check_range_proof tool
        // would accept a tampered LedgerInfo because it doesn't verify signatures
        
        // Create some fake transaction infos
        let start_version: Version = 100;
        let num_versions = 10;
        let txn_infos: Vec<TransactionInfo> = (0..num_versions)
            .map(|_| TransactionInfo::new(
                HashValue::random(),
                HashValue::random(),
                HashValue::random(),
                HashValue::random(),
                0,
                0,
            ))
            .collect();
        
        let txn_info_hashes: Vec<HashValue> = txn_infos
            .iter()
            .map(|info| info.hash())
            .collect();
        
        // Compute the accumulator root for these transactions
        // In a real scenario, this would be in the database
        let mut accumulator = MerkleAccumulator::new_empty();
        for hash in &txn_info_hashes {
            accumulator.append(&[*hash]).unwrap();
        }
        let correct_root_hash = accumulator.root_hash();
        
        // Create a TAMPERED LedgerInfo with an INCORRECT root hash
        // In a real attack, an attacker would make this match their tampered transaction data
        let tampered_root_hash = HashValue::random();
        let tampered_ledger_info = LedgerInfo::new(
            BlockInfo::new(
                1, // epoch
                0, // round
                HashValue::zero(),
                tampered_root_hash, // WRONG root hash
                start_version + num_versions as u64 - 1,
                0,
                None,
            ),
            HashValue::zero(),
        );
        
        // Create LedgerInfoWithSignatures with EMPTY signatures (invalid!)
        let tampered_li_with_sigs = LedgerInfoWithSignatures::new(
            tampered_ledger_info,
            AggregateSignature::empty(), // No valid signatures!
        );
        
        // The current implementation would accept this tampered LedgerInfo
        // because it never calls verify_signatures()
        
        // If we try to verify signatures (which the tool SHOULD do), it fails:
        use aptos_types::validator_verifier::ValidatorVerifier;
        let verifier = ValidatorVerifier::new(vec![]);
        
        let sig_verification_result = tampered_li_with_sigs.verify_signatures(&verifier);
        
        // Signature verification correctly FAILS for the tampered LedgerInfo
        assert!(sig_verification_result.is_err(), 
            "Tampered LedgerInfo with empty signatures should fail verification");
        
        // However, the range proof verification step would still proceed
        // in the current implementation because signatures are never checked!
        println!("VULNERABILITY: Tampered LedgerInfo would be used without signature verification");
    }
}
```

## Notes

**Additional Context:**

1. **Not an isolated issue**: The sister tool `check_txn_info_hashes.rs` in the same directory also retrieves LedgerInfo without signature verification, suggesting this is a systemic pattern in the db_debugger tools.

2. **Backup handler also affected**: The `BackupHandler` in `storage/aptosdb/src/backup/backup_handler.rs` uses `get_latest_ledger_info_in_epoch()` to create proofs for backups. However, in that case, the LedgerInfoWithSignatures is returned to clients who are expected to verify signatures themselves before trusting the data.

3. **Defense in depth principle**: While this is "just" a debugging tool, security tools must be trustworthy. If integrity verification tools can be bypassed or give false positives, they become security liabilities rather than assets.

4. **Genesis exception**: The fix should handle genesis LedgerInfo (round 0) specially, as it legitimately has no signatures per protocol design.

The vulnerability is confirmed: **the verify call can succeed with an incorrect root hash from a tampered LedgerInfo, hiding ledger inconsistencies**, because signature verification is completely absent from the verification flow.

### Citations

**File:** storage/aptosdb/src/db_debugger/ledger/check_range_proof.rs (L49-49)
```rust
            let li = ledger_metadata_db.get_latest_ledger_info_in_epoch(epoch)?;
```

**File:** storage/aptosdb/src/db_debugger/ledger/check_range_proof.rs (L61-65)
```rust
            range_proof.verify(
                li.ledger_info().transaction_accumulator_hash(),
                Some(self.start_version),
                &txn_info_hashes,
            )?;
```

**File:** storage/aptosdb/src/ledger_db/ledger_metadata_db.rs (L113-120)
```rust
    pub(crate) fn get_latest_ledger_info_in_epoch(
        &self,
        epoch: u64,
    ) -> Result<LedgerInfoWithSignatures> {
        self.db
            .get::<LedgerInfoSchema>(&epoch)?
            .ok_or_else(|| AptosDbError::NotFound(format!("Last LedgerInfo of epoch {epoch}")))
    }
```

**File:** types/src/proof/definition.rs (L618-714)
```rust
    pub fn verify(
        &self,
        expected_root_hash: HashValue,
        first_leaf_index: Option<u64>,
        leaf_hashes: &[HashValue],
    ) -> Result<()> {
        if first_leaf_index.is_none() {
            ensure!(
                leaf_hashes.is_empty(),
                "first_leaf_index indicated empty list while leaf_hashes is not empty.",
            );
            ensure!(
                self.left_siblings.is_empty() && self.right_siblings.is_empty(),
                "No siblings are needed.",
            );
            return Ok(());
        }

        ensure!(
            self.left_siblings.len() <= MAX_ACCUMULATOR_PROOF_DEPTH,
            "Proof has more than {} ({}) left siblings.",
            MAX_ACCUMULATOR_PROOF_DEPTH,
            self.left_siblings.len(),
        );
        ensure!(
            self.right_siblings.len() <= MAX_ACCUMULATOR_PROOF_DEPTH,
            "Proof has more than {} ({}) right siblings.",
            MAX_ACCUMULATOR_PROOF_DEPTH,
            self.right_siblings.len(),
        );
        ensure!(
            !leaf_hashes.is_empty(),
            "leaf_hashes is empty while first_leaf_index indicated non-empty list.",
        );

        let mut left_sibling_iter = self.left_siblings.iter().peekable();
        let mut right_sibling_iter = self.right_siblings.iter().peekable();

        let mut first_pos = Position::from_leaf_index(
            first_leaf_index.expect("first_leaf_index should not be None."),
        );
        let mut current_hashes = leaf_hashes.to_vec();
        let mut parent_hashes = vec![];

        // Keep reducing the list of hashes by combining all the children pairs, until there is
        // only one hash left.
        while current_hashes.len() > 1
            || left_sibling_iter.peek().is_some()
            || right_sibling_iter.peek().is_some()
        {
            let mut children_iter = current_hashes.iter();

            // If the first position on the current level is a right child, it needs to be combined
            // with a sibling on the left.
            if first_pos.is_right_child() {
                let left_hash = *left_sibling_iter.next().ok_or_else(|| {
                    format_err!("First child is a right child, but missing sibling on the left.")
                })?;
                let right_hash = *children_iter.next().expect("The first leaf must exist.");
                parent_hashes.push(MerkleTreeInternalNode::<H>::new(left_hash, right_hash).hash());
            }

            // Next we take two children at a time and compute their parents.
            let mut children_iter = children_iter.as_slice().chunks_exact(2);
            for chunk in children_iter.by_ref() {
                let left_hash = chunk[0];
                let right_hash = chunk[1];
                parent_hashes.push(MerkleTreeInternalNode::<H>::new(left_hash, right_hash).hash());
            }

            // Similarly, if the last position is a left child, it needs to be combined with a
            // sibling on the right.
            let remainder = children_iter.remainder();
            assert!(remainder.len() <= 1);
            if !remainder.is_empty() {
                let left_hash = remainder[0];
                let right_hash = *right_sibling_iter.next().ok_or_else(|| {
                    format_err!("Last child is a left child, but missing sibling on the right.")
                })?;
                parent_hashes.push(MerkleTreeInternalNode::<H>::new(left_hash, right_hash).hash());
            }

            first_pos = first_pos.parent();
            current_hashes.clear();
            std::mem::swap(&mut current_hashes, &mut parent_hashes);
        }

        ensure!(
            current_hashes[0] == expected_root_hash,
            "{}: Root hashes do not match. Actual root hash: {:x}. Expected root hash: {:x}.",
            type_name::<Self>(),
            current_hashes[0],
            expected_root_hash,
        );

        Ok(())
    }
```

**File:** types/src/ledger_info.rs (L303-308)
```rust
    pub fn verify_signatures(
        &self,
        validator: &ValidatorVerifier,
    ) -> ::std::result::Result<(), VerifyError> {
        validator.verify_multi_signatures(self.ledger_info(), &self.signatures)
    }
```

**File:** consensus/consensus-types/src/wrapped_ledger_info.rs (L104-106)
```rust
        self.ledger_info()
            .verify_signatures(validator)
            .context("Fail to verify WrappedLedgerInfo")?;
```

**File:** types/src/epoch_state.rs (L40-50)
```rust
impl Verifier for EpochState {
    fn verify(&self, ledger_info: &LedgerInfoWithSignatures) -> anyhow::Result<()> {
        ensure!(
            self.epoch == ledger_info.ledger_info().epoch(),
            "LedgerInfo has unexpected epoch {}, expected {}",
            ledger_info.ledger_info().epoch(),
            self.epoch
        );
        ledger_info.verify_signatures(&self.verifier)?;
        Ok(())
    }
```
