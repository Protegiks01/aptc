# Audit Report

## Title
Information Leakage in Secure Storage Error Messages Exposes Validator Infrastructure Topology

## Summary
The `Error::InternalError` type in `secure/storage/src/error.rs` leaks sensitive infrastructure information including file system paths, Vault server URLs, secret identifiers, and key names through error messages that are logged by consensus safety rules and potentially exposed via the inspection service.

## Finding Description

The secure storage module converts IO errors and Vault client errors to `InternalError` strings that preserve detailed error messages: [1](#0-0) [2](#0-1) 

These errors from on-disk storage operations include full file paths: [3](#0-2) 

Vault client errors include server URLs, HTTP response bodies, and secret paths: [4](#0-3) [5](#0-4) 

The consensus safety rules module converts these errors while preserving all details: [6](#0-5) 

These errors are then logged with the full error string by the safety rules logging infrastructure: [7](#0-6) [8](#0-7) 

Additionally, the inspection service can expose the complete node configuration including all `SecureBackend` settings: [9](#0-8) [10](#0-9) [11](#0-10) [12](#0-11) 

**Sensitive information leaked includes:**
- Absolute file paths to key storage (e.g., "/opt/aptos/validator/secure_storage.json")
- Vault server URLs (e.g., "https://vault.internal.network:8200")
- Secret path structures (e.g., "secret/data/validator_keys/consensus_key")
- Key identifiers and namespaces
- CA certificate paths
- Token file locations
- Directory structures revealing validator deployment topology

## Impact Explanation

This qualifies as **Medium Severity** information leakage per the Aptos bug bounty program. While it doesn't directly cause funds loss or consensus violations, the leaked information aids targeted attacks by:

1. **Infrastructure Reconnaissance**: Attackers learn the validator's storage architecture, file system layout, and network topology
2. **Targeted Exploitation**: Knowledge of exact file paths enables privilege escalation attacks if other vulnerabilities exist
3. **Vault Server Targeting**: Exposed Vault URLs allow attackers to focus reconnaissance on the key management infrastructure
4. **Social Engineering**: Detailed error messages with internal paths aid in crafting convincing phishing attacks against operators

This violates defense-in-depth principles where error messages should not contain sensitive operational details.

## Likelihood Explanation

**Likelihood: Medium to High**

This information becomes accessible through:

1. **Misconfigured Inspection Service**: If `expose_configuration: true` is set and the endpoint is network-accessible, external attackers can retrieve full configuration including all storage paths and Vault URLs

2. **Centralized Log Aggregation**: Organizations commonly export validator logs to monitoring systems (ELK, Splunk, Prometheus). If these systems have weaker access controls than validator nodes, attackers who compromise logging infrastructure obtain this topology information

3. **Support Interactions**: Operators troubleshooting storage issues may share error logs in support channels, inadvertently leaking infrastructure details

4. **Natural Error Occurrence**: Storage errors occur during normal operations (disk full, permission changes, network issues to Vault), so these logs are generated frequently without requiring attack action

## Recommendation

Implement sanitized error messages that omit sensitive details:

**For secure/storage/src/error.rs:**
```rust
impl From<io::Error> for Error {
    fn from(error: io::Error) -> Self {
        // Sanitize file paths from error messages
        Self::InternalError(format!("IO error: {}", error.kind()))
    }
}

impl From<aptos_vault_client::Error> for Error {
    fn from(error: aptos_vault_client::Error) -> Self {
        match error {
            aptos_vault_client::Error::NotFound(_, key) => Self::KeyNotSet(key),
            aptos_vault_client::Error::HttpError(403, _, _) => Self::PermissionDenied,
            aptos_vault_client::Error::HttpError(status, _, _) => 
                Self::InternalError(format!("Vault HTTP error: {}", status)),
            _ => Self::InternalError("Vault client error".to_string()),
        }
    }
}
```

**For consensus/safety-rules/src/error.rs:**
```rust
impl From<aptos_secure_storage::Error> for Error {
    fn from(error: aptos_secure_storage::Error) -> Self {
        match error {
            aptos_secure_storage::Error::PermissionDenied => {
                panic!("A permission error was thrown. Storage token may need renewal.");
            },
            aptos_secure_storage::Error::KeyVersionNotFound(_, _)
            | aptos_secure_storage::Error::KeyNotSet(_) => {
                Self::SecureStorageMissingDataError("Key not found in storage".to_string())
            },
            _ => Self::SecureStorageUnexpectedError("Storage operation failed".to_string()),
        }
    }
}
```

**For inspection service:**
The configuration endpoint should never expose `SecureBackend` details even when `expose_configuration` is enabled. Add filtering logic to redact sensitive fields.

## Proof of Concept

**Triggering the vulnerability:**

```rust
// This demonstrates how IO errors expose file paths through the error chain
use aptos_secure_storage::{OnDiskStorage, Storage, KVStorage};
use std::path::PathBuf;

fn demonstrate_path_leak() {
    // Create storage pointing to a non-existent directory
    let storage = Storage::from(OnDiskStorage::new(
        PathBuf::from("/opt/aptos/validator/nonexistent/secure.json")
    ));
    
    // Attempt to read, triggering IO error with full path
    match storage.get::<String>("test_key") {
        Err(e) => {
            // Error message contains: "No such file or directory: /opt/aptos/validator/nonexistent/secure.json"
            println!("Leaked error: {}", e);
            // This gets logged by safety rules with full path exposed
        },
        _ => {}
    }
}

// For Vault configuration leakage:
fn demonstrate_vault_leak() {
    // When Vault connection fails, error includes full URL
    let vault_storage = aptos_secure_storage::VaultStorage::new(
        "https://vault.validator.internal:8200".to_string(),
        "test-token".to_string(),
        None,
        None,
        true,
        None,
        None,
    );
    
    // Connection failure exposes: "Synthetic error: connection to https://vault.validator.internal:8200 failed"
    // This propagates to safety rules logs with full Vault URL
}

// Accessing via inspection service (if exposed):
// curl http://validator-node:9101/configuration
// Returns full NodeConfig with all SecureBackend paths and Vault URLs
```

**Notes:**
- This vulnerability is already present in production code and requires no special conditions to trigger
- Storage errors occur naturally during operations, causing these logs to be written
- The leaked information persists in log files and centralized logging systems
- Mitigation requires systematic sanitization of all error messages that may contain infrastructure details

### Citations

**File:** secure/storage/src/error.rs (L38-42)
```rust
impl From<io::Error> for Error {
    fn from(error: io::Error) -> Self {
        Self::InternalError(format!("{}", error))
    }
}
```

**File:** secure/storage/src/error.rs (L56-64)
```rust
impl From<aptos_vault_client::Error> for Error {
    fn from(error: aptos_vault_client::Error) -> Self {
        match error {
            aptos_vault_client::Error::NotFound(_, key) => Self::KeyNotSet(key),
            aptos_vault_client::Error::HttpError(403, _, _) => Self::PermissionDenied,
            _ => Self::InternalError(format!("{}", error)),
        }
    }
}
```

**File:** secure/storage/src/on_disk.rs (L53-69)
```rust
    fn read(&self) -> Result<HashMap<String, Value>, Error> {
        let mut file = File::open(&self.file_path)?;
        let mut contents = String::new();
        file.read_to_string(&mut contents)?;
        if contents.is_empty() {
            return Ok(HashMap::new());
        }
        let data = serde_json::from_str(&contents)?;
        Ok(data)
    }

    fn write(&self, data: &HashMap<String, Value>) -> Result<(), Error> {
        let contents = serde_json::to_vec(data)?;
        let mut file = File::create(self.temp_path.path())?;
        file.write_all(&contents)?;
        fs::rename(&self.temp_path, &self.file_path)?;
        Ok(())
```

**File:** secure/storage/vault/src/lib.rs (L39-55)
```rust
#[derive(Debug, Error, PartialEq, Eq)]
pub enum Error {
    #[error("Http error, status code: {0}, status text: {1}, body: {2}")]
    HttpError(u16, String, String),
    #[error("Internal error: {0}")]
    InternalError(String),
    #[error("Missing field {0}")]
    MissingField(String),
    #[error("404: Not Found: {0}/{1}")]
    NotFound(String, String),
    #[error("Overflow error: {0}")]
    OverflowError(String),
    #[error("Serialization error: {0}")]
    SerializationError(String),
    #[error("Synthetic error returned: {0}")]
    SyntheticError(String),
}
```

**File:** secure/storage/vault/src/lib.rs (L75-90)
```rust
impl From<ureq::Response> for Error {
    fn from(resp: ureq::Response) -> Self {
        if resp.synthetic() {
            match resp.into_string() {
                Ok(resp) => Error::SyntheticError(resp),
                Err(error) => Error::InternalError(error.to_string()),
            }
        } else {
            let status = resp.status();
            let status_text = resp.status_text().to_string();
            match resp.into_string() {
                Ok(body) => Error::HttpError(status, status_text, body),
                Err(error) => Error::InternalError(error.to_string()),
            }
        }
    }
```

**File:** consensus/safety-rules/src/error.rs (L78-98)
```rust
impl From<aptos_secure_storage::Error> for Error {
    fn from(error: aptos_secure_storage::Error) -> Self {
        match error {
            aptos_secure_storage::Error::PermissionDenied => {
                // If a storage error is thrown that indicates a permission failure, we
                // want to panic immediately to alert an operator that something has gone
                // wrong. For example, this error is thrown when a storage (e.g., vault)
                // token has expired, so it makes sense to fail fast and require a token
                // renewal!
                panic!(
                    "A permission error was thrown: {:?}. Maybe the storage token needs to be renewed?",
                    error
                );
            },
            aptos_secure_storage::Error::KeyVersionNotFound(_, _)
            | aptos_secure_storage::Error::KeyNotSet(_) => {
                Self::SecureStorageMissingDataError(error.to_string())
            },
            _ => Self::SecureStorageUnexpectedError(error.to_string()),
        }
    }
```

**File:** consensus/safety-rules/src/safety_rules.rs (L483-500)
```rust
fn run_and_log<F, L, R>(callback: F, log_cb: L, log_entry: LogEntry) -> Result<R, Error>
where
    F: FnOnce() -> Result<R, Error>,
    L: for<'a> Fn(SafetyLogSchema<'a>) -> SafetyLogSchema<'a>,
{
    let _timer = counters::start_timer("internal", log_entry.as_str());
    trace!(log_cb(SafetyLogSchema::new(log_entry, LogEvent::Request)));
    counters::increment_query(log_entry.as_str(), "request");
    callback()
        .inspect(|_v| {
            trace!(log_cb(SafetyLogSchema::new(log_entry, LogEvent::Success)));
            counters::increment_query(log_entry.as_str(), "success");
        })
        .inspect_err(|err| {
            warn!(log_cb(SafetyLogSchema::new(log_entry, LogEvent::Error)).error(err));
            counters::increment_query(log_entry.as_str(), "error");
        })
}
```

**File:** consensus/safety-rules/src/logging.rs (L10-23)
```rust
#[derive(Schema)]
pub struct SafetyLogSchema<'a> {
    name: LogEntry,
    event: LogEvent,
    round: Option<Round>,
    preferred_round: Option<u64>,
    last_voted_round: Option<u64>,
    highest_timeout_round: Option<u64>,
    epoch: Option<u64>,
    #[schema(display)]
    error: Option<&'a Error>,
    waypoint: Option<Waypoint>,
    author: Option<Author>,
}
```

**File:** crates/aptos-inspection-service/src/server/configuration.rs (L13-29)
```rust
pub fn handle_configuration_request(node_config: &NodeConfig) -> (StatusCode, Body, String) {
    // Only return configuration if the endpoint is enabled
    let (status_code, body) = if node_config.inspection_service.expose_configuration {
        // We format the configuration using debug formatting. This is important to
        // prevent secret/private keys from being serialized and leaked (i.e.,
        // all secret keys are marked with SilentDisplay and SilentDebug).
        let encoded_configuration = format!("{:?}", node_config);
        (StatusCode::OK, Body::from(encoded_configuration))
    } else {
        (
            StatusCode::FORBIDDEN,
            Body::from(CONFIGURATION_DISABLED_MESSAGE),
        )
    };

    (status_code, body, CONTENT_TYPE_TEXT.into())
}
```

**File:** config/src/config/secure_backend_config.rs (L16-22)
```rust
#[derive(Clone, Debug, Deserialize, PartialEq, Eq, Serialize)]
#[serde(rename_all = "snake_case", tag = "type")]
pub enum SecureBackend {
    InMemoryStorage,
    Vault(VaultConfig),
    OnDiskStorage(OnDiskStorageConfig),
}
```

**File:** config/src/config/secure_backend_config.rs (L51-74)
```rust
#[derive(Clone, Debug, Deserialize, PartialEq, Eq, Serialize)]
#[serde(deny_unknown_fields)]
pub struct VaultConfig {
    /// Optional SSL Certificate for the vault host, this is expected to be a full path.
    pub ca_certificate: Option<PathBuf>,
    /// A namespace is an optional portion of the path to a key stored within Vault. For example,
    /// a secret, S, without a namespace would be available in secret/data/S, with a namespace, N, it
    /// would be in secret/data/N/S.
    pub namespace: Option<String>,
    /// Vault leverages leases on many tokens, specify this to automatically have your lease
    /// renewed up to that many seconds more. If this is not specified, the lease will not
    /// automatically be renewed.
    pub renew_ttl_secs: Option<u32>,
    /// Vault's URL, note: only HTTP is currently supported.
    pub server: String,
    /// The authorization token for accessing secrets
    pub token: Token,
    /// Disable check-and-set when writing secrets to Vault
    pub disable_cas: Option<bool>,
    /// Timeout for new vault socket connections, in milliseconds.
    pub connection_timeout_ms: Option<u64>,
    /// Timeout for generic vault operations (e.g., reads and writes), in milliseconds.
    pub response_timeout_ms: Option<u64>,
}
```

**File:** config/src/config/secure_backend_config.rs (L86-97)
```rust
#[derive(Clone, Debug, Deserialize, PartialEq, Eq, Serialize)]
#[serde(deny_unknown_fields)]
pub struct OnDiskStorageConfig {
    // Required path for on disk storage
    pub path: PathBuf,
    /// A namespace is an optional portion of the path to a key stored within OnDiskStorage. For
    /// example, a key, S, without a namespace would be available in S, with a namespace, N, it
    /// would be in N/S.
    pub namespace: Option<String>,
    #[serde(skip)]
    data_dir: PathBuf,
}
```
