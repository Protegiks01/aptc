# Audit Report

## Title
Missing Validation for `hot_state_kv_db_path` in StorageConfig Sanitizer Causes Node Panic on Startup

## Summary
The `StorageConfig::sanitize()` function validates most sharded database path overrides (`state_kv_db_path`, `state_merkle_db_path`, `hot_state_merkle_db_path`) but fails to validate `hot_state_kv_db_path`. This allows an attacker to craft a malicious node configuration with invalid shard paths that passes sanitization but causes a node panic during initialization, resulting in a Denial of Service.

## Finding Description

The vulnerability exists in the config validation logic for storage path overrides. The `StorageConfig` struct supports fine-grained control over database paths through the `db_path_overrides` field, which includes four sharded database path configurations: [1](#0-0) 

When path overrides are provided, the `ConfigSanitizer::sanitize()` implementation validates three of these paths but **omits validation for `hot_state_kv_db_path`**: [2](#0-1) [3](#0-2) [4](#0-3) 

Notice that validation exists for `state_kv_db_path`, `state_merkle_db_path`, and `hot_state_merkle_db_path`, but there is **no corresponding validation block for `hot_state_kv_db_path`**.

However, `get_dir_paths()` unconditionally processes `hot_state_kv_db_path` if provided: [5](#0-4) 

The `ShardedDbPaths::new()` constructor calls `get_shard_paths().expect("Invalid config.")`, which panics if the configuration is invalid: [6](#0-5) 

Invalid configurations include:
- Non-absolute paths
- Shard IDs >= 16  
- Duplicate shard IDs [7](#0-6) 

The hot state KV database is actively used in production during node initialization: [8](#0-7) 

**Attack Path:**
1. Attacker crafts a malicious node config with invalid `hot_state_kv_db_path` (e.g., relative path "db" instead of absolute path "/data/db", or shard ID "16" which exceeds the valid range [0,16))
2. Config passes `ConfigSanitizer::sanitize()` because `hot_state_kv_db_path` validation is missing
3. Node startup calls `AptosDB::open()` → `get_dir_paths()` → `ShardedDbPaths::new(hot_state_kv_db_path)`
4. `get_shard_paths().expect()` encounters the invalid config and panics
5. Validator node crashes, causing service disruption

## Impact Explanation

This vulnerability enables a **Denial of Service attack** against Aptos validator nodes. An attacker who can influence node configuration (via compromised config management, malicious templates, or social engineering) can cause validator nodes to panic and crash on startup.

According to the Aptos Bug Bounty severity categories, this qualifies as **High Severity** because it causes:
- **Validator node crashes** (explicitly listed as High Severity)
- **API crashes** (the node fails to start, affecting all APIs)

While this requires the attacker to modify the node configuration file, this is a realistic threat vector since:
- Node operators often use configuration templates from untrusted sources
- Configuration management systems can be compromised
- The sanitizer is supposed to catch invalid configs, but fails to do so here

The impact is amplified because the panic occurs **after** sanitization, meaning operators who trust the validation layer may unknowingly deploy malicious configs.

## Likelihood Explanation

**Likelihood: Medium**

The vulnerability requires the attacker to:
1. Gain ability to modify the node configuration file (Medium difficulty)
2. Craft a malicious config with invalid `hot_state_kv_db_path` (Trivial)
3. Wait for node restart (Trivial)

While modifying the config file requires some level of access, it does not require:
- Private keys or cryptographic material
- Validator set membership
- On-chain governance participation
- Network-level attacks

The missing validation is a clear oversight in the sanitizer implementation pattern, where all other sharded DB paths are validated but `hot_state_kv_db_path` is skipped.

## Recommendation

Add validation for `hot_state_kv_db_path` in the `StorageConfig::sanitize()` function, following the same pattern used for the other sharded database paths:

```rust
// Add this block after the hot_state_merkle_db_path validation (around line 795)
if let Some(hot_state_kv_db_path) = db_path_overrides.hot_state_kv_db_path.as_ref() {
    if let Some(metadata_path) = hot_state_kv_db_path.metadata_path.as_ref() {
        if !metadata_path.is_absolute() {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                format!("Path {metadata_path:?} in db_path_overrides is not an absolute path."),
            ));
        }
    }

    if let Err(e) = hot_state_kv_db_path.get_shard_paths() {
        return Err(Error::ConfigSanitizerFailed(sanitizer_name, e.to_string()));
    }
}
```

This ensures that invalid `hot_state_kv_db_path` configurations are caught during sanitization rather than causing panics during node initialization.

## Proof of Concept

Create a malicious node configuration file `malicious_config.yaml`:

```yaml
storage:
  dir: /data/aptos
  rocksdb_configs:
    enable_storage_sharding: true
  db_path_overrides:
    hot_state_kv_db_path:
      metadata_path: /data/hot_state_metadata
      shard_paths:
        - shards: "0-15"
          path: "relative/path"  # Invalid: not an absolute path
```

Alternatively, use an out-of-range shard ID:

```yaml
storage:
  dir: /data/aptos
  rocksdb_configs:
    enable_storage_sharding: true
  db_path_overrides:
    hot_state_kv_db_path:
      metadata_path: /data/hot_state_metadata
      shard_paths:
        - shards: "16"  # Invalid: shard ID must be < 16
          path: /data/shard16
```

**Expected behavior with vulnerability:**
1. Load config via `NodeConfigLoader::load_and_sanitize_config()`
2. Config passes sanitization (missing validation)
3. Call `storage.get_dir_paths()` during `AptosDB::open()`
4. Node panics with message: "thread 'main' panicked at 'Invalid config.: ...'"

**Expected behavior after fix:**
1. Load config via `NodeConfigLoader::load_and_sanitize_config()`
2. Sanitizer detects invalid `hot_state_kv_db_path` and returns error
3. Node refuses to start with clear error message
4. No panic occurs

## Notes

This vulnerability represents a **gap in the defense-in-depth strategy** where the sanitizer is supposed to catch all configuration errors before they cause runtime failures. The inconsistent validation pattern (validating 3 out of 4 sharded DB path types) suggests this was an oversight rather than intentional design.

The fix is straightforward and maintains consistency with existing validation logic, ensuring all sharded database path configurations receive proper validation before use.

### Citations

**File:** config/src/config/storage_config.rs (L30-38)
```rust
#[derive(Clone, Debug, Default, Deserialize, PartialEq, Eq, Serialize)]
#[serde(default, deny_unknown_fields)]
struct DbPathConfig {
    ledger_db_path: Option<PathBuf>,
    state_kv_db_path: Option<ShardedDbPathConfig>,
    state_merkle_db_path: Option<ShardedDbPathConfig>,
    hot_state_kv_db_path: Option<ShardedDbPathConfig>,
    hot_state_merkle_db_path: Option<ShardedDbPathConfig>,
}
```

**File:** config/src/config/storage_config.rs (L55-78)
```rust
    pub fn get_shard_paths(&self) -> Result<HashMap<u8, PathBuf>> {
        let mut result = HashMap::new();
        for shard_path in &self.shard_paths {
            let shard_ids = Self::parse(shard_path.shards.as_str())?;
            let path = &shard_path.path;
            ensure!(
                path.is_absolute(),
                "Path ({path:?}) is not an absolute path."
            );
            for shard_id in shard_ids {
                ensure!(
                    shard_id < 16,
                    "Shard id ({shard_id}) is out of range [0, 16)."
                );
                let exist = result.insert(shard_id, path.clone()).is_some();
                ensure!(
                    !exist,
                    "Duplicated shard id ({shard_id}) is not allowed in the config."
                );
            }
        }

        Ok(result)
    }
```

**File:** config/src/config/storage_config.rs (L488-490)
```rust
            if let Some(hot_state_kv_db_path) = db_path_overrides.hot_state_kv_db_path.as_ref() {
                hot_state_kv_db_paths = ShardedDbPaths::new(hot_state_kv_db_path);
            }
```

**File:** config/src/config/storage_config.rs (L621-631)
```rust
    fn new(config: &ShardedDbPathConfig) -> Self {
        let mut shard_paths = arr![None; 16];
        for (shard_id, shard_path) in config.get_shard_paths().expect("Invalid config.") {
            shard_paths[shard_id as usize] = Some(shard_path);
        }

        Self {
            metadata_path: config.metadata_path.clone(),
            shard_paths,
        }
    }
```

**File:** config/src/config/storage_config.rs (L749-762)
```rust
            if let Some(state_kv_db_path) = db_path_overrides.state_kv_db_path.as_ref() {
                if let Some(metadata_path) = state_kv_db_path.metadata_path.as_ref() {
                    if !metadata_path.is_absolute() {
                        return Err(Error::ConfigSanitizerFailed(
                            sanitizer_name,
                            format!("Path {metadata_path:?} in db_path_overrides is not an absolute path."),
                        ));
                    }
                }

                if let Err(e) = state_kv_db_path.get_shard_paths() {
                    return Err(Error::ConfigSanitizerFailed(sanitizer_name, e.to_string()));
                }
            }
```

**File:** config/src/config/storage_config.rs (L764-777)
```rust
            if let Some(state_merkle_db_path) = db_path_overrides.state_merkle_db_path.as_ref() {
                if let Some(metadata_path) = state_merkle_db_path.metadata_path.as_ref() {
                    if !metadata_path.is_absolute() {
                        return Err(Error::ConfigSanitizerFailed(
                            sanitizer_name,
                            format!("Path {metadata_path:?} in db_path_overrides is not an absolute path."),
                        ));
                    }
                }

                if let Err(e) = state_merkle_db_path.get_shard_paths() {
                    return Err(Error::ConfigSanitizerFailed(sanitizer_name, e.to_string()));
                }
            }
```

**File:** config/src/config/storage_config.rs (L779-794)
```rust
            if let Some(hot_state_merkle_db_path) =
                db_path_overrides.hot_state_merkle_db_path.as_ref()
            {
                if let Some(metadata_path) = hot_state_merkle_db_path.metadata_path.as_ref() {
                    if !metadata_path.is_absolute() {
                        return Err(Error::ConfigSanitizerFailed(
                            sanitizer_name,
                            format!("Path {metadata_path:?} in db_path_overrides is not an absolute path."),
                        ));
                    }
                }

                if let Err(e) = hot_state_merkle_db_path.get_shard_paths() {
                    return Err(Error::ConfigSanitizerFailed(sanitizer_name, e.to_string()));
                }
            }
```

**File:** storage/aptosdb/src/state_kv_db.rs (L132-155)
```rust
            Some(
                (0..NUM_STATE_SHARDS)
                    .into_par_iter()
                    .map(|shard_id| {
                        let shard_root_path = db_paths.hot_state_kv_db_shard_root_path(shard_id);
                        let db = Self::open_shard(
                            shard_root_path,
                            shard_id,
                            &state_kv_db_config,
                            env,
                            block_cache,
                            readonly,
                            /* is_hot = */ true,
                        )
                        .unwrap_or_else(|e| {
                            panic!("Failed to open hot state kv db shard {shard_id}: {e:?}.")
                        });
                        Arc::new(db)
                    })
                    .collect::<Vec<_>>()
                    .try_into()
                    .unwrap(),
            )
        };
```
