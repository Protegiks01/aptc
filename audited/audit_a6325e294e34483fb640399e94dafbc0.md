# Audit Report

## Title
Missing Gas Schedule Validation Enables Network-Wide Liveness Failure via Malformed Governance Proposal

## Summary
The `fetch_gas_schedule()` function deserializes `GasScheduleV2` from JSON without validating that all required gas parameters are present or within valid ranges. Combined with missing on-chain validation in Move code, this allows a malformed gas schedule to be committed through governance, causing total network liveness failure when applied at epoch change. All transactions subsequently fail with `VM_STARTUP_FAILURE`, requiring a hardfork to recover.

## Finding Description

**Vulnerability Location:** [1](#0-0) 

The `fetch_gas_schedule()` function uses serde_json to deserialize `GasScheduleV2` from JSON/remote sources without any validation of the deserialized structure. This allows malformed gas schedules with missing required parameters, invalid values, or empty entries to pass through.

**Root Cause Chain:**

1. **No Validation at Deserialization:** [2](#0-1) 

The JSON deserialization accepts any data with `feature_version` and `entries` fields, without checking completeness.

2. **Minimal Validation in Proposal Generation:** [3](#0-2) 

Only the serialized blob size is checked, not its semantic validity.

3. **Missing On-Chain Validation:** [4](#0-3) [5](#0-4) 

The Move code contains TODO comments indicating planned validation ("check if gas schedule is consistent") but this validation is never implemented. Only feature version ordering is checked.

4. **Optional Simulation:** [6](#0-5) 

Proposal simulation that would catch the error is optional and can be skipped.

**Attack Propagation:**

When the malformed gas schedule is applied at epoch change via `on_new_epoch()`: [7](#0-6) 

The malformed schedule is written to on-chain state without validation.

Subsequently, when validators initialize the VM environment: [8](#0-7) 

The environment attempts to parse gas parameters: [9](#0-8) 

When required gas parameters are missing, the macro-generated parsing code fails: [10](#0-9) 

This error is stored in the environment, and every transaction execution fails: [11](#0-10) 

**Broken Invariant:** The network liveness invariant is violated - no transactions can be processed, causing total network halt.

## Impact Explanation

This vulnerability meets **Critical Severity** criteria per the Aptos bug bounty program:

- **Total loss of liveness/network availability:** Once a malformed gas schedule is applied, ALL transactions across ALL validators fail deterministically with `VM_STARTUP_FAILURE`. The test demonstrates this behavior: [12](#0-11) 

- **Requires hardfork:** The malformed gas schedule is committed to on-chain state and cannot be fixed through normal governance because no transactions can execute. A hardfork is required to either:
  - Restore a valid gas schedule directly in state
  - Deploy a patched VM that tolerates the malformed schedule

- **Deterministic failure across all nodes:** All validators encounter the same parsing failure when loading gas parameters, ensuring consensus is maintained but the network is unusable.

## Likelihood Explanation

**Medium to High Likelihood:**

1. **Governance Approval Required:** The attack requires a malicious or negligent governance proposal to pass, which provides some barrier. However:
   - Governance participants may not run simulation (it's optional)
   - Complex gas schedule changes are hard to audit manually
   - JSON files can be manipulated before proposal submission

2. **No Technical Barriers:** 
   - Creating a malformed JSON is trivial (delete any required parameter)
   - Proposal generation succeeds without validation
   - Move code explicitly lacks validation (TODO comments indicate awareness but no implementation)

3. **Known Weakness:** The codebase contains multiple TODO comments acknowledging this validation gap: [13](#0-12) 

This indicates developers are aware validation should exist but it was never implemented.

## Recommendation

**Immediate Fixes:**

1. **Add Validation in `fetch_gas_schedule()`:**
```rust
impl GasScheduleLocator {
    async fn fetch_gas_schedule(&self) -> Result<GasScheduleV2> {
        let gas_schedule = match self {
            GasScheduleLocator::LocalFile(path) => {
                let file_contents = fs::read_to_string(path)?;
                serde_json::from_str(&file_contents)?
            },
            GasScheduleLocator::RemoteFile(url) => {
                let response = reqwest::get(url.as_str()).await?;
                response.json().await?
            },
            GasScheduleLocator::Current => {
                return Ok(aptos_gas_schedule_updator::current_gas_schedule(
                    LATEST_GAS_FEATURE_VERSION,
                ));
            }
        };
        
        // Validate the gas schedule can be parsed into AptosGasParameters
        let map = gas_schedule.clone().into_btree_map();
        AptosGasParameters::from_on_chain_gas_schedule(&map, gas_schedule.feature_version)
            .map_err(|err| anyhow!("Invalid gas schedule: {}", err))?;
        
        Ok(gas_schedule)
    }
}
```

2. **Implement Move Validation:**
Replace TODO comments with actual validation in `gas_schedule.move`:
```move
public fun set_for_next_epoch(aptos_framework: &signer, gas_schedule_blob: vector<u8>) acquires GasScheduleV2 {
    system_addresses::assert_aptos_framework(aptos_framework);
    assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));
    
    let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
    
    // Validate gas schedule is parseable and complete
    validate_gas_schedule_completeness(&new_gas_schedule);
    
    if (exists<GasScheduleV2>(@aptos_framework)) {
        let cur_gas_schedule = borrow_global<GasScheduleV2>(@aptos_framework);
        assert!(
            new_gas_schedule.feature_version >= cur_gas_schedule.feature_version,
            error::invalid_argument(EINVALID_GAS_FEATURE_VERSION)
        );
    };
    config_buffer::upsert(new_gas_schedule);
}
```

3. **Make Simulation Mandatory:**
Require `--simulate` flag for production proposal generation, or at minimum add prominent warnings when skipped.

## Proof of Concept

**Step 1: Create Malformed Gas Schedule JSON**
```json
{
  "feature_version": 12,
  "entries": [
    ["instr.nop", 36],
    ["instr.ret", 220]
  ]
}
```
Note: This is missing required parameters like "instr.add", "instr.sub", etc.

**Step 2: Create Release Config**
```yaml
name: "malicious_release"
remote_endpoint: "https://fullnode.testnet.aptoslabs.com"
proposals:
  - name: "malformed_gas"
    execution_mode: MultiStep
    metadata:
      title: "Gas Schedule Update"
      description: "Update gas parameters"
    update_sequence:
      - Gas:
          new: "malformed_gas_schedule.json"
```

**Step 3: Generate Proposal (Without Simulation)**
```bash
aptos-release-builder generate-proposals \
  --release-config malicious_config.yaml \
  --output-dir ./malicious_proposal
```
âœ… Succeeds - no validation occurs

**Step 4: Execute Proposal via Governance**
The generated Move script can be submitted and executed through normal governance channels.

**Step 5: Network Halt at Next Epoch**
When the epoch changes and the malformed schedule is applied:
- All validators load the new gas schedule from state
- `AptosGasParameters::from_on_chain_gas_schedule()` fails with "Gas parameter instr.add does not exist"
- Every transaction returns `VM_STARTUP_FAILURE`
- Network is unusable until hardfork

**Verification:**
The existing test proves this behavior: [12](#0-11) 

This test demonstrates that removing a single gas parameter causes `VM_STARTUP_FAILURE`, confirming the vulnerability's impact.

## Notes

This vulnerability exists due to the defense-in-depth failure across three layers:
1. Release builder lacks validation
2. Move on-chain code lacks validation (TODO comments indicate awareness)  
3. Simulation is optional rather than mandatory

The convergence of these missing safeguards creates a Critical severity path to network liveness failure through governance, despite the existence of testing infrastructure that could catch such issues if used.

### Citations

**File:** aptos-move/aptos-release-builder/src/components/mod.rs (L197-214)
```rust
    async fn fetch_gas_schedule(&self) -> Result<GasScheduleV2> {
        println!("{:?}", self);
        match self {
            GasScheduleLocator::LocalFile(path) => {
                let file_contents = fs::read_to_string(path)?;
                let gas_schedule: GasScheduleV2 = serde_json::from_str(&file_contents)?;
                Ok(gas_schedule)
            },
            GasScheduleLocator::RemoteFile(url) => {
                let response = reqwest::get(url.as_str()).await?;
                let gas_schedule: GasScheduleV2 = response.json().await?;
                Ok(gas_schedule)
            },
            GasScheduleLocator::Current => Ok(aptos_gas_schedule_updator::current_gas_schedule(
                LATEST_GAS_FEATURE_VERSION,
            )),
        }
    }
```

**File:** aptos-move/aptos-release-builder/src/components/gas.rs (L124-125)
```rust
            let gas_schedule_blob = bcs::to_bytes(new_gas_schedule).unwrap();
            assert!(gas_schedule_blob.len() < 65536);
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L43-50)
```text
    public(friend) fun initialize(aptos_framework: &signer, gas_schedule_blob: vector<u8>) {
        system_addresses::assert_aptos_framework(aptos_framework);
        assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));

        // TODO(Gas): check if gas schedule is consistent
        let gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
        move_to<GasScheduleV2>(aptos_framework, gas_schedule);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L91-103)
```text
    public fun set_for_next_epoch(aptos_framework: &signer, gas_schedule_blob: vector<u8>) acquires GasScheduleV2 {
        system_addresses::assert_aptos_framework(aptos_framework);
        assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));
        let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
        if (exists<GasScheduleV2>(@aptos_framework)) {
            let cur_gas_schedule = borrow_global<GasScheduleV2>(@aptos_framework);
            assert!(
                new_gas_schedule.feature_version >= cur_gas_schedule.feature_version,
                error::invalid_argument(EINVALID_GAS_FEATURE_VERSION)
            );
        };
        config_buffer::upsert(new_gas_schedule);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L135-145)
```text
    public(friend) fun on_new_epoch(framework: &signer) acquires GasScheduleV2 {
        system_addresses::assert_aptos_framework(framework);
        if (config_buffer::does_exist<GasScheduleV2>()) {
            let new_gas_schedule = config_buffer::extract_v2<GasScheduleV2>();
            if (exists<GasScheduleV2>(@aptos_framework)) {
                *borrow_global_mut<GasScheduleV2>(@aptos_framework) = new_gas_schedule;
            } else {
                move_to(framework, new_gas_schedule);
            }
        }
    }
```

**File:** aptos-move/aptos-release-builder/src/main.rs (L82-84)
```rust
        /// If set, simulate the governance proposals after generation.
        #[clap(long)]
        simulate: Option<NetworkSelection>,
```

**File:** aptos-move/aptos-vm-environment/src/environment.rs (L246-247)
```rust
        let (gas_params, storage_gas_params, gas_feature_version) =
            get_gas_parameters(&mut sha3_256, &features, state_view);
```

**File:** aptos-move/aptos-vm-environment/src/gas.rs (L23-45)
```rust
fn get_gas_config_from_storage(
    sha3_256: &mut Sha3_256,
    state_view: &impl StateView,
) -> (Result<AptosGasParameters, String>, u64) {
    match GasScheduleV2::fetch_config_and_bytes(state_view) {
        Some((gas_schedule, bytes)) => {
            sha3_256.update(&bytes);
            let feature_version = gas_schedule.feature_version;
            let map = gas_schedule.into_btree_map();
            (
                AptosGasParameters::from_on_chain_gas_schedule(&map, feature_version),
                feature_version,
            )
        },
        None => match GasSchedule::fetch_config_and_bytes(state_view) {
            Some((gas_schedule, bytes)) => {
                sha3_256.update(&bytes);
                let map = gas_schedule.into_btree_map();
                (AptosGasParameters::from_on_chain_gas_schedule(&map, 0), 0)
            },
            None => (Err("Neither gas schedule v2 nor v1 exists.".to_string()), 0),
        },
    }
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/macros.rs (L38-41)
```rust
                    if let Some(key) = $crate::gas_schedule::macros::define_gas_parameters_extract_key_at_version!($key_bindings, feature_version) {
                        let name = format!("{}.{}", $prefix, key);
                        params.$name = gas_schedule.get(&name).cloned().ok_or_else(|| format!("Gas parameter {} does not exist. Feature version: {}.", name, feature_version))?.into();
                    }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L273-281)
```rust
pub(crate) fn get_or_vm_startup_failure<'a, T>(
    gas_params: &'a Result<T, String>,
    log_context: &AdapterLogSchema,
) -> Result<&'a T, VMStatus> {
    gas_params.as_ref().map_err(|err| {
        let msg = format!("VM Startup Failed. {}", err);
        speculative_error!(log_context, msg.clone());
        VMStatus::error(StatusCode::VM_STARTUP_FAILURE, Some(msg))
    })
```

**File:** aptos-move/e2e-move-tests/src/tests/missing_gas_parameter.rs (L9-28)
```rust
fn missing_gas_parameter() {
    let mut h = MoveHarness::new();

    h.modify_gas_schedule_raw(|gas_schedule| {
        let idx = gas_schedule
            .entries
            .iter()
            .position(|(key, _val)| key == "instr.add")
            .unwrap();
        gas_schedule.entries.remove(idx);
    });

    // Load the code
    let acc = h.new_account_with_balance_at(AccountAddress::from_hex_literal("0xbeef").unwrap(), 0);
    let txn_status = h.publish_package(&acc, &common::test_dir_path("common.data/do_nothing"));
    assert!(matches!(
        txn_status,
        TransactionStatus::Discard(StatusCode::VM_STARTUP_FAILURE)
    ))
}
```
