# Audit Report

## Title
Unvalidated StorageServerSummary Allows Malicious Peers to Manipulate State Sync and Cause DoS

## Summary
The `poll_peer()` function in `poller.rs` accepts `StorageServerSummary` responses from network peers without validating the cryptographic signatures in the embedded `synced_ledger_info` field. This allows malicious peers to inject crafted metadata claiming arbitrary versions, epochs, and timestamps, which is then used for critical peer selection and bootstrapping decisions.

## Finding Description

The vulnerability exists in the state sync data client's peer polling mechanism. When `poll_peer()` requests a `StorageServerSummary` from a peer, the response flows through `send_request_to_peer_and_decode()` which only performs:

1. BCS deserialization 
2. Type checking (ensuring it's a `StorageServerSummary` response)
3. Compression validation [1](#0-0) 

The `StorageServerSummary` contains a `data_summary` field with a `synced_ledger_info: Option<LedgerInfoWithSignatures>` that includes BLS aggregated signatures from validators. However, **these signatures are never verified**. [2](#0-1) 

The unverified summary is stored directly without validation: [3](#0-2) [4](#0-3) 

This unverified data is then aggregated into the global data summary and used for critical decisions:

**1. Waypoint Bootstrapping**: The `verify_waypoint_is_satisfiable()` function uses the unverified `highest_synced_ledger_info` to determine if the node's waypoint can be satisfied: [5](#0-4) 

**2. Peer Selection**: The unverified data influences which peers are chosen for data requests: [6](#0-5) 

**3. Optimistic Fetch Validation**: Peers are deemed suitable for optimistic fetches based on unverified timestamp data: [7](#0-6) 

**Attack Scenarios:**

1. **Waypoint DoS**: Malicious peers claim to have synced far beyond the waypoint (e.g., version 999,999,999), causing the bootstrapper to believe syncing is possible. The node then wastes resources attempting to sync from these peers who cannot provide valid data.

2. **Peer Selection Manipulation**: Malicious peers advertise artificially high versions to be preferentially selected over honest peers, causing the node to repeatedly request data from peers that will fail validation downstream.

3. **Timestamp Manipulation**: By setting recent timestamps in unverified `synced_ledger_info`, malicious peers bypass lag checks and get selected for optimistic fetches and subscriptions even when their actual data is stale.

4. **Resource Exhaustion**: A coordinated attack with multiple malicious peers claiming high versions forces the node to continuously poll and attempt to sync from invalid peers, consuming network bandwidth and CPU cycles.

## Impact Explanation

This is a **High Severity** vulnerability per the Aptos bug bounty criteria:

- **Validator node slowdowns**: Nodes waste resources attempting to sync from malicious peers, causing performance degradation
- **Significant protocol violations**: The fundamental assumption that peer advertisements are trustworthy is violated, breaking the peer selection mechanism
- **DoS potential**: Coordinated malicious peers can render state sync ineffective, preventing new nodes from bootstrapping

While actual transaction data received later undergoes cryptographic verification (preventing consensus violations), the unverified peer advertisements create significant availability issues and resource waste. The vulnerability does not reach Critical severity because downstream verification prevents actual data corruption or funds loss.

## Likelihood Explanation

**Likelihood: High**

- **Low Attack Complexity**: Any network peer can send malicious `StorageServerSummary` responses; no special privileges required
- **No Cost to Attacker**: Crafting invalid summaries requires no stake or resources beyond network connectivity
- **Difficult to Detect**: The attack is subtle because responses are structurally valid (proper BCS encoding, correct types), just cryptographically unverified
- **Immediate Impact**: Effects are visible immediately as nodes begin preferring malicious peers

The attack is trivial to execute: an attacker simply needs to respond to `GetStorageServerSummary` requests with a properly-formatted response containing a `LedgerInfoWithSignatures` with an arbitrary version and invalid/missing signatures.

## Recommendation

Add cryptographic validation of `synced_ledger_info` signatures before accepting `StorageServerSummary` responses. The validation should occur in `update_summary()` or immediately after receiving the response:

```rust
/// Updates the storage summary for the given peer
pub fn update_summary(&self, peer: PeerNetworkId, storage_summary: StorageServerSummary) -> Result<(), Error> {
    // Validate synced_ledger_info signatures if present
    if let Some(synced_ledger_info) = &storage_summary.data_summary.synced_ledger_info {
        // Retrieve the appropriate epoch state for verification
        let epoch = synced_ledger_info.ledger_info().epoch();
        let epoch_state = self.get_epoch_state_for_epoch(epoch)?;
        
        // Verify the signatures
        epoch_state.verify(synced_ledger_info).map_err(|e| {
            Error::InvalidResponse(format!(
                "Invalid synced_ledger_info signatures from peer {:?}: {:?}",
                peer, e
            ))
        })?;
    }
    
    // Store the validated summary
    self.peer_to_state
        .entry(peer)
        .or_insert(PeerState::new(self.data_client_config.clone()))
        .update_storage_summary(storage_summary);
    
    Ok(())
}
```

Additionally, implement sanity checks:
- Reject summaries claiming versions far beyond the current network state
- Reject summaries with timestamps far in the future
- Penalize peers that send invalid summaries by lowering their score aggressively

## Proof of Concept

```rust
#[tokio::test]
async fn test_malicious_storage_summary_not_validated() {
    use aptos_storage_service_types::responses::{
        StorageServerSummary, DataSummary, ProtocolMetadata
    };
    use aptos_types::ledger_info::{LedgerInfo, LedgerInfoWithSignatures};
    use aptos_crypto::hash::HashValue;
    
    // Create a malicious storage summary with a very high version
    // but with INVALID/MISSING signatures
    let malicious_ledger_info = LedgerInfo::new(
        /* block_info */ BlockInfo::new(
            /* epoch */ 1000,
            /* round */ 0, 
            /* id */ HashValue::zero(),
            /* executed_state_id */ HashValue::zero(),
            /* version */ 999_999_999, // Claim extremely high version
            /* timestamp_usecs */ 9999999999999999,
            /* next_epoch_state */ None,
        ),
        /* consensus_data_hash */ HashValue::zero(),
    );
    
    // Create LedgerInfoWithSignatures with NO valid signatures
    let malicious_synced_ledger_info = LedgerInfoWithSignatures::new(
        malicious_ledger_info,
        /* signatures */ BTreeMap::new(), // Empty signatures!
    );
    
    let malicious_summary = StorageServerSummary {
        protocol_metadata: ProtocolMetadata::default(),
        data_summary: DataSummary {
            synced_ledger_info: Some(malicious_synced_ledger_info),
            epoch_ending_ledger_infos: None,
            states: None,
            transactions: None,
            transaction_outputs: None,
        },
    };
    
    // In the current implementation, this malicious summary would be accepted
    // and stored without any signature verification!
    // The node would then believe this peer has synced to version 999,999,999
    // and preferentially select it for data requests.
    
    // Expected behavior: The summary should be REJECTED due to invalid signatures
    // Actual behavior: The summary is ACCEPTED and used for peer selection
}
```

## Notes

The vulnerability lies in the trust assumption that peer advertisements are honest. While the Aptos protocol correctly verifies actual transaction data and proofs when received, the metadata used for peer selection is accepted without cryptographic validation. This creates an attack surface where malicious peers can manipulate the peer selection algorithm and cause resource exhaustion without triggering downstream validation failures until significant resources have been wasted.

### Citations

**File:** state-sync/aptos-data-client/src/poller.rs (L412-416)
```rust
        let result: crate::error::Result<StorageServerSummary> = data_summary_poller
            .data_client
            .send_request_to_peer_and_decode(peer, storage_request, request_timeout)
            .await
            .map(Response::into_payload);
```

**File:** state-sync/storage-service/types/src/responses.rs (L612-616)
```rust
#[derive(Clone, Debug, Default, Deserialize, Eq, PartialEq, Serialize)]
pub struct StorageServerSummary {
    pub protocol_metadata: ProtocolMetadata,
    pub data_summary: DataSummary,
}
```

**File:** state-sync/storage-service/types/src/responses.rs (L892-934)
```rust
/// Returns true iff an optimistic data request can be serviced
/// by the peer with the given synced ledger info.
fn can_service_optimistic_request(
    aptos_data_client_config: &AptosDataClientConfig,
    time_service: TimeService,
    synced_ledger_info: Option<&LedgerInfoWithSignatures>,
) -> bool {
    let max_lag_secs = aptos_data_client_config.max_optimistic_fetch_lag_secs;
    check_synced_ledger_lag(synced_ledger_info, time_service, max_lag_secs)
}

/// Returns true iff a subscription data request can be serviced
/// by the peer with the given synced ledger info.
fn can_service_subscription_request(
    aptos_data_client_config: &AptosDataClientConfig,
    time_service: TimeService,
    synced_ledger_info: Option<&LedgerInfoWithSignatures>,
) -> bool {
    let max_lag_secs = aptos_data_client_config.max_subscription_lag_secs;
    check_synced_ledger_lag(synced_ledger_info, time_service, max_lag_secs)
}

/// Returns true iff the synced ledger info timestamp
/// is within the given lag (in seconds).
fn check_synced_ledger_lag(
    synced_ledger_info: Option<&LedgerInfoWithSignatures>,
    time_service: TimeService,
    max_lag_secs: u64,
) -> bool {
    if let Some(synced_ledger_info) = synced_ledger_info {
        // Get the ledger info timestamp (in microseconds)
        let ledger_info_timestamp_usecs = synced_ledger_info.ledger_info().timestamp_usecs();

        // Get the current timestamp and max version lag (in microseconds)
        let current_timestamp_usecs = time_service.now_unix_time().as_micros() as u64;
        let max_version_lag_usecs = max_lag_secs * NUM_MICROSECONDS_IN_SECOND;

        // Return true iff the synced ledger info timestamp is within the max version lag
        ledger_info_timestamp_usecs + max_version_lag_usecs > current_timestamp_usecs
    } else {
        false // No synced ledger info was found!
    }
}
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L176-179)
```rust
    /// Updates the storage summary for the peer
    fn update_storage_summary(&mut self, storage_summary: StorageServerSummary) {
        self.storage_summary = Some(storage_summary);
    }
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L200-227)
```rust
    pub fn can_service_request(
        &self,
        peer: &PeerNetworkId,
        time_service: TimeService,
        request: &StorageServiceRequest,
    ) -> bool {
        // Storage services can always respond to data advertisement requests.
        // We need this outer check, since we need to be able to send data summary
        // requests to new peers (who don't have a peer state yet).
        if request.data_request.is_storage_summary_request()
            || request.data_request.is_protocol_version_request()
        {
            return true;
        }

        // Check if the peer can service the request
        if let Some(peer_state) = self.peer_to_state.get(peer) {
            return match peer_state.get_storage_summary_if_not_ignored() {
                Some(storage_summary) => {
                    storage_summary.can_service(&self.data_client_config, time_service, request)
                },
                None => false, // The peer is temporarily ignored
            };
        }

        // Otherwise, the request cannot be serviced
        false
    }
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L325-330)
```rust
    pub fn update_summary(&self, peer: PeerNetworkId, storage_summary: StorageServerSummary) {
        self.peer_to_state
            .entry(peer)
            .or_insert(PeerState::new(self.data_client_config.clone()))
            .update_storage_summary(storage_summary);
    }
```

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L894-914)
```rust
        let highest_advertised_ledger_info = global_data_summary
            .advertised_data
            .highest_synced_ledger_info()
            .ok_or_else(|| {
                Error::UnsatisfiableWaypoint(
                    "Unable to check waypoint satisfiability! No highest advertised ledger info found in the network!".into(),
                )
            })?;
        let highest_advertised_version = highest_advertised_ledger_info.ledger_info().version();

        // Compare the highest advertised version with our waypoint
        if highest_advertised_version < waypoint_version {
            Err(Error::UnsatisfiableWaypoint(
                format!(
                    "The waypoint is not satisfiable! No advertised version higher than our waypoint! Highest version: {:?}, waypoint version: {:?}.",
                    highest_advertised_version, waypoint_version
                )
            ))
        } else {
            Ok(())
        }
```
