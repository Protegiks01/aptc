# Audit Report

## Title
Type Confusion Attack in Remote Executor NetworkMessage Handler Causing Shard DoS and Potential Consensus Divergence

## Summary
The `NetworkMessageService` gRPC endpoint accepts `NetworkMessage` with a `message_type` string field and raw `message` bytes, routing messages to handlers based solely on the `message_type` without validation. Handlers blindly deserialize the bytes as their expected type using `.unwrap()`, allowing attackers to send mismatched message types that cause shard crashes (DoS) or potentially type confusion leading to incorrect execution.

## Finding Description

The remote executor system uses a two-layer message routing architecture where the gRPC layer routes messages based on the `message_type` field to appropriate handlers, which then deserialize the raw bytes using BCS (Binary Canonical Serialization). The critical vulnerability exists because:

1. **No Authentication**: The gRPC server exposes the `NetworkMessageService` endpoint without any authentication or authorization checks. [1](#0-0) 

2. **Unvalidated Message Type Routing**: The server routes messages based solely on the `message_type` string field without validating that the bytes actually match that type. [2](#0-1) 

3. **Unsafe Deserialization**: Multiple message handlers blindly deserialize incoming bytes using `.unwrap()`:
   
   - **RemoteStateValueReceiver** expects `RemoteKVResponse`: [3](#0-2) 
   
   - **RemoteCoordinatorClient** expects `RemoteExecutionRequest`: [4](#0-3) 
   
   - **RemoteCrossShardClient** expects `CrossShardMsg`: [5](#0-4) 

**Attack Scenario:**

An attacker sends a gRPC request to a shard's NetworkMessageService endpoint with:
- `message_type = "execute_command_0"` (routes to execution handler)
- `message` bytes = BCS-encoded `RemoteKVResponse` (wrong type)

The execution handler receives the message and attempts to deserialize it as `RemoteExecutionRequest`. Since the bytes represent a different type, BCS deserialization fails and the `.unwrap()` panics, crashing the shard.

**Broken Invariants:**
- **Deterministic Execution**: Shards can crash or execute incorrectly based on manipulated messages
- **Consensus Safety**: Different shards may crash or interpret messages differently, causing divergence
- **Availability**: Crashed shards cannot participate in block execution

The `NetworkMessage` protobuf structure contains both fields without any binding between them: [6](#0-5) 

## Impact Explanation

This vulnerability qualifies as **HIGH severity** under the Aptos Bug Bounty program criteria:

1. **Validator Node Crashes**: An attacker can crash any shard by sending messages with mismatched types, causing the `.unwrap()` to panic. This directly causes "Validator node slowdowns" and service disruption.

2. **Protocol Violations**: The sharded execution protocol requires all shards to execute correctly and communicate with proper message types. Type confusion attacks violate this protocol invariant.

3. **Loss of Liveness**: If multiple shards crash, block execution stalls, preventing the blockchain from making progress. This approaches "Total loss of liveness" (Critical severity).

4. **Potential Consensus Divergence**: If BCS deserialization succeeds with misinterpreted bytes (type confusion), different shards could execute with different states, violating the "Deterministic Execution" invariant and potentially causing a consensus split.

## Likelihood Explanation

This vulnerability is **HIGHLY LIKELY** to be exploitable:

1. **No Authentication Required**: The gRPC endpoint has no authentication, allowing any network peer to send requests.

2. **Simple Attack Vector**: The attack requires only sending a single gRPC request with manipulated fields - no complex timing or state manipulation needed.

3. **Direct Impact**: The `.unwrap()` calls guarantee an immediate panic when deserialization fails with wrong types.

4. **Multiple Attack Points**: Three different message handlers are vulnerable, providing multiple attack surfaces.

5. **Production Code**: This code is in the production remote executor service, not experimental or disabled code paths.

## Recommendation

Implement **message type validation** before deserialization:

```rust
// In RemoteStateValueReceiver::handle_message
fn handle_message(
    shard_id: ShardId,
    message: Message,
    state_view: Arc<RwLock<RemoteStateView>>,
) {
    let _timer = REMOTE_EXECUTOR_TIMER
        .with_label_values(&[&shard_id.to_string(), "kv_responses"])
        .start_timer();
    let bcs_deser_timer = REMOTE_EXECUTOR_TIMER
        .with_label_values(&[&shard_id.to_string(), "kv_resp_deser"])
        .start_timer();
    
    // ADD VALIDATION: Check message type matches expected type
    let response: RemoteKVResponse = match bcs::from_bytes(&message.data) {
        Ok(resp) => resp,
        Err(e) => {
            error!("Failed to deserialize RemoteKVResponse for shard {}: {:?}", shard_id, e);
            return; // Don't panic, just log and return
        }
    };
    drop(bcs_deser_timer);
    // ... rest of function
}
```

**Better Solution**: Modify the gRPC handler to validate message_type against expected types:

```rust
// In GRPCNetworkMessageServiceServerWrapper::simple_msg_exchange
async fn simple_msg_exchange(
    &self,
    request: Request<NetworkMessage>,
) -> Result<Response<Empty>, Status> {
    let network_message = request.into_inner();
    let message_type = MessageType::new(network_message.message_type.clone());
    
    // Validate message_type is registered
    if !self.inbound_handlers.lock().unwrap().contains_key(&message_type) {
        return Err(Status::invalid_argument(
            format!("Unknown message type: {}", network_message.message_type)
        ));
    }
    
    let msg = Message::new(network_message.message);
    // ... rest of function
}
```

**Best Solution**: Add authentication to the gRPC endpoint using interceptors and validate message integrity with cryptographic signatures.

## Proof of Concept

```rust
#[cfg(test)]
mod test_type_confusion {
    use super::*;
    use aptos_protos::remote_executor::v1::{NetworkMessage, network_message_service_client::NetworkMessageServiceClient};
    use tonic::Request;
    
    #[tokio::test]
    async fn test_type_confusion_attack() {
        // Setup: Start a shard with execution command handler
        let shard_addr = SocketAddr::new(IpAddr::V4(Ipv4Addr::LOCALHOST), 8080);
        // ... setup code for ExecutorService ...
        
        // Attack: Connect as client
        let mut client = NetworkMessageServiceClient::connect(format!("http://{}", shard_addr))
            .await
            .unwrap();
        
        // Create a RemoteKVResponse message
        let kv_response = RemoteKVResponse::new(vec![]);
        let wrong_type_bytes = bcs::to_bytes(&kv_response).unwrap();
        
        // Send with wrong message_type (should route to execution handler)
        let malicious_request = Request::new(NetworkMessage {
            message: wrong_type_bytes,
            message_type: "execute_command_0".to_string(), // Wrong type!
        });
        
        // This should cause the execution handler to panic when trying to 
        // deserialize RemoteKVResponse as RemoteExecutionRequest
        let result = client.simple_msg_exchange(malicious_request).await;
        
        // The shard will crash with panic due to .unwrap() on failed deserialization
        assert!(result.is_err() || shard_has_crashed());
    }
}
```

## Notes

This vulnerability affects the remote executor system used for sharded block execution, which is a critical component for Aptos scalability. While the remote executor may not be deployed in all production configurations, when enabled, this vulnerability allows unauthenticated attackers to crash shards and disrupt block execution, qualifying as a HIGH severity issue per the Aptos Bug Bounty program.

The root causes are:
1. Missing authentication on the gRPC endpoint
2. No validation between `message_type` field and actual message content
3. Unsafe use of `.unwrap()` on deserialization without error handling

All three issues must be addressed to fully mitigate this vulnerability.

### Citations

**File:** secure/net/src/grpc_network_service/mod.rs (L75-87)
```rust
        Server::builder()
            .timeout(std::time::Duration::from_millis(rpc_timeout_ms))
            .add_service(
                NetworkMessageServiceServer::new(self).max_decoding_message_size(MAX_MESSAGE_SIZE),
            )
            .add_service(reflection_service)
            .serve_with_shutdown(server_addr, async {
                server_shutdown_rx.await.ok();
                info!("Received signal to shutdown server at {:?}", server_addr);
            })
            .await
            .unwrap();
        info!("Server shutdown at {:?}", server_addr);
```

**File:** secure/net/src/grpc_network_service/mod.rs (L93-116)
```rust
    async fn simple_msg_exchange(
        &self,
        request: Request<NetworkMessage>,
    ) -> Result<Response<Empty>, Status> {
        let _timer = NETWORK_HANDLER_TIMER
            .with_label_values(&[&self.self_addr.to_string(), "inbound_msgs"])
            .start_timer();
        let remote_addr = request.remote_addr();
        let network_message = request.into_inner();
        let msg = Message::new(network_message.message);
        let message_type = MessageType::new(network_message.message_type);

        if let Some(handler) = self.inbound_handlers.lock().unwrap().get(&message_type) {
            // Send the message to the registered handler
            handler.send(msg).unwrap();
        } else {
            error!(
                "No handler registered for sender: {:?} and msg type {:?}",
                remote_addr, message_type
            );
        }
        Ok(Response::new(Empty {}))
    }
}
```

**File:** execution/executor-service/src/remote_state_view.rs (L254-254)
```rust
        let response: RemoteKVResponse = bcs::from_bytes(&message.data).unwrap();
```

**File:** execution/executor-service/src/remote_cordinator_client.rs (L89-89)
```rust
                let request: RemoteExecutionRequest = bcs::from_bytes(&message.data).unwrap();
```

**File:** execution/executor-service/src/remote_cross_shard_client.rs (L64-64)
```rust
        let msg: CrossShardMsg = bcs::from_bytes(&message.to_bytes()).unwrap();
```

**File:** protos/rust/src/pb/aptos.remote_executor.v1.rs (L8-13)
```rust
pub struct NetworkMessage {
    #[prost(bytes="vec", tag="1")]
    pub message: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, tag="2")]
    pub message_type: ::prost::alloc::string::String,
}
```
