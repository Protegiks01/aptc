# Audit Report

## Title
PFN Network Isolation Bypass via VFN Network Configuration

## Summary
A Public Full Node (PFN) can bypass its intended network isolation by adding a VFN (Validator Full Node) network to its configuration. The config sanitizer fails to block VFN networks on PFNs, and validators incorrectly infer connecting peers as ValidatorFullNodes based solely on the network type, allowing unauthorized privilege escalation.

## Finding Description

The vulnerability exists in three interconnected components:

**1. Insufficient Config Validation**

The config sanitizer only prevents `NetworkId::Validator` from being added to fullnode configs, but does NOT prevent `NetworkId::Vfn`: [1](#0-0) 

The check uses `is_validator_network()` which only returns true for `NetworkId::Validator`: [2](#0-1) 

This means a malicious PFN config with a VFN network passes validation.

**2. VFN Network Uses MaybeMutual Authentication**

Validators expose VFN networks with `mutual_authentication` defaulting to `false` for non-validator networks: [3](#0-2) 

This causes validators to use `MaybeMutual` authentication mode on their VFN networks, which accepts connections from unknown peers.

**3. Incorrect Peer Role Inference**

When a validator receives an inbound connection on the VFN network from an unknown peer (not in trusted peers), it automatically infers the role as `ValidatorFullNode`: [4](#0-3) 

There is NO verification that the connecting peer is actually authorized to be a VFN. The code simply assumes: "If someone connects to my VFN network, they must be a VFN."

**4. Network ID Must Match in Handshake**

The protocol handshake requires both peers to have the same `network_id`: [5](#0-4) 

A malicious PFN with VFN network config would send `network_id=Vfn`, matching the validator's VFN network, so the handshake succeeds.

**Attack Path:**

1. Attacker configures a PFN with a VFN network in `full_node_networks` (alongside or instead of Public network)
2. Config sanitizer checks `is_validator_network()` → returns false for VFN → passes validation
3. PFN obtains validator's VFN network address (from seed peers, network scanning, or public info)
4. PFN initiates connection to validator's VFN network endpoint
5. During Noise handshake with `MaybeMutual` mode:
   - PFN is not in validator's trusted peers set
   - Validator checks: "I'm a validator, this is VFN network" → assigns `PeerRole::ValidatorFullNode`
6. Protocol handshake succeeds with matching `network_id=Vfn`
7. PFN is now connected with ValidatorFullNode privileges

## Impact Explanation

**Severity: HIGH**

This vulnerability allows privilege escalation from an unprivileged PFN to a privileged ValidatorFullNode role, resulting in:

1. **Network Isolation Bypass**: PFNs are designed to only operate on the Public network. This allows them to connect directly to validators' VFN networks, violating the intended network topology.

2. **Mempool Priority Abuse**: ValidatorFullNode peers receive higher priority in mempool transaction propagation:
   - Can manipulate transaction ordering by masquerading as VFN
   - Could selectively propagate or withhold transactions
   - May impact transaction inclusion fairness

3. **State Sync Privilege Escalation**: ValidatorFullNode peers are treated as more trusted upstream sources in state sync, potentially allowing:
   - Resource exhaustion by requesting priority service
   - Manipulation of peer selection algorithms

4. **Validator Resource Abuse**: Validators allocate more resources to VFN connections. Unauthorized VFN-role peers could:
   - Consume validator bandwidth and CPU intended for legitimate VFNs
   - Impact validator performance during critical consensus operations

**Not Critical because:**
- Does NOT allow consensus participation (VFNs don't participate in AptosBFT consensus)
- Does NOT directly cause fund loss or theft
- Does NOT break consensus safety guarantees
- Validators can still process blocks correctly

This qualifies as **High Severity** per the Aptos bug bounty: "Significant protocol violations" and potential for "Validator node slowdowns."

## Likelihood Explanation

**Likelihood: HIGH**

The attack is highly feasible because:

1. **Low Attacker Requirements**: Any PFN operator can modify their config file - no special privileges needed
2. **No Technical Barriers**: Standard networking tools and the public Aptos protocol
3. **Simple Configuration Change**: Just add a VFN network to `full_node_networks` in config YAML
4. **Publicly Accessible Endpoints**: Validator VFN network addresses may be discoverable through network scanning or seed peer configs
5. **No Active Monitoring**: No runtime checks detect PFNs masquerading as VFNs after successful handshake

The vulnerability is deterministic - if the config passes sanitization and the handshake completes, the privilege escalation succeeds 100% of the time.

## Recommendation

**Fix 1: Strengthen Config Validation**

Update the config sanitizer to explicitly check for VFN networks on PFNs:

```rust
// In config/src/config/config_sanitizer.rs, modify sanitize_fullnode_network_configs:

// After line 134, add:
// For PFNs specifically, also block VFN networks
if !node_type.is_validator() && !node_type.is_validator_fullnode() {
    if network_id.is_vfn_network() {
        return Err(Error::ConfigSanitizerFailed(
            sanitizer_name,
            "Public fullnode network configs cannot include VFN networks!".into(),
        ));
    }
}
```

**Fix 2: Require Explicit VFN Authorization**

Update the peer role inference logic to NOT automatically assign ValidatorFullNode role:

```rust
// In network/framework/src/noise/handshake.rs, modify the inference logic around line 408:

if self.network_context.role().is_validator() {
    if network_id.is_vfn_network() {
        // Don't automatically trust VFN network connections from unknown peers
        // They must be in the trusted peer set to get VFN role
        Ok(PeerRole::Unknown)  // Changed from ValidatorFullNode
    } else {
        Ok(PeerRole::Unknown)
    }
}
```

**Fix 3: Enable Mutual Authentication for VFN Networks**

Configure VFN networks to use `mutual_authentication: true` by default, preventing connections from unknown peers entirely.

## Proof of Concept

```rust
// Integration test demonstrating the vulnerability
// Place in: network/framework/src/noise/handshake_test.rs

#[tokio::test]
async fn test_pfn_vfn_network_bypass() {
    use crate::testutils::fake_socket::ReadWriteTestSocket;
    use aptos_config::config::{NetworkConfig, NodeConfig, RoleType};
    use aptos_config::network_id::NetworkId;
    
    // Setup: Create a validator with VFN network
    let validator_key = x25519::PrivateKey::generate(&mut OsRng);
    let validator_peer_id = PeerId::random();
    
    // Validator has VFN network with MaybeMutual auth (default)
    let validator_vfn_config = NetworkConfig::network_with_id(NetworkId::Vfn);
    assert_eq!(validator_vfn_config.mutual_authentication, false); // Uses MaybeMutual
    
    // Setup: Create a malicious PFN with VFN network added
    let pfn_key = x25519::PrivateKey::generate(&mut OsRng);
    let pfn_peer_id = PeerId::random();
    
    let mut pfn_config = NodeConfig {
        base: BaseConfig {
            role: RoleType::FullNode,
            ..Default::default()
        },
        full_node_networks: vec![
            NetworkConfig::network_with_id(NetworkId::Public),
            NetworkConfig::network_with_id(NetworkId::Vfn), // MALICIOUS: PFN with VFN network
        ],
        ..Default::default()
    };
    
    // Vulnerability 1: Config sanitizer fails to block VFN network on PFN
    let node_type = NodeType::extract_from_config(&pfn_config);
    // Due to VFN network presence, node is classified as VFN despite being a malicious PFN
    assert_eq!(node_type, NodeType::ValidatorFullnode);
    
    // Simulate handshake: PFN connects to validator's VFN network
    let (pfn_socket, validator_socket) = ReadWriteTestSocket::new_pair();
    
    // PFN initiates connection with network_id=Vfn
    let pfn_upgrader = NoiseUpgrader::new(
        NetworkContext::new(RoleType::FullNode, NetworkId::Vfn, pfn_peer_id),
        pfn_key,
        HandshakeAuthMode::server_only(&[NetworkId::Vfn]),
    );
    
    // Validator accepts connection on VFN network with MaybeMutual auth
    let validator_upgrader = NoiseUpgrader::new(
        NetworkContext::new(RoleType::Validator, NetworkId::Vfn, validator_peer_id),
        validator_key,
        HandshakeAuthMode::maybe_mutual(Arc::new(PeersAndMetadata::new(&[NetworkId::Vfn]))),
    );
    
    // Vulnerability 2: Validator accepts connection and assigns ValidatorFullNode role
    let validator_result = validator_upgrader.upgrade_inbound(validator_socket).await;
    assert!(validator_result.is_ok());
    
    let (_, connected_peer_id, peer_role) = validator_result.unwrap();
    assert_eq!(connected_peer_id, pfn_peer_id);
    
    // VULNERABILITY DEMONSTRATED: PFN gets ValidatorFullNode role!
    assert_eq!(peer_role, PeerRole::ValidatorFullNode);
    println!("VULNERABILITY: Malicious PFN successfully escalated to ValidatorFullNode role!");
}
```

## Notes

The vulnerability stems from an incorrect assumption in the peer role inference logic: "If a peer connects to my VFN network, they must be a VFN." This assumption fails when:

1. The config sanitizer doesn't prevent PFNs from having VFN networks
2. The VFN network uses `MaybeMutual` authentication (default for non-validator networks)  
3. The handshake protocol only checks network ID matching, not actual authorization

The fix requires defense-in-depth: preventing the misconfiguration at the config level AND not automatically trusting connections based solely on network type.

### Citations

**File:** config/src/config/config_sanitizer.rs (L133-139)
```rust
        // Verify that the fullnode network config is not a validator network config
        if network_id.is_validator_network() {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "Fullnode network configs cannot include a validator network!".into(),
            ));
        }
```

**File:** config/src/network_id.rs (L168-170)
```rust
    pub fn is_validator_network(&self) -> bool {
        self == &NetworkId::Validator
    }
```

**File:** config/src/config/network_config.rs (L135-142)
```rust
    pub fn network_with_id(network_id: NetworkId) -> NetworkConfig {
        let mutual_authentication = network_id.is_validator_network();
        let mut config = Self {
            discovery_method: DiscoveryMethod::None,
            discovery_methods: Vec::new(),
            identity: Identity::None,
            listen_address: "/ip4/0.0.0.0/tcp/6180".parse().unwrap(),
            mutual_authentication,
```

**File:** network/framework/src/noise/handshake.rs (L406-416)
```rust
                            // Try to infer the role from the network context
                            if self.network_context.role().is_validator() {
                                if network_id.is_vfn_network() {
                                    // Inbound connections to validators on the VFN network must be VFNs
                                    Ok(PeerRole::ValidatorFullNode)
                                } else {
                                    // Otherwise, they're unknown. Validators will connect through
                                    // authenticated channels (on the validator network) so shouldn't hit
                                    // this, and PFNs will connect on public networks (which aren't common).
                                    Ok(PeerRole::Unknown)
                                }
```

**File:** network/framework/src/protocols/wire/handshake/v1/mod.rs (L443-449)
```rust
        // verify that both peers are on the same network
        if self.network_id != other.network_id {
            return Err(HandshakeError::InvalidNetworkId(
                other.network_id,
                self.network_id,
            ));
        }
```
