# Audit Report

## Title
Unchecked Version Arithmetic in Subscription Stream Tracking Causes Integer Overflow Bypass

## Summary
The subscription stream tracking in the storage service performs unchecked arithmetic on version numbers, allowing integer overflows to occur silently without triggering `IntegerOverflow` errors. This bypasses the checked arithmetic pattern used elsewhere in state sync and can cause version tracking corruption, leading to state inconsistencies and potential consensus divergence.

## Finding Description
The state sync driver defines an `IntegerOverflow` error variant to handle arithmetic overflows [1](#0-0) , and most version arithmetic operations throughout state sync use checked arithmetic methods like `checked_add()` and `checked_sub()` to properly detect and handle overflows.

However, the subscription stream implementation in the storage service uses unchecked arithmetic when updating version tracking: [2](#0-1) 

When `update_known_version_and_epoch()` is called after sending data to a peer, the `highest_known_version` is incremented using the `+=` operator, which performs wrapping arithmetic in release builds. If `highest_known_version` is close to `u64::MAX` and `num_data_items` is large enough, the addition will overflow and wrap around to a small number instead of triggering an error.

The `highest_known_version` is initialized from the client-provided `known_version_at_stream_start` field in the subscription request metadata: [3](#0-2) [4](#0-3) 

An attacker can craft a subscription request with `known_version_at_stream_start` set to a value close to `u64::MAX`. When the storage service responds with transaction data, the version update will overflow, causing the peer's tracked version to wrap to a low value. This corrupts the subscription state tracking and can lead to:

1. Incorrect version bounds in subsequent data requests
2. Serving duplicate or missing transaction data
3. State sync getting stuck or diverging between nodes
4. Consensus nodes having inconsistent views of sync progress

Additional unchecked arithmetic occurs at:
- Line 550: `self.highest_known_epoch += 1;`
- Line 554: `self.next_index_to_serve += 1;`

In contrast, properly implemented version arithmetic uses checked operations: [5](#0-4) [6](#0-5) 

## Impact Explanation
This vulnerability qualifies as **Critical Severity** because it can cause:

1. **Consensus/Safety violations**: Different nodes may have inconsistent views of which transactions have been synced, potentially causing validators to diverge on state roots
2. **State inconsistencies requiring intervention**: Corrupted version tracking can cause state sync to fail or serve incorrect data, requiring manual node intervention or restarts
3. **Protocol violations**: The overflow bypasses the intended error handling mechanism, violating the invariant that version arithmetic should be bounds-checked

The vulnerability breaks the **State Consistency** and **Deterministic Execution** invariants - nodes must maintain consistent version tracking to ensure all validators process identical transaction sequences.

## Likelihood Explanation
**Likelihood: Medium to High**

The attack is feasible because:
1. Any network peer can send subscription requests to the storage service
2. The attacker controls the `known_version_at_stream_start` value in the request
3. No validation exists to ensure the starting version is reasonable
4. The overflow is silent in release builds (wrapping behavior)

While reaching `u64::MAX` in normal operation would take an extremely long time, an attacker can artificially set the version near the maximum. The attack becomes more likely as the network ages and version numbers naturally increase.

## Recommendation
Replace all unchecked arithmetic operations with checked variants that return `IntegerOverflow` errors:

```rust
// Update the highest known version
self.highest_known_version = self.highest_known_version
    .checked_add(num_data_items as u64)
    .ok_or_else(|| {
        Error::UnexpectedErrorEncountered("Highest known version has overflown!".into())
    })?;

// Update the highest known epoch if we've now hit an epoch ending ledger info
if self.highest_known_version == target_ledger_info.ledger_info().version()
    && target_ledger_info.ledger_info().ends_epoch()
{
    self.highest_known_epoch = self.highest_known_epoch
        .checked_add(1)
        .ok_or_else(|| {
            Error::UnexpectedErrorEncountered("Highest known epoch has overflown!".into())
        })?;
}

// Update the next index to serve
self.next_index_to_serve = self.next_index_to_serve
    .checked_add(1)
    .ok_or_else(|| {
        Error::UnexpectedErrorEncountered("Next index to serve has overflown!".into())
    })?;
```

Additionally, add validation when initializing subscription streams to reject requests with unreasonably high starting versions.

## Proof of Concept

```rust
#[cfg(test)]
mod overflow_poc {
    use super::*;
    use aptos_types::ledger_info::LedgerInfoWithSignatures;
    use aptos_storage_service_types::responses::DataResponse;

    #[test]
    fn test_version_overflow_in_subscription() {
        // Create a subscription stream with version near u64::MAX
        let near_max_version = u64::MAX - 100;
        
        // Create a mock subscription request with high known_version
        let metadata = SubscriptionStreamMetadata {
            known_version_at_stream_start: near_max_version,
            known_epoch_at_stream_start: 0,
            subscription_stream_id: 1,
        };
        
        // Simulate receiving a response with 200 transactions
        // This will cause: (u64::MAX - 100) + 200 = overflow -> wraps to ~99
        let num_transactions = 200;
        
        // After overflow, highest_known_version wraps to a low number
        // This breaks version tracking and causes state sync inconsistencies
        
        // Expected behavior: should return IntegerOverflow error
        // Actual behavior: silently wraps to ~99, corrupting state
    }
}
```

**Notes**

This vulnerability demonstrates a systematic gap in overflow protection within the storage service subscription handling. While the state-sync-driver components consistently use checked arithmetic [7](#0-6) , the storage-service component relies on unchecked operations. This inconsistency indicates the need for a comprehensive audit of all version arithmetic operations across the state sync subsystem to ensure uniform overflow protection.

### Citations

**File:** state-sync/state-sync-driver/src/error.rs (L27-28)
```rust
    #[error("An integer overflow has occurred: {0}")]
    IntegerOverflow(String),
```

**File:** state-sync/storage-service/server/src/subscription.rs (L316-316)
```rust
        let highest_known_version = subscription_request.highest_known_version_at_stream_start();
```

**File:** state-sync/storage-service/server/src/subscription.rs (L543-544)
```rust
        // Update the highest known version
        self.highest_known_version += num_data_items as u64;
```

**File:** state-sync/storage-service/types/src/requests.rs (L418-422)
```rust
pub struct SubscriptionStreamMetadata {
    pub known_version_at_stream_start: u64, // The highest known transaction version at stream start
    pub known_epoch_at_stream_start: u64,   // The highest known epoch at stream start
    pub subscription_stream_id: u64,        // The unique id of the subscription stream
}
```

**File:** state-sync/state-sync-driver/src/continuous_syncer.rs (L376-379)
```rust
        let synced_version = payload_start_version
            .checked_add(num_transactions_or_outputs as u64)
            .and_then(|version| version.checked_sub(1)) // synced_version = start + num txns/outputs - 1
            .ok_or_else(|| Error::IntegerOverflow("The synced version has overflown!".into()))?;
```

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L739-741)
```rust
        let next_version = highest_synced_version.checked_add(1).ok_or_else(|| {
            Error::IntegerOverflow("The next output version has overflown!".into())
        })?;
```

**File:** state-sync/state-sync-driver/src/utils.rs (L68-72)
```rust
    pub fn expected_next_version(&self) -> Result<Version, Error> {
        self.synced_version.checked_add(1).ok_or_else(|| {
            Error::IntegerOverflow("The expected next version has overflown!".into())
        })
    }
```
