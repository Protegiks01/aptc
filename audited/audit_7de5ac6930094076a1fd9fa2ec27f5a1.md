# Audit Report

## Title
Unauthenticated Cross-Shard Message Injection Enabling Consensus Safety Violation

## Summary
The sharded block executor's cross-shard communication channel lacks cryptographic authentication, allowing a compromised validator (or network attacker with MITM capabilities) to inject fake `RemoteTxnWriteMsg` messages. This corrupts execution state, causing non-deterministic execution across validators and breaking consensus safety.

## Finding Description

The Aptos sharded block executor uses `RemoteCrossShardClient` for communication between execution shards. When transactions have cross-shard dependencies, one shard sends execution results to dependent shards via `RemoteTxnWriteMsg` messages. These messages are transmitted over plain GRPC/HTTP without any authentication or signature verification. [1](#0-0) 

The messages are BCS-serialized and sent through NetworkController, which uses plain GRPC over HTTP: [2](#0-1) 

The underlying network layer is plain TCP with no encryption or authentication: [3](#0-2) 

When a message is received, `CrossShardCommitReceiver` directly processes it without any validation: [4](#0-3) 

The malicious message updates `CrossShardStateView` with attacker-controlled data: [5](#0-4) 

This corrupted state is then used during transaction execution. Transactions waiting on cross-shard dependencies will read the fake values: [6](#0-5) 

**Attack Flow:**
1. Validator Node A executes a block with sharded execution enabled
2. Shard 1 computes transaction T1 that writes to storage location L
3. Shard 2 has transaction T2 that depends on reading L from Shard 1
4. Compromised validator (or network attacker) intercepts the cross-shard communication
5. Attacker injects fake `RemoteTxnWriteMsg` with arbitrary value for L
6. Shard 2 uses the fake value for executing T2
7. Node A produces different execution results than honest validators
8. State root divergence causes consensus failure

## Impact Explanation

This vulnerability achieves **Critical Severity** under the "Consensus/Safety violations" category because:

1. **Breaks Deterministic Execution Invariant**: Different validators produce different state roots for identical blocks when they receive different cross-shard messages.

2. **Consensus Safety Violation**: Validators cannot reach agreement on block execution results, violating the core safety property of AptosBFT consensus (< 1/3 Byzantine tolerance).

3. **Potential Chain Split**: Divergent execution results prevent validators from agreeing on state transitions, potentially requiring manual intervention or hard fork to resolve.

4. **No Cryptographic Barrier**: The attack requires no signature forgery or cryptographic break—just network access to inject unauthenticated messages.

The vulnerability directly violates Critical Invariant #1 ("All validators must produce identical state roots for identical blocks") and Invariant #2 ("AptosBFT must prevent chain splits under < 1/3 Byzantine").

## Likelihood Explanation

**Likelihood: MEDIUM to HIGH**

**Attacker Requirements:**
- Control of one validator node participating in sharded execution, OR
- Network-level access (MITM) to validator infrastructure

**Complexity: LOW**
- Simple message injection attack
- No cryptographic operations required
- Straightforward BCS serialization of malicious payloads

**Deployment Considerations:**
If sharded execution with remote communication is enabled in production (via `REMOTE_SHARDED_BLOCK_EXECUTOR`), the vulnerability is immediately exploitable. Even if currently using local execution only, the vulnerable code exists in the production codebase.

A single compromised validator can cause divergence affecting the entire validator set, making this a high-impact, medium-barrier attack.

## Recommendation

Implement cryptographic authentication for all cross-shard messages:

1. **Message Signing**: Add validator signatures to `RemoteTxnWrite` messages:

```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct RemoteTxnWrite {
    state_key: StateKey,
    write_op: Option<WriteOp>,
    // Add authentication fields
    sender_shard_id: ShardId,
    sender_validator_index: u64,
    signature: Signature, // BLS signature over (state_key, write_op, sender_shard_id)
}
```

2. **Signature Verification**: Verify signatures in `CrossShardCommitReceiver`:

```rust
match msg {
    RemoteTxnWriteMsg(txn_commit_msg) => {
        // Verify signature before processing
        if !verify_cross_shard_message(&txn_commit_msg, validator_verifier) {
            warn!("Invalid cross-shard message signature");
            continue;
        }
        let (state_key, write_op) = txn_commit_msg.take();
        cross_shard_state_view.set_value(&state_key, write_op.and_then(|w| w.as_state_value()));
    },
    // ...
}
```

3. **Secure Transport**: If implementing remote sharded execution, use the existing Aptos network layer with Noise IK authentication instead of aptos-secure-net's unauthenticated channels. [7](#0-6) 

## Proof of Concept

```rust
// Exploit demonstration (conceptual - requires actual network setup)

use aptos_vm::sharded_block_executor::messages::{CrossShardMsg, RemoteTxnWrite};
use aptos_types::{state_store::state_key::StateKey, write_set::WriteOp};
use aptos_secure_net::network_controller::Message;

fn inject_fake_cross_shard_message(
    target_shard_address: SocketAddr,
    fake_state_key: StateKey,
    fake_write_op: WriteOp,
) {
    // Create malicious message
    let fake_msg = CrossShardMsg::RemoteTxnWriteMsg(
        RemoteTxnWrite::new(fake_state_key, Some(fake_write_op))
    );
    
    // Serialize without any authentication
    let serialized = bcs::to_bytes(&fake_msg).unwrap();
    
    // Send to target shard's GRPC endpoint
    // The receiver will accept and process this unauthenticated message
    send_grpc_message(target_shard_address, "cross_shard_0", serialized);
    
    // Victim shard now has corrupted state for cross-shard execution
    // This causes non-deterministic execution across validators
}
```

**Validation Steps:**
1. Deploy two remote executor shards with sharded block execution enabled
2. Submit a block with cross-shard dependencies
3. During execution, inject a fake `RemoteTxnWriteMsg` with different state value
4. Observe that the receiving shard uses the fake value
5. Compare execution results with honest validator using correct cross-shard values
6. Confirm state root divergence

## Notes

This vulnerability exists because the `aptos-secure-net` library (despite its misleading name) provides only a simple TCP/GRPC substrate with no security features. The cross-shard communication system assumes a trusted network environment, which is violated when any validator is compromised or network infrastructure is attacked.

The issue is particularly severe because it requires no cryptographic breaks—just network access and the ability to serialize BCS messages. Unlike consensus message injection (which requires valid BLS signatures from validators), cross-shard messages have zero authentication barriers.

### Citations

**File:** execution/executor-service/src/remote_cross_shard_client.rs (L55-66)
```rust
    fn send_cross_shard_msg(&self, shard_id: ShardId, round: RoundId, msg: CrossShardMsg) {
        let input_message = bcs::to_bytes(&msg).unwrap();
        let tx = self.message_txs[shard_id][round].lock().unwrap();
        tx.send(Message::new(input_message)).unwrap();
    }

    fn receive_cross_shard_msg(&self, current_round: RoundId) -> CrossShardMsg {
        let rx = self.message_rxs[current_round].lock().unwrap();
        let message = rx.recv().unwrap();
        let msg: CrossShardMsg = bcs::from_bytes(&message.to_bytes()).unwrap();
        msg
    }
```

**File:** secure/net/src/grpc_network_service/mod.rs (L123-138)
```rust
impl GRPCNetworkMessageServiceClientWrapper {
    pub fn new(rt: &Runtime, remote_addr: SocketAddr) -> Self {
        Self {
            remote_addr: remote_addr.to_string(),
            remote_channel: rt
                .block_on(async { Self::get_channel(format!("http://{}", remote_addr)).await }),
        }
    }

    async fn get_channel(remote_addr: String) -> NetworkMessageServiceClient<Channel> {
        info!("Trying to connect to remote server at {:?}", remote_addr);
        let conn = tonic::transport::Endpoint::new(remote_addr)
            .unwrap()
            .connect_lazy();
        NetworkMessageServiceClient::new(conn).max_decoding_message_size(MAX_MESSAGE_SIZE)
    }
```

**File:** secure/net/src/lib.rs (L1-30)
```rust
// Copyright (c) Aptos Foundation
// Licensed pursuant to the Innovation-Enabling Source Code License, available at https://github.com/aptos-labs/aptos-core/blob/main/LICENSE

#![forbid(unsafe_code)]

//! This provides a simple networking substrate between a client and server. It is assumed that all
//! operations are blocking and return only complete blocks of data. The intended use case has the
//! server blocking on read.  Upon receiving a payload during a read, the server should process the
//! payload, write a response, and then block on read again. The client should block on read after
//! performing a write. Upon errors or remote disconnections, the call (read, write) will return an
//! error to let the caller know of the event. A follow up call will result in the service
//! attempting to either reconnect in the case of a client or accept a new client in the case of a
//! server.
//!
//! Internally both the client and server leverage a NetworkStream that communications in blocks
//! where a block is a length prefixed array of bytes.

pub mod grpc_network_service;
pub mod network_controller;

use aptos_logger::{info, trace, warn, Schema};
use aptos_metrics_core::{register_int_counter_vec, IntCounterVec};
use once_cell::sync::Lazy;
use serde::Serialize;
use std::{
    io::{Read, Write},
    net::{Shutdown, SocketAddr, TcpListener, TcpStream},
    thread, time,
};
use thiserror::Error;
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/cross_shard_client.rs (L31-45)
```rust
        loop {
            let msg = cross_shard_client.receive_cross_shard_msg(round);
            match msg {
                RemoteTxnWriteMsg(txn_commit_msg) => {
                    let (state_key, write_op) = txn_commit_msg.take();
                    cross_shard_state_view
                        .set_value(&state_key, write_op.and_then(|w| w.as_state_value()));
                },
                CrossShardMsg::StopMsg => {
                    trace!("Cross shard commit receiver stopped for round {}", round);
                    break;
                },
            }
        }
    }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/cross_shard_state_view.rs (L49-56)
```rust
    pub fn set_value(&self, state_key: &StateKey, state_value: Option<StateValue>) {
        self.cross_shard_data
            .get(state_key)
            .unwrap()
            .set_value(state_value);
        // uncomment the following line to debug waiting count
        // trace!("waiting count for shard id {} is {}", self.shard_id, self.waiting_count());
    }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/cross_shard_state_view.rs (L77-82)
```rust
    fn get_state_value(&self, state_key: &StateKey) -> Result<Option<StateValue>, StateViewError> {
        if let Some(value) = self.cross_shard_data.get(state_key) {
            return Ok(value.get_value());
        }
        self.base_view.get_state_value(state_key)
    }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/messages.rs (L7-31)
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
pub enum CrossShardMsg {
    RemoteTxnWriteMsg(RemoteTxnWrite),
    StopMsg,
}

#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct RemoteTxnWrite {
    state_key: StateKey,
    // The write op is None if the transaction is aborted.
    write_op: Option<WriteOp>,
}

impl RemoteTxnWrite {
    pub fn new(state_key: StateKey, write_op: Option<WriteOp>) -> Self {
        Self {
            state_key,
            write_op,
        }
    }

    pub fn take(self) -> (StateKey, Option<WriteOp>) {
        (self.state_key, self.write_op)
    }
}
```
