# Audit Report

## Title
API Crashes Due to Missing Indexer Reader Validation When Storage Sharding is Enabled

## Summary
When storage sharding is enabled (default configuration) but both table info service and internal indexer DB are disabled (also default), the API Context is initialized with `indexer_reader = None`. Critical API endpoints that query account resources, modules, and transactions fail with "Indexer reader doesn't exist" errors, causing 500 Internal Server Errors and rendering these endpoints non-functional.

## Finding Description

The vulnerability exists in the initialization and usage pattern of the indexer reader across multiple components:

1. **Bootstrap Phase**: The `bootstrap()` function in indexer-grpc-table-info returns `None` when the service is disabled [1](#0-0) 

2. **IndexerReaders Construction**: When both indexers are disabled, `IndexerReaders::new()` returns `None` [2](#0-1) 

3. **API Context Creation**: The Context is created with `indexer_reader = None` [3](#0-2) 

4. **Runtime Failure**: When storage sharding is enabled (checked via `db_sharding_enabled()`), the code assumes `indexer_reader` must be available and attempts to use it without proper None handling:

   - In `get_state_values()` [4](#0-3) 
   
   - In `get_resources_by_pagination()` [5](#0-4) 
   
   - In `get_modules_by_pagination()` [6](#0-5) 
   
   - In `get_account_ordered_transactions()` [7](#0-6) 

5. **Configuration Defaults**: The problematic state occurs with default configuration:
   - Storage sharding is enabled by default [8](#0-7) 
   - Internal indexer DB is disabled by default [9](#0-8) 

6. **Missing Validation**: No configuration validation enforces that if storage sharding is enabled, at least one indexer must be enabled. The only check validates the reverse direction [10](#0-9) 

## Impact Explanation

This is a **HIGH severity** vulnerability per Aptos bug bounty criteria:

- **API Crashes**: Critical API endpoints return 500 Internal Server Error when queried, specifically:
  - `GET /accounts/:address/resources` 
  - `GET /accounts/:address/modules`
  - `GET /accounts/:address/transactions`
  - Any endpoint querying account state when sharding is enabled

- **Default Configuration Vulnerable**: The issue manifests with default node configuration, meaning nodes deployed without explicit indexer configuration will have non-functional API endpoints.

- **No Startup Warning**: The system starts successfully but fails at runtime when APIs are called, making the issue difficult to detect until user impact occurs.

This meets the HIGH severity criteria of "API crashes" as specified in the bug bounty program.

## Likelihood Explanation

**Likelihood: HIGH**

This issue is highly likely to occur because:

1. **Default Configuration**: Both `enable_storage_sharding = true` and indexers disabled are default settings
2. **No Validation**: No startup validation prevents this invalid state
3. **Silent Failure**: The node starts successfully, giving no indication of the problem
4. **Common Use Case**: Many nodes may run without indexers if they only need basic functionality
5. **Widespread Impact**: Affects all API calls to fundamental endpoints like resource queries

## Recommendation

Implement configuration validation at startup to enforce the invariant that when storage sharding is enabled, at least one indexer must be available. Add this validation to `StorageConfig::sanitize()`:

```rust
// In config/src/config/storage_config.rs, add to sanitize() method:
if config.rocksdb_configs.enable_storage_sharding {
    let table_info_enabled = node_config.indexer_table_info.table_info_service_mode.is_enabled();
    let internal_indexer_enabled = node_config.indexer_db_config.is_internal_indexer_db_enabled();
    
    if !table_info_enabled && !internal_indexer_enabled {
        return Err(Error::ConfigSanitizerFailed(
            sanitizer_name,
            "When storage sharding is enabled, at least one indexer (table_info_service or internal_indexer_db) must be enabled".to_string(),
        ));
    }
}
```

Alternatively, add graceful fallback handling in the API Context methods to use the direct DB reader when indexer is unavailable, though this would require careful consideration of performance implications.

## Proof of Concept

To reproduce this vulnerability:

1. **Configure Node** with default settings (or explicitly set):
```yaml
storage:
  rocksdb_configs:
    enable_storage_sharding: true  # default

indexer_table_info:
  table_info_service_mode: Disabled  # default

indexer_db_config:
  enable_transaction: false  # default
  enable_event: false  # default
  enable_statekeys: false  # default
```

2. **Start the Node**: The node will start successfully without errors

3. **Query API Endpoint**:
```bash
curl http://localhost:8080/v1/accounts/0x1/resources
```

4. **Expected Result**: 500 Internal Server Error with message "Indexer reader doesn't exist"

5. **Code Path Verification**: The error originates from [11](#0-10)  where `ok_or_else()` converts the None indexer_reader into an error, which then propagates up through [12](#0-11)  to become a 500 response.

## Notes

This vulnerability demonstrates a critical gap between configuration validation and runtime assumptions. The code correctly handles the `Option<Arc<dyn IndexerReader>>` type in the Context struct, but the conditional logic in `db_sharding_enabled()` creates an implicit requirement that when sharding is on, the indexer must exist. This assumption is never validated at startup, leading to runtime failures.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-table-info/src/runtime.rs (L57-63)
```rust
    if !config
        .indexer_table_info
        .table_info_service_mode
        .is_enabled()
    {
        return None;
    }
```

**File:** storage/indexer/src/indexer_reader.rs (L27-39)
```rust
    pub fn new(
        table_info_reader: Option<Arc<IndexerAsyncV2>>,
        db_indexer_reader: Option<Arc<DBIndexer>>,
    ) -> Option<Self> {
        if table_info_reader.is_none() && db_indexer_reader.is_none() {
            None
        } else {
            Some(Self {
                table_info_reader,
                db_indexer_reader,
            })
        }
    }
```

**File:** aptos-node/src/services.rs (L72-92)
```rust
    let (indexer_table_info_runtime, indexer_async_v2) = match bootstrap_indexer_table_info(
        node_config,
        chain_id,
        db_rw.clone(),
        mempool_client_sender.clone(),
    ) {
        Some((runtime, indexer_v2)) => (Some(runtime), Some(indexer_v2)),
        None => (None, None),
    };

    let (db_indexer_runtime, txn_event_reader) = match bootstrap_internal_indexer_db(
        node_config,
        db_rw.clone(),
        internal_indexer_db,
        update_receiver,
    ) {
        Some((runtime, db_indexer)) => (Some(runtime), Some(db_indexer)),
        None => (None, None),
    };

    let indexer_readers = IndexerReaders::new(indexer_async_v2, txn_event_reader);
```

**File:** api/src/context.rs (L443-458)
```rust
        let mut iter = if !db_sharding_enabled(&self.node_config) {
            Box::new(
                self.db
                    .get_prefixed_state_value_iterator(
                        &StateKeyPrefix::from(address),
                        None,
                        version,
                    )?
                    .map(|item| item.map_err(|err| anyhow!(err.to_string()))),
            )
        } else {
            self.indexer_reader
                .as_ref()
                .ok_or_else(|| format_err!("Indexer reader doesn't exist"))?
                .get_prefixed_state_value_iterator(&StateKeyPrefix::from(address), None, version)?
        };
```

**File:** api/src/context.rs (L477-496)
```rust
        let account_iter = if !db_sharding_enabled(&self.node_config) {
            Box::new(
                self.db
                    .get_prefixed_state_value_iterator(
                        &StateKeyPrefix::from(address),
                        prev_state_key,
                        version,
                    )?
                    .map(|item| item.map_err(|err| anyhow!(err.to_string()))),
            )
        } else {
            self.indexer_reader
                .as_ref()
                .ok_or_else(|| format_err!("Indexer reader doesn't exist"))?
                .get_prefixed_state_value_iterator(
                    &StateKeyPrefix::from(address),
                    prev_state_key,
                    version,
                )?
        };
```

**File:** api/src/context.rs (L568-587)
```rust
        let account_iter = if !db_sharding_enabled(&self.node_config) {
            Box::new(
                self.db
                    .get_prefixed_state_value_iterator(
                        &StateKeyPrefix::from(address),
                        prev_state_key,
                        version,
                    )?
                    .map(|item| item.map_err(|err| anyhow!(err.to_string()))),
            )
        } else {
            self.indexer_reader
                .as_ref()
                .ok_or_else(|| format_err!("Indexer reader doesn't exist"))?
                .get_prefixed_state_value_iterator(
                    &StateKeyPrefix::from(address),
                    prev_state_key,
                    version,
                )?
        };
```

**File:** api/src/context.rs (L900-923)
```rust
        let txns_res = if !db_sharding_enabled(&self.node_config) {
            self.db.get_account_ordered_transactions(
                address,
                start_seq_number,
                limit as u64,
                true,
                ledger_version,
            )
        } else {
            self.indexer_reader
                .as_ref()
                .ok_or_else(|| anyhow!("Indexer reader is None"))
                .map_err(|err| {
                    E::internal_with_code(err, AptosErrorCode::InternalError, ledger_info)
                })?
                .get_account_ordered_transactions(
                    address,
                    start_seq_number,
                    limit as u64,
                    true,
                    ledger_version,
                )
                .map_err(|e| AptosDbError::Other(e.to_string()))
        };
```

**File:** config/src/config/storage_config.rs (L233-233)
```rust
            enable_storage_sharding: true,
```

**File:** config/src/config/internal_indexer_db_config.rs (L69-80)
```rust
impl Default for InternalIndexerDBConfig {
    fn default() -> Self {
        Self {
            enable_transaction: false,
            enable_event: false,
            enable_event_v2_translation: false,
            event_v2_translation_ignores_below_version: 0,
            enable_statekeys: false,
            batch_size: 10_000,
        }
    }
}
```

**File:** config/src/config/internal_indexer_db_config.rs (L82-102)
```rust
impl ConfigSanitizer for InternalIndexerDBConfig {
    fn sanitize(
        node_config: &NodeConfig,
        _node_type: NodeType,
        _chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();
        let config = node_config.indexer_db_config;

        // Shouldn't turn on internal indexer for db without sharding
        if !node_config.storage.rocksdb_configs.enable_storage_sharding
            && config.is_internal_indexer_db_enabled()
        {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "Don't turn on internal indexer db if DB sharding is off".into(),
            ));
        }

        Ok(())
    }
```

**File:** api/src/accounts.rs (L450-471)
```rust
        let (resources, next_state_key) = self
            .context
            .get_resources_by_pagination(
                self.address.into(),
                self.start.as_ref(),
                self.ledger_version,
                // Just use the max as the default
                determine_limit(
                    self.limit,
                    max_account_resources_page_size,
                    max_account_resources_page_size,
                    &self.latest_ledger_info,
                )? as u64,
            )
            .context("Failed to get resources from storage")
            .map_err(|err| {
                BasicErrorWith404::internal_with_code(
                    err,
                    AptosErrorCode::InternalError,
                    &self.latest_ledger_info,
                )
            })?;
```
