# Audit Report

## Title
TOCTOU Vulnerability in TransferFunder Allows Funding Existing Accounts Despite "New Accounts Only" Policy

## Summary
The `TransferFunder::fund()` function contains a Time-Of-Check-Time-Of-Use (TOCTOU) race condition between checking if a receiver account exists (lines 284-293) and executing the transfer transaction (lines 314-320). This allows an attacker to bypass the faucet's "new accounts only" restriction by creating the receiver account during the race window, enabling the faucet to fund existing accounts contrary to its intended security policy. [1](#0-0) 

## Finding Description
The vulnerability exists in the temporal gap between off-chain validation and on-chain execution:

**Step 1 (Time of Check):** The faucet calls `update_sequence_numbers()` which queries the on-chain state via API to determine if the receiver account exists. [2](#0-1) 

**Step 2 (Validation):** The faucet checks if `receiver_seq_num.is_some()` and rejects the request if the account exists. [3](#0-2) 

**Step 3 (Race Window):** Between the check and transaction execution, another transaction can create the receiver account and be included in a block.

**Step 4 (Time of Use):** The faucet executes `aptos_account::transfer`, which is designed to handle both existing and non-existing accounts. [4](#0-3) 

The Move function `aptos_account::transfer` checks if the account exists and only creates it if it doesn't, then proceeds with the transfer regardless. [5](#0-4) 

The developer comment incorrectly states: "This Move function checks if the account exists, and if it does, returns an error." [6](#0-5) 

This is false—the function transfers to existing accounts without error.

**Attack Scenario:**
1. Attacker requests faucet funds for address A (not yet created)
2. Faucet checks if A exists → doesn't exist, passes validation
3. Attacker submits transaction to create account A
4. Both transactions enter mempool; attacker's transaction executes first
5. Faucet transaction executes: `aptos_account::transfer` sees account exists, skips creation, transfers funds successfully
6. Attacker has successfully received faucet funds to an existing account, bypassing the "new accounts only" policy

## Impact Explanation
This vulnerability falls under **Medium Severity** per the bug bounty criteria: "Limited funds loss or manipulation."

The faucet service loses control over its fund distribution policy by being forced to fund existing accounts. While rate limiting mechanisms still constrain per-IP/UID requests, an attacker can:
- Repeatedly exploit the race condition to receive funds for accounts they pre-create
- Bypass the explicit rejection mechanism designed to prevent funding existing accounts
- Potentially drain faucet funds faster than intended by the service operators

However, the impact is limited because:
- The faucet still controls the per-request amount
- Rate limiting prevents unlimited exploitation
- This affects testnet/devnet faucets (no real financial value)
- The faucet is not a consensus-critical component

## Likelihood Explanation
**Likelihood: Medium to High**

The race window is exploitable because:
1. The time between API query (off-chain) and transaction execution (on-chain) can be several seconds in a busy network
2. An attacker can submit both the faucet request and their own account creation transaction in rapid succession
3. Transaction ordering in the mempool provides opportunities for the attacker's transaction to execute first
4. No atomic on-chain check exists that would cause the faucet transaction to fail if the account state changes

The attack requires timing but is feasible with automated tooling and repeated attempts.

## Recommendation
Implement one of the following fixes:

**Option 1: Use a Move function that enforces account non-existence on-chain**
Create a new Move function that atomically checks account non-existence and aborts if the account exists:

```move
public entry fun transfer_to_new_account_only(source: &signer, to: address, amount: u64) {
    // Enforce that account doesn't exist
    assert!(!account::exists_at(to), error::already_exists(EACCOUNT_ALREADY_EXISTS));
    create_account(to);
    // Transfer logic...
}
```

**Option 2: Check transaction execution result**
Modify the faucet to verify the transaction actually created a new account by checking the receiver's sequence number after execution: [7](#0-6) 

After transaction success, query the receiver account and verify `sequence_number == 0` (indicating it was just created).

**Option 3: Accept the behavior and update documentation**
If funding existing accounts is acceptable, remove the check at lines 297-306 and update the comment to reflect actual behavior.

## Proof of Concept

**Rust Test Scenario:**
```rust
// Pseudocode for reproduction
async fn test_toctou_race() {
    let faucet = setup_transfer_faucet();
    let receiver = generate_new_address();
    
    // Thread 1: Faucet request
    let faucet_handle = tokio::spawn(async move {
        faucet.fund(None, receiver, None, false, false).await
    });
    
    // Thread 2: Create account during race window
    tokio::time::sleep(Duration::from_millis(10)); // After check, before execution
    let create_handle = tokio::spawn(async move {
        client.create_account(receiver).await
    });
    
    // Both complete successfully
    let faucet_result = faucet_handle.await.unwrap();
    let create_result = create_handle.await.unwrap();
    
    // Verify: Account exists and has faucet funds
    // This violates the "new accounts only" invariant
    assert!(faucet_result.is_ok()); // Should have failed but succeeded
}
```

The proof demonstrates that the faucet can successfully fund an account that was created between the existence check and transaction execution.

## Notes
This vulnerability represents a classic TOCTOU issue where off-chain state validation cannot guarantee on-chain state invariants. The mismatch between the developer's understanding of `aptos_account::transfer` behavior (documented in the incorrect comment) and its actual implementation is the root cause. While the faucet is not a consensus-critical component, maintaining accurate fund distribution policies is important for service integrity and resource management.

### Citations

**File:** crates/aptos-faucet/core/src/funder/transfer.rs (L284-293)
```rust
        let (_funder_seq_num, receiver_seq_num) = update_sequence_numbers(
            &client,
            &self.faucet_account,
            &self.outstanding_requests,
            receiver_address,
            amount,
            self.wait_for_outstanding_txns_secs,
            DEFAULT_ASSET_NAME,
        )
        .await?;
```

**File:** crates/aptos-faucet/core/src/funder/transfer.rs (L297-306)
```rust
        if receiver_seq_num.is_some() {
            return Err(AptosTapError::new(
                "Account ineligible".to_string(),
                AptosTapErrorCode::Rejected,
            )
            .rejection_reasons(vec![RejectionReason::new(
                format!("Account {} already exists", receiver_address),
                RejectionReasonCode::AccountAlreadyExists,
            )]));
        }
```

**File:** crates/aptos-faucet/core/src/funder/transfer.rs (L308-310)
```rust
        // This Move function checks if the account exists, and if it does,
        // returns an error. If not, it creates the account and transfers the
        // requested amount of coins to it.
```

**File:** crates/aptos-faucet/core/src/funder/transfer.rs (L314-320)
```rust
            let txn = self
                .execute_transaction(
                    &client,
                    aptos_stdlib::aptos_account_transfer(receiver_address, amount),
                    &receiver_address,
                )
                .await?;
```

**File:** crates/aptos-faucet/core/src/funder/common.rs (L311-339)
```rust
async fn get_sequence_numbers(
    client: &Client,
    funder_account: &RwLock<LocalAccount>,
    receiver_address: AccountAddress,
) -> Result<(u64, Option<u64>), AptosTapError> {
    let funder_address = funder_account.read().await.address();
    let f_request = client.get_account(funder_address);
    let r_request = client.get_account(receiver_address);
    let mut responses = futures::future::join_all([f_request, r_request]).await;

    let receiver_seq_num = responses
        .remove(1)
        .as_ref()
        .ok()
        .map(|account| account.inner().sequence_number);

    let funder_seq_num = responses
        .remove(0)
        .map_err(|e| {
            AptosTapError::new(
                format!("funder account {} not found: {:#}", funder_address, e),
                AptosTapErrorCode::AccountDoesNotExist,
            )
        })?
        .inner()
        .sequence_number;

    Ok((funder_seq_num, receiver_seq_num))
}
```

**File:** crates/aptos-faucet/core/src/funder/common.rs (L342-399)
```rust
pub async fn submit_transaction(
    client: &Client,
    faucet_account: &RwLock<LocalAccount>,
    signed_transaction: SignedTransaction,
    receiver_address: &AccountAddress,
    wait_for_transactions: bool,
) -> Result<SignedTransaction, AptosTapError> {
    let (result, event_on_success) = if wait_for_transactions {
        // If this fails, we assume it is the user's fault, e.g. because the
        // account already exists, but it is possible that the transaction
        // timed out. It's hard to tell because this function returns an opaque
        // anyhow error. https://github.com/aptos-labs/aptos-tap/issues/60.
        (
            client
                .submit_and_wait_bcs(&signed_transaction)
                .await
                .map(|_| ())
                .map_err(|e| {
                    AptosTapError::new_with_error_code(e, AptosTapErrorCode::TransactionFailed)
                }),
            "transaction_success",
        )
    } else {
        (
            client
                .submit_bcs(&signed_transaction)
                .await
                .map(|_| ())
                .map_err(|e| {
                    AptosTapError::new_with_error_code(e, AptosTapErrorCode::TransactionFailed)
                }),
            "transaction_submitted",
        )
    };

    // If there was an issue submitting a transaction we should just reset
    // our sequence numbers to what it was before.
    match result {
        Ok(_) => {
            info!(
                hash = signed_transaction.committed_hash(),
                address = receiver_address,
                event = event_on_success,
            );
            Ok(signed_transaction)
        },
        Err(e) => {
            faucet_account.write().await.decrement_sequence_number();
            warn!(
                hash = signed_transaction.committed_hash(),
                address = receiver_address,
                event = "transaction_failure",
                error_message = format!("{:#}", e)
            );
            Err(e)
        },
    }
}
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_account.move (L82-97)
```text
    public entry fun transfer(source: &signer, to: address, amount: u64) {
        if (!account::exists_at(to)) {
            create_account(to)
        };

        if (features::operations_default_to_fa_apt_store_enabled()) {
            fungible_transfer_only(source, to, amount)
        } else {
            // Resource accounts can be created without registering them to receive APT.
            // This conveniently does the registration if necessary.
            if (!coin::is_account_registered<AptosCoin>(to)) {
                coin::register<AptosCoin>(&create_signer(to));
            };
            coin::transfer<AptosCoin>(source, to, amount)
        }
    }
```
