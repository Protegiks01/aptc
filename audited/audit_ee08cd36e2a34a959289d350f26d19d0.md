# Audit Report

## Title
Non-Deterministic Layout Validation Causes Consensus Split Vulnerability

## Summary
The `randomly_check_layout_matches()` function uses non-deterministic randomness (`rand::thread_rng()`) to perform layout validation only 1% of the time during consensus-critical transaction execution. This violates the fundamental deterministic execution requirement for blockchain consensus, potentially causing different validators to produce different state roots for identical transactions.

## Finding Description

The vulnerability exists in the `randomly_check_layout_matches()` function which uses non-deterministic randomness during consensus-critical operations. [1](#0-0) 

The function uses `rand::thread_rng()` to generate a random number and only validates layout equality when the random number equals 1 (1% probability). This non-deterministic behavior violates Aptos's core design principle stated in the consensus documentation: "It is straightforward to integrate execution as a part of consensus to avoid forking issues that arise from non-deterministic execution in a leader-based protocol." [2](#0-1) 

The function is invoked in multiple consensus-critical paths:

1. **During change set squashing of resource writes**, where it checks layout compatibility when combining write operations. [3](#0-2) 

2. **During transaction session finalization**, when epilogue, prologue, and user sessions squash their change sets together. If the random check detects a layout mismatch, it returns `UNKNOWN_INVARIANT_VIOLATION_ERROR`, causing the transaction to fail. [4](#0-3) 

3. **During block execution in the parallel executor**, when materializing delayed field exchanges. [5](#0-4) 

**Attack Scenario:**
If any condition causes mismatched layouts during change set operations (due to bugs, edge cases in module upgrades, resource group inconsistencies, or malicious transaction crafting):
- Validator A generates random number ≠ 1 (99% probability) → check skipped → transaction succeeds
- Validator B generates random number = 1 (1% probability) → check runs → detects mismatch → transaction fails
- Result: Different validators produce different state roots for the same block, causing a consensus split

## Impact Explanation

**Critical Severity - Consensus Safety Violation**

This vulnerability meets the **Critical Severity** criteria per Aptos Bug Bounty program:

1. **Consensus/Safety Violations**: Different validators can execute identical transactions to produce different results, directly violating the deterministic execution invariant that all validators must produce identical state roots for identical blocks.

2. **Non-recoverable Network Partition**: When ~1% of validators reject a transaction that ~99% accept (or vice versa), the network experiences a consensus split requiring manual intervention or hard fork to resolve.

3. **Direct Violation of Core Design Principles**: The Aptos consensus system explicitly states: "we make the protocol more resistant to non-determinism bugs, by having validators collectively sign the resulting state of a block rather than just the sequence of transactions." [6](#0-5)  This vulnerability directly undermines this protection.

**Scope of Damage:**
- Loss of consensus finality when validators diverge on block state
- Potential blockchain halt requiring emergency coordination
- State inconsistency across validator nodes
- Erosion of trust in network reliability

## Likelihood Explanation

**Likelihood: Medium to High**

The likelihood assessment is based on several factors:

1. **Defensive Check Indicates Uncertainty**: The presence of this check (even if probabilistic) suggests developers anticipated scenarios where layouts might not match, despite the code comment stating they "are supposed to match."

2. **Trigger Conditions**: Layout mismatches could occur due to:
   - Module upgrade edge cases during transaction execution
   - Resource group layout computation inconsistencies  
   - Delayed field materialization edge cases
   - Bugs in Move VM layout generation

3. **Detection Difficulty**: The 99% pass rate means bugs causing layout mismatches may go undetected in testing environments but manifest in production when enough validators participate (statistical certainty with 100+ validators).

4. **No Privilege Required**: This affects normal transaction execution and does not require validator access or any special privileges.

5. **Inherent Design Flaw**: Regardless of current triggerability, using non-deterministic randomness in consensus-critical code paths is fundamentally incompatible with blockchain requirements.

## Recommendation

Replace the non-deterministic probabilistic check with one of these deterministic approaches:

**Option 1 - Always Validate (Simple but Expensive):**
```rust
pub fn check_layout_matches(
    layout_1: Option<&MoveTypeLayout>,
    layout_2: Option<&MoveTypeLayout>,
) -> Result<(), PanicError> {
    if layout_1.is_some() != layout_2.is_some() {
        return Err(code_invariant_error(format!(
            "Layouts don't match when they are expected to: {:?} and {:?}",
            layout_1, layout_2
        )));
    }
    if layout_1.is_some() && layout_1 != layout_2 {
        return Err(code_invariant_error(format!(
            "Layouts don't match when they are expected to: {:?} and {:?}",
            layout_1, layout_2
        )));
    }
    Ok(())
}
```

**Option 2 - Deterministic Sampling Based on Block Hash:**
Use the current block hash or transaction hash to derive a deterministic seed, ensuring all validators perform the same validation for the same transaction.

**Option 3 - Fast Layout Hash Comparison:**
Pre-compute deterministic hashes of layouts to enable O(1) equality checks instead of expensive recursive comparisons.

## Proof of Concept

The vulnerability is demonstrated by the code structure itself. A concrete PoC would require:

1. Creating a transaction that triggers layout mismatches during change set squashing
2. Running the same transaction on multiple validator nodes  
3. Observing that ~1% of validators reject the transaction while ~99% accept it
4. Confirming different state roots result from the same block

The core vulnerability is the use of non-deterministic randomness in consensus code, which is evident from the source code without requiring runtime demonstration.

## Notes

This vulnerability represents a fundamental architectural flaw where performance optimization (avoiding expensive layout comparisons) was implemented using non-deterministic randomness in a system that requires absolute determinism. Even if layout mismatches are rare in current production environments, the non-deterministic behavior violates the core safety guarantees of the consensus system and creates a latent risk for consensus splits.

The vulnerability affects the execution engine component which is explicitly designed to maintain deterministic execution across all validators. The parallel execution validation logic uses deterministic layout comparison [7](#0-6) , but this occurs after the non-deterministic squashing has already completed, so it cannot catch the consensus divergence introduced by `randomly_check_layout_matches()`.

### Citations

**File:** aptos-move/aptos-vm-types/src/change_set.rs (L48-74)
```rust
/// Sporadically checks if the given two input type layouts match.
pub fn randomly_check_layout_matches(
    layout_1: Option<&MoveTypeLayout>,
    layout_2: Option<&MoveTypeLayout>,
) -> Result<(), PanicError> {
    if layout_1.is_some() != layout_2.is_some() {
        return Err(code_invariant_error(format!(
            "Layouts don't match when they are expected to: {:?} and {:?}",
            layout_1, layout_2
        )));
    }
    if layout_1.is_some() {
        // Checking if 2 layouts are equal is a recursive operation and is expensive.
        // We generally call this `randomly_check_layout_matches` function when we know
        // that the layouts are supposed to match. As an optimization, we only randomly
        // check if the layouts are matching.
        let mut rng = rand::thread_rng();
        let random_number: u32 = rng.gen_range(0, 100);
        if random_number == 1 && layout_1 != layout_2 {
            return Err(code_invariant_error(format!(
                "Layouts don't match when they are expected to: {:?} and {:?}",
                layout_1, layout_2
            )));
        }
    }
    Ok(())
}
```

**File:** aptos-move/aptos-vm-types/src/change_set.rs (L522-550)
```rust
    fn squash_additional_resource_write_ops<
        K: Hash + Eq + PartialEq + Ord + Clone + std::fmt::Debug,
    >(
        write_set: &mut BTreeMap<K, (WriteOp, Option<TriompheArc<MoveTypeLayout>>)>,
        additional_write_set: BTreeMap<K, (WriteOp, Option<TriompheArc<MoveTypeLayout>>)>,
    ) -> Result<(), PanicError> {
        for (key, additional_entry) in additional_write_set.into_iter() {
            match write_set.entry(key.clone()) {
                Occupied(mut entry) => {
                    // Squash entry and additional entries if type layouts match.
                    let (additional_write_op, additional_type_layout) = additional_entry;
                    let (write_op, type_layout) = entry.get_mut();
                    randomly_check_layout_matches(
                        type_layout.as_deref(),
                        additional_type_layout.as_deref(),
                    )?;
                    let noop = !WriteOp::squash(write_op, additional_write_op).map_err(|e| {
                        code_invariant_error(format!("Error while squashing two write ops: {}.", e))
                    })?;
                    if noop {
                        entry.remove();
                    }
                },
                Vacant(entry) => {
                    entry.insert(additional_entry);
                },
            }
        }
        Ok(())
```

**File:** consensus/README.md (L31-31)
```markdown
The AptosBFT protocol decomposes into modules for safety (voting and commit rules) and liveness (round_state). This decoupling provides the ability to develop and experiment independently and on different modules in parallel. Due to the simple voting and commit rules, protocol safety is easy to implement and verify. It is straightforward to integrate execution as a part of consensus to avoid forking issues that arise from non-deterministic execution in a leader-based protocol. We did not consider proof-of-work based protocols, such as [Bitcoin](https://bitcoin.org/bitcoin.pdf), due to their poor performance and high energy (and environmental) costs.
```

**File:** consensus/README.md (L35-35)
```markdown
We reformulate the safety conditions and provide extended proofs of safety, liveness, and optimistic responsiveness. We also implement a number of additional features. First, we make the protocol more resistant to non-determinism bugs, by having validators collectively sign the resulting state of a block rather than just the sequence of transactions. This also allows clients to use quorum certificates to authenticate reads from the database. Second, we design a round_state that emits explicit timeouts, and validators rely on a quorum of those to move to the next round — without requiring synchronized clocks. Third, we intend to design an unpredictable leader election mechanism in which the leader of a round is determined by the proposer of the latest committed block using a verifiable rand ... (truncated)
```

**File:** aptos-move/aptos-vm/src/move_vm_ext/session/respawned_session.rs (L72-109)
```rust
    pub fn finish_with_squashed_change_set(
        mut self,
        change_set_configs: &ChangeSetConfigs,
        module_storage: &impl ModuleStorage,
        assert_no_additional_creation: bool,
    ) -> Result<VMChangeSet, VMStatus> {
        let additional_change_set = self.with_session_mut(|session| {
            unwrap_or_invariant_violation(
                session.take(),
                "VM session cannot be finished more than once.",
            )?
            .finish(change_set_configs, module_storage)
            .map_err(|e| e.into_vm_status())
        })?;
        if assert_no_additional_creation && additional_change_set.has_creation() {
            // After respawning in the epilogue, there shouldn't be new slots
            // created, otherwise there's a potential vulnerability like this:
            // 1. slot created by the user
            // 2. another user transaction deletes the slot and claims the refund
            // 3. in the epilogue the same slot gets recreated, and the final write set will have
            //    a ModifyWithMetadata carrying the original metadata
            // 4. user keeps doing the same and repeatedly claim refund out of the slot.
            return Err(VMStatus::error(
                StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR,
                err_msg("Unexpected storage allocation after respawning session."),
            ));
        }
        let mut change_set = self.into_heads().executor_view.change_set;
        change_set
            .squash_additional_change_set(additional_change_set)
            .map_err(|_err| {
                VMStatus::error(
                    StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR,
                    err_msg("Failed to squash VMChangeSet"),
                )
            })?;
        Ok(change_set)
    }
```

**File:** aptos-move/block-executor/src/executor_utilities.rs (L57-80)
```rust
macro_rules! resource_writes_to_materialize {
    ($writes:expr, $outputs:expr, $data_source:expr, $($txn_idx:expr),*) => {{
	$outputs
        .reads_needing_delayed_field_exchange($($txn_idx),*)
        .into_iter()
	    .map(|(key, metadata, layout)| -> Result<_, PanicError> {
	        let (value, existing_layout) = $data_source.fetch_exchanged_data(&key, $($txn_idx),*)?;
            randomly_check_layout_matches(Some(&existing_layout), Some(layout.as_ref()))?;
            let new_value = TriompheArc::new(TransactionWrite::from_state_value(Some(
                StateValue::new_with_metadata(
                    value.bytes().cloned().unwrap_or_else(Bytes::new),
                    metadata,
                ))
            ));
            Ok((key, new_value, layout))
        })
        .chain(
	        $writes.into_iter().filter_map(|(key, (value, maybe_layout))| {
		        maybe_layout.map(|layout| {
                    (!value.is_deletion()).then_some(Ok((key, value, layout)))
                }).flatten()
            })
        )
        .collect::<Result<Vec<_>, _>>()
```

**File:** aptos-move/mvhashmap/src/versioned_data.rs (L382-400)
```rust
fn compare_values_and_layouts<
    const ONLY_COMPARE_METADATA: bool,
    V: TransactionWrite + PartialEq,
>(
    prev_value: &V,
    new_value: &V,
    prev_maybe_layout: Option<&Arc<MoveTypeLayout>>,
    new_maybe_layout: Option<&Arc<MoveTypeLayout>>,
) -> bool {
    // ONLY_COMPARE_METADATA is a const static flag that indicates that these entries are
    // versioning metadata only, and not the actual value (Currently, only used for versioning
    // resource group metadata). Hence, validation is only performed on the metadata.
    if ONLY_COMPARE_METADATA {
        prev_value.as_state_value_metadata() == new_value.as_state_value_metadata()
    } else {
        // Layouts pass validation only if they are both None. Otherwise, validation pessimistically
        // fails. This is a simple logic that avoids potentially costly layout comparisons.
        prev_maybe_layout.is_none() && new_maybe_layout.is_none() && prev_value == new_value
    }
```
