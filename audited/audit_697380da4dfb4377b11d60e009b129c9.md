# Audit Report

## Title
Integer Overflow Panic in Rosetta API Total Stake Balance Calculation

## Summary
The `parse_requested_balance` function in the Aptos Rosetta API implementation lacks overflow protection when summing delegation pool stake values, which could cause server crashes in production due to enabled overflow checks. [1](#0-0) 

## Finding Description
The vulnerability exists in the total stake calculation path where three u64 values (active, inactive, pending_inactive stake) are summed without overflow checking. While the Move framework's `get_stake` view function returns three separate valid u64 values, their sum could theoretically exceed u64::MAX (18,446,744,073,709,551,615 octas â‰ˆ 184 million APT). [2](#0-1) 

The critical issue is compounded by Aptos Core's build configuration: [3](#0-2) 

With `overflow-checks = true` in release builds, any overflow triggers a panic rather than wrapping, causing immediate process termination.

## Impact Explanation
**Assessment: Not a Valid Security Vulnerability**

While this represents a code quality defect, it does **not** meet the criteria for a security vulnerability because:

1. **Exploitability requires impossibly large stake**: To trigger overflow, a single delegator would need >184 million APT across three stake states (active + inactive + pending_inactive > u64::MAX octas)

2. **Economic infeasibility**: With Aptos total supply around 1 billion APT, no single delegator can realistically accumulate this amount

3. **Existing protections**: The Move layer has overflow checks that would abort before returning values that could overflow when summed [4](#0-3) 

## Likelihood Explanation
**Extremely Low (Practically Zero)**

The attack requires:
- A single delegator with >184 million APT staked
- Distribution across multiple stake states that sum beyond u64::MAX
- These conditions cannot be met within Aptos tokenomics constraints

## Recommendation
Despite low exploitability, defensive programming best practices suggest using checked arithmetic:

```rust
} else if account_identifier.is_total_stake() {
    let sum = balances_result
        .iter()
        .map(|v| {
            v.as_str()
                .and_then(|s| s.parse::<u64>().ok())
                .unwrap_or(0)
        })
        .try_fold(0u64, |acc, val| acc.checked_add(val))
        .ok_or_else(|| ApiError::InternalError(Some("Stake balance overflow".to_string())))?;
    return Ok(Some(sum.to_string()));
}
```

## Proof of Concept
Cannot provide realistic PoC because the vulnerability requires economically impossible conditions (>184 million APT in single delegation).

---

## Notes

After thorough analysis, while the code lacks overflow protection and the test coverage is insufficient (as noted in the security question), this does **not constitute a realistically exploitable vulnerability**. The economic and protocol constraints make the required conditions impossible to achieve in practice.

The test gaps identified (u64::MAX values, overflow scenarios) remain valid testing recommendations, but the absence of these tests does not indicate an exploitable security flaw - rather, they were likely omitted because such values cannot occur within Aptos tokenomics.

**Verdict: Code quality issue, not a security vulnerability per Aptos bug bounty criteria.**

### Citations

**File:** crates/aptos-rosetta/src/types/misc.rs (L453-465)
```rust
    } else if account_identifier.is_total_stake() {
        return Some(
            balances_result
                .iter()
                .map(|v| {
                    v.as_str()
                        .map(|s| s.to_owned())
                        .and_then(|s| s.parse::<u64>().ok())
                        .unwrap_or(0)
                })
                .sum::<u64>()
                .to_string(),
        );
```

**File:** aptos-move/framework/aptos-framework/sources/delegation_pool.move (L640-693)
```text
    public fun get_stake(
        pool_address: address,
        delegator_address: address
    ): (u64, u64, u64) acquires DelegationPool, BeneficiaryForOperator {
        assert_delegation_pool_exists(pool_address);
        let pool = borrow_global<DelegationPool>(pool_address);
        let (
            lockup_cycle_ended,
            active,
            _,
            commission_active,
            commission_pending_inactive
        ) = calculate_stake_pool_drift(pool);

        let total_active_shares = pool_u64::total_shares(&pool.active_shares);
        let delegator_active_shares = pool_u64::shares(&pool.active_shares, delegator_address);

        let (_, _, pending_active, _) = stake::get_stake(pool_address);
        if (pending_active == 0) {
            // zero `pending_active` stake indicates that either there are no `add_stake` fees or
            // previous epoch has ended and should identify shares owning these fees as released
            total_active_shares = total_active_shares - pool_u64::shares(&pool.active_shares, NULL_SHAREHOLDER);
            if (delegator_address == NULL_SHAREHOLDER) {
                delegator_active_shares = 0
            }
        };
        active = pool_u64::shares_to_amount_with_total_stats(
            &pool.active_shares,
            delegator_active_shares,
            // exclude operator active rewards not converted to shares yet
            active - commission_active,
            total_active_shares
        );

        // get state and stake (0 if there is none) of the pending withdrawal
        let (withdrawal_inactive, withdrawal_stake) = get_pending_withdrawal(pool_address, delegator_address);
        // report non-active stakes accordingly to the state of the pending withdrawal
        let (inactive, pending_inactive) = if (withdrawal_inactive) (withdrawal_stake, 0) else (0, withdrawal_stake);

        // should also include commission rewards in case of the operator account
        // operator rewards are actually used to buy shares which is introducing
        // some imprecision (received stake would be slightly less)
        // but adding rewards onto the existing stake is still a good approximation
        if (delegator_address == beneficiary_for_operator(get_operator(pool_address))) {
            active = active + commission_active;
            // in-flight pending_inactive commission can coexist with already inactive withdrawal
            if (lockup_cycle_ended) {
                inactive = inactive + commission_pending_inactive
            } else {
                pending_inactive = pending_inactive + commission_pending_inactive
            }
        };

        (active, inactive, pending_inactive)
```

**File:** Cargo.toml (L921-923)
```text
[profile.release]
debug = true
overflow-checks = true
```
