# Audit Report

## Title
Insufficient Validation of Self-Reported Distance Metrics Enables Peer Selection Manipulation

## Summary
Byzantine peers can falsely report `distance_from_validators` values of 2 or higher to gain preferential treatment in peer selection across consensus observer subscriptions, mempool transaction forwarding, and state sync operations. While distances 0 and 1 are properly validated against peer roles, distances ≥2 only undergo a bounds check, allowing malicious peers to misrepresent their network position. [1](#0-0) 

## Finding Description

The `NetworkInformationResponse` struct contains a `distance_from_validators` field that peers self-report to indicate their proximity to the validator set. This metric is critical for peer prioritization across three subsystems:

1. **Consensus Observer**: Prioritizes peers by distance for consensus subscription selection
2. **Mempool**: Uses distance as third-tier priority (after health and network ID) for transaction forwarding
3. **State Sync**: Groups peers by distance for optimistic fetch requests

The client-side validation logic has asymmetric rigor: [2](#0-1) 

**Validated Cases (distances 0 and 1)**:
- Distance 0 requires peer to be a validator on the correct network
- Distance 1 requires peer to be a VFN on the correct network

**Unvalidated Cases (distances ≥2)**:
- Only checks: `distance_from_validators <= MAX_DISTANCE_FROM_VALIDATORS` (100)
- No verification of peer role, network topology, or actual position
- No cross-validation against independent measurements

**Attack Scenario**:

A Byzantine PFN at actual distance 5 connects to honest nodes and reports distance 2. This false value:
1. Passes validation (2 ≤ 100)
2. Gets stored in peer metadata
3. Is used for peer prioritization in all three subsystems
4. **Cascades** when other nodes calculate their own distances [3](#0-2) 

The server-side distance calculation trusts previously-validated peer responses, taking the minimum reported distance + 1. If a Byzantine peer's false distance is the minimum among connected peers, it propagates to the querying node's own distance calculation.

**Exploitation in Mempool**: [4](#0-3) 

The intelligent peer prioritization ranks peers by: health → network ID → **validator distance** → ping latency. A malicious peer with false distance 2 is prioritized over honest peers at distances 3-5, becoming the primary destination for transaction broadcasts and enabling censorship.

**Exploitation in Consensus Observer**: [5](#0-4) 

The subscription logic explicitly prioritizes distance over latency to "avoid close but not up-to-date peers." A malicious publisher reporting low distance becomes the preferred consensus data source, allowing it to provide false or manipulated consensus information to observers.

## Impact Explanation

This vulnerability meets **High Severity** criteria per the Aptos bug bounty program:

**Why NOT Critical**:
- Does not break consensus safety among validators (AptosBFT remains secure)
- Does not enable direct fund theft or minting
- Does not cause non-recoverable network partition
- Validators continue proper BFT consensus execution

**Why High Severity**:
- **Transaction Censorship**: Malicious peer becomes primary mempool destination, enabling selective transaction suppression
- **Data Manipulation**: Consensus observers receive false data from malicious publishers
- **State Sync Poisoning**: Malicious peers serve false state data to syncing nodes
- **Network-Wide Propagation**: False distances cascade through network calculations affecting multiple nodes
- **Significant Protocol Violation**: Undermines the entire peer selection mechanism across critical subsystems

The attack affects network operations and data integrity without requiring validator compromise, meeting the "Significant protocol violations" criterion for High severity.

## Likelihood Explanation

**Likelihood: High**

- **Low Attacker Requirements**: Any network peer can exploit this (no validator access needed)
- **Simple Execution**: Only requires reporting a false integer value in response
- **No Detection**: No logging or alerting for suspicious distance values
- **Persistent Effect**: Once accepted, false distance remains in peer metadata until next refresh
- **Cascading Impact**: Single malicious peer affects multiple downstream nodes' calculations
- **Multiple Attack Surfaces**: Affects three critical subsystems simultaneously

## Recommendation

Implement multi-factor validation for all distance values:

```rust
// In peer-monitoring-service/client/src/peer_states/network_info.rs
// Enhanced validation logic:

let is_valid_depth = match network_info_response.distance_from_validators {
    0 => {
        // Existing validation for distance 0
        peer_is_validator && peer_has_correct_network
    },
    1 => {
        // Existing validation for distance 1  
        peer_is_vfn && peer_has_correct_network
    },
    distance_from_validators => {
        // NEW: Enhanced validation for distances >= 2
        
        // Check 1: Distance must be within bounds
        if distance_from_validators > MAX_DISTANCE_FROM_VALIDATORS {
            return false;
        }
        
        // Check 2: For public network peers, enforce minimum distance based on role
        if network_id.is_public_network() {
            // PFNs on public network should report distance >= 2
            let peer_role = peer_metadata.get_connection_metadata().role;
            if peer_role == PeerRole::Unknown || peer_role == PeerRole::Downstream {
                if distance_from_validators < 2 {
                    return false; // PFNs cannot be at distance 0 or 1
                }
            }
        }
        
        // Check 3: Verify distance is consistent with our own distance
        // A peer cannot report distance less than (our_distance - 1)
        if let Some(our_distance) = get_our_calculated_distance() {
            if distance_from_validators < our_distance.saturating_sub(1) {
                warn!("Peer reports impossible distance: {} vs our distance: {}", 
                      distance_from_validators, our_distance);
                return false;
            }
        }
        
        true
    },
};
```

Additional mitigations:
1. Track distance changes over time; alert on suspicious fluctuations
2. Cross-validate distances against multiple connected peers
3. Implement reputation scoring that penalizes peers with inconsistent reports
4. Add metrics/logging for distance validation failures

## Proof of Concept

```rust
// Exploitation scenario demonstrating the vulnerability

#[cfg(test)]
mod distance_manipulation_poc {
    use super::*;
    
    #[test]
    fn test_byzantine_peer_false_distance_accepted() {
        // Setup: Create a PFN (Public Full Node) that should be at distance 5
        let mut network_info_state = create_network_info_state(RoleType::FullNode);
        
        // Attack: Byzantine PFN connects on public network and reports distance 2
        let byzantine_peer = PeerNetworkId::new(NetworkId::Public, PeerId::random());
        let connection_metadata = ConnectionMetadata::new(
            byzantine_peer.peer_id(),
            ConnectionId::default(),
            NetworkAddress::from_str("/ip4/127.0.0.1/tcp/8080").unwrap(),
            ConnectionOrigin::Inbound,
            MessagingProtocolVersion::V1,
            ProtocolIdSet::empty(),
            PeerRole::Unknown, // PFN role (not VFN or Validator)
        );
        let peer_metadata = PeerMetadata::new(connection_metadata);
        
        // Malicious response with false distance
        let malicious_response = PeerMonitoringServiceResponse::NetworkInformation(
            NetworkInformationResponse {
                connected_peers: Default::default(),
                distance_from_validators: 2, // FALSE: actual distance is 5+
            }
        );
        
        // Process the malicious response
        network_info_state.handle_monitoring_service_response(
            &byzantine_peer,
            peer_metadata,
            PeerMonitoringServiceRequest::GetNetworkInformation,
            malicious_response,
            0.0,
        );
        
        // Verify: The false distance is ACCEPTED and stored
        let stored_response = network_info_state.get_latest_network_info_response();
        assert!(stored_response.is_some(), "Malicious response was rejected - this means validation is working");
        
        let response = stored_response.unwrap();
        assert_eq!(response.distance_from_validators, 2, 
            "False distance of 2 was accepted when actual distance should be 5+");
        
        // Impact: This false distance will now be used for peer prioritization
        // in mempool, consensus observer, and state sync, giving the Byzantine
        // peer preferential treatment over honest peers at correct distances 3-5.
    }
}
```

**Note**: While the security question specifically asks about distances 0 and 1, my investigation reveals these values ARE properly validated against peer roles. The actual vulnerability exists for distances ≥2, which lack equivalent validation and enable the same attack objectives (preferential peer selection and network manipulation).

### Citations

**File:** peer-monitoring-service/types/src/response.rs (L50-55)
```rust
/// A response for the network information request
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
pub struct NetworkInformationResponse {
    pub connected_peers: BTreeMap<PeerNetworkId, ConnectionMetadata>, // Connected peers
    pub distance_from_validators: u64, // The distance of the peer from the validator set
}
```

**File:** peer-monitoring-service/client/src/peer_states/network_info.rs (L118-141)
```rust
        let is_valid_depth = match network_info_response.distance_from_validators {
            0 => {
                // Verify the peer is a validator and has the correct network id
                let peer_is_validator = peer_metadata.get_connection_metadata().role.is_validator();
                let peer_has_correct_network = match self.base_config.role {
                    RoleType::Validator => network_id.is_validator_network(), // We're a validator
                    RoleType::FullNode => network_id.is_vfn_network(),        // We're a VFN
                };
                peer_is_validator && peer_has_correct_network
            },
            1 => {
                // Verify the peer is a VFN and has the correct network id
                let peer_is_vfn = peer_metadata.get_connection_metadata().role.is_vfn();
                let peer_has_correct_network = match self.base_config.role {
                    RoleType::Validator => network_id.is_vfn_network(), // We're a validator
                    RoleType::FullNode => network_id.is_public_network(), // We're a VFN or PFN
                };
                peer_is_vfn && peer_has_correct_network
            },
            distance_from_validators => {
                // The distance must be less than or equal to the max
                distance_from_validators <= MAX_DISTANCE_FROM_VALIDATORS
            },
        };
```

**File:** peer-monitoring-service/server/src/lib.rs (L322-339)
```rust
    let mut min_peer_distance_from_validators = MAX_DISTANCE_FROM_VALIDATORS;
    for peer_metadata in connected_peers_and_metadata.values() {
        if let Some(ref latest_network_info_response) = peer_metadata
            .get_peer_monitoring_metadata()
            .latest_network_info_response
        {
            min_peer_distance_from_validators = min(
                min_peer_distance_from_validators,
                latest_network_info_response.distance_from_validators,
            );
        }
    }

    // We're one hop away from the peer
    min(
        MAX_DISTANCE_FROM_VALIDATORS,
        min_peer_distance_from_validators + 1,
    )
```

**File:** mempool/src/shared_mempool/priority.rs (L103-109)
```rust
        // Otherwise, compare by peer distance from the validators.
        // This avoids badly configured/connected peers (e.g., broken VN-VFN connections).
        let distance_ordering =
            compare_validator_distance(monitoring_metadata_a, monitoring_metadata_b);
        if !distance_ordering.is_eq() {
            return distance_ordering; // Only return if it's not equal
        }
```

**File:** consensus/src/consensus_observer/observer/subscription_utils.rs (L283-312)
```rust
pub fn sort_peers_by_subscription_optimality(
    peers_and_metadata: &HashMap<PeerNetworkId, PeerMetadata>,
) -> Vec<PeerNetworkId> {
    // Group peers and latencies by validator distance, i.e., distance -> [(peer, latency)]
    let mut unsupported_peers = Vec::new();
    let mut peers_and_latencies_by_distance = BTreeMap::new();
    for (peer_network_id, peer_metadata) in peers_and_metadata {
        // Verify that the peer supports consensus observer
        if !supports_consensus_observer(peer_metadata) {
            unsupported_peers.push(*peer_network_id);
            continue; // Skip the peer
        }

        // Get the distance and latency for the peer
        let distance = get_distance_for_peer(peer_network_id, peer_metadata);
        let latency = get_latency_for_peer(peer_network_id, peer_metadata);

        // If the distance is not found, use the maximum distance
        let distance =
            distance.unwrap_or(aptos_peer_monitoring_service_types::MAX_DISTANCE_FROM_VALIDATORS);

        // If the latency is not found, use a large latency
        let latency = latency.unwrap_or(MAX_PING_LATENCY_SECS);

        // Add the peer and latency to the distance group
        peers_and_latencies_by_distance
            .entry(distance)
            .or_insert_with(Vec::new)
            .push((*peer_network_id, OrderedFloat(latency)));
    }
```
