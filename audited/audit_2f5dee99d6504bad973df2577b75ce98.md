# Audit Report

## Title
DbStateView Silent Verification Bypass Enables Unverified State Reads in Verified Mode

## Summary
`DbStateView` implements a contract violation in its `TStateView` interface where cryptographic verification of state reads is silently skipped when proof fetching fails, even when operating in "verified" mode. This allows unverified state to be consumed by the Move VM, potentially leading to consensus violations.

## Finding Description

The `DbStateView` struct provides verified and unverified modes for reading blockchain state. When created via `verified_state_view_at_version()`, it sets `maybe_verify_against_state_root_hash` to signal that all state reads MUST be cryptographically verified against a trusted Merkle root hash extracted from a signed `LedgerInfo`. [1](#0-0) 

The critical contract violation occurs in the `get()` method. When verification is enabled, the implementation attempts to fetch state with a Merkle proof, but silently ignores failures: [2](#0-1) 

The vulnerability manifests in the following sequence:

1. When `maybe_verify_against_state_root_hash` is `Some(root_hash)`, verification is supposedly required
2. The code attempts `get_state_value_with_proof_by_version()` wrapped in `if let Ok(...)`
3. **If proof fetch SUCCEEDS**: The proof is verified and errors propagate correctly
4. **If proof fetch FAILS** (returns `Err`): The error is **silently ignored** due to the `if let Ok` pattern
5. Execution continues to `get_state_value_with_version_by_version()` which returns the value **without any verification**
6. This unverified value is returned to the caller (VM) as if it were verified

The `get_state_value_with_version_by_version()` method performs no cryptographic verification: [3](#0-2) 

**Attack Scenarios:**

1. **Storage Layer Compromise**: An attacker who gains influence over the storage layer can cause `get_state_value_with_proof_by_version()` to fail (e.g., by corrupting proof indexes), forcing all verified reads to become unverified.

2. **Race Condition with Buffered State**: The TODO comments acknowledge that "DB doesn't support returning proofs for buffered state." If buffered state exists at the requested version, proof fetching fails and verification is skipped, potentially causing non-deterministic execution across validators. [4](#0-3) 

3. **Database Implementation Bugs**: Any bug in the proof-fetching path causes silent verification bypass.

**Invariants Violated:**

- **State Consistency**: "State transitions must be atomic and verifiable via Merkle proofs" - violated because proofs are optionally verified
- **Deterministic Execution**: "All validators must produce identical state roots for identical blocks" - at risk if some validators skip verification while others don't
- **Cryptographic Correctness**: The contract that verified views provide verified state is broken

## Impact Explanation

This qualifies as **HIGH severity** per Aptos bug bounty criteria as a "Significant protocol violation":

1. **Consensus Violation Risk**: If different validators experience different proof-fetch failures (e.g., due to storage timing differences, race conditions with buffering, or partial database corruption), they will read different state values. This breaks deterministic execution and can cause chain divergence.

2. **Silent Security Failures**: The VM and other consumers have no mechanism to detect that verification was skipped. They operate under the assumption that state is verified when it may not be.

3. **State Manipulation**: An attacker who can reliably cause proof fetch failures (e.g., through storage vulnerabilities or by exploiting the buffered state race condition) can inject arbitrary unverified state into VM execution.

The impact is elevated because the `verified_state_view_at_version` API is explicitly designed for security-critical operations where state integrity must be guaranteed against a trusted `LedgerInfo`. Users of this API include transaction validation and state verification operations. [5](#0-4) 

## Likelihood Explanation

**Medium-to-High Likelihood:**

1. **Acknowledged Issue**: The TODO comments indicate developers are aware that proof verification doesn't work for buffered state, but the security implications haven't been addressed.

2. **Buffered State Race**: The `BufferedState` system maintains recent checkpoints in memory before persistence. If `verified_state_view_at_version()` is called on a buffered version before proofs are available, verification will silently fail. [6](#0-5) 

3. **Storage Error Conditions**: Any transient storage errors, I/O failures, or database inconsistencies can trigger the silent bypass.

4. **No Defensive Checks**: The code has no safeguards against this scenario; it's designed to silently fall back to unverified reads.

## Recommendation

**Fix: Make verification failures explicit and propagate errors**

The correct implementation should fail the entire read operation if verification is required but cannot be performed:

```rust
fn get(&self, key: &StateKey) -> StateViewResult<Option<(Version, StateValue)>> {
    if let Some(version) = self.version {
        if let Some(root_hash) = self.maybe_verify_against_state_root_hash {
            // Verification is REQUIRED - any failure must propagate
            let (value, proof) = self.db
                .get_state_value_with_proof_by_version(key, version)?;  // Propagate error!
            proof.verify(root_hash, *key.crypto_hash_ref(), value.as_ref())?;
            return Ok(value.map(|v| (version, v)));
        }
        // No verification requested - use fast path
        Ok(self.db.get_state_value_with_version_by_version(key, version)?)
    } else {
        Ok(None)
    }
}
```

**Alternative: Remove the verified mode if it cannot be supported**

If proofs genuinely cannot be provided for buffered state, then `verified_state_view_at_version()` should either:
1. Ensure the version is fully persisted before allowing verification, or
2. Return an error if verification is requested for a version that cannot be verified

The current silent fallback violates the security contract and creates undefined behavior.

## Proof of Concept

```rust
// Rust test demonstrating the vulnerability
#[cfg(test)]
mod tests {
    use super::*;
    use aptos_types::state_store::state_key::StateKey;
    use std::sync::Arc;

    struct FailingDbReader;
    
    impl DbReader for FailingDbReader {
        fn get_state_value_with_proof_by_version(
            &self,
            _key: &StateKey,
            _version: Version,
        ) -> Result<(Option<StateValue>, SparseMerkleProof)> {
            // Simulate proof fetch failure (e.g., buffered state, DB error)
            Err(anyhow::anyhow!("Proofs not available for buffered state"))
        }
        
        fn get_state_value_with_version_by_version(
            &self,
            _key: &StateKey,
            _version: Version,
        ) -> Result<Option<(Version, StateValue)>> {
            // Returns UNVERIFIED malicious state
            Ok(Some((
                0,
                StateValue::new_legacy(b"MALICIOUS_UNVERIFIED_DATA".to_vec().into())
            )))
        }
    }

    #[test]
    fn test_verification_bypass() {
        let db = Arc::new(FailingDbReader);
        let root_hash = HashValue::random(); // Trusted root hash
        
        // Create a "verified" state view
        let state_view = DbStateView {
            db,
            version: Some(0),
            maybe_verify_against_state_root_hash: Some(root_hash), // Verification REQUIRED
        };
        
        let key = StateKey::raw(b"test_key");
        
        // This should fail because verification is required but proofs aren't available
        // Instead, it returns UNVERIFIED data!
        let result = state_view.get(&key).unwrap();
        
        assert!(result.is_some()); // Unverified data was returned!
        // The VM will now execute with this unverified, potentially malicious state
    }
}
```

**Notes**

The vulnerability is particularly concerning because:

1. The `TStateView` trait contract implicitly guarantees that verified views provide verified data, but `DbStateView` violates this contract
2. The TODO comments suggest this is a known limitation ("DB doesn't support returning proofs for buffered state"), but it's treated as a performance optimization rather than a security violation
3. Consumers like the Move VM have no way to detect when verification was skipped
4. The silent fallback behavior means bugs in the proof-fetching path or storage layer issues will not be detected, they'll just disable security

The fix is straightforward: if verification is required (`maybe_verify_against_state_root_hash.is_some()`), then proof fetch failures MUST be treated as errors, not silently ignored.

### Citations

**File:** storage/storage-interface/src/state_store/state_view/db_state_view.rs (L21-46)
```rust
    /// DB doesn't support returning proofs for buffered state, so only optionally verify proof.
    /// TODO: support returning state proof for buffered state.
    maybe_verify_against_state_root_hash: Option<HashValue>,
}

impl DbStateView {
    fn get(&self, key: &StateKey) -> StateViewResult<Option<(Version, StateValue)>> {
        if let Some(version) = self.version {
            if let Some(root_hash) = self.maybe_verify_against_state_root_hash {
                // TODO(aldenhu): sample-verify proof inside DB
                // DB doesn't support returning proofs for buffered state, so only optionally
                // verify proof.
                // TODO: support returning state proof for buffered state.
                if let Ok((value, proof)) =
                    self.db.get_state_value_with_proof_by_version(key, version)
                {
                    proof.verify(root_hash, *key.crypto_hash_ref(), value.as_ref())?;
                }
            }
            Ok(self
                .db
                .get_state_value_with_version_by_version(key, version)?)
        } else {
            Ok(None)
        }
    }
```

**File:** storage/storage-interface/src/state_store/state_view/db_state_view.rs (L115-138)
```rust
impl VerifiedStateViewAtVersion for Arc<dyn DbReader> {
    fn verified_state_view_at_version(
        &self,
        version: Option<Version>,
        ledger_info: &LedgerInfo,
    ) -> StateViewResult<DbStateView> {
        let db = self.clone();

        if let Some(version) = version {
            let txn_with_proof =
                db.get_transaction_by_version(version, ledger_info.version(), false)?;
            txn_with_proof.verify(ledger_info)?;

            let state_root_hash = txn_with_proof
                .proof
                .transaction_info
                .state_checkpoint_hash()
                .ok_or_else(|| StateViewError::NotFound("state_checkpoint_hash".to_string()))?;

            Ok(DbStateView {
                db,
                version: Some(version),
                maybe_verify_against_state_root_hash: Some(state_root_hash),
            })
```

**File:** storage/aptosdb/src/state_kv_db.rs (L374-402)
```rust
    pub(crate) fn get_state_value_with_version_by_version(
        &self,
        state_key: &StateKey,
        version: Version,
    ) -> Result<Option<(Version, StateValue)>> {
        let mut read_opts = ReadOptions::default();

        // We want `None` if the state_key changes in iteration.
        read_opts.set_prefix_same_as_start(true);
        if !self.enabled_sharding() {
            let mut iter = self
                .db_shard(state_key.get_shard_id())
                .iter_with_opts::<StateValueSchema>(read_opts)?;
            iter.seek(&(state_key.clone(), version))?;
            Ok(iter
                .next()
                .transpose()?
                .and_then(|((_, version), value_opt)| value_opt.map(|value| (version, value))))
        } else {
            let mut iter = self
                .db_shard(state_key.get_shard_id())
                .iter_with_opts::<StateValueByKeyHashSchema>(read_opts)?;
            iter.seek(&(state_key.hash(), version))?;
            Ok(iter
                .next()
                .transpose()?
                .and_then(|((_, version), value_opt)| value_opt.map(|value| (version, value))))
        }
    }
```

**File:** execution/executor-test-helpers/src/integration_test_impl.rs (L266-281)
```rust
    let view = db
        .reader
        .verified_state_view_at_version(Some(current_version), latest_li)
        .unwrap();
    verify_account_balance(get_account_balance(&view, &addr1), |x| {
        approx_eq(x, 1_910 * B)
    })
    .unwrap();
    verify_account_balance(get_account_balance(&view, &addr2), |x| {
        approx_eq(x, 1_210 * B)
    })
    .unwrap();
    verify_account_balance(get_account_balance(&view, &addr3), |x| {
        approx_eq(x, 1_080 * B)
    })
    .unwrap();
```

**File:** storage/aptosdb/src/state_store/buffered_state.rs (L31-46)
```rust
/// BufferedState manages a range of recent state checkpoints and asynchronously commits
/// the updates in batches.
#[derive(Debug)]
pub struct BufferedState {
    /// the current state and the last checkpoint. shared with outside world.
    current_state: Arc<Mutex<LedgerStateWithSummary>>,
    /// The most recent checkpoint sent for persistence, not guaranteed to have committed already.
    last_snapshot: StateWithSummary,
    /// channel to send a checkpoint for persistence asynchronously
    state_commit_sender: SyncSender<CommitMessage<StateWithSummary>>,
    /// Estimated number of items in the buffer.
    estimated_items: usize,
    /// The target number of items in the buffer between commits.
    target_items: usize,
    join_handle: Option<JoinHandle<()>>,
}
```
