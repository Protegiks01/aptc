# Audit Report

## Title
Single OIDC Provider Dependency Creates Critical Single Point of Failure for All Keyless Accounts

## Summary
The default JWK consensus configuration only includes Google as an OIDC provider, creating a catastrophic single point of failure. If Google's signing infrastructure is compromised, attackers can forge valid JWTs for any Google user, obtain peppers from the pepper service, and drain all funds from all Google-based keyless accounts on Aptos. [1](#0-0) 

## Finding Description

The keyless account system relies on OIDC providers (like Google) to sign JWTs that authenticate users. The system has three critical trust points:

1. **JWK Consensus Configuration**: Validators fetch and agree on public keys from configured OIDC providers
2. **Pepper Service Authentication**: The pepper service verifies JWT signatures before issuing peppers
3. **Transaction Validation**: Validators verify JWT signatures when processing keyless transactions

All three points trust the same JWK from Google. The attack flow works as follows:

**Step 1: Attacker obtains compromised Google signing key** (via supply chain attack, infrastructure breach, etc.)

**Step 2: Attacker forges JWT for target victim**
- Craft JWT with victim's identity (e.g., `sub: "alice@gmail.com"`, `iss: "https://accounts.google.com"`)
- Sign with compromised Google private key
- JWT passes all cryptographic verification checks

**Step 3: Attacker obtains pepper from pepper service** [2](#0-1) 

The pepper service verifies the JWT signature using Google's public key fetched from the JWK cache. Since the attacker used the real (compromised) Google key, verification succeeds and the pepper service returns the deterministic pepper for that identity.

**Step 4: Attacker submits transaction to drain victim's account** [3](#0-2) 

Validators fetch the JWK from on-chain storage (which contains Google's public key) and verify the forged JWT. The signature verifies successfully, allowing the attacker to execute transactions as the victim. [4](#0-3) 

The fundamental issue is that **all security depends on Google never being compromised**. The identity commitment is computed as: [5](#0-4) 

While the pepper provides hiding, an attacker with a compromised Google key can:
1. Request peppers for any Google user by presenting valid (forged) JWTs
2. Compute the same identity commitment
3. Access any keyless account tied to Google authentication

This breaks the **Access Control** invariant: "System addresses (@aptos_framework, @core_resources) must be protected" - extended to user accounts, no unauthorized party should access accounts.

## Impact Explanation

**Critical Severity** - Loss of Funds (theft):
- **Scope**: ALL keyless accounts using Google as OIDC provider (potentially millions of users)
- **Damage**: Complete loss of all funds in affected accounts
- **Recoverability**: Requires hard fork to invalidate compromised provider and migrate accounts
- **Blast Radius**: Since Google is the ONLY default provider, this affects the entire keyless account user base

This meets the Critical severity criteria: "Loss of Funds (theft or minting)" with maximum possible impact.

## Likelihood Explanation

**Likelihood: Medium to High**

While Google has strong security practices, compromise scenarios are realistic:
- **Supply chain attacks**: Compromised dependencies in Google's signing infrastructure
- **Insider threats**: Malicious or compromised Google employees with key access
- **Software vulnerabilities**: 0-day exploits in Google's OIDC implementation
- **Infrastructure breaches**: Advanced persistent threats targeting Google's key management systems

Historical precedents:
- Microsoft signing key compromise (2023)
- SolarWinds supply chain attack (2020)
- DigiNotar certificate authority breach (2011)

The single-provider design means **ANY** compromise of Google instantly compromises ALL Aptos keyless accounts, with no defense-in-depth or redundancy.

## Recommendation

**Immediate Fix**: Add multiple OIDC providers to the default configuration to eliminate single point of failure:

```rust
pub fn default_enabled() -> Self {
    Self::V1(ConfigV1 {
        oidc_providers: vec![
            OIDCProvider {
                name: "https://accounts.google.com".to_string(),
                config_url: "https://accounts.google.com/.well-known/openid-configuration".to_string(),
            },
            OIDCProvider {
                name: "https://appleid.apple.com".to_string(),
                config_url: "https://appleid.apple.com/.well-known/openid-configuration".to_string(),
            },
            OIDCProvider {
                name: "https://login.microsoftonline.com/common/v2.0".to_string(),
                config_url: "https://login.microsoftonline.com/common/v2.0/.well-known/openid-configuration".to_string(),
            },
        ],
    })
}
```

**Long-term Solutions**:
1. **Provider diversity**: Support 5+ major OIDC providers by default
2. **Threshold signatures**: Require multi-provider attestation for high-value accounts
3. **Monitoring**: Implement anomaly detection for unusual JWT patterns
4. **Emergency response**: Pre-planned procedures for provider compromise (provider revocation, account migration)
5. **User education**: Warning about single-provider risk, encourage multi-factor setups

## Proof of Concept

```rust
// Simulated attack demonstrating the vulnerability
// This would be implemented as a Rust integration test

#[test]
fn test_google_key_compromise_attack() {
    // Setup: Keyless account for alice@gmail.com exists with balance
    let victim_identity = "alice@gmail.com";
    let victim_account = create_keyless_account(
        "https://accounts.google.com",  // issuer
        victim_identity,
        "sub",
    );
    fund_account(victim_account, 1_000_000); // Fund with 1M APT
    
    // Step 1: Attacker obtains compromised Google private key
    let compromised_google_key = obtain_compromised_key(); // Simulated
    
    // Step 2: Attacker forges JWT for victim
    let forged_jwt = create_jwt(
        issuer: "https://accounts.google.com",
        sub: victim_identity,
        aud: "test-client-id",
        nonce: compute_nonce(epk, exp_time, blinder),
    );
    let signed_jwt = sign_jwt(forged_jwt, compromised_google_key);
    
    // Step 3: Attacker obtains pepper from pepper service
    let pepper_response = pepper_service.get_pepper(
        jwt: signed_jwt,
        ephemeral_pubkey: attacker_epk,
        exp_date_secs: exp_time,
        epk_blinder: blinder,
    );
    assert!(pepper_response.is_ok()); // Service accepts forged JWT!
    
    // Step 4: Attacker computes victim's address
    let victim_address = compute_keyless_address(
        pepper: pepper_response.pepper,
        aud: "test-client-id",
        uid_key: "sub",
        uid_val: victim_identity,
    );
    assert_eq!(victim_address, victim_account); // Matches!
    
    // Step 5: Attacker drains account
    let steal_txn = create_transfer(
        from: victim_account,
        to: attacker_account,
        amount: 1_000_000,
        signature: create_keyless_signature(signed_jwt, attacker_epk),
    );
    
    let result = submit_transaction(steal_txn);
    assert!(result.is_ok()); // Transaction succeeds!
    assert_eq!(get_balance(attacker_account), 1_000_000);
    assert_eq!(get_balance(victim_account), 0);
}
```

## Notes

This vulnerability represents an architectural flaw in the default configuration, not a bug in the implementation. The code correctly implements the intended design, but the design itself creates an unacceptable single point of failure. While Google compromise requires an external event, supply chain attacks on major infrastructure providers are a realistic threat model that the blockchain design must account for. The fix is straightforward: diversify the default OIDC provider set to eliminate concentrated risk.

### Citations

**File:** types/src/on_chain_config/jwk_consensus_config.rs (L43-51)
```rust
    pub fn default_enabled() -> Self {
        Self::V1(ConfigV1 {
            oidc_providers: vec![OIDCProvider {
                name: "https://accounts.google.com".to_string(),
                config_url: "https://accounts.google.com/.well-known/openid-configuration"
                    .to_string(),
            }],
        })
    }
```

**File:** keyless/pepper/service/src/dedicated_handlers/pepper_request.rs (L351-397)
```rust
async fn verify_jwt_signature(
    jwk_cache: JWKCache,
    federated_jwks: FederatedJWKs<FederatedJWKIssuer>,
    jwt: &str,
    claims: &TokenData<Claims>,
) -> Result<(), PepperServiceError> {
    // Get the key ID from the JWT header
    let key_id = claims
        .header
        .kid
        .clone()
        .ok_or_else(|| PepperServiceError::BadRequest("Missing kid in JWT".to_string()))?;

    // Get the JWK from the cache, or fetch the federated JWK if not found
    let rsa_jwk = match jwk_fetcher::get_cached_jwk_as_rsa(&claims.claims.iss, &key_id, jwk_cache) {
        Ok(rsa_jwk) => rsa_jwk,
        Err(error) => {
            info!("Failed to get cached JWK for issuer {} and key ID {}: {}. Attempting to fetch federated JWK.", &claims.claims.iss, &key_id, error);
            jwk_fetcher::get_federated_jwk(jwt, federated_jwks)
                .await
                .map_err(|error| {
                    PepperServiceError::BadRequest(format!(
                        "Failed to fetch federated JWK: {}. JWT: {}",
                        error, jwt
                    ))
                })?
        },
    };
    let jwk_decoding_key =
        DecodingKey::from_rsa_components(&rsa_jwk.n, &rsa_jwk.e).map_err(|error| {
            PepperServiceError::BadRequest(format!(
                "Failed to create decoding key from JWK: {}",
                error
            ))
        })?;

    // Validate the JWT signature.
    // TODO: can we avoid decoding the JWT twice?
    let mut validation_with_sig_verification = Validation::new(RS256);
    validation_with_sig_verification.validate_exp = false; // Don't validate the exp time
    jsonwebtoken::decode::<Claims>(jwt, &jwk_decoding_key, &validation_with_sig_verification) // Signature verification happens here
        .map_err(|e| {
            PepperServiceError::BadRequest(format!("JWT signature verification failed: {e}"))
        })?;

    Ok(())
}
```

**File:** aptos-move/aptos-vm/src/keyless_validation.rs (L220-270)
```rust
    let patched_jwks = get_jwks_onchain(resolver)?;

    let training_wheels_pk = match &config.training_wheels_pubkey {
        None => None,
        // This takes ~4.4 microseconds, so we are not too concerned about speed here.
        // (Run `cargo bench -- ed25519/pk_deserialize` in `crates/aptos-crypto`.)
        Some(bytes) => Some(EphemeralPublicKey::ed25519(
            Ed25519PublicKey::try_from(bytes.as_slice()).map_err(|_| {
                // println!("[aptos-vm][groth16] On chain TW PK is invalid");

                invalid_signature!("The training wheels PK set on chain is not a valid PK")
            })?,
        )),
    };

    for (pk, sig) in authenticators {
        // Try looking up the jwk in 0x1.
        let jwk = match get_jwk_for_authenticator(&patched_jwks.jwks, pk.inner_keyless_pk(), sig) {
            // 1: If found in 0x1, then we consider that the ground truth & we are done.
            Ok(jwk) => jwk,
            // 2: If not found in 0x1, we check the Keyless PK type.
            Err(e) => {
                match pk {
                    // 2.a: If this is a federated keyless account; look in `jwk_addr` for JWKs
                    AnyKeylessPublicKey::Federated(fed_pk) => {
                        let federated_jwks =
                            get_federated_jwks_onchain(resolver, &fed_pk.jwk_addr, module_storage)
                                .map_err(|_| {
                                    invalid_signature!(format!(
                                        "Could not fetch federated PatchedJWKs at {}",
                                        fed_pk.jwk_addr
                                    ))
                                })?;
                        // 2.a.i If not found in jwk_addr either, then we fail the validation.
                        get_jwk_for_authenticator(&federated_jwks.jwks, pk.inner_keyless_pk(), sig)?
                    },
                    // 2.b: If this is not a federated keyless account, then we fail the validation.
                    AnyKeylessPublicKey::Normal(_) => return Err(e),
                }
            },
        };
        verify_keyless_signature_without_ephemeral_signature_check(
            pk,
            sig,
            &jwk,
            onchain_timestamp_obj.microseconds,
            &training_wheels_pk,
            config,
            pvk,
        )?;
    }
```

**File:** types/src/keyless/openid_sig.rs (L126-139)
```rust
    pub fn verify_jwt_signature(
        &self,
        rsa_jwk: &RSA_JWK,
        jwt_header_json: &str,
    ) -> anyhow::Result<()> {
        let jwt_b64 = format!(
            "{}.{}.{}",
            base64url_encode_str(jwt_header_json),
            base64url_encode_str(&self.jwt_payload_json),
            base64url_encode_bytes(&self.jwt_sig)
        );
        rsa_jwk.verify_signature_without_exp_check(&jwt_b64)?;
        Ok(())
    }
```

**File:** types/src/keyless/mod.rs (L307-335)
```rust
    pub fn new_from_preimage(
        pepper: &Pepper,
        aud: &str,
        uid_key: &str,
        uid_val: &str,
    ) -> anyhow::Result<Self> {
        let aud_val_hash =
            poseidon_bn254::keyless::pad_and_hash_string(aud, Self::MAX_AUD_VAL_BYTES)?;
        // println!("aud_val_hash: {}", aud_val_hash);
        let uid_key_hash =
            poseidon_bn254::keyless::pad_and_hash_string(uid_key, Self::MAX_UID_KEY_BYTES)?;
        // println!("uid_key_hash: {}", uid_key_hash);
        let uid_val_hash =
            poseidon_bn254::keyless::pad_and_hash_string(uid_val, Self::MAX_UID_VAL_BYTES)?;
        // println!("uid_val_hash: {}", uid_val_hash);
        let pepper_scalar = poseidon_bn254::keyless::pack_bytes_to_one_scalar(pepper.0.as_slice())?;
        // println!("Pepper Fr: {}", pepper_scalar);

        let fr = poseidon_bn254::hash_scalars(vec![
            pepper_scalar,
            aud_val_hash,
            uid_val_hash,
            uid_key_hash,
        ])?;

        let mut idc_bytes = vec![0u8; IdCommitment::NUM_BYTES];
        fr.serialize_uncompressed(&mut idc_bytes[..])?;
        Ok(IdCommitment(idc_bytes))
    }
```
