# Audit Report

## Title
Incorrect Peer Penalty for Connection Errors in State Sync Data Client

## Summary
The `send_request_to_peer()` function incorrectly applies `ErrorType::NotUseful` penalty to ALL error types, including connection-level errors like `RpcError::NotConnected` and `RpcError::IoError`. This causes honest peers with temporary connectivity issues to be incorrectly penalized, potentially leading to their exclusion from the peer selection pool when their score drops below the ignore threshold. [1](#0-0) 

## Finding Description
The state sync data client maintains peer scores to select reliable peers for data synchronization. When an RPC request fails, the system categorizes errors and applies scoring penalties accordingly. However, the current implementation has a critical flaw in error classification.

**The Bug:** At line 865, ALL errors result in `ErrorType::NotUseful` penalty, which multiplies the peer's score by 0.95 (reducing it by 5% per error). This includes connection-level errors that are NOT the peer's fault: [2](#0-1) 

The RPC error types that trigger this incorrect penalty include:
- `RpcError::NotConnected(PeerId)` - Peer is disconnected (network issue)
- `RpcError::IoError(io::Error)` - IO/network errors
- `RpcError::MpscSendError` - Connection shutting down
- Other transient connection issues [3](#0-2) 

**Scoring Mechanism:** The peer scoring system defines two penalty levels: [4](#0-3) 

When a peer's score drops to or below 25.0 (and `ignore_low_score_peers` is enabled, which is the default), the peer is excluded from data requests: [5](#0-4) [6](#0-5) 

**Exploitation Path:**
1. A node experiences network instability or an attacker disrupts connections to honest peers
2. Each connection failure applies a 5% score penalty (score × 0.95)
3. Starting from the default score of 50.0, approximately 14 connection errors are sufficient to drop the score below the ignore threshold: `50.0 × (0.95)^14 ≈ 24.3`
4. The honest peer is now excluded from all data requests, even though it never provided bad data
5. The node is forced to rely on remaining peers, which may include malicious actors or have limited data availability

## Impact Explanation
This vulnerability falls under **Medium Severity** based on the Aptos bug bounty criteria for the following reasons:

**State Synchronization Degradation:**
- Honest peers with temporary connectivity issues are incorrectly excluded from the peer selection pool
- This reduces peer diversity and can force nodes to sync from less reliable or potentially malicious peers
- During periods of network instability, many honest peers could be simultaneously penalized, severely limiting sync options

**Availability Impact:**
- In extreme scenarios where most honest peers are incorrectly ignored due to connection issues, a node may experience:
  - Significant sync delays (forced to use few remaining peers)
  - Increased vulnerability to malicious peer data (reduced peer diversity for verification)
  - Potential sync failures if no suitable peers remain available

**Not Network DoS:** While network-level DoS is out of scope, this is a logic bug in the peer scoring system that has availability implications. The bug exists regardless of whether connection failures are natural or attacker-induced.

## Likelihood Explanation
**High Likelihood** - This issue will occur naturally in production environments:

1. **Common in Distributed Systems:** Connection errors are routine in peer-to-peer networks due to:
   - Network instability and packet loss
   - Peer churn (nodes joining/leaving)
   - NAT traversal issues
   - Temporary routing problems

2. **Accumulative Effect:** Since penalties accumulate over time, even infrequent connection issues can eventually push honest peers below the ignore threshold

3. **Default Configuration:** The `ignore_low_score_peers` flag is enabled by default, meaning this bug affects all nodes using default settings

4. **No Differentiation:** The code makes no attempt to distinguish between connection-level errors (not peer's fault) and data-quality errors (peer's fault)

## Recommendation

Modify the error handling logic to distinguish between connection-level errors and data-quality errors. Connection errors should NOT penalize the peer's score:

```rust
// In send_request_to_peer() function, around line 830-868
Err(error) => {
    let (client_error, should_penalize_peer) = match error {
        aptos_storage_service_client::Error::RpcError(rpc_error) => match rpc_error {
            // Connection-level errors: Don't penalize peer
            RpcError::NotConnected(_) => {
                (Error::DataIsUnavailable(rpc_error.to_string()), false)
            },
            RpcError::IoError(_) => {
                (Error::DataIsUnavailable(rpc_error.to_string()), false)
            },
            RpcError::MpscSendError(_) => {
                (Error::DataIsUnavailable(rpc_error.to_string()), false)
            },
            RpcError::UnexpectedResponseChannelCancel => {
                (Error::DataIsUnavailable(rpc_error.to_string()), false)
            },
            // Timeout: Might be peer's fault (slow response)
            RpcError::TimedOut => {
                (Error::TimeoutWaitingForResponse(rpc_error.to_string()), true)
            },
            // Data-quality errors: Penalize peer
            RpcError::InvalidRpcResponse => {
                (Error::UnexpectedErrorEncountered(rpc_error.to_string()), true)
            },
            RpcError::ApplicationError(_) => {
                (Error::UnexpectedErrorEncountered(rpc_error.to_string()), true)
            },
            // Other errors: Penalize peer to be safe
            _ => (Error::UnexpectedErrorEncountered(rpc_error.to_string()), true),
        },
        aptos_storage_service_client::Error::StorageServiceError(err) => {
            (Error::UnexpectedErrorEncountered(err.to_string()), true)
        },
        _ => (Error::UnexpectedErrorEncountered(error.to_string()), true),
    };

    warn!(...);
    increment_request_counter(...);

    // Only penalize peer if the error is their fault
    if should_penalize_peer {
        self.notify_bad_response(id, peer, &request, ErrorType::NotUseful);
    }
    
    Err(client_error)
}
```

## Proof of Concept

```rust
#[cfg(test)]
mod test {
    use super::*;
    use aptos_config::config::AptosDataClientConfig;
    use std::sync::Arc;

    #[test]
    fn test_connection_errors_incorrectly_penalize_peers() {
        // Create peer states with default config
        let config = Arc::new(AptosDataClientConfig::default());
        let peer_states = PeerStates::new(config.clone());
        
        // Create a test peer
        let peer = PeerNetworkId::random();
        
        // Initialize peer with storage summary so it's tracked
        let storage_summary = StorageServerSummary::default();
        peer_states.update_summary(peer, storage_summary);
        
        // Get initial score (should be STARTING_SCORE = 50.0)
        let initial_score = peer_states
            .get_peer_to_states()
            .get(&peer)
            .unwrap()
            .get_score();
        assert_eq!(initial_score, 50.0);
        
        // Simulate 14 connection errors (NotConnected)
        // Each error applies ErrorType::NotUseful penalty (× 0.95)
        for _ in 0..14 {
            peer_states.update_score_error(peer, ErrorType::NotUseful);
        }
        
        // Check final score
        let final_score = peer_states
            .get_peer_to_states()
            .get(&peer)
            .unwrap()
            .get_score();
        
        // Expected: 50.0 × (0.95)^14 ≈ 24.3
        // Peer is now below IGNORE_PEER_THRESHOLD (25.0)
        assert!(final_score < 25.0);
        
        // Verify peer is now ignored
        let peer_state = peer_states.get_peer_to_states().get(&peer).unwrap();
        assert!(peer_state.get_storage_summary_if_not_ignored().is_none());
        
        println!(
            "BUG CONFIRMED: Peer incorrectly ignored after {} connection errors. \
             Score dropped from {} to {} (threshold: {})",
            14, initial_score, final_score, 25.0
        );
    }
}
```

**Expected Output:** The test demonstrates that 14 connection errors (which are NOT the peer's fault) are sufficient to push a peer below the ignore threshold, causing it to be excluded from all future requests despite never providing bad data.

## Notes

This vulnerability specifically affects the state synchronization layer's peer selection logic. While the impact is not as severe as consensus or funds-related vulnerabilities, it degrades the reliability and availability of state sync operations, which are critical for node operation and network health. The fix is straightforward: distinguish between network-level connectivity issues (not peer's fault) and data-quality issues (peer's fault) when applying scoring penalties.

### Citations

**File:** state-sync/aptos-data-client/src/client.rs (L830-868)
```rust
            Err(error) => {
                // Convert network error and storage service error types into
                // data client errors. Also categorize the error type for scoring
                // purposes.
                let client_error = match error {
                    aptos_storage_service_client::Error::RpcError(rpc_error) => match rpc_error {
                        RpcError::NotConnected(_) => {
                            Error::DataIsUnavailable(rpc_error.to_string())
                        },
                        RpcError::TimedOut => {
                            Error::TimeoutWaitingForResponse(rpc_error.to_string())
                        },
                        _ => Error::UnexpectedErrorEncountered(rpc_error.to_string()),
                    },
                    aptos_storage_service_client::Error::StorageServiceError(err) => {
                        Error::UnexpectedErrorEncountered(err.to_string())
                    },
                    _ => Error::UnexpectedErrorEncountered(error.to_string()),
                };

                warn!(
                    (LogSchema::new(LogEntry::StorageServiceResponse)
                        .event(LogEvent::ResponseError)
                        .request_type(&request.get_label())
                        .request_id(id)
                        .peer(&peer)
                        .error(&client_error))
                );

                increment_request_counter(
                    &metrics::ERROR_RESPONSES,
                    client_error.get_label(),
                    peer,
                );

                self.notify_bad_response(id, peer, &request, ErrorType::NotUseful);
                Err(client_error)
            },
        }
```

**File:** network/framework/src/protocols/rpc/error.rs (L14-44)
```rust
pub enum RpcError {
    #[error("Error: {0:?}")]
    Error(#[from] anyhow::Error),

    #[error("IO error: {0}")]
    IoError(#[from] io::Error),

    #[error("Bcs error: {0:?}")]
    BcsError(#[from] bcs::Error),

    #[error("Not connected with peer: {0}")]
    NotConnected(PeerId),

    #[error("Received invalid rpc response message")]
    InvalidRpcResponse,

    #[error("Application layer unexpectedly dropped response channel")]
    UnexpectedResponseChannelCancel,

    #[error("Error in application layer handling rpc request: {0:?}")]
    ApplicationError(anyhow::Error),

    #[error("Error sending on mpsc channel, connection likely shutting down: {0:?}")]
    MpscSendError(#[from] mpsc::SendError),

    #[error("Too many pending RPCs: {0}")]
    TooManyPending(u32),

    #[error("Rpc timed out")]
    TimedOut,
}
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L32-52)
```rust
/// Scores for peer rankings based on preferences and behavior.
const MAX_SCORE: f64 = 100.0;
const MIN_SCORE: f64 = 0.0;
const STARTING_SCORE: f64 = 50.0;
/// Add this score on a successful response.
const SUCCESSFUL_RESPONSE_DELTA: f64 = 1.0;
/// Not necessarily a malicious response, but not super useful.
const NOT_USEFUL_MULTIPLIER: f64 = 0.95;
/// Likely to be a malicious response.
const MALICIOUS_MULTIPLIER: f64 = 0.8;
/// Ignore a peer when their score dips below this threshold.
const IGNORE_PEER_THRESHOLD: f64 = 25.0;

pub enum ErrorType {
    /// A response or error that's not actively malicious but also doesn't help
    /// us make progress, e.g., timeouts, remote errors, invalid data, etc...
    NotUseful,
    /// A response or error that appears to be actively hindering progress or
    /// attempting to deceive us, e.g., invalid proof.
    Malicious,
}
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L152-160)
```rust
    fn is_ignored(&self) -> bool {
        // Only ignore peers if the config allows it
        if !self.data_client_config.ignore_low_score_peers {
            return false;
        }

        // Otherwise, ignore peers with a low score
        self.score <= IGNORE_PEER_THRESHOLD
    }
```

**File:** config/src/config/state_sync_config.rs (L466-466)
```rust
            ignore_low_score_peers: true,
```
