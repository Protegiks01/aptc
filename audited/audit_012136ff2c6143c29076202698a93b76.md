# Audit Report

## Title
Missing Size Limits on ProviderJWKs Enables Validator DoS via Resource Exhaustion

## Summary
The JWK consensus system lacks size validation on `ProviderJWKs` payloads in validator transactions, allowing excessively large JWK sets to be proposed and processed without bounds. Combined with unmetered gas execution, this enables resource exhaustion attacks against all validators in the network.

## Finding Description

The `process_jwk_update_inner()` function processes JWK updates without validating the size of the `ProviderJWKs` payload. The vulnerability manifests through multiple missing checks:

**1. No size check when adding to validator transaction pool:** [1](#0-0) 

The `process_quorum_certified_update` function creates a `ValidatorTransaction::ObservedJWKUpdate` and adds it to the pool without size validation.

**2. No per-transaction size limit in validator transaction pool:** [2](#0-1) 

The `put()` method accepts transactions of any size without validation.

**3. No size validation in Move processing:** [3](#0-2) 

The `upsert_into_observed_jwks` function processes JWK updates without checking payload size.

**4. Execution with unmetered gas:** [4](#0-3) 

The VM executes with `UnmeteredGasMeter`, removing computational cost limits.

**5. No field size limits on RSA_JWK:** [5](#0-4) 

All string fields (`kid`, `kty`, `alg`, `e`, `n`) are unbounded `String` types.

**Attack Path:**
A supported OIDC provider (either compromised or maliciously added through governance) serves an extremely large JWK set containing:
- Hundreds of JWK entries (no count limit)
- Each with large string fields (e.g., 10KB kid, 10KB n fields)

All validators observe this via `JWKObserver`, propose it, and reach quorum. The resulting 1-2MB transaction gets included in a block. All validators must deserialize and process it with unmetered execution, causing:
- Memory exhaustion during deserialization
- CPU exhaustion during Move VM execution  
- Storage bloat from persisting large JWK sets
- Network bandwidth consumption

## Impact Explanation

This qualifies as **High Severity** per Aptos bug bounty criteria due to "Validator node slowdowns". Resource exhaustion from processing multi-megabyte JWK payloads can significantly degrade validator performance, impacting:
- Block processing latency
- Consensus participation ability
- State synchronization performance
- Overall network throughput

While not causing complete liveness failure, sustained exploitation could force validators to allocate excessive resources or experience degraded service.

## Likelihood Explanation

**Likelihood: Low to Medium**

The attack requires:
1. Control of a supported OIDC provider's JWK endpoint (via compromise or malicious governance addition)
2. All validators observing the malicious JWK set
3. Quorum certification of the update

However, the impact is **guaranteed once triggered** since:
- No size checks exist at any layer
- Unmetered execution ensures processing completes
- All validators must process identical blocks for consensus

The comparison with federated JWKs is instructive: [6](#0-5) 

Federated JWKs have a 2 KiB size limit, but observed JWKs through validator consensus have none.

## Recommendation

Implement multi-layered size limits:

**1. Add per-transaction size check in validator pool:**
```rust
// In crates/aptos-jwk-consensus/src/jwk_manager/mod.rs
pub fn process_quorum_certified_update(&mut self, update: QuorumCertifiedUpdate) -> Result<()> {
    let txn = ValidatorTransaction::ObservedJWKUpdate(update.clone());
    
    // Add size check
    const MAX_JWK_UPDATE_SIZE_BYTES: usize = 512 * 1024; // 512 KiB
    let txn_size = txn.size_in_bytes();
    ensure!(
        txn_size <= MAX_JWK_UPDATE_SIZE_BYTES,
        "JWK update size {} exceeds limit {}",
        txn_size,
        MAX_JWK_UPDATE_SIZE_BYTES
    );
    
    let vtxn_guard = self.vtxn_pool.put(/*...*/);
    // ...
}
```

**2. Add validation in Move contract:**
```move
// In aptos-move/framework/aptos-framework/sources/jwks.move
const MAX_OBSERVED_JWKS_SIZE_BYTES: u64 = 512 * 1024; // 512 KiB
const MAX_JWKS_PER_PROVIDER: u64 = 100;

public fun upsert_into_observed_jwks(fx: &signer, provider_jwks_vec: vector<ProviderJWKs>) {
    // Add size validation
    vector::for_each_ref(&provider_jwks_vec, |provider_jwks| {
        let num_jwks = vector::length(&provider_jwks.jwks);
        assert!(num_jwks <= MAX_JWKS_PER_PROVIDER, ETOO_MANY_JWKS);
        
        let serialized_size = vector::length(&bcs::to_bytes(provider_jwks));
        assert!(serialized_size <= MAX_OBSERVED_JWKS_SIZE_BYTES, EJWK_SET_TOO_LARGE);
    });
    // ... existing logic
}
```

**3. Add field size limits for RSA_JWK:**
```move
// Validate string field lengths
assert!(string::length(&kid) <= 256, EJWK_FIELD_TOO_LARGE);
assert!(string::length(&n) <= 512, EJWK_FIELD_TOO_LARGE);
```

## Proof of Concept

```rust
// Rust PoC demonstrating size calculation
use aptos_types::jwks::{ProviderJWKs, RSA_JWK};
use aptos_types::validator_txn::ValidatorTransaction;

fn main() {
    let mut jwks = vec![];
    
    // Create 100 JWKs with 10KB kid fields each = ~1MB
    for i in 0..100 {
        jwks.push(RSA_JWK::new_256_aqab(
            &"x".repeat(10_000), // 10KB kid
            &"y".repeat(344),     // Valid RSA modulus size (base64 of 256 bytes)
        ));
    }
    
    let provider_jwks = ProviderJWKs {
        issuer: b"malicious.com".to_vec(),
        version: 1,
        jwks: jwks.into_iter().map(Into::into).collect(),
    };
    
    let update = QuorumCertifiedUpdate {
        update: provider_jwks,
        multi_sig: AggregateSignature::empty(),
    };
    
    let txn = ValidatorTransaction::ObservedJWKUpdate(update);
    
    // This will be ~1MB and pass all current checks
    println!("Transaction size: {} bytes", txn.size_in_bytes());
    
    // All validators must deserialize and process this without size limits
    // With UnmeteredGasMeter, no computational bounds exist
}
```

## Notes

The vulnerability exists in the production codebase but requires specific conditions to exploit:
- Compromised OIDC provider OR malicious governance action
- All validators must observe the same large JWK set
- Quorum certification process completes normally

The missing size limits violate **Critical Invariant #9**: "Resource Limits: All operations must respect gas, storage, and computational limits." The use of `UnmeteredGasMeter` specifically bypasses Move VM safety guarantees (Invariant #3).

The block-level 2MB limit provides minimal protection: [7](#0-6) 

A single 1.5MB JWK update would consume 75% of per-block validator transaction capacity while still being processable.

### Citations

**File:** crates/aptos-jwk-consensus/src/jwk_manager/mod.rs (L323-350)
```rust
    pub fn process_quorum_certified_update(&mut self, update: QuorumCertifiedUpdate) -> Result<()> {
        let issuer = update.update.issuer.clone();
        info!(
            epoch = self.epoch_state.epoch,
            issuer = String::from_utf8(issuer.clone()).ok(),
            version = update.update.version,
            "JWKManager processing certified update."
        );
        let state = self.states_by_issuer.entry(issuer.clone()).or_default();
        match &state.consensus_state {
            ConsensusState::InProgress { my_proposal, .. } => {
                //TODO: counters
                let txn = ValidatorTransaction::ObservedJWKUpdate(update.clone());
                let vtxn_guard =
                    self.vtxn_pool
                        .put(Topic::JWK_CONSENSUS(issuer.clone()), Arc::new(txn), None);
                state.consensus_state = ConsensusState::Finished {
                    vtxn_guard,
                    my_proposal: my_proposal.clone(),
                    quorum_certified: update.clone(),
                };
                info!(
                    epoch = self.epoch_state.epoch,
                    issuer = String::from_utf8(issuer).ok(),
                    version = update.update.version,
                    "certified update accepted."
                );
                Ok(())
```

**File:** crates/validator-transaction-pool/src/lib.rs (L58-82)
```rust
    pub fn put(
        &self,
        topic: Topic,
        txn: Arc<ValidatorTransaction>,
        pull_notification_tx: Option<aptos_channel::Sender<(), Arc<ValidatorTransaction>>>,
    ) -> TxnGuard {
        let mut pool = self.inner.lock();
        let seq_num = pool.next_seq_num;
        pool.next_seq_num += 1;

        pool.txn_queue.insert(seq_num, PoolItem {
            topic: topic.clone(),
            txn,
            pull_notification_tx,
        });

        if let Some(old_seq_num) = pool.seq_nums_by_topic.insert(topic.clone(), seq_num) {
            pool.txn_queue.remove(&old_seq_num);
        }

        TxnGuard {
            pool: self.inner.clone(),
            seq_num,
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L31-43)
```text
    /// We limit the size of a `PatchedJWKs` resource installed by a dapp owner for federated keyless accounts.
    /// Note: If too large, validators waste work reading it for invalid TXN signatures.
    const MAX_FEDERATED_JWKS_SIZE_BYTES: u64 = 2 * 1024; // 2 KiB

    const EUNEXPECTED_EPOCH: u64 = 1;
    const EUNEXPECTED_VERSION: u64 = 2;
    const EUNKNOWN_PATCH_VARIANT: u64 = 3;
    const EUNKNOWN_JWK_VARIANT: u64 = 4;
    const EISSUER_NOT_FOUND: u64 = 5;
    const EJWK_ID_NOT_FOUND: u64 = 6;
    const EINSTALL_FEDERATED_JWKS_AT_APTOS_FRAMEWORK: u64 = 7;
    const EFEDERATED_JWKS_TOO_LARGE: u64 = 8;
    const EINVALID_FEDERATED_JWK_SET: u64 = 9;
```

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L458-505)
```text
    /// Only used by validators to publish their observed JWK update.
    ///
    /// NOTE: It is assumed verification has been done to ensure each update is quorum-certified,
    /// and its `version` equals to the on-chain version + 1.
    public fun upsert_into_observed_jwks(fx: &signer, provider_jwks_vec: vector<ProviderJWKs>) acquires ObservedJWKs, PatchedJWKs, Patches {
        system_addresses::assert_aptos_framework(fx);
        let observed_jwks = borrow_global_mut<ObservedJWKs>(@aptos_framework);

        if (features::is_jwk_consensus_per_key_mode_enabled()) {
            vector::for_each(provider_jwks_vec, |proposed_provider_jwks|{
                let maybe_cur_issuer_jwks = remove_issuer(&mut observed_jwks.jwks, proposed_provider_jwks.issuer);
                let cur_issuer_jwks = if (option::is_some(&maybe_cur_issuer_jwks)) {
                    option::extract(&mut maybe_cur_issuer_jwks)
                } else {
                    ProviderJWKs {
                        issuer: proposed_provider_jwks.issuer,
                        version: 0,
                        jwks: vector[],
                    }
                };
                assert!(cur_issuer_jwks.version + 1 == proposed_provider_jwks.version, error::invalid_argument(EUNEXPECTED_VERSION));
                vector::for_each(proposed_provider_jwks.jwks, |jwk|{
                    let variant_type_name = *string::bytes(copyable_any::type_name(&jwk.variant));
                    let is_delete = if (variant_type_name == b"0x1::jwks::UnsupportedJWK") {
                        let repr = copyable_any::unpack<UnsupportedJWK>(jwk.variant);
                        &repr.payload == &DELETE_COMMAND_INDICATOR
                    } else {
                        false
                    };
                    if (is_delete) {
                        remove_jwk(&mut cur_issuer_jwks, get_jwk_id(&jwk));
                    } else {
                        upsert_jwk(&mut cur_issuer_jwks, jwk);
                    }
                });
                cur_issuer_jwks.version = cur_issuer_jwks.version + 1;
                upsert_provider_jwks(&mut observed_jwks.jwks, cur_issuer_jwks);
            });
        } else {
            vector::for_each(provider_jwks_vec, |provider_jwks| {
                upsert_provider_jwks(&mut observed_jwks.jwks, provider_jwks);
            });
        };

        let epoch = reconfiguration::current_epoch();
        emit(ObservedJWKsUpdated { epoch, jwks: observed_jwks.jwks });
        regenerate_patched_jwks();
    }
```

**File:** aptos-move/aptos-vm/src/validator_txns/jwk.rs (L144-166)
```rust
        // All verification passed. Apply the `observed`.
        let mut gas_meter = UnmeteredGasMeter;
        let mut session = self.new_session(resolver, session_id, None);
        let args = vec![
            MoveValue::Signer(AccountAddress::ONE),
            vec![observed].as_move_value(),
        ];

        let traversal_storage = TraversalStorage::new();
        session
            .execute_function_bypass_visibility(
                &JWKS_MODULE,
                UPSERT_INTO_OBSERVED_JWKS,
                vec![],
                serialize_values(&args),
                &mut gas_meter,
                &mut TraversalContext::new(&traversal_storage),
                module_storage,
            )
            .map_err(|e| {
                expect_only_successful_execution(e, UPSERT_INTO_OBSERVED_JWKS.as_str(), log_context)
            })
            .map_err(|r| Unexpected(r.unwrap_err()))?;
```

**File:** types/src/jwks/rsa/mod.rs (L18-25)
```rust
#[derive(Clone, Debug, Hash, PartialEq, Eq, Serialize, Deserialize, Object)]
pub struct RSA_JWK {
    pub kid: String,
    pub kty: String,
    pub alg: String,
    pub e: String,
    pub n: String,
}
```

**File:** types/src/on_chain_config/consensus_config.rs (L125-127)
```rust
const VTXN_CONFIG_PER_BLOCK_LIMIT_TXN_COUNT_DEFAULT: u64 = 2;
const VTXN_CONFIG_PER_BLOCK_LIMIT_TOTAL_BYTES_DEFAULT: u64 = 2097152; //2MB

```
