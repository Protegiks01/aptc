# Audit Report

## Title
Silent Fallback to Legacy Storage Pricing Enables Non-Deterministic Execution and Consensus Divergence

## Summary
When `StorageGasParameters::new()` is called for gas feature versions 1-9, if the on-chain `StorageGas` resource is missing, the code silently falls back to legacy V1 pricing instead of the expected V2 storage curve-based pricing. This creates a consensus vulnerability where validators with different on-chain states will charge different gas amounts for identical storage operations, violating the deterministic execution invariant and potentially causing network partition.

## Finding Description

The vulnerability exists in the storage gas parameter initialization flow: [1](#0-0) 

When `StorageGasParameters::new()` is invoked, it constructs storage pricing via `IoPricing::new()`: [2](#0-1) 

For gas feature versions 1-9, if `StorageGasSchedule::fetch_config(config_storage)` returns `None`, the code **silently falls back** to `IoPricingV1` instead of the expected `IoPricingV2`. Critically, this fallback happens without raising any error or warning. [3](#0-2) 

The two pricing models use fundamentally different formulas:

**IoPricingV1** uses static parameters from the gas schedule: [4](#0-3) 

**IoPricingV2** uses dynamic storage curves from on-chain configuration: [5](#0-4) 

The `StorageGas` resource is supposed to be initialized during genesis: [6](#0-5) 

And maintained through reconfiguration: [7](#0-6) 

**Attack Scenario:**

1. Network operates at gas feature version 2-9 (expecting V2 storage pricing)
2. Through genesis misconfiguration, state corruption bug, or state sync inconsistency, some validators lack the `StorageGas` resource at `@aptos_framework`
3. Validators with complete state: `StorageGasSchedule::fetch_config()` succeeds → Use `IoPricingV2`
4. Validators with missing `StorageGas`: `fetch_config()` returns `None` → Silently fall back to `IoPricingV1`
5. Both sets of validators execute the same transaction with storage operations
6. **V1 validators charge different gas amounts than V2 validators** (different formulas)
7. Execution results diverge (different remaining gas, different total fees)
8. State roots diverge
9. **Consensus splits**, network partitions

Additionally, the table gas parameter overwriting logic assumes V2 pricing: [8](#0-7) 

If V1 fallback occurs, the `if let IoPricing::V2(pricing)` pattern match fails, leaving table operations with potentially incorrect gas parameters.

Note: Storage operations are NOT literally "free" - both V1 and V2 charge gas. However, they use **different pricing formulas**, breaking determinism.

## Impact Explanation

**Severity: High** (Significant protocol violation per Aptos bug bounty)

This vulnerability violates the critical invariant: **"Deterministic Execution: All validators must produce identical state roots for identical blocks"**

Impact:
1. **Consensus Divergence**: Validators with different pricing models cannot reach agreement on state roots
2. **Network Partition**: The network splits into two factions (V1 vs V2 validators)
3. **Liveness Failure**: Unable to finalize blocks with >1/3 validators on each side
4. **Requires Manual Intervention**: Hard fork or coordinated restart needed to recover

While storage is not free, the non-determinism is sufficient to break consensus. This qualifies as "Significant protocol violation" under High severity.

## Likelihood Explanation

**Likelihood: Medium**

Prerequisites:
1. Network running at gas feature version 1-9
2. `StorageGas` resource missing on some validators but present on others

Possible triggers:
- **Genesis bugs**: Incomplete initialization if `storage_gas::initialize()` fails
- **State corruption**: Separate bug that corrupts or deletes on-chain resources  
- **State sync inconsistencies**: Snapshot restoration providing incomplete state
- **Upgrade issues**: Feature version upgrade without proper migration

While requiring specific conditions, the silent nature of the fallback means validators would not detect the inconsistency until consensus fails. The lack of validation makes this a defensive programming issue that could be triggered by other bugs.

## Recommendation

Add explicit validation that required on-chain configurations exist for their respective feature versions:

```rust
pub fn new(
    feature_version: u64,
    gas_params: &AptosGasParameters,
    config_storage: &impl ConfigStorage,
) -> Result<IoPricing, String> {
    use aptos_types::on_chain_config::OnChainConfig;
    use IoPricing::*;

    match feature_version {
        0 => Ok(V1(IoPricingV1::new(gas_params))),
        1..=9 => {
            let schedule = StorageGasSchedule::fetch_config(config_storage)
                .ok_or_else(|| format!(
                    "StorageGasSchedule is required for gas feature version {} but not found on-chain",
                    feature_version
                ))?;
            Ok(V2(IoPricingV2::new_with_storage_curves(
                feature_version,
                &schedule,
                gas_params,
            )))
        },
        10..=11 => Ok(V3(IoPricingV3 {
            feature_version,
            legacy_free_write_bytes_quota: gas_params.vm.txn.legacy_free_write_bytes_quota,
        })),
        12.. => Ok(V4(IoPricingV4)),
    }
}
```

Update `StorageGasParameters::new()` to propagate the error:

```rust
pub fn new(
    gas_feature_version: u64,
    features: &Features,
    gas_params: &AptosGasParameters,
    config_storage: &impl ConfigStorage,
) -> Result<Self, String> {
    let change_set_configs = ChangeSetConfigs::new(gas_feature_version, gas_params);
    let io_pricing = IoPricing::new(gas_feature_version, gas_params, config_storage)?;
    let space_pricing = DiskSpacePricing::new(gas_feature_version, features);

    Ok(Self {
        io_pricing,
        space_pricing,
        change_set_configs,
    })
}
```

This ensures validators fail fast with clear error messages rather than silently using incorrect pricing.

## Proof of Concept

```rust
#[test]
fn test_storage_gas_missing_causes_divergence() {
    use aptos_types::state_store::MockStateView;
    use aptos_vm_types::storage::io_pricing::IoPricing;
    use aptos_gas_schedule::AptosGasParameters;
    
    // Validator 1: Has StorageGas in state
    let state_with_storage_gas = create_state_with_storage_gas();
    let gas_params = AptosGasParameters::initial();
    let pricing_v1 = IoPricing::new(2, &gas_params, &state_with_storage_gas);
    
    // Validator 2: Missing StorageGas (simulating corruption)
    let state_without_storage_gas = MockStateView::empty();
    let pricing_v2 = IoPricing::new(2, &gas_params, &state_without_storage_gas);
    
    // Different pricing models returned
    assert!(matches!(pricing_v1, IoPricing::V2(_)));
    assert!(matches!(pricing_v2, IoPricing::V1(_))); // Silent fallback!
    
    // Calculate gas for same operation - results diverge
    let key = StateKey::raw(b"test");
    let op_size = WriteOpSize::Creation { write_len: 100 };
    
    let gas_v1 = pricing_v1.io_gas_per_write(&key, &op_size);
    let gas_v2 = pricing_v2.io_gas_per_write(&key, &op_size);
    
    // Different gas charges -> non-deterministic execution -> consensus split
    assert_ne!(gas_v1, gas_v2);
}
```

## Notes

While the security question mentions "free storage operations," the actual vulnerability is **non-deterministic gas charging** rather than zero-cost storage. Both V1 and V2 pricing charge gas, but use different formulas. The consensus risk from this non-determinism is sufficient to constitute a High severity protocol violation.

The root cause is inadequate validation of required on-chain configurations, allowing validators to silently operate with mismatched pricing models.

### Citations

**File:** aptos-move/aptos-vm-environment/src/gas.rs (L61-64)
```rust
    let storage_gas_params = match &mut gas_params {
        Ok(gas_params) => {
            let storage_gas_params =
                StorageGasParameters::new(gas_feature_version, features, gas_params, state_view);
```

**File:** aptos-move/aptos-vm-environment/src/gas.rs (L71-86)
```rust
                2..=6 => {
                    if let IoPricing::V2(pricing) = &storage_gas_params.io_pricing {
                        g.common_load_base_legacy = pricing.per_item_read * NumArgs::new(1);
                        g.common_load_base_new = 0.into();
                        g.common_load_per_byte = pricing.per_byte_read;
                        g.common_load_failure = 0.into();
                    }
                }
                7..=9 => {
                    if let IoPricing::V2(pricing) = &storage_gas_params.io_pricing {
                        g.common_load_base_legacy = 0.into();
                        g.common_load_base_new = pricing.per_item_read * NumArgs::new(1);
                        g.common_load_per_byte = pricing.per_byte_read;
                        g.common_load_failure = 0.into();
                    }
                }
```

**File:** aptos-move/aptos-vm-types/src/storage/io_pricing.rs (L36-46)
```rust
    fn new(gas_params: &AptosGasParameters) -> Self {
        Self {
            write_data_per_op: gas_params.vm.txn.storage_io_per_state_slot_write,
            write_data_per_new_item: gas_params.vm.txn.legacy_write_data_per_new_item,
            write_data_per_byte_in_key: gas_params.vm.txn.storage_io_per_state_byte_write,
            write_data_per_byte_in_val: gas_params.vm.txn.legacy_write_data_per_byte_in_val,
            load_data_base: gas_params.vm.txn.storage_io_per_state_slot_read * NumArgs::new(1),
            load_data_per_byte: gas_params.vm.txn.storage_io_per_state_byte_read,
            load_data_failure: gas_params.vm.txn.load_data_failure,
        }
    }
```

**File:** aptos-move/aptos-vm-types/src/storage/io_pricing.rs (L95-110)
```rust
    pub fn new_with_storage_curves(
        feature_version: u64,
        storage_gas_schedule: &StorageGasSchedule,
        gas_params: &AptosGasParameters,
    ) -> Self {
        Self {
            feature_version,
            free_write_bytes_quota: Self::get_free_write_bytes_quota(feature_version, gas_params),
            per_item_read: storage_gas_schedule.per_item_read.into(),
            per_item_create: storage_gas_schedule.per_item_create.into(),
            per_item_write: storage_gas_schedule.per_item_write.into(),
            per_byte_read: storage_gas_schedule.per_byte_read.into(),
            per_byte_create: storage_gas_schedule.per_byte_create.into(),
            per_byte_write: storage_gas_schedule.per_byte_write.into(),
        }
    }
```

**File:** aptos-move/aptos-vm-types/src/storage/io_pricing.rs (L242-266)
```rust
    pub fn new(
        feature_version: u64,
        gas_params: &AptosGasParameters,
        config_storage: &impl ConfigStorage,
    ) -> IoPricing {
        use aptos_types::on_chain_config::OnChainConfig;
        use IoPricing::*;

        match feature_version {
            0 => V1(IoPricingV1::new(gas_params)),
            1..=9 => match StorageGasSchedule::fetch_config(config_storage) {
                None => V1(IoPricingV1::new(gas_params)),
                Some(schedule) => V2(IoPricingV2::new_with_storage_curves(
                    feature_version,
                    &schedule,
                    gas_params,
                )),
            },
            10..=11 => V3(IoPricingV3 {
                feature_version,
                legacy_free_write_bytes_quota: gas_params.vm.txn.legacy_free_write_bytes_quota,
            }),
            12.. => V4(IoPricingV4),
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/genesis.move (L124-124)
```text
        storage_gas::initialize(&aptos_framework_account);
```

**File:** aptos-move/framework/aptos-framework/sources/storage_gas.move (L515-533)
```text
    public(friend) fun on_reconfig() acquires StorageGas, StorageGasConfig {
        assert!(
            exists<StorageGasConfig>(@aptos_framework),
            error::not_found(ESTORAGE_GAS_CONFIG)
        );
        assert!(
            exists<StorageGas>(@aptos_framework),
            error::not_found(ESTORAGE_GAS)
        );
        let (items, bytes) = state_storage::current_items_and_bytes();
        let gas_config = borrow_global<StorageGasConfig>(@aptos_framework);
        let gas = borrow_global_mut<StorageGas>(@aptos_framework);
        gas.per_item_read = calculate_read_gas(&gas_config.item_config, items);
        gas.per_item_create = calculate_create_gas(&gas_config.item_config, items);
        gas.per_item_write = calculate_write_gas(&gas_config.item_config, items);
        gas.per_byte_read = calculate_read_gas(&gas_config.byte_config, bytes);
        gas.per_byte_create = calculate_create_gas(&gas_config.byte_config, bytes);
        gas.per_byte_write = calculate_write_gas(&gas_config.byte_config, bytes);
    }
```
