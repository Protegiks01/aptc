# Audit Report

## Title
Critical Infrastructure Module Upgradeable with Compatibility Check Bypass via Private Inline Function Manipulation

## Summary
The `large_packages` module deployed at `0x0e1ca3011bdd07246d4d16d909dbb2d6953a86c4735d5acf5865d962c630cce7` on mainnet/testnet uses the default compatible upgrade policy, allowing an attacker with the compromised private key to deploy a malicious version by modifying private inline functions that bypass compatibility checks.

## Finding Description

The `large_packages` module serves as critical infrastructure for deploying large Move packages on Aptos mainnet and testnet. Investigation reveals multiple security weaknesses:

**1. Default Compatible Upgrade Policy**

The `aptos-experimental` package does not specify an `upgrade_policy` field in its Move.toml [1](#0-0) , which causes it to default to `UpgradePolicy::compat()` during metadata extraction [2](#0-1) .

**2. Authentication Bypass with Private Key**

An attacker possessing the private key for the deployment address can sign transactions as that account. The permission system treats master signers (non-permissioned signers) as having all permissions [3](#0-2) , allowing them to pass the `check_code_publishing_permission` check required for module publishing [4](#0-3) .

**3. Compatibility Check Gap for Private Functions**

The compatibility checker explicitly skips private functions during upgrade validation [5](#0-4) . All inline functions in the `large_packages` module are declared without visibility modifiers, making them private [6](#0-5) .

**4. Attack Execution Path**

An attacker with the compromised private key can:
1. Clone the `large_packages` module source code
2. Maintain identical signatures for all public entry functions (stage_code_chunk, stage_code_chunk_and_publish_to_account, etc.)
3. Modify private inline functions (`publish_to_account`, `publish_to_object`, `upgrade_object_code`, `assemble_module_code`) to inject malicious code that:
   - Replaces legitimate modules with backdoored versions
   - Steals assets during package deployment
   - Corrupts assembled bytecode
4. Submit the upgrade transaction, which passes compatibility checks because only public functions are validated
5. All subsequent users deploying packages via `large_packages` execute the malicious code

## Impact Explanation

**Critical Severity** - This vulnerability qualifies for Critical severity under Aptos Bug Bounty criteria:

- **Loss of Funds**: Attacker can steal tokens/assets from users deploying packages through the compromised module
- **Consensus/Safety Violations**: Malicious bytecode injection could deploy modules that break Move VM invariants or consensus rules
- **Mass Compromise**: Affects ALL users on mainnet and testnet who deploy large packages, as the module is used as trusted infrastructure [7](#0-6) 

The hardcoded address is documented as the canonical location for this functionality [8](#0-7) , making all users who follow official documentation vulnerable.

## Likelihood Explanation

**Moderate to High Likelihood**:

- Private keys for long-lived infrastructure accounts face ongoing compromise risk (insider threats, infrastructure breaches, side-channel attacks)
- The compatibility check gap is architectural and cannot be detected by users
- Once deployed, the malicious module appears identical to legitimate code from the outside
- No on-chain monitoring exists to detect inline function modifications
- The upgrade could be executed in a single transaction with no warning to users

## Recommendation

**Immediate Actions:**

1. **Freeze the Module**: Use the `freeze_code_object` function to set the upgrade policy to immutable [9](#0-8) 

2. **Rotate Deployment Model**: For future experimental modules requiring upgrades, use governance-controlled upgrades rather than single-key control

3. **Enhanced Compatibility Checks**: Extend the compatibility checker to validate that private inline functions have not changed their bytecode implementation (not just signatures)

**Code Fix for Future Deployments:**

Modify `aptos-experimental/Move.toml`:
```toml
[package]
name = "AptosExperimental"
version = "1.0.0"
upgrade_policy = "immutable"
```

Or publish via governance with explicit immutable policy enforcement.

## Proof of Concept

```move
// Malicious upgrade maintaining compatible public interface
module aptos_experimental::large_packages {
    // ... keep all public entry functions with identical signatures ...
    
    // MALICIOUS MODIFICATION - private inline function
    inline fun publish_to_account(
        publisher: &signer, staging_area: &mut StagingArea
    ) {
        let code = assemble_module_code(staging_area);
        
        // INJECTED: Before publishing, replace first module with backdoor
        if (vector::length(&code) > 0) {
            let backdoor = get_backdoor_bytecode(); // attacker's malicious code
            *vector::borrow_mut(&mut code, 0) = backdoor;
        };
        
        code::publish_package_txn(publisher, staging_area.metadata_serialized, code);
    }
    
    // Other inline functions similarly modified...
}
```

**Test Steps:**
1. Deploy initial `large_packages` module with compat policy
2. Craft upgrade with modified inline functions but identical public signatures
3. Submit upgrade transaction signed with module owner's key
4. Verify upgrade passes compatibility checks despite malicious inline function changes
5. Demonstrate that subsequent package deployments execute backdoored code

**Notes**

This vulnerability represents a critical design flaw where essential infrastructure depends on a single private key with an upgradeable module policy. The compatibility checker's exemption of private functions creates an exploitable gap that allows complete replacement of core logic while maintaining API compatibility. This breaks the Access Control invariant requiring protection of system addresses and critical infrastructure modules.

### Citations

**File:** aptos-move/framework/aptos-experimental/Move.toml (L1-9)
```text
[package]
name = "AptosExperimental"
version = "1.0.0"

[addresses]
aptos_experimental = "0x7"

[dependencies]
AptosFramework = { local = "../aptos-framework" }
```

**File:** aptos-move/framework/src/built_package.rs (L527-531)
```rust
        let upgrade_policy = if let Some(val) = custom_props.get(UPGRADE_POLICY_CUSTOM_FIELD) {
            str::parse::<UpgradePolicy>(val.as_ref())?
        } else {
            UpgradePolicy::compat()
        };
```

**File:** aptos-move/framework/aptos-framework/sources/permissioned_signer.move (L561-563)
```text
        if (!is_permissioned_signer(s)) {
            // master signer has all permissions
            return true
```

**File:** aptos-move/framework/aptos-framework/sources/code.move (L117-122)
```text
    public(friend) fun check_code_publishing_permission(s: &signer) {
        assert!(
            permissioned_signer::check_permission_exists(s, CodePublishingPermission {}),
            error::permission_denied(ENO_CODE_PERMISSION),
        );
    }
```

**File:** aptos-move/framework/aptos-framework/sources/code.move (L230-252)
```text
    public fun freeze_code_object(publisher: &signer, code_object: Object<PackageRegistry>) acquires PackageRegistry {
        check_code_publishing_permission(publisher);
        let code_object_addr = object::object_address(&code_object);
        assert!(exists<PackageRegistry>(code_object_addr), error::not_found(ECODE_OBJECT_DOES_NOT_EXIST));
        assert!(
            object::is_owner(code_object, signer::address_of(publisher)),
            error::permission_denied(ENOT_PACKAGE_OWNER)
        );

        let registry = borrow_global_mut<PackageRegistry>(code_object_addr);
        vector::for_each_mut(&mut registry.packages, |pack| {
            let package: &mut PackageMetadata = pack;
            package.upgrade_policy = upgrade_policy_immutable();
        });

        // We unfortunately have to make a copy of each package to avoid borrow checker issues as check_dependencies
        // needs to borrow PackageRegistry from the dependency packages.
        // This would increase the amount of gas used, but this is a rare operation and it's rare to have many packages
        // in a single code object.
        vector::for_each(registry.packages, |pack| {
            check_dependencies(code_object_addr, &pack);
        });
    }
```

**File:** third_party/move/move-binary-format/src/compatibility.rs (L168-174)
```rust
            if old_func.visibility() == Visibility::Private
                && !old_func.is_entry()
                && !old_is_persistent
            {
                // Function not exposed, continue with next one
                continue;
            }
```

**File:** aptos-move/framework/aptos-experimental/sources/large_packages.move (L132-225)
```text
    inline fun stage_code_chunk_internal(
        owner: &signer,
        metadata_chunk: vector<u8>,
        code_indices: vector<u16>,
        code_chunks: vector<vector<u8>>
    ): &mut StagingArea {
        assert!(
            vector::length(&code_indices) == vector::length(&code_chunks),
            error::invalid_argument(ECODE_MISMATCH)
        );

        let owner_address = signer::address_of(owner);

        if (!exists<StagingArea>(owner_address)) {
            move_to(
                owner,
                StagingArea {
                    metadata_serialized: vector[],
                    code: smart_table::new(),
                    last_module_idx: 0
                }
            );
        };

        let staging_area = borrow_global_mut<StagingArea>(owner_address);

        if (!vector::is_empty(&metadata_chunk)) {
            vector::append(&mut staging_area.metadata_serialized, metadata_chunk);
        };

        let i = 0;
        while (i < vector::length(&code_chunks)) {
            let inner_code = *vector::borrow(&code_chunks, i);
            let idx = (*vector::borrow(&code_indices, i) as u64);

            if (smart_table::contains(&staging_area.code, idx)) {
                vector::append(
                    smart_table::borrow_mut(&mut staging_area.code, idx), inner_code
                );
            } else {
                smart_table::add(&mut staging_area.code, idx, inner_code);
                if (idx > staging_area.last_module_idx) {
                    staging_area.last_module_idx = idx;
                }
            };
            i = i + 1;
        };

        staging_area
    }

    inline fun publish_to_account(
        publisher: &signer, staging_area: &mut StagingArea
    ) {
        let code = assemble_module_code(staging_area);
        code::publish_package_txn(publisher, staging_area.metadata_serialized, code);
    }

    inline fun publish_to_object(
        publisher: &signer, staging_area: &mut StagingArea
    ) {
        let code = assemble_module_code(staging_area);
        object_code_deployment::publish(
            publisher, staging_area.metadata_serialized, code
        );
    }

    inline fun upgrade_object_code(
        publisher: &signer,
        staging_area: &mut StagingArea,
        code_object: Object<PackageRegistry>
    ) {
        let code = assemble_module_code(staging_area);
        object_code_deployment::upgrade(
            publisher,
            staging_area.metadata_serialized,
            code,
            code_object
        );
    }

    inline fun assemble_module_code(staging_area: &mut StagingArea): vector<vector<u8>> {
        let last_module_idx = staging_area.last_module_idx;
        let code = vector[];
        let i = 0;
        while (i <= last_module_idx) {
            vector::push_back(
                &mut code,
                *smart_table::borrow(&staging_area.code, i)
            );
            i = i + 1;
        };
        code
    }
```

**File:** aptos-move/framework/src/chunked_publish.rs (L10-13)
```rust
/// The default address where the `large_packages.move` module is deployed.
/// This address is used on both mainnet and testnet.
pub const LARGE_PACKAGES_PROD_MODULE_ADDRESS: &str =
    "0x0e1ca3011bdd07246d4d16d909dbb2d6953a86c4735d5acf5865d962c630cce7";
```

**File:** crates/aptos/src/common/types.rs (L674-676)
```rust
    }
}

```
