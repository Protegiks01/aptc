# Audit Report

## Title
VFN Outbound Connection Manipulation via Unverified REST Discovery Allowing Malicious Peer Injection

## Summary
Validator Full Nodes (VFNs) using REST-based peer discovery are vulnerable to malicious peer injection because the REST client does not verify state proofs for the `ValidatorSet` it fetches. An attacker controlling the REST endpoint can inject malicious peers that receive `MediumPriority`, potentially forcing the VFN to sync from compromised peers during fallback scenarios.

## Finding Description

The vulnerability exists in the interaction between three components:

1. **REST Discovery without state proof verification**: The REST discovery mechanism fetches the `ValidatorSet` from a configured REST API endpoint but does not cryptographically verify the data. [1](#0-0) 

2. **Unverified REST client**: The `get_account_resource_bcs` method simply deserializes the response without validating state proofs. [2](#0-1) 

3. **MediumPriority assignment to outbound connections**: VFNs assign `MediumPriority` to outbound connections on the Public network, regardless of whether the peer is trusted. [3](#0-2) 

**Attack Flow:**

1. A VFN is configured with REST discovery pointing to a REST endpoint
2. Attacker compromises the REST endpoint (via DNS poisoning, MITM on HTTP, or misconfiguration)
3. Attacker returns a malicious `ValidatorSet` containing their own peer addresses and public keys
4. VFN updates discovered peers via `handle_update_discovered_peers(DiscoverySource::Rest, malicious_peers)` [4](#0-3) 

5. VFN establishes outbound connections to malicious peers on the Public network
6. During Noise handshake, malicious peers are assigned `PeerRole::Unknown` since they're not in the trusted peer set [5](#0-4) 

7. Despite being `Unknown`, these peers receive `MediumPriority` due to being outbound connections
8. During state sync, if `HighPriority` validators are unavailable or fail, the VFN falls back to `MediumPriority` peers, including the attacker's nodes [6](#0-5) 

## Impact Explanation

**Severity: Medium**

While the attacker cannot provide fake state data (due to signature verification in state sync), they can:

1. **Denial of Service**: Refuse to serve data, degrading VFN sync reliability
2. **Eclipse Attack**: Serve old (but valid) state with legitimate signatures, preventing the VFN from syncing to the latest state
3. **Manipulate non-verified responses**: Control responses to `GetStorageServerSummary`, `GetServerProtocolVersion`, etc., potentially influencing peer selection

The impact is limited because state sync properly verifies `LedgerInfoWithSignatures` for all critical state data: [7](#0-6) 

This prevents the attacker from corrupting the actual blockchain state. However, the vulnerability still violates the security invariant that VFNs should only sync from authenticated and trusted peers, and can cause **state inconsistencies requiring intervention** (Medium severity per bug bounty).

## Likelihood Explanation

**Likelihood: Medium**

The attack requires:
1. VFN configured to use REST discovery (legitimate but not universal)
2. Attacker ability to manipulate the REST endpoint (DNS poisoning, MITM on HTTP, or endpoint misconfiguration)
3. Fallback scenario where `HighPriority` validators are unavailable

While REST discovery is a documented configuration option, the likelihood is moderate because:
- Not all VFNs use REST discovery
- HTTPS endpoints with proper certificate validation reduce MITM risk
- VFNs typically maintain connections to validators on the VFN network

However, in scenarios where VFNs rely heavily on Public network peers or during network partitions, the impact increases significantly.

## Recommendation

Implement state proof verification for REST discovery responses:

1. **Add state proof verification to REST client**: Modify `get_account_resource_bcs` to accept and verify state proofs, similar to how light clients verify on-chain data.

2. **Validate ValidatorSet cryptographically**: Before accepting peers from REST discovery, verify the ValidatorSet against a trusted root (waypoint or verified ledger info).

3. **Restrict MediumPriority assignment**: Only assign `MediumPriority` to peers that are either:
   - In the trusted peer set, OR
   - Verified through on-chain discovery with valid proofs

Specifically, modify the priority logic:
```rust
// In priority.rs, lines 91-101
// Only give MediumPriority to verified outbound peers
if is_trusted_peer(peers_and_metadata.clone(), peer) {
    return PeerPriority::MediumPriority;
}
// Unverified outbound peers should be LowPriority
return PeerPriority::LowPriority;
```

4. **Use HTTPS by default**: Enforce HTTPS for REST discovery endpoints and implement certificate pinning for production deployments.

## Proof of Concept

```rust
// Reproduction steps:

// 1. Set up a malicious REST endpoint that returns a crafted ValidatorSet
// containing attacker-controlled peer addresses and keys

// 2. Configure a VFN with REST discovery pointing to the malicious endpoint:
// config.toml:
// [full_node_networks.0]
// discovery_methods = [{ Rest = { url = "http://attacker.com/v1/", interval_secs = 10 } }]

// 3. The VFN will fetch the malicious ValidatorSet:
// network/discovery/src/rest.rs:48
let validator_set = rest_client.get_account_resource_bcs::<ValidatorSet>(
    AccountAddress::ONE,
    "0x1::stake::ValidatorSet",
).await?;
// No state proof verification occurs

// 4. The VFN will connect to attacker peers on Public network
// These peers receive MediumPriority despite being Unknown:
// state-sync/aptos-data-client/src/priority.rs:93-95

// 5. During state sync with no HighPriority peers available,
// the VFN will request data from the attacker's MediumPriority peers:
// state-sync/aptos-data-client/src/client.rs:265-280

// 6. Attacker can now:
// - Refuse to serve data (DoS)
// - Serve old but valid state (eclipse attack)
// - Manipulate non-verified responses
```

**Notes:**
The vulnerability is real but impact-limited. State sync's signature verification prevents direct state corruption, but the ability to inject malicious peers with `MediumPriority` violates security assumptions and enables DoS/eclipse attacks. The severity is **Medium** rather than High/Critical due to these mitigating factors.

### Citations

**File:** network/discovery/src/rest.rs (L46-59)
```rust
        // Retrieve the onchain resource at the interval
        // TODO there should be a better way than converting this to a blocking call
        let response = block_on(self.rest_client.get_account_resource_bcs::<ValidatorSet>(
            AccountAddress::ONE,
            "0x1::stake::ValidatorSet",
        ));
        Poll::Ready(match response {
            Ok(inner) => {
                let validator_set = inner.into_inner();
                Some(Ok(extract_validator_set_updates(
                    self.network_context,
                    validator_set,
                )))
            },
```

**File:** crates/aptos-rest-client/src/lib.rs (L1209-1221)
```rust
    pub async fn get_account_resource_bcs<T: DeserializeOwned>(
        &self,
        address: AccountAddress,
        resource_type: &str,
    ) -> AptosResult<Response<T>> {
        let url = self.build_path(&format!(
            "accounts/{}/resource/{}",
            address.to_hex(),
            resource_type
        ))?;
        let response = self.get_bcs(url).await?;
        Ok(response.and_then(|inner| bcs::from_bytes(&inner))?)
    }
```

**File:** state-sync/aptos-data-client/src/priority.rs (L91-101)
```rust
        // Outbound connections should be prioritized over inbound connections.
        // This prioritizes other VFNs/seed peers over regular PFNs.
        return if let Some(metadata) = utils::get_metadata_for_peer(&peers_and_metadata, *peer) {
            if metadata.get_connection_metadata().is_outbound_connection() {
                PeerPriority::MediumPriority
            } else {
                PeerPriority::LowPriority
            }
        } else {
            PeerPriority::LowPriority // We don't have connection metadata
        };
```

**File:** network/framework/src/connectivity_manager/mod.rs (L886-898)
```rust
    fn handle_update_discovered_peers(
        &mut self,
        src: DiscoverySource,
        new_discovered_peers: PeerSet,
    ) {
        // Log the update event
        info!(
            NetworkSchema::new(&self.network_context),
            "{} Received updated list of discovered peers! Source: {:?}, num peers: {:?}",
            self.network_context,
            src,
            new_discovered_peers.len()
        );
```

**File:** network/framework/src/noise/handshake.rs (L391-423)
```rust
                    None => {
                        // The peer is not in the trusted peer set. Verify that the Peer ID is
                        // constructed correctly from the public key.
                        let derived_remote_peer_id =
                            aptos_types::account_address::from_identity_public_key(
                                remote_public_key,
                            );
                        if derived_remote_peer_id != remote_peer_id {
                            // The peer ID is not constructed correctly from the public key
                            Err(NoiseHandshakeError::ClientPeerIdMismatch(
                                remote_peer_short,
                                remote_peer_id,
                                derived_remote_peer_id,
                            ))
                        } else {
                            // Try to infer the role from the network context
                            if self.network_context.role().is_validator() {
                                if network_id.is_vfn_network() {
                                    // Inbound connections to validators on the VFN network must be VFNs
                                    Ok(PeerRole::ValidatorFullNode)
                                } else {
                                    // Otherwise, they're unknown. Validators will connect through
                                    // authenticated channels (on the validator network) so shouldn't hit
                                    // this, and PFNs will connect on public networks (which aren't common).
                                    Ok(PeerRole::Unknown)
                                }
                            } else {
                                // We're a VFN or PFN. VFNs get no inbound connections on the vfn network
                                // (so the peer won't be a validator). Thus, we're on the public network
                                // so mark the peer as unknown.
                                Ok(PeerRole::Unknown)
                            }
                        }
```

**File:** state-sync/aptos-data-client/src/client.rs (L265-280)
```rust
    pub(crate) fn choose_peers_for_request(
        &self,
        request: &StorageServiceRequest,
    ) -> crate::error::Result<HashSet<PeerNetworkId>, Error> {
        // Get all peers grouped by priorities
        let peers_by_priorities = self.get_peers_by_priorities()?;

        // Identify the peers that can service the request (ordered by priority)
        let mut serviceable_peers_by_priorities = vec![];
        for priority in PeerPriority::get_all_ordered_priorities() {
            // Identify the serviceable peers for the priority
            let peers = self.identify_serviceable(&peers_by_priorities, priority, request);

            // Add the serviceable peers to the ordered list
            serviceable_peers_by_priorities.push(peers);
        }
```

**File:** state-sync/state-sync-driver/src/utils.rs (L68-82)
```rust
    pub fn expected_next_version(&self) -> Result<Version, Error> {
        self.synced_version.checked_add(1).ok_or_else(|| {
            Error::IntegerOverflow("The expected next version has overflown!".into())
        })
    }

    /// Returns the proof ledger info that all data along the stream should have
    /// proofs relative to. This assumes the proof ledger info exists!
    pub fn get_proof_ledger_info(&self) -> Result<LedgerInfoWithSignatures, Error> {
        self.proof_ledger_info
            .clone()
            .ok_or_else(|| Error::UnexpectedError("The proof ledger info is missing!".into()))
    }

    /// Updates the currently synced version of the stream
```
