# Audit Report

## Title
Faucet Gas Price API Manipulation Leading to Fund Drainage

## Summary
The Aptos faucet's `GasUnitPriceManager::fetch_gas_unit_price()` function blindly trusts the `estimate_gas_price` API response without any validation. A malicious or compromised node API can return extremely high gas prices (up to the VM maximum of 10 billion octas/gas), causing the faucet to drastically overpay on gas fees and drain funds at an accelerated rate.

## Finding Description
The vulnerability exists in the gas price fetching mechanism of the Aptos faucet. The `fetch_gas_unit_price()` function retrieves gas prices from the node API without implementing any bounds checking or sanity validation. [1](#0-0) 

This fetched gas price is then used directly in transaction construction: [2](#0-1) 

The Aptos VM enforces a maximum gas price of 10,000,000,000 octas per gas unit: [3](#0-2) 

The VM validates this limit during transaction processing: [4](#0-3) 

**Attack Scenario:**
1. Attacker compromises or controls the node API endpoint that the faucet connects to (via misconfiguration, MITM attack, or malicious node operator)
2. The API's `estimate_gas_price` endpoint returns near-maximum gas prices (e.g., 9,000,000,000 octas/gas)
3. The faucet accepts this value without validation in `fetch_gas_unit_price()`
4. Each funding transaction uses this inflated gas price
5. With default `max_gas_amount` of 500,000, each transaction costs: 9,000,000,000 × 500,000 = 4,500,000,000,000,000 octas = 4,500,000 APT
6. Normal cost would be: 100 × 500,000 = 50,000,000 octas = 0.05 APT
7. This represents a 90,000,000× increase in gas costs, draining the faucet at an exponentially accelerated rate [5](#0-4) [6](#0-5) 

While a `gas_unit_price_override` configuration option exists, it is optional and many deployments may not set it: [7](#0-6) 

## Impact Explanation
This vulnerability enables **fund drainage** of the faucet through manipulated gas prices. According to Aptos bug bounty criteria, "Limited funds loss or manipulation" constitutes **Medium Severity** (up to $10,000). 

However, the impact could escalate to **High Severity** if:
- The faucet processes many transactions before detection
- The faucet holds substantial funds
- No monitoring alerts exist for abnormal gas costs

The vulnerability breaks the **Resource Limits** invariant: "All operations must respect gas, storage, and computational limits." The faucet should enforce reasonable upper bounds on gas prices rather than blindly trusting external API responses.

## Likelihood Explanation
The likelihood is **Medium** due to:

**Required Conditions:**
- Faucet must connect to a compromised/malicious node API
- `gas_unit_price_override` must not be configured
- No external monitoring of gas costs

**Feasibility:**
- Faucet misconfiguration to connect to malicious endpoints
- Man-in-the-middle attacks on unencrypted API connections  
- Compromised node operator setting malicious `static_override` values
- Legitimate network congestion could also cause abnormally high prices (though unlikely to reach VM maximums)

**Mitigating Factors:**
- Many faucets may use `gas_unit_price_override` configuration
- Faucet operators may monitor fund levels
- HTTPS connections prevent some MITM attacks

## Recommendation
Implement strict validation on gas prices returned from the API:

```rust
async fn fetch_gas_unit_price(&self) -> Result<u64> {
    const MAX_REASONABLE_GAS_PRICE: u64 = 10_000; // 10x normal max
    const MIN_GAS_PRICE: u64 = 100;
    
    let gas_price = self
        .api_client
        .estimate_gas_price()
        .await?
        .into_inner()
        .gas_estimate;
    
    // Validate gas price is within reasonable bounds
    if gas_price < MIN_GAS_PRICE {
        warn!("API returned unreasonably low gas price: {}", gas_price);
        return Ok(MIN_GAS_PRICE);
    }
    
    if gas_price > MAX_REASONABLE_GAS_PRICE {
        error!("API returned unreasonably high gas price: {}. Capping at {}", 
               gas_price, MAX_REASONABLE_GAS_PRICE);
        return Ok(MAX_REASONABLE_GAS_PRICE);
    }
    
    Ok(gas_price)
}
```

**Additional Mitigations:**
1. Make `gas_unit_price_override` mandatory in production configurations
2. Add monitoring/alerting for transactions exceeding expected gas costs
3. Implement circuit breakers that pause faucet operations if gas costs exceed thresholds
4. Log gas price changes prominently for operator awareness

## Proof of Concept
```rust
#[cfg(test)]
mod tests {
    use super::*;
    
    #[tokio::test]
    async fn test_malicious_gas_price_exploitation() {
        // Setup mock API server that returns malicious gas price
        let mock_server = MockServer::start().await;
        
        Mock::given(method("GET"))
            .and(path("/estimate_gas_price"))
            .respond_with(ResponseTemplate::new(200).set_body_json(json!({
                "gas_estimate": 9_000_000_000u64, // Near VM maximum
                "deprioritized_gas_estimate": 100,
                "prioritized_gas_estimate": 1000
            })))
            .mount(&mock_server)
            .await;
        
        // Create GasUnitPriceManager pointing to mock server
        let manager = GasUnitPriceManager::new(
            mock_server.uri().parse().unwrap(),
            Duration::from_secs(30)
        );
        
        // Fetch gas price - should return malicious value without validation
        let gas_price = manager.get_gas_unit_price().await.unwrap();
        
        assert_eq!(gas_price, 9_000_000_000);
        
        // Calculate impact with default max_gas_amount of 500,000
        let max_gas_amount = 500_000u64;
        let malicious_cost = gas_price * max_gas_amount;
        let normal_cost = 100u64 * max_gas_amount; // Normal gas price
        
        println!("Malicious transaction cost: {} octas ({} APT)", 
                 malicious_cost, malicious_cost / 100_000_000);
        println!("Normal transaction cost: {} octas ({} APT)", 
                 normal_cost, normal_cost / 100_000_000);
        println!("Cost multiplication factor: {}x", malicious_cost / normal_cost);
        
        // Demonstrates 90,000,000x cost increase
        assert!(malicious_cost / normal_cost > 1_000_000);
    }
}
```

### Citations

**File:** crates/aptos-faucet/core/src/funder/common.rs (L109-111)
```rust
    /// If given, we'll use this value for the gas unit price. If not, we'll use
    /// the gas unit price estimation API periodically.
    pub gas_unit_price_override: Option<u64>,
```

**File:** crates/aptos-faucet/core/src/funder/common.rs (L113-115)
```rust
    /// The maximum amount of gas to spend on a single transfer.
    #[serde(default = "TransactionSubmissionConfig::default_max_gas_amount")]
    pub max_gas_amount: u64,
```

**File:** crates/aptos-faucet/core/src/funder/common.rs (L157-159)
```rust
    fn default_max_gas_amount() -> u64 {
        500_000
    }
```

**File:** crates/aptos-faucet/core/src/funder/common.rs (L440-447)
```rust
    async fn fetch_gas_unit_price(&self) -> Result<u64> {
        Ok(self
            .api_client
            .estimate_gas_price()
            .await?
            .into_inner()
            .gas_estimate)
    }
```

**File:** crates/aptos-faucet/core/src/funder/transfer.rs (L211-214)
```rust
        let transaction_factory = self
            .transaction_factory
            .clone()
            .with_gas_unit_price(self.get_gas_unit_price().await?);
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L66-71)
```rust
        // The maximum gas unit price that a transaction can be submitted with.
        [
            max_price_per_gas_unit: FeePerGasUnit,
            "max_price_per_gas_unit",
            10_000_000_000
        ],
```

**File:** aptos-move/aptos-vm/src/gas.rs (L194-208)
```rust
    // The submitted gas price is greater than the maximum gas unit price set by the VM.
    if txn_metadata.gas_unit_price() > txn_gas_params.max_price_per_gas_unit {
        speculative_warn!(
            log_context,
            format!(
                "[VM] Gas unit error; max {}, submitted {}",
                txn_gas_params.max_price_per_gas_unit,
                txn_metadata.gas_unit_price()
            ),
        );
        return Err(VMStatus::error(
            StatusCode::GAS_UNIT_PRICE_ABOVE_MAX_BOUND,
            None,
        ));
    }
```
