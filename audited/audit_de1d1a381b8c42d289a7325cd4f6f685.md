# Audit Report

## Title
Consensus Node Crash Due to Unvalidated Author in Decoded AugDataId from Corrupted Database

## Summary
The `decode_key()` function for `AugDataId` in the randomness generation storage layer performs BCS deserialization without validating that the decoded `Author` is a valid validator address. When the consensus node loads corrupted certified augmented data from the database at startup, it attempts to use an invalid author in operations that expect only valid validators, causing an unrecoverable panic that prevents the node from starting.

## Finding Description

The vulnerability exists in the consensus randomness generation subsystem's storage layer. When a consensus node starts up, it initializes the `AugDataStore` by loading all persisted augmented data from the database: [1](#0-0) 

The database uses `AugDataSchema` to decode keys and values. The `decode_key()` implementation simply deserializes the `AugDataId` structure using BCS without any validation: [2](#0-1) 

The `AugDataId` structure contains an `Author` field representing a validator address: [3](#0-2) 

After loading the data, the initialization code iterates over each certified augmented data entry and calls the `augment()` method: [4](#0-3) 

The `augment()` method calls `add_certified_delta()` with the author from the loaded data: [5](#0-4) 

This eventually calls `get_pk_share()` which needs to look up the validator index: [6](#0-5) 

The `get_id()` method attempts to find the author in the validator set and **panics** if it's not found: [7](#0-6) 

**Attack Path:**
1. Database file becomes corrupted (filesystem corruption, malicious modification, or bug in write path)
2. Corrupted entry contains an `AugDataId` with an invalid `Author` that is not in the current epoch's validator set
3. Consensus node restarts and attempts to initialize
4. `AugDataStore::new()` loads the corrupted data without validation
5. Calls `augment()` → `add_certified_delta()` → `derive_apk()` → `get_pk_share()` → `get_id()`
6. `get_id()` panics with "Peer should be in the index!"
7. Node crashes and cannot recover without manual database cleanup

The `RandManager` is instantiated during consensus initialization without error handling around `AugDataStore::new()`: [8](#0-7) 

## Impact Explanation

This vulnerability causes **Denial of Service** against validator nodes, meeting **High Severity** criteria per Aptos bug bounty categories:
- **Validator node crashes**: The affected node cannot start and participate in consensus
- **Network availability impact**: If multiple validators are affected by the same corruption pattern, the network's consensus capacity is reduced
- **Unrecoverable without manual intervention**: Requires manual database cleanup or rollback to recover

While this doesn't directly cause consensus safety violations or fund loss, it compromises network **liveness and availability**, which are critical consensus invariants. The panic occurs during epoch initialization, preventing the validator from participating in consensus until the corrupted data is manually removed.

## Likelihood Explanation

**Medium to High Likelihood:**

Database corruption can occur through multiple vectors:
1. **Filesystem corruption**: Hardware failures, power loss, or filesystem bugs can corrupt the RocksDB database files
2. **Software bugs**: Bugs in the database write path or concurrent access issues could write inconsistent data
3. **Malicious local access**: An attacker with filesystem access (compromised host, malicious admin) could inject corrupted entries
4. **Migration/upgrade issues**: Epoch transitions or software upgrades could expose edge cases where invalid data is written

The vulnerability is especially concerning because:
- No validation exists between deserialization and use
- The panic is unrecoverable without manual intervention
- The error message provides limited diagnostic information
- Multiple validators could be affected by correlated corruption (e.g., same software bug)

## Recommendation

Add validation immediately after decoding the `AugDataId` to ensure the author is in the current validator set. The validation should fail gracefully with a warning rather than panicking:

**Option 1: Validate in decode_key (less flexible)**
```rust
impl<D: TAugmentedData> KeyCodec<AugDataSchema<D>> for AugDataId {
    fn decode_key(data: &[u8]) -> anyhow::Result<Self> {
        let id: AugDataId = bcs::from_bytes(data)?;
        // Note: Cannot validate against validator set here without RandConfig
        Ok(id)
    }
}
```

**Option 2: Validate during loading (recommended)**
```rust
impl<D: TAugmentedData> AugDataStore<D> {
    pub fn new(
        epoch: u64,
        signer: Arc<ValidatorSigner>,
        config: RandConfig,
        fast_config: Option<RandConfig>,
        db: Arc<dyn RandStorage<D>>,
    ) -> Self {
        let all_certified_data = db.get_all_certified_aug_data().unwrap_or_default();
        let (to_remove, mut certified_data) =
            Self::filter_by_epoch(epoch, all_certified_data.into_iter());
        
        // ADDED: Filter out entries with invalid authors
        let (mut invalid_authors, certified_data): (Vec<_>, Vec<_>) = certified_data
            .into_iter()
            .partition(|(id, _)| {
                config.validator
                    .address_to_validator_index()
                    .get(&id.author())
                    .is_none()
            });
        
        if !invalid_authors.is_empty() {
            error!(
                "[AugDataStore] Detected {} certified aug data entries with invalid authors (not in validator set), removing them",
                invalid_authors.len()
            );
            to_remove.extend(invalid_authors.into_iter().map(|(_, data)| data));
        }
        
        if let Err(e) = db.remove_certified_aug_data(to_remove) {
            error!(
                "[AugDataStore] failed to remove invalid certified aug data: {:?}",
                e
            );
        }

        // Continue with validated data...
        for (_, certified_data) in &certified_data {
            // Safe to call augment() now - author is validated
            certified_data
                .data()
                .augment(&config, &fast_config, certified_data.author());
        }
        
        // ... rest of initialization
    }
}
```

Additionally, improve error handling in `RandConfig::get_id()`:
```rust
pub fn get_id(&self, peer: &Author) -> anyhow::Result<usize> {
    self.validator
        .address_to_validator_index()
        .get(peer)
        .copied()
        .ok_or_else(|| anyhow!("Author {} not found in validator set", peer))
}
```

## Proof of Concept

**Rust Test Demonstrating the Panic:**

```rust
#[test]
#[should_panic(expected = "Peer should be in the index!")]
fn test_corrupted_aug_data_id_causes_panic() {
    use aptos_consensus_types::common::Author;
    use aptos_crypto::ed25519::Ed25519PrivateKey;
    use aptos_types::validator_signer::ValidatorSigner;
    use consensus::rand::rand_gen::storage::db::RandDb;
    use consensus::rand::rand_gen::types::{AugmentedData, CertifiedAugData, AugData, AugDataId};
    use std::sync::Arc;
    use tempfile::TempDir;
    
    // Create a temporary database
    let tmpdir = TempDir::new().unwrap();
    let db = Arc::new(RandDb::new(tmpdir.path()));
    
    // Create a corrupted AugDataId with an invalid author (not in validator set)
    let invalid_author = Author::random(); // Random author not in any validator set
    let corrupted_id = AugDataId::new(1, invalid_author);
    
    // Create augmented data with the corrupted author
    let aug_data = AugData::new(1, invalid_author, AugmentedData::mock());
    let certified_data = CertifiedAugData::new(aug_data, AggregateSignature::empty());
    
    // Directly write to database (simulating corruption)
    db.save_certified_aug_data(&certified_data).unwrap();
    
    // Create a minimal validator set (without the corrupted author)
    let valid_author = Author::random();
    let private_key = Ed25519PrivateKey::generate_for_testing();
    let signer = Arc::new(ValidatorSigner::new(valid_author, private_key));
    
    // Create RandConfig with the valid validator set
    let validator_verifier = /* construct minimal verifier */;
    let rand_config = RandConfig::new(/* params with validator_verifier */);
    
    // This will panic when trying to augment data with the invalid author
    let _store = AugDataStore::<AugmentedData>::new(
        1, // epoch
        signer,
        rand_config,
        None,
        db,
    );
    // Panic occurs in augment() -> add_certified_delta() -> get_id()
}
```

**Notes:**
- The vulnerability requires corrupted database state but represents a **robustness failure** in consensus-critical code
- Proper input validation on data loaded from persistent storage is a fundamental security requirement
- The lack of validation violates defensive programming principles for consensus systems
- The unrecoverable panic prevents validator participation until manual intervention

### Citations

**File:** consensus/src/rand/rand_gen/aug_data_store.rs (L57-60)
```rust
        let all_certified_data = db.get_all_certified_aug_data().unwrap_or_default();
        let (to_remove, certified_data) =
            Self::filter_by_epoch(epoch, all_certified_data.into_iter());
        if let Err(e) = db.remove_certified_aug_data(to_remove) {
```

**File:** consensus/src/rand/rand_gen/aug_data_store.rs (L67-71)
```rust
        for (_, certified_data) in &certified_data {
            certified_data
                .data()
                .augment(&config, &fast_config, certified_data.author());
        }
```

**File:** consensus/src/rand/rand_gen/storage/schema.rs (L52-54)
```rust
    fn decode_key(data: &[u8]) -> anyhow::Result<Self> {
        Ok(bcs::from_bytes(data)?)
    }
```

**File:** consensus/src/rand/rand_gen/types.rs (L184-187)
```rust
        let AugmentedData { delta, fast_delta } = self;
        rand_config
            .add_certified_delta(author, delta.clone())
            .expect("Add delta should succeed");
```

**File:** consensus/src/rand/rand_gen/types.rs (L437-440)
```rust
pub struct AugDataId {
    epoch: u64,
    author: Author,
}
```

**File:** consensus/src/rand/rand_gen/types.rs (L630-636)
```rust
    pub fn get_id(&self, peer: &Author) -> usize {
        *self
            .validator
            .address_to_validator_index()
            .get(peer)
            .expect("Peer should be in the index!")
    }
```

**File:** consensus/src/rand/rand_gen/types.rs (L671-674)
```rust
    pub fn get_pk_share(&self, peer: &Author) -> &PKShare {
        let index = self.get_id(peer);
        &self.keys.pk_shares[index]
    }
```

**File:** consensus/src/pipeline/execution_client.rs (L240-251)
```rust
        let rand_manager = RandManager::<Share, AugmentedData>::new(
            self.author,
            epoch_state.clone(),
            signer,
            rand_config,
            fast_rand_config,
            rand_ready_block_tx,
            network_sender.clone(),
            self.rand_storage.clone(),
            self.bounded_executor.clone(),
            &self.consensus_config.rand_rb_config,
        );
```
