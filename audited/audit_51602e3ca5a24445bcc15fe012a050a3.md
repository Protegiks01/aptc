# Audit Report

## Title
Insufficient Gas Metering for Module Deserialization Enables Validator CPU Exhaustion

## Summary
Module deserialization occurs between two separate gas charging phases, allowing attackers to cause expensive CPU work on validators before adequate gas charges are enforced. The initial charge of 7 gas/byte in the native function is insufficient to cover worst-case deserialization complexity.

## Finding Description

During module publishing, gas is charged in a split manner across two different code locations:

**Phase 1 - Native Function (Inadequate Initial Charge):** [1](#0-0) 

The native function charges only `1838 + 7 * module_size` internal gas units.

**Phase 2 - Unmetered Deserialization:** [2](#0-1) 

Deserialization happens WITHOUT any gas metering, calling: [3](#0-2) 

Which invokes: [4](#0-3) 

This includes both parsing and bounds checking without gas instrumentation.

**Phase 3 - Dependency Charge (Too Late):** [5](#0-4) 

The main dependency charge of `74460 + 42 * size` only happens AFTER deserialization completes.

**Gas Parameter Values:** [6](#0-5) [7](#0-6) 

**Exploitation Vector:**

An attacker can craft a 1MB governance transaction with a module containing:
- Maximum table entries (65,535 per table across 20+ table types)
- Deeply nested signatures (up to 256 levels via `SIGNATURE_TOKEN_DEPTH_MAX`)
- Maximum bytecode instructions (65,535 per function)
- Complex cross-references requiring extensive bounds checking

The deserialization performs:
1. ULEB128 decoding for ~1M+ variable-length integers
2. Recursive signature parsing (256 depth Ã— 65K signatures)
3. Comprehensive bounds checking across all tables
4. Bytecode validation for all 65K instructions

For a 1MB module, only **7,341,870** internal gas units are charged upfront, but deserialization could consume **50-100ms of CPU time** on validator nodes before the main 44M gas charge is applied.

## Impact Explanation

**Severity: Medium**

This breaks the **Resource Limits** invariant (#9): "All operations must respect gas, storage, and computational limits."

An attacker can:
1. Submit multiple transactions with maximally complex 1MB modules
2. Cause validators to spend 50-100ms per transaction on deserialization
3. Each validator processes this during block execution before adequate gas validation
4. With sufficient volume, this causes validator slowdowns and impacts block production times

This meets **High Severity** criteria per Aptos bug bounty: "Validator node slowdowns" and "Significant protocol violations" (gas metering bypass for expensive operations).

## Likelihood Explanation

**Likelihood: High**

- No special privileges required - any user can submit module publish transactions
- Governance transactions allow 1MB payloads, providing maximum attack surface
- Transaction size limits are the only barrier, but 1MB is sufficient for exploitation
- The attack is deterministic and reproducible
- Cost to attacker is minimal (only transaction fees based on inadequate gas charges)

## Recommendation

**Implement gas-metered deserialization by passing the gas meter into the deserialization pipeline:**

```rust
fn deserialize_module_bundle(
    &self, 
    modules: &ModuleBundle,
    gas_meter: &mut impl AptosGasMeter  // Add gas meter parameter
) -> VMResult<Vec<CompiledModule>> {
    let mut result = vec![];
    for module_blob in modules.iter() {
        // Charge incremental gas during deserialization
        gas_meter.charge_dependency(
            DependencyKind::Deserialization,
            &AccountAddress::ZERO,
            ident_str!(""),
            NumBytes::new(module_blob.code().len() as u64)
        )?;
        
        match CompiledModule::deserialize_with_config(
            module_blob.code(),
            self.deserializer_config(),
        ) {
            Ok(module) => result.push(module),
            Err(_err) => {
                return Err(PartialVMError::new(StatusCode::CODE_DESERIALIZATION_ERROR)
                    .finish(Location::Undefined))
            },
        }
    }
    Ok(result)
}
```

Move the deserialization charge before deserialization: [2](#0-1) 

Should be reordered to charge BEFORE calling `deserialize_module_bundle()`.

## Proof of Concept

```rust
// Rust test demonstrating the issue
#[test]
fn test_unmetered_deserialization_dos() {
    use move_binary_format::file_format::*;
    use std::time::Instant;
    
    // Create a module with maximum complexity
    let mut module = CompiledModule::default();
    
    // Add 65,535 signatures with deep nesting (256 levels)
    for i in 0..65535 {
        let mut sig_tokens = vec![];
        let mut nested_type = SignatureToken::U64;
        for _ in 0..256 {
            nested_type = SignatureToken::Vector(Box::new(nested_type));
        }
        sig_tokens.push(nested_type);
        module.signatures.push(Signature(sig_tokens));
    }
    
    // Serialize the module
    let bytes = module.serialize().unwrap();
    
    // Time deserialization
    let start = Instant::now();
    let _ = CompiledModule::deserialize(&bytes);
    let duration = start.elapsed();
    
    println!("Module size: {} bytes", bytes.len());
    println!("Deserialization time: {:?}", duration);
    println!("Gas charged (7 gas/byte): {}", 7 * bytes.len());
    
    // Assert that deserialization takes significant time
    // but only minimal gas was charged upfront
    assert!(duration.as_millis() > 10, "Deserialization should take >10ms");
}
```

**Notes:**
The vulnerability exists because deserialization happens in an unmetered code path between two gas charging phases. The initial 7 gas/byte charge is calibrated for simple data copying, not for complex recursive parsing and validation. This allows attackers to cause disproportionate CPU consumption on validators relative to gas paid.

### Citations

**File:** aptos-move/framework/src/natives/code.rs (L292-301)
```rust
    context.charge(CODE_REQUEST_PUBLISH_BASE)?;

    let policy = safely_pop_arg!(args, u8);
    let mut code = vec![];
    for module in safely_pop_arg!(args, Vec<Value>) {
        let module_code = module.value_as::<Vec<u8>>()?;

        context.charge(CODE_REQUEST_PUBLISH_PER_BYTE * NumBytes::new(module_code.len() as u64))?;
        code.push(module_code);
    }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1444-1461)
```rust
    fn deserialize_module_bundle(&self, modules: &ModuleBundle) -> VMResult<Vec<CompiledModule>> {
        let mut result = vec![];
        for module_blob in modules.iter() {
            match CompiledModule::deserialize_with_config(
                module_blob.code(),
                self.deserializer_config(),
            ) {
                Ok(module) => {
                    result.push(module);
                },
                Err(_err) => {
                    return Err(PartialVMError::new(StatusCode::CODE_DESERIALIZATION_ERROR)
                        .finish(Location::Undefined))
                },
            }
        }
        Ok(result)
    }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1491-1493)
```rust
        let modules = self.deserialize_module_bundle(&bundle)?;
        let modules: &Vec<CompiledModule> =
            traversal_context.referenced_module_bundles.alloc(modules);
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1525-1543)
```rust
            // Charge all modules in the bundle that is about to be published.
            for (module, blob) in modules.iter().zip(bundle.iter()) {
                let addr = module.self_addr();
                let name = module.self_name();
                gas_meter
                    .charge_dependency(
                        DependencyKind::New,
                        addr,
                        name,
                        NumBytes::new(blob.code().len() as u64),
                    )
                    .map_err(|err| err.finish(Location::Undefined))?;

                // In case of lazy loading: add all modules in a bundle as visited to avoid double
                // charging during module initialization.
                if self.features().is_lazy_loading_enabled() {
                    traversal_context.visit_if_not_special_address(addr, name);
                }
            }
```

**File:** third_party/move/move-binary-format/src/deserializer.rs (L52-71)
```rust
    pub fn deserialize_with_config(
        binary: &[u8],
        config: &DeserializerConfig,
    ) -> BinaryLoaderResult<Self> {
        let prev_state = move_core_types::state::set_state(VMState::DESERIALIZER);
        let result = std::panic::catch_unwind(|| {
            let module = deserialize_compiled_module(binary, config)?;
            BoundsChecker::verify_module(&module)?;

            Ok(module)
        })
        .unwrap_or_else(|_| {
            Err(PartialVMError::new(
                StatusCode::VERIFIER_INVARIANT_VIOLATION,
            ))
        });
        move_core_types::state::set_state(prev_state);

        result
    }
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/aptos_framework.rs (L320-321)
```rust
        [code_request_publish_base: InternalGas, "code.request_publish.base", 1838],
        [code_request_publish_per_byte: InternalGasPerByte, "code.request_publish.per_byte", 7],
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L241-249)
```rust
            dependency_per_module: InternalGas,
            { RELEASE_V1_10.. => "dependency_per_module" },
            74460,
        ],
        [
            dependency_per_byte: InternalGasPerByte,
            { RELEASE_V1_10.. => "dependency_per_byte" },
            42,
        ],
```
