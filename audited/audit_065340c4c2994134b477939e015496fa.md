# Audit Report

## Title
Storage Refunds Lost When Gas Meter Consistency Check Fails During Success Epilogue

## Summary
Users lose legitimate storage deletion refunds when a transaction successfully executes and deletes storage, but then fails the gas meter consistency check during the success epilogue. The transaction is re-processed as a failed transaction with `ZERO_STORAGE_REFUND`, causing fund loss.

## Finding Description

The `clear_refunds()` function in `fee_statement.rs` is never called in the codebase - it is dead code. [1](#0-0) 

However, there exists a related vulnerability where storage refunds are incorrectly eliminated during transaction processing. When a transaction:

1. **Successfully executes** and deletes storage items
2. **Calculates a storage refund** in `charge_change_set` [2](#0-1) 
3. **Stores the refund** in the epilogue session [3](#0-2) 
4. **Fails the gas meter consistency check** in `success_transaction_cleanup` [4](#0-3) 

The error propagates up through `execute_script_or_entry_function` [5](#0-4)  and is caught by error handling that retries the transaction as a **failure** [6](#0-5) 

The failure cleanup path calls `finish_aborted_transaction`, which creates a fee statement with `ZERO_STORAGE_REFUND` based on the incorrect assumption that "no slots are deleted in aborted transactions" [7](#0-6)  and [8](#0-7) 

This violates the **Transaction Validation** invariant that epilogue checks must correctly process all transaction fees and refunds.

## Impact Explanation

**Medium Severity** - Limited funds loss or manipulation.

Users lose storage deletion refunds when this occurs. The amount depends on:
- Number of storage slots deleted (each has a deposit)
- Bytes freed (byte-level deposits)
- Current storage pricing parameters

This meets the Medium severity criteria per the Aptos bug bounty program as it results in limited but real fund loss for affected users.

## Likelihood Explanation

**Low to Medium Likelihood**

The gas meter consistency check validates that `initial_balance - balance == execution_gas + io_gas + storage_fee_in_internal_units` [9](#0-8) 

This check only fails when:
1. There are bugs in gas metering arithmetic
2. Edge cases in gas conversion calculations
3. Unexpected interactions between different gas categories

While designed to be rare, the complexity of gas metering (with execution, IO, and storage fees tracked separately, plus conversions between internal/external units and octas) creates opportunities for subtle accounting errors that could trigger this condition.

## Recommendation

Store the calculated storage refund before entering the success epilogue, and restore it if the epilogue fails and the transaction must be retried as a failure:

```rust
fn success_transaction_cleanup(
    &self,
    mut epilogue_session: EpilogueSession,
    // ... other params
) -> Result<(VMStatus, VMOutput), VMStatus> {
    // Store refund BEFORE consistency check
    let calculated_storage_refund = epilogue_session.get_storage_fee_refund();
    
    if self.gas_feature_version() >= 12 {
        if let Err(err) = gas_meter.algebra().check_consistency() {
            // Return error WITH the refund information so it can be preserved
            return Err(VMStatus::with_storage_refund(
                err.finish(Location::Undefined).into(),
                calculated_storage_refund
            ));
        }
    }
    // ... rest of function
}
```

And in `finish_aborted_transaction`, check if the error contains a preserved refund:

```rust
fn finish_aborted_transaction(
    &self,
    error_vm_status: VMStatus, // Now potentially contains refund info
    // ... other params  
) -> Result<VMOutput, VMStatus> {
    let storage_refund = error_vm_status.extract_storage_refund()
        .unwrap_or(0); // Only zero if truly aborted, not if failed during epilogue
    
    let fee_statement = AptosVM::fee_statement_from_gas_meter(
        txn_data, 
        gas_meter, 
        storage_refund
    );
    // ... rest of function
}
```

## Proof of Concept

While difficult to trigger deterministically (requires inducing gas meter inconsistency), the vulnerability can be demonstrated through code inspection:

**Step 1**: Transaction deletes a storage slot worth 100 octas
**Step 2**: `charge_change_set` calculates `storage_refund = 100`  
**Step 3**: Gas meter develops inconsistency (e.g., through arithmetic overflow in conversion)
**Step 4**: `success_transaction_cleanup` consistency check fails
**Step 5**: Error handling calls `finish_aborted_transaction` with `ZERO_STORAGE_REFUND`
**Step 6**: User charged full fee without receiving the 100 octa refund

The code paths are clearly present in the implementation, as demonstrated by the citations above.

## Notes

The `clear_refunds()` function itself is dead code and never called. However, the broader question about storage refunds being eliminated at unexpected points is valid - they are zeroed when transactions fail during the success epilogue due to gas meter consistency failures, which is an incorrect assumption about transaction state.

### Citations

**File:** types/src/fee_statement.rs (L70-72)
```rust
    pub fn clear_refunds(&mut self) {
        self.storage_fee_refund_octas = 0;
    }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L702-703)
```rust
        // Storage refund is zero since no slots are deleted in aborted transactions.
        const ZERO_STORAGE_REFUND: u64 = 0;
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L757-757)
```rust
                AptosVM::fee_statement_from_gas_meter(txn_data, gas_meter, ZERO_STORAGE_REFUND);
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L840-846)
```rust
            if let Err(err) = gas_meter.algebra().check_consistency() {
                println!(
                    "[aptos-vm][gas-meter][success-epilogue] {}",
                    err.message()
                        .unwrap_or("No message found -- this should not happen.")
                );
                return Err(err.finish(Location::Undefined).into());
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1100-1100)
```rust
        self.success_transaction_cleanup(
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1150-1156)
```rust
        let storage_refund = self.charge_change_set(
            &mut user_session_change_set,
            gas_meter,
            txn_data,
            resolver,
            module_storage,
        )?;
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1159-1165)
```rust
        Ok(EpilogueSession::on_user_session_success(
            self,
            txn_data,
            resolver,
            user_session_change_set,
            storage_refund,
        ))
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L2105-2118)
```rust
        let (vm_status, mut output) = result.unwrap_or_else(|err| {
            self.on_user_transaction_execution_failure(
                prologue_change_set,
                err,
                resolver,
                code_storage,
                &serialized_signers,
                &txn_data,
                log_context,
                gas_meter,
                change_set_configs,
                &mut traversal_context,
            )
        });
```

**File:** aptos-move/aptos-gas-meter/src/algebra.rs (L138-170)
```rust
    fn check_consistency(&self) -> PartialVMResult<()> {
        let total = self
            .initial_balance
            .checked_sub(self.balance)
            .ok_or_else(|| {
                PartialVMError::new(StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR).with_message(
                    format!(
                        "Current balance ({}) exceedes the initial balance ({}) -- how is this ever possible?",
                        self.balance,
                        self.initial_balance
                    ),
                )
            })?;

        let total_calculated =
            self.execution_gas_used + self.io_gas_used + self.storage_fee_in_internal_units;
        if total != total_calculated {
            return Err(
                PartialVMError::new(StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR).with_message(
                    format!(
                        "The per-category costs do not add up. {} (total) != {} = {} (exec) + {} (io) + {} (storage)",
                        total,
                        total_calculated,
                        self.execution_gas_used,
                        self.io_gas_used,
                        self.storage_fee_in_internal_units,
                    ),
                ),
            );
        }

        Ok(())
    }
```
