# Audit Report

## Title
Backup System Allows Unvalidated Transaction Proofs Leading to State Corruption and Consensus Fork

## Summary
The transaction backup system fetches cryptographic proofs from the backup service without any validation during the backup phase. During restore, signature verification of these proofs is optional and can be completely bypassed when using the `--skip-epoch-endings` flag or when restoring epochs newer than the local epoch history. This allows an attacker controlling a backup service to create fake but internally-consistent backups that pass verification, leading to permanent state corruption and potential network-wide consensus forks.

## Finding Description

The vulnerability exists in a two-phase attack:

**Phase 1 - Backup (No Validation):**
The `TransactionBackupController::write_chunk` method fetches transaction range proofs from the client and writes them directly to storage without any cryptographic validation: [1](#0-0) 

The `get_transaction_range_proof` method simply makes an HTTP request and returns the raw stream: [2](#0-1) 

**Phase 2 - Restore (Optional Signature Verification):**
During restore, the proof validation is conditional on the presence of `epoch_history`: [3](#0-2) 

The `epoch_history` parameter is optional and explicitly set to `None` in several scenarios:

1. When using the `--skip-epoch-endings` flag in the restore coordinator: [4](#0-3) 

2. In one-off transaction restores via db-tool: [5](#0-4) 

**Even When Epoch History Exists - Weak Verification:**
If the epoch is newer than the available epoch history, signature verification is skipped with only a warning: [6](#0-5) 

**What IS Verified:**
The restore process only verifies internal cryptographic consistency - that transaction hashes match transaction infos and that the accumulator proof validates against the ledger info's root hash: [7](#0-6) [8](#0-7) 

However, this does NOT verify that the LedgerInfo itself is authentic (signed by a quorum of validators).

**Attack Scenario:**
1. Attacker compromises a backup service OR convinces victim to use a malicious backup service
2. Attacker creates a fake but internally-consistent backup containing:
   - Arbitrary transactions (e.g., minting tokens to attacker's account)
   - Matching TransactionInfo structures (with correct hashes)
   - A valid AccumulatorRangeProof that proves these infos exist in a fake accumulator
   - A forged LedgerInfo (without valid validator signatures) with a matching transaction_accumulator_hash
3. Victim performs restore using either:
   - The `--skip-epoch-endings` flag, OR
   - Restoring from a future epoch beyond their epoch_history
4. The fake backup passes all cryptographic consistency checks
5. Node starts with completely fabricated state
6. If multiple validators restore from the same fake backup, the network experiences a consensus fork

This violates the fundamental **Consensus Safety** invariant: "AptosBFT must prevent double-spending and chain splits under < 1/3 Byzantine" and the **State Consistency** invariant: "State transitions must be atomic and verifiable via Merkle proofs."

## Impact Explanation

**Critical Severity - Consensus/Safety Violation**

This vulnerability enables:
- **Network Fork**: If multiple validators restore from the same malicious backup, they will have divergent state, causing a permanent consensus split requiring a hard fork to resolve
- **State Corruption**: Arbitrary state can be injected into the database, including fake token balances, validator sets, or governance proposals
- **Total Network Compromise**: With sufficient social engineering, an attacker could distribute fake backups that fundamentally alter the blockchain's history and state

This meets the **Critical Severity** criteria per Aptos bug bounty program:
- "Consensus/Safety violations" - Direct violation of consensus safety guarantees
- "Non-recoverable network partition (requires hardfork)" - Would require coordinated hard fork to fix if multiple nodes are affected
- "Permanent freezing of funds (requires hardfork)" - Fake state could render real funds inaccessible

The impact is severe because it completely bypasses the BFT consensus mechanism's security guarantees by allowing state injection through the backup/restore path.

## Likelihood Explanation

**Medium-to-High Likelihood**

The attack is realistic because:

1. **Common Use Case**: Operators frequently restore nodes from backups during:
   - Initial node setup
   - Disaster recovery
   - Network migration
   - Testing/development

2. **Easy to Trigger**: The `--skip-epoch-endings` flag is a documented option that operators might use for:
   - Faster restore times
   - Debugging purposes
   - When epoch ending data is unavailable

3. **Trust Assumption**: Operators typically trust their backup sources, making social engineering feasible

4. **Future Epoch Bypass**: The automatic bypass for future epochs (with only a warning logged) means even well-intentioned operators with incomplete epoch history will skip verification

The attack requires:
- Compromising a backup service OR convincing an operator to use a malicious backup source
- No validator collusion or consensus participation needed
- No sophisticated cryptographic attacks required

## Recommendation

**Immediate Fix:**

1. **Mandatory Signature Verification**: Always verify LedgerInfo signatures during restore. Remove the `--skip-epoch-endings` option or make it only skip storage of epoch endings while still verifying signatures:

```rust
// In LoadedChunk::load (restore.rs)
let (range_proof, ledger_info) = storage
    .load_bcs_file::<(TransactionAccumulatorRangeProof, LedgerInfoWithSignatures)>(
        &manifest.proof,
    )
    .await?;

// ALWAYS verify signatures - no bypass
let epoch_history = epoch_history
    .ok_or_else(|| anyhow!("Epoch history required for secure restore. Cannot verify backup without it."))?;
epoch_history.verify_ledger_info(&ledger_info)?;
```

2. **Fix Future Epoch Bypass**: In `EpochHistory::verify_ledger_info`, return an error instead of just warning:

```rust
// In epoch_ending/restore.rs
if epoch > self.epoch_endings.len() as u64 {
    bail!(
        "Cannot verify LedgerInfo for epoch {} - only have history up to epoch {}. \
        Please restore epoch endings first.",
        epoch,
        self.epoch_endings.len()
    );
}
```

3. **Add Backup-Time Validation**: Optionally verify proofs during backup against a trusted local ledger info to catch issues early:

```rust
// In backup.rs write_chunk
let proof_bytes = self
    .client
    .get_transaction_range_proof(first_version, last_version)
    .await?;

// Validate proof if we have local state
if let Some(local_ledger_info) = self.get_local_ledger_info() {
    let (proof, ledger_info): (TransactionAccumulatorRangeProof, LedgerInfoWithSignatures) = 
        bcs::from_bytes(&proof_bytes)?;
    // Verify against trusted local state
    verify_proof(&proof, &ledger_info, first_version, last_version)?;
}

tokio::io::copy(&mut proof_bytes.as_slice(), &mut proof_file).await?;
```

## Proof of Concept

```rust
// Proof of Concept: Create a fake backup that passes verification when --skip-epoch-endings is used

use aptos_types::{
    transaction::{Transaction, TransactionInfo, Version},
    ledger_info::{LedgerInfo, LedgerInfoWithSignatures},
    proof::{TransactionAccumulatorRangeProof, AccumulatorRangeProof},
};
use aptos_crypto::HashValue;

#[test]
fn test_fake_backup_bypass() {
    // Step 1: Create fake transactions (e.g., minting tokens to attacker)
    let fake_txns = vec![/* malicious transactions */];
    
    // Step 2: Create matching TransactionInfos with correct hashes
    let fake_txn_infos: Vec<TransactionInfo> = fake_txns
        .iter()
        .map(|txn| {
            TransactionInfo::new(
                CryptoHash::hash(txn),
                HashValue::zero(), // fake state root
                HashValue::zero(), // fake event root
                0, // gas used
                /* ... */
            )
        })
        .collect();
    
    // Step 3: Create a fake accumulator and proof
    let txn_info_hashes: Vec<HashValue> = fake_txn_infos
        .iter()
        .map(CryptoHash::hash)
        .collect();
    
    let fake_accumulator = InMemoryTransactionAccumulator::new(vec![], 0)
        .append(&txn_info_hashes);
    
    let fake_proof = TransactionAccumulatorRangeProof::new(
        vec![], // left siblings
        vec![], // right siblings
    );
    
    // Step 4: Create a fake LedgerInfo (NO VALID SIGNATURES)
    let fake_ledger_info = LedgerInfo::new(
        /* ... */
        fake_accumulator.root_hash(),
        /* ... */
    );
    let fake_ledger_info_with_sigs = LedgerInfoWithSignatures::new(
        fake_ledger_info,
        BTreeMap::new(), // NO SIGNATURES!
    );
    
    // Step 5: Write fake backup to storage
    storage.save_backup(fake_txns, fake_txn_infos, fake_proof, fake_ledger_info_with_sigs);
    
    // Step 6: Restore with --skip-epoch-endings flag
    // The restore will SUCCEED because:
    // 1. Transaction hashes match TransactionInfos ✓
    // 2. AccumulatorRangeProof validates against LedgerInfo root ✓
    // 3. Signature verification is SKIPPED due to epoch_history=None ✗
    
    let restore_result = TransactionRestoreController::new(
        opt,
        global_opt,
        storage,
        None, // epoch_history = None bypasses signature check!
        VerifyExecutionMode::NoVerify,
    ).run().await;
    
    assert!(restore_result.is_ok()); // FAKE BACKUP PASSES VERIFICATION!
}
```

The PoC demonstrates that when `epoch_history` is `None`, a completely fabricated backup with no valid validator signatures passes all verification checks and is restored into the database.

## Notes

This vulnerability is particularly dangerous because:
1. The backup/restore system is designed for operational recovery, so operators trust their backup sources
2. The `--skip-epoch-endings` flag appears to be a performance optimization but actually disables critical security checks
3. The TODO comment in the code indicates the developers were aware this was problematic but hadn't fixed it
4. No warning is shown to operators that signature verification is being bypassed during restore

### Citations

**File:** storage/backup/backup-cli/src/backup_types/transaction/backup.rs (L163-170)
```rust
        tokio::io::copy(
            &mut self
                .client
                .get_transaction_range_proof(first_version, last_version)
                .await?,
            &mut proof_file,
        )
        .await?;
```

**File:** storage/backup/backup-cli/src/utils/backup_service_client.rs (L159-169)
```rust
    pub async fn get_transaction_range_proof(
        &self,
        first_version: Version,
        last_version: Version,
    ) -> Result<impl AsyncRead + use<>> {
        self.get(
            "transaction_range_proof",
            &format!("{}/{}", first_version, last_version,),
        )
        .await
    }
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L152-154)
```rust
        if let Some(epoch_history) = epoch_history {
            epoch_history.verify_ledger_info(&ledger_info)?;
        }
```

**File:** storage/backup/backup-cli/src/coordinators/restore.rs (L219-231)
```rust
        let epoch_history = if !self.skip_epoch_endings {
            Some(Arc::new(
                EpochHistoryRestoreController::new(
                    epoch_handles,
                    self.global_opt.clone(),
                    self.storage.clone(),
                )
                .run()
                .await?,
            ))
        } else {
            None
        };
```

**File:** storage/db-tool/src/restore.rs (L102-110)
```rust
                        TransactionRestoreController::new(
                            opt,
                            global.try_into()?,
                            storage.init_storage().await?,
                            None, /* epoch_history */
                            VerifyExecutionMode::NoVerify,
                        )
                        .run()
                        .await?;
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L276-287)
```rust
    pub fn verify_ledger_info(&self, li_with_sigs: &LedgerInfoWithSignatures) -> Result<()> {
        let epoch = li_with_sigs.ledger_info().epoch();
        ensure!(!self.epoch_endings.is_empty(), "Empty epoch history.",);
        if epoch > self.epoch_endings.len() as u64 {
            // TODO(aldenhu): fix this from upper level
            warn!(
                epoch = epoch,
                epoch_history_until = self.epoch_endings.len(),
                "Epoch is too new and can't be verified. Previous chunks are verified and node \
                won't be able to start if this data is malicious."
            );
            return Ok(());
```

**File:** types/src/transaction/mod.rs (L2295-2336)
```rust
    pub fn verify(
        &self,
        ledger_info: &LedgerInfo,
        first_transaction_version: Option<Version>,
    ) -> Result<()> {
        // Verify the first transaction versions match
        ensure!(
            self.get_first_transaction_version() == first_transaction_version,
            "First transaction version ({:?}) doesn't match given version ({:?}).",
            self.get_first_transaction_version(),
            first_transaction_version,
        );

        // Verify the lengths of the transactions and transaction infos match
        ensure!(
            self.proof.transaction_infos.len() == self.get_num_transactions(),
            "The number of TransactionInfo objects ({}) does not match the number of \
             transactions ({}).",
            self.proof.transaction_infos.len(),
            self.get_num_transactions(),
        );

        // Verify the transaction hashes match those of the transaction infos
        self.transactions
            .par_iter()
            .zip_eq(self.proof.transaction_infos.par_iter())
            .map(|(txn, txn_info)| {
                let txn_hash = CryptoHash::hash(txn);
                ensure!(
                    txn_hash == txn_info.transaction_hash(),
                    "The hash of transaction does not match the transaction info in proof. \
                     Transaction hash: {:x}. Transaction hash in txn_info: {:x}.",
                    txn_hash,
                    txn_info.transaction_hash(),
                );
                Ok(())
            })
            .collect::<Result<Vec<_>>>()?;

        // Verify the transaction infos are proven by the ledger info.
        self.proof
            .verify(ledger_info, self.get_first_transaction_version())?;
```

**File:** types/src/proof/definition.rs (L910-925)
```rust
    pub fn verify(
        &self,
        ledger_info: &LedgerInfo,
        first_transaction_info_version: Option<Version>,
    ) -> Result<()> {
        let txn_info_hashes: Vec<_> = self
            .transaction_infos
            .iter()
            .map(CryptoHash::hash)
            .collect();
        self.ledger_info_to_transaction_infos_proof.verify(
            ledger_info.transaction_accumulator_hash(),
            first_transaction_info_version,
            &txn_info_hashes,
        )
    }
```
