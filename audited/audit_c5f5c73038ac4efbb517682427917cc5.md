# Audit Report

## Title
Panic in Status Endpoint Due to Unchecked Optional Timestamp Fields in StreamProgressSampleProto

## Summary
The `get_throughput_from_samples()` function contains multiple `unwrap()` calls on optional `timestamp` fields without validation. When the grpc-manager receives StreamProgress data with None timestamps via heartbeat messages and renders its status page, the function panics, crashing the status endpoint.

## Finding Description

The vulnerability exists in the `get_throughput_from_samples()` function which processes StreamProgress samples to calculate throughput metrics. [1](#0-0) 

The protobuf definition declares the timestamp field as optional: [2](#0-1) 

This translates to an `Option<Timestamp>` in the generated Rust code: [3](#0-2) 

The function has three critical `unwrap()` calls that will panic if timestamp is None:
1. Line 95 in the `partition_point` closure when iterating through all samples
2. Line 104 when accessing the last sample's timestamp  
3. Line 105 when accessing the indexed sample's timestamp

**Attack Path:**

1. The grpc-manager receives heartbeat messages from data services containing ActiveStream information with StreamProgress data
2. The metadata_manager stores this data without validating timestamp fields: [4](#0-3) 

3. When the grpc-manager status page is accessed, it renders stream information by calling `get_throughput_from_samples()`: [5](#0-4) 

4. If any sample has `timestamp: None`, the `partition_point` closure panics on line 95, or if the indexed/last samples have None timestamps, the function panics on lines 104-105

A malicious data service can craft heartbeat messages with StreamProgress samples containing None timestamps, or protobuf deserialization errors could result in None timestamps, causing the status endpoint to panic and crash.

## Impact Explanation

This qualifies as **High Severity** under the Aptos bug bounty program's "API crashes" category. While this affects the indexer infrastructure rather than core consensus, the grpc-manager is a critical component for transaction indexing. Crashing its status endpoint:
- Denies visibility into system health and active streams
- Can be triggered repeatedly by malicious data services
- Affects operational monitoring and debugging capabilities

The impact is limited to the status/monitoring endpoint rather than transaction processing, but constitutes a clear API availability vulnerability.

## Likelihood Explanation

**Likelihood: Medium to High**

The vulnerability can be triggered by:
1. A malicious or compromised data service sending crafted heartbeat messages
2. Bugs in protobuf serialization/deserialization that produce None timestamps
3. Network corruption or malformed messages

Since data services regularly send heartbeats to the grpc-manager, and there's no validation preventing None timestamps, the attack surface is continuously exposed. Any data service (which doesn't require special privileges to register) can trigger this panic.

## Recommendation

Add validation to check for None timestamps before calling `unwrap()`. Use pattern matching with proper error handling:

```rust
pub fn get_throughput_from_samples(
    progress: Option<&StreamProgress>,
    duration: Duration,
) -> String {
    if let Some(progress) = progress {
        let now = SystemTime::now()
            .duration_since(SystemTime::UNIX_EPOCH)
            .unwrap()
            .as_secs_f64();
        
        let index = progress.samples.partition_point(|p| {
            // Validate timestamp exists
            if let Some(timestamp) = p.timestamp.as_ref() {
                let diff = now - timestamp_to_unixtime(timestamp);
                diff > duration.as_secs_f64()
            } else {
                // Skip samples without timestamps
                true
            }
        });

        if index + 1 < progress.samples.len() {
            let sample_a = progress.samples[index];
            let sample_b = progress.samples.last().unwrap();
            
            // Validate both timestamps exist
            if let (Some(ts_a), Some(ts_b)) = (sample_a.timestamp.as_ref(), sample_b.timestamp.as_ref()) {
                let time_diff = timestamp_to_unixtime(ts_b) - timestamp_to_unixtime(ts_a);
                let tps = (sample_b.version - sample_a.version) as f64 / time_diff;
                let bps = (sample_b.size_bytes - sample_a.size_bytes) as f64 / time_diff;
                return format!(
                    "{} tps, {} / s",
                    tps as u64,
                    bytesize::to_string(bps as u64, false)
                );
            }
        }
    }

    "No data".to_string()
}
```

Additionally, add validation in the metadata_manager when receiving heartbeat data to reject or sanitize samples with None timestamps.

## Proof of Concept

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use aptos_protos::indexer::v1::{StreamProgress, StreamProgressSampleProto};
    use std::time::Duration;

    #[test]
    #[should_panic(expected = "unwrap")]
    fn test_panic_on_none_timestamp() {
        // Create a sample with None timestamp
        let sample = StreamProgressSampleProto {
            timestamp: None,  // This will cause panic
            version: 100,
            size_bytes: 1000,
        };
        
        let progress = StreamProgress {
            samples: vec![sample],
        };
        
        // This call will panic on the unwrap() in partition_point
        let _result = get_throughput_from_samples(
            Some(&progress),
            Duration::from_secs(10),
        );
    }
}
```

To reproduce in the actual system, deploy a malicious data service that sends heartbeat messages with StreamProgress containing samples with `timestamp: None`, then access the grpc-manager status page.

## Notes

The data-service-v2 itself is NOT vulnerable when rendering its own streams because it always creates samples with `Some(timestamp)` via the `to_proto()` method. The vulnerability specifically affects the grpc-manager when it receives and renders external StreamProgress data from data service heartbeats.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/status_page/mod.rs (L85-117)
```rust
pub fn get_throughput_from_samples(
    progress: Option<&StreamProgress>,
    duration: Duration,
) -> String {
    if let Some(progress) = progress {
        let now = SystemTime::now()
            .duration_since(SystemTime::UNIX_EPOCH)
            .unwrap()
            .as_secs_f64();
        let index = progress.samples.partition_point(|p| {
            let diff = now - timestamp_to_unixtime(p.timestamp.as_ref().unwrap());
            diff > duration.as_secs_f64()
        });

        // Need 2 sample points for calculation.
        // TODO(grao): Consider doing interpolation here.
        if index + 1 < progress.samples.len() {
            let sample_a = progress.samples[index];
            let sample_b = progress.samples.last().unwrap();
            let time_diff = timestamp_to_unixtime(sample_b.timestamp.as_ref().unwrap())
                - timestamp_to_unixtime(sample_a.timestamp.as_ref().unwrap());
            let tps = (sample_b.version - sample_a.version) as f64 / time_diff;
            let bps = (sample_b.size_bytes - sample_a.size_bytes) as f64 / time_diff;
            return format!(
                "{} tps, {} / s",
                tps as u64,
                bytesize::to_string(bps as u64, /*si_prefix=*/ false)
            );
        }
    }

    "No data".to_string()
}
```

**File:** protos/proto/aptos/indexer/v1/grpc.proto (L12-16)
```text
message StreamProgressSampleProto {
  optional aptos.util.timestamp.Timestamp timestamp = 1;
  uint64 version = 2;
  uint64 size_bytes = 3;
}
```

**File:** protos/rust/src/pb/aptos.indexer.v1.rs (L160-167)
```rust
pub struct StreamProgressSampleProto {
    #[prost(message, optional, tag="1")]
    pub timestamp: ::core::option::Option<super::super::util::timestamp::Timestamp>,
    #[prost(uint64, tag="2")]
    pub version: u64,
    #[prost(uint64, tag="3")]
    pub size_bytes: u64,
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L489-509)
```rust
    fn handle_live_data_service_info(
        &self,
        address: GrpcAddress,
        mut info: LiveDataServiceInfo,
    ) -> Result<()> {
        let mut entry = self
            .live_data_services
            .entry(address.clone())
            .or_insert(LiveDataService::new(address));
        if info.stream_info.is_none() {
            info.stream_info = Some(StreamInfo {
                active_streams: vec![],
            });
        }
        entry.value_mut().recent_states.push_back(info);
        if entry.value().recent_states.len() > MAX_NUM_OF_STATES_TO_KEEP {
            entry.value_mut().recent_states.pop_front();
        }

        Ok(())
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/status_page.rs (L326-343)
```rust
                        .with_cell(TableCell::new(TableCellType::Data).with_raw(
                            get_throughput_from_samples(
                                active_stream.progress.as_ref(),
                                Duration::from_secs(10),
                            ),
                        ))
                        .with_cell(TableCell::new(TableCellType::Data).with_raw(
                            get_throughput_from_samples(
                                active_stream.progress.as_ref(),
                                Duration::from_secs(60),
                            ),
                        ))
                        .with_cell(TableCell::new(TableCellType::Data).with_raw(
                            get_throughput_from_samples(
                                active_stream.progress.as_ref(),
                                Duration::from_secs(600),
                            ),
                        )),
```
