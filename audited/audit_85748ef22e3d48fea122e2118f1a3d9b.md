# Audit Report

## Title
Integer Overflow in Latency Monitor Due to Unvalidated Peer-Provided Ledger Info Versions

## Summary
The latency monitor in `state-sync/aptos-data-client/src/latency_monitor.rs` extracts version numbers from peer-provided `LedgerInfoWithSignatures` without validation, leading to potential integer overflow that can cause node panics in debug builds or incorrect state tracking in release builds.

## Finding Description

The vulnerability exists in the data flow from peer-provided storage summaries to the latency monitor's arithmetic operations:

1. **Unvalidated Data Ingestion**: When peers advertise their storage state via `StorageServerSummary`, the contained `synced_ledger_info` is collected without signature verification or bounds checking: [1](#0-0) 

2. **Version Extraction Without Validation**: The latency monitor retrieves the highest advertised version by iterating through all peer-provided ledger infos: [2](#0-1) [3](#0-2) 

3. **Integer Overflow Vulnerability**: The extracted version is used in unchecked arithmetic that can overflow: [4](#0-3) 

**Attack Scenario**: A malicious peer crafts a `StorageServerSummary` with `synced_ledger_info.version = u64::MAX - 5000`. When the local node's `highest_synced_version` is close to `u64::MAX - 15000`, the addition `highest_synced_version + 10000` overflows, causing:
- **Debug builds**: Panic and node crash
- **Release builds**: Wraparound to a small number, causing the node to incorrectly believe it's caught up or corrupting version tracking in the BTreeMap

The vulnerability is confirmed by the absence of any signature verification or validation in the data client module: [5](#0-4) 

## Impact Explanation

**Medium Severity** per Aptos Bug Bounty criteria:

- **Node Availability**: Debug builds will panic and crash, causing temporary node unavailability requiring restart
- **State Inconsistencies**: Release builds will track incorrect versions in the latency monitor's `advertised_versions` BTreeMap, corrupting metrics and potentially causing resource exhaustion if multiple malicious peers send high version numbers
- **Limited Blast Radius**: Does not directly affect consensus safety or fund security, but impacts monitoring infrastructure reliability

This qualifies as "State inconsistencies requiring intervention" under Medium severity.

## Likelihood Explanation

**High Likelihood**:
- **Low Attack Complexity**: Any network peer can send malicious storage summaries
- **No Authentication Required**: Storage summaries are accepted from any connected peer without signature verification
- **Easy to Trigger**: A single malicious peer can cause the overflow by sending one crafted message
- **Production Impact**: While release builds use wrapping arithmetic, the resulting incorrect state tracking still causes operational issues

## Recommendation

Implement validation before accepting peer-provided ledger infos:

```rust
// In peer_states.rs, line 374-378, add validation:
if let Some(synced_ledger_info) = summary.data_summary.synced_ledger_info.as_ref() {
    // Validate version is within reasonable bounds
    let version = synced_ledger_info.ledger_info().version();
    if version <= self.data_client_config.max_reasonable_version {
        advertised_data
            .synced_ledger_infos
            .push(synced_ledger_info.clone());
    } else {
        // Log and reject suspicious version
        warn!("Rejecting ledger_info with unreasonably high version: {}", version);
    }
}

// In latency_monitor.rs, line 243, use saturating arithmetic:
if highest_synced_version.saturating_add(MAX_VERSION_LAG_TO_TOLERATE) >= highest_advertised_version {
```

Additionally, consider verifying ledger info signatures using the validator verifier before accepting them into the global data summary.

## Proof of Concept

```rust
#[test]
fn test_integer_overflow_with_malicious_ledger_info() {
    use aptos_types::ledger_info::{LedgerInfo, LedgerInfoWithSignatures};
    use aptos_types::block_info::BlockInfo;
    use aptos_crypto::hash::HashValue;
    
    // Create a malicious ledger info with version near u64::MAX
    let malicious_version = u64::MAX - 5000;
    let block_info = BlockInfo::new(
        1,                    // epoch
        0,                    // round
        HashValue::zero(),    // id
        HashValue::zero(),    // executed_state_id
        malicious_version,    // version - MALICIOUS HIGH VALUE
        0,                    // timestamp
        None,                 // next_epoch_state
    );
    let ledger_info = LedgerInfo::new(block_info, HashValue::zero());
    let malicious_ledger_info_with_sigs = LedgerInfoWithSignatures::new(
        ledger_info,
        AggregateSignature::empty(),
    );
    
    // Simulate the overflow scenario
    let highest_synced_version = u64::MAX - 15000;
    let MAX_VERSION_LAG_TO_TOLERATE: u64 = 10_000;
    
    // This will overflow in debug mode (panic) or wrap in release mode
    let result = highest_synced_version + MAX_VERSION_LAG_TO_TOLERATE;
    
    // In release mode, result wraps to a small number
    assert!(result < highest_synced_version); // Demonstrates wraparound
    
    // The comparison becomes meaningless:
    // result (small number) >= malicious_version (huge number) = false
    // This causes incorrect state tracking in the latency monitor
}
```

## Notes

The vulnerability demonstrates a fundamental trust issue in the state-sync data client: peer-provided metadata is accepted without cryptographic validation. While `LedgerInfoWithSignatures` contains BLS signatures that could be verified, the current implementation prioritizes performance over security by skipping this verification step. The integer overflow is a manifestation of this broader design weakness where malicious peers can inject arbitrary version numbers into the system's monitoring infrastructure.

### Citations

**File:** state-sync/aptos-data-client/src/peer_states.rs (L325-330)
```rust
    pub fn update_summary(&self, peer: PeerNetworkId, storage_summary: StorageServerSummary) {
        self.peer_to_state
            .entry(peer)
            .or_insert(PeerState::new(self.data_client_config.clone()))
            .update_storage_summary(storage_summary);
    }
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L374-378)
```rust
            if let Some(synced_ledger_info) = summary.data_summary.synced_ledger_info.as_ref() {
                advertised_data
                    .synced_ledger_infos
                    .push(synced_ledger_info.clone());
            }
```

**File:** state-sync/aptos-data-client/src/global_summary.rs (L184-198)
```rust
    pub fn highest_synced_ledger_info(&self) -> Option<LedgerInfoWithSignatures> {
        let highest_synced_position = self
            .synced_ledger_infos
            .iter()
            .map(|ledger_info_with_sigs| ledger_info_with_sigs.ledger_info().version())
            .position_max();

        if let Some(highest_synced_position) = highest_synced_position {
            self.synced_ledger_infos
                .get(highest_synced_position)
                .cloned()
        } else {
            None
        }
    }
```

**File:** state-sync/aptos-data-client/src/latency_monitor.rs (L127-141)
```rust
            let advertised_data = &self.data_client.get_global_data_summary().advertised_data;
            let highest_advertised_version = match advertised_data.highest_synced_ledger_info() {
                Some(ledger_info) => ledger_info.ledger_info().version(),
                None => {
                    sample!(
                        SampleRate::Duration(Duration::from_secs(LATENCY_MONITOR_LOG_FREQ_SECS)),
                        warn!(
                            (LogSchema::new(LogEntry::LatencyMonitor)
                                .event(LogEvent::AggregateSummary)
                                .message("Unable to get the highest advertised version!"))
                        );
                    );
                    continue; // Continue to the next round
                },
            };
```

**File:** state-sync/aptos-data-client/src/latency_monitor.rs (L243-243)
```rust
            if highest_synced_version + MAX_VERSION_LAG_TO_TOLERATE >= highest_advertised_version {
```
