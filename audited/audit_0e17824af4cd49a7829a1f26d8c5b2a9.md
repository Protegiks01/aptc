# Audit Report

## Title
Integer Underflow in Indexer Cache Worker BatchEnd Processing Leading to Cache Corruption and DoS

## Summary
The indexer-grpc cache worker's `process_transactions_from_node_response` function contains an unchecked integer subtraction vulnerability when processing `BatchEnd` signals. A malicious or compromised fullnode can send a `BatchEnd` message with `end_version < start_version`, causing integer underflow that results in cache worker crash (debug mode) or cache state corruption (release mode).

## Finding Description

The vulnerability exists in the calculation of `num_of_transactions` when processing `BatchEnd` status messages. [1](#0-0) 

The calculation `num_of_transactions = end_version - start_version + 1` assumes that `end_version >= start_version`. However, there is no validation to enforce this constraint. If a malicious fullnode sends a `BatchEnd` with `end_version = start_version - 1` (e.g., `start_version=100`, `end_version=99`):

**In debug builds**: The subtraction `99u64 - 100u64` triggers a panic with "attempt to subtract with overflow", causing immediate cache worker termination.

**In release builds**: The subtraction wraps around: `99u64 - 100u64 = u64::MAX`, then `u64::MAX + 1 = 0` due to overflow wrapping. This results in `num_of_transactions = 0`.

A secondary underflow occurs at the logging statement: [2](#0-1) 

When `num_of_transactions = 0` and `start_version = 0`: the expression `start_version + 0 - 1` evaluates to `0 - 1`, which underflows to `u64::MAX` in release mode, then casts to `-1i64`.

The protocol specification in the protobuf documentation shows the expected invariant: [3](#0-2) 

This indicates `end_version` should always be `>= start_version` for any batch with transactions. However, this invariant is not validated in the cache worker code.

**Attack Path:**
1. Attacker compromises or controls a fullnode that the cache worker connects to
2. Attacker sends valid `INIT` signal to establish the stream
3. Attacker sends `BatchEnd` with `start_version=100`, `end_version=99`
4. Cache worker calculates `num_of_transactions = 0` (release) or panics (debug)
5. In release mode, if no prior `ChunkDataOk` messages were sent, the version check at line 433 passes (`current_version == start_version + 0`)
6. Cache updates with `transaction_count=0`, potentially corrupting cache state [4](#0-3) 

## Impact Explanation

**Severity: Medium** - This meets the Aptos bug bounty criteria for Medium severity as it causes "State inconsistencies requiring intervention" in the indexer infrastructure.

**Impact:**
- **Debug builds**: Immediate DoS through panic, requiring cache worker restart
- **Release builds**: Cache state corruption where the cache believes it has processed transactions that were never actually processed
- **Downstream effects**: Indexer API may serve incorrect transaction data or version information to clients
- **Recovery**: Requires manual intervention to reset cache state and reconnect to trusted fullnode

**Limitations:**
- Does NOT affect core blockchain consensus, validator operations, or Move VM execution
- Does NOT threaten fund safety or blockchain state integrity
- Limited to indexer infrastructure availability and data correctness
- Does NOT affect other network participants

## Likelihood Explanation

**Likelihood: Medium-Low**

**Required attacker capabilities:**
- Control or compromise of a fullnode that the cache worker connects to, OR
- Man-in-the-middle attack on the gRPC connection between cache worker and fullnode

**Factors increasing likelihood:**
- No input validation on `end_version >= start_version` constraint
- Affects all cache worker deployments connecting to compromised fullnodes
- Release builds silently corrupt state rather than failing safely

**Factors decreasing likelihood:**
- Cache workers typically connect to trusted, operator-controlled fullnodes
- gRPC connections should use TLS/authentication (though not enforced in code)
- Requires attacker to compromise infrastructure, not just send network packets

## Recommendation

Add explicit validation that `end_version >= start_version` before performing the subtraction:

```rust
StatusType::BatchEnd => {
    let start_version = status.start_version;
    let end_version = status
        .end_version
        .expect("TransactionsFromNodeResponse status end_version is None");
    
    // Validate end_version >= start_version
    if end_version < start_version {
        bail!(
            "[Indexer Cache] Invalid BatchEnd: end_version ({}) < start_version ({})",
            end_version,
            start_version
        );
    }
    
    let num_of_transactions = end_version - start_version + 1;
    
    Ok(GrpcDataStatus::BatchEnd {
        start_version,
        num_of_transactions,
    })
}
```

Additionally, add validation in the fullnode service to prevent sending invalid `BatchEnd` messages: [5](#0-4) 

Add assertion before calling `get_status`:
```rust
assert!(
    max_version >= coordinator.current_version,
    "max_version must be >= current_version"
);
```

## Proof of Concept

```rust
// Test demonstrating the underflow vulnerability
#[cfg(test)]
mod tests {
    use super::*;
    use aptos_protos::internal::fullnode::v1::{
        stream_status::StatusType, StreamStatus, TransactionsFromNodeResponse,
        transactions_from_node_response::Response,
    };

    #[test]
    #[should_panic(expected = "attempt to subtract with overflow")]
    fn test_batch_end_underflow_debug() {
        // In debug mode, this should panic
        let start_version = 100u64;
        let end_version = 99u64; // Less than start_version
        
        // This calculation will panic in debug mode
        let num_of_transactions = end_version - start_version + 1;
        
        println!("num_of_transactions: {}", num_of_transactions);
    }

    #[test]
    fn test_batch_end_underflow_release() {
        // In release mode, this wraps around
        let start_version = 100u64;
        let end_version = 99u64;
        
        // Simulate release mode wrapping behavior
        let num_of_transactions = end_version.wrapping_sub(start_version).wrapping_add(1);
        
        // This will be 0 due to wrapping
        assert_eq!(num_of_transactions, 0);
        println!("num_of_transactions after wrap: {}", num_of_transactions);
    }

    #[test]
    fn test_logging_underflow() {
        let start_version = 0u64;
        let num_of_transactions = 0u64;
        
        // This underflows when start_version = 0
        let end_log_version = start_version.wrapping_add(num_of_transactions).wrapping_sub(1);
        
        // Will be u64::MAX
        assert_eq!(end_log_version, u64::MAX);
        
        // Cast to i64 gives -1
        let end_log_version_i64 = end_log_version as i64;
        assert_eq!(end_log_version_i64, -1);
    }
}
```

**Notes:**
- This vulnerability is in the indexer-grpc infrastructure component, not the core blockchain consensus layer
- The bug violates data integrity invariants for the cache system but does not compromise blockchain state or fund safety  
- Exploitation requires attacker control of the fullnode gRPC endpoint that the cache worker connects to
- The issue is classified as Medium severity per Aptos bug bounty guidelines as it causes state inconsistencies requiring manual intervention

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-cache-worker/src/worker.rs (L194-204)
```rust
                StatusType::BatchEnd => {
                    let start_version = status.start_version;
                    let num_of_transactions = status
                        .end_version
                        .expect("TransactionsFromNodeResponse status end_version is None")
                        - start_version
                        + 1;
                    Ok(GrpcDataStatus::BatchEnd {
                        start_version,
                        num_of_transactions,
                    })
```

**File:** ecosystem/indexer-grpc/indexer-grpc-cache-worker/src/worker.rs (L433-447)
```rust
                    if current_version != start_version + num_of_transactions {
                        error!(
                            current_version = current_version,
                            actual_current_version = start_version + num_of_transactions,
                            "[Indexer Cache] End signal received with wrong version."
                        );
                        ERROR_COUNT
                            .with_label_values(&["data_end_wrong_version"])
                            .inc();
                        break;
                    }
                    cache_operator
                        .update_cache_latest_version(transaction_count, current_version)
                        .await
                        .context("Failed to update the latest version in the cache")?;
```

**File:** ecosystem/indexer-grpc/indexer-grpc-cache-worker/src/worker.rs (L454-454)
```rust
                        Some((start_version + num_of_transactions - 1) as i64),
```

**File:** protos/proto/aptos/internal/fullnode/v1/fullnode_data.proto (L11-16)
```text
// Transaction data is transferred via 1 stream with batches until terminated.
// One stream consists:
//  StreamStatus: INIT with version x
//  loop k:
//    TransactionOutput data(size n)
//    StreamStatus: BATCH_END with version x + (k + 1) * n - 1
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/fullnode_data_service.rs (L163-168)
```rust
                let batch_end_status = get_status(
                    StatusType::BatchEnd,
                    coordinator.current_version,
                    Some(max_version),
                    ledger_chain_id,
                );
```
