# Audit Report

## Title
Vote Counting Inconsistency Leading to Consensus Liveness Degradation via Invalid Signature Phantom Votes

## Summary
A validator can send a vote with an invalid signature that passes the initial voting power check but fails during signature aggregation, creating a "phantom vote" that is recorded in the author tracking map but excluded from signature aggregation. This prevents the validator from correcting their vote and can cause rounds to fail to form Quorum Certificates (QCs), leading to consensus liveness degradation.

## Finding Description

The vulnerability exists in the `insert_vote()` function's handling of the aggregation error case. The function performs an optimistic voting power check that counts all signatures without verifying them, but then attempts signature aggregation which verifies signatures and filters out invalid ones. [1](#0-0) 

The critical flow is:

1. At line 371, `check_voting_power()` counts ALL signatures (both verified and unverified) without validating them.
2. If the check succeeds (voting power appears to meet quorum), the code proceeds to `aggregate_and_verify()` at line 383.
3. Inside `aggregate_and_verify()`, signatures are optimistically aggregated and then verified as a batch. [2](#0-1) 

4. If the aggregate signature verification fails, `filter_invalid_signatures()` is called which removes invalid signatures. [3](#0-2) 

5. A second `try_aggregate()` is attempted with only valid signatures, which can fail with `TooLittleVotingPower` if the remaining voting power is below quorum.
6. At line 396-398 in `pending_votes.rs`, this error is caught and the reduced voting power is returned.
7. However, the vote remains in the `author_to_vote` map (added at line 315-316), preventing the validator from resending a corrected vote. [4](#0-3) 

When the validator attempts to resend with a valid signature, the duplicate detection at line 291 only checks the ledger info digest, not the signature itself, resulting in a `DuplicateVote` rejection.

This creates a desynchronization where:
- `author_to_vote` contains the validator's entry (vote "accepted")
- `sig_aggregator.signatures` does NOT contain the validator's signature (filtered out)
- The validator cannot correct their vote (blocked by duplicate detection)
- The validator's voting power is permanently lost for this round

**Attack Scenario:**

Consider 4 validators with voting power: A(30%), B(30%), C(20%), D(20%), where quorum = 67%:

1. Validators A and B send valid votes (60% total)
2. Validator C sends a vote with an invalid signature
3. `check_voting_power()` sees 80% (A + B + C) ≥ 67%, proceeds to aggregate
4. Aggregate signature verification fails due to C's invalid signature
5. After filtering, only A and B remain (60% < 67%)
6. `TooLittleVotingPower` is returned with voting_power = 60
7. C's vote is in `author_to_vote` but signature is removed from aggregator
8. C attempts to resend with valid signature → rejected as `DuplicateVote`
9. If D is offline or Byzantine, the round cannot form a QC
10. Round times out, causing liveness degradation

## Impact Explanation

This vulnerability meets **High Severity** criteria per the Aptos bug bounty program:

- **Validator node slowdowns**: Rounds repeatedly fail to form QCs when validators have invalid signatures, forcing timeout-based round progression which is slower than normal consensus
- **Significant protocol violations**: Votes are "accepted" (return `VoteAdded`) but don't contribute to QCs, violating the expected behavior that accepted votes with sufficient voting power form QCs
- **Liveness degradation**: In edge cases with specific voting power distributions, multiple validators with this issue could prevent QC formation entirely for extended periods

The impact is NOT Critical because:
- Consensus safety is maintained (no double-signing or forks)
- The system eventually recovers after round timeout
- No funds are lost or frozen
- Network availability is degraded but not eliminated

## Likelihood Explanation

**For honest validators:** Low to Medium
- Could occur due to software bugs in signature generation
- Key corruption or inconsistent cryptographic state
- Implementation errors in BLS signature libraries
- Race conditions during signature creation

**For Byzantine validators:** High
- Trivially exploitable by any validator
- Requires no special privileges beyond being in the validator set
- Can be triggered at will by sending intentionally invalid signatures
- Byzantine validators (up to f < n/3) can amplify the effect

**Overall likelihood:** Medium - while individual validators sending invalid signatures should be rare, the ease of exploitation by Byzantine actors and lack of recovery mechanism make this a realistic attack vector.

## Recommendation

Add signature validation before adding votes to `author_to_vote`, or implement a mechanism to allow validators to replace invalid votes with corrected ones. The recommended fix is to verify the signature before accepting the vote into the author tracking map:

```rust
// In insert_vote(), after line 331 (checking voting power)
if validator_voting_power > 0 {
    // Verify the signature before proceeding
    if let Err(e) = validator_verifier.verify_signature(
        vote.author(),
        vote.ledger_info(),
        vote.signature().signature()
    ) {
        warn!("Received vote with invalid signature from {}: {}", vote.author(), e);
        return VoteReceptionResult::ErrorAddingVote(
            VerifyError::InvalidSignature(vote.author())
        );
    }
}
```

Alternatively, modify the duplicate detection logic to allow signature replacement:

```rust
// In insert_vote(), at line 291-296
if &li_digest == previous_li_digest {
    let new_timeout_vote = vote.is_timeout() && !previously_seen_vote.is_timeout();
    // Allow replacing votes if the previous one had an invalid signature
    // that was filtered out during aggregation
    let signature_replacement = sig_aggregator.signatures.get(&vote.author()).is_none();
    if !new_timeout_vote && !signature_replacement {
        return VoteReceptionResult::DuplicateVote;
    }
}
```

## Proof of Concept

```rust
#[test]
fn test_invalid_signature_phantom_vote() {
    use aptos_consensus_types::{
        block::block_test_utils::certificate_for_genesis,
        vote::Vote,
        vote_data::VoteData,
    };
    use aptos_crypto::{bls12381, hash::CryptoHash};
    use aptos_types::{
        block_info::BlockInfo,
        ledger_info::LedgerInfo,
        validator_verifier::random_validator_verifier,
    };

    // Set up 4 validators with specific voting powers
    // A=30%, B=30%, C=20%, D=20%, quorum=67%
    let (signers, validator_verifier) = random_validator_verifier(4, Some(3), false);
    let mut pending_votes = PendingVotes::new();

    // Create consistent vote data and ledger info
    let li = LedgerInfo::new(
        BlockInfo::new(1, 0, HashValue::random(), HashValue::random(), 0, 0, None),
        HashValue::random(),
    );
    let vote_data = VoteData::new(BlockInfo::random(1), BlockInfo::random(0));

    // Validator A (30%) sends valid vote
    let vote_a = Vote::new(vote_data.clone(), signers[0].author(), li.clone(), &signers[0]).unwrap();
    assert_eq!(
        pending_votes.insert_vote(&vote_a, &validator_verifier),
        VoteReceptionResult::VoteAdded(1) // 30% voting power
    );

    // Validator B (30%) sends valid vote
    let vote_b = Vote::new(vote_data.clone(), signers[1].author(), li.clone(), &signers[1]).unwrap();
    assert_eq!(
        pending_votes.insert_vote(&vote_b, &validator_verifier),
        VoteReceptionResult::VoteAdded(2) // 60% voting power
    );

    // Validator C (20%) sends vote with INVALID signature
    let vote_c_invalid = Vote::new_with_signature(
        vote_data.clone(),
        signers[2].author(),
        li.clone(),
        bls12381::Signature::dummy_signature(), // Invalid signature
    );

    // This should trigger the vulnerability:
    // - check_voting_power() succeeds (80% >= 67%)
    // - aggregate_and_verify() fails and filters out C's signature
    // - Returns VoteAdded with reduced voting power (60%)
    let result_c = pending_votes.insert_vote(&vote_c_invalid, &validator_verifier);
    
    // Verify that voting power is less than initial due to filtering
    match result_c {
        VoteReceptionResult::VoteAdded(voting_power) => {
            assert!(voting_power < 3, "Voting power should be reduced after filtering");
        }
        _ => panic!("Expected VoteAdded, got {:?}", result_c),
    }

    // Validator C tries to resend with VALID signature
    let vote_c_valid = Vote::new(
        vote_data.clone(),
        signers[2].author(),
        li.clone(),
        &signers[2]
    ).unwrap();

    // This should be rejected as DuplicateVote, proving the vulnerability
    assert_eq!(
        pending_votes.insert_vote(&vote_c_valid, &validator_verifier),
        VoteReceptionResult::DuplicateVote
    );

    // System is now stuck at 60% voting power (below 67% quorum)
    // Validator C cannot correct their vote
    // Round will timeout unless Validator D votes
}
```

**Notes:**

This vulnerability can occur legitimately when validators experience signature generation bugs or key corruption. The lack of a recovery mechanism creates a permanent voting power loss for affected validators within a round, leading to measurable liveness degradation. While the system eventually recovers via round timeout, repeated occurrences (either accidental or malicious) can significantly degrade consensus performance. The fix should either validate signatures before accepting votes or provide a mechanism for validators to correct invalid signatures.

### Citations

**File:** consensus/src/pending_votes.rs (L287-309)
```rust
        if let Some((previously_seen_vote, previous_li_digest)) =
            self.author_to_vote.get(&vote.author())
        {
            // is it the same vote?
            if &li_digest == previous_li_digest {
                // we've already seen an equivalent vote before
                let new_timeout_vote = vote.is_timeout() && !previously_seen_vote.is_timeout();
                if !new_timeout_vote {
                    // it's not a new timeout vote
                    return VoteReceptionResult::DuplicateVote;
                }
            } else {
                // we have seen a different vote for the same round
                error!(
                    SecurityEvent::ConsensusEquivocatingVote,
                    remote_peer = vote.author(),
                    vote = vote,
                    previous_vote = previously_seen_vote
                );

                return VoteReceptionResult::EquivocateVote;
            }
        }
```

**File:** consensus/src/pending_votes.rs (L371-401)
```rust
                match sig_aggregator.check_voting_power(validator_verifier, true) {
                    // a quorum of signature was reached, a new QC is formed
                    Ok(aggregated_voting_power) => {
                        assert!(
                                aggregated_voting_power >= validator_verifier.quorum_voting_power(),
                                "QC aggregation should not be triggered if we don't have enough votes to form a QC"
                            );
                        let verification_result = {
                            let _timer = counters::VERIFY_MSG
                                .with_label_values(&["vote_aggregate_and_verify"])
                                .start_timer();

                            sig_aggregator.aggregate_and_verify(validator_verifier).map(
                                |(ledger_info, aggregated_sig)| {
                                    LedgerInfoWithSignatures::new(ledger_info, aggregated_sig)
                                },
                            )
                        };
                        match verification_result {
                            Ok(ledger_info_with_sig) => {
                                *status = VoteStatus::EnoughVotes(ledger_info_with_sig.clone());
                                return VoteReceptionResult::NewQuorumCertificate(Arc::new(
                                    QuorumCert::new(vote.vote_data().clone(), ledger_info_with_sig),
                                ));
                            },
                            Err(VerifyError::TooLittleVotingPower { voting_power, .. }) => {
                                voting_power
                            },
                            Err(e) => return VoteReceptionResult::ErrorAggregatingSignature(e),
                        }
                    },
```

**File:** types/src/ledger_info.rs (L510-513)
```rust
    fn filter_invalid_signatures(&mut self, verifier: &ValidatorVerifier) {
        let signatures = mem::take(&mut self.signatures);
        self.signatures = verifier.filter_invalid_signatures(&self.data, signatures);
    }
```

**File:** types/src/ledger_info.rs (L517-536)
```rust
    pub fn aggregate_and_verify(
        &mut self,
        verifier: &ValidatorVerifier,
    ) -> Result<(T, AggregateSignature), VerifyError> {
        let aggregated_sig = self.try_aggregate(verifier)?;

        match verifier.verify_multi_signatures(&self.data, &aggregated_sig) {
            Ok(_) => {
                // We are not marking all the signatures as "verified" here, as two malicious
                // voters can collude and create a valid aggregated signature.
                Ok((self.data.clone(), aggregated_sig))
            },
            Err(_) => {
                self.filter_invalid_signatures(verifier);

                let aggregated_sig = self.try_aggregate(verifier)?;
                Ok((self.data.clone(), aggregated_sig))
            },
        }
    }
```
