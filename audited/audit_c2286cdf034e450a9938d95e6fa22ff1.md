# Audit Report

## Title
Database Credential Exposure in Postgres Health Checker

## Summary
The `HealthChecker::Postgres` and `HealthChecker::Processor` variants expose database connection strings containing plaintext passwords in both success messages and error messages, leading to credential disclosure in console output and log files.

## Finding Description

The health checker implementation in the Aptos localnet tooling exposes PostgreSQL credentials through multiple code paths:

**1. Connection String Construction with Embedded Passwords:**

When using `--host-postgres-password`, the connection string is constructed with the password embedded in plaintext format `postgres://user:password@host:port/database`. [1](#0-0) 

**2. Credential Exposure via `address_str()` Method:**

The `address_str()` method for the `Postgres` variant returns the full connection string including the password. [2](#0-1) 

**3. Success Case - Console Output Exposure:**

When the health check succeeds, the connection string with password is printed to stdout/logs. [3](#0-2) [4](#0-3) 

**4. Error Case - Error Message Exposure:**

When connection fails, the error message includes the full connection string via `address_str()`. [5](#0-4) 

The error is then captured and displayed to users: [6](#0-5) 

**5. Connection Establishment Errors:**

The underlying `AsyncPgConnection::establish()` call may also include the connection string in diesel-async error details. [7](#0-6) 

## Impact Explanation

This vulnerability qualifies as **High Severity** credential exposure because:

1. **Plaintext Password Disclosure**: Database passwords are exposed in plaintext through console output and log files
2. **Multiple Exposure Points**: Credentials leak in both success and failure scenarios
3. **Persistent Logging**: The `info!()` macro may write credentials to persistent log files
4. **Unauthorized Database Access**: Exposed credentials could enable unauthorized access to PostgreSQL databases that may contain:
   - Indexer data with transaction information
   - Processor state and metadata
   - Development/testing data that could be sensitive

While this affects the localnet development tool rather than production consensus nodes, the credential exposure could lead to unauthorized access to databases used by developers and testing environments.

## Likelihood Explanation

**Likelihood: High**

This vulnerability triggers automatically whenever:
1. A user runs the localnet with `--use-host-postgres` and `--host-postgres-password` flags
2. The connection succeeds (credentials printed to console)
3. The connection fails (credentials included in error messages)

The issue is deterministic and requires no special conditions - it occurs in normal operation. Any developer using host postgres with password authentication will expose their credentials.

## Recommendation

Implement credential sanitization in the `address_str()` method for database-related health checkers:

```rust
pub fn address_str(&self) -> &str {
    match self {
        HealthChecker::Http(url, _) => url.as_str(),
        HealthChecker::NodeApi(url) => url.as_str(),
        HealthChecker::DataServiceGrpc(url) => url.as_str(),
        // Return sanitized connection info without credentials
        HealthChecker::Postgres(_) => "postgres://<hidden>",
        // Return only the processor name, not the connection string
        HealthChecker::Processor(_, processor_name) => processor_name.as_str(),
        HealthChecker::IndexerApiMetadata(url) => url.as_str(),
    }
}
```

Additionally, ensure error messages from `AsyncPgConnection::establish()` are sanitized to remove connection string details before displaying to users.

## Proof of Concept

**Steps to Reproduce:**

1. Run the Aptos localnet with host postgres and password:
```bash
aptos node run-localnet \
  --use-host-postgres \
  --host-postgres-password "MySecretPassword123" \
  --with-indexer-api
```

2. **Scenario A - Success Case:**
   - If postgres is running and accessible, observe console output:
   ```
   Postgres is ready. Endpoint: postgres://postgres:MySecretPassword123@127.0.0.1:5432/local_testnet
   ```

3. **Scenario B - Failure Case:**
   - Stop the postgres service
   - Run the same command
   - Observe error message:
   ```
   One of the services failed to start up: Postgres at postgres://postgres:MySecretPassword123@127.0.0.1:5432/local_testnet did not start up: ...
   ```

**Expected Behavior:**
Connection strings should be sanitized to hide credentials:
```
Postgres is ready. Endpoint: postgres://postgres:***@127.0.0.1:5432/local_testnet
```

**Actual Behavior:**
Plaintext passwords are exposed in console output and error messages.

## Notes

This vulnerability affects both health checker implementations:
- `crates/aptos-localnet/src/health_checker.rs`
- `crates/aptos/src/node/local_testnet/health_checker.rs`

Both files contain identical vulnerable code patterns and should be fixed consistently. The same issue affects the `HealthChecker::Processor` variant which also receives connection strings with embedded credentials.

### Citations

**File:** crates/aptos/src/node/local_testnet/postgres.rs (L92-116)
```rust
    pub fn get_connection_string(&self, database: Option<&str>, external: bool) -> String {
        let password = match self.use_host_postgres {
            true => match &self.host_postgres_password {
                Some(password) => format!(":{}", password),
                None => "".to_string(),
            },
            false => "".to_string(),
        };
        let port = self.get_postgres_port(external);
        let database = match database {
            Some(database) => database,
            None => &self.postgres_database,
        };
        let host = match self.use_host_postgres {
            true => &self.host_postgres_host,
            false => match external {
                true => "127.0.0.1",
                false => POSTGRES_CONTAINER_NAME,
            },
        };
        format!(
            "postgres://{}{}@{}:{}/{}",
            self.postgres_user, password, host, port, database,
        )
    }
```

**File:** crates/aptos-localnet/src/health_checker.rs (L80-84)
```rust
            HealthChecker::Postgres(connection_string) => {
                AsyncPgConnection::establish(connection_string)
                    .await
                    .context("Failed to connect to postgres to check DB liveness")?;
                Ok(())
```

**File:** crates/aptos-localnet/src/health_checker.rs (L141-151)
```rust
            },
            None => format!("{} at {} did not start up", prefix, self.address_str()),
        })
        .await
    }

    /// This is only ever used for display purposes. If possible, this should be the
    /// endpoint of the service that this HealthChecker is checking.
    pub fn address_str(&self) -> &str {
        match self {
            HealthChecker::Http(url, _) => url.as_str(),
```

**File:** crates/aptos-localnet/src/health_checker.rs (L154-154)
```rust
            HealthChecker::Postgres(url) => url.as_str(),
```

**File:** crates/aptos/src/node/local_testnet/mod.rs (L162-166)
```rust
                    println!(
                        "{} is ready. Endpoint: {}",
                        health_checker,
                        health_checker.address_str()
                    );
```

**File:** crates/aptos/src/node/local_testnet/mod.rs (L168-172)
```rust
                    info!(
                        "[silent] {} is ready. Endpoint: {}",
                        health_checker,
                        health_checker.address_str()
                    );
```

**File:** crates/aptos/src/node/local_testnet/mod.rs (L183-189)
```rust
            f.map_err(|err| {
                CliError::UnexpectedError(format!(
                    "One of the services failed to start up: {:?}. \
                    Please check the logs at {} for more information.",
                    err,
                    test_dir.display(),
                ))
```
