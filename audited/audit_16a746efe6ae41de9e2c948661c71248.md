# Audit Report

## Title
Moderator Rate Limiting Bypass via StateValuesWithProofRequest Range Validation Gap

## Summary
A Byzantine peer can bypass the storage service's moderator rate limiting mechanism by sending `StateValuesWithProofRequest` messages with invalid index ranges (start_index > end_index). These malformed requests pass moderator validation but fail at the storage layer, consuming CPU resources without incrementing the invalid request counter that triggers peer blocking.

## Finding Description
The storage service implements a request moderator to protect against malicious peers by tracking invalid requests and temporarily blocking peers that exceed a threshold. However, there is a validation gap for `StateValuesWithProofRequest` that allows attackers to bypass this protection. [1](#0-0) 

When a `StateValuesWithProofRequest` is deserialized, Serde accepts any u64 values for `start_index` and `end_index` without validation, allowing inconsistent values like start_index=100, end_index=50. [2](#0-1) 

The moderator's `can_service` validation for this request type only checks if states are available at the requested version and if a proof can be created. It does NOT validate that start_index ≤ end_index, unlike other range-based request types. [3](#0-2) 

The moderator only increments the invalid request counter when `can_service` returns false. Since invalid range requests pass this check, they proceed to the storage layer. [4](#0-3) 

The storage layer validates the range using `inclusive_range_len`, which returns an error for invalid ranges. [5](#0-4) 

However, errors from the storage layer do not increment the moderator's invalid request counter, so the peer is never rate-limited.

## Impact Explanation
This vulnerability enables a resource exhaustion attack that can cause **validator node slowdowns** (High Severity per Aptos bug bounty criteria). A Byzantine peer can:

1. Send unlimited malformed `StateValuesWithProofRequest` messages
2. Each request consumes CPU time reaching the storage layer
3. Bypass the moderator's rate limiting designed to protect against such attacks
4. Degrade service quality for legitimate peers
5. Potentially exhaust node resources without consequences

The attack requires no special privileges and can be executed by any network peer.

## Likelihood Explanation
This vulnerability is highly likely to be exploited because:
- The attack is trivial to execute (send requests with start_index > end_index)
- No authentication or special privileges required
- The gap between moderator and storage validation is systematic
- Attackers can easily identify this attack vector through code inspection or fuzzing
- The rate limiting bypass makes the attack sustainable indefinitely

## Recommendation
Add range validation for `StateValuesWithProofRequest` in the moderator's `can_service` method, consistent with how other range-based requests are validated:

```rust
GetStateValuesWithProof(request) => {
    // Validate the range first
    let desired_range = match CompleteDataRange::new(request.start_index, request.end_index) {
        Ok(desired_range) => desired_range,
        Err(_) => return false,
    };
    
    let proof_version = request.version;
    let can_serve_states = self
        .states
        .map(|range| range.superset_of(&desired_range))
        .unwrap_or(false);
    
    let can_create_proof = self
        .synced_ledger_info
        .as_ref()
        .map(|li| li.ledger_info().version() >= proof_version)
        .unwrap_or(false);
    
    can_serve_states && can_create_proof
},
```

This ensures that invalid range requests are rejected at the moderator level, incrementing the invalid request counter and triggering rate limiting as intended.

## Proof of Concept
The existing test confirms the behavior: [6](#0-5) 

To demonstrate the bypass, a malicious peer would:

1. Establish connection to storage service
2. Send multiple `StateValuesWithProofRequest` with start_index=100, end_index=50
3. Observe that requests return `InvalidRequest` errors but peer is never blocked
4. Continue sending invalid requests indefinitely, consuming server resources

The attack succeeds because the moderator's invalid request counter remains at zero despite receiving many invalid requests.

## Notes
This vulnerability represents a gap in the defense-in-depth validation strategy. While the storage layer correctly rejects invalid ranges, the moderator's rate limiting mechanism—designed specifically to protect against malicious peers—is bypassed. This allows unprivileged attackers to conduct resource exhaustion attacks that would normally trigger protective measures.

### Citations

**File:** state-sync/storage-service/types/src/requests.rs (L343-348)
```rust
#[derive(Clone, Debug, Deserialize, Eq, Hash, PartialEq, Serialize)]
pub struct StateValuesWithProofRequest {
    pub version: u64,     // The version to fetch the state values at
    pub start_index: u64, // The index to start fetching state values (inclusive)
    pub end_index: u64,   // The index to stop fetching state values (inclusive)
}
```

**File:** state-sync/storage-service/types/src/responses.rs (L727-742)
```rust
            GetStateValuesWithProof(request) => {
                let proof_version = request.version;

                let can_serve_states = self
                    .states
                    .map(|range| range.contains(request.version))
                    .unwrap_or(false);

                let can_create_proof = self
                    .synced_ledger_info
                    .as_ref()
                    .map(|li| li.ledger_info().version() >= proof_version)
                    .unwrap_or(false);

                can_serve_states && can_create_proof
            },
```

**File:** state-sync/storage-service/server/src/moderator.rs (L154-185)
```rust
            // Verify the request is serviceable using the current storage server summary
            if !storage_server_summary.can_service(
                &self.aptos_data_client_config,
                self.time_service.clone(),
                request,
            ) {
                // Increment the invalid request count for the peer
                let mut unhealthy_peer_state = self
                    .unhealthy_peer_states
                    .entry(*peer_network_id)
                    .or_insert_with(|| {
                        // Create a new unhealthy peer state (this is the first invalid request)
                        let max_invalid_requests =
                            self.storage_service_config.max_invalid_requests_per_peer;
                        let min_time_to_ignore_peers_secs =
                            self.storage_service_config.min_time_to_ignore_peers_secs;
                        let time_service = self.time_service.clone();

                        UnhealthyPeerState::new(
                            max_invalid_requests,
                            min_time_to_ignore_peers_secs,
                            time_service,
                        )
                    });
                unhealthy_peer_state.increment_invalid_request_count(peer_network_id);

                // Return the validation error
                return Err(Error::InvalidRequest(format!(
                    "The given request cannot be satisfied. Request: {:?}, storage summary: {:?}",
                    request, storage_server_summary
                )));
            }
```

**File:** state-sync/storage-service/server/src/storage.rs (L900-911)
```rust
    fn get_state_value_chunk_with_proof_by_size(
        &self,
        version: u64,
        start_index: u64,
        end_index: u64,
        max_response_size: u64,
        use_size_and_time_aware_chunking: bool,
    ) -> Result<StateValueChunkWithProof, Error> {
        // Calculate the number of state values to fetch
        let expected_num_state_values = inclusive_range_len(start_index, end_index)?;
        let max_num_state_values = self.config.max_state_chunk_size;
        let num_state_values_to_fetch = min(expected_num_state_values, max_num_state_values);
```

**File:** state-sync/storage-service/server/src/storage.rs (L1484-1493)
```rust
/// `end == u64::MAX`.
fn inclusive_range_len(start: u64, end: u64) -> aptos_storage_service_types::Result<u64, Error> {
    // len = end - start + 1
    let len = end.checked_sub(start).ok_or_else(|| {
        Error::InvalidRequest(format!("end ({}) must be >= start ({})", end, start))
    })?;
    let len = len
        .checked_add(1)
        .ok_or_else(|| Error::InvalidRequest(format!("end ({}) must not be u64::MAX", end)))?;
    Ok(len)
```

**File:** state-sync/storage-service/server/src/tests/state_values.rs (L154-169)
```rust
#[tokio::test]
async fn test_get_states_with_proof_invalid() {
    // Create the storage client and server
    let (mut mock_client, service, _, _, _) = MockClient::new(None, None);
    tokio::spawn(service.start());

    // Test invalid ranges
    let start_index = 100;
    for end_index in [0, 99] {
        let response =
            get_state_values_with_proof(&mut mock_client, 0, start_index, end_index, false)
                .await
                .unwrap_err();
        assert_matches!(response, StorageServiceError::InvalidRequest(_));
    }
}
```
