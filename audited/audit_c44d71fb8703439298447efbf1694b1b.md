# Audit Report

## Title
Malicious Peer Can Permanently Disable Latency Monitoring via Unverified Storage Summary Advertisements

## Summary
A malicious peer can advertise a fake `LedgerInfoWithSignatures` with an arbitrarily high version number in its storage summary without any signature verification. This prevents the latency monitor from ever transitioning to the "caught up" state, permanently disabling critical sync performance metrics across all affected nodes.

## Finding Description

The vulnerability exists in the state synchronization data client's handling of peer-advertised storage summaries. When peers advertise their storage state, the system accepts `LedgerInfoWithSignatures` objects without verifying the BLS signatures.

**Attack Flow:**

1. **Malicious Peer Joins Network**: An attacker runs a peer node that connects to honest nodes in the network.

2. **Unverified Storage Summary Acceptance**: When the data poller requests storage summaries from peers, it accepts the response without verification: [1](#0-0) 

3. **Global Summary Aggregation**: The malicious peer's fake ledger info is added to the global data summary alongside legitimate ones: [2](#0-1) 

4. **Highest Version Selection**: The global data summary selects the highest version among all advertised ledger infos: [3](#0-2) 

5. **Latency Monitor Blocked**: The latency monitor uses this fake high version and can never catch up: [4](#0-3) 

The critical check that determines if monitoring should start: [5](#0-4) 

If a malicious peer continuously advertises `highest_advertised_version = highest_synced_version + MAX_VERSION_LAG_TO_TOLERATE + N` (where N > 0), the condition on line 243 will never be satisfied, and `caught_up_to_latest` remains `false` forever.

**Root Cause**: While signature verification methods exist on `LedgerInfoWithSignatures`, they are never invoked when accepting storage summaries from peers. The structure can be deserialized with arbitrary data: [6](#0-5) 

The verification method exists but is not called: [7](#0-6) 

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos bug bounty program for the following reasons:

1. **Validator Node Performance Degradation**: Operators lose critical visibility into sync performance, making it difficult to diagnose real sync issues. This falls under "Validator node slowdowns" as operators cannot properly monitor and tune their nodes.

2. **Network-Wide Observability Loss**: A single malicious peer affects all honest nodes that connect to it, causing widespread loss of latency metrics across the network.

3. **Operational Impact**: The `ProgressChecker` within the latency monitor will still function and may panic if no progress is made, but operators lose fine-grained metrics about:
   - `SEEN_TO_SYNC_LATENCY` - Time from seeing advertised data to syncing it
   - `PROPOSE_TO_SEEN_LATENCY` - Time from block proposal to seeing it advertised  
   - `PROPOSE_TO_SYNC_LATENCY` - End-to-end sync latency
   - `BLOCK_TIMESTAMP_LAG` - Clock drift between nodes

4. **Low Attack Barrier**: The attack requires no stake, no validator privileges, and minimal technical sophistication - just running a modified peer that advertises fake storage summaries.

## Likelihood Explanation

**Likelihood: HIGH**

1. **Ease of Exploitation**: An attacker only needs to:
   - Run a single malicious peer node
   - Modify the storage summary response to include a fake `LedgerInfoWithSignatures` with a high version
   - Connect to the target network

2. **No Authentication Required**: There is no verification that prevents acceptance of the malicious storage summary.

3. **Persistent Effect**: Once a node connects to the malicious peer, the effect persists until the peer is disconnected and the global summary refreshes (which may take time).

4. **Wide Attack Surface**: Any node accepting connections from external peers is vulnerable.

## Recommendation

Implement signature verification for `synced_ledger_info` in storage summaries before adding them to the global data summary. The verification should use the appropriate epoch state's validator verifier.

**Proposed Fix in `peer_states.rs`:**

```rust
pub fn calculate_global_data_summary(&self) -> GlobalDataSummary {
    // Gather all storage summaries, but exclude peers that are ignored
    let storage_summaries: Vec<StorageServerSummary> = self
        .peer_to_state
        .iter()
        .filter_map(|peer_state| {
            peer_state
                .value()
                .get_storage_summary_if_not_ignored()
                .cloned()
        })
        .collect();

    // ... existing code ...

    for summary in storage_summaries {
        // ... existing code for other fields ...
        
        if let Some(synced_ledger_info) = summary.data_summary.synced_ledger_info.as_ref() {
            // NEW: Verify the ledger info before accepting it
            if let Some(epoch_state) = self.get_verified_epoch_state_for_ledger_info(synced_ledger_info) {
                if synced_ledger_info.verify_signatures(&epoch_state.verifier()).is_ok() {
                    advertised_data
                        .synced_ledger_infos
                        .push(synced_ledger_info.clone());
                } else {
                    // Penalize peer for providing invalid signatures
                    self.update_score_error(peer_network_id, ErrorType::Malicious);
                }
            }
            // If we don't have the epoch state yet, skip this ledger info
        }
        
        // ... rest of the function ...
    }
}
```

Additionally, implement a helper method to retrieve the appropriate epoch state for verification, or require that the latency monitor only uses verified ledger infos from the state sync driver's verified epoch states.

**Alternative Mitigation**: If full verification is too expensive during summary aggregation, implement basic sanity checks:
- Reject ledger infos with versions that are unreasonably far ahead (e.g., > current_version + reasonable_threshold)
- Require a minimum number of peers to advertise similar versions before accepting them
- Track and ignore peers that consistently advertise suspicious versions

## Proof of Concept

```rust
// Proof of Concept: Malicious Peer Advertising Fake High Version
// This demonstrates how a malicious peer can craft and advertise a fake storage summary

use aptos_types::ledger_info::{LedgerInfo, LedgerInfoWithSignatures};
use aptos_crypto::bls12381::Signature as AggregateSignature;
use aptos_types::block_info::BlockInfo;
use aptos_crypto::hash::HashValue;
use aptos_storage_service_types::responses::{StorageServerSummary, DataSummary, ProtocolMetadata};

fn create_malicious_storage_summary(target_version_ahead: u64) -> StorageServerSummary {
    // Create a fake LedgerInfo with an arbitrarily high version
    let fake_commit_info = BlockInfo::new(
        0,  // epoch
        0,  // round  
        HashValue::zero(),  // id
        HashValue::zero(),  // executed_state_id
        u64::MAX - target_version_ahead,  // fake high version
        0,  // timestamp_usecs
        None,  // next_epoch_state
    );
    
    let fake_ledger_info = LedgerInfo::new(
        fake_commit_info,
        HashValue::zero(),  // consensus_data_hash
    );
    
    // Create a LedgerInfoWithSignatures with empty/fake signatures
    // No verification happens, so this will be accepted
    let fake_ledger_info_with_sigs = LedgerInfoWithSignatures::new(
        fake_ledger_info,
        AggregateSignature::empty(),  // No valid signatures!
    );
    
    // Create the malicious storage summary
    StorageServerSummary {
        protocol_metadata: ProtocolMetadata::default(),
        data_summary: DataSummary {
            synced_ledger_info: Some(fake_ledger_info_with_sigs),
            epoch_ending_ledger_infos: None,
            states: None,
            transactions: None,
            transaction_outputs: None,
        },
    }
}

// Attack Scenario:
// 1. Honest node's highest_synced_version = 1000
// 2. MAX_VERSION_LAG_TO_TOLERATE = 10000
// 3. Malicious peer advertises version = 11001 (always 1 ahead of the threshold)
// 4. Condition: 1000 + 10000 >= 11001 evaluates to FALSE
// 5. caught_up_to_latest remains false forever
// 6. Latency monitoring never starts

#[test]
fn test_malicious_peer_blocks_latency_monitor() {
    const MAX_VERSION_LAG_TO_TOLERATE: u64 = 10_000;
    
    let highest_synced_version = 1000;
    let malicious_advertised_version = highest_synced_version + MAX_VERSION_LAG_TO_TOLERATE + 1;
    
    // This condition will always be false
    let can_catch_up = highest_synced_version + MAX_VERSION_LAG_TO_TOLERATE >= malicious_advertised_version;
    assert_eq!(can_catch_up, false);
    
    // The latency monitor will never start collecting metrics
    println!("Attack successful: Latency monitor blocked at version {}", highest_synced_version);
}
```

**Notes:**
- The malicious peer can dynamically adjust the advertised version to always stay ahead by monitoring the network
- No cryptographic operations are required - the fake ledger info is accepted without verification
- The attack affects all nodes that connect to the malicious peer
- Actual state synchronization continues to work (with verification), but monitoring is disabled

### Citations

**File:** state-sync/aptos-data-client/src/poller.rs (L436-439)
```rust
        // Update the summary for the peer
        data_summary_poller
            .data_client
            .update_peer_storage_summary(peer, storage_summary);
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L374-378)
```rust
            if let Some(synced_ledger_info) = summary.data_summary.synced_ledger_info.as_ref() {
                advertised_data
                    .synced_ledger_infos
                    .push(synced_ledger_info.clone());
            }
```

**File:** state-sync/aptos-data-client/src/global_summary.rs (L184-198)
```rust
    pub fn highest_synced_ledger_info(&self) -> Option<LedgerInfoWithSignatures> {
        let highest_synced_position = self
            .synced_ledger_infos
            .iter()
            .map(|ledger_info_with_sigs| ledger_info_with_sigs.ledger_info().version())
            .position_max();

        if let Some(highest_synced_position) = highest_synced_position {
            self.synced_ledger_infos
                .get(highest_synced_position)
                .cloned()
        } else {
            None
        }
    }
```

**File:** state-sync/aptos-data-client/src/latency_monitor.rs (L127-147)
```rust
            let advertised_data = &self.data_client.get_global_data_summary().advertised_data;
            let highest_advertised_version = match advertised_data.highest_synced_ledger_info() {
                Some(ledger_info) => ledger_info.ledger_info().version(),
                None => {
                    sample!(
                        SampleRate::Duration(Duration::from_secs(LATENCY_MONITOR_LOG_FREQ_SECS)),
                        warn!(
                            (LogSchema::new(LogEntry::LatencyMonitor)
                                .event(LogEvent::AggregateSummary)
                                .message("Unable to get the highest advertised version!"))
                        );
                    );
                    continue; // Continue to the next round
                },
            };

            // Update the advertised version timestamps
            self.update_advertised_version_timestamps(
                highest_synced_version,
                highest_advertised_version,
            );
```

**File:** state-sync/aptos-data-client/src/latency_monitor.rs (L242-263)
```rust
        if !self.caught_up_to_latest {
            if highest_synced_version + MAX_VERSION_LAG_TO_TOLERATE >= highest_advertised_version {
                info!(
                    (LogSchema::new(LogEntry::LatencyMonitor)
                        .event(LogEvent::CaughtUpToLatest)
                        .message(
                            "We've caught up to the latest version! Starting the latency monitor."
                        ))
                );
                self.caught_up_to_latest = true; // We've caught up
            } else {
                sample!(
                    SampleRate::Duration(Duration::from_secs(LATENCY_MONITOR_LOG_FREQ_SECS)),
                    info!(
                        (LogSchema::new(LogEntry::LatencyMonitor)
                            .event(LogEvent::WaitingForCatchup)
                            .message("Waiting for the node to catch up to the latest version before starting the latency monitor."))
                    );
                );

                return; // We're still catching up, so we shouldn't update the advertised version timestamps
            }
```

**File:** types/src/ledger_info.rs (L240-260)
```rust
#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]
pub struct LedgerInfoWithV0 {
    ledger_info: LedgerInfo,
    /// Aggregated BLS signature of all the validators that signed the message. The bitmask in the
    /// aggregated signature can be used to find out the individual validators signing the message
    signatures: AggregateSignature,
}

impl Display for LedgerInfoWithV0 {
    fn fmt(&self, f: &mut Formatter) -> std::fmt::Result {
        write!(f, "{}", self.ledger_info)
    }
}

impl LedgerInfoWithV0 {
    pub fn new(ledger_info: LedgerInfo, signatures: AggregateSignature) -> Self {
        LedgerInfoWithV0 {
            ledger_info,
            signatures,
        }
    }
```

**File:** types/src/ledger_info.rs (L303-308)
```rust
    pub fn verify_signatures(
        &self,
        validator: &ValidatorVerifier,
    ) -> ::std::result::Result<(), VerifyError> {
        validator.verify_multi_signatures(self.ledger_info(), &self.signatures)
    }
```
