# Unable to Complete Audit - Incomplete Security Question

I notice that the **security question provided in your prompt is incomplete**. The prompt shows:

> **Security Question (scope for this run):** [File: aptos-core/aptos-move/aptos-aggregator/src/delta_change_set

The question appears to be truncated mid-sentence. There is a file path referenced but no actual security question or specific vulnerability concern specified.

## What I Need to Proceed

To conduct a proper security audit, I need a **complete security question** that specifies:

1. **What type of vulnerability** should I investigate? (e.g., consensus safety violation, state inconsistency, integer overflow, merge logic error, etc.)
2. **What attack scenario** should I explore? (e.g., malicious delta merging, history validation bypass, etc.)
3. **What invariant** am I checking? (e.g., deterministic execution, delta commutativity, overflow protection, etc.)

## What I've Examined

I have reviewed the following files to understand the delta change set implementation: [1](#0-0) [2](#0-1) [3](#0-2) [4](#0-3) [5](#0-4) [6](#0-5) 

## Next Steps

Please provide the **complete security question** so I can conduct a thorough investigation. For example:

- "Does the delta merge logic in `create_merged_delta` have any race conditions or consensus-breaking edge cases?"
- "Can an attacker craft deltas that cause state inconsistencies through history validation bypasses?"
- "Are there integer overflow vulnerabilities in the delta application logic?"

Once you provide the complete question, I will perform a comprehensive security audit following all the validation criteria you specified.

### Citations

**File:** aptos-move/aptos-aggregator/src/delta_change_set.rs (L1-613)
```rust
// Copyright (c) Aptos Foundation
// Licensed pursuant to the Innovation-Enabling Source Code License, available at https://github.com/aptos-labs/aptos-core/blob/main/LICENSE

//! Parallel data aggregation uses a `Delta` op. Every delta is is a state key
//! (for accessing the storage) and an operation: a partial function with a
//! postcondition.

use crate::{
    bounded_math::{BoundedMath, SignedU128},
    delta_math::{merge_data_and_delta, merge_two_deltas, DeltaHistory},
    types::{DelayedFieldsSpeculativeError, DeltaApplicationFailureReason},
};
use aptos_types::error::{code_invariant_error, PanicOr};

#[derive(Copy, Clone, PartialEq, Eq, Debug)]
pub struct DeltaWithMax {
    /// Delta which is the result of the execution.
    pub update: SignedU128,
    /// The maximum value the aggregator can reach.
    pub max_value: u128,
}

impl DeltaWithMax {
    /// Creates a new delta op.
    pub fn new(update: SignedU128, max_value: u128) -> Self {
        Self { max_value, update }
    }

    /// Returns the kind of update for the delta op.
    pub fn get_update(&self) -> SignedU128 {
        self.update
    }

    /// Returns the result of delta application to `base` or error if
    /// postcondition is not satisfied.
    pub fn apply_to(&self, base: u128) -> Result<u128, DelayedFieldsSpeculativeError> {
        let math = BoundedMath::new(self.max_value);
        match self.update {
            SignedU128::Positive(value) => math.unsigned_add(base, value).map_err(|_e| {
                DelayedFieldsSpeculativeError::DeltaApplication {
                    base_value: base,
                    max_value: self.max_value,
                    delta: self.update,
                    reason: DeltaApplicationFailureReason::Overflow,
                }
            }),
            SignedU128::Negative(value) => math.unsigned_subtract(base, value).map_err(|_e| {
                DelayedFieldsSpeculativeError::DeltaApplication {
                    base_value: base,
                    max_value: self.max_value,
                    delta: self.update,
                    reason: DeltaApplicationFailureReason::Underflow,
                }
            }),
        }
    }

    pub fn create_merged_delta(
        prev_delta: &DeltaWithMax,
        next_delta: &DeltaWithMax,
    ) -> Result<DeltaWithMax, PanicOr<DelayedFieldsSpeculativeError>> {
        if prev_delta.max_value != next_delta.max_value {
            Err(code_invariant_error(
                "Cannot merge deltas with different limits",
            ))?;
        }

        let new_delta = BoundedMath::new(prev_delta.max_value)
            .signed_add(&prev_delta.update, &next_delta.update)
            .map_err(|_| DelayedFieldsSpeculativeError::DeltaMerge {
                base_delta: prev_delta.update,
                delta: next_delta.update,
                max_value: prev_delta.max_value,
            })?;

        Ok(DeltaWithMax::new(new_delta, prev_delta.max_value))
    }

    pub fn into_op_no_additional_history(self) -> DeltaOp {
        let mut history = DeltaHistory::new();
        history.record_success(self.update);
        DeltaOp::new(self.update, self.max_value, history)
    }
}

/// Represents an update from aggregator's operation.
#[derive(Copy, Clone, PartialEq, Eq)]
pub struct DeltaOp {
    /// History computed during the transaction execution.
    history: DeltaHistory,
    /// The maximum value the aggregator can reach.
    max_value: u128,
    /// Delta which is the result of the execution.
    update: SignedU128,
}

impl DeltaOp {
    /// Creates a new delta op.
    pub fn new(update: SignedU128, max_value: u128, history: DeltaHistory) -> Self {
        Self {
            history,
            max_value,
            update,
        }
    }

    /// Returns the kind of update for the delta op.
    pub fn get_update(&self) -> SignedU128 {
        self.update
    }

    /// Returns the result of delta application to `base` or error if
    /// postcondition is not satisfied.
    pub fn apply_to(&self, base: u128) -> Result<u128, PanicOr<DelayedFieldsSpeculativeError>> {
        merge_data_and_delta(base, &self.update, &self.history, self.max_value)
    }

    pub fn create_merged_delta(
        prev_delta: &DeltaOp,
        next_delta: &DeltaOp,
    ) -> Result<DeltaOp, PanicOr<DelayedFieldsSpeculativeError>> {
        if prev_delta.max_value != next_delta.max_value {
            Err(code_invariant_error(
                "Cannot merge deltas with different limits",
            ))?;
        }

        let (new_update, new_history) = merge_two_deltas(
            &prev_delta.update,
            &prev_delta.history,
            &next_delta.update,
            &next_delta.history,
            next_delta.max_value,
        )?;

        Ok(DeltaOp::new(new_update, next_delta.max_value, new_history))
    }

    /// Applies self on top of previous delta, merging them together. Note
    /// that the strict ordering here is crucial for catching overflows
    /// correctly.
    pub fn merge_with_previous_delta(
        &mut self,
        previous_delta: DeltaOp,
    ) -> Result<(), PanicOr<DelayedFieldsSpeculativeError>> {
        *self = Self::create_merged_delta(&previous_delta, self)?;
        Ok(())
    }

    /// Applies next delta on top of self, merging two deltas together. This is a reverse
    /// of `merge_with_previous_delta`.
    pub fn merge_with_next_delta(
        &mut self,
        next_delta: DeltaOp,
    ) -> Result<(), PanicOr<DelayedFieldsSpeculativeError>> {
        *self = Self::create_merged_delta(self, &next_delta)?;
        Ok(())
    }

    pub fn into_inner(self) -> (SignedU128, DeltaHistory, u128) {
        (self.update, self.history, self.max_value)
    }
}

impl std::fmt::Debug for DeltaOp {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self.update {
            SignedU128::Positive(value) => {
                write!(
                    f,
                    "+{} ensures 0 <= result <= {}, {:?}",
                    value, self.max_value, self.history
                )
            },
            SignedU128::Negative(value) => {
                write!(
                    f,
                    "-{} ensures 0 <= result <= {}, {:?}",
                    value, self.max_value, self.history
                )
            },
        }
    }
}

/// Serializes value after delta application.
pub fn serialize(value: &u128) -> Vec<u8> {
    bcs::to_bytes(value).expect("unexpected serialization error in aggregator")
}

#[cfg(any(test, feature = "testing"))]
pub fn delta_sub(v: u128, max_value: u128) -> DeltaOp {
    DeltaOp::new(SignedU128::Negative(v), max_value, DeltaHistory {
        max_achieved_positive_delta: 0,
        min_achieved_negative_delta: v,
        min_overflow_positive_delta: None,
        max_underflow_negative_delta: None,
    })
}

#[cfg(any(test, feature = "testing"))]
pub fn delta_add(v: u128, max_value: u128) -> DeltaOp {
    DeltaOp::new(SignedU128::Positive(v), max_value, DeltaHistory {
        max_achieved_positive_delta: v,
        min_achieved_negative_delta: 0,
        min_overflow_positive_delta: None,
        max_underflow_negative_delta: None,
    })
}

#[cfg(test)]
mod test {
    use super::*;
    use crate::{
        aggregator_v1_extension::{EADD_OVERFLOW, ESUB_UNDERFLOW},
        resolver::{TAggregatorV1View, TDelayedFieldView},
        types::DelayedFieldValue,
        FakeAggregatorView,
    };
    use aptos_types::{
        error::PanicError,
        state_store::{
            state_key::StateKey,
            state_value::{StateValue, StateValueMetadata},
        },
        write_set::WriteOp,
    };
    use claims::{assert_err, assert_none, assert_ok, assert_ok_eq, assert_some_eq};
    use move_binary_format::errors::{PartialVMError, PartialVMResult};
    use move_core_types::{value::MoveTypeLayout, vm_status::StatusCode};
    use once_cell::sync::Lazy;
    use std::collections::{BTreeMap, HashSet};
    use triomphe::Arc as TriompheArc;

    fn delta_add_with_history(v: u128, max_value: u128, max: u128, min: u128) -> DeltaOp {
        let mut delta = delta_add(v, max_value);
        delta.history.max_achieved_positive_delta = max;
        delta.history.min_achieved_negative_delta = min;
        delta
    }

    fn delta_sub_with_history(v: u128, max_value: u128, max: u128, min: u128) -> DeltaOp {
        let mut delta = delta_sub(v, max_value);
        delta.history.max_achieved_positive_delta = max;
        delta.history.min_achieved_negative_delta = min;
        delta
    }

    #[test]
    fn test_delta_application() {
        // Testing a fresh delta of +5.
        let mut add5 = delta_add(5, 100);
        assert_ok_eq!(add5.apply_to(0), 5);
        assert_ok_eq!(add5.apply_to(95), 100);
        assert_err!(add5.apply_to(96));

        // Testing a delta of +5 with history now. We should consider three
        // cases: underflow, overflow, and successful application.
        add5.history.max_achieved_positive_delta = 50;
        add5.history.min_achieved_negative_delta = 10;
        assert_err!(add5.apply_to(5)); // underflow: 5 - 10 < 0!
        assert_err!(add5.apply_to(51)); // overflow: 51 + 50 > 100!
        assert_ok_eq!(add5.apply_to(10), 15);
        assert_ok_eq!(add5.apply_to(50), 55);

        // Testing a fresh delta of -5.
        let mut sub5 = delta_sub(5, 100);
        assert_ok_eq!(sub5.apply_to(5), 0);
        assert_ok_eq!(sub5.apply_to(100), 95);
        assert_err!(sub5.apply_to(0));
        assert_err!(sub5.apply_to(4));

        // Now, similarly to addition test, update the delta with
        // some random history. Again, we have three cases to check.
        sub5.history.max_achieved_positive_delta = 10;
        sub5.history.min_achieved_negative_delta = 20;
        assert_err!(sub5.apply_to(19)); // underflow: 19 - 20 < 0!
        assert_err!(sub5.apply_to(91)); // overflow:  91 + 10 > 100!
        assert_ok_eq!(sub5.apply_to(20), 15);
        assert_ok_eq!(sub5.apply_to(90), 85);
    }

    #[test]
    fn test_delta_merge_plus() {
        use SignedU128::*;

        // Case 1: preserving old history and updating the value.
        // Explanation: value becomes +2+1 = +3, history remains unchanged
        // because +4 > +2+1 and -3 < 0.
        let a = delta_add_with_history(2, 100, 4, 3);
        let mut b = delta_add(1, 100);
        let mut c = a;
        let d = b;

        assert_ok!(b.merge_with_previous_delta(a));
        assert_ok!(c.merge_with_next_delta(d));
        assert_eq!(b, c);
        assert_eq!(b.update, Positive(3));
        assert_eq!(b.history.max_achieved_positive_delta, 4);
        assert_eq!(b.history.min_achieved_negative_delta, 3);

        // Case 2: updating history upper bound.
        // Explanation: again, value is clearly +3, but this time the upper bound
        // in history is updated with +3+4 > +4, but lower bound is preserved
        // with -3 < +3-4.
        let a = delta_add_with_history(2, 100, 4, 3);
        let mut b = delta_add_with_history(3, 100, 4, 4);
        let mut c = a;
        let d = b;

        assert_ok!(b.merge_with_previous_delta(a));
        assert_ok!(c.merge_with_next_delta(d));
        assert_eq!(b, c);
        assert_eq!(b.update, Positive(5));
        assert_eq!(b.history.max_achieved_positive_delta, 6);
        assert_eq!(b.history.min_achieved_negative_delta, 3);

        // Case 3: updating history lower bound.
        // Explanation: clearly, upper bound remains at +90, but lower bound
        // has to be updated with +5-10 < -3.
        let a = delta_add_with_history(5, 100, 90, 3);
        let mut b = delta_add_with_history(10, 100, 4, 10);
        let mut c = a;
        let d = b;

        assert_ok!(b.merge_with_previous_delta(a));
        assert_ok!(c.merge_with_next_delta(d));
        assert_eq!(b, c);
        assert_eq!(b.update, Positive(15));
        assert_eq!(b.history.max_achieved_positive_delta, 90);
        assert_eq!(b.history.min_achieved_negative_delta, 5);

        // Case 4: overflow on value.
        // Explanation: value overflows because +51+50 > 100.
        let a = delta_add(51, 100);
        let mut b = delta_add(50, 100);
        let mut c = a;
        let d = b;

        assert_err!(c.merge_with_next_delta(d));
        assert_err!(b.merge_with_previous_delta(a));

        // Case 5: overflow on upper bound in the history.
        // Explanation: the new upper bound would be +5+96 > 100 and should not
        // have happened.
        let a = delta_add_with_history(5, 100, 90, 3);
        let mut b = delta_add_with_history(10, 100, 96, 0);
        let mut c = a;
        let d = b;

        assert_err!(c.merge_with_next_delta(d));
        assert_err!(b.merge_with_previous_delta(a));

        // Case 6: updating value with changing the sign. Note that we do not
        // test history here and onwards, because that code is shared by
        // plus-plus and plus-minus cases.
        // Explanation: +24-23 = +1
        let a = delta_add(24, 100);
        let mut b = delta_sub(23, 100);
        let mut c = a;
        let d = b;

        assert_ok!(b.merge_with_previous_delta(a));
        assert_ok!(c.merge_with_next_delta(d));
        assert_eq!(b, c);
        assert_eq!(b.update, Positive(1));

        // Case 7: updating value with changing the sign.
        // Explanation: +23-24 = -1
        let a = delta_add(23, 100);
        let mut b = delta_sub_with_history(24, 100, 20, 20);
        let mut c = a;
        let d = b;

        assert_ok!(b.merge_with_previous_delta(a));
        assert_ok!(c.merge_with_next_delta(d));
        assert_eq!(b, c);
        assert_eq!(b.update, Negative(1));
    }

    #[test]
    fn test_delta_merge_minus() {
        use SignedU128::*;

        // Case 1: preserving old history and updating the value.
        // Explanation: value becomes -20-20 = -40, history remains unchanged
        // because +1 > 0 and -40 <= -20-0.
        let a = delta_sub_with_history(20, 100, 1, 40);
        let mut b = delta_sub(20, 100);
        let mut c = a;
        let d = b;

        assert_ok!(b.merge_with_previous_delta(a));
        assert_ok!(c.merge_with_next_delta(d));
        assert_eq!(b, c);
        assert_eq!(b.update, Negative(40));
        assert_eq!(b.history.max_achieved_positive_delta, 1);
        assert_eq!(b.history.min_achieved_negative_delta, 40);

        // Case 2: updating history upper bound.
        // Explanation: upper bound is changed because -2+7 > 4. Lower bound
        // remains unchanged because -2-7 > -10.
        let a = delta_sub_with_history(2, 100, 4, 10);
        let mut b = delta_sub_with_history(3, 100, 7, 7);
        let mut c = a;
        let d = b;

        assert_ok!(b.merge_with_previous_delta(a));
        assert_ok!(c.merge_with_next_delta(d));
        assert_eq!(b, c);
        assert_eq!(b.update, Negative(5));
        assert_eq!(b.history.max_achieved_positive_delta, 5);
        assert_eq!(b.history.min_achieved_negative_delta, 10);

        // Case 3: updating history lower bound.
        // Explanation: +90 > -5+95 and therefore upper bound remains the same.
        // For lower bound, we have to update it because -5-4 < -5.
        let a = delta_sub_with_history(5, 100, 90, 5);
        let mut b = delta_sub_with_history(10, 100, 95, 4);
        let mut c = a;
        let d = b;

        assert_ok!(b.merge_with_previous_delta(a));
        assert_ok!(c.merge_with_next_delta(d));
        assert_eq!(b, c);
        assert_eq!(b.update, Negative(15));
        assert_eq!(b.history.max_achieved_positive_delta, 90);
        assert_eq!(b.history.min_achieved_negative_delta, 9);

        // Case 4: underflow on value.
        // Explanation: value underflows because -50-51 clearly should have
        // never happened.
        let a = delta_sub(50, 100);
        let mut b = delta_sub(51, 100);
        let mut c = a;
        let d = b;

        assert_err!(c.merge_with_next_delta(d));
        assert_err!(b.merge_with_previous_delta(a));

        // Case 5: underflow on lower bound in the history.
        // Explanation: the new lower bound would be -5-96 which clearly underflows.
        let a = delta_sub_with_history(5, 100, 0, 3);
        let mut b = delta_sub_with_history(10, 100, 0, 96);
        let mut c = a;
        let d = b;

        assert_err!(c.merge_with_next_delta(d));
        assert_err!(b.merge_with_previous_delta(a));

        // Case 6: updating value with changing the sign.
        // Explanation: -24+23 = -1.
        let a = delta_sub(24, 100);
        let mut b = delta_add(23, 100);
        let mut c = a;
        let d = b;

        assert_ok!(b.merge_with_previous_delta(a));
        assert_ok!(c.merge_with_next_delta(d));
        assert_eq!(b, c);
        assert_eq!(b.update, Negative(1));

        // Case 7: updating value with changing the sign.
        // Explanation: +23-24 = +1.
        let a = delta_add(23, 100);
        let mut b = delta_sub_with_history(24, 100, 20, 20);
        let mut c = a;
        let d = b;

        assert_ok!(b.merge_with_previous_delta(a));
        assert_ok!(c.merge_with_next_delta(d));
        assert_eq!(b, c);
        assert_eq!(b.update, Negative(1));
    }

    static KEY: Lazy<StateKey> = Lazy::new(|| StateKey::raw(b"test-key"));

    #[test]
    fn test_failed_write_op_conversion_because_of_empty_storage() {
        let state_view = FakeAggregatorView::default();
        let delta_op = delta_add(10, 1000);

        let err =
            assert_err!(state_view.try_convert_aggregator_v1_delta_into_write_op(&KEY, &delta_op));
        assert_eq!(
            err.major_status(),
            StatusCode::SPECULATIVE_EXECUTION_ABORT_ERROR
        );
        assert_none!(err.sub_status());
    }

    struct BadStorage;

    impl TAggregatorV1View for BadStorage {
        type Identifier = StateKey;

        fn get_aggregator_v1_state_value(
            &self,
            _id: &Self::Identifier,
        ) -> PartialVMResult<Option<StateValue>> {
            Err(
                PartialVMError::new(StatusCode::SPECULATIVE_EXECUTION_ABORT_ERROR)
                    .with_message("Error message from BadStorage.".to_string()),
            )
        }
    }

    impl TDelayedFieldView for BadStorage {
        type Identifier = ();
        type ResourceGroupTag = ();
        type ResourceKey = ();

        fn get_delayed_field_value(
            &self,
            _id: &Self::Identifier,
        ) -> Result<DelayedFieldValue, PanicOr<DelayedFieldsSpeculativeError>> {
            Err(code_invariant_error("Error message from BadStorage.").into())
        }

        fn delayed_field_try_add_delta_outcome(
            &self,
            _id: &Self::Identifier,
            _base_delta: &SignedU128,
            _delta: &SignedU128,
            _max_value: u128,
        ) -> Result<bool, PanicOr<DelayedFieldsSpeculativeError>> {
            Err(code_invariant_error("Error message from BadStorage.").into())
        }

        fn generate_delayed_field_id(&self, _width: u32) -> Self::Identifier {
            unimplemented!("Irrelevant for the test")
        }

        fn validate_delayed_field_id(&self, _id: &Self::Identifier) -> Result<(), PanicError> {
            unimplemented!("Irrelevant for the test")
        }

        fn get_reads_needing_exchange(
            &self,
            _delayed_write_set_keys: &HashSet<Self::Identifier>,
            _skip: &HashSet<Self::ResourceKey>,
        ) -> Result<
            BTreeMap<Self::ResourceKey, (StateValueMetadata, u64, TriompheArc<MoveTypeLayout>)>,
            PanicError,
        > {
            unimplemented!("Irrelevant for the test")
        }

        fn get_group_reads_needing_exchange(
            &self,
            _delayed_write_set_keys: &HashSet<Self::Identifier>,
            _skip: &HashSet<Self::ResourceKey>,
        ) -> PartialVMResult<BTreeMap<Self::ResourceKey, (StateValueMetadata, u64)>> {
            unimplemented!("Irrelevant for the test")
        }
    }

    #[test]
    fn test_failed_write_op_conversion_because_of_speculative_error() {
        let state_view = BadStorage;
        let delta_op = delta_add(10, 1000);

        let err =
            assert_err!(state_view.try_convert_aggregator_v1_delta_into_write_op(&KEY, &delta_op));
        assert_eq!(
            err.major_status(),
            StatusCode::SPECULATIVE_EXECUTION_ABORT_ERROR
        );
        assert_none!(err.sub_status());
    }

    #[test]
    fn test_successful_write_op_conversion() {
        let mut state_view = FakeAggregatorView::default();
        state_view.set_from_state_key(KEY.clone(), 100);

        // Both addition and subtraction should succeed!
        let add_op = delta_add(100, 200);
        let sub_op = delta_sub(100, 200);

        let add_result = state_view.try_convert_aggregator_v1_delta_into_write_op(&KEY, &add_op);
        assert_ok_eq!(
            add_result,
            WriteOp::legacy_modification(serialize(&200).into())
        );

        let sub_result = state_view.try_convert_aggregator_v1_delta_into_write_op(&KEY, &sub_op);
        assert_ok_eq!(
            sub_result,
            WriteOp::legacy_modification(serialize(&0).into())
        );
    }

    #[test]
    fn test_unsuccessful_write_op_conversion() {
        let mut state_view = FakeAggregatorView::default();
        state_view.set_from_state_key(KEY.clone(), 100);

        // Both addition and subtraction should fail!
        let add_op = delta_add(15, 100);
        let sub_op = delta_sub(101, 1000);

        let err =
            assert_err!(state_view.try_convert_aggregator_v1_delta_into_write_op(&KEY, &add_op));
        assert_eq!(err.major_status(), StatusCode::ABORTED);
        assert_some_eq!(err.sub_status(), EADD_OVERFLOW);

        let err =
            assert_err!(state_view.try_convert_aggregator_v1_delta_into_write_op(&KEY, &sub_op));
        assert_eq!(err.major_status(), StatusCode::ABORTED);
        assert_some_eq!(err.sub_status(), ESUB_UNDERFLOW);
    }
}
```

**File:** aptos-move/aptos-aggregator/src/bounded_math.rs (L1-219)
```rust
// Copyright (c) Aptos Foundation
// Licensed pursuant to the Innovation-Enabling Source Code License, available at https://github.com/aptos-labs/aptos-core/blob/main/LICENSE

#[derive(Debug, PartialEq, Eq)]
pub enum BoundedMathError {
    Overflow,
    Underflow,
}

pub type BoundedMathResult<T> = ::std::result::Result<T, BoundedMathError>;

pub fn ok_overflow<T>(value: BoundedMathResult<T>) -> BoundedMathResult<Option<T>> {
    match value {
        Ok(value) => Ok(Some(value)),
        Err(BoundedMathError::Overflow) => Ok(None),
        Err(BoundedMathError::Underflow) => Err(BoundedMathError::Underflow),
    }
}

pub fn ok_underflow<T>(value: BoundedMathResult<T>) -> BoundedMathResult<Option<T>> {
    match value {
        Ok(value) => Ok(Some(value)),
        Err(BoundedMathError::Overflow) => Err(BoundedMathError::Overflow),
        Err(BoundedMathError::Underflow) => Ok(None),
    }
}

fn negate_error<T>(result: BoundedMathResult<T>) -> BoundedMathResult<T> {
    result.map_err(|err| match err {
        BoundedMathError::Overflow => BoundedMathError::Underflow,
        BoundedMathError::Underflow => BoundedMathError::Overflow,
    })
}

// Unsigned operations operate on [0, max_value] range.
// Signed operations operate on [-max_value, max_value] range.
pub struct BoundedMath {
    max_value: u128,
}

impl BoundedMath {
    pub fn new(max_value: u128) -> Self {
        Self { max_value }
    }

    pub fn get_max_value(&self) -> u128 {
        self.max_value
    }

    pub fn unsigned_add(&self, base: u128, value: u128) -> BoundedMathResult<u128> {
        if self.max_value < base || value > (self.max_value - base) {
            Err(BoundedMathError::Overflow)
        } else {
            Ok(base + value)
        }
    }

    pub fn unsigned_subtract(&self, base: u128, value: u128) -> BoundedMathResult<u128> {
        if value > base {
            Err(BoundedMathError::Underflow)
        } else {
            Ok(base - value)
        }
    }

    pub fn unsigned_add_delta(&self, base: u128, delta: &SignedU128) -> BoundedMathResult<u128> {
        match delta {
            SignedU128::Positive(value) => self.unsigned_add(base, *value),
            SignedU128::Negative(value) => self.unsigned_subtract(base, *value),
        }
    }

    pub fn signed_add(
        &self,
        left: &SignedU128,
        right: &SignedU128,
    ) -> BoundedMathResult<SignedU128> {
        // Another useful macro, this time for merging deltas with different signs, such
        // as +A-B and -A+B. In these cases we have to check which of A or B is greater
        // and possibly flip a sign.
        macro_rules! update_different_sign {
            ($a:ident, $b:ident) => {
                if $a >= $b {
                    SignedU128::Positive(self.unsigned_subtract(*$a, *$b)?)
                } else {
                    SignedU128::Negative(self.unsigned_subtract(*$b, *$a)?)
                }
            };
        }

        Ok(match (left, right) {
            (SignedU128::Positive(v1), SignedU128::Positive(v2)) => {
                SignedU128::Positive(self.unsigned_add(*v1, *v2)?)
            },
            (SignedU128::Positive(v1), SignedU128::Negative(v2)) => update_different_sign!(v1, v2),
            (SignedU128::Negative(v1), SignedU128::Positive(v2)) => update_different_sign!(v2, v1),
            (SignedU128::Negative(v1), SignedU128::Negative(v2)) => {
                SignedU128::Negative(negate_error(self.unsigned_add(*v1, *v2))?)
            },
        })
    }
}

#[derive(Clone, Copy, Debug)]
pub enum SignedU128 {
    Positive(u128),
    Negative(u128),
}

impl PartialEq for SignedU128 {
    fn eq(&self, other: &Self) -> bool {
        match (self, other) {
            (Self::Positive(v1), Self::Positive(v2)) | (Self::Negative(v1), Self::Negative(v2)) => {
                v1 == v2
            },
            (Self::Positive(v1), Self::Negative(v2)) | (Self::Negative(v1), Self::Positive(v2)) => {
                *v1 == 0 && *v2 == 0
            },
        }
    }
}

impl Eq for SignedU128 {}

impl SignedU128 {
    pub fn is_zero(&self) -> bool {
        match self {
            Self::Positive(value) => *value == 0,
            Self::Negative(value) => *value == 0,
        }
    }

    pub fn delta(&self, positive: u128, negative: u128) -> Self {
        if positive >= negative {
            Self::Positive(positive - negative)
        } else {
            Self::Negative(negative - positive)
        }
    }

    pub fn minus(&self) -> Self {
        match self {
            Self::Positive(value) => Self::Negative(*value),
            Self::Negative(value) => Self::Positive(*value),
        }
    }

    pub fn abs(&self) -> u128 {
        match self {
            Self::Positive(value) | Self::Negative(value) => *value,
        }
    }
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn test_unsigned_add_delta() {
        let math = BoundedMath::new(100);
        assert_eq!(
            math.unsigned_add_delta(10, &SignedU128::Positive(5)),
            Ok(15)
        );
        assert_eq!(math.unsigned_add_delta(10, &SignedU128::Negative(5)), Ok(5));
        assert_eq!(
            math.unsigned_add_delta(10, &SignedU128::Positive(950)),
            Err(BoundedMathError::Overflow)
        );
        assert_eq!(
            math.unsigned_add_delta(10, &SignedU128::Negative(11)),
            Err(BoundedMathError::Underflow)
        );
    }

    #[test]
    fn test_delta_minus() {
        assert_eq!(SignedU128::Positive(10).minus(), SignedU128::Negative(10));
        assert_eq!(SignedU128::Negative(10).minus(), SignedU128::Positive(10));
    }

    #[test]
    fn test_signed_add() {
        let math = BoundedMath::new(100);
        assert_eq!(
            math.signed_add(&SignedU128::Positive(10), &SignedU128::Positive(5)),
            Ok(SignedU128::Positive(15))
        );
        assert_eq!(
            math.signed_add(&SignedU128::Positive(10), &SignedU128::Negative(5)),
            Ok(SignedU128::Positive(5))
        );
        assert_eq!(
            math.signed_add(&SignedU128::Negative(10), &SignedU128::Positive(5)),
            Ok(SignedU128::Negative(5))
        );
        assert_eq!(
            math.signed_add(&SignedU128::Negative(10), &SignedU128::Negative(5)),
            Ok(SignedU128::Negative(15))
        );
        assert_eq!(
            math.signed_add(&SignedU128::Positive(10), &SignedU128::Positive(90)),
            Ok(SignedU128::Positive(100))
        );
        assert_eq!(
            math.signed_add(&SignedU128::Positive(10), &SignedU128::Positive(91)),
            Err(BoundedMathError::Overflow)
        );
        assert_eq!(
            math.signed_add(&SignedU128::Negative(10), &SignedU128::Negative(90)),
            Ok(SignedU128::Negative(100))
        );
        assert_eq!(
            math.signed_add(&SignedU128::Negative(10), &SignedU128::Negative(91)),
            Err(BoundedMathError::Underflow)
        );
    }
}
```

**File:** aptos-move/aptos-aggregator/src/delta_math.rs (L1-405)
```rust
// Copyright (c) Aptos Foundation
// Licensed pursuant to the Innovation-Enabling Source Code License, available at https://github.com/aptos-labs/aptos-core/blob/main/LICENSE

use crate::{
    bounded_math::{ok_overflow, ok_underflow, BoundedMath, SignedU128},
    types::{
        DelayedFieldsSpeculativeError, DeltaApplicationFailureReason,
        DeltaHistoryMergeOffsetFailureReason,
    },
};
use aptos_types::error::{expect_ok, PanicOr};

/// Tracks values seen by aggregator. In particular, stores information about
/// the biggest and the smallest deltas that were applied successfully during
/// execution in the VM, as well as the smallest and the largest delta that failed
/// being applied. This information can be used by the executor to check if
/// final starting value would produce the same results for try_add/try_sub calls,
/// or re-execution is needed.
///  Most importantly, it allows commutativity of adds/subs. Example:
///
///
/// This graph shows how delta of aggregator changed during a single transaction
/// execution:
///
/// ```text
///                   X
///         X         :
/// +C ===========================================>
///         :         :
/// +A ===========================================>
///         :  ||     :
///         :||||     :                         +Z
///         |||||  ||||||                    ||||
///      |||||||||||||||||||||||||          |||||
/// +0 ===========================================> time
///            :          ||||||
///            :            ||
///            :            ||
/// -B ===========================================>
///            :             :
///            :             :
/// -D ===========================================>
///            X             :
///                          :
///                          X
/// ```
///
/// Clearly, +Z succeeds if +A and -B succeed, and +C and -D fail.
/// Therefore each delta validation consists of:
///   1. check +A did not overflow
///   2. check -B did not drop below zero
///   3. check +C did overflow
///   4. check -D does drop below zero
///
/// Checking +X is irrelevant since +A >= +Z, and so Z is not stored here.
#[derive(Clone, Hash, Copy, Default, PartialOrd, Ord, PartialEq, Eq)]
pub struct DeltaHistory {
    pub max_achieved_positive_delta: u128,
    pub min_achieved_negative_delta: u128,
    // `min_overflow_positive_delta` is None in two possible cases:
    // 1. No overflow occurred in the try_add/try_sub functions throughout the
    // transaction execution.
    // 2. The only overflows that occurred in the try_add/try_sub functions in
    // this transaction execution are with delta that exceeds limit.
    pub min_overflow_positive_delta: Option<u128>,
    // `max_underflow_negative_delta` is None in two possible cases:
    // 1. No underflow occurred in the try_add/try_sub functions throughout the
    // transaction execution.
    // 2. The only underflows that occurred in the try_add/try_sub functions in
    // this transaction execution are with delta that drops below -limit.
    pub max_underflow_negative_delta: Option<u128>,
}

impl std::fmt::Debug for DeltaHistory {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "history: (")?;
        if let Some(underflow) = self.max_underflow_negative_delta {
            write!(f, "underflow: -{}, ", underflow)?;
        };
        write!(
            f,
            "achieved: [-{}, {}]",
            self.min_achieved_negative_delta, self.max_achieved_positive_delta
        )?;
        if let Some(overflow) = self.min_overflow_positive_delta {
            write!(f, ", overflow: {}", overflow)?;
        };
        Ok(())
    }
}

impl DeltaHistory {
    pub fn new() -> Self {
        DeltaHistory {
            max_achieved_positive_delta: 0,
            min_achieved_negative_delta: 0,
            min_overflow_positive_delta: None,
            max_underflow_negative_delta: None,
        }
    }

    pub fn is_empty(&self) -> bool {
        self.max_achieved_positive_delta == 0
            && self.min_achieved_negative_delta == 0
            && self.min_overflow_positive_delta.is_none()
            && self.max_underflow_negative_delta.is_none()
    }

    /// Records observed delta in history. Should be called after an operation (addition/subtraction)
    /// is successful to record its side-effects.
    pub fn record_success(&mut self, delta: SignedU128) {
        match delta {
            SignedU128::Positive(value) => {
                self.max_achieved_positive_delta =
                    u128::max(self.max_achieved_positive_delta, value)
            },
            SignedU128::Negative(value) => {
                self.min_achieved_negative_delta =
                    u128::max(self.min_achieved_negative_delta, value)
            },
        }
    }

    fn record_failure(field: &mut Option<u128>, delta: u128) {
        *field = (*field).map_or(Some(delta), |min| Some(u128::min(min, delta)));
    }

    /// Records overflows in history. Should be called after an addition is unsuccessful
    /// to record its side-effects.
    pub fn record_overflow(&mut self, delta: u128) {
        Self::record_failure(&mut self.min_overflow_positive_delta, delta);
    }

    /// Records underflows in history. Should be called after a subtraction is unsuccessful
    /// to record its side-effects.
    pub fn record_underflow(&mut self, delta: u128) {
        Self::record_failure(&mut self.max_underflow_negative_delta, delta);
    }

    /// Validates if aggregator's history is correct when applied to the `base_value`.
    /// For example, if history observed a delta of +100, and the aggregator max_value
    /// is 150, then the base value of 60 will not pass validation (60 + 100 > 150),
    /// but the base value of 30 will (30 + 100 < 150).
    /// To validate the history of an aggregator, we want to ensure that if the
    /// `base_value` is the starting value of the aggregator before the transaction
    /// execution, all the previous calls to try_add/try_sub functions returned the
    /// correct result.
    pub fn validate_against_base_value(
        &self,
        base_value: u128,
        max_value: u128,
    ) -> Result<(), DelayedFieldsSpeculativeError> {
        let math = BoundedMath::new(max_value);
        // We need to make sure the following 4 conditions are satisified.
        //     base_value + max_achieved_positive_delta <= self.max_value
        //     base_value >= min_achieved_negative_delta
        //     base_value + min_overflow_positive_delta > self.max_value
        //     base_value < max_underflow_negative_delta
        math.unsigned_add(base_value, self.max_achieved_positive_delta)
            .map_err(|_e| DelayedFieldsSpeculativeError::DeltaApplication {
                base_value,
                max_value,
                delta: SignedU128::Positive(self.max_achieved_positive_delta),
                reason: DeltaApplicationFailureReason::Overflow,
            })?;
        math.unsigned_subtract(base_value, self.min_achieved_negative_delta)
            .map_err(|_e| DelayedFieldsSpeculativeError::DeltaApplication {
                base_value,
                max_value,
                delta: SignedU128::Negative(self.min_achieved_negative_delta),
                reason: DeltaApplicationFailureReason::Underflow,
            })?;

        if let Some(min_overflow_positive_delta) = self.min_overflow_positive_delta {
            if base_value <= max_value - min_overflow_positive_delta {
                return Err(DelayedFieldsSpeculativeError::DeltaApplication {
                    base_value,
                    max_value,
                    delta: SignedU128::Positive(min_overflow_positive_delta),
                    reason: DeltaApplicationFailureReason::ExpectedOverflow,
                });
            }
        }

        if let Some(max_underflow_negative_delta) = self.max_underflow_negative_delta {
            if base_value >= max_underflow_negative_delta {
                return Err(DelayedFieldsSpeculativeError::DeltaApplication {
                    base_value,
                    max_value,
                    delta: SignedU128::Negative(max_underflow_negative_delta),
                    reason: DeltaApplicationFailureReason::ExpectedUnderflow,
                });
            }
        }

        Ok(())
    }

    fn offset_and_merge_min_overflow(
        min_overflow: &Option<u128>,
        prev_delta: &SignedU128,
        prev_min_overflow: &Option<u128>,
        math: &BoundedMath,
    ) -> Result<Option<u128>, DelayedFieldsSpeculativeError> {
        let adjusted_min_overflow = min_overflow.map_or(
            Ok(None),
            // Return Result<Option<u128>>. we want to have None on overflow,
            // and to fail the merging on underflow
            |min_overflow| {
                ok_overflow(math.unsigned_add_delta(min_overflow, prev_delta)).map_err(|_| {
                    DelayedFieldsSpeculativeError::DeltaHistoryMergeOffset {
                        target: min_overflow,
                        delta: *prev_delta,
                        max_value: math.get_max_value(),
                        reason:
                            DeltaHistoryMergeOffsetFailureReason::FailureNotExceedingBoundsAnyMore,
                    }
                })
            },
        )?;

        Ok(match (adjusted_min_overflow, prev_min_overflow) {
            (Some(a), Some(b)) => Some(u128::min(a, *b)),
            (a, b) => a.or(*b),
        })
    }

    fn offset_and_merge_max_achieved(
        max_achieved: u128,
        prev_delta: &SignedU128,
        prev_max_achieved: u128,
        math: &BoundedMath,
    ) -> Result<u128, DelayedFieldsSpeculativeError> {
        Ok(
            ok_underflow(math.unsigned_add_delta(max_achieved, prev_delta))
                .map_err(|_| DelayedFieldsSpeculativeError::DeltaHistoryMergeOffset {
                    target: max_achieved,
                    delta: *prev_delta,
                    max_value: math.get_max_value(),
                    reason: DeltaHistoryMergeOffsetFailureReason::AchievedExceedsBounds,
                })?
                .map_or(prev_max_achieved, |value| {
                    u128::max(prev_max_achieved, value)
                }),
        )
    }

    pub fn offset_and_merge_history(
        &self,
        prev_delta: &SignedU128,
        prev_history: &Self,
        max_value: u128,
    ) -> Result<DeltaHistory, DelayedFieldsSpeculativeError> {
        let math = BoundedMath::new(max_value);

        let new_min_overflow = Self::offset_and_merge_min_overflow(
            &self.min_overflow_positive_delta,
            prev_delta,
            &prev_history.min_overflow_positive_delta,
            &math,
        )?;
        // max_underflow is identical to min_overflow, except that we offset in the opposite direction.
        let new_max_underflow = Self::offset_and_merge_min_overflow(
            &self.max_underflow_negative_delta,
            &prev_delta.minus(),
            &prev_history.max_underflow_negative_delta,
            &math,
        )?;

        // new_max_achieved = max(prev_max_achieved, max_achieved + prev_delta)
        // When adjusting max_achieved, if underflow - than the other is bigger,
        // but if overflow - we fail the merge, as we cannot successfully achieve
        // delta larger than max_value.
        let new_max_achieved = Self::offset_and_merge_max_achieved(
            self.max_achieved_positive_delta,
            prev_delta,
            prev_history.max_achieved_positive_delta,
            &math,
        )?;

        // new_min_achieved = max(prev_min_achieved, min_achieved - prev_delta)
        // Same as above, except for offsetting in the opposite direction.
        let new_min_achieved = Self::offset_and_merge_max_achieved(
            self.min_achieved_negative_delta,
            &prev_delta.minus(),
            prev_history.min_achieved_negative_delta,
            &math,
        )?;

        if new_min_overflow.is_some_and(|v| v <= new_max_achieved) {
            return Err(
                DelayedFieldsSpeculativeError::DeltaHistoryMergeAchievedAndFailureOverlap {
                    achieved: SignedU128::Positive(new_max_achieved),
                    overflow: SignedU128::Positive(new_min_overflow.unwrap()),
                },
            );
        }
        if new_max_underflow.is_some_and(|v| v <= new_min_achieved) {
            return Err(
                DelayedFieldsSpeculativeError::DeltaHistoryMergeAchievedAndFailureOverlap {
                    achieved: SignedU128::Negative(new_min_achieved),
                    overflow: SignedU128::Negative(new_max_underflow.unwrap()),
                },
            );
        }

        Ok(Self {
            max_achieved_positive_delta: new_max_achieved,
            min_achieved_negative_delta: new_min_achieved,
            min_overflow_positive_delta: new_min_overflow,
            max_underflow_negative_delta: new_max_underflow,
        })
    }

    pub fn stricter_than(&self, other: &DeltaHistory) -> bool {
        self.max_achieved_positive_delta >= other.max_achieved_positive_delta
            && self.min_achieved_negative_delta >= other.min_achieved_negative_delta
            && other.min_overflow_positive_delta.is_none_or(|other_v| {
                self.min_overflow_positive_delta
                    .is_some_and(|self_v| self_v <= other_v)
            })
            && other.max_underflow_negative_delta.is_none_or(|other_v| {
                self.max_underflow_negative_delta
                    .is_some_and(|self_v| self_v <= other_v)
            })
    }
}

pub fn merge_data_and_delta(
    prev_value: u128,
    delta: &SignedU128,
    history: &DeltaHistory,
    max_value: u128,
) -> Result<u128, PanicOr<DelayedFieldsSpeculativeError>> {
    // First, validate if the current delta operation can be applied to the base.
    history.validate_against_base_value(prev_value, max_value)?;
    // Then, apply the delta. Since history was validated, this should never fail.
    Ok(expect_ok(
        BoundedMath::new(max_value).unsigned_add_delta(prev_value, delta),
    )?)
}

pub fn merge_two_deltas(
    prev_delta: &SignedU128,
    prev_history: &DeltaHistory,
    next_delta: &SignedU128,
    next_history: &DeltaHistory,
    max_value: u128,
) -> Result<(SignedU128, DeltaHistory), PanicOr<DelayedFieldsSpeculativeError>> {
    let new_history = next_history.offset_and_merge_history(prev_delta, prev_history, max_value)?;
    let new_delta = expect_ok(BoundedMath::new(max_value).signed_add(prev_delta, next_delta))?;
    Ok((new_delta, new_history))
}

#[cfg(test)]
mod test {
    use crate::delta_math::DeltaHistory;
    use claims::{assert_err, assert_ok};

    #[test]
    fn test_change_in_base_value_1() {
        let history = DeltaHistory {
            max_achieved_positive_delta: 300,
            min_achieved_negative_delta: 200,
            min_overflow_positive_delta: None,
            max_underflow_negative_delta: None,
        };
        let max_value = 600;
        assert_ok!(history.validate_against_base_value(200, max_value));
        assert_err!(history.validate_against_base_value(199, max_value));
        assert_ok!(history.validate_against_base_value(300, max_value));
        assert_err!(history.validate_against_base_value(301, max_value));
    }

    #[test]
    fn test_change_in_base_value_2() {
        let history = DeltaHistory {
            max_achieved_positive_delta: 300,
            min_achieved_negative_delta: 0,
            min_overflow_positive_delta: Some(401),
            max_underflow_negative_delta: None,
        };
        let max_value = 600;
        assert_err!(history.validate_against_base_value(199, max_value));
        assert_ok!(history.validate_against_base_value(200, max_value));
        assert_ok!(history.validate_against_base_value(300, max_value));
        assert_err!(history.validate_against_base_value(301, max_value));
    }

    #[test]
    fn test_change_in_base_value_3() {
        let history = DeltaHistory {
            max_achieved_positive_delta: 200,
            min_achieved_negative_delta: 100,
            min_overflow_positive_delta: None,
            max_underflow_negative_delta: Some(201),
        };
        let max_value = 600;
        assert_ok!(history.validate_against_base_value(100, max_value));
        assert_ok!(history.validate_against_base_value(199, max_value));
        assert_ok!(history.validate_against_base_value(200, max_value));
        assert_err!(history.validate_against_base_value(201, max_value));
        assert_err!(history.validate_against_base_value(400, max_value));
    }
}
```

**File:** aptos-move/aptos-aggregator/src/types.rs (L1-228)
```rust
// Copyright (c) Aptos Foundation
// Licensed pursuant to the Innovation-Enabling Source Code License, available at https://github.com/aptos-labs/aptos-core/blob/main/LICENSE

use crate::bounded_math::SignedU128;
use aptos_types::error::{code_invariant_error, NonPanic, PanicError, PanicOr};
use move_binary_format::errors::PartialVMError;
use move_core_types::{
    value::{IdentifierMappingKind, MoveTypeLayout},
    vm_status::StatusCode,
};
use move_vm_types::{
    delayed_values::{
        delayed_field_id::{DelayedFieldID, TryFromMoveValue},
        derived_string_snapshot::{
            bytes_and_width_to_derived_string_struct, derived_string_struct_to_bytes_and_length,
            is_derived_string_struct_layout,
        },
    },
    values::{Struct, Value},
};

impl From<DelayedFieldsSpeculativeError> for PartialVMError {
    fn from(err: DelayedFieldsSpeculativeError) -> Self {
        PartialVMError::from(PanicOr::from(err))
    }
}

/// Different reasons for why applying new start_value doesn't
/// satisfy history bounds
#[derive(Clone, Debug, PartialEq, Eq)]
pub enum DeltaApplicationFailureReason {
    /// max_achieved wouldn't be within bounds
    Overflow,
    /// min_achieved wouldn't be within bounds
    Underflow,
    /// min_overflow wouldn't cause overflow any more
    ExpectedOverflow,
    /// max_underflow wouldn't cause underflow any more
    ExpectedUnderflow,
}

/// Different reasons for why merging two Deltas (value + history) failed,
/// because newer one couldn't be offsetted by the delta value
/// of the older one.
#[derive(Clone, Debug, PartialEq, Eq)]
pub enum DeltaHistoryMergeOffsetFailureReason {
    /// If we offset achieved, it exceeds bounds
    AchievedExceedsBounds,
    /// if we offset failure (overflow/underflow), it cannot
    /// exceed bounds any more (because it went on the opposite side of 0)
    FailureNotExceedingBoundsAnyMore,
}

#[derive(Clone, Debug, PartialEq, Eq)]
pub enum DelayedFieldsSpeculativeError {
    /// DelayedField with given ID couldn't be found
    /// (due to speculative nature), but must exist.
    NotFound(DelayedFieldID),
    /// Applying new start_value doesn't satisfy history bounds.
    DeltaApplication {
        base_value: u128,
        max_value: u128,
        delta: SignedU128,
        reason: DeltaApplicationFailureReason,
    },
    /// Merging two Deltas (value only) failed.
    DeltaMerge {
        base_delta: SignedU128,
        delta: SignedU128,
        max_value: u128,
    },
    /// Merging two Deltas (value + history) failed, because newer
    /// one couldn't be offsetted by the delta value of the older one.
    DeltaHistoryMergeOffset {
        target: u128,
        delta: SignedU128,
        max_value: u128,
        reason: DeltaHistoryMergeOffsetFailureReason,
    },
    /// Merging two Deltas (value + history) failed, because no value
    /// could satisfy both achieved and failure (overflow/underflow)
    /// bounds, as they now overlap.
    DeltaHistoryMergeAchievedAndFailureOverlap {
        achieved: SignedU128,
        overflow: SignedU128,
    },
    InconsistentRead,
}

impl NonPanic for DelayedFieldsSpeculativeError {}

/// Value of a DelayedField (i.e. aggregator or snapshot)
#[derive(Clone, Debug, Eq, PartialEq)]
pub enum DelayedFieldValue {
    Aggregator(u128),
    Snapshot(u128),
    // TODO[agg_v2](optimize) probably change to Derived(Arc<Vec<u8>>) to make copying predictably costly
    Derived(Vec<u8>),
}

impl DelayedFieldValue {
    pub fn into_aggregator_value(self) -> Result<u128, PanicError> {
        match self {
            DelayedFieldValue::Aggregator(value) => Ok(value),
            DelayedFieldValue::Snapshot(_) => Err(code_invariant_error(
                "Tried calling into_aggregator_value on Snapshot value",
            )),
            DelayedFieldValue::Derived(_) => Err(code_invariant_error(
                "Tried calling into_aggregator_value on String SnapshotValue",
            )),
        }
    }

    pub fn into_snapshot_value(self) -> Result<u128, PanicError> {
        match self {
            DelayedFieldValue::Snapshot(value) => Ok(value),
            DelayedFieldValue::Aggregator(_) => Err(code_invariant_error(
                "Tried calling into_snapshot_value on Aggregator value",
            )),
            DelayedFieldValue::Derived(_) => Err(code_invariant_error(
                "Tried calling into_snapshot_value on String SnapshotValue",
            )),
        }
    }

    pub fn into_derived_value(self) -> Result<Vec<u8>, PanicError> {
        match self {
            DelayedFieldValue::Derived(value) => Ok(value),
            DelayedFieldValue::Aggregator(_) => Err(code_invariant_error(
                "Tried calling into_derived_value on Aggregator value",
            )),
            DelayedFieldValue::Snapshot(_) => Err(code_invariant_error(
                "Tried calling into_derived_value on Snapshot value",
            )),
        }
    }

    pub fn try_into_move_value(
        self,
        layout: &MoveTypeLayout,
        width: u32,
    ) -> Result<Value, PartialVMError> {
        use DelayedFieldValue::*;
        use MoveTypeLayout::*;

        Ok(match (self, layout) {
            (Aggregator(v) | Snapshot(v), U64) => {
                if width != 8 {
                    return Err(PartialVMError::new(StatusCode::VM_EXTENSION_ERROR)
                        .with_message(format!("Expected width 8 for U64, got {}", width)));
                }
                Value::u64(v as u64)
            },
            (Aggregator(v) | Snapshot(v), U128) => {
                if width != 16 {
                    return Err(PartialVMError::new(StatusCode::VM_EXTENSION_ERROR)
                        .with_message(format!("Expected width 16 for U128, got {}", width)));
                }
                Value::u128(v)
            },
            (Derived(bytes), layout) if is_derived_string_struct_layout(layout) => {
                bytes_and_width_to_derived_string_struct(bytes, width as usize)?
            },
            (value, layout) => {
                return Err(
                    PartialVMError::new(StatusCode::VM_EXTENSION_ERROR).with_message(format!(
                        "Failed to convert {:?} into Move value with {} layout",
                        value, layout
                    )),
                )
            },
        })
    }

    /// Approximate memory consumption of current DelayedFieldValue
    pub fn get_approximate_memory_size(&self) -> usize {
        // 32 + len
        std::mem::size_of::<DelayedFieldValue>()
            + match &self {
                DelayedFieldValue::Aggregator(_) | DelayedFieldValue::Snapshot(_) => 0,
                // additional allocated memory for the data:
                DelayedFieldValue::Derived(v) => v.len(),
            }
    }
}

impl TryFromMoveValue for DelayedFieldValue {
    type Error = PartialVMError;
    // Need to distinguish between aggregators and snapshots of integer types.
    // TODO[agg_v2](cleanup): We only need that because of the current enum-based
    // implementations. See if we want to keep that separation, or clean it up.
    type Hint = IdentifierMappingKind;

    fn try_from_move_value(
        layout: &MoveTypeLayout,
        value: Value,
        hint: &Self::Hint,
    ) -> Result<(Self, u32), Self::Error> {
        use DelayedFieldValue::*;
        use IdentifierMappingKind as K;
        use MoveTypeLayout as L;

        Ok(match (hint, layout) {
            (K::Aggregator, L::U64) => (Aggregator(value.value_as::<u64>()? as u128), 8),
            (K::Aggregator, L::U128) => (Aggregator(value.value_as::<u128>()?), 16),
            (K::Snapshot, L::U64) => (Snapshot(value.value_as::<u64>()? as u128), 8),
            (K::Snapshot, L::U128) => (Snapshot(value.value_as::<u128>()?), 16),
            (K::DerivedString, layout) if is_derived_string_struct_layout(layout) => {
                let (bytes, width) =
                    derived_string_struct_to_bytes_and_length(value.value_as::<Struct>()?)?;
                (Derived(bytes), width)
            },
            _ => {
                return Err(
                    PartialVMError::new(StatusCode::VM_EXTENSION_ERROR).with_message(format!(
                        "Failed to convert Move value {:?} with {} layout into AggregatorValue",
                        value, layout
                    )),
                )
            },
        })
    }
}

pub enum ReadPosition {
    BeforeCurrentTxn,
    AfterCurrentTxn,
}
```

**File:** aptos-move/aptos-vm-types/src/change_set.rs (L420-480)
```rust
                            .map_err(PartialVMError::from)?;
                        write_op.set_bytes(serialize(&value).into())
                    },
                    None => {
                        // This case (applying a delta to deleted item) should
                        // never happen. Let's still return an error instead of
                        // panicking.
                        return Err(PartialVMError::new(
                            StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR,
                        )
                        .with_message(
                            "Cannot squash delta which was already deleted.".to_string(),
                        ));
                    },
                }
            } else {
                // Otherwise, this is a either a new delta or an additional delta
                // for the same state key.
                match aggregator_v1_delta_set.entry(state_key) {
                    Occupied(entry) => {
                        // In this case, we need to merge the new incoming delta
                        // to the existing delta, ensuring the strict ordering.
                        entry
                            .into_mut()
                            .merge_with_next_delta(additional_delta_op)
                            .map_err(PartialVMError::from)?;
                    },
                    Vacant(entry) => {
                        // We see this delta for the first time, so simply add it
                        // to the set.
                        entry.insert(additional_delta_op);
                    },
                }
            }
        }

        // Next, squash write ops.
        for (state_key, additional_write_op) in additional_aggregator_v1_write_set {
            match aggregator_v1_write_set.entry(state_key) {
                Occupied(mut entry) => {
                    squash_writes_pair!(entry, additional_write_op);
                },
                Vacant(entry) => {
                    // This is a new write op. It can overwrite a delta so we
                    // have to make sure we remove such a delta from the set in
                    // this case.
                    let removed_delta = aggregator_v1_delta_set.remove(entry.key());

                    // We cannot create after modification with a delta!
                    if removed_delta.is_some() && additional_write_op.is_creation() {
                        return Err(PartialVMError::new(
                            StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR,
                        )
                        .with_message(
                            "Cannot create a resource after modification with a delta.".to_string(),
                        ));
                    }

                    entry.insert(additional_write_op);
                },
            }
```

**File:** aptos-move/mvhashmap/src/versioned_delayed_fields.rs (L280-330)
```rust
                        .map(DelayedFieldValue::Aggregator)
                        .map(VersionedRead::Value);
                },
                (Value(_, _), _) => {
                    unreachable!("Value not DelayedFieldValue::Aggregator for Aggregator")
                },
                (Apply(AggregatorDelta { delta }), _)
                | (Estimate(Bypass(AggregatorDelta { delta })), true) => *delta,
                (Estimate(NoBypass), _) | (Estimate(_), false) => {
                    // We must wait on Estimates, or a bypass isn't available.
                    return Err(PanicOr::Or(MVDelayedFieldsError::Dependency(*idx)));
                },
                (Apply(_), _) | (Estimate(Bypass(_)), true) => {
                    unreachable!("Apply change type not AggregatorDelta for aggregator")
                },
            };

            // Read hit a delta during traversing the block and aggregating other deltas. We merge the
            // two deltas together. If there is an error, we return appropriate error
            // (DeltaApplicationError or PanicOr::CodeInvariantError
            // (there is no determinism concern as DeltaApplicationError may not occur in committed output).
            accumulator
                .merge_with_previous_delta(delta)
                .map_err(MVDelayedFieldsError::from_panic_or)?;
        }

        // Finally, resolve if needed with the base value.
        self.base_value
            .as_ref()
            .ok_or(PanicOr::Or(MVDelayedFieldsError::NotFound))
            .and_then(|base_value| match base_value {
                DelayedFieldValue::Aggregator(v) => accumulator
                    .apply_to(*v)
                    .map_err(MVDelayedFieldsError::from_panic_or)
                    .map(DelayedFieldValue::Aggregator)
                    .map(VersionedRead::Value),
                _ => Err(PanicOr::from(code_invariant_error(
                    "Found non-DelayedFieldValue::Aggregator base value for aggregator with delta",
                ))),
            })
    }

    // Reads a given aggregator value at a given version (transaction index) and produces
    // a ReadResult if successful, which is either a u128 value, or a snapshot specifying
    // a different aggregator (with ID) at a given version and a delta to apply on top.
    fn read(&self, txn_idx: TxnIndex) -> Result<VersionedRead<K>, PanicOr<MVDelayedFieldsError>> {
        use EstimatedEntry::*;
        use MVDelayedFieldsError::*;
        use VersionEntry::*;

        let mut iter = self.versioned_map.range(0..txn_idx);
```
