# Audit Report

## Title
TOCTOU Vulnerability in Version Upgrade Proposals Allows Governance Decision Override via Config Buffer Race Condition

## Summary
Multiple version upgrade proposals can execute within the same epoch when DKG-enabled reconfiguration is active, causing later proposals to silently overwrite earlier proposals in the config buffer. The validation in `version::set_for_next_epoch()` only checks against the current on-chain version, not any pending buffered version, allowing incompatible or out-of-order version upgrades.

## Finding Description

The vulnerability exists in the interaction between three components:

1. **Proposal Generation**: [1](#0-0) 
The Rust code generates Move scripts that call `version::set_for_next_epoch()` followed by `aptos_governance::reconfigure()`, with no validation of the version parameter against the current on-chain state.

2. **Version Validation**: [2](#0-1) 
The `set_for_next_epoch()` function validates only against the **current on-chain version** (not any pending buffered version), then calls `config_buffer::upsert()` which **overwrites** any existing buffered version.

3. **Config Buffer Mechanism**: [3](#0-2) 
The `upsert()` function uses `simple_map::upsert()` which overwrites previous values for the same config type, allowing later proposals to silently replace earlier ones.

4. **Async Reconfiguration**: [4](#0-3) 
When DKG is enabled, `try_start()` initiates an asynchronous DKG process. Subsequent calls return early if DKG is already in progress, allowing multiple proposals to execute before the epoch changes.

**Attack Scenario:**

**Time T0:** On-chain version = 5, no pending buffered version

**Time T1:** Governance Proposal A passes (upgrade to version 10)
- Transaction executes: `version::set_for_next_epoch(&signer, 10)`
  - Reads on-chain version: 5
  - Validates: 5 < 10 ✓
  - Calls `config_buffer::upsert(Version{10})` - buffers version 10
- Then calls: `aptos_governance::reconfigure(&signer)`
  - Initiates DKG session via `try_start()`
  - Epoch does NOT change immediately (DKG is async)

**Time T2:** Governance Proposal B passes (upgrade to version 6)
- Transaction executes: `version::set_for_next_epoch(&signer, 6)`
  - Reads on-chain version: **STILL 5** (epoch hasn't changed!)
  - Validates: 5 < 6 ✓
  - Calls `config_buffer::upsert(Version{6})` - **OVERWRITES** Version{10} with Version{6}
- Then calls: `aptos_governance::reconfigure(&signer)`
  - DKG already in progress for current epoch
  - Returns early without starting new DKG

**Time T3:** DKG completes, epoch boundary reached
- [5](#0-4) 
- `version::on_new_epoch()` extracts Version{6} from buffer
- **Version 6 is applied, version 10 is lost**
- Governance decision for version 10 is silently ignored

This breaks the **Governance Integrity** invariant - approved governance decisions must take effect as voted.

## Impact Explanation

**Severity: Medium** per Aptos Bug Bounty criteria - "State inconsistencies requiring intervention"

**Concrete Impacts:**

1. **Governance Decision Override**: Community-approved version upgrades are silently discarded without any error or notification, undermining the governance process.

2. **Incompatible Version States**: If version 10 was designed to upgrade from version 5 with specific prerequisites, but version 6 is applied first and then version 10's proposal fails on retry (since 6 < 10 validation would fail), the chain could be left in an unexpected state.

3. **Critical Upgrade Skipping**: If version 6 contains critical security fixes or state migrations, and version 10 overwrites it in the buffer, those critical updates are never applied.

4. **Consensus Impact Potential**: Different validators might execute proposals in different orders if there are transaction ordering variations, potentially causing state divergence (though unlikely given deterministic execution).

## Likelihood Explanation

**Likelihood: Medium-High** when DKG-enabled reconfiguration is active

**Factors increasing likelihood:**

1. **DKG Requirement**: The vulnerability only manifests when the `RECONFIGURE_WITH_DKG` feature is enabled and `randomness_config::enabled()` returns true. [6](#0-5) 

2. **Active Governance**: Requires multiple version upgrade proposals to be voted on and executed within the same epoch, which is realistic during active development or urgent upgrade scenarios.

3. **No Safeguards**: Unlike other config modules (e.g., `jwks.move`), the version module does not check for existing buffered values before upserting.

4. **Legitimate Use**: This can occur through normal governance operation without malicious intent - simply two legitimate upgrade proposals passing in the same epoch.

## Recommendation

**Solution 1: Check for Pending Buffered Version (Recommended)**

Modify `version::set_for_next_epoch()` to follow the pattern used in `jwks.move`:

```move
public entry fun set_for_next_epoch(account: &signer, major: u64) acquires Version {
    assert!(exists<SetVersionCapability>(signer::address_of(account)), error::permission_denied(ENOT_AUTHORIZED));
    
    // Check current on-chain version OR pending buffered version
    let old_major = if (config_buffer::does_exist<Version>()) {
        config_buffer::extract_v2<Version>().major
    } else {
        borrow_global<Version>(@aptos_framework).major
    };
    
    assert!(old_major < major, error::invalid_argument(EINVALID_MAJOR_VERSION_NUMBER));
    config_buffer::upsert(Version {major});
}
```

This ensures validation happens against any pending buffered version, not just the on-chain version. [7](#0-6) 

**Solution 2: Reject Multiple Version Upgrades in Same Epoch**

```move
public entry fun set_for_next_epoch(account: &signer, major: u64) acquires Version {
    assert!(exists<SetVersionCapability>(signer::address_of(account)), error::permission_denied(ENOT_AUTHORIZED));
    
    // Reject if there's already a pending version upgrade
    assert!(!config_buffer::does_exist<Version>(), error::invalid_state(EPENDING_VERSION_UPGRADE_EXISTS));
    
    let old_major = borrow_global<Version>(@aptos_framework).major;
    assert!(old_major < major, error::invalid_argument(EINVALID_MAJOR_VERSION_NUMBER));
    config_buffer::upsert(Version {major});
}
```

This prevents the race condition entirely by allowing only one version upgrade per epoch.

## Proof of Concept

```move
#[test(aptos_framework = @aptos_framework, proposer_1 = @0x123, proposer_2 = @0x234)]
public entry fun test_version_upgrade_toctou_vulnerability(
    aptos_framework: signer,
    proposer_1: signer,
    proposer_2: signer,
) acquires Version {
    // Initialize version to 5
    version::initialize(&aptos_framework, 5);
    config_buffer::initialize(&aptos_framework);
    
    // Setup: Enable DKG and randomness to trigger async reconfiguration
    // (In actual scenario, these would be enabled via governance)
    
    // Proposal 1: Upgrade to version 10
    // This represents a major upgrade that governance approved
    version::set_for_next_epoch(&aptos_framework, 10);
    assert!(config_buffer::does_exist<Version>(), 0);
    
    // Simulate that reconfigure() was called but DKG is still in progress
    // (Epoch has NOT changed, on-chain version is still 5)
    
    // Proposal 2: Upgrade to version 6
    // This represents another upgrade proposal that governance approved
    // The validation STILL checks against on-chain version 5, not buffered version 10
    version::set_for_next_epoch(&aptos_framework, 6);
    
    // Extract buffered version - it should be 6, not 10
    let buffered_version = config_buffer::extract_v2<Version>();
    assert!(buffered_version.major == 6, 1); // Version 10 was silently overwritten!
    
    // This demonstrates that:
    // 1. Both proposals validated successfully against version 5
    // 2. Both proposals executed without errors
    // 3. Only the second proposal's version (6) is in the buffer
    // 4. The first proposal's version (10) was silently lost
    // 5. Governance decision for version 10 is effectively ignored
}
```

**Notes:**
- This vulnerability requires DKG-enabled reconfiguration to be active
- The issue is in production code paths, not test code
- The fix should validate against pending buffered versions, following the pattern in `jwks.move`
- This represents a governance integrity violation where approved decisions are silently overridden

### Citations

**File:** aptos-move/aptos-release-builder/src/components/version.rs (L10-40)
```rust
pub fn generate_version_upgrade_proposal(
    version: &AptosVersion,
    is_testnet: bool,
    next_execution_hash: Option<HashValue>,
    is_multi_step: bool,
) -> Result<Vec<(String, String)>> {
    let signer_arg = get_signer_arg(is_testnet, &next_execution_hash);
    let mut result = vec![];

    let writer = CodeWriter::new(Loc::default());

    let proposal = generate_governance_proposal(
        &writer,
        is_testnet,
        next_execution_hash,
        is_multi_step,
        &["aptos_framework::version"],
        |writer| {
            emitln!(
                writer,
                "version::set_for_next_epoch({}, {});",
                signer_arg,
                version.major,
            );
            emitln!(writer, "aptos_governance::reconfigure({});", signer_arg);
        },
    );

    result.push(("version".to_string(), proposal));
    Ok(result)
}
```

**File:** aptos-move/framework/aptos-framework/sources/configs/version.move (L59-64)
```text
    public entry fun set_for_next_epoch(account: &signer, major: u64) acquires Version {
        assert!(exists<SetVersionCapability>(signer::address_of(account)), error::permission_denied(ENOT_AUTHORIZED));
        let old_major = borrow_global<Version>(@aptos_framework).major;
        assert!(old_major < major, error::invalid_argument(EINVALID_MAJOR_VERSION_NUMBER));
        config_buffer::upsert(Version {major});
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/version.move (L67-77)
```text
    public(friend) fun on_new_epoch(framework: &signer) acquires Version {
        system_addresses::assert_aptos_framework(framework);
        if (config_buffer::does_exist<Version>()) {
            let new_value = config_buffer::extract_v2<Version>();
            if (exists<Version>(@aptos_framework)) {
                *borrow_global_mut<Version>(@aptos_framework) = new_value;
            } else {
                move_to(framework, new_value);
            }
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/config_buffer.move (L62-70)
```text
    /// Upsert an on-chain config to the buffer for the next epoch.
    ///
    /// Typically used in `X::set_for_next_epoch()` where X is an on-chain config.
    public(friend) fun upsert<T: drop + store>(config: T) acquires PendingConfigs {
        let configs = borrow_global_mut<PendingConfigs>(@aptos_framework);
        let key = type_info::type_name<T>();
        let value = any::pack(config);
        simple_map::upsert(&mut configs.configs, key, value);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/reconfiguration_with_dkg.move (L22-40)
```text
    /// Trigger a reconfiguration with DKG.
    /// Do nothing if one is already in progress.
    public(friend) fun try_start() {
        let incomplete_dkg_session = dkg::incomplete_session();
        if (option::is_some(&incomplete_dkg_session)) {
            let session = option::borrow(&incomplete_dkg_session);
            if (dkg::session_dealer_epoch(session) == reconfiguration::current_epoch()) {
                return
            }
        };
        reconfiguration_state::on_reconfig_start();
        let cur_epoch = reconfiguration::current_epoch();
        dkg::start(
            cur_epoch,
            randomness_config::current(),
            stake::cur_validator_consensus_infos(),
            stake::next_validator_consensus_infos(),
        );
    }
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L685-692)
```text
    public entry fun reconfigure(aptos_framework: &signer) {
        system_addresses::assert_aptos_framework(aptos_framework);
        if (consensus_config::validator_txn_enabled() && randomness_config::enabled()) {
            reconfiguration_with_dkg::try_start();
        } else {
            reconfiguration_with_dkg::finish(aptos_framework);
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L352-363)
```text
    public fun remove_oidc_provider_for_next_epoch(fx: &signer, name: vector<u8>): Option<vector<u8>> acquires SupportedOIDCProviders {
        system_addresses::assert_aptos_framework(fx);

        let provider_set = if (config_buffer::does_exist<SupportedOIDCProviders>()) {
            config_buffer::extract_v2<SupportedOIDCProviders>()
        } else {
            *borrow_global<SupportedOIDCProviders>(@aptos_framework)
        };
        let ret = remove_oidc_provider_internal(&mut provider_set, name);
        config_buffer::upsert(provider_set);
        ret
    }
```
