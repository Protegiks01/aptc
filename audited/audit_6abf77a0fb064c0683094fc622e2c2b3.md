# Audit Report

## Title
Ledger History Corruption via Non-Monotonic Version Writes in put_ledger_info()

## Summary
The `put_ledger_info()` function does not enforce version monotonicity, and the normal commit path uses `>=` instead of `>` when validating version progression. While the normal commit path has root hash validation providing partial protection, the backup/restore path has no version checks at all, allowing out-of-order ledger info writes that can corrupt epoch tracking and ledger history consistency.

## Finding Description

The `put_ledger_info()` function in `ledger_metadata_db.rs` lacks any version monotonicity enforcement. [1](#0-0) 

The function writes to two schemas:
- `LedgerInfoSchema`: keyed by **epoch** (one entry per epoch) [2](#0-1) 
- `EpochByVersionSchema`: keyed by **version** (maps epoch-ending versions to epochs) [3](#0-2) 

### Critical Flaw #1: Version Check Uses >= Instead of >

In the normal commit path, `get_and_check_commit_range()` validates version progression using `>=` instead of `>`: [4](#0-3) 

This allows re-committing the **same version**, which should never be permitted. While the root hash validation provides some protection in the normal path, [5](#0-4)  this is a defense-in-depth violation.

### Critical Flaw #2: Restore Path Has Zero Version Validation

The backup/restore path calls `save_ledger_infos_impl()` which has **no version monotonicity checks**: [6](#0-5) 

This function blindly writes all provided ledger infos without verifying:
- Versions are in increasing order
- Versions don't conflict with existing committed data
- Versions are consistent within the same epoch

### Exploitation Scenarios

**Scenario A: Epoch Tracking Corruption via Restore**

During backup restore or state sync finalization, an operator or compromised state sync process could write: [7](#0-6) 

1. Epoch 5 ending at version 100
2. Epoch 5 ending at version 99 (out of order)

Result:
- Both versions 99 and 100 are marked as ending epoch 5 in `EpochByVersionSchema`
- Only the last LedgerInfo (version 99) is stored in `LedgerInfoSchema` for epoch 5
- `get_epoch()` queries now return inconsistent results [8](#0-7) 
- Nodes using this corrupted database will have different epoch boundaries than honest nodes

**Scenario B: Same-Version Re-commit**

The `>=` check allows committing version N when version N is already committed. While root hash validation prevents writing different content, this violates the fundamental invariant that each version should be committed exactly once.

## Impact Explanation

**Severity: Medium (up to $10,000)**

This vulnerability causes **state inconsistencies requiring intervention** per the Aptos bug bounty criteria. Specifically:

1. **Epoch Boundary Corruption**: Different nodes could have inconsistent epoch tracking, breaking consensus assumptions about epoch transitions
2. **Ledger History Inconsistency**: Out-of-order writes create databases where epoch-ending versions don't match the stored LedgerInfo
3. **Database Integrity Violation**: The fundamental invariant that versions progress monotonically is broken

While this doesn't directly enable fund theft or immediate consensus safety violations, it corrupts critical blockchain metadata that could lead to:
- Node disagreement on epoch boundaries
- Incorrect epoch state queries
- State sync failures when nodes compare epoch histories
- Requirement for manual database intervention to restore consistency

The impact is elevated because epoch tracking is foundational to AptosBFT consensus and validator rotation.

## Likelihood Explanation

**Likelihood: Medium**

The vulnerability is exploitable through:

1. **Backup/Restore Operations**: Operators performing database restoration could inadvertently or maliciously introduce out-of-order ledger infos if backup data is corrupted or manipulated
2. **State Sync Edge Cases**: The `finalize_state_snapshot()` path could potentially write out-of-order data if state sync sources provide inconsistent epoch histories
3. **Genesis Setup**: The `commit_genesis_ledger_info()` function also lacks version validation [9](#0-8) 

The `>=` flaw in normal commit is constantly exposed but mitigated by root hash validation. However, any future code changes that bypass this check could immediately expose the vulnerability.

## Recommendation

### Fix #1: Enforce Strict Version Monotonicity in put_ledger_info()

Add version monotonicity validation directly in `put_ledger_info()`:

```rust
pub(crate) fn put_ledger_info(
    &self,
    ledger_info_with_sigs: &LedgerInfoWithSignatures,
    batch: &mut SchemaBatch,
) -> Result<()> {
    let ledger_info = ledger_info_with_sigs.ledger_info();
    
    // NEW: Enforce version monotonicity
    if let Some(latest) = self.get_latest_ledger_info_option() {
        ensure!(
            ledger_info.version() > latest.ledger_info().version(),
            "Version must be strictly increasing. Current: {}, Attempting: {}",
            latest.ledger_info().version(),
            ledger_info.version()
        );
    }
    
    if ledger_info.ends_epoch() {
        batch.put::<EpochByVersionSchema>(&ledger_info.version(), &ledger_info.epoch())?;
    }
    batch.put::<LedgerInfoSchema>(&ledger_info.epoch(), ledger_info_with_sigs)
}
```

### Fix #2: Change >= to > in get_and_check_commit_range() [4](#0-3) 

Change line 526 from:
```rust
old_committed_ver.is_none() || version_to_commit >= old_committed_ver.unwrap(),
```
to:
```rust
old_committed_ver.is_none() || version_to_commit > old_committed_ver.unwrap(),
```

### Fix #3: Add Version Validation in save_ledger_infos_impl()

Validate that ledger infos are provided in increasing version order:

```rust
fn save_ledger_infos_impl(
    ledger_metadata_db: &LedgerMetadataDb,
    ledger_infos: &[LedgerInfoWithSignatures],
    batch: &mut SchemaBatch,
) -> Result<()> {
    // NEW: Validate monotonicity
    for i in 1..ledger_infos.len() {
        ensure!(
            ledger_infos[i].ledger_info().version() > ledger_infos[i-1].ledger_info().version(),
            "Ledger infos must be in increasing version order"
        );
    }
    
    ledger_infos
        .iter()
        .map(|li| ledger_metadata_db.put_ledger_info(li, batch))
        .collect::<Result<Vec<_>>>()?;

    Ok(())
}
```

## Proof of Concept

```rust
#[test]
fn test_out_of_order_ledger_info_corruption() {
    use aptos_types::ledger_info::LedgerInfo;
    use aptos_schemadb::SchemaBatch;
    
    // Setup: Create a mock AptosDB instance
    let tmpdir = aptos_temppath::TempPath::new();
    let db = AptosDB::new_for_test(&tmpdir);
    let metadata_db = db.ledger_db.metadata_db();
    
    // Create two ledger infos for the same epoch but different versions
    let epoch = 5;
    let version_100 = create_mock_epoch_ending_ledger_info(epoch, 100);
    let version_99 = create_mock_epoch_ending_ledger_info(epoch, 99);
    
    // Write version 100 first (correct order)
    let mut batch1 = SchemaBatch::new();
    metadata_db.put_ledger_info(&version_100, &mut batch1).unwrap();
    metadata_db.write_schemas(batch1).unwrap();
    
    // Now write version 99 (out of order) - THIS SHOULD FAIL BUT DOESN'T
    let mut batch2 = SchemaBatch::new();
    metadata_db.put_ledger_info(&version_99, &mut batch2).unwrap();
    metadata_db.write_schemas(batch2).unwrap();
    
    // Verify corruption: both versions are marked as ending epoch 5
    assert!(db.get_epoch(99).unwrap() == epoch); // Returns 5
    assert!(db.get_epoch(100).unwrap() == epoch); // Also returns 5
    
    // But the stored LedgerInfo is from version 99 (last write wins)
    let stored = metadata_db.get_latest_ledger_info_in_epoch(epoch).unwrap();
    assert_eq!(stored.ledger_info().version(), 99); // CORRUPTION: Should be 100
    
    // This creates inconsistent state where epoch 5 "ends" at both v99 and v100
}
```

## Notes

The vulnerability exists but requires either operator-level access (restore path) or specific edge cases in state sync. While the normal consensus path has defense-in-depth via root hash validation, the `>=` check and lack of inherent version monotonicity in `put_ledger_info()` represent design flaws that violate critical invariants and could enable future exploits if the protective checks are ever bypassed or removed.

### Citations

**File:** storage/aptosdb/src/ledger_db/ledger_metadata_db.rs (L186-198)
```rust
    pub(crate) fn put_ledger_info(
        &self,
        ledger_info_with_sigs: &LedgerInfoWithSignatures,
        batch: &mut SchemaBatch,
    ) -> Result<()> {
        let ledger_info = ledger_info_with_sigs.ledger_info();

        if ledger_info.ends_epoch() {
            // This is the last version of the current epoch, update the epoch by version index.
            batch.put::<EpochByVersionSchema>(&ledger_info.version(), &ledger_info.epoch())?;
        }
        batch.put::<LedgerInfoSchema>(&ledger_info.epoch(), ledger_info_with_sigs)
    }
```

**File:** storage/aptosdb/src/ledger_db/ledger_metadata_db.rs (L204-231)
```rust
    pub(crate) fn get_epoch(&self, version: Version) -> Result<u64> {
        let mut iter = self.db.iter::<EpochByVersionSchema>()?;
        // Search for the end of the previous epoch.
        iter.seek_for_prev(&version)?;
        let (epoch_end_version, epoch) = match iter.next().transpose()? {
            Some(x) => x,
            None => {
                // There should be a genesis LedgerInfo at version 0 (genesis only consists of one
                // transaction), so this normally doesn't happen. However this part of
                // implementation doesn't need to rely on this assumption.
                return Ok(0);
            },
        };
        ensure!(
            epoch_end_version <= version,
            "DB corruption: looking for epoch for version {}, got epoch {} ends at version {}",
            version,
            epoch,
            epoch_end_version
        );
        // If the obtained epoch ended before the given version, return epoch+1, otherwise
        // the given version is exactly the last version of the found epoch.
        Ok(if epoch_end_version < version {
            epoch + 1
        } else {
            epoch
        })
    }
```

**File:** storage/aptosdb/src/schema/ledger_info/mod.rs (L26-31)
```rust
define_schema!(
    LedgerInfoSchema,
    u64, /* epoch num */
    LedgerInfoWithSignatures,
    LEDGER_INFO_CF_NAME
);
```

**File:** storage/aptosdb/src/schema/epoch_by_version/mod.rs (L27-32)
```rust
define_schema!(
    EpochByVersionSchema,
    Version,
    u64, // epoch_num
    EPOCH_BY_VERSION_CF_NAME
);
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L200-205)
```rust
            // Save the epoch ending ledger infos
            restore_utils::save_ledger_infos(
                self.ledger_db.metadata_db(),
                ledger_infos,
                Some(&mut ledger_db_batch.ledger_metadata_db_batches),
            )?;
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L525-530)
```rust
        ensure!(
            old_committed_ver.is_none() || version_to_commit >= old_committed_ver.unwrap(),
            "Version too old to commit. Committed: {:?}; Trying to commit with LI: {}",
            old_committed_ver,
            version_to_commit,
        );
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L556-569)
```rust
        // Verify the root hash.
        let db_root_hash = self
            .ledger_db
            .transaction_accumulator_db()
            .get_root_hash(version)?;
        let li_root_hash = ledger_info_with_sig
            .ledger_info()
            .transaction_accumulator_hash();
        ensure!(
            db_root_hash == li_root_hash,
            "Root hash pre-committed doesn't match LedgerInfo. pre-commited: {:?} vs in LedgerInfo: {:?}",
            db_root_hash,
            li_root_hash,
        );
```

**File:** storage/aptosdb/src/backup/restore_utils.rs (L179-190)
```rust
fn save_ledger_infos_impl(
    ledger_metadata_db: &LedgerMetadataDb,
    ledger_infos: &[LedgerInfoWithSignatures],
    batch: &mut SchemaBatch,
) -> Result<()> {
    ledger_infos
        .iter()
        .map(|li| ledger_metadata_db.put_ledger_info(li, batch))
        .collect::<Result<Vec<_>>>()?;

    Ok(())
}
```

**File:** storage/aptosdb/src/db/mod.rs (L207-219)
```rust
    pub fn commit_genesis_ledger_info(&self, genesis_li: &LedgerInfoWithSignatures) -> Result<()> {
        let ledger_metadata_db = self.ledger_db.metadata_db();
        let current_epoch = ledger_metadata_db
            .get_latest_ledger_info_option()
            .map_or(0, |li| li.ledger_info().next_block_epoch());
        ensure!(
            genesis_li.ledger_info().epoch() == current_epoch && current_epoch == 0,
            "Genesis ledger info epoch is not 0"
        );
        let mut ledger_batch = SchemaBatch::new();
        ledger_metadata_db.put_ledger_info(genesis_li, &mut ledger_batch)?;
        ledger_metadata_db.write_schemas(ledger_batch)
    }
```
