# Audit Report

## Title
Critical Unit Conversion Mismatch in Storage Fee Distribution Causes Economic Imbalance

## Summary
The storage fee conversion lacks validation between `storage_fee_used()` (Octa) and `storage_fee_used_in_gas_units()` (internal gas), and uses inconsistent formulas when charging versus distributing fees. The forward conversion includes a 1,000,000x scaling factor that is omitted in the reverse conversion, causing massive over-distribution of fees to block proposers.

## Finding Description

The system uses two different conversion formulas for storage fees:

**Forward conversion (charging):** [1](#0-0) 

Uses: `ceil((storage_fee_octas * gas_unit_scaling_factor) / gas_unit_price)` where `gas_unit_scaling_factor = 1,000,000` [2](#0-1) 

**Reverse conversion (fee distribution):** [3](#0-2) 

Uses: `ceil(storage_fee_octas / gas_price)` - **missing the scaling factor entirely**.

When calculating fees to distribute to proposers, the code drastically underestimates the gas consumed by storage fees by a factor of ~1,000,000x. This causes the system to over-distribute approximately 1,000,000x more fees to proposers than intended.

Additionally, there is no validation ensuring consistency between the two storage fee representations [4](#0-3) , and in out-of-gas scenarios, the values become permanently inconsistent [5](#0-4) .

## Impact Explanation

This breaks **Invariant #6 (Staking Security)** - validator rewards must be calculated correctly. The miscalculation affects the FeeDistribution passed to the block epilogue [6](#0-5) , leading to:

- Systematic over-distribution of transaction fees to block proposers
- Economic imbalance in the reward mechanism
- Potential depletion of fee pools
- Incorrect economic incentives for validators

While all validators execute the same buggy code and reach consensus on the wrong values (preventing direct consensus divergence), this qualifies as **High Severity** under "Significant protocol violations" as it fundamentally breaks the fee distribution mechanism that underpins validator economics.

## Likelihood Explanation

**Likelihood: High** - This bug triggers on every block with transactions containing storage fees. The fee distribution calculation executes deterministically across all validators, so the systematic error affects the entire network continuously. No special conditions or attacker actions are required beyond normal transaction processing.

## Recommendation

Add the missing scaling factor in the reverse conversion:

```rust
let gas_unit_available_to_distribute = total_gas_unit
    .saturating_sub(
        (fee_statement.storage_fee_used() * gas_unit_scaling_factor)
            .div_ceil(gas_price)
    );
```

Additionally, implement validation in the consistency check [7](#0-6)  to verify the unit conversion relationship between `storage_fee_used` and `storage_fee_in_internal_units`.

## Proof of Concept

```rust
// Test demonstrating the unit mismatch
#[test]
fn test_storage_fee_conversion_mismatch() {
    let storage_fee_octas: u64 = 1000; // 1000 octas storage fee
    let gas_unit_price: u64 = 100; // 100 octas per gas unit  
    let gas_unit_scaling_factor: u64 = 1_000_000;
    
    // Forward conversion (what gets charged)
    let charged_gas_units = ((storage_fee_octas as u128 * gas_unit_scaling_factor as u128) 
        / gas_unit_price as u128) as u64;
    // Result: (1000 * 1_000_000) / 100 = 10_000_000 gas units
    
    // Reverse conversion (what gets subtracted in fee distribution)
    let distributed_gas_units = storage_fee_octas / gas_unit_price;
    // Result: 1000 / 100 = 10 gas units
    
    // The mismatch: 10_000_000 charged vs 10 subtracted
    assert_ne!(charged_gas_units, distributed_gas_units);
    // Proposer receives ~1_000_000x more fees than intended!
}
```

## Notes

While this bug does not cause consensus divergence between validators in normal operation (as all execute the same code), it represents a critical economic vulnerability that breaks the fee distribution mechanism. The FeeStatement documentation [8](#0-7)  acknowledges potential precision loss but does not account for systematic formula errors of this magnitude.

### Citations

**File:** aptos-move/aptos-gas-meter/src/algebra.rs (L138-170)
```rust
    fn check_consistency(&self) -> PartialVMResult<()> {
        let total = self
            .initial_balance
            .checked_sub(self.balance)
            .ok_or_else(|| {
                PartialVMError::new(StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR).with_message(
                    format!(
                        "Current balance ({}) exceedes the initial balance ({}) -- how is this ever possible?",
                        self.balance,
                        self.initial_balance
                    ),
                )
            })?;

        let total_calculated =
            self.execution_gas_used + self.io_gas_used + self.storage_fee_in_internal_units;
        if total != total_calculated {
            return Err(
                PartialVMError::new(StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR).with_message(
                    format!(
                        "The per-category costs do not add up. {} (total) != {} = {} (exec) + {} (io) + {} (storage)",
                        total,
                        total_calculated,
                        self.execution_gas_used,
                        self.io_gas_used,
                        self.storage_fee_in_internal_units,
                    ),
                ),
            );
        }

        Ok(())
    }
```

**File:** aptos-move/aptos-gas-meter/src/algebra.rs (L260-263)
```rust
        let gas_consumed_internal = div_ceil(
            (u64::from(amount) as u128) * (u64::from(txn_params.gas_unit_scaling_factor) as u128),
            u64::from(gas_unit_price) as u128,
        );
```

**File:** aptos-move/aptos-gas-meter/src/algebra.rs (L282-290)
```rust
            None => {
                let old_balance = self.balance;
                self.balance = 0.into();
                if self.feature_version >= 12 {
                    self.storage_fee_in_internal_units += old_balance;
                    self.storage_fee_used += amount;
                }
                return Err(PartialVMError::new(StatusCode::OUT_OF_GAS));
            },
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L22-22)
```rust
const GAS_SCALING_FACTOR: u64 = 1_000_000;
```

**File:** aptos-move/block-executor/src/executor.rs (L2069-2069)
```rust
                            .saturating_sub(fee_statement.storage_fee_used().div_ceil(gas_price));
```

**File:** aptos-move/block-executor/src/executor.rs (L2079-2083)
```rust
        Ok(T::block_epilogue_v1(
            block_id,
            block_end_info,
            FeeDistribution::new(amount),
        ))
```

**File:** aptos-move/aptos-gas-meter/src/traits.rs (L88-91)
```rust
    fn storage_fee_used_in_gas_units(&self) -> InternalGas;

    /// Returns the amount of storage fee used.
    fn storage_fee_used(&self) -> Fee;
```

**File:** types/src/fee_statement.rs (L51-54)
```rust
        }
    }

    pub fn new(
```
