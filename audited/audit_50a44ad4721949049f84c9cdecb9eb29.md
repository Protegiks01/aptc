# Audit Report

## Title
Unmetered Type Tag Conversion in Closure Creation Enables Gas Estimation Attack

## Summary
The `PackClosure` and `PackClosureGeneric` instructions charge flat gas costs that do not account for the computational complexity of converting type arguments to type tags. This allows attackers to create closures with many complex type parameters, causing disproportionate CPU consumption on validator nodes without paying proportional gas costs.

## Finding Description

During closure creation, the Move VM converts runtime type arguments to `TypeTag` representations via the `ty_to_ty_tag()` function. This conversion is computationally expensive for complex or deeply nested types, involving recursive traversal of type structures, struct tag construction, and caching operations. [1](#0-0) 

The gas metering for closure creation only charges based on the number of captured arguments, not the type argument complexity: [2](#0-1) [3](#0-2) 

The type tag conversion uses a `PseudoGasContext` for internal limits, but this is NOT the actual transaction gas meter: [4](#0-3) [5](#0-4) 

The `PseudoGasContext` only prevents pathological cases (via `TYPE_TAG_LIMIT_EXCEEDED` error) but does not charge actual transaction gas for the work performed.

**Attack Flow:**
1. Attacker creates a generic Move function with many type parameters (e.g., 50+)
2. Instantiates the function with complex, nested struct types
3. Creates closures from this instantiation via `PackClosureGeneric`
4. Gas charged: `pack_closure_generic_base (908) + pack_closure_generic_per_arg (147) × captured_count`
5. Actual CPU work: Recursive type tag conversion for all 50+ complex type arguments
6. Repeats across multiple transactions to exhaust validator CPU resources

Additionally, when closures are read via `ReadRef`, the gas visitor does not account for the `ty_args` vector size stored inside the abstract function: [6](#0-5) 

The visitor visits captured values but not the metadata inside the `LazyLoadedFunction`, which contains the `ty_args` vector.

## Impact Explanation

This vulnerability enables **validator node slowdowns** (High Severity per Aptos bug bounty):

- Attackers can create transactions that perform disproportionate CPU work relative to gas paid
- Each transaction creates closures with complex type arguments, triggering expensive type tag conversions
- The flat gas cost (908 + 147×n) remains constant regardless of type argument complexity
- Sustained attacks cause validator CPU exhaustion, degrading network performance
- Breaks the **Resource Limits invariant**: "All operations must respect gas, storage, and computational limits"

The `PseudoGasContext` limit prevents extreme pathological cases but allows a significant gap where moderately complex types (within the limit) are severely under-charged relative to their computational cost.

## Likelihood Explanation

**High likelihood:**
- Any transaction sender can craft Move modules with generic functions
- Type instantiation with complex types is a standard Move feature
- No special privileges or validator access required
- Attack can be automated and repeated across multiple transactions
- The gap between gas charged and CPU consumed is exploitable within normal blockchain parameters

## Recommendation

**Solution 1: Meter type tag conversion during closure creation**

Modify `charge_pack_closure` to accept type arguments and charge based on their complexity:

```rust
fn charge_pack_closure(
    &mut self,
    is_generic: bool,
    ty_args: &[Type],
    args: impl ExactSizeIterator<Item = impl ValueView>,
) -> PartialVMResult<()> {
    let num_args = NumArgs::new(args.len() as u64);
    let num_ty_args = NumArgs::new(ty_args.len() as u64);
    
    // Estimate type complexity (could use pseudo-gas cost from PseudoGasContext)
    let ty_complexity_cost = self.estimate_type_complexity(ty_args)?;
    
    let base_cost = if is_generic {
        PACK_CLOSURE_GENERIC_BASE
    } else {
        PACK_CLOSURE_BASE
    };
    
    self.algebra.charge_execution(
        base_cost + 
        PACK_CLOSURE_PER_ARG * num_args +
        PACK_CLOSURE_PER_TY_ARG * num_ty_args +
        ty_complexity_cost
    )
}
```

**Solution 2: Include ty_args in gas visitor pattern**

Modify the closure visitor to account for stored metadata: [7](#0-6) 

Update to charge for `ty_args` vector size stored in the abstract function.

## Proof of Concept

**Move module demonstrating the attack:**

```move
module attacker::gas_exploit {
    use std::vector;
    
    // Generic function with many type parameters
    public fun complex_function<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10,
                                 T11, T12, T13, T14, T15, T16, T17, T18, T19, T20>(
        _x: u64
    ): u64 {
        42
    }
    
    // Nested struct types for maximum complexity
    struct Nested1<T> { val: T }
    struct Nested2<T> { val: Nested1<T> }
    struct Nested3<T> { val: Nested2<T> }
    struct Nested4<T> { val: Nested3<T> }
    struct Nested5<T> { val: Nested4<T> }
    
    // Create closures with complex type instantiations
    public fun exploit() {
        // Instantiate with deeply nested types
        let f = |x| complex_function<
            Nested5<u64>, Nested5<u128>, Nested5<u256>,
            Nested5<vector<u64>>, Nested5<vector<u128>>,
            vector<Nested5<u64>>, vector<Nested5<u128>>,
            Nested4<Nested3<u64>>, Nested4<Nested3<u128>>,
            vector<vector<Nested3<u64>>>,
            Nested5<Nested4<u64>>, Nested5<Nested4<u128>>,
            vector<Nested5<Nested4<u64>>>,
            Nested3<vector<Nested2<u128>>>,
            vector<Nested4<vector<u64>>>,
            Nested5<vector<Nested3<u128>>>,
            vector<vector<Nested4<u64>>>,
            Nested3<Nested4<Nested5<u64>>>,
            vector<Nested5<vector<Nested4<u128>>>>,
            Nested4<vector<Nested5<vector<u64>>>>
        >(x);
        
        // Each closure creation triggers expensive type tag conversion
        // but only pays flat gas cost
        let _ = f(1);
    }
}
```

**Exploitation steps:**
1. Deploy the above module
2. Submit multiple transactions calling `exploit()`
3. Each transaction creates a closure with 20 deeply nested type arguments
4. Type tag conversion processes complex nested structures recursively
5. Gas charged: ~908 units (flat)
6. CPU cost: Proportional to type nesting depth × number of type args
7. Monitor validator CPU usage increasing disproportionately to gas consumed

**Notes:**
This vulnerability breaks the gas metering invariant and enables resource exhaustion attacks against validator nodes, qualifying as High Severity under the Aptos bug bounty program.

### Citations

**File:** third_party/move/move-vm/runtime/src/loader/function.rs (L262-274)
```rust
    pub(crate) fn new_resolved(
        layout_converter: &LayoutConverter<impl Loader>,
        gas_meter: &mut impl DependencyGasMeter,
        traversal_context: &mut TraversalContext,
        fun: Rc<LoadedFunction>,
        mask: ClosureMask,
    ) -> PartialVMResult<Self> {
        let runtime_environment = layout_converter.runtime_environment();
        let ty_args = fun
            .ty_args
            .iter()
            .map(|t| runtime_environment.ty_to_ty_tag(t))
            .collect::<PartialVMResult<Vec<_>>>()?;
```

**File:** aptos-move/aptos-gas-meter/src/meter.rs (L360-375)
```rust
    fn charge_pack_closure(
        &mut self,
        is_generic: bool,
        args: impl ExactSizeIterator<Item = impl ValueView>,
    ) -> PartialVMResult<()> {
        let num_args = NumArgs::new(args.len() as u64);

        match is_generic {
            false => self
                .algebra
                .charge_execution(PACK_CLOSURE_BASE + PACK_CLOSURE_PER_ARG * num_args),
            true => self.algebra.charge_execution(
                PACK_CLOSURE_GENERIC_BASE + PACK_CLOSURE_GENERIC_PER_ARG * num_args,
            ),
        }
    }
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/instr.rs (L96-99)
```rust
        [pack_closure_base: InternalGas, { RELEASE_V1_33.. => "pack_closure.base" }, 908],
        [pack_closure_per_arg: InternalGasPerArg,  { RELEASE_V1_33.. => "pack.closure.per_arg" }, 147],
        [pack_closure_generic_base: InternalGas,  { RELEASE_V1_33.. => "pack_closure_generic.base" }, 908],
        [pack_closure_generic_per_arg: InternalGasPerArg,  { RELEASE_V1_33.. => "pack_closure_generic.per_arg" }, 147],
```

**File:** third_party/move/move-vm/runtime/src/storage/ty_tag_converter.rs (L15-63)
```rust
struct PseudoGasContext {
    // Parameters for metering type tag construction:
    //   - maximum allowed cost,
    //   - base cost for any type to tag conversion,
    //   - cost for size of a struct tag.
    max_cost: u64,
    cost: u64,
    cost_base: u64,
    cost_per_byte: u64,
}

impl PseudoGasContext {
    fn new(vm_config: &VMConfig) -> Self {
        Self {
            max_cost: vm_config.type_max_cost,
            cost: 0,
            cost_base: vm_config.type_base_cost,
            cost_per_byte: vm_config.type_byte_cost,
        }
    }

    fn current_cost(&mut self) -> u64 {
        self.cost
    }

    fn charge_base(&mut self) -> PartialVMResult<()> {
        self.charge(self.cost_base)
    }

    fn charge_struct_tag(&mut self, struct_tag: &StructTag) -> PartialVMResult<()> {
        let size =
            (struct_tag.address.len() + struct_tag.module.len() + struct_tag.name.len()) as u64;
        self.charge(size * self.cost_per_byte)
    }

    fn charge(&mut self, amount: u64) -> PartialVMResult<()> {
        self.cost += amount;
        if self.cost > self.max_cost {
            Err(
                PartialVMError::new(StatusCode::TYPE_TAG_LIMIT_EXCEEDED).with_message(format!(
                    "Exceeded maximum type tag limit of {} when charging {}",
                    self.max_cost, amount
                )),
            )
        } else {
            Ok(())
        }
    }
}
```

**File:** third_party/move/move-vm/runtime/src/storage/ty_tag_converter.rs (L231-234)
```rust
    pub(crate) fn ty_to_ty_tag(&self, ty: &Type) -> PartialVMResult<TypeTag> {
        let mut gas_context = PseudoGasContext::new(self.runtime_environment.vm_config());
        self.ty_to_ty_tag_impl(ty, &mut gas_context)
    }
```

**File:** third_party/move/move-vm/types/src/values/values_impl.rs (L5548-5557)
```rust
impl Closure {
    fn visit_impl(&self, visitor: &mut impl ValueVisitor, depth: u64) -> PartialVMResult<()> {
        let Self(_, captured) = self;
        if visitor.visit_closure(depth, captured.len())? {
            for val in captured.iter() {
                val.visit_impl(visitor, depth + 1)?;
            }
        }
        Ok(())
    }
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/misc.rs (L321-325)
```rust
    fn visit_closure(&mut self, depth: u64, _len: usize) -> PartialVMResult<bool> {
        self.check_depth(depth)?;
        self.size += self.params.closure;
        Ok(true)
    }
```
