# Audit Report

## Title
Pruner Configuration Allows State Value Pruning Before Merkle Node Pruning, Causing State Sync Failures and Network Partition Risk

## Summary
The Aptos storage pruner system lacks validation to ensure that the state merkle tree prune window is compatible with the state key-value prune window. This allows operators to configure pruners such that state values are pruned before their corresponding merkle tree nodes, causing proof verification failures that prevent state sync and can lead to network partition.

## Finding Description

The Aptos storage system uses two independent pruners that operate on different data structures:

1. **StateKvPruner**: Prunes actual state values (StateValue entries) [1](#0-0) 

2. **StateMerklePruner**: Prunes Jellyfish Merkle tree nodes [2](#0-1) 

These pruners are configured with independent prune windows and are triggered at different points in the system:

- StateKvPruner is triggered synchronously after transaction commits [3](#0-2) 

- StateMerklePruner is triggered asynchronously after state snapshots are persisted [4](#0-3) 

The pruners use different configuration parameters:
- StateKvPruner uses `ledger_pruner_config.prune_window` (default: 90M versions) [5](#0-4) 
- StateMerklePruner uses `state_merkle_pruner_config.prune_window` (default: 1M versions) [6](#0-5) 

**The Vulnerability:**

When retrieving state values with proofs, the system performs a two-step process:

1. Traverse the merkle tree to get the value_index (StateKey, Version) from the leaf node
2. Use the value_index to retrieve the actual state value [7](#0-6) 

The `expect_value_by_version` method returns an error if the state value is missing [8](#0-7) 

**Exploitation Scenario:**

If an operator configures:
- `state_merkle_pruner_config.prune_window = 100_000_000` (100M)
- `ledger_pruner_config.prune_window = 50_000_000` (50M)

At blockchain version 150M:
- StateKvPruner prunes values up to version 100M (150M - 50M)
- StateMerklePruner prunes nodes up to version 50M (150M - 100M)

For version 75M:
- Merkle tree nodes still exist (75M > 50M)
- State values have been pruned (75M < 100M)
- Leaf nodes reference non-existent state values

When a peer requests state proof for version 75M:
- Merkle tree traversal succeeds
- `expect_value_by_version` fails with NotFound error
- State sync cannot complete

**Critical Design Flaw:**

The configuration sanitizer validates individual prune windows but does NOT validate their relationship [9](#0-8) 

The sanitizer checks:
- `state_merkle_prune_window >= 100_000` (warning only)
- `ledger_prune_window >= 50_000_000` (warning only)

But it never validates that `state_merkle_prune_window <= ledger_prune_window`, which is required to maintain the invariant that merkle nodes should not reference pruned state values.

## Impact Explanation

This vulnerability qualifies as **Critical Severity** under the Aptos bug bounty program because it can cause:

1. **Non-recoverable network partition**: Nodes with misconfigured pruners cannot serve state sync requests, preventing new nodes from joining and existing nodes from recovering. This matches the "Non-recoverable network partition (requires hardfork)" criterion.

2. **Total loss of liveness**: If multiple validators are misconfigured, the network's ability to onboard new validators or recover failed ones is compromised.

3. **State Consistency violation**: The fundamental invariant "State transitions must be atomic and verifiable via Merkle proofs" is broken when merkle leaf nodes point to pruned state values.

The impact is severe because:
- State sync is critical for network health and decentralization
- New validators cannot bootstrap
- Failed nodes cannot recover
- The misconfiguration is not detected until nodes attempt state sync
- No automatic recovery mechanism exists

## Likelihood Explanation

**Likelihood: Medium-High**

While the default configuration is safe, the likelihood of exploitation is elevated because:

1. **No validation exists**: Operators can create dangerous configurations without any warning or error [10](#0-9) 

2. **Counterintuitive defaults**: The default state_merkle_prune_window (1M) is much smaller than ledger_prune_window (90M), which may confuse operators who assume larger values are always "safer"

3. **Documentation gap**: The configuration file does not explicitly document the required relationship between these prune windows

4. **Operational scenarios**: Operators might reasonably configure smaller ledger prune windows (to save disk space) while keeping large state merkle windows (for historical queries), inadvertently inverting the critical relationship

5. **Silent failure**: The misconfiguration doesn't cause immediate problems on the misconfigured node itself - it only manifests when other nodes try to sync from it

## Recommendation

Add explicit validation in the configuration sanitizer to enforce the invariant:

```rust
impl ConfigSanitizer for StorageConfig {
    fn sanitize(
        node_config: &NodeConfig,
        _node_type: NodeType,
        _chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();
        let config = &node_config.storage;

        let ledger_prune_window = config
            .storage_pruner_config
            .ledger_pruner_config
            .prune_window;
        let state_merkle_prune_window = config
            .storage_pruner_config
            .state_merkle_pruner_config
            .prune_window;
        
        // ADD THIS VALIDATION:
        if state_merkle_prune_window > ledger_prune_window {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                format!(
                    "state_merkle_prune_window ({}) must be <= ledger_prune_window ({}) \
                    to prevent merkle nodes from referencing pruned state values. \
                    Violating this invariant causes state sync failures.",
                    state_merkle_prune_window,
                    ledger_prune_window
                ),
            ));
        }

        // ... existing validations ...
    }
}
```

Additionally, add runtime checks in the pruner managers to detect and log dangerous configurations:

```rust
impl StateKvPrunerManager {
    pub fn new(state_kv_db: Arc<StateKvDb>, config: LedgerPrunerConfig) -> Self {
        // ADD RUNTIME WARNING:
        let state_merkle_window = /* get from state merkle pruner */;
        if state_merkle_window > config.prune_window {
            warn!(
                "DANGEROUS CONFIGURATION: state_merkle_prune_window ({}) > ledger_prune_window ({}). \
                This will cause state sync failures. Please reconfigure immediately.",
                state_merkle_window, config.prune_window
            );
        }
        // ... existing initialization ...
    }
}
```

## Proof of Concept

```rust
// File: storage/aptosdb/src/pruner/test_pruner_coordination.rs

#[cfg(test)]
mod tests {
    use super::*;
    use aptos_config::config::{LedgerPrunerConfig, StateMerklePrunerConfig};
    use aptos_types::state_store::state_key::StateKey;

    #[test]
    #[should_panic(expected = "State Value is missing")]
    fn test_inverted_prune_windows_cause_state_sync_failure() {
        // Setup: Create database with inverted prune windows
        let temp_dir = TempPath::new();
        
        // Configure with INVERTED prune windows (dangerous configuration)
        let mut config = StorageConfig::default();
        config.storage_pruner_config.state_merkle_pruner_config.prune_window = 100_000_000; // 100M
        config.storage_pruner_config.ledger_pruner_config.prune_window = 50_000_000; // 50M
        
        let db = AptosDB::new_for_test(&temp_dir, config);
        
        // Commit transactions up to version 150M
        for v in 0..150_000_000 {
            let txn = create_test_transaction(v);
            db.save_transactions(&[txn], v, None).unwrap();
            
            // Trigger pruning periodically
            if v % 10_000 == 0 {
                db.state_store.state_kv_pruner.maybe_set_pruner_target_db_version(v);
                db.state_store.state_merkle_pruner.maybe_set_pruner_target_db_version(v);
            }
        }
        
        // Wait for pruning to complete
        db.state_store.state_kv_pruner.wait_for_pruner().unwrap();
        db.state_store.state_merkle_pruner.wait_for_pruner().unwrap();
        
        // Attempt to get state value with proof for version 75M
        // At this point:
        // - State values pruned up to: 150M - 50M = 100M (75M is pruned)
        // - Merkle nodes pruned up to: 150M - 100M = 50M (75M merkle node exists)
        let state_key = StateKey::raw(b"test_key");
        let key_hash = state_key.hash();
        
        // This should PANIC because:
        // 1. Merkle tree traversal succeeds (node exists at 75M)
        // 2. expect_value_by_version fails (state value pruned)
        let (_value, _proof) = db
            .state_store
            .get_state_value_with_proof_by_version_ext(&key_hash, 75_000_000, 0, false)
            .unwrap(); // This panics with "State Value is missing"
    }
}
```

### Citations

**File:** storage/aptosdb/src/pruner/state_kv_pruner/mod.rs (L31-42)
```rust
pub const STATE_KV_PRUNER_NAME: &str = "state_kv_pruner";

/// Responsible for pruning state kv db.
pub(crate) struct StateKvPruner {
    /// Keeps track of the target version that the pruner needs to achieve.
    target_version: AtomicVersion,
    progress: AtomicVersion,

    metadata_pruner: StateKvMetadataPruner,
    // Non-empty iff sharding is enabled.
    shard_pruners: Vec<StateKvShardPruner>,
}
```

**File:** storage/aptosdb/src/pruner/state_merkle_pruner/mod.rs (L37-49)
```rust
/// Responsible for pruning the state tree.
pub struct StateMerklePruner<S> {
    /// Keeps track of the target version that the pruner needs to achieve.
    target_version: AtomicVersion,
    /// Overall progress, updated when the whole version is done.
    progress: AtomicVersion,

    metadata_pruner: StateMerkleMetadataPruner<S>,
    // Non-empty iff sharding is enabled.
    shard_pruners: Vec<StateMerkleShardPruner<S>>,

    _phantom: PhantomData<S>,
}
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L625-632)
```rust
            // Activate the ledger pruner and state kv pruner.
            // Note the state merkle pruner is activated when state snapshots are persisted
            // in their async thread.
            self.ledger_pruner
                .maybe_set_pruner_target_db_version(version);
            self.state_store
                .state_kv_pruner
                .maybe_set_pruner_target_db_version(version);
```

**File:** storage/aptosdb/src/state_store/state_merkle_batch_committer.rs (L93-98)
```rust
                    self.state_db
                        .state_merkle_pruner
                        .maybe_set_pruner_target_db_version(current_version);
                    self.state_db
                        .epoch_snapshot_pruner
                        .maybe_set_pruner_target_db_version(current_version);
```

**File:** config/src/config/storage_config.rs (L387-395)
```rust
impl Default for LedgerPrunerConfig {
    fn default() -> Self {
        LedgerPrunerConfig {
            enable: true,
            prune_window: 90_000_000,
            batch_size: 5_000,
            user_pruning_window_offset: 200_000,
        }
    }
```

**File:** config/src/config/storage_config.rs (L398-412)
```rust
impl Default for StateMerklePrunerConfig {
    fn default() -> Self {
        StateMerklePrunerConfig {
            enable: true,
            // This allows a block / chunk being executed to have access to a non-latest state tree.
            // It needs to be greater than the number of versions the state committing thread is
            // able to commit during the execution of the block / chunk. If the bad case indeed
            // happens due to this being too small, a node restart should recover it.
            // Still, defaulting to 1M to be super safe.
            prune_window: 1_000_000,
            // A 10k transaction block (touching 60k state values, in the case of the account
            // creation benchmark) on a 4B items DB (or 1.33B accounts) yields 300k JMT nodes
            batch_size: 1_000,
        }
    }
```

**File:** config/src/config/storage_config.rs (L682-797)
```rust
impl ConfigSanitizer for StorageConfig {
    fn sanitize(
        node_config: &NodeConfig,
        _node_type: NodeType,
        _chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();
        let config = &node_config.storage;

        let ledger_prune_window = config
            .storage_pruner_config
            .ledger_pruner_config
            .prune_window;
        let state_merkle_prune_window = config
            .storage_pruner_config
            .state_merkle_pruner_config
            .prune_window;
        let epoch_snapshot_prune_window = config
            .storage_pruner_config
            .epoch_snapshot_pruner_config
            .prune_window;
        let user_pruning_window_offset = config
            .storage_pruner_config
            .ledger_pruner_config
            .user_pruning_window_offset;

        if ledger_prune_window < 50_000_000 {
            warn!("Ledger prune_window is too small, harming network data availability.");
        }
        if state_merkle_prune_window < 100_000 {
            warn!("State Merkle prune_window is too small, node might stop functioning.");
        }
        if epoch_snapshot_prune_window < 50_000_000 {
            warn!("Epoch snapshot prune_window is too small, harming network data availability.");
        }
        if user_pruning_window_offset > 1_000_000 {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "user_pruning_window_offset too large, so big a buffer is unlikely necessary. Set something < 1 million.".to_string(),
            ));
        }
        if user_pruning_window_offset > ledger_prune_window {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "user_pruning_window_offset is larger than the ledger prune window, the API will refuse to return any data.".to_string(),
            ));
        }

        if let Some(db_path_overrides) = config.db_path_overrides.as_ref() {
            if !config.rocksdb_configs.enable_storage_sharding {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "db_path_overrides is allowed only if sharding is enabled.".to_string(),
                ));
            }

            if let Some(ledger_db_path) = db_path_overrides.ledger_db_path.as_ref() {
                if !ledger_db_path.is_absolute() {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        format!(
                            "Path {ledger_db_path:?} in db_path_overrides is not an absolute path."
                        ),
                    ));
                }
            }

            if let Some(state_kv_db_path) = db_path_overrides.state_kv_db_path.as_ref() {
                if let Some(metadata_path) = state_kv_db_path.metadata_path.as_ref() {
                    if !metadata_path.is_absolute() {
                        return Err(Error::ConfigSanitizerFailed(
                            sanitizer_name,
                            format!("Path {metadata_path:?} in db_path_overrides is not an absolute path."),
                        ));
                    }
                }

                if let Err(e) = state_kv_db_path.get_shard_paths() {
                    return Err(Error::ConfigSanitizerFailed(sanitizer_name, e.to_string()));
                }
            }

            if let Some(state_merkle_db_path) = db_path_overrides.state_merkle_db_path.as_ref() {
                if let Some(metadata_path) = state_merkle_db_path.metadata_path.as_ref() {
                    if !metadata_path.is_absolute() {
                        return Err(Error::ConfigSanitizerFailed(
                            sanitizer_name,
                            format!("Path {metadata_path:?} in db_path_overrides is not an absolute path."),
                        ));
                    }
                }

                if let Err(e) = state_merkle_db_path.get_shard_paths() {
                    return Err(Error::ConfigSanitizerFailed(sanitizer_name, e.to_string()));
                }
            }

            if let Some(hot_state_merkle_db_path) =
                db_path_overrides.hot_state_merkle_db_path.as_ref()
            {
                if let Some(metadata_path) = hot_state_merkle_db_path.metadata_path.as_ref() {
                    if !metadata_path.is_absolute() {
                        return Err(Error::ConfigSanitizerFailed(
                            sanitizer_name,
                            format!("Path {metadata_path:?} in db_path_overrides is not an absolute path."),
                        ));
                    }
                }

                if let Err(e) = hot_state_merkle_db_path.get_shard_paths() {
                    return Err(Error::ConfigSanitizerFailed(sanitizer_name, e.to_string()));
                }
            }
        }

        Ok(())
```

**File:** storage/aptosdb/src/state_store/mod.rs (L228-235)
```rust
        let (leaf_data, proof) = db.get_with_proof_ext(key_hash, version, root_depth)?;
        Ok((
            match leaf_data {
                Some((_val_hash, (key, ver))) => Some(self.expect_value_by_version(&key, ver)?),
                None => None,
            },
            proof,
        ))
```

**File:** storage/aptosdb/src/state_store/mod.rs (L320-334)
```rust
    fn expect_value_by_version(
        &self,
        state_key: &StateKey,
        version: Version,
    ) -> Result<StateValue> {
        self.get_state_value_by_version(state_key, version)
            .and_then(|opt| {
                opt.ok_or_else(|| {
                    AptosDbError::NotFound(format!(
                        "State Value is missing for key {:?} by version {}",
                        state_key, version
                    ))
                })
            })
    }
```
