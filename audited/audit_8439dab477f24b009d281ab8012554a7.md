# Audit Report

## Title
Stream Message Size Limit Bypass via Incorrect Fragment Count Calculation

## Summary
The `handle_inbound_message()` function's Stream message processing path contains a critical size validation vulnerability. While **message misclassification between Message and Stream variants is NOT possible** (BCS deserialization and Rust's type system prevent this), the Stream message reconstruction logic allows an attacker to bypass the `max_message_size` limit by approximately 6.25%, enabling memory exhaustion attacks against validator nodes.

## Finding Description

The security question asks about misclassification at lines 596-599 of `peer/mod.rs`. Investigation confirms that **misclassification is cryptographically impossible** - BCS deserialization with variant indices and Rust's exhaustive pattern matching guarantee type-safe routing between Message and Stream handlers. [1](#0-0) 

However, a **related vulnerability exists in Stream message size validation**. The `max_fragments` calculation incorrectly allows reconstructed messages to exceed `max_message_size`: [2](#0-1) 

This calculation assumes fragments are the only data source, but ignores that the `StreamHeader` itself contains a `NetworkMessage` with data in its raw fields (up to ~4 MiB), which gets additional fragments appended: [3](#0-2) 

The inbound validation only checks fragment count, not total size: [4](#0-3) 

**Attack Path:**
1. Attacker sends `StreamHeader` with `num_fragments=16` containing a `NetworkMessage` with ~4 MiB of raw data (limited by frame codec)
2. Sends 16 `StreamFragment` messages, each with ~4 MiB of `raw_data` 
3. Total reconstructed size: ~4 MiB + (16 × 4 MiB) = ~68 MiB, exceeding the 64 MiB `max_message_size`
4. No size validation occurs during reconstruction [5](#0-4) 

The reconstructed oversized message is passed to `handle_inbound_network_message()` without size checks: [6](#0-5) 

## Impact Explanation

**Severity: HIGH**

This breaks the **Resource Limits** invariant (Critical Invariant #9) - operations must respect configured limits. Specifically:

- **Memory Exhaustion DoS**: Each oversized message consumes 6.25% more memory than configured (68 MiB vs 64 MiB)
- **Validator Node Instability**: Multiple concurrent oversized messages can exhaust node memory, causing crashes or severe slowdowns
- **Consensus/State-Sync Impact**: If consensus or state-sync messages are affected, nodes may fail to participate in consensus or sync state
- **Resource Limit Bypass**: Application protocols expect `max_message_size` enforcement; oversized messages may trigger unexpected behavior or crashes in protocol handlers

Per Aptos bug bounty criteria, this qualifies as **High Severity** due to potential "Validator node slowdowns" and "Significant protocol violations".

## Likelihood Explanation

**Likelihood: HIGH**

- **No Authentication Required**: Any network peer can exploit this by connecting to a validator
- **Simple Attack**: Requires only crafting valid BCS-serialized messages with maximally-filled data fields
- **Low Complexity**: No timing dependencies, race conditions, or complex state manipulation needed
- **Repeatable**: Attacker can send multiple oversized messages to amplify impact
- **Default Configuration Vulnerable**: Default `MAX_MESSAGE_SIZE=64 MiB` and `MAX_FRAME_SIZE=4 MiB` enable the bypass [7](#0-6) 

## Recommendation

Fix the `max_fragments` calculation to account for data in the `StreamHeader`:

```rust
// Current (INCORRECT):
let max_fragments = max_message_size / max_frame_size;

// Corrected:
let max_fragments = (max_message_size / max_frame_size).saturating_sub(1);
// Or more precisely:
let max_fragments = max_message_size.saturating_sub(max_frame_size) / max_frame_size;
```

This ensures: `max_total = max_frame_size + (max_fragments × max_frame_size) = max_message_size`

Additionally, add explicit size validation in `InboundStream::append_fragment()`:

```rust
fn append_fragment(&mut self, mut fragment: StreamFragment) -> anyhow::Result<bool> {
    // ... existing validation ...
    
    // NEW: Validate total size won't exceed limit
    let current_size = match &self.message {
        NetworkMessage::RpcRequest(r) => r.raw_request.len(),
        NetworkMessage::RpcResponse(r) => r.raw_response.len(),
        NetworkMessage::DirectSendMsg(m) => m.raw_msg.len(),
        NetworkMessage::Error(_) => unreachable!(),
    };
    let new_size = current_size.checked_add(fragment.raw_data.len())
        .ok_or_else(|| anyhow::anyhow!("Size overflow"))?;
    ensure!(
        new_size <= self.max_message_size,
        "Total stream size {} exceeds max_message_size {}",
        new_size, self.max_message_size
    );
    
    // ... rest of function ...
}
```

Pass `max_message_size` to `InboundStream` during construction.

## Proof of Concept

```rust
// PoC: Craft oversized stream message
// File: network/framework/src/peer/test.rs

#[tokio::test]
async fn test_stream_size_bypass() {
    use crate::protocols::wire::messaging::v1::*;
    use crate::protocols::stream::*;
    
    let max_frame_size = 4 * 1024 * 1024; // 4 MiB
    let max_message_size = 64 * 1024 * 1024; // 64 MiB
    let max_fragments = max_message_size / max_frame_size; // = 16 (WRONG!)
    
    // Create StreamHeader with NetworkMessage containing ~4 MiB of data
    let header_data_size = max_frame_size - 1000; // Account for overhead
    let header = StreamHeader {
        request_id: 1,
        num_fragments: max_fragments as u8,
        message: NetworkMessage::DirectSendMsg(DirectSendMsg {
            protocol_id: ProtocolId::ConsensusDirectSendBcs,
            priority: 0,
            raw_msg: vec![0xFF; header_data_size],
        }),
    };
    
    // Create 16 fragments, each with ~4 MiB of data
    let fragment_data_size = max_frame_size - 1000;
    let mut fragments = vec![];
    for i in 1..=max_fragments {
        fragments.push(StreamFragment {
            request_id: 1,
            fragment_id: i as u8,
            raw_data: vec![0xFF; fragment_data_size],
        });
    }
    
    // Calculate total reconstructed size
    let total_size = header_data_size + (max_fragments * fragment_data_size);
    println!("Total reconstructed message size: {} bytes", total_size);
    println!("Max message size: {} bytes", max_message_size);
    println!("Excess: {} bytes ({:.2}%)", 
             total_size - max_message_size,
             ((total_size - max_message_size) as f64 / max_message_size as f64) * 100.0);
    
    assert!(total_size > max_message_size, "Size bypass successful!");
    // Expected output: ~68 MiB > 64 MiB, ~6.25% excess
}
```

**Notes**

This vulnerability is NOT about message misclassification (which is impossible due to BCS type safety), but rather incorrect size validation in Stream message reconstruction. The issue stems from an off-by-one error in the `max_fragments` calculation that fails to account for the data payload in the `StreamHeader` itself. This allows attackers to reconstruct messages exceeding configured limits, violating the Resource Limits invariant and enabling memory exhaustion DoS attacks against validators.

### Citations

**File:** network/framework/src/peer/mod.rs (L168-168)
```rust
        let max_fragments = max_message_size / max_frame_size;
```

**File:** network/framework/src/peer/mod.rs (L447-541)
```rust
    fn handle_inbound_network_message(
        &mut self,
        message: NetworkMessage,
    ) -> Result<(), PeerManagerError> {
        match &message {
            NetworkMessage::DirectSendMsg(direct) => {
                let data_len = direct.raw_msg.len();
                network_application_inbound_traffic(
                    self.network_context,
                    direct.protocol_id,
                    data_len as u64,
                );
                match self.upstream_handlers.get(&direct.protocol_id) {
                    None => {
                        counters::direct_send_messages(&self.network_context, UNKNOWN_LABEL).inc();
                        counters::direct_send_bytes(&self.network_context, UNKNOWN_LABEL)
                            .inc_by(data_len as u64);
                    },
                    Some(handler) => {
                        let key = (self.connection_metadata.remote_peer_id, direct.protocol_id);
                        let sender = self.connection_metadata.remote_peer_id;
                        let network_id = self.network_context.network_id();
                        let sender = PeerNetworkId::new(network_id, sender);
                        match handler.push(key, ReceivedMessage::new(message, sender)) {
                            Err(_err) => {
                                // NOTE: aptos_channel never returns other than Ok(()), but we might switch to tokio::sync::mpsc and then this would work
                                counters::direct_send_messages(
                                    &self.network_context,
                                    DECLINED_LABEL,
                                )
                                .inc();
                                counters::direct_send_bytes(&self.network_context, DECLINED_LABEL)
                                    .inc_by(data_len as u64);
                            },
                            Ok(_) => {
                                counters::direct_send_messages(
                                    &self.network_context,
                                    RECEIVED_LABEL,
                                )
                                .inc();
                                counters::direct_send_bytes(&self.network_context, RECEIVED_LABEL)
                                    .inc_by(data_len as u64);
                            },
                        }
                    },
                }
            },
            NetworkMessage::Error(error_msg) => {
                warn!(
                    NetworkSchema::new(&self.network_context)
                        .connection_metadata(&self.connection_metadata),
                    error_msg = ?error_msg,
                    "{} Peer {} sent an error message: {:?}",
                    self.network_context,
                    self.remote_peer_id().short_str(),
                    error_msg,
                );
            },
            NetworkMessage::RpcRequest(request) => {
                match self.upstream_handlers.get(&request.protocol_id) {
                    None => {
                        counters::direct_send_messages(&self.network_context, UNKNOWN_LABEL).inc();
                        counters::direct_send_bytes(&self.network_context, UNKNOWN_LABEL)
                            .inc_by(request.raw_request.len() as u64);
                    },
                    Some(handler) => {
                        let sender = self.connection_metadata.remote_peer_id;
                        let network_id = self.network_context.network_id();
                        let sender = PeerNetworkId::new(network_id, sender);
                        if let Err(err) = self
                            .inbound_rpcs
                            .handle_inbound_request(handler, ReceivedMessage::new(message, sender))
                        {
                            warn!(
                                NetworkSchema::new(&self.network_context)
                                    .connection_metadata(&self.connection_metadata),
                                error = %err,
                                "{} Error handling inbound rpc request: {}",
                                self.network_context,
                                err
                            );
                        }
                    },
                }
            },
            NetworkMessage::RpcResponse(_) => {
                // non-reference cast identical to this match case
                let NetworkMessage::RpcResponse(response) = message else {
                    unreachable!("NetworkMessage type changed between match and let")
                };
                self.outbound_rpcs.handle_inbound_response(response)
            },
        };
        Ok(())
    }
```

**File:** network/framework/src/peer/mod.rs (L543-558)
```rust
    fn handle_inbound_stream_message(
        &mut self,
        message: StreamMessage,
    ) -> Result<(), PeerManagerError> {
        match message {
            StreamMessage::Header(header) => {
                self.inbound_stream.new_stream(header)?;
            },
            StreamMessage::Fragment(fragment) => {
                if let Some(message) = self.inbound_stream.append_fragment(fragment)? {
                    self.handle_inbound_network_message(message)?;
                }
            },
        }
        Ok(())
    }
```

**File:** network/framework/src/peer/mod.rs (L596-599)
```rust
        match message {
            MultiplexMessage::Message(message) => self.handle_inbound_network_message(message),
            MultiplexMessage::Stream(message) => self.handle_inbound_stream_message(message),
        }
```

**File:** network/framework/src/protocols/stream/mod.rs (L150-153)
```rust
        ensure!(
            (header_num_fragments as usize) <= max_fragments,
            "Stream header exceeds max fragments limit!"
        );
```

**File:** network/framework/src/protocols/stream/mod.rs (L200-209)
```rust
        // Append the fragment data to the message
        let raw_data = &mut fragment.raw_data;
        match &mut self.message {
            NetworkMessage::Error(_) => {
                panic!("StreamHeader for NetworkMessage::Error(_) should be rejected!")
            },
            NetworkMessage::RpcRequest(request) => request.raw_request.append(raw_data),
            NetworkMessage::RpcResponse(response) => response.raw_response.append(raw_data),
            NetworkMessage::DirectSendMsg(message) => message.raw_msg.append(raw_data),
        }
```

**File:** config/src/config/network_config.rs (L49-50)
```rust
pub const MAX_FRAME_SIZE: usize = 4 * 1024 * 1024; /* 4 MiB large messages will be chunked into multiple frames and streamed */
pub const MAX_MESSAGE_SIZE: usize = 64 * 1024 * 1024; /* 64 MiB */
```
