# Audit Report

## Title
Federated Keyless Accounts Allow Arbitrary Self-Signed OIDC Authentication Bypass

## Summary
An attacker can create a federated keyless account with `jwk_addr` pointing to their own controlled address, install self-signed JWKs at that address, and successfully validate transactions without any legitimate OIDC provider authentication. This completely bypasses the core security model of keyless accounts.

## Finding Description

The federated keyless account system allows users to specify a custom `jwk_addr` where JWKs (JSON Web Keys) are stored for signature verification. The validation logic implements a fallback mechanism where it first checks JWKs at the Aptos framework address (0x1), and only if not found there, reads from the federated `jwk_addr`. [1](#0-0) 

The critical flaw is that there is **no validation** that:
1. The issuer (`iss_val`) corresponds to a legitimate OIDC provider
2. The `jwk_addr` is controlled by a trusted entity
3. The issuer is in the `SupportedOIDCProviders` list maintained by governance

Furthermore, the Move function `update_federated_jwk_set` is a **public entry function** that anyone can call to install `FederatedJWKs` at their own address: [2](#0-1) 

The only restriction is that federated JWKs cannot be installed at the Aptos framework address: [3](#0-2) 

**Attack Path:**

1. Attacker chooses a custom issuer not in 0x1's `PatchedJWKs` (e.g., "https://attacker-controlled.com")
2. Attacker calls `update_federated_jwk_set` to install their own JWKs at their address with issuer "https://attacker-controlled.com"
3. Attacker creates a `FederatedKeylessPublicKey` with:
   - `jwk_addr` = attacker's address
   - `iss_val` = "https://attacker-controlled.com"
   - `idc` = any valid identity commitment
4. Attacker derives the account address from this public key
5. Attacker creates a JWT signed with their own private key (matching their installed JWK)
6. During transaction validation:
   - Lookup for "https://attacker-controlled.com" in 0x1 fails (custom issuer)
   - Falls back to reading `FederatedJWKs` from attacker's `jwk_addr`
   - Finds attacker's self-signed JWK
   - Signature validation **succeeds** using attacker's JWK

The 0x1 override mechanism only protects against attacks where the issuer **already exists** in 0x1. For custom issuers not in 0x1, there is zero validation. [4](#0-3) [5](#0-4) 

## Impact Explanation

**Critical Severity** - This vulnerability completely undermines the security model of keyless accounts:

- **Transaction Validation Bypass**: The fundamental assumption of keyless accounts is that authentication is delegated to trusted OIDC providers (Google, Facebook, etc.). This vulnerability allows anyone to be their own "OIDC provider" without any real authentication.

- **Identity Spoofing**: Attackers can create accounts that appear to be authenticated but have no connection to any legitimate identity provider.

- **Consensus Impact**: All validators will deterministically accept these invalid authentications, meaning the entire network validates transactions that should be rejected.

This breaks the **Transaction Validation** invariant: "Prologue/epilogue checks must enforce all invariants" - specifically that keyless accounts must be authenticated by legitimate OIDC providers, not self-signed by arbitrary attackers.

## Likelihood Explanation

**Likelihood: High**

This vulnerability is trivially exploitable:
- No special permissions required
- Public entry functions are available to anyone
- Attack requires only basic understanding of the keyless account system
- No rate limiting or additional security checks
- Can be executed entirely on-chain with standard transactions

The only reason this might not be immediately exploited is limited awareness of the federated keyless feature, but once known, exploitation is straightforward.

## Recommendation

Implement one or more of the following mitigations:

**Option 1: Issuer Whitelist Validation**
```rust
// In validate_authenticators, add before line 237:
fn validate_issuer(issuer: &str, resolver: &impl AptosMoveResolver) -> Result<(), VMStatus> {
    let supported_providers = SupportedOIDCProviders::fetch_config(resolver)
        .ok_or_else(|| invalid_signature!("Could not fetch SupportedOIDCProviders"))?;
    
    if !supported_providers.providers.iter().any(|p| p.name == issuer.as_bytes()) {
        return Err(invalid_signature!("Issuer not in SupportedOIDCProviders whitelist"));
    }
    Ok(())
}

// Call this for federated accounts:
validate_issuer(&pk.inner_keyless_pk().iss_val, resolver)?;
```

**Option 2: jwk_addr Governance Whitelist**
Maintain an on-chain resource of approved `jwk_addr` values that can only be updated through governance proposals. Validate that `fed_pk.jwk_addr` is in this whitelist during transaction validation.

**Option 3: Require Issuer in 0x1**
For federated keyless accounts, require that the issuer's JWKs exist in 0x1's `PatchedJWKs` (even if temporarily disabled), ensuring only governance-approved OIDC providers can be used.

## Proof of Concept

```rust
// Add to aptos-move/e2e-move-tests/src/tests/keyless_feature_gating.rs

#[test]
fn test_malicious_self_signed_federated_keyless() {
    let mut h = MoveHarness::new_with_features(
        vec![
            FeatureFlag::CRYPTOGRAPHY_ALGEBRA_NATIVES,
            FeatureFlag::BN254_STRUCTURES,
            FeatureFlag::KEYLESS_ACCOUNTS,
            FeatureFlag::FEDERATED_KEYLESS,
        ],
        vec![],
    );

    // Attacker's address for malicious JWKs
    let attacker_jwk_addr = AccountAddress::from_hex_literal("0xBAD").unwrap();
    
    // Attacker's custom OIDC issuer (NOT in 0x1)
    let malicious_iss = "https://evil-attacker-oidc.com";
    
    // Step 1: Attacker installs their own JWKs at their address
    // Note: get_sample_jwk() returns a test JWK that attacker controls the private key for
    let attacker_jwk = get_sample_jwk();
    let core_resources = install_federated_jwks_and_set_keyless_config(
        &mut h, 
        attacker_jwk_addr, 
        malicious_iss.to_string(), 
        attacker_jwk
    );
    
    run_upgrade_vk_script(
        &mut h,
        core_resources.clone(),
        Groth16VerificationKey::from(VERIFICATION_KEY_FOR_TESTING.clone()),
    );

    // Step 2: Create federated keyless account with malicious issuer
    let (sig, mut pk) = get_sample_groth16_sig_and_pk();
    pk.iss_val = malicious_iss.to_string(); // Use attacker's custom issuer
    
    let sender = create_federated_keyless_account(&mut h, attacker_jwk_addr, pk);
    let recipient = h.new_account_at(AccountAddress::from_hex_literal("0xb0b").unwrap());
    
    // Step 3: Transaction with self-signed JWT validates successfully!
    let txn = spend_keyless_account(&mut h, sig, &sender, *recipient.address());
    let output = h.run_raw(txn);
    
    // VULNERABILITY: This should FAIL but instead SUCCEEDS
    // because there's no validation that the issuer is legitimate
    assert_success!(
        output.status().clone(),
        "CRITICAL: Attacker's self-signed keyless account was accepted!"
    );
}
```

**Notes:**
- The existing test infrastructure in `keyless_feature_gating.rs` demonstrates this pattern but doesn't explicitly showcase the security vulnerability
- The test at line 254 (`test_federated_keyless_at_jwk_addr`) shows the mechanism works but uses test issuers that might appear legitimate
- The critical insight is that **any** custom issuer works, not just test issuers, allowing complete authentication bypass

### Citations

**File:** aptos-move/aptos-vm/src/keyless_validation.rs (L36-81)
```rust
fn get_resource_on_chain_at_addr<T: MoveStructType + for<'a> Deserialize<'a>>(
    addr: &AccountAddress,
    resolver: &impl AptosMoveResolver,
    module_storage: &impl ModuleStorage,
) -> anyhow::Result<T, VMStatus> {
    let struct_tag = T::struct_tag();
    if !struct_tag.address.is_special() {
        let msg = format!(
            "[keyless-validation] Address {} is not special",
            struct_tag.address
        );
        return Err(VMStatus::error(
            StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR,
            Some(msg),
        ));
    }

    // INVARIANT:
    //   The struct should be defined at core (0x1) address, so we do not require metering for any
    //   module loading.
    let module = module_storage
        .unmetered_get_existing_deserialized_module(&struct_tag.address, &struct_tag.module)
        .map_err(|e| e.into_vm_status())?;

    let bytes = resolver
        .get_resource_bytes_with_metadata_and_layout(addr, &struct_tag, &module.metadata, None)
        .map_err(|e| e.finish(Location::Undefined).into_vm_status())?
        .0
        .ok_or_else(|| {
            value_deserialization_error!(format!(
                "get_resource failed on {}::{}::{}",
                addr.to_hex_literal(),
                T::struct_tag().module,
                T::struct_tag().name
            ))
        })?;
    let obj = bcs::from_bytes::<T>(&bytes).map_err(|_| {
        value_deserialization_error!(format!(
            "could not deserialize {}::{}::{}",
            addr.to_hex_literal(),
            T::struct_tag().module,
            T::struct_tag().name
        ))
    })?;
    Ok(obj)
}
```

**File:** aptos-move/aptos-vm/src/keyless_validation.rs (L96-102)
```rust
fn get_federated_jwks_onchain(
    resolver: &impl AptosMoveResolver,
    jwk_addr: &AccountAddress,
    module_storage: &impl ModuleStorage,
) -> anyhow::Result<FederatedJWKs, VMStatus> {
    get_resource_on_chain_at_addr::<FederatedJWKs>(jwk_addr, resolver, module_storage)
}
```

**File:** aptos-move/aptos-vm/src/keyless_validation.rs (L237-260)
```rust
        let jwk = match get_jwk_for_authenticator(&patched_jwks.jwks, pk.inner_keyless_pk(), sig) {
            // 1: If found in 0x1, then we consider that the ground truth & we are done.
            Ok(jwk) => jwk,
            // 2: If not found in 0x1, we check the Keyless PK type.
            Err(e) => {
                match pk {
                    // 2.a: If this is a federated keyless account; look in `jwk_addr` for JWKs
                    AnyKeylessPublicKey::Federated(fed_pk) => {
                        let federated_jwks =
                            get_federated_jwks_onchain(resolver, &fed_pk.jwk_addr, module_storage)
                                .map_err(|_| {
                                    invalid_signature!(format!(
                                        "Could not fetch federated PatchedJWKs at {}",
                                        fed_pk.jwk_addr
                                    ))
                                })?;
                        // 2.a.i If not found in jwk_addr either, then we fail the validation.
                        get_jwk_for_authenticator(&federated_jwks.jwks, pk.inner_keyless_pk(), sig)?
                    },
                    // 2.b: If this is not a federated keyless account, then we fail the validation.
                    AnyKeylessPublicKey::Normal(_) => return Err(e),
                }
            },
        };
```

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L183-203)
```text
    public fun patch_federated_jwks(jwk_owner: &signer, patches: vector<Patch>) acquires FederatedJWKs {
        // Prevents accidental calls in 0x1::jwks that install federated JWKs at the Aptos framework address.
        assert!(!system_addresses::is_aptos_framework_address(signer::address_of(jwk_owner)),
            error::invalid_argument(EINSTALL_FEDERATED_JWKS_AT_APTOS_FRAMEWORK)
        );

        let jwk_addr = signer::address_of(jwk_owner);
        if (!exists<FederatedJWKs>(jwk_addr)) {
            move_to(jwk_owner, FederatedJWKs { jwks: AllProvidersJWKs { entries: vector[] } });
        };

        let fed_jwks = borrow_global_mut<FederatedJWKs>(jwk_addr);
        vector::for_each_ref(&patches, |obj|{
            let patch: &Patch = obj;
            apply_patch(&mut fed_jwks.jwks, *patch);
        });

        // TODO: Can we check the size more efficiently instead of serializing it via BCS?
        let num_bytes = vector::length(&bcs::to_bytes(fed_jwks));
        assert!(num_bytes < MAX_FEDERATED_JWKS_SIZE_BYTES, error::invalid_argument(EFEDERATED_JWKS_TOO_LARGE));
    }
```

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L258-277)
```text
    public entry fun update_federated_jwk_set(jwk_owner: &signer, iss: vector<u8>, kid_vec: vector<String>, alg_vec: vector<String>, e_vec: vector<String>, n_vec: vector<String>) acquires FederatedJWKs {
        assert!(!vector::is_empty(&kid_vec), error::invalid_argument(EINVALID_FEDERATED_JWK_SET));
        let num_jwk = vector::length<String>(&kid_vec);
        assert!(vector::length(&alg_vec) == num_jwk , error::invalid_argument(EINVALID_FEDERATED_JWK_SET));
        assert!(vector::length(&e_vec) == num_jwk, error::invalid_argument(EINVALID_FEDERATED_JWK_SET));
        assert!(vector::length(&n_vec) == num_jwk, error::invalid_argument(EINVALID_FEDERATED_JWK_SET));

        let remove_all_patch = new_patch_remove_all();
        let patches = vector[remove_all_patch];
        while (!vector::is_empty(&kid_vec)) {
            let kid = vector::pop_back(&mut kid_vec);
            let alg = vector::pop_back(&mut alg_vec);
            let e = vector::pop_back(&mut e_vec);
            let n = vector::pop_back(&mut n_vec);
            let jwk = new_rsa_jwk(kid, alg, e, n);
            let patch = new_patch_upsert_jwk(iss, jwk);
            vector::push_back(&mut patches, patch)
        };
        patch_federated_jwks(jwk_owner, patches);
    }
```
