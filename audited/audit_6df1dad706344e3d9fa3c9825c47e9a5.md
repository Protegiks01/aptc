# Audit Report

## Title
Memory Amplification via Transaction Clone Before Size Validation in Mempool

## Summary
The transaction validation process clones each incoming transaction before performing size validation, allowing an attacker to temporarily double memory consumption by sending large transaction batches. The size check in `check_gas()` occurs after the clone operation, violating the resource limits invariant.

## Finding Description

The vulnerability exists in the mempool's transaction validation pipeline. When a validator node receives transactions via network broadcast, each transaction is cloned before VM validation occurs: [1](#0-0) 

This clone happens before any transaction size validation. The actual size check occurs much later in the validation flow: [2](#0-1) 

The transaction size limit is 64 KB per transaction: [3](#0-2) 

**Attack Flow:**

1. Attacker connects to validator as network peer
2. Sends `BroadcastTransactionsRequest` with many maximum-sized transactions (300 × 64 KB = 19.2 MB per batch)
3. Each transaction is cloned at validation time (temporary 38.4 MB for one batch)
4. Parallel validation (`par_iter`) causes multiple simultaneous clones
5. Multiple concurrent broadcasts amplify the effect (up to 4 concurrent by default)
6. Size validation in `check_gas()` happens only after all clones are created [4](#0-3) 

Additionally, `TransactionMetadata::new()` performs additional clones of `EntryFunction` and `Multisig` payload components before size checks: [5](#0-4) 

The network layer allows messages up to 64 MiB, and batches can contain 300 transactions by default: [6](#0-5) 

## Impact Explanation

**Severity: Medium**

This qualifies as Medium severity under Aptos bug bounty criteria as it can cause "Validator node slowdowns." The memory amplification can degrade validator performance:

- Each malicious broadcast batch: ~38 MB temporary memory (19.2 MB transactions × 2)
- With 4 concurrent syncs: ~152 MB 
- Multiple peers × max_broadcasts_per_peer (20 default, 2 for validators): potential for several hundred MB temporary allocation
- This occurs repeatedly for each malicious broadcast received

While modern validators have substantial memory, this attack vector can contribute to resource exhaustion when combined with other load, potentially affecting consensus participation timing and mempool performance.

## Likelihood Explanation

**Likelihood: High**

The attack is straightforward to execute:
- Requires no special privileges (any network peer can broadcast)
- No cryptographic operations needed
- Deterministic trigger via crafted transactions
- No defensive checks exist before the clone operation
- Network protocol allows the attack traffic

The issue occurs on every transaction validation, making it continuously exploitable.

## Recommendation

**Fix: Validate transaction size before cloning**

Add an early size check in `process_incoming_transactions` or `filter_transactions` before the parallel validation that clones transactions:

```rust
// In process_incoming_transactions, after filter_transactions:
let transactions: Vec<_> = transactions
    .into_iter()
    .filter_map(|(t, ready_time, priority)| {
        // Early size check before clone
        let txn_size = t.txn_bytes_len();
        if txn_size > MAX_TRANSACTION_SIZE_IN_BYTES {
            statuses.push((
                t,
                (
                    MempoolStatus::new(MempoolStatusCode::VmError),
                    Some(StatusCode::EXCEEDED_MAX_TRANSACTION_SIZE),
                ),
            ));
            return None;
        }
        Some((t, ready_time, priority))
    })
    .collect();
```

This rejects oversized transactions before the expensive clone operation at line 494 of `tasks.rs`.

## Proof of Concept

**Rust reproduction steps:**

1. Configure a malicious peer node
2. Create 300 transactions, each with maximum allowed size (64 KB payload):
   ```rust
   let large_txns: Vec<SignedTransaction> = (0..300)
       .map(|_| create_transaction_with_payload_size(65536))
       .collect();
   ```
3. Send concurrent `BroadcastTransactionsRequest` messages to target validator
4. Monitor validator memory usage during validation - observe ~38 MB temporary spike per batch
5. Send multiple concurrent broadcasts from multiple peers to amplify effect
6. Observe validator performance degradation under sustained attack

The validator will clone all 300 transactions (19.2 MB) before checking their sizes, temporarily doubling memory usage to ~38 MB per batch during parallel validation.

## Notes

The mock implementation in `vm-validator/src/mocks/mock_vm_validator.rs` also exhibits similar behavior (taking `SignedTransaction` by value at line 47), but this is test-only code. The production vulnerability exists in the real validation flow through `mempool/src/shared_mempool/tasks.rs` where the clone occurs before all size validations.

### Citations

**File:** mempool/src/shared_mempool/tasks.rs (L494-494)
```rust
                let result = smp.validator.read().validate_transaction(t.0.clone());
```

**File:** aptos-move/aptos-vm/src/gas.rs (L109-121)
```rust
    } else if txn_metadata.transaction_size > txn_gas_params.max_transaction_size_in_bytes {
        speculative_warn!(
            log_context,
            format!(
                "[VM] Transaction size too big {} (max {})",
                txn_metadata.transaction_size, txn_gas_params.max_transaction_size_in_bytes
            ),
        );
        return Err(VMStatus::error(
            StatusCode::EXCEEDED_MAX_TRANSACTION_SIZE,
            None,
        ));
    }
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L73-76)
```rust
            max_transaction_size_in_bytes: NumBytes,
            "max_transaction_size_in_bytes",
            64 * 1024
        ],
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L3232-3239)
```rust
        let txn = match transaction.check_signature() {
            Ok(t) => t,
            _ => {
                return VMValidatorResult::error(StatusCode::INVALID_SIGNATURE);
            },
        };
        let auxiliary_info = AuxiliaryInfo::new_timestamp_not_yet_assigned(0);
        let txn_data = TransactionMetadata::new(&txn, &auxiliary_info);
```

**File:** aptos-move/aptos-vm/src/transaction_metadata.rs (L92-121)
```rust
            entry_function_payload: if txn.payload().is_multisig() {
                None
            } else if let Ok(TransactionExecutableRef::EntryFunction(e)) =
                txn.payload().executable_ref()
            {
                Some(e.clone())
            } else {
                None
            },
            multisig_payload: match txn.payload() {
                TransactionPayload::Multisig(m) => Some(m.clone()),
                TransactionPayload::Payload(TransactionPayloadInner::V1 {
                    executable,
                    extra_config:
                        TransactionExtraConfig::V1 {
                            multisig_address: Some(multisig_address),
                            ..
                        },
                }) => Some(Multisig {
                    multisig_address: *multisig_address,
                    transaction_payload: match executable {
                        TransactionExecutable::EntryFunction(e) => {
                            // TODO[Orderless]: How to avoid the clone operation here.
                            Some(MultisigTransactionPayload::EntryFunction(e.clone()))
                        },
                        _ => None,
                    },
                }),
                _ => None,
            },
```

**File:** config/src/config/mempool_config.rs (L113-114)
```rust
            shared_mempool_batch_size: 300,
            shared_mempool_max_batch_bytes: MAX_APPLICATION_MESSAGE_SIZE as u64,
```
