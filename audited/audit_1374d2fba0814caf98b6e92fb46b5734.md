# Audit Report

## Title
Blocking Thread Pool Exhaustion via Malicious DNS Names in Validator Network Addresses

## Summary
The `resolve_with_filter()` function and related DNS resolution code in the network layer can cause indefinite blocking of tokio's blocking thread pool when DNS servers never respond. Attackers controlling validator network addresses with malicious DNS names can exhaust all 64 blocking threads, preventing honest validators from performing any new blocking operations including legitimate DNS lookups and file I/O, potentially leading to loss of liveness.

## Finding Description

The vulnerability exists in two related code paths where DNS resolution is performed using blocking system calls without adequate protection against non-responding DNS servers:

1. **resolve_with_filter() in tcp.rs**: This function uses tokio's `lookup_host()` which internally wraps the blocking `getaddrinfo` system call via `spawn_blocking`. [1](#0-0) 

2. **spawn_latency_ping_task() in connectivity_manager**: This function directly calls `to_socket_addrs()` within a `spawn_blocking` task, which also uses blocking `getaddrinfo`. [2](#0-1) 

While there are timeout wrappers at higher levels (30-second `TRANSPORT_TIMEOUT` [3](#0-2)  and [4](#0-3) ), these timeouts only cancel the async future—they **do not** cancel the underlying blocking system call. When `getaddrinfo` lacks a system-level timeout and the DNS server never responds, the blocking thread remains occupied indefinitely.

The blocking thread pool is limited to 64 threads: [5](#0-4)  and [6](#0-5) 

**Attack Scenario:**

1. Attacker registers as validators (permissionless with sufficient stake) or compromises validator configurations
2. Sets validator network addresses to DNS names pointing to DNS servers that never respond (e.g., `/dns4/malicious-peer-{1..100}.evil.com/tcp/6180/noise-ik/<pubkey>/handshake/0`)
3. The connectivity manager attempts to ping eligible peers concurrently without ping latency information [7](#0-6) 
4. For each malicious peer, a `spawn_latency_ping_task` is spawned, consuming one blocking thread
5. Each blocking thread calls `to_socket_addrs()` which invokes `getaddrinfo` that waits indefinitely for DNS response
6. After spawning 64+ concurrent ping tasks, all blocking threads are exhausted
7. The `join_all(ping_tasks).await` call waits indefinitely with no timeout [8](#0-7) 
8. No new blocking operations can proceed, including legitimate DNS resolution and file I/O operations

The system allows DNS names in validator configurations as shown by infrastructure code: [9](#0-8) 

## Impact Explanation

**Severity: Medium to High**

This vulnerability breaks the **Resource Limits** invariant: "All operations must respect gas, storage, and computational limits." The blocking thread pool is a critical shared resource that should not be exhaustible by malicious actors.

**Potential Impacts:**
- **High Severity - Validator node slowdowns**: Once the blocking thread pool is exhausted, validators cannot perform new blocking operations, severely degrading performance
- **Medium Severity - State inconsistencies requiring intervention**: If validators cannot establish connections to honest peers due to thread pool exhaustion, they may fall behind in state synchronization
- Potential loss of liveness if the validator cannot maintain sufficient peer connections
- Other blocking operations (file I/O, etc.) are blocked, affecting overall node functionality

The impact is limited by:
- Existing connections remain functional
- The attack requires multiple malicious validator addresses (64+)
- Once peers have ping latency information, they aren't pinged again (limiting repeatability)

## Likelihood Explanation

**Likelihood: Medium**

**Requirements for exploitation:**
- Attacker must register as validators (requires staking but is permissionless) or compromise validator on-chain configurations
- Need to control 64+ validator addresses to fully exhaust the thread pool
- Requires control over DNS infrastructure to create non-responding DNS servers
- System's `getaddrinfo` must lack adequate timeouts (common on some Linux distributions with default configurations)

**Mitigating factors:**
- Aptos is designed to tolerate up to 1/3 Byzantine validators, so having malicious validators is within the threat model
- The blocking pool size (64) is relatively large
- Attack effectiveness depends on system DNS resolver configuration

The attack is feasible for a determined attacker with sufficient resources to stake multiple validators.

## Recommendation

Implement proper timeout handling for DNS resolution that actually cancels blocking operations:

1. **Use async DNS resolver with real cancellation**: Replace `to_socket_addrs()` with a true async DNS resolver library like `trust-dns-resolver` that supports proper cancellation, or implement a custom DNS resolver with timeout enforcement at the protocol level.

2. **Add timeout to ping operations**: Wrap the entire `join_all(ping_tasks)` call with a timeout to prevent indefinite waiting:
```rust
// In ping_eligible_peers()
let ping_timeout = Duration::from_secs(10);
match time_service.timeout(ping_timeout, join_all(ping_tasks)).await {
    Ok(_) => { /* log success */ },
    Err(_) => { warn!("Ping tasks timed out"); }
}
```

3. **Limit concurrent ping operations**: Instead of pinging all eligible peers concurrently, limit concurrent pings to prevent thread pool exhaustion:
```rust
const MAX_CONCURRENT_PINGS: usize = 16;
// Process peers in batches
```

4. **Prefer IP addresses over DNS names**: Where possible, encourage validators to use IP addresses in their network configurations, or resolve DNS names at configuration time rather than connection time.

## Proof of Concept

```rust
// Reproduction Steps:
// 1. Set up a DNS server that accepts queries but never responds
// 2. Register 64+ validators with network addresses pointing to non-responding DNS:
//    /dns4/hang-1.evil.com/tcp/6180/noise-ik/<pubkey1>/handshake/0
//    /dns4/hang-2.evil.com/tcp/6180/noise-ik/<pubkey2>/handshake/0
//    ... (up to 64+)
// 3. Configure honest validator to discover these malicious validators
// 4. Trigger connectivity manager to ping eligible peers
// 5. Monitor blocking thread pool usage - all 64 threads will be consumed
// 6. Attempt any new blocking operation (file I/O, new DNS lookup) - it will hang

// To demonstrate the blocking behavior in isolation:
#[tokio::test]
async fn test_dns_blocking_thread_exhaustion() {
    use tokio::net::lookup_host;
    use std::time::Duration;
    
    // Simulate non-responding DNS by using a DNS name that times out
    // In reality, this would require actual DNS server configuration
    let mut handles = vec![];
    
    // Spawn 64 tasks that each perform DNS lookup
    for i in 0..64 {
        let handle = tokio::spawn(async move {
            // This will block a thread in the blocking pool
            let _ = lookup_host(("non-responding-dns-{}.test", 6180)).await;
        });
        handles.push(handle);
    }
    
    // Try to perform another blocking operation - it will be delayed
    // until one of the above completes
    let start = std::time::Instant::now();
    tokio::task::spawn_blocking(|| {
        std::thread::sleep(Duration::from_millis(100));
    }).await.unwrap();
    let elapsed = start.elapsed();
    
    // If blocking pool is exhausted, this will take longer than expected
    println!("Blocking operation took: {:?}", elapsed);
}
```

## Notes

This vulnerability is particularly insidious because:
1. The timeout wrappers at the async level give a false sense of security—they cancel futures but not blocking system calls
2. The issue affects both the main connection path (`resolve_with_filter`) and the latency measurement path (`spawn_latency_ping_task`)
3. System administrators may not be aware that default DNS resolver configurations can lack adequate timeouts

The vulnerability does require the attacker to be a validator (or compromise validator configurations), which is within the Byzantine fault tolerance threat model but raises the bar for exploitation.

### Citations

**File:** network/netcore/src/transport/tcp.rs (L189-197)
```rust
async fn resolve_with_filter(
    ip_filter: IpFilter,
    dns_name: &str,
    port: u16,
) -> io::Result<impl Iterator<Item = SocketAddr> + '_> {
    Ok(lookup_host((dns_name, port))
        .await?
        .filter(move |socketaddr| ip_filter.matches(socketaddr.ip())))
}
```

**File:** network/framework/src/connectivity_manager/mod.rs (L663-705)
```rust
        // Spawn a task that pings each peer concurrently
        let ping_start_time = Instant::now();
        let mut ping_tasks = vec![];
        for (peer_id, peer) in peers_to_ping.into_iter() {
            // Get the network address for the peer
            let network_context = self.network_context;
            let network_address = match self.dial_states.get(&peer_id) {
                Some(dial_state) => match dial_state.random_addr(&peer.addrs) {
                    Some(network_address) => network_address.clone(),
                    None => {
                        warn!(
                            NetworkSchema::new(&network_context),
                            "Peer {} does not have a network address!",
                            peer_id.short_str()
                        );
                        continue; // Continue onto the next peer
                    },
                },
                None => {
                    warn!(
                        NetworkSchema::new(&network_context),
                        "Peer {} does not have a dial state!",
                        peer_id.short_str()
                    );
                    continue; // Continue onto the next peer
                },
            };

            // Ping the peer
            let ping_task = spawn_latency_ping_task(
                network_context,
                peer_id,
                network_address,
                self.discovered_peers.clone(),
            );

            // Add the task to the list of ping tasks
            ping_tasks.push(ping_task);
        }

        // Wait for all the ping tasks to complete (or timeout)
        let num_ping_tasks = ping_tasks.len();
        join_all(ping_tasks).await;
```

**File:** network/framework/src/connectivity_manager/mod.rs (L1159-1170)
```rust
    tokio::task::spawn_blocking(move || {
        // Extract the socket addresses from the network address
        let socket_addresses = match network_address.to_socket_addrs() {
            Ok(socket_addresses) => socket_addresses.collect::<Vec<_>>(),
            Err(error) => {
                warn!(
                    NetworkSchema::new(&network_context),
                    "Failed to resolve network address {:?}: {}", network_address, error
                );
                return;
            },
        };
```

**File:** network/framework/src/transport/mod.rs (L20-20)
```rust
pub use aptos_netcore::transport::tcp::{resolve_and_connect, TCPBufferCfg, TcpSocket};
```

**File:** network/framework/src/transport/mod.rs (L40-41)
```rust
/// A timeout for the connection to open and complete all of the upgrade steps.
pub const TRANSPORT_TIMEOUT: Duration = Duration::from_secs(30);
```

**File:** network/framework/src/transport/mod.rs (L567-567)
```rust
        let upgrade_fut = timeout_io(self.time_service.clone(), TRANSPORT_TIMEOUT, upgrade_fut);
```

**File:** crates/aptos-runtimes/src/lib.rs (L27-27)
```rust
    const MAX_BLOCKING_THREADS: usize = 64;
```

**File:** crates/aptos-runtimes/src/lib.rs (L50-50)
```rust
        .max_blocking_threads(MAX_BLOCKING_THREADS)
```
