# Audit Report

## Title
Storage Fee Double-Counting in Lazy Account Creation Fee Validation

## Summary
The `failed_transaction_cleanup` function incorrectly double-counts storage fees when validating minimum fee requirements for lazy account creation, allowing accounts to be created with insufficient storage fees paid.

## Finding Description

The `storage_fee_used()` function correctly returns fees measured in Octa (not gas units). However, there is a critical arithmetic error in how these fees are validated during lazy account creation in `aptos-move/aptos-vm/src/aptos_vm.rs`. [1](#0-0) 

The calculation at line 767 adds `storage_fee` to the product of `gas_used * gas_unit_price`. This is incorrect because `gas_used` already includes the storage fee converted to gas units. [2](#0-1) 

The gas meter's consistency check confirms that total gas consumed equals `execution_gas_used + io_gas_used + storage_fee_in_internal_units`, where `storage_fee_in_internal_units` is the storage fee (in Octa) divided by the gas unit price and converted to internal gas units. [3](#0-2) 

Therefore, when `gas_used * gas_unit_price` is calculated, it already includes the storage fee in Octa. Adding `storage_fee` again double-counts it.

According to the official documentation: [4](#0-3) 

The correct net charge formula is `total_charge_gas_units * gas_unit_price - storage_fee_refund_octas`, NOT `total_charge_gas_units * gas_unit_price + storage_fee_octas - storage_fee_refund_octas`.

**Attack Vector:**
During lazy account creation (sequence number 0 for non-existent accounts), if a transaction aborts:
1. The abort hook creates the account using `UnmeteredGasMeter` if needed (bypassing gas limits)
2. `charge_change_set` attempts to charge storage fees but failures are only logged
3. The check at line 773 should validate minimum fees were paid
4. Due to double-counting, `actual` is inflated by `storage_fee`, making the check pass when it should fail
5. Accounts get created with fees below the required minimum [5](#0-4) [6](#0-5) 

## Impact Explanation

**Medium Severity** - This violates the "Resource Limits" invariant by allowing state growth without proper fee payment. The protocol subsidizes storage costs for lazy account creation, leading to:

- **Economic Loss**: Difference between actual fees paid and minimum required fees
- **State Manipulation**: Accounts created without meeting minimum storage fee requirements  
- **State Bloat Vector**: Attackers can create accounts at discounted rates

While not causing direct fund theft or consensus violations, this allows systematic underpayment for state storage, which could be exploited at scale to bloat chain state while paying below the intended minimum costs.

## Likelihood Explanation

**High Likelihood** - This bug triggers automatically for any transaction that:
- Has sequence number 0 (new account)
- Aborts during execution
- Triggers lazy account creation

No special privileges or complex setup required. The vulnerability is present in the core transaction execution path and affects all validators identically (deterministic bug, not a consensus issue).

## Recommendation

Remove the incorrect addition of `storage_fee` in the fee validation check:

```rust
// BEFORE (incorrect):
let actual = gas_used * gas_unit_price + storage_fee - storage_refund;

// AFTER (correct):
let actual = gas_used * gas_unit_price - storage_refund;
```

This aligns with the documented net charge calculation and prevents double-counting the storage fee. [7](#0-6) 

## Proof of Concept

The vulnerability can be demonstrated by creating a transaction that:

1. Transfers funds to a new address (creating balance without Account resource)
2. Submits a transaction from that address with sequence number 0
3. Ensures the transaction aborts (e.g., insufficient gas for full execution)
4. Observes that the account gets created despite paying `actual_fee = execution + io + storage - refund` which is less than the required minimum `M`, as long as `actual_fee + storage >= M`

The double-counting allows the check to pass when:
- Correct calculation: `actual_fee < M` (should fail)
- Incorrect calculation: `actual_fee + storage_fee >= M` (incorrectly passes)

This can be verified by examining transaction receipts where `gas_used * gas_unit_price < hack_account_creation_fee_lower_bound()` but the account creation succeeds.

## Notes

This is a logic error in arithmetic, not a type confusion in the strict sense. The `storage_fee_used()` function correctly returns `Fee` type (Octa), but the surrounding calculation incorrectly uses this value. The Rust type system prevents direct unit confusion between `Fee` and `Gas` types, but cannot prevent this logical double-counting error where both values happen to be in the same unit (Octa) after conversion.

### Citations

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L722-730)
```rust
                .or_else(|_err| {
                    create_account_if_does_not_exist(
                        session,
                        module_storage,
                        &mut UnmeteredGasMeter,
                        txn_data.sender(),
                        traversal_context,
                    )
                })
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L743-754)
```rust
            if let Err(err) = self.charge_change_set(
                &mut abort_hook_session_change_set,
                gas_meter,
                txn_data,
                resolver,
                module_storage,
            ) {
                info!(
                    *log_context,
                    "Failed during charge_change_set: {:?}. Most likely exceeded gas limited.", err,
                );
            };
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L763-767)
```rust
                let gas_used = fee_statement.gas_used();
                let storage_fee = fee_statement.storage_fee_used();
                let storage_refund = fee_statement.storage_fee_refund();

                let actual = gas_used * gas_unit_price + storage_fee - storage_refund;
```

**File:** aptos-move/aptos-gas-meter/src/algebra.rs (L152-153)
```rust
        let total_calculated =
            self.execution_gas_used + self.io_gas_used + self.storage_fee_in_internal_units;
```

**File:** aptos-move/aptos-gas-meter/src/algebra.rs (L260-263)
```rust
        let gas_consumed_internal = div_ceil(
            (u64::from(amount) as u128) * (u64::from(txn_params.gas_unit_scaling_factor) as u128),
            u64::from(gas_unit_price) as u128,
        );
```

**File:** aptos-move/framework/aptos-framework/sources/transaction_fee.move (L57-62)
```text
    ///        - storage fee charge (storage space): `storage_fee_octas`, to be included in
    ///          `total_charge_gas_unit`, this number is converted to gas units according to the user
    ///          specified `gas_unit_price` on the transaction.
    ///    - storage deletion refund: `storage_fee_refund_octas`, this is not included in `gas_used` or
    ///      `total_charge_gas_units`, the net charge / refund is calculated by
    ///      `total_charge_gas_units` * `gas_unit_price` - `storage_fee_refund_octas`.
```
