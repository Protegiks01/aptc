# Audit Report

## Title
Missing Rs Length Validation in Weighted PVSS Transcript Allows Malicious Dealer to Cause Decryption Panics

## Summary
The weighted PVSS transcript verification does not validate that the `Rs` (ElGamal randomness) field has the expected length equal to `max_weight`. This allows a malicious DKG dealer to create a transcript with insufficient randomness elements, causing honest players with higher weights to panic during share decryption, resulting in validator node crashes and DKG protocol failure.

## Finding Description
The `HkzgWeightedElgamalWitness` is used in the DKG (Distributed Key Generation) PVSS protocol to encrypt shares for validators. The witness contains `chunked_plaintexts` (the actual shares) and `elgamal_randomness` (randomness for encryption). When a dealer creates a transcript, it includes the public statement consisting of `Cs` (encrypted chunks) and `Rs` (committed randomness).

The vulnerability exists in the transcript verification logic: [1](#0-0) 

The verification checks that `Cs.len()` and `Vs.len()` equal the total number of players, but **critically omits** validation that `Rs.len()` equals `max_weight`. This missing check allows a malicious dealer to submit a transcript with `Rs` having fewer elements than required.

During decryption, when a player attempts to decrypt their shares: [2](#0-1) 

The code uses `.take(weight)` to extract randomness elements from `Rs`. If a player has weight greater than `Rs.len()`, the iterator produces fewer elements than expected. Then: [3](#0-2) 

The loop iterates `for i in 0..weight` but attempts to access `ephemeral_keys[i]` which only has `Rs.len()` elements, causing an **index out of bounds panic**.

**Attack Path:**
1. Malicious dealer creates a witness with `elgamal_randomness.len() < max_weight` (e.g., 1 when max_weight is 3)
2. Dealer generates the proof and transcript normally - the homomorphism application will only use the available randomness due to zip truncation behavior: [4](#0-3) 
3. The resulting transcript has `Rs.len() = 1` 
4. Transcript verification passes (no Rs length check)
5. Honest player with weight â‰¥ 2 attempts decryption
6. **Node panics** with "index out of bounds" error at `ephemeral_keys[i]` access

## Impact Explanation
This is a **High Severity** vulnerability per Aptos bug bounty criteria:

- **Validator Node Crashes**: Any validator attempting to decrypt shares from a malformed transcript will panic, causing their node to crash during DKG execution
- **DKG Protocol Failure**: The DKG protocol cannot complete successfully if participants cannot decrypt their shares, preventing randomness beacon generation and validator set updates
- **Network Liveness Impact**: If DKG fails during epoch transitions, it can prevent the network from progressing to the next epoch, affecting consensus liveness
- **Amplification**: A single malicious dealer can affect multiple honest validators simultaneously

The vulnerability breaks the **Deterministic Execution** and **Resource Limits** invariants, as honest validators crash unexpectedly rather than handling errors gracefully.

## Likelihood Explanation
**High Likelihood:**
- Any participant in the DKG protocol can act as a dealer
- Exploitation requires no special privileges beyond DKG participation
- The attack is trivial to execute - simply construct a transcript with shortened Rs vector
- No cryptographic operations or complex protocol manipulation needed
- The vulnerability will trigger deterministically for any player with weight > Rs.len()

The only requirement is that the attacker be a validator eligible to participate in DKG, which is achievable through normal staking mechanisms.

## Recommendation
Add explicit validation of Rs dimensions during transcript verification:

```rust
fn verify<A: Serialize + Clone>(
    &self,
    sc: &Self::SecretSharingConfig,
    pp: &Self::PublicParameters,
    spks: &[Self::SigningPubKey],
    eks: &[Self::EncryptPubKey],
    sid: &A,
) -> anyhow::Result<()> {
    // Existing checks...
    if self.subtrs.Cs.len() != sc.get_total_num_players() {
        bail!("Expected {} arrays of chunked ciphertexts, but got {}", ...);
    }
    if self.subtrs.Vs.len() != sc.get_total_num_players() {
        bail!("Expected {} arrays of commitment elements, but got {}", ...);
    }
    
    // ADD THIS CHECK:
    if self.subtrs.Rs.len() != sc.get_max_weight() {
        bail!(
            "Expected {} randomness vectors (max_weight), but got {}",
            sc.get_max_weight(),
            self.subtrs.Rs.len()
        );
    }
    
    // Additionally validate that each Rs[i] has consistent chunk count
    let expected_chunks = num_chunks_per_scalar::<E::ScalarField>(pp.ell) as usize;
    for (i, R_vec) in self.subtrs.Rs.iter().enumerate() {
        if R_vec.len() != expected_chunks {
            bail!(
                "Expected {} chunks in Rs[{}], but got {}",
                expected_chunks, i, R_vec.len()
            );
        }
    }
    
    // Continue with existing verification...
}
```

## Proof of Concept
```rust
#[test]
#[should_panic(expected = "index out of bounds")]
fn test_malformed_rs_causes_panic() {
    use ark_bn254::{Bn254, Fr};
    use aptos_crypto::weighted_config::WeightedConfig;
    
    // Setup: 3-out-of-5 config with weights [2, 3] (max_weight = 3)
    let sc = WeightedConfig::new(3, vec![2, 3]).unwrap();
    let pp = PublicParameters::<Bn254>::default();
    
    // Create a valid transcript
    let mut transcript = Transcript::<Bn254>::generate(&sc, &pp, &mut thread_rng());
    
    // ATTACK: Maliciously truncate Rs to have only 1 element (should be 3)
    transcript.subtrs.Rs = vec![transcript.subtrs.Rs[0].clone()];
    
    // Verification passes (no Rs length check!)
    let eks = generate_encryption_keys(&sc, &mut thread_rng());
    let spks = generate_signing_keys(&sc);
    assert!(transcript.verify(&sc, &pp, &spks, &eks, &"test").is_ok());
    
    // Player with weight 3 attempts decryption
    let player = sc.get_player(1); // Player 1 has weight 3
    let dk = generate_decryption_key(&mut thread_rng());
    
    // This will panic: index out of bounds when accessing ephemeral_keys[2]
    transcript.subtrs.decrypt_own_share(&sc, &player, &dk, &pp);
}
```

## Notes
The vulnerability is specifically in the `verify` function's incomplete dimension validation. While `Cs` dimensions are validated indirectly through the flattening check, `Rs` dimensions are never validated, creating an asymmetry in the security guarantees. The fix requires adding explicit length checks for both `Rs` outer dimension (must equal `max_weight`) and inner dimensions (each must have the correct number of chunks).

### Citations

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcript.rs (L133-153)
```rust
        if eks.len() != sc.get_total_num_players() {
            bail!(
                "Expected {} encryption keys, but got {}",
                sc.get_total_num_players(),
                eks.len()
            );
        }
        if self.subtrs.Cs.len() != sc.get_total_num_players() {
            bail!(
                "Expected {} arrays of chunked ciphertexts, but got {}",
                sc.get_total_num_players(),
                self.subtrs.Cs.len()
            );
        }
        if self.subtrs.Vs.len() != sc.get_total_num_players() {
            bail!(
                "Expected {} arrays of commitment elements, but got {}",
                sc.get_total_num_players(),
                self.subtrs.Vs.len()
            );
        }
```

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcript.rs (L331-336)
```rust
        let ephemeral_keys: Vec<_> = self
            .Rs
            .iter()
            .take(weight)
            .map(|R_i_vec| R_i_vec.iter().map(|R_i| R_i.mul(dk.dk)).collect::<Vec<_>>())
            .collect();
```

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcript.rs (L349-355)
```rust
        for i in 0..weight {
            // TODO: should really put this in a separate function
            let dealt_encrypted_secret_key_share_chunks: Vec<_> = Cs[i]
                .iter()
                .zip(ephemeral_keys[i].iter())
                .map(|(C_ij, ephemeral_key)| C_ij.sub(ephemeral_key))
                .collect();
```

**File:** crates/aptos-dkg/src/pvss/chunky/chunked_elgamal.rs (L210-217)
```rust
    chunks_vec
        .iter()
        .zip(correlated_randomness_vec.iter())
        .map(|(chunks, correlated_randomness)| {
            chunks_msm_terms::<C>(pp, ek, chunks, correlated_randomness)
        })
        .collect()
}
```
