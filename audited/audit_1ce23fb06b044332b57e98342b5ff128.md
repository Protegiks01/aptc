# Audit Report

## Title
Division by Zero Panic in ConnectedComponentPartitioner When num_executor_shards is Zero

## Summary
The `ConnectedComponentPartitioner` contains a division operation that will cause either a panic (via integer modulo-by-zero) or undefined behavior (via float division and casting) if called with `num_executor_shards = 0`. However, production code has protective measures that prevent this scenario from occurring in practice.

## Finding Description

The block partitioner implementation contains two critical division operations that lack input validation for `num_executor_shards`:

**First Panic Point** - Integer Modulo by Zero: [1](#0-0) 

This calls `get_anchor_shard_id` which performs: [2](#0-1) 

**Second Issue** - Float Division and UB: [3](#0-2) 

The execution flow is: [4](#0-3) 

When `num_executor_shards = 0`:
1. If transactions access storage locations, `init()` will panic on modulo-by-zero
2. If no storage access occurs, `pre_partition()` encounters float division by zero (resulting in infinity), then casting infinity to `usize` causes undefined behavior

## Impact Explanation

**Why NOT High Severity:**

The production code contains protective measures that prevent this scenario: [5](#0-4) 

The wrapper ensures that when `num_shards == 0`, the partitioner is never instantiated or called. Additionally, the default configuration is: [6](#0-5) 

While the method lacks input validation (defensive programming issue), there is **no realistic attack path** for an unprivileged attacker to trigger this vulnerability through normal transaction submission, API calls, or configuration.

## Likelihood Explanation

**Likelihood: Very Low**

- Production wrapper prevents instantiation when shards = 0
- No external API allows setting this value maliciously
- Would require code changes or test harness to trigger
- Not exploitable through transaction submission or peer interaction

## Recommendation

Add input validation to the `partition` method as a defense-in-depth measure:

```rust
fn partition(
    &self,
    txns: Vec<AnalyzedTransaction>,
    num_executor_shards: usize,
) -> PartitionedTransactions {
    assert!(num_executor_shards > 0, "num_executor_shards must be greater than 0");
    // ... rest of implementation
}
```

## Proof of Concept

```rust
#[test]
#[should_panic(expected = "attempt to calculate the remainder with a divisor of zero")]
fn test_partitioner_with_zero_shards() {
    let partitioner = PartitionerV2::new(
        4,
        4,
        0.9,
        64,
        false,
        Box::new(ConnectedComponentPartitioner {
            load_imbalance_tolerance: 2.0,
        }),
    );
    
    let block_generator = P2PBlockGenerator::new(100);
    let mut rng = thread_rng();
    let block = block_generator.rand_block(&mut rng, 10);
    
    // This will panic
    let _partitioned = partitioner.partition(block, 0);
}
```

---

## Notes

**This does NOT qualify as a valid bug bounty submission** because:
- The vulnerability is protected by production wrapper code
- No realistic attack path exists for unprivileged attackers
- Cannot be triggered through normal protocol operation
- Requires code modification or test harness to exploit

This is a **defensive programming improvement** rather than an exploitable security vulnerability. The production deployment is safe due to the protective wrapper in `BlockPreparationStage`.

### Citations

**File:** execution/block-partitioner/src/v2/init.rs (L46-49)
```rust
                                let anchor_shard_id = get_anchor_shard_id(
                                    storage_location,
                                    state.num_executor_shards,
                                );
```

**File:** execution/block-partitioner/src/lib.rs (L39-43)
```rust
fn get_anchor_shard_id(storage_location: &StorageLocation, num_shards: usize) -> ShardId {
    let mut hasher = DefaultHasher::new();
    storage_location.hash(&mut hasher);
    (hasher.finish() % num_shards as u64) as usize
}
```

**File:** execution/block-partitioner/src/pre_partition/connected_component/mod.rs (L88-91)
```rust
        // Calculate txn group size limit.
        let group_size_limit = ((state.num_txns() as f32) * self.load_imbalance_tolerance
            / (state.num_executor_shards as f32))
            .ceil() as usize;
```

**File:** execution/block-partitioner/src/v2/mod.rs (L140-157)
```rust
        let mut state = PartitionState::new(
            self.thread_pool.clone(),
            self.dashmap_num_shards,
            txns,
            num_executor_shards,
            self.max_partitioning_rounds,
            self.cross_shard_dep_avoid_threshold,
            self.partition_last_round,
        );
        // Step 1: build some necessary indices for txn senders/storage locations.
        Self::init(&mut state);

        // Step 2: pre-partition.
        (
            state.ori_idxs_by_pre_partitioned,
            state.start_txn_idxs_by_shard,
            state.pre_partitioned,
        ) = self.pre_partitioner.pre_partition(&state);
```

**File:** execution/executor-benchmark/src/block_preparation.rs (L47-52)
```rust
        let maybe_partitioner = if num_shards == 0 {
            None
        } else {
            let partitioner = partitioner_config.build();
            Some(partitioner)
        };
```

**File:** execution/executor-benchmark/src/main.rs (L205-206)
```rust
    #[clap(long, default_value = "0")]
    num_executor_shards: usize,
```
