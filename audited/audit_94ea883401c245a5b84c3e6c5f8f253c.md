# Audit Report

## Title
Node Crash Due to Empty Weights HashMap in SecretShareAggregator::retain()

## Summary
The `SecretShareAggregator::retain()` function unconditionally expects all share authors to exist in the `weights` HashMap parameter, but this HashMap is initialized as empty and never populated, causing guaranteed node crashes during normal secret sharing operations when any shares exist in the aggregator.

## Finding Description

The vulnerability exists in the interaction between two components:

1. **Empty Weights Initialization**: The `SecretShareConfig` struct initializes its `weights` field as an empty `HashMap::new()` [1](#0-0)  and this HashMap is never populated anywhere in the codebase. The `get_peer_weights()` method simply returns a reference to this empty HashMap. [2](#0-1) 

2. **Unchecked Weight Lookup**: The `SecretShareAggregator::retain()` function calls `.expect("Author must exist for weight")` on `weights.get(author)` for every share author, which panics if the author is not found in the weights map. [3](#0-2) 

**Exploitation Path (Normal Operation - No Attack Required):**

1. Validators broadcast their secret shares for a round via `broadcast_without_self()` [4](#0-3) 

2. Receiving validators process incoming shares through the verification task, which deserializes and verifies shares [5](#0-4) 

3. Verified shares are added to the `SecretShareItem` in `PendingMetadata` state via the `add_share()` method, storing them in the aggregator [6](#0-5) 

4. When the receiving validator computes its own self-share, it calls `add_self_share()`, which retrieves the empty weights HashMap [7](#0-6) 

5. This triggers `add_share_with_metadata()`, which calls `share_aggregator.retain()` with the empty weights HashMap [8](#0-7) 

6. **PANIC**: The `retain()` function attempts to recalculate total weight by looking up each share author in the empty HashMap, causing `expect()` to panic [9](#0-8) 

7. The consensus node crashes with the error message "Author must exist for weight"

**Broken Invariant**: This violates the "Total loss of liveness/network availability" critical invariant - nodes with secret sharing enabled cannot participate in consensus because they crash during normal operation.

## Impact Explanation

This is a **CRITICAL SEVERITY** issue per Aptos bug bounty criteria:

- **Total loss of liveness/network availability**: Any consensus node with the secret sharing feature enabled will crash immediately when attempting to process secret shares from peers
- **Non-recoverable without restart**: The node must be restarted after each crash, and will crash again upon receiving the next set of shares
- **Affects all nodes**: Every validator node using secret sharing will experience this issue
- **No Byzantine behavior required**: This occurs during normal, honest operation - not an attack
- **Blocks feature deployment**: The secret sharing feature cannot be deployed to production in this state

The impact meets the Critical Severity threshold of "Total loss of liveness/network availability" worth up to $1,000,000 in the bug bounty program.

## Likelihood Explanation

**Likelihood: CERTAIN (100%)**

This vulnerability will trigger with absolute certainty under the following conditions:

1. The secret sharing feature is enabled for an epoch
2. At least one validator broadcasts their secret share before another validator computes its own self-share
3. The receiving validator has any shares in its aggregator when it calls `add_self_share()`

Given that network message delivery is asynchronous and validators may have different block processing speeds, it is **guaranteed** that some validators will receive peer shares before computing their own self-share. This makes the crash inevitable during normal operation.

The vulnerability requires **zero** attacker sophistication - it happens automatically as part of the protocol's normal operation.

## Recommendation

**Immediate Fix**: Populate the `weights` HashMap in `SecretShareConfig` with actual validator weights from the `ValidatorVerifier`.

Modify the `SecretShareConfig::new()` constructor in `types/src/secret_sharing.rs` to extract weights from the validator verifier:

```rust
pub fn new(
    author: Author,
    epoch: u64,
    validator: Arc<ValidatorVerifier>,
    digest_key: DigestKey,
    msk_share: MasterSecretKeyShare,
    verification_keys: Vec<VerificationKey>,
    config: <FPTXWeighted as BatchThresholdEncryption>::ThresholdConfig,
    encryption_key: EncryptionKey,
) -> Self {
    // Build weights map from validator verifier
    let weights = validator
        .address_to_validator_index()
        .keys()
        .map(|addr| (*addr, 1u64)) // Use actual voting weights when available
        .collect();
    
    Self {
        _author: author,
        _epoch: epoch,
        validator,
        digest_key,
        msk_share,
        verification_keys,
        config,
        encryption_key,
        weights,
    }
}
```

**Alternative Fix**: Remove the `expect()` and handle missing weights gracefully:

In `consensus/src/rand/secret_sharing/secret_share_store.rs`, modify the `retain()` function:

```rust
fn retain(&mut self, metadata: &SecretShareMetadata, weights: &HashMap<Author, u64>) {
    self.shares.retain(|_, share| share.metadata == *metadata);
    self.total_weight = self
        .shares
        .keys()
        .filter_map(|author| weights.get(author))
        .sum();
}
```

**Recommended Approach**: Implement the first fix to properly populate weights, as the weights are clearly intended to be used for threshold calculations. The `get_peer_weight()` method currently returns a hardcoded `1`, indicating this is incomplete functionality. [10](#0-9) 

## Proof of Concept

**Rust Integration Test**:

```rust
#[tokio::test]
async fn test_secret_share_retain_panic() {
    use aptos_types::secret_sharing::{SecretShareConfig, SecretShare, SecretShareMetadata};
    use aptos_consensus::rand::secret_sharing::secret_share_store::{
        SecretShareAggregator, SecretShareStore
    };
    use std::collections::HashMap;
    
    // Create a SecretShareConfig with empty weights (current behavior)
    let config = SecretShareConfig::new(
        /* ... initialize with test parameters ... */
    );
    
    // Verify weights HashMap is empty
    assert!(config.get_peer_weights().is_empty());
    
    // Create aggregator and add a share from a valid validator
    let mut aggregator = SecretShareAggregator::new(author);
    let share = SecretShare::new(/* valid validator share */);
    aggregator.add_share(share, 1);
    
    // Create metadata matching the share
    let metadata = SecretShareMetadata::new(/* ... */);
    
    // This call WILL PANIC with "Author must exist for weight"
    // because weights HashMap is empty but aggregator has shares
    aggregator.retain(&metadata, config.get_peer_weights());
    // PANIC occurs here ^
}
```

**Reproduction Steps**:

1. Enable secret sharing feature in an Aptos testnet
2. Start multiple validator nodes
3. Propose a block requiring secret sharing
4. Observe that validators crash with panic message "Author must exist for weight" when processing incoming secret shares
5. Check logs to confirm the panic originates from `SecretShareAggregator::retain()`

The vulnerability is deterministic and will crash nodes reliably under the conditions described.

---

**Notes**: 

This vulnerability exists because the `weights` field was added to `SecretShareConfig` but the initialization logic was never completed. The comment "This is temporary and meant to change in future PRs" at [11](#0-10)  and the TODO comment regarding weight configuration suggest this feature was under development but deployed in an incomplete state. The hardcoded return value of `1` in `get_peer_weight()` further confirms this is unfinished functionality that assumes uniform weights but relies on a populated HashMap that is never created.

### Citations

**File:** types/src/secret_sharing.rs (L134-134)
```rust
/// This is temporary and meant to change in future PRs
```

**File:** types/src/secret_sharing.rs (L168-168)
```rust
            weights: HashMap::new(),
```

**File:** types/src/secret_sharing.rs (L196-198)
```rust
    pub fn get_peer_weight(&self, _peer: &Author) -> u64 {
        1
    }
```

**File:** types/src/secret_sharing.rs (L200-202)
```rust
    pub fn get_peer_weights(&self) -> &HashMap<Author, u64> {
        &self.weights
    }
```

**File:** consensus/src/rand/secret_sharing/secret_share_store.rs (L74-81)
```rust
    fn retain(&mut self, metadata: &SecretShareMetadata, weights: &HashMap<Author, u64>) {
        self.shares.retain(|_, share| share.metadata == *metadata);
        self.total_weight = self
            .shares
            .keys()
            .map(|author| weights.get(author).expect("Author must exist for weight"))
            .sum();
    }
```

**File:** consensus/src/rand/secret_sharing/secret_share_store.rs (L110-112)
```rust
            SecretShareItem::PendingMetadata(aggr) => {
                aggr.add_share(share, share_weight);
                Ok(())
```

**File:** consensus/src/rand/secret_sharing/secret_share_store.rs (L168-168)
```rust
                share_aggregator.retain(share.metadata(), share_weights);
```

**File:** consensus/src/rand/secret_sharing/secret_share_store.rs (L242-242)
```rust
        let peer_weights = self.secret_share_config.get_peer_weights();
```

**File:** consensus/src/rand/secret_sharing/secret_share_manager.rs (L154-156)
```rust
        self.network_sender.broadcast_without_self(
            SecretShareMessage::Share(self_secret_share).into_network_message(),
        );
```

**File:** consensus/src/rand/secret_sharing/secret_share_manager.rs (L218-226)
```rust
                    match bcs::from_bytes::<SecretShareMessage>(dec_msg.req.data()) {
                        Ok(msg) => {
                            if msg.verify(&epoch_state_clone, &config_clone).is_ok() {
                                let _ = tx.unbounded_send(SecretShareRpc {
                                    msg,
                                    protocol: dec_msg.protocol,
                                    response_sender: dec_msg.response_sender,
                                });
                            }
```
