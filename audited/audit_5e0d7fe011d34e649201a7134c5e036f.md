# Audit Report

## Title
Gas Validation Bypass During Backup Restoration Allows Zero-Gas Transactions in Restored Ledger

## Summary
The backup restoration system does not validate that gas was properly charged for transactions during restore operations. Both direct save and replay-with-NoVerify code paths skip gas validation, allowing malicious backup files containing zero-gas transactions to be restored into the ledger database, violating the critical invariant that all transactions must properly charge gas.

## Finding Description

The vulnerability exists in two restore code paths that both fail to validate gas charges:

**Path 1: Direct Save Without Validation**

When restoring transactions with versions below `replay_from_version`, the system calls `RestoreHandler::save_transactions` [1](#0-0) , which delegates to `restore_utils::save_transactions_impl` [2](#0-1) . This function saves `TransactionInfo` objects (containing the `gas_used` field [3](#0-2) ) directly to the database without validating that gas was properly charged.

**Path 2: Replay with NoVerify Mode**

When restoring transactions at or above `replay_from_version`, the system uses `VerifyExecutionMode::NoVerify` by default in all standard restore operations [4](#0-3)  and in the restore coordinator [5](#0-4) [6](#0-5) . With `NoVerify` mode, the `should_verify()` check returns false [7](#0-6) , causing the chunk executor to skip `verify_execution()` entirely [8](#0-7)  and apply transactions without re-executing them to validate gas consumption.

**Cryptographic Verification is Insufficient**

While the restore process verifies cryptographic proofs via `TransactionListWithProof::verify()` [9](#0-8) , this only validates that transaction hashes match and that `TransactionInfo` objects are authentically part of the ledger. It does NOT validate the correctness of the `gas_used` field value itself.

**Attack Scenario:**
1. Attacker crafts malicious backup files where `TransactionInfo` objects have `gas_used = 0`
2. The backup maintains valid cryptographic proofs (which only prove authenticity, not correctness of gas values)
3. Victim node performs restore operation using standard tools
4. System either saves transactions directly (Path 1) or applies them with NoVerify (Path 2)
5. Zero-gas transactions are committed to the restored database
6. Restored ledger state violates gas payment invariants

## Impact Explanation

This is a **HIGH severity** vulnerability per Aptos bug bounty criteria:

- **Significant Protocol Violation**: Breaks the fundamental invariant that all user transactions must pay gas fees (Invariant #9: "All operations must respect gas, storage, and computational limits")
- **State Inconsistency**: Restored databases contain invalid ledger state that would not have been producible through normal transaction execution
- **Restoration Attack Vector**: Any node restoring from a compromised or malicious backup source could import invalid transactions
- **Consensus Divergence Risk**: If different nodes restore from different backup sources (some malicious, some legitimate), they could have inconsistent ledger histories

While this doesn't allow immediate theft of funds or consensus breaks on the live network, it enables significant protocol violations and state inconsistencies requiring intervention.

## Likelihood Explanation

**Likelihood: Medium**

**Attack Requirements:**
- Attacker must control or intercept backup files used for restoration
- Victim must perform a restore operation (common for new nodes, disaster recovery, or archive nodes)
- Default restore operations use NoVerify mode for performance reasons

**Feasibility Factors:**
- Backup files are often stored in cloud storage or distributed via CDN
- Organizations may use third-party backup providers
- No integrity checks exist to detect modified gas_used values
- The vulnerability is in default code paths used by standard tooling

This is more likely than attacks requiring validator collusion, but less likely than attacks on live transaction processing.

## Recommendation

Implement mandatory gas validation during restore operations:

**Option 1: Always Verify Execution During Replay**
Change the default `VerifyExecutionMode` from `NoVerify` to `verify_all()` for restoration operations. This ensures transactions are re-executed and gas charges are validated.

**Option 2: Add Gas-Specific Validation**
Add a dedicated validation step in `save_transactions_impl` that verifies gas charges are within acceptable bounds and match expected values for the transaction type.

**Option 3: Backup Integrity Checks**
Add cryptographic signatures or checksums that cover not just transaction hashes but also `TransactionInfo` field values, preventing modification of gas_used values without detection.

**Recommended Implementation:**
At minimum, change restore operations to use `VerifyExecutionMode::verify_all()` instead of `NoVerify` for security-critical restores, with an explicit opt-in flag for `NoVerify` mode that warns users about the security implications.

## Proof of Concept

```rust
// Conceptual PoC - demonstrates the vulnerability path
// This would need to be integrated into the actual test framework

use aptos_backup_cli::backup_types::transaction::restore::TransactionRestoreController;
use aptos_executor_types::VerifyExecutionMode;
use aptos_types::transaction::{TransactionInfo, TransactionInfoV0};

#[test]
fn test_zero_gas_transaction_restore() {
    // Step 1: Create a malicious backup with zero-gas TransactionInfo
    let malicious_txn_info = TransactionInfoV0::new(
        transaction_hash,
        state_change_hash,
        event_root_hash,
        Some(state_checkpoint_hash),
        0, // gas_used = 0 (malicious)
        ExecutionStatus::Success,
        None,
    );
    
    // Step 2: Create backup chunk with this transaction
    let chunk = create_transaction_chunk_with_modified_gas(malicious_txn_info);
    
    // Step 3: Attempt restore with NoVerify mode (current default)
    let controller = TransactionRestoreController::new(
        restore_opt,
        global_opt,
        storage,
        None,
        VerifyExecutionMode::NoVerify, // Default in production
    );
    
    // Step 4: Verify zero-gas transaction is accepted
    controller.run().await.expect("Restore should succeed");
    
    // Step 5: Query restored DB and confirm gas_used = 0
    let restored_txn_info = db.get_transaction_info(version).unwrap();
    assert_eq!(restored_txn_info.gas_used(), 0); // Vulnerability: accepted!
}
```

## Notes

This vulnerability specifically affects the backup/restore subsystem and does not impact normal transaction processing on live networks. However, it represents a significant weakness in the restoration trust model, as operators must trust that backup sources have not been tampered with. Given that backup restoration is a critical recovery mechanism for Aptos nodes, this validation gap should be addressed.

### Citations

**File:** storage/aptosdb/src/backup/restore_handler.rs (L78-99)
```rust
    pub fn save_transactions(
        &self,
        first_version: Version,
        txns: &[Transaction],
        persisted_aux_info: &[PersistedAuxiliaryInfo],
        txn_infos: &[TransactionInfo],
        events: &[Vec<ContractEvent>],
        write_sets: Vec<WriteSet>,
    ) -> Result<()> {
        restore_utils::save_transactions(
            self.state_store.clone(),
            self.ledger_db.clone(),
            first_version,
            txns,
            persisted_aux_info,
            txn_infos,
            events,
            write_sets,
            None,
            false,
        )
    }
```

**File:** storage/aptosdb/src/backup/restore_utils.rs (L193-294)
```rust
pub(crate) fn save_transactions_impl(
    state_store: Arc<StateStore>,
    ledger_db: Arc<LedgerDb>,
    first_version: Version,
    txns: &[Transaction],
    persisted_aux_info: &[PersistedAuxiliaryInfo],
    txn_infos: &[TransactionInfo],
    events: &[Vec<ContractEvent>],
    write_sets: &[WriteSet],
    ledger_db_batch: &mut LedgerDbSchemaBatches,
    state_kv_batches: &mut ShardedStateKvSchemaBatch,
    kv_replay: bool,
) -> Result<()> {
    for (idx, txn) in txns.iter().enumerate() {
        ledger_db.transaction_db().put_transaction(
            first_version + idx as Version,
            txn,
            /*skip_index=*/ false,
            &mut ledger_db_batch.transaction_db_batches,
        )?;
    }

    for (idx, aux_info) in persisted_aux_info.iter().enumerate() {
        PersistedAuxiliaryInfoDb::put_persisted_auxiliary_info(
            first_version + idx as Version,
            aux_info,
            &mut ledger_db_batch.persisted_auxiliary_info_db_batches,
        )?;
    }

    for (idx, txn_info) in txn_infos.iter().enumerate() {
        TransactionInfoDb::put_transaction_info(
            first_version + idx as Version,
            txn_info,
            &mut ledger_db_batch.transaction_info_db_batches,
        )?;
    }

    ledger_db
        .transaction_accumulator_db()
        .put_transaction_accumulator(
            first_version,
            txn_infos,
            &mut ledger_db_batch.transaction_accumulator_db_batches,
        )?;

    ledger_db.event_db().put_events_multiple_versions(
        first_version,
        events,
        &mut ledger_db_batch.event_db_batches,
    )?;

    if ledger_db.enable_storage_sharding() {
        for (idx, txn_events) in events.iter().enumerate() {
            for event in txn_events {
                if let Some(event_key) = event.event_key() {
                    if *event_key == new_block_event_key() {
                        LedgerMetadataDb::put_block_info(
                            first_version + idx as Version,
                            event,
                            &mut ledger_db_batch.ledger_metadata_db_batches,
                        )?;
                    }
                }
            }
        }
    }
    // insert changes in write set schema batch
    for (idx, ws) in write_sets.iter().enumerate() {
        WriteSetDb::put_write_set(
            first_version + idx as Version,
            ws,
            &mut ledger_db_batch.write_set_db_batches,
        )?;
    }

    if kv_replay && first_version > 0 && state_store.get_usage(Some(first_version - 1)).is_ok() {
        let (ledger_state, _hot_state_updates) = state_store.calculate_state_and_put_updates(
            &StateUpdateRefs::index_write_sets(first_version, write_sets, write_sets.len(), vec![]),
            &mut ledger_db_batch.ledger_metadata_db_batches, // used for storing the storage usage
            state_kv_batches,
        )?;
        // n.b. ideally this is set after the batches are committed
        state_store.set_state_ignoring_summary(ledger_state);
    }

    let last_version = first_version + txns.len() as u64 - 1;
    ledger_db_batch
        .ledger_metadata_db_batches
        .put::<DbMetadataSchema>(
            &DbMetadataKey::LedgerCommitProgress,
            &DbMetadataValue::Version(last_version),
        )?;
    ledger_db_batch
        .ledger_metadata_db_batches
        .put::<DbMetadataSchema>(
            &DbMetadataKey::OverallCommitProgress,
            &DbMetadataValue::Version(last_version),
        )?;

    Ok(())
}
```

**File:** types/src/transaction/mod.rs (L2025-2051)
```rust
pub struct TransactionInfoV0 {
    /// The amount of gas used.
    gas_used: u64,

    /// The vm status. If it is not `Executed`, this will provide the general error class. Execution
    /// failures and Move abort's receive more detailed information. But other errors are generally
    /// categorized with no status code or other information
    status: ExecutionStatus,

    /// The hash of this transaction.
    transaction_hash: HashValue,

    /// The root hash of Merkle Accumulator storing all events emitted during this transaction.
    event_root_hash: HashValue,

    /// The hash value summarizing all changes caused to the world state by this transaction.
    /// i.e. hash of the output write set.
    state_change_hash: HashValue,

    /// The root hash of the Sparse Merkle Tree describing the world state at the end of this
    /// transaction. Depending on the protocol configuration, this can be generated periodical
    /// only, like per block.
    state_checkpoint_hash: Option<HashValue>,

    /// The hash value summarizing PersistedAuxiliaryInfo.
    auxiliary_info_hash: Option<HashValue>,
}
```

**File:** types/src/transaction/mod.rs (L2318-2353)
```rust
        self.transactions
            .par_iter()
            .zip_eq(self.proof.transaction_infos.par_iter())
            .map(|(txn, txn_info)| {
                let txn_hash = CryptoHash::hash(txn);
                ensure!(
                    txn_hash == txn_info.transaction_hash(),
                    "The hash of transaction does not match the transaction info in proof. \
                     Transaction hash: {:x}. Transaction hash in txn_info: {:x}.",
                    txn_hash,
                    txn_info.transaction_hash(),
                );
                Ok(())
            })
            .collect::<Result<Vec<_>>>()?;

        // Verify the transaction infos are proven by the ledger info.
        self.proof
            .verify(ledger_info, self.get_first_transaction_version())?;

        // Verify the events if they exist.
        if let Some(event_lists) = &self.events {
            ensure!(
                event_lists.len() == self.get_num_transactions(),
                "The length of event_lists ({}) does not match the number of transactions ({}).",
                event_lists.len(),
                self.get_num_transactions(),
            );
            event_lists
                .into_par_iter()
                .zip_eq(self.proof.transaction_infos.par_iter())
                .map(|(events, txn_info)| verify_events_against_root_hash(events, txn_info))
                .collect::<Result<Vec<_>>>()?;
        }

        Ok(())
```

**File:** storage/db-tool/src/restore.rs (L97-111)
```rust
                    Oneoff::Transaction {
                        storage,
                        opt,
                        global,
                    } => {
                        TransactionRestoreController::new(
                            opt,
                            global.try_into()?,
                            storage.init_storage().await?,
                            None, /* epoch_history */
                            VerifyExecutionMode::NoVerify,
                        )
                        .run()
                        .await?;
                    },
```

**File:** storage/backup/backup-cli/src/coordinators/restore.rs (L289-300)
```rust
            TransactionRestoreBatchController::new(
                transaction_restore_opt,
                Arc::clone(&self.storage),
                txn_manifests,
                Some(db_next_version),
                Some((kv_replay_version, true /* only replay KV */)),
                epoch_history.clone(),
                VerifyExecutionMode::NoVerify,
                None,
            )
            .run()
            .await?;
```

**File:** storage/backup/backup-cli/src/coordinators/restore.rs (L360-371)
```rust
            TransactionRestoreBatchController::new(
                self.global_opt,
                self.storage,
                txn_manifests,
                first_version,
                replay_version,
                epoch_history,
                VerifyExecutionMode::NoVerify,
                None,
            )
            .run()
            .await?;
```

**File:** execution/executor-types/src/lib.rs (L240-242)
```rust
    pub fn should_verify(&self) -> bool {
        !matches!(self, Self::NoVerify)
    }
```

**File:** execution/executor/src/chunk_executor/mod.rs (L562-575)
```rust
            let next_begin = if verify_execution_mode.should_verify() {
                self.verify_execution(
                    transactions,
                    persisted_aux_info,
                    transaction_infos,
                    write_sets,
                    event_vecs,
                    batch_begin,
                    batch_end,
                    verify_execution_mode,
                )?
            } else {
                batch_end
            };
```
