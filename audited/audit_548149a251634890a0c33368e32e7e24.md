# Audit Report

## Title
Gas Charging Bypass via Delete+Create Squashing in Table Operations

## Summary
The `has_creation()` function fails to detect resource creations when a table entry is deleted and recreated within the same transaction due to WriteOp squashing logic. This allows attackers to bypass slot creation gas fees by converting Delete+Create operations into Modification operations, paying only modification fees instead of the full creation cost including slot deposits.

## Finding Description

The vulnerability exists in the interaction between three components:

1. **WriteOp Squashing Logic**: When change sets from multiple operations are combined, the `WriteOp::squash` function converts a Deletion followed by a Creation into a Modification. [1](#0-0) 

2. **The has_creation() Check**: This function only detects `WriteOpSize::Creation` operations, missing effectively-created slots that were squashed into Modifications. [2](#0-1) 

3. **Gas Fee Structure**: Creation operations charge slot deposit fees, while Modification operations only charge for incremental bytes. [3](#0-2) [4](#0-3) 

**Attack Vector**: 

An attacker can exploit this through table operations, which allow removing and adding entries at the same key within a single transaction: [5](#0-4) [6](#0-5) 

The native implementations use `move_to` (for add) and `move_from` (for remove), which generate Creation and Deletion WriteOps respectively: [7](#0-6) [8](#0-7) 

**Exploitation Steps**:

1. Table contains entry at key K (slot deposit already paid in previous transaction)
2. Transaction calls `table::remove(table, K)` → generates Deletion WriteOp, user receives full refund (slot + bytes deposit)
3. Transaction calls `table::add(table, K, new_value)` → generates Creation WriteOp
4. During change set finalization, WriteOp::squash converts Deletion + Creation → Modification
5. Gas charging sees only Modification WriteOpSize, charges only bytes fee (no slot fee)
6. Net result: User gets refunded the slot deposit but doesn't pay it again for the recreated entry

The developers were aware of related concerns as evidenced by the check in respawned_session.rs, but it uses `has_creation()` which fails to detect squashed creations: [9](#0-8) 

## Impact Explanation

**Severity: MEDIUM** - Limited funds loss or manipulation through gas fee bypass.

Financial Impact:
- With V1 pricing: Slot creation fee of `legacy_storage_fee_per_state_slot_create` is bypassed (typically significant)
- With V2 pricing: Slot deposit of `storage_fee_per_state_slot` is bypassed
- Attacker receives full refund on deletion but avoids paying the slot fee on recreation

This violates the critical invariant: "Resource Limits: All operations must respect gas, storage, and computational limits."

The impact is limited to gas fee manipulation rather than consensus safety or total funds loss, qualifying it as Medium severity per the Aptos bug bounty criteria.

## Likelihood Explanation

**Likelihood: HIGH**

The attack is trivially executable by any user with access to table operations:
- No special privileges required
- No validator collusion needed
- Simple two-line Move code (remove then add)
- Works on any existing table entry
- Deterministic and repeatable

The only requirement is that the table entry must have existed previously (from an earlier transaction) so that the deletion receives a refund.

## Recommendation

Implement a more robust creation detection mechanism that tracks effective creations even after squashing. Options include:

1. **Track Creation Intent**: Before squashing, mark state keys that underwent deletion to detect subsequent recreations.

2. **Detect Delete+Create Patterns**: In the squashing logic, when converting Deletion + Creation to Modification, set a flag indicating this was an effective creation.

3. **Enhanced has_creation() Check**: Add detection for Modification operations that carry metadata from deleted entries, indicating they represent recreations.

Recommended fix in `write_set.rs`:

```rust
pub enum WriteOpKind {
    Creation,
    Modification,
    Deletion,
    // New variant for squashed delete+create
    RecreationAfterDeletion,
}

// In squash function:
(Deletion(d_meta), Creation(c)) => {
    // Mark this as a recreation, not a simple modification
    *op = Self(RecreationAfterDeletion(StateValue::new_with_metadata(
        c.into_bytes(), 
        d_meta.clone()
    )))
}
```

Then update `has_creation()` to detect both Creation and RecreationAfterDeletion.

## Proof of Concept

```move
#[test(account = @0x1)]
fun test_gas_bypass_via_delete_create(account: signer) {
    use aptos_std::table;
    
    // Setup: Create table with an entry (simulate previous transaction)
    let t = table::new<u64, vector<u8>>();
    let key: u64 = 42;
    let initial_value = b"initial_data_that_paid_slot_fee";
    table::add(&mut t, key, initial_value);
    
    // Store the table to simulate previous transaction
    move_to(&account, TableHolder { t });
    
    // Attack: In new transaction, remove and recreate
    let holder = borrow_global_mut<TableHolder<u64, vector<u8>>>(@0x1);
    
    // Step 1: Remove entry (get refund of slot + bytes deposit)
    let _old_value = table::remove(&mut holder.t, key);
    
    // Step 2: Add new entry at same key (should pay slot fee but won't after squashing)
    let new_value = b"new_data_should_pay_slot_fee_but_wont";
    table::add(&mut holder.t, key, new_value);
    
    // After squashing: Deletion + Creation becomes Modification
    // Gas charged: Only modification fee (bytes only, no slot creation fee)
    // Net result: Attacker avoided slot creation fee
}

struct TableHolder<phantom K: copy + drop, phantom V: store> has key {
    t: table::Table<K, V>
}
```

This test demonstrates the vulnerability: the delete+add pattern on the same key within a transaction results in squashed WriteOps that bypass slot creation fees.

### Citations

**File:** types/src/write_set.rs (L188-196)
```rust
            (Deletion(d_meta), Creation(c)) => {
                // n.b. With write sets from multiple sessions being squashed together, it's possible
                //   to see two ops carrying different metadata (or one with it the other without)
                //   due to deleting in one session and recreating in another. The original metadata
                //   shouldn't change due to the squash.
                // And because the deposit or refund happens after all squashing is finished, it's
                // not a concern of fairness.
                *op = Self(Modification(StateValue::new_with_metadata(c.into_bytes(), d_meta.clone())))
            },
```

**File:** aptos-move/aptos-vm-types/src/change_set.rs (L769-772)
```rust
    pub fn has_creation(&self) -> bool {
        self.write_set_size_iter()
            .any(|(_key, op_size)| matches!(op_size, WriteOpSize::Creation { .. }))
    }
```

**File:** aptos-move/aptos-vm-types/src/storage/space_pricing.rs (L124-136)
```rust
            Creation { write_len } => {
                let slot_fee = params.legacy_storage_fee_per_state_slot_create * NumSlots::new(1);
                let bytes_fee = Self::discounted_write_op_size_for_v1(params, op.key, write_len)
                    * params.legacy_storage_fee_per_excess_state_byte;

                if !op.metadata_mut.is_none() {
                    op.metadata_mut.set_slot_deposit(slot_fee.into())
                }

                ChargeAndRefund {
                    charge: slot_fee + bytes_fee,
                    refund: 0.into(),
                }
```

**File:** aptos-move/aptos-vm-types/src/storage/space_pricing.rs (L174-185)
```rust
            Creation { .. } => {
                // permanent storage fee
                let slot_deposit = u64::from(params.storage_fee_per_state_slot);

                op.metadata_mut.maybe_upgrade();
                op.metadata_mut.set_slot_deposit(slot_deposit);
                op.metadata_mut.set_bytes_deposit(target_bytes_deposit);

                ChargeAndRefund {
                    charge: (slot_deposit + target_bytes_deposit).into(),
                    refund: 0.into(),
                }
```

**File:** aptos-move/framework/aptos-stdlib/sources/table.move (L27-29)
```text
    public fun add<K: copy + drop, V>(self: &mut Table<K, V>, key: K, val: V) {
        add_box<K, V, Box<V>>(self, key, Box { val })
    }
```

**File:** aptos-move/framework/aptos-stdlib/sources/table.move (L75-78)
```text
    public fun remove<K: copy + drop, V>(self: &mut Table<K, V>, key: K): V {
        let Box { val } = remove_box<K, V, Box<V>>(self, key);
        val
    }
```

**File:** aptos-move/framework/table-natives/src/lib.rs (L428-433)
```rust
    let res = match gv.move_to(val) {
        Ok(_) => Ok(smallvec![]),
        Err(_) => Err(SafeNativeError::Abort {
            abort_code: ALREADY_EXISTS,
        }),
    };
```

**File:** aptos-move/framework/table-natives/src/lib.rs (L602-607)
```rust
    let res = match gv.move_from() {
        Ok(val) => Ok(smallvec![val]),
        Err(_) => Err(SafeNativeError::Abort {
            abort_code: NOT_FOUND,
        }),
    };
```

**File:** aptos-move/aptos-vm/src/move_vm_ext/session/respawned_session.rs (L86-98)
```rust
        if assert_no_additional_creation && additional_change_set.has_creation() {
            // After respawning in the epilogue, there shouldn't be new slots
            // created, otherwise there's a potential vulnerability like this:
            // 1. slot created by the user
            // 2. another user transaction deletes the slot and claims the refund
            // 3. in the epilogue the same slot gets recreated, and the final write set will have
            //    a ModifyWithMetadata carrying the original metadata
            // 4. user keeps doing the same and repeatedly claim refund out of the slot.
            return Err(VMStatus::error(
                StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR,
                err_msg("Unexpected storage allocation after respawning session."),
            ));
        }
```
