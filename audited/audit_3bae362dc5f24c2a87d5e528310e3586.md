# Audit Report

## Title
State KV Pruner Off-By-One Error: Incorrect Deletion of Tombstones at min_readable_version Boundary

## Summary
The state KV pruner uses an inclusive boundary condition (`stale_since_version <= target_version`) when deleting stale state entries, causing tombstones (deletion markers) at exactly `min_readable_version` to be incorrectly pruned. This results in state queries at the minimum readable version returning stale data instead of correctly indicating deleted keys, breaking the State Consistency invariant.

## Finding Description
The vulnerability exists in the boundary logic used by the state pruning system across multiple pruner implementations. The core issue involves three related facts: [1](#0-0) 

First, the pruner's `target_version` is set equal to `min_readable_version`, which represents the oldest version that should still be queryable. [2](#0-1) 

Second, the pruning logic uses the condition `stale_since_version <= target_version` to determine which entries to delete, meaning entries where `stale_since_version == min_readable_version` are deleted. [3](#0-2) 

Third, when a key is deleted at version V, a tombstone is created with both `stale_since_version = V` and `version = V`. The comment explicitly states "can be pruned once this `version` goes out of the pruning window." [4](#0-3) 

However, the system's error checking explicitly allows queries at `min_readable_version` itself (using `version >= min_readable_version`), expecting this version to be fully readable.

**Exploitation Path:**

1. State evolves: version 99 has key K with value V1, version 100 deletes key K (creating tombstone), version 101+ continues
2. Pruning window advances such that `min_readable_version = 100`
3. Pruner calculates `target_version = 100` and deletes all entries with `stale_since_version <= 100`
4. This deletes:
   - The StaleStateValueIndex for the tombstone (stale_since_version=100, version=100)  
   - The actual StateValue entry at (K, version 100) which contains the deletion marker (None)
5. When an API client or syncing node queries state at version 100: [5](#0-4) 

   - The query seeks to (state_key, version 100) in descending version order
   - Since the tombstone at version 100 was deleted, the iterator finds the next available entry
   - This returns the value from version 99 or earlier (V1) instead of correctly returning None
   - The state at version 100 is misrepresented as having the key present with the old value

## Impact Explanation
This vulnerability breaks **Critical Invariant #4: State Consistency** - "State transitions must be atomic and verifiable via Merkle proofs."

**Severity: High** - This constitutes a "Significant protocol violation" under the Aptos bug bounty criteria because:

1. **State Query Incorrectness**: All state queries at exactly `min_readable_version` will return incorrect data for any keys that were deleted at that version. This affects:
   - REST API endpoints serving historical state
   - Blockchain explorers and indexers
   - Applications relying on historical state queries

2. **State Synchronization Risk**: If a syncing node attempts to reconstruct state from `min_readable_version` (which is explicitly marked as readable), it will:
   - Receive incorrect state values for deleted keys
   - Potentially compute incorrect state roots
   - Risk state divergence from properly synced nodes

3. **Deterministic Execution Violation**: Different nodes querying the same version could potentially get different results depending on their pruning state, violating the deterministic execution requirement for validators.

While this does not directly cause consensus failure (state roots are computed from current state, not pruned historical data), it creates a **state inconsistency requiring intervention** (Medium severity) with potential escalation to validator synchronization issues (High severity).

## Likelihood Explanation
**Likelihood: High** - This bug triggers automatically during normal pruning operations:

1. **Automatic Occurrence**: No attacker action required; happens whenever the pruning window advances
2. **Frequent Trigger**: Every key deletion at a version that later becomes `min_readable_version` is affected
3. **Production Impact**: All nodes running with pruning enabled (standard configuration) experience this issue
4. **Detection Difficulty**: The bug only affects queries at the exact boundary version, which may not be frequently tested

The bug has likely been occurring in production but may not have been detected because:
- Historical queries at exact boundary versions are uncommon
- State sync typically uses snapshots or starts from slightly later versions
- The impact window is limited (only one version at a time)

## Recommendation
**Fix: Change the boundary condition from inclusive to exclusive:**

In `storage/aptosdb/src/pruner/state_kv_pruner/state_kv_shard_pruner.rs`, line 60:

```rust
// Current (incorrect):
if index.stale_since_version <= target_version {

// Should be:
if index.stale_since_version < target_version {
```

Similarly, in `storage/aptosdb/src/pruner/state_merkle_pruner/mod.rs`, line 208:

```rust
// Current (incorrect):  
if index.stale_since_version <= target_version {

// Should be:
if index.stale_since_version < target_version {
```

**Rationale**: A tombstone or value created at version V is needed to correctly represent state at version V. If `min_readable_version = V`, then version V must be fully queryable with correct tombstone markers. The comment in the code supports this interpretation: data "can be pruned once this version goes out of the pruning window," meaning when `min_readable_version > version`, not `>=`.

**Alternative Fix**: Adjust the target_version calculation to be `min_readable_version - 1`, but this is less clear and could introduce edge cases at version 0.

## Proof of Concept

```rust
// Reproduction test (add to storage/aptosdb/src/pruner/state_kv_pruner/test.rs)
#[test]
fn test_tombstone_at_min_readable_version_boundary() {
    let tmp_dir = TempPath::new();
    let db = AptosDB::new_for_test(&tmp_dir);
    
    // Setup: Create state at version 99
    let key = StateKey::raw(b"test_key");
    let value_v99 = StateValue::new_legacy(b"value_at_99".to_vec().into());
    
    // Write version 99
    db.state_store.put_value_sets(
        vec![vec![(key.clone(), Some(value_v99.clone()))]],
        0, // first_version
        99, // last_version  
        None, // ledger_info
    ).unwrap();
    
    // Write version 100 with deletion (tombstone)
    db.state_store.put_value_sets(
        vec![vec![(key.clone(), None)]], // None = deletion
        100, // first_version
        100, // last_version
        None,
    ).unwrap();
    
    // Verify state before pruning
    let result_v99 = db.state_store.get_state_value_by_version(&key, 99).unwrap();
    assert!(result_v99.is_some());
    assert_eq!(result_v99.unwrap(), value_v99);
    
    let result_v100 = db.state_store.get_state_value_by_version(&key, 100).unwrap();
    assert!(result_v100.is_none(), "Version 100 should show key as deleted");
    
    // Set min_readable_version = 100 and prune
    db.state_store.state_kv_pruner.save_min_readable_version(100).unwrap();
    db.state_store.state_kv_pruner.set_pruner_target_db_version(100);
    db.state_store.state_kv_pruner.prune(1000).unwrap(); // Prune with large batch
    
    // BUG: After pruning, querying at version 100 returns wrong result
    let result_after_prune = db.state_store.get_state_value_by_version(&key, 100).unwrap();
    
    // Expected: Still None (key deleted at v100)
    // Actual: Returns value_v99 or error (tombstone was incorrectly pruned)
    assert!(result_after_prune.is_none(), 
        "VULNERABILITY: Tombstone at min_readable_version was incorrectly pruned, \
         causing state query to return stale data instead of correctly indicating deletion");
}
```

This test demonstrates that after pruning to `min_readable_version = 100`, queries at version 100 no longer correctly return None for deleted keys, violating state consistency guarantees.

### Citations

**File:** storage/aptosdb/src/pruner/state_merkle_pruner/state_merkle_pruner_manager.rs (L162-173)
```rust
        let min_readable_version = latest_version.saturating_sub(self.prune_window);
        self.min_readable_version
            .store(min_readable_version, Ordering::SeqCst);

        PRUNER_VERSIONS
            .with_label_values(&[S::name(), "min_readable"])
            .set(min_readable_version as i64);

        self.pruner_worker
            .as_ref()
            .unwrap()
            .set_target_db_version(min_readable_version);
```

**File:** storage/aptosdb/src/pruner/state_kv_pruner/state_kv_shard_pruner.rs (L60-64)
```rust
            if index.stale_since_version > target_version {
                break;
            }
            batch.delete::<StaleStateValueIndexByKeyHashSchema>(&index)?;
            batch.delete::<StateValueByKeyHashSchema>(&(index.state_key_hash, index.version))?;
```

**File:** storage/aptosdb/src/state_store/mod.rs (L947-950)
```rust
                if update_to_cold.state_op.expect_as_write_op().is_delete() {
                    // This is a tombstone, can be pruned once this `version` goes out of
                    // the pruning window.
                    Self::put_state_kv_index(batch, enable_sharding, version, version, key);
```

**File:** storage/aptosdb/src/db/aptosdb_internal.rs (L305-314)
```rust
    pub(super) fn error_if_state_kv_pruned(&self, data_type: &str, version: Version) -> Result<()> {
        let min_readable_version = self.state_store.state_kv_pruner.get_min_readable_version();
        ensure!(
            version >= min_readable_version,
            "{} at version {} is pruned, min available version is {}.",
            data_type,
            version,
            min_readable_version
        );
        Ok(())
```

**File:** storage/aptosdb/src/state_kv_db.rs (L374-401)
```rust
    pub(crate) fn get_state_value_with_version_by_version(
        &self,
        state_key: &StateKey,
        version: Version,
    ) -> Result<Option<(Version, StateValue)>> {
        let mut read_opts = ReadOptions::default();

        // We want `None` if the state_key changes in iteration.
        read_opts.set_prefix_same_as_start(true);
        if !self.enabled_sharding() {
            let mut iter = self
                .db_shard(state_key.get_shard_id())
                .iter_with_opts::<StateValueSchema>(read_opts)?;
            iter.seek(&(state_key.clone(), version))?;
            Ok(iter
                .next()
                .transpose()?
                .and_then(|((_, version), value_opt)| value_opt.map(|value| (version, value))))
        } else {
            let mut iter = self
                .db_shard(state_key.get_shard_id())
                .iter_with_opts::<StateValueByKeyHashSchema>(read_opts)?;
            iter.seek(&(state_key.hash(), version))?;
            Ok(iter
                .next()
                .transpose()?
                .and_then(|((_, version), value_opt)| value_opt.map(|value| (version, value))))
        }
```
