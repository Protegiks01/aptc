# Audit Report

## Title
On-Chain Discovery Allows Malicious Validator Operators to Inject Attacker-Controlled Nodes into Trusted Peer Set

## Summary
The on-chain validator discovery mechanism in `DiscoveryMethod::Onchain` does not validate that network identity keys (x25519 public keys) embedded in validator network addresses are authentic or bound to the validator's account. A malicious validator operator can call `stake::update_network_and_fullnode_addresses()` with attacker-controlled network addresses and keys, causing all other validators to add these malicious keys to their trusted peer set and establish connections to attacker-controlled infrastructure.

## Finding Description

The vulnerability exists in the interaction between the staking module's address update function and the network discovery system. The attack flow is:

1. **Operator Updates Network Addresses** [1](#0-0) 
   The `update_network_and_fullnode_addresses()` function only verifies operator authorization but performs NO validation that the network keys in the addresses are legitimate or bound to the validator's identity.

2. **Keys Extracted from Addresses** [2](#0-1) 
   The `extract_validator_set_updates()` function creates `Peer` objects using `Peer::from_addrs()`, which extracts x25519 public keys directly from network addresses without validation.

3. **Malicious Keys Added to Trusted Set** [3](#0-2) 
   The connectivity manager's `handle_update_discovered_peers()` function updates the trusted peer set with whatever keys are in the addresses, then calls `set_trusted_peers()` to propagate them.

4. **Authentication Succeeds with Attacker Keys** [4](#0-3) 
   The `authenticate_inbound()` function only checks if the remote public key exists in `peer.keys` from the trusted set. Since the attacker's keys are now in this set, authentication succeeds.

5. **No Cryptographic Binding** [5](#0-4) 
   The code acknowledges that validator peer IDs (account addresses) are independent of network identity keys, with no cryptographic binding between them.

**Attack Scenario:**
- Malicious operator generates attacker-controlled x25519 keypair
- Calls `update_network_and_fullnode_addresses()` with addresses containing attacker's keys and IP
- All validators receive this via on-chain discovery at next epoch
- Validators add attacker's keys to trusted set for that peer_id
- When validators connect to that peer_id, they dial attacker's infrastructure
- Attacker successfully authenticates using their private keys
- Attacker now sits in communication path, can read/drop/delay all network messages to/from victim

**Why This Works:**
The network addresses contain protocol information including x25519 public keys [6](#0-5) , and these keys are extracted and trusted without verifying they belong to the validator account.

## Impact Explanation

**Severity: High to Critical**

This vulnerability enables:

1. **Man-in-the-Middle Attacks**: Attacker intercepts all network traffic to/from victim validator
2. **Liveness Attacks**: Selective message dropping can prevent victim from participating in consensus  
3. **Network Partition**: If multiple validators are compromised, could partition the network
4. **Privacy Breach**: All consensus messages (even if signed) can be read by attacker
5. **Protocol Violation**: Fundamentally breaks the trust model that on-chain discovery provides authentic peer information

**Mitigating Factor**: Consensus messages are signed with BLS12-381 keys (separate from network keys), preventing the attacker from forging valid consensus votes or proposals. However, the attacker can still disrupt liveness and violate the authenticated communication invariant.

This qualifies as **High Severity** ("Significant protocol violations", "Validator node slowdowns") with potential escalation to **Critical** ("Total loss of liveness/network availability") if multiple validators are affected simultaneously.

## Likelihood Explanation

**Likelihood: Medium to High**

**Requirements:**
- Compromised validator operator account (through key theft, phishing, or malicious insider)
- Ability to submit transaction calling `update_network_and_fullnode_addresses()`
- Wait for epoch boundary for changes to propagate

**Feasibility:**
- Operator accounts are high-value targets for attackers
- The attack is straightforward with no complex timing or state requirements
- No collusion between validators needed
- Effects persist until operator reverts the change or is removed

The question explicitly considers malicious validator operators as in-scope ("malicious on-chain validator set updates"), making this a realistic threat model.

## Recommendation

**Immediate Fix**: Implement cryptographic binding between validator account addresses (peer_id) and network identity keys.

**Option 1 - Consensus Key Signature**:
Require that network address updates include a signature from the validator's consensus key (BLS) proving authorization:

```rust
public entry fun update_network_and_fullnode_addresses(
    operator: &signer,
    pool_address: address,
    new_network_addresses: vector<u8>,
    new_fullnode_addresses: vector<u8>,
    consensus_key_signature: vector<u8>, // NEW: Signature over the new keys
) acquires StakePool, ValidatorConfig {
    // ... existing authorization checks ...
    
    let validator_info = borrow_global_mut<ValidatorConfig>(pool_address);
    
    // NEW: Verify consensus key signed the network address update
    let message = hash_network_address_update(pool_address, new_network_addresses);
    assert!(
        verify_consensus_signature(&validator_info.consensus_pubkey, &message, &consensus_key_signature),
        error::invalid_argument(EINVALID_KEY_SIGNATURE)
    );
    
    validator_info.network_addresses = new_network_addresses;
    // ... rest of function ...
}
```

**Option 2 - Derive Peer ID from Network Key**:
Change the system to derive validator peer IDs from their network identity keys (similar to fullnodes), establishing a cryptographic binding. This would be a larger architectural change.

**Option 3 - Additional Validation in Discovery**:
Add verification in `authenticate_inbound()` that checks peer_id consistency [7](#0-6) , but apply it to ALL peers including those in the trusted set (currently only checked for unknown peers in MaybeMutual mode).

## Proof of Concept

```rust
// Integration test demonstrating the vulnerability
#[test]
fn test_malicious_network_address_update() {
    // Setup: Create validator with legitimate keys
    let mut executor = TestExecutor::new();
    let validator_account = create_validator_account();
    let legitimate_key = x25519::PrivateKey::generate_for_testing();
    
    // Attacker generates their own keys
    let attacker_key = x25519::PrivateKey::generate_for_testing();
    let attacker_address = NetworkAddress::from_str(&format!(
        "/ip4/1.2.3.4/tcp/6180/noise-ik/{}/handshake/0",
        attacker_key.public_key()
    )).unwrap();
    
    // Malicious operator calls update with attacker's keys
    let result = stake::update_network_and_fullnode_addresses(
        &validator_operator,
        validator_account,
        bcs::to_bytes(&vec![attacker_address]).unwrap(),
        vec![],
    );
    assert!(result.is_ok()); // No validation prevents this!
    
    // Trigger epoch change
    executor.new_epoch();
    
    // Other validators receive update via on-chain discovery
    let validator_set = executor.read_validator_set();
    let peer = validator_set.get(&validator_account).unwrap();
    
    // Verify attacker's key is now in trusted set
    assert!(peer.keys.contains(&attacker_key.public_key()));
    
    // When honest validator connects, it will dial attacker's infrastructure
    // and successfully authenticate using the attacker's key
}
```

## Notes

The vulnerability fundamentally violates the security invariant that on-chain validator information should be cryptographically authentic and trustworthy. While BLS signature verification on consensus messages prevents safety violations, the network-level man-in-the-middle capability still enables significant attacks on liveness, privacy, and the overall security model of the validator network.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L955-995)
```text
    public entry fun update_network_and_fullnode_addresses(
        operator: &signer,
        pool_address: address,
        new_network_addresses: vector<u8>,
        new_fullnode_addresses: vector<u8>,
    ) acquires StakePool, ValidatorConfig {
        check_stake_permission(operator);
        assert_reconfig_not_in_progress();
        assert_stake_pool_exists(pool_address);
        let stake_pool = borrow_global_mut<StakePool>(pool_address);
        assert!(signer::address_of(operator) == stake_pool.operator_address, error::unauthenticated(ENOT_OPERATOR));
        assert!(exists<ValidatorConfig>(pool_address), error::not_found(EVALIDATOR_CONFIG));
        let validator_info = borrow_global_mut<ValidatorConfig>(pool_address);
        let old_network_addresses = validator_info.network_addresses;
        validator_info.network_addresses = new_network_addresses;
        let old_fullnode_addresses = validator_info.fullnode_addresses;
        validator_info.fullnode_addresses = new_fullnode_addresses;

        if (std::features::module_event_migration_enabled()) {
            event::emit(
                UpdateNetworkAndFullnodeAddresses {
                    pool_address,
                    old_network_addresses,
                    new_network_addresses,
                    old_fullnode_addresses,
                    new_fullnode_addresses,
                },
            );
        } else {
            event::emit_event(
                &mut stake_pool.update_network_and_fullnode_addresses_events,
                UpdateNetworkAndFullnodeAddressesEvent {
                    pool_address,
                    old_network_addresses,
                    new_network_addresses,
                    old_fullnode_addresses,
                    new_fullnode_addresses,
                },
            );
        };
    }
```

**File:** network/discovery/src/validator_set.rs (L108-150)
```rust
pub(crate) fn extract_validator_set_updates(
    network_context: NetworkContext,
    node_set: ValidatorSet,
) -> PeerSet {
    let is_validator = network_context.network_id().is_validator_network();

    // Decode addresses while ignoring bad addresses
    node_set
        .into_iter()
        .map(|info| {
            let peer_id = *info.account_address();
            let config = info.into_config();

            let addrs = if is_validator {
                config
                    .validator_network_addresses()
                    .map_err(anyhow::Error::from)
            } else {
                config
                    .fullnode_network_addresses()
                    .map_err(anyhow::Error::from)
            }
            .map_err(|err| {
                inc_by_with_context(&DISCOVERY_COUNTS, &network_context, "read_failure", 1);

                warn!(
                    NetworkSchema::new(&network_context),
                    "OnChainDiscovery: Failed to parse any network address: peer: {}, err: {}",
                    peer_id,
                    err
                )
            })
            .unwrap_or_default();

            let peer_role = if is_validator {
                PeerRole::Validator
            } else {
                PeerRole::ValidatorFullNode
            };
            (peer_id, Peer::from_addrs(peer_role, addrs))
        })
        .collect()
}
```

**File:** network/framework/src/connectivity_manager/mod.rs (L886-1002)
```rust
    fn handle_update_discovered_peers(
        &mut self,
        src: DiscoverySource,
        new_discovered_peers: PeerSet,
    ) {
        // Log the update event
        info!(
            NetworkSchema::new(&self.network_context),
            "{} Received updated list of discovered peers! Source: {:?}, num peers: {:?}",
            self.network_context,
            src,
            new_discovered_peers.len()
        );

        // Remove peers that no longer have relevant network information
        let mut keys_updated = false;
        let mut peers_to_check_remove = Vec::new();
        for (peer_id, peer) in self.discovered_peers.write().peer_set.iter_mut() {
            let new_peer = new_discovered_peers.get(peer_id);
            let check_remove = if let Some(new_peer) = new_peer {
                if new_peer.keys.is_empty() {
                    keys_updated |= peer.keys.clear_src(src);
                }
                if new_peer.addresses.is_empty() {
                    peer.addrs.clear_src(src);
                }
                new_peer.addresses.is_empty() && new_peer.keys.is_empty()
            } else {
                keys_updated |= peer.keys.clear_src(src);
                peer.addrs.clear_src(src);
                true
            };
            if check_remove {
                peers_to_check_remove.push(*peer_id);
            }
        }

        // Remove peers that no longer have state
        for peer_id in peers_to_check_remove {
            self.discovered_peers.write().remove_peer_if_empty(&peer_id);
        }

        // Make updates to the peers accordingly
        for (peer_id, discovered_peer) in new_discovered_peers {
            // Don't include ourselves, because we don't need to dial ourselves
            if peer_id == self.network_context.peer_id() {
                continue;
            }

            // Create the new `DiscoveredPeer`, role is set when a `Peer` is first discovered
            let mut discovered_peers = self.discovered_peers.write();
            let peer = discovered_peers
                .peer_set
                .entry(peer_id)
                .or_insert_with(|| DiscoveredPeer::new(discovered_peer.role));

            // Update the peer's pubkeys
            let mut peer_updated = false;
            if peer.keys.update(src, discovered_peer.keys) {
                info!(
                    NetworkSchema::new(&self.network_context)
                        .remote_peer(&peer_id)
                        .discovery_source(&src),
                    "{} pubkey sets updated for peer: {}, pubkeys: {}",
                    self.network_context,
                    peer_id.short_str(),
                    peer.keys
                );
                keys_updated = true;
                peer_updated = true;
            }

            // Update the peer's addresses
            if peer.addrs.update(src, discovered_peer.addresses) {
                info!(
                    NetworkSchema::new(&self.network_context).remote_peer(&peer_id),
                    network_addresses = &peer.addrs,
                    "{} addresses updated for peer: {}, update src: {:?}, addrs: {}",
                    self.network_context,
                    peer_id.short_str(),
                    src,
                    &peer.addrs,
                );
                peer_updated = true;
            }

            // If we're currently trying to dial this peer, we reset their
            // dial state. As a result, we will begin our next dial attempt
            // from the first address (which might have changed) and from a
            // fresh backoff (since the current backoff delay might be maxed
            // out if we can't reach any of their previous addresses).
            if peer_updated {
                if let Some(dial_state) = self.dial_states.get_mut(&peer_id) {
                    *dial_state = DialState::new(self.backoff_strategy.clone());
                }
            }
        }

        // update eligible peers accordingly
        if keys_updated {
            // For each peer, union all of the pubkeys from each discovery source
            // to generate the new eligible peers set.
            let new_eligible = self.discovered_peers.read().get_eligible_peers();

            // Swap in the new eligible peers set
            if let Err(error) = self
                .peers_and_metadata
                .set_trusted_peers(&self.network_context.network_id(), new_eligible)
            {
                error!(
                    NetworkSchema::new(&self.network_context),
                    error = %error,
                    "Failed to update trusted peers set"
                );
            }
        }
    }
```

**File:** network/framework/src/noise/handshake.rs (L394-398)
```rust
                        let derived_remote_peer_id =
                            aptos_types::account_address::from_identity_public_key(
                                remote_public_key,
                            );
                        if derived_remote_peer_id != remote_peer_id {
```

**File:** network/framework/src/noise/handshake.rs (L488-500)
```rust
    fn authenticate_inbound(
        remote_peer_short: ShortHexStr,
        peer: &Peer,
        remote_public_key: &x25519::PublicKey,
    ) -> Result<PeerRole, NoiseHandshakeError> {
        if !peer.keys.contains(remote_public_key) {
            return Err(NoiseHandshakeError::UnauthenticatedClientPubkey(
                remote_peer_short,
                hex::encode(remote_public_key.as_slice()),
            ));
        }
        Ok(peer.role)
    }
```

**File:** types/src/account_address.rs (L135-146)
```rust
// Note: This is inconsistent with current types because AccountAddress is derived
// from consensus key which is of type Ed25519PublicKey. Since AccountAddress does
// not mean anything in a setting without remote authentication, we use the network
// public key to generate a peer_id for the peer.
// See this issue for potential improvements: https://github.com/aptos-labs/aptos-core/issues/3960
pub fn from_identity_public_key(identity_public_key: x25519::PublicKey) -> AccountAddress {
    let mut array = [0u8; AccountAddress::LENGTH];
    let pubkey_slice = identity_public_key.as_slice();
    // keep only the last 16 bytes
    array.copy_from_slice(&pubkey_slice[x25519::PUBLIC_KEY_SIZE - AccountAddress::LENGTH..]);
    AccountAddress::new(array)
}
```

**File:** config/src/config/network_config.rs (L498-505)
```rust
    pub fn from_addrs(role: PeerRole, addresses: Vec<NetworkAddress>) -> Peer {
        let keys: HashSet<x25519::PublicKey> = addresses
            .iter()
            .filter_map(NetworkAddress::find_noise_proto)
            .collect();
        Peer::new(addresses, keys, role)
    }
}
```
