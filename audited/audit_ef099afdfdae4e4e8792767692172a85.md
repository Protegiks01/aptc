# Audit Report

## Title
Script Parameter Count Limit Bypass in Bytecode Verifier

## Summary
The `verify_script()` function in `limits.rs` does not validate script parameters against the `max_function_parameters` configuration limit, while module function parameters are properly validated. This allows scripts to bypass the production limit of 128 parameters, potentially causing resource exhaustion on validator nodes.

## Finding Description
The Aptos production configuration sets `max_function_parameters: Some(128)` to limit function parameter counts and prevent resource exhaustion. [1](#0-0) 

For modules, this limit is enforced in `LimitsVerifier::verify_function_handles()`, which checks each function handle's parameter signature length against the configured limit. [2](#0-1) 

However, for scripts, `verify_script_impl()` only calls `verify_function_handles()` to check external function handles that the script calls, NOT the script's own parameters stored in `script.parameters`. [3](#0-2) 

The script's parameter signature (referenced by `script.parameters: SignatureIndex`) is validated for type safety in `verify_type_nodes()`, but this function does NOT check parameter count limits - it only validates type node complexity. [4](#0-3) 

An attacker can exploit this by creating a script with >128 parameters (e.g., 500 parameters). The bytecode verifier will accept it, but during execution, all parameters will be pushed onto the operand stack, which has a limit of 1024 values. Combined with other stack operations, this could cause stack exhaustion, resource consumption, and execution failures.

## Impact Explanation
This vulnerability has **Medium Severity** impact because:

1. **Resource Limit Bypass**: Violates Critical Invariant #9 ("Resource Limits: All operations must respect gas, storage, and computational limits"). The limit exists to prevent resource exhaustion, and scripts bypass it entirely.

2. **Validator Node Resource Exhaustion**: Scripts with hundreds of parameters consume excessive memory and processing time during verification and execution, potentially slowing down validator nodes. This falls under High Severity criteria ("Validator node slowdowns").

3. **Stack Overflow Risk**: The Move interpreter has a 1024-value operand stack limit. A script with 500+ parameters could exhaust this limit when combined with normal bytecode operations, causing execution failures.

4. **Inconsistent Enforcement**: The same limit that protects against malicious modules does not protect against malicious scripts, creating an attack surface asymmetry.

While this doesn't directly cause consensus violations or fund loss, it enables resource exhaustion attacks on the network and violates established security boundaries.

## Likelihood Explanation
**Likelihood: High**

- **Trivial to Exploit**: Any user can craft and submit a script transaction with >128 parameters. No special privileges required.
- **No Defense Mechanism**: The vulnerability exists in the core verification pipeline with no additional checks to catch it.
- **Production Impact**: The `max_function_parameters` limit is actively enforced in production configuration, indicating this is a real concern.
- **Easy Detection**: An attacker can easily test that scripts with >128 parameters pass verification while module functions do not.

## Recommendation
Add explicit validation of `script.parameters` signature length in `verify_script_impl()`:

**In `third_party/move/move-bytecode-verifier/src/limits.rs`**, modify the `verify_script_impl` function to add parameter count validation:

```rust
fn verify_script_impl(
    config: &VerifierConfig,
    script: &'a CompiledScript,
) -> PartialVMResult<()> {
    let limit_check = Self {
        resolver: BinaryIndexedView::Script(script),
    };
    limit_check.verify_function_handles(config)?;
    limit_check.verify_struct_handles(config)?;
    
    // ADD THIS CHECK: Validate script parameter count
    if let Some(limit) = config.max_function_parameters {
        let param_count = limit_check.resolver.signature_at(script.parameters).0.len();
        if param_count > limit {
            return Err(PartialVMError::new(StatusCode::TOO_MANY_PARAMETERS)
                .with_message(format!(
                    "script has {} parameters, exceeds limit of {}",
                    param_count, limit
                )));
        }
    }
    
    limit_check.verify_type_nodes(config)
}
```

This ensures scripts are subject to the same parameter count limits as module functions.

## Proof of Concept
Create a test script with 200 parameters (exceeding the 128 limit):

```rust
#[test]
fn script_parameter_limit_bypass() {
    use move_binary_format::file_format::*;
    
    let mut script = CompiledScript {
        version: 6,
        module_handles: vec![],
        struct_handles: vec![],
        function_handles: vec![],
        function_instantiations: vec![],
        // Create signature with 200 bool parameters
        signatures: vec![
            Signature(vec![]), // Index 0: empty
            Signature(vec![SignatureToken::Bool; 200]), // Index 1: 200 params
        ],
        identifiers: vec![],
        address_identifiers: vec![],
        constant_pool: vec![],
        metadata: vec![],
        code: CodeUnit {
            locals: SignatureIndex(0),
            code: vec![Bytecode::Ret],
        },
        type_parameters: vec![],
        parameters: SignatureIndex(1), // Points to 200-param signature
        access_specifiers: None,
    };
    
    let config = VerifierConfig {
        max_function_parameters: Some(128),
        ..Default::default()
    };
    
    // This should FAIL but currently PASSES (vulnerability)
    let result = LimitsVerifier::verify_script(&config, &script);
    
    // Currently: result.is_ok() == true (BUG!)
    // Expected: result.is_err() == true with StatusCode::TOO_MANY_PARAMETERS
    assert!(result.is_err(), "Script with 200 parameters should be rejected");
    assert_eq!(result.unwrap_err().major_status(), StatusCode::TOO_MANY_PARAMETERS);
}
```

This test will currently PASS when it should FAIL, demonstrating the vulnerability.

## Notes
The existing test in `limit_tests.rs` only validates that external function handles called by scripts are checked, not the script's own parameters. [5](#0-4) 

Type validation through `signature_v2::verify_script()` is equivalent for both scripts and modules, but limits checking in `limits.rs` has this critical gap.

### Citations

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L159-159)
```rust
        max_function_parameters: Some(128),
```

**File:** third_party/move/move-bytecode-verifier/src/limits.rs (L41-51)
```rust
    fn verify_script_impl(
        config: &VerifierConfig,
        script: &'a CompiledScript,
    ) -> PartialVMResult<()> {
        let limit_check = Self {
            resolver: BinaryIndexedView::Script(script),
        };
        limit_check.verify_function_handles(config)?;
        limit_check.verify_struct_handles(config)?;
        limit_check.verify_type_nodes(config)
    }
```

**File:** third_party/move/move-bytecode-verifier/src/limits.rs (L73-84)
```rust
            if let Some(limit) = config.max_function_parameters {
                if self
                    .resolver
                    .signature_at(function_handle.parameters)
                    .0
                    .len()
                    > limit
                {
                    return Err(PartialVMError::new(StatusCode::TOO_MANY_PARAMETERS)
                        .at_index(IndexKind::FunctionHandle, idx as u16));
                }
            }
```

**File:** third_party/move/move-bytecode-verifier/src/limits.rs (L96-125)
```rust
    fn verify_type_nodes(&self, config: &VerifierConfig) -> PartialVMResult<()> {
        for sign in self.resolver.signatures() {
            for ty in &sign.0 {
                self.verify_type_node(config, ty)?
            }
        }
        for cons in self.resolver.constant_pool() {
            self.verify_type_node(config, &cons.type_)?
        }
        if let Some(sdefs) = self.resolver.struct_defs() {
            for sdef in sdefs {
                match &sdef.field_information {
                    StructFieldInformation::Native => {},
                    StructFieldInformation::Declared(fdefs) => {
                        for fdef in fdefs {
                            self.verify_type_node(config, &fdef.signature.0)?
                        }
                    },
                    StructFieldInformation::DeclaredVariants(variants) => {
                        for variant in variants {
                            for fdef in &variant.fields {
                                self.verify_type_node(config, &fdef.signature.0)?
                            }
                        }
                    },
                }
            }
        }
        Ok(())
    }
```

**File:** third_party/move/move-bytecode-verifier/bytecode-verifier-tests/src/unit_tests/limit_tests.rs (L152-177)
```rust
    let mut s = basic_test_script();
    s.signatures.push(Signature(
        std::iter::repeat_n(SignatureToken::Bool, 10).collect(),
    ));
    s.function_handles.push(FunctionHandle {
        module: ModuleHandleIndex::new(0),
        name: IdentifierIndex::new(0),
        parameters: SignatureIndex(1),
        return_: SignatureIndex(0),
        type_parameters: vec![],
        access_specifiers: None,
        attributes: vec![],
    });

    assert_eq!(
        LimitsVerifier::verify_script(
            &VerifierConfig {
                max_function_parameters: Some(9),
                ..Default::default()
            },
            &s
        )
        .unwrap_err()
        .major_status(),
        StatusCode::TOO_MANY_PARAMETERS
    );
```
