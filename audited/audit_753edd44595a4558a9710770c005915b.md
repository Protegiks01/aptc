# Audit Report

## Title
Division by Zero in RotatingProposer Leading to Complete Network Halt via Unvalidated Governance Configuration

## Summary
The `RotatingProposer::get_valid_proposer()` function performs division by `contiguous_rounds` without validating it is non-zero. A governance proposal setting `contiguous_rounds` to 0 would cause all validators to panic when determining proposers, resulting in complete network halt. The single-proposer fuzzing setup with `contiguous_rounds=1` never tests this critical edge case. [1](#0-0) 

## Finding Description

The fuzzing configuration creates a single-proposer `RotatingProposer` that always returns the same validator, hiding edge cases in the proposer election logic. [2](#0-1) 

The `get_valid_proposer()` method divides `round` by `contiguous_rounds` without validation. When `contiguous_rounds` is 0, this causes **division by zero panic**. [3](#0-2) 

The constructor performs no validation on `contiguous_rounds` or `proposers`. [4](#0-3) 

The epoch manager directly uses the on-chain config value without validation. [5](#0-4) 

The Move module only validates non-empty byte vector, not the actual configuration values.

**Attack Path:**
1. Governance proposal sets `ProposerElectionType::RotatingProposer(0)` or `FixedProposer(0)`
2. Proposal passes and new epoch begins
3. All validators call `get_valid_proposer()` to determine proposer
4. Division by zero panic occurs on ALL validators simultaneously
5. Network halts completely - no blocks can be produced
6. Requires hard fork to recover

This breaks the **Consensus Safety** invariant by causing total loss of liveness.

## Impact Explanation

**Critical Severity** - This meets the Aptos bug bounty criteria for:
- "Non-recoverable network partition (requires hardfork)" 
- "Total loss of liveness/network availability"

When triggered, ALL validators crash when calling `get_valid_proposer()` for any round. This happens during:
- Proposal generation (determining if node should propose)
- Proposal validation (checking if proposer is correct)
- Failed authors computation (tracking which validators failed to propose) [6](#0-5) [7](#0-6) 

The network cannot recover without a hard fork to fix the on-chain configuration.

## Likelihood Explanation

**Low-Medium Likelihood:**
- Requires governance proposal to pass (needs stake majority or governance bug)
- Could occur through:
  1. Buggy governance proposal accidentally setting value to 0
  2. Malicious governance takeover (though this is partially trusted)
- No validation exists at any layer (Move, Rust constructor, epoch manager)
- The single-proposer fuzzing setup never tests `contiguous_rounds=0`, so this bug could remain undetected

## Recommendation

Add validation at multiple layers:

**1. RotatingProposer constructor validation:**
```rust
pub fn new(proposers: Vec<Author>, contiguous_rounds: u32) -> Self {
    assert!(!proposers.is_empty(), "Proposers list cannot be empty");
    assert!(contiguous_rounds > 0, "Contiguous rounds must be positive");
    Self {
        proposers,
        contiguous_rounds,
    }
}
```

**2. Epoch manager validation:** [8](#0-7) 

Add validation before creating proposer election:
```rust
match &onchain_config.proposer_election_type() {
    ProposerElectionType::RotatingProposer(contiguous_rounds) => {
        ensure!(*contiguous_rounds > 0, "contiguous_rounds must be positive");
        Arc::new(RotatingProposer::new(proposers, *contiguous_rounds))
    },
    // Similar for FixedProposer
}
```

**3. Move module validation:**
Add native function to validate config structure before accepting it.

**4. Improve fuzzing:**
Update fuzzing to test edge cases:
```rust
// Test with contiguous_rounds = 0 (should panic)
// Test with multiple validators
// Test with various contiguous_rounds values
```

## Proof of Concept

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use aptos_types::account_address::AccountAddress;

    #[test]
    #[should_panic(expected = "attempt to divide by zero")]
    fn test_rotating_proposer_division_by_zero() {
        let proposers = vec![AccountAddress::random()];
        let pe = RotatingProposer::new(proposers, 0); // contiguous_rounds = 0
        
        // This will panic with division by zero
        let _ = pe.get_valid_proposer(1);
    }
    
    #[test]
    fn test_single_proposer_fuzzing_never_catches_zero() {
        // This mimics the fuzzing setup which always uses contiguous_rounds=1
        let proposers = vec![AccountAddress::random()];
        let pe = RotatingProposer::new(proposers, 1);
        
        // This always works fine, hiding the bug
        assert!(pe.get_valid_proposer(1) == proposers[0]);
        assert!(pe.get_valid_proposer(100) == proposers[0]);
    }
}
```

**Notes:**

The single-proposer fuzzing configuration definitively hides this vulnerability by:
1. Always using `contiguous_rounds=1` (never testing 0)
2. Always using a single proposer (division result always valid)
3. Never testing multi-validator rotation scenarios

While this vulnerability requires governance to trigger, it represents a critical input validation failure that could cause irreversible network damage. The lack of validation at any layer (Move, Rust, epoch manager) combined with fuzzing that never tests the edge case makes this a significant security gap.

### Citations

**File:** consensus/src/round_manager_fuzzing.rs (L198-198)
```rust
    let proposer_election = Arc::new(RotatingProposer::new(vec![signer.author()], 1));
```

**File:** consensus/src/liveness/rotating_proposer_election.rs (L27-32)
```rust
    pub fn new(proposers: Vec<Author>, contiguous_rounds: u32) -> Self {
        Self {
            proposers,
            contiguous_rounds,
        }
    }
```

**File:** consensus/src/liveness/rotating_proposer_election.rs (L36-39)
```rust
    fn get_valid_proposer(&self, round: Round) -> Author {
        self.proposers
            [((round / u64::from(self.contiguous_rounds)) % self.proposers.len() as u64) as usize]
    }
```

**File:** consensus/src/epoch_manager.rs (L296-304)
```rust
        match &onchain_config.proposer_election_type() {
            ProposerElectionType::RotatingProposer(contiguous_rounds) => {
                Arc::new(RotatingProposer::new(proposers, *contiguous_rounds))
            },
            // We don't really have a fixed proposer!
            ProposerElectionType::FixedProposer(contiguous_rounds) => {
                let proposer = choose_leader(proposers);
                Arc::new(RotatingProposer::new(vec![proposer], *contiguous_rounds))
            },
```

**File:** aptos-move/framework/aptos-framework/sources/configs/consensus_config.move (L52-56)
```text
    public fun set_for_next_epoch(account: &signer, config: vector<u8>) {
        system_addresses::assert_aptos_framework(account);
        assert!(vector::length(&config) > 0, error::invalid_argument(EINVALID_CONFIG));
        std::config_buffer::upsert<ConsensusConfig>(ConsensusConfig {config});
    }
```

**File:** consensus/src/round_manager.rs (L1196-1200)
```rust
            self.proposer_election.is_valid_proposal(&proposal),
            "[RoundManager] Proposer {} for block {} is not a valid proposer for this round or created duplicate proposal",
            author,
            proposal,
        );
```

**File:** consensus/src/liveness/proposal_generator.rs (L897-899)
```rust
        for i in start..end_round {
            failed_authors.push((i, proposer_election.get_valid_proposer(i)));
        }
```
