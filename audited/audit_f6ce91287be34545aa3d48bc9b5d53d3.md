# Audit Report

## Title
Insecure File Permissions on Session Configuration Expose API Keys to Local Attackers

## Summary
The session initialization and saving operations in the transaction simulation framework write sensitive configuration files (including API keys) with default file permissions that allow any user on the system to read them. This violates the principle of least privilege and exposes fullnode API credentials to local attackers.

## Finding Description

The `aptos move sim init` command allows users to initialize simulation sessions that fork from remote network state, requiring an API key for fullnode access. [1](#0-0) 

This API key is passed to `Session::init_with_remote_state()` which stores it in a `Config` struct containing the API key as plaintext. [2](#0-1) 

The configuration is then saved to disk using `Config::save_to_file()` which uses the standard `std::fs::write()` function. [3](#0-2) 

The session initialization writes this config file without setting explicit file permissions. [4](#0-3) 

By default, `std::fs::write()` respects the system's umask, which typically results in file permissions of 0644 (readable by owner, group, and others) or 0664. This means any user on a multi-user system can read the config.json file and extract the API key.

The same insecure pattern is used for all session file writes including delta state and operation summaries. [5](#0-4) 

The Aptos codebase already has established secure patterns for writing sensitive files with restricted 0600 permissions, but the session code does not use these utilities. [6](#0-5) 

**Attack Path:**
1. User Alice runs: `aptos move sim init --path ./my-session --network mainnet --api-key "secret-key-abc123"`
2. Session directory is created at `./my-session/config.json` with world-readable permissions (0644)
3. Attacker Bob (another user on the same system) runs: `cat /path/to/alice/my-session/config.json`
4. Bob extracts the API key from the JSON: `{"base":{"Remote":{"api_key":"secret-key-abc123",...}}}`
5. Bob can now use Alice's API key to bypass rate limiting on the fullnode, potentially causing service abuse or DoS under Alice's credentials

## Impact Explanation

This vulnerability qualifies as **Medium Severity** under the Aptos bug bounty program criteria:

- **Information Leak**: Exposes API credentials that provide authenticated access to fullnode services
- **Credential Theft**: Allows unauthorized use of another user's API key for rate-limit bypass
- **Service Abuse**: Stolen credentials can be used to abuse fullnode APIs, potentially causing degraded service for the legitimate owner
- **Local Attack Surface**: Requires local system access but no special privileges beyond standard user account

While this does not directly compromise blockchain consensus or validator operations, it exposes sensitive credentials that have operational and service value. The CLI documentation explicitly states the API key is "strongly recommended to avoid rate limiting," indicating its importance for normal operations.

## Likelihood Explanation

**High Likelihood** - This vulnerability will trigger in every usage scenario where:
- A user initializes a session with `--network` and `--api-key` flags (recommended usage pattern)
- The system is multi-user (servers, shared development environments, CI/CD systems)
- An attacker has local user access (common in cloud/shared infrastructure)

The vulnerability is **guaranteed to occur** with default configuration - there is no opt-in security flag or warning to users about permission settings. The attack requires minimal sophistication (simply reading a world-readable file).

## Recommendation

Use `OpenOptions` with explicit Unix file permissions (mode 0600) for all session file writes. Follow the existing secure pattern already established in the codebase:

**For `config.rs`:**
```rust
use std::fs::OpenOptions;
use std::io::Write;

#[cfg(unix)]
use std::os::unix::fs::OpenOptionsExt;

pub fn save_to_file(&self, path: &std::path::Path) -> Result<()> {
    let json = serde_json::to_string_pretty(self)?;
    
    let mut opts = OpenOptions::new();
    opts.write(true).create(true).truncate(true);
    
    #[cfg(unix)]
    opts.mode(0o600); // Owner read/write only
    
    let mut file = opts.open(path)?;
    file.write_all(json.as_bytes())?;
    Ok(())
}
```

**For `delta.rs` and `txn_output.rs`:**
Apply the same pattern to `save_delta()`, `save_write_set()`, and `save_events()` functions.

**For `session.rs`:**
All `std::fs::write()` calls for summary files should use the secure write helper.

Alternatively, reuse the existing `write_to_user_only_file()` utility from `crates/aptos/src/common/utils.rs` to maintain consistency across the codebase.

## Proof of Concept

**Setup and Exploitation:**
```bash
#!/bin/bash
# Run as User Alice
aptos move sim init \
  --path /tmp/alice-session \
  --network mainnet \
  --api-key "alice-secret-key-12345"

# Check file permissions (will show 0644 - world readable)
ls -la /tmp/alice-session/config.json
# Output: -rw-r--r-- 1 alice users 234 Jan 1 12:00 config.json

# Run as User Bob (attacker)
cat /tmp/alice-session/config.json
# Output shows API key in plaintext:
# {
#   "base": {
#     "Remote": {
#       "node_url": "https://fullnode.mainnet.aptoslabs.com",
#       "network_version": 123456,
#       "api_key": "alice-secret-key-12345"
#     }
#   },
#   "ops": 0
# }

# Bob extracts and uses the API key
API_KEY=$(cat /tmp/alice-session/config.json | jq -r '.base.Remote.api_key')
curl -H "Authorization: Bearer $API_KEY" https://fullnode.mainnet.aptoslabs.com/v1/
```

**Verification:**
Create a test Rust program to verify default permissions:
```rust
use std::fs;
use std::os::unix::fs::PermissionsExt;

fn main() {
    // Simulate current behavior
    fs::write("/tmp/test-session.json", r#"{"api_key": "secret"}"#).unwrap();
    
    let metadata = fs::metadata("/tmp/test-session.json").unwrap();
    let permissions = metadata.permissions();
    
    // Will print: File mode: 644 (world-readable)
    println!("File mode: {:o}", permissions.mode() & 0o777);
}
```

## Notes

This vulnerability affects all session operations that persist data to disk, including:
- Initial session creation (`Session::init()` and `Session::init_with_remote_state()`)
- Session state updates during operations (funding, transaction execution, view operations)
- All delta, event, and write set snapshots

The issue is particularly concerning because the CLI documentation actively encourages API key usage without warning about the security implications of file permissions in multi-user environments.

### Citations

**File:** crates/aptos/src/move_tool/sim.rs (L34-38)
```rust
    /// API key for connecting to the fullnode.
    ///
    /// It is strongly recommended to specify an API key to avoid rate limiting.
    #[clap(long)]
    api_key: Option<String>,
```

**File:** aptos-move/aptos-transaction-simulation-session/src/config.rs (L15-21)
```rust
    /// The session starts from a remote network state (a "forked state").
    Remote {
        node_url: Url,
        network_version: u64,
        api_key: Option<String>,
    },
}
```

**File:** aptos-move/aptos-transaction-simulation-session/src/config.rs (L56-60)
```rust
    pub fn save_to_file(&self, path: &std::path::Path) -> Result<()> {
        let json = serde_json::to_string_pretty(self)?;
        std::fs::write(path, json)?;
        Ok(())
    }
```

**File:** aptos-move/aptos-transaction-simulation-session/src/session.rs (L173-175)
```rust
        let config = Config::with_remote(node_url.clone(), network_version, api_key.clone());
        let config_path = session_path.join("config.json");
        config.save_to_file(&config_path)?;
```

**File:** aptos-move/aptos-transaction-simulation-session/src/delta.rs (L28-30)
```rust
    let json = serde_json::to_string_pretty(&delta_str)?;
    std::fs::write(delta_path, json)?;

```

**File:** crates/aptos/src/common/utils.rs (L223-229)
```rust
/// Write a User only read / write file
pub fn write_to_user_only_file(path: &Path, name: &str, bytes: &[u8]) -> CliTypedResult<()> {
    let mut opts = OpenOptions::new();
    #[cfg(unix)]
    opts.mode(0o600);
    write_to_file_with_opts(path, name, bytes, &mut opts)
}
```
