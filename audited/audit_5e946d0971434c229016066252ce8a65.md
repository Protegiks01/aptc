# Audit Report

## Title
Critical Validator Set Manipulation via Unverified Epoch Ending Restore

## Summary
The epoch ending restore functionality in `db-tool` accepts the first epoch ending LedgerInfo without cryptographic signature verification when no trusted waypoint is provided, allowing an attacker to inject a malicious validator set into the database. This breaks consensus safety as the restored node will accept blocks from unauthorized validators and fork from the legitimate network.

## Finding Description

The vulnerability exists in the epoch ending backup restoration flow. When a node operator restores epoch ending data using `db-tool restore oneoff epoch-ending` without specifying a `--trust-waypoint`, the system fails to cryptographically verify the first epoch ending LedgerInfo's signatures.

**Attack Flow:**

1. **Malicious Backup Creation**: An attacker creates a malicious epoch ending backup containing:
   - A crafted first LedgerInfo with an attacker-controlled validator set in its `next_epoch_state` field
   - Subsequent LedgerInfos properly signed using the malicious validator set

2. **Restoration Phase**: When the victim runs the restore command, the code path is: [1](#0-0) 
   
   The `.run(None)` call passes `None` as `previous_epoch_ending_ledger_info`, which means no previous LedgerInfo exists to verify against.

3. **Missing Verification**: In the `preheat_impl` function, the verification logic has a critical gap: [2](#0-1) 
   
   For the first LedgerInfo in the batch:
   - Line 129: `trusted_waypoints.get()` returns `None` (no waypoint configured)
   - Line 136: `previous_li` is `None` (initialized at line 88)
   - **No else clause executes** - the LedgerInfo is pushed to `ledger_infos` without ANY signature verification
   - Line 149: This unverified LI becomes the trust anchor for subsequent LIs

4. **Chain of Compromised Trust**: Subsequent LedgerInfos are verified using: [3](#0-2) 
   
   The verification relies on `pre_li.ledger_info().next_epoch_state()?.verify(&li)`, where `EpochState::verify()` checks signatures against the validator set: [4](#0-3) 
   
   Since the first LI was never verified, all subsequent verifications validate against the attacker's malicious validator set.

5. **Database Persistence**: The malicious epoch endings are saved to the database: [5](#0-4) 

6. **Node Startup Compromise**: When the node starts, consensus initialization reads epoch state from the database without re-verification: [6](#0-5) 
   
   The database is treated as a trusted source - no cryptographic verification occurs during reads. The compromised validator set becomes the basis for consensus participation.

**Broken Invariants:**
- **Consensus Safety**: The node accepts blocks from unauthorized validators, enabling chain splits
- **Cryptographic Correctness**: Signature verification is bypassed entirely for the first epoch ending
- **Validator Set Integrity**: Unauthorized validators can be injected without stake or proper authorization

## Impact Explanation

**Critical Severity** - This vulnerability meets the highest severity criteria per the Aptos bug bounty program:

1. **Consensus/Safety Violation**: The restored node will:
   - Accept blocks signed by the attacker's malicious validators
   - Reject legitimate blocks from authorized validators  
   - Fork permanently from the canonical chain
   - Potentially sign conflicting blocks, violating BFT safety guarantees

2. **Network Partition**: Multiple nodes restored with different malicious validator sets would create non-recoverable network partitions, potentially requiring a hard fork to resolve.

3. **Loss of Funds**: The forked chain could enable double-spending attacks, as transactions on the malicious fork would not be recognized by the legitimate network.

4. **Systemic Risk**: If this attack targets multiple validators or full nodes, it could fragment the network into incompatible partitions, breaking the fundamental assumption that >2/3 honest validators maintain consensus.

This directly violates the critical invariant: "Consensus Safety: AptosBFT must prevent double-spending and chain splits under < 1/3 Byzantine."

## Likelihood Explanation

**High Likelihood**:

1. **Common Operational Scenario**: Node operators frequently use `db-tool restore` for:
   - Disaster recovery after data loss
   - Setting up new validator or full nodes
   - Migration between infrastructure providers

2. **Easy to Execute**: The attack requires:
   - No privileged access to existing validators
   - No sophisticated cryptographic attacks
   - Simply providing a malicious backup file to a victim

3. **Low Detection Probability**: The compromised node would appear functional initially, only diverging when the malicious epoch becomes active. By then, the database corruption has already occurred.

4. **Social Engineering Vector**: Attackers could distribute "helpful" pre-synced backup files through community channels, claiming they speed up node setup.

5. **Default Unsafe Behavior**: The `--trust-waypoint` parameter is **optional** per the CLI definition: [7](#0-6) 
   
   Operators may not realize this critical security parameter is required for safe restoration.

## Recommendation

**Immediate Fix**: Make trusted waypoints **mandatory** for epoch ending restoration, or implement a fallback verification mechanism.

**Proposed Code Changes:**

1. **Require Trusted Waypoint**: Modify `EpochEndingRestoreOpt` to enforce that at least one trusted waypoint must be provided:

```rust
// In storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs
impl EpochEndingRestoreController {
    pub fn new(
        opt: EpochEndingRestoreOpt,
        global_opt: GlobalRestoreOptions,
        storage: Arc<dyn BackupStorage>,
    ) -> Result<Self> {
        // Require at least one trusted waypoint for epoch ending restore
        ensure!(
            !global_opt.trusted_waypoints.is_empty(),
            "Epoch ending restore requires at least one trusted waypoint for security. \
             Use --trust-waypoint to specify the genesis waypoint or a known epoch ending waypoint."
        );
        
        Ok(Self {
            storage,
            run_mode: global_opt.run_mode,
            manifest_handle: opt.manifest_handle,
            target_version: global_opt.target_version,
            trusted_waypoints: global_opt.trusted_waypoints,
        })
    }
}
```

2. **Add Explicit Verification Check**: In `preheat_impl`, fail explicitly if verification cannot be performed:

```rust
// After line 147 in preheat_impl
if let Some(wp_trusted) = self.trusted_waypoints.get(&wp_li.version()) {
    // Waypoint verification
} else if let Some(pre_li) = previous_li {
    // Signature verification via previous epoch state
} else {
    // First LI with no trusted anchor - MUST FAIL
    bail!(
        "Cannot verify first epoch ending LedgerInfo without a trusted waypoint. \
         Epoch: {}, Version: {}. Please provide --trust-waypoint for security.",
        li.ledger_info().epoch(),
        li.ledger_info().version()
    );
}
```

3. **Update Documentation**: Add prominent warnings in documentation and help text about the security requirement for trusted waypoints during epoch ending restoration.

## Proof of Concept

```rust
// Test demonstrating the vulnerability
// File: storage/backup/backup-cli/src/backup_types/epoch_ending/tests.rs

#[tokio::test]
async fn test_unverified_epoch_ending_restore_vulnerability() {
    use crate::backup_types::epoch_ending::restore::*;
    use aptos_types::{
        ledger_info::{LedgerInfo, LedgerInfoWithSignatures},
        block_info::BlockInfo,
        epoch_state::EpochState,
        validator_verifier::ValidatorVerifier,
        aggregate_signature::AggregateSignature,
    };
    use aptos_crypto::hash::HashValue;
    
    // Create a malicious validator set with attacker's keys
    let (malicious_signers, malicious_verifier) = 
        aptos_types::validator_verifier::random_validator_verifier(3, None, true);
    
    // Create malicious first epoch ending LedgerInfo
    let malicious_epoch_state = EpochState {
        epoch: 1,
        verifier: Arc::new(malicious_verifier),
    };
    
    let malicious_li = LedgerInfo::new(
        BlockInfo::new(
            0, // epoch 0 ending
            0,
            HashValue::zero(),
            HashValue::zero(),
            0, // version
            0,
            Some(malicious_epoch_state), // Contains malicious validator set!
        ),
        HashValue::zero(),
    );
    
    // Create malicious signature (not from legitimate validators)
    let malicious_li_with_sigs = LedgerInfoWithSignatures::new(
        malicious_li,
        AggregateSignature::empty(), // Invalid signature
    );
    
    // Restore without trusted waypoint
    let global_opt = GlobalRestoreOptions {
        target_version: Version::MAX,
        trusted_waypoints: Arc::new(HashMap::new()), // EMPTY - no waypoint!
        run_mode: Arc::new(RestoreRunMode::Verify),
        concurrent_downloads: 1,
        replay_concurrency_level: 1,
    };
    
    // This should FAIL but currently SUCCEEDS - demonstrating the vulnerability
    let controller = EpochEndingRestoreController::new(
        opt,
        global_opt,
        storage.clone(),
    );
    
    let result = controller.run(None).await;
    
    // Currently this succeeds when it should fail!
    // With the fix, this should return an error requiring a trusted waypoint
    assert!(result.is_err(), "Should reject unverified epoch ending restore");
}
```

**Steps to Reproduce:**

1. Create a malicious epoch ending backup manifest with crafted validator set
2. Run: `cargo run --bin db-tool -- restore oneoff epoch-ending --epoch-ending-manifest <malicious_manifest> --target-db-dir /tmp/victim_db`
3. Note: No `--trust-waypoint` parameter provided
4. Observe: Malicious epoch endings are saved to database without verification
5. Start node using the compromised database
6. Result: Node uses malicious validator set for consensus

**Notes**

The vulnerability stems from an incomplete security model in the restoration logic. The code assumes that either a trusted waypoint OR a previous verified LedgerInfo will always be available, but this assumption is violated for the first LedgerInfo in a standalone epoch ending restore operation. The manifest-level verification only checks structural integrity (epoch ranges, chunk consistency), not cryptographic authenticity of the validator sets contained within the LedgerInfos.

This represents a critical break in the chain of trust: blockchain security fundamentally relies on cryptographically verifying every state transition. By accepting an unverified epoch ending LedgerInfo, the system allows an attacker to rewrite the consensus authority, effectively hijacking the node's view of the legitimate blockchain.

### Citations

**File:** storage/db-tool/src/restore.rs (L70-82)
```rust
                    Oneoff::EpochEnding {
                        storage,
                        opt,
                        global,
                    } => {
                        EpochEndingRestoreController::new(
                            opt,
                            global.try_into()?,
                            storage.init_storage().await?,
                        )
                        .run(None)
                        .await?;
                    },
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L129-150)
```rust
                if let Some(wp_trusted) = self.trusted_waypoints.get(&wp_li.version()) {
                    ensure!(
                        *wp_trusted == wp_li,
                        "Waypoints don't match. In backup: {}, trusted: {}",
                        wp_li,
                        wp_trusted,
                    );
                } else if let Some(pre_li) = previous_li {
                    pre_li
                        .ledger_info()
                        .next_epoch_state()
                        .ok_or_else(|| {
                            anyhow!(
                                "Next epoch state not found from LI at epoch {}.",
                                pre_li.ledger_info().epoch()
                            )
                        })?
                        .verify(&li)?;
                }
                ledger_infos.push(li);
                previous_li = ledger_infos.last();
                next_epoch += 1;
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L247-253)
```rust
        match self.controller.run_mode.as_ref() {
            RestoreRunMode::Restore { restore_handler } => {
                restore_handler.save_ledger_infos(&preheat_data.ledger_infos)?;

                EPOCH_ENDING_EPOCH.set(last_li.epoch() as i64);
                EPOCH_ENDING_VERSION.set(last_li.version() as i64);
            },
```

**File:** types/src/epoch_state.rs (L41-49)
```rust
    fn verify(&self, ledger_info: &LedgerInfoWithSignatures) -> anyhow::Result<()> {
        ensure!(
            self.epoch == ledger_info.ledger_info().epoch(),
            "LedgerInfo has unexpected epoch {}, expected {}",
            ledger_info.ledger_info().epoch(),
            self.epoch
        );
        ledger_info.verify_signatures(&self.verifier)?;
        Ok(())
```

**File:** storage/aptosdb/src/ledger_db/ledger_metadata_db.rs (L135-154)
```rust
    pub(crate) fn get_epoch_state(&self, epoch: u64) -> Result<EpochState> {
        ensure!(epoch > 0, "EpochState only queryable for epoch >= 1.",);

        let ledger_info_with_sigs =
            self.db
                .get::<LedgerInfoSchema>(&(epoch - 1))?
                .ok_or_else(|| {
                    AptosDbError::NotFound(format!("Last LedgerInfo of epoch {}", epoch - 1))
                })?;
        let latest_epoch_state = ledger_info_with_sigs
            .ledger_info()
            .next_epoch_state()
            .ok_or_else(|| {
                AptosDbError::Other(
                    "Last LedgerInfo in epoch must carry next_epoch_state.".to_string(),
                )
            })?;

        Ok(latest_epoch_state.clone())
    }
```

**File:** storage/backup/backup-cli/src/utils/mod.rs (L332-346)
```rust
pub struct TrustedWaypointOpt {
    #[clap(
        long,
        help = "(multiple) When provided, an epoch ending LedgerInfo at the waypoint version will be \
        checked against the hash in the waypoint, but signatures on it are NOT checked. \
        Use this for two purposes: \
        1. set the genesis or the latest waypoint to confirm the backup is compatible. \
        2. set waypoints at versions where writeset transactions were used to overwrite the \
        validator set, so that the signature check is skipped. \
        N.B. LedgerInfos are verified only when restoring / verifying the epoch ending backups, \
        i.e. they are NOT checked at all when doing one-shot restoring of the transaction \
        and state backups."
    )]
    pub trust_waypoint: Vec<Waypoint>,
}
```
