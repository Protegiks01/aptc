# Audit Report

## Title
Replay-Verify Coordinator Bypasses Epoch Boundary Cryptographic Verification, Accepting Forged Ledger Infos from Compromised Backup Storage

## Summary
The `ReplayVerifyCoordinator` in `replay_verify.rs` hardcodes `epoch_history` to `None` when instantiating both `StateSnapshotRestoreController` and `TransactionRestoreBatchController`, completely disabling validator signature verification on ledger infos. This allows an attacker with write access to backup storage to inject forged ledger infos that would be accepted during replay verification, breaking the cryptographic chain of trust that authenticates epoch transitions. [1](#0-0) 

## Finding Description

The Aptos backup verification architecture is designed with a cryptographic chain of trust where each epoch's validator set authenticates the next epoch's validator set through signed ledger infos. This is implemented via the `EpochHistory::verify_ledger_info()` method, which verifies that ledger infos carry valid BLS signatures from the appropriate epoch's validator set. [2](#0-1) 

When loading transaction chunks, the `LoadedChunk::load()` method conditionally verifies ledger info signatures only when `epoch_history` is present: [3](#0-2) 

In contrast, the production `RestoreCoordinator` properly constructs `EpochHistory` and passes it to both state snapshot and transaction restore controllers: [4](#0-3) [5](#0-4) 

However, `ReplayVerifyCoordinator` bypasses this entire verification chain by hardcoding `epoch_history` to `None`, with no option to enable it. This means the cryptographic verification that ensures only validator-signed ledger infos are accepted is completely disabled.

**Attack Path:**
1. Attacker compromises backup storage credentials (e.g., GCS bucket access tokens)
2. Attacker crafts malicious transaction backup files containing:
   - Forged `LedgerInfoWithSignatures` with arbitrary epochs, state roots, and consensus data
   - Valid transaction accumulator merkle proofs that connect to the forged ledger info
   - Transactions that may not have been legitimately executed in those epochs
3. Attacker replaces or injects these files into backup storage
4. When `replay-verify` runs (used in production CI/CD per the GitHub workflow), it:
   - Loads the malicious chunks
   - Skips `epoch_history.verify_ledger_info()` check (line 152-154 in restore.rs)
   - Only verifies merkle proofs match the forged ledger info (line 167)
   - Accepts the forged data as valid
5. If these "verified" backups are later used for node restoration, nodes could be initialized with invalid state [6](#0-5) 

The trusted waypoint mechanism provides only partial protection, as documented: [7](#0-6) 

Waypoints verify only specific epoch-ending ledger infos, not the ledger infos attached to every transaction chunk.

## Impact Explanation

This vulnerability represents a **High Severity** issue under the "Significant protocol violations" category because:

1. **Breaks Cryptographic Chain of Trust**: The fundamental Aptos security invariant that only validator-signed ledger infos are accepted is violated. This is a critical cryptographic correctness failure.

2. **Production Infrastructure Compromise**: The `replay-verify` tool is used in production CI/CD pipelines to verify backup integrity before potential node restoration operations.

3. **State Poisoning Risk**: If compromised backups pass replay-verify and are used for node restoration, validators could be initialized with invalid state that was never part of legitimate consensus, potentially leading to state inconsistencies requiring manual intervention.

4. **Validator Set Confusion**: Forged ledger infos could claim different validator sets than were actually active, potentially confusing epoch transition logic if the data is trusted.

While this does not directly compromise the live consensus network, it undermines the backup verification infrastructure that protects against state corruption during disaster recovery scenarios.

## Likelihood Explanation

**Likelihood: Medium**

The attack requires:
- Compromise of backup storage credentials (GCS buckets, S3, or local filesystem access)
- Understanding of Aptos backup file format and merkle tree construction
- Ability to craft valid transaction accumulator proofs

While backup storage compromise is a realistic threat vector (credential leaks, insider access, misconfigured IAM policies), the attack requires technical sophistication. However, given that `replay-verify` runs automatically in CI/CD without human verification of cryptographic signatures, the exploitation window exists whenever backup storage is compromised.

The risk is elevated because the design clearly intends for epoch verification to occur (as evidenced by the regular restore and verify coordinators), but `replay-verify` explicitly disables it without security justification.

## Recommendation

Add support for epoch history verification in `ReplayVerifyCoordinator`. The fix should:

1. Load epoch ending backups via `EpochHistoryRestoreController`
2. Pass the resulting `EpochHistory` to both `StateSnapshotRestoreController` and `TransactionRestoreBatchController`
3. Optionally provide a CLI flag to skip epoch verification only for debugging purposes (with appropriate warnings)

**Recommended code change in `replay_verify.rs`:**

Modify `run_impl()` to load epoch endings before transaction restore:

```rust
async fn run_impl(self) -> Result<(), ReplayError> {
    // ... existing code ...
    
    let epoch_endings = metadata_view.select_epoch_ending_backups(self.end_version)?;
    let epoch_handles = epoch_endings
        .iter()
        .filter(|e| e.first_version <= self.end_version)
        .map(|backup| backup.manifest.clone())
        .collect();
    
    let epoch_history = Some(Arc::new(
        EpochHistoryRestoreController::new(
            epoch_handles,
            global_opt.clone(),
            self.storage.clone(),
        )
        .run()
        .await?,
    ));
    
    // Pass epoch_history (not None) to both controllers
    StateSnapshotRestoreController::new(
        // ...
        epoch_history.clone(),  // Changed from None
    )
    
    TransactionRestoreBatchController::new(
        // ...
        epoch_history,  // Changed from None
        // ...
    )
}
```

This aligns `replay-verify` with the security model of `restore` and `verify` coordinators.

## Proof of Concept

**Conceptual PoC (Rust pseudocode demonstrating the vulnerability):**

```rust
// Step 1: Attacker creates forged LedgerInfoWithSignatures
let forged_ledger_info = LedgerInfoWithSignatures::new(
    LedgerInfo::new(
        BlockInfo::new(
            999,  // Fake epoch
            0,
            HashValue::random(),  // Arbitrary state root
            HashValue::zero(),
            1000000,  // Fake version
            0,
            None,  // No next_epoch_state
        ),
        HashValue::zero(),
    ),
    AggregateSignature::empty(),  // Invalid/missing signatures!
);

// Step 2: Create transaction chunk with matching merkle proof
// (proof construction details omitted for brevity)
let malicious_chunk = create_chunk_with_fake_proof(
    forged_ledger_info,
    malicious_transactions,
);

// Step 3: Inject into backup storage
backup_storage.upload("malicious_chunk.backup", malicious_chunk);

// Step 4: Run replay-verify
// Because epoch_history is None, the forged ledger info passes verification!
// Only the merkle proof is checked, not the signatures.
```

**To fully exploit:**
1. Gain access to backup storage (e.g., stolen GCS credentials)
2. Use Aptos backup file format to craft chunks with forged ledger infos
3. Ensure transaction accumulator proofs are valid relative to the forged ledger info
4. Upload to backup storage used by replay-verify CI/CD
5. Wait for replay-verify to run and accept the forged data

The vulnerability is confirmed by comparing the code paths: `RestoreCoordinator` and `VerifyCoordinator` both construct `epoch_history`, while `ReplayVerifyCoordinator` hardcodes it to `None`.

### Citations

**File:** storage/backup/backup-cli/src/coordinators/replay_verify.rs (L191-205)
```rust
        TransactionRestoreBatchController::new(
            global_opt,
            self.storage,
            transactions
                .into_iter()
                .map(|t| t.manifest)
                .collect::<Vec<_>>(),
            save_start_version,
            Some((next_txn_version, false)), /* replay_from_version */
            None,                            /* epoch_history */
            self.verify_execution_mode.clone(),
            None,
        )
        .run()
        .await?;
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L276-312)
```rust
    pub fn verify_ledger_info(&self, li_with_sigs: &LedgerInfoWithSignatures) -> Result<()> {
        let epoch = li_with_sigs.ledger_info().epoch();
        ensure!(!self.epoch_endings.is_empty(), "Empty epoch history.",);
        if epoch > self.epoch_endings.len() as u64 {
            // TODO(aldenhu): fix this from upper level
            warn!(
                epoch = epoch,
                epoch_history_until = self.epoch_endings.len(),
                "Epoch is too new and can't be verified. Previous chunks are verified and node \
                won't be able to start if this data is malicious."
            );
            return Ok(());
        }
        if epoch == 0 {
            ensure!(
                li_with_sigs.ledger_info() == &self.epoch_endings[0],
                "Genesis epoch LedgerInfo info doesn't match.",
            );
        } else if let Some(wp_trusted) = self
            .trusted_waypoints
            .get(&li_with_sigs.ledger_info().version())
        {
            let wp_li = Waypoint::new_any(li_with_sigs.ledger_info());
            ensure!(
                *wp_trusted == wp_li,
                "Waypoints don't match. In backup: {}, trusted: {}",
                wp_li,
                wp_trusted,
            );
        } else {
            self.epoch_endings[epoch as usize - 1]
                .next_epoch_state()
                .ok_or_else(|| anyhow!("Shouldn't contain non- epoch bumping LIs."))?
                .verify(li_with_sigs)?;
        };
        Ok(())
    }
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L152-154)
```rust
        if let Some(epoch_history) = epoch_history {
            epoch_history.verify_ledger_info(&ledger_info)?;
        }
```

**File:** storage/backup/backup-cli/src/coordinators/restore.rs (L219-231)
```rust
        let epoch_history = if !self.skip_epoch_endings {
            Some(Arc::new(
                EpochHistoryRestoreController::new(
                    epoch_handles,
                    self.global_opt.clone(),
                    self.storage.clone(),
                )
                .run()
                .await?,
            ))
        } else {
            None
        };
```

**File:** storage/backup/backup-cli/src/coordinators/restore.rs (L360-371)
```rust
            TransactionRestoreBatchController::new(
                self.global_opt,
                self.storage,
                txn_manifests,
                first_version,
                replay_version,
                epoch_history,
                VerifyExecutionMode::NoVerify,
                None,
            )
            .run()
            .await?;
```

**File:** .github/workflows/workflow-run-replay-verify.yaml (L248-259)
```yaml
                ./aptos-debugger aptos-db replay-verify \
                  --metadata-cache-dir $MC \
                  --command-adapter-config ${{ inputs.BACKUP_CONFIG_TEMPLATE_PATH }} \
                  --start-version $begin \
                  --end-version $end \
                  \
                  --lazy-quit \
                  --enable-storage-sharding \
                  --target-db-dir $DB \
                  --concurrent-downloads 8 \
                  --replay-concurrency-level 4 \
                  || res=$?
```

**File:** storage/backup/backup-cli/src/utils/mod.rs (L333-343)
```rust
    #[clap(
        long,
        help = "(multiple) When provided, an epoch ending LedgerInfo at the waypoint version will be \
        checked against the hash in the waypoint, but signatures on it are NOT checked. \
        Use this for two purposes: \
        1. set the genesis or the latest waypoint to confirm the backup is compatible. \
        2. set waypoints at versions where writeset transactions were used to overwrite the \
        validator set, so that the signature check is skipped. \
        N.B. LedgerInfos are verified only when restoring / verifying the epoch ending backups, \
        i.e. they are NOT checked at all when doing one-shot restoring of the transaction \
        and state backups."
```
