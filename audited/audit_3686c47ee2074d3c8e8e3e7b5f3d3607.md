# Audit Report

## Title
Non-Atomic State Update in Pruner Manager Creates Temporary In-Memory/Persistent State Inconsistency During Fast Sync

## Summary
The `save_min_readable_version()` function in all pruner managers updates the in-memory `min_readable_version` before persisting it to disk. If the disk write fails, this creates a temporary inconsistency between in-memory and persisted state that persists until node restart.

## Finding Description

In `StateKvPrunerManager::save_min_readable_version()`, the function updates the in-memory `AtomicVersion` **before** attempting to persist the value to disk: [1](#0-0) 

The same pattern exists in all three pruner managers: [2](#0-1) [3](#0-2) 

This function is called during state snapshot finalization, **after** the main transaction data has already been committed to disk: [4](#0-3) 

**Critical Issue**: If `write_pruner_progress()` fails (e.g., disk full, I/O error):
1. The main transaction data has been committed (line 223) and cannot be rolled back
2. The in-memory `min_readable_version` has been updated
3. The persisted `min_readable_version` remains at the old value
4. The error propagates via `?`, causing `finalize_state_snapshot()` to fail
5. However, the in-memory state remains corrupted until the node restarts

**On Node Restart**: The node loads the old `min_readable_version` from disk, but the transaction data at the newer version is present, creating a state where:
- The node reports `min_readable_version = V_old`
- But only has data from `V_new` onwards (where `V_new > V_old`)
- Queries for versions between `V_old` and `V_new` are not rejected as "pruned" but fail with "not found"

The pruner interface comment confirms this function's purpose: [5](#0-4) 

## Impact Explanation

**Severity: Medium**

This creates a **temporary state inconsistency** that violates the atomicity principle but has limited security impact:

1. **Not Permanent**: The inconsistency is resolved on node restart when state is reloaded from disk
2. **Limited Scope**: Only affects nodes performing fast sync/restore operations, not nodes in normal operation
3. **Error Propagated**: The `finalize_state_snapshot()` operation fails, preventing the node from continuing with corrupted state in normal operation
4. **No Direct Consensus Impact**: Nodes performing fast sync are not participating in consensus
5. **Incorrect API Behavior**: During the window between failure and restart, API queries return incorrect error messages ("not found" instead of "pruned")

This qualifies as **Medium Severity** per Aptos bug bounty criteria:
- "State inconsistencies requiring intervention" âœ“
- Does not cause fund loss or consensus violations
- Requires manual intervention (node restart) to fully resolve

## Likelihood Explanation

**Likelihood: Low to Medium**

The vulnerability requires:
1. A node performing state sync/fast sync operations (common during catch-up)
2. Disk write failure at the specific moment of `write_pruner_progress()` (rare but possible)
3. Causes: disk space exhaustion, I/O errors, filesystem issues

While disk failures are not common, they can occur naturally or be induced through resource exhaustion attacks. However, remotely triggering this at the precise moment is difficult without access to the node.

## Recommendation

**Fix: Make the state update atomic by persisting first, then updating in-memory state only on success**

Modify all three pruner managers to follow this pattern:

```rust
fn save_min_readable_version(&self, min_readable_version: Version) -> Result<()> {
    // FIRST: Persist to disk
    self.state_kv_db.write_pruner_progress(min_readable_version)?;
    
    // ONLY update in-memory state after successful persistence
    self.min_readable_version
        .store(min_readable_version, Ordering::SeqCst);
    
    PRUNER_VERSIONS
        .with_label_values(&["state_kv_pruner", "min_readable"])
        .set(min_readable_version as i64);
    
    Ok(())
}
```

This ensures that if the disk write fails, the in-memory state remains unchanged, maintaining consistency.

**Alternative Fix**: If immediate in-memory update is required for performance, implement a rollback mechanism:

```rust
fn save_min_readable_version(&self, min_readable_version: Version) -> Result<()> {
    let old_version = self.min_readable_version.load(Ordering::SeqCst);
    
    // Update in-memory
    self.min_readable_version
        .store(min_readable_version, Ordering::SeqCst);
    
    PRUNER_VERSIONS
        .with_label_values(&["state_kv_pruner", "min_readable"])
        .set(min_readable_version as i64);
    
    // Try to persist
    if let Err(e) = self.state_kv_db.write_pruner_progress(min_readable_version) {
        // Rollback on failure
        self.min_readable_version.store(old_version, Ordering::SeqCst);
        PRUNER_VERSIONS
            .with_label_values(&["state_kv_pruner", "min_readable"])
            .set(old_version as i64);
        return Err(e);
    }
    
    Ok(())
}
```

## Proof of Concept

```rust
// Test demonstrating the inconsistency
#[test]
fn test_save_min_readable_version_inconsistency() {
    use std::sync::Arc;
    use aptos_storage_interface::Result;
    
    // Simulate a StateKvDb that fails on write_pruner_progress
    struct FailingStateKvDb {
        should_fail: bool,
    }
    
    impl FailingStateKvDb {
        fn write_pruner_progress(&self, _version: u64) -> Result<()> {
            if self.should_fail {
                Err(anyhow::anyhow!("Simulated disk write failure").into())
            } else {
                Ok(())
            }
        }
    }
    
    // Create manager with AtomicVersion
    let min_readable = AtomicVersion::new(0);
    let db = Arc::new(FailingStateKvDb { should_fail: true });
    
    // Before failure
    assert_eq!(min_readable.load(Ordering::SeqCst), 0);
    
    // Simulate save_min_readable_version behavior
    let new_version = 1000;
    
    // Step 1: Update in-memory (happens first in current code)
    min_readable.store(new_version, Ordering::SeqCst);
    
    // Step 2: Try to persist (fails)
    let result = db.write_pruner_progress(new_version);
    
    // Result: Error is returned, BUT in-memory state is already updated
    assert!(result.is_err(), "Expected write to fail");
    assert_eq!(min_readable.load(Ordering::SeqCst), 1000, 
               "In-memory state updated despite disk write failure");
    
    // On restart, would load 0 from disk, but in-memory shows 1000
    // This demonstrates the inconsistency window
}
```

## Notes

This vulnerability represents a violation of atomic state update principles rather than a critical security flaw. The inconsistency is **temporary** (not permanent as questioned), resolved on node restart, and occurs only during error conditions in fast sync operations. While it should be fixed for robustness, it does not directly enable consensus attacks or fund theft.

### Citations

**File:** storage/aptosdb/src/pruner/state_kv_pruner/state_kv_pruner_manager.rs (L57-66)
```rust
    fn save_min_readable_version(&self, min_readable_version: Version) -> Result<()> {
        self.min_readable_version
            .store(min_readable_version, Ordering::SeqCst);

        PRUNER_VERSIONS
            .with_label_values(&["state_kv_pruner", "min_readable"])
            .set(min_readable_version as i64);

        self.state_kv_db.write_pruner_progress(min_readable_version)
    }
```

**File:** storage/aptosdb/src/pruner/ledger_pruner/ledger_pruner_manager.rs (L80-89)
```rust
    fn save_min_readable_version(&self, min_readable_version: Version) -> Result<()> {
        self.min_readable_version
            .store(min_readable_version, Ordering::SeqCst);

        PRUNER_VERSIONS
            .with_label_values(&["ledger_pruner", "min_readable"])
            .set(min_readable_version as i64);

        self.ledger_db.write_pruner_progress(min_readable_version)
    }
```

**File:** storage/aptosdb/src/pruner/state_merkle_pruner/state_merkle_pruner_manager.rs (L74-84)
```rust
    fn save_min_readable_version(&self, min_readable_version: Version) -> Result<()> {
        self.min_readable_version
            .store(min_readable_version, Ordering::SeqCst);

        PRUNER_VERSIONS
            .with_label_values(&[S::name(), "min_readable"])
            .set(min_readable_version as i64);

        self.state_merkle_db
            .write_pruner_progress(&S::progress_metadata_key(None), min_readable_version)
    }
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L223-234)
```rust
            self.ledger_db.write_schemas(ledger_db_batch)?;

            self.ledger_pruner.save_min_readable_version(version)?;
            self.state_store
                .state_merkle_pruner
                .save_min_readable_version(version)?;
            self.state_store
                .epoch_snapshot_pruner
                .save_min_readable_version(version)?;
            self.state_store
                .state_kv_pruner
                .save_min_readable_version(version)?;
```

**File:** storage/aptosdb/src/pruner/pruner_manager.rs (L33-35)
```rust
    // Only used at the end of fast sync to store the min_readable_version to db and update the
    // in memory progress.
    fn save_min_readable_version(&self, min_readable_version: Version) -> Result<()>;
```
