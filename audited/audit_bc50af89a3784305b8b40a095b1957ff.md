# Audit Report

## Title
Unbounded Memory Exhaustion via Pending Optimistic Proposal Queue Manipulation

## Summary
The `process_opt_proposal_msg()` function in `consensus/src/round_manager.rs` lacks upper bound validation on proposal rounds before inserting into the `pending_opt_proposals` BTreeMap. A Byzantine validator can exploit this to queue many optimistic proposals for future rounds, causing unbounded memory growth and potential node crashes.

## Finding Description

The vulnerability exists in the optimistic proposal buffering mechanism. [1](#0-0) 

When an optimistic proposal is received, the function performs `sync_up()` to advance the node's round based on the proposal's sync_info. [2](#0-1) 

If the proposal's round doesn't match `current_round()` after syncing, it's buffered in `pending_opt_proposals` after only validating the proposer. [3](#0-2) 

Critically, **there is no check limiting how far in the future the proposal's round can be** relative to `current_round()`. This contrasts with the randomness share system, which enforces `FUTURE_ROUNDS_TO_ACCEPT = 200`. [4](#0-3) 

The randomness system validates shares with: [5](#0-4) 

The `pending_opt_proposals` map is defined as an unbounded `BTreeMap<Round, OptBlockData>`. [6](#0-5) 

Each `OptBlockData` contains a full block payload including validator transactions and transaction batches. [7](#0-6) 

The maximum block size is 6MB. [8](#0-7) 

Cleanup only occurs when processing proposals from the loopback channel, which removes past proposals but retains future ones. [9](#0-8) 

**Attack Scenario:**
1. Network progresses to round 1000 with valid QCs for all rounds
2. Victim node is at round 800 (offline/partitioned temporarily)
3. Byzantine validator collects QCs for rounds 798-998 from the network
4. For each round where they are the valid proposer, Byzantine validator crafts optimistic proposals with valid QCs
5. Byzantine validator sends all proposals simultaneously to victim node
6. Each proposal passes verification (valid signature on QC, valid proposer, correct structure)
7. Each proposal triggers `sync_up()` advancing the node incrementally, but remains ahead of `current_round()`
8. All proposals get queued in `pending_opt_proposals` simultaneously
9. With ~2-20 proposals per validator (depending on validator set size), and blocks up to 6MB each, memory consumption reaches 12MB-120MB+ per attacking validator
10. Multiple colluding Byzantine validators or repeated attacks can exhaust node memory

The verification ensures proposals have valid structure and QCs, but doesn't prevent future round flooding. [10](#0-9) 

## Impact Explanation

**Severity: High**

This vulnerability enables Byzantine validators to cause memory exhaustion on victim nodes, leading to:

1. **Validator Node Slowdowns/Crashes** - Matches the High severity category "Validator node slowdowns" and can escalate to node crashes from OOM (Out of Memory) errors
2. **Liveness Impact** - If multiple validators are targeted successfully, network liveness degrades as fewer honest nodes participate in consensus
3. **Resource Limits Violation** - Breaks the critical invariant: "Resource Limits: All operations must respect gas, storage, and computational limits"

With default configuration allowing 6MB blocks and no bound on queued proposals, a coordinated attack by Byzantine validators controlling 10% of proposer slots across 200 rounds could queue 1.2GB+ of data on victim nodes.

## Likelihood Explanation

**Likelihood: Medium-High**

**Prerequisites:**
- Attacker must be a registered validator (Byzantine validator within the <1/3 threshold)
- Network must have progressed beyond victim node's current round (common during network partitions, node restarts, or slow sync)
- Attacker must be valid proposer for future rounds (guaranteed by deterministic proposer election)

**Feasibility:**
- High: Byzantine validators are part of the Aptos threat model (< 1/3 assumption)
- High: Network partitions and nodes falling behind are normal operational scenarios
- High: Requires only standard consensus protocol messages, no cryptographic breaks
- Medium: Impact scales with number of colluding validators, but single validator can still cause significant memory pressure

**Detection Difficulty:**
- Hard: Proposals appear legitimate with valid QCs and valid proposer assignments
- Hard: No rate limiting or bound checking to trigger alerts
- Medium: Memory growth would be observable but may be attributed to normal catch-up operations

## Recommendation

Add bounded round acceptance similar to the randomness share system. Insert validation after `sync_up()` and before queuing:

```rust
pub async fn process_opt_proposal_msg(
    &mut self,
    proposal_msg: OptProposalMsg,
) -> anyhow::Result<()> {
    // ... existing checks ...
    
    self.sync_up(proposal_msg.sync_info(), proposal_msg.proposer())
        .await?;
    
    // Add bound check here
    const MAX_FUTURE_ROUNDS_TO_BUFFER: u64 = 200;
    ensure!(
        proposal_msg.round() <= self.round_state.current_round() + MAX_FUTURE_ROUNDS_TO_BUFFER,
        "[OptProposal] Proposal round {} is too far in the future (current round: {})",
        proposal_msg.round(),
        self.round_state.current_round()
    );
    
    if self.round_state.current_round() == proposal_msg.round() {
        // ... process immediately ...
    } else {
        // ... existing validation and queuing ...
    }
    
    Ok(())
}
```

Additionally, consider adding a maximum size limit to `pending_opt_proposals`:

```rust
const MAX_PENDING_OPT_PROPOSALS: usize = 100;

if self.pending_opt_proposals.len() >= MAX_PENDING_OPT_PROPOSALS {
    warn!(
        "Pending opt proposals queue full ({}), rejecting round {}",
        self.pending_opt_proposals.len(),
        proposal_msg.round()
    );
    return Err(anyhow::anyhow!("Pending opt proposals queue full"));
}
```

## Proof of Concept

```rust
#[tokio::test]
async fn test_opt_proposal_memory_exhaustion() {
    use consensus::round_manager::RoundManager;
    use consensus_types::opt_proposal_msg::OptProposalMsg;
    
    // Setup: Create RoundManager at round 100
    let mut round_manager = create_round_manager_at_round(100);
    
    // Attack: Create 200 opt proposals for future rounds 101-300
    // Each proposal has valid QC for round R-2
    let mut proposals = vec![];
    for round in 101..=300 {
        let qc = create_valid_qc_for_round(round - 2);
        let opt_proposal = create_opt_proposal_with_qc(
            round,
            byzantine_validator_address(),
            qc,
            create_full_block_payload(6 * 1024 * 1024), // 6MB payload
        );
        proposals.push(opt_proposal);
    }
    
    // Measure memory before attack
    let memory_before = get_process_memory_mb();
    
    // Send all proposals to victim node
    for proposal in proposals {
        round_manager.process_opt_proposal_msg(proposal).await.unwrap();
    }
    
    // Verify memory exhaustion
    let memory_after = get_process_memory_mb();
    let memory_growth = memory_after - memory_before;
    
    // Expected: ~1.2GB growth (200 proposals * 6MB each)
    assert!(
        memory_growth > 1000,
        "Memory growth {} MB is suspiciously low for 200 6MB proposals",
        memory_growth
    );
    
    // Verify all proposals are queued
    assert_eq!(
        round_manager.pending_opt_proposals.len(),
        200,
        "Expected all 200 proposals to be queued"
    );
    
    println!("SUCCESS: Memory exhaustion attack successful!");
    println!("Memory growth: {} MB", memory_growth);
    println!("Pending proposals: {}", round_manager.pending_opt_proposals.len());
}
```

### Citations

**File:** consensus/src/round_manager.rs (L330-330)
```rust
    pending_opt_proposals: BTreeMap<Round, OptBlockData>,
```

**File:** consensus/src/round_manager.rs (L813-814)
```rust
        self.sync_up(proposal_msg.sync_info(), proposal_msg.proposer())
            .await?;
```

**File:** consensus/src/round_manager.rs (L816-834)
```rust
        if self.round_state.current_round() == proposal_msg.round() {
            self.opt_proposal_loopback_tx
                .send(proposal_msg.take_block_data())
                .await
                .expect("Sending to a self loopback unbounded channel cannot fail");
        } else {
            // Pre-check that proposal is from valid proposer before queuing it.
            // This check is done after syncing up to sync info to ensure proposer
            // election provider is up to date.
            ensure!(
                self.proposer_election
                    .is_valid_proposer(proposal_msg.proposer(), proposal_msg.round()),
                "[OptProposal] Not a valid proposer for round {}: {}",
                proposal_msg.round(),
                proposal_msg.proposer()
            );
            self.pending_opt_proposals
                .insert(proposal_msg.round(), proposal_msg.take_block_data());
        }
```

**File:** consensus/src/round_manager.rs (L2083-2083)
```rust
                    self.pending_opt_proposals = self.pending_opt_proposals.split_off(&opt_proposal.round().add(1));
```

**File:** consensus/src/rand/rand_gen/types.rs (L26-26)
```rust
pub const FUTURE_ROUNDS_TO_ACCEPT: u64 = 200;
```

**File:** consensus/src/rand/rand_gen/rand_store.rs (L285-288)
```rust
        ensure!(
            share.metadata().round <= self.highest_known_round + FUTURE_ROUNDS_TO_ACCEPT,
            "Share from future round"
        );
```

**File:** consensus/consensus-types/src/opt_block_data.rs (L20-28)
```rust
#[derive(Deserialize, Serialize, Clone, Debug, PartialEq, Eq, CryptoHasher)]
/// Same as BlockData, without QC and with parent id
pub struct OptBlockData {
    pub epoch: u64,
    pub round: Round,
    pub timestamp_usecs: u64,
    pub parent: BlockInfo,
    pub block_body: OptBlockBody,
}
```

**File:** config/src/config/consensus_config.rs (L231-231)
```rust
            max_receiving_block_bytes: 6 * 1024 * 1024, // 6MB
```

**File:** consensus/consensus-types/src/opt_proposal_msg.rs (L54-93)
```rust
    pub fn verify_well_formed(&self) -> Result<()> {
        self.block_data
            .verify_well_formed()
            .context("Fail to verify OptProposalMsg's data")?;
        ensure!(
            self.block_data.round() > 1,
            "Proposal for {} has round <= 1",
            self.block_data,
        );
        ensure!(
            self.block_data.epoch() == self.sync_info.epoch(),
            "ProposalMsg has different epoch number from SyncInfo"
        );
        // Ensure the sync info has the grandparent QC
        ensure!(
            self.block_data.grandparent_qc().certified_block().id()
                == self.sync_info.highest_quorum_cert().certified_block().id(),
            "Proposal HQC in SyncInfo certifies {}, but block grandparent id is {}",
            self.sync_info.highest_quorum_cert().certified_block().id(),
            self.block_data.grandparent_qc().certified_block().id(),
        );
        let grandparent_round = self
            .block_data
            .round()
            .checked_sub(2)
            .ok_or_else(|| anyhow::anyhow!("proposal round overflowed!"))?;

        let highest_certified_round = self.block_data.grandparent_qc().certified_block().round();
        ensure!(
            grandparent_round == highest_certified_round,
            "Proposal {} does not have a certified round {}",
            self.block_data,
            grandparent_round
        );
        // Optimistic proposal shouldn't have a timeout certificate
        ensure!(
            self.sync_info.highest_2chain_timeout_cert().is_none(),
            "Optimistic proposal shouldn't have a timeout certificate"
        );
        Ok(())
```
