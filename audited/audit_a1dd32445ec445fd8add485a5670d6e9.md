# Audit Report

## Title
Premature State Transition to "Decided" Causes Irrecoverable Liveness Failure in Secret Sharing

## Summary
The `SecretShareAggregator::try_aggregate()` function transitions the secret share state to `Decided` immediately upon reaching the threshold weight, but performs the actual cryptographic aggregation asynchronously. If aggregation fails after the state transition, the node becomes permanently stuck because the share requester task sees the `Decided` state and exits without requesting additional shares.

## Finding Description

The vulnerability exists in the interaction between three components:

1. **Premature state transition**: [1](#0-0) 

The `try_aggregate` method checks if the threshold weight is reached, then immediately returns `Either::Right(self_share)` while spawning an async task for actual aggregation. This causes the state machine to transition to `Decided` before cryptographic aggregation completes.

2. **State transition logic**: [2](#0-1) 

When `Either::Right` is returned, the state transitions from `PendingDecision` to `Decided` immediately (line 149), regardless of whether the async aggregation succeeds.

3. **Share requester no-op behavior**: [3](#0-2) 

The share requester task checks `get_all_shares_authors` which returns `None` for `Decided` state: [4](#0-3) 

When `None` is returned, the requester task becomes a no-op and exits without requesting shares from any peers.

**Attack Scenario:**

A Byzantine validator (or set of validators below the 1/3 threshold) can send shares that individually pass verification but collectively fail during aggregation. The attack sequence:

1. Honest node processes block and adds self share to store
2. Share requester task is spawned with 300ms delay
3. Byzantine validators send shares that pass `SecretShare::verify()` individually
4. Shares accumulate until threshold weight is reached
5. `try_aggregate` is called, immediately returns `Either::Right`, state â†’ `Decided`
6. Share requester task wakes up at 300ms, calls `get_all_shares_authors`
7. Function returns `None` because state is `Decided`, requester task exits
8. Asynchronous aggregation executes `SecretShare::aggregate()` and fails
9. Error is logged but no decision is sent to `decision_tx`
10. Block remains in `pending_secret_key_rounds` indefinitely
11. Node cannot request more shares (requester already exited)
12. **Liveness failure**: Node stuck, cannot advance consensus for this block

## Impact Explanation

**Severity: Medium** - This meets the Medium severity criteria from the Aptos bug bounty program: "State inconsistencies requiring intervention."

The vulnerability causes:
- **Liveness degradation**: Affected nodes cannot advance consensus for the impacted block
- **State inconsistency**: Node believes shares are decided but no secret key exists
- **Requires manual intervention**: Node restart or manual recovery needed
- **Does not affect safety**: No double-spending or chain split occurs
- **Limited scope**: Only affects nodes that receive the malicious share combination

This is not Critical severity because:
- It doesn't cause permanent network partition (only affects individual nodes)
- It doesn't violate consensus safety (no conflicting blocks committed)
- It doesn't result in fund loss or theft

## Likelihood Explanation

**Likelihood: Medium**

The vulnerability is realistic because:

1. **Feasible attack**: Byzantine validators can craft shares that pass individual verification but fail collective aggregation by exploiting edge cases in the batch threshold encryption scheme (e.g., inconsistent Lagrange coefficients, malformed group elements that validate individually but break aggregation)

2. **No special privileges needed**: Any Byzantine validator can send malicious shares through normal network channels

3. **Natural occurrence possible**: Even without malicious intent, rare cryptographic errors or precision issues during aggregation could trigger this

4. **Window of opportunity**: The 300ms delay provides a consistent window for the race condition to occur

However, the likelihood is constrained by:
- Requires understanding of the batch threshold encryption internals
- Must craft shares that pass verification but fail aggregation
- Only affects nodes that receive the specific combination of shares

## Recommendation

**Fix: Defer state transition until after aggregation completes**

Modify the aggregation logic to keep the state in `PendingDecision` until the async aggregation task completes. Use a channel to communicate success/failure back to the main thread:

```rust
pub fn try_aggregate(
    self,
    secret_share_config: &SecretShareConfig,
    metadata: SecretShareMetadata,
    decision_tx: Sender<SecretSharedKey>,
) -> Either<Self, SecretShare> {
    if self.total_weight < secret_share_config.threshold() {
        return Either::Left(self);
    }
    
    observe_block(metadata.timestamp, BlockStage::SECRET_SHARING_ADD_ENOUGH_SHARE);
    
    let dec_config = secret_share_config.clone();
    let self_share = self.get_self_share()
        .expect("Aggregated item should have self share");
    
    // Perform aggregation synchronously or with proper state tracking
    match SecretShare::aggregate(self.shares.values(), &dec_config) {
        Ok(key) => {
            let dec_key = SecretSharedKey::new(metadata, key);
            let _ = decision_tx.unbounded_send(dec_key);
            Either::Right(self_share)  // Only transition to Decided on success
        },
        Err(e) => {
            warn!(epoch = metadata.epoch, round = metadata.round, "Aggregation error: {e}");
            Either::Left(self)  // Stay in PendingDecision to allow retry
        }
    }
}
```

**Alternative: Allow requester task to run even after Decided state if no decision was sent**

Track whether a decision was actually sent and allow share requesting if aggregation failed despite reaching threshold.

## Proof of Concept

```rust
// Rust test demonstrating the vulnerability
#[tokio::test]
async fn test_premature_decided_state_liveness_failure() {
    // Setup: Create SecretShareStore and manager
    let (decision_tx, mut decision_rx) = unbounded();
    let mut store = SecretShareStore::new(1, author, config.clone(), decision_tx);
    
    // Add self share
    store.add_self_share(self_share).unwrap();
    
    // Simulate Byzantine shares that pass verification but fail aggregation
    // Add shares until threshold is reached
    for byzantine_share in craft_malicious_shares_that_fail_aggregation() {
        store.add_share(byzantine_share).unwrap();
    }
    
    // At this point, state is Decided but no decision was sent
    let metadata = self_share.metadata();
    
    // Simulate share requester task waking up
    let maybe_existing = store.get_all_shares_authors(metadata);
    assert_eq!(maybe_existing, None);  // Returns None because state is Decided
    
    // Verify no decision was received
    tokio::time::sleep(Duration::from_millis(500)).await;
    assert!(decision_rx.try_next().is_err());  // No decision received
    
    // Node is now stuck: state is Decided but no secret key exists
    // and share requester task cannot run to request more shares
}

fn craft_malicious_shares_that_fail_aggregation() -> Vec<SecretShare> {
    // Implementation would craft shares that individually verify
    // but cause aggregate() to fail due to cryptographic inconsistencies
    // This is feasible in batch threshold encryption schemes
}
```

**Notes:**
- The vulnerability requires Byzantine validators to craft specific shares that break aggregation
- The 300ms hardcoded delay creates a consistent race window
- The issue is exacerbated by the lack of retry logic when aggregation fails
- This breaks the consensus liveness invariant without affecting safety

### Citations

**File:** consensus/src/rand/secret_sharing/secret_share_store.rs (L38-72)
```rust
    pub fn try_aggregate(
        self,
        secret_share_config: &SecretShareConfig,
        metadata: SecretShareMetadata,
        decision_tx: Sender<SecretSharedKey>,
    ) -> Either<Self, SecretShare> {
        if self.total_weight < secret_share_config.threshold() {
            return Either::Left(self);
        }
        observe_block(
            metadata.timestamp,
            BlockStage::SECRET_SHARING_ADD_ENOUGH_SHARE,
        );
        let dec_config = secret_share_config.clone();
        let self_share = self
            .get_self_share()
            .expect("Aggregated item should have self share");
        tokio::task::spawn_blocking(move || {
            let maybe_key = SecretShare::aggregate(self.shares.values(), &dec_config);
            match maybe_key {
                Ok(key) => {
                    let dec_key = SecretSharedKey::new(metadata, key);
                    let _ = decision_tx.unbounded_send(dec_key);
                },
                Err(e) => {
                    warn!(
                        epoch = metadata.epoch,
                        round = metadata.round,
                        "Aggregation error: {e}"
                    );
                },
            }
        });
        Either::Right(self_share)
    }
```

**File:** consensus/src/rand/secret_sharing/secret_share_store.rs (L130-154)
```rust
    fn try_aggregate(
        &mut self,
        secret_share_config: &SecretShareConfig,
        decision_tx: Sender<SecretSharedKey>,
    ) {
        let item = std::mem::replace(self, Self::new(Author::ONE));
        let new_item = match item {
            SecretShareItem::PendingDecision {
                share_aggregator,
                metadata,
            } => match share_aggregator.try_aggregate(
                secret_share_config,
                metadata.clone(),
                decision_tx,
            ) {
                Either::Left(share_aggregator) => Self::PendingDecision {
                    metadata,
                    share_aggregator,
                },
                Either::Right(self_share) => Self::Decided { self_share },
            },
            item @ (SecretShareItem::Decided { .. } | SecretShareItem::PendingMetadata(_)) => item,
        };
        let _ = std::mem::replace(self, new_item);
    }
```

**File:** consensus/src/rand/secret_sharing/secret_share_store.rs (L184-194)
```rust
    fn get_all_shares_authors(&self) -> Option<HashSet<Author>> {
        match self {
            SecretShareItem::PendingDecision {
                share_aggregator, ..
            } => Some(share_aggregator.shares.keys().cloned().collect()),
            SecretShareItem::Decided { .. } => None,
            SecretShareItem::PendingMetadata(_) => {
                unreachable!("Should only be called after block is added")
            },
        }
    }
```

**File:** consensus/src/rand/secret_sharing/secret_share_manager.rs (L237-277)
```rust
    fn spawn_share_requester_task(&self, metadata: SecretShareMetadata) -> DropGuard {
        let rb = self.reliable_broadcast.clone();
        let aggregate_state = Arc::new(SecretShareAggregateState::new(
            self.secret_share_store.clone(),
            metadata.clone(),
            self.config.clone(),
        ));
        let epoch_state = self.epoch_state.clone();
        let secret_share_store = self.secret_share_store.clone();
        let task = async move {
            // TODO(ibalajiarun): Make this configurable
            tokio::time::sleep(Duration::from_millis(300)).await;
            let maybe_existing_shares = secret_share_store.lock().get_all_shares_authors(&metadata);
            if let Some(existing_shares) = maybe_existing_shares {
                let epoch = epoch_state.epoch;
                let request = RequestSecretShare::new(metadata.clone());
                let targets = epoch_state
                    .verifier
                    .get_ordered_account_addresses_iter()
                    .filter(|author| !existing_shares.contains(author))
                    .collect::<Vec<_>>();
                info!(
                    epoch = epoch,
                    round = metadata.round,
                    "[SecretShareManager] Start broadcasting share request for {}",
                    targets.len(),
                );
                rb.multicast(request, aggregate_state, targets)
                    .await
                    .expect("Broadcast cannot fail");
                info!(
                    epoch = epoch,
                    round = metadata.round,
                    "[SecretShareManager] Finish broadcasting share request",
                );
            }
        };
        let (abort_handle, abort_registration) = AbortHandle::new_pair();
        tokio::spawn(Abortable::new(task, abort_registration));
        DropGuard::new(abort_handle)
    }
```
