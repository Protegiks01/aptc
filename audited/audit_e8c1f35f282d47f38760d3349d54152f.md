# Audit Report

## Title
Module Initialization Order Vulnerability: Capability Escalation Through Incorrect init_module Execution Sequence

## Summary
The Aptos VM executes module `init_module` functions in the order modules appear in the published bundle, not in topological dependency order. This allows an attacker to publish modules with carefully chosen names such that dependent modules initialize before their dependencies, enabling capability escalation when conditional initialization logic is present.

## Finding Description

The vulnerability exists in the module publishing flow where `init_module` functions execute in bundle order rather than dependency order, breaking the initialization invariant.

**Root Cause Chain:**

1. **Module ordering is not enforced at publishing time**: [1](#0-0) 

The CLI extracts modules via `package.extract_code()` which returns modules in file system order (typically alphabetical by filename), not topological order.

2. **extract_code() returns modules in arbitrary order**: [2](#0-1) 

The method iterates over `root_modules()` without any dependency-based sorting.

3. **init_module execution uses bundle order**: [3](#0-2) 

The VM iterates through modules sequentially (line 105: `for module in modules`) and executes each module's `init_module` in that order, with no topological sorting applied.

4. **compute_topological_order() exists but is NEVER called in production**: [4](#0-3) 

This function can compute correct ordering but is only used in test infrastructure, not in the production module publishing path.

**Attack Scenario:**

An attacker creates two modules where Module A depends on Module B, but names them such that A initializes first:

```
// File: a_privileged.move (initializes FIRST due to alphabetical order)
module deployer::a_privileged {
    struct Capability has key { is_admin: bool }
    
    fun init_module(s: &signer) {
        // Conditional logic with dangerous fallback
        let is_admin = if (exists<z_gatekeeper::Policy>(signer::address_of(s))) {
            z_gatekeeper::check_admin(s)  // Returns false
        } else {
            true  // ESCALATION: Grant admin if gatekeeper not initialized!
        };
        move_to(s, Capability { is_admin });
    }
}

// File: z_gatekeeper.move (initializes SECOND despite being dependency)
module deployer::z_gatekeeper {
    struct Policy has key { }
    
    fun init_module(s: &signer) {
        move_to(s, Policy { });  // Initialize access control
    }
    
    public fun check_admin(s: &signer): bool { false }
}
```

When published, alphabetical ordering causes `a_privileged` to initialize before `z_gatekeeper`, granting admin capability through the fallback path.

## Impact Explanation

**Severity: High** (up to $50,000)

This vulnerability enables:
1. **Capability Escalation**: Modules can gain elevated privileges during initialization by exploiting missing dependency state
2. **Access Control Bypass**: Security checks that should restrict initialization are bypassed when dependencies haven't initialized yet
3. **Persistent Incorrect State**: The escalated privileges persist after deployment, affecting all future operations

This qualifies as "Significant protocol violations" under the High severity category. While not causing direct fund loss, it breaks the fundamental security model of Move's resource-based access control during the critical initialization phase.

The issue affects **deterministic execution** invariant - different module orderings could result in different security states, and breaks **access control** invariant by allowing privilege escalation.

## Likelihood Explanation

**Likelihood: Medium-Low**

The vulnerability requires:
1. ✓ Attacker can control module filenames (choosing alphabetical ordering)
2. ✓ Modules can be published with arbitrary ordering (no validation enforced)
3. ⚠️ Developer writes conditional initialization logic with privileged fallback (uncommon but possible)
4. ✓ Wrong ordering doesn't cause transaction abort (conditional logic handles missing state)

While the conditional init_module pattern is uncommon, it's not unrealistic - developers might implement feature flags, tiered capabilities, or progressive initialization patterns. The lack of any ordering validation makes this exploitable when such patterns exist.

## Recommendation

**Fix 1: Enforce topological ordering before init_module execution**

Modify `finish_with_module_publishing_and_initialization()` to sort modules before executing init_module: [5](#0-4) 

Add topological sorting at line 104:
```rust
// Sort modules in topological order before initialization
let sorted_modules = {
    let module_refs: Vec<&CompiledModule> = modules.iter().collect();
    let dep_graph = move_bytecode_utils::dependency_graph::DependencyGraph::new(module_refs.iter().copied());
    let ordered = dep_graph.compute_topological_order()
        .map_err(|e| e.finish(Location::Undefined))?;
    ordered.collect::<Vec<_>>()
};

for module in sorted_modules {
    // existing init_module logic...
}
```

**Fix 2: Add validation in StagingModuleStorage creation**

Add dependency order validation when creating StagingModuleStorage to fail early if modules are incorrectly ordered: [6](#0-5) 

**Fix 3: CLI-side ordering**

Make `extract_code()` return modules in dependency order using the existing `sorted_code_and_modules()` pattern: [7](#0-6) 

## Proof of Concept

```move
// save as: a_escalate.move
module 0xCAFE::a_escalate {
    use std::signer;
    
    struct AdminCap has key {
        level: u8
    }
    
    fun init_module(deployer: &signer) {
        let level = if (exists<0xCAFE::z_control::AccessControl>(signer::address_of(deployer))) {
            0  // Should get 0 (no privileges)
        } else {
            255  // Escalation: max privileges if control not initialized
        };
        
        move_to(deployer, AdminCap { level });
    }
    
    #[view]
    public fun get_level(addr: address): u8 acquires AdminCap {
        borrow_global<AdminCap>(addr).level
    }
}

// save as: z_control.move
module 0xCAFE::z_control {
    struct AccessControl has key { }
    
    fun init_module(deployer: &signer) {
        move_to(deployer, AccessControl { });
    }
}

// Test: Publish with files in alphabetical order
// Expected: a_escalate.level == 255 (VULNERABLE)
// Correct: a_escalate.level == 0 (if topologically sorted)
```

**Reproduction Steps:**
1. Create both module files with exact names above
2. Compile package (modules saved alphabetically to disk)
3. Publish using `aptos move publish`
4. Query `a_escalate::get_level(0xCAFE)`
5. Observe `level = 255` instead of expected `0`

**Notes:**

This vulnerability demonstrates a gap between the compiler's topological ordering (used for compilation) and the runtime's init_module execution ordering (uses bundle order). The `compute_topological_order()` function exists but is never integrated into the production publishing path, leaving modules vulnerable to initialization order attacks.

### Citations

**File:** crates/aptos/src/move_tool/mod.rs (L987-1023)
```rust
fn create_package_publication_data(
    package: BuiltPackage,
    publish_type: PublishType,
    object_address: Option<AccountAddress>,
) -> CliTypedResult<PackagePublicationData> {
    let compiled_units = package.extract_code();
    let metadata = package.extract_metadata()?;
    let metadata_serialized = bcs::to_bytes(&metadata).expect("PackageMetadata has BCS");

    let payload = match publish_type {
        PublishType::AccountDeploy => {
            aptos_cached_packages::aptos_stdlib::code_publish_package_txn(
                metadata_serialized.clone(),
                compiled_units.clone(),
            )
        },
        PublishType::ObjectDeploy => {
            aptos_cached_packages::aptos_stdlib::object_code_deployment_publish(
                metadata_serialized.clone(),
                compiled_units.clone(),
            )
        },
        PublishType::ObjectUpgrade => {
            aptos_cached_packages::aptos_stdlib::object_code_deployment_upgrade(
                metadata_serialized.clone(),
                compiled_units.clone(),
                object_address.expect("Object address must be provided for upgrading object code."),
            )
        },
    };

    Ok(PackagePublicationData {
        metadata_serialized,
        compiled_units,
        payload,
    })
}
```

**File:** aptos-move/framework/src/built_package.rs (L426-434)
```rust
    pub fn extract_code(&self) -> Vec<Vec<u8>> {
        self.package
            .root_modules()
            .map(|unit_with_source| {
                let bytecode_version = self.options.inferred_bytecode_version();
                unit_with_source.unit.serialize(Some(bytecode_version))
            })
            .collect()
    }
```

**File:** aptos-move/aptos-vm/src/move_vm_ext/session/user_transaction_sessions/user.rs (L81-203)
```rust
    pub(crate) fn finish_with_module_publishing_and_initialization(
        mut self,
        resolver: &impl AptosMoveResolver,
        module_storage: &impl AptosModuleStorage,
        gas_meter: &mut impl AptosGasMeter,
        traversal_context: &mut TraversalContext,
        features: &Features,
        gas_feature_version: u64,
        change_set_configs: &ChangeSetConfigs,
        destination: AccountAddress,
        bundle: ModuleBundle,
        modules: &[CompiledModule],
        compatability_checks: Compatibility,
    ) -> Result<UserSessionChangeSet, VMStatus> {
        // Stage module bundle on top of module storage. In case modules cannot be added (for
        // example, fail compatibility checks, create cycles, etc.), we return an error here.
        let staging_module_storage = StagingModuleStorage::create_with_compat_config(
            &destination,
            compatability_checks,
            module_storage,
            bundle.into_bytes(),
        )?;

        let init_func_name = ident_str!("init_module");
        for module in modules {
            // INVARIANT:
            //   We have charged for the old version (if it exists) before when pre-processing the
            //   module bundle. We have also charged for the new versions as well.
            if features.is_lazy_loading_enabled() {
                traversal_context
                    .check_is_special_or_visited(module.self_addr(), module.self_name())
                    .map_err(|err| err.finish(Location::Undefined))?;
            }

            if module_storage
                .unmetered_check_module_exists(module.self_addr(), module.self_name())?
            {
                // Module existed before, so do not run initialization.
                continue;
            }

            self.session.execute(|session| {
                dispatch_loader!(&staging_module_storage, loader, {
                    #[allow(clippy::collapsible_else_if)]
                    if gas_feature_version <= RELEASE_V1_30 {
                        if let Ok(init_func) = loader.load_instantiated_function(
                            &LegacyLoaderConfig::unmetered(),
                            gas_meter,
                            traversal_context,
                            &module.self_id(),
                            init_func_name,
                            &[],
                        ) {
                            // We need to check that init_module function we found is well-formed.
                            verifier::module_init::legacy_verify_module_init_function(module)
                                .map_err(|e| e.finish(Location::Undefined))?;

                            session.execute_loaded_function(
                                init_func,
                                vec![MoveValue::Signer(destination).simple_serialize().unwrap()],
                                gas_meter,
                                traversal_context,
                                &loader,
                                // We should never enable trace record for init_module - it runs on
                                // newly published state so it is safer to do checks in-place.
                                &mut NoOpTraceRecorder,
                            )?;
                        }
                    } else {
                        if let Ok((module, function)) = loader.load_function_definition(
                            gas_meter,
                            traversal_context,
                            &module.self_id(),
                            init_func_name,
                        ) {
                            verifier::module_init::verify_init_module_function(&function)?;

                            let ty_args_id =
                                loader.runtime_environment().ty_pool().intern_ty_args(&[]);
                            let loaded_function = LoadedFunction {
                                owner: LoadedFunctionOwner::Module(module),
                                ty_args: vec![],
                                ty_args_id,
                                function,
                            };
                            session.execute_loaded_function(
                                loaded_function,
                                vec![MoveValue::Signer(destination)
                                    .simple_serialize()
                                    .expect("Signer is always serializable")],
                                gas_meter,
                                traversal_context,
                                &loader,
                                // We should never enable trace record for init_module - it runs on
                                // newly published state so it is safer to do checks in-place.
                                &mut NoOpTraceRecorder,
                            )?;
                        }
                    }
                });
                Ok::<_, VMStatus>(())
            })?;
        }

        // Get the changes from running module initialization. Note that here we use the staged
        // module storage to ensure resource group metadata from new modules is visible.
        let Self { session } = self;
        let change_set = session.finish_with_squashed_change_set(
            change_set_configs,
            &staging_module_storage,
            false,
        )?;

        let write_ops = convert_modules_into_write_ops(
            resolver,
            features,
            module_storage,
            staging_module_storage.release_verified_module_bundle(),
        )
        .map_err(|e| e.finish(Location::Undefined))?;
        let module_write_set = ModuleWriteSet::new(write_ops);
        UserSessionChangeSet::new(change_set, module_write_set, change_set_configs)
    }
```

**File:** third_party/move/tools/move-bytecode-utils/src/dependency_graph.rs (L53-60)
```rust
    /// Return an iterator over the modules in `self` in topological order--modules with least deps first.
    /// Fails with an error if `self` contains circular dependencies
    pub fn compute_topological_order(&self) -> Result<impl Iterator<Item = &CompiledModule>> {
        match petgraph::algo::toposort(&self.graph, None) {
            Err(_) => bail!("Circular dependency detected"),
            Ok(ordered_idxs) => Ok(ordered_idxs.into_iter().map(move |idx| self.modules[idx.0])),
        }
    }
```

**File:** third_party/move/move-vm/runtime/src/storage/publishing.rs (L112-218)
```rust
    pub fn create_with_compat_config(
        sender: &AccountAddress,
        compatibility: Compatibility,
        existing_module_storage: &'a M,
        module_bundle: Vec<Bytes>,
    ) -> VMResult<Self> {
        // Create a new runtime environment, so that it is not shared with the existing one. This
        // is extremely important for correctness of module publishing: we need to make sure that
        // no speculative information is cached! By cloning the environment, we ensure that when
        // using this new module storage with changes, global caches are not accessed. Only when
        // the published module is committed, and its structs are accessed, their information will
        // be cached in the global runtime environment.
        //
        // Note: cloning the environment is relatively cheap because it only stores global caches
        // that cannot be invalidated by module upgrades using a shared pointer, so it is not a
        // deep copy. See implementation of Clone for this struct for more details.
        let staged_runtime_environment = existing_module_storage.runtime_environment().clone();
        let is_lazy_loading_enabled = existing_module_storage
            .runtime_environment()
            .vm_config()
            .enable_lazy_loading;
        let is_enum_option_enabled = staged_runtime_environment.vm_config().enable_enum_option;
        let is_framework_for_option_enabled = staged_runtime_environment
            .vm_config()
            .enable_framework_for_option;
        let deserializer_config = &staged_runtime_environment.vm_config().deserializer_config;

        // For every module in bundle, run compatibility checks and construct a new bytes storage
        // view such that added modules shadow any existing ones.
        let mut staged_modules = BTreeMap::new();
        for module_bytes in module_bundle {
            let compiled_module =
                CompiledModule::deserialize_with_config(&module_bytes, deserializer_config)
                    .map(Arc::new)
                    .map_err(|err| {
                        err.append_message_with_separator(
                            '\n',
                            "[VM] module deserialization failed".to_string(),
                        )
                        .finish(Location::Undefined)
                    })?;
            let addr = compiled_module.self_addr();
            let name = compiled_module.self_name();

            // Make sure all modules' addresses match the sender. The self address is
            // where the module will actually be published. If we did not check this,
            // the sender could publish a module under anyone's account.
            if addr != sender {
                let msg = format!(
                    "Compiled modules address {} does not match the sender {}",
                    addr, sender
                );
                return Err(verification_error(
                    StatusCode::MODULE_ADDRESS_DOES_NOT_MATCH_SENDER,
                    IndexKind::AddressIdentifier,
                    compiled_module.self_handle_idx().0,
                )
                .with_message(msg)
                .finish(Location::Undefined));
            }

            // All modules can be republished, as long as the new module is compatible
            // with the old module.
            if compatibility.need_check_compat() {
                // INVARIANT:
                //   Old module must be metered at the caller side.
                if let Some(old_module_ref) =
                    existing_module_storage.unmetered_get_deserialized_module(addr, name)?
                {
                    if !is_framework_for_option_enabled
                        && is_enum_option_enabled
                        && old_module_ref.self_id().is_option()
                        && old_module_ref.self_id() == compiled_module.self_id()
                    {
                        // skip check for option module during publishing
                    } else {
                        let old_module = old_module_ref.as_ref();
                        compatibility
                            .check(old_module, &compiled_module)
                            .map_err(|e| e.finish(Location::Undefined))?;
                    }
                }
            }

            // Modules that pass compatibility checks are added to the staged storage.
            use btree_map::Entry::*;
            let account_module_storage = match staged_modules.entry(*compiled_module.self_addr()) {
                Occupied(entry) => entry.into_mut(),
                Vacant(entry) => entry.insert(BTreeMap::new()),
            };
            let prev = account_module_storage.insert(
                compiled_module.self_name().to_owned(),
                (module_bytes, compiled_module.clone()),
            );

            // Publishing the same module in the same bundle is not allowed.
            if prev.is_some() {
                let msg = format!(
                    "Module {}::{} occurs more than once in published bundle",
                    compiled_module.self_addr(),
                    compiled_module.self_name()
                );
                return Err(PartialVMError::new(StatusCode::DUPLICATE_MODULE_NAME)
                    .with_message(msg)
                    .finish(Location::Undefined));
            }
        }
```

**File:** aptos-move/framework/src/release_bundle.rs (L142-162)
```rust
    /// Returns code and compiled modules, topological sorted regarding dependencies.
    pub fn sorted_code_and_modules(&self) -> Vec<(&[u8], CompiledModule)> {
        let mut map = self
            .code
            .iter()
            .map(|c| {
                let m = CompiledModule::deserialize(c).unwrap();
                (m.self_id(), (c.as_slice(), m))
            })
            .collect::<BTreeMap<_, _>>();
        let mut order = vec![];
        for id in map.keys() {
            sort_by_deps(&map, &mut order, id.clone());
        }
        let mut result = vec![];
        for id in order {
            let (code, module) = map.remove(&id).unwrap();
            result.push((code, module))
        }
        result
    }
```
