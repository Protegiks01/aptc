# Audit Report

## Title
Config Deserialization Bypass Allows Insecure In-Memory Safety Rules Backend on Mainnet Validators

## Summary
A mainnet validator can be tricked into starting with in-memory storage for consensus safety rules instead of persistent storage by providing a config file with omitted critical fields. This bypasses the config sanitizer's mainnet checks by causing chain ID extraction to fail silently, allowing the validator to lose safety data on restart and potentially double-sign blocks.

## Finding Description

The vulnerability exists in the interaction between serde's default field handling, config loading, and the config sanitization logic. The attack exploits the following chain of events:

**Step 1: Insecure Defaults**

The `ConsensusConfig` struct uses `#[serde(default)]` which allows fields to be omitted during deserialization: [1](#0-0) 

The `SafetyRulesConfig` also uses `#[serde(default)]` and its default backend is `InMemoryStorage`: [2](#0-1) 

The `ExecutionConfig` defaults to an empty `PathBuf` for `genesis_file_location`: [3](#0-2) 

**Step 2: Sanitizer Should Catch This**

The `SafetyRulesConfig::sanitize()` function specifically checks that mainnet validators don't use `InMemoryStorage`: [4](#0-3) 

However, this check only runs when `chain_id.is_some()` and the chain is mainnet.

**Step 3: Chain ID Extraction Failure**

During config loading, the system attempts to extract the chain ID from the genesis transaction: [5](#0-4) 

Notice that when chain ID extraction fails, it prints a warning but continues with `chain_id = None`.

The `get_chain_id()` function requires a valid genesis transaction: [6](#0-5) 

**Step 4: Genesis Not Loaded When Path Is Empty**

When `genesis_file_location` is omitted (defaults to empty PathBuf), the genesis file loading is skipped: [7](#0-6) 

The `genesis` field remains `None`, causing chain ID extraction to fail.

**Step 5: Sanitizer Bypass**

When sanitization runs with `chain_id = None`, the mainnet-specific safety checks are skipped: [8](#0-7) 

The validator starts successfully with `InMemoryStorage` for safety rules.

**Attack Execution:**

An attacker creates a malicious config file targeting a mainnet validator operator:

```yaml
base:
  role: validator
  waypoint:
    from_config: "0:6072b68a942aace147e0655c5704beaa255c84a7829baa4e72a500f1516584c4"

# Omit execution.genesis_file_location - defaults to empty path
# Omit consensus.safety_rules.backend - defaults to InMemoryStorage

validator_network:
  network_id: "Validator"
  mutual_authentication: true
  # ... other required network config
```

When the operator starts their node with this config via the production path: [9](#0-8) 

The node successfully starts with in-memory safety rules storage despite being a mainnet validator.

## Impact Explanation

**Severity: Critical**

This vulnerability breaks the **Consensus Safety** invariant. When a mainnet validator uses `InMemoryStorage` for safety rules:

1. **Safety Data Loss**: The validator's critical consensus safety data (last voted round, last vote epoch, preferred round) is stored only in memory and lost on node restart.

2. **Double-Signing Risk**: After restart, the validator has no memory of what it previously voted for and could vote for conflicting blocks at the same height, violating BFT safety.

3. **Equivocation**: Without persistent safety data, the validator may sign multiple proposals for the same round, which is slashable behavior that can corrupt consensus.

4. **Consensus Safety Violation**: If multiple validators are affected, the network could experience safety violations including potential chain splits, directly violating the "Consensus Safety: AptosBFT must prevent double-spending and chain splits under < 1/3 Byzantine" invariant.

This qualifies as **Critical Severity** under the Aptos Bug Bounty program:
- **Consensus/Safety violations**: Direct violation of BFT safety guarantees
- **Loss of Funds**: Affected validators would be slashed for equivocation
- **Network Impact**: Could affect network liveness and safety if multiple validators impacted

The safety rules storage is explicitly designed to be persistent: [10](#0-9) 

## Likelihood Explanation

**Likelihood: Low-Medium**

**Factors Increasing Likelihood:**
- Config files are typically managed by validator operators who may not fully understand all fields
- The missing fields are "invisible" - the config appears valid and the node starts successfully
- No runtime errors occur until after a restart when safety violations happen
- Social engineering or supply chain attacks could deliver malicious configs
- Genesis file path omission seems benign (might be interpreted as "use default location")

**Factors Decreasing Likelihood:**
- Requires attacker to influence validator operator's config file
- Most operators use official config templates which include all fields
- Operators following documentation would have proper configs
- Error would be caught if operator tests with node restart

**Realistic Attack Vectors:**
1. Social engineering: Attacker provides "optimized" config to operator
2. Supply chain: Compromised config generation tool
3. Documentation error: Misleading setup guide omits critical fields
4. Copy-paste error: Operator accidentally uses incomplete config snippet

The vulnerability is exploitable because the sanitizer is designed to catch this exact misconfiguration, but fails to do so due to the chain ID extraction bypass.

## Recommendation

**Fix 1: Fail Hard on Chain ID Extraction Failure for Validators**

Modify the chain ID extraction logic to fail hard for validators instead of continuing with None: [11](#0-10) 

Change to:
```rust
fn extract_node_type_and_chain_id(node_config: &NodeConfig) -> Result<(NodeType, Option<ChainId>), Error> {
    let node_type = NodeType::extract_from_config(node_config);
    
    // For validators, chain ID is required
    let chain_id = match get_chain_id(node_config) {
        Ok(chain_id) => Some(chain_id),
        Err(error) => {
            if node_type.is_validator() {
                return Err(Error::InvariantViolation(format!(
                    "Chain ID extraction failed for validator node! Error: {:?}", error
                )));
            }
            println!("Failed to extract the chain ID: {:?}! Continuing with None.", error);
            None
        }
    };
    Ok((node_type, chain_id))
}
```

**Fix 2: Enforce Genesis File for Validators**

Add validation that validators must have a valid genesis file location: [12](#0-11) 

Add check:
```rust
fn sanitize(node_config: &NodeConfig, node_type: NodeType, chain_id: Option<ChainId>) -> Result<(), Error> {
    let sanitizer_name = Self::get_sanitizer_name();
    let execution_config = &node_config.execution;
    
    // Validators must have a valid genesis file location
    if node_type.is_validator() && execution_config.genesis_file_location.as_os_str().is_empty() {
        return Err(Error::ConfigSanitizerFailed(
            sanitizer_name,
            "Validators must specify a genesis_file_location!".into(),
        ));
    }
    
    // ... rest of sanitizer
}
```

**Fix 3: Add Role-Based Safety Rules Backend Check**

Add an additional check in the sanitizer that doesn't depend on chain_id: [13](#0-12) 

Add before the chain_id check:
```rust
// Validators should never use InMemoryStorage regardless of chain
if node_type.is_validator() && safety_rules_config.backend.is_in_memory() {
    return Err(Error::ConfigSanitizerFailed(
        sanitizer_name,
        "Validators should use persistent storage (OnDiskStorage or VaultStorage) for safety rules, not InMemoryStorage!".into(),
    ));
}
```

## Proof of Concept

**PoC Config File (malicious_validator_config.yaml):**

```yaml
base:
  role: validator
  data_dir: "/opt/aptos/data"
  waypoint:
    from_config: "0:6072b68a942aace147e0655c5704beaa255c84a7829baa4e72a500f1516584c4"

# OMITTED: execution.genesis_file_location (defaults to empty)
# OMITTED: consensus.safety_rules.backend (defaults to InMemoryStorage)

validator_network:
  network_id: "Validator"
  mutual_authentication: true
  listen_address: "/ip4/0.0.0.0/tcp/6180"

full_node_networks: []
```

**Reproduction Steps:**

1. Create the malicious config file above
2. Attempt to start an Aptos node with this config on a system with mainnet genesis available
3. Observe that the node starts successfully (bypassing the sanitizer check)
4. Check the safety rules backend - it will be InMemoryStorage
5. Restart the node - safety data is lost
6. Node could now double-sign if it receives proposals for previously voted rounds

**Expected Behavior:**
The node should REJECT the config during sanitization with an error like:
"The secure backend should not be set to in memory storage in mainnet!"

**Actual Behavior:**
The node starts successfully with InMemoryStorage because chain_id extraction fails (genesis not loaded) and the mainnet safety check is skipped.

**Verification Command:**
After starting the node, check the consensus safety rules initialization logs - they will show InMemoryStorage being used despite the node being configured as a mainnet validator.

## Notes

This vulnerability demonstrates a defense-in-depth failure where:
1. The first line of defense (`#[serde(default)]` allowing omissions) is a design choice
2. The second line of defense (config sanitizer) exists but has a bypass
3. The bypass occurs through error handling that's too permissive (continuing with None on failure)

The fix requires making the error handling more strict for validators and adding redundant checks that don't depend on successfully extracting the chain ID.

### Citations

**File:** config/src/config/consensus_config.rs (L30-31)
```rust
#[derive(Clone, Debug, Deserialize, PartialEq, Serialize)]
#[serde(default, deny_unknown_fields)]
```

**File:** config/src/config/safety_rules_config.rs (L23-39)
```rust
#[derive(Clone, Debug, Deserialize, PartialEq, Serialize)]
#[serde(default, deny_unknown_fields)]
pub struct SafetyRulesConfig {
    pub backend: SecureBackend,
    pub logger: LoggerConfig,
    pub service: SafetyRulesService,
    pub test: Option<SafetyRulesTestConfig>,
    // Read/Write/Connect networking operation timeout in milliseconds.
    pub network_timeout_ms: u64,
    pub enable_cached_safety_data: bool,
    pub initial_safety_rules_config: InitialSafetyRulesConfig,
}

impl Default for SafetyRulesConfig {
    fn default() -> Self {
        Self {
            backend: SecureBackend::InMemoryStorage,
```

**File:** config/src/config/safety_rules_config.rs (L71-83)
```rust
impl ConfigSanitizer for SafetyRulesConfig {
    fn sanitize(
        node_config: &NodeConfig,
        node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();
        let safety_rules_config = &node_config.consensus.safety_rules;

        // If the node is not a validator, there's nothing to be done
        if !node_type.is_validator() {
            return Ok(());
        }
```

**File:** config/src/config/safety_rules_config.rs (L85-96)
```rust
        if let Some(chain_id) = chain_id {
            // Verify that the secure backend is appropriate for mainnet validators
            if chain_id.is_mainnet()
                && node_type.is_validator()
                && safety_rules_config.backend.is_in_memory()
            {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "The secure backend should not be set to in memory storage in mainnet!"
                        .to_string(),
                ));
            }
```

**File:** config/src/config/execution_config.rs (L78-82)
```rust
impl Default for ExecutionConfig {
    fn default() -> ExecutionConfig {
        ExecutionConfig {
            genesis: None,
            genesis_file_location: PathBuf::new(),
```

**File:** config/src/config/execution_config.rs (L100-109)
```rust
    pub fn load_from_path(&mut self, root_dir: &RootPath) -> Result<(), Error> {
        if !self.genesis_file_location.as_os_str().is_empty() {
            // Ensure the genesis file exists
            let genesis_path = root_dir.full_path(&self.genesis_file_location);
            if !genesis_path.exists() {
                return Err(Error::Unexpected(format!(
                    "The genesis file could not be found! Ensure the given path is correct: {:?}",
                    genesis_path.display()
                )));
            }
```

**File:** config/src/config/execution_config.rs (L157-186)
```rust
impl ConfigSanitizer for ExecutionConfig {
    fn sanitize(
        node_config: &NodeConfig,
        _node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();
        let execution_config = &node_config.execution;

        // If this is a mainnet node, ensure that additional verifiers are enabled
        if let Some(chain_id) = chain_id {
            if chain_id.is_mainnet() {
                if !execution_config.paranoid_hot_potato_verification {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "paranoid_hot_potato_verification must be enabled for mainnet nodes!"
                            .into(),
                    ));
                }
                if !execution_config.paranoid_type_verification {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "paranoid_type_verification must be enabled for mainnet nodes!".into(),
                    ));
                }
            }
        }

        Ok(())
    }
```

**File:** config/src/config/node_config_loader.rs (L112-123)
```rust
fn extract_node_type_and_chain_id(node_config: &NodeConfig) -> (NodeType, Option<ChainId>) {
    // Get the node type from the node config
    let node_type = NodeType::extract_from_config(node_config);

    // Get the chain ID from the genesis transaction
    match get_chain_id(node_config) {
        Ok(chain_id) => (node_type, Some(chain_id)),
        Err(error) => {
            println!("Failed to extract the chain ID from the genesis transaction: {:?}! Continuing with None.", error);
            (node_type, None)
        },
    }
```

**File:** config/src/config/node_config_loader.rs (L162-164)
```rust
    let genesis_txn = get_genesis_txn(node_config).ok_or_else(|| {
        Error::InvariantViolation("The genesis transaction was not found!".to_string())
    })?;
```

**File:** aptos-node/src/lib.rs (L177-183)
```rust
            let config = NodeConfig::load_from_path(config_path.clone()).unwrap_or_else(|error| {
                panic!(
                    "Failed to load the node config file! Given file path: {:?}. Error: {:?}",
                    config_path.display(),
                    error
                )
            });
```
