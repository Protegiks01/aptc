# Audit Report

## Title
Integer Overflow in Epoch Ending Restore Leading to Denial of Service (Not Chain Fork)

## Summary
The epoch ending restore functionality in `backup-cli` contains multiple integer overflow points that can be triggered by malicious backup manifests. However, contrary to the security question's premise, this does NOT lead to chain fork due to robust cryptographic verification. The realistic impact is Denial of Service through panic-induced crashes when overflow-checks are enabled.

## Finding Description

The `preheat_impl()` function and manifest verification contain several unchecked arithmetic operations on epoch values: [1](#0-0) [2](#0-1) [3](#0-2) 

An attacker who controls backup storage or can social engineer a node operator can provide a malicious `EpochEndingBackup` manifest with epoch values near `u64::MAX` (e.g., `first_epoch = u64::MAX - 10`, `last_epoch = u64::MAX`). 

**Attack Flow:**
1. Attacker creates malicious manifest JSON with `chunk.last_epoch = u64::MAX`
2. Node operator loads manifest via `storage.load_json_file(&manifest_handle)`
3. During `manifest.verify()`, the calculation `next_epoch = chunk.last_epoch + 1` overflows
4. With `overflow-checks = true` in Cargo.toml [4](#0-3) , this causes immediate panic
5. Backup restore process crashes - Denial of Service achieved

**Why Chain Fork is NOT Realistic:**

The security question asks about "potential chain fork," but this is prevented by multiple defense layers:

1. **Cryptographic Verification**: Each ledger info is cryptographically verified against trusted waypoints or previous epoch signatures [5](#0-4) 

2. **Epoch Sequence Validation**: Actual epoch numbers in ledger infos must match expected sequence [6](#0-5) 

3. **Waypoint Cross-Validation**: Waypoints from manifest must match waypoints computed from ledger infos [7](#0-6) 

For a chain fork to occur, an attacker would need cryptographically valid ledger infos with arbitrary epoch numbers, requiring compromise of the validator set - a scenario far beyond the scope of this overflow bug.

## Impact Explanation

**Actual Impact: HIGH Severity (Denial of Service)**

Per Aptos bug bounty criteria, this qualifies as **High Severity** due to "API crashes" [8](#0-7) . The backup-cli is a critical operational tool that crashes when processing malicious manifests, preventing disaster recovery.

- Prevents nodes from restoring from compromised backups
- Could delay network recovery after catastrophic failures
- Affects node operators' ability to bootstrap new validators

**NOT Critical Severity** because:
- Does not cause loss of funds
- Does not violate consensus safety (cryptographic verification prevents malformed data acceptance)
- Does not cause non-recoverable network partition
- Chain fork scenario is blocked by defense-in-depth

## Likelihood Explanation

**Medium Likelihood** - Requires:
1. Attacker compromises backup storage infrastructure OR
2. Social engineering of node operator to use malicious backup source
3. Operator attempts restore operation during these conditions

During disaster recovery scenarios when backups are most critical, this vulnerability becomes more impactful. The lack of bounds checking on epoch values makes exploitation straightforward once attacker controls manifest source.

## Recommendation

Implement bounds validation and use saturating/checked arithmetic, following the pattern used in the database reader: [9](#0-8) 

**Recommended Fix:**

```rust
// In manifest.rs verify() method:
ensure!(
    chunk.last_epoch < u64::MAX, 
    "Chunk last_epoch too large: {}", 
    chunk.last_epoch
);
let next_epoch = chunk.last_epoch.saturating_add(1);

// In restore.rs preheat_impl():
let expected_last_epoch = chunk.first_epoch
    .checked_add(lis.len() as u64)
    .ok_or_else(|| anyhow!("Epoch calculation overflow"))?
    .saturating_sub(1);
    
ensure!(
    expected_last_epoch == chunk.last_epoch,
    "Number of items in chunks doesn't match..."
);
```

Additionally, validate epoch values against reasonable bounds (e.g., current epoch + reasonable delta).

## Proof of Concept

```rust
// Create malicious manifest JSON
use serde_json::json;

let malicious_manifest = json!({
    "first_epoch": u64::MAX - 5,
    "last_epoch": u64::MAX,
    "waypoints": vec!["waypoint1", "waypoint2", "waypoint3", "waypoint4", "waypoint5", "waypoint6"],
    "chunks": vec![
        {
            "first_epoch": u64::MAX - 5,
            "last_epoch": u64::MAX,
            "ledger_infos": "malicious_chunk.bin"
        }
    ]
});

// Save to file and provide as manifest_handle to EpochEndingRestoreController
// When restore runs:
// 1. manifest.verify() will panic at: next_epoch = u64::MAX + 1
// 2. With overflow-checks=true, process crashes
// Result: Denial of Service
```

To test: Create a malicious manifest file with epoch values near `u64::MAX`, run `cargo build --release -p aptos-backup-cli`, and attempt restore. The process will panic with integer overflow.

---

## Notes

**Critical Clarification**: While the integer overflow vulnerability exists and constitutes a valid **HIGH severity DoS attack**, the **chain fork scenario specifically mentioned in the security question is NOT realistic**. The cryptographic verification layers (signature validation, waypoint verification, epoch sequence checking) prevent malformed epoch data from being accepted into the node's epoch history, even if arithmetic overflow were to wrap instead of panic.

The Aptos codebase explicitly enables overflow-checks in release builds as a security measure [8](#0-7) , which converts potential silent data corruption into explicit crashes - a security-conscious design choice that transforms this from a potential consensus issue into a DoS vulnerability.

### Citations

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L99-105)
```rust
                chunk.first_epoch + lis.len() as u64 == chunk.last_epoch + 1,
                "Number of items in chunks doesn't match that in manifest. \
                first_epoch: {}, last_epoch: {}, items in chunk: {}",
                chunk.first_epoch,
                chunk.last_epoch,
                lis.len(),
            );
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L113-118)
```rust
                ensure!(
                    li.ledger_info().epoch() == next_epoch,
                    "LedgerInfo epoch not expected. Expected: {}, actual: {}.",
                    li.ledger_info().epoch(),
                    next_epoch,
                );
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L119-128)
```rust
                let wp_manifest = waypoint_iter.next().ok_or_else(|| {
                    anyhow!("More LedgerInfo's found than waypoints in manifest.")
                })?;
                let wp_li = Waypoint::new_epoch_boundary(li.ledger_info())?;
                ensure!(
                    *wp_manifest == wp_li,
                    "Waypoints don't match. In manifest: {}, In chunk: {}",
                    wp_manifest,
                    wp_li,
                );
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L129-147)
```rust
                if let Some(wp_trusted) = self.trusted_waypoints.get(&wp_li.version()) {
                    ensure!(
                        *wp_trusted == wp_li,
                        "Waypoints don't match. In backup: {}, trusted: {}",
                        wp_li,
                        wp_trusted,
                    );
                } else if let Some(pre_li) = previous_li {
                    pre_li
                        .ledger_info()
                        .next_epoch_state()
                        .ok_or_else(|| {
                            anyhow!(
                                "Next epoch state not found from LI at epoch {}.",
                                pre_li.ledger_info().epoch()
                            )
                        })?
                        .verify(&li)?;
                }
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L150-150)
```rust
                next_epoch += 1;
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/manifest.rs (L56-56)
```rust
            next_epoch = chunk.last_epoch + 1;
```

**File:** Cargo.toml (L921-923)
```text
[profile.release]
debug = true
overflow-checks = true
```

**File:** RUST_SECURE_CODING.md (L17-20)
```markdown
Utilize Cargo for project management without overriding variables like `debug-assertions` and `overflow-checks`.

- **`debug-assertions`**: This variable controls whether debug assertions are enabled. Debug assertions are checks that are only present in debug builds. They are used to catch bugs during development by validating assumptions made in the code.
- **`overflow-checks`**: This variable determines whether arithmetic overflow checks are performed. In Rust, when overflow checks are enabled (which is the default in debug mode), an integer operation that overflows will cause a panic in debug builds, preventing potential security vulnerabilities like buffer overflows.
```

**File:** storage/aptosdb/src/db/aptosdb_reader.rs (L578-583)
```rust
            self.check_epoch_ending_ledger_infos_request(start_epoch, end_epoch)?;
            let limit = std::cmp::min(
                end_epoch.saturating_sub(start_epoch),
                MAX_NUM_EPOCH_ENDING_LEDGER_INFO as u64,
            );
            let end_epoch = start_epoch.saturating_add(limit);
```
