# Audit Report

## Title
Integer Underflow in Zeromorph batch_open() Causes Validator Node Crash

## Summary
The `batch_open()` function in the Zeromorph polynomial commitment scheme contains an integer underflow vulnerability when called with an empty `polys` vector. This causes the function `compute_batched_lifted_degree_quotient()` to compute `1 << (0 - 1)`, resulting in a panic and denial of service. [1](#0-0) 

## Finding Description
When `batch_open()` is invoked with an empty polynomial vector, the following execution path occurs:

1. **Empty gamma powers generation**: At line 545, `powers(gamma, polys.len())` is called with `polys.len() = 0`, producing an empty vector. [2](#0-1) 

2. **Zero polynomial creation**: The fold operation at lines 547-552 iterates over empty iterators, returning `Self::Polynomial::zero()` - a zero polynomial with `num_vars = 0`. [3](#0-2) 

3. **Propagation to open()**: This zero polynomial is passed to `Zeromorph::open()` at line 562, which calls `compute_multilinear_quotients()` returning an empty quotients vector. [4](#0-3) 

4. **Integer underflow**: In `compute_batched_lifted_degree_quotient()`, when `quotients.len() = 0`, line 157 computes the offset as `1 << (num_vars - 1)` where `num_vars = 0`. [5](#0-4) 

This results in `0usize - 1`, which:
- **Debug mode**: Panics with integer overflow error
- **Release mode**: Wraps to `usize::MAX`, then `1 << usize::MAX` panics or causes undefined behavior

The `powers()` function correctly handles zero count by returning an empty vector, but downstream code assumes `num_vars >= 1`. [6](#0-5) 

## Impact Explanation
**Severity: Medium**

This vulnerability causes **validator node crashes** through panic, qualifying as Medium severity under Aptos bug bounty criteria ("Validator node slowdowns" / "API crashes" at High, but given the experimental nature, Medium is appropriate).

**Impact:**
- Any node executing `batch_open([])` would crash
- Denial of service for affected validator nodes
- Potential consensus disruption if multiple validators crash simultaneously

**Mitigating factors:**
- The code is explicitly marked "THIS CODE HAS NOT YET BEEN VETTED, ONLY USE FOR BENCHMARKING PURPOSES!!!!!" 
- No production callers of `batch_open` for Zeromorph were found in the codebase
- The Aptos DKG implementation uses PVSS transcripts, not Zeromorph PCS [7](#0-6) 

## Likelihood Explanation
**Likelihood: Low-Medium**

**Attack requirements:**
- Attacker would need to invoke the `batch_open()` API with an empty vector
- Currently, no external API exposes this functionality in production

**However:**
- If Zeromorph PCS is integrated into the randomness generation or other cryptographic protocols in the future, this becomes exploitable
- The trait interface accepts arbitrary `Vec<Self::Polynomial>` with no documented preconditions [8](#0-7) 

## Recommendation
Add input validation to `batch_open()` to reject empty polynomial vectors:

```rust
fn batch_open<R: RngCore + CryptoRng>(
    ck: Self::CommitmentKey,
    polys: Vec<Self::Polynomial>,
    challenge: Vec<Self::WitnessField>,
    rs: Option<Vec<Self::WitnessField>>,
    rng: &mut R,
    trs: &mut merlin::Transcript,
) -> Self::Proof {
    // Add validation
    if polys.is_empty() {
        panic!("batch_open requires at least one polynomial");
    }
    
    let rs = rs.expect("rs must be present");
    // ... rest of implementation
}
```

Alternatively, fix the offset calculation in `compute_batched_lifted_degree_quotient()` to handle `num_vars = 0`:

```rust
fn compute_batched_lifted_degree_quotient<P: Pairing>(
    quotients: &[UniPoly<P::ScalarField>],
    y_challenge: &P::ScalarField,
) -> (UniPoly<P::ScalarField>, usize) {
    let num_vars = quotients.len();
    
    // Handle empty case
    if num_vars == 0 {
        return (UniPoly::from_coefficients_vec(vec![P::ScalarField::zero()]), 0);
    }
    
    // ... rest of implementation
}
```

## Proof of Concept

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use ark_bls12_381::Bls12_381 as E;
    use rand::thread_rng;

    #[test]
    #[should_panic(expected = "attempt to subtract with overflow")]
    fn test_batch_open_empty_polys_panic() {
        type CS = Zeromorph<E>;
        let mut rng = thread_rng();
        
        // Setup
        let (ck, _vk) = CS::setup(vec![1, 1], &mut rng);
        
        // Create empty polynomial vector
        let polys: Vec<<CS as PolynomialCommitmentScheme>::Polynomial> = vec![];
        
        // Create matching empty randomness vector
        let rs: Option<Vec<<CS as PolynomialCommitmentScheme>::WitnessField>> = Some(vec![]);
        
        // Challenge point (arbitrary, won't matter)
        let challenge = vec![CS::random_witness(&mut rng), CS::random_witness(&mut rng)];
        
        let mut trs = merlin::Transcript::new(b"test");
        
        // This should panic due to integer underflow
        let _proof = CS::batch_open(ck, polys, challenge, rs, &mut rng, &mut trs);
    }
}
```

**Notes:**
- This vulnerability exists in experimental code not yet deployed to production
- The Zeromorph implementation is marked as unvetted and for benchmarking only
- No current attack vector exists, but this represents a latent vulnerability if the code is integrated into production systems
- Input validation at the API boundary is the most robust mitigation

### Citations

**File:** crates/aptos-dkg/src/pcs/zeromorph.rs (L6-6)
```rust
// THIS CODE HAS NOT YET BEEN VETTED, ONLY USE FOR BENCHMARKING PURPOSES!!!!!
```

**File:** crates/aptos-dkg/src/pcs/zeromorph.rs (L157-157)
```rust
    (UniPoly::from_coefficients_vec(q_hat), 1 << (num_vars - 1))
```

**File:** crates/aptos-dkg/src/pcs/zeromorph.rs (L544-545)
```rust
        let gamma = trs.challenge_scalar();
        let gammas = powers(gamma, polys.len());
```

**File:** crates/aptos-dkg/src/pcs/zeromorph.rs (L547-552)
```rust
        let combined_poly = polys
            .iter()
            .zip(gammas.iter())
            .fold(Self::Polynomial::zero(), |acc, (poly, gamma_i)| {
                acc + poly * gamma_i
            });
```

**File:** crates/aptos-dkg/src/pcs/zeromorph.rs (L562-562)
```rust
        Zeromorph::open(&ck, &combined_poly, &challenge, eval, Scalar(s), rng, trs)
```

**File:** crates/aptos-crypto/src/utils.rs (L12-25)
```rust
pub fn powers<T>(base: T, count: usize) -> Vec<T>
where
    T: MulAssign + One + Copy,
{
    let mut powers = Vec::with_capacity(count);
    let mut current = T::one();

    for _ in 0..count {
        powers.push(current);
        current *= base;
    }

    powers
}
```

**File:** types/src/dkg/real_dkg/mod.rs (L38-40)
```rust
pub type WTrx = pvss::das::WeightedTranscript;
pub type DkgPP = <WTrx as Transcript>::PublicParameters;
pub type SSConfig = <WTrx as Transcript>::SecretSharingConfig;
```

**File:** crates/aptos-dkg/src/pcs/traits.rs (L43-51)
```rust
    fn batch_open<R: RngCore + CryptoRng>(
        ck: Self::CommitmentKey,
        polys: Vec<Self::Polynomial>,
        //   coms: Vec<Commitment>,
        challenge: Vec<Self::WitnessField>,
        rs: Option<Vec<Self::WitnessField>>,
        rng: &mut R,
        trs: &mut merlin::Transcript,
    ) -> Self::Proof;
```
