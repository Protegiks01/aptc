# Audit Report

## Title
Network Halt via Integer Overflow in Gas Cost Validation with Unchecked Multiplication

## Summary
The `check_gas()` function in `aptos-move/aptos-vm/src/gas.rs` performs unchecked multiplication of `gas_unit_price * max_gas_amount` when validating account creation costs. Combined with missing validation in the governance gas schedule update path and Rust's `overflow-checks = true` in release builds, this creates a potential for validator panics and network halt if gas parameters exceed safe bounds.

## Finding Description

The vulnerability exists in the interaction between three components:

1. **Unchecked multiplication in gas validation** [1](#0-0) 

2. **Missing validation in gas schedule updates** - The gas schedule can be updated via governance without validating that parameter combinations satisfy the overflow constraint documented at [2](#0-1) . The update functions contain explicit TODOs for missing validation [3](#0-2) .

3. **Overflow-checks enabled in release builds** [4](#0-3)  - This causes panics on integer overflow rather than silent wrapping.

**Attack Path:**
1. A governance proposal sets extreme values for gas parameters (e.g., `maximum_number_of_gas_units = 10_000_000_000` and `max_price_per_gas_unit = 10_000_000_000`)
2. These values pass the current validation in `set_for_next_epoch()` which only checks version monotonicity [5](#0-4) 
3. A user submits a transaction for account creation with `max_gas_amount` and `gas_unit_price` set to maximum allowed values
4. During validation in `check_gas()`, the multiplication overflows u64::MAX (18,446,744,073,709,551,615)
5. With `overflow-checks = true`, the validator process panics and crashes
6. All validators processing this transaction crash, causing network halt

**Contrast with Move epilogue:** The transaction epilogue has proper overflow protection using u128 casting [6](#0-5) , but the Rust validation code does not.

## Impact Explanation

**Critical Severity - Total Loss of Liveness/Network Availability**

If exploited, this vulnerability causes:
- All validators processing the transaction to panic and crash
- Complete network halt requiring emergency intervention
- No transactions can be processed until validators are manually restarted and the gas parameters are corrected via emergency governance action

This meets the Critical severity category: "Total loss of liveness/network availability" worth up to $1,000,000 per Aptos bug bounty criteria.

## Likelihood Explanation

**Low to Medium Likelihood:**

While the technical mechanism is sound, exploitation requires:
1. Governance passing a proposal with extreme gas parameter values (e.g., both parameters in the billions range where their product exceeds u64::MAX)
2. Such values being accidentally or maliciously included in a governance proposal
3. The proposal passing governance vote
4. A user submitting a transaction that triggers the overflow

The current production defaults are safe: `MAX_GAS_AMOUNT = 2_000_000` and `max_price_per_gas_unit = 10_000_000_000` have a product of ~20 trillion, well below u64::MAX [7](#0-6) .

However, the explicit TODO comments indicate this validation was intentionally deferred, increasing risk of accidental misconfiguration.

## Recommendation

**Immediate Fix:** Add validation in `set_for_next_epoch()` to enforce the overflow constraint:

```move
public fun set_for_next_epoch(aptos_framework: &signer, gas_schedule_blob: vector<u8>) acquires GasScheduleV2 {
    system_addresses::assert_aptos_framework(aptos_framework);
    assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));
    let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
    
    // ADDED: Validate gas parameter constraints
    validate_gas_schedule_consistency(&new_gas_schedule);
    
    if (exists<GasScheduleV2>(@aptos_framework)) {
        let cur_gas_schedule = borrow_global<GasScheduleV2>(@aptos_framework);
        assert!(
            new_gas_schedule.feature_version >= cur_gas_schedule.feature_version,
            error::invalid_argument(EINVALID_GAS_FEATURE_VERSION)
        );
    };
    config_buffer::upsert(new_gas_schedule);
}

fun validate_gas_schedule_consistency(schedule: &GasScheduleV2) {
    // Extract max_gas_amount and max_price_per_gas_unit from entries
    // Validate: (max_gas_amount as u128) * (max_price_per_gas_unit as u128) <= MAX_U64
    // Abort if constraint violated
}
```

**Defense-in-Depth:** Use checked multiplication in Rust code:

```rust
let actual = gas_unit_price.checked_mul(max_gas_amount)
    .ok_or_else(|| VMStatus::error(
        StatusCode::ARITHMETIC_ERROR,
        Some("Gas cost calculation overflow".to_string())
    ))?;
```

## Proof of Concept

```rust
#[test]
#[should_panic(expected = "attempt to multiply with overflow")]
fn test_gas_cost_overflow() {
    // Simulate extreme gas parameters that would overflow
    let gas_unit_price: u64 = 10_000_000_000; // 10 billion
    let max_gas_amount: u64 = 10_000_000_000; // 10 billion
    
    // This multiplication will panic with overflow-checks = true
    // Product: 100 quintillion > u64::MAX (18.4 quintillion)
    let _actual = gas_unit_price * max_gas_amount; // PANICS
}
```

**Notes:**
- The vulnerability requires governance to set extreme parameter values, which limits practical exploitability under normal circumstances
- However, the lack of validation creates a systemic risk, especially given the explicit TODO comments indicating this check was known to be missing
- The inconsistency between Move's checked arithmetic in the epilogue and Rust's unchecked arithmetic in validation creates a defense gap

### Citations

**File:** aptos-move/aptos-vm/src/gas.rs (L233-233)
```rust
        let actual = gas_unit_price * max_gas_amount;
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L52-53)
```rust
        // `MAX_PRICE_PER_GAS_UNIT` to always satisfy the inequality that
        // MAXIMUM_NUMBER_OF_GAS_UNITS * MAX_PRICE_PER_GAS_UNIT < min(u64::MAX, GasUnits<GasCarrier>::MAX)
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L47-47)
```text
        // TODO(Gas): check if gas schedule is consistent
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L91-103)
```text
    public fun set_for_next_epoch(aptos_framework: &signer, gas_schedule_blob: vector<u8>) acquires GasScheduleV2 {
        system_addresses::assert_aptos_framework(aptos_framework);
        assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));
        let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
        if (exists<GasScheduleV2>(@aptos_framework)) {
            let cur_gas_schedule = borrow_global<GasScheduleV2>(@aptos_framework);
            assert!(
                new_gas_schedule.feature_version >= cur_gas_schedule.feature_version,
                error::invalid_argument(EINVALID_GAS_FEATURE_VERSION)
            );
        };
        config_buffer::upsert(new_gas_schedule);
    }
```

**File:** Cargo.toml (L923-923)
```text
overflow-checks = true
```

**File:** aptos-move/framework/aptos-framework/sources/transaction_validation.move (L815-818)
```text
        assert!(
            (txn_gas_price as u128) * (gas_used as u128) <= MAX_U64,
            error::out_of_range(EOUT_OF_GAS)
        );
```

**File:** config/global-constants/src/lib.rs (L31-31)
```rust
pub const MAX_GAS_AMOUNT: u64 = 2_000_000;
```
