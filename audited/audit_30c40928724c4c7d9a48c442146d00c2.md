# Audit Report

## Title
Delayed Field Time-Travel Read Vulnerability in BlockSTM Parallel Executor

## Summary
A critical vulnerability exists in the `read_latest_predicted_value` fallback logic that allows transactions to read delayed field values from future (uncommitted) transactions during speculative execution. The validation incorrectly passes because it uses the same flawed logic, enabling transactions to commit with values from transactions that haven't committed yet, violating deterministic execution guarantees.

## Finding Description

The vulnerability occurs in the `VersionedValue::read_latest_predicted_value` method when handling newly-created delayed fields. [1](#0-0) 

When no entry exists in the valid commit range `[0, next_idx_to_commit)` and no base value exists (newly created delayed field), the method falls back to reading `first_key_value()` from the versioned map without range constraints. [2](#0-1) 

The public interface clamps the search range using `next_idx_to_commit`, but the fallback bypasses this: [3](#0-2) 

This fallback is triggered during value deserialization in both execution and validation: [4](#0-3) 

**Attack Scenario:**

1. **Setup**: Transaction T_7 creates a new delayed field `df_new` with value 1000 and embeds its identifier in resource R
2. **Speculative Execution**: Transaction T_3 speculatively reads resource R from T_7, triggering `identifier_to_value(df_new)`
3. **Time-Travel Read**: 
   - Range calculation: `min(txn_idx + 1, next_idx_to_commit) = min(4, 3) = 3`
   - Search range: `[0, 3)` contains no entry for `df_new`
   - Falls back to `first_key_value()` â†’ reads index 7 entry (value 1000)
   - T_3 obtains value from future transaction T_7

4. **Validation Bypass**: When T_3 commits, `validate_delayed_field_reads` is called: [5](#0-4) 

   The validation uses `ReadPosition::BeforeCurrentTxn` but still triggers the same fallback, reading the same value from T_7's entry. Since `1000 == 1000`, validation passes.

5. **State Inconsistency**: T_3 commits with value 1000. Later, T_7 aborts/re-executes and commits with value 2000. Result: T_3's committed state is based on an incorrect value that doesn't match the final committed delayed field value.

The resource-level read dependency on R is tracked, but the delayed field VALUE change is not properly validated because the resource only stores the delayed field IDENTIFIER, not the value itself. The separate delayed field validation uses the buggy fallback logic.

## Impact Explanation

**Critical Severity** - This violates the **Deterministic Execution** invariant: "All validators must produce identical state roots for identical blocks."

Different validators may execute transactions in different speculative orders. If validator A's T_3 reads from T_7's incarnation 0 (value 1000) and validator B's T_3 reads from T_7's incarnation 1 (value 2000) due to timing differences, they will commit different values for T_3, causing state root divergence and consensus failure.

This creates:
- **Consensus Safety Violation**: Network fork requiring emergency hardfork
- **State Inconsistency**: Committed transaction outputs depend on non-deterministic speculative execution order
- **Validator Disagreement**: Different validators produce different state roots for the same block sequence

## Likelihood Explanation

**High Likelihood** - This occurs whenever:
1. A transaction creates a new delayed field (aggregator/snapshot)
2. A lower-indexed transaction attempts to read it during speculative parallel execution  
3. The timing allows the read before the creator transaction commits

Block-STM's aggressive speculative execution makes this scenario common in high-throughput environments. The vulnerability is triggered automatically without requiring attacker sophistication - just normal parallel execution patterns with delayed field usage.

## Recommendation

**Fix**: Remove the unsafe fallback in `read_latest_predicted_value`. When no entry exists in the valid range and no base value exists, return `MVDelayedFieldsError::NotFound` instead of falling back to `first_key_value()`.

```rust
fn read_latest_predicted_value(
    &self,
    next_idx_to_commit: TxnIndex,
) -> Result<DelayedFieldValue, MVDelayedFieldsError> {
    use VersionEntry::*;
    
    self.versioned_map
        .range(0..next_idx_to_commit)
        .next_back()
        .map_or_else(
            || match &self.base_value {
                Some(value) => Ok(value.clone()),
                // REMOVE THE FALLBACK - return error instead
                None => Err(MVDelayedFieldsError::NotFound),
            },
            |(_, entry)| match entry.as_ref().deref() {
                Value(v, _) => Ok(v.clone()),
                Apply(_) => unreachable!("Apply entries may not exist for committed txn indices"),
                Estimate(_) => unreachable!("Committed entry may not be an Estimate"),
            },
        )
}
```

This ensures transactions can only read delayed fields from committed transactions or base storage, never from future speculative executions.

## Proof of Concept

The vulnerability is in the core execution engine and requires Rust-level reproduction:

```rust
// Reproduction steps:
// 1. Initialize MVHashMap with VersionedDelayedFields
// 2. Set next_idx_to_commit = 3 (T_0, T_1, T_2 committed)
// 3. Transaction T_7 executes: creates DelayedFieldID(1, width=32), writes value 1000 at index 7
// 4. Transaction T_3 executes: calls read_latest_predicted_value(&DelayedFieldID(1, 32), 3, AfterCurrentTxn)
// 5. Observe: Returns value 1000 from index 7 (should return NotFound error)
// 6. Validation: calls read_latest_predicted_value(&DelayedFieldID(1, 32), 3, BeforeCurrentTxn)
// 7. Observe: Also returns 1000, validation passes (should fail)
// 8. Result: T_3 commits with time-traveled value from T_7
```

The bug is reproducible in unit tests by creating a `VersionedDelayedFields` instance, simulating the described transaction execution order, and observing that `read_latest_predicted_value` returns values from higher-indexed transactions when it should return an error.

### Citations

**File:** aptos-move/mvhashmap/src/versioned_delayed_fields.rs (L225-253)
```rust
    fn read_latest_predicted_value(
        &self,
        next_idx_to_commit: TxnIndex,
    ) -> Result<DelayedFieldValue, MVDelayedFieldsError> {
        use VersionEntry::*;

        self.versioned_map
            .range(0..next_idx_to_commit)
            .next_back()
            .map_or_else(
                || match &self.base_value {
                    Some(value) => Ok(value.clone()),
                    None => match self.versioned_map.first_key_value() {
                        Some((_, entry)) => match entry.as_ref().deref() {
                            Value(v, _) => Ok(v.clone()),
                            Apply(_) | Estimate(_) => Err(MVDelayedFieldsError::NotFound),
                        },
                        None => Err(MVDelayedFieldsError::NotFound),
                    },
                },
                |(_, entry)| match entry.as_ref().deref() {
                    Value(v, _) => Ok(v.clone()),
                    Apply(_) => {
                        unreachable!("Apply entries may not exist for committed txn indices")
                    },
                    Estimate(_) => unreachable!("Committed entry may not be an Estimate"),
                },
            )
    }
```

**File:** aptos-move/mvhashmap/src/versioned_delayed_fields.rs (L748-766)
```rust
    fn read_latest_predicted_value(
        &self,
        id: &K,
        current_txn_idx: TxnIndex,
        read_position: ReadPosition,
    ) -> Result<DelayedFieldValue, MVDelayedFieldsError> {
        self.values
            .get_mut(id)
            .ok_or(MVDelayedFieldsError::NotFound)
            .and_then(|v| {
                v.read_latest_predicted_value(
                    match read_position {
                        ReadPosition::BeforeCurrentTxn => current_txn_idx,
                        ReadPosition::AfterCurrentTxn => current_txn_idx + 1,
                    }
                    .min(self.next_idx_to_commit.load(Ordering::Relaxed)),
                )
            })
    }
```

**File:** aptos-move/block-executor/src/value_exchange.rs (L92-101)
```rust
        let delayed_field = match &self.latest_view.latest_view {
            ViewState::Sync(state) => state
                .versioned_map
                .delayed_fields()
                .read_latest_predicted_value(
                    &identifier,
                    self.txn_idx,
                    ReadPosition::AfterCurrentTxn,
                )
                .expect("Committed value for ID must always exist"),
```

**File:** aptos-move/block-executor/src/captured_reads.rs (L1142-1184)
```rust
    pub(crate) fn validate_delayed_field_reads(
        &self,
        delayed_fields: &dyn TVersionedDelayedFieldView<DelayedFieldID>,
        idx_to_validate: TxnIndex,
    ) -> Result<bool, PanicError> {
        if self.delayed_field_speculative_failure {
            return Ok(false);
        }

        use MVDelayedFieldsError::*;
        for (id, read_value) in &self.delayed_field_reads {
            match delayed_fields.read_latest_predicted_value(
                id,
                idx_to_validate,
                ReadPosition::BeforeCurrentTxn,
            ) {
                Ok(current_value) => match read_value {
                    DelayedFieldRead::Value { value, .. } => {
                        if value != &current_value {
                            return Ok(false);
                        }
                    },
                    DelayedFieldRead::HistoryBounded {
                        restriction,
                        max_value,
                        ..
                    } => match restriction.validate_against_base_value(
                        current_value.into_aggregator_value()?,
                        *max_value,
                    ) {
                        Ok(_) => {},
                        Err(_) => {
                            return Ok(false);
                        },
                    },
                },
                Err(NotFound) | Err(Dependency(_)) | Err(DeltaApplicationFailure) => {
                    return Ok(false);
                },
            }
        }
        Ok(true)
    }
```
