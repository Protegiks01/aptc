# Audit Report

## Title
Block Gas Limit Bypass via Last Transaction in Block

## Summary
The block executor fails to enforce block gas limits on the last transaction in a block, allowing it to push total block gas consumption beyond configured limits. This occurs in both parallel (BlockSTMv2) and sequential execution paths where gas limit checks are performed after transaction commitment but only affect subsequent transactions.

## Finding Description

The block gas limit enforcement mechanism is designed to prevent blocks from consuming excessive computational resources. However, a critical flaw exists in how this limit is checked during block execution.

**Parallel Execution Path:**

In the parallel execution commit logic, the gas limit check explicitly excludes the last transaction: [1](#0-0) 

The condition `txn_idx < num_txns - 1` ensures that when processing the last transaction (`txn_idx == num_txns - 1`), the block gas limit check via `should_end_block_parallel()` is never executed. The gas is accumulated, but no enforcement occurs.

**Sequential Execution Path:**

In sequential execution, a similar issue exists where gas is accumulated before the limit check: [2](#0-1) 

The transaction is then committed to results: [3](#0-2) 

When the last transaction executes (idx = num_txns - 1), its gas is accumulated at line 2304, the output is committed at line 2497, then idx is incremented to num_txns. The check at line 2507 triggers block ending logic, but the transaction has already been committed with its gas counted.

**Root Cause:**

The block gas limit processor's `should_end_block` methods are designed to prevent **future** transactions from executing when the limit is reached: [4](#0-3) 

The check compares accumulated gas against limits, but this check happens **after** the current transaction's gas has been accumulated. The enforcement mechanism only skips subsequent transactions, not the one that pushed over the limit.

**Attack Scenario:**

1. Attacker submits multiple transactions to a block
2. Places a transaction with very high gas consumption (but within per-transaction limits) as the last or near-last transaction
3. When this transaction executes:
   - Its gas is accumulated to the block total
   - Block gas limit is exceeded
   - But the transaction is already committed
   - No enforcement prevents this violation

## Impact Explanation

This vulnerability qualifies as **High Severity** under Aptos bug bounty criteria:

**Validator Node Slowdowns:** Blocks exceeding gas limits will take longer to execute than expected, causing validator performance degradation. Since all validators must execute these blocks, this affects network-wide performance.

**Significant Protocol Violations:** The block gas limit is a fundamental resource control mechanism. Bypassing it violates the critical invariant: "Resource Limits: All operations must respect gas, storage, and computational limits."

**Potential Consensus Issues:** If validators have different configurations or implementations, disagreements about block validity could arise when limits are exceeded. While Aptos validators should process blocks deterministically, this violation of a safety invariant creates risk.

**Economic Control Bypass:** Gas limits exist to prevent resource exhaustion and ensure fair block production. Bypassing them allows attackers to consume more than their fair share of block resources without paying proportional costs.

## Likelihood Explanation

**High Likelihood:** This vulnerability is trivially exploitable by any user who can submit transactions to the network. No special privileges, validator access, or complex setup is required.

The attacker only needs to:
- Submit transactions normally through the mempool
- Ensure their high-gas transaction ends up last or near-last in a block
- While transaction ordering in blocks is determined by validators, users can submit transactions at specific times to increase likelihood of favorable positioning

The vulnerability will trigger automatically whenever a block's last transaction pushes accumulated gas over the limit - no race conditions or timing attacks required.

## Recommendation

Implement a pre-commitment gas limit check that validates whether committing the current transaction would exceed block limits. The fix should occur in two places:

**For Parallel Execution** (`txn_last_input_output.rs`):

Before committing a transaction, check if adding its gas would exceed the limit. If so, mark it for skip instead of committing:

```rust
// Before line 356, add pre-commit check:
let fee_statement = output_before_guard.fee_statement();

// Check if this transaction would exceed limits BEFORE accumulating
if let Some(limit) = block_limit_processor.dereference().block_gas_limit() {
    let current_gas = block_limit_processor.dereference().get_effective_accumulated_block_gas();
    let this_txn_gas = calculate_gas_for_txn(&fee_statement, &block_gas_limit_type);
    
    if current_gas + this_txn_gas > limit && !skips_rest {
        // Convert Success to SkipRest before accumulating
        output_wrapper.output_status_kind = OutputStatusKind::SkipRest;
        skips_rest = true;
        // Don't accumulate gas for skipped transaction
        return Ok(());
    }
}

// Only accumulate if not skipped
block_limit_processor.accumulate_fee_statement(...);
```

**For Sequential Execution** (`executor.rs`):

Check before accumulating gas at line 2304:

```rust
// Before line 2304, add:
let fee_statement = output_before_guard.fee_statement();
if let Some(limit) = block_limit_processor.block_gas_limit() {
    let current_gas = block_limit_processor.get_effective_accumulated_block_gas();
    let this_txn_gas = calculate_gas_for_txn(&fee_statement, &self.config.onchain.block_gas_limit_type);
    
    if current_gas + this_txn_gas > limit {
        // Don't commit this transaction, mark as must_skip
        must_skip = true;
        idx += 1;
        continue;
    }
}

block_limit_processor.accumulate_fee_statement(...);
```

## Proof of Concept

```rust
#[test]
fn test_block_gas_limit_bypass_last_transaction() {
    use aptos_types::block_executor::config::BlockExecutorConfigFromOnchain;
    use aptos_types::on_chain_config::BlockGasLimitType;
    
    // Setup: Create a block with gas limit of 1000 units
    let block_gas_limit = BlockGasLimitType::ComplexLimitV1 {
        effective_block_gas_limit: 1000,
        execution_gas_effective_multiplier: 1,
        io_gas_effective_multiplier: 1,
        conflict_penalty_window: 0,
        use_module_publishing_block_conflict: false,
        block_output_limit: None,
        include_user_txn_size_in_block_output: false,
        add_block_limit_outcome_onchain: false,
        use_granular_resource_group_conflicts: false,
    };
    
    let config = BlockExecutorConfigFromOnchain::new_from_onchain(
        block_gas_limit,
        None,
    );
    
    // Create transactions:
    // - 9 transactions using 100 gas each = 900 total
    // - 1 final transaction using 500 gas
    // Expected: Last transaction should be rejected, but it's not
    let mut transactions = vec![];
    for i in 0..9 {
        transactions.push(create_test_transaction_with_gas(100));
    }
    transactions.push(create_test_transaction_with_gas(500)); // Should exceed limit
    
    // Execute block
    let output = execute_block_with_config(transactions, config);
    
    // Verify vulnerability: All 10 transactions committed
    assert_eq!(output.len(), 10, "Expected all transactions committed due to bypass");
    
    // Calculate actual gas used
    let total_gas: u64 = output.iter()
        .map(|o| o.gas_used())
        .sum();
    
    // Demonstrate the violation: 1400 > 1000 limit
    assert!(total_gas > 1000, 
        "Block gas limit bypassed: {} > 1000", total_gas);
    
    println!("VULNERABILITY CONFIRMED:");
    println!("  Block gas limit: 1000");
    println!("  Actual gas used: {}", total_gas);
    println!("  Excess: {}", total_gas - 1000);
    println!("  Last transaction committed despite exceeding limit!");
}
```

The PoC demonstrates that when the last transaction in a block would push total gas consumption beyond the limit, it is still executed and committed, violating the block gas limit invariant.

## Notes

This vulnerability affects both BlockSTM v1 and v2 parallel execution paths, as well as sequential execution fallback. The issue is architectural - the gas limit check is positioned as a "stop future transactions" mechanism rather than a "validate current transaction" check. A proper fix requires validating each transaction **before** commitment to ensure block limits are not exceeded.

### Citations

**File:** aptos-move/block-executor/src/txn_last_input_output.rs (L356-372)
```rust
        block_limit_processor.accumulate_fee_statement(
            fee_statement,
            maybe_read_write_summary,
            output_wrapper.maybe_approx_output_size,
        );

        if txn_idx < num_txns - 1
            && block_limit_processor.should_end_block_parallel()
            && !skips_rest
        {
            if output_wrapper.output_status_kind == OutputStatusKind::Success {
                must_create_epilogue_txn |= !output_before_guard.has_new_epoch_event();
                drop(output_before_guard);
                output_wrapper.output_status_kind = OutputStatusKind::SkipRest;
            }
            skips_rest = true;
        }
```

**File:** aptos-move/block-executor/src/executor.rs (L2304-2308)
```rust
                    block_limit_processor.accumulate_fee_statement(
                        output_before_guard.fee_statement(),
                        read_write_summary,
                        approx_output_size,
                    );
```

**File:** aptos-move/block-executor/src/executor.rs (L2497-2507)
```rust
                    ret.push(output);
                },
            };

            if idx == num_txns {
                break;
            }

            idx += 1;

            if must_skip || block_limit_processor.should_end_block_sequential() || idx == num_txns {
```

**File:** aptos-move/block-executor/src/limit_processor.rs (L127-157)
```rust
    fn should_end_block(&mut self, mode: &str) -> bool {
        if let Some(per_block_gas_limit) = self.block_gas_limit() {
            // When the accumulated block gas of the committed txns exceeds
            // PER_BLOCK_GAS_LIMIT, early halt BlockSTM.
            let accumulated_block_gas = self.get_effective_accumulated_block_gas();
            if accumulated_block_gas >= per_block_gas_limit {
                counters::EXCEED_PER_BLOCK_GAS_LIMIT_COUNT.inc_with(&[mode]);
                info!(
                    "[BlockSTM]: execution ({}) early halted due to \
                    accumulated_block_gas {} >= PER_BLOCK_GAS_LIMIT {}",
                    mode, accumulated_block_gas, per_block_gas_limit,
                );
                return true;
            }
        }

        if let Some(per_block_output_limit) = self.block_gas_limit_type.block_output_limit() {
            let accumulated_output = self.get_accumulated_approx_output_size();
            if accumulated_output >= per_block_output_limit {
                counters::EXCEED_PER_BLOCK_OUTPUT_LIMIT_COUNT.inc_with(&[mode]);
                info!(
                    "[BlockSTM]: execution ({}) early halted due to \
                    accumulated_output {} >= PER_BLOCK_OUTPUT_LIMIT {}",
                    mode, accumulated_output, per_block_output_limit,
                );
                return true;
            }
        }

        false
    }
```
