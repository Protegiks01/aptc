# Audit Report

## Title
Governance Misconfiguration Can Cause Total Network Halt Due to Missing Gas Price Bounds Validation

## Summary

The Aptos blockchain lacks validation to ensure that `min_price_per_gas_unit` < `max_price_per_gas_unit` when the gas schedule is updated through governance. This allows a governance misconfiguration (malicious or accidental) to set min >= max, causing ALL transactions to be permanently rejected and requiring a hardfork to recover.

## Finding Description

The vulnerability exists in two critical locations:

**1. Missing Validation in Governance Update Path** [1](#0-0) 

The `set_for_next_epoch()` function accepts new gas schedule parameters but only validates:
- Non-empty blob
- Feature version >= current version

There is NO validation that `min_price_per_gas_unit < max_price_per_gas_unit`. The code contains a TODO comment acknowledging this missing validation: [2](#0-1) 

**2. Transaction Rejection Logic in Gas Validation** [3](#0-2) [4](#0-3) 

The `check_gas()` function enforces that every transaction's `gas_unit_price` must satisfy:
- `gas_unit_price >= min_price_per_gas_unit` (enforced at lines 178-192)
- `gas_unit_price <= max_price_per_gas_unit` (enforced at lines 195-208)

**Attack Scenario:**

1. Governance passes a proposal updating the gas schedule with malicious parameters:
   - Example: `min_price_per_gas_unit = 1000`, `max_price_per_gas_unit = 500`

2. The update passes validation and is applied at the next epoch

3. From that point forward, for ANY transaction with gas_unit_price = P:
   - If P < 1000: Transaction rejected with `GAS_UNIT_PRICE_BELOW_MIN_BOUND`
   - If P >= 1000: Transaction rejected with `GAS_UNIT_PRICE_ABOVE_MAX_BOUND` (since max=500)
   - NO value of P can satisfy both constraints

4. **Result: Complete network halt** - zero transactions can be processed

**Evidence of Missing Validation:**

The legacy Diem framework (third-party code) HAD this validation: [5](#0-4) 

The current Aptos StorageGas module HAS similar validation for its gas curves: [6](#0-5) 

But the Aptos gas_schedule module does NOT have this validation, despite the TODO comments indicating it should.

The Rust deserialization also lacks validation: [7](#0-6) 

This only checks that required keys exist in the gas schedule map, not that values maintain required invariants.

## Impact Explanation

**Severity: CRITICAL** (up to $1,000,000 per Aptos Bug Bounty)

This vulnerability meets the Critical severity criteria:

1. **Total loss of liveness/network availability**: Once misconfigured, the network cannot process ANY transactions - complete halt

2. **Non-recoverable network partition (requires hardfork)**: The only recovery path is a coordinated hardfork to manually override the gas schedule parameters, as no transactions can execute (including governance transactions to fix the issue)

3. **Breaks Core Invariant**: Violates the "Resource Limits" invariant - the network becomes unable to process any operations regardless of gas parameters

**Blast Radius:**
- Affects: ALL validator nodes, ALL users
- Duration: Permanent until hardfork
- Recovery: Requires emergency hardfork coordination

## Likelihood Explanation

**Likelihood: Medium to High**

**Factors Increasing Likelihood:**

1. **No Validation Exists**: The complete absence of bounds checking means this can happen through:
   - Accidental misconfiguration during governance upgrade
   - Malicious governance proposal (requires votes but still possible)
   - Software bug in gas schedule generation tools

2. **TODO Comments Indicate Known Gap**: The presence of TODO comments in the code suggests the team is aware this validation is needed but hasn't implemented it: [8](#0-7) 

3. **Historical Precedent**: The Diem framework had this validation, suggesting it was removed or never ported to Aptos

4. **Complex Parameter Updates**: Gas schedules contain many parameters updated as raw key-value pairs, making it easy to introduce errors

**Factors Decreasing Likelihood:**

1. Requires governance proposal to pass (but doesn't require malicious intent - could be accidental)
2. Gas schedule updates are relatively infrequent

## Recommendation

**Immediate Fix: Add Validation to Gas Schedule Updates**

Add bounds validation in `gas_schedule.move`:

```move
public fun set_for_next_epoch(aptos_framework: &signer, gas_schedule_blob: vector<u8>) acquires GasScheduleV2 {
    system_addresses::assert_aptos_framework(aptos_framework);
    assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));
    
    let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
    
    // ADD THIS VALIDATION:
    validate_gas_schedule_consistency(&new_gas_schedule);
    
    if (exists<GasScheduleV2>(@aptos_framework)) {
        let cur_gas_schedule = borrow_global<GasScheduleV2>(@aptos_framework);
        assert!(
            new_gas_schedule.feature_version >= cur_gas_schedule.feature_version,
            error::invalid_argument(EINVALID_GAS_FEATURE_VERSION)
        );
    };
    config_buffer::upsert(new_gas_schedule);
}

// New validation function
fun validate_gas_schedule_consistency(schedule: &GasScheduleV2) {
    let min_price = get_u64_param(schedule, "txn.min_price_per_gas_unit");
    let max_price = get_u64_param(schedule, "txn.max_price_per_gas_unit");
    
    assert!(
        min_price <= max_price,
        error::invalid_argument(EGAS_SCHEDULE_INCONSISTENCY)
    );
    
    // Add other consistency checks as needed
}
```

**Additional Recommendations:**

1. Add similar validation to all gas schedule update functions (`initialize`, `set_gas_schedule`, `set_for_next_epoch_check_hash`)

2. Add Rust-side validation in the deserialization logic: [9](#0-8) 

3. Add comprehensive tests for boundary conditions

4. Implement a "sanity check" mode in governance tooling that validates gas schedules before proposal submission

## Proof of Concept

**Move Test Demonstrating the Vulnerability:**

```move
#[test(framework = @aptos_framework)]
#[expected_failure(abort_code = 0x10009, location = aptos_framework::transaction_validation)]
fun test_inverted_gas_bounds_reject_all_transactions(framework: &signer) {
    // Setup: Create malicious gas schedule with min > max
    let malicious_entries = vector[
        GasEntry { key: string::utf8(b"txn.min_price_per_gas_unit"), val: 1000 },
        GasEntry { key: string::utf8(b"txn.max_price_per_gas_unit"), val: 500 },
        // ... other required entries ...
    ];
    
    let malicious_schedule = GasScheduleV2 {
        feature_version: 100,
        entries: malicious_entries,
    };
    
    // This should be rejected but currently isn't validated
    gas_schedule::set_for_next_epoch(framework, bcs::to_bytes(&malicious_schedule));
    aptos_governance::reconfigure(framework);
    
    // Now ANY transaction with ANY gas price will be rejected
    // Try price = 750 (between 500 and 1000, but invalid range)
    let txn = create_test_transaction(750);
    
    // This will fail with GAS_UNIT_PRICE_ABOVE_MAX_BOUND
    // because 750 > max (500), even though it's also < min (1000)
    execute_transaction(txn); // REJECTED
}
```

**Rust Test Demonstrating Transaction Rejection:**

```rust
#[test]
fn test_invalid_gas_bounds_cause_transaction_rejection() {
    // Create gas parameters with inverted bounds
    let mut txn_params = TransactionGasParameters::initial();
    txn_params.min_price_per_gas_unit = 1000.into();
    txn_params.max_price_per_gas_unit = 500.into();
    
    let gas_params = AptosGasParameters {
        vm: VMGasParameters { txn: txn_params, ..Default::default() },
        ..Default::default()
    };
    
    // Try to validate a transaction with price = 750
    let txn_metadata = TransactionMetadata {
        gas_unit_price: 750,
        ..Default::default()
    };
    
    // This will return VMStatus::Error(GAS_UNIT_PRICE_ABOVE_MAX_BOUND)
    let result = check_gas(
        &gas_params,
        gas_feature_version,
        &resolver,
        &module_storage,
        &txn_metadata,
        &features,
        false,
        &log_context,
    );
    
    assert!(result.is_err());
    // No valid price exists that satisfies both constraints!
}
```

## Notes

This vulnerability represents a critical gap in the governance safety mechanisms. While the Aptos team has implemented bounds validation for StorageGas curves, the same protection was not extended to transaction gas parameters. The presence of TODO comments in the code indicates this was a known issue that was never addressed. The impact is catastrophic - a single misconfigured governance proposal could halt the entire network indefinitely, requiring emergency intervention and a hardfork to recover.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L47-47)
```text
        // TODO(Gas): check if gas schedule is consistent
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L67-67)
```text
            // TODO(Gas): check if gas schedule is consistent
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L91-103)
```text
    public fun set_for_next_epoch(aptos_framework: &signer, gas_schedule_blob: vector<u8>) acquires GasScheduleV2 {
        system_addresses::assert_aptos_framework(aptos_framework);
        assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));
        let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
        if (exists<GasScheduleV2>(@aptos_framework)) {
            let cur_gas_schedule = borrow_global<GasScheduleV2>(@aptos_framework);
            assert!(
                new_gas_schedule.feature_version >= cur_gas_schedule.feature_version,
                error::invalid_argument(EINVALID_GAS_FEATURE_VERSION)
            );
        };
        config_buffer::upsert(new_gas_schedule);
    }
```

**File:** aptos-move/aptos-vm/src/gas.rs (L174-192)
```rust
    // The submitted gas price is less than the minimum gas unit price set by the VM.
    // NB: MIN_PRICE_PER_GAS_UNIT may equal zero, but need not in the future. Hence why
    // we turn off the clippy warning.
    #[allow(clippy::absurd_extreme_comparisons)]
    let below_min_bound = txn_metadata.gas_unit_price() < txn_gas_params.min_price_per_gas_unit;
    if below_min_bound {
        speculative_warn!(
            log_context,
            format!(
                "[VM] Gas unit error; min {}, submitted {}",
                txn_gas_params.min_price_per_gas_unit,
                txn_metadata.gas_unit_price()
            ),
        );
        return Err(VMStatus::error(
            StatusCode::GAS_UNIT_PRICE_BELOW_MIN_BOUND,
            None,
        ));
    }
```

**File:** aptos-move/aptos-vm/src/gas.rs (L194-208)
```rust
    // The submitted gas price is greater than the maximum gas unit price set by the VM.
    if txn_metadata.gas_unit_price() > txn_gas_params.max_price_per_gas_unit {
        speculative_warn!(
            log_context,
            format!(
                "[VM] Gas unit error; max {}, submitted {}",
                txn_gas_params.max_price_per_gas_unit,
                txn_metadata.gas_unit_price()
            ),
        );
        return Err(VMStatus::error(
            StatusCode::GAS_UNIT_PRICE_ABOVE_MAX_BOUND,
            None,
        ));
    }
```

**File:** third_party/move/move-examples/diem-framework/move-packages/DPN/sources/DiemVMConfig.move (L154-157)
```text
        assert!(
            min_price_per_gas_unit <= max_price_per_gas_unit,
            errors::invalid_argument(EGAS_CONSTANT_INCONSISTENCY)
        );
```

**File:** aptos-move/framework/aptos-framework/sources/storage_gas.spec.move (L12-13)
```text
        /// Invariant 1: The minimum gas charge does not exceed the maximum gas charge.
        invariant min_gas <= max_gas;
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/macros.rs (L32-46)
```rust
        impl $crate::traits::FromOnChainGasSchedule for $params_name {
            #[allow(unused)]
            fn from_on_chain_gas_schedule(gas_schedule: &std::collections::BTreeMap<String, u64>, feature_version: u64) -> Result<Self, String> {
                let mut params = $params_name::zeros();

                $(
                    if let Some(key) = $crate::gas_schedule::macros::define_gas_parameters_extract_key_at_version!($key_bindings, feature_version) {
                        let name = format!("{}.{}", $prefix, key);
                        params.$name = gas_schedule.get(&name).cloned().ok_or_else(|| format!("Gas parameter {} does not exist. Feature version: {}.", name, feature_version))?.into();
                    }
                )*

                Ok(params)
            }
        }
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L59-71)
```rust
        // The minimum gas price that a transaction can be submitted with.
        // TODO(Gas): should probably change this to something > 0
        [
            min_price_per_gas_unit: FeePerGasUnit,
            "min_price_per_gas_unit",
            aptos_global_constants::GAS_UNIT_PRICE
        ],
        // The maximum gas unit price that a transaction can be submitted with.
        [
            max_price_per_gas_unit: FeePerGasUnit,
            "max_price_per_gas_unit",
            10_000_000_000
        ],
```
