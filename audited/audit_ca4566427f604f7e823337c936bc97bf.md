# Audit Report

## Title
Configuration Validation Gap: Missing Enforcement of enable_statekeys Requirement for Sharded Deployments

## Summary
The configuration sanitizer fails to enforce that `enable_statekeys` must be enabled when storage sharding is enabled, causing API endpoints `/accounts/{address}/resources` and `/accounts/{address}/modules` to fail with errors on production nodes. This creates operational issues and confusing error messages for API clients.

## Finding Description

When storage sharding is enabled (`enable_storage_sharding=true`), the API layer unconditionally routes resource and module queries through the internal indexer reader. [1](#0-0) 

The indexer reader checks if state keys are enabled before serving requests: [2](#0-1) 

If `enable_statekeys=false`, the method returns an error `"Internal statekeys index is not enabled"`. This error propagates to API clients as a 500 Internal Server Error. [3](#0-2) 

The critical issue is that mainnet and testnet nodes **must** have sharding enabled: [4](#0-3) 

However, the default configuration has `enable_statekeys=false`: [5](#0-4) 

The configuration sanitizer only enforces that internal indexer cannot be enabled without sharding, but doesn't enforce the reverse - that sharding requires `enable_statekeys` for resource APIs to function: [6](#0-5) 

The storage documentation explicitly states this requirement: [7](#0-6) 

## Impact Explanation

This issue does **not** meet the security vulnerability criteria. It is a **configuration validation bug** with the following characteristics:

- **No consensus impact**: The blockchain continues to operate normally
- **No funds at risk**: No possibility of theft, minting, or freezing
- **No security breach**: No access control, authentication, or authorization bypass
- **Operational issue only**: APIs fail with proper error handling, not crashes

The errors are returned correctly to clients (not silently failing or returning incorrect data). This is fundamentally an operational/configuration problem, not a security vulnerability.

## Likelihood Explanation

While the likelihood of misconfiguration is moderate (operators might deploy with sharding enabled but forget to enable `enable_statekeys`), this does not constitute an exploitable attack surface. There is no attacker involvement - it's purely operator error that the sanitizer should catch but doesn't.

## Recommendation

Add validation in the `InternalIndexerDBConfig` sanitizer to enforce the requirement:

```rust
impl ConfigSanitizer for InternalIndexerDBConfig {
    fn sanitize(
        node_config: &NodeConfig,
        _node_type: NodeType,
        _chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();
        let config = node_config.indexer_db_config;

        // Shouldn't turn on internal indexer for db without sharding
        if !node_config.storage.rocksdb_configs.enable_storage_sharding
            && config.is_internal_indexer_db_enabled()
        {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "Don't turn on internal indexer db if DB sharding is off".into(),
            ));
        }

        // NEW: Enforce enable_statekeys when sharding is enabled
        if node_config.storage.rocksdb_configs.enable_storage_sharding
            && !config.enable_statekeys
        {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "enable_statekeys must be true when storage sharding is enabled for resource APIs to function".into(),
            ));
        }

        Ok(())
    }
}
```

## Proof of Concept

This is a configuration validation issue, not a security vulnerability. A "proof of concept" would simply be:

1. Configure a node with `enable_storage_sharding: true` and `enable_statekeys: false`
2. Start the node (passes all validation)
3. Query `GET /v1/accounts/0x1/resources`
4. Observe 500 Internal Server Error with message about internal indexer not enabled

**However, this does not constitute a security vulnerability per the strict validation criteria.**

---

## **Final Assessment**

After rigorous analysis, this issue **DOES NOT** meet the extremely high bar for a valid security vulnerability:

❌ Not exploitable by unprivileged attacker (requires operator misconfiguration)  
❌ Does not break critical security invariants (consensus, funds, access control)  
❌ Does not meet severity criteria (no funds, availability attack, or crashes)  
❌ No attack path - purely operational/configuration issue  

**Classification**: Configuration validation bug requiring improvement, but **NOT** a security vulnerability eligible for bug bounty.

### Citations

**File:** api/src/context.rs (L470-496)
```rust
    pub fn get_resources_by_pagination(
        &self,
        address: AccountAddress,
        prev_state_key: Option<&StateKey>,
        version: u64,
        limit: u64,
    ) -> Result<(Vec<(StructTag, Vec<u8>)>, Option<StateKey>)> {
        let account_iter = if !db_sharding_enabled(&self.node_config) {
            Box::new(
                self.db
                    .get_prefixed_state_value_iterator(
                        &StateKeyPrefix::from(address),
                        prev_state_key,
                        version,
                    )?
                    .map(|item| item.map_err(|err| anyhow!(err.to_string()))),
            )
        } else {
            self.indexer_reader
                .as_ref()
                .ok_or_else(|| format_err!("Indexer reader doesn't exist"))?
                .get_prefixed_state_value_iterator(
                    &StateKeyPrefix::from(address),
                    prev_state_key,
                    version,
                )?
        };
```

**File:** storage/indexer/src/indexer_reader.rs (L140-166)
```rust
    fn get_prefixed_state_value_iterator(
        &self,
        key_prefix: &StateKeyPrefix,
        cursor: Option<&StateKey>,
        ledger_version: Version,
    ) -> anyhow::Result<Box<dyn Iterator<Item = anyhow::Result<(StateKey, StateValue)>> + '_>> {
        if let Some(db_indexer_reader) = &self.db_indexer_reader {
            if db_indexer_reader.indexer_db.statekeys_enabled() {
                return Ok(Box::new(
                    db_indexer_reader
                        .get_prefixed_state_value_iterator(key_prefix, cursor, ledger_version)
                        .map_err(|err| {
                            anyhow!(format!(
                                "failed to get prefixed state value iterator {}",
                                err
                            ))
                        })?,
                )
                    as Box<
                        dyn Iterator<Item = anyhow::Result<(StateKey, StateValue)>>,
                    >);
            } else {
                anyhow::bail!("Internal statekeys index is not enabled")
            }
        }
        anyhow::bail!("DB indexer reader is not available")
    }
```

**File:** api/src/accounts.rs (L448-471)
```rust
    pub fn resources(self, accept_type: &AcceptType) -> BasicResultWith404<Vec<MoveResource>> {
        let max_account_resources_page_size = self.context.max_account_resources_page_size();
        let (resources, next_state_key) = self
            .context
            .get_resources_by_pagination(
                self.address.into(),
                self.start.as_ref(),
                self.ledger_version,
                // Just use the max as the default
                determine_limit(
                    self.limit,
                    max_account_resources_page_size,
                    max_account_resources_page_size,
                    &self.latest_ledger_info,
                )? as u64,
            )
            .context("Failed to get resources from storage")
            .map_err(|err| {
                BasicErrorWith404::internal_with_code(
                    err,
                    AptosErrorCode::InternalError,
                    &self.latest_ledger_info,
                )
            })?;
```

**File:** config/src/config/storage_config.rs (L664-668)
```rust
            if (chain_id.is_testnet() || chain_id.is_mainnet())
                && config_yaml["rocksdb_configs"]["enable_storage_sharding"].as_bool() != Some(true)
            {
                panic!("Storage sharding (AIP-97) is not enabled in node config. Please follow the guide to migration your node, and set storage.rocksdb_configs.enable_storage_sharding to true explicitly in your node config. https://aptoslabs.notion.site/DB-Sharding-Migration-Public-Full-Nodes-1978b846eb7280b29f17ceee7d480730");
            }
```

**File:** config/src/config/internal_indexer_db_config.rs (L69-80)
```rust
impl Default for InternalIndexerDBConfig {
    fn default() -> Self {
        Self {
            enable_transaction: false,
            enable_event: false,
            enable_event_v2_translation: false,
            event_v2_translation_ignores_below_version: 0,
            enable_statekeys: false,
            batch_size: 10_000,
        }
    }
}
```

**File:** config/src/config/internal_indexer_db_config.rs (L82-103)
```rust
impl ConfigSanitizer for InternalIndexerDBConfig {
    fn sanitize(
        node_config: &NodeConfig,
        _node_type: NodeType,
        _chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();
        let config = node_config.indexer_db_config;

        // Shouldn't turn on internal indexer for db without sharding
        if !node_config.storage.rocksdb_configs.enable_storage_sharding
            && config.is_internal_indexer_db_enabled()
        {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "Don't turn on internal indexer db if DB sharding is off".into(),
            ));
        }

        Ok(())
    }
}
```

**File:** storage/README.md (L164-176)
```markdown
Account based resource APIs
* /accounts/{address}/modules
* /accounts/{address}/resources

The internal indexer is configured as below.
The batch size is used to chunk the transactions to smaller batches before writting to internal indexer DB.
```
indexer_db_config:
    enable_transaction: true // this is required for account based transaction API
    enable_event: true // this is required for account based event APIs
    enable_statekeys: true // this is required for account based resource APIs
    batch_size: 10000
```
```
