# Audit Report

## Title
Configuration Sanitizer Bypass Allows Unauthenticated Admin Service on Mainnet

## Summary
The `skip_config_sanitizer` flag in `NodeStartupConfig` can be set by node operators through their YAML configuration file, bypassing all configuration sanitization checks including the critical mainnet authentication requirement for the admin service. This allows nodes to start with unauthenticated admin service endpoints exposed on mainnet, violating a fundamental security control.

## Finding Description

The admin service sanitizer enforces that authentication must be enabled when the admin service runs on mainnet networks. [1](#0-0) 

However, the entire config sanitization framework can be bypassed through a user-controllable flag. [2](#0-1) 

The `skip_config_sanitizer` field is part of `NodeStartupConfig`, which is a public, serde-deserializable field in the main `NodeConfig` struct. [3](#0-2) [4](#0-3) 

When a mainnet node operator creates a configuration file with:
```yaml
node_startup:
  skip_config_sanitizer: true
admin_service:
  enabled: true
  authentication_configs: []
```

The node will:
1. Successfully load and deserialize the configuration
2. Skip all sanitization checks due to the early return
3. Start with the admin service running without authentication
4. Expose sensitive debugging endpoints to unauthenticated network access

The admin service exposes highly sensitive endpoints including CPU profiling, thread dumps, consensus database access, quorum store state, and mempool information. [5](#0-4) 

Authentication is checked at the handler level, where empty authentication configs grant automatic access. [6](#0-5) 

## Impact Explanation

This vulnerability meets **High Severity** criteria per the Aptos bug bounty program:

1. **Validator node slowdowns**: An attacker can repeatedly invoke CPU profiling and thread dump endpoints to degrade validator performance
2. **API crashes**: Heavy profiling or database dump requests can exhaust resources and crash the admin service
3. **Significant protocol violations**: Bypasses a mandatory security control specifically designed to protect mainnet validators

The exposed endpoints allow attackers to:
- Extract consensus state and timing information for consensus analysis attacks
- Profile CPU usage patterns to identify performance vulnerabilities  
- Dump memory allocation data revealing internal state
- Monitor mempool state for transaction ordering insights
- Cause resource exhaustion through repeated heavy queries

While this requires operator misconfiguration to expose the vulnerability, once exposed, any network-level attacker can exploit the unauthenticated endpoints.

## Likelihood Explanation

**Medium likelihood**:

The vulnerability requires the node operator to explicitly set `skip_config_sanitizer: true` in their configuration. However:

1. Documentation does not clearly warn about security implications of this flag
2. Operators debugging issues may enable it without understanding the risks
3. The flag exists in production configuration structures without clear "testing only" annotations
4. No runtime checks prevent setting this flag on mainnet networks

A test demonstrating that this flag intentionally bypasses security checks exists in the codebase. [7](#0-6) 

## Recommendation

Implement defense-in-depth by preventing sanitizer bypass on production networks:

```rust
impl ConfigSanitizer for NodeConfig {
    fn sanitize(
        node_config: &NodeConfig,
        node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        // Prevent skipping sanitization on mainnet
        if node_config.node_startup.skip_config_sanitizer {
            if let Some(chain_id) = chain_id {
                if chain_id.is_mainnet() {
                    return Err(Error::ConfigSanitizerFailed(
                        "NodeConfigSanitizer".to_string(),
                        "Cannot skip config sanitization on mainnet networks".to_string(),
                    ));
                }
            }
        }
        
        // If config sanitization is disabled on non-mainnet, allow it
        if node_config.node_startup.skip_config_sanitizer {
            return Ok(());
        }

        // Continue with existing sanitization...
```

Alternatively, remove `skip_config_sanitizer` from the serde-deserializable configuration entirely, making it a compile-time or environment-variable controlled flag for development only.

## Proof of Concept

Create a mainnet node configuration file `mainnet_bad_config.yaml`:

```yaml
base:
  role: "validator"
  data_dir: "/opt/aptos/data"
  waypoint:
    from_config: "0:0x0000000000000000000000000000000000000000000000000000000000000000"

node_startup:
  skip_config_sanitizer: true

admin_service:
  enabled: true
  address: "0.0.0.0"
  port: 9102
  authentication_configs: []

consensus:
  # ... other required fields
```

Load and start a node with this configuration:

```bash
# Node will start successfully despite invalid mainnet configuration
aptos-node -f mainnet_bad_config.yaml
```

From any machine with network access:

```bash
# Access unauthenticated admin endpoints
curl http://validator-ip:9102/profilez
curl http://validator-ip:9102/threadz  
curl http://validator-ip:9102/debug/consensus/consensusdb
curl http://validator-ip:9102/malloc/stats
```

All requests succeed without authentication, exposing sensitive validator internals on a production mainnet network.

---

**Notes:**

This vulnerability exists as a design flaw in the configuration sanitization framework. The `skip_config_sanitizer` flag was likely intended for development and testing but remains accessible in production configuration schemas without adequate safeguards. While exploitation requires operator misconfiguration, the subsequent exposure allows unauthenticated network-level attacks on critical validator infrastructure, making this a significant security concern for mainnet deployments.

### Citations

**File:** config/src/config/admin_service_config.rs (L67-77)
```rust
        if node_config.admin_service.enabled == Some(true) {
            if let Some(chain_id) = chain_id {
                if chain_id.is_mainnet()
                    && node_config.admin_service.authentication_configs.is_empty()
                {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "Must enable authentication for AdminService on mainnet.".into(),
                    ));
                }
            }
```

**File:** config/src/config/config_sanitizer.rs (L45-48)
```rust
        // If config sanitization is disabled, don't do anything!
        if node_config.node_startup.skip_config_sanitizer {
            return Ok(());
        }
```

**File:** config/src/config/config_sanitizer.rs (L212-239)
```rust
    fn test_disable_config_sanitizer() {
        // Create a default node config (with sanitization enabled)
        let mut node_config = NodeConfig::default();

        // Set a bad node config for mainnet
        node_config.execution.paranoid_hot_potato_verification = false;

        // Sanitize the config and verify the sanitizer fails
        let error =
            NodeConfig::sanitize(&node_config, NodeType::Validator, Some(ChainId::mainnet()))
                .unwrap_err();
        assert!(matches!(error, Error::ConfigSanitizerFailed(_, _)));

        // Create a node config with the sanitizer disabled
        let mut node_config = NodeConfig {
            node_startup: NodeStartupConfig {
                skip_config_sanitizer: true,
                ..Default::default()
            },
            ..Default::default()
        };

        // Set a bad node config for mainnet
        node_config.execution.paranoid_hot_potato_verification = false;

        // Sanitize the config and verify the sanitizer passes
        NodeConfig::sanitize(&node_config, NodeType::Validator, Some(ChainId::mainnet())).unwrap();
    }
```

**File:** config/src/config/node_startup_config.rs (L6-11)
```rust
#[derive(Clone, Copy, Debug, Deserialize, PartialEq, Eq, Serialize)]
#[serde(default, deny_unknown_fields)]
pub struct NodeStartupConfig {
    pub skip_config_optimizer: bool, // Whether or not to skip the config optimizer at startup
    pub skip_config_sanitizer: bool, // Whether or not to skip the config sanitizer at startup
}
```

**File:** config/src/config/node_config.rs (L75-75)
```rust
    pub node_startup: NodeStartupConfig,
```

**File:** crates/aptos-admin-service/src/server/mod.rs (L154-181)
```rust
        let mut authenticated = false;
        if context.config.authentication_configs.is_empty() {
            authenticated = true;
        } else {
            for authentication_config in &context.config.authentication_configs {
                match authentication_config {
                    AuthenticationConfig::PasscodeSha256(passcode_sha256) => {
                        let query = req.uri().query().unwrap_or("");
                        let query_pairs: HashMap<_, _> =
                            url::form_urlencoded::parse(query.as_bytes()).collect();
                        let passcode: Option<String> =
                            query_pairs.get("passcode").map(|p| p.to_string());
                        if let Some(passcode) = passcode {
                            if sha256::digest(passcode) == *passcode_sha256 {
                                authenticated = true;
                            }
                        }
                    },
                }
            }
        };

        if !authenticated {
            return Ok(reply_with_status(
                StatusCode::NETWORK_AUTHENTICATION_REQUIRED,
                format!("{} endpoint requires authentication.", req.uri().path()),
            ));
        }
```

**File:** crates/aptos-admin-service/src/server/mod.rs (L183-243)
```rust
        match (req.method().clone(), req.uri().path()) {
            #[cfg(target_os = "linux")]
            (hyper::Method::GET, "/profilez") => handle_cpu_profiling_request(req).await,
            #[cfg(target_os = "linux")]
            (hyper::Method::GET, "/threadz") => handle_thread_dump_request(req).await,
            #[cfg(unix)]
            (hyper::Method::GET, "/malloc/stats") => {
                malloc::handle_malloc_stats_request(context.config.malloc_stats_max_len)
            },
            #[cfg(unix)]
            (hyper::Method::GET, "/malloc/dump_profile") => malloc::handle_dump_profile_request(),
            (hyper::Method::GET, "/debug/consensus/consensusdb") => {
                let consensus_db = context.consensus_db.read().clone();
                if let Some(consensus_db) = consensus_db {
                    consensus::handle_dump_consensus_db_request(req, consensus_db).await
                } else {
                    Ok(reply_with_status(
                        StatusCode::NOT_FOUND,
                        "Consensus db is not available.",
                    ))
                }
            },
            (hyper::Method::GET, "/debug/consensus/quorumstoredb") => {
                let quorum_store_db = context.quorum_store_db.read().clone();
                if let Some(quorum_store_db) = quorum_store_db {
                    consensus::handle_dump_quorum_store_db_request(req, quorum_store_db).await
                } else {
                    Ok(reply_with_status(
                        StatusCode::NOT_FOUND,
                        "Quorum store db is not available.",
                    ))
                }
            },
            (hyper::Method::GET, "/debug/consensus/block") => {
                let consensus_db = context.consensus_db.read().clone();
                let quorum_store_db = context.quorum_store_db.read().clone();
                if let Some(consensus_db) = consensus_db
                    && let Some(quorum_store_db) = quorum_store_db
                {
                    consensus::handle_dump_block_request(req, consensus_db, quorum_store_db).await
                } else {
                    Ok(reply_with_status(
                        StatusCode::NOT_FOUND,
                        "Consensus db and/or quorum store db is not available.",
                    ))
                }
            },
            (hyper::Method::GET, "/debug/mempool/parking-lot/addresses") => {
                let mempool_client_sender = context.mempool_client_sender.read().clone();
                if let Some(mempool_client_sender) = mempool_client_sender {
                    mempool::mempool_handle_parking_lot_address_request(req, mempool_client_sender)
                        .await
                } else {
                    Ok(reply_with_status(
                        StatusCode::NOT_FOUND,
                        "Mempool parking lot is not available.",
                    ))
                }
            },
            _ => Ok(reply_with_status(StatusCode::NOT_FOUND, "Not found.")),
        }
```
