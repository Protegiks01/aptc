# Audit Report

## Title
Unmetered UTF-8 Validation During Transaction Argument Construction Enables Validator CPU Griefing Attack

## Summary
Validators perform O(n) UTF-8 validation on string arguments during transaction argument construction without charging gas. Attackers can submit transactions with maximum-size strings (up to ~60KB for regular transactions, ~900KB for governance transactions) that fail later in execution, forcing validators to waste CPU time on unmetered validation work.

## Finding Description

The vulnerability exists in the transaction argument validation flow where string arguments are constructed before transaction execution. When a transaction includes `string::String` arguments, the system validates UTF-8 encoding during argument deserialization, but this validation is not metered.

**Transaction Execution Flow:**

1. Transaction passes signature validation
2. Transaction size is checked against limits (64KB for regular, 1MB for governance)
3. Prologue runs and verifies gas balance
4. **Argument construction begins** (this is where the vulnerability occurs)
5. For each `String` argument, UTF-8 validation is performed
6. Transaction execution begins with metered gas

The critical issue is at step 4-5. The UTF-8 validation code path: [1](#0-0) 

This code performs `std::str::from_utf8(&arg)` validation, which is O(n) in the string length, without charging any gas. The developers acknowledged this issue: [2](#0-1) 

**Size Limits:**

The maximum string size per argument is 1MB: [3](#0-2) 

Transaction size limits are: [4](#0-3) 

**Attack Scenario:**

1. Attacker submits a transaction with a ~50KB string argument (fits within 64KB transaction limit after BCS encoding overhead)
2. Transaction passes mempool validation and enters consensus
3. During block execution, prologue runs and gas balance check passes
4. Argument construction phase begins - UTF-8 validation runs on the 50KB string **without charging gas**
5. Transaction execution begins and fails (e.g., due to `abort`, `assert`, or intentional revert)
6. Validator has wasted CPU cycles validating 50KB of UTF-8 without compensation

The attacker can amplify this by:
- Submitting many such transactions in rapid succession
- Using governance transaction limits (1MB) for even larger strings
- Including multiple string arguments per transaction
- Using `vector<String>` arguments (unlimited string constructors allowed)

This breaks the **Resource Limits** invariant: "All operations must respect gas, storage, and computational limits."

## Impact Explanation

This is a **Medium Severity** vulnerability per Aptos bug bounty criteria, specifically qualifying as "Validator node slowdowns."

**Quantified Impact:**

- **CPU Waste per Transaction**: For a 50KB string, UTF-8 validation requires scanning every byte once (50,000 operations)
- **Amplification**: Attacker can submit hundreds of such transactions per second
- **Cost to Attacker**: Only transaction fees for failed transactions (minimal, as execution fails early)
- **Cost to Validators**: Wasted CPU cycles on every validator node processing the block

While this doesn't cause consensus failures or fund loss, it creates an asymmetric griefing attack where the attacker's cost (failed transaction fees) is much lower than the validators' cost (CPU time). Over sustained periods, this could degrade validator performance and increase block processing time.

## Likelihood Explanation

**Likelihood: HIGH**

This vulnerability is highly likely to be exploited because:

1. **Low Barrier to Entry**: Any user can submit transactions with string arguments
2. **No Special Permissions**: No validator access or governance participation required
3. **Trivial to Exploit**: Simply construct transactions with large string arguments
4. **Difficult to Detect**: Appears as normal transaction submission
5. **Economically Viable**: Failed transaction fees are minimal compared to CPU cost imposed

The only mitigating factor is that transaction size limits (64KB) cap the maximum damage per transaction, but attackers can submit many transactions.

## Recommendation

**Immediate Fix:** Charge gas for UTF-8 validation during argument construction.

Modify the `validate_and_construct` function to charge gas based on the string length before performing UTF-8 validation:

```rust
if constructor.func_name.as_str() == "utf8" {
    // ... existing error handling ...
    
    let len = get_len(cursor)?;
    
    // ADD THIS: Charge gas for UTF-8 validation
    // Use similar rate to native_check_utf8 in string.rs
    let validation_cost = InternalGas::new(BASE_COST) 
        + InternalGasPerByte::new(PER_BYTE_COST) * NumBytes::new(len as u64);
    gas_meter.charge_gas(validation_cost)?;
    
    if cursor.position().checked_add(len as u64)
        .is_none_or(|l| l > initial_cursor_len as u64) {
        // ... existing validation ...
    }
    
    let mut arg = vec![];
    read_n_bytes(len, cursor, &mut arg)?;
    std::str::from_utf8(&arg).map_err(|_| constructor_error())?;
    // ... rest of function ...
}
```

**Long-term Improvements:**

1. Implement comprehensive gas metering for all argument construction operations as noted in the TODO
2. Consider caching validated strings if they appear multiple times
3. Add stricter limits on total argument size per transaction [5](#0-4) 

## Proof of Concept

```rust
// Add to aptos-move/e2e-move-tests/src/tests/string_args.rs

#[test]
fn test_unmetered_utf8_validation_griefing() {
    use aptos_types::account_address::AccountAddress;
    use move_core_types::language_storage::ModuleId;
    
    // Create a large valid UTF-8 string (50KB)
    let large_string = "a".repeat(50_000);
    let large_string_bytes = large_string.as_bytes();
    
    // BCS encode as String constructor argument
    let mut arg = vec![];
    // Encode length as ULEB128
    let mut len = large_string_bytes.len();
    while len >= 128 {
        arg.push((len | 128) as u8);
        len >>= 7;
    }
    arg.push(len as u8);
    // Append string bytes
    arg.extend_from_slice(large_string_bytes);
    
    // Submit transaction that will fail but forces UTF-8 validation
    let mut h = MoveHarness::new();
    
    // Deploy a module with entry function taking String
    let account = h.new_account_at(AccountAddress::from_hex_literal("0xcafe").unwrap());
    let code = r#"
        module 0xcafe::test {
            use std::string::String;
            
            public entry fun process_string(s: String) {
                // Intentionally abort to waste validator CPU
                abort 1
            }
        }
    "#;
    h.run_module_compilation(&account, compile_source_module(code));
    
    // Submit transaction with large string argument
    let payload = aptos_types::transaction::TransactionPayload::EntryFunction(
        EntryFunction::new(
            ModuleId::new(
                AccountAddress::from_hex_literal("0xcafe").unwrap(),
                Identifier::new("test").unwrap(),
            ),
            Identifier::new("process_string").unwrap(),
            vec![],
            vec![arg], // Large string argument
        )
    );
    
    let txn = account.create_user_txn(payload);
    
    // Transaction will fail due to abort, but validator has already
    // performed unmetered UTF-8 validation on 50KB string
    let output = h.run_transaction(txn);
    
    // Verify transaction failed but UTF-8 validation occurred
    assert!(output.status().is_discarded() || output.status().is_failed());
    
    // The validator wasted CPU time on UTF-8 validation without charging gas
}
```

## Notes

The vulnerability is exacerbated by the special handling of the `utf8` constructor to support `vector<String>` arguments. The developers explicitly exempted strings from the `max_invocations` limit to maintain compatibility, but did not add gas metering as compensation: [6](#0-5) 

For comparison, when `string::utf8()` is called during actual Move execution, gas IS charged appropriately: [7](#0-6) 

The inconsistency creates an exploitable gap where argument construction (pre-execution) is unmetered while normal execution (post-prologue) is properly metered.

### Citations

**File:** aptos-move/aptos-vm/src/verifier/transaction_arg_validation.rs (L242-242)
```rust
    // Perhaps in a future we should do proper gas metering here
```

**File:** aptos-move/aptos-vm/src/verifier/transaction_arg_validation.rs (L429-468)
```rust
    // HACK mitigation of performance attack
    // To maintain compatibility with vector<string> or so on, we need to allow unlimited strings.
    // So we do not count the string constructor against the max_invocations, instead we
    // shortcut the string case to avoid the performance attack.
    if constructor.func_name.as_str() == "utf8" {
        let constructor_error = || {
            // A slight hack, to prevent additional piping of the feature flag through all
            // function calls. We know the feature is active when more structs then just strings are
            // allowed.
            let are_struct_constructors_enabled = allowed_structs.len() > 1;
            if are_struct_constructors_enabled {
                PartialVMError::new(StatusCode::ABORTED)
                    .with_sub_status(1)
                    .at_code_offset(FunctionDefinitionIndex::new(0), 0)
                    .finish(Location::Module(constructor.module_id.clone()))
                    .into_vm_status()
            } else {
                VMStatus::error(StatusCode::FAILED_TO_DESERIALIZE_ARGUMENT, None)
            }
        };
        // Short cut for the utf8 constructor, which is a special case.
        let len = get_len(cursor)?;
        if cursor
            .position()
            .checked_add(len as u64)
            .is_none_or(|l| l > initial_cursor_len as u64)
        {
            // We need to make sure we do not allocate more bytes than
            // needed.
            return Err(VMStatus::error(
                StatusCode::FAILED_TO_DESERIALIZE_ARGUMENT,
                Some("String argument is too long".to_string()),
            ));
        }

        let mut arg = vec![];
        read_n_bytes(len, cursor, &mut arg)?;
        std::str::from_utf8(&arg).map_err(|_| constructor_error())?;
        return bcs::to_bytes(&arg)
            .map_err(|_| VMStatus::error(StatusCode::FAILED_TO_DESERIALIZE_ARGUMENT, None));
```

**File:** aptos-move/aptos-vm/src/verifier/transaction_arg_validation.rs (L557-557)
```rust
    const MAX_NUM_BYTES: usize = 1_000_000;
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L73-81)
```rust
            max_transaction_size_in_bytes: NumBytes,
            "max_transaction_size_in_bytes",
            64 * 1024
        ],
        [
            max_transaction_size_in_bytes_gov: NumBytes,
            { RELEASE_V1_13.. => "max_transaction_size_in_bytes.gov" },
            1024 * 1024
        ],
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L993-1002)
```rust
            let args = dispatch_transaction_arg_validation!(
                session,
                &loader,
                gas_meter,
                traversal_context,
                serialized_signers,
                entry_fn.args().to_vec(),
                &function,
                self.features().is_enabled(FeatureFlag::STRUCT_CONSTRUCTORS),
            )?;
```

**File:** third_party/move/move-stdlib/src/natives/string.rs (L39-54)
```rust
fn native_check_utf8(
    gas_params: &CheckUtf8GasParameters,
    _context: &mut NativeContext,
    _ty_args: &[Type],
    mut args: VecDeque<Value>,
) -> PartialVMResult<NativeResult> {
    debug_assert!(args.len() == 1);
    let s_arg = pop_arg!(args, VectorRef);
    let s_ref = s_arg.as_bytes_ref();
    let ok = std::str::from_utf8(s_ref.as_slice()).is_ok();
    // TODO: extensible native cost tables

    let cost = gas_params.base + gas_params.per_byte * NumBytes::new(s_ref.as_slice().len() as u64);

    NativeResult::map_partial_vm_result_one(cost, Ok(Value::bool(ok)))
}
```
