# Audit Report

## Title
Mainnet Security Check Bypass via Silent Chain ID Extraction Failure

## Summary
A critical error handling inconsistency in `node_config_loader.rs` allows mainnet validator nodes to start with dangerous configurations that should be forbidden. When chain ID extraction fails (returning `Error::InvariantViolation`), the error is silently suppressed, causing all mainnet-specific security sanitizers to be bypassed.

## Finding Description

The vulnerability exists in the interaction between three functions in the node configuration loading process: [1](#0-0) 

The `get_chain_id()` function returns `Error::InvariantViolation` when it cannot extract the chain ID from the genesis transaction (missing file, corrupted data, wrong format, deserialization failure). [2](#0-1) 

However, `extract_node_type_and_chain_id()` catches ALL errors from `get_chain_id()` and silently suppresses them via `match/Err` pattern, printing only to stdout and returning `chain_id = None`. This is fundamentally different from how `Error::Yaml` is handled - that error type propagates up and causes node startup to fail: [3](#0-2) 

The critical issue is that when `chain_id = None`, **all mainnet-specific security checks are bypassed** because they use the pattern `if let Some(chain_id) = chain_id { if chain_id.is_mainnet() { ... } }`:

**Failpoints check bypassed:** [4](#0-3) 

**Paranoid verification checks bypassed:** [5](#0-4) 

**Safety rules validation bypassed:** [6](#0-5) 

**Consensus test mode check bypassed:** [7](#0-6) 

### Attack Scenario

1. Operator deploys a mainnet validator node with misconfigured settings in `node.yaml`: `paranoid_hot_potato_verification: false`, `paranoid_type_verification: false`, `failpoints` enabled, or in-memory storage backend
2. Genesis file is missing, corrupted, or points to an invalid path (due to misconfiguration, file system issues, or malicious modification)
3. During node startup, `get_chain_id()` fails with `Error::InvariantViolation`
4. Error is caught and suppressed in `extract_node_type_and_chain_id()`, returning `chain_id = None`
5. All mainnet security sanitizers see `None` and skip their mainnet-specific checks
6. Node successfully starts and joins mainnet with dangerous configurations
7. Validator operates with:
   - **Disabled paranoid verification** → potential consensus divergence if VM bugs exist
   - **In-memory storage** → data loss on crash, no persistence guarantees
   - **Test configurations enabled** → debugging/testing code paths active in production
   - **Failpoints enabled** → attackers can trigger intentional failures

The node will still apply genesis during DB bootstrap if needed: [8](#0-7) 

But the missing genesis only triggers an info log, not a failure, allowing the node to continue with existing database state while bypassing security checks.

## Impact Explanation

**Critical Severity** - This vulnerability can lead to:

1. **Consensus Safety Violations**: Disabling `paranoid_hot_potato_verification` and `paranoid_type_verification` removes critical Move VM runtime checks that ensure deterministic execution across all validators. If VM bugs exist, different validators could compute different state roots for the same block, violating the fundamental consensus invariant.

2. **Validator Availability Compromise**: Using in-memory storage backends on mainnet validators means all safety rules state is lost on crash/restart, potentially causing validators to equivocate or violate BFT safety properties.

3. **Production Debugging Features Active**: Test configurations and failpoints on mainnet create attack surfaces for causing intentional validator failures or triggering untested code paths.

This meets **Critical Severity** criteria per Aptos Bug Bounty: "Consensus/Safety violations" and "Significant protocol violations."

## Likelihood Explanation

**High Likelihood** - This can occur through:

1. **Operator Misconfiguration**: Genesis file path incorrectly set or file accidentally deleted during deployment
2. **Config Template Issues**: Deployment scripts or templates with wrong genesis paths
3. **File System Corruption**: Genesis blob corruption due to disk issues
4. **Supply Chain Attack**: Malicious config templates distributed to operators

The vulnerability is particularly concerning because:
- The error is **silently suppressed** with only stdout logging (no crash, no clear alert)
- Operators may not realize mainnet checks are being bypassed
- The node appears to start successfully and join the network
- No obvious indicators that security invariants are violated

## Recommendation

The error handling must be made consistent - `Error::InvariantViolation` from `get_chain_id()` should **not** be silently suppressed. The fix should:

1. **Fail fast when chain ID cannot be determined during mainnet deployment:**

```rust
fn extract_node_type_and_chain_id(node_config: &NodeConfig) -> Result<(NodeType, Option<ChainId>), Error> {
    let node_type = NodeType::extract_from_config(node_config);
    
    // Try to get the chain ID from the genesis transaction
    match get_chain_id(node_config) {
        Ok(chain_id) => Ok((node_type, Some(chain_id))),
        Err(error) => {
            // Log the error for debugging
            eprintln!("Failed to extract the chain ID from the genesis transaction: {:?}", error);
            
            // For production nodes, this should be a hard failure
            // Only allow None for test/local deployments
            if should_require_chain_id(node_config) {
                Err(error)
            } else {
                println!("Continuing without chain ID (non-production deployment)");
                Ok((node_type, None))
            }
        }
    }
}

fn should_require_chain_id(node_config: &NodeConfig) -> bool {
    // Require chain ID for validators and nodes with genesis file configured
    node_config.base.role.is_validator() || 
    !node_config.execution.genesis_file_location.as_os_str().is_empty()
}
```

2. **Alternative: Make mainnet checks mandatory even when chain_id is None:**

```rust
// In config_sanitizer.rs
fn sanitize_failpoints_config(
    node_config: &NodeConfig,
    _node_type: NodeType,
    chain_id: Option<ChainId>,
) -> Result<(), Error> {
    let sanitizer_name = FAILPOINTS_SANITIZER_NAME.to_string();
    let failpoints_enabled = are_failpoints_enabled();
    
    // If we cannot determine chain ID but failpoints are enabled,
    // fail safe by assuming this could be mainnet
    if chain_id.is_none() && failpoints_enabled {
        return Err(Error::ConfigSanitizerFailed(
            sanitizer_name,
            "Cannot verify chain ID, but failpoints are enabled. This is not allowed for safety.".into(),
        ));
    }
    
    // Original mainnet check
    if let Some(chain_id) = chain_id {
        if chain_id.is_mainnet() && failpoints_enabled {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "Failpoints are not supported on mainnet nodes!".into(),
            ));
        }
    }
    // ... rest of checks
}
```

Apply similar fail-safe logic to all mainnet-specific sanitizers.

## Proof of Concept

```rust
#[cfg(test)]
mod exploit_test {
    use super::*;
    use crate::config::{NodeConfig, RoleType, BaseConfig, ExecutionConfig};
    use std::path::PathBuf;
    
    #[test]
    fn test_mainnet_checks_bypassed_when_genesis_missing() {
        // Create a node config for a mainnet validator
        let mut node_config = NodeConfig {
            base: BaseConfig {
                role: RoleType::Validator,
                ..Default::default()
            },
            execution: ExecutionConfig {
                // Point to non-existent genesis file
                genesis_file_location: PathBuf::from("/nonexistent/genesis.blob"),
                // Disable paranoid checks (should be rejected on mainnet!)
                paranoid_hot_potato_verification: false,
                paranoid_type_verification: false,
                ..Default::default()
            },
            ..Default::default()
        };
        
        // Try to extract chain ID - should fail
        let result = get_chain_id(&node_config);
        assert!(result.is_err());
        assert!(matches!(result.unwrap_err(), Error::InvariantViolation(_)));
        
        // But extract_node_type_and_chain_id suppresses the error!
        let (node_type, chain_id) = extract_node_type_and_chain_id(&node_config);
        assert_eq!(node_type, NodeType::Validator);
        assert!(chain_id.is_none()); // Chain ID is None despite error!
        
        // Now sanitizers will skip mainnet checks
        // This should FAIL but doesn't because chain_id is None
        let sanitize_result = ExecutionConfig::sanitize(&node_config, node_type, chain_id);
        
        // VULNERABILITY: Sanitizer passes even though paranoid checks are disabled!
        assert!(sanitize_result.is_ok(), "Security checks bypassed!");
        
        // If we provide mainnet chain_id explicitly, it correctly fails
        let sanitize_with_mainnet = ExecutionConfig::sanitize(
            &node_config, 
            node_type, 
            Some(ChainId::mainnet())
        );
        assert!(sanitize_with_mainnet.is_err(), "Should fail with explicit mainnet chain_id");
    }
}
```

## Notes

This vulnerability demonstrates a critical principle: **error suppression must never weaken security guarantees**. The inconsistent handling between `Error::Yaml` (fails node startup) and `Error::InvariantViolation` (silently suppressed) creates a security bypass. All mainnet-specific sanitizers assume `chain_id = None` means "unknown/test environment" rather than "chain ID extraction failed on what might be mainnet," leading to fail-open behavior instead of fail-safe.

### Citations

**File:** config/src/config/node_config_loader.rs (L94-107)
```rust
fn get_local_config_yaml<P: AsRef<Path>>(node_config_path: P) -> Result<Value, Error> {
    // Read the file contents into a string
    let local_config_yaml = NodeConfig::read_config_file(&node_config_path)?;

    // Parse the file contents as a yaml value
    let local_config_yaml = serde_yaml::from_str(&local_config_yaml).map_err(|error| {
        Error::Yaml(
            "Failed to parse the node config file into a YAML value".into(),
            error,
        )
    })?;

    Ok(local_config_yaml)
}
```

**File:** config/src/config/node_config_loader.rs (L112-124)
```rust
fn extract_node_type_and_chain_id(node_config: &NodeConfig) -> (NodeType, Option<ChainId>) {
    // Get the node type from the node config
    let node_type = NodeType::extract_from_config(node_config);

    // Get the chain ID from the genesis transaction
    match get_chain_id(node_config) {
        Ok(chain_id) => (node_type, Some(chain_id)),
        Err(error) => {
            println!("Failed to extract the chain ID from the genesis transaction: {:?}! Continuing with None.", error);
            (node_type, None)
        },
    }
}
```

**File:** config/src/config/node_config_loader.rs (L158-198)
```rust
fn get_chain_id(node_config: &NodeConfig) -> Result<ChainId, Error> {
    // TODO: can we make this less hacky?

    // Load the genesis transaction from disk
    let genesis_txn = get_genesis_txn(node_config).ok_or_else(|| {
        Error::InvariantViolation("The genesis transaction was not found!".to_string())
    })?;

    // Extract the chain ID from the genesis transaction
    match genesis_txn {
        Transaction::GenesisTransaction(WriteSetPayload::Direct(change_set)) => {
            let chain_id_state_key = StateKey::on_chain_config::<ChainId>()?;

            // Get the write op from the write set
            let write_set_mut = change_set.clone().write_set().clone().into_mut();
            let write_op = write_set_mut.get(&chain_id_state_key).ok_or_else(|| {
                Error::InvariantViolation(
                    "The genesis transaction does not contain the write op for the chain id!"
                        .into(),
                )
            })?;

            // Extract the chain ID from the write op
            let write_op_bytes = write_op.bytes().ok_or_else(|| Error::InvariantViolation(
                "The genesis transaction does not contain the correct write op for the chain ID!".into(),
            ))?;
            let chain_id = ChainId::deserialize_into_config(write_op_bytes).map_err(|error| {
                Error::InvariantViolation(format!(
                    "Failed to deserialize the chain ID: {:?}",
                    error
                ))
            })?;

            Ok(chain_id)
        },
        _ => Err(Error::InvariantViolation(format!(
            "The genesis transaction has the incorrect type: {:?}!",
            genesis_txn
        ))),
    }
}
```

**File:** config/src/config/config_sanitizer.rs (L82-91)
```rust
    // Verify that failpoints are not enabled in mainnet
    let failpoints_enabled = are_failpoints_enabled();
    if let Some(chain_id) = chain_id {
        if chain_id.is_mainnet() && failpoints_enabled {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "Failpoints are not supported on mainnet nodes!".into(),
            ));
        }
    }
```

**File:** config/src/config/execution_config.rs (L167-183)
```rust
        if let Some(chain_id) = chain_id {
            if chain_id.is_mainnet() {
                if !execution_config.paranoid_hot_potato_verification {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "paranoid_hot_potato_verification must be enabled for mainnet nodes!"
                            .into(),
                    ));
                }
                if !execution_config.paranoid_type_verification {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "paranoid_type_verification must be enabled for mainnet nodes!".into(),
                    ));
                }
            }
        }
```

**File:** config/src/config/safety_rules_config.rs (L85-113)
```rust
        if let Some(chain_id) = chain_id {
            // Verify that the secure backend is appropriate for mainnet validators
            if chain_id.is_mainnet()
                && node_type.is_validator()
                && safety_rules_config.backend.is_in_memory()
            {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "The secure backend should not be set to in memory storage in mainnet!"
                        .to_string(),
                ));
            }

            // Verify that the safety rules service is set to local for optimal performance
            if chain_id.is_mainnet() && !safety_rules_config.service.is_local() {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    format!("The safety rules service should be set to local in mainnet for optimal performance! Given config: {:?}", &safety_rules_config.service)
                ));
            }

            // Verify that the safety rules test config is not enabled in mainnet
            if chain_id.is_mainnet() && safety_rules_config.test.is_some() {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "The safety rules test config should not be used in mainnet!".to_string(),
                ));
            }
        }
```

**File:** config/src/config/consensus_config.rs (L516-523)
```rust
        if let Some(chain_id) = chain_id {
            if chain_id.is_mainnet() && is_consensus_only_perf_test_enabled() {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "consensus-only-perf-test should not be enabled in mainnet!".to_string(),
                ));
            }
        }
```

**File:** aptos-node/src/storage.rs (L34-42)
```rust
    if let Some(genesis) = get_genesis_txn(node_config) {
        let ledger_info_opt =
            maybe_bootstrap::<AptosVMBlockExecutor>(db_rw, genesis, genesis_waypoint)
                .map_err(|err| anyhow!("DB failed to bootstrap {}", err))?;
        Ok(ledger_info_opt)
    } else {
        info ! ("Genesis txn not provided! This is fine only if you don't expect to apply it. Otherwise, the config is incorrect!");
        Ok(None)
    }
```
