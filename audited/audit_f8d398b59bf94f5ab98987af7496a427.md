# Audit Report

## Title
Empty Validator Set Causes Consensus Panic Through Unchecked Proposer Election Initialization

## Summary
The `RotatingProposer::new()` function in the consensus layer accepts an empty validator set without validation, causing an inevitable panic when `get_valid_proposer()` attempts a division-by-zero modulo operation. This can be triggered through governance proposals that set `minimum_stake` above all validators' current stakes, resulting in a total network halt requiring a hardfork to recover.

## Finding Description

The vulnerability exists in the proposer election mechanism and spans multiple layers of the Aptos stack:

**Root Cause:** The `RotatingProposer::new()` constructor does not validate that the `proposers` vector is non-empty. [1](#0-0) 

When `get_valid_proposer()` is called with an empty proposers vector, it performs a modulo operation that panics: [2](#0-1) 

**Attack Vector:** The vulnerability is triggered through the epoch transition process:

1. **Governance Update:** A governance proposal calls `update_required_stake()` with `minimum_stake` set higher than all validators' current stakes. The validation only checks `minimum_stake <= maximum_stake && maximum_stake > 0`: [3](#0-2) 

2. **Epoch Transition Filter:** During `on_new_epoch()`, validators are filtered by voting power. If all validators fall below `minimum_stake`, the active validator set becomes empty: [4](#0-3) 

3. **Propagation to Consensus:** The empty validator set flows through `ValidatorVerifier` creation (which accepts empty vectors): [5](#0-4) 

4. **Proposer Election Creation:** The `EpochManager` creates a `RotatingProposer` with an empty proposers vector: [6](#0-5) 

5. **Consensus Panic:** When the `RoundManager` processes any round event and calls `get_valid_proposer()`, the node crashes: [7](#0-6) 

Additionally, the `choose_leader()` function used for `FixedProposer` will also panic on an empty vector: [8](#0-7) 

## Impact Explanation

**Severity: CRITICAL** (up to $1,000,000 per Aptos Bug Bounty)

This vulnerability meets the **"Total loss of liveness/network availability"** and **"Non-recoverable network partition (requires hardfork)"** criteria:

- **Total Network Halt:** All consensus nodes crash when attempting to determine proposers for any round
- **No Automatic Recovery:** Nodes will continuously crash on restart until a hardfork updates the validator set
- **Chain Halt:** No blocks can be produced, no transactions can be processed
- **Economic Damage:** Complete network unavailability affecting all users, validators, and applications
- **Hardfork Required:** Recovery requires coordinated hardfork to restore valid validator set

## Likelihood Explanation

**Likelihood: Medium-Low**

**Preconditions:**
- Requires governance proposal execution (legitimate governance mechanism)
- Requires `minimum_stake` to be set higher than ALL validators' current stakes

**Scenarios:**
1. **Accidental Misconfiguration:** Governance proposal accidentally sets unrealistic `minimum_stake` (e.g., adding extra zeros)
2. **Malicious Governance Attack:** Compromised governance proposes extreme `minimum_stake` to halt network
3. **Edge Case in Validator Exit:** Multiple large validators unstake simultaneously while minimum increases

**Likelihood Assessment:**
- **Not Automatic:** Requires specific governance action
- **Realistic:** No technical barriers prevent this configuration
- **Human Error Prone:** Staking parameter updates are error-prone operations
- **High Impact:** Even low likelihood justified given catastrophic consequences

## Recommendation

**Immediate Fix:** Add validation in multiple layers:

**Layer 1 - Proposer Election Constructor:**
```rust
pub fn new(proposers: Vec<Author>, contiguous_rounds: u32) -> Self {
    assert!(
        !proposers.is_empty(),
        "Cannot create RotatingProposer with empty validator set"
    );
    Self {
        proposers,
        contiguous_rounds,
    }
}
```

**Layer 2 - Epoch Manager Validation:**
```rust
fn create_proposer_election(
    &self,
    epoch_state: &EpochState,
    onchain_config: &OnChainConsensusConfig,
) -> Arc<dyn ProposerElection + Send + Sync> {
    let proposers = epoch_state
        .verifier
        .get_ordered_account_addresses_iter()
        .collect::<Vec<_>>();
    
    assert!(
        !proposers.is_empty(),
        "Cannot start epoch with empty validator set"
    );
    
    // ... rest of function
}
```

**Layer 3 - Staking Configuration Validation (Defense in Depth):**
```move
public fun update_required_stake(
    aptos_framework: &signer,
    minimum_stake: u64,
    maximum_stake: u64,
) acquires StakingConfig, ValidatorSet {
    system_addresses::assert_aptos_framework(aptos_framework);
    validate_required_stake(minimum_stake, maximum_stake);
    
    // NEW: Ensure at least one validator meets the new minimum
    let validator_set = borrow_global<ValidatorSet>(@aptos_framework);
    let has_valid_validator = vector::any(&validator_set.active_validators, |v| {
        let v: &ValidatorInfo = v;
        v.voting_power >= minimum_stake
    });
    assert!(
        has_valid_validator,
        error::invalid_argument(EWOULD_CREATE_EMPTY_VALIDATOR_SET)
    );
    
    let staking_config = borrow_global_mut<StakingConfig>(@aptos_framework);
    staking_config.minimum_stake = minimum_stake;
    staking_config.maximum_stake = maximum_stake;
}
```

## Proof of Concept

```move
#[test_only]
module aptos_framework::empty_validator_set_poc {
    use aptos_framework::stake;
    use aptos_framework::staking_config;
    use aptos_framework::aptos_coin::AptosCoin;
    use aptos_framework::coin;
    use std::signer;

    #[test(aptos_framework = @0x1, validator1 = @0x123, validator2 = @0x456)]
    public entry fun test_empty_validator_set_causes_epoch_failure(
        aptos_framework: &signer,
        validator1: &signer,
        validator2: &signer,
    ) {
        // Setup: Initialize two validators with 100 stake each
        let (burn, mint) = aptos_coin::initialize_for_test(aptos_framework);
        
        stake::initialize_test_validator(
            validator1,
            100, // stake amount
            true,
            true
        );
        
        stake::initialize_test_validator(
            validator2,
            100, // stake amount
            true,
            true
        );

        // Attack: Governance sets minimum_stake above all validators' stakes
        // This passes validation (only checks min <= max)
        staking_config::update_required_stake(
            aptos_framework,
            10000, // minimum_stake >> 100 (all validators' stakes)
            100000 // maximum_stake
        );

        // Trigger: Next epoch transition filters out ALL validators
        // This would result in empty active_validators vector
        // In production, this propagates to consensus causing panic
        stake::end_epoch();
        
        // After this point, consensus would attempt to create RotatingProposer
        // with empty proposers vector, causing panic on first get_valid_proposer() call
        
        coin::destroy_burn_cap(burn);
        coin::destroy_mint_cap(mint);
    }
}
```

**Rust Unit Test Demonstrating Panic:**
```rust
#[test]
#[should_panic(expected = "attempt to calculate the remainder with a divisor of zero")]
fn test_empty_proposer_panic() {
    let empty_proposers = vec![];
    let proposer_election = RotatingProposer::new(empty_proposers, 1);
    // This will panic with division by zero
    let _ = proposer_election.get_valid_proposer(1);
}
```

## Notes

This vulnerability demonstrates a critical gap in defensive programming across the consensus stack. While governance proposals are the intended mechanism for updating staking parameters, the lack of validation creates a direct path from configuration update to consensus failure. The issue is particularly severe because:

1. **Silent Propagation:** Empty validator sets flow through multiple layers without triggering errors
2. **Late Failure:** The panic occurs during consensus operation, not during configuration
3. **Total Impact:** All nodes crash simultaneously, preventing any recovery mechanism
4. **No Automatic Detection:** The invalid configuration is only detected when consensus attempts to use it

The recommended fixes provide defense in depth at three critical layers, ensuring the invariant "validator set is non-empty" is enforced throughout the system.

### Citations

**File:** consensus/src/liveness/rotating_proposer_election.rs (L20-23)
```rust
pub fn choose_leader(peers: Vec<Author>) -> Author {
    // As it is just a tmp hack function, pick the min PeerId to be a proposer.
    peers.into_iter().min().expect("No trusted peers found!")
}
```

**File:** consensus/src/liveness/rotating_proposer_election.rs (L27-32)
```rust
    pub fn new(proposers: Vec<Author>, contiguous_rounds: u32) -> Self {
        Self {
            proposers,
            contiguous_rounds,
        }
    }
```

**File:** consensus/src/liveness/rotating_proposer_election.rs (L36-39)
```rust
    fn get_valid_proposer(&self, round: Round) -> Author {
        self.proposers
            [((round / u64::from(self.contiguous_rounds)) % self.proposers.len() as u64) as usize]
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/staking_config.move (L274-285)
```text
    public fun update_required_stake(
        aptos_framework: &signer,
        minimum_stake: u64,
        maximum_stake: u64,
    ) acquires StakingConfig {
        system_addresses::assert_aptos_framework(aptos_framework);
        validate_required_stake(minimum_stake, maximum_stake);

        let staking_config = borrow_global_mut<StakingConfig>(@aptos_framework);
        staking_config.minimum_stake = minimum_stake;
        staking_config.maximum_stake = maximum_stake;
    }
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1372-1401)
```text
        let next_epoch_validators = vector::empty();
        let (minimum_stake, _) = staking_config::get_required_stake(&config);
        let vlen = vector::length(&validator_set.active_validators);
        let total_voting_power = 0;
        let i = 0;
        while ({
            spec {
                invariant spec_validators_are_initialized(next_epoch_validators);
                invariant i <= vlen;
            };
            i < vlen
        }) {
            let old_validator_info = vector::borrow_mut(&mut validator_set.active_validators, i);
            let pool_address = old_validator_info.addr;
            let validator_config = borrow_global<ValidatorConfig>(pool_address);
            let stake_pool = borrow_global<StakePool>(pool_address);
            let new_validator_info = generate_validator_info(pool_address, stake_pool, *validator_config);

            // A validator needs at least the min stake required to join the validator set.
            if (new_validator_info.voting_power >= minimum_stake) {
                spec {
                    assume total_voting_power + new_validator_info.voting_power <= MAX_U128;
                };
                total_voting_power = total_voting_power + (new_validator_info.voting_power as u128);
                vector::push_back(&mut next_epoch_validators, new_validator_info);
            };
            i = i + 1;
        };

        validator_set.active_validators = next_epoch_validators;
```

**File:** types/src/validator_verifier.rs (L206-214)
```rust
    pub fn new(validator_infos: Vec<ValidatorConsensusInfo>) -> Self {
        let total_voting_power = sum_voting_power(&validator_infos);
        let quorum_voting_power = if validator_infos.is_empty() {
            0
        } else {
            total_voting_power * 2 / 3 + 1
        };
        Self::build_index(validator_infos, quorum_voting_power, total_voting_power)
    }
```

**File:** consensus/src/epoch_manager.rs (L292-298)
```rust
        let proposers = epoch_state
            .verifier
            .get_ordered_account_addresses_iter()
            .collect::<Vec<_>>();
        match &onchain_config.proposer_election_type() {
            ProposerElectionType::RotatingProposer(contiguous_rounds) => {
                Arc::new(RotatingProposer::new(proposers, *contiguous_rounds))
```

**File:** consensus/src/round_manager.rs (L428-430)
```rust
        let prev_proposer = self
            .proposer_election
            .get_valid_proposer(new_round.saturating_sub(1));
```
