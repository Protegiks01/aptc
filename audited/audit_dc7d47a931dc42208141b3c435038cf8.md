# Audit Report

## Title
Unbounded gas_price_to_burn Allows Governance to Eliminate Validator Fee Rewards, Breaking Economic Incentives

## Summary
The `gas_price_to_burn` parameter in the execution configuration lacks validation bounds, allowing governance to set it to values equal to or exceeding the minimum gas price (100 in production). This would reduce or eliminate validator fee rewards, breaking the critical economic incentive structure that ensures network security and liveness.

## Finding Description

The Aptos blockchain distributes transaction fees to validators using a two-stage mechanism. First, transaction fees are burned during epilogue execution. [1](#0-0)  Then, at block epilogue, validators receive a distribution based on the formula: `fee_to_distribute = gas_unit_available_to_distribute * (gas_price - gas_price_to_burn)`. [2](#0-1) 

The `gas_price_to_burn` parameter is configurable via governance through the execution config. [3](#0-2)  It defaults to 90. [4](#0-3) 

However, when governance updates this parameter via `execution_config::set_for_next_epoch()`, the only validation is that the config bytes are non-empty. [5](#0-4)  There are no bounds checks on the numeric value of `gas_price_to_burn`.

The minimum gas price in production is 100. [6](#0-5) 

**Attack Scenario:**

A compromised or malicious governance actor submits a proposal to set `gas_price_to_burn = 100` or higher. When this takes effect:

1. For transactions paying the minimum gas price (100): `gas_price (100) > gas_price_to_burn (100)` evaluates to `false`, so validators receive **zero fees**
2. For `gas_price_to_burn = 200`: Even transactions paying 200 per gas unit yield zero validator fees
3. For `gas_price_to_burn = 10,000,000,000` (the maximum): **ALL** transactions yield zero validator fees

The fee distribution check uses strict greater-than comparison, not greater-than-or-equal. [7](#0-6)  This means validators earn nothing when `gas_price <= gas_price_to_burn`.

## Impact Explanation

This qualifies as **High Severity** under the Aptos bug bounty program for the following reasons:

1. **Significant Protocol Violation**: It breaks the "Staking Security" invariant that "Validator rewards and penalties must be calculated correctly." Zero fee rewards when validators are performing valid work represents incorrect calculation.

2. **Economic Attack on Network Security**: Validators rely on transaction fees as economic compensation. Eliminating fee rewards removes the financial incentive to:
   - Propose blocks
   - Validate transactions
   - Maintain network infrastructure
   - Stay online and perform duties

3. **Potential Network Degradation**: If validators begin leaving due to zero compensation:
   - Validator set could shrink
   - Network security degrades (less Byzantine fault tolerance margin)
   - Block production could slow or halt if too many validators exit
   - This approaches "significant protocol violations" territory in the High severity category

4. **Governance Trust Boundary Violation**: While governance is generally trusted, critical system parameters that can break core invariants should have technical safeguards. Compare this to `burn_percentage` which has explicit bounds validation (0-100). [8](#0-7) 

## Likelihood Explanation

**Moderate-to-Low Likelihood**, but non-negligible:

1. **Requires Governance Compromise**: An attacker needs to either:
   - Compromise governance participants
   - Accumulate sufficient voting power
   - Exploit governance voting vulnerabilities

2. **Could Occur Through Mistake**: Even well-intentioned governance could accidentally set this value incorrectly during a configuration update, especially since there are no guardrails.

3. **Governance is a Known Attack Vector**: Historical blockchain incidents show governance as a realistic attack surface (e.g., governance attacks on various DeFi protocols).

4. **Single Parameter Change**: Unlike complex multi-step attacks, this requires only updating one parameter value.

## Recommendation

Add validation bounds on `gas_price_to_burn` to ensure it cannot exceed a safe threshold below the minimum gas price. The fix should be implemented in the Move code:

```move
// In execution_config.move
const EINVALID_GAS_PRICE_TO_BURN: u64 = 2;
const MAX_GAS_PRICE_TO_BURN: u64 = 99; // Must be less than min gas price (100)

public fun set_for_next_epoch(account: &signer, config: vector<u8>) {
    system_addresses::assert_aptos_framework(account);
    assert!(vector::length(&config) > 0, error::invalid_argument(EINVALID_CONFIG));
    
    // Deserialize and validate gas_price_to_burn if present
    let execution_config: OnChainExecutionConfig = bcs::from_bytes(&config);
    if (let Some(gas_price) = execution_config.gas_price_to_burn()) {
        assert!(
            gas_price <= MAX_GAS_PRICE_TO_BURN,
            error::invalid_argument(EINVALID_GAS_PRICE_TO_BURN)
        );
    }
    
    config_buffer::upsert(ExecutionConfig { config });
}
```

Alternatively, add validation in the Rust deserialization code to reject configs with invalid `gas_price_to_burn` values.

## Proof of Concept

```rust
// Test in aptos-move/framework/aptos-framework/tests/execution_config_tests.move

#[test(aptos_framework = @aptos_framework)]
#[expected_failure(abort_code = EINVALID_GAS_PRICE_TO_BURN)]
fun test_gas_price_to_burn_too_high_rejected(aptos_framework: &signer) {
    // Create ExecutionConfigV7 with gas_price_to_burn = 100
    let config = ExecutionConfigV7 {
        transaction_shuffler_type: /* ... */,
        block_gas_limit_type: /* ... */,
        enable_per_block_gas_limit: false,
        transaction_deduper_type: /* ... */,
        gas_price_to_burn: 100, // Invalid: >= min gas price
        persisted_auxiliary_info_version: 1,
    };
    
    let config_bytes = bcs::to_bytes(&OnChainExecutionConfig::V7(config));
    
    // This should fail validation
    execution_config::set_for_next_epoch(aptos_framework, config_bytes);
}

#[test(aptos_framework = @aptos_framework)]
fun test_gas_price_to_burn_valid_accepted(aptos_framework: &signer) {
    let config = ExecutionConfigV7 {
        transaction_shuffler_type: /* ... */,
        block_gas_limit_type: /* ... */,
        enable_per_block_gas_limit: false,
        transaction_deduper_type: /* ... */,
        gas_price_to_burn: 90, // Valid: < min gas price
        persisted_auxiliary_info_version: 1,
    };
    
    let config_bytes = bcs::to_bytes(&OnChainExecutionConfig::V7(config));
    
    // This should succeed
    execution_config::set_for_next_epoch(aptos_framework, config_bytes);
}
```

**Notes:**

This vulnerability exists because governance parameters that can break critical system invariants lack defensive validation. While governance is generally trusted, defense-in-depth principles suggest that parameters affecting core protocol security (like validator economic incentives) should have technical guardrails to prevent both malicious exploitation and accidental misconfiguration. The absence of bounds checking on `gas_price_to_burn` creates an exploitable governance attack surface that could degrade network security and liveness.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/transaction_fee.move (L22-23)
```text
    /// The burn percentage is out of range [0, 100].
    const EINVALID_BURN_PERCENTAGE: u64 = 3;
```

**File:** aptos-move/framework/aptos-framework/sources/transaction_fee.move (L79-81)
```text
    public(friend) fun burn_fee(
        account: address, fee: u64
    ) acquires AptosFABurnCapabilities, AptosCoinCapabilities {
```

**File:** aptos-move/block-executor/src/executor.rs (L2066-2072)
```rust
                    let gas_price_to_burn = self.config.onchain.gas_price_to_burn();
                    if gas_price > gas_price_to_burn {
                        let gas_unit_available_to_distribute = total_gas_unit
                            .saturating_sub(fee_statement.storage_fee_used().div_ceil(gas_price));
                        if gas_unit_available_to_distribute > 0 {
                            let fee_to_distribute =
                                gas_unit_available_to_distribute * (gas_price - gas_price_to_burn);
```

**File:** types/src/on_chain_config/execution_config.rs (L73-84)
```rust
    pub fn gas_price_to_burn(&self) -> Option<u64> {
        match self {
            OnChainExecutionConfig::Missing
            | OnChainExecutionConfig::V1(_)
            | OnChainExecutionConfig::V2(_)
            | OnChainExecutionConfig::V3(_)
            | OnChainExecutionConfig::V4(_)
            | OnChainExecutionConfig::V5(_) => None,
            OnChainExecutionConfig::V6(config) => Some(config.gas_price_to_burn),
            OnChainExecutionConfig::V7(config) => Some(config.gas_price_to_burn),
        }
    }
```

**File:** types/src/on_chain_config/execution_config.rs (L130-130)
```rust
            gas_price_to_burn: 90,
```

**File:** aptos-move/framework/aptos-framework/sources/configs/execution_config.move (L48-52)
```text
    public fun set_for_next_epoch(account: &signer, config: vector<u8>) {
        system_addresses::assert_aptos_framework(account);
        assert!(vector::length(&config) > 0, error::invalid_argument(EINVALID_CONFIG));
        config_buffer::upsert(ExecutionConfig { config });
    }
```

**File:** config/global-constants/src/lib.rs (L25-26)
```rust
#[cfg(not(any(test, feature = "testing")))]
pub const GAS_UNIT_PRICE: u64 = 100;
```
