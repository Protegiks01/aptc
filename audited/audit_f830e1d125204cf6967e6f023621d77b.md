# Audit Report

## Title
Missing Gas Schedule Completeness Validation Allows Network-Wide Denial of Service

## Summary
The gas schedule update mechanism lacks validation to ensure that a new gas schedule contains all required parameters for its declared `feature_version`. This allows governance to accidentally or maliciously apply an incomplete gas schedule that causes all transactions to fail with `VM_STARTUP_FAILURE`, resulting in total network liveness loss requiring a hard fork to recover.

## Finding Description

The vulnerability exists in the interaction between two components:

1. **Gas Schedule Validation (Move)**: The `set_for_next_epoch` function in `gas_schedule.move` validates only that the new `feature_version` is greater than or equal to the current version, but does not validate that the gas schedule contains all required parameters for that version. [1](#0-0) 

The TODO comments at lines 47, 67-68, and 75 explicitly acknowledge that gas schedule consistency checking should be implemented but is missing. [2](#0-1) 

2. **Gas Parameter Loading (Rust)**: The `from_on_chain_gas_schedule` macro attempts to load parameters based on version-specific naming conventions. For `feature_version >= 10`, it expects parameters with new names like `"txn.storage_io_per_state_slot_read"` instead of the legacy `"txn.load_data.base"`. [3](#0-2) 

The macro returns an error if a required parameter is missing: [4](#0-3) 

3. **Version Range Handling**: The `get_gas_parameters` function uses an unbounded match case `10..` that accepts any `feature_version >= 10`, including extremely high values like `u64::MAX`, without upper bound validation. [5](#0-4) 

**Attack Path:**

1. Governance submits a proposal to update the gas schedule with:
   - `feature_version = 1000` (or any value >= 10 but higher than current version ~45)
   - Gas parameters using only legacy naming (e.g., `"txn.load_data.base"` without `"txn.storage_io_per_state_slot_read"`)

2. The Move validation passes because it only checks `new_version >= current_version` ✓

3. At the next epoch transition, the gas schedule is applied via `on_new_epoch` [6](#0-5) 

4. When any transaction attempts to execute, the VM calls `get_gas_parameters`: [7](#0-6) 

5. The `from_on_chain_gas_schedule` function fails to find required parameters and returns `Err("Gas parameter txn.storage_io_per_state_slot_read does not exist. Feature version: 1000.")`

6. This error is converted to `VMStatus::error(StatusCode::VM_STARTUP_FAILURE)`: [8](#0-7) 

7. Transaction execution returns early with this error: [9](#0-8) 

8. All transactions are discarded with `TransactionStatus::Discard(StatusCode::VM_STARTUP_FAILURE)`, as confirmed by the test: [10](#0-9) 

9. The network is completely bricked—no transactions can execute, including governance transactions that could fix the issue.

## Impact Explanation

**Critical Severity** - This vulnerability meets the Critical impact criteria per Aptos bug bounty:

- **Total loss of liveness/network availability**: All transactions across the entire network fail immediately upon execution with `VM_STARTUP_FAILURE` and are discarded. No user transactions, system transactions, or governance proposals can execute.

- **Non-recoverable network partition (requires hardfork)**: Since no transactions can execute (including governance proposals), the network cannot recover through normal means. Validators must coordinate an emergency hard fork to either:
  - Roll back state to before the malformed gas schedule
  - Deploy a patched version that ignores the invalid gas schedule
  - Apply a hardcoded override for the gas schedule

This breaks the **Move VM Safety** invariant (#3): "Bytecode execution must respect gas limits and memory constraints" - transactions cannot even reach the execution stage to be metered properly.

It also violates the **Deterministic Execution** invariant (#1) in the sense that the system fails to execute any transactions deterministically.

## Likelihood Explanation

**Medium Likelihood**:

While this requires governance action (reducing likelihood), it can occur through:

1. **Accidental triggering**: During a legitimate gas schedule upgrade, governance could accidentally submit a malformed gas schedule with incorrect parameter names or missing parameters for the new version. This is especially likely during version transitions when parameter names change.

2. **Lack of validation**: The TODO comments in the code explicitly indicate that validation was planned but never implemented, suggesting this is a known gap.

3. **No test coverage**: The match statement's `10..` case has no upper bound validation and accepts arbitrarily high version numbers without checking parameter completeness.

The unbounded `10..` range specifically increases risk because it accepts any future version number (including values like 100, 1000, or `u64::MAX`) without corresponding parameter validation.

## Recommendation

**Immediate Fix**: Add gas schedule completeness validation in the Move contract:

```move
public fun set_for_next_epoch(aptos_framework: &signer, gas_schedule_blob: vector<u8>) acquires GasScheduleV2 {
    system_addresses::assert_aptos_framework(aptos_framework);
    assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));
    let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
    if (exists<GasScheduleV2>(@aptos_framework)) {
        let cur_gas_schedule = borrow_global<GasScheduleV2>(@aptos_framework);
        assert!(
            new_gas_schedule.feature_version >= cur_gas_schedule.feature_version,
            error::invalid_argument(EINVALID_GAS_FEATURE_VERSION)
        );
    };
    
    // ADD VALIDATION: Verify gas schedule can be parsed for the declared version
    validate_gas_schedule_completeness(&new_gas_schedule);
    
    config_buffer::upsert(new_gas_schedule);
}

// New validation function
native fun validate_gas_schedule_completeness(schedule: &GasScheduleV2);
```

Implement the native function in Rust to call `AptosGasParameters::from_on_chain_gas_schedule` and verify it succeeds before accepting the gas schedule.

**Additional Hardening**:
1. Add upper bound validation to the `10..` match case or use explicit version ranges
2. Implement the TODO gas schedule consistency checks at lines 47, 67-68, and 75
3. Add integration tests that verify gas schedule updates with missing parameters are rejected

## Proof of Concept

```rust
// Rust test demonstrating the vulnerability
#[test]
fn test_incomplete_gas_schedule_bricks_network() {
    let mut harness = MoveHarness::new();
    
    // Step 1: Create a gas schedule with high feature_version but missing required parameters
    harness.modify_gas_schedule_raw(|gas_schedule| {
        // Set feature_version to 1000 (triggers 10.. case)
        gas_schedule.feature_version = 1000;
        
        // Remove parameters required for version 10+
        gas_schedule.entries.retain(|(key, _)| {
            key != "txn.storage_io_per_state_slot_read" &&
            key != "txn.storage_io_per_state_byte_read"
        });
        
        // Keep only legacy parameter names
        // This passes Move validation but fails at runtime
    });
    
    // Step 2: Try to execute any transaction
    let account = harness.new_account_at(AccountAddress::from_hex_literal("0xbeef").unwrap());
    let result = harness.run_transaction_payload(
        &account,
        aptos_stdlib::aptos_coin_transfer(AccountAddress::ZERO, 1)
    );
    
    // Step 3: Verify all transactions fail with VM_STARTUP_FAILURE
    assert!(matches!(
        result.status(),
        TransactionStatus::Discard(StatusCode::VM_STARTUP_FAILURE)
    ));
    
    // Network is now completely bricked - no transactions can execute
}
```

## Notes

This vulnerability is distinct from a bypass—it's a complete system failure. The `10..` unbounded range combined with missing validation creates a critical footgun where governance can accidentally destroy network liveness. The TODO comments confirm this validation gap was known but never addressed.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L47-48)
```text
        // TODO(Gas): check if gas schedule is consistent
        let gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L91-103)
```text
    public fun set_for_next_epoch(aptos_framework: &signer, gas_schedule_blob: vector<u8>) acquires GasScheduleV2 {
        system_addresses::assert_aptos_framework(aptos_framework);
        assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));
        let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
        if (exists<GasScheduleV2>(@aptos_framework)) {
            let cur_gas_schedule = borrow_global<GasScheduleV2>(@aptos_framework);
            assert!(
                new_gas_schedule.feature_version >= cur_gas_schedule.feature_version,
                error::invalid_argument(EINVALID_GAS_FEATURE_VERSION)
            );
        };
        config_buffer::upsert(new_gas_schedule);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L135-145)
```text
    public(friend) fun on_new_epoch(framework: &signer) acquires GasScheduleV2 {
        system_addresses::assert_aptos_framework(framework);
        if (config_buffer::does_exist<GasScheduleV2>()) {
            let new_gas_schedule = config_buffer::extract_v2<GasScheduleV2>();
            if (exists<GasScheduleV2>(@aptos_framework)) {
                *borrow_global_mut<GasScheduleV2>(@aptos_framework) = new_gas_schedule;
            } else {
                move_to(framework, new_gas_schedule);
            }
        }
    }
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L88-96)
```rust
        [
            storage_io_per_state_slot_read: InternalGasPerArg,
            { 0..=9 => "load_data.base", 10.. => "storage_io_per_state_slot_read"},
            // At the current mainnet scale, we should assume most levels of the (hexary) JMT nodes
            // in cache, hence target charging 1-2 4k-sized pages for each read. Notice the cost
            // of seeking for the leaf node is covered by the first page of the "value size fee"
            // (storage_io_per_state_byte_read) defined below.
            302_385,
        ],
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/macros.rs (L38-42)
```rust
                    if let Some(key) = $crate::gas_schedule::macros::define_gas_parameters_extract_key_at_version!($key_bindings, feature_version) {
                        let name = format!("{}.{}", $prefix, key);
                        params.$name = gas_schedule.get(&name).cloned().ok_or_else(|| format!("Gas parameter {} does not exist. Feature version: {}.", name, feature_version))?.into();
                    }
                )*
```

**File:** aptos-move/aptos-vm-environment/src/gas.rs (L23-46)
```rust
fn get_gas_config_from_storage(
    sha3_256: &mut Sha3_256,
    state_view: &impl StateView,
) -> (Result<AptosGasParameters, String>, u64) {
    match GasScheduleV2::fetch_config_and_bytes(state_view) {
        Some((gas_schedule, bytes)) => {
            sha3_256.update(&bytes);
            let feature_version = gas_schedule.feature_version;
            let map = gas_schedule.into_btree_map();
            (
                AptosGasParameters::from_on_chain_gas_schedule(&map, feature_version),
                feature_version,
            )
        },
        None => match GasSchedule::fetch_config_and_bytes(state_view) {
            Some((gas_schedule, bytes)) => {
                sha3_256.update(&bytes);
                let map = gas_schedule.into_btree_map();
                (AptosGasParameters::from_on_chain_gas_schedule(&map, 0), 0)
            },
            None => (Err("Neither gas schedule v2 nor v1 exists.".to_string()), 0),
        },
    }
}
```

**File:** aptos-move/aptos-vm-environment/src/gas.rs (L69-93)
```rust
            match gas_feature_version {
                0..=1 => (),
                2..=6 => {
                    if let IoPricing::V2(pricing) = &storage_gas_params.io_pricing {
                        g.common_load_base_legacy = pricing.per_item_read * NumArgs::new(1);
                        g.common_load_base_new = 0.into();
                        g.common_load_per_byte = pricing.per_byte_read;
                        g.common_load_failure = 0.into();
                    }
                }
                7..=9 => {
                    if let IoPricing::V2(pricing) = &storage_gas_params.io_pricing {
                        g.common_load_base_legacy = 0.into();
                        g.common_load_base_new = pricing.per_item_read * NumArgs::new(1);
                        g.common_load_per_byte = pricing.per_byte_read;
                        g.common_load_failure = 0.into();
                    }
                }
                10.. => {
                    g.common_load_base_legacy = 0.into();
                    g.common_load_base_new = gas_params.vm.txn.storage_io_per_state_slot_read * NumArgs::new(1);
                    g.common_load_per_byte = gas_params.vm.txn.storage_io_per_state_byte_read;
                    g.common_load_failure = 0.into();
                }
            };
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L273-281)
```rust
pub(crate) fn get_or_vm_startup_failure<'a, T>(
    gas_params: &'a Result<T, String>,
    log_context: &AdapterLogSchema,
) -> Result<&'a T, VMStatus> {
    gas_params.as_ref().map_err(|err| {
        let msg = format!("VM Startup Failed. {}", err);
        speculative_error!(log_context, msg.clone());
        VMStatus::error(StatusCode::VM_STARTUP_FAILURE, Some(msg))
    })
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L2147-2164)
```rust
        let vm_params = self.gas_params(log_context)?.vm.clone();

        let initial_balance = if self.features().is_account_abstraction_enabled()
            || self.features().is_derivable_account_abstraction_enabled()
        {
            vm_params.txn.max_aa_gas.min(txn.max_gas_amount().into())
        } else {
            txn.max_gas_amount().into()
        };

        let mut gas_meter = make_gas_meter(
            self.gas_feature_version(),
            vm_params,
            self.storage_gas_params(log_context)?.clone(),
            is_approved_gov_script,
            initial_balance,
            code_storage,
        );
```

**File:** aptos-move/e2e-move-tests/src/tests/missing_gas_parameter.rs (L8-28)
```rust
#[test]
fn missing_gas_parameter() {
    let mut h = MoveHarness::new();

    h.modify_gas_schedule_raw(|gas_schedule| {
        let idx = gas_schedule
            .entries
            .iter()
            .position(|(key, _val)| key == "instr.add")
            .unwrap();
        gas_schedule.entries.remove(idx);
    });

    // Load the code
    let acc = h.new_account_with_balance_at(AccountAddress::from_hex_literal("0xbeef").unwrap(), 0);
    let txn_status = h.publish_package(&acc, &common::test_dir_path("common.data/do_nothing"));
    assert!(matches!(
        txn_status,
        TransactionStatus::Discard(StatusCode::VM_STARTUP_FAILURE)
    ))
}
```
