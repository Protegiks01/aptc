# Audit Report

## Title
Multi-Step Governance Proposals Allow Arbitrary Script Execution Through Unvalidated next_execution_hash

## Summary
The multi-step governance proposal system fails to validate the `next_execution_hash` parameter during proposal execution, allowing an attacker to approve and execute arbitrary scripts that were never reviewed or approved by governance voters. This completely bypasses the governance security model for multi-step proposals.

## Finding Description

The vulnerability exists in the interaction between the off-chain proposal generation system and on-chain execution logic for multi-step governance proposals.

**The Flow:**

1. When a multi-step proposal is created, only the **first step's** execution hash is committed and voted on by governance participants. [1](#0-0) 

2. When the first step executes, it calls `resolve_multi_step_proposal` with a `next_execution_hash` parameter that specifies what hash should be approved for the next step. [2](#0-1) 

3. This `next_execution_hash` is blindly accepted and stored **without any validation**: [3](#0-2) 

4. The hash is then retrieved and added to `ApprovedExecutionHashes`, allowing **any script** with that hash to execute: [4](#0-3) 

**The Attack:**

An attacker can:
1. Create a multi-step proposal with a benign-looking first step
2. Get governance approval (voters only see and approve the first step's hash)
3. Execute the first step, which passes a **malicious hash** as `next_execution_hash`
4. Execute a completely different, malicious second step that was **never approved** by governance

The off-chain generation tools correctly calculate hashes, but there is **no on-chain enforcement** that the provided `next_execution_hash` matches any pre-committed value. [5](#0-4) 

This breaks the fundamental security assumption: that all steps in a multi-step proposal are pre-committed and validated through governance voting.

## Impact Explanation

**Critical Severity** - This vulnerability allows complete bypass of the governance system, which is the highest authority in the Aptos blockchain. 

Impact includes:
- **Governance Bypass**: Attackers can execute arbitrary privileged scripts without governance approval
- **Protocol Parameter Manipulation**: Could modify consensus parameters, gas schedules, features, etc.
- **Fund Theft**: Could drain treasury funds or manipulate coin supplies
- **Validator Set Manipulation**: Could alter the validator set or staking parameters
- **Total System Compromise**: The `@aptos_framework` signer can execute any privileged operation

This meets the Critical Severity criteria: "Consensus/Safety violations" and potentially "Loss of Funds (theft or minting)".

## Likelihood Explanation

**High Likelihood** - This vulnerability is straightforward to exploit:
- Requires only normal governance participation (sufficient stake to propose)
- No special permissions or validator access needed
- Attack is deterministic and reliable
- The vulnerable code path executes on every multi-step proposal

The only barrier is the requirement to create a governance proposal and have it pass voting, but once passed, the attack is guaranteed to succeed.

## Recommendation

The system must validate that `next_execution_hash` matches a pre-committed value. Options include:

**Option 1: Pre-commit all step hashes at proposal creation**
```move
// In create_proposal_v2, add a new field
public fun create_proposal_v2<ProposalType: store>(
    // ... existing params ...
    execution_hash: vector<u8>,
    next_step_hashes: vector<vector<u8>>,  // NEW: All subsequent step hashes
    is_multi_step_proposal: bool,
): u64 {
    // Store next_step_hashes in proposal metadata
    if (is_multi_step_proposal && !vector::is_empty(&next_step_hashes)) {
        simple_map::add(&mut metadata, utf8(NEXT_STEP_HASHES_KEY), 
                       to_bytes(&next_step_hashes));
    }
    // ... rest of function
}

// In resolve_proposal_v2, validate the hash
public fun resolve_proposal_v2<ProposalType: store>(
    voting_forum_address: address,
    proposal_id: u64,
    next_execution_hash: vector<u8>,
) {
    // ... existing code ...
    
    // Validate next_execution_hash matches pre-committed value
    if (!vector::is_empty(&next_execution_hash)) {
        let next_hashes_key = utf8(NEXT_STEP_HASHES_KEY);
        assert!(
            simple_map::contains_key(&proposal.metadata, &next_hashes_key),
            error::invalid_argument(EINVALID_NEXT_EXECUTION_HASH)
        );
        let committed_hashes: vector<vector<u8>> = from_bcs::to_bytes(
            simple_map::borrow(&proposal.metadata, &next_hashes_key)
        );
        
        // Verify the provided hash matches the next committed hash
        let step_index = calculate_current_step_index(&proposal);
        assert!(
            *vector::borrow(&committed_hashes, step_index) == next_execution_hash,
            error::invalid_argument(EINVALID_NEXT_EXECUTION_HASH)
        );
    }
    
    // ... rest of function
}
```

**Option 2: Require each step to be individually approved through governance**
This would eliminate multi-step proposals in favor of sequential single-step proposals, each requiring full governance approval.

## Proof of Concept

```move
#[test_only]
module aptos_framework::governance_exploit_test {
    use aptos_framework::aptos_governance;
    use aptos_framework::voting;
    use std::vector;
    use aptos_std::crypto_algebra::sha3_256;
    
    #[test(framework = @aptos_framework, attacker = @0x123)]
    fun test_malicious_next_execution_hash(
        framework: &signer,
        attacker: &signer,
    ) {
        // Setup: Initialize governance and give attacker stake
        setup_governance(framework, attacker);
        
        // Step 1: Create benign first step script
        let benign_script = b"script { fun main() { /* benign code */ } }";
        let benign_hash = sha3_256(benign_script);
        
        // Step 2: Create proposal with benign first step
        let proposal_id = aptos_governance::create_proposal_v2_impl(
            attacker,
            signer::address_of(attacker),
            benign_hash,
            b"metadata",
            b"hash",
            true, // is_multi_step
        );
        
        // Step 3: Vote and pass the proposal
        vote_and_pass_proposal(proposal_id);
        
        // Step 4: Execute first step with MALICIOUS next hash
        let malicious_script = b"script { fun main() { /* STEAL FUNDS */ } }";
        let malicious_hash = sha3_256(malicious_script);
        
        // First step calls resolve_multi_step_proposal with malicious_hash
        let framework_signer = aptos_governance::resolve_multi_step_proposal(
            proposal_id,
            @0x1,
            malicious_hash, // <-- ATTACKER CONTROLS THIS
        );
        
        // Step 5: Now malicious_hash is APPROVED without governance vote!
        // Attacker can execute malicious_script
        
        // Verify the malicious hash is now in ApprovedExecutionHashes
        let approved = get_approved_hashes();
        assert!(simple_map::contains_key(&approved, &proposal_id), 0);
        assert!(*simple_map::borrow(&approved, &proposal_id) == malicious_hash, 1);
        
        // SUCCESS: Attacker bypassed governance for the second step
    }
}
```

**Notes:**
This vulnerability represents a fundamental flaw in the multi-step proposal security model where subsequent steps are not subject to the same governance scrutiny as the initial step, violating the principle that all privileged operations should require governance approval.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/voting.move (L332-336)
```text
        table::add(&mut voting_forum.proposals, proposal_id, Proposal {
            proposer,
            creation_time_secs: timestamp::now_seconds(),
            execution_content: option::some<ProposalType>(execution_content),
            execution_hash,
```

**File:** aptos-move/framework/aptos-framework/sources/voting.move (L562-566)
```text
        } else {
            // If the current step is not the last step,
            // update the proposal's execution hash on-chain to the execution hash of the next step.
            proposal.execution_hash = next_execution_hash;
        };
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L613-629)
```text
    public fun add_approved_script_hash(proposal_id: u64) acquires ApprovedExecutionHashes {
        let approved_hashes = borrow_global_mut<ApprovedExecutionHashes>(@aptos_framework);

        // Ensure the proposal can be resolved.
        let proposal_state = voting::get_proposal_state<GovernanceProposal>(@aptos_framework, proposal_id);
        assert!(proposal_state == PROPOSAL_STATE_SUCCEEDED, error::invalid_argument(EPROPOSAL_NOT_RESOLVABLE_YET));

        let execution_hash = voting::get_execution_hash<GovernanceProposal>(@aptos_framework, proposal_id);

        // If this is a multi-step proposal, the proposal id will already exist in the ApprovedExecutionHashes map.
        // We will update execution hash in ApprovedExecutionHashes to be the next_execution_hash.
        if (simple_map::contains_key(&approved_hashes.hashes, &proposal_id)) {
            let current_execution_hash = simple_map::borrow_mut(&mut approved_hashes.hashes, &proposal_id);
            *current_execution_hash = execution_hash;
        } else {
            simple_map::add(&mut approved_hashes.hashes, proposal_id, execution_hash);
        }
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L644-649)
```text
    public fun resolve_multi_step_proposal(
        proposal_id: u64,
        signer_address: address,
        next_execution_hash: vector<u8>
    ): signer acquires GovernanceResponsbility, ApprovedExecutionHashes {
        voting::resolve_proposal_v2<GovernanceProposal>(@aptos_framework, proposal_id, next_execution_hash);
```

**File:** aptos-move/aptos-release-builder/src/components/framework.rs (L120-131)
```rust
        if is_multi_step {
            // If we're generating a multi-step proposal
            let next_execution_hash_bytes = if result.is_empty() {
                next_execution_hash
            } else {
                get_execution_hash(&result)
            };
            release.generate_script_proposal_multi_step(
                account,
                move_script_path.clone(),
                next_execution_hash_bytes,
            )?;
```
