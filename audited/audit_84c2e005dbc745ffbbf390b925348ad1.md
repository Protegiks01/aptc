# Audit Report

## Title
Unencrypted Network Communication in Remote Executor Service Exposes Sensitive Transaction Data

## Summary
The remote executor service uses plaintext HTTP for gRPC communication between coordinator and executor shards, transmitting sensitive blockchain execution data without encryption. This allows network attackers to intercept transaction data, state keys/values, and cross-shard messages, potentially enabling information disclosure and man-in-the-middle attacks.

## Finding Description

The `aptos_secure_net` module, despite its name suggesting security, implements unencrypted network communication for the remote sharded block executor system. 

**Vulnerable Code Path:**

The gRPC client establishes connections using plain HTTP instead of HTTPS: [1](#0-0) 

The gRPC server similarly lacks TLS configuration: [2](#0-1) 

The `create_outbound_channel` function creates communication channels without any encryption setup: [3](#0-2) 

**Sensitive Data Transmitted:**

When remote executor sharding is enabled, the following sensitive data is transmitted in plaintext:

1. **Transaction Execution Commands** - containing analyzed transactions with read/write hints: [4](#0-3) 

2. **Execution Results** - containing transaction outputs: [5](#0-4) 

3. **Cross-Shard Messages** - containing state keys and write operations: [6](#0-5) 

4. **State Key-Value Pairs** - for state synchronization: [7](#0-6) 

**Attack Scenario:**

When remote sharded execution is enabled via configuration: [8](#0-7) 

An attacker with network access between the coordinator and executor shards can:

1. **Passive Interception**: Use packet capture tools (Wireshark, tcpdump) to intercept and read all gRPC messages containing transaction data, state updates, and execution results before they are committed to the blockchain.

2. **Man-in-the-Middle Attack**: Position themselves between shards to intercept and potentially modify messages, causing:
   - Different shards to execute with manipulated data
   - Cross-shard messages to be altered, leading to state inconsistencies
   - Execution results to be corrupted

This breaks multiple critical invariants:
- **Deterministic Execution**: Modified messages could cause shards to produce different results
- **State Consistency**: Manipulated cross-shard messages break state consistency guarantees
- **Confidentiality**: Transaction data exposed before public commitment

## Impact Explanation

**HIGH Severity** per Aptos Bug Bounty criteria:

1. **Significant Protocol Violation**: The lack of encryption for inter-shard communication violates fundamental security principles for distributed systems handling sensitive blockchain data.

2. **Information Disclosure**: Attackers can intercept:
   - Transaction details before they are publicly committed
   - State keys and values being synchronized
   - Cross-shard write operations
   - Execution results and VM state transitions

3. **Potential State Inconsistency**: Man-in-the-middle attacks could cause:
   - Different shards to execute with different data
   - Corrupted cross-shard messages leading to divergent state
   - Invalid transaction outputs being propagated

4. **Validator Node Security**: While not directly compromising validator keys, this exposes internal execution details that could aid further attacks.

This does not reach CRITICAL severity because it requires:
- Network access to inter-shard communication paths
- Remote executor sharding to be enabled (not default configuration)
- Does not directly cause fund loss without additional exploitation

## Likelihood Explanation

**Medium Likelihood:**

**Enabling Factors:**
- Remote executor sharding is a production feature accessible via command-line configuration
- No warnings or documentation about trusted network requirements
- Module naming ("aptos_secure_net") misleadingly suggests security

**Limiting Factors:**
- Requires remote executor sharding to be enabled (not always active)
- Attacker needs network access to inter-shard communication paths
- May be mitigated if deployed only on isolated private networks

**Real-World Scenarios:**
- Cloud deployments where network isolation is misconfigured
- Development/testing environments that accidentally expose ports
- Compromised network infrastructure providing attacker access
- Internal malicious actors with network access

The vulnerability is always present when remote sharding is enabled, making exploitation straightforward for positioned attackers.

## Recommendation

**Immediate Fix:** Implement TLS/encryption for gRPC communication in the remote executor service.

**Required Changes:**

1. **Add TLS Configuration to gRPC Client:**
   - Generate or configure TLS certificates for mutual authentication
   - Modify the endpoint URL from `http://` to `https://`
   - Configure `tonic::transport::ClientTlsConfig`

2. **Add TLS Configuration to gRPC Server:**
   - Configure server certificates
   - Use `tonic::transport::ServerTlsConfig`
   - Enable mutual TLS authentication to verify shard identities

3. **Certificate Management:**
   - Implement certificate distribution mechanism for coordinator and shards
   - Support certificate rotation
   - Validate peer certificates against authorized shard identities

4. **Configuration Updates:**
   - Add TLS configuration parameters to command-line arguments
   - Document security requirements for remote executor deployment
   - Consider renaming module to accurately reflect security status

**Alternative Mitigation:**
If immediate TLS implementation is not feasible, add:
- Clear documentation warning about plaintext communication
- Deployment guides specifying isolated network requirements
- Runtime warnings when remote sharding is enabled without proper network isolation

## Proof of Concept

**Step 1: Enable Remote Executor Sharding**
```bash
# Start coordinator
./aptos-node --remote-executor-mode coordinator --coordinator-address 127.0.0.1:52200

# Start executor shards
./aptos-node --remote-executor-mode shard --shard-id 0 \
  --coordinator-address 127.0.0.1:52200 \
  --remote-executor-addresses 127.0.0.1:52201,127.0.0.1:52202
```

**Step 2: Capture Network Traffic**
```bash
# Run tcpdump to capture gRPC traffic
sudo tcpdump -i lo -w capture.pcap 'port 52200 or port 52201 or port 52202'
```

**Step 3: Execute Transactions**
Execute a block of transactions through the sharded executor system.

**Step 4: Analyze Captured Traffic**
```bash
# Open in Wireshark
wireshark capture.pcap

# Filter for gRPC traffic
# Display Filter: tcp.port == 52200

# Observe plaintext protobuf messages containing:
# - Transaction data in RemoteExecutionRequest
# - State keys and values in RemoteKVRequest/Response
# - Execution results in RemoteExecutionResult
# - Cross-shard write operations in CrossShardMsg
```

**Expected Result:** 
Network capture will show unencrypted protobuf-serialized messages containing all transaction execution data, state updates, and cross-shard communications in plaintext, confirming the absence of transport-layer encryption.

**Verification:**
The gRPC communication uses HTTP (not HTTPS) as evidenced by the connection string construction, and the server builder has no TLS configuration, making all data transmitted over these channels readable to network observers.

### Citations

**File:** secure/net/src/grpc_network_service/mod.rs (L75-86)
```rust
        Server::builder()
            .timeout(std::time::Duration::from_millis(rpc_timeout_ms))
            .add_service(
                NetworkMessageServiceServer::new(self).max_decoding_message_size(MAX_MESSAGE_SIZE),
            )
            .add_service(reflection_service)
            .serve_with_shutdown(server_addr, async {
                server_shutdown_rx.await.ok();
                info!("Received signal to shutdown server at {:?}", server_addr);
            })
            .await
            .unwrap();
```

**File:** secure/net/src/grpc_network_service/mod.rs (L128-128)
```rust
                .block_on(async { Self::get_channel(format!("http://{}", remote_addr)).await }),
```

**File:** secure/net/src/network_controller/mod.rs (L115-126)
```rust
    pub fn create_outbound_channel(
        &mut self,
        remote_peer_addr: SocketAddr,
        message_type: String,
    ) -> Sender<Message> {
        let (outbound_sender, outbound_receiver) = unbounded();

        self.outbound_handler
            .register_handler(message_type, remote_peer_addr, outbound_receiver);

        outbound_sender
    }
```

**File:** execution/executor-service/src/lib.rs (L32-40)
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct RemoteExecutionResult {
    pub inner: Result<Vec<Vec<TransactionOutput>>, VMStatus>,
}

impl RemoteExecutionResult {
    pub fn new(inner: Result<Vec<Vec<TransactionOutput>>, VMStatus>) -> Self {
        Self { inner }
    }
```

**File:** execution/executor-service/src/lib.rs (L48-53)
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct ExecuteBlockCommand {
    pub(crate) sub_blocks: SubBlocksForShard<AnalyzedTransaction>,
    pub(crate) concurrency_level: usize,
    pub(crate) onchain_config: BlockExecutorConfigFromOnchain,
}
```

**File:** execution/executor-service/src/lib.rs (L67-86)
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct RemoteKVRequest {
    pub(crate) shard_id: ShardId,
    pub(crate) keys: Vec<StateKey>,
}

impl RemoteKVRequest {
    pub fn new(shard_id: ShardId, keys: Vec<StateKey>) -> Self {
        Self { shard_id, keys }
    }

    pub fn into(self) -> (ShardId, Vec<StateKey>) {
        (self.shard_id, self.keys)
    }
}

#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct RemoteKVResponse {
    pub(crate) inner: Vec<(StateKey, Option<StateValue>)>,
}
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/messages.rs (L13-18)
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct RemoteTxnWrite {
    state_key: StateKey,
    // The write op is None if the transaction is aborted.
    write_op: Option<WriteOp>,
}
```

**File:** execution/executor/src/workflow/do_get_execution_output.rs (L261-267)
```rust
        if !get_remote_addresses().is_empty() {
            Ok(V::execute_block_sharded(
                &REMOTE_SHARDED_BLOCK_EXECUTOR.lock(),
                partitioned_txns,
                state_view,
                onchain_config,
            )?)
```
