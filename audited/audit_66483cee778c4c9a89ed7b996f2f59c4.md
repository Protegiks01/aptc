# Audit Report

## Title
Missing Bounds Validation in `MultiBucketTimelineIndex::timeline_range()` Allows Mempool State Corruption

## Summary
The `timeline_range()` function in `MultiBucketTimelineIndex` fails to validate that `timeline_index_identifier` values are within valid bounds before array indexing. While it validates the count of pairs matches the timeline count, it does not verify each identifier is in the range [0, timelines.len()-1]. A malicious peer can exploit this by crafting broadcast messages with out-of-bounds timeline identifiers, causing silent failures that corrupt mempool state tracking and disrupt transaction propagation.

## Finding Description

The vulnerability exists in the `timeline_range()` method: [1](#0-0) 

The function only validates that the number of pairs equals the number of timelines (line 468), but never checks if each `timeline_index_identifier` is within valid bounds. When an out-of-bounds identifier is used, `.get(timeline_index_identifier as usize)` returns `None`, which silently converts to an empty vector via `map_or_else(Vec::new, ...)`.

In contrast, the `update()` method in `MultiBucketTimelineIndexIds` correctly validates bounds: [2](#0-1) 

Lines 308-311 explicitly check if any identifier is out of bounds and return early if so.

**Attack Path:**

1. Malicious peer crafts a `MempoolMessageId` where the encoded `timeline_index_identifier` values are out of bounds (e.g., 100, 101, 102 when only 0, 1, 2 are valid): [3](#0-2) 

The `decode()` method (line 378) extracts `timeline_index_identifier` from the encoded message without validation, allowing any u8 value (0-255). [4](#0-3) 

2. When the victim node calls `timeline_range_of_message()`: [5](#0-4) 

3. This flows through `transaction_store.timeline_range()`: [6](#0-5) 

4. Which calls the vulnerable `MultiBucketTimelineIndex::timeline_range()`, causing out-of-bounds identifiers to silently return empty results.

5. In `determine_broadcast_batch()`, this corrupts message tracking: [7](#0-6) 

Messages are incorrectly filtered out when `timeline_range_of_message()` returns empty due to out-of-bounds indices, even though valid transactions exist at correct indices.

6. During rebroadcast, empty transaction sets are sent: [8](#0-7) 

This breaks the **State Consistency** invariant as mempool tracking state diverges from actual transaction state.

## Impact Explanation

This vulnerability qualifies as **High Severity** under Aptos bug bounty criteria:

1. **Validator node slowdowns**: Malicious peers can cause nodes to fail propagating transactions correctly, leading to degraded network performance.

2. **Significant protocol violations**: The mempool's state tracking becomes inconsistent with actual transaction state. Messages are incorrectly marked as processed when they haven't been, and rebroadcasts fail silently.

3. **Network-wide impact**: Every node that receives broadcasts from a malicious peer is affected. Since broadcast messages are a core part of mempool operation, this can propagate throughout the network.

The vulnerability does not require validator privileges or special access—any network peer can send crafted broadcast messages.

## Likelihood Explanation

**High likelihood**:
- Any network peer can send `MempoolSyncMsg` messages
- Crafting malicious message IDs is straightforward—just encode out-of-bounds timeline identifiers
- The vulnerable code path is executed on every broadcast message received
- No authentication or special permissions required
- The attack is low-cost and repeatable

## Recommendation

Add bounds validation to `timeline_range()` matching the validation in `update()`:

```rust
pub(crate) fn timeline_range(
    &self,
    start_end_pairs: HashMap<TimelineIndexIdentifier, (TimelineId, TimelineId)>,
) -> Vec<(AccountAddress, ReplayProtector)> {
    assert_eq!(start_end_pairs.len(), self.timelines.len());
    
    // Add bounds validation for each identifier
    for index_identifier in start_end_pairs.keys() {
        if *index_identifier as usize >= self.timelines.len() {
            // Invalid identifier, return empty or error
            return Vec::new();
        }
    }

    let mut all_txns = vec![];
    for (timeline_index_identifier, (start_id, end_id)) in start_end_pairs {
        let mut txns = self
            .timelines
            .get(timeline_index_identifier as usize)
            .map_or_else(Vec::new, |timeline| {
                timeline.timeline_range(start_id, end_id)
            });
        all_txns.append(&mut txns);
    }
    all_txns
}
```

Alternatively, replace the `assert_eq!` with comprehensive validation that checks both count and bounds, similar to lines 304-312 in `types.rs`.

## Proof of Concept

```rust
#[cfg(test)]
mod test {
    use super::*;
    use std::collections::HashMap;

    #[test]
    fn test_timeline_range_out_of_bounds() {
        // Create MultiBucketTimelineIndex with 3 timelines
        let mut index = MultiBucketTimelineIndex::new(vec![0, 100, 200]).unwrap();
        
        // Craft malicious start_end_pairs with correct count but invalid identifiers
        let mut malicious_pairs = HashMap::new();
        malicious_pairs.insert(100u8, (0u64, 10u64)); // Out of bounds (should be 0, 1, or 2)
        malicious_pairs.insert(101u8, (0u64, 10u64)); // Out of bounds
        malicious_pairs.insert(102u8, (0u64, 10u64)); // Out of bounds
        
        // This should fail but currently succeeds and returns empty
        let result = index.timeline_range(malicious_pairs);
        
        // Currently returns empty vec instead of catching invalid identifiers
        assert_eq!(result.len(), 0); // Vulnerability: silently returns empty
        
        // Expected behavior: should validate and reject or panic on out-of-bounds
    }
}
```

This test demonstrates that out-of-bounds `timeline_index_identifier` values pass the count check but silently return empty results, confirming the vulnerability.

## Notes

The inconsistency between `MultiBucketTimelineIndexIds::update()` (which validates bounds) and `MultiBucketTimelineIndex::timeline_range()` (which does not) suggests this was an oversight rather than intentional design. The fix should align both methods to use consistent validation logic.

### Citations

**File:** mempool/src/core_mempool/index.rs (L464-481)
```rust
    pub(crate) fn timeline_range(
        &self,
        start_end_pairs: HashMap<TimelineIndexIdentifier, (TimelineId, TimelineId)>,
    ) -> Vec<(AccountAddress, ReplayProtector)> {
        assert_eq!(start_end_pairs.len(), self.timelines.len());

        let mut all_txns = vec![];
        for (timeline_index_identifier, (start_id, end_id)) in start_end_pairs {
            let mut txns = self
                .timelines
                .get(timeline_index_identifier as usize)
                .map_or_else(Vec::new, |timeline| {
                    timeline.timeline_range(start_id, end_id)
                });
            all_txns.append(&mut txns);
        }
        all_txns
    }
```

**File:** mempool/src/shared_mempool/types.rs (L45-45)
```rust
pub type TimelineIndexIdentifier = u8;
```

**File:** mempool/src/shared_mempool/types.rs (L300-318)
```rust
    pub(crate) fn update(
        &mut self,
        start_end_pairs: HashMap<TimelineIndexIdentifier, (TimelineId, TimelineId)>,
    ) {
        if self.id_per_bucket.len() != start_end_pairs.len() {
            return;
        }

        for index_identifier in start_end_pairs.keys() {
            if *index_identifier as usize >= self.id_per_bucket.len() {
                return;
            }
        }

        for (index_identifier, (_start, end)) in start_end_pairs {
            self.id_per_bucket[index_identifier as usize] =
                std::cmp::max(self.id_per_bucket[index_identifier as usize], end);
        }
    }
```

**File:** mempool/src/shared_mempool/types.rs (L372-388)
```rust
    pub(crate) fn decode(
        &self,
    ) -> HashMap<MempoolSenderBucket, HashMap<TimelineIndexIdentifier, (u64, u64)>> {
        let mut result = HashMap::new();
        for (start, end) in self.0.iter() {
            let sender_bucket = (start >> 56) as MempoolSenderBucket;
            let timeline_index_identifier = ((start >> 48) & 0xFF) as TimelineIndexIdentifier;
            // Remove the leading two bytes that indicates the sender bucket.
            let start = start & 0x0000FFFFFFFFFFFF;
            let end = end & 0x0000FFFFFFFFFFFF;
            result
                .entry(sender_bucket)
                .or_insert_with(HashMap::new)
                .insert(timeline_index_identifier, (start, end));
        }
        result
    }
```

**File:** mempool/src/core_mempool/mempool.rs (L630-644)
```rust
    pub(crate) fn timeline_range_of_message(
        &self,
        sender_start_end_pairs: HashMap<
            MempoolSenderBucket,
            HashMap<TimelineIndexIdentifier, (u64, u64)>,
        >,
    ) -> Vec<(SignedTransaction, u64)> {
        sender_start_end_pairs
            .iter()
            .flat_map(|(sender_bucket, start_end_pairs)| {
                self.transactions
                    .timeline_range(*sender_bucket, start_end_pairs.clone())
            })
            .collect()
    }
```

**File:** mempool/src/core_mempool/transaction_store.rs (L840-870)
```rust
    pub(crate) fn timeline_range(
        &self,
        sender_bucket: MempoolSenderBucket,
        start_end_pairs: HashMap<TimelineIndexIdentifier, (u64, u64)>,
    ) -> Vec<(SignedTransaction, u64)> {
        self.timeline_index
            .get(&sender_bucket)
            .unwrap_or_else(|| {
                panic!(
                    "Unable to get the timeline index for the sender bucket {}",
                    sender_bucket
                )
            })
            .timeline_range(start_end_pairs)
            .iter()
            .filter_map(|(account, replay_protector)| {
                self.transactions
                    .get(account)
                    .and_then(|txns| txns.get(replay_protector))
                    .map(|txn| {
                        (
                            txn.txn.clone(),
                            aptos_infallible::duration_since_epoch_at(
                                &txn.insertion_info.ready_time,
                            )
                            .as_millis() as u64,
                        )
                    })
            })
            .collect()
    }
```

**File:** mempool/src/shared_mempool/network.rs (L400-421)
```rust
        state.broadcast_info.sent_messages = state
            .broadcast_info
            .sent_messages
            .clone()
            .into_iter()
            .filter(|(message_id, _batch)| {
                !mempool
                    .timeline_range_of_message(message_id.decode())
                    .is_empty()
            })
            .collect::<BTreeMap<MempoolMessageId, SystemTime>>();
        state.broadcast_info.retry_messages = state
            .broadcast_info
            .retry_messages
            .clone()
            .into_iter()
            .filter(|message_id| {
                !mempool
                    .timeline_range_of_message(message_id.decode())
                    .is_empty()
            })
            .collect::<BTreeSet<MempoolMessageId>>();
```

**File:** mempool/src/shared_mempool/network.rs (L461-488)
```rust
                    let txns = message_id
                        .decode()
                        .into_iter()
                        .flat_map(|(sender_bucket, start_end_pairs)| {
                            if self.node_type.is_validator() {
                                mempool
                                    .timeline_range(sender_bucket, start_end_pairs)
                                    .into_iter()
                                    .map(|(txn, ready_time)| {
                                        (txn, ready_time, BroadcastPeerPriority::Primary)
                                    })
                                    .collect::<Vec<_>>()
                            } else {
                                self.prioritized_peers_state
                                    .get_sender_bucket_priority_for_peer(&peer, sender_bucket)
                                    .map_or_else(Vec::new, |priority| {
                                        mempool
                                            .timeline_range(sender_bucket, start_end_pairs)
                                            .into_iter()
                                            .map(|(txn, ready_time)| {
                                                (txn, ready_time, priority.clone())
                                            })
                                            .collect::<Vec<_>>()
                                    })
                            }
                        })
                        .collect::<Vec<_>>();
                    (message_id.clone(), txns, metric_label)
```
