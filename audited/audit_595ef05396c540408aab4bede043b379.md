# Audit Report

## Title
Configuration Semantic Drift on Save/Load Roundtrip Due to Base Config Loss

## Summary
The `OverrideNodeConfig` serialization system does not preserve roundtrip consistency. When a config with non-default `base_config` is saved and loaded, the `base_config` information is lost, causing critical security settings to silently revert to defaults.

## Finding Description

The vulnerability exists in the save/load implementation of `OverrideNodeConfig`: [1](#0-0) [2](#0-1) [3](#0-2) 

**The Bug Flow:**

1. **Save Phase**: `save_config()` calls `get_yaml()` which computes a diff between `override_config` and `base_config`, saving only fields that differ.

2. **Load Phase**: `load_config()` loads the saved YAML as a complete `NodeConfig`, then wraps it with `new_with_default_base()` which **always** uses `NodeConfig::default()` as the base, discarding the original base_config.

3. **Result**: If `override_config` had a field set to the same value as the non-default `base_config`, that field won't be saved (no diff), and on load it will revert to `NodeConfig::default()` value.

**Security-Critical Example 1: API Exposure**

The API is enabled by default: [4](#0-3) [5](#0-4) 

During genesis/validator setup, operators can use init_config callbacks: [6](#0-5) 

If init_config sets: `override_config.api.enabled = false` and `base_config.api.enabled = false` to intentionally disable the API, the save produces an empty diff. On load, both configs revert to default `true`, **unexpectedly exposing the API**.

**Security-Critical Example 2: Safety Rules Storage**

Safety rules default to insecure in-memory storage: [7](#0-6) 

Mainnet validators **must** use on-disk storage: [8](#0-7) 

If a validator sets `override_config.consensus.safety_rules.backend = OnDiskStorage` and `base_config.consensus.safety_rules.backend = OnDiskStorage`, then saves/loads, the config silently reverts to `InMemoryStorage`, violating mainnet security requirements.

## Impact Explanation

This meets **Medium Severity** criteria:
- **State inconsistencies requiring intervention**: Configs silently change after save/load
- **Validator node security misconfigurations**: APIs unexpectedly exposed, safety rules use insecure storage

The bug breaks **Invariant #10: Cryptographic Correctness** (safety rules cryptographic state persistence) and validator security assumptions. While not directly exploitable by external attackers, it creates operational security failures during:
- Genesis validator configuration
- Node restarts with config reloading  
- Testnet/forge configurations transitioning to production

## Likelihood Explanation

**HIGH likelihood** in real-world operations:

1. Genesis setup scripts commonly use `OverrideNodeConfig::new()` with custom base configs [6](#0-5) 

2. Testsuites and forge configurations use config override functions [9](#0-8) 

3. The bug is **silent** - operators won't notice until security issues manifest

4. The test suite even validates this broken behavior: [10](#0-9) 
(This test only validates the default case, missing the non-default base_config scenario)

## Recommendation

**Fix 1: Persist base_config in serialization**

Modify the `OverrideNodeConfig` struct to include base_config in serialization, or store a marker indicating which fields were intentionally set to match the base.

**Fix 2: Change load_config to preserve base_config semantics**

```rust
impl PersistableConfig for OverrideNodeConfig {
    fn load_config<P: AsRef<Path>>(path: P) -> Result<Self, Error> {
        let config = NodeConfig::load_config(path)?;
        // Note: This approach still loses base_config info
        // Better: serialize OverrideNodeConfig directly, not just the diff
        Ok(Self::new_with_default_base(config))
    }

    fn save_config<P: AsRef<Path>>(&self, output_file: P) -> Result<(), Error> {
        // Option 1: Save the full override_config, not the diff
        let yaml_string = serde_yaml::to_string(&self.override_config)?;
        
        // Option 2: Save both configs with metadata
        // let full_config = FullOverrideConfig {
        //     override_config: &self.override_config,
        //     base_config: &self.base_config,
        // };
        // let yaml_string = serde_yaml::to_string(&full_config)?;
        
        let yaml_bytes = yaml_string.as_bytes().to_vec();
        Self::write_file(yaml_bytes, output_file)
    }
}
```

**Fix 3: Add validation test for non-default base_config**

Add test cases that verify roundtrip consistency when `base_config != NodeConfig::default()`.

## Proof of Concept

```rust
#[test]
fn test_override_config_roundtrip_with_custom_base() {
    use tempfile::tempdir;
    
    // Setup: Create config with API disabled in both override and base
    let mut override_config = NodeConfig::default();
    override_config.api.enabled = false;
    
    let mut base_config = NodeConfig::default();
    base_config.api.enabled = false; // Non-default base
    
    let original = OverrideNodeConfig::new(override_config.clone(), base_config);
    
    // Verify original has API disabled
    assert_eq!(original.override_config().api.enabled, false);
    assert_eq!(original.base_config().api.enabled, false);
    
    // Save and load
    let temp_dir = tempdir().unwrap();
    let config_path = temp_dir.path().join("config.yaml");
    original.save_config(&config_path).unwrap();
    let loaded = OverrideNodeConfig::load_config(&config_path).unwrap();
    
    // BUG: After load, API is enabled (reverts to default true)
    assert_eq!(loaded.override_config().api.enabled, true); // ❌ FAILS - should be false
    assert_eq!(loaded.base_config().api.enabled, true);     // ❌ Lost custom base
    
    // Demonstrate semantic drift in get_yaml()
    let original_yaml = original.get_yaml().unwrap();
    let loaded_yaml = loaded.get_yaml().unwrap();
    
    // Original: empty diff (both false)
    assert_eq!(original_yaml.as_mapping().unwrap().len(), 0);
    
    // Loaded: also empty diff (both true)  
    assert_eq!(loaded_yaml.as_mapping().unwrap().len(), 0);
    
    // But the actual configs are semantically different!
    assert_ne!(
        original.override_config().api.enabled,
        loaded.override_config().api.enabled
    ); // ❌ Roundtrip inconsistency
}
```

**Notes**

This vulnerability specifically affects operational security during node configuration and genesis setup. While not directly exploitable by external network attackers, it creates a systemic risk where security-critical configurations silently revert to insecure defaults after save/load cycles. The impact is amplified because the bug is silent and occurs in trusted operational contexts where operators expect configuration persistence guarantees.

### Citations

**File:** config/src/config/override_node_config.rs (L127-133)
```rust
    pub fn get_yaml(&self) -> anyhow::Result<serde_yaml::Value> {
        let config_yaml = serde_yaml::to_value(&self.override_config)?;
        let base_yaml = serde_yaml::to_value(&self.base_config)?;
        diff_override_config_yaml(config_yaml, base_yaml).map(|diff_yaml| {
            diff_yaml.unwrap_or(serde_yaml::Value::Mapping(serde_yaml::Mapping::new()))
        })
    }
```

**File:** config/src/config/override_node_config.rs (L137-140)
```rust
    fn load_config<P: AsRef<Path>>(path: P) -> Result<Self, Error> {
        let config = NodeConfig::load_config(path)?;
        Ok(Self::new_with_default_base(config))
    }
```

**File:** config/src/config/override_node_config.rs (L142-152)
```rust
    fn save_config<P: AsRef<Path>>(&self, output_file: P) -> Result<(), Error> {
        let yaml_value = self.get_yaml()?;
        let yaml_string = serde_yaml::to_string(&yaml_value).map_err(|e| {
            Error::Yaml(
                "Unable to serialize override config to yaml. Error: {}".to_string(),
                e,
            )
        })?;
        let yaml_bytes = yaml_string.as_bytes().to_vec();
        Self::write_file(yaml_bytes, output_file)
    }
```

**File:** config/src/config/override_node_config.rs (L268-278)
```rust
    fn test_override_config_load_save() {
        let mut override_config =
            OverrideNodeConfig::new(NodeConfig::default(), NodeConfig::default());
        let config = override_config.override_config_mut();
        config.api.enabled = false;

        let temp_file = temp_dir().join("override_config.yaml");
        override_config.save_config(temp_file.as_path()).unwrap();
        let loaded_config = OverrideNodeConfig::load_config(temp_file.as_path()).unwrap();
        assert_eq!(override_config, loaded_config);
    }
```

**File:** config/src/config/api_config.rs (L104-106)
```rust
fn default_enabled() -> bool {
    true
}
```

**File:** config/src/config/api_config.rs (L115-115)
```rust
            enabled: default_enabled(),
```

**File:** crates/aptos-genesis/src/builder.rs (L567-577)
```rust
        let mut override_config = template.clone();
        let mut base_config = NodeConfig::default();
        if let Some(init_config) = &self.init_config {
            (init_config)(index, &mut override_config, &mut base_config);
        }

        let mut validator = ValidatorNodeConfig::new(
            name,
            index,
            self.config_dir.as_path(),
            OverrideNodeConfig::new(override_config, base_config),
```

**File:** config/src/config/safety_rules_config.rs (L36-48)
```rust
impl Default for SafetyRulesConfig {
    fn default() -> Self {
        Self {
            backend: SecureBackend::InMemoryStorage,
            logger: LoggerConfig::default(),
            service: SafetyRulesService::Local,
            test: None,
            // Default value of 30 seconds for a timeout
            network_timeout_ms: 30_000,
            enable_cached_safety_data: true,
            initial_safety_rules_config: InitialSafetyRulesConfig::None,
        }
    }
```

**File:** config/src/config/safety_rules_config.rs (L86-96)
```rust
            // Verify that the secure backend is appropriate for mainnet validators
            if chain_id.is_mainnet()
                && node_type.is_validator()
                && safety_rules_config.backend.is_in_memory()
            {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "The secure backend should not be set to in memory storage in mainnet!"
                        .to_string(),
                ));
            }
```

**File:** testsuite/forge/src/config.rs (L152-157)
```rust
    fn override_node_config_from_fn(config_fn: OverrideNodeConfigFn) -> OverrideNodeConfig {
        let mut override_config = NodeConfig::default();
        let mut base_config = NodeConfig::default();
        config_fn(&mut override_config, &mut base_config);
        OverrideNodeConfig::new(override_config, base_config)
    }
```
