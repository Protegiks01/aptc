# Audit Report

## Title
Missing State KV Pruning Check Allows Access to Pruned State Values via Epoch Snapshots

## Summary
Four critical state retrieval functions check only the state merkle pruning window but fail to check the state KV pruning window, allowing attempts to access pruned state values when epoch snapshots exist but the underlying state KV data has been pruned. This causes state sync failures and API crashes.

## Finding Description

The `error_if_state_kv_pruned` function only validates one pruning window (state KV pruner), while state merkle trees maintain two separate pruning windows (regular state merkle pruner and epoch snapshot pruner). [1](#0-0) 

State merkle trees have dedicated epoch snapshot support that allows longer retention for epoch-ending versions, checked via `error_if_state_merkle_pruned`. [2](#0-1) 

However, state KV values (the actual state data) do NOT have corresponding epoch snapshots. The state KV pruner uses the shared `ledger_pruner_config`. [3](#0-2) 

Four vulnerable functions check ONLY merkle tree pruning but then access state values from the state KV database:

1. **`get_state_value_with_proof_by_version_ext`** - checks merkle pruning only [4](#0-3)  but internally calls `expect_value_by_version` which queries state KV [5](#0-4) 

2. **`get_state_value_chunk_with_proof`** - checks merkle pruning only [6](#0-5)  but retrieves state values internally

3. **`get_state_value_chunk_iter`** - checks merkle pruning only [7](#0-6)  but calls `expect_value_by_version` for each entry [8](#0-7) 

4. **`get_state_value_chunk_proof`** - checks merkle pruning only [9](#0-8) 

In contrast, `get_state_value_by_version` correctly checks state KV pruning. [10](#0-9) 

**Attack Scenario:**
1. Operator configures: `epoch_snapshot_pruner.prune_window = 100M` versions, `ledger_pruner_config.prune_window = 50M` versions (realistic for aggressive transaction pruning while retaining epoch snapshots for state sync)
2. At current version `N`, version `V = N - 75M` is an epoch-ending version
3. State merkle epoch snapshot exists at V (within 100M window)
4. State KV values are pruned at V (beyond 50M window)
5. Node calls `get_state_value_chunk_with_proof(V, 0, 1000)` during state sync
6. `error_if_state_merkle_pruned` passes (epoch snapshot exists and version is epoch-ending)
7. System attempts to fetch state values via `expect_value_by_version`
8. State values are missing (pruned), causing `NotFound` errors and state sync failure

These functions are actively used by the state sync storage service. [11](#0-10) 

## Impact Explanation

**High Severity** per Aptos bug bounty criteria:

1. **API Crashes**: The vulnerable functions return errors or panic when state values are unexpectedly missing, causing API failures for legitimate state sync requests

2. **State Sync Failures**: Nodes attempting to sync from epoch snapshots will fail if state KV data is pruned but merkle snapshots exist, preventing nodes from joining the network or catching up

3. **Node Operation Disruption**: Validator and fullnode operations depend on state sync; failures cascade to network availability issues

4. **Service Availability**: The state sync storage service becomes unreliable for versions within the pruning gap, affecting multiple nodes simultaneously

This breaks the **State Consistency** invariant - the system promises to provide state data for versions that pass pruning checks, but fails to deliver.

## Likelihood Explanation

**Likelihood: Medium-High**

This vulnerability manifests when:
1. Operators configure epoch snapshot retention longer than ledger/state KV retention (operationally reasonable for disk space management)
2. The configuration gap is common: aggressive transaction pruning (small `ledger_pruner_config.prune_window`) + long epoch snapshot retention (large `epoch_snapshot_pruner.prune_window`) for state sync support
3. State sync requests target epoch-ending versions in the gap window
4. The default configuration (epoch=80M, ledger=90M) is safe, but custom configurations are widespread in production

The vulnerability is **easily triggerable** once the pruning configuration creates the gap, and affects all nodes querying state within that window.

## Recommendation

Add `error_if_state_kv_pruned` checks to all four vulnerable functions:

```rust
fn get_state_value_with_proof_by_version_ext(
    &self,
    key_hash: &HashValue,
    version: Version,
    root_depth: usize,
    use_hot_state: bool,
) -> Result<(Option<StateValue>, SparseMerkleProofExt)> {
    gauged_api("get_state_value_with_proof_by_version_ext", || {
        self.error_if_state_merkle_pruned("State merkle", version)?;
        self.error_if_state_kv_pruned("StateValue", version)?; // ADD THIS
        
        self.state_store.get_state_value_with_proof_by_version_ext(
            key_hash,
            version,
            root_depth,
            use_hot_state,
        )
    })
}

fn get_state_value_chunk_with_proof(
    &self,
    version: Version,
    first_index: usize,
    chunk_size: usize,
) -> Result<StateValueChunkWithProof> {
    gauged_api("get_state_value_chunk_with_proof", || {
        self.error_if_state_merkle_pruned("State merkle", version)?;
        self.error_if_state_kv_pruned("StateValue", version)?; // ADD THIS
        
        self.state_store
            .get_value_chunk_with_proof(version, first_index, chunk_size)
    })
}

fn get_state_value_chunk_iter(
    &self,
    version: Version,
    first_index: usize,
    chunk_size: usize,
) -> Result<Box<dyn Iterator<Item = Result<(StateKey, StateValue)>> + '_>> {
    gauged_api("get_state_value_chunk_iter", || {
        self.error_if_state_merkle_pruned("State merkle", version)?;
        self.error_if_state_kv_pruned("StateValue", version)?; // ADD THIS
        
        let state_value_chunk_iter =
            self.state_store
                .get_value_chunk_iter(version, first_index, chunk_size)?;
        Ok(Box::new(state_value_chunk_iter)
            as Box<dyn Iterator<Item = Result<(StateKey, StateValue)>> + '_>)
    })
}

fn get_state_value_chunk_proof(
    &self,
    version: Version,
    first_index: usize,
    state_key_values: Vec<(StateKey, StateValue)>,
) -> Result<StateValueChunkWithProof> {
    gauged_api("get_state_value_chunk_proof", || {
        self.error_if_state_merkle_pruned("State merkle", version)?;
        self.error_if_state_kv_pruned("StateValue", version)?; // ADD THIS
        
        self.state_store
            .get_value_chunk_proof(version, first_index, state_key_values)
    })
}
```

**Alternative/Additional Fix**: Enforce configuration validation to ensure `epoch_snapshot_pruner.prune_window <= ledger_pruner_config.prune_window` at startup, preventing the misconfiguration that creates the pruning gap.

## Proof of Concept

```rust
// Integration test demonstrating the vulnerability
#[test]
fn test_state_value_chunk_pruning_gap() {
    use aptos_config::config::{PrunerConfig, EpochSnapshotPrunerConfig, LedgerPrunerConfig};
    use aptos_storage_interface::DbReader;
    
    // Setup: Create DB with custom pruning configuration
    let mut pruner_config = PrunerConfig::default();
    
    // Create the vulnerable configuration
    pruner_config.epoch_snapshot_pruner_config = EpochSnapshotPrunerConfig {
        enable: true,
        prune_window: 100_000_000, // 100M versions
        batch_size: 1_000,
    };
    
    pruner_config.ledger_pruner_config = LedgerPrunerConfig {
        enable: true,
        prune_window: 50_000_000, // 50M versions - SHORTER than epoch snapshots!
        batch_size: 5_000,
        user_pruning_window_offset: 0,
    };
    
    let db = create_test_db_with_config(pruner_config);
    
    // Generate transactions to create an epoch-ending version
    let epoch_ending_version = create_epoch_ending_at_version(&db, 1000);
    
    // Advance chain by 75M versions (within epoch snapshot window, beyond state KV window)
    advance_chain_by(&db, 75_000_000);
    
    // Trigger pruning
    db.state_store.state_kv_pruner.prune();
    db.state_store.state_db.epoch_snapshot_pruner.prune();
    
    // Attempt to get state value chunk - this should fail but doesn't check state KV pruning
    let result = db.get_state_value_chunk_with_proof(
        epoch_ending_version,
        0,
        1000,
    );
    
    // VULNERABILITY: Check passes (epoch snapshot exists) but state values are pruned
    // This causes NotFound errors when trying to fetch actual state values
    assert!(result.is_err()); // Should fail with state KV pruned error
    
    // The error will be NotFound from expect_value_by_version, not a proper pruning error
    // because error_if_state_kv_pruned was never called
}
```

**Notes:**
- All vulnerable functions access state KV data but only validate merkle tree pruning
- The pruning gap creates a window where merkle proofs exist but state values don't
- This is exploitable with legitimate state sync operations, not requiring malicious intent
- Impact scales with number of nodes affected during state sync operations
- Fix requires adding missing pruning checks or enforcing configuration constraints

### Citations

**File:** storage/aptosdb/src/db/aptosdb_internal.rs (L68-69)
```rust
        let state_kv_pruner =
            StateKvPrunerManager::new(Arc::clone(&state_kv_db), pruner_config.ledger_pruner_config);
```

**File:** storage/aptosdb/src/db/aptosdb_internal.rs (L273-303)
```rust
    pub(super) fn error_if_state_merkle_pruned(
        &self,
        data_type: &str,
        version: Version,
    ) -> Result<()> {
        let min_readable_version = self
            .state_store
            .state_db
            .state_merkle_pruner
            .get_min_readable_version();
        if version >= min_readable_version {
            return Ok(());
        }

        let min_readable_epoch_snapshot_version = self
            .state_store
            .state_db
            .epoch_snapshot_pruner
            .get_min_readable_version();
        if version >= min_readable_epoch_snapshot_version {
            self.ledger_db.metadata_db().ensure_epoch_ending(version)
        } else {
            bail!(
                "{} at version {} is pruned. snapshots are available at >= {}, epoch snapshots are available at >= {}",
                data_type,
                version,
                min_readable_version,
                min_readable_epoch_snapshot_version,
            )
        }
    }
```

**File:** storage/aptosdb/src/db/aptosdb_internal.rs (L305-315)
```rust
    pub(super) fn error_if_state_kv_pruned(&self, data_type: &str, version: Version) -> Result<()> {
        let min_readable_version = self.state_store.state_kv_pruner.get_min_readable_version();
        ensure!(
            version >= min_readable_version,
            "{} at version {} is pruned, min available version is {}.",
            data_type,
            version,
            min_readable_version
        );
        Ok(())
    }
```

**File:** storage/aptosdb/src/db/aptosdb_reader.rs (L631-642)
```rust
    fn get_state_value_by_version(
        &self,
        state_store_key: &StateKey,
        version: Version,
    ) -> Result<Option<StateValue>> {
        gauged_api("get_state_value_by_version", || {
            self.error_if_state_kv_pruned("StateValue", version)?;

            self.state_store
                .get_state_value_by_version(state_store_key, version)
        })
    }
```

**File:** storage/aptosdb/src/db/aptosdb_reader.rs (L677-693)
```rust
    fn get_state_value_with_proof_by_version_ext(
        &self,
        key_hash: &HashValue,
        version: Version,
        root_depth: usize,
        use_hot_state: bool,
    ) -> Result<(Option<StateValue>, SparseMerkleProofExt)> {
        gauged_api("get_state_value_with_proof_by_version_ext", || {
            self.error_if_state_merkle_pruned("State merkle", version)?;

            self.state_store.get_state_value_with_proof_by_version_ext(
                key_hash,
                version,
                root_depth,
                use_hot_state,
            )
        })
```

**File:** storage/aptosdb/src/db/aptosdb_reader.rs (L880-891)
```rust
    fn get_state_value_chunk_with_proof(
        &self,
        version: Version,
        first_index: usize,
        chunk_size: usize,
    ) -> Result<StateValueChunkWithProof> {
        gauged_api("get_state_value_chunk_with_proof", || {
            self.error_if_state_merkle_pruned("State merkle", version)?;
            self.state_store
                .get_value_chunk_with_proof(version, first_index, chunk_size)
        })
    }
```

**File:** storage/aptosdb/src/db/aptosdb_reader.rs (L893-909)
```rust
    fn get_state_value_chunk_iter(
        &self,
        version: Version,
        first_index: usize,
        chunk_size: usize,
    ) -> Result<Box<dyn Iterator<Item = Result<(StateKey, StateValue)>> + '_>> {
        gauged_api("get_state_value_chunk_iter", || {
            self.error_if_state_merkle_pruned("State merkle", version)?;
            let state_value_chunk_iter =
                self.state_store
                    .get_value_chunk_iter(version, first_index, chunk_size)?;
            Ok(Box::new(state_value_chunk_iter)
                as Box<
                    dyn Iterator<Item = Result<(StateKey, StateValue)>> + '_,
                >)
        })
    }
```

**File:** storage/aptosdb/src/db/aptosdb_reader.rs (L911-922)
```rust
    fn get_state_value_chunk_proof(
        &self,
        version: Version,
        first_index: usize,
        state_key_values: Vec<(StateKey, StateValue)>,
    ) -> Result<StateValueChunkWithProof> {
        gauged_api("get_state_value_chunk_proof", || {
            self.error_if_state_merkle_pruned("State merkle", version)?;
            self.state_store
                .get_value_chunk_proof(version, first_index, state_key_values)
        })
    }
```

**File:** storage/aptosdb/src/state_store/mod.rs (L209-236)
```rust
    fn get_state_value_with_proof_by_version_ext(
        &self,
        key_hash: &HashValue,
        version: Version,
        root_depth: usize,
        use_hot_state: bool,
    ) -> Result<(Option<StateValue>, SparseMerkleProofExt)> {
        let db = if use_hot_state {
            if self.state_merkle_db.sharding_enabled() {
                self.hot_state_merkle_db
                    .as_ref()
                    .ok_or(AptosDbError::HotStateError)?
            } else {
                // Unsharded unit tests still rely on this.
                &self.state_merkle_db
            }
        } else {
            &self.state_merkle_db
        };
        let (leaf_data, proof) = db.get_with_proof_ext(key_hash, version, root_depth)?;
        Ok((
            match leaf_data {
                Some((_val_hash, (key, ver))) => Some(self.expect_value_by_version(&key, ver)?),
                None => None,
            },
            proof,
        ))
    }
```

**File:** storage/aptosdb/src/state_store/mod.rs (L1095-1115)
```rust
    pub fn get_value_chunk_iter(
        self: &Arc<Self>,
        version: Version,
        first_index: usize,
        chunk_size: usize,
    ) -> Result<impl Iterator<Item = Result<(StateKey, StateValue)>> + Send + Sync + use<>> {
        let store = Arc::clone(self);
        let value_chunk_iter = JellyfishMerkleIterator::new_by_index(
            Arc::clone(&self.state_merkle_db),
            version,
            first_index,
        )?
        .take(chunk_size)
        .map(move |res| {
            res.and_then(|(_, (key, version))| {
                Ok((key.clone(), store.expect_value_by_version(&key, version)?))
            })
        });

        Ok(value_chunk_iter)
    }
```

**File:** state-sync/storage-service/server/src/storage.rs (L900-1010)
```rust
    fn get_state_value_chunk_with_proof_by_size(
        &self,
        version: u64,
        start_index: u64,
        end_index: u64,
        max_response_size: u64,
        use_size_and_time_aware_chunking: bool,
    ) -> Result<StateValueChunkWithProof, Error> {
        // Calculate the number of state values to fetch
        let expected_num_state_values = inclusive_range_len(start_index, end_index)?;
        let max_num_state_values = self.config.max_state_chunk_size;
        let num_state_values_to_fetch = min(expected_num_state_values, max_num_state_values);

        // If size and time-aware chunking are disabled, use the legacy implementation
        if !use_size_and_time_aware_chunking {
            return self.get_state_value_chunk_with_proof_by_size_legacy(
                version,
                start_index,
                end_index,
                num_state_values_to_fetch,
                max_response_size,
            );
        }

        // Get the state value chunk iterator
        let mut state_value_iterator = self.storage.get_state_value_chunk_iter(
            version,
            start_index as usize,
            num_state_values_to_fetch as usize,
        )?;

        // Initialize the fetched state values
        let mut state_values = vec![];

        // Create a response progress tracker
        let mut response_progress_tracker = ResponseDataProgressTracker::new(
            num_state_values_to_fetch,
            max_response_size,
            self.config.max_storage_read_wait_time_ms,
            self.time_service.clone(),
        );

        // Fetch as many state values as possible
        while !response_progress_tracker.is_response_complete() {
            match state_value_iterator.next() {
                Some(Ok(state_value)) => {
                    // Calculate the number of serialized bytes for the state value
                    let num_serialized_bytes = get_num_serialized_bytes(&state_value)
                        .map_err(|error| Error::UnexpectedErrorEncountered(error.to_string()))?;

                    // Add the state value to the list
                    if response_progress_tracker
                        .data_items_fits_in_response(true, num_serialized_bytes)
                    {
                        state_values.push(state_value);
                        response_progress_tracker.add_data_item(num_serialized_bytes);
                    } else {
                        break; // Cannot add any more data items
                    }
                },
                Some(Err(error)) => {
                    return Err(Error::StorageErrorEncountered(error.to_string()));
                },
                None => {
                    // Log a warning that the iterator did not contain all the expected data
                    warn!(
                        "The state value iterator is missing data! Version: {:?}, \
                        start index: {:?}, end index: {:?}, num state values to fetch: {:?}",
                        version, start_index, end_index, num_state_values_to_fetch
                    );
                    break;
                },
            }
        }

        // Create the state value chunk with proof
        let state_value_chunk_with_proof = self.storage.get_state_value_chunk_proof(
            version,
            start_index as usize,
            state_values,
        )?;

        // Update the data truncation metrics
        response_progress_tracker
            .update_data_truncation_metrics(DataResponse::get_state_value_chunk_with_proof_label());

        Ok(state_value_chunk_with_proof)
    }

    /// Returns a state value chunk with proof response (bound by the max response size in bytes).
    /// This is the legacy implementation (that does not use size and time-aware chunking).
    fn get_state_value_chunk_with_proof_by_size_legacy(
        &self,
        version: u64,
        start_index: u64,
        end_index: u64,
        mut num_state_values_to_fetch: u64,
        max_response_size: u64,
    ) -> Result<StateValueChunkWithProof, Error> {
        while num_state_values_to_fetch >= 1 {
            let state_value_chunk_with_proof = self.storage.get_state_value_chunk_with_proof(
                version,
                start_index as usize,
                num_state_values_to_fetch as usize,
            )?;
            if num_state_values_to_fetch == 1 {
                return Ok(state_value_chunk_with_proof); // We cannot return less than a single item
            }

            // Attempt to divide up the request if it overflows the message size
            let (overflow_frame, num_bytes) =
```
