# Audit Report

## Title
Indexer Denial of Service via Panic on Invalid Coin Event Amount Deserialization

## Summary
The Aptos indexer crashes and halts all transaction processing when it encounters a coin withdraw/deposit event with an amount field that cannot be deserialized as a BigDecimal. This occurs due to an `.unwrap()` call that panics on deserialization errors, causing complete indexer unavailability.

## Finding Description
The vulnerability exists in the coin event processing pipeline. When the indexer processes coin withdraw/deposit events, it attempts to deserialize the event data including the `amount` field. [1](#0-0) 

The `from_event()` function returns `Result<Option<CoinEvent>>`. When deserializing a WithdrawEvent, if the amount field contains a string that cannot be parsed as BigDecimal (handled by `deserialize_from_string`), the deserialization fails and returns an `Err`. [2](#0-1) 

The critical issue occurs in the calling code where this Result is unwrapped without error handling: [3](#0-2) 

When `.unwrap()` is called on an `Err` result, the indexer panics. This panic propagates through the CoinTransactionProcessor: [4](#0-3) 

The panic ultimately causes the entire indexer runtime to crash: [5](#0-4) 

**Answer to the security question:** The indexer **fails the entire transaction indexing** by panicking and crashing when the amount field is invalid.

## Impact Explanation
This issue qualifies as **Medium severity** under the Aptos bug bounty criteria for "State inconsistencies requiring intervention":

- **Indexer Unavailability**: The indexer completely stops processing new transactions, preventing updates to coin balances, activities, and supply tracking
- **Application Service Disruption**: All applications and services relying on the indexer API for balance queries, transaction history, and coin metadata experience failures
- **Manual Recovery Required**: The indexer must be manually restarted and may repeatedly crash on the same malformed transaction unless the data is fixed
- **Historical Data Gaps**: Transaction history becomes incomplete until the issue is resolved

While the indexer is an off-chain component and doesn't affect consensus or on-chain fund security, it is critical infrastructure for the Aptos ecosystem that many applications depend on.

## Likelihood Explanation
The likelihood is **Low to Medium** because:

**Requires unusual circumstances:**
- Events are serialized by the Move VM during execution, which should always produce valid numeric strings for `u64` amounts
- Invalid data would most likely result from:
  - Bugs in Move VM event serialization logic
  - Database corruption during storage or retrieval
  - Version mismatches between the blockchain and indexer
  - Historical data migration issues

**Not directly attacker-controlled:**
- Attackers cannot directly emit events with arbitrary serialization
- The Move VM controls event data formatting

**Historical precedent:**
- Similar deserialization issues have occurred in blockchain indexing systems during upgrades or when processing legacy data

## Recommendation
Replace the `.unwrap()` call with proper error handling that logs the error and continues processing:

```rust
for (index, event) in events.iter().enumerate() {
    let event_type = event.typ.to_string();
    match CoinEvent::from_event(event_type.as_str(), &event.data, txn_version) {
        Ok(Some(parsed_event)) => {
            coin_activities.push(Self::from_parsed_event(
                &event_type,
                event,
                &parsed_event,
                txn_version,
                &all_event_to_coin_type,
                txn_info.block_height.unwrap().0 as i64,
                &entry_function_id_str,
                txn_timestamp,
                index as i64,
            ));
        },
        Ok(None) => {
            // Event type not supported, continue
        },
        Err(e) => {
            aptos_logger::error!(
                transaction_version = txn_version,
                event_type = event_type,
                error = ?e,
                "Failed to parse coin event, skipping"
            );
            // Continue processing other events
        }
    }
}
```

This approach:
1. Logs the error with full context for debugging
2. Skips the problematic event rather than crashing
3. Continues processing remaining events in the transaction
4. Allows the indexer to maintain availability despite data issues

## Proof of Concept

```rust
// Test case to reproduce the panic
#[test]
#[should_panic(expected = "failed to parse type")]
fn test_invalid_amount_causes_panic() {
    use serde_json::json;
    
    // Create event data with invalid amount string
    let invalid_event_data = json!({
        "amount": "not_a_number"
    });
    
    // This will panic when unwrap() is called on the Err result
    let result = CoinEvent::from_event(
        "0x1::coin::WithdrawEvent",
        &invalid_event_data,
        1000
    );
    
    // In production code, this unwrap causes the indexer to crash
    result.unwrap();
}
```

To simulate in a running indexer:
1. Set up a test indexer instance
2. Manually insert corrupted event data in the database with an invalid amount field
3. Restart the indexer and observe it crash when processing the corrupted transaction
4. Verify that applying the recommended fix allows the indexer to skip the event and continue processing

**Notes:**
- This vulnerability affects the indexer infrastructure reliability but does not compromise on-chain security, consensus, or funds
- The issue is in the off-chain indexing layer, not the core blockchain execution
- Similar `.unwrap()` patterns exist in other event processing code and should be reviewed

### Citations

**File:** crates/indexer/src/models/coin_models/coin_utils.rs (L131-134)
```rust
pub struct WithdrawCoinEvent {
    #[serde(deserialize_with = "deserialize_from_string")]
    pub amount: BigDecimal,
}
```

**File:** crates/indexer/src/models/coin_models/coin_utils.rs (L245-261)
```rust
    pub fn from_event(
        data_type: &str,
        data: &serde_json::Value,
        txn_version: i64,
    ) -> Result<Option<CoinEvent>> {
        match data_type {
            "0x1::coin::WithdrawEvent" => serde_json::from_value(data.clone())
                .map(|inner| Some(CoinEvent::WithdrawCoinEvent(inner))),
            "0x1::coin::DepositEvent" => serde_json::from_value(data.clone())
                .map(|inner| Some(CoinEvent::DepositCoinEvent(inner))),
            _ => Ok(None),
        }
        .context(format!(
            "version {} failed! failed to parse type {}, data {:?}",
            txn_version, data_type, data
        ))
    }
```

**File:** crates/indexer/src/models/coin_models/coin_activities.rs (L179-196)
```rust
        for (index, event) in events.iter().enumerate() {
            let event_type = event.typ.to_string();
            if let Some(parsed_event) =
                CoinEvent::from_event(event_type.as_str(), &event.data, txn_version).unwrap()
            {
                coin_activities.push(Self::from_parsed_event(
                    &event_type,
                    event,
                    &parsed_event,
                    txn_version,
                    &all_event_to_coin_type,
                    txn_info.block_height.unwrap().0 as i64,
                    &entry_function_id_str,
                    txn_timestamp,
                    index as i64,
                ));
            };
        }
```

**File:** crates/indexer/src/processors/coin_processor.rs (L297-305)
```rust
        for txn in &transactions {
            let (
                mut coin_activities,
                mut coin_balances,
                coin_infos,
                current_coin_balances,
                mut coin_supply,
            ) = CoinActivity::from_transaction(txn, maybe_aptos_coin_info);
            all_coin_activities.append(&mut coin_activities);
```

**File:** crates/indexer/src/runtime.rs (L216-219)
```rust
        let batches = match futures::future::try_join_all(tasks).await {
            Ok(res) => res,
            Err(err) => panic!("Error processing transaction batches: {:?}", err),
        };
```
