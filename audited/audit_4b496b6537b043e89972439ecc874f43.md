# Audit Report

## Title
Consensus Split Vulnerability Due to Silent Fallback in Randomness Config Variant Parsing

## Summary
When the on-chain `randomness_config` Move module is upgraded to add a new variant (e.g., ConfigV3), validators running older Rust binaries will fail to parse the unknown variant and silently fall back to `OnChainRandomnessConfig::Off`. This causes validators with different binary versions to have divergent views on whether randomness is enabled, leading to different block metadata transaction types being created during execution. This results in a **consensus safety violation** causing network partition requiring a hard fork. [1](#0-0) 

## Finding Description

The vulnerability exists in how `RandomnessConfigMoveStruct` handles variant deserialization using the `MoveAny` pattern. The `TryFrom` implementation only recognizes three variant types: `ConfigOff`, `ConfigV1`, and `ConfigV2`. When an unknown variant type is encountered, it returns an error that gets silently converted to the disabled state. [2](#0-1) 

The error handling in `from_configs()` uses `.ok()` which swallows the parsing error and then `unwrap_or_else()` defaults to `default_if_missing()`, which returns `OnChainRandomnessConfig::Off`.

**Attack Scenario:**

1. A governance proposal upgrades the framework to add `ConfigV3` with new randomness features
2. Some validators upgrade their binaries early; others haven't upgraded yet
3. The proposal executes, setting the on-chain config to use `ConfigV3`
4. At the next epoch boundary, validators fetch the config:
   - **OLD validators**: Parse fails on unknown variant → falls back to `Off` → `randomness_enabled() = false`
   - **NEW validators**: Parse succeeds → `ConfigV3` → `randomness_enabled() = true` [3](#0-2) 

5. During block execution, the `is_randomness_enabled` flag determines which metadata transaction type to create: [4](#0-3) 

   - **OLD validators**: Create `BlockMetadata` transaction (legacy format)
   - **NEW validators**: Create `BlockMetadataExt::V1` transaction (with randomness support) [5](#0-4) [6](#0-5) 

6. These are **different transaction types** that serialize and hash differently, resulting in:
   - Different transaction lists in the block
   - Different execution results
   - **Different state roots**
   - **Consensus split** - validators cannot agree on the canonical chain

This breaks the **Deterministic Execution** invariant: "All validators must produce identical state roots for identical blocks."

## Impact Explanation

**Severity: CRITICAL** (up to $1,000,000)

This vulnerability qualifies as Critical severity under multiple bug bounty categories:

1. **Consensus/Safety violations**: Different validators compute different state roots for the same block, violating Byzantine Fault Tolerance guarantees
2. **Non-recoverable network partition (requires hardfork)**: The network splits into two incompatible partitions (old vs new binary validators), requiring a coordinated hard fork to recover
3. **Total loss of liveness/network availability**: If neither partition maintains >2/3 stake, the chain halts

The consensus split affects **all network participants** and breaks the fundamental security guarantee of blockchain consensus. This is not a theoretical issue - it's a latent design flaw that will manifest during any framework upgrade that adds new randomness config variants.

## Likelihood Explanation

**Likelihood: MEDIUM to HIGH**

This vulnerability is highly likely to occur because:

1. **Framework upgrades are routine**: Aptos regularly upgrades the framework through governance proposals
2. **ConfigV2 was recently added**: The existence of `ConfigV1` and `ConfigV2` demonstrates that the randomness config evolves over time, making `ConfigV3` a realistic future addition
3. **Imperfect upgrade coordination**: Validator operators upgrade at different times, creating a window where mixed versions coexist
4. **Silent failure**: The error is logged as a warning but execution continues with wrong assumptions [7](#0-6) 

5. **No runtime version enforcement**: Unlike Move module compatibility which has strict checks, there's no mechanism preventing validators from running incompatible binary versions during config transitions

The vulnerability could be triggered **accidentally** during legitimate upgrades or **intentionally** by a malicious governance participant who coordinates the timing to maximize network disruption.

## Recommendation

Replace the runtime variant pattern with a compile-time enum pattern similar to `OnChainExecutionConfig`: [8](#0-7) 

**Recommended Fix:**

```rust
// types/src/on_chain_config/randomness_config.rs

#[derive(Clone, Debug, Deserialize, PartialEq, Eq, Serialize)]
pub enum OnChainRandomnessConfig {
    Off,
    V1(ConfigV1),
    V2(ConfigV2),
    // Future versions here
    Missing, // For backwards compatibility
}

impl OnChainRandomnessConfig {
    pub fn randomness_enabled(&self) -> bool {
        match self {
            OnChainRandomnessConfig::Off => false,
            OnChainRandomnessConfig::Missing => false,
            OnChainRandomnessConfig::V1(_) => true,
            OnChainRandomnessConfig::V2(_) => true,
            // New versions MUST be explicitly handled
        }
    }
    
    pub fn default_if_missing() -> Self {
        OnChainRandomnessConfig::Missing
    }
}

impl OnChainConfig for OnChainRandomnessConfig {
    const MODULE_IDENTIFIER: &'static str = "randomness_config";
    const TYPE_IDENTIFIER: &'static str = "RandomnessConfig";
    
    fn deserialize_into_config(bytes: &[u8]) -> Result<Self> {
        let raw_bytes: Vec<u8> = bcs::from_bytes(bytes)?;
        bcs::from_bytes(&raw_bytes)
            .map_err(|e| format_err!("[on-chain config] Failed to deserialize: {}", e))
    }
}
```

Update the Move module to store the enum directly instead of using `Any`:

```move
// aptos-move/framework/aptos-framework/sources/configs/randomness_config.move

struct RandomnessConfig has copy, drop, key, store {
    config: vector<u8>  // BCS-serialized OnChainRandomnessConfig enum
}
```

This approach ensures:
1. **Compile-time safety**: Old binaries won't compile without handling new variants
2. **No silent failures**: Deserialization errors are explicit
3. **Consistent behavior**: All validators either parse successfully or fail explicitly
4. **Forward compatibility**: The `Missing` variant provides safe fallback for old data

## Proof of Concept

**Scenario: Simulated ConfigV3 Addition**

1. Deploy framework with `ConfigV2` in use
2. Validator Set: 4 validators (VA, VB with old binary; VC, VD with new binary)
3. Governance proposal executes to set `RandomnessConfig` to `ConfigV3`
4. At epoch N+1:
   - VA, VB fetch config → parse fails → `randomness_enabled = false`
   - VC, VD fetch config → parse succeeds → `randomness_enabled = true`
5. Block at round 10 proposed by VA:
   - VA creates `BlockMetadata(id, epoch, round, ...)`
   - VC, VD expect `BlockMetadataExt::V1(id, epoch, round, ..., randomness)`
6. VC, VD reject VA's block due to transaction type mismatch
7. Block at round 11 proposed by VC:
   - VC creates `BlockMetadataExt::V1(...)`
   - VA, VB expect `BlockMetadata(...)` 
8. VA, VB reject VC's block due to transaction type mismatch
9. **Network partitions**: Neither set can make progress with the other

**Verification Steps:**

```rust
// Test in types/src/on_chain_config/randomness_config.rs

#[test]
fn test_unknown_variant_causes_silent_fallback() {
    // Simulate ConfigV3 that old code doesn't recognize
    let unknown_variant = MoveAny {
        type_name: "0x1::randomness_config::ConfigV3".to_string(),
        data: vec![1, 2, 3], // arbitrary data
    };
    let config_struct = RandomnessConfigMoveStruct { variant: unknown_variant };
    
    // Old code path: conversion fails silently
    let result = OnChainRandomnessConfig::try_from(config_struct);
    assert!(result.is_err()); // Proves parse failure
    
    // from_configs silently converts to Off
    let actual = OnChainRandomnessConfig::from_configs(0, 0, Some(config_struct));
    assert_eq!(actual, OnChainRandomnessConfig::Off);
    assert!(!actual.randomness_enabled()); // Randomness incorrectly disabled
}
```

This demonstrates the silent fallback behavior that causes the consensus split.

### Citations

**File:** types/src/on_chain_config/randomness_config.rs (L139-151)
```rust
    pub fn from_configs(
        local_seqnum: u64,
        onchain_seqnum: u64,
        onchain_raw_config: Option<RandomnessConfigMoveStruct>,
    ) -> Self {
        if local_seqnum > onchain_seqnum {
            Self::default_disabled()
        } else {
            onchain_raw_config
                .and_then(|onchain_raw| OnChainRandomnessConfig::try_from(onchain_raw).ok())
                .unwrap_or_else(OnChainRandomnessConfig::default_if_missing)
        }
    }
```

**File:** types/src/on_chain_config/randomness_config.rs (L154-174)
```rust
impl TryFrom<RandomnessConfigMoveStruct> for OnChainRandomnessConfig {
    type Error = anyhow::Error;

    fn try_from(value: RandomnessConfigMoveStruct) -> Result<Self, Self::Error> {
        let RandomnessConfigMoveStruct { variant } = value;
        let variant_type_name = variant.type_name.as_str();
        match variant_type_name {
            ConfigOff::MOVE_TYPE_NAME => Ok(OnChainRandomnessConfig::Off),
            ConfigV1::MOVE_TYPE_NAME => {
                let v1 = MoveAny::unpack(ConfigV1::MOVE_TYPE_NAME, variant)
                    .map_err(|e| anyhow!("unpack as v1 failed: {e}"))?;
                Ok(OnChainRandomnessConfig::V1(v1))
            },
            ConfigV2::MOVE_TYPE_NAME => {
                let v2 = MoveAny::unpack(ConfigV2::MOVE_TYPE_NAME, variant)
                    .map_err(|e| anyhow!("unpack as v2 failed: {e}"))?;
                Ok(OnChainRandomnessConfig::V2(v2))
            },
            _ => Err(anyhow!("unknown variant type")),
        }
    }
```

**File:** consensus/src/pipeline/execution_client.rs (L566-567)
```rust
        let randomness_enabled = onchain_consensus_config.is_vtxn_enabled()
            && onchain_randomness_config.randomness_enabled();
```

**File:** consensus/src/pipeline/pipeline_builder.rs (L807-811)
```rust
        let metadata_txn = if let Some(maybe_rand) = rand_result {
            block.new_metadata_with_randomness(&validator, maybe_rand)
        } else {
            block.new_block_metadata(&validator).into()
        };
```

**File:** consensus/consensus-types/src/block.rs (L580-594)
```rust
    pub fn new_block_metadata(&self, validators: &[AccountAddress]) -> BlockMetadata {
        BlockMetadata::new(
            self.id(),
            self.epoch(),
            self.round(),
            self.author().unwrap_or(AccountAddress::ZERO),
            self.previous_bitvec().into(),
            // For nil block, we use 0x0 which is convention for nil address in move.
            self.block_data()
                .failed_authors()
                .map_or(vec![], |failed_authors| {
                    Self::failed_authors_to_indices(validators, failed_authors)
                }),
            self.timestamp_usecs(),
        )
```

**File:** consensus/consensus-types/src/block.rs (L597-610)
```rust
    pub fn new_metadata_with_randomness(
        &self,
        validators: &[AccountAddress],
        randomness: Option<Randomness>,
    ) -> BlockMetadataExt {
        BlockMetadataExt::new_v1(
            self.id(),
            self.epoch(),
            self.round(),
            self.author().unwrap_or(AccountAddress::ZERO),
            self.previous_bitvec().into(),
            // For nil block, we use 0x0 which is convention for nil address in move.
            self.block_data()
                .failed_authors()
```

**File:** consensus/src/epoch_manager.rs (L1195-1197)
```rust
        if let Err(error) = &randomness_config_move_struct {
            warn!("Failed to read on-chain randomness config {}", error);
        }
```

**File:** types/src/on_chain_config/execution_config.rs (L10-24)
```rust
/// The on-chain execution config, in order to be able to add fields, we use enum to wrap the actual struct.
#[derive(Clone, Debug, Deserialize, PartialEq, Eq, Serialize)]
pub enum OnChainExecutionConfig {
    V1(ExecutionConfigV1),
    V2(ExecutionConfigV2),
    V3(ExecutionConfigV3),
    /// To maintain backwards compatibility on replay, we must ensure that any new features resolve
    /// to previous behavior (before OnChainExecutionConfig was registered) in case of Missing.
    Missing,
    // Reminder: Add V4 and future versions here, after Missing (order matters for enums).
    V4(ExecutionConfigV4),
    V5(ExecutionConfigV5),
    V6(ExecutionConfigV6),
    V7(ExecutionConfigV7),
}
```
