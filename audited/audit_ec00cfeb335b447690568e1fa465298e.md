# Audit Report

## Title
State Snapshot Finalization Fails to Write StateKvCommitProgress Leading to Panic on Restart

## Summary
The `finalize_state_snapshot()` function writes `OverallCommitProgress` and `LedgerCommitProgress` to the ledger database but fails to commit the state KV batches or write `StateKvCommitProgress`. This leaves the database in an inconsistent state where subsequent restarts trigger a panic in `sync_commit_progress()` when it expects all progress markers to exist atomically.

## Finding Description

The vulnerability exists in the state snapshot finalization flow, which breaks the **State Consistency** invariant requiring atomic state transitions.

When a node completes state snapshot restoration via `finalize_state_snapshot()`, it creates batches for both ledger and state KV data but only persists the ledger batches: [1](#0-0) 

The function passes these batches to `save_transactions()`: [2](#0-1) 

However, `save_transactions()` with a `Some(existing_batch)` parameter does NOT commit the state KV batches—it only populates them: [3](#0-2) 

After `save_transactions()` returns, `finalize_state_snapshot()` writes progress markers: [4](#0-3) 

But critically, it only writes the ledger batch: [5](#0-4) 

The `sharded_kv_batch` and `state_kv_metadata_batch` are never committed, meaning:
- State KV data is not persisted
- `StateKvCommitProgress` is not written

On the next node restart, `StateStore::new()` calls `sync_commit_progress()`: [6](#0-5) 

The `sync_commit_progress()` function expects `StateKvCommitProgress` to exist when `OverallCommitProgress` exists: [7](#0-6) 

Since `StateKvCommitProgress` is `None`, the node panics with "State K/V commit progress cannot be None", preventing restart.

## Impact Explanation

**High Severity** - This vulnerability causes:

1. **Validator Node Crashes**: Any validator performing state sync via snapshot restoration will crash on restart and cannot recover without manual database intervention
2. **Loss of Liveness**: Affected validators cannot participate in consensus, reducing network validator count
3. **State Inconsistency**: The database is left with ledger data but missing corresponding state KV data, violating atomicity guarantees

This meets **High Severity** criteria from the Aptos bug bounty:
- Validator node crashes (API crashes)
- Significant protocol violations (state consistency broken)

While not reaching Critical severity (doesn't cause consensus safety violations or permanent fund loss), it significantly impacts network availability and requires manual intervention to recover.

## Likelihood Explanation

**HIGH likelihood** - This occurs during normal node operations:

1. State snapshot restoration is a standard mechanism for nodes to catch up to the network
2. Fast sync and state sync both use this code path
3. Any node performing state sync will trigger this bug
4. The bug is deterministic—it will occur every time `finalize_state_snapshot()` is called
5. No attacker action required—this is a logic bug in normal operations

The combination of high likelihood and high impact makes this a critical operational issue.

## Recommendation

Add state KV batch commit to `finalize_state_snapshot()` before writing progress markers:

```rust
// After line 218 in aptosdb_writer.rs, add:
self.state_kv_db.commit(
    version,
    Some(state_kv_metadata_batch),
    sharded_kv_batch,
)?;
```

This ensures `StateKvCommitProgress` is written atomically with `OverallCommitProgress`, maintaining the invariant that `sync_commit_progress()` depends on.

Alternatively, modify `sync_commit_progress()` to handle missing `StateKvCommitProgress` gracefully by initializing it to match `OverallCommitProgress` when absent, though the first approach is cleaner.

## Proof of Concept

```rust
// Reproduction steps:
// 1. Start a fresh Aptos node
// 2. Trigger state snapshot restoration (via fast sync or state sync v2)
// 3. Let finalize_state_snapshot() complete
// 4. Restart the node
// Expected: Node panics with "State K/V commit progress cannot be None."

// The panic occurs at:
// storage/aptosdb/src/state_store/mod.rs:434
// when sync_commit_progress() is called during StateStore::new()

// To verify the bug:
// 1. Check ledger DB for OverallCommitProgress after finalization
// 2. Check state KV DB for StateKvCommitProgress - it will be absent
// 3. Restart triggers panic in sync_commit_progress()
```

**Notes:**

This vulnerability demonstrates a critical atomicity failure in the database initialization flow. The `open_dbs()` function itself opens databases correctly, but the state snapshot finalization process leaves databases in an inconsistent state that causes corruption on subsequent restart attempts, directly answering the security question about partial initialization.

The TODO comment at line 272-273 in `aptosdb_writer.rs` acknowledges this class of issues: "Write progress for each of the following databases, and handle the inconsistency at the startup time", indicating the developers were aware of potential consistency problems but did not fully address them.

### Citations

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L163-165)
```rust
            let mut ledger_db_batch = LedgerDbSchemaBatches::new();
            let mut sharded_kv_batch = self.state_kv_db.new_sharded_native_batches();
            let mut state_kv_metadata_batch = SchemaBatch::new();
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L183-198)
```rust
            restore_utils::save_transactions(
                self.state_store.clone(),
                self.ledger_db.clone(),
                version,
                &transactions,
                &persisted_aux_info,
                &transaction_infos,
                &events,
                wsets,
                Some((
                    &mut ledger_db_batch,
                    &mut sharded_kv_batch,
                    &mut state_kv_metadata_batch,
                )),
                false,
            )?;
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L207-218)
```rust
            ledger_db_batch
                .ledger_metadata_db_batches
                .put::<DbMetadataSchema>(
                    &DbMetadataKey::LedgerCommitProgress,
                    &DbMetadataValue::Version(version),
                )?;
            ledger_db_batch
                .ledger_metadata_db_batches
                .put::<DbMetadataSchema>(
                    &DbMetadataKey::OverallCommitProgress,
                    &DbMetadataValue::Version(version),
                )?;
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L223-223)
```rust
            self.ledger_db.write_schemas(ledger_db_batch)?;
```

**File:** storage/aptosdb/src/backup/restore_utils.rs (L131-144)
```rust
    if let Some((ledger_db_batch, state_kv_batches, _state_kv_metadata_batch)) = existing_batch {
        save_transactions_impl(
            state_store,
            ledger_db,
            first_version,
            txns,
            persisted_aux_info,
            txn_infos,
            events,
            write_sets.as_ref(),
            ledger_db_batch,
            state_kv_batches,
            kv_replay,
        )?;
```

**File:** storage/aptosdb/src/state_store/mod.rs (L354-359)
```rust
            Self::sync_commit_progress(
                Arc::clone(&ledger_db),
                Arc::clone(&state_kv_db),
                Arc::clone(&state_merkle_db),
                /*crash_if_difference_is_too_large=*/ true,
            );
```

**File:** storage/aptosdb/src/state_store/mod.rs (L417-436)
```rust
        if let Some(overall_commit_progress) = ledger_metadata_db
            .get_synced_version()
            .expect("DB read failed.")
        {
            info!(
                overall_commit_progress = overall_commit_progress,
                "Start syncing databases..."
            );
            let ledger_commit_progress = ledger_metadata_db
                .get_ledger_commit_progress()
                .expect("Failed to read ledger commit progress.");
            assert_ge!(ledger_commit_progress, overall_commit_progress);

            let state_kv_commit_progress = state_kv_db
                .metadata_db()
                .get::<DbMetadataSchema>(&DbMetadataKey::StateKvCommitProgress)
                .expect("Failed to read state K/V commit progress.")
                .expect("State K/V commit progress cannot be None.")
                .expect_version();
            assert_ge!(state_kv_commit_progress, overall_commit_progress);
```
