# Audit Report

## Title
Day Boundary Race Condition in Redis Rate Limiter Allows Negative Counter Accumulation and Rate Limit Bypass

## Summary
The `RedisRatelimitChecker` generates Redis keys based on the current day, calculated independently in both `check()` and `complete()` methods. When a request is processed across a day boundary (e.g., `check()` at 23:59:59, `complete()` at 00:00:01), these methods operate on different Redis keys for different days. This causes the previous day's counter to be incremented without decrement, while the new day's counter is decremented without prior increment, resulting in a negative balance that allows bypassing rate limits.

## Finding Description
The vulnerability exists in how Redis keys are generated for rate limiting. [1](#0-0) 

Both `check()` and `complete()` call `get_key_and_secs_until_next_day()` independently, which includes the current day in the key using `days_since_tap_epoch(get_current_time_secs())`. [2](#0-1) 

**Attack Scenario:**

1. Attacker sends a request at 23:59:59 on Day N
2. `check()` generates key `"ip:X.X.X.X:N"` and increments counter for Day N (e.g., 0 â†’ 1) [3](#0-2) 
3. Request processing experiences delay (network latency, high load, slow blockchain response)
4. Funding operation fails with 500 error at 00:00:01 on Day N+1
5. `complete()` generates key `"ip:X.X.X.X:N+1"` (different key!) and decrements counter for Day N+1 [4](#0-3) 
6. Redis DECR operation on non-existent or zero-value key results in -1 [5](#0-4) 
7. The limit check allows requests when `limit_value <= max_requests_per_day`, so -1 passes [6](#0-5) 
8. Attacker can now make `(max_requests_per_day + 1)` requests on Day N+1

By repeating this attack (e.g., 100 times over multiple days), the attacker accumulates a large negative balance (e.g., -100), allowing `max_requests_per_day + 100` requests, effectively bypassing rate limiting.

## Impact Explanation
This vulnerability qualifies as **High Severity** under the Aptos bug bounty program for the following reasons:

1. **Significant Protocol Violation**: Completely bypasses the intended rate limiting mechanism designed to prevent faucet abuse
2. **Fund Drainage**: Allows attackers to drain faucet funds beyond intended limits by accumulating negative balances over time
3. **Service Degradation**: Enables resource exhaustion attacks against the faucet service
4. **No Privileged Access Required**: Exploitable by any unprivileged user with basic knowledge of the system

While this affects the faucet (not consensus or core blockchain), the faucet is a critical infrastructure component for testnet/devnet operations, and its compromise constitutes a significant protocol violation per the bug bounty criteria.

## Likelihood Explanation
**Likelihood: Medium to High**

**Natural Occurrence:**
- Requests near midnight boundaries happen regularly
- Any request taking >1 second to process near midnight will trigger this
- Network latency, blockchain node congestion, or database slowdowns increase probability

**Deliberate Exploitation:**
- Attacker can deliberately send requests at 23:59:59 to maximize probability
- Can use complex request parameters to induce processing delays
- Can target times of known high load or maintenance windows
- No special permissions or insider knowledge required
- Attack can be automated and repeated indefinitely

**Cumulative Effect:**
- Each successful attack builds up negative balance
- Over weeks/months, attacker can accumulate very large negative values
- Makes the attack increasingly severe over time

## Recommendation
Capture the day value once at request initiation and pass it through the execution pipeline to ensure `check()` and `complete()` operate on the same Redis key.

**Recommended Fix:**

1. Modify `CheckerData` to include the day value:
```rust
pub struct CheckerData {
    pub time_request_received_secs: u64,
    pub day_value: u64,  // Add this field
    pub receiver: AccountAddress,
    pub source_ip: IpAddr,
    pub headers: Arc<HeaderMap>,
}
```

2. Calculate day once in `fund.rs` when creating `CheckerData`: [7](#0-6) 

3. Modify `get_key_and_secs_until_next_day()` to accept day as parameter instead of calculating it

4. Use the captured day value in both `check()` and `complete()` to ensure they operate on the same key

Alternatively, implement idempotency by:
- Adding a unique request ID to track which requests have had `complete()` called
- Storing the increment/decrement operations in a transaction log
- Using Redis transactions (MULTI/EXEC) to ensure atomic check-increment-complete operations

## Proof of Concept
```rust
#[cfg(test)]
mod tests {
    use super::*;
    
    #[tokio::test]
    async fn test_day_boundary_negative_counter() {
        // Setup Redis connection and checker
        let config = RedisRatelimitCheckerConfig {
            database_address: "localhost".to_string(),
            database_port: 6379,
            database_number: 0,
            database_user: None,
            database_password: None,
            max_requests_per_day: 10,
            ratelimit_key_provider_config: RatelimitKeyProviderConfig::Ip,
        };
        let checker = RedisRatelimitChecker::new(config).await.unwrap();
        
        // Create checker data
        let checker_data = CheckerData {
            receiver: AccountAddress::from_hex_literal("0x1").unwrap(),
            source_ip: "192.168.1.1".parse().unwrap(),
            headers: Arc::new(HeaderMap::new()),
            time_request_received_secs: get_current_time_secs(),
        };
        
        // Simulate request at end of day
        // Mock time to be 23:59:59 - requires time injection mechanism
        
        // Call check() - increments counter for day N
        checker.check(checker_data.clone(), false).await.unwrap();
        
        // Simulate delay crossing midnight
        // Mock time to be 00:00:01 of next day
        
        // Call complete() with 500 error - decrements counter for day N+1
        let complete_data = CompleteData {
            checker_data,
            txn_hashes: vec![],
            response_is_500: true,
        };
        checker.complete(complete_data).await.unwrap();
        
        // Verify: Day N counter should be 1, Day N+1 counter should be -1
        // This allows max_requests_per_day + 1 requests on Day N+1
    }
}
```

**Note:** Full PoC requires time injection/mocking capabilities or manual testing near actual midnight boundaries.

## Notes
While the security question mentions "retry logic" as the cause, the actual vulnerability stems from a race condition at day boundaries rather than explicit retry mechanisms. The application code contains no retry logic that would call `complete()` multiple times for a single request. However, the day boundary issue achieves the same exploitable outcome: negative counters that bypass rate limiting. The lack of idempotency protection and the independent calculation of day values in `check()` and `complete()` create this critical vulnerability.

### Citations

**File:** crates/aptos-faucet/core/src/checkers/redis_ratelimit.rs (L186-200)
```rust
    fn get_key_and_secs_until_next_day(
        &self,
        ratelimit_key_prefix: &str,
        ratelimit_key_value: &str,
    ) -> (String, u64) {
        let now_secs = get_current_time_secs();
        let seconds_until_next_day = seconds_until_next_day(now_secs);
        let key = format!(
            "{}:{}:{}",
            ratelimit_key_prefix,
            ratelimit_key_value,
            days_since_tap_epoch(now_secs)
        );
        (key, seconds_until_next_day)
    }
```

**File:** crates/aptos-faucet/core/src/checkers/redis_ratelimit.rs (L202-221)
```rust
    fn check_limit_value(
        &self,
        limit_value: Option<i64>,
        seconds_until_next_day: u64,
    ) -> Option<RejectionReason> {
        if limit_value.unwrap_or(0) > self.args.max_requests_per_day as i64 {
            Some(
                RejectionReason::new(
                    format!(
                        "You have reached the maximum allowed number of requests per day: {}",
                        self.args.max_requests_per_day
                    ),
                    RejectionReasonCode::UsageLimitExhausted,
                )
                .retry_after(seconds_until_next_day),
            )
        } else {
            None
        }
    }
```

**File:** crates/aptos-faucet/core/src/checkers/redis_ratelimit.rs (L236-243)
```rust
        // Generate a key corresponding to this identifier and the current day.
        let key_prefix = self.ratelimit_key_provider.ratelimit_key_prefix();
        let key_value = self
            .ratelimit_key_provider
            .ratelimit_key_value(&data)
            .await?;
        let (key, seconds_until_next_day) =
            self.get_key_and_secs_until_next_day(key_prefix, &key_value);
```

**File:** crates/aptos-faucet/core/src/checkers/redis_ratelimit.rs (L321-326)
```rust
        let key_prefix = self.ratelimit_key_provider.ratelimit_key_prefix();
        let key_value = self
            .ratelimit_key_provider
            .ratelimit_key_value(&data.checker_data)
            .await?;
        let (key, _) = self.get_key_and_secs_until_next_day(key_prefix, &key_value);
```

**File:** crates/aptos-faucet/core/src/checkers/redis_ratelimit.rs (L328-333)
```rust
        let _: () = conn.decr(&key, 1).await.map_err(|e| {
            AptosTapError::new_with_error_code(
                format!("Failed to decrement value for redis key {}: {}", key, e),
                AptosTapErrorCode::StorageError,
            )
        })?;
```

**File:** crates/aptos-faucet/core/src/helpers.rs (L33-35)
```rust
pub fn days_since_tap_epoch(current_time_secs: u64) -> u64 {
    (current_time_secs - TAP_EPOCH_SECS) / 86400
}
```

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L237-242)
```rust
        let checker_data = CheckerData {
            receiver,
            source_ip,
            headers: Arc::new(header_map.clone()),
            time_request_received_secs: get_current_time_secs(),
        };
```
