# Audit Report

## Title
Unbounded Memory Exhaustion in `/request_captcha` Endpoint Due to Missing Rate Limiting

## Summary
The `/request_captcha` endpoint lacks IP-based rate limiting, allowing an attacker to generate unlimited captcha challenges and exhaust server memory through unbounded HashMap growth, leading to faucet service denial.

## Finding Description

The `request_captcha()` function in the Aptos faucet service creates captcha challenges without any rate limiting controls. [1](#0-0) 

Each request generates a new captcha challenge that is stored in an unbounded `HashMap<u32, String>` within the `CaptchaManager` structure. [2](#0-1) 

The `create_challenge()` method generates a random key and inserts it into the HashMap without any size checks or cleanup mechanisms. [3](#0-2) 

**The developers explicitly acknowledged this vulnerability in their code comments:** [4](#0-3) 

While the faucet implements IP-based rate limiting through `MemoryRatelimitChecker` and `RedisRatelimitChecker`, these protections are **only applied to the `/fund` endpoint** via the `preprocess_request()` function. [5](#0-4) 

The `/request_captcha` endpoint operates independently and never invokes any checker validation, leaving it completely unprotected against abuse.

**Attack Scenario:**
1. Attacker scripts thousands of GET requests to `/request_captcha`
2. Each request creates a new HashMap entry storing `(u32_key, String_value)`
3. No cleanup mechanism removes old/stale entries
4. HashMap grows unbounded until server OOM
5. Faucet service crashes, denying service to legitimate users

This violates the **Resource Limits** invariant: "All operations must respect gas, storage, and computational limits."

## Impact Explanation

**Severity: HIGH** (up to $50,000 per Aptos Bug Bounty criteria)

This vulnerability causes:
- **API crashes** through memory exhaustion
- **Service unavailability** preventing legitimate testnet/devnet users from funding accounts
- **Validator node slowdowns** if the faucet runs on validator infrastructure

The impact qualifies as HIGH severity because it enables a denial-of-service attack that crashes the faucet API service, which is critical infrastructure for Aptos testnet/devnet operations.

## Likelihood Explanation

**Likelihood: VERY HIGH**

This attack is trivial to execute:
- No authentication required (public GET endpoint)
- Single HTTP client can generate thousands of requests per second
- No CAPTCHA solving required (ironically, requesting captchas is unprotected)
- Attack can be scripted in minutes
- Low resource requirement for attacker (simple HTTP flooding)

The developers' warning comment indicates they were aware of this issue but it remains unmitigated.

## Recommendation

**Immediate Fix:** Apply the existing rate limiting checkers to the `/request_captcha` endpoint.

**Option 1 - Reuse Existing Infrastructure:**
Modify `CaptchaApi` to use the same `FundApiComponents::preprocess_request()` pattern:

```rust
async fn request_captcha(
    &self,
    source_ip: RealIp,
    header_map: &HeaderMap,
) -> Result<Response<Binary<Vec<u8>>>, AptosTapErrorResponse> {
    if !self.enabled {
        return Err(AptosTapError::new(
            "The CaptchaChecker is not enabled".to_string(),
            AptosTapErrorCode::EndpointNotEnabled,
        )
        .into());
    }
    
    // Apply rate limiting before generating captcha
    self.fund_api_components
        .preprocess_request(&dummy_fund_request, source_ip, header_map, true)
        .await?;
    
    let mut captcha_manager = self.captcha_manager.lock().await;
    let (key, image) = match captcha_manager.create_challenge() {
        Ok((key, image)) => (key, image),
        Err(e) => {
            return Err(
                AptosTapError::new_with_error_code(e, AptosTapErrorCode::CheckerError).into(),
            );
        },
    };
    Ok(Response::new(Binary(image)).header(CAPTCHA_KEY, key))
}
```

**Option 2 - Add Cleanup Mechanism:**
Implement automatic cleanup of stale challenges:

```rust
pub struct CaptchaManager {
    challenges: HashMap<u32, (String, u64)>, // Add timestamp
    max_challenges: usize,
}

impl CaptchaManager {
    pub fn create_challenge(&mut self) -> Result<(u32, Vec<u8>)> {
        // Remove expired challenges (e.g., older than 5 minutes)
        let now = get_current_time_secs();
        self.challenges.retain(|_, (_, timestamp)| now - *timestamp < 300);
        
        // Enforce maximum size
        if self.challenges.len() >= self.max_challenges {
            bail!("Too many pending challenges, try again later");
        }
        
        // ... rest of implementation
    }
}
```

## Proof of Concept

```bash
#!/bin/bash
# Simple PoC demonstrating memory exhaustion attack

FAUCET_URL="http://localhost:8081/request_captcha"
REQUESTS=100000

echo "Flooding faucet with captcha requests..."
for i in $(seq 1 $REQUESTS); do
    curl -s "$FAUCET_URL" > /dev/null &
    if [ $((i % 1000)) -eq 0 ]; then
        echo "Sent $i requests..."
    fi
done

wait
echo "Attack complete. Monitor faucet memory usage."
```

**Expected Result:**
- Faucet memory usage grows linearly with requests
- After sufficient requests (depends on available RAM), faucet crashes with OOM error
- Service becomes unavailable

**Validation:**
Monitor memory with `ps aux | grep faucet` or container metrics. The RSS (Resident Set Size) will continuously increase until the process is killed by the OOM killer.

---

**Notes:**

The vulnerability is **confirmed by the developers' own warning comment** acknowledging the OOM risk. The rate limiting infrastructure already exists in the codebase but was never applied to the captcha endpoint, representing a critical oversight in the security design. This is a straightforward denial-of-service vulnerability that meets all validation criteria for a HIGH severity finding.

### Citations

**File:** crates/aptos-faucet/core/src/endpoints/captcha.rs (L40-58)
```rust
    async fn request_captcha(&self) -> Result<Response<Binary<Vec<u8>>>, AptosTapErrorResponse> {
        if !self.enabled {
            return Err(AptosTapError::new(
                "The CaptchaChecker is not enabled".to_string(),
                AptosTapErrorCode::EndpointNotEnabled,
            )
            .into());
        }
        let mut captcha_manager = self.captcha_manager.lock().await;
        let (key, image) = match captcha_manager.create_challenge() {
            Ok((key, image)) => (key, image),
            Err(e) => {
                return Err(
                    AptosTapError::new_with_error_code(e, AptosTapErrorCode::CheckerError).into(),
                );
            },
        };
        Ok(Response::new(Binary(image)).header(CAPTCHA_KEY, key))
    }
```

**File:** crates/aptos-faucet/core/src/checkers/tap_captcha.rs (L4-6)
```rust
//! Warning: This could be attacked and cause the server to OOM because we
//! don't throw out captchas info if it has been sitting there for too long /
//! the map grows too large.
```

**File:** crates/aptos-faucet/core/src/checkers/tap_captcha.rs (L125-131)
```rust
#[derive(Debug, Default)]
pub struct CaptchaManager {
    /// When a challenge is created, we return to the client the captcha itself
    /// and a random key they must make the second request with. This is a map
    /// from that random key to the value of the captcha.
    challenges: HashMap<u32, String>,
}
```

**File:** crates/aptos-faucet/core/src/checkers/tap_captcha.rs (L142-162)
```rust
    pub fn create_challenge(&mut self) -> Result<(u32, Vec<u8>)> {
        // Generate a random key.
        let key = rand::thread_rng().gen_range(0, u32::MAX - 1);

        // Generate a captcha.
        let (name, image) = Captcha::new()
            .add_chars(5)
            .apply_filter(Noise::new(0.4))
            .apply_filter(Wave::new(4.0, 6.0).vertical())
            .apply_filter(Wave::new(3.0, 2.0).horizontal())
            .apply_filter(Grid::new(10, 6))
            .apply_filter(Dots::new(8))
            .as_tuple()
            .context("Failed to generate captcha")?;

        // Store the captcha information.
        self.challenges.insert(key, name);

        // Return (key, <captcha as base64>).
        Ok((key, image))
    }
```

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L197-281)
```rust
    async fn preprocess_request(
        &self,
        fund_request: &FundRequest,
        source_ip: RealIp,
        header_map: &HeaderMap,
        dry_run: bool,
    ) -> poem::Result<(CheckerData, bool, Option<SemaphorePermit<'_>>), AptosTapError> {
        let permit = match &self.concurrent_requests_semaphore {
            Some(semaphore) => match semaphore.try_acquire() {
                Ok(permit) => Some(permit),
                Err(_) => {
                    return Err(AptosTapError::new(
                        "Server overloaded, please try again later".to_string(),
                        AptosTapErrorCode::ServerOverloaded,
                    ))
                },
            },
            None => None,
        };

        let source_ip = match source_ip.0 {
            Some(ip) => ip,
            None => {
                return Err(AptosTapError::new(
                    "No source IP found in the request".to_string(),
                    AptosTapErrorCode::SourceIpMissing,
                ))
            },
        };

        let receiver = match fund_request.receiver() {
            Some(receiver) => receiver,
            None => {
                return Err(AptosTapError::new(
                    "Account address, auth key, or pub key must be provided and valid".to_string(),
                    AptosTapErrorCode::InvalidRequest,
                ))
            },
        };

        let checker_data = CheckerData {
            receiver,
            source_ip,
            headers: Arc::new(header_map.clone()),
            time_request_received_secs: get_current_time_secs(),
        };

        // See if this request meets the criteria to bypass checkers / storage.
        for bypasser in &self.bypassers {
            if bypasser
                .request_can_bypass(checker_data.clone())
                .await
                .map_err(|e| {
                    AptosTapError::new_with_error_code(e, AptosTapErrorCode::BypasserError)
                })?
            {
                info!(
                    "Allowing request from {} to bypass checks / storage",
                    source_ip
                );
                return Ok((checker_data, true, permit));
            }
        }

        // Ensure request passes checkers.
        let mut rejection_reasons = Vec::new();
        for checker in &self.checkers {
            rejection_reasons.extend(checker.check(checker_data.clone(), dry_run).await.map_err(
                |e| AptosTapError::new_with_error_code(e, AptosTapErrorCode::CheckerError),
            )?);
            if !rejection_reasons.is_empty() && self.return_rejections_early {
                break;
            }
        }

        if !rejection_reasons.is_empty() {
            return Err(AptosTapError::new(
                format!("Request rejected by {} checkers", rejection_reasons.len()),
                AptosTapErrorCode::Rejected,
            )
            .rejection_reasons(rejection_reasons));
        }

        Ok((checker_data, false, permit))
    }
```
