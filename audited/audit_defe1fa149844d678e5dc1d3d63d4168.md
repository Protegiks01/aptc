# Audit Report

## Title
Transaction Hash Validation Bypass in Replay Functionality Allows Transaction Spoofing

## Summary
The `Replay::execute()` function in the Aptos CLI fails to validate that the locally computed transaction hash matches the authoritative transaction hash stored in `TransactionInfo`. This allows a malicious REST API endpoint to return a different transaction than what was actually committed on-chain, as long as it produces identical execution outputs.

## Finding Description

The replay functionality fetches a committed transaction and its metadata from a REST API endpoint, then re-executes it locally to verify deterministic execution. However, a critical validation step is missing. [1](#0-0) 

The transaction is fetched from the REST API and the hash is computed locally: [2](#0-1) 

The `committed_hash` field uses a `OnceCell` that is marked with `#[serde(skip)]`, meaning it's never deserialized from the network response—it's always computed locally from the transaction data provided by the REST API. [3](#0-2) 

After execution, the validation only checks execution outputs, NOT the transaction hash: [4](#0-3) 

The `ensure_match_transaction_info` function validates status, gas used, write set hash, and event root hash: [5](#0-4) 

**Critical Gap**: The function never checks if `txn.committed_hash()` matches `txn_info.transaction_hash()`. The authoritative transaction hash exists in `TransactionInfo`: [6](#0-5) [7](#0-6) 

**Attack Scenario**: 
1. User runs: `aptos move replay --network <malicious_endpoint> --txn-id 12345`
2. Malicious REST API returns:
   - Transaction A' (modified payload/signature)
   - TransactionInfo for original transaction A (contains correct hash and outputs for A)
3. Replay computes hash from A', executes A'
4. If A' produces identical outputs to A, validation passes
5. User believes they replayed transaction A, but actually replayed A'

## Impact Explanation

**Medium Severity** - This qualifies as "State inconsistencies requiring intervention" per the Aptos bug bounty program. While it doesn't directly cause loss of funds or consensus violations, it breaks the **Cryptographic Correctness** invariant by failing to validate transaction hashes against their authoritative values.

**Security Implications**:
- **Transaction Spoofing**: Attackers can mislead users about transaction content during replay
- **Audit Trail Corruption**: Security auditors using replay for forensics may analyze wrong transactions
- **Misleading Diagnostics**: Debugging tools relying on replay will produce incorrect analysis
- **Gas Profiling Manipulation**: Gas profiling reports will have incorrect transaction hashes

This is particularly concerning for compliance and audit scenarios where transaction replay is used to verify historical executions.

## Likelihood Explanation

**Medium Likelihood**:
- Requires attacker to control the REST endpoint (via MITM attack or user connecting to malicious node)
- Attacker must craft replacement transaction with identical outputs (difficult for complex transactions, trivial for simple ones)
- Users may use custom REST endpoints for testing/debugging, increasing attack surface
- No special permissions required—any user can be affected

The attack becomes more feasible for:
- Simple transfer transactions (easy to replicate outputs)
- Testing environments where users point to untrusted endpoints
- Man-in-the-middle scenarios on unsecured networks

## Recommendation

Add transaction hash validation in the `ensure_match_transaction_info` function or directly in `Replay::execute()`:

**Option 1 - Add to validation function**:
```rust
// In types/src/transaction/mod.rs, ensure_match_transaction_info()
pub fn ensure_match_transaction_info(
    &self,
    version: Version,
    txn_info: &TransactionInfo,
    txn_hash: HashValue,  // Add this parameter
    expected_write_set: Option<&WriteSet>,
    expected_events: Option<&[ContractEvent]>,
) -> Result<()> {
    const ERR_MSG: &str = "TransactionOutput does not match TransactionInfo";
    
    // Add hash validation FIRST
    ensure!(
        txn_hash == txn_info.transaction_hash(),
        "{}: version:{}, transaction_hash:{:?}, expected:{:?}",
        ERR_MSG,
        version,
        txn_hash,
        txn_info.transaction_hash(),
    );
    
    // ... rest of existing validation
}
```

**Option 2 - Add to Replay::execute()** (simpler, focused fix):
```rust
// In crates/aptos/src/move_tool/mod.rs, Replay::execute()
let hash = txn.committed_hash();

// Validate transaction hash BEFORE execution
if hash != txn_info.transaction_hash() {
    return Err(CliError::UnexpectedError(format!(
        "Transaction hash mismatch: computed={}, expected={}",
        hash,
        txn_info.transaction_hash()
    )));
}
```

**Recommended**: Option 2 is cleaner as it validates at the point where the discrepancy matters, before spending resources on execution.

## Proof of Concept

```rust
// Test case demonstrating the vulnerability
#[tokio::test]
async fn test_replay_hash_validation_bypass() {
    use aptos_types::transaction::{Transaction, SignedTransaction, TransactionInfo};
    use aptos_crypto::HashValue;
    
    // Simulate malicious REST API behavior
    // 1. Craft a fake transaction (Transaction A')
    let fake_txn = create_simple_transfer_transaction(
        sender_address,
        recipient_address_modified,  // Different recipient
        100_000,
    );
    
    // 2. Get TransactionInfo for the real transaction (Transaction A)
    let real_txn_info = TransactionInfo::new(
        real_transaction_hash,  // Hash of the real transaction
        state_change_hash,      // These outputs happen to match
        event_root_hash,
        Some(state_checkpoint_hash),
        gas_used,
        ExecutionStatus::Success,
        None,
    );
    
    // 3. Simulate replay
    let computed_hash = fake_txn.committed_hash();
    
    // 4. Execute fake transaction
    let (vm_status, vm_output) = execute_transaction(fake_txn);
    
    // 5. Current validation PASSES even though hashes don't match
    let txn_output = vm_output.try_materialize_into_transaction_output(&resolver)?;
    
    // This should fail but currently passes:
    assert!(txn_output.ensure_match_transaction_info(
        version,
        &real_txn_info,
        None,
        None
    ).is_ok());
    
    // But the hashes don't match!
    assert_ne!(computed_hash, real_txn_info.transaction_hash());
    
    // User thinks they replayed the real transaction but actually replayed fake_txn
}
```

**Notes**

The vulnerability exists because the replay functionality was designed to validate execution determinism (same inputs → same outputs) but not transaction authenticity (correct transaction was provided). The `TransactionInfo.transaction_hash` field exists precisely for this validation purpose but is never checked. This represents a gap in the defense-in-depth strategy for transaction replay integrity.

### Citations

**File:** crates/aptos/src/move_tool/mod.rs (L2404-2418)
```rust
        let (txn, txn_info, aux_info) = debugger
            .get_committed_transaction_at_version(self.txn_id)
            .await?;

        let txn = match txn {
            Transaction::UserTransaction(txn) => txn,
            _ => {
                return Err(CliError::UnexpectedError(
                    "Unsupported transaction type. Only user transactions are supported."
                        .to_string(),
                ))
            },
        };

        let hash = txn.committed_hash();
```

**File:** crates/aptos/src/move_tool/mod.rs (L2463-2467)
```rust
        if !self.skip_comparison {
            txn_output
                .ensure_match_transaction_info(self.txn_id, &txn_info, None, None)
                .map_err(|msg| CliError::UnexpectedError(msg.to_string()))?;
        }
```

**File:** types/src/transaction/mod.rs (L1047-1057)
```rust
    #[serde(skip)]
    raw_txn_size: OnceCell<usize>,

    /// A cached size of the authenticator.
    /// Prevents serializing the same authenticator multiple times to determine size.
    #[serde(skip)]
    authenticator_size: OnceCell<usize>,

    /// A cached hash of the transaction.
    #[serde(skip)]
    committed_hash: OnceCell<HashValue>,
```

**File:** types/src/transaction/mod.rs (L1335-1339)
```rust
    pub fn committed_hash(&self) -> HashValue {
        *self
            .committed_hash
            .get_or_init(|| Transaction::UserTransaction(self.clone()).hash())
    }
```

**File:** types/src/transaction/mod.rs (L1869-1927)
```rust
    pub fn ensure_match_transaction_info(
        &self,
        version: Version,
        txn_info: &TransactionInfo,
        expected_write_set: Option<&WriteSet>,
        expected_events: Option<&[ContractEvent]>,
    ) -> Result<()> {
        const ERR_MSG: &str = "TransactionOutput does not match TransactionInfo";

        let expected_txn_status: TransactionStatus = txn_info.status().clone().into();
        ensure!(
            self.status() == &expected_txn_status,
            "{}: version:{}, status:{:?}, auxiliary data:{:?}, expected:{:?}",
            ERR_MSG,
            version,
            self.status(),
            self.auxiliary_data(),
            expected_txn_status,
        );

        ensure!(
            self.gas_used() == txn_info.gas_used(),
            "{}: version:{}, gas_used:{:?}, expected:{:?}",
            ERR_MSG,
            version,
            self.gas_used(),
            txn_info.gas_used(),
        );

        let write_set_hash = CryptoHash::hash(self.write_set());
        ensure!(
            write_set_hash == txn_info.state_change_hash(),
            "{}: version:{}, write_set_hash:{:?}, expected:{:?}, write_set: {:?}, expected(if known): {:?}",
            ERR_MSG,
            version,
            write_set_hash,
            txn_info.state_change_hash(),
            self.write_set,
            expected_write_set,
        );

        let event_hashes = self
            .events()
            .iter()
            .map(CryptoHash::hash)
            .collect::<Vec<_>>();
        let event_root_hash = InMemoryEventAccumulator::from_leaves(&event_hashes).root_hash;
        ensure!(
            event_root_hash == txn_info.event_root_hash(),
            "{}: version:{}, event_root_hash:{:?}, expected:{:?}, events: {:?}, expected(if known): {:?}",
            ERR_MSG,
            version,
            event_root_hash,
            txn_info.event_root_hash(),
            self.events(),
            expected_events,
        );

        Ok(())
```

**File:** types/src/transaction/mod.rs (L2034-2035)
```rust
    /// The hash of this transaction.
    transaction_hash: HashValue,
```

**File:** types/src/transaction/mod.rs (L2074-2076)
```rust
    pub fn transaction_hash(&self) -> HashValue {
        self.transaction_hash
    }
```
