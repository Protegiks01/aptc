# Audit Report

## Title
State Sync Infinite Retry Loop on Deterministic Delayed Values Code Invariant Errors

## Summary
During state synchronization, if `code_invariant_error()` is triggered by a deterministic bug in the delayed values implementation, a validator enters an infinite retry loop attempting to execute the same problematic block repeatedly, causing permanent desynchronization from the network.

## Finding Description

The Aptos state synchronization system lacks a proper recovery mechanism when `code_invariant_error()` is triggered during block execution. This error type, defined in the delayed values module, is designed to catch "bugs in the code" but creates a critical failure mode during state sync. [1](#0-0) 

When this error occurs during execution, it propagates as a `BlockExecutionError::FatalBlockExecutorError(PanicError::CodeInvariantError)` and is converted to `VMStatus::Error` with the `DELAYED_FIELD_OR_BLOCKSTM_CODE_INVARIANT_ERROR` status code: [2](#0-1) 

This error propagates through the execution pipeline to the storage synchronizer, which calls `handle_storage_synchronizer_error`: [3](#0-2) 

The error notification is sent to the driver: [4](#0-3) 

The driver's error handler terminates the active stream with `InvalidPayloadData` feedback: [5](#0-4) 

The continuous syncer resets the stream and may fallback to output syncing: [6](#0-5) 

**The Critical Flaw:** After the stream reset, the periodic `drive_progress` loop creates a new stream starting from the same ledger version that caused the error. If the error is deterministic (caused by specific transaction data in that block), the validator will:

1. Execute the problematic block
2. Hit `code_invariant_error()`
3. Reset the stream with error notification
4. Retry from the same version
5. Repeat steps 1-4 indefinitely

Multiple scenarios in the delayed values implementation can trigger deterministic code invariant errors:

**Width Mismatch:** [7](#0-6) 

**Conversion Failures:** [8](#0-7) 

**Width Validation:** [9](#0-8) 

**Derived String Issues:** [10](#0-9) 

Even with output syncing fallback, if the error occurs during output application (which also processes delayed fields for materialization), the fallback provides no relief.

## Impact Explanation

This qualifies as **High Severity** under the Aptos bug bounty criteria for "Validator node slowdowns" and "Significant protocol violations."

**Impact Quantification:**
- Affected validator becomes permanently stuck and cannot sync to current blockchain state
- Validator cannot participate in consensus
- If multiple validators are affected by the same deterministic bug, network liveness could be impacted
- Requires manual intervention or hardfork to recover
- Violates the "State Consistency" critical invariant: validators diverge permanently

The vulnerability breaks deterministic execution guarantees because while the error indicates a code bug, different validators may encounter it at different times or under different conditions due to timing, state loading order, or subtle implementation differences.

## Likelihood Explanation

**Likelihood: Medium-High**

The likelihood depends on the existence of latent bugs in the delayed values implementation that can be triggered by specific transaction patterns. Given that:

1. The delayed values system is complex with multiple error conditions
2. Code invariant errors are explicitly designed to catch "bugs in the code"
3. The retry loop has no escape mechanism or retry limit
4. No circuit breaker exists to detect repeated failures on the same block
5. Multiple validators could be affected simultaneously if the bug is deterministic

If any delayed values bug exists that triggers `code_invariant_error()` for a specific block, permanent desync is guaranteed. The error recovery design assumes transient failures, not deterministic errors.

## Recommendation

Implement a circuit breaker mechanism in the state synchronizer to detect repeated failures on the same block:

1. Track consecutive failures for each ledger version
2. After N failures (e.g., 3-5 retries), mark the block as "poisoned"
3. Skip execution and force fallback to output-only syncing for poisoned blocks
4. Add monitoring/alerting for code invariant errors during sync
5. Implement a maximum retry limit per block before escalating to manual intervention
6. Add detailed logging of the exact error context to aid debugging

Example fix location in `storage_synchronizer.rs`:
- Add a `HashMap<Version, u32>` to track failure counts per version
- In `handle_storage_synchronizer_error`, increment the counter
- If count exceeds threshold, force output-only mode permanently for that version
- Reset counter on successful processing

Additionally, consider graceful degradation:
- Allow validators to continue syncing past problematic blocks by accepting outputs without re-execution
- Implement consensus-level detection of validators stuck on specific blocks
- Add governance capability to mark known-bad blocks that should skip execution

## Proof of Concept

```rust
// Conceptual test demonstrating the infinite retry scenario
// File: state-sync/state-sync-driver/src/tests/permanent_desync.rs

#[tokio::test]
async fn test_code_invariant_error_causes_permanent_retry_loop() {
    // 1. Setup: Create a mock chunk executor that returns code invariant error
    //    for a specific block version (e.g., version 1000)
    let mut mock_executor = MockChunkExecutor::new();
    mock_executor
        .expect_enqueue_chunk_by_execution()
        .returning(|txn_list, _, _| {
            if txn_list.first_transaction_version().unwrap() == 1000 {
                // Simulate code_invariant_error being triggered
                Err(anyhow::anyhow!("Storage synchronizer error: Failed to execute the data chunk! Error: UnexpectedError(\"DELAYED_FIELD_OR_BLOCKSTM_CODE_INVARIANT_ERROR\")"))
            } else {
                Ok(())
            }
        });

    // 2. Initialize storage synchronizer with synced version 999
    let storage_syncer = StorageSynchronizer::new(
        Arc::new(mock_executor),
        // ... other params
    );

    // 3. Attempt to sync block at version 1000 multiple times
    for attempt in 1..=10 {
        let result = storage_syncer
            .execute_transactions(
                NotificationMetadata::new_for_test(attempt),
                create_transaction_list_at_version(1000),
                create_target_ledger_info(1000),
                None,
            )
            .await;

        // 4. Verify that each attempt fails with the same error
        assert!(result.is_err());
        assert!(result.unwrap_err().to_string().contains("DELAYED_FIELD_OR_BLOCKSTM_CODE_INVARIANT_ERROR"));

        // 5. Verify validator remains stuck at version 999
        assert_eq!(get_synced_version(), 999);
    }

    // 6. Demonstrate that validator never progresses past version 1000
    // even after many retry attempts, confirming permanent desync
    assert_eq!(get_synced_version(), 999); // Still stuck after 10 attempts
}
```

**Notes:**
- The actual vulnerability manifestation requires a real bug in delayed values that triggers `code_invariant_error()` deterministically
- This PoC demonstrates the retry loop behavior when such an error occurs
- Testing would require injecting a delayed field with malformed width/structure into a block at version 1000
- Real-world exploitation requires identifying specific transaction patterns that trigger delayed values bugs

### Citations

**File:** third_party/move/move-vm/types/src/delayed_values/error.rs (L11-19)
```rust
pub fn code_invariant_error<M: std::fmt::Debug>(message: M) -> PartialVMError {
    let msg = format!(
        "Delayed logic code invariant broken (there is a bug in the code), {:?}",
        message
    );
    println!("ERROR: {}", msg);
    PartialVMError::new(StatusCode::DELAYED_FIELD_OR_BLOCKSTM_CODE_INVARIANT_ERROR)
        .with_message(msg)
}
```

**File:** aptos-move/aptos-vm/src/block_executor/mod.rs (L577-583)
```rust
            Err(BlockExecutionError::FatalBlockExecutorError(PanicError::CodeInvariantError(
                err_msg,
            ))) => Err(VMStatus::Error {
                status_code: StatusCode::DELAYED_FIELD_OR_BLOCKSTM_CODE_INVARIANT_ERROR,
                sub_status: None,
                message: Some(err_msg),
            }),
```

**File:** state-sync/state-sync-driver/src/storage_synchronizer.rs (L572-586)
```rust
                Err(error) => {
                    // Send an error notification to the driver (we failed to execute/apply the chunk)
                    let error = if executed_chunk {
                        format!("Failed to execute the data chunk! Error: {:?}", error)
                    } else {
                        format!("Failed to apply the data chunk! Error: {:?}", error)
                    };
                    handle_storage_synchronizer_error(
                        notification_metadata,
                        error,
                        &error_notification_sender,
                        &pending_data_chunks,
                    )
                    .await;
                },
```

**File:** state-sync/state-sync-driver/src/storage_synchronizer.rs (L1250-1266)
```rust
async fn handle_storage_synchronizer_error(
    notification_metadata: NotificationMetadata,
    error: String,
    error_notification_sender: &mpsc::UnboundedSender<ErrorNotification>,
    pending_data_chunks: &Arc<AtomicU64>,
) {
    // Send an error notification to the driver
    send_storage_synchronizer_error(
        error_notification_sender.clone(),
        notification_metadata.notification_id,
        error,
    )
    .await;

    // Decrement the number of pending data chunks
    decrement_pending_data_chunks(pending_data_chunks.clone());
}
```

**File:** state-sync/state-sync-driver/src/driver.rs (L495-533)
```rust
    async fn handle_error_notification(&mut self, error_notification: ErrorNotification) {
        warn!(LogSchema::new(LogEntry::SynchronizerNotification)
            .error_notification(error_notification.clone())
            .message("Received an error notification from the storage synchronizer!"));

        // Terminate the currently active streams
        let notification_id = error_notification.notification_id;
        let notification_feedback = NotificationFeedback::InvalidPayloadData;
        if self.bootstrapper.is_bootstrapped() {
            if let Err(error) = self
                .continuous_syncer
                .handle_storage_synchronizer_error(NotificationAndFeedback::new(
                    notification_id,
                    notification_feedback,
                ))
                .await
            {
                error!(LogSchema::new(LogEntry::SynchronizerNotification)
                    .message(&format!(
                        "Failed to terminate the active stream for the continuous syncer! Error: {:?}",
                        error
                    )));
            }
        } else if let Err(error) = self
            .bootstrapper
            .handle_storage_synchronizer_error(NotificationAndFeedback::new(
                notification_id,
                notification_feedback,
            ))
            .await
        {
            error!(
                LogSchema::new(LogEntry::SynchronizerNotification).message(&format!(
                    "Failed to terminate the active stream for the bootstrapper! Error: {:?}",
                    error
                ))
            );
        };
    }
```

**File:** state-sync/state-sync-driver/src/continuous_syncer.rs (L501-522)
```rust
    pub async fn handle_storage_synchronizer_error(
        &mut self,
        notification_and_feedback: NotificationAndFeedback,
    ) -> Result<(), Error> {
        // Reset the active stream
        self.reset_active_stream(Some(notification_and_feedback))
            .await?;

        // Fallback to output syncing if we need to
        if let ContinuousSyncingMode::ExecuteTransactionsOrApplyOutputs =
            self.get_continuous_syncing_mode()
        {
            self.output_fallback_handler.fallback_to_outputs();
            metrics::set_gauge(
                &metrics::DRIVER_FALLBACK_MODE,
                ExecutingComponent::ContinuousSyncer.get_label(),
                1,
            );
        }

        Ok(())
    }
```

**File:** third_party/move/move-vm/types/src/delayed_values/delayed_field_id.rs (L61-65)
```rust
        if width <= value_len_width_upper_bound + 1 {
            return Err(code_invariant_error(format!(
                "DerivedStringSnapshot size issue for id {self:?}: width: {width}, value_width_upper_bound: {value_len_width_upper_bound}"
            )));
        }
```

**File:** third_party/move/move-vm/types/src/delayed_values/delayed_field_id.rs (L150-154)
```rust
                return Err(code_invariant_error(format!(
                    "Failed to convert {:?} into a Move value with {} layout",
                    self, layout
                )))
            },
```

**File:** third_party/move/move-vm/types/src/delayed_values/delayed_field_id.rs (L196-201)
```rust
        if id.extract_width() != width {
            return Err(code_invariant_error(format!(
                "Extracted identifier has a wrong width: id={id:?}, width={width}, expected={}",
                id.extract_width(),
            )));
        }
```

**File:** third_party/move/move-vm/types/src/delayed_values/derived_string_snapshot.rs (L80-84)
```rust
    if value_width + 1 > width {
        return Err(code_invariant_error(format!(
            "DerivedStringSnapshot size issue: no space left for padding: value_width: {value_width}, width: {width}"
        )));
    }
```
