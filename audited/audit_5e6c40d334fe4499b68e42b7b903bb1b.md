# Audit Report

## Title
Missing Round Ordering Validation in SafetyRules sign_proposal Allows Signing of Consensus-Violating Proposals

## Summary
The `guarded_sign_proposal` function in SafetyRules fails to validate that a block's round number is strictly greater than its parent's round number (from the QuorumCert). This allows a maliciously crafted BlockData, if successfully deserialized via the serializer, to bypass critical consensus safety checks and obtain a validator signature despite violating the fundamental AptosBFT invariant that `block.round() > parent_block.round()`.

## Finding Description
The vulnerability exists in the validation logic of the `sign_proposal` path within SafetyRules. When BlockData is deserialized through the SerializerService and passed to `guarded_sign_proposal`, the following validation occurs: [1](#0-0) 

The checks performed are:
1. Signer existence and author matching (lines 350-351)
2. Epoch matching with safety_data (line 354)
3. Round strictly greater than last_voted_round (lines 356-362)
4. QC signature verification (line 364)
5. QC certified_block round >= preferred_round (line 365)

**Critical Missing Check**: The code does NOT verify that `block_data.round() > block_data.quorum_cert().certified_block().round()`.

This check IS present in the `verify_well_formed` function used for incoming proposals: [2](#0-1) 

However, `verify_well_formed` is never called in the `sign_proposal` path, creating a validation gap.

**Attack Scenario**:
1. Attacker obtains a valid QuorumCert for round R, epoch E
2. Attacker crafts malicious BlockData with:
   - `round`: R (SAME as QC's certified_block round, violating the invariant)
   - `epoch`: E (current epoch)
   - `quorum_cert`: the valid QC from step 1
   - `author`: victim validator's address
   - Valid timestamp and payload
3. Attacker sends this via the serializer to `sign_proposal`: [3](#0-2) 

4. Deserialization succeeds (all fields are syntactically valid)
5. Validation in `guarded_sign_proposal` passes because:
   - R > last_voted_round (if last_voted_round < R)
   - Epoch matches
   - QC signatures are valid
   - QC.certified_block().round() (R) >= preferred_round
6. Validator signs the proposal, violating consensus safety rules

The BlockData deserialization at line 46 performs no semantic validation: [4](#0-3) 

This deserialization only validates JSON structure, not consensus semantics. The Round type is simply a u64: [5](#0-4) 

Therefore, any u64 value can be deserialized for the round field, including values that violate round ordering.

## Impact Explanation
**Severity: Critical** - This constitutes a **Consensus Safety Violation**.

AptosBFT consensus requires strict round ordering to maintain chain integrity and prevent equivocation. The invariant that `block.round() > parent_block.round()` is fundamental to:
1. Establishing a total ordering of blocks
2. Preventing round number manipulation attacks
3. Ensuring consensus agreement across validators

A validator signing a proposal that violates this invariant has committed a safety violation, even if other validators subsequently reject the malformed block. This breaks the **Consensus Safety** invariant specified in the security requirements: "AptosBFT must prevent double-spending and chain splits under < 1/3 Byzantine".

While honest validators would reject the malformed proposal during their own validation: [6](#0-5) 

The signing validator has already been compromised into producing an invalid signature, which could:
- Enable complex consensus attacks when combined with other vulnerabilities
- Damage validator reputation and lead to slashing
- Violate the defense-in-depth principle by trusting deserialized data

## Likelihood Explanation
**Likelihood: Medium**

The exploit requires an attacker to inject malicious serialized data into the SafetyRules serializer interface. In typical deployments, this requires:
1. Compromising the IPC channel between consensus and SafetyRules, OR
2. Exploiting a separate vulnerability that allows data injection

However, the likelihood is elevated because:
- The serializer explicitly accepts external input (by design for remote SafetyRules)
- No semantic validation occurs during deserialization
- The attack is deterministic once the injection point is achieved
- Defense-in-depth failures should be considered exploitable

## Recommendation
Add a call to `verify_well_formed` or implement equivalent round ordering validation in `guarded_sign_proposal`:

```rust
fn guarded_sign_proposal(
    &mut self,
    block_data: &BlockData,
) -> Result<bls12381::Signature, Error> {
    self.signer()?;
    self.verify_author(block_data.author())?;

    let mut safety_data = self.persistent_storage.safety_data()?;
    self.verify_epoch(block_data.epoch(), &safety_data)?;

    // ADD THIS CHECK:
    let parent_round = block_data.quorum_cert().certified_block().round();
    if block_data.round() <= parent_round {
        return Err(Error::InvalidProposal(format!(
            "Block round {} must be greater than parent round {}",
            block_data.round(),
            parent_round
        )));
    }

    if block_data.round() <= safety_data.last_voted_round {
        return Err(Error::InvalidProposal(format!(
            "Proposed round {} is not higher than last voted round {}",
            block_data.round(),
            safety_data.last_voted_round
        )));
    }

    self.verify_qc(block_data.quorum_cert())?;
    self.verify_and_update_preferred_round(block_data.quorum_cert(), &mut safety_data)?;

    let signature = self.sign(block_data)?;
    Ok(signature)
}
```

Alternatively, perform semantic validation immediately after deserialization in the serializer: [7](#0-6) 

## Proof of Concept
```rust
#[test]
fn test_sign_proposal_with_invalid_round_ordering() {
    use aptos_safety_rules::{SafetyRules, TSafetyRules};
    use aptos_consensus_types::{block_data::BlockData, common::Round};
    
    let (mut safety_rules, signer) = create_safety_rules_for_test();
    let (proof, genesis_qc) = make_genesis(&signer);
    safety_rules.initialize(&proof).unwrap();
    
    // Create a valid proposal at round 1
    let round_1_proposal = make_proposal_with_qc(1, genesis_qc.clone(), &signer);
    let round_1_sig = safety_rules.sign_proposal(round_1_proposal.block().block_data()).unwrap();
    let round_1_qc = create_qc_for_block(round_1_proposal.block(), &signer);
    
    // Create malicious BlockData with round EQUAL to parent round (violates invariant)
    let malicious_block_data = BlockData::new_for_testing(
        genesis_qc.certified_block().epoch(), // same epoch
        1, // SAME round as QC's certified block - INVALID!
        round_1_proposal.block().timestamp_usecs() + 1,
        round_1_qc.clone(), // QC certifies round 1
        BlockType::Proposal {
            payload: Payload::empty(false, true),
            author: signer.author(),
            failed_authors: vec![],
        },
    );
    
    // This should FAIL but currently SUCCEEDS due to missing validation
    let result = safety_rules.sign_proposal(&malicious_block_data);
    
    // Expected: Err(Error::InvalidProposal("Block round must be greater than parent round"))
    // Actual: Ok(signature) - VULNERABILITY!
    assert!(result.is_err(), "Should reject proposal with round <= parent round");
}
```

The PoC demonstrates that a BlockData with `round == parent_round` can obtain a signature through `sign_proposal`, violating the consensus invariant that blocks must have strictly increasing round numbers relative to their parents.

**Notes**

The vulnerability is particularly concerning because:
1. The serializer path bypasses the structural validation that honest proposal generation would enforce
2. JSON deserialization accepts any syntactically valid data without semantic checks
3. The `Round` type being a simple u64 alias means no type-level protection exists
4. The missing check is precisely the one that enforces a fundamental consensus invariant

This represents a defense-in-depth failure where the assumption that BlockData is always well-formed (because it comes from ProposalGenerator in normal operation) creates a security gap when alternative input paths exist.

### Citations

**File:** consensus/safety-rules/src/safety_rules.rs (L78-80)
```rust
        proposed_block
            .verify_well_formed()
            .map_err(|error| Error::InvalidProposal(error.to_string()))?;
```

**File:** consensus/safety-rules/src/safety_rules.rs (L346-370)
```rust
    fn guarded_sign_proposal(
        &mut self,
        block_data: &BlockData,
    ) -> Result<bls12381::Signature, Error> {
        self.signer()?;
        self.verify_author(block_data.author())?;

        let mut safety_data = self.persistent_storage.safety_data()?;
        self.verify_epoch(block_data.epoch(), &safety_data)?;

        if block_data.round() <= safety_data.last_voted_round {
            return Err(Error::InvalidProposal(format!(
                "Proposed round {} is not higher than last voted round {}",
                block_data.round(),
                safety_data.last_voted_round
            )));
        }

        self.verify_qc(block_data.quorum_cert())?;
        self.verify_and_update_preferred_round(block_data.quorum_cert(), &mut safety_data)?;
        // we don't persist the updated preferred round to save latency (it'd be updated upon voting)

        let signature = self.sign(block_data)?;
        Ok(signature)
    }
```

**File:** consensus/consensus-types/src/block.rs (L474-478)
```rust
        let parent = self.quorum_cert().certified_block();
        ensure!(
            parent.round() < self.round(),
            "Block must have a greater round than parent's block"
        );
```

**File:** consensus/safety-rules/src/serializer.rs (L46-54)
```rust
        let input = serde_json::from_slice(&input_message)?;

        let output = match input {
            SafetyRulesInput::ConsensusState => {
                serde_json::to_vec(&self.internal.consensus_state())
            },
            SafetyRulesInput::Initialize(li) => serde_json::to_vec(&self.internal.initialize(&li)),
            SafetyRulesInput::SignProposal(block_data) => {
                serde_json::to_vec(&self.internal.sign_proposal(&block_data))
```

**File:** consensus/consensus-types/src/common.rs (L33-33)
```rust
pub type Round = u64;
```
