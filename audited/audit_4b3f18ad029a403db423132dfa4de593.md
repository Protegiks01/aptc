# Audit Report

## Title
Zero-Cost Byte Reads from Tables via Governance Manipulation of Storage Gas Parameters

## Summary
A governance-approved malicious proposal can set storage gas parameters to zero, specifically the `per_byte_read` parameter, enabling attackers to read arbitrarily large table entries (up to 1MB) for 99.6% less gas cost. This creates a severe resource exhaustion attack vector against validator nodes while the attacker pays minimal gas fees.

## Finding Description

The vulnerability exists in the storage gas parameter validation and usage chain across multiple components:

**1. Missing Validation in `new_gas_curve()`**

The `new_gas_curve()` function in `storage_gas.move` validates that `max_gas >= min_gas` but does not prevent both values from being zero. [1](#0-0) 

This allows a governance proposal to create a gas curve with `new_gas_curve(0, 0, points)`, passing all validations.

**2. Zero `per_byte_read` Propagation**

During epoch reconfiguration, the `on_reconfig()` function calculates storage gas parameters using the configured gas curves. When the read curve has both `min_gas=0` and `max_gas=0`, the interpolation in `calculate_gas()` always returns 0. [2](#0-1) [3](#0-2) 

**3. Zero Gas Charging in Table Operations**

The calculated `per_byte_read=0` is then used to set `common_load_per_byte` in table gas parameters for gas feature versions 2-9. [4](#0-3) 

**4. Exploitation in Native Table Functions**

The `charge_load_cost()` function charges gas as `COMMON_LOAD_BASE + COMMON_LOAD_PER_BYTE * num_bytes`. When `COMMON_LOAD_PER_BYTE=0`, reading a 1MB table entry costs only ~605K gas instead of ~159M gas. [5](#0-4) 

**Attack Path:**
1. Malicious actor creates governance proposal calling `gas_schedule::set_storage_gas_config_for_next_epoch()` with a `StorageGasConfig` where `byte_config.read_curve = new_gas_curve(0, 0, points)`
2. Proposal passes governance voting
3. Next epoch begins, triggering `on_reconfig()` which sets `per_byte_read=0`
4. VM loads gas parameters with `common_load_per_byte=0`
5. Attacker creates large table entries (up to 1MB each)
6. Attacker repeatedly reads these entries in transactions, paying only base costs (~605K gas) instead of proportional byte costs (~159M gas for 1MB)
7. Validators must process full 1MB deserializations and state accesses while attacker pays 262x less gas
8. Validators experience CPU, memory, and I/O exhaustion

This breaks the **Resource Limits** invariant: "All operations must respect gas, storage, and computational limits." The gas metering no longer prices operations proportionally to their resource consumption.

## Impact Explanation

**Severity: High** (per Aptos Bug Bounty: "Validator node slowdowns" - up to $50,000)

The vulnerability enables massive resource exhaustion attacks:

- **Validator CPU exhaustion**: Deserializing 1MB values repeatedly
- **Validator memory pressure**: Loading large values into memory
- **Validator I/O exhaustion**: Repeated storage reads of large entries
- **Network-wide impact**: All validators must process underpriced reads
- **Cost asymmetry**: Attacker pays 0.4% of normal cost, validators pay 100% of resources

For comparison of gas costs with default `per_byte_read=151`:
- **Normal 1MB read**: ~158,334,176 internal gas units
- **Exploited 1MB read**: ~604,770 internal gas units  
- **Savings**: 99.6% reduction [6](#0-5) 

While this doesn't directly cause consensus failure or fund loss, it creates a severe DoS vector causing validator slowdowns and potential crashes, which qualifies as High severity under the bug bounty program.

## Likelihood Explanation

**Likelihood: Medium-High with governance approval**

**Requirements:**
- Governance proposal must be submitted and pass voting
- Requires sufficient voting power to approve the proposal
- Attacker needs ability to create large table entries (standard capability)

**Feasibility:**
- Governance is a legitimate on-chain mechanism
- Proposal could be disguised as a "gas optimization" 
- Could occur through compromised governance participants
- Could occur accidentally through poorly reviewed proposals
- Once enabled, any unprivileged attacker can exploit it

The governance requirement increases the bar, but once enabled, exploitation is trivial and the impact affects all validators network-wide.

## Recommendation

Add validation to ensure gas curve parameters cannot be set to zero for critical operations like storage reads. Implement a minimum threshold for `min_gas` in read curves.

**Suggested Fix** (in `storage_gas.move`):

```move
public fun new_gas_curve(min_gas: u64, max_gas: u64, points: vector<Point>): GasCurve {
    assert!(max_gas >= min_gas, error::invalid_argument(EINVALID_GAS_RANGE));
    assert!(max_gas <= MAX_U64 / BASIS_POINT_DENOMINATION, error::invalid_argument(EINVALID_GAS_RANGE));
    // ADD THIS: Prevent zero gas for critical operations
    assert!(min_gas > 0 || max_gas > 0, error::invalid_argument(EINVALID_GAS_RANGE));
    validate_points(&points);
    GasCurve {
        min_gas,
        max_gas,
        points
    }
}
```

Alternatively, add specific validation in `set_storage_gas_config()` to check that read curve minimums are above zero:

```move
public fun set_storage_gas_config(aptos_framework: &signer, config: StorageGasConfig) {
    // Validate read curves have non-zero minimum gas
    assert!(config.byte_config.read_curve.min_gas > 0, error::invalid_argument(EINVALID_GAS_RANGE));
    storage_gas::set_config(aptos_framework, config);
    reconfiguration::reconfigure();
}
```

## Proof of Concept

```move
#[test(framework = @aptos_framework)]
fun test_zero_per_byte_read_exploit(framework: signer) {
    use aptos_framework::storage_gas;
    use aptos_framework::gas_schedule;
    use aptos_framework::state_storage;
    
    // Initialize storage gas normally
    state_storage::initialize(&framework);
    storage_gas::initialize(&framework);
    
    // Create malicious gas curve with zero cost
    let malicious_read_curve = storage_gas::new_gas_curve(
        0,  // min_gas = 0
        0,  // max_gas = 0  
        vector[]
    );
    
    // Create malicious storage gas config
    let malicious_byte_config = storage_gas::new_usage_gas_config(
        1000000, // target_usage (must be > 0)
        malicious_read_curve,  // Zero-cost read curve
        storage_gas::base_8192_exponential_curve(5000, 500000), // Normal create
        storage_gas::base_8192_exponential_curve(5000, 500000)  // Normal write
    );
    
    let normal_item_config = storage_gas::new_usage_gas_config(
        2000000,
        storage_gas::base_8192_exponential_curve(300000, 30000000),
        storage_gas::base_8192_exponential_curve(300000, 30000000),
        storage_gas::base_8192_exponential_curve(300000, 30000000)
    );
    
    let malicious_config = storage_gas::new_storage_gas_config(
        normal_item_config,
        malicious_byte_config
    );
    
    // Apply via governance (simulated)
    gas_schedule::set_storage_gas_config(&framework, malicious_config);
    
    // Trigger reconfiguration to apply
    storage_gas::on_reconfig();
    
    // Verify per_byte_read is now 0
    let gas = borrow_global<storage_gas::StorageGas>(@aptos_framework);
    assert!(gas.per_byte_read == 0, 1); // Vulnerability confirmed!
    
    // At this point, table reads of any size cost zero per byte
    // Attacker can now read 1MB entries for ~605K gas instead of ~159M gas
}
```

## Notes

This vulnerability requires governance approval to enable, placing it at the boundary between legitimate governance action and exploitable bug. However, it represents a critical flaw in the validation logic that allows the gas metering system to be fundamentally broken. The lack of minimum gas validation for critical operations like storage reads is a design oversight that could enable severe DoS attacks once exploited through governance.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/storage_gas.move (L334-343)
```text
    public fun new_gas_curve(min_gas: u64, max_gas: u64, points: vector<Point>): GasCurve {
        assert!(max_gas >= min_gas, error::invalid_argument(EINVALID_GAS_RANGE));
        assert!(max_gas <= MAX_U64 / BASIS_POINT_DENOMINATION, error::invalid_argument(EINVALID_GAS_RANGE));
        validate_points(&points);
        GasCurve {
            min_gas,
            max_gas,
            points
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/storage_gas.move (L453-496)
```text
    fun calculate_gas(max_usage: u64, current_usage: u64, curve: &GasCurve): u64 {
        let capped_current_usage = if (current_usage > max_usage) max_usage else current_usage;
        let points = &curve.points;
        let num_points = vector::length(points);
        let current_usage_bps = capped_current_usage * BASIS_POINT_DENOMINATION / max_usage;

        // Check the corner case that current_usage_bps drops before the first point.
        let (left, right) = if (num_points == 0) {
            (&Point { x: 0, y: 0 }, &Point { x: BASIS_POINT_DENOMINATION, y: BASIS_POINT_DENOMINATION })
        } else if (current_usage_bps < vector::borrow(points, 0).x) {
            (&Point { x: 0, y: 0 }, vector::borrow(points, 0))
        } else if (vector::borrow(points, num_points - 1).x <= current_usage_bps) {
            (vector::borrow(points, num_points - 1), &Point { x: BASIS_POINT_DENOMINATION, y: BASIS_POINT_DENOMINATION })
        } else {
            let (i, j) = (0, num_points - 2);
            while ({
                spec {
                    invariant i <= j;
                    invariant j < num_points - 1;
                    invariant points[i].x <= current_usage_bps;
                    invariant current_usage_bps < points[j + 1].x;
                };
                i < j
            }) {
                let mid = j - (j - i) / 2;
                if (current_usage_bps < vector::borrow(points, mid).x) {
                    spec {
                        // j is strictly decreasing.
                        assert mid - 1 < j;
                    };
                    j = mid - 1;
                } else {
                    spec {
                        // i is strictly increasing.
                        assert i < mid;
                    };
                    i = mid;
                };
            };
            (vector::borrow(points, i), vector::borrow(points, i + 1))
        };
        let y_interpolated = interpolate(left.x, right.x, left.y, right.y, current_usage_bps);
        interpolate(0, BASIS_POINT_DENOMINATION, curve.min_gas, curve.max_gas, y_interpolated)
    }
```

**File:** aptos-move/framework/aptos-framework/sources/storage_gas.move (L515-533)
```text
    public(friend) fun on_reconfig() acquires StorageGas, StorageGasConfig {
        assert!(
            exists<StorageGasConfig>(@aptos_framework),
            error::not_found(ESTORAGE_GAS_CONFIG)
        );
        assert!(
            exists<StorageGas>(@aptos_framework),
            error::not_found(ESTORAGE_GAS)
        );
        let (items, bytes) = state_storage::current_items_and_bytes();
        let gas_config = borrow_global<StorageGasConfig>(@aptos_framework);
        let gas = borrow_global_mut<StorageGas>(@aptos_framework);
        gas.per_item_read = calculate_read_gas(&gas_config.item_config, items);
        gas.per_item_create = calculate_create_gas(&gas_config.item_config, items);
        gas.per_item_write = calculate_write_gas(&gas_config.item_config, items);
        gas.per_byte_read = calculate_read_gas(&gas_config.byte_config, bytes);
        gas.per_byte_create = calculate_create_gas(&gas_config.byte_config, bytes);
        gas.per_byte_write = calculate_write_gas(&gas_config.byte_config, bytes);
    }
```

**File:** aptos-move/aptos-vm-environment/src/gas.rs (L69-86)
```rust
            match gas_feature_version {
                0..=1 => (),
                2..=6 => {
                    if let IoPricing::V2(pricing) = &storage_gas_params.io_pricing {
                        g.common_load_base_legacy = pricing.per_item_read * NumArgs::new(1);
                        g.common_load_base_new = 0.into();
                        g.common_load_per_byte = pricing.per_byte_read;
                        g.common_load_failure = 0.into();
                    }
                }
                7..=9 => {
                    if let IoPricing::V2(pricing) = &storage_gas_params.io_pricing {
                        g.common_load_base_legacy = 0.into();
                        g.common_load_base_new = pricing.per_item_read * NumArgs::new(1);
                        g.common_load_per_byte = pricing.per_byte_read;
                        g.common_load_failure = 0.into();
                    }
                }
```

**File:** aptos-move/framework/table-natives/src/lib.rs (L325-351)
```rust
fn charge_load_cost(
    context: &mut SafeNativeContext,
    loaded: Option<Option<NumBytes>>,
) -> SafeNativeResult<()> {
    context.charge(COMMON_LOAD_BASE_LEGACY)?;

    match loaded {
        Some(Some(num_bytes)) => {
            let num_bytes = if context.gas_feature_version() >= 12 {
                // Round up bytes to whole pages
                // TODO(gas): make PAGE_SIZE configurable
                const PAGE_SIZE: u64 = 4096;

                let loaded_u64: u64 = num_bytes.into();
                let r = loaded_u64 % PAGE_SIZE;
                let rounded_up = loaded_u64 + if r == 0 { 0 } else { PAGE_SIZE - r };

                NumBytes::new(rounded_up)
            } else {
                num_bytes
            };
            context.charge(COMMON_LOAD_BASE_NEW + COMMON_LOAD_PER_BYTE * num_bytes)
        },
        Some(None) => context.charge(COMMON_LOAD_BASE_NEW + COMMON_LOAD_FAILURE),
        None => Ok(()),
    }
}
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/table.rs (L14-18)
```rust
        // These are dummy value, they copied from storage gas in aptos-core/aptos-vm/src/aptos_vm_impl.rs
        [common_load_base_legacy: InternalGas, "common.load.base", 302385],
        [common_load_base_new: InternalGas, { 7.. => "common.load.base_new" }, 302385],
        [common_load_per_byte: InternalGasPerByte, "common.load.per_byte", 151],
        [common_load_failure: InternalGas, "common.load.failure", 0],
```
