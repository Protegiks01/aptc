# Audit Report

## Title
Unauthenticated Network Topology Information Disclosure via Inspection Service Endpoints

## Summary
The Aptos inspection service exposes sensitive network topology information through unauthenticated HTTP endpoints bound to all network interfaces. The `/peer_information` endpoint (enabled by default) and `/configuration` endpoint (auto-enabled on testnet/devnet) leak IP addresses, ports, and validator network topology that can facilitate targeted attacks on validator infrastructure.

## Finding Description

The inspection service starts an HTTP server that binds to all network interfaces (`0.0.0.0:9101` by default) without any authentication mechanism. [1](#0-0) 

Two critical endpoints expose network topology:

**1. Peer Information Endpoint (enabled by default):**

The `/peer_information` endpoint is enabled by default and exposes connection metadata containing IP addresses and ports of all connected peers. [2](#0-1) 

The `ConnectionMetadata` struct serialized in this response contains the `addr: NetworkAddress` field with full IP address and port information. [3](#0-2) 

Additionally, the endpoint exposes trusted peers (validator set & seed peers) with their network addresses. [4](#0-3) 

The `Peer` struct contains a `Vec<NetworkAddress>` that includes IP addresses and ports. [5](#0-4) 

**2. Configuration Endpoint (auto-enabled on non-mainnet):**

While disabled by default, the configuration endpoint is automatically enabled for testnet and devnet nodes. [6](#0-5) 

When enabled, it exposes the entire `NodeConfig` structure which includes network configuration with listen addresses and seed peer addresses. [7](#0-6) 

The `NetworkConfig` struct contains `listen_address`, `seed_addrs`, and `seeds` fields that expose network topology. [8](#0-7) 

**Attack Vector:**

1. Attacker performs port scan to discover inspection service on port 9101
2. Attacker sends `GET /peer_information` request (no authentication required)
3. Response contains IP addresses and ports of all connected validators
4. Attacker uses this information to map the validator network topology
5. Attacker can now launch targeted DDoS attacks, network-level attacks, or reconnaissance for more sophisticated exploits

## Impact Explanation

This vulnerability meets **HIGH severity** criteria per the Aptos bug bounty program because it exposes critical infrastructure information that can facilitate validator network attacks. While not directly causing "validator node slowdowns" or "API crashes," the disclosed information enables attackers to:

- Map the complete validator network topology
- Identify all validator IP addresses and listening ports  
- Discover seed peer relationships
- Plan coordinated attacks on multiple validators
- Target specific validators for network-level attacks

This information disclosure undermines the security posture of the entire validator network and can be leveraged for attacks that impact consensus availability and network liveness.

## Likelihood Explanation

This vulnerability has **HIGH likelihood** of exploitation because:

1. **No Authentication Required**: Any attacker who can reach port 9101 can exploit this
2. **Default Configuration**: The peer_information endpoint is enabled by default
3. **Public Binding**: Service binds to `0.0.0.0` making it accessible from any network interface
4. **Easy Discovery**: Standard port scanning reveals the service
5. **Simple Exploitation**: A single HTTP GET request is sufficient
6. **Auto-Enable on Testnet**: Configuration endpoint is automatically enabled on testnet/devnet

Many operators may not realize this service is publicly accessible or may misconfigure firewall rules, leaving the inspection service exposed to the internet.

## Recommendation

Implement the following security measures:

1. **Bind to Localhost by Default**: Change the default binding address from `0.0.0.0` to `127.0.0.1` to prevent external access:

```rust
impl Default for InspectionServiceConfig {
    fn default() -> InspectionServiceConfig {
        InspectionServiceConfig {
            address: "127.0.0.1".to_string(), // Changed from 0.0.0.0
            port: 9101,
            expose_configuration: false,
            expose_identity_information: false, // Changed to false
            expose_peer_information: false,     // Changed to false
            expose_system_information: false,   // Changed to false
        }
    }
}
```

2. **Add Authentication**: Implement API key or token-based authentication for the inspection service

3. **Sanitize Network Information**: Filter out IP addresses and network topology from responses, or provide a sanitized mode

4. **Documentation**: Clearly document the security implications of exposing the inspection service

5. **Firewall Warnings**: Add startup warnings when the service is bound to non-localhost addresses

## Proof of Concept

**Step 1: Start an Aptos Node**
```bash
# Default configuration binds inspection service to 0.0.0.0:9101
aptos-node -f /path/to/validator.yaml
```

**Step 2: Query Peer Information (No Authentication Required)**
```bash
curl http://VALIDATOR_IP:9101/peer_information
```

**Expected Output:**
```
Peer information summary:
    - Number of peers: 100
    - Registered networks: [Validator, Public]
    - Peers and network IDs: [...]

Connection metadata for each peer:
    - Peer: 0x..., connection state: Connected, connection metadata: {"remote_peer_id":"0x...","connection_id":1,"addr":"/ip4/10.0.1.5/tcp/6180/noise-ik/...","origin":"Outbound",...}
    - Peer: 0x..., connection state: Connected, connection metadata: {"remote_peer_id":"0x...","addr":"/ip4/10.0.2.8/tcp/6180/noise-ik/...","origin":"Outbound",...}
    [... exposes IP addresses of all connected validators ...]

Trusted peers (validator set & seeds):
    - Network: Validator
        - Peer: 0x..., peer information: Peer { addresses: ["/dns/validator1.example.com/tcp/6180/..."], keys: {...}, role: Validator }
        - Peer: 0x..., peer information: Peer { addresses: ["/ip4/10.0.3.10/tcp/6180/..."], keys: {...}, role: Validator }
    [... complete validator network topology ...]
```

**Step 3: Query Configuration on Testnet/Devnet**
```bash
curl http://TESTNET_NODE_IP:9101/configuration
```

**Expected Output:**
```
NodeConfig { 
    validator_network: Some(NetworkConfig { 
        listen_address: /ip4/0.0.0.0/tcp/6180, 
        seed_addrs: {
            0x...: ["/ip4/10.0.1.5/tcp/6180/...", "/ip4/10.0.2.8/tcp/6180/..."],
            ...
        },
        seeds: {
            0x...: Peer { addresses: ["/dns/seed1.testnet.com/tcp/6180/..."], ... }
        },
        ...
    }),
    ...
}
```

This PoC demonstrates that an unauthenticated attacker can retrieve complete network topology information including IP addresses, ports, and peer relationships of the validator network.

## Notes

While mainnet validators have some protection (the configuration endpoint cannot be enabled), the peer_information endpoint remains enabled by default and exposes similar sensitive information. The auto-enable behavior for testnet/devnet nodes further increases the attack surface. This is a design-level security issue rather than an implementation bug, but it significantly compromises the security posture of the validator network infrastructure.

### Citations

**File:** config/src/config/inspection_service_config.rs (L26-36)
```rust
impl Default for InspectionServiceConfig {
    fn default() -> InspectionServiceConfig {
        InspectionServiceConfig {
            address: "0.0.0.0".to_string(),
            port: 9101,
            expose_configuration: false,
            expose_identity_information: true,
            expose_peer_information: true,
            expose_system_information: true,
        }
    }
```

**File:** config/src/config/inspection_service_config.rs (L71-109)
```rust
impl ConfigOptimizer for InspectionServiceConfig {
    fn optimize(
        node_config: &mut NodeConfig,
        local_config_yaml: &Value,
        _node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<bool, Error> {
        let inspection_service_config = &mut node_config.inspection_service;
        let local_inspection_config_yaml = &local_config_yaml["inspection_service"];

        // Enable all endpoints for non-mainnet nodes (to aid debugging)
        let mut modified_config = false;
        if let Some(chain_id) = chain_id {
            if !chain_id.is_mainnet() {
                if local_inspection_config_yaml["expose_configuration"].is_null() {
                    inspection_service_config.expose_configuration = true;
                    modified_config = true;
                }

                if local_inspection_config_yaml["expose_identity_information"].is_null() {
                    inspection_service_config.expose_identity_information = true;
                    modified_config = true;
                }

                if local_inspection_config_yaml["expose_peer_information"].is_null() {
                    inspection_service_config.expose_peer_information = true;
                    modified_config = true;
                }

                if local_inspection_config_yaml["expose_system_information"].is_null() {
                    inspection_service_config.expose_system_information = true;
                    modified_config = true;
                }
            }
        }

        Ok(modified_config)
    }
}
```

**File:** crates/aptos-inspection-service/src/server/peer_information.rs (L148-168)
```rust
/// Displays connection metadata for each peer
fn display_peer_connection_metadata(
    peer_information_output: &mut Vec<String>,
    all_peers: &Vec<PeerNetworkId>,
    peers_and_metadata: &PeersAndMetadata,
) {
    peer_information_output.push("Connection metadata for each peer:".into());

    // Fetch and display the connection metadata for each peer
    for peer in all_peers {
        if let Ok(peer_metadata) = peers_and_metadata.get_metadata_for_peer(*peer) {
            let connection_metadata = peer_metadata.get_connection_metadata();
            peer_information_output.push(format!(
                "\t- Peer: {}, connection state: {:?}, connection metadata: {}",
                peer,
                peer_metadata.get_connection_state(),
                serde_json::to_string(&connection_metadata).unwrap_or_default()
            ));
        }
    }
}
```

**File:** crates/aptos-inspection-service/src/server/peer_information.rs (L273-300)
```rust
/// Displays the entire set of trusted peers
fn display_trusted_peers(
    peer_information_output: &mut Vec<String>,
    registered_networks: Vec<NetworkId>,
    peers_and_metadata: &PeersAndMetadata,
) {
    peer_information_output.push("Trusted peers (validator set & seeds):".into());

    // Fetch and display the trusted peers for each network
    for network in registered_networks {
        peer_information_output.push(format!("\t- Network: {}", network));
        if let Ok(trusted_peers) = peers_and_metadata.get_trusted_peers(&network) {
            // Sort the peers before displaying them
            let mut sorted_trusted_peers = BTreeMap::new();
            for (peer_id, peer_info) in trusted_peers {
                sorted_trusted_peers.insert(peer_id, peer_info);
            }

            // Display the trusted peers
            for (peer_id, peer_info) in sorted_trusted_peers {
                peer_information_output.push(format!(
                    "\t\t- Peer: {:?}, peer information: {:?}",
                    peer_id, peer_info
                ));
            }
        }
    }
}
```

**File:** network/framework/src/transport/mod.rs (L98-108)
```rust
/// Metadata associated with an established and fully upgraded connection.
#[derive(Clone, Deserialize, Eq, PartialEq, Serialize)]
pub struct ConnectionMetadata {
    pub remote_peer_id: PeerId,
    pub connection_id: ConnectionId,
    pub addr: NetworkAddress,
    pub origin: ConnectionOrigin,
    pub messaging_protocol: MessagingProtocolVersion,
    pub application_protocols: ProtocolIdSet,
    pub role: PeerRole,
}
```

**File:** config/src/config/network_config.rs (L55-126)
```rust
#[derive(Clone, Debug, Deserialize, PartialEq, Serialize)]
#[serde(default, deny_unknown_fields)]
pub struct NetworkConfig {
    /// Maximum backoff delay for connecting outbound to peers
    pub max_connection_delay_ms: u64,
    /// Base for outbound connection backoff
    pub connection_backoff_base: u64,
    /// Rate to check connectivity to connected peers
    pub connectivity_check_interval_ms: u64,
    /// Size of all network channels
    pub network_channel_size: usize,
    /// Choose a protocol to discover and dial out to other peers on this network.
    /// `DiscoveryMethod::None` disables discovery and dialing out (unless you have
    /// seed peers configured).
    pub discovery_method: DiscoveryMethod,
    /// Same as `discovery_method` but allows for multiple
    pub discovery_methods: Vec<DiscoveryMethod>,
    /// Identity of this network
    pub identity: Identity,
    // TODO: Add support for multiple listen/advertised addresses in config.
    /// The address that this node is listening on for new connections.
    pub listen_address: NetworkAddress,
    /// Select this to enforce that both peers should authenticate each other, otherwise
    /// authentication only occurs for outgoing connections.
    pub mutual_authentication: bool,
    /// ID of the network to differentiate between networks
    pub network_id: NetworkId,
    /// Number of threads to run for networking
    pub runtime_threads: Option<usize>,
    /// Overrides for the size of the inbound and outbound buffers for each peer.
    /// NOTE: The defaults are None, so socket options are not called. Change to Some values with
    /// caution. Experiments have shown that relying on Linux's default tcp auto-tuning can perform
    /// better than setting these. In particular, for larger values to take effect, the
    /// `net.core.rmem_max` and `net.core.wmem_max` sysctl values may need to be increased. On a
    /// vanilla GCP machine, these are set to 212992. Without increasing the sysctl values and
    /// setting a value will constrain the buffer size to the sysctl value. (In contrast, default
    /// auto-tuning can increase beyond these values.)
    pub inbound_rx_buffer_size_bytes: Option<u32>,
    pub inbound_tx_buffer_size_bytes: Option<u32>,
    pub outbound_rx_buffer_size_bytes: Option<u32>,
    pub outbound_tx_buffer_size_bytes: Option<u32>,
    /// Addresses of initial peers to connect to. In a mutual_authentication network,
    /// we will extract the public keys from these addresses to set our initial
    /// trusted peers set.  TODO: Replace usage in configs with `seeds` this is for backwards compatibility
    pub seed_addrs: HashMap<PeerId, Vec<NetworkAddress>>,
    /// The initial peers to connect to prior to onchain discovery
    pub seeds: PeerSet,
    /// The maximum size of an inbound or outbound request frame
    pub max_frame_size: usize,
    /// Enables proxy protocol on incoming connections to get original source addresses
    pub enable_proxy_protocol: bool,
    /// Interval to send healthcheck pings to peers
    pub ping_interval_ms: u64,
    /// Timeout until a healthcheck ping is rejected
    pub ping_timeout_ms: u64,
    /// Number of failed healthcheck pings until a peer is marked unhealthy
    pub ping_failures_tolerated: u64,
    /// Maximum number of outbound connections, limited by ConnectivityManager
    pub max_outbound_connections: usize,
    /// Maximum number of outbound connections, limited by PeerManager
    pub max_inbound_connections: usize,
    /// Inbound rate limiting configuration, if not specified, no rate limiting
    pub inbound_rate_limit_config: Option<RateLimitConfig>,
    /// Outbound rate limiting configuration, if not specified, no rate limiting
    pub outbound_rate_limit_config: Option<RateLimitConfig>,
    /// The maximum size of an inbound or outbound message (it may be divided into multiple frame)
    pub max_message_size: usize,
    /// The maximum number of parallel message deserialization tasks that can run (per application)
    pub max_parallel_deserialization_tasks: Option<usize>,
    /// Whether or not to enable latency aware peer dialing
    pub enable_latency_aware_dialing: bool,
}
```

**File:** config/src/config/network_config.rs (L457-464)
```rust
/// Represents a single seed configuration for a seed peer
#[derive(Clone, Debug, Default, Deserialize, PartialEq, Eq, Serialize)]
#[serde(default)]
pub struct Peer {
    pub addresses: Vec<NetworkAddress>,
    pub keys: HashSet<x25519::PublicKey>,
    pub role: PeerRole,
}
```

**File:** crates/aptos-inspection-service/src/server/configuration.rs (L12-29)
```rust
/// Handles a new configuration request
pub fn handle_configuration_request(node_config: &NodeConfig) -> (StatusCode, Body, String) {
    // Only return configuration if the endpoint is enabled
    let (status_code, body) = if node_config.inspection_service.expose_configuration {
        // We format the configuration using debug formatting. This is important to
        // prevent secret/private keys from being serialized and leaked (i.e.,
        // all secret keys are marked with SilentDisplay and SilentDebug).
        let encoded_configuration = format!("{:?}", node_config);
        (StatusCode::OK, Body::from(encoded_configuration))
    } else {
        (
            StatusCode::FORBIDDEN,
            Body::from(CONFIGURATION_DISABLED_MESSAGE),
        )
    };

    (status_code, body, CONTENT_TYPE_TEXT.into())
}
```
