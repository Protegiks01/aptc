# Audit Report

## Title
Unbounded PackageRegistry Deserialization Enables Client-Side Denial of Service Attack

## Summary
The `maybe_download_package()` function in the Aptos CLI lacks size limits when deserializing `PackageRegistry` resources from the blockchain, allowing attackers to publish packages with extremely large metadata blobs that cause Out-Of-Memory (OOM) crashes in client tools during dependency resolution.

## Finding Description

The vulnerability exists in the package dependency resolution mechanism used by Aptos CLI and SDK tools. When a Move project declares a custom dependency with the `aptos` key in `Move.toml`, the build system calls `maybe_download_package()` to fetch package metadata from the blockchain. [1](#0-0) 

This function creates a `CachedPackageRegistry` by fetching the on-chain `PackageRegistry` resource: [2](#0-1) 

The REST client retrieves this resource using BCS deserialization **without any size limits**: [3](#0-2) 

The `PackageRegistry` struct contains `Vec<PackageMetadata>`, where each `PackageMetadata` has potentially unbounded `Vec<u8>` fields: [4](#0-3) [5](#0-4) 

While standard package publishing is limited to 60KB, attackers can bypass this using **chunked publishing** which accumulates metadata without size limits: [6](#0-5) 

The Move framework provides no on-chain size limits for these metadata fields: [7](#0-6) 

**Attack Path:**
1. Attacker creates a malicious package with multi-gigabyte `manifest`, `source`, or `source_map` fields (using gzip compression to store data efficiently on-chain)
2. Attacker publishes using chunked publishing to bypass transaction size limits
3. Victim creates a Move project with a dependency referencing the malicious package address
4. During `aptos move compile` or build, the CLI calls `maybe_download_package()`
5. REST client fetches the entire multi-GB PackageRegistry resource
6. `bcs::from_bytes()` attempts to deserialize without size checks
7. OOM occurs, crashing the CLI/SDK tools

This breaks **Invariant #9: Resource Limits** - all operations must respect computational and memory limits.

## Impact Explanation

This qualifies as **Medium Severity** under the Aptos bug bounty program:

- **API crashes**: The REST client will OOM when deserializing extremely large responses
- **Developer toolchain DoS**: Any developer attempting to build a project with the malicious dependency will experience crashes
- **State inconsistencies requiring intervention**: Malicious packages remain on-chain indefinitely, permanently affecting dependency resolution

While this doesn't directly affect consensus or validator nodes (which have separate gas/memory limits during execution), it creates a persistent denial-of-service condition for the developer ecosystem. Unlike other parts of the codebase that use `bcs::from_bytes_with_limit()`: [8](#0-7) 

The REST client does not enforce such limits, making it vulnerable to resource exhaustion attacks.

## Likelihood Explanation

**Likelihood: High**

- **Low attacker cost**: Publishing packages is permissionless; chunked publishing is supported out-of-the-box
- **Persistent attack**: Once published, the malicious package remains on-chain indefinitely
- **Wide attack surface**: Any Move project using custom dependencies is vulnerable
- **Easy triggering**: Simply adding the malicious package as a dependency triggers the vulnerability
- **No detection**: There are no warnings or checks before fetching large metadata

The attack requires no special privileges and can affect multiple users who reference the malicious package.

## Recommendation

Implement size limits for BCS deserialization in the REST client, similar to other protected code paths. Add a configurable maximum size for resource deserialization:

**In `crates/aptos-rest-client/src/lib.rs`:**

```rust
// Add constant
const MAX_RESOURCE_SIZE: usize = 10 * 1024 * 1024; // 10 MB

pub async fn get_account_resource_bcs<T: DeserializeOwned>(
    &self,
    address: AccountAddress,
    resource_type: &str,
) -> AptosResult<Response<T>> {
    let url = self.build_path(&format!(
        "accounts/{}/resource/{}",
        address.to_hex(),
        resource_type
    ))?;
    let response = self.get_bcs(url).await?;
    // Use size-limited deserialization
    Ok(response.and_then(|inner| {
        if inner.len() > MAX_RESOURCE_SIZE {
            return Err(anyhow::anyhow!("Resource size exceeds maximum allowed size"));
        }
        bcs::from_bytes_with_limit(&inner, MAX_RESOURCE_SIZE)
    })?)
}
```

**Additional hardening:**
1. Add API-side response size limits for BCS endpoints
2. Implement on-chain size limits for PackageMetadata fields in `code.move`
3. Add warnings in CLI when downloading large packages
4. Consider compressed size limits in chunked publishing

## Proof of Concept

**Rust reproduction demonstrating the vulnerability:**

```rust
// File: test_oom_attack.rs
use aptos_framework::natives::code::{PackageMetadata, PackageRegistry, ModuleMetadata, UpgradePolicy};
use aptos_rest_client::Client;
use aptos_types::account_address::AccountAddress;
use url::Url;

#[tokio::test]
async fn test_large_package_registry_oom() {
    // Create a malicious PackageRegistry with extremely large metadata
    let mut large_metadata = PackageMetadata {
        name: "malicious".to_string(),
        upgrade_policy: UpgradePolicy::arbitrary(),
        upgrade_number: 0,
        source_digest: "test".to_string(),
        manifest: vec![0u8; 100_000_000], // 100 MB manifest
        modules: vec![
            ModuleMetadata {
                name: "module".to_string(),
                source: vec![0u8; 100_000_000], // 100 MB source
                source_map: vec![0u8; 100_000_000], // 100 MB source map
                extension: None,
            }
        ],
        deps: vec![],
        extension: None,
    };
    
    let registry = PackageRegistry {
        packages: vec![large_metadata],
    };
    
    // Serialize - this will succeed
    let serialized = bcs::to_bytes(&registry).unwrap();
    println!("Serialized size: {} MB", serialized.len() / 1_000_000);
    
    // Deserialize without limit - this will cause OOM for very large sizes
    // In production, this would be called via get_account_resource_bcs
    let result = bcs::from_bytes::<PackageRegistry>(&serialized);
    
    // With size limit (safe version)
    let result_limited = bcs::from_bytes_with_limit::<PackageRegistry>(
        &serialized, 
        10_000_000 // 10 MB limit
    );
    
    assert!(result_limited.is_err(), "Should reject oversized packages");
}
```

**Move PoC for publishing large package:**

```move
// Create Move.toml with extremely large manifest
// Use aptos move publish --chunked-publish to upload
// Target: Create package with 100MB+ metadata that triggers OOM when downloaded

// Victim Move.toml:
[package]
name = "victim"
version = "0.1.0"

[dependencies]
MaliciousPackage = { aptos = "0xMALICIOUS_ADDRESS/malicious_package" }

// Running: aptos move compile
// Result: OOM crash during dependency resolution
```

## Notes

The vulnerability is client-side and does not affect blockchain consensus or validator operations. However, it creates a **persistent DoS vector** against the developer ecosystem. The codebase already uses `bcs::from_bytes_with_limit()` in security-critical contexts like network protocol deserialization, but this protection is missing in the REST client layer. The fix requires minimal changes and should be applied consistently across all BCS deserialization points handling untrusted data.

### Citations

**File:** crates/aptos/src/move_tool/package_hooks.rs (L38-55)
```rust
async fn maybe_download_package(info: &CustomDepInfo) -> anyhow::Result<()> {
    if !info
        .download_to
        .join(CompiledPackageLayout::BuildInfo.path())
        .exists()
    {
        let registry = CachedPackageRegistry::create(
            Url::parse(info.node_url.as_str())?,
            load_account_arg(info.package_address.as_str())?,
            false,
        )
        .await?;
        let package = registry.get_package(info.package_name).await?;
        package.save_package_to_disk(info.download_to.as_path())
    } else {
        Ok(())
    }
}
```

**File:** crates/aptos/src/move_tool/stored_package.rs (L43-69)
```rust
    pub async fn create(
        url: Url,
        addr: AccountAddress,
        with_bytecode: bool,
    ) -> anyhow::Result<Self> {
        let client = Client::new(url);
        // Need to use a different type to deserialize JSON
        let inner = client
            .get_account_resource_bcs::<PackageRegistry>(addr, "0x1::code::PackageRegistry")
            .await?
            .into_inner();
        let mut bytecode = BTreeMap::new();
        if with_bytecode {
            for pack in &inner.packages {
                for module in &pack.modules {
                    let bytes = client
                        .get_account_module(addr, &module.name)
                        .await?
                        .into_inner()
                        .bytecode
                        .0;
                    bytecode.insert(module.name.clone(), bytes);
                }
            }
        }
        Ok(Self { inner, bytecode })
    }
```

**File:** crates/aptos-rest-client/src/lib.rs (L1209-1221)
```rust
    pub async fn get_account_resource_bcs<T: DeserializeOwned>(
        &self,
        address: AccountAddress,
        resource_type: &str,
    ) -> AptosResult<Response<T>> {
        let url = self.build_path(&format!(
            "accounts/{}/resource/{}",
            address.to_hex(),
            resource_type
        ))?;
        let response = self.get_bcs(url).await?;
        Ok(response.and_then(|inner| bcs::from_bytes(&inner))?)
    }
```

**File:** aptos-move/framework/src/natives/code.rs (L60-71)
```rust
#[derive(Clone, Debug, Serialize, Deserialize, Eq, PartialEq)]
pub struct PackageMetadata {
    pub name: String,
    pub upgrade_policy: UpgradePolicy,
    pub upgrade_number: u64,
    pub source_digest: String,
    #[serde(with = "serde_bytes")]
    pub manifest: Vec<u8>,
    pub modules: Vec<ModuleMetadata>,
    pub deps: Vec<PackageDep>,
    pub extension: Option<Any>,
}
```

**File:** aptos-move/framework/src/natives/code.rs (L101-109)
```rust
#[derive(Clone, Debug, Serialize, Deserialize, PartialEq, Eq)]
pub struct ModuleMetadata {
    pub name: String,
    #[serde(with = "serde_bytes")]
    pub source: Vec<u8>,
    #[serde(with = "serde_bytes")]
    pub source_map: Vec<u8>,
    pub extension: Option<Any>,
}
```

**File:** aptos-move/framework/aptos-experimental/sources/large_packages.move (L132-160)
```text
    inline fun stage_code_chunk_internal(
        owner: &signer,
        metadata_chunk: vector<u8>,
        code_indices: vector<u16>,
        code_chunks: vector<vector<u8>>
    ): &mut StagingArea {
        assert!(
            vector::length(&code_indices) == vector::length(&code_chunks),
            error::invalid_argument(ECODE_MISMATCH)
        );

        let owner_address = signer::address_of(owner);

        if (!exists<StagingArea>(owner_address)) {
            move_to(
                owner,
                StagingArea {
                    metadata_serialized: vector[],
                    code: smart_table::new(),
                    last_module_idx: 0
                }
            );
        };

        let staging_area = borrow_global_mut<StagingArea>(owner_address);

        if (!vector::is_empty(&metadata_chunk)) {
            vector::append(&mut staging_area.metadata_serialized, metadata_chunk);
        };
```

**File:** aptos-move/framework/aptos-framework/sources/code.move (L23-49)
```text
    /// The package registry at the given address.
    struct PackageRegistry has key, store, drop {
        /// Packages installed at this address.
        packages: vector<PackageMetadata>,
    }

    /// Metadata for a package. All byte blobs are represented as base64-of-gzipped-bytes
    struct PackageMetadata has copy, drop, store {
        /// Name of this package.
        name: String,
        /// The upgrade policy of this package.
        upgrade_policy: UpgradePolicy,
        /// The numbers of times this module has been upgraded. Also serves as the on-chain version.
        /// This field will be automatically assigned on successful upgrade.
        upgrade_number: u64,
        /// The source digest of the sources in the package. This is constructed by first building the
        /// sha256 of each individual source, than sorting them alphabetically, and sha256 them again.
        source_digest: String,
        /// The package manifest, in the Move.toml format. Gzipped text.
        manifest: vector<u8>,
        /// The list of modules installed by this package.
        modules: vector<ModuleMetadata>,
        /// Holds PackageDeps.
        deps: vector<PackageDep>,
        /// For future extension
        extension: Option<Any>
    }
```

**File:** network/framework/src/protocols/wire/handshake/v1/mod.rs (L259-262)
```rust
    /// Deserializes the value using BCS encoding (with a specified limit)
    fn bcs_decode<T: DeserializeOwned>(&self, bytes: &[u8], limit: usize) -> anyhow::Result<T> {
        bcs::from_bytes_with_limit(bytes, limit).map_err(|e| anyhow!("{:?}", e))
    }
```
