# Audit Report

## Title
Consensus Observer DoS via Unvalidated ExecutionPoolWindow Size in OrderedBlockWithWindow Messages

## Summary
The `ExecutionPoolWindow::verify_window_contents()` method is unimplemented, allowing attackers to send `OrderedBlockWithWindow` messages containing arbitrarily large vectors of block IDs (up to ~2 million HashValues per message). This causes memory and CPU exhaustion on consensus observer nodes, leading to validator slowdowns and potential service disruption.

## Finding Description

The consensus observer system accepts `OrderedBlockWithWindow` messages containing an `ExecutionPoolWindow` structure with a `block_ids` vector that should represent parent block dependencies. However, the size validation for this vector is completely missing. [1](#0-0) 

The `verify_window_contents()` method contains only a TODO comment and immediately returns `Ok(())` without performing any validation. This method is called during message processing but provides no protection: [2](#0-1) 

The expected window size from the on-chain consensus configuration is typically 0-1 blocks: [3](#0-2) 

However, with no validation enforcement, an attacker can exploit this by:

1. Constructing an `OrderedBlockWithWindow` message with `ExecutionPoolWindow` containing millions of `HashValue` entries
2. Each `HashValue` is 32 bytes, allowing up to ~2,097,152 hash values within the 64 MiB network message size limit
3. The message passes through network deserialization (constrained only by the general network limit)
4. During BCS deserialization, the system allocates memory for the entire vector
5. The message reaches `process_ordered_block_with_window_message()` where the no-op validation allows it through
6. Multiple such messages can be sent concurrently to exhaust node resources

The network layer enforces a maximum message size of 64 MiB: [4](#0-3) 

This provides the only bound, but 64 MiB is still sufficient for significant resource exhaustion. The message streaming protocol handles fragmentation for large messages: [5](#0-4) 

However, there is no application-level validation checking that the `block_ids` vector size matches the expected window size configuration.

## Impact Explanation

This vulnerability qualifies as **High Severity** per the Aptos bug bounty criteria for "Validator node slowdowns":

- **Memory Exhaustion**: Each malicious message forces allocation of up to 64 MiB for storing ~2 million HashValues
- **CPU Exhaustion**: BCS deserialization of large vectors is computationally expensive
- **Amplification Attack**: An attacker can send multiple messages simultaneously to multiple observer nodes
- **Service Degradation**: Consensus observer nodes become slow or unresponsive, degrading the network's ability to propagate consensus decisions to VFNs and observers

The impact affects consensus observers, which are critical for:
- Validator Full Nodes (VFNs) receiving consensus updates
- Decentralized node synchronization
- Network scalability and observability

While this doesn't directly break consensus safety, it violates the **Resource Limits** invariant (#9): "All operations must respect gas, storage, and computational limits."

## Likelihood Explanation

**Likelihood: High**

The attack is trivially exploitable:
- **No Authentication Required**: Any network peer can send `ConsensusObserverDirectSend` messages
- **Simple Payload Construction**: Just requires constructing a message with a large vector
- **Low Cost**: Network bandwidth is the only resource requirement for the attacker
- **Wide Attack Surface**: All consensus observers (VFNs and observer nodes) are vulnerable

The code clearly indicates this is unfinished functionality (TODO comment), making it an obvious oversight rather than an edge case.

## Recommendation

Implement proper size validation in the `verify_window_contents()` method:

```rust
/// Verifies the execution pool window contents and returns an error if the data is invalid
pub fn verify_window_contents(&self, expected_window_size: u64) -> Result<(), Error> {
    // Verify that the window size matches the expected size
    let actual_window_size = self.block_ids.len() as u64;
    
    // Check if window size is within reasonable bounds
    if actual_window_size > expected_window_size {
        return Err(Error::InvalidMessageError(
            format!(
                "Execution pool window size exceeds limit! Expected: {}, Actual: {}",
                expected_window_size,
                actual_window_size
            )
        ));
    }
    
    // Additional validation: ensure window size is within absolute maximum
    const MAX_ABSOLUTE_WINDOW_SIZE: u64 = 100; // Conservative upper bound
    if actual_window_size > MAX_ABSOLUTE_WINDOW_SIZE {
        return Err(Error::InvalidMessageError(
            format!(
                "Execution pool window size exceeds absolute maximum! Actual: {}, Max: {}",
                actual_window_size,
                MAX_ABSOLUTE_WINDOW_SIZE
            )
        ));
    }
    
    Ok(())
}
```

Additionally, consider adding validation at the network message handling layer to reject oversized messages before full deserialization.

## Proof of Concept

```rust
// Proof of Concept: Constructing a malicious OrderedBlockWithWindow message
use aptos_crypto::HashValue;
use consensus::consensus_observer::network::observer_message::{
    OrderedBlock, OrderedBlockWithWindow, ExecutionPoolWindow,
    ConsensusObserverDirectSend,
};

fn create_dos_message() -> ConsensusObserverDirectSend {
    // Create a minimal valid OrderedBlock
    let ordered_block = OrderedBlock::new(
        vec![/* minimal block data */],
        /* minimal ledger info */
    );
    
    // Create a malicious ExecutionPoolWindow with ~2 million hash values
    // This fills the 64 MiB message size limit
    let malicious_block_ids: Vec<HashValue> = (0..2_000_000)
        .map(|i| {
            // Generate arbitrary hash values
            let mut bytes = [0u8; 32];
            bytes[0..8].copy_from_slice(&i.to_le_bytes());
            HashValue::from_slice(&bytes).unwrap()
        })
        .collect();
    
    let malicious_window = ExecutionPoolWindow::new(malicious_block_ids);
    
    // Create the OrderedBlockWithWindow message
    let ordered_block_with_window = OrderedBlockWithWindow::new(
        ordered_block,
        malicious_window,
    );
    
    ConsensusObserverDirectSend::OrderedBlockWithWindow(ordered_block_with_window)
}

// Attack steps:
// 1. Establish network connection to target consensus observer node
// 2. Serialize the malicious message using BCS
// 3. Send via ConsensusObserver protocol (ProtocolId::ConsensusObserver)
// 4. Repeat multiple times to amplify resource exhaustion
// 5. Target node experiences memory allocation of ~64 MiB per message
//    plus CPU overhead for deserialization
// 6. Multiple concurrent messages cause node slowdown or OOM crash
```

**Execution Steps:**
1. Compile the above code against the Aptos codebase
2. Run a local consensus observer node
3. Send the crafted message to the observer
4. Observe memory and CPU usage spike
5. Send multiple messages concurrently to demonstrate DoS impact

**Expected Result:** The consensus observer node will experience significant memory and CPU usage, leading to degraded performance or service interruption.

## Notes

The vulnerability is particularly concerning because:
- The TODO comment indicates this is known unfinished functionality
- Consensus observers are becoming increasingly critical for Aptos network scalability
- The 64 MiB network limit provides sufficient space for devastating resource exhaustion
- No rate limiting or size checks exist at the application layer

### Citations

**File:** consensus/src/consensus_observer/network/observer_message.rs (L312-333)
```rust
/// The execution pool window information for an ordered block
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
pub struct ExecutionPoolWindow {
    // TODO: identify exactly what information is required here
    block_ids: Vec<HashValue>, // The list of parent block hashes in chronological order
}

impl ExecutionPoolWindow {
    pub fn new(block_ids: Vec<HashValue>) -> Self {
        Self { block_ids }
    }

    /// Returns a reference to the block IDs in the execution pool window
    pub fn block_ids(&self) -> &Vec<HashValue> {
        &self.block_ids
    }

    /// Verifies the execution pool window contents and returns an error if the data is invalid
    pub fn verify_window_contents(&self, _expected_window_size: u64) -> Result<(), Error> {
        Ok(()) // TODO: Implement this method!
    }
}
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L849-867)
```rust
        // Verify the execution pool window contents
        let execution_pool_window = ordered_block_with_window.execution_pool_window();
        if let Err(error) = execution_pool_window.verify_window_contents(execution_pool_window_size)
        {
            // Log the error and update the invalid message counter
            error!(
                LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                    "Failed to verify execution pool window contents! Ignoring: {:?}, from peer: {:?}. Error: {:?}",
                    ordered_block.proof_block_info(),
                    peer_network_id,
                    error
                ))
            );
            increment_invalid_message_counter(
                &peer_network_id,
                metrics::ORDERED_BLOCK_WITH_WINDOW_LABEL,
            );
            return;
        };
```

**File:** types/src/on_chain_config/consensus_config.rs (L10-13)
```rust
/// Default Window Size for Execution Pool.
/// This describes the number of blocks in the Execution Pool Window
pub const DEFAULT_WINDOW_SIZE: Option<u64> = None;
pub const DEFAULT_ENABLED_WINDOW_SIZE: Option<u64> = Some(1);
```

**File:** config/src/config/network_config.rs (L48-50)
```rust
    (MAX_MESSAGE_SIZE - MAX_MESSAGE_METADATA_SIZE) - MESSAGE_PADDING_SIZE; /* The message size that applications should check against */
pub const MAX_FRAME_SIZE: usize = 4 * 1024 * 1024; /* 4 MiB large messages will be chunked into multiple frames and streamed */
pub const MAX_MESSAGE_SIZE: usize = 64 * 1024 * 1024; /* 64 MiB */
```

**File:** network/framework/src/protocols/stream/mod.rs (L259-273)
```rust
    pub async fn stream_message(&mut self, mut message: NetworkMessage) -> anyhow::Result<()> {
        // Verify that the message is not an error message
        ensure!(
            !matches!(message, NetworkMessage::Error(_)),
            "Error messages should not be streamed!"
        );

        // Verify that the message size is within limits
        let message_data_len = message.data_len();
        ensure!(
            message_data_len <= self.max_message_size,
            "Message length {} exceeds max message size {}!",
            message_data_len,
            self.max_message_size,
        );
```
