# Audit Report

## Title
Silent Payload Verification Failure Causes Consensus Liveness Failure in Consensus Observer

## Summary

The `insert_block_payload` function in the consensus observer payload store silently drops payload updates when the store is at capacity, even when replacing existing entries. This causes `verify_payload_signatures` to report payloads as successfully verified when they remain unverified, leading to blocks never being ordered and processed, resulting in a consensus liveness failure. [1](#0-0) 

## Finding Description

The vulnerability exists in the block payload verification flow during epoch transitions. When `verify_payload_signatures` is called to verify unverified block payloads, it attempts to re-insert successfully verified payloads back into the store as "verified". However, the `insert_block_payload` function performs a capacity check that doesn't distinguish between inserting new entries and updating existing entries. [2](#0-1) 

**Attack Flow:**

1. Attacker floods the consensus observer with block payloads until the store reaches `max_num_pending_blocks` capacity
2. Some payloads arrive unverified (before epoch state is available)
3. During epoch transition, `verify_payload_signatures` is called to verify these payloads
4. The function successfully verifies payloads and collects them in `verified_payloads_to_update`
5. When attempting to re-insert these payloads as "verified" via `insert_block_payload`, the capacity check at line 86 fails (store is at limit)
6. The function silently returns early without inserting, leaving payloads in "unverified" state
7. However, `verify_payload_signatures` returns these rounds as successfully verified [3](#0-2) 

8. The consensus observer then calls `order_ready_pending_block` for each "verified" round
9. This function checks if all payloads exist using `all_payloads_exist`, which specifically requires `AvailableAndVerified` status
10. The check fails because payloads are still `AvailableAndUnverified`
11. Blocks are never ordered or committed, causing liveness failure [4](#0-3) 

The root cause is that `insert_block_payload` checks `self.block_payloads.lock().len() >= max_num_pending_blocks` without considering that a BTreeMap `insert` operation doesn't increase size when replacing an existing key. The function should allow updates to existing entries even at capacity.

## Impact Explanation

This vulnerability can cause **total loss of liveness** in the consensus observer node, qualifying as **Critical Severity** per Aptos bug bounty criteria. When the payload store reaches capacity during high network activity or targeted attack:

- Blocks cannot be marked as having verified payloads
- The consensus observer cannot order or commit any new blocks
- The node becomes stuck, unable to process transactions
- State sync and block execution pipeline stalls
- Node operators must manually intervene to restart services

While this affects the consensus observer (not the full validator), observer nodes are critical for:
- Light clients and wallets that rely on observers for block updates
- State sync between validators
- Network health monitoring

An attacker can deliberately trigger this by sending many block payload messages to fill the store, then waiting for epoch transition when verification occurs.

## Likelihood Explanation

**High Likelihood** - This vulnerability can occur in normal network conditions:

1. **Natural Occurrence**: During high transaction volume or network congestion, the payload store can legitimately reach capacity
2. **Epoch Transitions**: The vulnerable code path is triggered at every epoch transition when `verify_payload_signatures` is called
3. **No Special Privileges**: Any network peer can send block payload messages to observers
4. **Amplification**: An attacker can deliberately flood observers with payloads to ensure capacity is reached

The attack requires:
- Ability to send consensus observer protocol messages (any network peer)
- Knowledge of epoch boundaries (public information)
- Sufficient payloads to reach `max_num_pending_blocks` (default: configurable, typically ~100-1000)

## Recommendation

Modify `insert_block_payload` to distinguish between inserting new entries and updating existing entries. The capacity check should only apply to new insertions:

```rust
pub fn insert_block_payload(
    &mut self,
    block_payload: BlockPayload,
    verified_payload_signatures: bool,
) {
    let epoch_and_round = (block_payload.epoch(), block_payload.round());
    
    // Only check capacity for new entries, not updates
    let is_new_entry = !self.block_payloads.lock().contains_key(&epoch_and_round);
    if is_new_entry {
        let max_num_pending_blocks = self.consensus_observer_config.max_num_pending_blocks as usize;
        if self.block_payloads.lock().len() >= max_num_pending_blocks {
            warn!(
                LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                    "Exceeded the maximum number of payloads: {:?}. Dropping block: {:?}!",
                    max_num_pending_blocks,
                    block_payload.block(),
                ))
            );
            return;
        }
    }

    // Create and insert the new payload status
    let payload_status = if verified_payload_signatures {
        BlockPayloadStatus::AvailableAndVerified(block_payload)
    } else {
        BlockPayloadStatus::AvailableAndUnverified(block_payload)
    };

    self.block_payloads
        .lock()
        .insert(epoch_and_round, payload_status);
}
```

Alternatively, change the function to return a `Result` instead of silently dropping insertions, allowing callers to handle failures appropriately.

## Proof of Concept

```rust
#[test]
fn test_verify_payload_signatures_at_capacity() {
    // Setup: Create store with max capacity of 10
    let max_num_pending_blocks = 10;
    let config = ConsensusObserverConfig {
        max_num_pending_blocks,
        ..Default::default()
    };
    let mut store = BlockPayloadStore::new(config);
    
    // Fill store to capacity with 9 verified payloads
    for i in 0..9 {
        let payload = create_test_payload(0, i);
        store.insert_block_payload(payload, true);
    }
    
    // Add 1 unverified payload (total: 10, at limit)
    let unverified_payload = create_test_payload(0, 9);
    store.insert_block_payload(unverified_payload.clone(), false);
    
    // Verify store is at capacity
    assert_eq!(store.block_payloads.lock().len(), 10);
    
    // Create epoch state and verify signatures
    let epoch_state = create_test_epoch_state(0);
    let verified_rounds = store.verify_payload_signatures(&epoch_state);
    
    // BUG: Function returns round 9 as verified
    assert_eq!(verified_rounds, vec![9]);
    
    // BUG: But the payload is still unverified in the store!
    let payloads = store.block_payloads.lock();
    match payloads.get(&(0, 9)) {
        Some(BlockPayloadStatus::AvailableAndVerified(_)) => {
            panic!("Expected unverified, but payload was marked as verified");
        },
        Some(BlockPayloadStatus::AvailableAndUnverified(_)) => {
            // BUG CONFIRMED: Payload remains unverified despite being returned
            // as verified by verify_payload_signatures
        },
        None => panic!("Payload missing from store"),
    }
    
    // Consequence: all_payloads_exist will now fail
    let blocks = vec![create_test_block(0, 9)];
    assert!(!store.all_payloads_exist(&blocks)); // FAILS - blocks cannot be ordered!
}
```

**Steps to reproduce:**
1. Configure consensus observer with small `max_num_pending_blocks` (e.g., 10)
2. Send block payload messages to fill the store to capacity
3. Send one additional payload without signature verification
4. Trigger epoch transition (or wait for natural epoch boundary)
5. Observe that `verify_payload_signatures` returns the payload round as verified
6. Observe that `all_payloads_exist` returns false for blocks requiring that payload
7. Observe that blocks are never ordered, causing liveness failure

## Notes

The vulnerability specifically affects the consensus observer component during epoch transitions. The silent failure pattern in `insert_block_payload` violates Rust best practices for error handlingâ€”functions that can fail should return `Result` types rather than silently ignoring failures. This allows proper error propagation and recovery mechanisms.

### Citations

**File:** consensus/src/consensus_observer/observer/payload_store.rs (L46-57)
```rust
    /// Returns true iff all the payloads for the given blocks
    /// are available and have been verified.
    pub fn all_payloads_exist(&self, blocks: &[Arc<PipelinedBlock>]) -> bool {
        let block_payloads = self.block_payloads.lock();
        blocks.iter().all(|block| {
            let epoch_and_round = (block.epoch(), block.round());
            matches!(
                block_payloads.get(&epoch_and_round),
                Some(BlockPayloadStatus::AvailableAndVerified(_))
            )
        })
    }
```

**File:** consensus/src/consensus_observer/observer/payload_store.rs (L79-109)
```rust
    pub fn insert_block_payload(
        &mut self,
        block_payload: BlockPayload,
        verified_payload_signatures: bool,
    ) {
        // Verify that the number of payloads doesn't exceed the maximum
        let max_num_pending_blocks = self.consensus_observer_config.max_num_pending_blocks as usize;
        if self.block_payloads.lock().len() >= max_num_pending_blocks {
            warn!(
                LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                    "Exceeded the maximum number of payloads: {:?}. Dropping block: {:?}!",
                    max_num_pending_blocks,
                    block_payload.block(),
                ))
            );
            return; // Drop the block if we've exceeded the maximum
        }

        // Create the new payload status
        let epoch_and_round = (block_payload.epoch(), block_payload.round());
        let payload_status = if verified_payload_signatures {
            BlockPayloadStatus::AvailableAndVerified(block_payload)
        } else {
            BlockPayloadStatus::AvailableAndUnverified(block_payload)
        };

        // Insert the new payload status
        self.block_payloads
            .lock()
            .insert(epoch_and_round, payload_status);
    }
```

**File:** consensus/src/consensus_observer/observer/payload_store.rs (L215-274)
```rust
    /// Verifies the block payload signatures against the given epoch state.
    /// If verification is successful, blocks are marked as verified.
    pub fn verify_payload_signatures(&mut self, epoch_state: &EpochState) -> Vec<Round> {
        // Get the current epoch
        let current_epoch = epoch_state.epoch;

        // Gather the keys for the block payloads
        let payload_epochs_and_rounds: Vec<(u64, Round)> =
            self.block_payloads.lock().keys().cloned().collect();

        // Go through all unverified blocks and attempt to verify the signatures
        let mut verified_payloads_to_update = vec![];
        for (epoch, round) in payload_epochs_and_rounds {
            // Check if we can break early (BtreeMaps are sorted by key)
            if epoch > current_epoch {
                break;
            }

            // Otherwise, attempt to verify the payload signatures
            if epoch == current_epoch {
                if let Entry::Occupied(mut entry) = self.block_payloads.lock().entry((epoch, round))
                {
                    if let BlockPayloadStatus::AvailableAndUnverified(block_payload) =
                        entry.get_mut()
                    {
                        if let Err(error) = block_payload.verify_payload_signatures(epoch_state) {
                            // Log the verification failure
                            error!(
                                LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                                    "Failed to verify the block payload signatures for epoch: {:?} and round: {:?}. Error: {:?}",
                                    epoch, round, error
                                ))
                            );

                            // Remove the block payload from the store
                            entry.remove();
                        } else {
                            // Save the block payload for reinsertion
                            verified_payloads_to_update.push(block_payload.clone());
                        }
                    }
                }
            }
        }

        // Collect the rounds of all newly verified blocks
        let verified_payload_rounds: Vec<Round> = verified_payloads_to_update
            .iter()
            .map(|block_payload| block_payload.round())
            .collect();

        // Update the verified block payloads. Note: this will cause
        // notifications to be sent to any listeners that are waiting.
        for verified_payload in verified_payloads_to_update {
            self.insert_block_payload(verified_payload, true);
        }

        // Return the newly verified payload rounds
        verified_payload_rounds
    }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L1035-1044)
```rust
            let verified_payload_rounds = self
                .observer_block_data
                .lock()
                .verify_payload_signatures(&new_epoch_state);

            // Order all the pending blocks that are now ready (these were buffered during state sync)
            for payload_round in verified_payload_rounds {
                self.order_ready_pending_block(new_epoch_state.epoch, payload_round)
                    .await;
            }
```
