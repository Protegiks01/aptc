# Audit Report

## Title
Missing Authentication on Internal FullnodeData gRPC Service Enables Resource Exhaustion and Node Slowdowns

## Summary
The `FullnodeDataServer` gRPC service exposes internal blockchain indexing functionality without any authentication mechanism, despite the service being marked as "internal" in the protocol buffer namespace. This allows any network client to connect and stream unlimited blockchain transaction data, enabling resource exhaustion attacks that can slow down or crash fullnodes and validators running the indexer service.

## Finding Description

The `FullnodeDataServer` implementation in the indexer-grpc-fullnode component creates an unauthenticated gRPC endpoint that provides access to sensitive node operations. The vulnerability manifests in multiple locations:

**1. Service Instantiation Without Authentication** [1](#0-0) 

The server is instantiated with only compression configuration, completely omitting the `with_interceptor()` method that would add authentication middleware. This is in contrast to the pattern suggested by the generated code where authentication interceptors can be added.

**2. No Authentication Configuration Available** [2](#0-1) 

The `IndexerGrpcConfig` struct contains no fields for authentication tokens, auth checking, or access control of any kind. The only security-related configuration is the network binding address.

**3. Public Network Exposure by Default** [3](#0-2) [4](#0-3) 

The default configuration and example deployments bind to `0.0.0.0:50051`, exposing the service to all network interfaces without any access restrictions.

**4. Sensitive Operations Exposed** [5](#0-4) 

The `get_transactions_from_node` method allows streaming arbitrary ranges of blockchain transactions without authentication. An attacker can request the entire blockchain history repeatedly. [6](#0-5) 

The `ping` method exposes node synchronization status and metadata to unauthenticated clients.

**Attack Scenario:**

1. Attacker discovers fullnode/validator with indexer gRPC enabled on default port 50051
2. Attacker opens multiple concurrent connections using standard gRPC clients
3. Each connection requests streaming of transactions from version 0 to max
4. Node resources (CPU, memory, network bandwidth, disk I/O) are exhausted serving multiple streams
5. Validator performance degrades, potentially missing consensus rounds or slowing transaction processing
6. Legitimate indexers cannot connect or receive delayed data

The service being in the `aptos.internal.fullnode.v1` namespace indicates it was designed for internal use, yet no authentication enforcement exists.

## Impact Explanation

This vulnerability qualifies as **High Severity** per the Aptos bug bounty criteria:

**Validator Node Slowdowns**: When the indexer gRPC service runs on validator nodes (which is supported by the configuration), unlimited unauthenticated requests can consume significant resources:
- CPU cycles for transaction serialization and streaming
- Memory for buffering transaction data across multiple concurrent streams  
- Network bandwidth saturation from streaming large volumes of data
- Disk I/O pressure from repeated blockchain traversals

These resource constraints can degrade validator performance, potentially causing missed block proposals, delayed vote processing, or consensus participation issues.

**API Crashes**: The service lacks per-client rate limiting or connection limits. An attacker spawning thousands of concurrent connections could exhaust:
- File descriptor limits
- Memory allocation for gRPC channels and buffers
- Thread pool resources in the tokio runtime

This could cause the gRPC service to crash or become unresponsive, denying service to legitimate indexers.

While blockchain transaction data is inherently public, the lack of authentication prevents:
- Rate limiting per client
- Blocking abusive IP addresses  
- Monitoring and alerting on suspicious access patterns
- Distinguishing legitimate vs. malicious traffic

## Likelihood Explanation

**Likelihood: High**

This vulnerability is highly likely to be exploited because:

1. **Trivial to Exploit**: No specialized knowledge required beyond basic gRPC client usage. The README itself provides example commands to connect without authentication.

2. **Default Configuration**: The vulnerable configuration is the default setup shown in documentation, meaning many nodes are likely exposed.

3. **Public Attack Surface**: Nodes bound to `0.0.0.0` are discoverable via network scanning on the default port 50051.

4. **No Security Warnings**: Documentation does not warn operators about the security implications of exposing this service publicly.

5. **Economic Incentive**: Competitors or malicious actors have incentives to degrade validator performance or disrupt indexing infrastructure.

## Recommendation

**Immediate Fix**: Implement authentication interceptor enforcement on `FullnodeDataServer`: [7](#0-6) 

Replace the unauthenticated server instantiation with an interceptor that validates authentication tokens:

```rust
// Add authentication configuration to IndexerGrpcConfig
pub struct IndexerGrpcConfig {
    // ... existing fields ...
    pub required_auth_tokens: Vec<String>,
    pub enable_auth_check: bool,
}

// In runtime.rs bootstrap function:
let svc = if !node_config.indexer_grpc.required_auth_tokens.is_empty() 
    && node_config.indexer_grpc.enable_auth_check {
    
    let auth_tokens = node_config.indexer_grpc.required_auth_tokens.clone();
    let interceptor = move |req: Request<()>| {
        let auth_header = req.metadata()
            .get("x-aptos-data-authorization")
            .and_then(|v| v.to_str().ok());
        
        match auth_header {
            Some(token) if auth_tokens.contains(&token.to_string()) => Ok(req),
            _ => Err(Status::unauthenticated("Invalid or missing authentication token"))
        }
    };
    
    FullnodeDataServer::new(server)
        .with_interceptor(interceptor)
        .send_compressed(CompressionEncoding::Zstd)
        .accept_compressed(CompressionEncoding::Zstd)
        .accept_compressed(CompressionEncoding::Gzip)
} else {
    // Allow disabling auth for backwards compatibility, but log warning
    warn!("[indexer-grpc] Running without authentication - not recommended for production");
    FullnodeDataServer::new(server)
        .send_compressed(CompressionEncoding::Zstd)
        .accept_compressed(CompressionEncoding::Zstd)
        .accept_compressed(CompressionEncoding::Gzip)
};
```

**Additional Recommendations**:
1. Add network binding warnings to configuration validation
2. Implement per-client rate limiting 
3. Add connection limits to prevent resource exhaustion
4. Update documentation to highlight security considerations
5. Consider moving to mTLS for stronger authentication

## Proof of Concept

**Step 1**: Start a fullnode with indexer gRPC enabled using default configuration:

```yaml
# fullnode.yaml
storage:
  enable_indexer: true

indexer_grpc:
  enabled: true
  address: 0.0.0.0:50051
```

**Step 2**: Launch resource exhaustion attack from any network location:

```bash
# Install grpcurl
# Connect without any authentication and stream transactions
for i in {1..100}; do
  grpcurl -max-msg-sz 100000000 \
    -d '{"starting_version": 0}' \
    -import-path protos/proto \
    -proto aptos/internal/fullnode/v1/fullnode_data.proto \
    -plaintext <TARGET_IP>:50051 \
    aptos.internal.fullnode.v1.FullnodeData/GetTransactionsFromNode &
done

# Monitor target node resource consumption
# Observe CPU, memory, and network bandwidth saturation
# Measure validator performance degradation
```

**Step 3**: Verify impact:
- Monitor target node with `htop` or similar - observe resource exhaustion
- Check validator metrics for missed proposals or delayed consensus participation  
- Verify legitimate indexers cannot connect or experience severe latency

This demonstrates that the unauthenticated gRPC endpoint enables trivial resource exhaustion attacks with significant operational impact on fullnodes and validators.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/runtime.rs (L101-121)
```rust
        let tonic_server = Server::builder()
            .http2_keepalive_interval(Some(std::time::Duration::from_secs(60)))
            .http2_keepalive_timeout(Some(std::time::Duration::from_secs(5)))
            .add_service(reflection_service_clone);

        let router = match use_data_service_interface {
            false => {
                let svc = FullnodeDataServer::new(server)
                    .send_compressed(CompressionEncoding::Zstd)
                    .accept_compressed(CompressionEncoding::Zstd)
                    .accept_compressed(CompressionEncoding::Gzip);
                tonic_server.add_service(svc)
            },
            true => {
                let svc = RawDataServer::new(localnet_data_server)
                    .send_compressed(CompressionEncoding::Zstd)
                    .accept_compressed(CompressionEncoding::Zstd)
                    .accept_compressed(CompressionEncoding::Gzip);
                tonic_server.add_service(svc)
            },
        };
```

**File:** config/src/config/indexer_grpc_config.rs (L33-59)
```rust
pub struct IndexerGrpcConfig {
    pub enabled: bool,

    /// If true, the GRPC stream interface exposed by the data service will be used
    /// instead of the standard fullnode GRPC stream interface. In other words, with
    /// this enabled, you can use an indexer fullnode like it is an instance of the
    /// indexer-grpc data service (aka the Transaction Stream Service API).
    pub use_data_service_interface: bool,

    /// The address that the grpc server will listen on.
    pub address: SocketAddr,

    /// Number of processor tasks to fan out
    pub processor_task_count: Option<u16>,

    /// Number of transactions each processor will process
    pub processor_batch_size: u16,

    /// Number of transactions returned in a single stream response
    pub output_batch_size: u16,

    /// Size of the transaction channel buffer for streaming.
    pub transaction_channel_size: usize,

    /// Maximum size in bytes for transaction filters.
    pub max_transaction_filter_size_bytes: usize,
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/README.md (L21-21)
```markdown
      address: 0.0.0.0:50051
```

**File:** docker/compose/validator-testnet/docker-compose.yaml (L43-43)
```yaml
      - "50051:50051" # Indexer GRPC, if enabled
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/fullnode_data_service.rs (L67-78)
```rust
    async fn get_transactions_from_node(
        &self,
        req: Request<GetTransactionsFromNodeRequest>,
    ) -> Result<Response<Self::GetTransactionsFromNodeStream>, Status> {
        // Gets configs for the stream, partly from the request and partly from the node config
        let r = req.into_inner();
        let starting_version = match r.starting_version {
            Some(version) => version,
            // Live mode unavailable for FullnodeDataService
            // Enable use_data_service_interface in config to use LocalnetDataService instead
            None => return Err(Status::invalid_argument("Starting version must be set")),
        };
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/fullnode_data_service.rs (L207-217)
```rust
    async fn ping(
        &self,
        _request: Request<PingFullnodeRequest>,
    ) -> Result<Response<PingFullnodeResponse>, Status> {
        let timestamp = timestamp_now_proto();
        let known_latest_version = self
            .service_context
            .context
            .db
            .get_synced_version()
            .map_err(|e| Status::internal(format!("{e}")))?;
```
