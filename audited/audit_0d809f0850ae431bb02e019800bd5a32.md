# Audit Report

## Title
Multisig Transaction Reentrancy Causes Vote Count Corruption in Cleanup Events

## Summary
Multisig transaction payloads can make reentrant calls to multisig account management functions (e.g., `add_owners`, `remove_owners`) during execution. These modifications to the owner list occur before the cleanup phase, causing the transaction cleanup logic to use the modified owner list when counting votes, leading to incorrect vote counts in emitted events and audit trails.

## Finding Description

The multisig transaction execution flow has a reentrancy vulnerability where the transaction payload executes before state cleanup: [1](#0-0) 

During step 2, the payload executes with the multisig account's signer: [2](#0-1) 

This allows the payload to call entry functions like `add_owners` or `remove_owners`: [3](#0-2) 

The critical issue occurs in the cleanup phase. After payload execution completes, the cleanup function counts votes using the **current** (potentially modified) owner list: [4](#0-3) 

The vote counting function iterates over the current owner list: [5](#0-4) 

**Attack Scenario:**
1. Multisig account with owners [Alice, Bob, Charlie, Dave], threshold = 3
2. Create transaction to `remove_owners(vec![Dave])`
3. Alice creates (1 approval), Bob approves (2 approvals), Dave **rejects** (1 rejection)
4. Charlie approves (3 approvals, can execute)
5. Transaction executes: payload removes Dave from owner list → owners = [Alice, Bob, Charlie]
6. Cleanup counts votes from [Alice, Bob, Charlie] only → Dave's rejection is not counted
7. Event reports 3 approvals, 0 rejections (Dave's vote lost)

This violates the invariant demonstrated in the test suite: [6](#0-5) 

## Impact Explanation

**Severity: MEDIUM**

The vulnerability causes state inconsistencies in governance accounting:
- **Vote count corruption**: Events report incorrect approval/rejection counts
- **Audit trail manipulation**: Dissenting votes can be hidden by removing voters during execution
- **Governance transparency violation**: Historical records don't reflect actual votes cast
- **Data integrity failure**: Downstream systems relying on events receive false data

This qualifies as **Medium Severity** per Aptos bug bounty criteria: "State inconsistencies requiring intervention" and impacts governance integrity tracking systems.

## Likelihood Explanation

**Likelihood: MEDIUM**

The attack requires:
- Malicious multisig owners with k-of-n signatures (insider access to that specific multisig)
- Payload must be crafted to modify owner list
- For hash-only transactions, payload is not visible until execution
- Any Aptos user can create a multisig and become an owner

While requiring owner collusion, the attack is straightforward once threshold signatures are obtained. The payload construction is trivial and the vulnerability is reliably exploitable.

## Recommendation

**Fix: Snapshot the owner list before transaction execution**

Modify `remove_executed_transaction` to accept the original owner list from when the transaction was validated, rather than using the current owner list:

```move
// In validate_multisig_transaction or transaction_execution_cleanup_common:
// Capture owner list BEFORE execution
let original_owners = *&multisig_account_resource.owners;

// Pass to cleanup
fun remove_executed_transaction(
    multisig_account_resource: &mut MultisigAccount,
    original_owners: &vector<address>  // Add parameter
): (u64, u64) {
    let sequence_number = multisig_account_resource.last_executed_sequence_number + 1;
    let transaction = table::remove(&mut multisig_account_resource.transactions, sequence_number);
    multisig_account_resource.last_executed_sequence_number = sequence_number;
    // Use original_owners instead of current owners
    num_approvals_and_rejections_internal(original_owners, &transaction)
}
```

This ensures vote counts reflect the owner set at the time votes were cast, not after payload modifications.

## Proof of Concept

```move
#[test(owner_1 = @0x123, owner_2 = @0x124, owner_3 = @0x125, owner_4 = @0x126)]
fun test_reentrancy_vote_count_corruption(
    owner_1: &signer, owner_2: &signer, owner_3: &signer, owner_4: &signer
) acquires MultisigAccount {
    setup();
    let owner_1_addr = address_of(owner_1);
    let owner_2_addr = address_of(owner_2);
    let owner_3_addr = address_of(owner_3);
    let owner_4_addr = address_of(owner_4);
    
    create_account(owner_1_addr);
    let multisig_account = get_next_multisig_account_address(owner_1_addr);
    
    // Create 4-owner multisig with threshold 3
    create_with_owners(owner_1, vector[owner_2_addr, owner_3_addr, owner_4_addr], 3, vector[], vector[]);
    
    // Create transaction to remove owner_4 (payload will cause reentrancy)
    let payload = encode_remove_owner_payload(multisig_account, owner_4_addr);
    create_transaction(owner_1, multisig_account, payload);
    
    // Owner_2 and owner_3 approve, owner_4 REJECTS
    approve_transaction(owner_2, multisig_account, 1);
    approve_transaction(owner_3, multisig_account, 1);
    reject_transaction(owner_4, multisig_account, 1); // This rejection will be lost!
    
    // Execute - owner_4 is removed during execution
    successful_transaction_execution_cleanup(owner_1_addr, multisig_account, payload);
    
    // BUG: Vote count should show 3 approvals, 1 rejection
    // But it reports 3 approvals, 0 rejections because owner_4 was removed
    // Owner_4's rejection is completely lost in the accounting
}
```

**Notes:**
- The vulnerability is real and reproducible
- Impact is limited to data integrity, not direct security harm
- Requires owner-level access to the specific multisig account
- Primary concern is governance transparency and audit trail correctness

### Citations

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1283-1300)
```rust
        // Step 2: Execute the target payload. Transaction failure here is tolerated. In case of any
        // failures, we'll discard the session and start a new one. This ensures that any data
        // changes are not persisted.
        // The multisig transaction would still be considered executed even if execution fails.
        let execution_result = match payload {
            MultisigTransactionPayload::EntryFunction(entry_function) => self
                .execute_multisig_entry_function(
                    resolver,
                    module_storage,
                    session,
                    gas_meter,
                    traversal_context,
                    multisig_address,
                    &entry_function,
                    change_set_configs,
                    trace_recorder,
                ),
        };
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1377-1387)
```rust
        session.execute(|session| {
            self.validate_and_execute_entry_function(
                module_storage,
                session,
                &SerializedSigners::new(vec![serialized_signer(&multisig_address)], None),
                gas_meter,
                traversal_context,
                payload,
                trace_recorder,
            )
        })?;
```

**File:** aptos-move/framework/aptos-framework/sources/multisig_account.move (L781-789)
```text
    entry fun add_owners(
        multisig_account: &signer, new_owners: vector<address>) acquires MultisigAccount {
        update_owner_schema(
            address_of(multisig_account),
            new_owners,
            vector[],
            option::none()
        );
    }
```

**File:** aptos-move/framework/aptos-framework/sources/multisig_account.move (L1288-1293)
```text
    fun remove_executed_transaction(multisig_account_resource: &mut MultisigAccount): (u64, u64) {
        let sequence_number = multisig_account_resource.last_executed_sequence_number + 1;
        let transaction = table::remove(&mut multisig_account_resource.transactions, sequence_number);
        multisig_account_resource.last_executed_sequence_number = sequence_number;
        num_approvals_and_rejections_internal(&multisig_account_resource.owners, &transaction)
    }
```

**File:** aptos-move/framework/aptos-framework/sources/multisig_account.move (L1372-1388)
```text
    inline fun num_approvals_and_rejections_internal(owners: &vector<address>, transaction: &MultisigTransaction): (u64, u64) {
        let num_approvals = 0;
        let num_rejections = 0;

        let votes = &transaction.votes;
        vector::for_each_ref(owners, |owner| {
            if (simple_map::contains_key(votes, owner)) {
                if (*simple_map::borrow(votes, owner)) {
                    num_approvals = num_approvals + 1;
                } else {
                    num_rejections = num_rejections + 1;
                };
            }
        });

        (num_approvals, num_rejections)
    }
```

**File:** aptos-move/framework/aptos-framework/sources/multisig_account.move (L2113-2133)
```text
    public entry fun test_validate_transaction_should_not_consider_removed_owners(
        owner_1: &signer, owner_2: &signer, owner_3: & signer) acquires MultisigAccount {
        setup();
        let owner_1_addr = address_of(owner_1);
        let owner_2_addr = address_of(owner_2);
        let owner_3_addr = address_of(owner_3);
        create_account(owner_1_addr);
        let multisig_account = get_next_multisig_account_address(owner_1_addr);
        create_with_owners(owner_1, vector[owner_2_addr, owner_3_addr], 2, vector[], vector[]);

        // Owner 1 and 2 approved but then owner 1 got removed.
        create_transaction(owner_1, multisig_account, PAYLOAD);
        approve_transaction(owner_2, multisig_account, 1);
        // Before owner 1 is removed, the transaction technically has sufficient approvals.
        assert!(can_be_executed(multisig_account, 1), 0);
        let multisig_signer = &create_signer(multisig_account);
        remove_owners(multisig_signer, vector[owner_1_addr]);
        // Now that owner 1 is removed, their approval should be invalidated and the transaction no longer
        // has enough approvals to be executed.
        assert!(!can_be_executed(multisig_account, 1), 1);
    }
```
