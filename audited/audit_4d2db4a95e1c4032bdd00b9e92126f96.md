# Audit Report

## Title
Key Collision Vulnerability in Secure Storage Previous Version Naming Pattern

## Summary
The `get_previous_version_name()` function in the secure storage system creates key names by appending `_previous` to the base key name, without validating that this derived name doesn't conflict with legitimately created keys. This can lead to silent key overwrites in storage backends that lack collision protection (OnDiskStorage and InMemoryStorage).

## Finding Description

The secure storage system uses a naming convention to track previous versions of rotated keys. The function `get_previous_version_name()` creates these names by appending `_previous` to the original key name. [1](#0-0) 

When a key is rotated, the system stores the old key using this naming pattern. [2](#0-1) 

However, there is no validation to prevent users from creating keys that explicitly use the `_previous` suffix. In OnDiskStorage, the `set()` operation uses HashMap's `insert()` method which silently overwrites existing keys. [3](#0-2) 

Similarly, InMemoryStorage exhibits the same behavior. [4](#0-3) 

**Attack Scenario:**
1. An operator creates a key named "mykey_previous" for legitimate purposes
2. Later, a key named "mykey" is created and rotated
3. The rotation operation stores the old "mykey" as "mykey_previous", silently overwriting the legitimate key
4. The original "mykey_previous" key material is permanently lost

OnDiskStorage is used in production validator configurations. [5](#0-4) 

Note that VaultStorage (the production-recommended backend) does have collision protection through key existence checks. [6](#0-5) 

## Impact Explanation

This issue qualifies as **Medium Severity** under the Aptos bug bounty criteria ("State inconsistencies requiring intervention"). The vulnerability can cause:

- **Loss of cryptographic key material**: Legitimate keys get silently overwritten without warning
- **Operational failures**: Systems depending on the overwritten keys will fail
- **State inconsistencies**: The storage state becomes inconsistent with operator expectations

However, the impact is limited because:
- VaultStorage (production) has protection against this
- OnDiskStorage is explicitly marked for non-production use in code comments
- Exploitation requires either operator error or write access to secure storage

## Likelihood Explanation

The likelihood is **Low to Medium**:

**Low likelihood** because:
- Secure storage is meant to be access-controlled
- Key names are typically system-controlled constants, not user input
- Requires operational mistakes or naming conflicts between different tools

**Medium likelihood** in scenarios where:
- Multiple tools/components share the same OnDiskStorage
- Custom key names are used without awareness of the `_previous` pattern
- Development/testing environments where OnDiskStorage is common

## Recommendation

Implement key name validation to prevent the `_previous` suffix in user-created keys, and add collision detection in the rotation logic:

```rust
// In crypto_kv_storage.rs, add validation before import_private_key:
fn import_private_key(&mut self, name: &str, key: Ed25519PrivateKey) -> Result<(), Error> {
    // Validate key name doesn't use reserved suffix
    if name.ends_with("_previous") {
        return Err(Error::InvalidKeyName(
            "Key names cannot end with '_previous' (reserved for key rotation)".to_string()
        ));
    }
    self.set(name, key)
}

// In rotate_key, check for collision before overwriting:
fn rotate_key(&mut self, name: &str) -> Result<Ed25519PublicKey, Error> {
    let private_key: Ed25519PrivateKey = self.get(name)?.value;
    let (new_private_key, new_public_key) = new_ed25519_key_pair();
    
    let previous_name = get_previous_version_name(name);
    // Warn if overwriting an existing key
    if self.get::<Ed25519PrivateKey>(&previous_name).is_ok() {
        warn!("Overwriting existing key: {}", previous_name);
    }
    
    self.set(&previous_name, private_key)?;
    self.set(name, new_private_key)?;
    Ok(new_public_key)
}
```

Additionally, OnDiskStorage should implement the same collision protection as VaultStorage for production safety.

## Proof of Concept

```rust
#[cfg(test)]
mod test_key_collision {
    use super::*;
    use aptos_secure_storage::{CryptoStorage, OnDiskStorage, Storage};
    use aptos_crypto::ed25519::Ed25519PrivateKey;
    
    #[test]
    fn test_previous_version_key_collision() {
        let temp_path = aptos_temppath::TempPath::new();
        temp_path.create_as_file().unwrap();
        let mut storage = Storage::from(OnDiskStorage::new(temp_path.path().to_path_buf()));
        
        // Create a key with the "_previous" suffix
        let original_key = storage.create_key("mykey_previous").unwrap();
        let original_private = storage.export_private_key("mykey_previous").unwrap();
        
        // Create another key and rotate it
        storage.create_key("mykey").unwrap();
        storage.rotate_key("mykey").unwrap();
        
        // The rotation has overwritten "mykey_previous" silently
        let after_rotation = storage.export_private_key("mykey_previous").unwrap();
        
        // Verify the key was overwritten (they should be different)
        assert_ne!(original_private, after_rotation, 
            "Original key was silently overwritten by rotation!");
        
        // The original key material is now lost
    }
}
```

---

**Notes:**

While this vulnerability exists in the code, its practical exploitability is limited:

1. **Access Control**: Secure storage is meant to be protected, so attackers typically cannot create arbitrary keys
2. **Production Protection**: VaultStorage (recommended for production) already has collision protection
3. **Limited Usage**: OnDiskStorage is marked for non-production use in its documentation [7](#0-6) 

The vulnerability represents a design flaw that could cause operational issues rather than a directly exploitable security vulnerability by external attackers. It would primarily affect scenarios involving operator mistakes, tool conflicts, or development environments.

### Citations

**File:** secure/storage/src/crypto_kv_storage.rs (L80-86)
```rust
    fn rotate_key(&mut self, name: &str) -> Result<Ed25519PublicKey, Error> {
        let private_key: Ed25519PrivateKey = self.get(name)?.value;
        let (new_private_key, new_public_key) = new_ed25519_key_pair();
        self.set(&get_previous_version_name(name), private_key)?;
        self.set(name, new_private_key)?;
        Ok(new_public_key)
    }
```

**File:** secure/storage/src/crypto_kv_storage.rs (L123-125)
```rust
fn get_previous_version_name(name: &str) -> String {
    format!("{}_previous", name)
}
```

**File:** secure/storage/src/on_disk.rs (L16-22)
```rust
/// OnDiskStorage represents a key value store that is persisted to the local filesystem and is
/// intended for single threads (or must be wrapped by a Arc<RwLock<>>). This provides no permission
/// checks and simply offers a proof of concept to unblock building of applications without more
/// complex data stores. Internally, it reads and writes all data to a file, which means that it
/// must make copies of all key material which violates the code base. It violates it because
/// the anticipation is that data stores would securely handle key material. This should not be used
/// in production.
```

**File:** secure/storage/src/on_disk.rs (L85-93)
```rust
    fn set<V: Serialize>(&mut self, key: &str, value: V) -> Result<(), Error> {
        let now = self.time_service.now_secs();
        let mut data = self.read()?;
        data.insert(
            key.to_string(),
            serde_json::to_value(GetResponse::new(value, now))?,
        );
        self.write(&data)
    }
```

**File:** secure/storage/src/in_memory.rs (L50-57)
```rust
    fn set<V: Serialize>(&mut self, key: &str, value: V) -> Result<(), Error> {
        let now = self.time_service.now_secs();
        self.data.insert(
            key.to_string(),
            serde_json::to_vec(&GetResponse::new(value, now))?,
        );
        Ok(())
    }
```

**File:** docker/compose/aptos-node/validator.yaml (L11-13)
```yaml
    backend:
      type: "on_disk_storage"
      path: secure-data.json
```

**File:** secure/storage/src/vault.rs (L221-227)
```rust
    fn import_private_key(&mut self, name: &str, key: Ed25519PrivateKey) -> Result<(), Error> {
        let ns_name = self.crypto_name(name);
        match self.get_public_key(name) {
            Ok(_) => return Err(Error::KeyAlreadyExists(ns_name)),
            Err(Error::KeyNotSet(_)) => (/* Expected this for new keys! */),
            Err(e) => return Err(e),
        }
```
