# Audit Report

## Title
Mainnet Validator Peer Information Disclosure via Default Configuration

## Summary
The `expose_peer_information` flag in the Inspection Service defaults to `true`, and there is no configuration sanitizer check to prevent mainnet validators from exposing sensitive peer network topology data. This allows any attacker to query the `/peer_information` endpoint and obtain detailed information about validator connections, peer IDs, trusted validator sets, and state sync metadata, enabling targeted network attacks.

## Finding Description

The Inspection Service configuration contains an `expose_peer_information` flag that controls whether the `/peer_information` endpoint returns sensitive network data. The vulnerability arises from three critical configuration failures:

**1. Unsafe Default Value**

The default configuration sets `expose_peer_information` to `true`: [1](#0-0) 

**2. Missing Mainnet Sanitizer Check**

The configuration sanitizer only validates `expose_configuration` for mainnet validators, but completely ignores `expose_peer_information`, `expose_identity_information`, and `expose_system_information`: [2](#0-1) 

This contrasts with the explicit check for `expose_configuration` which prevents mainnet validators from exposing that data. No equivalent protection exists for peer information.

**3. No Optimizer Protection**

The config optimizer only forces the flag to `true` for non-mainnet chains when not explicitly set, but does not force it to `false` for mainnet: [3](#0-2) 

**Attack Vector**

When the `/peer_information` endpoint is queried, it exposes:
- All peer IDs and network IDs (validator topology mapping)
- Connection metadata including connection states
- Trusted peers including the complete validator set and seed nodes
- State sync metadata with peer scores and storage summaries
- Internal client state information
- Detailed monitoring metadata [4](#0-3) 

The service binds to `0.0.0.0:9101` by default with no authentication: [5](#0-4) 

**Exploitation Path**

1. Attacker identifies a mainnet validator deployed with default configuration (no explicit `expose_peer_information: false` in YAML)
2. Attacker makes HTTP GET request: `curl http://validator-ip:9101/peer_information`
3. Service returns complete network topology including all validator peer IDs, connection states, and trusted validator set
4. Attacker uses this information to:
   - Map the entire validator network topology
   - Identify well-connected validators (high-value targets)
   - Determine which validators are behind in state sync (timing attack opportunities)
   - Plan targeted network partitioning or eclipse attacks
   - Craft connection-level DoS attacks against specific peers

## Impact Explanation

**Severity: HIGH**

This vulnerability qualifies as HIGH severity under the Aptos bug bounty program for the following reasons:

1. **Significant Protocol Violation**: Mainnet validators should not expose operational data that enables targeted attacks. The sanitizer explicitly prevents `expose_configuration` disclosure but fails to protect equally sensitive peer information.

2. **Attack Enablement**: The disclosed information directly enables multiple attack vectors:
   - **Network topology mapping** allows attackers to understand validator interconnections
   - **Peer identification** enables targeted connection attacks on specific validator pairs
   - **State sync status** reveals validators that may be vulnerable to timing-based exploits
   - **Trusted validator set** disclosure provides complete attack surface mapping

3. **Wide Exposure**: Any validator operator who deploys using default configurations or standard templates (which don't explicitly set this flag) will be vulnerable. The default validator templates examined do not include this setting: [6](#0-5) 

4. **No Authentication**: The inspection service has no access controls, making exploitation trivial for any network-reachable attacker.

While this is primarily an information disclosure issue, it provides critical reconnaissance data for more sophisticated attacks against the validator network, including potential consensus disruption through targeted peer manipulation.

## Likelihood Explanation

**Likelihood: HIGH**

This vulnerability is highly likely to exist in production deployments:

1. **Default Configuration Trap**: Validators deployed with default settings or incomplete configurations will automatically expose peer information since the default is `true`.

2. **No Warning or Error**: Unlike `expose_configuration` which triggers a sanitizer error for mainnet validators, there is no validation failure to alert operators that they're exposing peer information: [7](#0-6) 

3. **Template Omission**: Standard validator configuration templates do not explicitly disable this setting, relying on defaults.

4. **Public Accessibility**: The service binds to `0.0.0.0` by default, making it accessible from any network interface unless firewall rules are manually configured.

## Recommendation

**Immediate Fix: Add Sanitizer Check for Mainnet Validators**

Modify the `ConfigSanitizer` implementation for `InspectionServiceConfig` to enforce that mainnet validators must have `expose_peer_information` set to `false`: [7](#0-6) 

Add the following check within the sanitizer:

```rust
// Verify that mainnet validators do not expose peer information
if let Some(chain_id) = chain_id {
    if node_type.is_validator()
        && chain_id.is_mainnet()
        && inspection_service_config.expose_peer_information
    {
        return Err(Error::ConfigSanitizerFailed(
            sanitizer_name,
            "Mainnet validators should not expose peer information!".to_string(),
        ));
    }
}
```

**Additional Hardening:**

1. **Change Default for Validators**: Modify the default to check node role and set `expose_peer_information: false` for validators
2. **Update Documentation**: Clearly document that this flag should be `false` for production validators
3. **Update Templates**: Explicitly set `expose_peer_information: false` in all validator configuration templates
4. **Consider Network Binding**: Default the inspection service to bind to `127.0.0.1` instead of `0.0.0.0` for validators, requiring explicit configuration for external access

## Proof of Concept

**Setup:**
1. Deploy a mainnet validator using the default configuration template without explicitly setting `expose_peer_information: false`
2. Ensure the inspection service port (9101) is network-accessible

**Exploit:**
```bash
# Query the peer information endpoint
curl http://validator-ip:9101/peer_information

# Response will contain:
# - Peer information summary (number of peers, network IDs, peer list)
# - Connection metadata for each peer (connection state, metadata)
# - Trusted peers (complete validator set)
# - Basic and detailed monitoring metadata
# - State sync metadata (peer scores, bucket IDs, storage summaries)
# - Internal client state

# Example output excerpt:
# Peer information summary:
#     - Number of peers: 150
#     - Registered networks: [Validator, Public]
#     - Peers and network IDs: [...]
# 
# Trusted peers (validator set & seeds):
#     - Network: Validator
#         - Peer: <peer_id>, peer information: {...}
# [... full validator set exposed ...]
```

**Verification:**
The test suite confirms the intended behavior when the flag is enabled vs disabled: [8](#0-7) 

When `expose_peer_information: true`, all sensitive data is returned with `StatusCode::OK`. The vulnerability is that this `true` state is the default for mainnet validators due to missing sanitizer checks.

## Notes

This vulnerability represents a configuration security gap where the protection applied to `expose_configuration` (preventing mainnet validators from exposing that data) was not consistently applied to other equally sensitive endpoints like `expose_peer_information`. The oversight is in the sanitizer logic which explicitly checks one flag but not the others, creating an inconsistent security posture.

The information disclosed through this endpoint is particularly valuable for attackers planning network-level attacks, as it provides complete visibility into validator network topology, connection states, and operational metadata that should remain confidential for production networks.

### Citations

**File:** crates/aptos-inspection-service/src/server/peer_information.rs (L27-35)
```rust
    let (status_code, body) = if node_config.inspection_service.expose_peer_information {
        let peer_information = get_peer_information(aptos_data_client, peers_and_metadata);
        (StatusCode::OK, Body::from(peer_information))
    } else {
        (
            StatusCode::FORBIDDEN,
            Body::from(PEER_INFO_DISABLED_MESSAGE),
        )
    };
```

**File:** crates/aptos-inspection-service/src/server/peer_information.rs (L40-106)
```rust
/// Returns a simple text formatted string with peer and network information
fn get_peer_information(
    aptos_data_client: AptosDataClient,
    peers_and_metadata: Arc<PeersAndMetadata>,
) -> String {
    // Get all registered networks
    let registered_networks: Vec<NetworkId> =
        peers_and_metadata.get_registered_networks().collect();

    // Get all peers (sorted by peer ID)
    let mut all_peers = peers_and_metadata.get_all_peers();
    all_peers.sort();

    // Display a summary of all peers and networks
    let mut peer_information_output = Vec::<String>::new();
    display_peer_information_summary(
        &mut peer_information_output,
        &all_peers,
        &registered_networks,
    );
    peer_information_output.push("\n".into());

    // Display connection metadata for each peer
    display_peer_connection_metadata(
        &mut peer_information_output,
        &all_peers,
        peers_and_metadata.deref(),
    );
    peer_information_output.push("\n".into());

    // Display the entire set of trusted peers
    display_trusted_peers(
        &mut peer_information_output,
        registered_networks,
        peers_and_metadata.deref(),
    );
    peer_information_output.push("\n".into());

    // Display basic peer metadata for each peer
    display_peer_monitoring_metadata(
        &mut peer_information_output,
        &all_peers,
        peers_and_metadata.deref(),
    );
    peer_information_output.push("\n".into());

    // Display state sync metadata for each peer
    display_state_sync_metadata(&mut peer_information_output, &all_peers, aptos_data_client);
    peer_information_output.push("\n".into());

    // Display detailed peer metadata for each peer
    display_detailed_monitoring_metadata(
        &mut peer_information_output,
        &all_peers,
        peers_and_metadata.deref(),
    );
    peer_information_output.push("\n".into());

    // Display the internal client state for each peer
    display_internal_client_state(
        &mut peer_information_output,
        &all_peers,
        peers_and_metadata.deref(),
    );

    peer_information_output.join("\n") // Separate each entry with a newline to construct the output
}
```

**File:** config/src/config/inspection_service_config.rs (L26-36)
```rust
impl Default for InspectionServiceConfig {
    fn default() -> InspectionServiceConfig {
        InspectionServiceConfig {
            address: "0.0.0.0".to_string(),
            port: 9101,
            expose_configuration: false,
            expose_identity_information: true,
            expose_peer_information: true,
            expose_system_information: true,
        }
    }
```

**File:** config/src/config/inspection_service_config.rs (L45-68)
```rust
impl ConfigSanitizer for InspectionServiceConfig {
    fn sanitize(
        node_config: &NodeConfig,
        node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();
        let inspection_service_config = &node_config.inspection_service;

        // Verify that mainnet validators do not expose the configuration
        if let Some(chain_id) = chain_id {
            if node_type.is_validator()
                && chain_id.is_mainnet()
                && inspection_service_config.expose_configuration
            {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "Mainnet validators should not expose the node configuration!".to_string(),
                ));
            }
        }

        Ok(())
    }
```

**File:** config/src/config/inspection_service_config.rs (L82-105)
```rust
        let mut modified_config = false;
        if let Some(chain_id) = chain_id {
            if !chain_id.is_mainnet() {
                if local_inspection_config_yaml["expose_configuration"].is_null() {
                    inspection_service_config.expose_configuration = true;
                    modified_config = true;
                }

                if local_inspection_config_yaml["expose_identity_information"].is_null() {
                    inspection_service_config.expose_identity_information = true;
                    modified_config = true;
                }

                if local_inspection_config_yaml["expose_peer_information"].is_null() {
                    inspection_service_config.expose_peer_information = true;
                    modified_config = true;
                }

                if local_inspection_config_yaml["expose_system_information"].is_null() {
                    inspection_service_config.expose_system_information = true;
                    modified_config = true;
                }
            }
        }
```

**File:** config/src/config/test_data/validator.yaml (L1-81)
```yaml
base:
    data_dir: "/opt/aptos/data"
    role: "validator"
    waypoint:
        from_storage:
            type: "vault"
            server: "https://127.0.0.1:8200"
            ca_certificate: "/full/path/to/certificate"
            token:
                from_disk: "/full/path/to/token"

consensus:
    safety_rules:
        service:
            type: process
            server_address: "/ip4/127.0.0.1/tcp/5555"

execution:
    genesis_file_location: "relative/path/to/genesis"

# For validator node we setup two networks, validator_network to allow validator connect to each other,
# and full_node_networks to allow fullnode connects to validator.

full_node_networks:
    - listen_address: "/ip4/0.0.0.0/tcp/6181"
      max_outbound_connections: 0
      identity:
          type: "from_storage"
          key_name: "fullnode_network"
          peer_id_name: "owner_account"
          backend:
              type: "vault"
              server: "https://127.0.0.1:8200"
              ca_certificate: "/full/path/to/certificate"
              token:
                  from_disk: "/full/path/to/token"
      network_id:
          private: "vfn"

validator_network:
    discovery_method: "onchain"
    listen_address: "/ip4/0.0.0.0/tcp/6180"
    identity:
        type: "from_storage"
        key_name: "validator_network"
        peer_id_name: "owner_account"
        backend:
            type: "vault"
            server: "https://127.0.0.1:8200"
            ca_certificate: "/full/path/to/certificate"
            token:
                from_disk: "/full/path/to/token"
    network_id: "validator"
    ### Load keys from file
    # identity:
    #     type: "from_file"
    #     path: /full/path/to/private-keys.yml
    #
    ### Load keys from secure storage service like vault:
    #
    # identity:
    #     type: "from_storage"
    #     key_name: "validator_network"
    #     peer_id_name: "owner_account"
    #     backend:
    #         type: "vault"
    #         server: "https://127.0.0.1:8200"
    #         ca_certificate: "/full/path/to/certificate"
    #         token:
    #             from_disk: "/full/path/to/token"
    #
    ### Load keys directly from config
    #
    # identity:
    #     type: "from_config"
    #     key: "b0f405a3e75516763c43a2ae1d70423699f34cd68fa9f8c6bb2d67aa87d0af69"
    #     peer_id: "00000000000000000000000000000000d58bc7bb154b38039bc9096ce04e1237"
    mutual_authentication: true
    max_frame_size: 4194304 # 4 MiB
api:
    enabled: true
```

**File:** crates/aptos-inspection-service/src/server/tests.rs (L189-215)
```rust
#[tokio::test]
async fn test_inspect_peer_information() {
    // Create a validator node config
    let mut config = NodeConfig::get_default_validator_config();

    // Disable the peer information endpoint and ping it
    config.inspection_service.expose_peer_information = false;
    let mut response = send_get_request_to_path(&config, PEER_INFORMATION_PATH).await;
    let response_body = block_on(body::to_bytes(response.body_mut())).unwrap();

    // Verify that the response contains an error
    assert_eq!(response.status(), StatusCode::FORBIDDEN);
    assert_eq!(response_body, PEER_INFO_DISABLED_MESSAGE);

    // Enable the peer information endpoint and ping it
    config.inspection_service.expose_peer_information = true;
    let mut response = send_get_request_to_path(&config, PEER_INFORMATION_PATH).await;
    let response_body = block_on(body::to_bytes(response.body_mut())).unwrap();
    let response_body_string = read_to_string(response_body.as_ref()).unwrap();

    // Verify that the response contains the expected information
    assert_eq!(response.status(), StatusCode::OK);
    assert!(response_body_string.contains("Number of peers"));
    assert!(response_body_string.contains("Registered networks"));
    assert!(response_body_string.contains("Peers and network IDs"));
    assert!(response_body_string.contains("State sync metadata"));
}
```
