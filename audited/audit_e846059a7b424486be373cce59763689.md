# Audit Report

## Title
VerifyCoordinator Performs Incomplete Transaction Verification, Potentially Accepting Invalid Blockchain State

## Summary
The `VerifyCoordinator` in the backup-cli system uses `VerifyExecutionMode::NoVerify`, which skips transaction execution verification and only validates cryptographic proofs. However, the `VERIFY_TRANSACTION_VERSION` metric is still updated, misleading operators into believing full verification occurred. This could allow acceptance of blockchain state with valid cryptographic integrity but incorrect execution results, leading to consensus splits or permanent state corruption. [1](#0-0) 

## Finding Description

The backup verification system has two coordinators with fundamentally different verification guarantees:

1. **VerifyCoordinator**: Performs only cryptographic verification (Merkle proofs, signatures) without re-executing transactions
2. **ReplayVerifyCoordinator**: Performs full verification including transaction re-execution and output comparison

The critical vulnerability lies in how `VerifyCoordinator` explicitly disables execution verification: [2](#0-1) 

This `NoVerify` mode causes the chunk executor to completely skip the `verify_execution()` method: [3](#0-2) 

When `should_verify()` returns false (which it does for `NoVerify`): [4](#0-3) 

The verification process only validates that:
- Merkle proofs are cryptographically correct
- Transaction signatures are valid  
- Ledger info signatures are valid

**What is NOT verified:**
- Transaction execution produces the expected state transitions
- Write sets match actual VM execution output
- Events match actual VM execution output
- Gas consumption is correct
- State roots are deterministically reproducible

Yet the metric indicates successful "verification": [5](#0-4) 

**Attack Scenarios:**

1. **VM Version Mismatch**: A backup created with VM version A is verified with VM version B. The crypto is valid, but execution would produce different results. VerifyCoordinator accepts it, but actual replay causes consensus divergence.

2. **Corrupted Backup with Valid Crypto**: An attacker or bug creates a backup where the cryptographic proofs are valid (signed by validators), but the transaction outputs are incorrect. The VerifyCoordinator validates it as "correct."

3. **Consensus Split During Restore**: Multiple nodes restore from the same backup verified by VerifyCoordinator. During actual replay, subtle VM differences cause different execution results, creating a permanent chain split.

The dashboard visualization exacerbates the issue: [6](#0-5) 

Operators see "Verified transaction version in backup" and believe full verification occurred, when only cryptographic validation was performed.

## Impact Explanation

**Critical Severity** - This vulnerability breaks the **Deterministic Execution** and **State Consistency** invariants:

1. **Consensus Safety Violation**: If nodes restore from backups verified with VerifyCoordinator but containing execution mismatches, they will diverge in state. Since crypto proofs are valid, both states appear legitimate, causing a consensus split requiring manual intervention or hardfork.

2. **State Corruption**: Accepting a backup with valid crypto but incorrect execution results permanently corrupts the blockchain state. All subsequent blocks build on the corrupted foundation.

3. **Misleading Security Guarantees**: The metric name `VERIFY_TRANSACTION_VERSION` and dashboard label "Verified transaction version" create a false sense of security. Operators believe backups are fully validated when they're not.

4. **Non-Recoverable Network Partition**: If multiple validator nodes independently verify and restore from the same incompletely-verified backup, and their VMs produce different execution results during actual replay, the network permanently splits. This requires a hardfork to resolve.

This directly meets Critical severity criteria from the Aptos Bug Bounty: **"Consensus/Safety violations"** and potentially **"Non-recoverable network partition (requires hardfork)"**.

## Likelihood Explanation

**HIGH LIKELIHOOD** in production environments:

1. **Documented Usage**: The VerifyCoordinator is invoked via CLI command `aptos-debugger aptos-db backup verify` and is actively used to validate backups before restoration. [7](#0-6) 

2. **Metric-Driven Operations**: Operators monitoring Grafana dashboards rely on the `aptos_db_backup_verify_transaction_version` metric to confirm backup integrity.

3. **VM Evolution**: As the AptosVM evolves (bug fixes, optimizations, new features), execution determinism across versions is not guaranteed. Backups from older versions verified with VerifyCoordinator may execute differently when replayed.

4. **Cost/Time Pressure**: ReplayVerifyCoordinator requires a full database and is significantly slower. Operators under time pressure may use the faster VerifyCoordinator, unaware of the incomplete verification.

5. **Documentation Gap**: The CLI help text says "verify the backup through restoring with the backup files" without clarifying this is crypto-only verification: [8](#0-7) 

## Recommendation

Implement a multi-layered fix:

**1. Rename and Clarify**
- Rename `VerifyCoordinator` to `VerifyCryptoCoordinator` or `QuickVerifyCoordinator`
- Rename metric from `VERIFY_TRANSACTION_VERSION` to `VERIFY_CRYPTO_TRANSACTION_VERSION`
- Update dashboard labels to "Cryptographically Verified Transaction Version"
- Add prominent warnings in CLI help text

**2. Add Execution Verification Mode**
Modify `VerifyCoordinator` to accept an optional `VerifyExecutionMode` parameter:

```rust
pub struct VerifyCoordinator {
    // ... existing fields ...
    verify_execution_mode: VerifyExecutionMode,  // NEW
}

impl VerifyCoordinator {
    pub fn new(
        // ... existing parameters ...
        verify_execution_mode: Option<VerifyExecutionMode>,  // NEW
    ) -> Result<Self> {
        Ok(Self {
            // ... existing fields ...
            verify_execution_mode: verify_execution_mode
                .unwrap_or(VerifyExecutionMode::NoVerify),  // Default for compatibility
        })
    }
    
    async fn run_impl(self) -> Result<()> {
        // ... existing code ...
        
        TransactionRestoreBatchController::new(
            global_opt,
            self.storage,
            txn_manifests,
            None,
            None,
            epoch_history,
            self.verify_execution_mode,  // CHANGED: Use configurable mode
            self.output_transaction_analysis,
        )
        .run()
        .await?;

        Ok(())
    }
}
```

**3. Add CLI Flag**
```rust
#[derive(Parser)]
pub struct VerifyOpt {
    // ... existing fields ...
    
    #[clap(
        long,
        help = "Enable full execution verification (RECOMMENDED). Without this flag, only \
                cryptographic integrity is verified, which does NOT guarantee execution \
                correctness. Use --full-verification for production backups."
    )]
    full_verification: bool,
}
```

**4. Add Safety Warnings**
Add runtime warnings when NoVerify mode is used:
```rust
if matches!(verify_execution_mode, VerifyExecutionMode::NoVerify) {
    warn!(
        "⚠️  SECURITY WARNING: Cryptographic-only verification enabled. \
         Transaction execution is NOT being verified. Use --full-verification \
         for production backups to ensure execution correctness."
    );
}
```

**5. Update Metrics**
Add separate metrics for crypto-only vs. full verification:
```rust
pub static VERIFY_CRYPTO_ONLY_TRANSACTION_VERSION: Lazy<IntGauge> = ...;
pub static VERIFY_FULL_EXECUTION_TRANSACTION_VERSION: Lazy<IntGauge> = ...;
```

## Proof of Concept

```rust
#[tokio::test]
async fn test_verify_coordinator_incomplete_verification() {
    use aptos_backup_cli::coordinators::verify::VerifyCoordinator;
    use aptos_executor_types::VerifyExecutionMode;
    use tempfile::TempDir;
    
    // Setup: Create a backup with valid crypto but modified execution results
    let backup_dir = TempDir::new().unwrap();
    let storage = create_test_backup_storage(&backup_dir);
    
    // Create a transaction backup where:
    // 1. Merkle proofs are valid
    // 2. Signatures are valid
    // 3. But transaction outputs are intentionally corrupted
    let backup = create_corrupted_but_cryptographically_valid_backup(&storage).await;
    
    // Run VerifyCoordinator (uses NoVerify internally)
    let coordinator = VerifyCoordinator::new(
        storage.clone(),
        MetadataCacheOpt::default(),
        TrustedWaypointOpt::default(),
        4, // concurrent downloads
        0, // start_version
        100, // end_version
        Version::MAX, // state_snapshot_before_version
        false, // skip_epoch_endings
        false, // validate_modules
        None, // output_transaction_analysis
    ).unwrap();
    
    // This should succeed because only crypto is checked
    let verify_result = coordinator.run().await;
    assert!(verify_result.is_ok(), "VerifyCoordinator accepted corrupted backup!");
    
    // Check that the metric was updated
    let metric_value = VERIFY_TRANSACTION_VERSION.get();
    assert_eq!(metric_value, 100, "Metric indicates 'verification' complete");
    
    // Now try ReplayVerifyCoordinator with full execution verification
    let db_dir = TempDir::new().unwrap();
    let restore_handler = create_test_restore_handler(&db_dir);
    
    let replay_coordinator = ReplayVerifyCoordinator::new(
        storage.clone(),
        MetadataCacheOpt::default(),
        TrustedWaypointOpt::default(),
        4, // concurrent downloads
        1, // replay_concurrency_level
        restore_handler,
        0, // start_version
        100, // end_version
        false, // validate_modules
        VerifyExecutionMode::verify_all(), // FULL verification
    ).unwrap();
    
    // This should FAIL because execution doesn't match
    let replay_result = replay_coordinator.run().await;
    assert!(
        matches!(replay_result, Err(ReplayError::TxnMismatch)),
        "ReplayVerifyCoordinator correctly detected execution mismatch!"
    );
    
    println!("✅ PoC demonstrates VerifyCoordinator accepts invalid state that ReplayVerifyCoordinator rejects");
}

fn create_corrupted_but_cryptographically_valid_backup(
    storage: &Arc<dyn BackupStorage>
) -> TransactionBackup {
    // Create transactions with valid signatures and proofs
    let mut backup = create_valid_transaction_backup();
    
    // Corrupt the execution results (write sets, events) 
    // while keeping crypto proofs valid
    for chunk in &mut backup.chunks {
        // Modify transaction outputs but keep merkle proofs intact
        modify_execution_outputs_preserve_crypto(chunk);
    }
    
    backup
}
```

## Notes

This vulnerability exists due to a design tradeoff between performance and security. The VerifyCoordinator was likely intended for quick validation of backup integrity (crypto only), while ReplayVerifyCoordinator provides thorough verification with execution checking. However, the lack of clear distinction in naming, metrics, and documentation creates a critical security gap where operators may unknowingly rely on incomplete verification, especially under operational pressure.

The fix must preserve backward compatibility while adding clear warnings and the option for full verification within the VerifyCoordinator itself.

### Citations

**File:** storage/backup/backup-cli/src/coordinators/verify.rs (L145-156)
```rust
        TransactionRestoreBatchController::new(
            global_opt,
            self.storage,
            txn_manifests,
            None,
            None, /* replay_from_version */
            epoch_history,
            VerifyExecutionMode::NoVerify,
            self.output_transaction_analysis,
        )
        .run()
        .await?;
```

**File:** execution/executor/src/chunk_executor/mod.rs (L562-575)
```rust
            let next_begin = if verify_execution_mode.should_verify() {
                self.verify_execution(
                    transactions,
                    persisted_aux_info,
                    transaction_infos,
                    write_sets,
                    event_vecs,
                    batch_begin,
                    batch_end,
                    verify_execution_mode,
                )?
            } else {
                batch_end
            };
```

**File:** execution/executor-types/src/lib.rs (L240-242)
```rust
    pub fn should_verify(&self) -> bool {
        !matches!(self, Self::NoVerify)
    }
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L778-778)
```rust
                VERIFY_TRANSACTION_VERSION.set(last_version as i64);
```

**File:** dashboards/storage-backup-and-restore.json (L937-938)
```json
          "title": "Verified transaction version in backup",
          "type": "bargauge"
```

**File:** storage/db-tool/src/backup.rs (L42-43)
```rust
    #[clap(about = "verify the backup through restoring with the backup files")]
    Verify(VerifyOpt),
```

**File:** storage/db-tool/src/backup.rs (L237-252)
```rust
            Command::Verify(opt) => {
                VerifyCoordinator::new(
                    opt.storage.init_storage().await?,
                    opt.metadata_cache_opt,
                    opt.trusted_waypoints_opt,
                    opt.concurrent_downloads.get(),
                    opt.start_version.unwrap_or(0),
                    opt.end_version.unwrap_or(Version::MAX),
                    opt.state_snapshot_before_version.unwrap_or(Version::MAX),
                    opt.skip_epoch_endings,
                    opt.validate_modules,
                    opt.output_transaction_analysis,
                )?
                .run()
                .await?
            },
```
