# Audit Report

## Title
Integer Overflow Denial of Service in Indexer gRPC Data Service v2

## Summary
The indexer-grpc-data-service-v2 contains an unchecked integer addition vulnerability that allows unauthenticated attackers to crash the service by sending maliciously crafted `GetTransactionsRequest` messages with overflow-inducing parameters.

## Finding Description

The security question focuses on line 86's validation check, but the actual exploitable vulnerability exists at line 125 in the same function. While the question hypothesizes a bypass scenario, the real security issue is a denial-of-service attack via integer overflow panic. [1](#0-0) 

The code performs an unchecked addition `starting_version + count` when calculating `ending_version`. Since Aptos enables `overflow-checks = true` in the release profile [2](#0-1) , this addition will panic when the sum exceeds `u64::MAX`.

**Attack Path:**
1. Attacker sends a `GetTransactionsRequest` with `starting_version = 1000` and `transactions_count = u64::MAX`
2. The validation at line 86 checks: `1000 > known_latest_version + 10000` - this evaluates to FALSE (assuming normal `known_latest_version`), so the request passes validation
3. Execution reaches line 125: `starting_version + count = 1000 + u64::MAX`
4. This overflows `u64::MAX`, triggering a panic due to enabled overflow checks
5. The indexer service crashes, denying service to all clients

The same vulnerability exists in the historical data service [3](#0-2)  which lacks the validation check entirely, making it even more vulnerable.

Notably, other components in the codebase already use safe overflow handling. The fullnode data service correctly uses `saturating_add` to prevent this exact issue [4](#0-3) .

## Impact Explanation

This qualifies as **High Severity** per the Aptos bug bounty program criteria for "API crashes" (up to $50,000). 

While the indexer-grpc-data-service-v2 is not a consensus-critical component, it is a production service that external clients depend on for transaction data streaming. A successful attack would:
- Crash the indexer service, requiring manual restart
- Deny service to all downstream consumers (wallets, explorers, analytics platforms)
- Disrupt the Aptos ecosystem's data availability infrastructure

The attack does not affect blockchain consensus, validator operation, or funds security, but it does compromise API availability.

## Likelihood Explanation

**Likelihood: High**

- **Attacker Requirements**: None. Any unauthenticated user can send gRPC requests
- **Complexity**: Trivial. Attacker only needs to construct a single malicious protobuf message
- **Cost**: Free. No transaction fees or stake required
- **Detectability**: Low. The malicious request appears syntactically valid until the overflow occurs
- **Automation**: Easily scriptable for repeated attacks

## Recommendation

Replace the unchecked addition with `saturating_add` to safely cap the value at `u64::MAX`, following the pattern already established in `fullnode_data_service.rs`.

**Fix for live_data_service/mod.rs (line 123-125):**
```rust
let ending_version = request
    .transactions_count
    .map(|count| starting_version.saturating_add(count));
```

**Fix for historical_data_service.rs (line 108-110):**
```rust
let ending_version = request
    .transactions_count
    .map(|count| starting_version.saturating_add(count));
```

Additionally, consider adding explicit validation for `transactions_count` to reject unreasonably large values before any arithmetic operations.

## Proof of Concept

```rust
#[cfg(test)]
mod overflow_poc {
    use super::*;
    use aptos_protos::indexer::v1::GetTransactionsRequest;

    #[test]
    #[should_panic(expected = "attempt to add with overflow")]
    fn test_transactions_count_overflow() {
        // This simulates the overflow that occurs at line 125
        let starting_version: u64 = 1000;
        let transactions_count: u64 = u64::MAX;
        
        // This addition will panic with overflow-checks enabled
        let _ending_version = starting_version + transactions_count;
    }

    #[test]
    fn test_saturating_add_prevents_overflow() {
        // This demonstrates the correct fix
        let starting_version: u64 = 1000;
        let transactions_count: u64 = u64::MAX;
        
        // saturating_add safely caps at u64::MAX
        let ending_version = starting_version.saturating_add(transactions_count);
        assert_eq!(ending_version, u64::MAX);
    }
}
```

To exploit in production:
```bash
# Send malicious gRPC request using grpcurl
grpcurl -d '{
  "starting_version": "1000",
  "transactions_count": "18446744073709551615"
}' \
-plaintext indexer-grpc-service:50051 \
aptos.indexer.v1.RawData/GetTransactions
```

## Notes

The question specifically asked about bypassing the validation check at line 86 by providing `starting_version` near `u64::MAX`. However, that scenario does **not** constitute a bypass - large `starting_version` values are correctly rejected by the validation.

The actual vulnerability is at line 125 where `starting_version + transactions_count` can overflow. This is exploitable because an attacker can use a **small** `starting_version` (to pass validation) combined with a **large** `transactions_count` (to trigger overflow).

With overflow-checks enabled, this results in a panic/crash (DoS), not undefined behavior. Without overflow-checks, the value would wrap, but this still doesn't create a useful bypass scenario for the attacker.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/mod.rs (L123-125)
```rust
                let ending_version = request
                    .transactions_count
                    .map(|count| starting_version + count);
```

**File:** Cargo.toml (L921-923)
```text
[profile.release]
debug = true
overflow-checks = true
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/historical_data_service.rs (L108-110)
```rust
                let ending_version = request
                    .transactions_count
                    .map(|count| starting_version + count);
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/fullnode_data_service.rs (L83-84)
```rust
        let ending_version = if let Some(count) = r.transactions_count {
            starting_version.saturating_add(count)
```
