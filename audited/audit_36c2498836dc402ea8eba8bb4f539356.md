# Audit Report

## Title
Missing Visitor Implementations for Signed Integer Vectors Cause Inconsistent Gas Calculation

## Summary
The `abstract_stack_size` function in `misc.rs` is missing visitor method implementations for signed integer vector types (`visit_vec_i8`, `visit_vec_i16`, `visit_vec_i32`, `visit_vec_i64`, `visit_vec_i128`, `visit_vec_i256`), causing inconsistent gas calculation behavior compared to unsigned integer vectors and potentially enabling gas-related exploits.

## Finding Description

The `abstract_stack_size` function implements a visitor pattern to calculate the abstract stack size of Move values for gas metering purposes. This function is critical for memory tracking during pack, unpack, and closure operations. [1](#0-0) 

The Visitor implementation provides overrides for unsigned integer vector methods (`visit_vec_u8`, `visit_vec_u16`, `visit_vec_u32`, `visit_vec_u64`, `visit_vec_u128`, `visit_vec_u256`), which include special logic based on `feature_version`: [2](#0-1) 

However, the implementation is **missing overrides for signed integer vectors** (`visit_vec_i8`, `visit_vec_i16`, `visit_vec_i32`, `visit_vec_i64`, `visit_vec_i128`, `visit_vec_i256`), which were introduced in RELEASE_V1_38: [3](#0-2) 

When these methods are not overridden, the default trait implementations are used, which behave differently: [4](#0-3) 

The default implementations:
1. Call `visit_vec` which sets `res` to the vector container size
2. Then iterate through elements, calling `visit_i8`, `visit_i16`, etc., which **overwrite** `res` with the element primitive size

This causes the stack size for signed integer vectors to be calculated as the **element size** rather than the **container size**, which is inconsistent with unsigned integer vectors where special feature-version logic applies.

The function is used in critical gas metering paths: [5](#0-4) [6](#0-5) [7](#0-6) 

**Regarding the invariant violation**: The error message "Visitor should have set the `res` value" would be triggered if:
1. A new Move value type is added to the VM without corresponding visitor method implementations
2. A ValueView implementation returns Ok() without calling any visitor methods
3. Future refactoring introduces code paths that bypass visitor method calls

The current missing implementations don't cause invariant violations (res IS set, just to the wrong value), but they represent the **same class of bug** - incomplete visitor implementations leading to incorrect gas calculation.

## Impact Explanation

**Medium Severity** - This vulnerability affects gas metering correctness and system determinism:

1. **Incorrect Gas Calculation**: Operations involving signed integer vectors (pack, unpack, closure creation) calculate incorrect stack sizes, leading to under-charging or over-charging gas fees

2. **Consensus Divergence Risk**: If different validators have different feature versions or handle the inconsistency differently, they may calculate different gas amounts for identical transactions, potentially causing consensus failures

3. **Economic Exploit**: Attackers could craft transactions with large signed integer vectors to exploit under-charged gas, enabling resource exhaustion attacks

4. **Deterministic Execution Violation**: The inconsistent behavior between signed and unsigned integer vectors violates the deterministic execution invariant - identical operations should have identical gas costs

## Likelihood Explanation

**High Likelihood**:
- Signed integer types are production features (RELEASE_V1_38+)
- Any Move code using `vector<i8>`, `vector<i16>`, `vector<i32>`, `vector<i64>`, `vector<i128>`, or `vector<i256>` triggers the issue
- The missing implementations are systematic (all 6 signed vector types)
- The same pattern exists in `abstract_packed_size` function, suggesting a systematic oversight when signed integers were added [8](#0-7) 

## Recommendation

Add the missing visitor method implementations for signed integer vector types in both `abstract_stack_size` and `abstract_packed_size` functions. The implementations should match the pattern used for unsigned integer vectors:

```rust
// In abstract_stack_size Visitor implementation (around line 717)
#[inline]
fn visit_vec_i8(&mut self, depth: u64, vals: &[i8]) -> PartialVMResult<()> {
    if self.feature_version < 3 {
        self.res = Some(0.into());
    } else {
        self.visit_vec(depth, vals.len())?;
    }
    Ok(())
}

#[inline]
fn visit_vec_i16(&mut self, depth: u64, vals: &[i16]) -> PartialVMResult<()> {
    self.visit_vec(depth, vals.len())?;
    Ok(())
}

// Similarly for visit_vec_i32, visit_vec_i64, visit_vec_i128, visit_vec_i256
```

The same additions should be made to the `abstract_packed_size` function's Visitor implementation to ensure consistent behavior across all gas calculation paths.

## Proof of Concept

Create a Move module that uses signed integer vectors and observe inconsistent gas behavior:

```move
module 0x1::test_signed_vectors {
    public fun pack_i8_vector(): vector<i8> {
        vector[1i8, 2i8, 3i8, 4i8, 5i8]
    }
    
    public fun pack_u8_vector(): vector<u8> {
        vector[1u8, 2u8, 3u8, 4u8, 5u8]
    }
    
    public entry fun test_pack_operations() {
        let _v1 = pack_i8_vector(); // Uses incorrect default implementation
        let _v2 = pack_u8_vector(); // Uses correct overridden implementation
        // Gas charged will be inconsistent between these identical operations
    }
}
```

The gas calculation for packing the i8 vector will use the default trait implementation (calculating element size), while the u8 vector will use the overridden implementation (calculating container size based on feature_version), causing inconsistent gas charges for structurally identical operations.

To verify in Rust tests:
1. Create a `vector<i8>` value
2. Call `abstract_stack_size` with different feature versions
3. Compare with equivalent `vector<u8>` behavior
4. Observe the inconsistency where i8 vector always returns element size while u8 vector behavior depends on feature_version

## Notes

This issue represents an incomplete implementation when signed integer types were added in RELEASE_V1_38. The TODO comment at line 645 ("necessary due to a bug upstream") suggests awareness of similar issues with specialized vector methods, but the signed integer variants were not included in the fix. This affects both `abstract_stack_size` and `abstract_packed_size` functions, indicating a systematic gap in the visitor pattern implementation for the newer signed integer types.

### Citations

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/misc.rs (L39-62)
```rust
        [i8: AbstractValueSize, { RELEASE_V1_38.. => "i8" }, 40],
        [i16: AbstractValueSize, { RELEASE_V1_38.. => "i16" }, 40],
        [i32: AbstractValueSize, { RELEASE_V1_38.. => "i32" }, 40],
        [i64: AbstractValueSize, { RELEASE_V1_38.. => "i64" }, 40],
        [i128: AbstractValueSize, { RELEASE_V1_38.. => "i128" }, 40],
        [i256: AbstractValueSize, { RELEASE_V1_38.. => "i256" }, 40],
        [bool: AbstractValueSize, "bool", 40],
        [address: AbstractValueSize, "address", 40],
        [struct_: AbstractValueSize, "struct", 40],
        [closure: AbstractValueSize, { RELEASE_V1_33.. => "closure" }, 40],
        [vector: AbstractValueSize, "vector", 40],
        [reference: AbstractValueSize, "reference", 40],
        [per_u8_packed: AbstractValueSizePerArg, "per_u8_packed", 1],
        [per_u16_packed: AbstractValueSizePerArg, { 5.. => "per_u16_packed" }, 2],
        [per_u32_packed: AbstractValueSizePerArg, { 5.. => "per_u32_packed" }, 4],
        [per_u64_packed: AbstractValueSizePerArg, "per_u64_packed", 8],
        [per_u128_packed: AbstractValueSizePerArg, "per_u128_packed", 16],
        [per_u256_packed: AbstractValueSizePerArg, { 5.. => "per_u256_packed" }, 32],
        [per_i8_packed: AbstractValueSizePerArg, { RELEASE_V1_38.. => "per_i8_packed" }, 1],
        [per_i16_packed: AbstractValueSizePerArg, { RELEASE_V1_38.. => "per_i16_packed" }, 2],
        [per_i32_packed: AbstractValueSizePerArg, { RELEASE_V1_38.. => "per_i32_packed" }, 4],
        [per_i64_packed: AbstractValueSizePerArg, { RELEASE_V1_38.. => "per_i64_packed" }, 8],
        [per_i128_packed: AbstractValueSizePerArg, { RELEASE_V1_38.. => "per_i128_packed" }, 16],
        [per_i256_packed: AbstractValueSizePerArg, { RELEASE_V1_38.. => "per_i256_packed" }, 32],
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/misc.rs (L495-730)
```rust
    pub fn abstract_stack_size(
        &self,
        val: impl ValueView,
        feature_version: u64,
    ) -> PartialVMResult<AbstractValueSize> {
        struct Visitor<'a> {
            feature_version: u64,
            params: &'a AbstractValueSizeGasParameters,
            res: Option<AbstractValueSize>,
            max_value_nest_depth: Option<u64>,
        }

        impl Visitor<'_> {
            check_depth_impl!();
        }

        impl ValueVisitor for Visitor<'_> {
            #[inline]
            fn visit_delayed(&mut self, depth: u64, _val: DelayedFieldID) -> PartialVMResult<()> {
                self.check_depth(depth)?;
                self.res = Some(self.params.u64);
                Ok(())
            }

            #[inline]
            fn visit_u8(&mut self, depth: u64, _val: u8) -> PartialVMResult<()> {
                self.check_depth(depth)?;
                self.res = Some(self.params.u8);
                Ok(())
            }

            #[inline]
            fn visit_u16(&mut self, depth: u64, _val: u16) -> PartialVMResult<()> {
                self.check_depth(depth)?;
                self.res = Some(self.params.u16);
                Ok(())
            }

            #[inline]
            fn visit_u32(&mut self, depth: u64, _val: u32) -> PartialVMResult<()> {
                self.check_depth(depth)?;
                self.res = Some(self.params.u32);
                Ok(())
            }

            #[inline]
            fn visit_u64(&mut self, depth: u64, _val: u64) -> PartialVMResult<()> {
                self.check_depth(depth)?;
                self.res = Some(self.params.u64);
                Ok(())
            }

            #[inline]
            fn visit_u128(&mut self, depth: u64, _val: u128) -> PartialVMResult<()> {
                self.check_depth(depth)?;
                self.res = Some(self.params.u128);
                Ok(())
            }

            #[inline]
            fn visit_u256(&mut self, depth: u64, _val: &U256) -> PartialVMResult<()> {
                self.check_depth(depth)?;
                self.res = Some(self.params.u256);
                Ok(())
            }

            #[inline]
            fn visit_i8(&mut self, depth: u64, _val: i8) -> PartialVMResult<()> {
                self.check_depth(depth)?;
                self.res = Some(self.params.i8);
                Ok(())
            }

            #[inline]
            fn visit_i16(&mut self, depth: u64, _val: i16) -> PartialVMResult<()> {
                self.check_depth(depth)?;
                self.res = Some(self.params.i16);
                Ok(())
            }

            #[inline]
            fn visit_i32(&mut self, depth: u64, _val: i32) -> PartialVMResult<()> {
                self.check_depth(depth)?;
                self.res = Some(self.params.i32);
                Ok(())
            }

            #[inline]
            fn visit_i64(&mut self, depth: u64, _val: i64) -> PartialVMResult<()> {
                self.check_depth(depth)?;
                self.res = Some(self.params.i64);
                Ok(())
            }

            #[inline]
            fn visit_i128(&mut self, depth: u64, _val: i128) -> PartialVMResult<()> {
                self.check_depth(depth)?;
                self.res = Some(self.params.i128);
                Ok(())
            }

            #[inline]
            fn visit_i256(&mut self, depth: u64, _val: &I256) -> PartialVMResult<()> {
                self.check_depth(depth)?;
                self.res = Some(self.params.i256);
                Ok(())
            }

            #[inline]
            fn visit_bool(&mut self, depth: u64, _val: bool) -> PartialVMResult<()> {
                self.check_depth(depth)?;
                self.res = Some(self.params.bool);
                Ok(())
            }

            #[inline]
            fn visit_address(&mut self, depth: u64, _val: &AccountAddress) -> PartialVMResult<()> {
                self.check_depth(depth)?;
                self.res = Some(self.params.address);
                Ok(())
            }

            #[inline]
            fn visit_struct(&mut self, depth: u64, _len: usize) -> PartialVMResult<bool> {
                self.check_depth(depth)?;
                self.res = Some(self.params.struct_);
                Ok(false)
            }

            #[inline]
            fn visit_closure(&mut self, depth: u64, _len: usize) -> PartialVMResult<bool> {
                self.check_depth(depth)?;
                self.res = Some(self.params.closure);
                Ok(false)
            }

            #[inline]
            fn visit_vec(&mut self, depth: u64, _len: usize) -> PartialVMResult<bool> {
                self.check_depth(depth)?;
                self.res = Some(self.params.vector);
                Ok(false)
            }

            #[inline]
            fn visit_ref(&mut self, depth: u64, _is_global: bool) -> PartialVMResult<bool> {
                self.check_depth(depth)?;
                self.res = Some(self.params.reference);
                Ok(false)
            }

            // TODO(Gas): The following function impls are necessary due to a bug upstream.
            //            Remove them once the bug is fixed.
            #[inline]
            fn visit_vec_u8(&mut self, depth: u64, vals: &[u8]) -> PartialVMResult<()> {
                if self.feature_version < 3 {
                    self.res = Some(0.into());
                } else {
                    self.visit_vec(depth, vals.len())?;
                }
                Ok(())
            }

            #[inline]
            fn visit_vec_u16(&mut self, depth: u64, vals: &[u16]) -> PartialVMResult<()> {
                self.visit_vec(depth, vals.len())?;
                Ok(())
            }

            #[inline]
            fn visit_vec_u32(&mut self, depth: u64, vals: &[u32]) -> PartialVMResult<()> {
                self.visit_vec(depth, vals.len())?;
                Ok(())
            }

            #[inline]
            fn visit_vec_u64(&mut self, depth: u64, vals: &[u64]) -> PartialVMResult<()> {
                if self.feature_version < 3 {
                    self.res = Some(0.into());
                } else {
                    self.visit_vec(depth, vals.len())?;
                }
                Ok(())
            }

            #[inline]
            fn visit_vec_u128(&mut self, depth: u64, vals: &[u128]) -> PartialVMResult<()> {
                if self.feature_version < 3 {
                    self.res = Some(0.into());
                } else {
                    self.visit_vec(depth, vals.len())?;
                }
                Ok(())
            }

            #[inline]
            fn visit_vec_u256(&mut self, depth: u64, vals: &[U256]) -> PartialVMResult<()> {
                self.visit_vec(depth, vals.len())?;
                Ok(())
            }

            #[inline]
            fn visit_vec_bool(&mut self, depth: u64, vals: &[bool]) -> PartialVMResult<()> {
                if self.feature_version < 3 {
                    self.res = Some(0.into());
                } else {
                    self.visit_vec(depth, vals.len())?;
                }
                Ok(())
            }

            #[inline]
            fn visit_vec_address(
                &mut self,
                depth: u64,
                vals: &[AccountAddress],
            ) -> PartialVMResult<()> {
                if self.feature_version < 3 {
                    self.res = Some(0.into());
                } else {
                    self.visit_vec(depth, vals.len())?;
                }
                Ok(())
            }
        }

        let mut visitor = Visitor {
            feature_version,
            params: self,
            res: None,
            max_value_nest_depth: Some(DEFAULT_MAX_VM_VALUE_NESTED_DEPTH),
        };
        val.visit(&mut visitor)?;
        visitor.res.ok_or_else(|| {
            PartialVMError::new_invariant_violation("Visitor should have set the `res` value")
        })
    }
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/misc.rs (L879-930)
```rust
            // TODO(Gas): The following function impls are necessary due to a bug upstream.
            //            Remove them once the bug is fixed.
            #[inline]
            fn visit_vec_u8(&mut self, depth: u64, vals: &[u8]) -> PartialVMResult<()> {
                self.visit_vec(depth, vals.len())?;
                Ok(())
            }

            #[inline]
            fn visit_vec_u16(&mut self, depth: u64, vals: &[u16]) -> PartialVMResult<()> {
                self.visit_vec(depth, vals.len())?;
                Ok(())
            }

            #[inline]
            fn visit_vec_u32(&mut self, depth: u64, vals: &[u32]) -> PartialVMResult<()> {
                self.visit_vec(depth, vals.len())?;
                Ok(())
            }

            #[inline]
            fn visit_vec_u64(&mut self, depth: u64, vals: &[u64]) -> PartialVMResult<()> {
                self.visit_vec(depth, vals.len())?;
                Ok(())
            }

            #[inline]
            fn visit_vec_u128(&mut self, depth: u64, vals: &[u128]) -> PartialVMResult<()> {
                self.visit_vec(depth, vals.len())?;
                Ok(())
            }

            fn visit_vec_u256(&mut self, depth: u64, vals: &[U256]) -> PartialVMResult<()> {
                self.visit_vec(depth, vals.len())?;
                Ok(())
            }

            #[inline]
            fn visit_vec_bool(&mut self, depth: u64, vals: &[bool]) -> PartialVMResult<()> {
                self.visit_vec(depth, vals.len())?;
                Ok(())
            }

            #[inline]
            fn visit_vec_address(
                &mut self,
                depth: u64,
                vals: &[AccountAddress],
            ) -> PartialVMResult<()> {
                self.visit_vec(depth, vals.len())?;
                Ok(())
            }
```

**File:** third_party/move/move-vm/types/src/views.rs (L294-343)
```rust
    fn visit_vec_i8(&mut self, depth: u64, vals: &[i8]) -> PartialVMResult<()> {
        self.visit_vec(depth, vals.len())?;
        for val in vals {
            self.visit_i8(depth + 1, *val)?;
        }
        Ok(())
    }

    fn visit_vec_i16(&mut self, depth: u64, vals: &[i16]) -> PartialVMResult<()> {
        self.visit_vec(depth, vals.len())?;
        for val in vals {
            self.visit_i16(depth + 1, *val)?;
        }
        Ok(())
    }

    fn visit_vec_i32(&mut self, depth: u64, vals: &[i32]) -> PartialVMResult<()> {
        self.visit_vec(depth, vals.len())?;
        for val in vals {
            self.visit_i32(depth + 1, *val)?;
        }
        Ok(())
    }

    fn visit_vec_i64(&mut self, depth: u64, vals: &[i64]) -> PartialVMResult<()> {
        self.visit_vec(depth, vals.len())?;
        for val in vals {
            self.visit_i64(depth + 1, *val)?;
        }
        Ok(())
    }

    fn visit_vec_i128(&mut self, depth: u64, vals: &[i128]) -> PartialVMResult<()> {
        self.visit_vec(depth, vals.len())?;
        for val in vals {
            self.visit_i128(depth + 1, *val)?;
        }
        Ok(())
    }

    fn visit_vec_i256(
        &mut self,
        depth: u64,
        vals: &[move_core_types::int256::I256],
    ) -> PartialVMResult<()> {
        self.visit_vec(depth, vals.len())?;
        for val in vals {
            self.visit_i256(depth + 1, val)?;
        }
        Ok(())
```

**File:** aptos-move/aptos-memory-usage-tracker/src/lib.rs (L439-457)
```rust
    fn charge_pack(
        &mut self,
        is_generic: bool,
        args: impl ExactSizeIterator<Item = impl ValueView> + Clone,
    ) -> PartialVMResult<()> {
        self.use_heap_memory(
            args.clone()
                .try_fold(AbstractValueSize::zero(), |acc, val| {
                    let stack_size = self
                        .vm_gas_params()
                        .misc
                        .abs_val
                        .abstract_stack_size(val, self.feature_version())?;
                    Ok::<_, PartialVMError>(acc + stack_size)
                })?,
        )?;

        self.base.charge_pack(is_generic, args)
    }
```

**File:** aptos-move/aptos-memory-usage-tracker/src/lib.rs (L460-478)
```rust
    fn charge_unpack(
        &mut self,
        is_generic: bool,
        args: impl ExactSizeIterator<Item = impl ValueView> + Clone,
    ) -> PartialVMResult<()> {
        self.release_heap_memory(args.clone().try_fold(
            AbstractValueSize::zero(),
            |acc, val| {
                let stack_size = self
                    .vm_gas_params()
                    .misc
                    .abs_val
                    .abstract_stack_size(val, self.feature_version())?;
                Ok::<_, PartialVMError>(acc + stack_size)
            },
        )?);

        self.base.charge_unpack(is_generic, args)
    }
```

**File:** aptos-move/aptos-memory-usage-tracker/src/lib.rs (L481-499)
```rust
    fn charge_pack_closure(
        &mut self,
        is_generic: bool,
        args: impl ExactSizeIterator<Item = impl ValueView> + Clone,
    ) -> PartialVMResult<()> {
        self.use_heap_memory(
            args.clone()
                .try_fold(AbstractValueSize::zero(), |acc, val| {
                    let stack_size = self
                        .vm_gas_params()
                        .misc
                        .abs_val
                        .abstract_stack_size(val, self.feature_version())?;
                    Ok::<_, PartialVMError>(acc + stack_size)
                })?,
        )?;

        self.base.charge_pack_closure(is_generic, args)
    }
```
