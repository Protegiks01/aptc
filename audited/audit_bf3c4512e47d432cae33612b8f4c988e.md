# Audit Report

## Title
DKG Transcript Verification Panic Enables Validator DoS via Unbounded Witness Size

## Summary
A malicious dealer can craft a DKG transcript with an oversized `chunked_plaintexts` vector in the Sigma protocol proof, causing validators to panic during verification when the witness size exceeds the pre-configured MSM basis length. This enables targeted denial-of-service attacks against validators during distributed key generation.

## Finding Description

The vulnerability exists in the DKG transcript verification flow where a projection function in `LiftHomomorphism::msm_terms()` transforms untrusted proof data without size validation, ultimately triggering a panic in the underlying cryptographic commitment verification.

**Attack Path:**

1. A malicious dealer creates a DKG transcript containing a `SharingProof` with a crafted Sigma protocol proof (`SoK` field) [1](#0-0) 

2. The proof's `z` field (prover response) contains a `HkzgWeightedElgamalWitness` with an excessively large `chunked_plaintexts` vector (e.g., millions of nested elements) [2](#0-1) 

3. The transcript is deserialized successfully via BCS, with no size bounds checking on the witness data [3](#0-2) 

4. During verification, `Transcript::verify()` is called, which invokes sigma protocol verification [4](#0-3) 

5. The verification flow calls `msm_terms(&proof.z)` on the untrusted witness [5](#0-4) 

6. This reaches `LiftHomomorphism::msm_terms()` which calls the projection function to transform the witness [6](#0-5) 

7. The projection flattens `chunked_plaintexts` into a `values` vector without bounds checking [7](#0-6) 

8. The flattened witness is passed to `CommitmentHomomorphism::msm_terms()`, which **panics** when `input.values.len()` exceeds the fixed `msm_basis.len()` [8](#0-7) 

9. The panic crashes the validator node processing the DKG result transaction

**Root Cause:** The assertion assumes trusted input, but `proof.z` comes from an untrusted dealer. The `msm_basis` length is bounded by public parameters (determined by `max_num_shares`), while an attacker can create arbitrarily large `chunked_plaintexts` vectors that deserialize successfully.

## Impact Explanation

**Severity: HIGH** (up to $50,000 per Aptos Bug Bounty)

This vulnerability enables:
- **Validator Node Crashes**: Any validator processing the malicious transcript will panic and terminate
- **DKG Disruption**: If enough validators crash when processing the same malicious transcript, the DKG ceremony fails
- **Network Liveness Issues**: Repeated crashes during epoch transitions can delay or prevent validator set updates
- **Resource Limits Violation**: Breaks the documented invariant that "All operations must respect gas, storage, and computational limits"

The impact is High rather than Critical because:
- Does not directly cause fund loss or consensus safety violations
- Requires malicious dealer participation (though any validator can be a dealer)
- Affects availability rather than integrity
- Validators can restart and continue (though vulnerability persists)

However, this is a significant protocol violation that can severely degrade network availability during critical DKG phases.

## Likelihood Explanation

**Likelihood: HIGH**

This vulnerability is highly likely to be exploited because:
- **Low Barrier**: Any validator selected as a DKG dealer can craft the malicious transcript
- **No Authentication Required**: The attack occurs during deserialization/verification before signature validation could reject it
- **Deterministic Trigger**: The panic is guaranteed when `values.len() > msm_basis.len()`
- **No Input Validation**: There are no size checks on `chunked_plaintexts` before the panic [9](#0-8) 

The attack is trivial to execute: simply create a `HkzgWeightedElgamalWitness` with `chunked_plaintexts` containing more total elements than `msm_basis.len()` (typically a few thousand), which can be easily exceeded by adding nested vectors.

## Recommendation

Add explicit size validation in `Transcript::verify()` before calling `hom.verify()`:

```rust
// In weighted_transcript.rs, after line 153, add:
let expected_total_chunks = sc.get_total_weight() * num_chunks_per_scalar::<E::ScalarField>(pp.ell) as usize;

// Validate SoK witness size before verification
if let FirstProofItem::Commitment(_) = &self.sharing_proof.SoK.first_proof_item {
    let total_chunks: usize = self.sharing_proof.SoK.z.chunked_plaintexts
        .iter()
        .map(|player_chunks| player_chunks.iter().map(|chunk| chunk.len()).sum::<usize>())
        .sum();
    
    if total_chunks != expected_total_chunks {
        bail!(
            "Invalid SoK witness size: expected {} chunks, got {}",
            expected_total_chunks,
            total_chunks
        );
    }
}
```

Additionally, consider replacing the `assert!` with a graceful error return: [8](#0-7) 

Replace with:
```rust
if self.msm_basis.len() < input.values.len() {
    return Err(anyhow::anyhow!(
        "Not enough Lagrange basis elements for univariate hiding KZG: required {}, got {}",
        input.values.len(),
        self.msm_basis.len()
    ));
}
```

## Proof of Concept

```rust
// PoC demonstrating the vulnerability
// This would be added as a test in weighted_transcript.rs

#[test]
#[should_panic(expected = "Not enough Lagrange basis elements")]
fn test_oversized_witness_causes_panic() {
    use crate::pvss::chunky::hkzg_chunked_elgamal::HkzgWeightedElgamalWitness;
    use aptos_crypto::weighted_config::WeightedConfigArkworks;
    
    // Setup normal DKG parameters
    let mut rng = thread_rng();
    let pp = PublicParameters::<Bls12_381>::new(10, 16, 1, &mut rng); // 10 shares max
    let sc = WeightedConfigArkworks::new(/* normal config */);
    
    // Create a valid transcript
    let mut transcript = Transcript::generate(/* ... */);
    
    // Craft malicious SoK with oversized chunked_plaintexts
    // msm_basis.len() is bounded by max_num_chunks_padded (from public params)
    // We'll exceed this by creating an excessively large chunked_plaintexts
    let malicious_witness = HkzgWeightedElgamalWitness {
        hkzg_randomness: CommitmentRandomness::rand(&mut rng),
        // Create 1000 players × 100 chunks × 100 scalars = 10M scalars
        // This will far exceed the msm_basis capacity (~few thousand)
        chunked_plaintexts: vec![
            vec![vec![Scalar::rand(&mut rng); 100]; 100]; 
            1000
        ],
        elgamal_randomness: vec![vec![Scalar::rand(&mut rng); 10]; 100],
    };
    
    // Replace the SoK's z field with malicious witness
    transcript.sharing_proof.SoK.z = malicious_witness;
    
    // Attempt verification - this will panic!
    let result = transcript.verify(&sc, &pp, &spks, &eks, &sid);
    // Validator node crashes here with panic from univariate_hiding_kzg.rs:352
}
```

## Notes

The vulnerability specifically affects the DKG transcript verification path during validator transactions. The panic occurs in `CommitmentHomomorphism::msm_terms()` which uses an `assert!` macro assuming the input has already been validated. However, the `LiftHomomorphism` wrapper allows untrusted data to flow through the projection function without size validation, bypassing the implicit assumption that witness sizes match the public parameters.

This is a defense-in-depth failure where multiple layers (deserialization, early validation, projection function) all assume someone else is validating the input size, but none actually do so before reaching the assertion.

### Citations

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcript.rs (L133-153)
```rust
        if eks.len() != sc.get_total_num_players() {
            bail!(
                "Expected {} encryption keys, but got {}",
                sc.get_total_num_players(),
                eks.len()
            );
        }
        if self.subtrs.Cs.len() != sc.get_total_num_players() {
            bail!(
                "Expected {} arrays of chunked ciphertexts, but got {}",
                sc.get_total_num_players(),
                self.subtrs.Cs.len()
            );
        }
        if self.subtrs.Vs.len() != sc.get_total_num_players() {
            bail!(
                "Expected {} arrays of commitment elements, but got {}",
                sc.get_total_num_players(),
                self.subtrs.Vs.len()
            );
        }
```

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcript.rs (L178-190)
```rust
            if let Err(err) = hom.verify(
                &TupleCodomainShape(
                    self.sharing_proof.range_proof_commitment.clone(),
                    chunked_elgamal::WeightedCodomainShape {
                        chunks: self.subtrs.Cs.clone(),
                        randomness: self.subtrs.Rs.clone(),
                    },
                ),
                &self.sharing_proof.SoK,
                &sok_cntxt,
            ) {
                bail!("PoK verification failed: {:?}", err);
            }
```

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcript.rs (L420-432)
```rust
#[derive(CanonicalSerialize, CanonicalDeserialize, Clone, Debug, PartialEq, Eq)]
pub struct SharingProof<E: Pairing> {
    /// SoK: the SK is knowledge of `witnesses` s_{i,j} yielding the commitment and the C and the R, their image is the PK, and the signed message is a certain context `cntxt`
    pub SoK: sigma_protocol::Proof<
        E::ScalarField,
        hkzg_chunked_elgamal::WeightedHomomorphism<'static, E>,
    >, // static because we don't want the lifetime of the Proof to depend on the Homomorphism TODO: try removing it?
    /// A batched range proof showing that all committed values s_{i,j} lie in some range
    pub range_proof: dekart_univariate_v2::Proof<E>,
    /// A KZG-style commitment to the values s_{i,j} going into the range proof
    pub range_proof_commitment:
        <dekart_univariate_v2::Proof<E> as BatchedRangeProof<E>>::Commitment,
}
```

**File:** crates/aptos-dkg/src/pvss/chunky/hkzg_chunked_elgamal.rs (L44-51)
```rust
#[derive(
    SigmaProtocolWitness, CanonicalSerialize, CanonicalDeserialize, Debug, Clone, PartialEq, Eq,
)]
pub struct HkzgWeightedElgamalWitness<F: PrimeField> {
    pub hkzg_randomness: univariate_hiding_kzg::CommitmentRandomness<F>,
    pub chunked_plaintexts: Vec<Vec<Vec<Scalar<F>>>>, // For each player, plaintexts z_i, which are chunked z_{i,j}
    pub elgamal_randomness: Vec<Vec<Scalar<F>>>, // For at most max_weight, for each chunk, a blinding factor
}
```

**File:** crates/aptos-dkg/src/pvss/chunky/hkzg_chunked_elgamal.rs (L204-218)
```rust
            projection: |dom: &HkzgWeightedElgamalWitness<E::ScalarField>| {
                let HkzgWeightedElgamalWitness {
                    hkzg_randomness,
                    chunked_plaintexts,
                    ..
                } = dom;
                let flattened_chunked_plaintexts: Vec<Scalar<E::ScalarField>> =
                    std::iter::once(Scalar(E::ScalarField::ZERO))
                        .chain(chunked_plaintexts.iter().flatten().flatten().cloned())
                        .collect();
                univariate_hiding_kzg::Witness::<E::ScalarField> {
                    hiding_randomness: hkzg_randomness.clone(),
                    values: flattened_chunked_plaintexts,
                }
            },
```

**File:** aptos-move/aptos-vm/src/validator_txns/dkg.rs (L106-109)
```rust
        let transcript = bcs::from_bytes::<<DefaultDKG as DKGTrait>::Transcript>(
            dkg_node.transcript_bytes.as_slice(),
        )
        .map_err(|_| Expected(TranscriptDeserializationFailed))?;
```

**File:** crates/aptos-dkg/src/sigma_protocol/traits.rs (L124-124)
```rust
        let msm_terms_for_prover_response = self.msm_terms(&proof.z);
```

**File:** crates/aptos-dkg/src/sigma_protocol/homomorphism/fixed_base_msms.rs (L111-113)
```rust
    fn msm_terms(&self, input: &Self::Domain) -> Self::CodomainShape<Self::MsmInput> {
        let projected = (self.projection)(input);
        self.hom.msm_terms(&projected)
```

**File:** crates/aptos-dkg/src/pcs/univariate_hiding_kzg.rs (L352-357)
```rust
        assert!(
            self.msm_basis.len() >= input.values.len(),
            "Not enough Lagrange basis elements for univariate hiding KZG: required {}, got {}",
            input.values.len(),
            self.msm_basis.len()
        );
```
