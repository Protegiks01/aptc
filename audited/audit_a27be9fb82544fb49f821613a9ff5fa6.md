# Audit Report

## Title
Permanent Fund Loss via Transfers to Reserved Address 0x0

## Summary
Transfers to the reserved VM address `0x0` result in permanent and irrecoverable fund loss when the `default_account_resource` feature flag is enabled. The transfer mechanism creates a primary fungible store for address `0x0` without validation, allowing funds to be deposited to an address that cannot be controlled by any private key.

## Finding Description

The vulnerability exists in the interaction between account existence checks and object creation validation.

Address `0x0` is the reserved VM address `@vm_reserved`, verified by the system addresses module [1](#0-0) . Account creation explicitly prevents creating accounts at reserved addresses including `0x0` [2](#0-1)  and [3](#0-2) .

However, when the `default_account_resource` feature is enabled, the `exists_at()` function returns `true` for ALL addresses [4](#0-3) . This behavior is formally specified [5](#0-4) .

This causes the transfer function to skip account creation validation when transferring to `0x0` [6](#0-5) . The transfer proceeds through the fungible asset path [7](#0-6) , which creates a primary fungible store by calling the object creation framework [8](#0-7) .

The critical flaw is in `create_object_internal()`, which accepts any `creator_address` parameter without validation and sets it as the object owner [9](#0-8) . Once funds are deposited to this store, they become permanently inaccessible because no private key exists for address `0x0`, account creation at `0x0` is explicitly blocked, and no system recovery mechanism exists.

## Impact Explanation

This vulnerability qualifies as **Medium Severity** under Aptos bug bounty criteria for "Limited funds loss or manipulation."

The impact is limited to individual transactions where users accidentally specify `0x0` as the recipient. Each affected transaction results in complete and permanent loss of transferred funds with no possibility of recovery without protocol-level intervention. The funds are not stolen by an attacker but are effectively burned in an unintended manner. Notably, `0x0` is not designated as the official burn address [10](#0-9) , making this an unintended loss mechanism.

## Likelihood Explanation

The likelihood is **Medium** because:

1. **User error required**: The vulnerability requires a user to explicitly specify `0x0` as the recipient, which is not a common operation but can occur through null address bugs in client applications, copy-paste errors, script bugs with uninitialized variables, or testing code accidentally used in production.

2. **Feature flags enabled by default**: Both required feature flags are enabled in the default configuration [11](#0-10)  and [12](#0-11) .

3. **Silent failure**: The transaction succeeds without error, providing no warning to users that their funds are permanently lost.

## Recommendation

Add explicit validation in the transfer path to reject transfers to reserved addresses when creating primary fungible stores. Specifically:

1. Add a check in `create_object_internal()` or `create_user_derived_object()` to reject reserved addresses (`@vm_reserved`, `@aptos_framework`, `@aptos_token`) as owner addresses.

2. Alternatively, add validation in `create_primary_store()` before calling object creation functions to ensure the owner address is not a reserved address.

3. Add explicit error messages that warn users when attempting to transfer to reserved addresses.

## Proof of Concept

```move
#[test(sender = @0xcafe, framework = @0x1)]
fun test_transfer_to_vm_reserved_loses_funds(sender: signer, framework: signer) {
    // Setup: Initialize APT and fund sender account
    let (burn_cap, mint_cap) = aptos_coin::initialize_for_test(&framework);
    aptos_account::create_account(signer::address_of(&sender));
    coin::deposit(signer::address_of(&sender), coin::mint(1000, &mint_cap));
    
    // Execute: Transfer to 0x0
    aptos_account::transfer(&sender, @0x0, 500);
    
    // Verify: Funds are lost - no way to recover from 0x0
    // The primary fungible store exists at 0x0 with 500 APT
    // But no private key exists to access it
    assert!(coin::balance<AptosCoin>(signer::address_of(&sender)) == 500, 0);
    // Funds are effectively burned with no recovery mechanism
    
    coin::destroy_burn_cap(burn_cap);
    coin::destroy_mint_cap(mint_cap);
}
```

### Citations

**File:** aptos-move/framework/aptos-framework/sources/system_addresses.move (L74-76)
```text
    public fun is_vm_address(addr: address): bool {
        addr == @vm_reserved
    }
```

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L278-281)
```text
            assert!(
                account_address != @vm_reserved && account_address != @aptos_framework && account_address != @aptos_token,
                error::invalid_argument(ECANNOT_RESERVED_ADDRESS)
            );
```

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L293-296)
```text
        assert!(
            new_address != @vm_reserved && new_address != @aptos_framework && new_address != @aptos_token,
            error::invalid_argument(ECANNOT_RESERVED_ADDRESS)
        );
```

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L348-350)
```text
    public fun exists_at(addr: address): bool {
        features::is_default_account_resource_enabled() || exists<Account>(addr)
    }
```

**File:** aptos-move/framework/aptos-framework/sources/account/account.spec.move (L162-166)
```text
    spec fun spec_exists_at(addr: address): bool {
        use std::features;
        use std::features::DEFAULT_ACCOUNT_RESOURCE;
        features::spec_is_enabled(DEFAULT_ACCOUNT_RESOURCE) || exists<Account>(addr)
    }
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_account.move (L82-85)
```text
    public entry fun transfer(source: &signer, to: address, amount: u64) {
        if (!account::exists_at(to)) {
            create_account(to)
        };
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_account.move (L286-304)
```text
    public(friend) entry fun fungible_transfer_only(
        source: &signer, to: address, amount: u64
    ) {
        let sender_store =
            ensure_primary_fungible_store_exists(signer::address_of(source));
        let recipient_store = ensure_primary_fungible_store_exists(to);

        // use internal APIs, as they skip:
        // - owner, frozen and dispatchable checks
        // as APT cannot be frozen or have dispatch, and PFS cannot be transfered
        // (PFS could potentially be burned. regular transfer would permanently unburn the store.
        // Ignoring the check here has the equivalent of unburning, transfers, and then burning again)
        fungible_asset::withdraw_permission_check_by_address(
            source, sender_store, amount
        );
        fungible_asset::unchecked_deposit(
            recipient_store, fungible_asset::unchecked_withdraw(sender_store, amount)
        );
    }
```

**File:** aptos-move/framework/aptos-framework/sources/primary_fungible_store.move (L75-88)
```text
    public fun create_primary_store<T: key>(
        owner_addr: address,
        metadata: Object<T>,
    ): Object<FungibleStore> acquires DeriveRefPod {
        let metadata_addr = metadata.object_address();
        object::address_to_object<Metadata>(metadata_addr);
        let derive_ref = &borrow_global<DeriveRefPod>(metadata_addr).metadata_derive_ref;
        let constructor_ref = &object::create_user_derived_object(owner_addr, derive_ref);
        // Disable ungated transfer as deterministic stores shouldn't be transferrable.
        let transfer_ref = &constructor_ref.generate_transfer_ref();
        transfer_ref.disable_ungated_transfer();

        fungible_asset::create_store(constructor_ref, metadata)
    }
```

**File:** aptos-move/framework/aptos-framework/sources/object.move (L93-94)
```text
    /// Address where unwanted objects can be forcefully transferred to.
    const BURN_ADDRESS: address = @0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;
```

**File:** aptos-move/framework/aptos-framework/sources/object.move (L318-339)
```text
    fun create_object_internal(
        creator_address: address,
        object: address,
        can_delete: bool,
    ): ConstructorRef {
        assert!(!exists<ObjectCore>(object), error::already_exists(EOBJECT_EXISTS));

        let object_signer = create_signer(object);
        let guid_creation_num = INIT_GUID_CREATION_NUM;
        let transfer_events_guid = guid::create(object, &mut guid_creation_num);

        move_to(
            &object_signer,
            ObjectCore {
                guid_creation_num,
                owner: creator_address,
                allow_ungated_transfer: true,
                transfer_events: event::new_event_handle(transfer_events_guid),
            },
        );
        ConstructorRef { self: object, can_delete }
    }
```

**File:** types/src/on_chain_config/aptos_features.rs (L235-235)
```rust
            FeatureFlag::OPERATIONS_DEFAULT_TO_FA_APT_STORE,
```

**File:** types/src/on_chain_config/aptos_features.rs (L260-260)
```rust
            FeatureFlag::DEFAULT_ACCOUNT_RESOURCE,
```
