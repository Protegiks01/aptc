# Audit Report

## Title
Rosetta API Stake Balance Double-Counting Vulnerability Leading to Accounting Inconsistencies

## Summary
The Rosetta API's `get_stake_balances()` function contains an accounting inconsistency where the sum of individually queried stake component balances does not equal the reported total stake balance. Specifically, `pending_active` stake is double-counted: once within the "active stake" calculation and again as a separate "pending_active stake" component, resulting in a discrepancy equal to the `pending_active` amount.

## Finding Description
The vulnerability exists in the stake balance calculation logic within the Rosetta API implementation. The issue stems from conflicting semantic interpretations of "active stake" between the staking contract module and the stake pool module. [1](#0-0) 

The function calls `staking_contract_amounts()` which returns `total_active_stake` defined as `active + pending_active` in the staking contract logic: [2](#0-1) 

The commission is calculated based on this combined `total_active_stake`. However, when returning individual balance components, the Rosetta API uses this commission-adjusted value for "active stake" while also exposing `pending_active` as a separate balance: [3](#0-2) 

This creates the following inconsistency:
- **Active stake balance** (line 347): `(active + pending_active) - commission`
- **Pending active balance** (line 350): `pending_active` 
- **Inactive balance** (line 353): `inactive`
- **Pending inactive balance** (line 356): `pending_inactive`
- **Total stake balance** (line 360): `(active + inactive + pending_active + pending_inactive) - commission`

When external systems sum the individual components (lines 347, 350, 353, 356), they get:
`(active + pending_active - commission) + pending_active + inactive + pending_inactive = active + 2*pending_active + inactive + pending_inactive - commission`

But the total stake query (line 360) returns:
`active + inactive + pending_active + pending_inactive - commission`

**The difference is exactly `pending_active`**, which is counted twice in the individual component sum.

Notably, the developers have acknowledged this issue exists: [4](#0-3) 

## Impact Explanation
This vulnerability qualifies as **Medium Severity** under the Aptos Bug Bounty program criteria for "State inconsistencies requiring intervention."

The impact includes:
1. **External Integration Errors**: Exchanges, wallets, and block explorers using the Rosetta API will display incorrect total balances when summing individual stake components
2. **Failed Reconciliation**: Automated accounting systems will detect mismatches between component sums and reported totals, triggering alerts or blocking operations
3. **User Confusion**: Users checking multiple balance types will observe that the mathematics don't reconcile, eroding trust in the platform
4. **Potential Financial Errors**: Systems that rely on component balance sums for decision-making (e.g., withdrawal limits, collateral calculations) may operate on inflated balance figures

While this doesn't directly manipulate on-chain state or steal funds from the blockchain, it violates a fundamental accounting invariant: the sum of parts must equal the whole. For financial systems, this type of inconsistency can lead to serious operational issues and loss of user trust.

## Likelihood Explanation
**Likelihood: High**

This vulnerability affects every query to the Rosetta API for staking contract balances where:
1. A staking contract exists between a staker and operator
2. The stake pool has non-zero `pending_active` balance
3. External systems query multiple balance types and sum them

The Rosetta API is specifically designed for external integrators (exchanges, custodians, analytics platforms), making widespread exposure likely. The issue is deterministic and will occur for any integration that follows the standard pattern of querying individual balance components.

## Recommendation
Correct the "active stake" balance calculation to exclude `pending_active` since it's reported separately. The active stake balance should represent only the actual active component:

**Option 1: Return only `active` portion (excluding `pending_active`)**
```rust
if owner_account.is_active_stake() {
    // Return only the active component, adjusted for commission
    // Commission should be proportionally applied only to the active portion
    let active_only = stake_pool.active;
    let commission_on_active = commission_amount * active_only / total_active_stake;
    requested_balance = Some((active_only - commission_on_active).to_string());
}
```

**Option 2: Merge active and pending_active into single balance type**
Alternatively, eliminate the separate `pending_active` query option and only expose combined "active" (which includes pending_active) or clearly document the overlap.

**Option 3: Adjust total stake calculation**
If the intent is for "active stake" to include `pending_active`, then the total stake calculation should not subtract the full commission:
```rust
if owner_account.is_total_stake() {
    // Total should match sum of individually reported components
    // Commission was already subtracted from active stake, don't subtract again
    let active_with_commission_removed = total_active_stake - commission_amount;
    let total = active_with_commission_removed + stake_pool.inactive + stake_pool.pending_inactive;
    requested_balance = Some(total.to_string());
}
```

The most semantically correct fix is **Option 1**, as it maintains clear separation between the four stake pool states.

## Proof of Concept
```rust
#[tokio::test]
async fn test_stake_balance_inconsistency() {
    // Setup: Create a stake pool with the following balances
    // active = 1000, pending_active = 200, inactive = 300, pending_inactive = 100
    // principal = 1000, commission_percentage = 10%
    
    let rest_client = setup_test_client().await;
    let owner_account = AccountIdentifier::new_with_active_stake(staker_address);
    let pool_address = create_test_pool(1000, 200, 300, 100).await;
    
    // Commission calculation:
    // total_active_stake = 1000 + 200 = 1200
    // accumulated_rewards = 1200 - 1000 = 200
    // commission = 200 * 10 / 100 = 20
    
    // Query individual components
    let active_balance = get_stake_balances(
        &rest_client, 
        &AccountIdentifier::new_with_active_stake(staker_address),
        pool_address,
        version
    ).await.unwrap().unwrap().balance.unwrap().value.parse::<u64>().unwrap();
    // Expected: (1000 + 200) - 20 = 1180
    
    let pending_active_balance = get_stake_balances(
        &rest_client,
        &AccountIdentifier::new_with_pending_active_stake(staker_address),
        pool_address,
        version
    ).await.unwrap().unwrap().balance.unwrap().value.parse::<u64>().unwrap();
    // Expected: 200
    
    let inactive_balance = get_stake_balances(
        &rest_client,
        &AccountIdentifier::new_with_inactive_stake(staker_address),
        pool_address,
        version
    ).await.unwrap().unwrap().balance.unwrap().value.parse::<u64>().unwrap();
    // Expected: 300
    
    let pending_inactive_balance = get_stake_balances(
        &rest_client,
        &AccountIdentifier::new_with_pending_inactive_stake(staker_address),
        pool_address,
        version
    ).await.unwrap().unwrap().balance.unwrap().value.parse::<u64>().unwrap();
    // Expected: 100
    
    let total_balance = get_stake_balances(
        &rest_client,
        &AccountIdentifier::new_with_total_stake(staker_address),
        pool_address,
        version
    ).await.unwrap().unwrap().balance.unwrap().value.parse::<u64>().unwrap();
    // Expected: 1600 - 20 = 1580
    
    let sum_of_components = active_balance + pending_active_balance + 
                           inactive_balance + pending_inactive_balance;
    // Actual sum: 1180 + 200 + 300 + 100 = 1780
    
    assert_eq!(sum_of_components, total_balance, 
        "Sum of components ({}) should equal total balance ({}), but differs by {}",
        sum_of_components, total_balance, sum_of_components - total_balance);
    
    // This assertion will FAIL, exposing the vulnerability
    // Difference: 1780 - 1580 = 200 = pending_active amount
}
```

## Notes
The developers have already identified this issue via a TODO comment in the source code, but it remains unresolved. The vulnerability primarily affects external systems integrating with Aptos via the Rosetta API rather than on-chain consensus or state. However, given the critical role of the Rosetta API in exchange integrations and the severity of accounting inconsistencies in financial systems, this qualifies as a Medium severity vulnerability requiring prompt remediation.

### Citations

**File:** crates/aptos-rosetta/src/types/misc.rs (L325-340)
```rust
        let staking_contract_amounts_response = view::<Vec<u64>>(
            rest_client,
            version,
            AccountAddress::ONE,
            ident_str!(STAKING_CONTRACT_MODULE),
            ident_str!("staking_contract_amounts"),
            vec![],
            vec![
                bcs::to_bytes(&owner_address)?,
                bcs::to_bytes(&operator_address)?,
            ],
        )
        .await?;
        let total_active_stake = staking_contract_amounts_response[0];
        let accumulated_rewards = staking_contract_amounts_response[1];
        let commission_amount = staking_contract_amounts_response[2];
```

**File:** crates/aptos-rosetta/src/types/misc.rs (L342-344)
```rust
        // TODO: I think all of these are off, probably need to recalculate all of them
        // see the get_staking_contract_amounts_internal function in staking_contract.move for more
        // information on why commission is only subtracted from active and total stake
```

**File:** crates/aptos-rosetta/src/types/misc.rs (L345-365)
```rust
        if owner_account.is_active_stake() {
            // active stake is principal and rewards (including commission) so subtract the commission
            requested_balance = Some((total_active_stake - commission_amount).to_string());
        } else if owner_account.is_pending_active_stake() {
            // pending_active cannot have commission because it is new principal
            requested_balance = Some(stake_pool.pending_active.to_string());
        } else if owner_account.is_inactive_stake() {
            // inactive will not have commission because commission has already been extracted
            requested_balance = Some(stake_pool.inactive.to_string());
        } else if owner_account.is_pending_inactive_stake() {
            // pending_inactive will not have commission because commission has already been extracted
            requested_balance = Some(stake_pool.pending_inactive.to_string());
        } else if owner_account.is_total_stake() {
            // total stake includes commission since it includes active stake, which includes commission
            requested_balance =
                Some((stake_pool.get_total_staked_amount() - commission_amount).to_string());
        } else if owner_account.is_commission() {
            requested_balance = Some(commission_amount.to_string());
        } else if owner_account.is_rewards() {
            requested_balance = Some(accumulated_rewards.to_string());
        }
```

**File:** aptos-move/framework/aptos-framework/sources/staking_contract.move (L1057-1072)
```text
    fun get_staking_contract_amounts_internal(
        staking_contract: &StakingContract
    ): (u64, u64, u64) {
        // Pending_inactive is not included in the calculation because pending_inactive can only come from:
        // 1. Outgoing commissions. This means commission has already been extracted.
        // 2. Stake withdrawals from stakers. This also means commission has already been extracted as
        // request_commission_internal is called in unlock_stake
        let (active, _, pending_active, _) =
            stake::get_stake(staking_contract.pool_address);
        let total_active_stake = active + pending_active;
        let accumulated_rewards = total_active_stake - staking_contract.principal;
        let commission_amount =
            accumulated_rewards * staking_contract.commission_percentage / 100;

        (total_active_stake, accumulated_rewards, commission_amount)
    }
```
