# Audit Report

## Title
Validator Node Crash via Aggregator Deletion Race in Parallel Execution Path

## Summary
A critical divergence between sequential and parallel aggregator materialization paths allows an attacker to crash validator nodes by exploiting a race condition between aggregator deletion and delta application. The parallel execution path panics when materializing deltas for deleted aggregators, while the sequential path correctly returns a speculative execution error.

## Finding Description

The Aptos BlockSTM parallel executor has two distinct code paths for materializing aggregator V1 deltas:

**Sequential/VM Path:** Uses `try_convert_aggregator_v1_delta_into_write_op()` which properly handles deleted aggregators by returning `SPECULATIVE_EXECUTION_ABORT_ERROR` when the base value is None. [1](#0-0) 

**Parallel Executor Path:** Uses `materialize_aggregator_v1_delta_writes()` which panics when the base value is None (deleted aggregator). [2](#0-1) 

The vulnerability arises because:

1. Aggregator delta operations (`add()`/`sub()`) do not require reading the base value during execution - they only accumulate deltas without creating read dependencies: [3](#0-2) 

2. When an aggregator is destroyed via `remove_aggregator()`, it's removed from the aggregators map immediately: [4](#0-3) 

3. During parallel commit, if the MVHashMap cannot resolve the delta (returns `Err`), the code falls back to reading from storage and expects the value to exist. When `from_state_value(None)` creates a deletion WriteOp, calling `.as_u128()` returns `Ok(None)`, and the subsequent `.expect("Aggregator base value must exist")` panics: [5](#0-4) 

**Attack Scenario:**
- Transaction A deletes aggregator X and commits
- Transaction B applies deltas to aggregator X without explicitly reading its value (no `read_and_materialize()` call)
- B executes in parallel with no read dependency on X's base value
- B passes validation (no conflicting reads detected)
- During B's commit phase (`materialize_txn_commit`), the system attempts to materialize B's deltas
- Storage returns None (X was deleted by A)
- Node panics at line 1105 and crashes

## Impact Explanation

**Critical Severity** - This qualifies as a validator node crash vulnerability, which falls under the "Remote Code Execution on validator node" category (effectively making the node unavailable). 

The attack causes:
- **Deterministic Execution Violation**: Different validators may crash depending on transaction ordering and parallel execution timing, leading to consensus inconsistencies
- **Validator Availability Loss**: Affected nodes crash and must restart, reducing network security and liveness
- **Network Partition Risk**: If enough validators crash simultaneously, the network could lose consensus

This meets the Critical severity criteria: "Total loss of liveness/network availability" and breaks the core invariant that "All validators must produce identical state roots for identical blocks" since some validators crash while others may not.

## Likelihood Explanation

**High Likelihood** - This attack is practical because:

1. **No special privileges required**: Any transaction sender can create transactions that delete aggregators and apply deltas
2. **Natural occurrence**: Aggregator deletions are legitimate operations; attackers simply need to craft transactions that apply deltas without explicit reads
3. **Parallel execution amplifies risk**: BlockSTM's parallel execution model makes race conditions more likely
4. **No validation prevents this**: The validation logic doesn't detect missing read dependencies for delta operations that never read the base value

The attack complexity is low - an attacker needs only to:
- Deploy a Move module with aggregator operations
- Submit Transaction A to destroy an aggregator
- Submit Transaction B to apply deltas to the same aggregator without reading it
- Wait for parallel execution to trigger the panic

## Recommendation

**Fix the parallel execution path to match the sequential path behavior:**

Modify `materialize_aggregator_v1_delta_writes()` to handle deleted aggregators gracefully instead of panicking. Replace the storage read fallback with proper error handling:

```rust
let committed_delta = versioned_cache
    .data()
    .materialize_delta(&k, txn_idx)
    .unwrap_or_else(|op| {
        let storage_value = base_view
            .get_state_value(&k)
            .expect("Error reading the base value for committed delta in storage");

        let w: T::Value = TransactionWrite::from_state_value(storage_value);
        
        // FIX: Check if aggregator was deleted instead of panicking
        let value_u128 = match w.as_u128() {
            Ok(Some(v)) => v,
            Ok(None) => {
                // Aggregator was deleted - this transaction must be re-executed
                // Return a sentinel value or trigger re-validation
                panic!("SPECULATIVE_EXECUTION_ABORT: Aggregator base value deleted");
            },
            Err(e) => panic!("Aggregator base value deserialization error: {:?}", e),
        };

        versioned_cache.data().set_base_value(
            k.clone(),
            ValueWithLayout::RawFromStorage(TriompheArc::new(w)),
        );
        op.apply_to(value_u128)
            .expect("Materializing delta w. base value set must succeed")
    });
```

**Better solution:** Ensure aggregator delta operations always create read dependencies on the base value, or refactor the materialization path to use the same code for both sequential and parallel execution.

## Proof of Concept

```rust
// Rust test case demonstrating the vulnerability
#[test]
#[should_panic(expected = "Aggregator base value must exist")]
fn test_deleted_aggregator_panic() {
    // Setup: Create an aggregator in storage
    let mut state = setup_test_state();
    let aggregator_key = create_test_aggregator(&mut state, 1000);
    
    // Transaction A: Delete the aggregator
    let txn_a = Transaction::delete_aggregator(aggregator_key.clone());
    execute_and_commit(&mut state, txn_a);
    
    // Transaction B: Apply delta to deleted aggregator (without reading)
    let txn_b = Transaction::add_to_aggregator(aggregator_key.clone(), 100);
    
    // Execute B in parallel mode
    // B accumulates deltas without reading base value
    let output_b = execute_transaction_parallel(&state, txn_b);
    
    // During commit, materialize_aggregator_v1_delta_writes is called
    // This will panic at line 1105 when it finds the base value is None
    materialize_and_commit(&mut state, output_b); // PANICS HERE
}
```

The test demonstrates that when parallel execution attempts to materialize deltas for a deleted aggregator, the node crashes with a panic instead of gracefully handling the speculative execution error.

### Citations

**File:** aptos-move/aptos-aggregator/src/resolver.rs (L85-88)
```rust
        let base = self.get_aggregator_v1_value(id)?.ok_or_else(|| {
            PartialVMError::new(StatusCode::SPECULATIVE_EXECUTION_ABORT_ERROR)
                .with_message("Cannot convert delta for deleted aggregator".to_string())
        })?;
```

**File:** aptos-move/block-executor/src/executor.rs (L1097-1105)
```rust
                        let storage_value = base_view
                            .get_state_value(&k)
                            .expect("Error reading the base value for committed delta in storage");

                        let w: T::Value = TransactionWrite::from_state_value(storage_value);
                        let value_u128 = w
                            .as_u128()
                            .expect("Aggregator base value deserialization error")
                            .expect("Aggregator base value must exist");
```

**File:** aptos-move/aptos-aggregator/src/aggregator_v1_extension.rs (L128-163)
```rust
    pub fn add(&mut self, value: u128) -> PartialVMResult<()> {
        let math = BoundedMath::new(self.max_value);
        match self.state {
            AggregatorState::Data => {
                // If aggregator knows the value, add directly and keep the state.
                self.value = math
                    .unsigned_add(self.value, value)
                    .map_err(addition_v1_error)?;
                return Ok(());
            },
            AggregatorState::PositiveDelta => {
                // If positive delta, add directly but also record the state.
                self.value = math
                    .unsigned_add(self.value, value)
                    .map_err(addition_v1_error)?;
            },
            AggregatorState::NegativeDelta => {
                // Negative delta is a special case, since the state might
                // change depending on how big the `value` is. Suppose
                // aggregator has -X and want to do +Y. Then, there are two
                // cases:
                //     1. X <= Y: then the result is +(Y-X)
                //     2. X  > Y: then the result is -(X-Y)
                if self.value <= value {
                    self.value = expect_ok(math.unsigned_subtract(value, self.value))?;
                    self.state = AggregatorState::PositiveDelta;
                } else {
                    self.value = expect_ok(math.unsigned_subtract(self.value, value))?;
                }
            },
        }

        // Record side-effects of addition in history.
        self.record();
        Ok(())
    }
```

**File:** aptos-move/aptos-aggregator/src/aggregator_v1_extension.rs (L333-345)
```rust
    pub fn remove_aggregator(&mut self, id: AggregatorID) {
        // Aggregator no longer in use during this transaction: remove it.
        self.aggregators.remove(&id);

        if self.new_aggregators.contains(&id) {
            // Aggregator has been created in the same transaction. Therefore, no
            // side-effects.
            self.new_aggregators.remove(&id);
        } else {
            // Otherwise, aggregator has been created somewhere else.
            self.destroyed_aggregators.insert(id);
        }
    }
```

**File:** types/src/write_set.rs (L444-449)
```rust
    fn from_state_value(maybe_state_value: Option<StateValue>) -> Self {
        match maybe_state_value {
            None => Self::legacy_deletion(),
            Some(state_value) => Self(BaseStateOp::Modification(state_value)),
        }
    }
```
