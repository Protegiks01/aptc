# Audit Report

## Title
Consensus Divergence Due to Unimplemented get_usage() in RemoteStateViewClient

## Summary
The `RemoteStateViewClient` used in remote sharded execution has an unimplemented `get_usage()` method that panics, while `CachedStateView` used in local execution implements it properly. Since every block's prologue transaction calls this method via the native function `state_storage::get_state_storage_usage_only_at_epoch_beginning()`, validators configured for remote execution will panic on every block, causing consensus divergence.

## Finding Description

The sharded block executor supports two execution modes based on configuration:
- **Local execution**: Uses `LocalExecutorClient` with `CachedStateView`
- **Remote execution**: Uses `RemoteExecutorClient` with `RemoteStateViewClient` [1](#0-0) 

The architectural difference creates a critical vulnerability:

**Local Execution Path:**
1. `ExecutorShardCommand` contains `Arc<CachedStateView>` directly [2](#0-1) 

2. `CachedStateView` implements `StateStorageView::get_usage()` properly via the blanket implementation [3](#0-2) 

**Remote Execution Path:**
1. Commands are serialized without the state view [4](#0-3) 

2. Remote shards create `ExecutorShardCommand` with `Arc<RemoteStateViewClient>` instead [5](#0-4) 

3. **Critical Issue**: `RemoteStateViewClient::get_usage()` is unimplemented and panics [6](#0-5) 

**The Trigger:**
Every block's prologue transaction calls `block::block_prologue_common()` which invokes: [7](#0-6) 

This calls `state_storage::on_new_block()`: [8](#0-7) 

Which calls the native function `get_state_storage_usage_only_at_epoch_beginning()`: [9](#0-8) 

The native implementation calls `ctx.resolver.get_usage()`: [10](#0-9) 

**Result:** Validators using remote execution panic on every block's prologue, while validators using local execution succeed, breaking the **Deterministic Execution** invariant.

## Impact Explanation

This is a **Critical Severity** vulnerability:

1. **Consensus Safety Violation**: Different validators produce different execution results (panic vs success) for identical blocks, violating consensus safety guarantees.

2. **Network Partition**: Validators are split into two groups based on configuration:
   - Validators with remote execution enabled: Crash on every block
   - Validators with local execution: Continue normally
   
3. **Non-recoverable without Hardfork**: The divergence occurs at the protocol level in mandatory system transactions (block prologue), requiring a hardfork to fix.

4. **Total Loss of Liveness** for affected validators: Remote execution validators cannot process any blocks.

This meets the Critical Severity criteria: "Consensus/Safety violations" and "Non-recoverable network partition (requires hardfork)".

## Likelihood Explanation

**Likelihood: Medium to High** depending on deployment:

- The vulnerability triggers **automatically** on every block for any validator configured with remote execution
- No attacker action required - this is a configuration-dependent deterministic bug
- The feature exists in production code with configuration flags [11](#0-10) 

- If any validator enables remote execution in production (via `set_remote_addresses()`), they will diverge from the network immediately

The only reason this might not be actively exploited is if remote execution is not yet enabled in production. However, the code path is production-ready and could be activated.

## Recommendation

Implement `get_usage()` for `RemoteStateViewClient` by fetching the usage from the coordinator's state view service, similar to how state values are fetched:

```rust
// In remote_state_view.rs
impl TStateView for RemoteStateViewClient {
    // ... existing methods ...
    
    fn get_usage(&self) -> StateViewResult<StateStorageUsage> {
        // Send request to coordinator's state view service
        // and wait for response, similar to get_state_value()
        // For now, delegate to the coordinator's state view
        todo!("Implement remote get_usage() via coordinator state view service")
    }
}
```

Alternatively, add a new message type to the remote protocol:

1. Add `GetUsageRequest` and `GetUsageResponse` message types
2. Implement handler in `RemoteStateViewService` to fetch usage from the underlying state view
3. Implement `RemoteStateViewClient::get_usage()` to send request and await response

**Immediate Mitigation**: Add validation to prevent remote execution from being enabled until this is fixed, or document that remote execution is experimental and should not be used in production.

## Proof of Concept

**Rust Reproduction Steps:**

1. Configure a validator with remote execution enabled:
```rust
// In validator configuration
use aptos_executor_service::remote_executor_client::{set_remote_addresses, set_coordinator_address};

set_coordinator_address(coordinator_addr);
set_remote_addresses(vec![shard_addr_1, shard_addr_2]);
```

2. Process any block with the block prologue transaction

3. **Expected Result**: 
   - Local execution validators: Block processes successfully
   - Remote execution validators: Panic with `unimplemented!("get_usage is not implemented for RemoteStateView")`

**Move Test to Verify:**

While the issue is in Rust code, we can create a Move test that calls the native function:

```move
#[test(framework = @aptos_framework)]
fun test_state_storage_usage_called_in_prologue(framework: &signer) {
    use aptos_framework::state_storage;
    
    // This would fail if RemoteStateViewClient is used
    state_storage::initialize(framework);
    state_storage::on_new_block(1);
    // If we reach here without panic, local execution works
}
```

The vulnerability is triggered not by Move code but by the execution infrastructure configuration.

**Notes**

This vulnerability demonstrates a subtle but critical issue with the BCS serialization/remote execution architecture: the `Arc<StateView>` is intentionally not serialized (as it cannot be), but the replacement `RemoteStateViewClient` on the remote side is not a complete implementation of the `StateView` trait. This creates an execution divergence between local and remote paths.

The question specifically asked about "Arc pointer values causing functional differences" - while the Arc pointer itself isn't the issue, the *replacement* of the Arc-wrapped state view with a different implementation that has missing functionality is exactly the kind of subtle difference that causes consensus divergence.

### Citations

**File:** execution/executor/src/workflow/do_get_execution_output.rs (L261-267)
```rust
        if !get_remote_addresses().is_empty() {
            Ok(V::execute_block_sharded(
                &REMOTE_SHARDED_BLOCK_EXECUTOR.lock(),
                partitioned_txns,
                state_view,
                onchain_config,
            )?)
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/local_executor_shard.rs (L193-200)
```rust
            self.command_txs[i]
                .send(ExecutorShardCommand::ExecuteSubBlocks(
                    state_view.clone(),
                    sub_blocks_for_shard,
                    concurrency_level_per_shard,
                    onchain_config.clone(),
                ))
                .unwrap();
```

**File:** aptos-move/aptos-vm-types/src/resolver.rs (L252-270)
```rust
impl<S> StateStorageView for S
where
    S: StateView,
{
    type Key = StateKey;

    fn id(&self) -> StateViewId {
        self.id()
    }

    fn read_state_value(&self, state_key: &Self::Key) -> Result<(), StateViewError> {
        self.get_state_value(state_key)?;
        Ok(())
    }

    fn get_usage(&self) -> Result<StateStorageUsage, StateViewError> {
        self.get_usage()
    }
}
```

**File:** execution/executor-service/src/remote_executor_client.rs (L35-44)
```rust
pub fn set_remote_addresses(addresses: Vec<SocketAddr>) {
    REMOTE_ADDRESSES.set(addresses).ok();
}

pub fn get_remote_addresses() -> Vec<SocketAddr> {
    match REMOTE_ADDRESSES.get() {
        Some(value) => value.clone(),
        None => vec![],
    }
}
```

**File:** execution/executor-service/src/remote_executor_client.rs (L195-205)
```rust
            let execution_request = RemoteExecutionRequest::ExecuteBlock(ExecuteBlockCommand {
                sub_blocks,
                concurrency_level: concurrency_level_per_shard,
                onchain_config: onchain_config.clone(),
            });

            senders[shard_id]
                .lock()
                .unwrap()
                .send(Message::new(bcs::to_bytes(&execution_request).unwrap()))
                .unwrap();
```

**File:** execution/executor-service/src/remote_cordinator_client.rs (L101-107)
```rust
                        let (sub_blocks, concurrency, onchain_config) = command.into();
                        ExecutorShardCommand::ExecuteSubBlocks(
                            self.state_view_client.clone(),
                            sub_blocks,
                            concurrency,
                            onchain_config,
                        )
```

**File:** execution/executor-service/src/remote_state_view.rs (L206-209)
```rust
    fn get_usage(&self) -> StateViewResult<StateStorageUsage> {
        unimplemented!("get_usage is not implemented for RemoteStateView")
    }
}
```

**File:** aptos-move/framework/aptos-framework/sources/block.move (L196-196)
```text
        state_storage::on_new_block(reconfiguration::current_epoch());
```

**File:** aptos-move/framework/aptos-framework/sources/state_storage.move (L39-49)
```text
    public(friend) fun on_new_block(epoch: u64) acquires StateStorageUsage {
        assert!(
            exists<StateStorageUsage>(@aptos_framework),
            error::not_found(ESTATE_STORAGE_USAGE)
        );
        let usage = borrow_global_mut<StateStorageUsage>(@aptos_framework);
        if (epoch != usage.epoch) {
            usage.epoch = epoch;
            usage.usage = get_state_storage_usage_only_at_epoch_beginning();
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/state_storage.move (L64-64)
```text
    native fun get_state_storage_usage_only_at_epoch_beginning(): Usage;
```

**File:** aptos-move/framework/src/natives/state_storage.rs (L69-73)
```rust
    let ctx = context.extensions().get::<NativeStateStorageContext>();
    let usage = ctx.resolver.get_usage().map_err(|err| {
        PartialVMError::new(StatusCode::VM_EXTENSION_ERROR)
            .with_message(format!("Failed to get state storage usage: {}", err))
    })?;
```
