# Audit Report

## Title
State Value Storage Leak Due to Incorrect Version Key in Truncation Logic

## Summary
A critical bug in the crash recovery truncation logic causes state values to be permanently leaked in the database. When rolling back uncommitted state after a crash, the system successfully deletes stale index entries but fails to delete the corresponding state values due to using an incorrect version key, creating orphaned state values that accumulate over time.

## Finding Description
The vulnerability exists in the `delete_state_value_and_index` function which is called during crash recovery to truncate uncommitted state. The Aptos storage system uses a two-part architecture:

1. **State values** stored at key `(state_key_hash, version)` where `version` is when the value was written [1](#0-0) 
2. **Stale indices** that track which state values can be pruned, containing `stale_since_version`, `version`, and `state_key_hash` fields [2](#0-1) 

During crash recovery, `sync_commit_progress` is called during StateStore initialization to synchronize commit progress across database components [3](#0-2) . When inconsistencies are detected, it calls `truncate_state_kv_db` [4](#0-3) , which eventually invokes `delete_state_value_and_index`.

**The Critical Bug:**

In the truncation logic, when deleting state values in sharded mode, the code incorrectly uses `index.stale_since_version` as the version key: [5](#0-4) 

The same bug exists in the non-sharded path: [6](#0-5) 

However, state values are stored at `(state_key_hash, version)` where `version` is the version when the value was written, NOT `stale_since_version`. The correct implementation can be seen in the pruning logic, which properly uses `index.version`: [7](#0-6) 

**How Stale Indices Work:**

When a state value is updated, a stale index is created where `stale_since_version` equals the current version and `version` equals the old value's version [8](#0-7) . This allows the system to track that the old value at `(state_key_hash, old_version)` became stale at the current version.

**Attack Path:**
1. At version 100, state value written and stored at key `(hash, 100)`
2. At version 200, value updated: stale index created with `stale_since_version=200, version=100`
3. Node crashes after version 200 commits but before overall progress marker updates
4. On restart, truncation attempts to delete:
   - Index: ✓ Successfully deleted
   - State value: ✗ Tries to delete at `(hash, 200)` but value is at `(hash, 100)`
5. Result: State value at `(hash, 100)` orphaned without index
6. Pruner can never find it since it only iterates through indices [9](#0-8) 

## Impact Explanation
This vulnerability qualifies as **High Severity** under the Aptos bug bounty program:

**Validator Node Slowdowns**: Accumulated storage bloat from repeated crash/recovery cycles progressively degrades validator performance. Each crash leaks orphaned state values that cannot be pruned. Over time, this causes:
- Slower disk I/O operations as database size grows
- More expensive RocksDB compaction
- Reduced memory cache effectiveness
- Degraded query performance

**State Consistency Violation**: The system violates its storage hygiene guarantees - orphaned state values cannot be removed through normal pruning operations, representing a fundamental failure in the storage layer's garbage collection.

**Requires Manual Intervention**: The leaked storage is permanent and cannot be cleaned up through normal operations. Recovery requires manual database cleanup scripts, database rebuild from snapshots, or potentially coordinated network intervention if widespread.

This does not reach Critical severity as it doesn't directly cause fund loss or consensus violations, but the cumulative impact qualifies as High severity per the "Validator Node Slowdowns" category.

## Likelihood Explanation
This vulnerability has **High Likelihood**:

**Automatic Triggering**: The bug is triggered automatically during crash recovery with no malicious actor required. The truncation logic is invoked by `sync_commit_progress` during normal StateStore initialization [10](#0-9) .

**Frequent Occurrence**: Validator nodes crash regularly due to hardware failures, out-of-memory conditions, software panics, upgrades, and OS maintenance. Each crash that occurs after shard commits but before progress marker updates triggers this bug.

**Cumulative Effect**: Each crash event leaks storage. Given hundreds of validators and regular crashes across the network, this accumulates significantly over time, especially for high-throughput validators.

## Recommendation
Fix the `delete_state_value_and_index` function to use `index.version` instead of `index.stale_since_version` when deleting state values:

**For sharded mode (line 564-567):**
```rust
batch.delete::<StateValueByKeyHashSchema>(&(
    index.state_key_hash,
    index.version,  // Changed from index.stale_since_version
))?;
```

**For non-sharded mode (line 576):**
```rust
batch.delete::<StateValueSchema>(&(index.state_key, index.version))?;
```

This matches the correct implementation used in the pruning logic.

## Proof of Concept
The existing test `test_truncation` does not catch this bug because it only verifies that remaining data has `version <= target_version`, but doesn't verify that ALL data that should be deleted is actually deleted [11](#0-10) . 

A proper test would need to:
1. Create state values and their stale indices
2. Simulate a crash by advancing state_kv_commit_progress beyond overall_commit_progress
3. Call sync_commit_progress to trigger truncation
4. Verify that BOTH indices AND their corresponding state values are deleted
5. Check for orphaned state values (values without corresponding indices)

The bug can be reproduced by examining any production validator that has experienced crashes - orphaned state values will accumulate in the database over time, detectable by comparing the state values present against the stale indices.

## Notes
The bug affects both sharded and non-sharded storage configurations. The existing test coverage validates the wrong property (remaining data versions) rather than verifying complete deletion of truncated data, which is why this bug was not caught during development.

### Citations

**File:** storage/aptosdb/src/schema/state_value_by_key_hash/mod.rs (L7-15)
```rust
//! An Index Key in this data set has 2 pieces of information:
//!     1. The state key hash
//!     2. The version associated with the key
//! The value associated with the key is the serialized State Value.
//!
//! ```text
//! |<-------- key -------->|<------ value ---->|
//! |  state key hash | version |  state value  |
//! ```
```

**File:** types/src/state_store/state_value.rs (L378-388)
```rust
/// Indicates a state value becomes stale since `stale_since_version`.
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[cfg_attr(any(test, feature = "fuzzing"), derive(proptest_derive::Arbitrary))]
pub struct StaleStateValueByKeyHashIndex {
    /// The version since when the node is overwritten and becomes stale.
    pub stale_since_version: Version,
    /// The version identifying the value associated with this record.
    pub version: Version,
    /// The hash of `StateKey` identifying the value associated with this record.
    pub state_key_hash: HashValue,
}
```

**File:** storage/aptosdb/src/state_store/mod.rs (L354-359)
```rust
            Self::sync_commit_progress(
                Arc::clone(&ledger_db),
                Arc::clone(&state_kv_db),
                Arc::clone(&state_merkle_db),
                /*crash_if_difference_is_too_large=*/ true,
            );
```

**File:** storage/aptosdb/src/state_store/mod.rs (L410-502)
```rust
    pub fn sync_commit_progress(
        ledger_db: Arc<LedgerDb>,
        state_kv_db: Arc<StateKvDb>,
        state_merkle_db: Arc<StateMerkleDb>,
        crash_if_difference_is_too_large: bool,
    ) {
        let ledger_metadata_db = ledger_db.metadata_db();
        if let Some(overall_commit_progress) = ledger_metadata_db
            .get_synced_version()
            .expect("DB read failed.")
        {
            info!(
                overall_commit_progress = overall_commit_progress,
                "Start syncing databases..."
            );
            let ledger_commit_progress = ledger_metadata_db
                .get_ledger_commit_progress()
                .expect("Failed to read ledger commit progress.");
            assert_ge!(ledger_commit_progress, overall_commit_progress);

            let state_kv_commit_progress = state_kv_db
                .metadata_db()
                .get::<DbMetadataSchema>(&DbMetadataKey::StateKvCommitProgress)
                .expect("Failed to read state K/V commit progress.")
                .expect("State K/V commit progress cannot be None.")
                .expect_version();
            assert_ge!(state_kv_commit_progress, overall_commit_progress);

            // LedgerCommitProgress was not guaranteed to commit after all ledger changes finish,
            // have to attempt truncating every column family.
            info!(
                ledger_commit_progress = ledger_commit_progress,
                "Attempt ledger truncation...",
            );
            let difference = ledger_commit_progress - overall_commit_progress;
            if crash_if_difference_is_too_large {
                assert_le!(difference, MAX_COMMIT_PROGRESS_DIFFERENCE);
            }
            truncate_ledger_db(ledger_db.clone(), overall_commit_progress)
                .expect("Failed to truncate ledger db.");

            // State K/V commit progress isn't (can't be) written atomically with the data,
            // because there are shards, so we have to attempt truncation anyway.
            info!(
                state_kv_commit_progress = state_kv_commit_progress,
                "Start state KV truncation..."
            );
            let difference = state_kv_commit_progress - overall_commit_progress;
            if crash_if_difference_is_too_large {
                assert_le!(difference, MAX_COMMIT_PROGRESS_DIFFERENCE);
            }
            truncate_state_kv_db(
                &state_kv_db,
                state_kv_commit_progress,
                overall_commit_progress,
                std::cmp::max(difference as usize, 1), /* batch_size */
            )
            .expect("Failed to truncate state K/V db.");

            let state_merkle_max_version = get_max_version_in_state_merkle_db(&state_merkle_db)
                .expect("Failed to get state merkle max version.")
                .expect("State merkle max version cannot be None.");
            if state_merkle_max_version > overall_commit_progress {
                let difference = state_merkle_max_version - overall_commit_progress;
                if crash_if_difference_is_too_large {
                    assert_le!(difference, MAX_COMMIT_PROGRESS_DIFFERENCE);
                }
            }
            let state_merkle_target_version = find_tree_root_at_or_before(
                ledger_metadata_db,
                &state_merkle_db,
                overall_commit_progress,
            )
            .expect("DB read failed.")
            .unwrap_or_else(|| {
                panic!(
                    "Could not find a valid root before or at version {}, maybe it was pruned?",
                    overall_commit_progress
                )
            });
            if state_merkle_target_version < state_merkle_max_version {
                info!(
                    state_merkle_max_version = state_merkle_max_version,
                    target_version = state_merkle_target_version,
                    "Start state merkle truncation..."
                );
                truncate_state_merkle_db(&state_merkle_db, state_merkle_target_version)
                    .expect("Failed to truncate state merkle db.");
            }
        } else {
            info!("No overall commit progress was found!");
        }
    }
```

**File:** storage/aptosdb/src/state_store/mod.rs (L973-979)
```rust
                    Self::put_state_kv_index(
                        batch,
                        enable_sharding,
                        version,
                        old_entry.expect_value_version(),
                        key,
                    )
```

**File:** storage/aptosdb/src/utils/truncation_helper.rs (L564-567)
```rust
            batch.delete::<StateValueByKeyHashSchema>(&(
                index.state_key_hash,
                index.stale_since_version,
            ))?;
```

**File:** storage/aptosdb/src/utils/truncation_helper.rs (L576-576)
```rust
            batch.delete::<StateValueSchema>(&(index.state_key, index.stale_since_version))?;
```

**File:** storage/aptosdb/src/pruner/state_kv_pruner/state_kv_shard_pruner.rs (L54-65)
```rust
        let mut iter = self
            .db_shard
            .iter::<StaleStateValueIndexByKeyHashSchema>()?;
        iter.seek(&current_progress)?;
        for item in iter {
            let (index, _) = item?;
            if index.stale_since_version > target_version {
                break;
            }
            batch.delete::<StaleStateValueIndexByKeyHashSchema>(&index)?;
            batch.delete::<StateValueByKeyHashSchema>(&(index.state_key_hash, index.version))?;
        }
```

**File:** storage/aptosdb/src/db_debugger/truncate/mod.rs (L303-331)
```rust
                let mut iter = state_kv_db.metadata_db().iter::<StateValueByKeyHashSchema>().unwrap();
                iter.seek_to_first();
                for item in iter {
                    let ((_, version), _) = item.unwrap();
                    prop_assert!(version <= target_version);
                }

                let mut iter = state_kv_db.metadata_db().iter::<StaleStateValueIndexByKeyHashSchema>().unwrap();
                iter.seek_to_first();
                for item in iter {
                    let version = item.unwrap().0.stale_since_version;
                    prop_assert!(version <= target_version);
                }

            } else {
                let mut iter = state_kv_db.metadata_db().iter::<StateValueSchema>().unwrap();
                iter.seek_to_first();
                for item in iter {
                    let ((_, version), _) = item.unwrap();
                    prop_assert!(version <= target_version);
                }

                let mut iter = state_kv_db.metadata_db().iter::<StaleStateValueIndexSchema>().unwrap();
                iter.seek_to_first();
                for item in iter {
                    let version = item.unwrap().0.stale_since_version;
                    prop_assert!(version <= target_version);
                }
            }
```
