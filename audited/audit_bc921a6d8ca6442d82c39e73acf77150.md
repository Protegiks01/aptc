# Audit Report

## Title
Manifest Tampering Allows Validator Set Manipulation Through Backup Restoration Without Integrity Verification

## Summary
The epoch ending backup manifest and associated chunk files lack cryptographic integrity verification, allowing an attacker with write access to backup storage to inject fake epoch ending ledger infos containing malicious validator sets. When nodes restore from compromised backups without providing trusted waypoints, the fake validator sets are imported into the database and used for consensus validation, breaking consensus safety guarantees.

## Finding Description

The `EpochEndingBackupMeta` struct stores a `manifest` field as a plain `FileHandle` (which is just a `String` type alias) with no cryptographic signature or integrity verification: [1](#0-0) [2](#0-1) 

During backup restoration, the `EpochEndingRestoreController` loads the manifest and validates epoch ending ledger infos through the following verification chain: [3](#0-2) 

The critical vulnerability exists in the verification logic at lines 119-147. The code checks waypoints from the manifest against waypoints computed from ledger infos, then attempts signature verification: [4](#0-3) 

**The bypass occurs when:**
1. No trusted waypoints are provided (the `trust_waypoint` CLI parameter is optional and defaults to an empty vector)
2. The restore is processing the first epoch (`previous_li` is `None` on initialization at line 88) [5](#0-4) [6](#0-5) 

In this scenario, neither the trusted waypoint check (lines 129-135) nor the signature verification (lines 136-146) executes, allowing completely unverified ledger infos to be accepted as long as the waypoints in the manifest match the waypoints computed from the fake ledger infos—both of which the attacker controls.

**Attack Path:**
1. Attacker gains write access to backup storage (compromised S3 bucket, file system, etc.)
2. Attacker creates fake `LedgerInfoWithSignatures` containing a malicious `next_epoch_state` with attacker-controlled validators
3. Attacker generates matching waypoints for the fake ledger infos
4. Attacker creates a fake manifest JSON file referencing the fake waypoints and chunk files
5. Attacker replaces the real manifest and chunk files in backup storage
6. Node operator initiates restore without providing trusted waypoints (which is valid usage)
7. The fake ledger infos pass verification and are saved to the database: [7](#0-6) 

8. The consensus layer retrieves the fake validator set from these ledger infos: [8](#0-7) 

The epoch ending ledger infos contain `next_epoch_state` which includes the `ValidatorVerifier` used by consensus to validate signatures on blocks and quorum certificates. By injecting fake validator sets, an attacker can cause nodes to accept blocks signed by malicious validators that are not part of the legitimate validator set.

## Impact Explanation

This vulnerability qualifies as **CRITICAL SEVERITY** under the Aptos Bug Bounty program criteria:

**Consensus/Safety Violation**: This directly breaks the "Consensus Safety" invariant. The validator set is a fundamental consensus parameter that determines which entities can sign blocks and participate in consensus. By manipulating validator sets through backup tampering, an attacker can:

1. **Cause consensus splits**: Different nodes restoring from different backups (legitimate vs. compromised) will have different validator sets and accept different blocks as valid
2. **Accept unauthorized blocks**: Nodes with fake validator sets will accept blocks signed by the attacker's validators as legitimate
3. **Network partition**: The network could split into multiple chains, each following different validator sets

**Non-recoverable without intervention**: If multiple nodes restore from compromised backups, the network would require manual intervention or a hard fork to recover consensus on the correct validator set.

## Likelihood Explanation

**MODERATE to HIGH likelihood** depending on operational security practices:

**Attacker Requirements:**
- Write access to backup storage (S3 bucket credentials, file system access, cloud storage API keys)
- Ability to create validly-formatted epoch ending ledger infos and waypoints (publicly documented formats)
- No cryptographic keys required—the vulnerability bypasses signature verification entirely

**Realistic Scenarios:**
1. Compromised cloud storage credentials (common attack vector)
2. Misconfigured backup storage permissions (publicly writable buckets)
3. Insider threat from infrastructure administrators
4. Supply chain attack on backup infrastructure

**Exploitation Complexity:** LOW
- No specialized cryptographic knowledge required
- Attack can be scripted once backup formats are understood
- No timing requirements or race conditions

**Detection Difficulty:** HIGH
- No cryptographic verification would detect the tampering
- Only trusted waypoints (if provided) would catch this attack
- Operators may not realize they've restored from compromised backups until consensus anomalies appear

## Recommendation

Implement cryptographic integrity verification for backup manifests and chunks using one of these approaches:

**Option 1: Mandatory Trusted Waypoints**
Require at least one trusted waypoint (e.g., genesis waypoint) for all restore operations:

```rust
// In EpochEndingRestoreController::preheat_impl
ensure!(
    !self.trusted_waypoints.is_empty() || previous_li.is_some(),
    "Restore requires at least one trusted waypoint or previous epoch ending ledger info for security"
);
```

**Option 2: Cryptographic Manifest Signatures**
Sign all manifest files with operator keys and verify signatures during restore:

```rust
pub struct EpochEndingBackupMeta {
    pub first_epoch: u64,
    pub last_epoch: u64,
    pub first_version: Version,
    pub last_version: Version,
    pub manifest: FileHandle,
    pub manifest_signature: Ed25519Signature,  // Add signature
    pub signer_public_key: Ed25519PublicKey,   // Add public key
}
```

**Option 3: Content-Based Verification**
Store content hashes in metadata files that are stored separately from backup data:

```rust
pub struct EpochEndingBackupMeta {
    pub first_epoch: u64,
    pub last_epoch: u64,
    pub first_version: Version,
    pub last_version: Version,
    pub manifest: FileHandle,
    pub manifest_hash: HashValue,  // Cryptographic hash of manifest contents
}
```

**Recommended Solution:** Combine Options 1 and 2:
- Make trusted waypoints mandatory for restores from untrusted sources
- Add cryptographic signatures to all backup manifests
- Document security best practices for backup storage access control

## Proof of Concept

```rust
// Proof of concept demonstrating the vulnerability
// This would be added to storage/backup/backup-cli/src/backup_types/epoch_ending/tests.rs

#[tokio::test]
async fn test_manifest_tampering_vulnerability() {
    use aptos_crypto::{ed25519::Ed25519PrivateKey, PrivateKey, Uniform};
    use aptos_types::{
        block_info::BlockInfo,
        epoch_state::EpochState,
        ledger_info::{LedgerInfo, LedgerInfoWithSignatures},
        validator_verifier::ValidatorVerifier,
        waypoint::Waypoint,
    };
    use rand::SeedableRng;
    
    // Create fake validator set with attacker's key
    let mut rng = rand::rngs::StdRng::from_seed([0u8; 32]);
    let attacker_key = Ed25519PrivateKey::generate(&mut rng);
    let attacker_pubkey = attacker_key.public_key();
    
    // Create fake validator verifier with attacker as sole validator
    let fake_validator_verifier = ValidatorVerifier::new_single(
        attacker_pubkey,
        1,  // voting power
    );
    
    let fake_epoch_state = EpochState {
        epoch: 0,
        verifier: Arc::new(fake_validator_verifier),
    };
    
    // Create fake epoch ending ledger info with malicious validator set
    let block_info = BlockInfo::new(
        0,  // epoch
        0,  // round
        HashValue::zero(),
        HashValue::zero(),
        0,  // version
        0,  // timestamp
        Some(fake_epoch_state),  // Inject fake validator set
    );
    
    let fake_ledger_info = LedgerInfo::new(
        block_info,
        HashValue::zero(),
    );
    
    // Create signature with attacker's key (validators would normally sign)
    let signature = attacker_key.sign(&fake_ledger_info);
    let fake_li_with_sigs = LedgerInfoWithSignatures::new(
        fake_ledger_info.clone(),
        BTreeMap::from([(attacker_pubkey, signature)]),
    );
    
    // Create fake waypoint matching the fake ledger info
    let fake_waypoint = Waypoint::new_epoch_boundary(&fake_ledger_info).unwrap();
    
    // Create fake manifest with fake waypoint
    let fake_manifest = EpochEndingBackup {
        first_epoch: 0,
        last_epoch: 0,
        waypoints: vec![fake_waypoint],
        chunks: vec![/* chunk with fake_li_with_sigs */],
    };
    
    // Write fake manifest and chunks to storage
    // ... (storage setup omitted for brevity)
    
    // Restore WITHOUT trusted waypoints - this should fail but currently succeeds
    let restore_controller = EpochEndingRestoreController::new(
        EpochEndingRestoreOpt {
            manifest_handle: fake_manifest_handle,
        },
        GlobalRestoreOptions {
            target_version: Version::MAX,
            trusted_waypoints: Arc::new(HashMap::new()), // NO TRUSTED WAYPOINTS
            run_mode: Arc::new(RestoreRunMode::Verify),
            concurrent_downloads: 1,
            replay_concurrency_level: 1,
        },
        storage,
    );
    
    // This restore succeeds and imports the fake validator set!
    let result = restore_controller.run(None).await;
    assert!(result.is_ok(), "Fake manifest was accepted without verification!");
    
    // The database now contains fake validator set that will be used for consensus
    // This breaks consensus safety as the node will accept blocks signed by the attacker
}
```

## Notes

This vulnerability represents a critical gap in the backup/restore trust model. While the system correctly implements signature verification for epoch ending ledger infos when chain continuity exists, it fails to enforce any verification for the initial epoch when no trusted waypoints are provided. This creates a bootstrapping vulnerability where the initial validator set can be arbitrarily set by an attacker with backup storage access.

The impact is amplified because:
1. Trusted waypoints are optional in the current design, making the vulnerable code path the default for some restore scenarios
2. Backup storage is often treated as a lower-security tier than validator keys, but this vulnerability shows it can directly compromise consensus
3. The attack is silent—nodes would not detect they've been compromised until they start accepting invalid blocks

Operators should immediately implement strict access controls on backup storage and always provide trusted waypoints (especially genesis waypoints) when performing restores.

### Citations

**File:** storage/backup/backup-cli/src/storage/mod.rs (L40-41)
```rust
pub type FileHandle = String;
pub type FileHandleRef = str;
```

**File:** storage/backup/backup-cli/src/metadata/mod.rs (L176-182)
```rust
pub struct EpochEndingBackupMeta {
    pub first_epoch: u64,
    pub last_epoch: u64,
    pub first_version: Version,
    pub last_version: Version,
    pub manifest: FileHandle,
}
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L80-83)
```rust
    async fn preheat_impl(&self) -> Result<EpochEndingRestorePreheatData> {
        let manifest: EpochEndingBackup =
            self.storage.load_json_file(&self.manifest_handle).await?;
        manifest.verify()?;
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L88-88)
```rust
        let mut previous_li: Option<&LedgerInfoWithSignatures> = None;
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L119-147)
```rust
                let wp_manifest = waypoint_iter.next().ok_or_else(|| {
                    anyhow!("More LedgerInfo's found than waypoints in manifest.")
                })?;
                let wp_li = Waypoint::new_epoch_boundary(li.ledger_info())?;
                ensure!(
                    *wp_manifest == wp_li,
                    "Waypoints don't match. In manifest: {}, In chunk: {}",
                    wp_manifest,
                    wp_li,
                );
                if let Some(wp_trusted) = self.trusted_waypoints.get(&wp_li.version()) {
                    ensure!(
                        *wp_trusted == wp_li,
                        "Waypoints don't match. In backup: {}, trusted: {}",
                        wp_li,
                        wp_trusted,
                    );
                } else if let Some(pre_li) = previous_li {
                    pre_li
                        .ledger_info()
                        .next_epoch_state()
                        .ok_or_else(|| {
                            anyhow!(
                                "Next epoch state not found from LI at epoch {}.",
                                pre_li.ledger_info().epoch()
                            )
                        })?
                        .verify(&li)?;
                }
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L248-249)
```rust
            RestoreRunMode::Restore { restore_handler } => {
                restore_handler.save_ledger_infos(&preheat_data.ledger_infos)?;
```

**File:** storage/backup/backup-cli/src/utils/mod.rs (L331-346)
```rust
#[derive(Clone, Default, Parser)]
pub struct TrustedWaypointOpt {
    #[clap(
        long,
        help = "(multiple) When provided, an epoch ending LedgerInfo at the waypoint version will be \
        checked against the hash in the waypoint, but signatures on it are NOT checked. \
        Use this for two purposes: \
        1. set the genesis or the latest waypoint to confirm the backup is compatible. \
        2. set waypoints at versions where writeset transactions were used to overwrite the \
        validator set, so that the signature check is skipped. \
        N.B. LedgerInfos are verified only when restoring / verifying the epoch ending backups, \
        i.e. they are NOT checked at all when doing one-shot restoring of the transaction \
        and state backups."
    )]
    pub trust_waypoint: Vec<Waypoint>,
}
```

**File:** storage/aptosdb/src/ledger_db/ledger_metadata_db.rs (L135-150)
```rust
    pub(crate) fn get_epoch_state(&self, epoch: u64) -> Result<EpochState> {
        ensure!(epoch > 0, "EpochState only queryable for epoch >= 1.",);

        let ledger_info_with_sigs =
            self.db
                .get::<LedgerInfoSchema>(&(epoch - 1))?
                .ok_or_else(|| {
                    AptosDbError::NotFound(format!("Last LedgerInfo of epoch {}", epoch - 1))
                })?;
        let latest_epoch_state = ledger_info_with_sigs
            .ledger_info()
            .next_epoch_state()
            .ok_or_else(|| {
                AptosDbError::Other(
                    "Last LedgerInfo in epoch must carry next_epoch_state.".to_string(),
                )
```
