# Audit Report

## Title
VerifierConfig `max_basic_blocks` Limit Bypass Enables Resource Exhaustion via Expensive Pre-Check Operations

## Summary
The `max_basic_blocks` limit in `VerifierConfig` is enforced AFTER expensive control flow graph analysis operations have already been performed. An attacker can submit Move modules with arbitrarily large numbers of basic blocks that exceed configured limits, causing validators to perform costly memory allocations and graph traversals before the limit check rejects the module. This enables resource exhaustion attacks against validator nodes.

## Finding Description
The Move bytecode verification pipeline enforces limits through `VerifierConfig` to prevent resource exhaustion. However, the `max_basic_blocks` limit is applied inconsistently across verification stages, violating the critical invariant: "All operations must respect gas, storage, and computational limits." [1](#0-0) 

The vulnerable execution flow is:

1. `CodeUnitVerifier::verify_function` calls `control_flow::verify_function` 
2. Inside `control_flow::verify_function`, a `FunctionView` with CFG is created
3. `verify_reducibility` is called, which creates `LoopSummary::new(function_view.cfg())` [2](#0-1) 

4. `LoopSummary::new` performs expensive operations on the unchecked CFG: [3](#0-2) 

The `LoopSummary::new` constructor allocates four vectors sized to `num_blocks` and performs a complete depth-first traversal of the CFG, building the spanning tree and categorizing edges. This happens BEFORE the `max_basic_blocks` check at line 147-153 of `code_unit_verifier.rs`.

**Attack Scenario:**
An attacker crafts a Move module with 100,000 basic blocks (e.g., a long chain of `Branch` instructions). Production config sets `max_basic_blocks = 1024`: [4](#0-3) 

When validators verify this module:
1. `LoopSummary::new` allocates 4 vectors Ã— 100,000 elements = significant memory
2. DFS traversal processes all 100,000 blocks
3. Loop analysis iterates through nodes
4. THEN the check at line 147 rejects it with `TOO_MANY_BASIC_BLOCKS`

The expensive operations (memory allocation, DFS traversal, loop processing) occur before enforcement, enabling resource exhaustion.

## Impact Explanation
This vulnerability qualifies as **High Severity** per the Aptos Bug Bounty program:

**Direct Match to High Severity Category:**
- "Validator node slowdowns" - Explicitly listed as High Severity impact

**Concrete Impact:**
1. **Resource Exhaustion:** Validators waste CPU and memory on modules exceeding limits
2. **DoS Vector:** Attacker can repeatedly submit such modules, forcing validators to perform expensive verification
3. **Network Degradation:** If multiple validators are impacted simultaneously, network performance degrades
4. **Metering Bypass:** Expensive operations occur before limits are enforced, defeating the purpose of `VerifierConfig`

**Why Not Critical:**
- Does not cause consensus violations or safety breaks
- Does not enable fund theft or state corruption  
- Validators eventually reject the module (self-healing)
- Does not require hardfork to recover

**Why Not Medium:**
- More severe than "limited" impact - affects core validator operations
- Can impact multiple validators simultaneously
- Affects network-critical verification path

## Likelihood Explanation
**High Likelihood:**

1. **Low Attacker Complexity:** Creating modules with many basic blocks is trivial - just chain Branch instructions
2. **No Privileged Access Required:** Any account with enough gas to submit a module publishing transaction can exploit this
3. **Guaranteed Trigger:** The vulnerability triggers deterministically on every verification attempt
4. **Production Configuration Vulnerable:** The production `VerifierConfig` at `max_basic_blocks = 1024` is susceptible to blocks far exceeding this limit
5. **Multiple Attack Vectors:** Same issue exists for scripts with `max_basic_blocks_in_script` check

## Recommendation
**Apply limit checks BEFORE expensive operations.** Move the `max_basic_blocks` check to occur before `control_flow::verify_function` or inside it before `LoopSummary::new`:

```rust
// In code_unit_verifier.rs, verify_function:
fn verify_function(
    verifier_config: &VerifierConfig,
    index: FunctionDefinitionIndex,
    function_definition: &FunctionDefinition,
    module: &CompiledModule,
    name_def_map: &HashMap<IdentifierIndex, FunctionDefinitionIndex>,
    meter: &mut impl Meter,
) -> PartialVMResult<usize> {
    // ... existing code ...
    
    // CHECK LIMITS EARLY - before control_flow::verify_function
    if let Some(limit) = verifier_config.max_basic_blocks {
        // Need to compute basic blocks count early
        let cfg = ControlFlowGraph::new(&code.code);
        if cfg.num_blocks() > limit {
            return Err(
                PartialVMError::new(StatusCode::TOO_MANY_BASIC_BLOCKS)
                    .at_code_offset(index, 0)
            );
        }
    }
    
    let function_view = control_flow::verify_function(
        verifier_config,
        module,
        index,
        function_definition,
        code,
        meter,
    )?;
    
    // ... rest of existing code ...
}
```

Apply similar early checks for:
- `max_basic_blocks_in_script` in `verify_script_impl`
- `max_loop_depth` (already checked inside `verify_reducibility`, but verify no expensive ops before it)

## Proof of Concept
```rust
use move_binary_format::file_format::{Bytecode, CodeUnit, empty_module};
use move_bytecode_verifier::{CodeUnitVerifier, VerifierConfig};
use move_core_types::vm_status::StatusCode;

#[test]
fn test_max_basic_blocks_bypass() {
    // Create a module with 10,000 basic blocks (far exceeding limit of 1024)
    let mut code = Vec::new();
    
    // Create a long chain of branches: each creates a new basic block
    for i in 0..9999 {
        code.push(Bytecode::Branch((i + 1) as u16));
    }
    code.push(Bytecode::Ret); // Final instruction
    
    let module = dummy_procedure_module(code);
    
    // Use production config with max_basic_blocks = 1024
    let config = VerifierConfig {
        max_basic_blocks: Some(1024),
        ..Default::default()
    };
    
    // This will perform expensive LoopSummary::new with 10,000 blocks
    // BEFORE checking the limit
    let start = std::time::Instant::now();
    let result = CodeUnitVerifier::verify_module(&config, &module);
    let elapsed = start.elapsed();
    
    // Eventually rejected, but only AFTER expensive operations
    assert_eq!(result.unwrap_err().major_status(), StatusCode::TOO_MANY_BASIC_BLOCKS);
    
    // Demonstrate that significant time was spent before rejection
    println!("Time spent before limit check: {:?}", elapsed);
    // Expected: measurable time proportional to 10,000 blocks
}
```

**Notes:**
- The same verification code path is exercised during module publishing when validators process transactions
- An attacker can repeatedly submit such modules to continuously exhaust validator resources
- The attack is amplified because ALL validators must verify the same malicious module

### Citations

**File:** third_party/move/move-bytecode-verifier/src/code_unit_verifier.rs (L138-153)
```rust
        let function_view = control_flow::verify_function(
            verifier_config,
            module,
            index,
            function_definition,
            code,
            meter,
        )?;

        if let Some(limit) = verifier_config.max_basic_blocks {
            if function_view.cfg().blocks().len() > limit {
                return Err(
                    PartialVMError::new(StatusCode::TOO_MANY_BASIC_BLOCKS).at_code_offset(index, 0)
                );
            }
        }
```

**File:** third_party/move/move-bytecode-verifier/src/control_flow.rs (L117-127)
```rust
fn verify_reducibility<'a>(
    verifier_config: &VerifierConfig,
    function_view: &'a FunctionView<'a>,
) -> PartialVMResult<()> {
    let current_function = function_view.index().unwrap_or(FunctionDefinitionIndex(0));
    let err = move |code: StatusCode, offset: CodeOffset| {
        Err(PartialVMError::new(code).at_code_offset(current_function, offset))
    };

    let summary = LoopSummary::new(function_view.cfg());
    let mut partition = LoopPartition::new(&summary);
```

**File:** third_party/move/move-bytecode-verifier/src/loop_summary.rs (L74-99)
```rust
        let num_blocks = cfg.num_blocks() as usize;

        // Fields in LoopSummary that are filled via a depth-first traversal of `cfg`.
        let mut blocks = vec![0; num_blocks];
        let mut descs = vec![0; num_blocks];
        let mut backs = vec![vec![]; num_blocks];
        let mut preds = vec![vec![]; num_blocks];

        let mut next_node = NodeId(0);

        let root_block = cfg.entry_block_id();
        let root_node = next_node.bump();

        let mut exploration = BTreeMap::new();
        blocks[usize::from(root_node)] = root_block;
        exploration.insert(root_block, InProgress(root_node));

        let mut stack: Vec<Frontier> = cfg
            .successors(root_block)
            .iter()
            .map(|succ| Visit {
                from_node: root_node,
                to_block: *succ,
            })
            .collect();

```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L155-160)
```rust
    VerifierConfig {
        scope: VerificationScope::Everything,
        max_loop_depth: Some(5),
        max_generic_instantiation_length: Some(32),
        max_function_parameters: Some(128),
        max_basic_blocks: Some(1024),
```
