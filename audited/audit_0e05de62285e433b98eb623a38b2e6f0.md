# Audit Report

## Title
Missing Code Signing and Public Key Pinning in Aptos CLI Auto-Update Mechanism

## Summary
The Aptos CLI's self-update mechanism in `build_updater()` lacks cryptographic signature verification and public key pinning. Downloaded binaries from GitHub releases are installed without any authenticity verification, creating a critical supply chain vulnerability.

## Finding Description

The `build_updater()` function in the Aptos CLI update module creates an updater configuration that downloads and installs binary releases from GitHub without any signature verification mechanism. [1](#0-0) 

The updater configuration only specifies repository parameters, version tags, and target platform, but contains no signature verification, public key pinning, or cryptographic authentication of any kind. [2](#0-1) 

Furthermore, a comprehensive search of the entire update module confirms the complete absence of signature verification functionality. The codebase contains no references to signature verification, public keys, or code signing in the update mechanism.

The dependency configuration shows the `self_update` crate is used with only archive handling features (`archive-zip`, `compression-zip-deflate`), with no signature verification features enabled. [3](#0-2) 

**Attack Scenario:**

If an attacker compromises the `aptos-labs` GitHub account or the release infrastructure, they could:

1. Publish a malicious release with a valid version tag (e.g., `aptos-cli-v7.15.0`)
2. Users running `aptos update` would fetch the malicious release list from GitHub
3. The updater would download the malicious binary without verification
4. The malicious binary would replace the legitimate CLI tool
5. Upon execution, the malicious code could steal private keys, manipulate transactions, compromise validator nodes, or execute arbitrary commands

The repository parameters are also configurable via CLI flags, though exploitation via this vector would require social engineering. [4](#0-3) 

## Impact Explanation

This vulnerability represents a **High severity** supply chain attack vector under the Aptos bug bounty program criteria:

- **Significant protocol violations**: Compromised CLI tools used by validator operators could lead to validator node compromise, affecting network security and consensus
- **Remote Code Execution**: Malicious binaries execute with the privileges of the user running the update, potentially affecting validator nodes if operators use the CLI
- **Wide impact surface**: All users of `aptos update` are affected, including developers, node operators, and validator operators

While this is not direct "Remote Code Execution on validator node" (Critical severity), it creates a realistic path to validator compromise through compromised infrastructure. The lack of any cryptographic verification violates fundamental software supply chain security principles.

## Likelihood Explanation

**High Likelihood** for the following reasons:

1. **GitHub account compromise is a realistic threat**: Nation-state actors and sophisticated attackers regularly target critical infrastructure accounts. Recent supply chain attacks (SolarWinds, CodeCov) demonstrate this threat model.

2. **No defense-in-depth**: The absence of signature verification means a single point of failure (GitHub account security) determines the integrity of all CLI installations.

3. **Automatic installation**: Users running `aptos update` receive no cryptographic assurance of binary authenticity, making the attack transparent to victims.

4. **High-value target**: Aptos CLI is used by validator operators and developers handling significant cryptocurrency value, making it an attractive target.

## Recommendation

Implement code signing with pinned public key verification:

1. **Generate a code signing keypair**: The Aptos Foundation should generate an Ed25519 or ECDSA keypair dedicated to release signing, with the private key stored in a Hardware Security Module (HSM).

2. **Sign all releases**: Each binary release should include a detached signature file (e.g., `aptos-Linux-x86_64.sig`).

3. **Pin the public key**: Embed the verification public key directly in the binary source code:

```rust
// In aptos.rs or a new module
const APTOS_RELEASE_SIGNING_KEY: &str = 
    "ed25519_public_key_here_in_hex_or_base64";

fn verify_release_signature(binary: &[u8], signature: &[u8]) -> Result<()> {
    // Use aptos-crypto to verify Ed25519 signature
    let public_key = Ed25519PublicKey::try_from(
        hex::decode(APTOS_RELEASE_SIGNING_KEY)?
    )?;
    let sig = Ed25519Signature::try_from(signature)?;
    sig.verify(&binary, &public_key)
        .map_err(|e| anyhow!("Signature verification failed: {}", e))
}
```

4. **Modify build_updater()**: After downloading but before installing, verify the signature:

```rust
// In build_updater(), after download completes
let binary_path = /* downloaded binary path */;
let sig_path = /* download signature file from release */;
verify_release_signature(&fs::read(binary_path)?, &fs::read(sig_path)?)?;
// Then proceed with installation
```

5. **Key rotation mechanism**: Implement a secure key rotation mechanism where new keys are signed by old keys, maintaining a chain of trust.

6. **Remove configurable repo parameters**: Hardcode the repository parameters to prevent social engineering attacks, or require explicit confirmation from users if custom repositories are used.

## Proof of Concept

**Demonstrating the vulnerability** (ethical disclosure - DO NOT EXECUTE maliciously):

1. **Setup**: Create a GitHub repository mimicking the aptos-core release structure:
```bash
# Create malicious repository with release
gh repo create attacker/fake-aptos-core
# Create a release with tag aptos-cli-v7.15.0
# Upload a binary that prints "COMPROMISED" instead of normal CLI
```

2. **Exploit** (requires social engineering, shown for demonstration):
```bash
# User runs update with attacker's repository
aptos update --repo-owner attacker --repo-name fake-aptos-core
# CLI downloads and installs malicious binary without verification
```

3. **Verification**: The binary is installed and executed without any signature check. The lack of verification code can be confirmed by:
```bash
# Search the codebase
grep -r "verify.*signature\|pubkey\|public_key" crates/aptos/src/update/
# Returns no results related to binary verification
```

**Realistic attack without social engineering**:

If the `aptos-labs` GitHub account is compromised, attackers can publish malicious releases without any client-side defenses, as the current implementation trusts GitHub releases implicitly.

---

## Notes

- The primary vulnerability is the **absence of cryptographic signature verification**, not the configurable repository parameters (which require social engineering).
- The threat model includes compromised GitHub infrastructure, account takeovers, and supply chain attacksâ€”all realistic threats for high-value cryptocurrency infrastructure.
- HTTPS provides transport security but does not authenticate the source of the binaries or protect against compromised release infrastructure.
- This violates industry best practices for software distribution (e.g., Rust's rustup uses GPG signatures, Debian uses package signing, etc.).
- The Aptos codebase already contains extensive cryptographic infrastructure (`aptos-crypto` crate) that could be leveraged for signature verification.

### Citations

**File:** crates/aptos/src/update/aptos.rs (L33-39)
```rust
    /// The owner of the repo to download the binary from.
    #[clap(long, default_value = "aptos-labs")]
    repo_owner: String,

    /// The name of the repo to download the binary from.
    #[clap(long, default_value = "aptos-core")]
    repo_name: String,
```

**File:** crates/aptos/src/update/aptos.rs (L96-149)
```rust
    fn build_updater(&self, info: &UpdateRequiredInfo) -> Result<Box<dyn ReleaseUpdate>> {
        let installation_method =
            InstallationMethod::from_env().context("Failed to determine installation method")?;
        match installation_method {
            InstallationMethod::Source => {
                return Err(anyhow!(
                    "Detected this CLI was built from source, refusing to update"
                ));
            },
            InstallationMethod::Homebrew => {
                return Err(anyhow!(
                    "Detected this CLI comes from homebrew, use `brew upgrade aptos` instead"
                ));
            },
            InstallationMethod::PackageManager => {
                return Err(anyhow!(
                    "Detected this CLI comes from a package manager, use your package manager to update instead"
                ));
            },
            InstallationMethod::Other => {},
        }

        // Determine the target we should download. This is necessary because we don't
        // name our binary releases using the target triples nor do we build specifically
        // for all major triples, so we have to generalize to one of the binaries we do
        // happen to build. We figure this out based on what system the CLI was built on.
        let build_info = cli_build_information();
        let target = match build_info.get(BUILD_OS).context("Failed to determine build info of current CLI")?.as_str() {
            "linux-x86_64" => "Linux-x86_64",
            "linux-aarch64" => "Linux-aarch64",
            "macos-x86_64" => "macOS-x86_64",
            "macos-aarch64" => "macOS-arm64",
            "windows-x86_64" => "Windows-x86_64",
            wildcard => return Err(anyhow!("Self-updating is not supported on your OS ({}) right now, please download the binary manually", wildcard)),
        };

        let current_version = match &info.current_version {
            Some(version) => version,
            None => unreachable!("current_version should always be Some at this point"),
        };

        // Build a new configuration that will direct the library to download the
        // binary with the target version tag and target that we determined above.
        Update::configure()
            .repo_owner(&self.repo_owner)
            .repo_name(&self.repo_name)
            .bin_name("aptos")
            .current_version(current_version)
            .target_version_tag(&format!("aptos-cli-v{}", info.target_version))
            .target(target)
            .no_confirm(self.prompt_options.assume_yes)
            .build()
            .map_err(|e| anyhow!("Failed to build self-update configuration: {:#}", e))
    }
```

**File:** crates/aptos/Cargo.toml (L99-102)
```text
self_update = { git = "https://github.com/banool/self_update.git", rev = "8306158ad0fd5b9d4766a3c6bf967e7ef0ea5c4b", features = [
    "archive-zip",
    "compression-zip-deflate",
] }
```
