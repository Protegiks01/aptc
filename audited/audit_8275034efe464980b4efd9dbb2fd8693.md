# Audit Report

## Title
Non-Deterministic Verification in Consensus-Critical DKG Sigma Protocol

## Summary
The sigma protocol implementation used in DKG transcript verification generates non-deterministic random challenges during verification, violating consensus determinism requirements. This occurs in `compute_verifier_challenges()` which uses `thread_rng()` to generate batching challenges, potentially causing validators to disagree on transcript verification outcomes.

## Finding Description

The DKG (Distributed Key Generation) system uses sigma protocols to prove knowledge of secret shares in PVSS (Publicly Verifiable Secret Sharing) transcripts. These proofs are verified during validator transaction processing in consensus.

The vulnerability exists in the verification path where random batching challenges are generated: [1](#0-0) 

And similarly in the pairing tuple homomorphism: [2](#0-1) 

This non-deterministic randomness is used during DKG transcript verification, which is called in the consensus-critical validator transaction processing path: [3](#0-2) 

The verification flows through: [4](#0-3) 

Which calls the PVSS transcript verification: [5](#0-4) 

**The Issue**: While the core Fiat-Shamir challenge `c` is computed deterministically from the proof transcript, the batching challenge `beta` is generated using `thread_rng()` during each verification. Different validators generate different `beta` values for the same proof.

For a mathematically valid proof, all verification equations are satisfied, so any `beta` value will result in acceptance (deterministic). However, for an invalid or borderline-invalid proof, different `beta` values could theoretically lead to different verification outcomes with probability `1/|field_size|`.

**Regarding Forking Lemma**: The forking lemma security proof for sigma protocols requires that given two accepting transcripts with the same commitment but different challenges, a witness can be extracted. The core challenge `c` is correctly computed via Fiat-Shamir and satisfies forking lemma requirements. However, the additional non-deterministic `beta` challenge introduces verification non-determinism that, while not breaking the cryptographic soundness proof, violates consensus determinism requirements.

## Impact Explanation

**Consensus Determinism Violation (Critical Invariant #1 Broken)**

This violates the fundamental requirement that "All validators must produce identical state roots for identical blocks." In practice:

- **Probability of disagreement**: For an invalid proof, different validators might disagree with probability ≈ `1/2^256` (negligible)
- **Consequence if triggered**: Consensus liveness failure - validators cannot agree on block validity
- **Severity**: While cryptographically the probability is negligible, ANY non-determinism in consensus-critical code violates safety requirements

However, the practical exploitability is **extremely low** because:
1. Valid proofs pass with all `beta` values (deterministic acceptance)
2. Invalid proofs fail with overwhelming probability ~1 for any `beta` (near-deterministic rejection)
3. No clear attack vector exists to craft proofs that behave differently across `beta` values

## Likelihood Explanation

**Likelihood: Negligible in Practice**

The probability of actual validator disagreement is approximately `1/|ScalarField|` ≈ `2^-256` for invalid proofs. This is cryptographically negligible.

An attacker would need to:
1. Submit a DKG transcript with a borderline-invalid sigma proof
2. Hope that random `beta` values cause some validators to accept and others to reject
3. Success probability: ~`2^-256` (effectively impossible)

The TODO comments in the code indicate developers are aware this should be parameterized: [6](#0-5) 

## Recommendation

Make the verification deterministic by deriving `beta` from the proof transcript using Fiat-Shamir, or make it a parameter passed by the caller (derived deterministically from block context).

**Recommended Fix:**

```rust
// In compute_verifier_challenges:
fn compute_verifier_challenges<Ct>(
    &self,
    public_statement: &Self::Codomain,
    prover_first_message: &Self::Codomain,
    cntxt: &Ct,
    number_of_beta_powers: usize,
) -> (C::ScalarField, Vec<C::ScalarField>)
where
    Ct: Serialize,
{
    // Fiat–Shamir challenge c
    let c = fiat_shamir_challenge_for_sigma_protocol::<_, C::ScalarField, _>(
        cntxt,
        self,
        public_statement,
        prover_first_message,
        &self.dst(),
    );

    // Derive beta deterministically from the same transcript
    let mut beta_transcript = merlin::Transcript::new(b"BATCHING_CHALLENGE");
    beta_transcript.append_message(b"fiat_shamir_challenge", &c.into_bigint().to_bytes_le());
    beta_transcript.append_message(b"dst", &self.dst());
    let beta = <merlin::Transcript as fiat_shamir::SigmaProtocol<C::ScalarField, Self>>::challenge_for_sigma_protocol(&mut beta_transcript);
    
    let powers_of_beta = utils::powers(beta, number_of_beta_powers);
    (c, powers_of_beta)
}
```

## Proof of Concept

Given the negligible probability (`2^-256`), a practical PoC demonstrating actual validator disagreement is not feasible. However, the non-determinism can be observed:

```rust
// Demonstration that beta is non-deterministic
#[test]
fn test_verification_non_determinism() {
    let proof = /* valid DKG transcript proof */;
    let params = /* public parameters */;
    
    // Verify the same proof multiple times
    for _ in 0..10 {
        // Each call generates a different random beta internally
        assert!(verify_transcript(&params, &proof).is_ok());
        // Note: All should pass for valid proofs, but different beta values are used
    }
}
```

**Note**: While the non-determinism exists in the code, the practical exploitability is negligible due to the cryptographic properties of the batching technique. The issue is primarily a code quality and theoretical correctness concern rather than a practically exploitable vulnerability.

---

**Notes**

After thorough analysis, while this represents a violation of deterministic execution principles in consensus-critical code, the **practical exploitability is negligible** (probability ~`2^-256`). The cryptographic soundness and forking lemma security proofs remain valid because the core Fiat-Shamir challenge is deterministic. This is more accurately classified as a **code quality issue requiring remediation** rather than an immediately exploitable critical vulnerability. The TODO comments suggest developers are aware and plan to address this architectural concern.

### Citations

**File:** crates/aptos-dkg/src/sigma_protocol/traits.rs (L95-96)
```rust
        let mut rng = ark_std::rand::thread_rng(); // TODO: move this to trait!!
        let beta = C::ScalarField::rand(&mut rng);
```

**File:** crates/aptos-dkg/src/sigma_protocol/homomorphism/tuple.rs (L351-352)
```rust
        let mut rng = ark_std::rand::thread_rng(); // TODO: make this part of the function input?
        let beta = H1::Scalar::rand(&mut rng); // verifier-specific challenge
```

**File:** aptos-move/aptos-vm/src/validator_txns/dkg.rs (L111-112)
```rust
        DefaultDKG::verify_transcript(&pub_params, &transcript)
            .map_err(|_| Expected(TranscriptVerificationFailed))?;
```

**File:** types/src/dkg/real_dkg/mod.rs (L368-374)
```rust
        trx.main.verify(
            &params.pvss_config.wconfig,
            &params.pvss_config.pp,
            &spks,
            &all_eks,
            &aux,
        )?;
```

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcript.rs (L178-190)
```rust
            if let Err(err) = hom.verify(
                &TupleCodomainShape(
                    self.sharing_proof.range_proof_commitment.clone(),
                    chunked_elgamal::WeightedCodomainShape {
                        chunks: self.subtrs.Cs.clone(),
                        randomness: self.subtrs.Rs.clone(),
                    },
                ),
                &self.sharing_proof.SoK,
                &sok_cntxt,
            ) {
                bail!("PoK verification failed: {:?}", err);
            }
```
