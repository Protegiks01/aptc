# Audit Report

## Title
Insufficient Client-Side Success Metrics in Remote SafetyRules Creates Detection Blind Spot for Compromised Safety Rule Enforcement

## Summary
The remote SafetyRules service architecture only emits success/failure metrics from the server-side SafetyRules process, with no independent verification metrics on the client (consensus node) side. The client-side wrappers (`SerializerClient` and `MetricsSafetyRules`) only track timing and concurrency, not operation outcomes. This creates a blind spot where a compromised SafetyRules service could violate consensus safety rules while simultaneously manipulating its own metrics to report success, with no independent client-side validation to detect the attack.

## Finding Description

The SafetyRules component is critical to Aptos consensus safety, preventing validators from signing conflicting blocks or votes that would violate BFT invariants. When configured as a remote service (`SafetyRulesService::Process`), it runs in a separate process and communicates over the network.

**Metrics Architecture:**

The metrics emission occurs at multiple layers:

1. **Server-side (Remote SafetyRules Process)**: The `run_and_log` function in `safety_rules.rs` wraps all TSafetyRules method implementations and emits three counter increments per operation: [1](#0-0) 

2. **Client-side (Consensus Node)**: The `SerializerClient` only tracks timing via `counters::start_timer("external", ...)`: [2](#0-1) 

3. **Client-side wrapper**: `MetricsSafetyRules` uses the `monitor!` macro which only creates a timer and gauge for concurrency tracking: [3](#0-2) 

The `monitor!` macro and `OP_COUNTERS` do not track success vs. failure outcomes: [4](#0-3) 

**Attack Scenario:**

If an attacker compromises the remote SafetyRules service process (e.g., through validator operator collusion, RCE, or supply chain attack), they can:

1. Modify the SafetyRules implementation to bypass critical safety checks (e.g., allowing double voting, signing conflicting blocks)
2. Continue calling `counters::increment_query(method, "success")` to maintain the appearance of normal operation
3. Return properly formatted signatures that the consensus node will accept

The consensus node's client-side metrics will show:
- Normal request timing (via `SerializerClient` timers)
- Normal concurrency levels (via `MetricsSafetyRules` gauges)
- No indication that safety rules are being violated

The server-side metrics can be manipulated by the compromised process to show success. There is no independent verification on the client side to detect that safety rules were actually bypassed.

## Impact Explanation

**Severity: Medium**

This meets the Medium severity criteria: "State inconsistencies requiring intervention" and makes detection of safety rule violations significantly harder.

While the attack requires compromising the SafetyRules service process (which is a trusted component), the lack of independent client-side verification metrics means:

1. **Delayed Detection**: Consensus safety violations (double voting, equivocation) may only be detected when they actually break consensus at the network level, rather than being caught immediately through monitoring
2. **Forensics Difficulty**: Post-incident analysis becomes harder when client-side metrics don't independently track operation outcomes
3. **Defense-in-Depth Failure**: The architecture violates defense-in-depth principles by having no independent verification layer

The impact is not Critical because it requires first compromising the SafetyRules process, but it significantly degrades the detection capabilities for such compromises.

## Likelihood Explanation

**Likelihood: Low-Medium**

The likelihood depends on the threat model:
- Requires compromising the SafetyRules service process first (low likelihood for external attackers)
- More feasible for malicious validator operators who control the SafetyRules deployment
- Supply chain attacks could affect multiple validators simultaneously

Once a compromise occurs, the lack of client-side verification makes sustained undetected operation highly likely.

## Recommendation

Implement independent client-side success/failure metrics that cannot be manipulated by a compromised SafetyRules service:

1. **Add client-side outcome tracking to SerializerClient**:
```rust
impl TSafetyRules for SerializerClient {
    fn sign_proposal(&mut self, block_data: &BlockData) -> Result<bls12381::Signature, Error> {
        let _timer = counters::start_timer("external", LogEntry::SignProposal.as_str());
        let response = self.request(SafetyRulesInput::SignProposal(Box::new(block_data.clone())));
        
        // Add independent client-side metrics
        match &response {
            Ok(_) => counters::increment_query("sign_proposal_client", "success"),
            Err(_) => counters::increment_query("sign_proposal_client", "error"),
        }
        
        serde_json::from_slice(&response?)?
    }
    // Similar for other methods...
}
```

2. **Add monitoring alerts** that compare client-side vs server-side success rates to detect anomalies

3. **Consider cryptographic commitments**: Have SafetyRules sign its internal state (last_voted_round, epoch, etc.) with each response, allowing the client to verify state progression independently

## Proof of Concept

**Scenario**: Demonstrating the metrics blind spot

1. Deploy a validator with remote SafetyRules (`SafetyRulesService::Process`)
2. Observe that `aptos_safety_rules_queries{method="sign_proposal",result="success"}` metrics are emitted from the SafetyRules process
3. Observe that client-side only emits `consensus_duration{op="safety_rules"}` timing metrics from `monitor!` macro
4. Simulate a compromised SafetyRules by modifying it to:
   - Skip the `verify_and_update_preferred_round` check
   - Still call `counters::increment_query("sign_proposal", "success")`
   - Return valid signatures
5. Verify that monitoring systems see normal success rates and timing, with no indication of bypassed safety checks
6. The violation is only detected when the consensus network observes conflicting votes, not through SafetyRules metrics

**Note**: This PoC requires modifying the SafetyRules binary to demonstrate the attack, which is consistent with the compromise scenario but makes it impractical to provide runnable code without actually implementing the malicious behavior.

---

**Notes**:

The vulnerability is fundamentally about **observability and detection** rather than direct exploitation. The remote SafetyRules architecture creates a single point of trust where both the safety enforcement AND the metrics reporting are controlled by the same process. This violates defense-in-depth principles and makes compromises harder to detect.

The fix requires adding independent verification metrics on the client side that cannot be manipulated by a compromised SafetyRules service, enabling early detection of safety rule violations through monitoring before they cause consensus-level failures.

### Citations

**File:** consensus/safety-rules/src/safety_rules.rs (L483-500)
```rust
fn run_and_log<F, L, R>(callback: F, log_cb: L, log_entry: LogEntry) -> Result<R, Error>
where
    F: FnOnce() -> Result<R, Error>,
    L: for<'a> Fn(SafetyLogSchema<'a>) -> SafetyLogSchema<'a>,
{
    let _timer = counters::start_timer("internal", log_entry.as_str());
    trace!(log_cb(SafetyLogSchema::new(log_entry, LogEvent::Request)));
    counters::increment_query(log_entry.as_str(), "request");
    callback()
        .inspect(|_v| {
            trace!(log_cb(SafetyLogSchema::new(log_entry, LogEvent::Success)));
            counters::increment_query(log_entry.as_str(), "success");
        })
        .inspect_err(|err| {
            warn!(log_cb(SafetyLogSchema::new(log_entry, LogEvent::Error)).error(err));
            counters::increment_query(log_entry.as_str(), "error");
        })
}
```

**File:** consensus/safety-rules/src/serializer.rs (L104-175)
```rust
impl TSafetyRules for SerializerClient {
    fn consensus_state(&mut self) -> Result<ConsensusState, Error> {
        let _timer = counters::start_timer("external", LogEntry::ConsensusState.as_str());
        let response = self.request(SafetyRulesInput::ConsensusState)?;
        serde_json::from_slice(&response)?
    }

    fn initialize(&mut self, proof: &EpochChangeProof) -> Result<(), Error> {
        let _timer = counters::start_timer("external", LogEntry::Initialize.as_str());
        let response = self.request(SafetyRulesInput::Initialize(Box::new(proof.clone())))?;
        serde_json::from_slice(&response)?
    }

    fn sign_proposal(&mut self, block_data: &BlockData) -> Result<bls12381::Signature, Error> {
        let _timer = counters::start_timer("external", LogEntry::SignProposal.as_str());
        let response =
            self.request(SafetyRulesInput::SignProposal(Box::new(block_data.clone())))?;
        serde_json::from_slice(&response)?
    }

    fn sign_timeout_with_qc(
        &mut self,
        timeout: &TwoChainTimeout,
        timeout_cert: Option<&TwoChainTimeoutCertificate>,
    ) -> Result<bls12381::Signature, Error> {
        let _timer = counters::start_timer("external", LogEntry::SignTimeoutWithQC.as_str());
        let response = self.request(SafetyRulesInput::SignTimeoutWithQC(
            Box::new(timeout.clone()),
            Box::new(timeout_cert.cloned()),
        ))?;
        serde_json::from_slice(&response)?
    }

    fn construct_and_sign_vote_two_chain(
        &mut self,
        vote_proposal: &VoteProposal,
        timeout_cert: Option<&TwoChainTimeoutCertificate>,
    ) -> Result<Vote, Error> {
        let _timer =
            counters::start_timer("external", LogEntry::ConstructAndSignVoteTwoChain.as_str());
        let response = self.request(SafetyRulesInput::ConstructAndSignVoteTwoChain(
            Box::new(vote_proposal.clone()),
            Box::new(timeout_cert.cloned()),
        ))?;
        serde_json::from_slice(&response)?
    }

    fn construct_and_sign_order_vote(
        &mut self,
        order_vote_proposal: &OrderVoteProposal,
    ) -> Result<OrderVote, Error> {
        let _timer =
            counters::start_timer("external", LogEntry::ConstructAndSignOrderVote.as_str());
        let response = self.request(SafetyRulesInput::ConstructAndSignOrderVote(Box::new(
            order_vote_proposal.clone(),
        )))?;
        serde_json::from_slice(&response)?
    }

    fn sign_commit_vote(
        &mut self,
        ledger_info: LedgerInfoWithSignatures,
        new_ledger_info: LedgerInfo,
    ) -> Result<bls12381::Signature, Error> {
        let _timer = counters::start_timer("external", LogEntry::SignCommitVote.as_str());
        let response = self.request(SafetyRulesInput::SignCommitVote(
            Box::new(ledger_info),
            Box::new(new_ledger_info),
        ))?;
        serde_json::from_slice(&response)?
    }
}
```

**File:** consensus/src/lib.rs (L94-101)
```rust
macro_rules! monitor {
    ($name:literal, $fn:expr) => {{
        use $crate::{counters::OP_COUNTERS, IntGaugeGuard};
        let _timer = OP_COUNTERS.timer($name);
        let _guard = IntGaugeGuard::new(OP_COUNTERS.gauge(concat!($name, "_running")));
        $fn
    }};
}
```

**File:** crates/aptos-metrics-core/src/op_counters.rs (L38-133)
```rust
pub struct OpMetrics {
    counters: IntCounterVec,
    gauges: IntGaugeVec,
    peer_gauges: IntGaugeVec,
    duration_histograms: HistogramVec,
}

impl OpMetrics {
    pub fn new<S: Into<String>>(name: S) -> OpMetrics {
        let name_str = name.into();
        OpMetrics {
            counters: IntCounterVec::new(
                Opts::new(name_str.clone(), format!("Counters for {}", name_str)),
                &["op"],
            )
            .unwrap(),
            gauges: IntGaugeVec::new(
                Opts::new(
                    format!("{}_gauge", name_str),
                    format!("Gauges for {}", name_str),
                ),
                &["op"],
            )
            .unwrap(),
            peer_gauges: IntGaugeVec::new(
                Opts::new(
                    format!("{}_peer_gauge", name_str),
                    format!("Gauges of each remote peer for {}", name_str),
                ),
                &["op", "remote_peer_id"],
            )
            .unwrap(),
            duration_histograms: HistogramVec::new(
                HistogramOpts::new(
                    format!("{}_duration", name_str),
                    format!("Histogram values for {}", name_str),
                ),
                &["op"],
            )
            .unwrap(),
        }
    }

    pub fn new_and_registered<S: Into<String>>(name: S) -> OpMetrics {
        let op_metrics = OpMetrics::new(name);
        prometheus::register(Box::new(op_metrics.clone()))
            .expect("OpMetrics registration on Prometheus failed.");
        op_metrics
    }

    #[inline]
    pub fn gauge(&self, name: &str) -> IntGauge {
        self.gauges.with_label_values(&[name])
    }

    #[inline]
    pub fn peer_gauge(&self, name: &str, remote_peer_id: &str) -> IntGauge {
        self.peer_gauges.with_label_values(&[name, remote_peer_id])
    }

    #[inline]
    pub fn inc(&self, op: &str) {
        self.counters.with_label_values(&[op]).inc();
    }

    #[inline]
    pub fn inc_by(&self, op: &str, v: usize) {
        // The underlying method is expecting i64, but most of the types
        // we're going to log are `u64` or `usize`.
        self.counters.with_label_values(&[op]).inc_by(v as u64);
    }

    #[inline]
    pub fn set(&self, op: &str, v: usize) {
        // The underlying method is expecting i64, but most of the types
        // we're going to log are `u64` or `usize`.
        self.gauges.with_label_values(&[op]).set(v as i64);
    }

    #[inline]
    pub fn observe(&self, op: &str, v: f64) {
        self.duration_histograms.with_label_values(&[op]).observe(v);
    }

    pub fn observe_duration(&self, op: &str, d: Duration) {
        // Duration is full seconds + nanos elapsed from the previous full second
        let v = d.as_secs() as f64 + f64::from(d.subsec_nanos()) / 1e9;
        self.duration_histograms.with_label_values(&[op]).observe(v);
    }

    pub fn timer(&self, op: &str) -> HistogramTimer {
        self.duration_histograms
            .with_label_values(&[op])
            .start_timer()
    }
}
```
