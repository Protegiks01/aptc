# Audit Report

## Title
Missing Gas Schedule Parameter Validation Enables Network-Wide Liveness Failure

## Summary
The `generate_gas_upgrade_proposal()` function lacks validation to ensure all required gas parameters are present in the gas schedule before creating a governance proposal. Deploying an incomplete gas schedule causes all validators to fail transaction execution with `VM_STARTUP_FAILURE`, resulting in total network halt requiring hardfork recovery.

## Finding Description

The `generate_gas_upgrade_proposal()` function in `gas.rs` accepts a `GasScheduleV2` object and generates a governance proposal to update the on-chain gas schedule without validating parameter completeness. [1](#0-0) 

When the proposal executes successfully and triggers epoch transition, the incomplete gas schedule becomes active. Subsequently, when any transaction attempts execution, the VM tries to load gas parameters: [2](#0-1) 

The gas parameter loading uses the `FromOnChainGasSchedule` trait, which attempts to retrieve each required parameter. If any parameter is missing, it returns an error: [3](#0-2) 

This error is converted to `VM_STARTUP_FAILURE` by the helper function: [4](#0-3) 

Once this occurs, ALL transactions (including governance proposals to fix the issue) are discarded, causing complete network halt. The Move framework code contains TODO comments acknowledging this missing validation: [5](#0-4) 

The same TODO appears at lines 67 and 75, indicating this validation gap was recognized but never implemented.

**Attack Path:**
1. A governance proposal is created (accidentally or maliciously) with incomplete gas schedule missing critical parameters like "instr.add", "instr.mul", or "call.base"
2. Proposal passes governance voting and calls `set_for_next_epoch_check_hash()` or `set_for_next_epoch()`
3. The incomplete schedule is buffered via `config_buffer::upsert()`
4. `aptos_governance::reconfigure()` triggers epoch transition
5. During next epoch, `on_new_epoch()` applies the incomplete schedule: [6](#0-5) 

6. All subsequent transactions fail at VM initialization when gas parameter loading returns error
7. Network is completely halted - no transactions can execute on any validator

This breaks Critical Invariant #9 (Resource Limits) and Invariant #3 (Move VM Safety) as the VM cannot even initialize to enforce gas limits.

## Impact Explanation

**Severity: CRITICAL** (up to $1,000,000 per bug bounty program)

This vulnerability qualifies as "Total loss of liveness/network availability" and "Non-recoverable network partition (requires hardfork)" because:

1. **Complete Network Halt**: All validators deterministically fail to execute ANY transaction with `VM_STARTUP_FAILURE`
2. **Self-Perpetuating**: Governance proposals to fix the issue cannot execute because they also require gas parameter loading
3. **Requires Hardfork**: Recovery requires manual intervention using genesis transactions and database bootstrapping, coordinating all validators to restart with new waypoint
4. **Affects All Users**: No transactions can be processed - all transfers, contract calls, and governance operations are blocked
5. **Deterministic Failure**: All validators will exhibit identical behavior, maintaining consensus on the halted state

The existing test demonstrates this behavior: [7](#0-6) 

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH**

This vulnerability can manifest through:

1. **Accidental Misconfiguration**: Developer error when generating gas schedules (copy-paste errors, incomplete parameter sets, script bugs)
2. **Malicious Governance Proposal**: Single malicious governance participant with sufficient voting power
3. **Software Bugs**: Automated gas schedule generation tools with bugs could produce incomplete schedules

The TODO comments at three locations in `gas_schedule.move` indicate developers were aware validation was needed but never implemented it, suggesting this was considered a real risk.

Unlike 51% attacks (excluded from scope), this requires only:
- Governance proposal submission capability (requires stake but not majority)
- Proposal approval through normal voting (not requiring attack coordination)
- No validator insider access or collusion needed

## Recommendation

Implement comprehensive gas schedule validation before proposal creation and during on-chain updates:

**1. Add validation in `generate_gas_upgrade_proposal()`:**

```rust
pub fn generate_gas_upgrade_proposal(
    old_gas_schedule: Option<&GasScheduleV2>,
    new_gas_schedule: &GasScheduleV2,
    is_testnet: bool,
    next_execution_hash: Option<HashValue>,
    is_multi_step: bool,
) -> Result<Vec<(String, String)>> {
    // VALIDATE COMPLETENESS
    let gas_schedule_map = new_gas_schedule.to_btree_map_borrowed();
    let validation_result = AptosGasParameters::from_on_chain_gas_schedule(
        &new_gas_schedule.entries.iter().map(|(k,v)| (k.clone(), *v)).collect(),
        new_gas_schedule.feature_version
    );
    
    if let Err(err) = validation_result {
        anyhow::bail!("Gas schedule validation failed: {}", err);
    }
    
    // ... rest of existing code
}
```

**2. Add validation in Move framework `set_for_next_epoch()` and `set_for_next_epoch_check_hash()`:**

Replace TODO comments with actual consistency checks that verify all expected parameter keys exist for the given feature version.

**3. Add smoke tests** that verify complete gas schedules before deployment to testnet/mainnet.

## Proof of Concept

The existing test already demonstrates the vulnerability: [7](#0-6) 

**Steps to reproduce network halt scenario:**

1. Create test harness with governance capability
2. Generate gas schedule with missing "instr.add" parameter
3. Submit governance proposal with incomplete schedule
4. Vote to approve proposal
5. Execute proposal and trigger reconfiguration
6. Attempt to execute any subsequent transaction
7. Observe: Transaction rejected with `VM_STARTUP_FAILURE`
8. Verify: ALL transaction types fail, including governance proposals

The test confirms transactions are discarded with `StatusCode::VM_STARTUP_FAILURE`, matching the expected behavior when gas parameters fail to load.

## Notes

This vulnerability exists due to the incomplete implementation of validation that was explicitly marked with TODO comments in the gas schedule module. The impact is deterministic across all validators, meaning the network will halt uniformly rather than causing consensus divergence. Recovery requires coordinated hardfork procedures involving genesis transaction generation, database bootstrapping, and validator coordination - a complex manual process documented in the testsuite's genesis recovery tests.

### Citations

**File:** aptos-move/aptos-release-builder/src/components/gas.rs (L80-155)
```rust
pub fn generate_gas_upgrade_proposal(
    old_gas_schedule: Option<&GasScheduleV2>,
    new_gas_schedule: &GasScheduleV2,
    is_testnet: bool,
    next_execution_hash: Option<HashValue>,
    is_multi_step: bool,
) -> Result<Vec<(String, String)>> {
    let signer_arg = get_signer_arg(is_testnet, &next_execution_hash);
    let mut result = vec![];

    let writer = CodeWriter::new(Loc::default());

    emitln!(
        writer,
        "// Source commit hash: {}",
        aptos_build_info::get_git_hash()
    );
    emitln!(writer);

    emitln!(writer, "// Gas schedule upgrade proposal");

    let old_hash = match old_gas_schedule {
        Some(old_gas_schedule) => {
            let old_bytes = bcs::to_bytes(old_gas_schedule)?;
            let old_hash = hex::encode(Sha3_512::digest(old_bytes.as_slice()));
            emitln!(writer, "//");
            emitln!(writer, "// Old Gas Schedule Hash (Sha3-512): {}", old_hash);

            emit_gas_schedule_diff(&writer, old_gas_schedule, new_gas_schedule)?;

            Some(old_hash)
        },
        None => None,
    };
    emitln!(writer, "//");
    emit_full_gas_schedule(&writer, new_gas_schedule)?;

    let proposal = generate_governance_proposal(
        &writer,
        is_testnet,
        next_execution_hash,
        is_multi_step,
        &["aptos_framework::gas_schedule"],
        |writer| {
            let gas_schedule_blob = bcs::to_bytes(new_gas_schedule).unwrap();
            assert!(gas_schedule_blob.len() < 65536);

            emit!(writer, "let gas_schedule_blob: vector<u8> = ");
            generate_blob_as_hex_string(writer, &gas_schedule_blob);
            emitln!(writer, ";");
            emitln!(writer);

            match old_hash {
                Some(old_hash) => {
                    emitln!(
                        writer,
                        "gas_schedule::set_for_next_epoch_check_hash({}, x\"{}\", gas_schedule_blob);",
                        signer_arg,
                        old_hash,
                    );
                },
                None => {
                    emitln!(
                        writer,
                        "gas_schedule::set_for_next_epoch({}, gas_schedule_blob);",
                        signer_arg
                    );
                },
            }
            emitln!(writer, "aptos_governance::reconfigure({});", signer_arg);
        },
    );

    result.push(("gas-schedule".to_string(), proposal));
    Ok(result)
}
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L273-282)
```rust
pub(crate) fn get_or_vm_startup_failure<'a, T>(
    gas_params: &'a Result<T, String>,
    log_context: &AdapterLogSchema,
) -> Result<&'a T, VMStatus> {
    gas_params.as_ref().map_err(|err| {
        let msg = format!("VM Startup Failed. {}", err);
        speculative_error!(log_context, msg.clone());
        VMStatus::error(StatusCode::VM_STARTUP_FAILURE, Some(msg))
    })
}
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L2147-2160)
```rust
        let vm_params = self.gas_params(log_context)?.vm.clone();

        let initial_balance = if self.features().is_account_abstraction_enabled()
            || self.features().is_derivable_account_abstraction_enabled()
        {
            vm_params.txn.max_aa_gas.min(txn.max_gas_amount().into())
        } else {
            txn.max_gas_amount().into()
        };

        let mut gas_meter = make_gas_meter(
            self.gas_feature_version(),
            vm_params,
            self.storage_gas_params(log_context)?.clone(),
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/macros.rs (L38-42)
```rust
                    if let Some(key) = $crate::gas_schedule::macros::define_gas_parameters_extract_key_at_version!($key_bindings, feature_version) {
                        let name = format!("{}.{}", $prefix, key);
                        params.$name = gas_schedule.get(&name).cloned().ok_or_else(|| format!("Gas parameter {} does not exist. Feature version: {}.", name, feature_version))?.into();
                    }
                )*
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L47-48)
```text
        // TODO(Gas): check if gas schedule is consistent
        let gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L135-145)
```text
    public(friend) fun on_new_epoch(framework: &signer) acquires GasScheduleV2 {
        system_addresses::assert_aptos_framework(framework);
        if (config_buffer::does_exist<GasScheduleV2>()) {
            let new_gas_schedule = config_buffer::extract_v2<GasScheduleV2>();
            if (exists<GasScheduleV2>(@aptos_framework)) {
                *borrow_global_mut<GasScheduleV2>(@aptos_framework) = new_gas_schedule;
            } else {
                move_to(framework, new_gas_schedule);
            }
        }
    }
```

**File:** aptos-move/e2e-move-tests/src/tests/missing_gas_parameter.rs (L8-28)
```rust
#[test]
fn missing_gas_parameter() {
    let mut h = MoveHarness::new();

    h.modify_gas_schedule_raw(|gas_schedule| {
        let idx = gas_schedule
            .entries
            .iter()
            .position(|(key, _val)| key == "instr.add")
            .unwrap();
        gas_schedule.entries.remove(idx);
    });

    // Load the code
    let acc = h.new_account_with_balance_at(AccountAddress::from_hex_literal("0xbeef").unwrap(), 0);
    let txn_status = h.publish_package(&acc, &common::test_dir_path("common.data/do_nothing"));
    assert!(matches!(
        txn_status,
        TransactionStatus::Discard(StatusCode::VM_STARTUP_FAILURE)
    ))
}
```
