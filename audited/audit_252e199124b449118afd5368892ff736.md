# Audit Report

## Title
Configuration-Dependent Internal Indexer Metadata Inconsistency Leading to Permanent Node Startup Failure

## Summary
The `kv_finish()` function in `state_store/mod.rs` conditionally writes internal indexer metadata (StateVersion, TransactionVersion, EventVersion) based on runtime configuration flags, while always writing LatestVersion. Configuration changes between node restarts can create permanently inconsistent metadata that causes node startup to panic with no automatic recovery mechanism, requiring manual database repair or complete resync.

## Finding Description

The vulnerability exists in the conditional metadata writes within the `kv_finish()` function: [1](#0-0) 

The function writes metadata to the internal indexer database based on which indexers are enabled in the configuration: [2](#0-1) 

While LatestVersion is always written, StateVersion, TransactionVersion, and EventVersion are only written if their respective indexers are enabled via configuration: [3](#0-2) 

During node startup, the internal indexer service validates that all enabled indexer types have matching version progress, and panics if they don't match: [4](#0-3) 

**Attack Scenario:**

1. Node operator runs validator with indexer configuration: `enable_statekeys=true, enable_transaction=true, enable_event=true`
2. State snapshot restore completes at version 1000, `kv_finish(version=1000)` writes all four metadata values: LatestVersion=999, StateVersion=999, TransactionVersion=999, EventVersion=999
3. Node operator modifies configuration (intentionally or accidentally) and restarts with: `enable_statekeys=false, enable_transaction=false, enable_event=true`
4. Node processes more data, `kv_finish(version=2000)` is called
5. This write only updates LatestVersion=1999 and EventVersion=1999, leaving StateVersion=999 and TransactionVersion=999 unchanged
6. Node operator realizes the misconfiguration and changes config back to enable all indexers
7. On restart, `get_start_version()` compares versions and finds mismatches
8. Node panics: "Cannot start state indexer because the progress doesn't match"
9. Node is permanently unable to start without manual database intervention

This breaks the **State Consistency** invariant - the indexer metadata is in an inconsistent state that prevents normal operation.

## Impact Explanation

This is a **HIGH severity** issue per Aptos bug bounty criteria due to:

1. **Validator Node Unavailability**: The affected node cannot start and provide validation services, directly impacting network participation
2. **No Automatic Recovery**: There is no built-in recovery mechanism; manual database repair or complete resync is required
3. **Significant Protocol Violation**: The internal indexer is critical infrastructure for state synchronization and API services
4. **Operator Error Amplification**: A simple configuration mistake during troubleshooting or upgrades can permanently brick a node

While not reaching Critical severity (no consensus break or fund loss), this represents a significant operational risk that can lead to prolonged validator downtime and potential network degradation if multiple operators make similar configuration mistakes.

## Likelihood Explanation

**Medium-High Likelihood:**

1. **Realistic Trigger**: Node operators commonly modify indexer configurations during:
   - Performance tuning to disable unused indexers
   - Troubleshooting issues by selectively enabling/disabling features
   - Upgrades that change default configuration values
   - Storage optimization to reduce disk usage

2. **No Validation**: The code lacks configuration consistency checks across restarts. The sanitizer only checks if sharding is enabled, not metadata consistency: [5](#0-4) 

3. **Silent Corruption**: The metadata becomes inconsistent silently during normal operation, only manifesting as a panic on the next configuration change

4. **No Warning**: There are no warnings or guards preventing configuration changes that would create inconsistent state

## Recommendation

Implement metadata consistency checks and recovery mechanisms:

**Option 1: Prevent Inconsistent Configuration Changes**
- Add validation that prevents disabling an indexer if its metadata exists in the database
- Require explicit `--force-indexer-reset` flag to allow disabling, which clears associated metadata

**Option 2: Write All Metadata Regardless of Configuration**
- Always write all four metadata values in `kv_finish()`, removing the conditional logic
- This ensures metadata stays consistent even if configuration changes
- Disabled indexers simply won't process new data, but their metadata tracking remains intact

**Option 3: Add Recovery on Startup**
- Detect metadata version mismatches during startup
- Automatically sync stale metadata values to match LatestVersion
- Log a warning but allow the node to continue

**Recommended Fix (Option 2):**

```rust
fn kv_finish(&self, version: Version, usage: StateStorageUsage) -> Result<()> {
    self.ledger_db.metadata_db().put_usage(version, usage)?;
    if let Some(internal_indexer_db) = self.internal_indexer_db.as_ref() {
        if version > 0 {
            let mut batch = SchemaBatch::new();
            // Always write all metadata to maintain consistency
            batch.put::<InternalIndexerMetadataSchema>(
                &MetadataKey::LatestVersion,
                &MetadataValue::Version(version - 1),
            )?;
            batch.put::<InternalIndexerMetadataSchema>(
                &MetadataKey::StateVersion,
                &MetadataValue::Version(version - 1),
            )?;
            batch.put::<InternalIndexerMetadataSchema>(
                &MetadataKey::TransactionVersion,
                &MetadataValue::Version(version - 1),
            )?;
            batch.put::<InternalIndexerMetadataSchema>(
                &MetadataKey::EventVersion,
                &MetadataValue::Version(version - 1),
            )?;
            internal_indexer_db
                .get_inner_db_ref()
                .write_schemas(batch)?;
        }
    }
    Ok(())
}
```

Additionally, add a configuration validator:

```rust
// In config sanitizer
fn validate_indexer_config_consistency(
    existing_metadata: &InternalIndexerMetadata,
    new_config: &InternalIndexerDBConfig,
) -> Result<(), Error> {
    if existing_metadata.state_version.is_some() && !new_config.enable_statekeys {
        return Err(Error::ConfigSanitizerFailed(
            "indexer_config",
            "Cannot disable statekeys indexer with existing metadata. Use --force-indexer-reset to clear.".into(),
        ));
    }
    // Similar checks for transaction and event indexers
    Ok(())
}
```

## Proof of Concept

```rust
// Reproduction test demonstrating the vulnerability
#[test]
fn test_indexer_metadata_inconsistency_on_config_change() {
    use aptos_config::config::InternalIndexerDBConfig;
    use aptos_db_indexer_schemas::metadata::MetadataKey;
    use aptos_schemadb::SchemaBatch;
    
    // Step 1: Initialize node with all indexers enabled
    let mut config = InternalIndexerDBConfig::default();
    config.enable_statekeys = true;
    config.enable_transaction = true;
    config.enable_event = true;
    
    let (db, state_store) = setup_test_db_with_config(config);
    
    // Step 2: Complete state restore at version 1000
    state_store.kv_finish(1000, StateStorageUsage::new_untracked()).unwrap();
    
    // Verify all metadata is written
    let indexer_db = state_store.internal_indexer_db.as_ref().unwrap();
    assert_eq!(indexer_db.get_persisted_version().unwrap(), Some(999));
    assert_eq!(indexer_db.get_state_version().unwrap(), Some(999));
    assert_eq!(indexer_db.get_transaction_version().unwrap(), Some(999));
    assert_eq!(indexer_db.get_event_version().unwrap(), Some(999));
    
    // Step 3: Simulate config change - disable statekeys and transaction indexers
    drop(state_store);
    let mut new_config = InternalIndexerDBConfig::default();
    new_config.enable_statekeys = false;  // DISABLED
    new_config.enable_transaction = false; // DISABLED
    new_config.enable_event = true;
    
    let state_store = reopen_db_with_config(db, new_config);
    
    // Step 4: Process more data
    state_store.kv_finish(2000, StateStorageUsage::new_untracked()).unwrap();
    
    // Step 5: Verify metadata is now inconsistent
    let indexer_db = state_store.internal_indexer_db.as_ref().unwrap();
    assert_eq!(indexer_db.get_persisted_version().unwrap(), Some(1999)); // Updated
    assert_eq!(indexer_db.get_state_version().unwrap(), Some(999));      // STALE!
    assert_eq!(indexer_db.get_transaction_version().unwrap(), Some(999)); // STALE!
    assert_eq!(indexer_db.get_event_version().unwrap(), Some(1999));     // Updated
    
    // Step 6: Attempt to restart with all indexers enabled again
    drop(state_store);
    let mut final_config = InternalIndexerDBConfig::default();
    final_config.enable_statekeys = true;
    final_config.enable_transaction = true;
    final_config.enable_event = true;
    
    // Step 7: This should panic in get_start_version()
    let result = std::panic::catch_unwind(|| {
        let service = InternalIndexerDBService::new(db, final_config);
        service.get_start_version(&node_config).await
    });
    
    // Verify the panic occurred
    assert!(result.is_err(), "Expected panic due to version mismatch");
    
    // The node is now permanently unable to start without manual intervention
}
```

## Notes

The vulnerability is particularly insidious because:

1. The metadata inconsistency occurs silently during normal operation
2. The failure only manifests on the next configuration change that re-enables disabled indexers
3. There's no warning or validation to prevent the problematic configuration sequence
4. Recovery requires expert knowledge of the internal database schema

This represents a violation of the **State Consistency** invariant and demonstrates how configuration-dependent conditional writes can create persistent corruption in distributed systems.

### Citations

**File:** storage/aptosdb/src/state_store/mod.rs (L1281-1315)
```rust
    fn kv_finish(&self, version: Version, usage: StateStorageUsage) -> Result<()> {
        self.ledger_db.metadata_db().put_usage(version, usage)?;
        if let Some(internal_indexer_db) = self.internal_indexer_db.as_ref() {
            if version > 0 {
                let mut batch = SchemaBatch::new();
                batch.put::<InternalIndexerMetadataSchema>(
                    &MetadataKey::LatestVersion,
                    &MetadataValue::Version(version - 1),
                )?;
                if internal_indexer_db.statekeys_enabled() {
                    batch.put::<InternalIndexerMetadataSchema>(
                        &MetadataKey::StateVersion,
                        &MetadataValue::Version(version - 1),
                    )?;
                }
                if internal_indexer_db.transaction_enabled() {
                    batch.put::<InternalIndexerMetadataSchema>(
                        &MetadataKey::TransactionVersion,
                        &MetadataValue::Version(version - 1),
                    )?;
                }
                if internal_indexer_db.event_enabled() {
                    batch.put::<InternalIndexerMetadataSchema>(
                        &MetadataKey::EventVersion,
                        &MetadataValue::Version(version - 1),
                    )?;
                }
                internal_indexer_db
                    .get_inner_db_ref()
                    .write_schemas(batch)?;
            }
        }

        Ok(())
    }
```

**File:** config/src/config/internal_indexer_db_config.rs (L10-19)
```rust
#[derive(Clone, Copy, Debug, Deserialize, PartialEq, Eq, Serialize)]
#[serde(default, deny_unknown_fields)]
pub struct InternalIndexerDBConfig {
    pub enable_transaction: bool,
    pub enable_event: bool,
    pub enable_event_v2_translation: bool,
    pub event_v2_translation_ignores_below_version: u64,
    pub enable_statekeys: bool,
    pub batch_size: usize,
}
```

**File:** config/src/config/internal_indexer_db_config.rs (L82-99)
```rust
impl ConfigSanitizer for InternalIndexerDBConfig {
    fn sanitize(
        node_config: &NodeConfig,
        _node_type: NodeType,
        _chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();
        let config = node_config.indexer_db_config;

        // Shouldn't turn on internal indexer for db without sharding
        if !node_config.storage.rocksdb_configs.enable_storage_sharding
            && config.is_internal_indexer_db_enabled()
        {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "Don't turn on internal indexer db if DB sharding is off".into(),
            ));
        }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-table-info/src/internal_indexer_db_service.rs (L102-139)
```rust
        let start_version = self
            .db_indexer
            .indexer_db
            .get_persisted_version()?
            .map_or(0, |v| v + 1);

        if node_config.indexer_db_config.enable_statekeys() {
            let state_start_version = self
                .db_indexer
                .indexer_db
                .get_state_version()?
                .map_or(0, |v| v + 1);
            if start_version != state_start_version {
                panic!("Cannot start state indexer because the progress doesn't match.");
            }
        }

        if node_config.indexer_db_config.enable_transaction() {
            let transaction_start_version = self
                .db_indexer
                .indexer_db
                .get_transaction_version()?
                .map_or(0, |v| v + 1);
            if start_version != transaction_start_version {
                panic!("Cannot start transaction indexer because the progress doesn't match.");
            }
        }

        if node_config.indexer_db_config.enable_event() {
            let event_start_version = self
                .db_indexer
                .indexer_db
                .get_event_version()?
                .map_or(0, |v| v + 1);
            if start_version != event_start_version {
                panic!("Cannot start event indexer because the progress doesn't match.");
            }
        }
```
