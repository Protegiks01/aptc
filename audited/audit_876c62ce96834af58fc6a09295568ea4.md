# Audit Report

## Title
Inbound Connection Limit Bypass via Incorrect PeerRole Assignment on VFN Network

## Summary
Validators on the VFN (Validator Full Node) network incorrectly assign `PeerRole::ValidatorFullNode` to untrusted inbound peers through role inference logic, causing these connections to bypass inbound connection limits. This allows attackers to exhaust validator resources through connection flooding attacks.

## Finding Description

The vulnerability stems from a logic mismatch between the role assignment in the Noise handshake layer and the security assumptions in the peer manager layer.

**In the Noise handshake layer**, when a validator receives an inbound connection on the VFN network using `MaybeMutual` authentication mode, untrusted peers (not in `trusted_peers`) are assigned `PeerRole::ValidatorFullNode` through role inference logic. [1](#0-0) 

The code explicitly infers that any inbound connection to a validator on the VFN network must be from a ValidatorFullNode, regardless of whether the peer is in the trusted peers set.

**In the peer manager layer**, the `handle_new_connection_event` function contains logic to enforce inbound connection limits for unknown peers. However, it explicitly checks if `conn.metadata.role == PeerRole::Unknown` before applying these limits: [2](#0-1) 

The code comment states: "Everything below here is meant for unknown peers only. The role comes from the Noise handshake and if it's not `Unknown` then it is trusted." This assumption is **incorrect** because roles can be assigned via inference (not just from `trusted_peers`).

The connection limit enforcement logic is only executed when the role is `Unknown`: [3](#0-2) 

**Attack Scenario:**
1. Attacker discovers a validator's VFN network address (exposed on port 6181 in Docker deployments)
2. Attacker connects to the validator on the VFN network
3. Attacker completes the Noise handshake with any keypair (not in `trusted_peers`)
4. The validator assigns `PeerRole::ValidatorFullNode` via inference logic
5. In `handle_new_connection_event`, the check `conn.metadata.role == PeerRole::Unknown` fails
6. The connection limit enforcement block is **completely skipped**
7. Attacker repeats steps 2-6 to create unlimited connections, bypassing the `inbound_connection_limit`

## Impact Explanation

This vulnerability enables **connection exhaustion attacks** against validators, which qualifies as **High Severity** per the Aptos bug bounty program category "Validator node slowdowns" with "DoS through resource exhaustion."

An attacker can:
- Exhaust file descriptors (each TCP connection consumes one)
- Consume memory (each connection maintains state)
- Degrade validator performance through connection management overhead
- Potentially trigger out-of-memory conditions or system instability
- Impact consensus participation if the validator becomes overloaded

The default `MAX_INBOUND_CONNECTIONS` is set to 100 connections to prevent resource exhaustion, but this protection is completely bypassed for VFN network connections from untrusted peers. [4](#0-3) 

## Likelihood Explanation

**Likelihood: High**

Requirements for exploitation:
- Knowledge of validator's VFN network address (VFN network binds to port 6181 and is exposed in Docker deployments)
- Ability to establish TCP connections to the VFN network port
- Ability to complete the Noise handshake protocol (standard cryptographic operation)

No special privileges, validator insider access, or complex exploitation techniques are required. The VFN network uses `MaybeMutual` authentication mode by design, which explicitly allows connections from any peer: [5](#0-4) 

The VFN network is accessible in standard deployments as port 6181 is exposed externally to allow validator fullnodes to connect.

## Recommendation

Modify the peer manager's connection limit logic to apply limits to **all** untrusted inbound peers, not just those with `PeerRole::Unknown`. The check should verify if the peer is in the `trusted_peers` set rather than relying solely on the role assignment:

```rust
// In handle_new_connection_event
if conn.metadata.origin == ConnectionOrigin::Inbound {
    // Check if peer is actually trusted (in trusted_peers set)
    // rather than just checking the role
    let is_trusted = trusted_peers.get(&conn.metadata.remote_peer_id).is_some();
    
    if !is_trusted {
        // Apply connection limits to all untrusted peers
        // regardless of their assigned role
        let unknown_inbound_conns = self.active_peers
            .iter()
            .filter(|(peer_id, (metadata, _))| {
                metadata.origin == ConnectionOrigin::Inbound
                    && trusted_peers.get(peer_id).is_none()
            })
            .count();
            
        if unknown_inbound_conns + 1 > self.inbound_connection_limit {
            // Reject connection
        }
    }
}
```

Additionally, the role inference logic in the Noise handshake layer should be reconsidered, or connection limits should be enforced before role assignment completes.

## Proof of Concept

The vulnerability can be demonstrated by:
1. Setting up a validator node with VFN network enabled
2. Connecting multiple untrusted peers to the VFN network port (6181)
3. Observing that connections are accepted beyond the `max_inbound_connections` limit
4. Monitoring resource consumption (file descriptors, memory) increases without bound

Existing test coverage validates the intended behavior: [6](#0-5) 

This test explicitly validates that untrusted VFN connections receive `PeerRole::ValidatorFullNode` via inference, confirming the vulnerability exists as designed.

## Notes

This vulnerability represents a defense-in-depth failure where the application layer relies solely on network-layer security (firewall rules, network segmentation) to prevent untrusted peers from accessing the VFN network. While the VFN network is intended for semi-private use, the application should enforce connection limits for all untrusted peers regardless of network assumptions.

The vulnerability is in-scope as it affects core network layer security controls and enables resource exhaustion attacks against validators, falling under the "Validator Node Slowdowns" category of the Aptos bug bounty program.

### Citations

**File:** network/framework/src/noise/handshake.rs (L95-98)
```rust
    /// In `MaybeMutual` mode, the dialer authenticates the server and the server will allow all
    /// inbound connections from any peer but will mark connections as `Trusted` if the incoming
    /// connection is apart of its trusted peers set.
    MaybeMutual(Arc<PeersAndMetadata>),
```

**File:** network/framework/src/noise/handshake.rs (L407-410)
```rust
                            if self.network_context.role().is_validator() {
                                if network_id.is_vfn_network() {
                                    // Inbound connections to validators on the VFN network must be VFNs
                                    Ok(PeerRole::ValidatorFullNode)
```

**File:** network/framework/src/noise/handshake.rs (L970-973)
```rust
            let (_, peer_id, peer_role) = server.upgrade_inbound(listener_socket).await.unwrap();
            assert_eq!(peer_id, client_peer_id);
            assert_eq!(peer_role, PeerRole::ValidatorFullNode);
        };
```

**File:** network/framework/src/peer_manager/mod.rs (L353-355)
```rust
            // Everything below here is meant for unknown peers only. The role comes from
            // the Noise handshake and if it's not `Unknown` then it is trusted.
            if conn.metadata.role == PeerRole::Unknown {
```

**File:** network/framework/src/peer_manager/mod.rs (L358-389)
```rust
                let unknown_inbound_conns = self
                    .active_peers
                    .iter()
                    .filter(|(peer_id, (metadata, _))| {
                        metadata.origin == ConnectionOrigin::Inbound
                            && trusted_peers
                                .get(peer_id)
                                .is_none_or(|peer| peer.role == PeerRole::Unknown)
                    })
                    .count();

                // Reject excessive inbound connections made by unknown peers
                // We control outbound connections with Connectivity manager before we even send them
                // and we must allow connections that already exist to pass through tie breaking.
                if !self
                    .active_peers
                    .contains_key(&conn.metadata.remote_peer_id)
                    && unknown_inbound_conns + 1 > self.inbound_connection_limit
                {
                    info!(
                        NetworkSchema::new(&self.network_context)
                            .connection_metadata_with_address(&conn.metadata),
                        "{} Connection rejected due to connection limit: {}",
                        self.network_context,
                        conn.metadata
                    );
                    counters::connections_rejected(&self.network_context, conn.metadata.origin)
                        .inc();
                    self.disconnect(conn);
                    return;
                }
            }
```

**File:** config/src/config/network_config.rs (L44-44)
```rust
pub const MAX_INBOUND_CONNECTIONS: usize = 100;
```
