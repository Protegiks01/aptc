# Audit Report

## Title
Critical Epoch Validation Bypass in Transaction Restore Allowing Unauthorized Block Injection

## Summary
The transaction restore functionality in `LoadedChunk::load()` allows complete bypass of epoch-level validation and signature verification when `epoch_history` is `None`. This enables an attacker with control over backup storage to inject fabricated blockchain data with fake ledger infos, unauthorized epochs, and invalid validator signatures, leading to complete state corruption and consensus violations.

## Finding Description

The vulnerability exists in the transaction backup restore flow where critical security validation is conditionally skipped.

**The Vulnerable Code Path:**

In `LoadedChunk::load()`, epoch validation occurs only when `epoch_history` is `Some`: [1](#0-0) 

However, when operators use the oneoff transaction restore command via db-tool, `epoch_history` is explicitly passed as `None`: [2](#0-1) 

**What Critical Validation is Bypassed:**

When `epoch_history.verify_ledger_info()` is skipped, the following critical security checks are bypassed:

1. **Signature Verification**: `EpochState::verify()` validates ledger info signatures against the authorized validator set: [3](#0-2) 

2. **Epoch Authorization**: The verification ensures the ledger info is from the correct epoch with authorized validators: [4](#0-3) 

3. **Validator Set Chain of Trust**: For non-genesis epochs, validation retrieves the previous epoch's `next_epoch_state()` which contains the authorized validator set for the current epoch, ensuring the chain of validator transitions is cryptographically valid.

**Insufficient Remaining Validation:**

After the epoch validation is skipped, only Merkle proof validation occurs: [5](#0-4) 

This verification chain only validates that transactions are part of the accumulator referenced by the ledger info: [6](#0-5) 

The proof verification only checks Merkle inclusion, not ledger info authenticity: [7](#0-6) 

**Attack Scenario:**

1. Attacker compromises or controls the backup storage
2. Attacker creates malicious backup containing:
   - Fabricated `LedgerInfoWithSignatures` with fake/missing signatures
   - Arbitrary epoch number (can claim to be from unauthorized epoch)
   - Fake transaction accumulator root
   - Transactions that Merkle-prove against the fake accumulator
3. Operator runs: `db-tool restore oneoff transaction --transaction-manifest <attacker_manifest>`
4. Since `epoch_history` is `None`, signature verification is skipped
5. Merkle proof validation passes (transactions match the fake ledger info)
6. Malicious data is written directly to the database: [8](#0-7) 

**Broken Invariants:**

This vulnerability breaks multiple critical invariants:
- **Consensus Safety**: Allows injection of blocks that were never agreed upon by validators
- **Cryptographic Correctness**: BLS signature verification is completely bypassed
- **State Consistency**: Allows arbitrary state transitions not validated by the consensus protocol

## Impact Explanation

**Critical Severity** - This meets the highest severity tier per Aptos bug bounty criteria:

1. **Consensus/Safety Violations**: An attacker can inject blockchain data that was never validated by the AptosBFT consensus protocol, breaking the fundamental safety guarantee that all committed blocks require quorum validator signatures.

2. **State Corruption**: The restored database contains fabricated transactions and state that never occurred on the actual blockchain, leading to:
   - Incorrect account balances and resources
   - Invalid smart contract state
   - Corrupted Jellyfish Merkle tree roots

3. **Network Partition Risk**: If a restored node with corrupted state attempts to participate in consensus or serve state sync requests, it will diverge from honest nodes, potentially requiring a hard fork to recover.

4. **Complete Trust Model Violation**: The attack bypasses the entire validator signature verification mechanism, which is the foundation of blockchain security. Validators' BLS signatures that normally prove consensus agreement are never checked.

The vulnerability allows an unprivileged attacker (one who controls backup storage but has no validator keys) to completely compromise a node's database integrity.

## Likelihood Explanation

**High Likelihood**:

1. **Common Operation**: The oneoff transaction restore command is a legitimate operational tool that administrators would use for:
   - Debugging and testing
   - Partial database restoration
   - Database recovery scenarios

2. **Attacker Requirements**: 
   - Control or compromise of the backup storage endpoint (S3 bucket, file server, etc.)
   - Ability to craft valid BCS-serialized backup files
   - No validator keys or insider access required

3. **No Security Warnings**: The code contains no warnings or documentation indicating that oneoff restore bypasses critical security validation.

4. **Existing TODO**: The code even contains an acknowledgment that epoch validation has gaps: [9](#0-8) 

## Recommendation

**Immediate Fix**: Make epoch history validation mandatory for transaction restore operations.

```rust
impl LoadedChunk {
    async fn load(
        manifest: TransactionChunk,
        storage: &Arc<dyn BackupStorage>,
        epoch_history: Option<&Arc<EpochHistory>>,
    ) -> Result<Self> {
        // ... existing code to load transactions ...

        let (range_proof, ledger_info) = storage
            .load_bcs_file::<(TransactionAccumulatorRangeProof, LedgerInfoWithSignatures)>(
                &manifest.proof,
            )
            .await?;
        
        // CRITICAL: Always require epoch history for signature validation
        let epoch_history = epoch_history.ok_or_else(|| {
            anyhow!(
                "Epoch history is required for transaction restore to validate ledger info signatures. \
                Use the full restore coordinator (BootstrapDB) instead of oneoff restore to ensure \
                proper epoch validation."
            )
        })?;
        
        epoch_history.verify_ledger_info(&ledger_info)?;

        // ... rest of existing validation ...
    }
}
```

**Alternative**: If oneoff restore must support `None` epoch_history for specific use cases, require explicit trusted waypoints:

```rust
// In GlobalRestoreOptions, require trusted_waypoints when epoch_history is None
ensure!(
    epoch_history.is_some() || !trusted_waypoints.is_empty(),
    "Transaction restore requires either epoch history or trusted waypoints for security validation"
);
```

**Long-term**: 
1. Remove the oneoff transaction restore command entirely, requiring all restores to use the coordinator which properly validates epochs
2. Add security documentation warning about the implications of skipping epoch validation
3. Implement backup storage authentication and integrity checks (signed manifests, etc.)

## Proof of Concept

**Attack Simulation Steps:**

1. Create malicious backup files:

```rust
// Attacker crafts fake backup data
use aptos_types::{
    ledger_info::{LedgerInfo, LedgerInfoWithSignatures},
    transaction::{Transaction, TransactionInfo},
};

// Create fake ledger info with arbitrary epoch (e.g., epoch 999)
let fake_ledger_info = LedgerInfo::new(
    BlockInfo::new(
        999, // arbitrary fake epoch
        0,
        HashValue::zero(),
        HashValue::zero(),
        0,
        0,
        None,
    ),
    HashValue::zero(), // fake consensus data hash
);

// Create fake signatures (empty/invalid signatures)
let fake_li_with_sigs = LedgerInfoWithSignatures::new(
    fake_ledger_info,
    AggregateSignature::empty(), // No valid signatures!
);

// Create transactions that Merkle-prove against fake accumulator
let malicious_transactions = vec![
    // Transactions that transfer funds to attacker, etc.
];

// Serialize to backup format and upload to compromised storage
```

2. Operator runs restore command:

```bash
# Operator unknowingly restores from compromised backup storage
db-tool restore oneoff transaction \
    --transaction-manifest s3://compromised-backup/malicious-manifest.json \
    --target-db-dir /opt/aptos/data
```

3. Result: Database contains completely fabricated blockchain state with no valid validator signatures, breaking consensus safety guarantees.

**Verification that attack bypasses validation:**

The attack succeeds because:
- Line 152-154 check is skipped (epoch_history is None)
- Line 167 verification only checks Merkle proofs, not signatures
- No other signature validation occurs in the restore path
- Data is written directly to database without further validation

This can be verified by adding logging to `LoadedChunk::load()` to confirm `epoch_history` is `None` and signature verification is never called during oneoff transaction restore.

### Citations

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L152-154)
```rust
        if let Some(epoch_history) = epoch_history {
            epoch_history.verify_ledger_info(&ledger_info)?;
        }
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L157-167)
```rust
        let txn_list_with_proof =
            TransactionListWithProofV2::new(TransactionListWithAuxiliaryInfos::new(
                TransactionListWithProof::new(
                    txns,
                    Some(event_vecs),
                    Some(manifest.first_version),
                    TransactionInfoListWithProof::new(range_proof, txn_infos),
                ),
                persisted_aux_info,
            ));
        txn_list_with_proof.verify(ledger_info.ledger_info(), Some(manifest.first_version))?;
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L507-517)
```rust
                        tokio::task::spawn_blocking(move || {
                            restore_handler.save_transactions(
                                first_version,
                                &txns_to_save,
                                &persisted_aux_info_to_save,
                                &txn_infos_to_save,
                                &event_vecs_to_save,
                                write_sets_to_save,
                            )
                        })
                        .await??;
```

**File:** storage/db-tool/src/restore.rs (L102-110)
```rust
                        TransactionRestoreController::new(
                            opt,
                            global.try_into()?,
                            storage.init_storage().await?,
                            None, /* epoch_history */
                            VerifyExecutionMode::NoVerify,
                        )
                        .run()
                        .await?;
```

**File:** types/src/epoch_state.rs (L40-50)
```rust
impl Verifier for EpochState {
    fn verify(&self, ledger_info: &LedgerInfoWithSignatures) -> anyhow::Result<()> {
        ensure!(
            self.epoch == ledger_info.ledger_info().epoch(),
            "LedgerInfo has unexpected epoch {}, expected {}",
            ledger_info.ledger_info().epoch(),
            self.epoch
        );
        ledger_info.verify_signatures(&self.verifier)?;
        Ok(())
    }
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L276-312)
```rust
    pub fn verify_ledger_info(&self, li_with_sigs: &LedgerInfoWithSignatures) -> Result<()> {
        let epoch = li_with_sigs.ledger_info().epoch();
        ensure!(!self.epoch_endings.is_empty(), "Empty epoch history.",);
        if epoch > self.epoch_endings.len() as u64 {
            // TODO(aldenhu): fix this from upper level
            warn!(
                epoch = epoch,
                epoch_history_until = self.epoch_endings.len(),
                "Epoch is too new and can't be verified. Previous chunks are verified and node \
                won't be able to start if this data is malicious."
            );
            return Ok(());
        }
        if epoch == 0 {
            ensure!(
                li_with_sigs.ledger_info() == &self.epoch_endings[0],
                "Genesis epoch LedgerInfo info doesn't match.",
            );
        } else if let Some(wp_trusted) = self
            .trusted_waypoints
            .get(&li_with_sigs.ledger_info().version())
        {
            let wp_li = Waypoint::new_any(li_with_sigs.ledger_info());
            ensure!(
                *wp_trusted == wp_li,
                "Waypoints don't match. In backup: {}, trusted: {}",
                wp_li,
                wp_trusted,
            );
        } else {
            self.epoch_endings[epoch as usize - 1]
                .next_epoch_state()
                .ok_or_else(|| anyhow!("Shouldn't contain non- epoch bumping LIs."))?
                .verify(li_with_sigs)?;
        };
        Ok(())
    }
```

**File:** types/src/transaction/mod.rs (L2295-2336)
```rust
    pub fn verify(
        &self,
        ledger_info: &LedgerInfo,
        first_transaction_version: Option<Version>,
    ) -> Result<()> {
        // Verify the first transaction versions match
        ensure!(
            self.get_first_transaction_version() == first_transaction_version,
            "First transaction version ({:?}) doesn't match given version ({:?}).",
            self.get_first_transaction_version(),
            first_transaction_version,
        );

        // Verify the lengths of the transactions and transaction infos match
        ensure!(
            self.proof.transaction_infos.len() == self.get_num_transactions(),
            "The number of TransactionInfo objects ({}) does not match the number of \
             transactions ({}).",
            self.proof.transaction_infos.len(),
            self.get_num_transactions(),
        );

        // Verify the transaction hashes match those of the transaction infos
        self.transactions
            .par_iter()
            .zip_eq(self.proof.transaction_infos.par_iter())
            .map(|(txn, txn_info)| {
                let txn_hash = CryptoHash::hash(txn);
                ensure!(
                    txn_hash == txn_info.transaction_hash(),
                    "The hash of transaction does not match the transaction info in proof. \
                     Transaction hash: {:x}. Transaction hash in txn_info: {:x}.",
                    txn_hash,
                    txn_info.transaction_hash(),
                );
                Ok(())
            })
            .collect::<Result<Vec<_>>>()?;

        // Verify the transaction infos are proven by the ledger info.
        self.proof
            .verify(ledger_info, self.get_first_transaction_version())?;
```

**File:** types/src/proof/definition.rs (L910-925)
```rust
    pub fn verify(
        &self,
        ledger_info: &LedgerInfo,
        first_transaction_info_version: Option<Version>,
    ) -> Result<()> {
        let txn_info_hashes: Vec<_> = self
            .transaction_infos
            .iter()
            .map(CryptoHash::hash)
            .collect();
        self.ledger_info_to_transaction_infos_proof.verify(
            ledger_info.transaction_accumulator_hash(),
            first_transaction_info_version,
            &txn_info_hashes,
        )
    }
```
