# Audit Report

## Title
HTTP Status Code Bypass in JWK Fetching Allows Parsing Error Responses as Valid JWKs

## Summary
The `fetch_jwks_from_jwks_uri()` function does not validate HTTP status codes before parsing response bodies as JSON, allowing error responses (4xx, 5xx) to be processed as valid JWKs if they contain parseable JSON with a "keys" field. This violates the cryptographic correctness invariant and could lead to malicious or malformed JWK data being stored on-chain through validator consensus.

## Finding Description

The vulnerable code is in the `fetch_jwks_from_jwks_uri()` function: [1](#0-0) 

The function calls `.json()` directly on the reqwest response without checking if the HTTP status code indicates success (2xx). The reqwest library's `.json()` method will deserialize any valid JSON body regardless of the HTTP status code.

**Attack Flow:**

1. **OIDC Endpoint Configuration**: Validators are configured to fetch JWKs from OIDC provider endpoints via the JWK consensus system: [2](#0-1) 

2. **Vulnerable Parsing**: When the endpoint returns a non-200 response (e.g., 404 Not Found, 500 Internal Server Error, 503 Service Unavailable) with a JSON body containing a "keys" field, it gets parsed as a valid `JWKsResponse`.

3. **JWK Conversion**: Each value in the "keys" array is converted to a JWK. The conversion is infallible - invalid entries become `UnsupportedJWK` objects: [3](#0-2) [4](#0-3) 

4. **Consensus Processing**: All validators observe the same error response, create a properly versioned update, and reach consensus on the malformed JWKs: [5](#0-4) 

5. **On-Chain Storage**: The malformed JWKs are stored on-chain via `ValidatorTransaction::ObservedJWKUpdate`: [6](#0-5) 

**Example Malicious Error Response:**
```json
{
  "error": "Service unavailable",
  "keys": []
}
```

This would cause all keys for a provider to be removed, breaking keyless authentication for that issuer.

**Contrast with Secure Pattern:**

The codebase demonstrates the correct pattern in multiple locations: [7](#0-6) [8](#0-7) 

Both examples check `response.status().is_success()` before parsing the response body.

## Impact Explanation

**Severity: MEDIUM ($10,000)**

This vulnerability falls under "State inconsistencies requiring intervention" per the bug bounty criteria because:

1. **Cryptographic Correctness Violation (Invariant #10)**: Malformed or malicious JWK data could be stored on-chain, compromising the keyless authentication system's cryptographic guarantees.

2. **Deterministic Execution Concern (Invariant #1)**: If validators observe different HTTP status codes at different times due to timing or network issues, they may reach consensus on inconsistent JWK states.

3. **Limited but Real Impact**: While not directly causing fund theft, this could:
   - Break keyless authentication for legitimate users if error responses are accepted
   - Allow injection of malicious JWKs if an OIDC endpoint is compromised
   - Cause service disruption requiring manual intervention to fix on-chain JWK state

The impact is limited to MEDIUM rather than HIGH because:
- Requires specific error response structure (JSON with "keys" field)
- Requires 2/3+1 validator consensus (not single validator exploit)
- Does not directly lead to fund theft without additional authentication bypass

## Likelihood Explanation

**Likelihood: MEDIUM**

The vulnerability can be triggered in several realistic scenarios:

1. **Temporary Service Outages**: OIDC providers may return structured JSON error responses during outages. Modern APIs commonly return JSON error bodies even for 5xx errors.

2. **Misconfigured Endpoints**: Test, staging, or newly deployed OIDC endpoints might return error responses with unexpected structures.

3. **Compromised OIDC Provider**: While difficult, if an attacker compromises an OIDC provider or performs a successful MITM attack, they can craft error responses to inject malicious JWKs.

4. **Deterministic Failures**: All validators fetch from the same endpoint, so a consistent error response will be observed by all validators, leading to consensus on the malformed data.

The likelihood is not HIGH because:
- Requires error responses to have specific JSON structure with "keys" field
- Most common error responses don't match this structure
- Well-known OIDC providers (Google, Apple) are highly secure

## Recommendation

Add HTTP status code validation before parsing the response body. The fix should follow the established pattern used elsewhere in the codebase:

```rust
pub async fn fetch_jwks_from_jwks_uri(
    my_addr: Option<AccountAddress>,
    jwks_uri: &str,
) -> Result<Vec<JWK>> {
    let client = reqwest::Client::new();
    let mut request_builder = client.get(jwks_uri);
    if let Some(addr) = my_addr {
        request_builder = request_builder.header(COOKIE, addr.to_hex());
    }
    
    let response = request_builder.send().await?;
    
    // Validate HTTP status code before parsing
    let status = response.status();
    if !status.is_success() {
        let error_text = response.text().await.unwrap_or_else(|_| String::from("Failed to read error body"));
        return Err(anyhow::anyhow!(
            "JWK fetch failed with HTTP status {}: {}",
            status,
            error_text
        ));
    }
    
    let JWKsResponse { keys } = response.json().await?;
    let jwks = keys.into_iter().map(JWK::from).collect();
    Ok(jwks)
}
```

Additionally, apply the same fix to `fetch_jwks_uri_from_openid_config()`: [9](#0-8) 

## Proof of Concept

```rust
use aptos_jwk_utils::fetch_jwks_from_jwks_uri;
use mockito::{mock, server_url};
use tokio;

#[tokio::test]
async fn test_http_error_parsed_as_jwks() {
    // Create a mock server that returns a 404 error with JSON body containing "keys"
    let _m = mock("GET", "/jwks")
        .with_status(404)
        .with_header("content-type", "application/json")
        .with_body(r#"{"error": "not found", "keys": [{"kid": "malicious", "payload": "bad"}]}"#)
        .create();

    let jwks_url = format!("{}/jwks", server_url());
    
    // This should fail due to non-200 status, but currently succeeds
    let result = fetch_jwks_from_jwks_uri(None, &jwks_url).await;
    
    // Current behavior: result is Ok with malformed JWKs
    // Expected behavior: result should be Err due to 404 status
    assert!(result.is_ok(), "BUG: 404 error response was parsed as valid JWKs!");
    
    // Demonstrate that the error response was converted to JWKs
    let jwks = result.unwrap();
    println!("Malformed JWKs from error response: {:?}", jwks);
}

#[tokio::test]
async fn test_500_error_with_empty_keys() {
    // Simulate a service unavailable error with empty keys array
    let _m = mock("GET", "/jwks")
        .with_status(503)
        .with_header("content-type", "application/json")
        .with_body(r#"{"error": "service unavailable", "keys": []}"#)
        .create();

    let jwks_url = format!("{}/jwks", server_url());
    let result = fetch_jwks_from_jwks_uri(None, &jwks_url).await;
    
    // This would cause all validators to observe empty JWK set
    // Breaking authentication for that provider
    assert!(result.is_ok());
    let jwks = result.unwrap();
    assert_eq!(jwks.len(), 0, "BUG: Empty keys from 503 error would break authentication!");
}
```

**Notes:**
- This vulnerability requires error responses to have a specific JSON structure with a "keys" field
- The codebase consistently uses status code checking in other HTTP client code, making this an inconsistent pattern
- The fix aligns with security best practices and the established patterns in the rest of the Aptos codebase

### Citations

**File:** crates/jwk-utils/src/lib.rs (L25-37)
```rust
pub async fn fetch_jwks_from_jwks_uri(
    my_addr: Option<AccountAddress>,
    jwks_uri: &str,
) -> Result<Vec<JWK>> {
    let client = reqwest::Client::new();
    let mut request_builder = client.get(jwks_uri);
    if let Some(addr) = my_addr {
        request_builder = request_builder.header(COOKIE, addr.to_hex());
    }
    let JWKsResponse { keys } = request_builder.send().await?.json().await?;
    let jwks = keys.into_iter().map(JWK::from).collect();
    Ok(jwks)
}
```

**File:** crates/jwk-utils/src/lib.rs (L40-44)
```rust
pub async fn fetch_jwks_uri_from_openid_config(config_url: &str) -> Result<String> {
    let client = reqwest::Client::new();
    let OpenIDConfiguration { jwks_uri, .. } = client.get(config_url).send().await?.json().await?;
    Ok(jwks_uri)
}
```

**File:** crates/aptos-jwk-consensus/src/jwk_observer.rs (L102-110)
```rust
async fn fetch_jwks(open_id_config_url: &str, my_addr: Option<AccountAddress>) -> Result<Vec<JWK>> {
    let jwks_uri = fetch_jwks_uri_from_openid_config(open_id_config_url)
        .await
        .map_err(|e| anyhow!("fetch_jwks failed with open-id config request: {e}"))?;
    let jwks = fetch_jwks_from_jwks_uri(my_addr, jwks_uri.as_str())
        .await
        .map_err(|e| anyhow!("fetch_jwks failed with jwks uri request: {e}"))?;
    Ok(jwks)
}
```

**File:** types/src/jwks/jwk/mod.rs (L80-90)
```rust
impl From<serde_json::Value> for JWK {
    fn from(value: serde_json::Value) -> Self {
        match RSA_JWK::try_from(&value) {
            Ok(rsa) => Self::RSA(rsa),
            Err(_) => {
                let unsupported = UnsupportedJWK::from(value);
                Self::Unsupported(unsupported)
            },
        }
    }
}
```

**File:** types/src/jwks/unsupported/mod.rs (L51-59)
```rust
impl From<serde_json::Value> for UnsupportedJWK {
    fn from(json_value: serde_json::Value) -> Self {
        let payload = json_value.to_string().into_bytes(); //TODO: canonical to_string.
        Self {
            id: HashValue::sha3_256_of(payload.as_slice()).to_vec(),
            payload,
        }
    }
}
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager/mod.rs (L197-201)
```rust
            let observed = ProviderJWKs {
                issuer: issuer.clone(),
                version: state.on_chain_version() + 1,
                jwks,
            };
```

**File:** aptos-move/aptos-vm/src/validator_txns/jwk.rs (L144-166)
```rust
        // All verification passed. Apply the `observed`.
        let mut gas_meter = UnmeteredGasMeter;
        let mut session = self.new_session(resolver, session_id, None);
        let args = vec![
            MoveValue::Signer(AccountAddress::ONE),
            vec![observed].as_move_value(),
        ];

        let traversal_storage = TraversalStorage::new();
        session
            .execute_function_bypass_visibility(
                &JWKS_MODULE,
                UPSERT_INTO_OBSERVED_JWKS,
                vec![],
                serialize_values(&args),
                &mut gas_meter,
                &mut TraversalContext::new(&traversal_storage),
                module_storage,
            )
            .map_err(|e| {
                expect_only_successful_execution(e, UPSERT_INTO_OBSERVED_JWKS.as_str(), log_context)
            })
            .map_err(|r| Unexpected(r.unwrap_err()))?;
```

**File:** crates/aptos-faucet/core/src/checkers/google_captcha.rs (L89-104)
```rust
        let status_code = verify_result.status();
        let resp = verify_result
            .text()
            .await
            .map_err(|e| AptosTapError::new_with_error_code(e, AptosTapErrorCode::CheckerError))?;
        if !status_code.is_success() {
            debug!(
                message = "Google captcha API returned error status code",
                status = status_code.as_str(),
                resp = resp
            );
        } else {
            // Rather than `verify_result.json`, we parse the result with serde_json to have more flexibilities
            let resp: serde_json::Value = serde_json::from_str(resp.as_str()).map_err(|e| {
                AptosTapError::new_with_error_code(e, AptosTapErrorCode::CheckerError)
            })?;
```

**File:** crates/aptos-rest-client/src/lib.rs (L1645-1665)
```rust
    async fn check_response(
        &self,
        response: reqwest::Response,
    ) -> AptosResult<(reqwest::Response, State)> {
        if !response.status().is_success() {
            Err(parse_error(response).await)
        } else {
            let state = parse_state(&response)?;

            Ok((response, state))
        }
    }

    async fn json<T: serde::de::DeserializeOwned>(
        &self,
        response: reqwest::Response,
    ) -> AptosResult<Response<T>> {
        let (response, state) = self.check_response(response).await?;
        let json = response.json().await.map_err(anyhow::Error::from)?;
        Ok(Response::new(json, state))
    }
```
