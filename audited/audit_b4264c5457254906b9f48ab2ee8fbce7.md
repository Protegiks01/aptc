# Audit Report

## Title
Cache Inconsistency Between Script Cache and Module Cache Across Transaction Boundaries in Sequential Execution

## Summary
During sequential block execution using `UnsyncMap`, the `script_cache` and `module_cache` are updated independently and non-atomically, allowing scripts verified against old module versions to execute with newer module versions after module upgrades within the same block.

## Finding Description

The `UnsyncCodeStorage` contains two separate caches that are updated independently: [1](#0-0) 

In sequential block execution, a single `UnsyncMap` instance is created and persists across all transactions: [2](#0-1) 

This `UnsyncMap` contains both caches: [3](#0-2) 

**The vulnerability occurs through the following sequence:**

1. **Transaction T1 loads and caches a script**: When a script is loaded, it immediately caches modules it depends on in `module_cache` (with version information), then verifies and caches the script in `script_cache` (without version information): [4](#0-3) 

2. **Transaction T1 aborts**: If the transaction aborts for any reason (gas limit, runtime error, etc.), the function returns early without calling `apply_output_sequential`: [5](#0-4) 

However, the caches have already been updated during loading.

3. **Transaction T2 publishes new module version**: When modules are published successfully, `apply_output_sequential` updates the `module_cache`: [6](#0-5) 

Note that only the layout cache is flushed, but **script_cache is NOT invalidated**.

4. **Transaction T3 executes cached script**: When the same script is loaded again, it's returned directly from cache without re-verification: [7](#0-6) 

The script was verified against the old module version but now executes with the new module version from `module_cache`.

**Known Issue Acknowledgment**: The codebase contains a test documenting this cache coherence bug: [8](#0-7) 

However, the documented workaround (flushing in `MoveVmExt::new_session`) does **not** apply to sequential block execution where `UnsyncMap` persists across all transactions in a block.

## Impact Explanation

**Severity: Medium**

This violates Move's bytecode verification guarantee that scripts are verified against the exact module versions they execute with. While Aptos enforces backward compatibility for module upgrades (preventing signature/layout changes), this cache inconsistency still creates risks:

1. **Verification Bypass**: Scripts execute without re-verification after their dependencies change
2. **Behavioral Inconsistency**: Scripts may exhibit unexpected behavior with upgraded module implementations  
3. **Potential Type Safety Issues**: If compatibility checks have bugs or edge cases, type safety could be violated

The impact is limited to **Medium** (not Critical) because:
- Aptos's compatibility enforcement prevents most type safety violations
- Consensus is not affected (all validators experience the same issue)
- Requires specific transaction sequencing within a single block
- Only affects sequential execution fallback path

## Likelihood Explanation

**Likelihood: Medium**

This can occur whenever:
1. Sequential execution is used (fallback when parallel execution fails or explicitly configured)
2. A transaction loads a script and aborts
3. A subsequent transaction in the same block publishes a module upgrade
4. A third transaction executes the cached script

While each individual condition is uncommon, sequential execution does occur in production as a fallback mechanism, making this exploitable in practice.

## Recommendation

Implement script cache invalidation when modules are published. In `apply_output_sequential`, add script cache flushing alongside the existing layout cache flush:

```rust
// In apply_output_sequential, after line 2131:
if modules_published {
    global_module_cache.flush_layout_cache();
    // ADD: Invalidate script cache when modules change
    unsync_map.script_cache().flush(); // This would require adding a flush() method
}
```

Alternatively, implement per-transaction script cache scopes or add version tracking to the script cache to detect stale entries.

## Proof of Concept

```move
// Module v1
module 0xCAFE::TestModule {
    public fun get_value(): u64 { 42 }
}

// Script depending on TestModule
script {
    use 0xCAFE::TestModule;
    fun main() {
        let v = TestModule::get_value();
        assert!(v == 42, 1);
    }
}

// In sequential execution:
// T1: Execute script (caches script verified against v1), transaction aborts due to gas
// T2: Publish TestModule v2 with get_value() returning 100
// T3: Execute script again (uses cached script from T1 but new module from T2)
//     Script expects 42 but module returns 100 -> assertion fails
//     This demonstrates cache inconsistency
```

**Notes**

This finding represents a cache coherence issue explicitly documented in the codebase tests, but the existing mitigation (session-level cache flushing) does not cover the sequential block execution path. The independent update of `script_cache` and `module_cache` violates atomicity expectations and creates a window for scripts to execute with mismatched dependency versions within a single block.

### Citations

**File:** third_party/move/move-vm/runtime/src/storage/implementations/unsync_code_storage.rs (L37-40)
```rust
pub struct UnsyncCodeStorage<M> {
    script_cache: UnsyncScriptCache<[u8; 32], CompiledScript, Script>,
    module_storage: M,
}
```

**File:** aptos-move/block-executor/src/executor.rs (L2117-2131)
```rust
        let mut modules_published = false;
        for write in output_before_guard.module_write_set().values() {
            add_module_write_to_module_cache::<T>(
                write,
                txn_idx,
                runtime_environment,
                global_module_cache,
                unsync_map.module_cache(),
            )?;
            modules_published = true;
        }
        // For simplicity, flush layout cache on module publish.
        if modules_published {
            global_module_cache.flush_layout_cache();
        }
```

**File:** aptos-move/block-executor/src/executor.rs (L2205-2205)
```rust
        let unsync_map = UnsyncMap::new();
```

**File:** aptos-move/block-executor/src/executor.rs (L2237-2248)
```rust
                ExecutionStatus::Abort(err) => {
                    if let Some(commit_hook) = &self.transaction_commit_hook {
                        commit_hook.on_execution_aborted(idx as TxnIndex);
                    }
                    error!(
                        "Sequential execution FatalVMError by transaction {}",
                        idx as TxnIndex
                    );
                    // Record the status indicating the unrecoverable VM failure.
                    return Err(SequentialBlockExecutionError::ErrorToReturn(
                        BlockExecutionError::FatalVMError(err),
                    ));
```

**File:** aptos-move/mvhashmap/src/unsync_map.rs (L47-50)
```rust
    // Code caches for modules and scripts.
    module_cache:
        UnsyncModuleCache<ModuleId, CompiledModule, Module, AptosModuleExtension, Option<TxnIndex>>,
    script_cache: UnsyncScriptCache<[u8; 32], CompiledScript, Script>,
```

**File:** third_party/move/move-vm/runtime/src/storage/loader/lazy.rs (L129-138)
```rust
        let deserialized_script = match self.module_storage.get_script(&hash) {
            Some(Verified(script)) => {
                // Before returning early, meter modules because script might have been cached by
                // other thread.
                for (addr, name) in script.immediate_dependencies_iter() {
                    let module_id = ModuleId::new(*addr, name.to_owned());
                    self.charge_module(gas_meter, traversal_context, &module_id)
                        .map_err(|err| err.finish(Location::Undefined))?;
                }
                return Ok(script);
```

**File:** third_party/move/move-vm/runtime/src/storage/loader/lazy.rs (L151-165)
```rust
        let immediate_dependencies = locally_verified_script
            .immediate_dependencies_iter()
            .map(|(addr, name)| {
                let module_id = ModuleId::new(*addr, name.to_owned());
                self.metered_load_module(gas_meter, traversal_context, &module_id)
            })
            .collect::<VMResult<Vec<_>>>()?;

        let verified_script = self
            .runtime_environment()
            .build_verified_script(locally_verified_script, &immediate_dependencies)?;

        Ok(self
            .module_storage
            .insert_verified_script(hash, verified_script))
```

**File:** aptos-move/e2e-move-tests/src/tests/code_publishing.rs (L215-219)
```rust
/// This test verifies that the cache incoherence bug on module upgrade is fixed. This bug
/// exposes itself by that after module upgrade the old version of the module stays
/// active until the MoveVM terminates. In order to workaround this until there is a better
/// fix, we flush the cache in `MoveVmExt::new_session`. One can verify the fix by commenting
/// the flush operation out, then this test fails.
```
