# Audit Report

## Title
Incomplete State Checkpoint Hash Validation Allows Ledger Corruption During State Sync

## Summary
The `DoStateCheckpoint::get_state_checkpoint_hashes()` function performs incomplete validation of `known_state_checkpoints` provided by the chunk verifier during state synchronization. It only validates the state checkpoint hash at the last checkpoint index, failing to verify that all other transactions have `None` as their checkpoint hash. This allows inconsistent state checkpoint data to propagate through the ledger update pipeline, potentially causing consensus violations and state divergence between nodes.

## Finding Description

The vulnerability exists in the validation logic when `known_state_checkpoints` is provided (state sync path). The system enforces an invariant that each block contains at most one state checkpoint, typically at the last transaction. However, the validation in `DoStateCheckpoint::get_state_checkpoint_hashes()` only partially enforces this invariant. [1](#0-0) 

When `known_state_checkpoints` is provided, the validation performs only two checks:
1. Length matches the number of transactions
2. **If** a checkpoint exists locally (`last_checkpoint_index` is `Some`), the hash at that index matches

**Critical gaps in validation:**

**Gap 1:** If `last_checkpoint_index` is `None` (no checkpoint computed locally) but `known` contains `Some(hash)` values at any index, these are accepted without validation. This can occur when state sync data indicates checkpoints that the local state computation doesn't produce, indicating execution non-determinism or state divergence.

**Gap 2:** If `last_checkpoint_index` is `Some(idx)` but `known` contains `Some(hash)` values at **other indices** (e.g., `known[5]` and `known[10]` both have values when only index 10 should), only the hash at `idx` is validated. The extra hashes at other indices are never checked and pass through unchallenged.

These invalid hashes then flow into `DoLedgerUpdate::run()` where they're used to construct `TransactionInfo` objects: [2](#0-1) 

The `state_checkpoint_hash` at line 68 is directly indexed from the unvalidated array and embedded into the `TransactionInfo` structure, which is then hashed to produce the transaction accumulator root. [3](#0-2) 

**Why verification doesn't catch this:** After ledger update, the chunk verifier compares the computed `TransactionInfo` objects against the expected ones from state sync. However, since the expected transaction infos are the **same source** as the `known_state_checkpoints`, the malicious/incorrect data validates against itself, creating a circular validation failure. [4](#0-3) 

**Attack Scenario:**
1. Node A executes a block and due to a bug/non-determinism produces state checkpoint hashes at multiple indices (violating the one-checkpoint invariant)
2. Node A's validators sign and commit this data
3. Node B syncs this block via state sync and receives the `TransactionInfoListWithProof` with multiple checkpoint hashes
4. Node B extracts these hashes as `known_state_checkpoints`
5. `DoStateCheckpoint` validation only checks the last checkpoint index, missing the extra checkpoint at an earlier index
6. `DoLedgerUpdate` constructs `TransactionInfo` objects with all the checkpoint hashes from the invalid array
7. Verification passes because it compares against the same invalid source data
8. Node B commits incorrect ledger state

Meanwhile, Node C executes the same block correctly (one checkpoint only) and computes different `TransactionInfo` objects. Nodes B and C now have divergent transaction accumulator roots, breaking consensus safety.

## Impact Explanation

This is a **High Severity** vulnerability (per Aptos Bug Bounty criteria) that violates the **Deterministic Execution** invariant. Specifically:

1. **State Consistency Violation:** Different nodes can commit different `TransactionInfo` objects for the same transactions, leading to different transaction accumulator root hashes
2. **Consensus Safety Break:** The transaction accumulator root is used for consensus validity checks. Divergent roots mean different nodes disagree on the canonical ledger state
3. **State Divergence Amplification:** If execution non-determinism or bugs cause validators to produce incorrect checkpoint patterns, this validation gap allows the error to propagate network-wide through state sync, even to nodes that might have executed correctly

While this vulnerability requires an existing execution bug or non-determinism to be triggered, it **amplifies and propagates** such bugs rather than catching them at the validation boundary. This violates defense-in-depth principles and can turn a localized execution issue into a network-wide consensus failure.

## Likelihood Explanation

**Likelihood: Medium to High**

This vulnerability can be triggered when:
1. Execution non-determinism causes different checkpoint patterns across validators
2. Bugs in state update tracking produce incorrect `state_update_refs`  
3. Serialization/deserialization errors corrupt checkpoint metadata during state sync
4. Race conditions in concurrent execution produce inconsistent checkpoint indices

The Aptos execution pipeline is complex, and the likelihood of edge cases causing checkpoint inconsistencies is non-trivial. Once triggered, the incomplete validation ensures the bug propagates to all syncing nodes.

## Recommendation

Add comprehensive validation to ensure `known_state_checkpoints` conforms to the single-checkpoint invariant:

```rust
fn get_state_checkpoint_hashes(
    execution_output: &ExecutionOutput,
    known_state_checkpoints: Option<Vec<Option<HashValue>>>,
    state_summary: &LedgerStateSummary,
) -> Result<Vec<Option<HashValue>>> {
    let _timer = OTHER_TIMERS.timer_with(&["get_state_checkpoint_hashes"]);

    let num_txns = execution_output.to_commit.len();
    let last_checkpoint_index = execution_output
        .to_commit
        .state_update_refs()
        .last_inner_checkpoint_index();

    if let Some(known) = known_state_checkpoints {
        ensure!(
            known.len() == num_txns,
            "Bad number of known hashes. {} vs {}",
            known.len(),
            num_txns
        );
        
        // NEW VALIDATION: Check consistency with computed checkpoint pattern
        match last_checkpoint_index {
            Some(idx) => {
                // Ensure the checkpoint hash at idx matches
                ensure!(
                    known[idx] == Some(state_summary.last_checkpoint().root_hash()),
                    "Root hash mismatch with known hashes passed in. {:?} vs {:?}",
                    known[idx],
                    Some(&state_summary.last_checkpoint().root_hash()),
                );
                
                // NEW: Ensure all OTHER indices are None (at most one checkpoint)
                for (i, hash) in known.iter().enumerate() {
                    if i != idx {
                        ensure!(
                            hash.is_none(),
                            "Unexpected checkpoint hash at index {} (expected only at {}). Found: {:?}",
                            i,
                            idx,
                            hash
                        );
                    }
                }
            },
            None => {
                // NEW: If no checkpoint computed, ensure all known hashes are None
                for (i, hash) in known.iter().enumerate() {
                    ensure!(
                        hash.is_none(),
                        "Unexpected checkpoint hash at index {} when no checkpoint was computed. Found: {:?}",
                        i,
                        hash
                    );
                }
            }
        }

        Ok(known)
    } else {
        if !execution_output.is_block {
            execution_output.to_commit.ensure_at_most_one_checkpoint()?;
        }

        let mut out = vec![None; num_txns];

        if let Some(index) = last_checkpoint_index {
            out[index] = Some(state_summary.last_checkpoint().root_hash());
        }

        Ok(out)
    }
}
```

This ensures that `known_state_checkpoints` matches the exact checkpoint pattern computed locally, catching any inconsistencies before they corrupt the ledger.

## Proof of Concept

```rust
// Conceptual PoC demonstrating the validation gap
// This would be integrated into executor tests

#[cfg(test)]
mod test {
    use super::*;
    
    #[test]
    #[should_panic(expected = "Unexpected checkpoint hash at index")]
    fn test_rejects_multiple_checkpoint_hashes() {
        // Setup: Create execution output with checkpoint at index 9 (last txn)
        let execution_output = create_test_execution_output_with_checkpoint_at(9, 10);
        let state_summary = compute_test_state_summary(&execution_output);
        
        // Malicious input: known_state_checkpoints has hashes at indices 3 and 9
        let mut known_checkpoints = vec![None; 10];
        known_checkpoints[3] = Some(HashValue::random()); // Invalid extra checkpoint
        known_checkpoints[9] = Some(state_summary.last_checkpoint().root_hash()); // Valid last checkpoint
        
        // Current implementation: This incorrectly PASSES because only index 9 is checked
        // With fix: This should FAIL with "Unexpected checkpoint hash at index 3"
        let result = DoStateCheckpoint::get_state_checkpoint_hashes(
            &execution_output,
            Some(known_checkpoints),
            &state_summary,
        );
        
        // Current: result.unwrap() succeeds with invalid data
        // With fix: result.unwrap() panics with validation error
        result.unwrap();
    }
    
    #[test]
    #[should_panic(expected = "Unexpected checkpoint hash at index")]
    fn test_rejects_checkpoint_when_none_computed() {
        // Setup: Execution output with NO checkpoint
        let execution_output = create_test_execution_output_without_checkpoint(5);
        let state_summary = compute_test_state_summary(&execution_output);
        
        // Malicious input: known_state_checkpoints claims checkpoint at index 2
        let mut known_checkpoints = vec![None; 5];
        known_checkpoints[2] = Some(HashValue::random());
        
        // Current implementation: This incorrectly PASSES because last_checkpoint_index is None
        // With fix: This should FAIL with "Unexpected checkpoint hash at index 2"
        let result = DoStateCheckpoint::get_state_checkpoint_hashes(
            &execution_output,
            Some(known_checkpoints),
            &state_summary,
        );
        
        result.unwrap();
    }
}
```

**Notes**

The vulnerability stems from an **incomplete invariant enforcement** at the validation boundary between state sync and ledger updates. While the execution layer enforces "at most one checkpoint per block" through assertions, the state sync validation path doesn't fully verify this invariant when accepting external data. This creates a gap where execution bugs or non-determinism can propagate network-wide, amplifying their impact from isolated issues to consensus-breaking failures.

The fix is straightforward: comprehensively validate that `known_state_checkpoints` matches the exact single-checkpoint pattern computed locally, rejecting any deviation. This provides defense-in-depth and ensures that state sync data inconsistencies are caught before corrupting the ledger.

### Citations

**File:** execution/executor/src/workflow/do_state_checkpoint.rs (L57-73)
```rust
        if let Some(known) = known_state_checkpoints {
            ensure!(
                known.len() == num_txns,
                "Bad number of known hashes. {} vs {}",
                known.len(),
                num_txns
            );
            if let Some(idx) = last_checkpoint_index {
                ensure!(
                    known[idx] == Some(state_summary.last_checkpoint().root_hash()),
                    "Root hash mismatch with known hashes passed in. {:?} vs {:?}",
                    known[idx],
                    Some(&state_summary.last_checkpoint().root_hash()),
                );
            }

            Ok(known)
```

**File:** execution/executor/src/workflow/do_ledger_update.rs (L68-68)
```rust
                let state_checkpoint_hash = state_checkpoint_hashes[i];
```

**File:** execution/executor/src/workflow/do_ledger_update.rs (L77-88)
```rust
                let txn_info = TransactionInfo::new(
                    txn.hash(),
                    write_set_hash,
                    event_root_hash,
                    state_checkpoint_hash,
                    txn_output.gas_used(),
                    txn_output
                        .status()
                        .as_kept_status()
                        .expect("Already sorted."),
                    auxiliary_info_hash,
                );
```

**File:** execution/executor/src/chunk_executor/mod.rs (L346-365)
```rust
        let state_checkpoint_output = DoStateCheckpoint::run(
            &output.execution_output,
            &parent_state_summary,
            &ProvableStateSummary::new_persisted(self.db.reader.as_ref())?,
            Some(
                chunk_verifier
                    .transaction_infos()
                    .iter()
                    .map(|t| t.state_checkpoint_hash())
                    .collect_vec(),
            ),
        )?;

        let ledger_update_output = DoLedgerUpdate::run(
            &output.execution_output,
            &state_checkpoint_output,
            parent_accumulator.clone(),
        )?;

        chunk_verifier.verify_chunk_result(&parent_accumulator, &ledger_update_output)?;
```
