# Audit Report

## Title
Lack of Gas Schedule Entry Validation Enables Network-Wide Denial of Service Through Governance

## Summary
The gas schedule update mechanism lacks validation of entry completeness during on-chain storage, allowing malformed gas schedules to be committed to state through governance proposals. When the VM attempts to load a malformed schedule, all transactions fail with `VM_STARTUP_FAILURE`, causing total network unavailability requiring emergency governance intervention or hard fork recovery.

## Finding Description

The vulnerability exists in the gas schedule update flow where the `ToOnChainGasSchedule` trait produces unvalidated data that passes through governance without entry completeness checks.

**Flow:**

1. **Data Generation**: The `ToOnChainGasSchedule::to_on_chain_gas_schedule()` method returns `Vec<(String, u64)>` without validating that all required entries for a given feature version are present. [1](#0-0) 

2. **On-Chain Storage**: When governance calls `gas_schedule::set_for_next_epoch()`, the function only validates:
   - The blob is non-empty
   - BCS deserialization to `GasScheduleV2` succeeds  
   - Feature version is >= current version
   
   **Critically, it does NOT validate entry completeness** (as noted by TODO comments): [2](#0-1) 

The TODO comment at line 47, 67, and 75 explicitly states this missing validation: [3](#0-2) 

3. **Reconfiguration**: During epoch transition, `on_new_epoch()` moves the schedule from buffer to active storage without validation: [4](#0-3) 

4. **VM Startup Failure**: When the next transaction executes, `AptosEnvironment::new()` loads the gas schedule and calls `from_on_chain_gas_schedule()`, which validates that **all required entries exist**. If entries are missing, it returns an error: [5](#0-4) 

5. **Network Halt**: The error is stored in the environment and converted to `VM_STARTUP_FAILURE` when accessed: [6](#0-5) 

**All subsequent transactions are discarded**, as demonstrated by the test case: [7](#0-6) 

## Impact Explanation

This vulnerability qualifies as **Critical Severity** under the Aptos Bug Bounty program:

- **Total loss of liveness/network availability**: All transactions fail with `VM_STARTUP_FAILURE`, rendering the blockchain completely non-functional
- **Requires emergency intervention**: Recovery requires either:
  - Emergency governance proposal to fix the gas schedule (but if all transactions fail, governance cannot execute)
  - Hard fork to restore a valid gas schedule state
  
The impact affects **every node in the network simultaneously**, as all nodes load the same malformed gas schedule from on-chain state. This breaks the **State Consistency** and **Resource Limits** invariants.

## Likelihood Explanation

**Moderate to High Likelihood:**

1. **Accidental Trigger**: The most likely scenario is a bug in proposal generation tooling (e.g., `aptos-gas-schedule-updator` or custom scripts) that produces incomplete entries. While the off-chain simulation tool validates gas parameters, simulation is not enforced on-chain: [8](#0-7) 

2. **Compromised Governance**: A compromised governance participant with sufficient stake could intentionally create a malformed schedule.

3. **Known Gap**: The presence of TODO comments indicates this is a known validation gap that has not been addressed: [9](#0-8) 

## Recommendation

Add validation to `gas_schedule::set_for_next_epoch()` and `set_for_next_epoch_check_hash()` to ensure the gas schedule can be successfully parsed before storing it on-chain:

```move
public fun set_for_next_epoch(aptos_framework: &signer, gas_schedule_blob: vector<u8>) acquires GasScheduleV2 {
    system_addresses::assert_aptos_framework(aptos_framework);
    assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));
    let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
    
    if (exists<GasScheduleV2>(@aptos_framework)) {
        let cur_gas_schedule = borrow_global<GasScheduleV2>(@aptos_framework);
        assert!(
            new_gas_schedule.feature_version >= cur_gas_schedule.feature_version,
            error::invalid_argument(EINVALID_GAS_FEATURE_VERSION)
        );
    };
    
    // NEW: Validate that the gas schedule can be parsed
    validate_gas_schedule_entries(&new_gas_schedule);
    
    config_buffer::upsert(new_gas_schedule);
}

// NEW: Validation function
fun validate_gas_schedule_entries(schedule: &GasScheduleV2) {
    // This would need to be implemented in Move by checking for required keys
    // Or call out to Rust validation logic via native function
    // For now, a native function approach is most practical:
    // native fun validate_gas_params(schedule: &GasScheduleV2): bool;
}
```

Alternatively, implement this check in Rust before the Move call by having the proposal generation tooling validate outputs from `to_on_chain_gas_schedule()` before serialization.

## Proof of Concept

```rust
// In aptos-move/e2e-move-tests/src/tests/malformed_gas_schedule.rs

#[test]
fn malformed_gas_schedule_causes_network_halt() {
    let mut harness = MoveHarness::new();
    
    // Create a malformed gas schedule with missing required entries
    let malformed_schedule = GasScheduleV2 {
        feature_version: LATEST_GAS_FEATURE_VERSION,
        entries: vec![
            // Intentionally missing critical entries like "instr.add", "instr.ret", etc.
            ("txn.min_transaction_gas_units".to_string(), 1000),
        ],
    };
    
    let malformed_blob = bcs::to_bytes(&malformed_schedule).unwrap();
    
    // Submit governance proposal to update gas schedule
    let framework_signer = harness.aptos_framework_account();
    harness.run_entry_function(
        &framework_signer,
        str::parse("0x1::gas_schedule::set_for_next_epoch").unwrap(),
        vec![],
        vec![bcs::to_bytes(&malformed_blob).unwrap()],
    );
    
    // Trigger reconfiguration
    harness.run_entry_function(
        &framework_signer,
        str::parse("0x1::aptos_governance::reconfigure").unwrap(),
        vec![],
        vec![],
    );
    
    // Attempt to execute any transaction - should fail with VM_STARTUP_FAILURE
    let account = harness.new_account_at(AccountAddress::random());
    let txn_status = harness.run_transaction_payload(
        &account,
        aptos_cached_packages::aptos_stdlib::aptos_coin_transfer(
            AccountAddress::random(),
            1000,
        ),
    );
    
    // All transactions now fail due to missing gas parameters
    assert!(matches!(
        txn_status,
        TransactionStatus::Discard(StatusCode::VM_STARTUP_FAILURE)
    ));
    
    // Network is now halted - no transactions can execute
}
```

## Notes

This vulnerability demonstrates a critical gap in on-chain validation that enables network-wide denial of service. While governance access is required to exploit it, the catastrophic impact (total network halt affecting all nodes simultaneously) and the presence of explicit TODO comments indicating known validation gaps justify treating this as a high-priority security issue requiring immediate remediation.

The fix should implement entry completeness validation before storing gas schedules on-chain, converting the runtime validation failure into an upfront rejection during proposal execution. This prevents the network from entering an unrecoverable state.

### Citations

**File:** aptos-move/aptos-gas-schedule/src/traits.rs (L18-23)
```rust
pub trait ToOnChainGasSchedule {
    /// Converts `self` into a list of entries of the on-chain gas schedule.
    /// Each entry is a key-value pair where the key is a string representing the name of the
    /// parameter, where the value is the gas parameter itself.
    fn to_on_chain_gas_schedule(&self, feature_version: u64) -> Vec<(String, u64)>;
}
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L47-47)
```text
        // TODO(Gas): check if gas schedule is consistent
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L67-67)
```text
            // TODO(Gas): check if gas schedule is consistent
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L91-103)
```text
    public fun set_for_next_epoch(aptos_framework: &signer, gas_schedule_blob: vector<u8>) acquires GasScheduleV2 {
        system_addresses::assert_aptos_framework(aptos_framework);
        assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));
        let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
        if (exists<GasScheduleV2>(@aptos_framework)) {
            let cur_gas_schedule = borrow_global<GasScheduleV2>(@aptos_framework);
            assert!(
                new_gas_schedule.feature_version >= cur_gas_schedule.feature_version,
                error::invalid_argument(EINVALID_GAS_FEATURE_VERSION)
            );
        };
        config_buffer::upsert(new_gas_schedule);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L135-145)
```text
    public(friend) fun on_new_epoch(framework: &signer) acquires GasScheduleV2 {
        system_addresses::assert_aptos_framework(framework);
        if (config_buffer::does_exist<GasScheduleV2>()) {
            let new_gas_schedule = config_buffer::extract_v2<GasScheduleV2>();
            if (exists<GasScheduleV2>(@aptos_framework)) {
                *borrow_global_mut<GasScheduleV2>(@aptos_framework) = new_gas_schedule;
            } else {
                move_to(framework, new_gas_schedule);
            }
        }
    }
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/macros.rs (L32-46)
```rust
        impl $crate::traits::FromOnChainGasSchedule for $params_name {
            #[allow(unused)]
            fn from_on_chain_gas_schedule(gas_schedule: &std::collections::BTreeMap<String, u64>, feature_version: u64) -> Result<Self, String> {
                let mut params = $params_name::zeros();

                $(
                    if let Some(key) = $crate::gas_schedule::macros::define_gas_parameters_extract_key_at_version!($key_bindings, feature_version) {
                        let name = format!("{}.{}", $prefix, key);
                        params.$name = gas_schedule.get(&name).cloned().ok_or_else(|| format!("Gas parameter {} does not exist. Feature version: {}.", name, feature_version))?.into();
                    }
                )*

                Ok(params)
            }
        }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L273-282)
```rust
pub(crate) fn get_or_vm_startup_failure<'a, T>(
    gas_params: &'a Result<T, String>,
    log_context: &AdapterLogSchema,
) -> Result<&'a T, VMStatus> {
    gas_params.as_ref().map_err(|err| {
        let msg = format!("VM Startup Failed. {}", err);
        speculative_error!(log_context, msg.clone());
        VMStatus::error(StatusCode::VM_STARTUP_FAILURE, Some(msg))
    })
}
```

**File:** aptos-move/e2e-move-tests/src/tests/missing_gas_parameter.rs (L8-28)
```rust
#[test]
fn missing_gas_parameter() {
    let mut h = MoveHarness::new();

    h.modify_gas_schedule_raw(|gas_schedule| {
        let idx = gas_schedule
            .entries
            .iter()
            .position(|(key, _val)| key == "instr.add")
            .unwrap();
        gas_schedule.entries.remove(idx);
    });

    // Load the code
    let acc = h.new_account_with_balance_at(AccountAddress::from_hex_literal("0xbeef").unwrap(), 0);
    let txn_status = h.publish_package(&acc, &common::test_dir_path("common.data/do_nothing"));
    assert!(matches!(
        txn_status,
        TransactionStatus::Discard(StatusCode::VM_STARTUP_FAILURE)
    ))
}
```

**File:** aptos-move/aptos-release-builder/src/simulate.rs (L436-449)
```rust
        let gas_schedule =
            GasScheduleV2::fetch_config(&state_view).context("failed to fetch gas schedule v2")?;
        let gas_feature_version = gas_schedule.feature_version;
        let gas_params = AptosGasParameters::from_on_chain_gas_schedule(
            &gas_schedule.into_btree_map(),
            gas_feature_version,
        )
        .map_err(|err| {
            anyhow!(
                "failed to construct gas params at gas version {}: {}",
                gas_feature_version,
                err
            )
        })?;
```
