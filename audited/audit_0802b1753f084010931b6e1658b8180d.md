# Audit Report

## Title
Misleading KeyRotation Event Bitmap for Multi-Key Rotations via rotate_authentication_key_from_public_key

## Summary
The `rotate_authentication_key_from_public_key` function emits `KeyRotationToPublicKey` events with an all-zero `verified_public_key_bit_map` for multi-key schemes (MULTI_KEY_SCHEME, MULTI_ED25519_SCHEME), indicating no keys were cryptographically verified. This misleading event data could confuse recovery tools and wallet software that rely on the bitmap to understand which keys in a multi-signature configuration have been verified, potentially leading to incorrect account recovery or security decisions.

## Finding Description

The Aptos account module provides multiple functions for authentication key rotation. The `KeyRotationToPublicKey` event structure includes a `verified_public_key_bit_map` field that is explicitly documented to indicate "which public keys have been verified by the account owner" [1](#0-0) .

When using `rotate_authentication_key` with proper cryptographic proofs, the bitmap correctly reflects which keys in a multi-ed25519 configuration signed the rotation challenge [2](#0-1) .

However, the `rotate_authentication_key_from_public_key` function unconditionally sets this bitmap to all zeros for ALL schemes, including multi-key configurations [3](#0-2) .

For multi-signature accounts, this creates a semantic inconsistency: the function successfully rotates the authentication key to a multi-key configuration, but the emitted event incorrectly suggests that none of the keys in that configuration were verified. Recovery tools reading these events may incorrectly interpret the multi-key as unverified or invalid.

The vulnerability is particularly relevant for multisig accounts because the `multisig_account` module can use `rotate_authentication_key_internal` (which is called by `rotate_authentication_key_from_public_key`) to rotate keys [4](#0-3) .

## Impact Explanation

This issue falls into the **Low Severity** category per the Aptos bug bounty program criteria. It represents a non-critical implementation bug that could cause confusion in recovery tooling but does not directly lead to:
- Loss or theft of funds
- Consensus violations
- State corruption
- Access control bypasses

The impact is limited to potential misinterpretation of event data by off-chain recovery tools and wallet software, which could lead to user confusion or failed recovery attempts if tools treat the all-zero bitmap as indicating invalid keys.

## Likelihood Explanation

This issue occurs whenever an account owner uses `rotate_authentication_key_from_public_key` to rotate to a MULTI_KEY_SCHEME or MULTI_ED25519_SCHEME. The function is designed for "non-standard key algorithms, such as passkeys" [5](#0-4) , but it accepts all schemes including standard multi-key configurations.

The likelihood is MODERATE because:
- The function is accessible to any account owner
- Multi-key rotations using this function will emit misleading events
- Recovery tools may rely on the bitmap field for security decisions

## Recommendation

**Option 1 (Restrictive):** Restrict `rotate_authentication_key_from_public_key` to only support schemes that genuinely cannot provide proof-of-knowledge (e.g., certain passkey implementations), and abort if MULTI_ED25519_SCHEME or standard MULTI_KEY_SCHEME is used.

**Option 2 (Documentation):** Clearly document that the all-zero bitmap for this function indicates "unverified rotation" (no PoK required) rather than "invalid keys", and ensure recovery tools handle this case appropriately.

**Option 3 (Separate Events):** Emit a different event type (e.g., `UnverifiedKeyRotation`) when using `rotate_authentication_key_from_public_key` to distinguish it from verified rotations.

## Proof of Concept

```move
#[test(account = @0x123)]
public entry fun test_multisig_unverified_rotation_bitmap(account: &signer) {
    use aptos_framework::account;
    use aptos_std::multi_ed25519;
    
    // Create a multi-ed25519 key with 2-of-3 threshold
    let pubkey1 = x"..."; // 32 bytes ed25519 pubkey
    let pubkey2 = x"..."; // 32 bytes ed25519 pubkey  
    let pubkey3 = x"..."; // 32 bytes ed25519 pubkey
    let threshold = 2u8;
    
    // Serialize multi-ed25519 public key
    let multi_pubkey_bytes = serialize_multi_ed25519(pubkey1, pubkey2, pubkey3, threshold);
    
    // Rotate to multi-ed25519 using rotate_authentication_key_from_public_key
    account::rotate_authentication_key_from_public_key(
        account,
        1, // MULTI_ED25519_SCHEME
        multi_pubkey_bytes
    );
    
    // The emitted KeyRotationToPublicKey event will have:
    // - verified_public_key_bit_map = [0x00, 0x00, 0x00, 0x00]
    // - public_key_scheme = 1
    // - public_key = multi_pubkey_bytes (contains all 3 keys)
    //
    // Recovery tools seeing this event might incorrectly conclude
    // that none of the 3 keys in the multi-ed25519 were verified,
    // potentially causing confusion during account recovery.
}
```

## Notes

The root issue is that `verified_public_key_bit_map` has dual semantics: it can mean either "no keys verified" (for unverified rotations) or "these specific keys in the multi-key were verified" (for verified rotations). The field cannot distinguish between "unverified by design" vs "invalid/unverified keys". This ambiguity affects recovery tools that rely on event data to understand account key configurations for multi-signature accounts.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L41-46)
```text
        // The bitmap of verified public keys.  This indicates which public keys have been verified by the account owner.
        // The bitmap is 4 bytes long, thus representing 32 bits.  Each bit represents whether a public key has been verified.
        // In the 32 bit representation, if a bit at index i (read left to right) is 1, then the public key at index i has
        // been verified in the public key.
        //
        // For example: [0x10100000,0x00000000,0x00000000,0x00000000] marks the first and third public keys in the multi-key as verified.
```

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L453-456)
```text
    /// Note that this does not update the `OriginatingAddress` table because the `new_auth_key` is not "verified": it
    /// does not come with a proof-of-knowledge of the underlying SK. Nonetheless, we need this functionality due to
    /// the introduction of non-standard key algorithms, such as passkeys, which cannot produce proofs-of-knowledge in
    /// the format expected in `rotate_authentication_key`.
```

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L487-495)
```text
        event::emit(KeyRotationToPublicKey {
            account: addr,
            // Set verified_public_key_bit_map to [0x00, 0x00, 0x00, 0x00] as the public key(s) are not verified
            verified_public_key_bit_map: vector[0x00, 0x00, 0x00, 0x00],
            public_key_scheme: scheme,
            public_key: new_public_key_bytes,
            old_auth_key,
            new_auth_key,
        });
```

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L663-671)
```text
        let verified_public_key_bit_map;
        if (to_scheme == ED25519_SCHEME) {
            // Set verified_public_key_bit_map to [0x80, 0x00, 0x00, 0x00] as the public key is verified and there is only one public key.
            verified_public_key_bit_map = vector[0x80, 0x00, 0x00, 0x00];
        } else {
            // The new key is a multi-ed25519 key, so set the verified_public_key_bit_map to the signature bitmap.
            let len = vector::length(&cap_update_table);
            verified_public_key_bit_map = vector::slice(&cap_update_table, len - 4, len);
        };
```

**File:** aptos-move/framework/aptos-framework/sources/multisig_account.move (L598-598)
```text
        account::rotate_authentication_key_internal(multisig_account, ZERO_AUTH_KEY);
```
