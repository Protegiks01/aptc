# Audit Report

## Title
Consensus Observer Accepts Unverified Future Epoch Commits Leading to Permanent Desynchronization

## Summary
The consensus observer's `process_commit_decision_message()` function fails to verify commit decisions for future epochs before using them to update the node's root state and trigger state synchronization. An attacker controlling a subscribed peer can send a malicious future epoch commit, causing the observer to corrupt its state and permanently miss all legitimate commits.

## Finding Description

The vulnerability exists in the commit decision processing logic where future epoch commits bypass cryptographic verification. [1](#0-0) 

Current epoch commits are verified via `verify_commit_proof()` which validates signatures against the epoch state validator set: [2](#0-1) 

However, future epoch commits skip this verification entirely and proceed directly to state synchronization: [3](#0-2) 

The TODO comment at lines 497-498 acknowledges this gap but the issue remains unaddressed. When processing an unverified future epoch commit, the observer unconditionally:

1. **Updates its root to the unverified commit proof**, corrupting its base state: [4](#0-3) 

2. **Clears its block payload and ordered block stores**, discarding legitimate pending data

3. **Initiates state sync to an invalid target**: [5](#0-4) 

Critically, when state sync fails to reach the invalid target (because signatures are invalid or the target doesn't exist on the network), it **silently returns without notifying the observer**. The observer remains stuck indefinitely with a corrupted root state, and all subsequent legitimate commits are dropped as "behind" the fake root: [6](#0-5) 

**Attack Scenario:**

1. Observer subscribes to peer P (legitimate or compromised)
2. Observer is at epoch 10, round 100
3. Attacker controlling P sends `CommitDecision` with epoch 11, round 1, and invalid/arbitrary signatures
4. Observer skips verification (epoch 11 â‰  current epoch 10)
5. Observer updates root to epoch 11 round 1, clears all blocks
6. Observer starts state sync to epoch 11 round 1
7. State sync fails (target unreachable/invalid), logs error, exits without notification
8. Observer permanently stuck at fake epoch 11 round 1 root
9. All legitimate epoch 10 commits arrive but are dropped as "old"
10. Observer never recovers, completely desynced from consensus

## Impact Explanation

This vulnerability achieves **High Severity** under the Aptos Bug Bounty criteria:

- **Validator node slowdowns**: Observer nodes become permanently non-functional
- **Significant protocol violations**: Observers lose all ability to track consensus
- **Liveness failure**: Affected observers cannot serve their intended purpose

While this affects observer nodes (not validator nodes), consensus observers are critical infrastructure for monitoring consensus and serving read requests. Their permanent failure impacts network observability and downstream systems relying on them.

The attack requires only that an attacker controls a single peer that the observer subscribes to, which could occur through:
- Compromising a legitimate validator
- Social engineering observer operators to subscribe to malicious peers
- Exploiting vulnerabilities in peer discovery

## Likelihood Explanation

**Likelihood: Medium-to-High**

- **Ease of exploitation**: Attack is trivial - send a single malformed message
- **No special privileges required**: Any subscribed peer can exploit this
- **No cryptographic barriers**: No signature verification occurs for future epochs
- **Persistent damage**: Single successful attack causes permanent node failure
- **Detection difficulty**: Appears as normal state sync activity until failure

The primary barrier is that the attacker must be accepted as a subscription peer by the target observer. However, given the number of observers and diversity of peer selection strategies, exploitation opportunities exist.

## Recommendation

**Immediate Fix:** Verify future epoch commit signatures before processing, or defer handling until epoch transition occurs naturally.

**Suggested Code Changes:**

```rust
// In process_commit_decision_message(), lines 466-527
if commit_epoch == epoch_state.epoch {
    // Current logic for current epoch (already has verification)
    if let Err(error) = commit_decision.verify_commit_proof(&epoch_state) {
        error!(...);
        increment_invalid_message_counter(&peer_network_id, metrics::COMMIT_DECISION_LABEL);
        return;
    }
    // ... process verified commit
} else if commit_epoch > epoch_state.epoch {
    // NEW: Buffer future epoch commits instead of immediately processing
    // Store them temporarily and re-verify after epoch transition
    warn!(
        LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
            "Received commit for future epoch {}. Current epoch: {}. Buffering for later verification.",
            commit_epoch, epoch_state.epoch
        ))
    );
    
    // Option 1: Buffer in a future_epoch_commits map, verify after epoch change
    // Option 2: Simply drop and rely on receiving it again after epoch transition
    // Option 3: Trigger epoch change detection but DON'T update root until verified
    
    return; // Do NOT proceed to state sync with unverified future epoch commits
}
```

**Additional Safeguards:**

1. Add timeout/recovery mechanism for failed state sync operations
2. Validate state sync targets before updating root state
3. Implement rollback capability if state sync fails
4. Add metrics for rejected future epoch commits

## Proof of Concept

```rust
// Rust integration test demonstrating the attack
#[tokio::test]
async fn test_unverified_future_epoch_commit_attack() {
    // Setup: Create consensus observer at epoch 10, round 100
    let (observer, peer_network_id) = setup_observer_at_epoch(10, 100).await;
    
    // Attacker: Craft malicious commit for future epoch with invalid signatures
    let malicious_commit = CommitDecision::new(
        LedgerInfoWithSignatures::new(
            LedgerInfo::new(
                BlockInfo::new(
                    11, // Future epoch
                    1,  // Low round
                    HashValue::random(),
                    HashValue::random(),
                    0,
                    0,
                    None,
                ),
                HashValue::random(),
            ),
            AggregateSignature::empty(), // Invalid/empty signatures
        )
    );
    
    // Send malicious commit from subscribed peer
    let message = ConsensusObserverDirectSend::CommitDecision(malicious_commit);
    observer.process_network_message(
        ConsensusObserverNetworkMessage::new(peer_network_id, message)
    ).await;
    
    // Verify observer is now stuck:
    // 1. Root updated to epoch 11 round 1 (unverified)
    let root = observer.observer_block_data.lock().root();
    assert_eq!(root.ledger_info().epoch(), 11);
    assert_eq!(root.ledger_info().round(), 1);
    
    // 2. State sync is active but will fail
    assert!(observer.state_sync_manager.is_syncing_to_commit());
    
    // 3. Legitimate epoch 10 commits are now rejected
    let legitimate_commit = create_valid_commit(10, 101);
    observer.process_network_message(
        ConsensusObserverNetworkMessage::new(peer_network_id, legitimate_commit)
    ).await;
    
    // 4. Legitimate commit was dropped (epoch 10 < fake root epoch 11)
    let highest_committed = observer.observer_block_data
        .lock()
        .get_highest_committed_epoch_round();
    assert_eq!(highest_committed, (11, 1)); // Still stuck at fake commit
    
    // Observer is permanently desynced - VULNERABILITY CONFIRMED
}
```

## Notes

The TODO comment explicitly acknowledges this issue but provides no mitigation. The problem is architectural: future epoch commits cannot be verified without the future epoch's validator set, yet the current implementation treats them as trustworthy. The fix requires either buffering for later verification or rejecting them entirely until epoch transition occurs through normal consensus mechanisms.

This vulnerability demonstrates a critical gap in the trust boundary between consensus observers and their subscribed peers, where cryptographic guarantees are bypassed for operational convenience.

### Citations

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L453-461)
```rust
        let get_highest_committed_epoch_round = self
            .observer_block_data
            .lock()
            .get_highest_committed_epoch_round();
        if (commit_epoch, commit_round) <= get_highest_committed_epoch_round {
            // Update the metrics for the dropped commit decision
            update_metrics_for_dropped_commit_decision_message(peer_network_id, &commit_decision);
            return;
        }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L466-495)
```rust
        // If the commit decision is for the current epoch, verify and process it
        let epoch_state = self.get_epoch_state();
        if commit_epoch == epoch_state.epoch {
            // Verify the commit decision
            if let Err(error) = commit_decision.verify_commit_proof(&epoch_state) {
                // Log the error and update the invalid message counter
                error!(
                    LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                        "Failed to verify commit decision! Ignoring: {:?}, from peer: {:?}. Error: {:?}",
                        commit_decision.proof_block_info(),
                        peer_network_id,
                        error
                    ))
                );
                increment_invalid_message_counter(&peer_network_id, metrics::COMMIT_DECISION_LABEL);
                return;
            }

            // Update the latency metrics for commit processing
            update_message_processing_latency_metrics(
                message_received_time,
                &peer_network_id,
                metrics::COMMIT_DECISION_LABEL,
            );

            // Update the pending blocks with the commit decision
            if self.process_commit_decision_for_pending_block(&commit_decision) {
                return; // The commit decision was successfully processed
            }
        }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L497-527)
```rust
        // TODO: identify the best way to handle an invalid commit decision
        // for a future epoch. In such cases, we currently rely on state sync.

        // Otherwise, we failed to process the commit decision. If the commit
        // is for a future epoch or round, we need to state sync.
        let last_block = self.observer_block_data.lock().get_last_ordered_block();
        let epoch_changed = commit_epoch > last_block.epoch();
        if epoch_changed || commit_round > last_block.round() {
            // If we're waiting for state sync to transition into a new epoch,
            // we should just wait and not issue a new state sync request.
            if self.state_sync_manager.is_syncing_through_epoch() {
                info!(
                    LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                        "Already waiting for state sync to reach new epoch: {:?}. Dropping commit decision: {:?}!",
                        self.observer_block_data.lock().root().commit_info(),
                        commit_decision.proof_block_info()
                    ))
                );
                return;
            }

            // Otherwise, we should start the state sync process for the commit.
            // Update the block data (to the commit decision).
            self.observer_block_data
                .lock()
                .update_blocks_for_state_sync_commit(&commit_decision);

            // Start state syncing to the commit decision
            self.state_sync_manager
                .sync_to_commit(commit_decision, epoch_changed);
        }
```

**File:** consensus/src/consensus_observer/network/observer_message.rs (L366-376)
```rust
    /// Verifies the commit proof and returns an error if the proof is invalid
    pub fn verify_commit_proof(&self, epoch_state: &EpochState) -> Result<(), Error> {
        epoch_state.verify(&self.commit_proof).map_err(|error| {
            Error::InvalidMessageError(format!(
                "Failed to verify commit proof ledger info: {:?}, Error: {:?}",
                self.proof_block_info(),
                error
            ))
        })
    }
}
```

**File:** consensus/src/consensus_observer/observer/block_data.rs (L275-291)
```rust
    pub fn update_blocks_for_state_sync_commit(&mut self, commit_decision: &CommitDecision) {
        // Get the commit proof, epoch and round
        let commit_proof = commit_decision.commit_proof();
        let commit_epoch = commit_decision.epoch();
        let commit_round = commit_decision.round();

        // Update the root
        self.update_root(commit_proof.clone());

        // Update the block payload store
        self.block_payload_store
            .remove_blocks_for_epoch_round(commit_epoch, commit_round);

        // Update the ordered block store
        self.ordered_block_store
            .remove_blocks_for_commit(commit_proof);
    }
```

**File:** consensus/src/consensus_observer/observer/state_sync_manager.rs (L189-231)
```rust
    /// Invokes state sync to synchronize to a new commit decision
    pub fn sync_to_commit(&mut self, commit_decision: CommitDecision, epoch_changed: bool) {
        // Log that we're starting to sync to the commit decision
        info!(
            LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                "Started syncing to commit: {}!",
                commit_decision.proof_block_info()
            ))
        );

        // Get the commit decision epoch and round
        let commit_epoch = commit_decision.epoch();
        let commit_round = commit_decision.round();

        // Clone the required components for the state sync task
        let execution_client = self.execution_client.clone();
        let sync_notification_sender = self.state_sync_notification_sender.clone();

        // Spawn a task to sync to the commit decision
        let (abort_handle, abort_registration) = AbortHandle::new_pair();
        tokio::spawn(Abortable::new(
            async move {
                // Update the state sync metrics now that we're syncing to a commit
                metrics::set_gauge_with_label(
                    &metrics::OBSERVER_STATE_SYNC_EXECUTING,
                    metrics::STATE_SYNCING_TO_COMMIT,
                    1, // We're syncing to a commit decision
                );

                // Sync to the commit decision
                if let Err(error) = execution_client
                    .clone()
                    .sync_to_target(commit_decision.commit_proof().clone())
                    .await
                {
                    error!(
                        LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                            "Failed to sync to commit decision: {:?}! Error: {:?}",
                            commit_decision, error
                        ))
                    );
                    return;
                }
```
