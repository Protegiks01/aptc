# Audit Report

## Title
RoundProposer Configuration Lacks Validator Set Validation, Enabling Governance-Based Consensus Liveness Attacks

## Summary
The `RoundProposer` implementation accepts arbitrary account addresses from on-chain governance proposals without validating that these addresses belong to the current validator set. A malicious governance proposal can inject invalid addresses into the round-to-proposer mapping, causing targeted consensus rounds to timeout and degrading network liveness.

## Finding Description

The vulnerability exists across multiple validation points in the consensus configuration system:

**1. Missing Validation in Move Smart Contract**

The `consensus_config::set_for_next_epoch` function only checks that configuration bytes are non-empty, without validating the actual proposer addresses: [1](#0-0) 

**2. No Validation in Configuration Type Definition**

The `ProposerElectionType::RoundProposer` variant accepts a raw `HashMap<Round, AccountAddress>` without constraints: [2](#0-1) 

**3. Direct Usage Without Validation in Consensus**

When creating the proposer election handler, the `round_proposers` HashMap from the on-chain config is directly cloned and passed to `RoundProposer::new` without checking if the addresses are valid validators: [3](#0-2) 

**4. Constructor Accepts Arbitrary Addresses**

The `RoundProposer::new` constructor accepts any HashMap without validation: [4](#0-3) 

**Attack Path:**

1. Attacker with governance control crafts a malicious `ConsensusConfig` containing `ProposerElectionType::RoundProposer` with invalid addresses (e.g., `{100: 0xDEADBEEF, 200: 0xBADC0FFE}`)
2. Governance proposal passes through normal voting process
3. Configuration is applied at next epoch boundary
4. When consensus reaches round 100:
   - All validators call `get_valid_proposer(100)` → returns `0xDEADBEEF`
   - Each validator checks `is_valid_proposer(their_address, 100)` → returns `false`
   - No validator creates a proposal for round 100
   - Round times out after configured timeout period
   - Consensus proceeds to round 101 [5](#0-4) 

While block signature verification would catch an invalid proposer attempting to sign a block, the attack prevents any legitimate validator from proposing, so no block is ever created: [6](#0-5) 

The validation in `block_prologue_common` is never reached because no block enters the execution phase: [7](#0-6) 

## Impact Explanation

**High Severity** - This vulnerability causes:

1. **Consensus Liveness Degradation**: Targeted rounds always timeout, increasing transaction latency
2. **Predictable Denial-of-Service**: Attacker can block specific rounds (e.g., every 10th round) for the entire epoch
3. **Performance Disruption**: Validator reputation scores are negatively impacted by failed rounds
4. **Resource Waste**: Validators spend computation processing timeouts instead of consensus

This meets **High Severity** criteria per Aptos Bug Bounty:
- "Validator node slowdowns" - forced timeouts degrade consensus performance
- "Significant protocol violations" - violates the invariant that proposer election returns valid validators

While not reaching Critical severity (network continues operating), it represents a measurable governance attack vector that can disrupt consensus timing and performance for an entire epoch duration.

## Likelihood Explanation

**Likelihood: Medium-Low**

**Requirements:**
- Attacker must control sufficient governance stake to propose and pass a proposal
- Requires understanding of BCS serialization and `ConsensusConfig` structure
- Attack is detectable (governance proposals are public)

**Feasibility:**
- Governance mechanisms are designed to be used by major stakeholders
- No technical complexity beyond crafting the malicious configuration bytes
- Impact is guaranteed once proposal passes and epoch transitions

**Mitigation Factors:**
- Governance participants are generally trusted (high stake requirement)
- Can be reverted by subsequent governance proposal
- Does not cause permanent damage or complete network halt

## Recommendation

**Primary Fix: Add Validator Set Validation in Epoch Manager**

Validate that all addresses in the `RoundProposer` mapping belong to the current validator set when creating the proposer election handler:

```rust
// In consensus/src/epoch_manager.rs, around line 396
ProposerElectionType::RoundProposer(round_proposers) => {
    let proposers = epoch_state
        .verifier
        .get_ordered_account_addresses_iter()
        .collect::<Vec<_>>();
    
    // Validate all addresses are in validator set
    for (round, proposer) in round_proposers.iter() {
        ensure!(
            epoch_state.verifier.get_public_key(proposer).is_some(),
            "RoundProposer config contains invalid address {:?} for round {} - not in validator set",
            proposer,
            round
        );
    }
    
    let default_proposer = proposers
        .first()
        .expect("INVARIANT VIOLATION: proposers is empty");
    Arc::new(RoundProposer::new(
        round_proposers.clone(),
        *default_proposer,
    ))
}
```

**Secondary Fix: Add Move-Level Validation**

Add a native function in `consensus_config.move` to validate configuration bytes before acceptance:

```move
// Validate that config is well-formed and contains only valid validator addresses
native fun validate_consensus_config_internal(config_bytes: vector<u8>): bool;

public fun set_for_next_epoch(account: &signer, config: vector<u8>) {
    system_addresses::assert_aptos_framework(account);
    assert!(vector::length(&config) > 0, error::invalid_argument(EINVALID_CONFIG));
    assert!(validate_consensus_config_internal(config), error::invalid_argument(EINVALID_CONFIG));
    std::config_buffer::upsert<ConsensusConfig>(ConsensusConfig {config});
}
```

## Proof of Concept

```rust
// Test demonstrating the vulnerability
#[test]
fn test_round_proposer_invalid_address_causes_timeout() {
    use crate::liveness::{
        proposer_election::ProposerElection,
        round_proposer_election::RoundProposer,
    };
    use aptos_types::account_address::AccountAddress;
    use std::collections::HashMap;
    
    // Simulate validator set
    let validator1 = AccountAddress::from_hex_literal("0x1").unwrap();
    let validator2 = AccountAddress::from_hex_literal("0x2").unwrap();
    
    // Malicious address not in validator set
    let invalid_address = AccountAddress::from_hex_literal("0xDEADBEEF").unwrap();
    
    // Create malicious round proposer mapping
    let mut round_proposers = HashMap::new();
    round_proposers.insert(100, invalid_address); // Round 100 points to invalid address
    round_proposers.insert(101, validator1);      // Round 101 is normal
    
    let proposer_election = RoundProposer::new(round_proposers, validator1);
    
    // For round 100, no legitimate validator can propose
    assert!(!proposer_election.is_valid_proposer(validator1, 100));
    assert!(!proposer_election.is_valid_proposer(validator2, 100));
    assert_eq!(proposer_election.get_valid_proposer(100), invalid_address);
    
    // Round 101 works normally
    assert!(proposer_election.is_valid_proposer(validator1, 101));
    
    // This demonstrates that round 100 will timeout since no validator
    // can propose, causing liveness degradation
}
```

**Notes**

The vulnerability is exploitable by governance participants with sufficient stake to pass proposals. While the trust model generally assumes governance participants are trusted, the security question explicitly scopes "malicious governance proposals," indicating this attack vector is within scope. The vulnerability enables targeted consensus disruption for the duration of an epoch, representing a significant protocol violation per the High Severity criteria. The fix is straightforward: validate proposer addresses against the validator set at configuration application time.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/configs/consensus_config.move (L52-56)
```text
    public fun set_for_next_epoch(account: &signer, config: vector<u8>) {
        system_addresses::assert_aptos_framework(account);
        assert!(vector::length(&config) > 0, error::invalid_argument(EINVALID_CONFIG));
        std::config_buffer::upsert<ConsensusConfig>(ConsensusConfig {config});
    }
```

**File:** types/src/on_chain_config/consensus_config.rs (L522-522)
```rust
    RoundProposer(HashMap<Round, AccountAddress>),
```

**File:** consensus/src/epoch_manager.rs (L396-404)
```rust
            ProposerElectionType::RoundProposer(round_proposers) => {
                // Hardcoded to the first proposer
                let default_proposer = proposers
                    .first()
                    .expect("INVARIANT VIOLATION: proposers is empty");
                Arc::new(RoundProposer::new(
                    round_proposers.clone(),
                    *default_proposer,
                ))
```

**File:** consensus/src/liveness/round_proposer_election.rs (L18-23)
```rust
    pub fn new(proposers: HashMap<Round, Author>, default_proposer: Author) -> Self {
        Self {
            proposers,
            default_proposer,
        }
    }
```

**File:** consensus/src/liveness/round_proposer_election.rs (L27-32)
```rust
    fn get_valid_proposer(&self, round: Round) -> Author {
        match self.proposers.get(&round) {
            None => self.default_proposer,
            Some(round_proposer) => *round_proposer,
        }
    }
```

**File:** types/src/validator_verifier.rs (L255-266)
```rust
    pub fn verify<T: Serialize + CryptoHash>(
        &self,
        author: AccountAddress,
        message: &T,
        signature: &bls12381::Signature,
    ) -> std::result::Result<(), VerifyError> {
        match self.get_public_key(&author) {
            Some(public_key) => public_key
                .verify_struct_signature(message, signature)
                .map_err(|_| VerifyError::InvalidMultiSignature),
            None => Err(VerifyError::UnknownAuthor),
        }
```

**File:** aptos-move/framework/aptos-framework/sources/block.move (L168-171)
```text
        assert!(
            proposer == @vm_reserved || stake::is_current_epoch_validator(proposer),
            error::permission_denied(EINVALID_PROPOSER),
        );
```
