# Audit Report

## Title
Malicious Governance Can Inject Fraudulent OIDC Providers Leading to Keyless Account Compromise and Fund Theft

## Summary
The JWK consensus system lacks validation of OIDC provider configurations set through governance proposals. A malicious or compromised governance proposal can insert arbitrary OIDC providers with attacker-controlled endpoints, causing all validators to fetch and reach consensus on fraudulent JWKs. These fraudulent JWKs are then used to validate keyless account signatures, enabling complete authentication bypass and theft of funds from any keyless account.

## Finding Description

The vulnerability exists across multiple layers of the JWK consensus system:

**1. No Validation During Configuration** [1](#0-0) 

At this point, OIDC providers are extracted from on-chain configuration without any validation of the URLs or issuer names. The code simply converts the Move types to Rust types with no security checks.

**2. Governance Can Set Arbitrary Providers** [2](#0-1) 

The `set_for_next_epoch` function allows the framework signer (obtained via governance) to set any JWKConsensusConfig, with only duplicate name checking: [3](#0-2) 

The `new_oidc_provider` function accepts arbitrary strings without validation: [4](#0-3) 

**3. Validators Blindly Fetch from Configured URLs** [5](#0-4) 

The fetch functions perform no validation of URLs or content. They simply make HTTP requests to whatever URL is provided and parse the response. [6](#0-5) 

**4. Consensus on Identical Fraudulent Data** [7](#0-6) 

Validators will reach consensus if they all observe the same data. A malicious server that returns identical fraudulent JWKs to all validators will successfully achieve consensus.

**5. No Validation During Keyless Authentication** [8](#0-7) 

Keyless validation retrieves JWKs from on-chain state by issuer without additional validation. It trusts whatever JWKs were stored through consensus.

**Attack Path:**

1. Attacker controls or compromises a governance proposal (requires 2/3+ voting power)
2. Proposal updates JWKConsensusConfig with malicious OIDC provider:
   - `name`: "https://accounts.google.com" (spoofing legitimate issuer)
   - `config_url`: "https://attacker-controlled.com/.well-known/openid-configuration"
3. At next epoch, all validators spawn observers that fetch from attacker's URL
4. Attacker's server returns fraudulent OpenID configuration and JWKs (same response to all validators)
5. All validators observe identical fraudulent JWKs
6. Validators reach consensus (2/3+ agree on the same data)
7. Fraudulent JWKs committed to chain under issuer "https://accounts.google.com"
8. Attacker creates JWT with `iss: "https://accounts.google.com"`, signed with attacker's private key matching the fraudulent JWK
9. Keyless validation retrieves fraudulent JWK from on-chain state
10. Signature validates successfully → **Unauthorized access to keyless accounts → Theft of funds**

## Impact Explanation

This vulnerability meets **Critical Severity** criteria under "Loss of Funds (theft or minting)":

- **Direct Theft Path**: Attacker gains unauthorized access to any keyless account by forging valid-looking JWTs
- **Scope**: Affects all keyless accounts using the spoofed issuer
- **Irreversibility**: Once fraudulent JWKs are on-chain and funds are stolen, recovery requires hardfork
- **Authentication Bypass**: Complete circumvention of OIDC-based authentication security model

The vulnerability breaks multiple critical invariants:
- **Cryptographic Correctness**: System accepts fraudulent cryptographic material
- **Access Control**: Unauthorized access to protected accounts
- **Governance Integrity**: Governance can subvert authentication without validation checks

## Likelihood Explanation

**Likelihood: Medium**

**Required Conditions:**
- Governance proposal must pass with 2/3+ voting power
- Requires either governance compromise or malicious insiders

**Factors Increasing Likelihood:**
- No technical barriers once governance control achieved
- Governance proposals may not receive sufficient security scrutiny
- Attack is not immediately obvious from proposal text
- Social engineering of governance participants possible
- Single malicious proposal affects all future keyless authentications

**Factors Decreasing Likelihood:**
- Requires significant governance control (2/3+ voting power)
- High-value target would likely receive security review
- Attack leaves on-chain evidence

Despite requiring governance control, this represents a **critical defense-in-depth failure**. Governance should have guardrails preventing catastrophic security breaches even if compromised.

## Recommendation

Implement multi-layered validation:

**1. OIDC Provider Allowlist:**
```move
// In jwk_consensus_config.move
const ALLOWED_OIDC_PROVIDERS: vector<String> = vector[
    utf8(b"https://accounts.google.com"),
    utf8(b"https://appleid.apple.com"),
    // ... other trusted providers
];

public fun new_oidc_provider(name: String, config_url: String): OIDCProvider {
    // Validate name is in allowlist
    assert!(vector::contains(&ALLOWED_OIDC_PROVIDERS, &name), EINVALID_PROVIDER);
    
    // Validate config_url domain matches name
    assert!(validate_url_domain_matches(&name, &config_url), EURL_DOMAIN_MISMATCH);
    
    OIDCProvider { name, config_url }
}
```

**2. URL Domain Validation in Rust:**
```rust
// In types/src/on_chain_config/jwk_consensus_config.rs
impl OIDCProvider {
    pub fn validate(&self) -> anyhow::Result<()> {
        // Enforce HTTPS
        ensure!(self.config_url.starts_with("https://"), "config_url must use HTTPS");
        
        // Extract domain from issuer name and config_url
        let issuer_domain = extract_domain(&self.name)?;
        let config_domain = extract_domain(&self.config_url)?;
        
        // Verify domains match
        ensure!(issuer_domain == config_domain, "Issuer domain must match config_url domain");
        
        Ok(())
    }
}
```

**3. Separate Governance for Security-Critical Changes:**
- Require higher threshold (e.g., 80%) for OIDC provider changes
- Implement time delays before changes take effect
- Add emergency pause mechanism for JWK consensus

**4. Runtime Validation:**
- Verify fetched OpenID configuration issuer field matches expected issuer
- Implement certificate pinning for known providers
- Add anomaly detection for sudden JWK changes

## Proof of Concept

```rust
// Test demonstrating the vulnerability
#[tokio::test]
async fn test_malicious_oidc_provider_attack() {
    // 1. Setup: Malicious HTTP server returning fraudulent JWKs
    let malicious_server = start_fake_oidc_server(|_| {
        // Return fake OpenID config
        json!({
            "issuer": "https://accounts.google.com",
            "jwks_uri": "https://attacker.com/jwks"
        })
    });
    
    // 2. Create malicious governance proposal
    let malicious_provider = OIDCProvider {
        name: b"https://accounts.google.com".to_vec(),
        config_url: format!("http://localhost:{}/openid-config", malicious_server.port()).into_bytes(),
    };
    
    let config = OnChainJWKConsensusConfig::V1(ConfigV1 {
        oidc_providers: vec![malicious_provider],
    });
    
    // 3. Simulate epoch change with malicious config
    let mut epoch_manager = setup_epoch_manager();
    epoch_manager.start_new_epoch(create_payload_with_config(config)).await.unwrap();
    
    // 4. Validators fetch from malicious endpoint
    tokio::time::sleep(Duration::from_secs(15)).await; // Wait for fetch cycle
    
    // 5. Verify fraudulent JWKs reached consensus and are on-chain
    let on_chain_jwks = fetch_on_chain_jwks();
    assert!(on_chain_jwks.get_provider_jwks("https://accounts.google.com").is_some());
    
    // 6. Demonstrate authentication bypass
    let fraudulent_jwt = create_jwt_signed_by_attacker("https://accounts.google.com");
    let validation_result = validate_keyless_signature(fraudulent_jwt, on_chain_jwks);
    
    // VULNERABILITY: Fraudulent JWT validates successfully!
    assert!(validation_result.is_ok());
}
```

**Notes:**
- This vulnerability exists even though it requires governance control, as the question explicitly explores governance as a threat vector
- The lack of validation represents a critical defense-in-depth failure
- Real-world impact depends on governance security, but defense-in-depth principles require validation at multiple layers
- The attack is technically straightforward once governance control is achieved, requiring only a standard web server returning fraudulent JSON responses

### Citations

**File:** crates/aptos-jwk-consensus/src/epoch_manager.rs (L177-186)
```rust
        let (jwk_manager_should_run, oidc_providers) = match jwk_consensus_config {
            Ok(config) => {
                let should_run =
                    config.jwk_consensus_enabled() && onchain_consensus_config.is_vtxn_enabled();
                let providers = config
                    .oidc_providers_cloned()
                    .into_iter()
                    .map(jwks::OIDCProvider::from)
                    .collect();
                (should_run, Some(SupportedOIDCProviders { providers }))
```

**File:** aptos-move/framework/aptos-framework/sources/configs/jwk_consensus_config.move (L62-65)
```text
    public fun set_for_next_epoch(framework: &signer, config: JWKConsensusConfig) {
        system_addresses::assert_aptos_framework(framework);
        config_buffer::upsert(config);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/jwk_consensus_config.move (L90-102)
```text
    public fun new_v1(oidc_providers: vector<OIDCProvider>): JWKConsensusConfig {
        let name_set = simple_map::new<String, u64>();
        vector::for_each_ref(&oidc_providers, |provider| {
            let provider: &OIDCProvider = provider;
            let (_, old_value) = simple_map::upsert(&mut name_set, provider.name, 0);
            if (option::is_some(&old_value)) {
                abort(error::invalid_argument(EDUPLICATE_PROVIDERS))
            }
        });
        JWKConsensusConfig {
            variant: copyable_any::pack( ConfigV1 { oidc_providers } )
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/jwk_consensus_config.move (L105-107)
```text
    public fun new_oidc_provider(name: String, config_url: String): OIDCProvider {
        OIDCProvider { name, config_url }
    }
```

**File:** crates/jwk-utils/src/lib.rs (L25-37)
```rust
pub async fn fetch_jwks_from_jwks_uri(
    my_addr: Option<AccountAddress>,
    jwks_uri: &str,
) -> Result<Vec<JWK>> {
    let client = reqwest::Client::new();
    let mut request_builder = client.get(jwks_uri);
    if let Some(addr) = my_addr {
        request_builder = request_builder.header(COOKIE, addr.to_hex());
    }
    let JWKsResponse { keys } = request_builder.send().await?.json().await?;
    let jwks = keys.into_iter().map(JWK::from).collect();
    Ok(jwks)
}
```

**File:** crates/jwk-utils/src/lib.rs (L40-44)
```rust
pub async fn fetch_jwks_uri_from_openid_config(config_url: &str) -> Result<String> {
    let client = reqwest::Client::new();
    let OpenIDConfiguration { jwks_uri, .. } = client.get(config_url).send().await?.json().await?;
    Ok(jwks_uri)
}
```

**File:** crates/aptos-jwk-consensus/src/observation_aggregation/mod.rs (L81-84)
```rust
        ensure!(
            self.local_view == peer_view,
            "adding peer observation failed with mismatched view"
        );
```

**File:** aptos-move/aptos-vm/src/keyless_validation.rs (L112-126)
```rust
fn get_jwk_for_authenticator(
    jwks: &AllProvidersJWKs,
    pk: &KeylessPublicKey,
    sig: &KeylessSignature,
) -> Result<JWK, VMStatus> {
    let jwt_header = sig
        .parse_jwt_header()
        .map_err(|_| invalid_signature!("Failed to parse JWT header"))?;

    let jwk_move_struct = jwks.get_jwk(&pk.iss_val, &jwt_header.kid).map_err(|_| {
        invalid_signature!(format!(
            "JWK for {} with KID {} was not found",
            pk.iss_val, jwt_header.kid
        ))
    })?;
```
