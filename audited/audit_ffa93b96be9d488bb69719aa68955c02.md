# Audit Report

## Title
Unauthenticated Inspection Service Exposes Validator Network Topology and Operational Metadata

## Summary
The Aptos inspection service lacks authentication mechanisms and binds to all network interfaces (0.0.0.0) by default, allowing any network attacker to access sensitive operational information including validator network topology, peer IP addresses, and connection metadata when the service is exposed on a public interface.

## Finding Description

The inspection service in Aptos Core provides multiple HTTP endpoints for debugging and monitoring without any authentication layer. The service configuration defaults to binding on all network interfaces, making it accessible from the public internet if firewall rules are misconfigured. [1](#0-0) 

The service has no authentication logic in its request handling: [2](#0-1) 

Multiple endpoints expose sensitive operational information by default:

**1. Identity Information Endpoint** (`/identity_information`) - enabled by default: [3](#0-2) 

This exposes validator peer IDs: [4](#0-3) 

**2. Peer Information Endpoint** (`/peer_information`) - enabled by default: [5](#0-4) 

This endpoint exposes connection metadata including actual IP addresses of connected peers: [6](#0-5) 

The `ConnectionMetadata` structure contains the network address field with actual IP addresses: [7](#0-6) 

**Attack Scenario:**
1. Attacker scans for exposed port 9101 (default inspection service port)
2. Issues HTTP GET to `http://<target-ip>:9101/peer_information`
3. Extracts `ConnectionMetadata` from response containing `addr` field with IP addresses
4. Maps complete validator network topology including peer IDs and IP addresses
5. Uses this intelligence for targeted network-level attacks or validator deanonymization

**Security Guarantee Violations:**
While this doesn't directly break consensus protocol invariants, it violates operational security principles by exposing infrastructure topology that could enable attacks against validator availability and network partitioning.

## Impact Explanation

This finding is categorized as **Low to Medium Severity** under the Aptos bug bounty criteria:

- **Low Severity** ($1,000): "Minor information leaks" - The service exposes operational metadata
- Potentially **Medium Severity** if the information disclosure enables state inconsistencies requiring intervention

The exposure includes:
- Validator peer IDs (though these are derivable from on-chain validator set)
- **Actual IP addresses of connected validators** (not available on-chain)
- Network topology and connection patterns
- Internal synchronization state
- System and build information

This information enables reconnaissance for subsequent attacks, though those attacks (e.g., DDoS) may be out of scope per bug bounty rules. However, the information disclosure itself facilitates targeted attacks that could lead to "Validator node slowdowns" (High severity).

## Likelihood Explanation

**High Likelihood** in misconfigured deployments:

1. **Default configuration is insecure**: Binds to 0.0.0.0, not 127.0.0.1
2. **Operator awareness**: Node operators may not realize this service exposes sensitive data
3. **No warning**: The configuration sanitizer only prevents `/configuration` exposure on mainnet validators, not `/peer_information` or `/identity_information` [8](#0-7) 

4. **Documentation gap**: Operators may follow example configs that don't explicitly secure this service
5. **Docker/container deployments**: Logic exists to determine binding address based on container environment, but production deployments may not follow this pattern [9](#0-8) 

## Recommendation

**Immediate Mitigations:**

1. **Change default binding address** to `127.0.0.1` for production configurations:
```rust
// In config/src/config/inspection_service_config.rs
fn default() -> InspectionServiceConfig {
    InspectionServiceConfig {
        address: "127.0.0.1".to_string(), // Changed from 0.0.0.0
        port: 9101,
        expose_configuration: false,
        expose_identity_information: false, // Changed to false for validators
        expose_peer_information: false, // Changed to false for validators  
        expose_system_information: true,
    }
}
```

2. **Add authentication layer** using token-based auth or IP allowlisting:
```rust
// Add to InspectionServiceConfig
pub struct InspectionServiceConfig {
    // ... existing fields ...
    pub allowed_ips: Vec<String>,
    pub auth_token: Option<String>,
}
```

3. **Enhance configuration sanitizer** to warn on mainnet when binding to 0.0.0.0:
```rust
// In config_sanitizer::sanitize()
if chain_id.is_mainnet() && 
   node_type.is_validator() && 
   inspection_service_config.address == "0.0.0.0" {
    return Err(Error::ConfigSanitizerFailed(
        sanitizer_name,
        "Mainnet validators should bind inspection service to 127.0.0.1".to_string(),
    ));
}
```

4. **Disable sensitive endpoints by default** for mainnet validators in the optimizer: [10](#0-9) 

5. **Add prominent security warnings** in documentation and configuration templates

## Proof of Concept

**Reconnaissance Script:**
```bash
#!/bin/bash
# Scan for exposed inspection services and extract peer information

TARGET_IP=$1
PORT=9101

echo "Testing inspection service on $TARGET_IP:$PORT"

# Test identity information endpoint
echo -e "\n[+] Fetching identity information:"
curl -s "http://$TARGET_IP:$PORT/identity_information"

# Test peer information endpoint  
echo -e "\n\n[+] Fetching peer information:"
curl -s "http://$TARGET_IP:$PORT/peer_information"

# Parse connection metadata to extract IP addresses
echo -e "\n\n[+] Extracting peer IP addresses:"
curl -s "http://$TARGET_IP:$PORT/peer_information" | \
  grep -oP '"addr":"[^"]*"' | \
  sed 's/"addr":"//g' | sed 's/"//g'
```

**Expected Output on Vulnerable Node:**
```
Testing inspection service on X.X.X.X:9101

[+] Fetching identity information:
Identity Information:
    - Validator network (validator), peer ID: 0xABCD...1234
    - Fullnode network (vfn), peer ID: 0xDEF0...5678

[+] Fetching peer information:
Peer information summary:
    - Number of peers: 42
    - Registered networks: [validator, vfn]
    - Peers and network IDs: [...]

Connection metadata for each peer:
    - Peer: 0x1234.../validator, connection state: Connected, 
      connection metadata: {"remote_peer_id":"0x1234...","addr":"/ip4/10.20.30.40/tcp/6180",...}
    [...]

[+] Extracting peer IP addresses:
/ip4/10.20.30.40/tcp/6180
/ip4/10.20.30.41/tcp/6180
/ip4/10.20.30.42/tcp/6180
[...]
```

This demonstrates that an unauthenticated attacker can enumerate the entire validator network topology including actual IP addresses, which are not available through on-chain data alone.

## Notes

This vulnerability represents a **defense-in-depth failure** rather than a direct protocol attack. While the inspection service is intended for debugging, its default configuration creates an operational security risk that violates the principle of least privilege. The combination of no authentication, public binding, and sensitive data exposure creates an attack vector for infrastructure-level reconnaissance that could facilitate more sophisticated attacks against validator availability and network stability.

### Citations

**File:** config/src/config/inspection_service_config.rs (L26-37)
```rust
impl Default for InspectionServiceConfig {
    fn default() -> InspectionServiceConfig {
        InspectionServiceConfig {
            address: "0.0.0.0".to_string(),
            port: 9101,
            expose_configuration: false,
            expose_identity_information: true,
            expose_peer_information: true,
            expose_system_information: true,
        }
    }
}
```

**File:** config/src/config/inspection_service_config.rs (L45-69)
```rust
impl ConfigSanitizer for InspectionServiceConfig {
    fn sanitize(
        node_config: &NodeConfig,
        node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();
        let inspection_service_config = &node_config.inspection_service;

        // Verify that mainnet validators do not expose the configuration
        if let Some(chain_id) = chain_id {
            if node_type.is_validator()
                && chain_id.is_mainnet()
                && inspection_service_config.expose_configuration
            {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "Mainnet validators should not expose the node configuration!".to_string(),
                ));
            }
        }

        Ok(())
    }
}
```

**File:** config/src/config/inspection_service_config.rs (L71-109)
```rust
impl ConfigOptimizer for InspectionServiceConfig {
    fn optimize(
        node_config: &mut NodeConfig,
        local_config_yaml: &Value,
        _node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<bool, Error> {
        let inspection_service_config = &mut node_config.inspection_service;
        let local_inspection_config_yaml = &local_config_yaml["inspection_service"];

        // Enable all endpoints for non-mainnet nodes (to aid debugging)
        let mut modified_config = false;
        if let Some(chain_id) = chain_id {
            if !chain_id.is_mainnet() {
                if local_inspection_config_yaml["expose_configuration"].is_null() {
                    inspection_service_config.expose_configuration = true;
                    modified_config = true;
                }

                if local_inspection_config_yaml["expose_identity_information"].is_null() {
                    inspection_service_config.expose_identity_information = true;
                    modified_config = true;
                }

                if local_inspection_config_yaml["expose_peer_information"].is_null() {
                    inspection_service_config.expose_peer_information = true;
                    modified_config = true;
                }

                if local_inspection_config_yaml["expose_system_information"].is_null() {
                    inspection_service_config.expose_system_information = true;
                    modified_config = true;
                }
            }
        }

        Ok(modified_config)
    }
}
```

**File:** crates/aptos-inspection-service/src/server/mod.rs (L104-169)
```rust
async fn serve_requests(
    req: Request<Body>,
    node_config: NodeConfig,
    aptos_data_client: AptosDataClient,
    peers_and_metadata: Arc<PeersAndMetadata>,
) -> Result<Response<Body>, hyper::Error> {
    // Process the request and get the response components
    let (status_code, body, content_type) = match req.uri().path() {
        CONFIGURATION_PATH => {
            // /configuration
            // Exposes the node configuration
            configuration::handle_configuration_request(&node_config)
        },
        CONSENSUS_HEALTH_CHECK_PATH => {
            // /consensus_health_check
            // Exposes the consensus health check
            metrics::handle_consensus_health_check(&node_config).await
        },
        FORGE_METRICS_PATH => {
            // /forge_metrics
            // Exposes forge encoded metrics
            metrics::handle_forge_metrics()
        },
        IDENTITY_INFORMATION_PATH => {
            // /identity_information
            // Exposes the identity information of the node
            identity_information::handle_identity_information_request(&node_config)
        },
        INDEX_PATH => {
            // /
            // Exposes the index and list of available endpoints
            index::handle_index_request()
        },
        JSON_METRICS_PATH => {
            // /json_metrics
            // Exposes JSON encoded metrics
            metrics::handle_json_metrics_request()
        },
        METRICS_PATH => {
            // /metrics
            // Exposes text encoded metrics
            metrics::handle_metrics_request()
        },
        PEER_INFORMATION_PATH => {
            // /peer_information
            // Exposes the peer information
            peer_information::handle_peer_information_request(
                &node_config,
                aptos_data_client,
                peers_and_metadata,
            )
        },
        SYSTEM_INFORMATION_PATH => {
            // /system_information
            // Exposes the system and build information
            system_information::handle_system_information_request(node_config)
        },
        _ => {
            // Handle the invalid path
            (
                StatusCode::NOT_FOUND,
                Body::from(INVALID_ENDPOINT_MESSAGE),
                CONTENT_TYPE_TEXT.into(),
            )
        },
    };
```

**File:** crates/aptos-inspection-service/src/server/identity_information.rs (L13-26)
```rust
pub fn handle_identity_information_request(node_config: &NodeConfig) -> (StatusCode, Body, String) {
    // Only return identity information if the endpoint is enabled
    let (status_code, body) = if node_config.inspection_service.expose_identity_information {
        let identity_information = get_identity_information(node_config);
        (StatusCode::OK, Body::from(identity_information))
    } else {
        (
            StatusCode::FORBIDDEN,
            Body::from(IDENTITY_INFO_DISABLED_MESSAGE),
        )
    };

    (status_code, body, CONTENT_TYPE_TEXT.into())
}
```

**File:** crates/aptos-inspection-service/src/server/identity_information.rs (L29-51)
```rust
fn get_identity_information(node_config: &NodeConfig) -> String {
    let mut identity_information = Vec::<String>::new();
    identity_information.push("Identity Information:".into());

    // If the validator network is configured, fetch the identity information
    if let Some(validator_network) = &node_config.validator_network {
        identity_information.push(format!(
            "\t- Validator network ({}), peer ID: {}",
            validator_network.network_id,
            validator_network.peer_id()
        ));
    }

    // For each fullnode network, fetch the identity information
    for fullnode_network in &node_config.full_node_networks {
        identity_information.push(format!(
            "\t- Fullnode network ({}), peer ID: {}",
            fullnode_network.network_id,
            fullnode_network.peer_id()
        ));
    }

    identity_information.join("\n") // Separate each entry with a newline to construct the output
```

**File:** crates/aptos-inspection-service/src/server/peer_information.rs (L20-38)
```rust
/// Handles a new peer information request
pub fn handle_peer_information_request(
    node_config: &NodeConfig,
    aptos_data_client: AptosDataClient,
    peers_and_metadata: Arc<PeersAndMetadata>,
) -> (StatusCode, Body, String) {
    // Only return peer information if the endpoint is enabled
    let (status_code, body) = if node_config.inspection_service.expose_peer_information {
        let peer_information = get_peer_information(aptos_data_client, peers_and_metadata);
        (StatusCode::OK, Body::from(peer_information))
    } else {
        (
            StatusCode::FORBIDDEN,
            Body::from(PEER_INFO_DISABLED_MESSAGE),
        )
    };

    (status_code, body, CONTENT_TYPE_TEXT.into())
}
```

**File:** crates/aptos-inspection-service/src/server/peer_information.rs (L148-168)
```rust
/// Displays connection metadata for each peer
fn display_peer_connection_metadata(
    peer_information_output: &mut Vec<String>,
    all_peers: &Vec<PeerNetworkId>,
    peers_and_metadata: &PeersAndMetadata,
) {
    peer_information_output.push("Connection metadata for each peer:".into());

    // Fetch and display the connection metadata for each peer
    for peer in all_peers {
        if let Ok(peer_metadata) = peers_and_metadata.get_metadata_for_peer(*peer) {
            let connection_metadata = peer_metadata.get_connection_metadata();
            peer_information_output.push(format!(
                "\t- Peer: {}, connection state: {:?}, connection metadata: {}",
                peer,
                peer_metadata.get_connection_state(),
                serde_json::to_string(&connection_metadata).unwrap_or_default()
            ));
        }
    }
}
```

**File:** network/framework/src/transport/mod.rs (L98-108)
```rust
/// Metadata associated with an established and fully upgraded connection.
#[derive(Clone, Deserialize, Eq, PartialEq, Serialize)]
pub struct ConnectionMetadata {
    pub remote_peer_id: PeerId,
    pub connection_id: ConnectionId,
    pub addr: NetworkAddress,
    pub origin: ConnectionOrigin,
    pub messaging_protocol: MessagingProtocolVersion,
    pub application_protocols: ProtocolIdSet,
    pub role: PeerRole,
}
```

**File:** crates/aptos/src/node/local_testnet/mod.rs (L99-103)
```rust
    /// By default all services running on the host system will be bound to 127.0.0.1,
    /// unless you're running the CLI inside a container, in which case it will run
    /// them on 0.0.0.0. You can use this flag to override this behavior in both cases.
    #[clap(long)]
    bind_to: Option<Ipv4Addr>,
```
