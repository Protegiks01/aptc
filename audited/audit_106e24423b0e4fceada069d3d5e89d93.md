# Audit Report

## Title
BLS12-381 Public Key Subgroup Check Gas Undercharging Enables Asymmetric Cost Attack

## Summary
The BLS12-381 public key subgroup check function charges 70.5% less gas than the actual computational cost, allowing attackers to flood validators with computationally expensive cryptographic operations while paying minimal fees. This creates an asymmetric cost attack vector that can lead to validator resource exhaustion.

## Finding Description

The native function `bls12381_pk_subgroub_check` incorrectly charges `BLS12381_PER_PUBKEY_DESERIALIZE` (400,684 gas units) instead of the correct parameter `BLS12381_PER_PUBKEY_SUBGROUP_CHECK` (1,360,120 gas units). [1](#0-0) 

The gas schedule defines the correct costs for these operations: [2](#0-1) 

The function documentation explicitly states it should charge `per_pubkey_subgroup_check_cost`, but the implementation violates this specification: [3](#0-2) 

This function is exposed to attackers through the public Move API via `public_key_from_bytes`: [4](#0-3) 

The subgroup check operation is computationally expensive, taking approximately 39 microseconds per operation. An attacker can craft transactions that repeatedly call `public_key_from_bytes` with valid public key bytes, triggering expensive subgroup checks while paying only 29.5% (400,684 / 1,360,120) of the actual computational cost.

**Attack Scenario:**
1. Attacker creates transactions calling `bls12381::public_key_from_bytes` repeatedly
2. Each call performs an expensive prime-order subgroup membership check (~39 microseconds)
3. Attacker pays 400,684 gas units per check instead of the correct 1,360,120 gas units
4. Attacker gets 959,436 gas units worth of free computation per operation (70.5% discount)
5. By flooding the network with such transactions, validators waste significant CPU resources while the attacker pays minimal transaction fees

## Impact Explanation

**Severity: High** - This vulnerability enables validator node slowdowns through asymmetric cost attacks.

The 70.5% gas undercharge means an attacker can cause 3.4x more computational load on validators than they pay for. For transactions at maximum gas limits, this allows attackers to exhaust validator CPU resources while paying significantly reduced fees. The subgroup check is a cryptographically expensive operation that cannot be optimized away, making this a reliable attack vector.

While this doesn't directly cause consensus violations or fund loss, sustained attacks can degrade network performance and increase block times, affecting overall network availability. This aligns with the "High Severity" category: "Validator node slowdowns."

## Likelihood Explanation

**Likelihood: High**

The vulnerability is:
- **Easy to exploit**: Any unprivileged user can call the public Move function
- **No special requirements**: Only requires crafting valid BLS12-381 public key bytes
- **Economically attractive**: 70.5% discount on computational costs makes it profitable for attackers
- **Difficult to detect**: Legitimate use of BLS12-381 functions makes malicious transactions indistinguishable from normal usage
- **No rate limiting**: Transaction throughput limits are the only constraint

An attacker needs only basic knowledge of the Aptos transaction format and BLS12-381 public key serialization to execute this attack.

## Recommendation

Change line 158 in `bls12381_pk_subgroub_check` from:
```rust
context.charge(BLS12381_PER_PUBKEY_DESERIALIZE * NumArgs::one())?;
```

To:
```rust
context.charge(BLS12381_PER_PUBKEY_SUBGROUP_CHECK * NumArgs::one())?;
``` [5](#0-4) 

This aligns the implementation with the documented gas cost and ensures the charged gas correctly reflects the actual computational burden.

## Proof of Concept

```move
module attacker::gas_exploit {
    use aptos_std::bls12381;
    use std::vector;

    /// Exploit the undercharged subgroup check by calling it repeatedly
    public entry fun exploit_gas_undercharge(iterations: u64) {
        // Valid BLS12-381 public key bytes (G1 generator point)
        let valid_pk = x"97f1d3a73197d7942695638c4fa9ac0fc3688c4f9774b905a14e3a3f171bac586c55e83ff97a1aeffb3af00adb22c6bb";
        
        let i = 0;
        while (i < iterations) {
            // Each call performs expensive subgroup check but pays only 400,684 gas
            // instead of the correct 1,360,120 gas (70.5% undercharge)
            let _ = bls12381::public_key_from_bytes(valid_pk);
            i = i + 1;
        };
        
        // With iterations=100, attacker gets 95,943,600 gas worth of computation
        // while paying only 40,068,400 gas (saving 55,875,200 gas units)
    }
}
```

The attacker can submit multiple transactions with high iteration counts to maximize validator CPU usage while minimizing gas costs. The asymmetric cost ratio of 3.4:1 makes this economically viable for resource exhaustion attacks.

## Notes

The vulnerability affects all BLS12-381 operations that perform public key validation, including:
- `public_key_from_bytes` (directly exposed public API)
- `verify_normal_signature_internal` (when `check_pk_subgroup=true`)

The signature subgroup check function correctly charges the appropriate gas parameter and is not vulnerable to this issue. [6](#0-5)

### Citations

**File:** aptos-move/framework/src/natives/cryptography/bls12381.rs (L152-161)
```rust
/// Checks prime-order subgroup membership on a bls12381::PublicKey struct.
fn bls12381_pk_subgroub_check(
    pk: &bls12381::PublicKey,
    context: &mut SafeNativeContext,
) -> SafeNativeResult<bool> {
    // NOTE(Gas): constant-time; around 39 microseconds on Apple M1
    context.charge(BLS12381_PER_PUBKEY_DESERIALIZE * NumArgs::one())?;

    Ok(pk.subgroup_check().is_ok())
}
```

**File:** aptos-move/framework/src/natives/cryptography/bls12381.rs (L163-171)
```rust
/// Checks prime-order subgroup membership on a bls12381::Signature struct.
fn bls12381_sig_subgroub_check(
    sig: &bls12381::Signature,
    context: &mut SafeNativeContext,
) -> SafeNativeResult<bool> {
    context.charge(BLS12381_PER_SIG_SUBGROUP_CHECK * NumArgs::one())?;

    Ok(sig.subgroup_check().is_ok())
}
```

**File:** aptos-move/framework/src/natives/cryptography/bls12381.rs (L384-412)
```rust
/***************************************************************************************************
 * native fun bls12381_validate_pubkey
 *
 *   gas cost: base_cost + per_pubkey_deserialize_cost +? per_pubkey_subgroup_check_cost
 *
 * where +? indicates that the expression stops evaluating there if the previous gas-charging step
 * failed
 **************************************************************************************************/
fn native_bls12381_validate_pubkey(
    context: &mut SafeNativeContext,
    ty_args: &[Type],
    mut arguments: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    debug_assert!(ty_args.is_empty());
    debug_assert!(arguments.len() == 1);

    context.charge(BLS12381_BASE)?;

    let pk_bytes = safely_pop_arg!(arguments, Vec<u8>);

    let pk = match bls12381_deserialize_pk(pk_bytes, context)? {
        Some(key) => key,
        None => return Ok(smallvec![Value::bool(false)]),
    };

    let valid = bls12381_pk_subgroub_check(&pk, context)?;

    Ok(smallvec![Value::bool(valid)])
}
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/aptos_framework.rs (L174-176)
```rust
        [bls12381_per_pubkey_deserialize: InternalGasPerArg, "bls12381.per_pubkey_deserialize", 400684],
        [bls12381_per_pubkey_aggregate: InternalGasPerArg, "bls12381.per_pubkey_aggregate", 15439],
        [bls12381_per_pubkey_subgroup_check: InternalGasPerArg, "bls12381.per_pubkey_subgroup_check", 1360120],
```

**File:** aptos-move/framework/aptos-stdlib/sources/cryptography/bls12381.move (L86-95)
```text
    /// Creates a new public key from a sequence of bytes.
    public fun public_key_from_bytes(bytes: vector<u8>): Option<PublicKey> {
        if (validate_pubkey_internal(bytes)) {
            option::some(PublicKey {
                bytes
            })
        } else {
            option::none<PublicKey>()
        }
    }
```
