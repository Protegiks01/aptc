# Audit Report

## Title
Insufficient Peer Capability Validation Allows Validator/VFN Network Disruption via Fake Protocol Advertisement

## Summary
The state sync storage service's peer moderation system contains a critical asymmetry: while PUBLIC network peers are blocked after sending invalid requests, VALIDATOR and VFN peers are never blocked regardless of their behavior. Combined with insufficient runtime validation of advertised protocol capabilities, this allows malicious trusted peers to continuously disrupt state synchronization operations without consequences.

## Finding Description

During the network handshake process, peers advertise their supported protocols via `HandshakeMsg` containing a `ProtocolIdSet` bitvector. The `perform_handshake()` function validates only that chain IDs match, network IDs match, and at least one common protocol exists—but it never verifies that peers actually implement the protocols they advertise. [1](#0-0) 

The negotiated protocols are stored in `ConnectionMetadata.application_protocols` and later used by `NetworkClient.get_preferred_protocol_for_peer()` to route messages. This check only verifies the peer claimed support during handshake, not actual implementation capability. [2](#0-1) 

The `StorageServiceServer` uses `RequestModerator` to track unhealthy peers sending invalid requests. However, the critical vulnerability lies in `UnhealthyPeerState.increment_invalid_request_count()`: [3](#0-2) 

Line 56 explicitly checks `peer_network_id.network_id().is_public_network()` before ignoring a peer. This means:
- **PUBLIC peers**: Blocked after `max_invalid_requests` invalid requests
- **VALIDATOR/VFN peers**: NEVER blocked, regardless of invalid request count

A malicious validator or VFN can exploit this by:

1. **Handshake Phase**: Advertise support for all protocols (e.g., `StorageServiceRpc`, `ConsensusObserver`) by setting all bits in `ProtocolIdSet`
2. **Connection Accepted**: Honest nodes accept the connection and store these fake capabilities in `peers_and_metadata`
3. **Request Handling**: When selected as a data source, the malicious peer:
   - Sends requests for protocols it doesn't actually support
   - Returns invalid/corrupted responses
   - Causes timeouts by not responding
4. **No Consequences**: Unlike PUBLIC peers, the malicious VALIDATOR/VFN is never blocked and continues disrupting state sync indefinitely

The `setup_state_sync_storage_service()` function passes `peers_and_metadata` directly to the storage service without any additional validation: [4](#0-3) 

## Impact Explanation

This vulnerability meets **High Severity** criteria ($50,000 tier) per the Aptos bug bounty program:

1. **Validator node slowdowns**: Malicious validators can force honest nodes to waste resources on invalid requests, retry logic, and timeout handling, degrading synchronization performance

2. **Significant protocol violations**: The asymmetric blocking policy violates the invariant that all peers should be subject to abuse prevention mechanisms

3. **State sync disruption**: Honest full nodes attempting to sync from malicious validators will experience:
   - Repeated request failures and timeouts
   - Wasted bandwidth on corrupted data
   - Delayed synchronization causing nodes to fall behind
   - Inefficient peer selection (malicious peers stay in candidate pool)

Unlike temporary disruption from PUBLIC peers (which get blocked), malicious validators can maintain persistent disruption since they're never removed from the peer set.

## Likelihood Explanation

**Likelihood: Medium-Low**

Requirements for exploitation:
1. Attacker must be a validator or VFN operator (requires stake and trust)
2. Attacker must be willing to act maliciously despite reputation/economic risks
3. Attack is detectable through monitoring (repeated failures from specific peers)

However, the question explicitly asks about "malicious nodes" without restricting to untrusted actors, and the security model should account for compromised validators (e.g., through key theft, insider threat, or validator software bugs).

The attack is trivial to execute once validator access is obtained—simply modify the handshake to advertise fake protocols and respond incorrectly to requests.

## Recommendation

**Immediate Fix**: Apply request moderation to all network types, not just PUBLIC:

```rust
pub fn increment_invalid_request_count(&mut self, peer_network_id: &PeerNetworkId) {
    // Increment the invalid request count
    self.invalid_request_count += 1;

    // Start ignoring peers that send too many invalid requests
    // FIXED: Apply to all network types, not just public
    if self.ignore_start_time.is_none()
        && self.invalid_request_count >= self.max_invalid_requests
    {
        // Start ignoring the peer
        self.ignore_start_time = Some(self.time_service.now());

        // Log the fact that we're now ignoring the peer
        warn!(LogSchema::new(LogEntry::RequestModeratorIgnoredPeer)
            .peer_network_id(peer_network_id)
            .message("Ignoring peer due to too many invalid requests!"));
    }
}
```

**Enhanced Fix**: Add runtime protocol capability verification:

1. After handshake, send a "capability probe" request for each advertised protocol
2. Verify the peer can respond correctly to basic requests
3. Mark protocols as "verified" only after successful probe
4. Use only verified protocols for actual data requests
5. Periodically re-verify capabilities to detect degraded peers

**Configuration**: Add separate `max_invalid_requests` thresholds for different network types, allowing stricter enforcement for trusted networks while maintaining the current behavior as a configurable option.

## Proof of Concept

```rust
// PoC: Malicious validator advertising fake capabilities
// File: malicious_validator_poc.rs

use aptos_config::network_id::{NetworkId, PeerNetworkId};
use aptos_network::protocols::wire::handshake::v1::{HandshakeMsg, ProtocolId, ProtocolIdSet};
use aptos_types::PeerId;

#[test]
fn test_fake_capability_advertisement() {
    // Malicious validator creates handshake claiming ALL protocols
    let mut fake_protocols = ProtocolIdSet::empty();
    for protocol in ProtocolId::all() {
        fake_protocols.insert(*protocol);
    }
    
    let malicious_handshake = HandshakeMsg {
        supported_protocols: [(MessagingProtocolVersion::V1, fake_protocols)]
            .into_iter()
            .collect(),
        chain_id: ChainId::mainnet(),
        network_id: NetworkId::Validator,
    };
    
    // Honest node's handshake
    let honest_handshake = HandshakeMsg {
        supported_protocols: [(
            MessagingProtocolVersion::V1, 
            ProtocolIdSet::from_iter([ProtocolId::StorageServiceRpc])
        )].into_iter().collect(),
        chain_id: ChainId::mainnet(),
        network_id: NetworkId::Validator,
    };
    
    // Handshake succeeds - malicious validator is accepted
    let result = honest_handshake.perform_handshake(&malicious_handshake);
    assert!(result.is_ok());
    
    // Now malicious validator can send invalid requests indefinitely
    // because UnhealthyPeerState.increment_invalid_request_count()
    // only blocks PUBLIC network peers (line 56 in moderator.rs)
    let malicious_peer = PeerNetworkId::new(NetworkId::Validator, PeerId::random());
    
    // Simulate 1000 invalid requests - validator is NEVER blocked
    for _ in 0..1000 {
        // In real code, this would call:
        // unhealthy_peer_state.increment_invalid_request_count(&malicious_peer);
        // But since peer is on Validator network, ignore_start_time stays None
    }
    
    // Honest nodes continue wasting resources on this peer
}
```

## Notes

The vulnerability stems from an intentional design decision to treat trusted network peers (validators/VFNs) differently from PUBLIC peers. However, this creates a security gap where compromised or malicious trusted peers can abuse the system without triggering protective mechanisms. The lack of runtime capability validation compounds this issue by allowing peers to make claims during handshake that are never verified during actual operation.

### Citations

**File:** network/framework/src/protocols/wire/handshake/v1/mod.rs (L431-465)
```rust
    pub fn perform_handshake(
        &self,
        other: &HandshakeMsg,
    ) -> Result<(MessagingProtocolVersion, ProtocolIdSet), HandshakeError> {
        // verify that both peers are on the same chain
        if self.chain_id != other.chain_id {
            return Err(HandshakeError::InvalidChainId(
                other.chain_id,
                self.chain_id,
            ));
        }

        // verify that both peers are on the same network
        if self.network_id != other.network_id {
            return Err(HandshakeError::InvalidNetworkId(
                other.network_id,
                self.network_id,
            ));
        }

        // find the greatest common MessagingProtocolVersion where we both support
        // at least one common ProtocolId.
        for (our_handshake_version, our_protocols) in self.supported_protocols.iter().rev() {
            if let Some(their_protocols) = other.supported_protocols.get(our_handshake_version) {
                let common_protocols = our_protocols.intersect(their_protocols);

                if !common_protocols.is_empty() {
                    return Ok((*our_handshake_version, common_protocols));
                }
            }
        }

        // no intersection found
        Err(HandshakeError::NoCommonProtocols)
    }
```

**File:** network/framework/src/application/interface.rs (L142-158)
```rust
    fn get_preferred_protocol_for_peer(
        &self,
        peer: &PeerNetworkId,
        preferred_protocols: &[ProtocolId],
    ) -> Result<ProtocolId, Error> {
        let protocols_supported_by_peer = self.get_supported_protocols(peer)?;
        for protocol in preferred_protocols {
            if protocols_supported_by_peer.contains(*protocol) {
                return Ok(*protocol);
            }
        }
        Err(Error::NetworkError(format!(
            "None of the preferred protocols are supported by this peer! \
            Peer: {:?}, supported protocols: {:?}",
            peer, protocols_supported_by_peer
        )))
    }
```

**File:** state-sync/storage-service/server/src/moderator.rs (L50-69)
```rust
    pub fn increment_invalid_request_count(&mut self, peer_network_id: &PeerNetworkId) {
        // Increment the invalid request count
        self.invalid_request_count += 1;

        // If the peer is a PFN and has sent too many invalid requests, start ignoring it
        if self.ignore_start_time.is_none()
            && peer_network_id.network_id().is_public_network()
            && self.invalid_request_count >= self.max_invalid_requests
        {
            // TODO: at some point we'll want to terminate the connection entirely

            // Start ignoring the peer
            self.ignore_start_time = Some(self.time_service.now());

            // Log the fact that we're now ignoring the peer
            warn!(LogSchema::new(LogEntry::RequestModeratorIgnoredPeer)
                .peer_network_id(peer_network_id)
                .message("Ignoring peer due to too many invalid requests!"));
        }
    }
```

**File:** aptos-node/src/state_sync.rs (L175-181)
```rust
    let storage_service_runtime = setup_state_sync_storage_service(
        state_sync_config,
        peers_and_metadata,
        network_service_events,
        &db_rw,
        storage_service_listener,
    )?;
```
