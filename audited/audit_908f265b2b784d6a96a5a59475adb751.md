# Audit Report

## Title
Missing Bounds Validation for SignatureIndex in Access Specifier ResourceInstantiation

## Summary
The bytecode verifier's BoundsChecker fails to validate SignatureIndex references within FunctionHandle.access_specifiers, specifically when ResourceSpecifier::ResourceInstantiation is used. This allows malformed modules with out-of-bounds signature indices to pass verification, only to fail later during module loading with ACCESS_CONTROL_INVARIANT_VIOLATION.

## Finding Description

The Move bytecode verifier performs bounds checking as its first validation pass to ensure all table indices are within bounds. However, the `check_function_handle` method does not validate the `access_specifiers` field, which can contain `ResourceSpecifier::ResourceInstantiation(StructHandleIndex, SignatureIndex)` with an unchecked SignatureIndex. [1](#0-0) 

The FunctionHandle structure includes an access_specifiers field that should be bounds-checked: [2](#0-1) 

The ResourceSpecifier enum includes ResourceInstantiation with a SignatureIndex: [3](#0-2) 

During module loading, the unchecked SignatureIndex is accessed, which returns an error if out of bounds: [4](#0-3) [5](#0-4) 

The bytecode verifier explicitly runs BoundsChecker first, expecting it to catch all bounds violations: [6](#0-5) 

**Attack Path:**
1. Attacker crafts a CompiledModule with a FunctionHandle containing access_specifiers
2. The access_specifiers include ResourceInstantiation with SignatureIndex pointing beyond the signature table bounds
3. Module passes BoundsChecker verification (gap in validation)
4. During Function::new() in module loading, load_access_specifier attempts to access the invalid index
5. Runtime returns ACCESS_CONTROL_INVARIANT_VIOLATION error
6. Transaction is rejected, module is not published

## Impact Explanation

**Severity Assessment: LOW** 

While this represents a gap in the verification pipeline, it does NOT meet High or Medium severity criteria because:

1. **No Consensus Divergence**: All validator nodes consistently reject the malformed module with the same error during loading
2. **No State Corruption**: The module never gets published since the error occurs during loading, before state changes
3. **Defense-in-Depth Works**: The runtime bounds check in `access_table()` prevents any undefined behavior
4. **No Availability Impact**: Malicious modules are simply rejected; no node crashes or slowdowns occur

The issue violates the design principle that "all bounds checking should happen during verification," but the runtime safety check ensures no actual security harm occurs. This is a code quality and defense-in-depth issue rather than an exploitable vulnerability.

## Likelihood Explanation

While crafting such a malicious module is trivial, the impact is limited to transaction rejection. An attacker gains no advantage, as the module cannot be published or executed. The runtime check ensures deterministic rejection across all nodes.

## Recommendation

Add bounds checking for access_specifiers in the BoundsChecker to maintain the invariant that all bounds violations are caught during verification:

```rust
fn check_function_handle(&self, function_handle: &FunctionHandle) -> PartialVMResult<()> {
    check_bounds_impl(self.view.module_handles(), function_handle.module)?;
    check_bounds_impl(self.view.identifiers(), function_handle.name)?;
    check_bounds_impl(self.view.signatures(), function_handle.parameters)?;
    check_bounds_impl(self.view.signatures(), function_handle.return_)?;
    
    // Validate access specifiers
    if let Some(access_specs) = &function_handle.access_specifiers {
        for spec in access_specs {
            self.check_access_specifier(spec)?;
        }
    }
    
    // existing type parameter validation...
}

fn check_access_specifier(&self, spec: &AccessSpecifier) -> PartialVMResult<()> {
    match &spec.resource {
        ResourceSpecifier::ResourceInstantiation(struct_idx, sig_idx) => {
            check_bounds_impl(self.view.struct_handles(), *struct_idx)?;
            check_bounds_impl(self.view.signatures(), *sig_idx)?;
        },
        ResourceSpecifier::Resource(struct_idx) => {
            check_bounds_impl(self.view.struct_handles(), *struct_idx)?;
        },
        ResourceSpecifier::DeclaredAtAddress(addr_idx) => {
            check_bounds_impl(self.view.address_identifiers(), *addr_idx)?;
        },
        ResourceSpecifier::DeclaredInModule(mod_idx) => {
            check_bounds_impl(self.view.module_handles(), *mod_idx)?;
        },
        _ => {},
    }
    // Also validate address specifier indices...
    Ok(())
}
```

## Proof of Concept

```rust
#[test]
fn invalid_signature_index_in_access_specifier() {
    use move_binary_format::file_format::*;
    
    let mut m = basic_test_module();
    
    // Create access specifier with out-of-bounds SignatureIndex
    m.function_handles[0].access_specifiers = Some(vec![
        AccessSpecifier {
            kind: AccessKind::Writes,
            negated: false,
            resource: ResourceSpecifier::ResourceInstantiation(
                StructHandleIndex(0),
                SignatureIndex(999), // Out of bounds - only 1 signature exists
            ),
            address: AddressSpecifier::Any,
        }
    ]);
    
    // This SHOULD fail but currently passes verification
    let result = BoundsChecker::verify_module(&m);
    
    // Bug: verification passes when it should fail
    assert!(result.is_ok(), "BoundsChecker should catch this but doesn't");
    
    // The error only surfaces during module loading at runtime
    // This demonstrates the verification gap but not an exploitable vulnerability
}
```

**Notes:**
- This issue does not meet High severity criteria per the Aptos bug bounty program
- Runtime defense-in-depth prevents any actual security impact
- Recommended fix improves code correctness and verification completeness
- No consensus divergence or state corruption is possible with current implementation

### Citations

**File:** third_party/move/move-binary-format/src/check_bounds.rs (L238-248)
```rust
    fn check_function_handle(&self, function_handle: &FunctionHandle) -> PartialVMResult<()> {
        check_bounds_impl(self.view.module_handles(), function_handle.module)?;
        check_bounds_impl(self.view.identifiers(), function_handle.name)?;
        check_bounds_impl(self.view.signatures(), function_handle.parameters)?;
        check_bounds_impl(self.view.signatures(), function_handle.return_)?;
        // function signature type parameters must be in bounds to the function type parameters
        let type_param_count = function_handle.type_parameters.len();
        self.check_type_parameters_in_signature(function_handle.parameters, type_param_count)?;
        self.check_type_parameters_in_signature(function_handle.return_, type_param_count)?;
        Ok(())
    }
```

**File:** third_party/move/move-binary-format/src/file_format.rs (L327-346)
```rust
pub struct FunctionHandle {
    /// The module that defines the function.
    pub module: ModuleHandleIndex,
    /// The name of the function.
    pub name: IdentifierIndex,
    /// The list of arguments to the function.
    pub parameters: SignatureIndex,
    /// The list of return types.
    pub return_: SignatureIndex,
    /// The type formals (identified by their index into the vec) and their constraints
    pub type_parameters: Vec<AbilitySet>,
    /// An optional list of access specifiers. If this is unspecified, the function is assumed
    /// to access arbitrary resources. Otherwise, each specifier approximates a set of resources
    /// which are read/written by the function. An empty list indicates the function is pure and
    /// does not depend on any global state.
    #[cfg_attr(
        any(test, feature = "fuzzing"),
        proptest(filter = "|x| x.as_ref().map(|v| v.len() <= 64).unwrap_or(true)")
    )]
    pub access_specifiers: Option<Vec<AccessSpecifier>>,
```

**File:** third_party/move/move-binary-format/src/file_format.rs (L882-893)
```rust
pub enum ResourceSpecifier {
    /// Any resource
    Any,
    /// A resource declared at the given address.
    DeclaredAtAddress(AddressIdentifierIndex),
    /// A resource declared in the given module.
    DeclaredInModule(ModuleHandleIndex),
    /// An explicit resource
    Resource(StructHandleIndex),
    /// A resource instantiation.
    ResourceInstantiation(StructHandleIndex, SignatureIndex),
}
```

**File:** third_party/move/move-vm/runtime/src/loader/access_specifier_loader.rs (L71-76)
```rust
        ResourceInstantiation(str_idx, ty_idx) => Ok(ResourceSpecifier::ResourceInstantiation(
            access_table(struct_names, str_idx.0)?.clone(),
            access_table(signature_table, ty_idx.0)?.clone(),
        )),
    }
}
```

**File:** third_party/move/move-vm/runtime/src/loader/access_specifier_loader.rs (L114-125)
```rust
fn access_table<T>(table: &[T], idx: TableIndex) -> PartialVMResult<&T> {
    if (idx as usize) < table.len() {
        Ok(&table[idx as usize])
    } else {
        Err(index_out_of_range())
    }
}

fn index_out_of_range() -> PartialVMError {
    PartialVMError::new(StatusCode::ACCESS_CONTROL_INVARIANT_VIOLATION)
        .with_message("table index out of range".to_owned())
}
```

**File:** third_party/move/move-bytecode-verifier/src/verifier.rs (L134-145)
```rust
pub fn verify_module_with_config(config: &VerifierConfig, module: &CompiledModule) -> VMResult<()> {
    if config.verify_nothing() {
        return Ok(());
    }
    let prev_state = move_core_types::state::set_state(VMState::VERIFIER);
    let result = std::panic::catch_unwind(|| {
        // Always needs to run bound checker first as subsequent passes depend on it
        BoundsChecker::verify_module(module).map_err(|e| {
            // We can't point the error at the module, because if bounds-checking
            // failed, we cannot safely index into module's handle to itself.
            e.finish(Location::Undefined)
        })?;
```
