# Audit Report

## Title
Indexer Permanent Crash Loop Due to Unrecoverable Metadata Corruption

## Summary
The internal indexer lacks fallback logic to handle corrupted metadata that successfully deserializes but contains the wrong enum variant. When this occurs, the indexer enters a permanent crash loop on startup, requiring manual database deletion and full rebuild to recover.

## Finding Description

The indexer metadata system uses an enum `MetadataValue` with two variants: `Version(u64)` and `StateSnapshotProgress(StateSnapshotProgress)`. The decoding and extraction logic has a critical flaw in the error handling path. [1](#0-0) 

The `expect_version()` method panics if the wrong variant is encountered: [2](#0-1) 

This panic is triggered during indexer startup when reading version metadata: [3](#0-2) 

The startup sequence calls `get_start_version()` which invokes multiple version getters: [4](#0-3) 

**Attack Scenario:**

1. Disk corruption (bit flips, partial writes, filesystem errors) corrupts the BCS-encoded metadata in RocksDB
2. The corrupted bytes still pass BCS deserialization but decode to the wrong `MetadataValue` variant (e.g., `StateSnapshotProgress` instead of `Version`)
3. On indexer startup, `get_version()` successfully retrieves the corrupted metadata
4. The `expect_version()` method panics with "Not version"
5. The global panic handler catches the panic and exits the process with code 12: [5](#0-4) 

6. On automatic restart, the same corrupted metadata is read, causing another panic
7. The system enters an infinite crash loop with no recovery mechanism

**No Fallback Logic:** The indexer startup path has no error handling to:
- Detect metadata corruption
- Reset corrupted metadata to safe defaults
- Skip corrupted entries and reinitialize
- Provide graceful degradation [6](#0-5) 

## Impact Explanation

This qualifies as **High Severity** under the Aptos bug bounty criteria:

- **Total loss of liveness/network availability**: The indexer becomes permanently unavailable, making all account-based APIs non-functional. This includes critical operations like account transaction history, event queries, and state key lookups.

- **Requires manual intervention**: Recovery requires an operator to manually delete the entire indexer database and trigger a full rebuild from genesis, which could take hours or days depending on chain history.

- **No automatic recovery**: Unlike transient failures, this creates a permanent deadlock that cannot self-heal through restarts or timeouts.

While this doesn't directly affect consensus or validator operations, the indexer is essential infrastructure for node API functionality, and its permanent failure constitutes a critical availability issue.

## Likelihood Explanation

**Likelihood: Medium**

This vulnerability requires specific conditions but is realistic:

**Triggering Conditions:**
- Disk corruption events (bit flips, bad sectors, power failures during writes)
- Filesystem corruption or inconsistencies
- Hardware failures affecting persistent storage
- Improper shutdown during metadata updates

**Mitigating Factors:**
- Modern storage systems have error correction
- RocksDB has some built-in corruption detection
- The corruption must result in valid BCS encoding but wrong variant

**Realistic Scenarios:**
- Production nodes experiencing hardware failures
- Cloud infrastructure with transient storage issues
- Nodes running on degraded or failing disks
- Emergency shutdowns or ungraceful terminations

The likelihood increases in large-scale deployments where storage failures are statistically inevitable over time.

## Recommendation

Implement defensive error handling with graceful degradation:

**Option 1: Safe Extraction with Error Result**

Replace the panicking `expect_version()` with a fallible extraction method:

```rust
impl MetadataValue {
    pub fn try_as_version(self) -> Result<Version> {
        match self {
            Self::Version(v) => Ok(v),
            _ => Err(anyhow::anyhow!("Expected Version variant, found {:?}", self)),
        }
    }
}
```

Update `get_version()` to handle errors:

```rust
fn get_version(&self, key: &MetadataKey) -> Result<Option<Version>> {
    match self.db.get::<InternalIndexerMetadataSchema>(key)? {
        Some(value) => match value.try_as_version() {
            Ok(v) => Ok(Some(v)),
            Err(e) => {
                warn!("Corrupted metadata for {:?}: {}. Reinitializing.", key, e);
                Ok(None)  // Treat as missing, will start from 0
            }
        },
        None => Ok(None),
    }
}
```

**Option 2: Metadata Validation on Startup**

Add a validation pass before processing:

```rust
pub fn validate_and_repair_metadata(&self) -> Result<()> {
    for key in [MetadataKey::LatestVersion, MetadataKey::EventVersion, 
                MetadataKey::StateVersion, MetadataKey::TransactionVersion] {
        if let Some(value) = self.db.get::<InternalIndexerMetadataSchema>(&key)? {
            if !matches!(value, MetadataValue::Version(_)) {
                warn!("Invalid metadata variant for {:?}, resetting", key);
                self.db.delete::<InternalIndexerMetadataSchema>(&key)?;
            }
        }
    }
    Ok(())
}
```

**Option 3: Catch Panic with Recovery**

As a last resort, wrap the startup in `catch_unwind`:

```rust
match std::panic::catch_unwind(|| {
    indexer_service.get_start_version(&config_clone)
}) {
    Ok(Ok(version)) => version,
    Ok(Err(e)) => return Err(e),
    Err(panic) => {
        error!("Metadata corruption detected, resetting indexer DB");
        // Reset metadata and retry
        indexer_service.reset_metadata()?;
        0  // Start from genesis
    }
}
```

## Proof of Concept

```rust
#[cfg(test)]
mod corruption_test {
    use super::*;
    use aptos_db_indexer_schemas::{
        metadata::{MetadataKey, MetadataValue, StateSnapshotProgress},
        schema::indexer_metadata::InternalIndexerMetadataSchema,
    };
    use aptos_schemadb::{SchemaBatch, DB};
    use aptos_crypto::HashValue;
    use aptos_types::state_store::state_storage_usage::StateStorageUsage;
    
    #[test]
    #[should_panic(expected = "Not version")]
    fn test_metadata_corruption_causes_panic() {
        // Create temporary DB
        let tmpdir = tempfile::tempdir().unwrap();
        let db = Arc::new(DB::open(
            tmpdir.path(),
            "test_indexer_db",
            vec!["indexer_metadata"],
            &Default::default(),
        ).unwrap());
        
        // Simulate corruption: write StateSnapshotProgress variant 
        // to a key that expects Version variant
        let mut batch = SchemaBatch::new();
        let corrupted_value = MetadataValue::StateSnapshotProgress(
            StateSnapshotProgress::new(
                HashValue::zero(),
                StateStorageUsage::new_untracked(),
            )
        );
        batch.put::<InternalIndexerMetadataSchema>(
            &MetadataKey::LatestVersion,  // Expects Version variant
            &corrupted_value,              // But storing StateSnapshotProgress
        ).unwrap();
        db.write_schemas(batch).unwrap();
        
        // Create indexer instance
        let config = InternalIndexerDBConfig::new(true, true, true, 0, true, 10_000);
        let indexer_db = InternalIndexerDB::new(db, config);
        
        // This should panic with "Not version"
        let _ = indexer_db.get_persisted_version();
    }
}
```

**Notes:**
- The vulnerability affects all indexer metadata reads that use `expect_version()` or `expect_state_snapshot_progress()`
- Recovery requires manual intervention: deleting `/path/to/storage/internal_indexer_db` and allowing full rebuild
- The issue is exacerbated because there's no logging or indication of which specific metadata key is corrupted
- Similar pattern exists in the main AptosDB metadata handling which may have the same vulnerability

### Citations

**File:** storage/indexer_schemas/src/metadata.rs (L10-13)
```rust
pub enum MetadataValue {
    Version(Version),
    StateSnapshotProgress(StateSnapshotProgress),
}
```

**File:** storage/indexer_schemas/src/metadata.rs (L16-20)
```rust
    pub fn expect_version(self) -> Version {
        match self {
            Self::Version(v) => v,
            _ => panic!("Not version"),
        }
```

**File:** storage/indexer/src/db_indexer.rs (L287-292)
```rust
    fn get_version(&self, key: &MetadataKey) -> Result<Option<Version>> {
        Ok(self
            .db
            .get::<InternalIndexerMetadataSchema>(key)?
            .map(|v| v.expect_version()))
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-table-info/src/internal_indexer_db_service.rs (L88-106)
```rust
    pub async fn get_start_version(&self, node_config: &NodeConfig) -> Result<Version> {
        let fast_sync_enabled = node_config
            .state_sync
            .state_sync_driver
            .bootstrapping_mode
            .is_fast_sync();
        let mut main_db_synced_version = self.db_indexer.main_db_reader.ensure_synced_version()?;

        // Wait till fast sync is done
        while fast_sync_enabled && main_db_synced_version == 0 {
            tokio::time::sleep(std::time::Duration::from_secs(1)).await;
            main_db_synced_version = self.db_indexer.main_db_reader.ensure_synced_version()?;
        }

        let start_version = self
            .db_indexer
            .indexer_db
            .get_persisted_version()?
            .map_or(0, |v| v + 1);
```

**File:** crates/crash-handler/src/lib.rs (L26-57)
```rust
pub fn setup_panic_handler() {
    panic::set_hook(Box::new(move |pi: &PanicHookInfo<'_>| {
        handle_panic(pi);
    }));
}

// Formats and logs panic information
fn handle_panic(panic_info: &PanicHookInfo<'_>) {
    // The Display formatter for a PanicHookInfo contains the message, payload and location.
    let details = format!("{}", panic_info);
    let backtrace = format!("{:#?}", Backtrace::new());

    let info = CrashInfo { details, backtrace };
    let crash_info = toml::to_string_pretty(&info).unwrap();
    error!("{}", crash_info);
    // TODO / HACK ALARM: Write crash info synchronously via eprintln! to ensure it is written before the process exits which error! doesn't guarantee.
    // This is a workaround until https://github.com/aptos-labs/aptos-core/issues/2038 is resolved.
    eprintln!("{}", crash_info);

    // Wait till the logs have been flushed
    aptos_logger::flush();

    // Do not kill the process if the panics happened at move-bytecode-verifier.
    // This is safe because the `state::get_state()` uses a thread_local for storing states. Thus the state can only be mutated to VERIFIER by the thread that's running the bytecode verifier.
    //
    // TODO: once `can_unwind` is stable, we should assert it. See https://github.com/rust-lang/rust/issues/92988.
    if state::get_state() == VMState::VERIFIER || state::get_state() == VMState::DESERIALIZER {
        return;
    }

    // Kill the process
    process::exit(12);
```

**File:** ecosystem/indexer-grpc/indexer-grpc-table-info/src/runtime.rs (L42-44)
```rust
    runtime.spawn(async move {
        indexer_service.run(&config_clone).await.unwrap();
    });
```
