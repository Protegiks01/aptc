# Audit Report

## Title
Indexer Historical Table Items Expose Deleted Sensitive Data via GraphQL API

## Summary
The Aptos indexer's GraphQL API exposes historical table item data through the `table_items` table without properly filtering deleted entries, allowing attackers to access sensitive data that was supposedly removed via deletion operations. While the `current_table_items` table correctly updates to set `decoded_value=None` upon deletion, the historical `table_items` table permanently retains all previous values, creating a persistent information disclosure vulnerability.

## Finding Description

The Aptos indexer maintains two tables for tracking Move table items:

1. **`current_table_items`**: Stores the current state of each table item
2. **`table_items`**: Stores the complete history of all state changes

When a table item is deleted, the system processes it as follows: [1](#0-0) 

The deletion creates new database entries with `is_deleted=true` and `decoded_value=None`. However, this creates two security issues:

**Issue 1: Historical Data Retention**
The `table_items` table uses `(transaction_version, write_set_change_index)` as its primary key, meaning each state change creates a new row. When an item containing sensitive data is deleted:
- Row 1 (version N): `is_deleted=false`, `decoded_value=<sensitive_data>`
- Row 2 (version M): `is_deleted=true`, `decoded_value=None`

Both rows persist indefinitely in the database.

**Issue 2: GraphQL API Exposure Without Filtering**
The Hasura GraphQL API configuration exposes the historical table without proper access controls: [2](#0-1) 

Critically, the `is_deleted` field is **not exposed** in the GraphQL API columns list, even though it exists in the schema: [3](#0-2) 

This means attackers can:
1. Query `table_items` by `table_handle` and filter for specific keys
2. Retrieve all historical versions including those with sensitive data
3. Cannot easily determine which entries were later deleted (since `is_deleted` is not exposed)
4. Access supposedly "deleted" sensitive data indefinitely

**Attack Scenario:**
```graphql
query GetHistoricalData {
  table_items(
    where: {
      table_handle: {_eq: "0x123..."},
      key: {_eq: "user_private_data"}
    }
  ) {
    transaction_version
    decoded_value
  }
}
```

This returns all historical values, including those from before deletion, exposing sensitive data that users believed was removed from the system.

## Impact Explanation

This vulnerability falls under **Medium Severity** per the Aptos bug bounty criteria as it represents an information disclosure issue with the following impacts:

1. **Privacy Violation**: Users who delete sensitive data from Move tables (e.g., personal information, private application state) have a reasonable expectation that this data is no longer accessible. The indexer violates this expectation by preserving and exposing historical values.

2. **Compliance Risk**: Applications using Aptos tables for storing user data that may need to comply with data deletion requirements (GDPR "right to be forgotten", CCPA, etc.) cannot achieve true deletion through the blockchain's deletion mechanism.

3. **Information Reconnaissance**: Attackers can enumerate deleted entries to identify potentially sensitive data patterns or understand the evolution of state that applications intended to hide.

While this does not directly affect consensus, execution, or result in fund loss, it represents a significant state inconsistency between user expectations and actual data accessibility. The indexer is a critical infrastructure component used by most applications and users to query blockchain state.

## Likelihood Explanation

**Likelihood: HIGH**

This vulnerability is highly likely to be exploited because:

1. **No Authentication Required**: The GraphQL API is publicly accessible to anonymous users with no authentication barriers [4](#0-3) 

2. **Simple Exploitation**: Requires only standard GraphQL queries, no specialized tools or deep blockchain knowledge

3. **Widespread Indexer Usage**: The Aptos indexer is the standard way to query blockchain data, meaning any application using table items for sensitive data is potentially affected

4. **Persistent Data**: Once sensitive data is written, it remains queryable forever even after deletion, expanding the attack window indefinitely

5. **Discovery is Trivial**: Attackers can easily discover which table handles contain interesting data by monitoring on-chain transactions and then query the full history

## Recommendation

Implement multi-layered protection for deleted table items:

**1. Filter Historical Queries (Immediate Fix)**
Update the Hasura metadata to exclude rows where `is_deleted=true` from the `table_items` API:

```json
{
  "table": {
    "name": "table_items",
    "schema": "public"
  },
  "select_permissions": [
    {
      "role": "anonymous",
      "permission": {
        "columns": [
          "decoded_key",
          "decoded_value",
          "is_deleted",
          "key",
          "table_handle",
          "transaction_version",
          "write_set_change_index"
        ],
        "filter": {
          "is_deleted": {"_eq": false}
        },
        "limit": 100
      }
    }
  ]
}
```

**2. Expose is_deleted Field**
Add the `is_deleted` field to the exposed columns so clients can filter appropriately: [5](#0-4) 

**3. Consider Data Purging**
For sensitive applications, implement a configurable data retention policy that physically removes `decoded_value` from deleted historical entries after a grace period, while preserving the deletion record itself for audit purposes.

**4. Document Behavior**
Clearly document in the API and Move framework documentation that table item deletion is a logical deletion that preserves historical values in the indexer, and that applications requiring true data deletion should either:
- Use ephemeral storage mechanisms
- Encrypt sensitive data with keys that can be destroyed
- Avoid storing sensitive data on-chain

## Proof of Concept

**Step 1: Write sensitive data to a table**
```move
// Move code
use aptos_framework::table;

fun write_sensitive_data(account: &signer) {
    let t = table::new<address, vector<u8>>();
    table::add(&mut t, @0x123, b"sensitive_user_secret_data");
    // Store table handle for later reference
}
```

**Step 2: Delete the data**
```move
fun delete_sensitive_data() {
    // Later, delete the entry
    table::remove(&mut t, @0x123);
}
```

**Step 3: Query historical data via GraphQL**
```graphql
query ExploitDeletedData {
  table_items(
    where: {
      table_handle: {_eq: "<handle_from_step1>"},
      decoded_key: {_contains: {"address": "0x123"}}
    },
    order_by: {transaction_version: asc}
  ) {
    transaction_version
    decoded_value
    write_set_change_index
  }
}
```

**Expected Result**: Returns two rows:
- First row (lower version): `decoded_value` contains `"sensitive_user_secret_data"`
- Second row (higher version): `decoded_value` is null

**Actual Vulnerability**: The attacker retrieves the sensitive data from the first row even though it was explicitly deleted, and the `is_deleted` field is not exposed to help determine which row represents the deletion.

---

**Notes**

This vulnerability is specific to the **indexer's GraphQL API layer** and does not affect the core blockchain consensus or execution. The on-chain REST API that queries validator nodes directly would correctly return only non-deleted current state. However, the indexer is a critical infrastructure component that most applications and users rely on, making this a significant practical vulnerability.

The root cause is a mismatch between user expectations (deletion removes data) and blockchain immutability (all history is preserved). While historical data retention is a feature of blockchain systems, the API should implement proper access controls to prevent unauthorized access to supposedly deleted sensitive information.

### Citations

**File:** crates/indexer/src/models/move_tables.rs (L82-120)
```rust
    pub fn from_delete_table_item(
        delete_table_item: &DeleteTableItem,
        write_set_change_index: i64,
        transaction_version: i64,
        transaction_block_height: i64,
    ) -> (Self, CurrentTableItem) {
        let decoded_key = delete_table_item
            .data
            .as_ref()
            .unwrap_or_else(|| {
                panic!(
                    "Could not extract data from DeletedTableItem '{:?}'",
                    delete_table_item
                )
            })
            .key
            .clone();
        (
            Self {
                transaction_version,
                write_set_change_index,
                transaction_block_height,
                key: delete_table_item.key.to_string(),
                table_handle: standardize_address(&delete_table_item.handle.to_string()),
                decoded_key: decoded_key.clone(),
                decoded_value: None,
                is_deleted: true,
            },
            CurrentTableItem {
                table_handle: standardize_address(&delete_table_item.handle.to_string()),
                key_hash: hash_str(&delete_table_item.key.to_string()),
                key: delete_table_item.key.to_string(),
                decoded_key,
                decoded_value: None,
                last_transaction_version: transaction_version,
                is_deleted: true,
            },
        )
    }
```

**File:** crates/aptos-localnet/src/hasura_metadata.json (L2256-2270)
```json
            "select_permissions": [
              {
                "role": "anonymous",
                "permission": {
                  "columns": [
                    "decoded_key",
                    "decoded_value",
                    "key",
                    "table_handle",
                    "transaction_version",
                    "write_set_change_index"
                  ],
                  "filter": {},
                  "limit": 100
                }
```

**File:** crates/indexer/src/schema.rs (L662-674)
```rust
diesel::table! {
    table_items (transaction_version, write_set_change_index) {
        key -> Text,
        transaction_version -> Int8,
        write_set_change_index -> Int8,
        transaction_block_height -> Int8,
        #[max_length = 66]
        table_handle -> Varchar,
        decoded_key -> Jsonb,
        decoded_value -> Nullable<Jsonb>,
        is_deleted -> Bool,
        inserted_at -> Timestamp,
    }
```
