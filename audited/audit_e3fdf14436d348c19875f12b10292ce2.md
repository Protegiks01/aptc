# Audit Report

## Title
Missing Eval Proof Verification and Silent Failure Logging in Batch Encryption Decryption Pipeline

## Summary
The batch encryption decryption pipeline in Aptos consensus fails to verify eval proofs before use and does not log or monitor decryption failures. While verification methods exist, they are never called in production code, allowing potential computation errors or malicious modifications to go undetected.

## Finding Description

The batch threshold encryption system implements KZG-based eval proof verification in `DigestKey::verify_pf()` [1](#0-0) , which returns `EvalProofVerifyError` on verification failure. However, this verification is **never invoked** in the production decryption pipeline.

In the consensus decryption flow [2](#0-1) , eval proofs are computed locally and used directly for decryption without verification. When decryption fails, the error is silently caught with no logging, metrics, or attribution [3](#0-2) .

The `prepare_individual()` method uses eval proofs in pairing computations without verification [4](#0-3) , meaning incorrect proofs (from bugs or malicious modification) will cause silent decryption failures with no detectability.

**Attack Scenario:**
1. A compromised validator node (malware, supply chain attack) modifies eval proof computation
2. All encrypted transactions fail to decrypt on that validator
3. No logs, metrics, or alerts are generated
4. The malicious behavior continues undetected across multiple blocks
5. Network operators cannot diagnose or attribute the failures

This violates the **Deterministic Execution** invariant - validators should be able to detect when their computations deviate from expected results.

## Impact Explanation

**Medium Severity** - This issue falls under "State inconsistencies requiring intervention" per Aptos bug bounty criteria. While it doesn't directly enable fund theft, it creates an unmonitored attack surface where:

1. **Compromised validators** can silently fail to process encrypted transactions without detection
2. **Implementation bugs** in eval proof computation go unnoticed
3. **Debugging and incident response** becomes impossible without diagnostic data
4. **Byzantine behavior** cannot be distinguished from benign failures

The lack of verification means the `EvalProofVerifyError` defined in the error types [5](#0-4)  is effectively dead code that never gets triggered in production.

## Likelihood Explanation

**Medium Likelihood** - While requiring validator-level compromise or bugs, this is realistic because:

1. Supply chain attacks on validator infrastructure are well-documented threats
2. Implementation bugs in cryptographic computation are common
3. The lack of self-checks means errors propagate silently
4. Each validator computes proofs independently, making coordinated monitoring difficult

## Recommendation

**Add mandatory eval proof verification before use:**

```rust
// In decryption_pipeline_builder.rs, after line 113:
let proofs = FPTXWeighted::eval_proofs_compute_all(&proofs_promise, &digest_key);

// ADD VERIFICATION:
if let Err(e) = digest_key.verify_all(&digest, &proofs) {
    error!(
        "Eval proof verification failed for block {} round {}: {:?}",
        block.id(),
        encryption_round,
        e
    );
    EVAL_PROOF_VERIFY_FAILURES.inc();
    // Continue with error handling or abort
}
```

**Add logging for decryption failures:**

```rust
// In the decrypt loop, replace line 140-145 with:
} else {
    warn!(
        "Decryption failed for transaction {} in block {}",
        ciphertext.id(),
        block.id()
    );
    DECRYPTION_FAILURES.inc();
    txn.payload_mut()
        .as_encrypted_payload_mut()
        .map(|p| p.into_failed_decryption(eval_proof).expect("must happen"))
        .expect("must exist");
}
```

## Proof of Concept

The vulnerability can be demonstrated by modifying a validator's eval proof computation to return invalid proofs and observing that:

1. No `EvalProofVerifyError` is ever generated
2. Decryption silently fails
3. No logs or metrics are produced

The verification methods exist but are unreachable from production code paths, as confirmed by the fact that `DigestKey::verify` and `verify_all` are only called in test code [6](#0-5) .

A validator running with corrupted eval proof computation would process blocks indefinitely without any observability into the failure mode, violating monitoring and security best practices for consensus-critical infrastructure.

---

**Notes:**

The core issue is that while the cryptographic verification infrastructure is properly implemented, it's completely bypassed in the production code path. Each validator computes eval proofs locally and trusts their own computation without self-verification, creating a blind spot for detecting compromises or bugs. The lack of logging compounds this by preventing post-mortem analysis of failures.

### Citations

**File:** crates/aptos-batch-encryption/src/shared/digest.rs (L138-146)
```rust
    fn verify_pf(&self, digest: &Digest, id: Id, pf: G1Affine) -> Result<()> {
        // TODO use multipairing here?
        Ok((PairingSetting::pairing(
            pf,
            self.tau_g2 - G2Projective::from(G2Affine::generator() * id.x()),
        ) == PairingSetting::pairing(digest.as_g1(), G2Affine::generator()))
        .then_some(())
        .ok_or(BatchEncryptionError::EvalProofVerifyError)?)
    }
```

**File:** crates/aptos-batch-encryption/src/shared/digest.rs (L153-157)
```rust
    pub fn verify_all(&self, digest: &Digest, pfs: &EvalProofs) -> Result<()> {
        pfs.computed_proofs
            .iter()
            .try_for_each(|(id, pf)| self.verify_pf(digest, *id, *pf))
    }
```

**File:** consensus/src/pipeline/decryption_pipeline_builder.rs (L113-148)
```rust
        let proofs = FPTXWeighted::eval_proofs_compute_all(&proofs_promise, &digest_key);

        let maybe_decryption_key = secret_shared_key_rx
            .await
            .expect("decryption key should be available");
        // TODO(ibalajiarun): account for the case where decryption key is not available
        let decryption_key = maybe_decryption_key.expect("decryption key should be available");

        let decrypted_txns = encrypted_txns
            .into_par_iter()
            .zip(txn_ciphertexts)
            .map(|(mut txn, ciphertext)| {
                let eval_proof = proofs.get(&ciphertext.id()).expect("must exist");
                if let Ok(payload) = FPTXWeighted::decrypt_individual::<DecryptedPayload>(
                    &decryption_key.key,
                    &ciphertext,
                    &digest,
                    &eval_proof,
                ) {
                    let (executable, nonce) = payload.unwrap();
                    txn.payload_mut()
                        .as_encrypted_payload_mut()
                        .map(|p| {
                            p.into_decrypted(eval_proof, executable, nonce)
                                .expect("must happen")
                        })
                        .expect("must exist");
                } else {
                    txn.payload_mut()
                        .as_encrypted_payload_mut()
                        .map(|p| p.into_failed_decryption(eval_proof).expect("must happen"))
                        .expect("must exist");
                }
                txn
            })
            .collect();
```

**File:** crates/aptos-batch-encryption/src/shared/ciphertext/bibe.rs (L92-106)
```rust
    fn prepare_individual(
        &self,
        digest: &Digest,
        eval_proof: &EvalProof,
    ) -> Result<PreparedBIBECiphertext> {
        let pairing_output = PairingSetting::pairing(digest.as_g1(), self.ct_g2[0])
            + PairingSetting::pairing(**eval_proof, self.ct_g2[1]);

        Ok(PreparedBIBECiphertext {
            pairing_output,
            ct_g2: self.ct_g2[2].into(),
            padded_key: self.padded_key.clone(),
            symmetric_ciphertext: self.symmetric_ciphertext.clone(),
        })
    }
```

**File:** crates/aptos-batch-encryption/src/errors.rs (L23-24)
```rust
    #[error("Error when verifying eval proof")]
    EvalProofVerifyError,
```
