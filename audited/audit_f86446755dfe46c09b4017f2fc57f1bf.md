# Audit Report

## Title
Rosetta API Cannot Detect Chain Forks Due to Non-Cryptographic Block Hash Implementation

## Summary
The Aptos Rosetta API implementation uses a fake block hash format (`chain_id-block_height`) instead of the actual cryptographic block hash available in the blockchain data. This prevents Rosetta clients from verifying block content integrity or detecting if different nodes serve different content at the same block height.

## Finding Description

The Rosetta API is designed to provide a standardized interface for blockchain integrations, where block hashes serve as cryptographic identifiers to verify block content and detect chain forks. However, the Aptos implementation violates this design principle.

The vulnerability exists in how `BlockIdentifier` is constructed from blockchain data. The code explicitly ignores the real cryptographic hash available in `BcsBlock.block_hash` and instead generates a deterministic string: [1](#0-0) 

This fake hash is acknowledged in the codebase documentation: [2](#0-1) 

The blockchain data does contain real cryptographic block hashes: [3](#0-2) [4](#0-3) 

**Attack Scenario:**

If any of the following occur, Rosetta clients cannot detect the inconsistency:

1. **Storage corruption bug**: If AptosDB has corruption that causes block N to contain different transactions than originally committed, the Rosetta API would serve corrupted data with the same hash (`chain_id-N`).

2. **State sync inconsistency**: During state synchronization, if a node temporarily serves blocks from an inconsistent state, clients cannot verify the content matches the canonical chain.

3. **Malicious node operator**: A compromised Rosetta server could serve fabricated transactions at specific heights, and clients have no cryptographic proof to verify authenticity.

4. **Cross-node verification impossible**: When querying multiple Rosetta servers, clients cannot cryptographically verify they're receiving identical block content, as the hash is deterministic from height alone.

The parent block verification also uses the fake hash: [5](#0-4) 

## Impact Explanation

**Severity: High** (up to $50,000 per bug bounty criteria)

This qualifies as a "Significant protocol violation" because:

1. **Breaks Rosetta API design invariants**: The Rosetta specification requires block hashes to be content-based cryptographic identifiers. This implementation violates that fundamental assumption.

2. **Breaks defense-in-depth**: While Aptos BFT prevents forks under normal operation (<1/3 Byzantine), this creates a single point of trust. If any bug in consensus, storage, or state sync causes inconsistent state, Rosetta clients cannot detect it.

3. **Impacts exchanges and integrators**: Financial institutions relying on Rosetta for Aptos integration cannot verify block authenticity or detect data inconsistencies across multiple nodes.

4. **No client-side verification possible**: Unlike other Rosetta implementations (Bitcoin, Ethereum) where clients can verify block hashes match the consensus rules, Aptos clients must fully trust their specific Rosetta server.

## Likelihood Explanation

**Likelihood: Medium**

While Aptos BFT consensus prevents forks during normal operation, several realistic scenarios could trigger inconsistent state:

1. **Storage bugs**: Past blockchain implementations have had storage corruption bugs (LevelDB/RocksDB issues, disk failures, backup/restore errors).

2. **State sync edge cases**: Complex state synchronization logic may have edge cases where nodes temporarily serve inconsistent data.

3. **Upgrades and migrations**: During network upgrades or data migrations, inconsistencies may occur.

4. **Malicious infrastructure**: Compromised cloud providers or malicious node operators could serve fake data.

The impact is amplified because Rosetta is specifically designed for financial integrations (exchanges, custodians) where data integrity is critical.

## Recommendation

Replace the fake block hash with the actual cryptographic block hash from the blockchain data:

```rust
impl BlockIdentifier {
    pub fn from_block(
        block: &aptos_rest_client::aptos_api_types::BcsBlock,
        chain_id: ChainId,
    ) -> BlockIdentifier {
        BlockIdentifier {
            index: block.block_height,
            // Use the real cryptographic hash instead of fake hash
            hash: format!("0x{}", hex::encode(block.block_hash.to_vec())),
        }
    }
}
```

Additionally, if block hash lookups are needed, create a proper index:
- Add a `BlockByHashSchema` in storage to map block hash â†’ block height
- Implement hash-based lookup in `get_block_index_from_request`
- This maintains the benefits of content-addressable blocks

The API should also verify parent block hashes match:

```rust
async fn get_block_by_index(
    block_cache: &BlockRetriever,
    block_height: u64,
    chain_id: ChainId,
) -> ApiResult<(BlockIdentifier, aptos_rest_client::aptos_api_types::BcsBlock)> {
    let block = block_cache.get_block_by_height(block_height, true).await?;
    
    if block_height == 0 {
        Ok((BlockIdentifier::from_block(&block, chain_id), block))
    } else {
        let prev_block = block_cache.get_block_by_height(block_height - 1, false).await?;
        let prev_block_id = BlockIdentifier::from_block(&prev_block, chain_id);
        
        // Verify consistency: current block should reference previous block's hash
        // (requires adding parent_hash to NewBlockEvent or inferring from consensus data)
        
        Ok((prev_block_id, block))
    }
}
```

## Proof of Concept

This demonstrates that two different block contents would have the same Rosetta block hash:

```rust
#[cfg(test)]
mod test {
    use super::*;
    use aptos_types::chain_id::ChainId;
    use aptos_crypto::HashValue;
    
    #[test]
    fn test_block_hash_collision() {
        let chain_id = ChainId::test();
        let height = 100;
        
        // Create two different blocks at same height with different hashes
        let block1 = BcsBlock {
            block_height: height,
            block_hash: HashValue::random(), // Different hash
            block_timestamp: 1000000,
            first_version: 1000,
            last_version: 1099,
            transactions: None,
        };
        
        let block2 = BcsBlock {
            block_height: height,
            block_hash: HashValue::random(), // Different hash
            block_timestamp: 1000000,
            first_version: 1000,
            last_version: 1099,
            transactions: None,
        };
        
        // Both blocks have DIFFERENT real hashes
        assert_ne!(block1.block_hash, block2.block_hash);
        
        // But Rosetta generates the SAME identifier for both
        let id1 = BlockIdentifier::from_block(&block1, chain_id);
        let id2 = BlockIdentifier::from_block(&block2, chain_id);
        
        assert_eq!(id1.hash, id2.hash); // VULNERABILITY: Same fake hash!
        assert_eq!(id1.hash, "4-100"); // Both map to "chain_id-height"
        
        // This means Rosetta clients cannot distinguish between:
        // - The canonical block at height 100
        // - A corrupted/fake block at height 100
        // - Blocks from a forked chain at height 100
    }
}
```

**Notes:**

While Aptos BFT consensus provides strong fork prevention guarantees under normal operation, the Rosetta API implementation creates unnecessary risk by not using actual cryptographic block hashes. This violates the defense-in-depth principle and the Rosetta API design specification. Financial integrators cannot verify block authenticity or detect data inconsistencies across nodes, creating a single point of trust in their Rosetta server infrastructure.

### Citations

**File:** crates/aptos-rosetta/src/types/identifiers.rs (L423-433)
```rust
impl BlockIdentifier {
    pub fn from_block(
        block: &aptos_rest_client::aptos_api_types::BcsBlock,
        chain_id: ChainId,
    ) -> BlockIdentifier {
        BlockIdentifier {
            index: block.block_height,
            hash: BlockHash::new(chain_id, block.block_height).to_string(),
        }
    }
}
```

**File:** crates/aptos-rosetta/src/common.rs (L294-302)
```rust
/// BlockHash is not actually the block hash!  This was a hack put in, since we don't actually have
/// [BlockHash] indexable.  Instead, it just returns the combination of [ChainId] and the block_height (aka index).
///
/// The [BlockHash] string format is `chain_id-block_height`
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct BlockHash {
    chain_id: ChainId,
    block_height: u64,
}
```

**File:** api/types/src/block.rs (L28-41)
```rust
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BcsBlock {
    /// The block height (number of the block from 0)
    pub block_height: u64,
    pub block_hash: aptos_crypto::HashValue,
    /// The block timestamp in Unix epoch microseconds
    pub block_timestamp: u64,
    /// The first ledger version of the block inclusive
    pub first_version: u64,
    /// The last ledger version of the block inclusive
    pub last_version: u64,
    /// The transactions in the block in sequential order
    pub transactions: Option<Vec<TransactionOnChainData>>,
}
```

**File:** types/src/account_config/events/new_block.rs (L18-31)
```rust
/// Struct that represents a NewBlockEvent.
/// Should be kept in-sync with NewBlockEvent move struct in block.move.
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct NewBlockEvent {
    pub hash: AccountAddress,
    pub epoch: u64,
    pub round: u64,
    pub height: u64,
    pub previous_block_votes_bitvec: Vec<u8>,
    pub proposer: AccountAddress,
    pub failed_proposer_indices: Vec<u64>,
    // usecs (microseconds)
    pub timestamp: u64,
}
```

**File:** crates/aptos-rosetta/src/block.rs (L115-141)
```rust
/// Retrieves a block by its index (block height)
async fn get_block_by_index(
    block_cache: &BlockRetriever,
    block_height: u64,
    chain_id: ChainId,
) -> ApiResult<(
    BlockIdentifier,
    aptos_rest_client::aptos_api_types::BcsBlock,
)> {
    let block = block_cache.get_block_by_height(block_height, true).await?;

    // For the genesis block, we populate parent_block_identifier with the
    // same genesis block. Refer to
    // https://www.rosetta-api.org/docs/common_mistakes.html#malformed-genesis-block
    if block_height == 0 {
        Ok((BlockIdentifier::from_block(&block, chain_id), block))
    } else {
        // Retrieve the previous block's identifier
        let prev_block = block_cache
            .get_block_by_height(block_height - 1, false)
            .await?;
        let prev_block_id = BlockIdentifier::from_block(&prev_block, chain_id);

        // Retrieve the current block
        Ok((prev_block_id, block))
    }
}
```
