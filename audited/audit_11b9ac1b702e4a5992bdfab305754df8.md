# Audit Report

## Title
Resource Exhaustion via Per-Request HTTP Client Creation in NFT Metadata Crawler Asset Uploader Worker

## Summary
The `upload_asset()` function in the NFT metadata crawler's asset uploader worker creates a new `reqwest::Client` instance for every upload request, leading to resource exhaustion under concurrent load. This design flaw can be exploited to cause service degradation or denial of service of the NFT metadata indexing service.

## Finding Description

The asset uploader worker exposes an unauthenticated HTTP endpoint that creates a new HTTP client for each incoming request. [1](#0-0) 

This anti-pattern violates resource management best practices. Each `reqwest::Client` instance:
- Maintains its own connection pool
- Allocates internal data structures and memory
- Consumes system file descriptors
- Has a 180-second timeout [2](#0-1) 

The worker endpoint has no authentication or rate limiting protection. [3](#0-2) 

The server binds to all network interfaces (0.0.0.0), potentially exposing it to external access. [4](#0-3) 

**Attack Path:**
1. Attacker discovers the worker endpoint (typically deployed separately from the throttler)
2. Sends concurrent POST requests to the `/` endpoint with arbitrary URLs
3. Each request triggers creation of a new `Client` with 180s timeout
4. Under sustained load, accumulated clients exhaust system resources (file descriptors, memory, TCP connections)
5. Service becomes unresponsive or crashes

In contrast, the throttler component correctly uses a shared client instance. [5](#0-4) 

The same vulnerability exists in the `get_by_asset_uri()` function. [6](#0-5) 

## Impact Explanation

**Severity: Medium** (per the security question's classification)

This vulnerability causes service degradation or complete unavailability of the NFT metadata crawler service. However, it is important to note:

**Limited Scope:**
- Affects only the NFT metadata crawler, an auxiliary ecosystem service
- Does **not** impact core Aptos blockchain functionality (consensus, validators, transaction processing)
- Does **not** affect funds, staking, or governance
- The main blockchain continues operating normally even if this service fails

The impact aligns with Medium severity as it causes operational disruption to an ecosystem service but does not compromise the blockchain's security guarantees or financial integrity.

## Likelihood Explanation

**Likelihood: Medium to High**

The vulnerability is easily exploitable if the worker endpoint is network-accessible:
- No authentication required
- No rate limiting implemented
- Simple HTTP requests are sufficient
- No special privileges needed

Likelihood depends on deployment architecture:
- **Higher** if the worker is exposed to the internet or untrusted networks
- **Lower** if properly firewalled or deployed in a restricted network environment

The design pattern itself (creating clients per request) makes the service inherently vulnerable to resource exhaustion under any significant concurrent load, whether malicious or legitimate.

## Recommendation

**Fix: Use a Shared HTTP Client Instance**

Modify `AssetUploaderWorkerContext` to maintain a shared `reqwest::Client` instance, similar to the throttler's implementation:

```rust
#[derive(Clone)]
pub struct AssetUploaderWorkerContext {
    config: Arc<AssetUploaderWorkerConfig>,
    client: Arc<Client>,  // Add shared client
}

impl AssetUploaderWorkerContext {
    pub fn new(config: AssetUploaderWorkerConfig) -> Self {
        Self {
            config: Arc::new(config),
            client: Arc::new(
                Client::builder()
                    .timeout(Duration::from_secs(MAX_ASSET_UPLOAD_RETRY_SECONDS))
                    .build()
                    .expect("Failed to build HTTP client")
            ),
        }
    }

    async fn upload_asset(&self, url: &Url) -> anyhow::Result<impl IntoResponse + use<>> {
        let hashed_url = sha256::digest(url.to_string());
        // Use self.client instead of creating new one
        let form = Form::new()
            .text("id", hashed_url.clone())
            .text("metadata", format!("{{\"asset_uri\": \"{}\"}}", url))
            .text("url", url.to_string());

        let res = self.client  // Use shared client
            .post(format!(
                "https://api.cloudflare.com/client/v4/accounts/{}/images/v1",
                self.config.cloudflare_account_id
            ))
            .header("Authorization", format!("Bearer {}", self.config.cloudflare_auth_key))
            .multipart(form)
            .send()
            .await
            .context("Error sending request to Cloudflare")?;

        reqwest_response_to_axum_response(res).await
    }
}
```

Apply the same fix to `get_by_asset_uri()`.

**Additional Hardening (Optional):**
- Add authentication middleware to the worker endpoints
- Implement rate limiting using tower middleware
- Add monitoring for concurrent request counts
- Consider connection pool size limits if needed

## Proof of Concept

```rust
// File: ecosystem/nft-metadata-crawler/tests/resource_exhaustion_test.rs
use reqwest::Client;
use std::time::Duration;
use tokio;

#[tokio::test]
async fn test_worker_resource_exhaustion() {
    // Assumes worker is running on localhost:8080
    let worker_url = "http://localhost:8080/";
    let client = Client::new();
    
    // Spawn 100 concurrent requests
    let mut handles = vec![];
    for i in 0..100 {
        let client_clone = client.clone();
        let url = worker_url.to_string();
        
        let handle = tokio::spawn(async move {
            let response = client_clone
                .post(&url)
                .json(&serde_json::json!({
                    "url": format!("https://example.com/image{}.png", i)
                }))
                .timeout(Duration::from_secs(200))
                .send()
                .await;
            
            match response {
                Ok(_) => println!("Request {} succeeded", i),
                Err(e) => println!("Request {} failed: {}", i, e),
            }
        });
        
        handles.push(handle);
    }
    
    // Wait for all requests
    for handle in handles {
        let _ = handle.await;
    }
    
    // Under the current implementation, system resources will be strained
    // Monitor file descriptors: lsof -p <worker_pid> | wc -l
    // Monitor memory: ps aux | grep worker
}
```

## Notes

**Important Context:**
1. This vulnerability affects the **NFT metadata crawler**, which is an ecosystem indexing service, not core blockchain infrastructure
2. Exploitation does not compromise consensus, validator operations, or funds
3. The Aptos blockchain continues functioning normally even if this service is unavailable
4. The actual issue is resource exhaustion via client proliferation, not traditional connection pool exhaustion
5. Deployment configuration (network access, firewalls) significantly affects exploitability
6. This represents a deviation from best practices seen elsewhere in the codebase where shared clients are properly used

### Citations

**File:** ecosystem/nft-metadata-crawler/src/asset_uploader/worker/mod.rs (L71-74)
```rust
        let client = Client::builder()
            .timeout(Duration::from_secs(MAX_ASSET_UPLOAD_RETRY_SECONDS))
            .build()
            .context("Error building reqwest client")?;
```

**File:** ecosystem/nft-metadata-crawler/src/asset_uploader/worker/mod.rs (L131-134)
```rust
        let client = Client::builder()
            .timeout(Duration::from_secs(MAX_ASSET_UPLOAD_RETRY_SECONDS))
            .build()
            .context("Error building reqwest client")?;
```

**File:** ecosystem/nft-metadata-crawler/src/asset_uploader/worker/mod.rs (L224-229)
```rust
    fn build_router(&self) -> Router {
        Router::new()
            .route("/", post(Self::handle_upload))
            .route("/get_existing", get(Self::handle_get_by_asset_uri))
            .layer(Extension(Arc::new(self.clone())))
    }
```

**File:** ecosystem/nft-metadata-crawler/src/utils/constants.rs (L17-17)
```rust
pub const MAX_ASSET_UPLOAD_RETRY_SECONDS: u64 = 180;
```

**File:** ecosystem/nft-metadata-crawler/src/config.rs (L100-100)
```rust
        let listener = TcpListener::bind(format!("0.0.0.0:{}", self.server_port)).await?;
```

**File:** ecosystem/nft-metadata-crawler/src/asset_uploader/throttler/mod.rs (L99-99)
```rust
            client: Arc::new(Client::new()),
```
