# Audit Report

## Title
Unbounded Type Argument List Parsing Causes Memory Exhaustion in Validator API Servers

## Summary
The `parse_type_tag()` function in the Move type parser lacks limits on the number of type arguments in struct tags. An attacker can submit a JSON transaction with a maliciously crafted type tag containing millions of comma-separated type arguments, causing unbounded memory allocation during JSON deserialization and leading to API server crashes or severe slowdowns.

## Finding Description

The vulnerability exists in the type tag parsing logic where struct type arguments are parsed without any limit on their count. [1](#0-0) 

The `parse_comma_list()` function iterates indefinitely until it encounters the end token (`>`), with no limit on the number of items parsed. When parsing struct type arguments, this function is invoked: [2](#0-1) 

While there is a depth limit (`MAX_TYPE_TAG_NESTING = 8`) to prevent excessive nesting: [3](#0-2) [4](#0-3) 

**There is NO limit on the WIDTH** (number of type arguments at a single nesting level).

### Attack Vector

When a user submits a transaction via the REST API using JSON format, the type arguments are deserialized through this path:

1. JSON deserialization of `MoveType` occurs: [5](#0-4) 

2. Which calls the `FromStr` implementation: [6](#0-5) 

3. Leading to the vulnerable parser at line 830: [7](#0-6) 

This parsing happens **BEFORE** any validation or gas checks are performed: [8](#0-7) 

The `data.verify()` call on line 481 occurs AFTER JSON deserialization has already completed, meaning the malicious parsing has already consumed memory.

### Exploitation Scenario

An attacker crafts a JSON transaction payload:
```
POST /v1/transactions
{
  "sender": "0x1",
  "sequence_number": "0",
  "payload": {
    "type": "entry_function_payload",
    "function": "0x1::coin::transfer",
    "type_arguments": ["0x1::M::S<u64,u64,u64,u64,u64,... (1 million repetitions) ...,u64>"],
    "arguments": []
  },
  ...
}
```

When the API server deserializes this JSON:
- The tokenizer creates ~2 million tokens (1M type args + 1M commas)
- The parser allocates a Vec and pushes 1 million `TypeTag::U64` entries
- Each TypeTag is ~24-40 bytes, resulting in 24-40 MB allocation just for the Vec
- Plus tokenization overhead and intermediate allocations
- This happens synchronously in the API request handler thread

Multiple parallel requests can multiply the effect, exhausting server memory.

## Impact Explanation

**HIGH Severity** per Aptos bug bounty criteria:
- **API crashes**: Memory exhaustion can crash the REST API server
- **Validator node slowdowns**: Even if not crashing, garbage collection pressure and memory allocation can severely degrade performance
- **Denial of Service**: Affects transaction submission, a critical validator function

The API server is integral to validator node operations: [9](#0-8) 

When enabled on validator nodes, this vulnerability allows any unauthenticated attacker to disrupt transaction processing without requiring:
- Gas payment
- Valid signatures
- Account ownership
- Any on-chain state

## Likelihood Explanation

**HIGH likelihood**:
- Trivial to exploit - single HTTP POST request
- No authentication required
- No rate limiting on parsing (only on successful transaction submission)
- Attack completes during JSON deserialization, before any validation
- Can be automated and repeated
- Multiple concurrent requests amplify the effect
- Works against any validator node with API enabled for transaction submission

## Recommendation

Implement a maximum limit on the number of type arguments allowed in struct tags. Add a constant similar to `MAX_TYPE_TAG_NESTING`:

```rust
// In third_party/move/move-core/types/src/safe_serialize.rs
pub(crate) const MAX_TYPE_TAG_NESTING: u8 = 8;
pub(crate) const MAX_TYPE_ARGS_PER_STRUCT: usize = 32; // Add this

// In third_party/move/move-core/types/src/parser.rs
fn parse_comma_list<F, R>(
    &mut self,
    parse_list_item: F,
    end_token: Token,
    allow_trailing_comma: bool,
    max_items: Option<usize>, // Add limit parameter
) -> Result<Vec<R>>
where
    F: Fn(&mut Self) -> Result<R>,
    R: std::fmt::Debug,
{
    let mut v = vec![];
    if !(self.peek() == Some(&end_token)) {
        loop {
            if let Some(max) = max_items {
                if v.len() >= max {
                    bail!("Exceeded maximum number of items: {}", max);
                }
            }
            v.push(parse_list_item(self)?);
            if self.peek() == Some(&end_token) {
                break;
            }
            self.consume(Token::Comma)?;
            if self.peek() == Some(&end_token) && allow_trailing_comma {
                break;
            }
        }
    }
    Ok(v)
}

// When parsing struct type arguments (line 316-320):
let ty_args = self.parse_comma_list(
    |parser| parser.parse_type_tag(depth + 1),
    Token::Gt,
    true,
    Some(MAX_TYPE_ARGS_PER_STRUCT), // Enforce limit
)?;
```

## Proof of Concept

```rust
// Add to third_party/move/move-core/types/src/parser.rs tests
#[test]
fn test_excessive_type_arguments_should_fail() {
    // Create a struct tag with 10,000 type arguments
    let mut malicious_tag = String::from("0x1::Module::Struct<");
    for i in 0..10000 {
        if i > 0 {
            malicious_tag.push_str(",");
        }
        malicious_tag.push_str("u64");
    }
    malicious_tag.push_str(">");
    
    // This should fail with an error, but currently succeeds and consumes memory
    let result = parse_struct_tag(&malicious_tag);
    
    // Currently this assertion FAILS (vulnerability exists):
    // assert!(result.is_err(), "Should reject excessive type arguments");
    
    // To demonstrate the memory consumption:
    if let Ok(tag) = result {
        assert_eq!(tag.type_args.len(), 10000); // Shows it actually parsed all 10k
        // Each TypeTag is ~32 bytes = 320KB just for the Vec
        // With 1 million args = 32MB+ per request
    }
}

// HTTP-based PoC (requires running API server):
// curl -X POST http://localhost:8080/v1/transactions \
//   -H "Content-Type: application/json" \
//   -d '{
//     "sender": "0x1",
//     "sequence_number": "0", 
//     "max_gas_amount": "1000",
//     "gas_unit_price": "1",
//     "expiration_timestamp_secs": "9999999999",
//     "payload": {
//       "type": "entry_function_payload",
//       "function": "0x1::aptos_account::transfer",
//       "type_arguments": ["0x1::M::S<u64,u64,u64,u64,u64,u64,u64,u64,u64,u64,u64,u64,u64,u64,u64,... (repeat 100000 times) ...>"],
//       "arguments": []
//     },
//     "signature": { "type": "ed25519_signature", "public_key": "0x00", "signature": "0x00" }
//   }'
// 
// Monitor server memory usage - it will spike during deserialization
```

### Citations

**File:** third_party/move/move-core/types/src/parser.rs (L237-261)
```rust
    fn parse_comma_list<F, R>(
        &mut self,
        parse_list_item: F,
        end_token: Token,
        allow_trailing_comma: bool,
    ) -> Result<Vec<R>>
    where
        F: Fn(&mut Self) -> Result<R>,
        R: std::fmt::Debug,
    {
        let mut v = vec![];
        if !(self.peek() == Some(&end_token)) {
            loop {
                v.push(parse_list_item(self)?);
                if self.peek() == Some(&end_token) {
                    break;
                }
                self.consume(Token::Comma)?;
                if self.peek() == Some(&end_token) && allow_trailing_comma {
                    break;
                }
            }
        }
        Ok(v)
    }
```

**File:** third_party/move/move-core/types/src/parser.rs (L287-289)
```rust
        if depth > crate::safe_serialize::MAX_TYPE_TAG_NESTING {
            bail!("Exceeded TypeTag nesting limit during parsing: {}", depth);
        }
```

**File:** third_party/move/move-core/types/src/parser.rs (L314-325)
```rust
                                let ty_args = if self.peek() == Some(&Token::Lt) {
                                    self.next()?;
                                    let ty_args = self.parse_comma_list(
                                        |parser| parser.parse_type_tag(depth + 1),
                                        Token::Gt,
                                        true,
                                    )?;
                                    self.consume(Token::Gt)?;
                                    ty_args
                                } else {
                                    vec![]
                                };
```

**File:** third_party/move/move-core/types/src/safe_serialize.rs (L11-11)
```rust
pub(crate) const MAX_TYPE_TAG_NESTING: u8 = 8;
```

**File:** api/types/src/move_types.rs (L813-842)
```rust
impl FromStr for MoveType {
    type Err = anyhow::Error;

    fn from_str(mut s: &str) -> Result<Self, Self::Err> {
        let mut is_ref = false;
        let mut is_mut = false;
        if s.starts_with('&') {
            s = &s[1..];
            is_ref = true;
        }
        if is_ref && s.starts_with("mut ") {
            s = &s[4..];
            is_mut = true;
        }
        // Previously this would just crap out, but this meant the API could
        // return a serialized version of an object and not be able to
        // deserialize it using that same object.
        let inner = match parse_type_tag(s) {
            Ok(inner) => (&inner).into(),
            Err(_e) => MoveType::Unparsable(s.to_string()),
        };
        if is_ref {
            Ok(MoveType::Reference {
                mutable: is_mut,
                to: Box::new(inner),
            })
        } else {
            Ok(inner)
        }
    }
```

**File:** api/types/src/move_types.rs (L852-860)
```rust
impl<'de> Deserialize<'de> for MoveType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let data = <String>::deserialize(deserializer)
            .map_err(|e| D::Error::custom(format_err!("deserialize Move type failed, {}", e)))?;
        data.parse().map_err(D::Error::custom)
    }
```

**File:** api/src/transactions.rs (L476-488)
```rust
    async fn submit_transaction(
        &self,
        accept_type: AcceptType,
        data: SubmitTransactionPost,
    ) -> SubmitTransactionResult<PendingTransaction> {
        data.verify()
            .context("Submitted transaction invalid'")
            .map_err(|err| {
                SubmitTransactionError::bad_request_with_code_no_info(
                    err,
                    AptosErrorCode::InvalidInput,
                )
            })?;
```

**File:** config/src/config/api_config.rs (L48-49)
```rust
    #[serde(default = "default_enabled")]
    pub transaction_submission_enabled: bool,
```
