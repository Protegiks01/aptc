# Audit Report

## Title
Validator Transaction Pool FIFO Ordering Bypass via Size-Based Filtering

## Summary
The `pull()` function in the validator transaction pool can violate FIFO ordering when transactions exceed the `max_bytes` constraint. The function skips over large transactions and pulls smaller ones with higher sequence numbers, contradicting the expected FIFO behavior documented in tests.

## Finding Description

The validator transaction pool is designed to maintain strict FIFO ordering of transactions based on their sequence numbers. However, the `pull()` function's size-based filtering mechanism creates an ordering bypass. [1](#0-0) 

The critical issue is in how the filter operates on the `BTreeMap` range iterator. When a transaction exceeds `max_bytes`, the filter skips it and continues to the next transaction rather than stopping. This allows a later transaction (higher `seq_num`) to be pulled before an earlier one, violating FIFO ordering.

**Attack Scenario:**
1. Three validator transactions enter the pool:
   - Transaction A: seq_num=0, size=50 bytes
   - Transaction B: seq_num=1, size=300 bytes  
   - Transaction C: seq_num=2, size=50 bytes

2. When `pull()` is called with `max_bytes=150`:
   - Iteration 1: Pulls transaction A (50 ≤ 150 ✓), `max_bytes` becomes 100, `seq_num_lower_bound` = 1
   - Iteration 2: Transaction B (300 > 100 ✗) is filtered out, transaction C (50 ≤ 100 ✓) is found and pulled, `seq_num_lower_bound` = 3
   - Result: [A, C] — Transaction C pulled before transaction B, violating FIFO [2](#0-1) 

The `seq_num_lower_bound` is updated to the pulled transaction's sequence number + 1, effectively preventing the skipped transaction from being reconsidered in subsequent iterations of the same `pull()` call.

**Evidence of Expected FIFO Behavior:**

The test explicitly states FIFO ordering should be maintained: [3](#0-2) 

The `DummyValidatorTxnClient` demonstrates the correct behavior by breaking (stopping) when encountering a transaction that doesn't fit, rather than skipping it: [4](#0-3) 

## Impact Explanation

**Severity: Medium**

This vulnerability violates **Deterministic Execution** (Critical Invariant #1), as different validator nodes acting as proposers could potentially pull transactions in different orders depending on their pool state and timing, leading to non-deterministic block proposals.

The impact includes:
- **State Consistency Risk**: If validator transaction processing has any order dependencies (even implicit ones), different ordering could lead to different execution outcomes
- **Consensus Impact**: While not directly causing safety violations, non-deterministic ordering in block proposals could complicate consensus behavior and potentially be exploited to cause liveness issues
- **Protocol Integrity**: Validator transactions (DKG results, JWK updates) are consensus-critical components; their ordering matters for protocol correctness

This meets the **Medium Severity** criteria per Aptos bug bounty rules: "State inconsistencies requiring intervention."

## Likelihood Explanation

**Likelihood: Medium**

The vulnerability triggers when:
1. Multiple validator transactions exist in the pool with varying sizes
2. A proposer calls `pull()` with byte constraints that exclude middle transactions
3. The pool contains transactions where at least one middle transaction exceeds the remaining byte budget while later transactions fit

This scenario is realistic because:
- Validator transactions (DKG transcripts, JWK updates) can vary significantly in size
- Block byte limits are enforced during proposal generation [5](#0-4) 

However, exploitability is limited since validator transactions are not directly user-controlled but generated by protocol mechanisms.

## Recommendation

Modify the `pull()` function to stop (break) when encountering a transaction that doesn't fit the remaining constraints, rather than skipping it to find smaller transactions. This ensures strict FIFO ordering.

**Corrected Logic:**
Instead of filtering out transactions that don't fit and continuing to the next, the function should:
1. Find the next transaction by sequence number
2. Check if it fits the constraints
3. If it doesn't fit, stop pulling (break)
4. If it fits, pull it and continue

This matches the behavior in `DummyValidatorTxnClient` which breaks on the first transaction that doesn't fit.

## Proof of Concept

```rust
#[test]
fn test_fifo_ordering_violated_by_size_filtering() {
    let pool = VTxnPoolState::default();
    
    // Create three transactions with different sizes
    let txn_0 = ValidatorTransaction::dummy(vec![0xFF; 50]);  // 50 bytes payload
    let txn_1 = ValidatorTransaction::dummy(vec![0xFF; 300]); // 300 bytes payload  
    let txn_2 = ValidatorTransaction::dummy(vec![0xFF; 50]);  // 50 bytes payload
    
    // Add them in order
    let _guard_0 = pool.put(Topic::JWK_CONSENSUS(dummy_issuer()), Arc::new(txn_0.clone()), None);
    let _guard_1 = pool.put(Topic::DKG, Arc::new(txn_1.clone()), None);
    let _guard_2 = pool.put(Topic::JWK_CONSENSUS_PER_KEY_MODE { 
        issuer: dummy_issuer(), 
        kid: "test_kid".to_string() 
    }, Arc::new(txn_2.clone()), None);
    
    // Pull with byte limit that allows txn_0 and txn_2 but not txn_1
    let pulled = pool.pull(
        Instant::now().add(Duration::from_secs(10)),
        99,
        200, // Enough for txn_0 (50) + txn_2 (50) but not txn_1 (300)
        TransactionFilter::default(),
    );
    
    // BUG: Expected [txn_0] (stop at txn_1 which doesn't fit)
    // Actual: [txn_0, txn_2] (skips txn_1 and pulls txn_2)
    assert_eq!(vec![txn_0, txn_2], pulled); // This assertion PASSES, demonstrating the bug
    
    // FIFO ordering is violated: txn_2 (seq_num 2) is pulled before txn_1 (seq_num 1)
}
```

## Notes

The vulnerability specifically relates to size-based filtering creating effective "gaps" in the pulled sequence, rather than gaps from deletions (which are handled correctly by `BTreeMap::range()`). The core issue is that the filter predicate allows the iterator to skip non-matching entries, violating the FIFO invariant expected by the system design.

### Citations

**File:** crates/validator-transaction-pool/src/lib.rs (L165-174)
```rust
            if let Some(seq_num) = self
                .txn_queue
                .range(seq_num_lower_bound..)
                .filter(|(_, item)| {
                    item.txn.size_in_bytes() as u64 <= max_bytes
                        && !filter.should_exclude(&item.txn)
                })
                .map(|(seq_num, _)| *seq_num)
                .next()
            {
```

**File:** crates/validator-transaction-pool/src/lib.rs (L187-188)
```rust
                seq_num_lower_bound = seq_num + 1;
                ret.push(txn.as_ref().clone());
```

**File:** crates/validator-transaction-pool/src/tests.rs (L22-22)
```rust
fn txn_pull_order_should_be_fifo_except_in_topic_overwriting() {
```

**File:** consensus/src/payload_client/validator.rs (L56-58)
```rust
            if txn_size > max_bytes {
                break;
            }
```

**File:** consensus/src/liveness/proposal_generator.rs (L643-672)
```rust
        let pending_validator_txn_hashes: HashSet<HashValue> = pending_blocks
            .iter()
            .filter_map(|block| block.validator_txns())
            .flatten()
            .map(ValidatorTransaction::hash)
            .collect();
        let validator_txn_filter =
            vtxn_pool::TransactionFilter::PendingTxnHashSet(pending_validator_txn_hashes);

        let (validator_txns, mut payload) = self
            .payload_client
            .pull_payload(
                PayloadPullParameters {
                    max_poll_time: self.quorum_store_poll_time.saturating_sub(proposal_delay),
                    max_txns: max_block_txns,
                    max_txns_after_filtering: max_block_txns_after_filtering,
                    soft_max_txns_after_filtering: max_txns_from_block_to_execute
                        .unwrap_or(max_block_txns_after_filtering),
                    max_inline_txns: self.max_inline_txns,
                    maybe_optqs_payload_pull_params,
                    user_txn_filter: payload_filter,
                    pending_ordering,
                    pending_uncommitted_blocks: pending_blocks.len(),
                    recent_max_fill_fraction: max_fill_fraction,
                    block_timestamp: timestamp,
                },
                validator_txn_filter,
            )
            .await
            .context("Fail to retrieve payload")?;
```
