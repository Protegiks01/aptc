# Audit Report

## Title
Indexer Panic on Post-Migration Coin Events Due to Missing Event-to-CoinType Mapping

## Summary
The external indexer (`crates/indexer/`) panics when processing coin deposit/withdraw events after a CoinStore has been migrated to a fungible asset store. This occurs because the v2-to-v1 event translator uses fallback event creation numbers for migrated accounts, but the indexer only builds its event-to-coin-type mapping from CoinStore resources in the transaction's write set, which no longer exist post-migration. [1](#0-0) 

## Finding Description

The vulnerability exists in a multi-component interaction between the event translation system and the external indexer:

**Component 1: CoinStore Migration**
When users migrate from legacy CoinStore to modern fungible asset stores, the `maybe_convert_to_fungible_store` function permanently deletes the CoinStore resource: [2](#0-1) 

After migration, the account no longer has a CoinStore resource, only a primary fungible asset store.

**Component 2: V2-to-V1 Event Translation**
Modern deposit/withdraw operations emit v2 module events (CoinDeposit/CoinWithdraw). The internal indexer's `CoinDepositTranslator` converts these to v1 events for backward compatibility: [3](#0-2) 

Critically, when the CoinStore doesn't exist (line 248-249 returns None), the translator uses **deterministic fallback creation numbers**: 2 for deposit events, 3 for withdraw events (line 260-264).

**Component 3: API Event Translation**
The API serves translated v1 events when `enable_event_v2_translation` is enabled: [4](#0-3) 

**Component 4: External Indexer Panic**
The external indexer processes transactions by:
1. Building an event-to-coin-type mapping from CoinStore resources in the **write set** only
2. Processing events and looking up their GUIDs in this mapping [5](#0-4) 

The mapping is built exclusively from CoinStore write resources: [6](#0-5) 

**The Vulnerability:**
After CoinStore migration:
1. Deposit/withdraw operations use fungible asset stores (no CoinStore updates)
2. Transaction emits v2 CoinDeposit/CoinWithdraw events
3. V2-to-v1 translator uses fallback creation numbers (account_address, creation_num=2 or 3)
4. API serves this translated v1 event to the external indexer
5. Transaction write set contains **fungible asset changes only** (no CoinStore)
6. Indexer's event_to_coin_type mapping is **empty** for this account's events
7. Indexer attempts lookup at line 226 → **unwrap_or_else panics** [7](#0-6) 

## Impact Explanation

**High Severity** - Indexer crashes causing API data unavailability:

1. **Indexer Process Crash**: The panic causes the indexer process to terminate, halting all coin activity indexing
2. **API Data Loss**: Applications relying on indexed coin transfer history lose access to real-time and historical data
3. **Cascading Failures**: Multiple indexer instances crash when processing the same problematic transactions
4. **Recovery Complexity**: Requires code fix and reprocessing of affected transaction ranges

This meets **High Severity** criteria per Aptos bug bounty:
- "API crashes" - Indexer crashes prevent API data availability
- "Significant protocol violations" - Breaks the indexer's guarantee of processing all coin activities

While not directly a consensus issue, indexer availability is critical infrastructure that many applications depend on for transaction history, balance tracking, and event monitoring.

## Likelihood Explanation

**High Likelihood** due to:

1. **Active Migration Feature**: The `maybe_convert_to_fungible_store` function is actively used as Aptos migrates from CoinStore to fungible assets: [8](#0-7) 

2. **Automatic Triggering**: The vulnerability triggers automatically when any user with a migrated CoinStore performs a deposit/withdraw operation
3. **Feature Flag Dependency**: The `enable_event_v2_translation` flag is likely enabled in production to maintain backward compatibility
4. **No User Error Required**: Users following normal migration flows will trigger this issue

The attack doesn't require malicious intent - it occurs naturally during normal system operation with migrated accounts.

## Recommendation

**Option 1: Handle Missing Mapping Gracefully (Immediate Fix)**

Modify the external indexer to handle missing event GUIDs without panicking. Extract coin type from the v2 event data if available:

```rust
// In coin_activities.rs, replace lines 225-233
let coin_type = if let Some(ct) = event_to_coin_type.get(&event_move_guid) {
    ct.clone()
} else {
    // For migrated accounts, extract coin type from event data if available
    // or skip indexing this event with a warning
    warn!(
        "Event GUID not found in mapping for migrated account, version: {}, guid: {:?}",
        txn_version, event_move_guid
    );
    return; // Skip this event rather than panic
}
```

**Option 2: Preserve Event Metadata in Translation (Better Long-term Fix)**

Modify the v2-to-v1 translator to include coin type information in the translated event's data or use a special marker that the indexer can recognize: [3](#0-2) 

Add coin_type to the translated event's metadata or use a different approach where the indexer can extract coin type from the v2 event data directly.

**Option 3: Indexer v2 Event Support (Future-proof)**

Extend the external indexer to process v2 events directly without requiring v1 translation, eliminating the dependency on CoinStore resources entirely.

## Proof of Concept

```rust
// Reproduction steps:

// 1. Setup: Account with CoinStore migrates to fungible asset
// In Move:
module test_addr::trigger_bug {
    use aptos_framework::coin;
    use aptos_framework::aptos_coin::AptosCoin;
    
    public entry fun trigger_indexer_panic(account: &signer) {
        // Step 1: Migrate CoinStore to fungible asset store
        coin::migrate_to_fungible_store<AptosCoin>(account);
        
        // Step 2: Perform a deposit (emits v2 CoinDeposit event)
        // This will be translated to v1 with fallback creation number
        // but CoinStore is not in write set
        let coins = coin::withdraw<AptosCoin>(account, 100);
        coin::deposit(signer::address_of(account), coins);
        
        // When external indexer processes this transaction:
        // - Sees v1 DepositEvent with creation_number=2
        // - Builds mapping from write set (no CoinStore present)
        // - Lookup fails → PANIC at coin_activities.rs:228
    }
}

// Expected result: Indexer process terminates with panic:
// "Could not find event in resources (CoinStore), version: X, 
//  event guid: EventGuidResource { addr: "0x...", creation_num: 2 }"
```

## Notes

This vulnerability demonstrates a critical assumption mismatch between the event translation layer (which queries current state) and the indexer layer (which only examines the transaction's write set). The migration from CoinStore to fungible assets breaks this assumption, causing production crashes.

The fix should either make the indexer resilient to missing mappings or ensure the translation layer provides sufficient information for the indexer to function without depending on CoinStore resources that may no longer exist.

### Citations

**File:** crates/indexer/src/models/coin_models/coin_activities.rs (L129-196)
```rust
        for wsc in writesets {
            let (maybe_coin_info, maybe_coin_balance_data) =
                if let APIWriteSetChange::WriteResource(write_resource) = wsc {
                    (
                        CoinInfo::from_write_resource(write_resource, txn_version, txn_timestamp)
                            .unwrap(),
                        CoinBalance::from_write_resource(
                            write_resource,
                            txn_version,
                            txn_timestamp,
                        )
                        .unwrap(),
                    )
                } else {
                    (None, None)
                };

            let maybe_coin_supply = if let APIWriteSetChange::WriteTableItem(table_item) = &wsc {
                CoinSupply::from_write_table_item(
                    table_item,
                    maybe_aptos_coin_info,
                    txn_version,
                    txn_timestamp,
                    txn_epoch,
                )
                .unwrap()
            } else {
                None
            };

            if let Some(coin_info) = maybe_coin_info {
                coin_infos.insert(coin_info.coin_type.clone(), coin_info);
            }
            if let Some((coin_balance, current_coin_balance, event_to_coin_type)) =
                maybe_coin_balance_data
            {
                current_coin_balances.insert(
                    (
                        coin_balance.owner_address.clone(),
                        coin_balance.coin_type.clone(),
                    ),
                    current_coin_balance,
                );
                coin_balances.push(coin_balance);
                all_event_to_coin_type.extend(event_to_coin_type);
            }
            if let Some(coin_supply) = maybe_coin_supply {
                all_coin_supply.push(coin_supply);
            }
        }
        for (index, event) in events.iter().enumerate() {
            let event_type = event.typ.to_string();
            if let Some(parsed_event) =
                CoinEvent::from_event(event_type.as_str(), &event.data, txn_version).unwrap()
            {
                coin_activities.push(Self::from_parsed_event(
                    &event_type,
                    event,
                    &parsed_event,
                    txn_version,
                    &all_event_to_coin_type,
                    txn_info.block_height.unwrap().0 as i64,
                    &entry_function_id_str,
                    txn_timestamp,
                    index as i64,
                ));
            };
        }
```

**File:** crates/indexer/src/models/coin_models/coin_activities.rs (L206-251)
```rust
    fn from_parsed_event(
        event_type: &str,
        event: &APIEvent,
        coin_event: &CoinEvent,
        txn_version: i64,
        event_to_coin_type: &EventToCoinType,
        block_height: i64,
        entry_function_id_str: &Option<String>,
        transaction_timestamp: chrono::NaiveDateTime,
        event_index: i64,
    ) -> Self {
        let amount = match coin_event {
            CoinEvent::WithdrawCoinEvent(inner) => inner.amount.clone(),
            CoinEvent::DepositCoinEvent(inner) => inner.amount.clone(),
        };
        let event_move_guid = EventGuidResource {
            addr: event.guid.account_address.to_string(),
            creation_num: event.guid.creation_number.0 as i64,
        };
        let coin_type =
            event_to_coin_type
                .get(&event_move_guid)
                .unwrap_or_else(|| {
                    panic!(
                        "Could not find event in resources (CoinStore), version: {}, event guid: {:?}, mapping: {:?}",
                        txn_version, event_move_guid, event_to_coin_type
                    )
                }).clone();

        Self {
            transaction_version: txn_version,
            event_account_address: standardize_address(&event.guid.account_address.to_string()),
            event_creation_number: event.guid.creation_number.0 as i64,
            event_sequence_number: event.sequence_number.0 as i64,
            owner_address: standardize_address(&event.guid.account_address.to_string()),
            coin_type,
            amount,
            activity_type: event_type.to_string(),
            is_gas_fee: false,
            is_transaction_success: true,
            entry_function_id_str: entry_function_id_str.clone(),
            block_height,
            transaction_timestamp,
            event_index: Some(event_index),
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/coin.move (L650-701)
```text
    fun maybe_convert_to_fungible_store<CoinType>(
        account: address
    ) acquires CoinStore, CoinConversionMap, CoinInfo {
        if (exists<CoinStore<CoinType>>(account)) {
            let CoinStore<CoinType> { coin, frozen, deposit_events, withdraw_events } =
                move_from<CoinStore<CoinType>>(account);
            if (is_coin_initialized<CoinType>() && coin.value > 0) {
                let metadata = ensure_paired_metadata<CoinType>();
                let store =
                    primary_fungible_store::ensure_primary_store_exists(
                        account, metadata
                    );

                event::emit(
                    CoinStoreDeletion {
                        coin_type: type_info::type_name<CoinType>(),
                        event_handle_creation_address: guid::creator_address(
                            event::guid(&deposit_events)
                        ),
                        deleted_deposit_event_handle_creation_number: guid::creation_num(
                            event::guid(&deposit_events)
                        ),
                        deleted_withdraw_event_handle_creation_number: guid::creation_num(
                            event::guid(&withdraw_events)
                        )
                    }
                );

                if (coin.value == 0) {
                    destroy_zero(coin);
                } else {
                    fungible_asset::unchecked_deposit_with_no_events(
                        object_address(&store),
                        coin_to_fungible_asset(coin)
                    );
                };

                // Note:
                // It is possible the primary fungible store may already exist before this function call.
                // In this case, if the account owns a frozen CoinStore and an unfrozen primary fungible store, this
                // function would convert and deposit the rest coin into the primary store and freeze it to make the
                // `frozen` semantic as consistent as possible.
                if (frozen != fungible_asset::is_frozen(store)) {
                    fungible_asset::set_frozen_flag_internal(store, frozen);
                }
            } else {
                destroy_zero(coin);
            };
            event::destroy_handle(deposit_events);
            event::destroy_handle(withdraw_events);
        };
    }
```

**File:** aptos-move/framework/aptos-framework/sources/coin.move (L716-738)
```text
    /// Voluntarily migrate to fungible store for `CoinType` if not yet.
    public entry fun migrate_to_fungible_store<CoinType>(
        account: &signer
    ) acquires CoinStore, CoinConversionMap, CoinInfo {
        let account_addr = signer::address_of(account);
        assert_signer_has_permission<CoinType>(account);
        maybe_convert_to_fungible_store<CoinType>(account_addr);
    }

    /// Migrate to fungible store for `CoinType` if not yet.
    public entry fun migrate_coin_store_to_fungible_store<CoinType>(
        accounts: vector<address>
    ) acquires CoinStore, CoinConversionMap, CoinInfo {
        if (features::new_accounts_default_to_fa_store_enabled()
            || features::new_accounts_default_to_fa_apt_store_enabled()) {
            std::vector::for_each(
                accounts,
                |account| {
                    maybe_convert_to_fungible_store<CoinType>(account);
                }
            );
        }
    }
```

**File:** storage/indexer/src/event_v2_translator.rs (L238-274)
```rust
struct CoinDepositTranslator;
impl EventV2Translator for CoinDepositTranslator {
    fn translate_event_v2_to_v1(
        &self,
        v2: &ContractEventV2,
        engine: &EventV2TranslationEngine,
    ) -> Result<ContractEventV1> {
        let coin_deposit = CoinDeposit::try_from_bytes(v2.event_data())?;
        let struct_tag_str = format!("0x1::coin::CoinStore<{}>", coin_deposit.coin_type());
        let struct_tag = StructTag::from_str(&struct_tag_str)?;
        let (key, sequence_number) = if let Some(state_value_bytes) =
            engine.get_state_value_bytes_for_resource(coin_deposit.account(), &struct_tag)?
        {
            // We can use `DummyCoinType` as it does not affect the correctness of deserialization.
            let coin_store_resource: CoinStoreResource<DummyCoinType> =
                bcs::from_bytes(&state_value_bytes)?;
            let key = *coin_store_resource.deposit_events().key();
            let sequence_number = engine
                .get_next_sequence_number(&key, coin_store_resource.deposit_events().count())?;
            (key, sequence_number)
        } else {
            // The creation number of DepositEvent is deterministically 2.
            static DEPOSIT_EVENT_CREATION_NUMBER: u64 = 2;
            (
                EventKey::new(DEPOSIT_EVENT_CREATION_NUMBER, *coin_deposit.account()),
                0,
            )
        };
        let deposit_event = DepositEvent::new(coin_deposit.amount());
        Ok(ContractEventV1::new(
            key,
            sequence_number,
            DEPOSIT_EVENT_TYPE.clone(),
            bcs::to_bytes(&deposit_event)?,
        )?)
    }
}
```

**File:** api/src/context.rs (L1004-1036)
```rust
    fn maybe_translate_v2_to_v1_events(
        &self,
        mut txn: TransactionOnChainData,
    ) -> TransactionOnChainData {
        if self.indexer_reader.is_some()
            && self
                .node_config
                .indexer_db_config
                .enable_event_v2_translation
        {
            self.translate_v2_to_v1_events_for_version(txn.version, &mut txn.events)
                .ok();
        }
        txn
    }

    fn translate_v2_to_v1_events_for_version(
        &self,
        version: u64,
        events: &mut [ContractEvent],
    ) -> Result<()> {
        for (idx, event) in events.iter_mut().enumerate() {
            let translated_event = self
                .indexer_reader
                .as_ref()
                .ok_or(anyhow!("Internal indexer reader doesn't exist"))?
                .get_translated_v1_event_by_version_and_index(version, idx as u64);
            if let Ok(translated_event) = translated_event {
                *event = ContractEvent::V1(translated_event);
            }
        }
        Ok(())
    }
```

**File:** crates/indexer/src/models/coin_models/coin_balances.rs (L46-95)
```rust
impl CoinBalance {
    /// We can find coin info from resources. If the coin info appears multiple times we will only keep the first transaction because it can't be modified.
    pub fn from_write_resource(
        write_resource: &APIWriteResource,
        txn_version: i64,
        txn_timestamp: chrono::NaiveDateTime,
    ) -> anyhow::Result<Option<(Self, CurrentCoinBalance, EventToCoinType)>> {
        match &CoinResource::from_write_resource(write_resource, txn_version)? {
            Some(CoinResource::CoinStoreResource(inner)) => {
                let coin_info_type = &CoinInfoType::from_move_type(
                    &write_resource.data.typ.generic_type_params[0],
                    txn_version,
                )?;
                let owner_address = standardize_address(&write_resource.address.to_string());
                let coin_balance = Self {
                    transaction_version: txn_version,
                    owner_address: owner_address.clone(),
                    coin_type_hash: coin_info_type.to_hash(),
                    coin_type: coin_info_type.get_coin_type_trunc(),
                    amount: inner.coin.value.clone(),
                    transaction_timestamp: txn_timestamp,
                };
                let current_coin_balance = CurrentCoinBalance {
                    owner_address,
                    coin_type_hash: coin_info_type.to_hash(),
                    coin_type: coin_info_type.get_coin_type_trunc(),
                    amount: inner.coin.value.clone(),
                    last_transaction_version: txn_version,
                    last_transaction_timestamp: txn_timestamp,
                };
                let event_to_coin_mapping: EventToCoinType = HashMap::from([
                    (
                        (inner.withdraw_events.guid.id.clone()),
                        coin_balance.coin_type.clone(),
                    ),
                    (
                        (inner.deposit_events.guid.id.clone()),
                        coin_balance.coin_type.clone(),
                    ),
                ]);

                Ok(Some((
                    coin_balance,
                    current_coin_balance,
                    event_to_coin_mapping,
                )))
            },
            _ => Ok(None),
        }
    }
```
