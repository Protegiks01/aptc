# Audit Report

## Title
Multi-Key Authentication Threshold Validation Bypass Allowing Security Downgrade

## Summary
The `multi_key` module lacks critical validation when deserializing multi-key public keys, allowing accounts to be configured with invalid signature thresholds (including threshold=0 or threshold>num_keys). This enables malicious wallet software or UI manipulation to create accounts with severely weakened authentication requirements, potentially allowing attackers with access to a single compromised key to control accounts that were intended to require multiple signatures.

## Finding Description

The vulnerability exists in the Move framework's multi-key deserialization logic. When an account rotates to multi-key authentication via `rotate_authentication_key_from_public_key`, the multi-key public key is deserialized without validating critical security invariants. [1](#0-0) 

The `deserialize_multi_key` function directly constructs a `MultiKey` without any validation checks. In contrast, the safe constructor validates these constraints: [2](#0-1) 

However, even this constructor fails to validate that `signatures_required > 0`, only checking that it doesn't exceed the number of keys.

The account rotation function accepts any scheme including `MULTI_KEY_SCHEME` and calls the unvalidated deserialization: [3](#0-2) 

The Rust implementation's `MultiKey::new()` constructor has proper validation: [4](#0-3) 

However, the struct uses derived `Deserialize`, bypassing this validation during BCS deserialization: [5](#0-4) 

During transaction verification, the threshold check becomes meaningless with threshold=0: [6](#0-5) 

**Attack Path:**

1. User attempts to upgrade from single-key to multi-key authentication for enhanced security (e.g., intending 2-of-3 multi-sig)
2. Malicious wallet software or manipulated UI provides a crafted multi-key with `signatures_required=1` (or even `=0`) instead of the intended `=2`
3. User calls `rotate_authentication_key_from_public_key` with scheme `MULTI_KEY_SCHEME=3`
4. Move code deserializes the multi-key without validation, rotation succeeds
5. User believes they have 2-of-3 security, but actually have 1-of-3 security
6. Later, if attacker compromises any single key, they gain full account control
7. User loses funds, expecting that 2 keys would need to be compromised

**Broken Invariants:**
- **Transaction Validation**: Authentication thresholds must be valid (signatures_required > 0 and signatures_required <= num_keys)
- **Cryptographic Correctness**: Multi-signature schemes must enforce the specified threshold
- **Access Control**: Accounts must not be controllable with fewer signatures than configured

## Impact Explanation

This is a **Critical Severity** vulnerability meeting the "$1,000,000" tier criteria:

1. **Loss of Funds**: Attackers who compromise a single key can steal all funds from accounts that users believe require multiple signatures (e.g., 2-of-3 or 3-of-5 multi-sig).

2. **Security Expectation Violation**: Users explicitly choosing multi-key authentication for enhanced security are unknowingly given weakened security, violating fundamental trust assumptions.

3. **Consensus Impact**: While not directly breaking consensus, this creates deterministic but incorrect behavior - all validators will consistently accept transactions that violate the user's intended security policy.

4. **Permanent Damage**: Once rotated to an invalid threshold, recovery requires another key rotation, but if the user doesn't realize the configuration is wrong, their account remains vulnerable indefinitely.

Additionally, the DoS variant (threshold > num_keys) can permanently freeze accounts, requiring a hard fork to recover.

## Likelihood Explanation

**High Likelihood** due to:

1. **Attack Surface**: Any wallet application or dApp that implements multi-key rotation could contain this bug, either accidentally or maliciously
2. **User Visibility**: Threshold values are typically numeric inputs in UIs - easy to manipulate or mistype without obvious visual feedback
3. **No Runtime Protection**: The blockchain accepts and stores invalid configurations without warning
4. **Widespread Impact**: As multi-key authentication adoption grows (especially for institutional custody requiring M-of-N security), more accounts become vulnerable

The attack requires no special privileges - only the ability to influence parameters during account rotation, which could happen through:
- Malicious browser extensions
- Compromised wallet software
- Phishing sites with manipulated transaction parameters
- Simple UI bugs in legitimate wallets

## Recommendation

Add comprehensive validation to `deserialize_multi_key` in Move:

```move
public fun deserialize_multi_key(stream: &mut bcs_stream::BCSStream): MultiKey {
    let public_keys = bcs_stream::deserialize_vector(stream, |x| single_key::deserialize_any_public_key(x));
    let signatures_required = bcs_stream::deserialize_u8(stream);
    
    // CRITICAL VALIDATION
    let num_keys = public_keys.length();
    assert!(
        num_keys > 0,
        error::invalid_argument(E_INVALID_MULTI_KEY_NO_KEYS)
    );
    assert!(
        num_keys <= MAX_NUMBER_OF_PUBLIC_KEYS,
        error::invalid_argument(E_INVALID_MULTI_KEY_TOO_MANY_KEYS)
    );
    assert!(
        signatures_required > 0,
        error::invalid_argument(E_INVALID_MULTI_KEY_ZERO_THRESHOLD)
    );
    assert!(
        (signatures_required as u64) <= num_keys,
        error::invalid_argument(E_INVALID_MULTI_KEY_SIGNATURES_REQUIRED)
    );
    
    MultiKey { public_keys, signatures_required }
}
```

Add validation to `new_multi_key_from_single_keys` to check `signatures_required > 0`.

For Rust, implement custom `Deserialize` that calls `MultiKey::new()`:

```rust
impl<'de> Deserialize<'de> for MultiKey {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        #[derive(Deserialize)]
        struct MultiKeyRaw {
            public_keys: Vec<AnyPublicKey>,
            signatures_required: u8,
        }
        
        let raw = MultiKeyRaw::deserialize(deserializer)?;
        MultiKey::new(raw.public_keys, raw.signatures_required)
            .map_err(serde::de::Error::custom)
    }
}
```

## Proof of Concept

```move
#[test(account = @0x123)]
fun test_multi_key_threshold_zero_exploit(account: signer) {
    use std::vector;
    use aptos_std::ed25519;
    use aptos_std::single_key;
    use aptos_std::multi_key;
    
    // Create 3 ED25519 keys
    let pk1_bytes = x"1ea76665..."; // Sample public key
    let pk2_bytes = x"eaba36...";
    let pk3_bytes = x"04cf90...";
    
    let pk1 = ed25519::new_unvalidated_public_key_from_bytes(pk1_bytes);
    let pk2 = ed25519::new_unvalidated_public_key_from_bytes(pk2_bytes);
    let pk3 = ed25519::new_unvalidated_public_key_from_bytes(pk3_bytes);
    
    let any_pk1 = single_key::from_ed25519_public_key_unvalidated(pk1);
    let any_pk2 = single_key::from_ed25519_public_key_unvalidated(pk2);
    let any_pk3 = single_key::from_ed25519_public_key_unvalidated(pk3);
    
    let keys = vector::empty();
    vector::push_back(&mut keys, any_pk1);
    vector::push_back(&mut keys, any_pk2);
    vector::push_back(&mut keys, any_pk3);
    
    // Craft malicious multi-key with threshold=0 via BCS bytes
    // Format: [vector_length, pk1, pk2, pk3, threshold_byte]
    let malicious_bytes = /* BCS encoding with last byte = 0x00 */;
    
    // This should FAIL but currently SUCCEEDS
    let malicious_mk = multi_key::new_public_key_from_bytes(malicious_bytes);
    
    // Rotate account to use this weak multi-key
    account::rotate_authentication_key_from_public_key(
        &account,
        3, // MULTI_KEY_SCHEME
        malicious_bytes
    );
    
    // Account now accepts transactions with just 1 signature instead of intended 2+
    // User believes they have 2-of-3 security, but actually have 1-of-3
}
```

This vulnerability represents a critical breakdown in the authentication security model, allowing accounts to be configured with invalid signature thresholds that violate users' security expectations and enable fund theft.

### Citations

**File:** aptos-move/framework/aptos-stdlib/sources/cryptography/multi_key.move (L59-74)
```text
    public fun new_multi_key_from_single_keys(single_keys: vector<single_key::AnyPublicKey>, signatures_required: u8): MultiKey {
        let num_keys = single_keys.length();
        assert!(
            num_keys > 0,
            error::invalid_argument(E_INVALID_MULTI_KEY_NO_KEYS)
        );
        assert!(
            num_keys <= MAX_NUMBER_OF_PUBLIC_KEYS,
            error::invalid_argument(E_INVALID_MULTI_KEY_TOO_MANY_KEYS)
        );
        assert!(
            (signatures_required as u64) <= num_keys,
            error::invalid_argument(E_INVALID_MULTI_KEY_SIGNATURES_REQUIRED)
        );
        MultiKey { public_keys: single_keys, signatures_required }
    }
```

**File:** aptos-move/framework/aptos-stdlib/sources/cryptography/multi_key.move (L76-81)
```text
    /// Deserializes a MultiKey public key from a BCS stream.
    public fun deserialize_multi_key(stream: &mut bcs_stream::BCSStream): MultiKey {
        let public_keys = bcs_stream::deserialize_vector(stream, |x| single_key::deserialize_any_public_key(x));
        let signatures_required = bcs_stream::deserialize_u8(stream);
        MultiKey { public_keys, signatures_required }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L468-496)
```text
    entry fun rotate_authentication_key_from_public_key(account: &signer, scheme: u8, new_public_key_bytes: vector<u8>) acquires Account {
        let addr = signer::address_of(account);
        let account_resource = &Account[addr];
        let old_auth_key = account_resource.authentication_key;
        let new_auth_key;
        if (scheme == ED25519_SCHEME) {
            let from_pk = ed25519::new_unvalidated_public_key_from_bytes(new_public_key_bytes);
            new_auth_key = ed25519::unvalidated_public_key_to_authentication_key(&from_pk);
        } else if (scheme == MULTI_ED25519_SCHEME) {
            let from_pk = multi_ed25519::new_unvalidated_public_key_from_bytes(new_public_key_bytes);
            new_auth_key = multi_ed25519::unvalidated_public_key_to_authentication_key(&from_pk);
        } else if (scheme == SINGLE_KEY_SCHEME) {
            new_auth_key = single_key::new_public_key_from_bytes(new_public_key_bytes).to_authentication_key();
        } else if (scheme == MULTI_KEY_SCHEME) {
            new_auth_key = multi_key::new_public_key_from_bytes(new_public_key_bytes).to_authentication_key();
        } else {
            abort error::invalid_argument(EUNRECOGNIZED_SCHEME)
        };
        rotate_authentication_key_call(account, new_auth_key);
        event::emit(KeyRotationToPublicKey {
            account: addr,
            // Set verified_public_key_bit_map to [0x00, 0x00, 0x00, 0x00] as the public key(s) are not verified
            verified_public_key_bit_map: vector[0x00, 0x00, 0x00, 0x00],
            public_key_scheme: scheme,
            public_key: new_public_key_bytes,
            old_auth_key,
            new_auth_key,
        });
    }
```

**File:** types/src/transaction/authenticator.rs (L1098-1103)
```rust
        ensure!(
            self.signatures.len() >= self.public_keys.signatures_required() as usize,
            "Not enough signatures for verification, {} < {}.",
            self.signatures.len(),
            self.public_keys.signatures_required(),
        );
```

**File:** types/src/transaction/authenticator.rs (L1132-1136)
```rust
#[derive(Clone, Debug, Eq, PartialEq, Hash, Serialize, Deserialize)]
pub struct MultiKey {
    public_keys: Vec<AnyPublicKey>,
    signatures_required: u8,
}
```

**File:** types/src/transaction/authenticator.rs (L1154-1177)
```rust
    pub fn new(public_keys: Vec<AnyPublicKey>, signatures_required: u8) -> Result<Self> {
        ensure!(
            signatures_required > 0,
            "The number of required signatures is 0."
        );

        ensure!(
            public_keys.len() <= MAX_NUM_OF_SIGS, // This max number of signatures is also the max number of public keys.
            "The number of public keys is greater than {}.",
            MAX_NUM_OF_SIGS
        );

        ensure!(
            public_keys.len() >= signatures_required as usize,
            "The number of public keys is smaller than the number of required signatures, {} < {}",
            public_keys.len(),
            signatures_required
        );

        Ok(Self {
            public_keys,
            signatures_required,
        })
    }
```
