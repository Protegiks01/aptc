# Audit Report

## Title
Consensus Transaction Deduplication Bypass Enables Block Space Griefing via Gas Price Variants

## Summary

The consensus transaction deduplicator allows multiple variants of the same transaction with different gas prices to bypass deduplication and consume block space, despite only one being executable. Failed variants are discarded without gas charge, enabling cost-effective block space griefing attacks.

## Finding Description

The vulnerability exists in the consensus block preparation pipeline where transaction deduplication occurs after aggregating batches from multiple validators.

**Deduplication Mechanism:**

The `TxnHashAndAuthenticatorDeduper` performs two-stage filtering:

**Stage 1**: Identifies possible duplicates by matching `(sender, replay_protector)` pairs. [1](#0-0) 

**Stage 2**: For possible duplicates, calculates `(committed_hash, authenticator)` and filters based on unique pairs. [2](#0-1) 

**Critical Issue:**

The `committed_hash()` method wraps the `SignedTransaction` in `Transaction::UserTransaction` and computes a hash over the entire structure. [3](#0-2) 

Since `RawTransaction` includes the `gas_unit_price` field: [4](#0-3) 

And `Transaction` has `CryptoHasher` and `BCSCryptoHash` derives: [5](#0-4) 

Transactions with identical sender, sequence number, and payload but different gas prices produce different `committed_hash` values, allowing them to bypass Stage 2 deduplication.

**Attack Execution Path:**

1. **Batch Creation**: Each validator runs a `BatchGenerator` that pulls transactions from its local mempool and creates batches.

2. **Batch Certification**: Batches are broadcast and certified by collecting signatures from multiple validators, forming `ProofOfStore` structures.

3. **Block Proposal**: A proposer can include multiple certified batches from different validators in a single block proposal (confirmed by the payload structures that contain multiple batches).

4. **Deduplication Bypass**: During block preparation, transactions from all batches are combined and deduplicated. Variants with different gas prices pass both deduplication stages because they have different `(committed_hash, authenticator)` pairs.

5. **Execution Failure**: During execution, only the first transaction succeeds. Subsequent variants fail with `SEQUENCE_NUMBER_TOO_OLD` status. [6](#0-5) [7](#0-6) 

6. **Zero Gas Charge**: Failed transactions with `SEQUENCE_NUMBER_TOO_OLD` are discarded without charging gas, as confirmed in test code: [8](#0-7) 

**Why Mempool Protection Doesn't Apply:**

While individual mempools have gas price upgrade logic that replaces lower-priced variants: [9](#0-8) 

This protection only applies within a single node's mempool. Once batches are created, certified with `ProofOfStore`, and included in block proposals, the consensus deduplicator is the final defense—and it fails to catch gas price variants.

## Impact Explanation

**Severity: Medium**

This vulnerability enables block space griefing with the following impacts:

1. **Disproportionate Resource Consumption**: An attacker submits N transaction variants (differing only in gas price) to different validators. All N variants consume block space and validator processing resources, but the attacker pays gas for only 1 successful transaction. The remaining N-1 variants fail with `SEQUENCE_NUMBER_TOO_OLD` without gas charges.

2. **Transaction Censorship**: By filling blocks with self-inflicted failing transactions, attackers can prevent legitimate users' transactions from being included, causing delays and service degradation.

3. **Validator Resource Waste**: All validators must process, validate, and attempt to execute all N variants, wasting CPU cycles and I/O operations on transactions that will inevitably fail.

This aligns with **Medium Severity** per Aptos bug bounty criteria: resource exhaustion attacks that degrade network service quality without causing critical fund loss or consensus violations.

## Likelihood Explanation

**Likelihood: High**

The attack is highly feasible because:

1. **Low Barrier to Entry**: Any user can submit transactions to multiple public RPC endpoints without special permissions or stake requirements.

2. **Simple Execution**: Creating variants requires only changing the `gas_unit_price` parameter and re-signing the transaction—minimal technical sophistication needed.

3. **Economic Viability**: The attacker pays full gas for only 1 transaction while consuming N transaction slots in the block. For motivated griefing attackers, this asymmetry makes the attack economically rational.

4. **Network Topology**: Aptos's distributed architecture with geographically dispersed validators and multiple public RPC endpoints facilitates submitting different variants to different nodes before mempool broadcasts fully propagate.

5. **Timing Window**: While mempool broadcasting eventually converges, batch creation occurs continuously. An attacker can exploit the timing window before broadcasts complete, especially given network latencies between geographically distributed validators.

## Recommendation

**Option 1: Normalize Gas Price in Deduplication Hash**

Modify the deduplication logic to exclude `gas_unit_price` from the hash calculation. The deduplicator should use a hash computed over `(sender, sequence_number, payload, max_gas_amount, expiration_timestamp_secs, chain_id)` but exclude `gas_unit_price`. This allows genuine duplicates with different gas prices to be detected while still distinguishing truly different transactions.

**Option 2: Pre-Execution Prologue Check**

Move prologue validation (including sequence number checking) before deduplication. This allows early detection of sequence number conflicts, though it increases computational cost since signature verification would need to occur earlier.

**Option 3: Charge Gas for Prologue Failures**

Modify the transaction execution logic to charge a minimum gas fee for transactions that fail in prologue validation (including `SEQUENCE_NUMBER_TOO_OLD`). This eliminates the economic incentive for the attack since the attacker must pay for all variants.

**Recommended Solution**: Option 1 (normalize gas price in deduplication) is the most efficient fix, as it directly addresses the root cause without increasing computational overhead or changing gas economics.

## Proof of Concept

The vulnerability can be demonstrated with a Rust test that:

1. Creates multiple `SignedTransaction` variants with the same sender, sequence number, and payload but different `gas_unit_price` values
2. Verifies that each variant produces a different `committed_hash()`
3. Passes all variants through the `TxnHashAndAuthenticatorDeduper`
4. Confirms that all variants pass deduplication (are not filtered)
5. Simulates execution showing only one succeeds while others fail with `SEQUENCE_NUMBER_TOO_OLD`

The test would use the existing test infrastructure in `consensus/src/txn_hash_and_authenticator_deduper.rs` test module, demonstrating that transactions differing only in gas price bypass the deduplicator.

## Notes

The deduplication design intentionally uses `(committed_hash, authenticator)` pairs because deduplication occurs before signature verification and prologue checks for performance optimization. However, this design decision combined with the inclusion of `gas_unit_price` in the hash and the zero gas charge for `SEQUENCE_NUMBER_TOO_OLD` failures creates an exploitable vulnerability. The issue is not that the deduplication logic is broken per se, but that the interaction between deduplication, hash computation, and gas charging creates an unintended attack vector.

### Citations

**File:** consensus/src/txn_hash_and_authenticator_deduper.rs (L44-54)
```rust
        for (i, txn) in transactions.iter().enumerate() {
            match seen.get(&(txn.sender(), txn.replay_protector())) {
                None => {
                    seen.insert((txn.sender(), txn.replay_protector()), i);
                },
                Some(first_index) => {
                    is_possible_duplicate = true;
                    possible_duplicates[*first_index] = true;
                    possible_duplicates[i] = true;
                },
            }
```

**File:** consensus/src/txn_hash_and_authenticator_deduper.rs (L63-90)
```rust
        let hash_and_authenticators: Vec<_> = possible_duplicates
            .into_par_iter()
            .zip(&transactions)
            .with_min_len(optimal_min_len(num_txns, 48))
            .map(|(need_hash, txn)| match need_hash {
                true => Some((txn.committed_hash(), txn.authenticator())),
                false => None,
            })
            .collect();

        // TODO: Possibly parallelize. See struct comment.
        let mut seen_hashes = HashSet::new();
        let mut num_duplicates: usize = 0;
        let filtered: Vec<_> = hash_and_authenticators
            .into_iter()
            .zip(transactions)
            .filter_map(|(maybe_hash, txn)| match maybe_hash {
                None => Some(txn),
                Some(hash_and_authenticator) => {
                    if seen_hashes.insert(hash_and_authenticator) {
                        Some(txn)
                    } else {
                        num_duplicates += 1;
                        None
                    }
                },
            })
            .collect();
```

**File:** types/src/transaction/mod.rs (L179-205)
```rust
pub struct RawTransaction {
    /// Sender's address.
    sender: AccountAddress,

    /// Sequence number of this transaction. This must match the sequence number
    /// stored in the sender's account at the time the transaction executes.
    sequence_number: u64,

    /// The transaction payload, e.g., a script to execute.
    payload: TransactionPayload,

    /// Maximal total gas to spend for this transaction.
    max_gas_amount: u64,

    /// Price to be paid per gas unit.
    gas_unit_price: u64,

    /// Expiration timestamp for this transaction, represented
    /// as seconds from the Unix Epoch. If the current blockchain timestamp
    /// is greater than or equal to this time, then the transaction has
    /// expired and will be discarded. This can be set to a large value far
    /// in the future to indicate that a transaction does not expire.
    expiration_timestamp_secs: u64,

    /// Chain ID of the Aptos network this transaction is intended for.
    chain_id: ChainId,
}
```

**File:** types/src/transaction/mod.rs (L1335-1339)
```rust
    pub fn committed_hash(&self) -> HashValue {
        *self
            .committed_hash
            .get_or_init(|| Transaction::UserTransaction(self.clone()).hash())
    }
```

**File:** types/src/transaction/mod.rs (L2945-2951)
```rust
#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize, CryptoHasher, BCSCryptoHash)]
pub enum Transaction {
    /// Transaction submitted by the user. e.g: P2P payment transaction, publishing module
    /// transaction, etc.
    /// TODO: We need to rename SignedTransaction to SignedUserTransaction, as well as all the other
    ///       transaction types we had in our codebase.
    UserTransaction(SignedTransaction),
```

**File:** aptos-move/aptos-vm/src/errors.rs (L20-20)
```rust
pub const ESEQUENCE_NUMBER_TOO_OLD: u64 = 1002;
```

**File:** aptos-move/aptos-vm/src/errors.rs (L128-128)
```rust
                (INVALID_ARGUMENT, ESEQUENCE_NUMBER_TOO_OLD) => StatusCode::SEQUENCE_NUMBER_TOO_OLD,
```

**File:** aptos-move/e2e-tests/src/account_universe/bad_transaction.rs (L52-58)
```rust
                if seq >= sender.sequence_number {
                    TransactionStatus::Discard(StatusCode::SEQUENCE_NUMBER_TOO_NEW)
                } else {
                    TransactionStatus::Discard(StatusCode::SEQUENCE_NUMBER_TOO_OLD)
                },
                0,
            ),
```

**File:** mempool/src/core_mempool/transaction_store.rs (L274-283)
```rust
                } else if current_version.get_gas_price() < txn.get_gas_price() {
                    // Update txn if gas unit price is a larger value than before
                    if let Some(txn) = txns.remove(&txn_replay_protector) {
                        self.index_remove(&txn);
                    };
                    counters::CORE_MEMPOOL_GAS_UPGRADED_TXNS.inc();
                } else if current_version.get_gas_price() > txn.get_gas_price() {
                    return MempoolStatus::new(MempoolStatusCode::InvalidUpdate).with_message(
                        "Transaction already in mempool with a higher gas price".to_string(),
                    );
```
