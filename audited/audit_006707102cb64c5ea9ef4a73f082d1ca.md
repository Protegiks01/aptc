# Audit Report

## Title
Staging Area Pollution Leading to State Inconsistency and Denial of Service in Large Package Publishing

## Summary
The chunked package publishing mechanism in `large_packages.move` does not enforce cleanup of the staging area before starting a new publish operation. When previous `stage_code_chunk` transactions leave residual data in the `StagingArea` resource, subsequent publish operations incorrectly combine old chunks with new chunks, leading to state inconsistencies that prevent successful package publication until manual cleanup is performed.

## Finding Description

The vulnerability exists in the Move smart contract implementation of the large packages framework. The `stage_code_chunk_internal` function reuses existing `StagingArea` resources without validating or clearing previous data. [1](#0-0) 

When a `StagingArea` already exists, the function directly borrows and mutates it, appending new metadata to existing metadata without clearing the previous contents. [2](#0-1) 

For code chunks, the implementation appends new chunks to existing chunks at the same module index rather than replacing them. [3](#0-2) 

Critically, `last_module_idx` only increases and never decreases, meaning residual modules from failed publish attempts persist in the staging area. [4](#0-3) 

When assembling the final package, the `assemble_module_code` function loops from 0 to `last_module_idx`, including all residual modules from previous failed attempts. [5](#0-4) 

**Attack Scenario:**
1. User uploads Package A with modules at indices [0, 1, 2] via multiple `stage_code_chunk` calls
2. The final `stage_code_chunk_and_publish_to_account` transaction fails (e.g., incompatible upgrade, gas limit, or intentional abort)
3. `StagingArea` now contains: `metadata_A`, `code[0]=module_A0`, `code[1]=module_A1`, `code[2]=module_A2`, `last_module_idx=2`
4. User attempts to upload Package B with modules at indices [0, 1] only
5. New chunks append to existing: `code[0]=module_A0+module_B0`, `code[1]=module_A1+module_B1`, `code[2]=module_A2` (unchanged)
6. `metadata_serialized` becomes: `metadata_A + metadata_B` (invalid concatenation)
7. When `assemble_module_code` executes, it collects modules 0, 1, and 2 with corrupted bytecode
8. The publish transaction fails with invalid bytecode/metadata, leaving the staging area further polluted
9. User cannot successfully publish until manually calling `cleanup_staging_area`

This breaks the **State Consistency** invariant - the `StagingArea` resource enters an inconsistent state that prevents legitimate operations without manual intervention.

## Impact Explanation

This vulnerability qualifies as **MEDIUM severity** under the Aptos bug bounty criteria:

- **State inconsistencies requiring intervention**: The polluted `StagingArea` resource prevents subsequent publish operations from succeeding until manual cleanup is performed. [6](#0-5) 

- **Denial of Service**: Users whose chunked publish operations fail partway through (due to gas exhaustion, compatibility errors, or other failures) are blocked from publishing new packages until they discover and execute the cleanup procedure.

- **No direct fund loss**: The corrupted bytecode will fail Move bytecode verification, preventing publication of malformed code, so this does not escalate to critical severity.

While the Aptos CLI provides a warning when detecting non-empty staging areas [7](#0-6) , this protection only exists at the CLI layer and can be bypassed by users accepting the prompt or using the REST API or other SDKs that interact directly with the Move contract.

## Likelihood Explanation

This vulnerability has **HIGH likelihood** of occurrence:

1. **Common trigger conditions**: Any failed chunked publish operation leaves the staging area polluted. Failures can occur due to incompatible module upgrades, immutable package upgrade attempts, gas exhaustion during multi-transaction sequences, or user abandonment of publish operations.

2. **No automatic cleanup on failure**: The `cleanup_staging_area` call only executes after successful completion of publish operations [8](#0-7) , leaving residual data on any transaction failure.

3. **Discovery difficulty**: Users may not be aware of the `cleanup_staging_area` command, especially when using non-CLI tools.

4. **Bypass of CLI warnings**: The CLI warning requires user confirmation to proceed, which users may dismiss, and developers using APIs directly have no such protection.

## Recommendation

The `stage_code_chunk_internal` function should be modified to clear the existing `StagingArea` before starting a new publish operation, or implement explicit versioning to detect incompatible state. Additionally, consider adding a transaction-level check to validate that the staging area is empty or belongs to the current publish session before allowing new chunks to be staged.

## Proof of Concept

A Move test demonstrating this vulnerability would stage code chunks for Package A, cause the publish to fail, then attempt to stage Package B chunks which would append to the existing data and cause the final publish to fail with corrupted bytecode. The test would verify that manual cleanup via `cleanup_staging_area` is required before successful publication can proceed.

---

**Notes:**
- This vulnerability exists in the `aptos-experimental` framework module deployed on mainnet at address `0xa29df848eebfe5d981f708c2a5b06d31af2be53bbd8ddc94c8523f4b903f7adb`
- The issue is a design flaw in the state management logic rather than a missing input validation
- The impact is limited to individual users and does not affect network-wide consensus or other users' operations
- While the CLI provides warnings, the vulnerability exists at the Move contract layer and affects all interaction methods

### Citations

**File:** aptos-move/framework/aptos-experimental/sources/large_packages.move (L80-95)
```text
    public entry fun stage_code_chunk_and_publish_to_account(
        owner: &signer,
        metadata_chunk: vector<u8>,
        code_indices: vector<u16>,
        code_chunks: vector<vector<u8>>
    ) acquires StagingArea {
        let staging_area =
            stage_code_chunk_internal(
                owner,
                metadata_chunk,
                code_indices,
                code_chunks
            );
        publish_to_account(owner, staging_area);
        cleanup_staging_area(owner);
    }
```

**File:** aptos-move/framework/aptos-experimental/sources/large_packages.move (L145-160)
```text
        if (!exists<StagingArea>(owner_address)) {
            move_to(
                owner,
                StagingArea {
                    metadata_serialized: vector[],
                    code: smart_table::new(),
                    last_module_idx: 0
                }
            );
        };

        let staging_area = borrow_global_mut<StagingArea>(owner_address);

        if (!vector::is_empty(&metadata_chunk)) {
            vector::append(&mut staging_area.metadata_serialized, metadata_chunk);
        };
```

**File:** aptos-move/framework/aptos-experimental/sources/large_packages.move (L167-170)
```text
            if (smart_table::contains(&staging_area.code, idx)) {
                vector::append(
                    smart_table::borrow_mut(&mut staging_area.code, idx), inner_code
                );
```

**File:** aptos-move/framework/aptos-experimental/sources/large_packages.move (L173-175)
```text
                if (idx > staging_area.last_module_idx) {
                    staging_area.last_module_idx = idx;
                }
```

**File:** aptos-move/framework/aptos-experimental/sources/large_packages.move (L213-224)
```text
    inline fun assemble_module_code(staging_area: &mut StagingArea): vector<vector<u8>> {
        let last_module_idx = staging_area.last_module_idx;
        let code = vector[];
        let i = 0;
        while (i <= last_module_idx) {
            vector::push_back(
                &mut code,
                *smart_table::borrow(&staging_area.code, i)
            );
            i = i + 1;
        };
        code
```

**File:** aptos-move/framework/aptos-experimental/sources/large_packages.move (L227-231)
```text
    public entry fun cleanup_staging_area(owner: &signer) acquires StagingArea {
        let StagingArea { metadata_serialized: _, code, last_module_idx: _ } =
            move_from<StagingArea>(signer::address_of(owner));
        smart_table::destroy(code);
    }
```

**File:** crates/aptos/src/move_tool/mod.rs (L1704-1713)
```rust
    if !is_staging_area_empty(txn_options, large_packages_module_address).await? {
        let message = format!(
            "The resource {}::large_packages::StagingArea under account {} is not empty.\
        \nThis may cause package publishing to fail if the data is unexpected. \
        \nUse the `aptos move clear-staging-area` command to clean up the `StagingArea` resource under the account.",
            large_packages_module_address, account_address,
        )
            .bold();
        println!("{}", message);
        prompt_yes_with_override("Do you want to proceed?", txn_options.prompt_options)?;
```
