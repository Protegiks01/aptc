# Audit Report

## Title
Time-of-Check-Time-of-Use Race Condition in Indexer Service Router Causes Data Inconsistencies

## Summary
The `DataServiceWrapperWrapper::get_transactions()` routing logic contains a TOCTOU race condition when both live and historical services are enabled. The router calls `live_data_service.get_transactions()` twice - first to peek for data availability, then again to get the actual stream - creating a time window where cache state changes can cause routing failures and data inconsistencies.

## Finding Description

The routing logic implements a problematic double-call pattern when both services are available: [1](#0-0) 

The code creates a stream from the live service, peeks it to check data availability, then **discards that stream and creates a second stream** if the peek succeeds. Between these two calls, the live service's in-memory cache can change state.

The live service uses a rolling window cache with limited capacity: [2](#0-1) 

When the cache reaches capacity, it evicts old transactions: [3](#0-2) 

And when new data arrives beyond the slot limit: [4](#0-3) 

**Attack Scenario:**
1. Attacker identifies cache boundaries via the ping API (which reveals `min_servable_version`)
2. Attacker requests transactions at version V near `start_version` (edge of cache window)
3. First call succeeds, peek returns `Some(Ok(_))`
4. New transactions arrive and cache evicts version V, incrementing `start_version`
5. Second call fails with "Requested data is too old" error
6. Client receives error despite data being momentarily available
7. Historical service fallback doesn't occur because routing decision was already made based on the successful peek

The live service explicitly checks if requested data has been evicted: [5](#0-4) 

And returns an error when data is too old: [6](#0-5) 

**Additional Issue:** The peek operation can block indefinitely if requesting near-future versions, as the live service waits for data: [7](#0-6) 

This prevents fallback to historical service even when historical could serve the data immediately.

## Impact Explanation

This meets **Medium severity** criteria as specified in the security question. The vulnerability causes:

1. **Data Inconsistencies**: Same request produces different results based on timing, violating service reliability guarantees
2. **Service Availability Issues**: Legitimate client requests fail unexpectedly when requesting data at cache boundaries
3. **Unpredictable Behavior**: Routing decisions become non-deterministic under load

While this doesn't affect blockchain consensus or validator operations (the indexer is an off-chain read-only service), it impacts the reliability of the indexer infrastructure that clients depend on for accessing blockchain data. This falls under "State inconsistencies requiring intervention" from a client data consistency perspective.

## Likelihood Explanation

**High likelihood** in production environments:

- The vulnerability triggers naturally under normal load when the cache is actively evicting old transactions
- No sophisticated timing attacks required - normal cache churn is sufficient
- Default cache configuration uses limited size (5M slots, 10GB), making eviction common
- The time window between the two calls is significant enough (involves async operations, network latency) for state changes to occur
- High-throughput blockchains generate constant cache pressure, increasing eviction frequency

## Recommendation

**Fix 1: Eliminate the double-call pattern** by reusing the first stream:

```rust
async fn get_transactions(
    &self,
    req: Request<GetTransactionsRequest>,
) -> Result<Response<Self::GetTransactionsStream>, Status> {
    if let Some(live_data_service) = self.live_data_service.as_ref() {
        if let Some(historical_data_service) = self.historical_data_service.as_ref() {
            let request = req.into_inner();
            let stream = live_data_service
                .get_transactions(Request::new(request.clone()))
                .await?
                .into_inner();
            
            // Peek to check if live service has data
            let mut peekable = std::pin::pin!(stream.peekable());
            match peekable.peek().await {
                Some(Ok(_)) => {
                    // Data available from live service, return this stream
                    return Ok(Response::new(Box::pin(peekable) as Self::GetTransactionsStream));
                }
                _ => {
                    // Fallback to historical service
                    historical_data_service
                        .get_transactions(Request::new(request))
                        .await
                }
            }
        } else {
            live_data_service.get_transactions(req).await
        }
    } else if let Some(historical_data_service) = self.historical_data_service.as_ref() {
        historical_data_service.get_transactions(req).await
    } else {
        unreachable!("Must have at least one of the data services enabled.");
    }
}
```

**Fix 2: Add explicit version-based routing** to decide which service to use upfront based on the request's `starting_version` and known service boundaries, eliminating the need for peek-based routing.

## Proof of Concept

```rust
#[cfg(test)]
mod test {
    use super::*;
    use tokio::time::{sleep, Duration};
    
    #[tokio::test]
    async fn test_toctou_race_condition() {
        // Setup: Create both services with limited cache
        let config = IndexerGrpcDataServiceConfig {
            chain_id: 1,
            live_data_service_config: LiveDataServiceConfig {
                enabled: true,
                num_slots: 100, // Small cache to force eviction
                size_limit_bytes: 1000,
            },
            historical_data_service_config: HistoricalDataServiceConfig {
                enabled: true,
                // ... config
            },
            // ... other config
        };
        
        // Start services and populate cache
        // Fill cache to near capacity with versions 0-99
        
        // Attack: Request version 0 (at edge of cache)
        let request = GetTransactionsRequest {
            starting_version: Some(0),
            transactions_count: Some(10),
            ..Default::default()
        };
        
        // Spawn task that continuously adds new transactions
        // to force cache eviction
        tokio::spawn(async {
            loop {
                // Add new transactions to trigger eviction
                sleep(Duration::from_millis(10)).await;
            }
        });
        
        // First call succeeds (during peek)
        // Second call fails (version 0 evicted between calls)
        let result = wrapper.get_transactions(Request::new(request)).await;
        
        // Assert: Should succeed but may fail due to TOCTOU
        // In fixed version, should always succeed by either:
        // 1. Reusing first stream if live has data
        // 2. Falling back to historical if live fails
    }
}
```

## Notes

This vulnerability is specific to the indexer-grpc data service infrastructure and does not affect blockchain consensus, validator operations, or on-chain security. However, it impacts the reliability and consistency of the indexing infrastructure that external applications depend on for accessing blockchain data. The issue is particularly problematic in high-throughput scenarios where cache churn is frequent.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/service.rs (L47-63)
```rust
        if let Some(live_data_service) = self.live_data_service.as_ref() {
            if let Some(historical_data_service) = self.historical_data_service.as_ref() {
                let request = req.into_inner();
                let mut stream = live_data_service
                    .get_transactions(Request::new(request.clone()))
                    .await?
                    .into_inner();
                let peekable = std::pin::pin!(stream.as_mut().peekable());
                if let Some(Ok(_)) = peekable.peek().await {
                    return live_data_service
                        .get_transactions(Request::new(request.clone()))
                        .await;
                }

                historical_data_service
                    .get_transactions(Request::new(request))
                    .await
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/config.rs (L58-74)
```rust
pub struct LiveDataServiceConfig {
    pub enabled: bool,
    #[serde(default = "LiveDataServiceConfig::default_num_slots")]
    pub num_slots: usize,
    #[serde(default = "LiveDataServiceConfig::default_size_limit_bytes")]
    pub size_limit_bytes: usize,
}

impl LiveDataServiceConfig {
    fn default_num_slots() -> usize {
        5_000_000
    }

    fn default_size_limit_bytes() -> usize {
        10_000_000_000
    }
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/data_manager.rs (L89-93)
```rust
        if end_version > self.end_version {
            self.end_version = end_version;
            if self.start_version + (self.num_slots as u64) < end_version {
                self.start_version = end_version - self.num_slots as u64;
            }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/data_manager.rs (L107-117)
```rust
        if self.total_size >= self.size_limit_bytes {
            while self.total_size >= self.eviction_target {
                if let Some(transaction) =
                    self.data[self.start_version as usize % self.num_slots].take()
                {
                    self.total_size -= transaction.encoded_len();
                    drop(transaction);
                }
                self.start_version += 1;
            }
        }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/in_memory_cache.rs (L69-71)
```rust
            if starting_version < data_manager.start_version {
                return None;
            }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/mod.rs (L179-183)
```rust
            if next_version > known_latest_version {
                info!(stream_id = id, "next_version {next_version} is larger than known_latest_version {known_latest_version}");
                tokio::time::sleep(Duration::from_millis(100)).await;
                continue;
            }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/mod.rs (L225-233)
```rust
            } else {
                let err = Err(Status::not_found("Requested data is too old."));
                info!(stream_id = id, "Client error: {err:?}.");
                let _ = response_sender.send(err).await;
                COUNTER
                    .with_label_values(&["terminate_requested_data_too_old"])
                    .inc();
                break;
            }
```
