# Audit Report

## Title
Public Indexer Models Enable Database Corruption via Unvalidated Direct Construction

## Summary
The indexer's public models module exposes database model structs with public fields and no validation constraints, allowing external code with database access to construct and insert malformed transaction records that bypass all application-level validation, leading to corrupted indexer state and potential API failures.

## Finding Description
The indexer crate exposes its models module as public [1](#0-0) , making all database model structs accessible to external code. The `Transaction` struct, which represents the core transactions table, is defined with all fields as public [2](#0-1) .

While the intended construction path uses the private `from_transaction_info` method that properly validates and converts API transaction data [3](#0-2) , the public fields allow direct struct construction bypassing all validation.

Additionally, the database module exposes public functions for connection pool creation [4](#0-3)  and the schema is publicly accessible [5](#0-4) .

**Attack Vector:**
An attacker with indexer database credentials can write external code that:
1. Imports the public `aptos-indexer` crate
2. Creates a database connection using the public `new_db_pool` function
3. Constructs malformed `Transaction` models directly with invalid values (negative block heights, malformed hashes, invalid transaction types, negative gas/event counts)
4. Inserts these models using Diesel ORM directly, bypassing the private insert functions

The database schema only enforces UNIQUE and NOT NULL constraints [6](#0-5)  but has no CHECK constraints on value ranges, hash formats, or transaction type validity.

## Impact Explanation
This vulnerability falls under **Medium Severity** per the Aptos bug bounty program as it causes "State inconsistencies requiring intervention."

**Specific Impacts:**
1. **Data Integrity Violation**: Corrupted indexer records with semantically invalid data (negative heights/epochs, malformed hashes, invalid types)
2. **API Query Failures**: Applications querying the indexer API receive malformed data causing parsing errors, panics on negative-to-unsigned casts, and type validation failures
3. **Ecosystem Application Disruption**: Wallets, explorers, DEX interfaces, and other applications relying on indexer data malfunction or display incorrect information
4. **Referential Integrity Cascades**: Foreign key relationships propagate corruption to related tables (events, write_set_changes, signatures) [7](#0-6) 

While this does not directly affect on-chain consensus or blockchain state, it corrupts critical off-chain infrastructure that the Aptos ecosystem relies upon for transaction querying and indexing.

## Likelihood Explanation
**Likelihood: Medium**

This vulnerability requires:
- Compromise of indexer database credentials (realistic through configuration leaks, environment variable exposure, or misconfigured access controls)
- Basic Rust programming knowledge to construct and insert models
- No validator access or on-chain privileges required

Database credential compromise is a well-documented attack vector in modern infrastructure. Indexer databases are often separate services with distinct credentials from validator infrastructure, and multiple applications may legitimately connect to the same indexer database, increasing the attack surface.

## Recommendation
Implement comprehensive validation at the type level using Rust's type system and validation at the database schema level:

**1. Make model struct fields private and add validation constructors:**
```rust
pub struct Transaction {
    version: i64,
    block_height: i64,
    hash: String,
    // ... other private fields
}

impl Transaction {
    pub fn new_validated(
        version: i64,
        block_height: i64,
        hash: String,
        type_: String,
        // ... other fields
    ) -> Result<Self, ValidationError> {
        // Validate version >= 0
        if version < 0 {
            return Err(ValidationError::NegativeVersion);
        }
        // Validate block_height >= 0
        if block_height < 0 {
            return Err(ValidationError::NegativeBlockHeight);
        }
        // Validate hash format (0x-prefixed, 66 chars)
        if !hash.starts_with("0x") || hash.len() != 66 {
            return Err(ValidationError::InvalidHash);
        }
        // Validate transaction type
        if !["genesis_transaction", "block_metadata_transaction", 
             "user_transaction", "state_checkpoint_transaction"].contains(&type_.as_str()) {
            return Err(ValidationError::InvalidType);
        }
        // Additional validation for other fields
        Ok(Self { version, block_height, hash, type_, /* ... */ })
    }
}
```

**2. Add database CHECK constraints:**
```sql
ALTER TABLE transactions ADD CONSTRAINT check_version_positive CHECK (version >= 0);
ALTER TABLE transactions ADD CONSTRAINT check_block_height_positive CHECK (block_height >= 0);
ALTER TABLE transactions ADD CONSTRAINT check_hash_format CHECK (hash ~ '^0x[0-9a-fA-F]{64}$');
ALTER TABLE transactions ADD CONSTRAINT check_valid_type CHECK (type IN ('genesis_transaction', 'block_metadata_transaction', 'user_transaction', 'state_checkpoint_transaction', 'block_epilogue_transaction', 'validator_transaction'));
ALTER TABLE transactions ADD CONSTRAINT check_num_events_non_negative CHECK (num_events >= 0);
ALTER TABLE transactions ADD CONSTRAINT check_num_write_set_changes_non_negative CHECK (num_write_set_changes >= 0);
ALTER TABLE transactions ADD CONSTRAINT check_epoch_non_negative CHECK (epoch >= 0);
```

**3. Make the database module pub(crate) or add access control:**
Restrict direct database access to internal indexer components only.

## Proof of Concept
```rust
// External malicious application
use aptos_indexer::database::new_db_pool;
use aptos_indexer::models::transactions::Transaction;
use aptos_indexer::schema;
use bigdecimal::BigDecimal;
use diesel::prelude::*;

fn exploit_indexer() -> Result<(), Box<dyn std::error::Error>> {
    // Attacker obtains database credentials
    let database_url = "postgresql://user:password@host:5432/indexer_db";
    let pool = new_db_pool(database_url)?;
    let mut conn = pool.get()?;
    
    // Construct malformed transaction bypassing all validation
    let malformed_txn = Transaction {
        version: 999999,  // Arbitrary version not in blockchain
        block_height: -1,  // INVALID: negative block height
        hash: "not_a_valid_hash".to_string(),  // INVALID: not 0x-prefixed hex
        type_: "malicious_type".to_string(),  // INVALID: not a valid transaction type
        payload: Some(serde_json::json!({"exploit": "data"})),
        state_change_hash: "x".to_string(),  // INVALID: malformed hash
        event_root_hash: "x".to_string(),
        state_checkpoint_hash: None,
        gas_used: BigDecimal::from(-100),  // INVALID: negative gas
        success: true,
        vm_status: "fake_status".to_string(),
        accumulator_root_hash: "y".to_string(),
        num_events: -10,  // INVALID: negative count
        num_write_set_changes: -5,  // INVALID: negative count
        epoch: -1,  // INVALID: negative epoch
    };
    
    // Insert directly using Diesel, bypassing all application validation
    diesel::insert_into(schema::transactions::table)
        .values(&malformed_txn)
        .execute(&mut conn)?;
    
    println!("Successfully inserted malformed transaction into indexer database");
    println!("Indexer state is now corrupted with invalid data");
    
    Ok(())
}
```

**Expected Result:** The malformed transaction is successfully inserted into the database, corrupting the indexer state. Subsequent API queries for this version will return semantically invalid data causing downstream application failures.

---

## Notes
This vulnerability specifically affects the off-chain indexer infrastructure, not the blockchain consensus or on-chain state. However, the indexer is critical infrastructure for the Aptos ecosystem, and its corruption can cascade to all applications and services that rely on it for querying transaction history and blockchain state. The severity is correctly classified as Medium because it requires database credential compromise rather than network-level access, but the impact on ecosystem applications can be significant.

### Citations

**File:** crates/indexer/src/lib.rs (L17-17)
```rust
pub mod models;
```

**File:** crates/indexer/src/lib.rs (L20-20)
```rust
pub mod schema;
```

**File:** crates/indexer/src/models/transactions.rs (L31-50)
```rust
#[derive(Debug, Deserialize, FieldCount, Identifiable, Insertable, Serialize)]
#[diesel(primary_key(version))]
#[diesel(table_name = transactions)]
pub struct Transaction {
    pub version: i64,
    pub block_height: i64,
    pub hash: String,
    pub type_: String,
    pub payload: Option<serde_json::Value>,
    pub state_change_hash: String,
    pub event_root_hash: String,
    pub state_checkpoint_hash: Option<String>,
    pub gas_used: BigDecimal,
    pub success: bool,
    pub vm_status: String,
    pub accumulator_root_hash: String,
    pub num_events: i64,
    pub num_write_set_changes: i64,
    pub epoch: i64,
}
```

**File:** crates/indexer/src/models/transactions.rs (L76-101)
```rust
    fn from_transaction_info(
        info: &TransactionInfo,
        payload: Option<serde_json::Value>,
        type_: String,
        num_events: i64,
        block_height: i64,
        epoch: i64,
    ) -> Self {
        Self {
            type_,
            payload,
            version: info.version.0 as i64,
            block_height,
            hash: info.hash.to_string(),
            state_change_hash: info.state_change_hash.to_string(),
            event_root_hash: info.event_root_hash.to_string(),
            state_checkpoint_hash: info.state_checkpoint_hash.map(|h| h.to_string()),
            gas_used: u64_to_bigdecimal(info.gas_used.0),
            success: info.success,
            vm_status: info.vm_status.clone(),
            accumulator_root_hash: info.accumulator_root_hash.to_string(),
            num_events,
            num_write_set_changes: info.changes.len() as i64,
            epoch,
        }
    }
```

**File:** crates/indexer/src/database.rs (L59-62)
```rust
pub fn new_db_pool(database_url: &str) -> Result<PgDbPool, PoolError> {
    let manager = ConnectionManager::<PgConnection>::new(database_url);
    PgPool::builder().build(manager).map(Arc::new)
}
```

**File:** crates/indexer/migrations/2022-08-08-043603_core_tables/up.sql (L32-49)
```sql
CREATE TABLE transactions (
  version BIGINT UNIQUE PRIMARY KEY NOT NULL,
  block_height BIGINT NOT NULL,
  hash VARCHAR(66) UNIQUE NOT NULL,
  type VARCHAR(50) NOT NULL,
  payload jsonb,
  state_change_hash VARCHAR(66) NOT NULL,
  event_root_hash VARCHAR(66) NOT NULL,
  state_checkpoint_hash VARCHAR(66),
  gas_used NUMERIC NOT NULL,
  success BOOLEAN NOT NULL,
  vm_status TEXT NOT NULL,
  accumulator_root_hash VARCHAR(66) NOT NULL,
  num_events BIGINT NOT NULL,
  num_write_set_changes BIGINT NOT NULL,
  -- Default time columns
  inserted_at TIMESTAMP NOT NULL DEFAULT NOW()
);
```

**File:** crates/indexer/migrations/2022-08-08-043603_core_tables/up.sql (L223-223)
```sql
  CONSTRAINT fk_transaction_versions FOREIGN KEY (transaction_version) REFERENCES transactions (version)
```
