# Audit Report

## Title
Transitive Dependency Verification Bypass in Lazy Loading Mode Allows Publishing of Incompatible Module Bundles

## Summary
When lazy loading is enabled (the default configuration), the module publishing verification in `create_with_compat_config()` fails to verify transitive dependencies during bundle publishing. An attacker can publish a bundle of modules where second-level dependencies bypass linking verification, potentially causing consensus violations and Move VM safety failures.

## Finding Description

The vulnerability exists in the module bundle verification logic when lazy loading is enabled. The critical flow occurs in two locations: [1](#0-0) 

When verifying a staged module with lazy loading enabled, the code fetches immediate dependencies using `unmetered_get_existing_lazily_verified_module`. However, this function has a critical flaw: [2](#0-1) 

The function calls `build_verified_module_skip_linking_checks` at line 321, which explicitly skips dependency verification: [3](#0-2) 

This function does NOT call `dependencies::verify_module`, meaning all linking validation is bypassed:
- Function signature compatibility checks
- Struct ability compatibility checks  
- Type parameter constraint validation
- Module existence verification

**Attack Scenario:**

1. Attacker crafts three modules: `0x1::aaa_module`, `0x1::bbb_module`, `0x1::ccc_module`
2. Module relationships: `aaa_module` → `bbb_module` → `ccc_module`
3. `ccc_module` exports a struct `S` with Copy ability
4. `bbb_module` uses `S` but declares it without Copy ability (incompatible)
5. Attacker publishes all three in one bundle

**Exploitation Flow:**

The staged modules are verified in BTreeMap iteration order (lexicographic): [4](#0-3) 

Since `aaa_module` < `bbb_module` < `ccc_module` alphabetically:

1. **Verifying `aaa_module`** (first in order):
   - Fetches dependency `bbb_module` via `unmetered_get_existing_lazily_verified_module`
   - `bbb_module` is not yet verified (hasn't been processed in the loop)
   - Calls `build_verified_module_skip_linking_checks` for `bbb_module`
   - **`bbb_module`'s dependency on `ccc_module` is never verified!**
   - The incompatibility between how `bbb_module` uses `ccc_module::S` is never detected

2. `aaa_module` is marked verified with linking checks only against the improperly verified `bbb_module`

3. When `bbb_module` and `ccc_module` are processed later in the loop, they're already cached as "verified"

**Contrast with Eager Loading:**

The eager loading path uses a recursive verification approach: [5](#0-4) 

The recursive call at lines 401-408 ensures all transitive dependencies are properly verified with linking checks. Lazy loading lacks this recursive verification.

## Impact Explanation

**Severity: Critical**

This vulnerability breaks multiple critical invariants:

1. **Deterministic Execution Violation**: Different validators may interpret the malicious bytecode differently, leading to state divergence and consensus failures. If validators have different cached states or process transactions in different orders, they may verify modules differently.

2. **Move VM Safety Violation**: Type safety guarantees can be broken. For example:
   - A struct declared without `copy` in module B but with `copy` in module C
   - Type parameter constraints mismatches
   - Function signature incompatibilities
   - These can lead to VM crashes, undefined behavior, or memory safety violations

3. **Consensus Safety**: If validators execute the malicious modules differently, they will compute different state roots for the same block, causing a consensus split that cannot be resolved without manual intervention or a hard fork.

This meets the **Critical Severity** criteria:
- ✓ Consensus/Safety violations
- ✓ Non-recoverable network partition (requires hardfork if exploited)
- ✓ Move VM safety violations leading to potential undefined behavior

## Likelihood Explanation

**Likelihood: High**

The vulnerability is highly likely to be exploitable because:

1. **Lazy loading is enabled by default**: [6](#0-5) 

2. **No special privileges required**: Any user can publish Move modules and submit bundles

3. **Deterministic exploitation**: Attacker controls module names, thus controlling verification order through BTreeMap lexicographic ordering

4. **Wide attack surface**: Any bundle with transitive dependencies (A→B→C) where A is alphabetically before B is vulnerable

5. **No monitoring or detection**: The verification passes successfully, giving no indication of the bypass

The only requirement is understanding the verification order and crafting modules with appropriate names.

## Recommendation

**Primary Fix:** Ensure transitive dependencies are always verified with linking checks, even in lazy loading mode.

Modify `publishing.rs` to recursively verify dependencies during bundle publishing:

```rust
// In publishing.rs, create_with_compat_config(), around line 261-271
// Instead of directly calling unmetered_get_existing_lazily_verified_module,
// ensure full verification:

for (dep_addr, dep_name) in locally_verified_code.immediate_dependencies_iter() {
    let dep_id = ModuleId::new(*dep_addr, dep_name.to_owned());
    
    // CRITICAL: Use eager verification for dependencies during publishing
    // to ensure transitive dependencies are checked
    let dependency = staged_module_storage
        .unmetered_get_eagerly_verified_module(dep_addr, dep_name)?
        .ok_or_else(|| module_linker_error!(dep_addr, dep_name))?;
    
    verified_dependencies.push(dependency);
}
```

**Alternative Fix:** Modify `unmetered_get_lazily_verified_module` to detect when it's being called during publishing and force linking checks:

```rust
// In module_storage.rs, add a parameter to control verification depth
fn unmetered_get_lazily_verified_module(
    &self,
    module_id: &ModuleId,
    force_linking_checks: bool,  // New parameter
) -> VMResult<Option<Arc<Module>>> {
    // ... existing code ...
    
    if force_linking_checks {
        // Recursively verify dependencies similar to eager mode
        // Use visit_dependencies_and_verify logic
    } else {
        // Existing skip_linking_checks path
    }
}
```

**Defense in Depth:** Add verification ordering independence check that re-verifies all modules in a bundle after staging to catch any verification bypasses.

## Proof of Concept

```move
// File: aaa_module.move
module 0x1::aaa_module {
    use 0x1::bbb_module;
    
    public fun use_b() {
        bbb_module::get_value();
    }
}

// File: bbb_module.move  
module 0x1::bbb_module {
    use 0x1::ccc_module;
    
    // Declares struct S without Copy ability
    struct S has drop { value: u64 }
    
    public fun get_value(): u64 {
        // Incorrectly assumes ccc_module::get_struct() returns 
        // a copyable struct, but S is declared without Copy here
        let s = ccc_module::get_struct();
        let s_copy = s; // This would fail if S doesn't have Copy
        s.value + s_copy.value // Type confusion
    }
}

// File: ccc_module.move
module 0x1::ccc_module {
    // Declares struct S WITH Copy ability
    struct S has copy, drop { value: u64 }
    
    public fun get_struct(): S {
        S { value: 42 }
    }
}
```

**Exploitation Steps:**

1. Compile all three modules
2. Submit them in a single transaction as a bundle: `[aaa_module, bbb_module, ccc_module]`
3. With lazy loading enabled, verification proceeds:
   - `aaa_module` is verified first (alphabetically first)
   - Fetches `bbb_module` as dependency
   - `bbb_module` verified with `skip_linking_checks`
   - **`bbb_module`'s incompatible usage of `ccc_module::S` is never checked**
4. Bundle is accepted despite type inconsistency
5. Execution of `aaa_module::use_b()` causes undefined behavior or consensus split

**Rust Test Reproduction:**

```rust
#[test]
fn test_transitive_dependency_bypass() {
    let mut harness = MoveHarness::new_with_features(
        vec![FeatureFlag::EnableLazyLoading], 
        vec![]
    );
    
    // Create three modules with dependency chain
    let aaa_module = compile_module("aaa_module.move");
    let bbb_module = compile_module("bbb_module.move"); 
    let ccc_module = compile_module("ccc_module.move");
    
    // Publish as bundle - verification should fail but doesn't
    let result = harness.publish_module_bundle(
        &account,
        vec![aaa_module, bbb_module, ccc_module]
    );
    
    // This should fail but succeeds due to vulnerability
    assert!(result.is_ok()); // Vulnerability: accepts invalid bundle
    
    // Executing the module causes undefined behavior
    let exec_result = harness.run_entry_function(
        &account,
        "aaa_module",
        "use_b",
        vec![],
        vec![]
    );
    
    // Different validators may produce different results here
    // leading to consensus split
}
```

## Notes

The vulnerability is particularly dangerous because:

1. **Silent failure**: The verification passes successfully with no errors or warnings
2. **Deterministic exploitation**: Attacker has full control over exploitation via module naming
3. **Default configuration vulnerable**: Lazy loading is enabled by default in production
4. **Consensus impact**: Different validators may execute malicious code differently, causing permanent chain splits

The fix must ensure that either:
- Transitive dependencies are always fully verified during publishing (regardless of lazy loading), OR
- Module verification order is made independent through explicit dependency resolution before verification

### Citations

**File:** third_party/move/move-vm/runtime/src/storage/publishing.rs (L234-243)
```rust
        for (addr, name, bytes, compiled_module) in staged_module_storage
            .storage
            .byte_storage()
            .staged_modules
            .iter()
            .flat_map(|(addr, account_storage)| {
                account_storage
                    .iter()
                    .map(move |(name, (bytes, module))| (addr, name, bytes, module))
            })
```

**File:** third_party/move/move-vm/runtime/src/storage/publishing.rs (L245-275)
```rust
            if is_lazy_loading_enabled {
                // Local bytecode verification.
                staged_runtime_environment.paranoid_check_module_address_and_name(
                    compiled_module,
                    compiled_module.self_addr(),
                    compiled_module.self_name(),
                )?;
                let locally_verified_code = staged_runtime_environment
                    .build_locally_verified_module(
                        compiled_module.clone(),
                        bytes.len(),
                        &sha3_256(bytes),
                    )?;

                // Linking checks to immediate dependencies. Note that we do not check cyclic
                // dependencies here.
                let mut verified_dependencies = vec![];
                for (dep_addr, dep_name) in locally_verified_code.immediate_dependencies_iter() {
                    // INVARIANT:
                    //   Immediate dependency of the module in a bundle must be metered at the
                    //   caller side.
                    let dependency =
                        staged_module_storage.unmetered_get_existing_lazily_verified_module(
                            &ModuleId::new(*dep_addr, dep_name.to_owned()),
                        )?;
                    verified_dependencies.push(dependency);
                }
                staged_runtime_environment.build_verified_module_with_linking_checks(
                    locally_verified_code,
                    &verified_dependencies,
                )?;
```

**File:** third_party/move/move-vm/runtime/src/storage/module_storage.rs (L295-329)
```rust
    fn unmetered_get_lazily_verified_module(
        &self,
        module_id: &ModuleId,
    ) -> VMResult<Option<Arc<Module>>> {
        let (module, version) = match self.get_module_or_build_with(module_id, self)? {
            Some(module_and_version) => module_and_version,
            None => return Ok(None),
        };

        if module.code().is_verified() {
            return Ok(Some(module.code().verified().clone()));
        }

        let _timer = VM_TIMER.timer_with_label("unmetered_get_lazily_verified_module [cache miss]");
        let runtime_environment = self.runtime_environment();
        runtime_environment.paranoid_check_module_address_and_name(
            module.code().deserialized(),
            module_id.address(),
            module_id.name(),
        )?;
        let locally_verified_code = runtime_environment.build_locally_verified_module(
            module.code().deserialized().clone(),
            module.extension().size_in_bytes(),
            module.extension().hash(),
        )?;
        let verified_code =
            runtime_environment.build_verified_module_skip_linking_checks(locally_verified_code)?;
        let verified_module = self.insert_verified_module(
            module_id.clone(),
            verified_code,
            module.extension().clone(),
            version,
        )?;
        Ok(Some(verified_module.code().verified().clone()))
    }
```

**File:** third_party/move/move-vm/runtime/src/storage/module_storage.rs (L345-427)
```rust
fn visit_dependencies_and_verify<T, E, V>(
    module_id: ModuleId,
    module: Arc<ModuleCode<CompiledModule, Module, E>>,
    version: V,
    visited: &mut HashSet<ModuleId>,
    module_cache_with_context: &T,
) -> VMResult<Arc<Module>>
where
    T: WithRuntimeEnvironment
        + ModuleCache<
            Key = ModuleId,
            Deserialized = CompiledModule,
            Verified = Module,
            Extension = E,
            Version = V,
        > + ModuleCodeBuilder<
            Key = ModuleId,
            Deserialized = CompiledModule,
            Verified = Module,
            Extension = E,
        >,
    E: WithBytes + WithSize + WithHash,
    V: Clone + Default + Ord,
{
    let runtime_environment = module_cache_with_context.runtime_environment();

    // Step 1: Local verification.
    runtime_environment.paranoid_check_module_address_and_name(
        module.code().deserialized(),
        module_id.address(),
        module_id.name(),
    )?;
    let locally_verified_code = runtime_environment.build_locally_verified_module(
        module.code().deserialized().clone(),
        module.extension().size_in_bytes(),
        module.extension().hash(),
    )?;

    // Step 2: Traverse and collect all verified immediate dependencies so that we can verify
    // non-local properties of the module.
    let mut verified_dependencies = vec![];
    for (addr, name) in locally_verified_code.immediate_dependencies_iter() {
        let dependency_id = ModuleId::new(*addr, name.to_owned());

        let (dependency, dependency_version) = module_cache_with_context
            .get_module_or_build_with(&dependency_id, module_cache_with_context)?
            .ok_or_else(|| module_linker_error!(addr, name))?;

        // Dependency is already verified!
        if dependency.code().is_verified() {
            verified_dependencies.push(dependency.code().verified().clone());
            continue;
        }

        if visited.insert(dependency_id.clone()) {
            // Dependency is not verified, and we have not visited it yet.
            let verified_dependency = visit_dependencies_and_verify(
                dependency_id.clone(),
                dependency,
                dependency_version,
                visited,
                module_cache_with_context,
            )?;
            verified_dependencies.push(verified_dependency);
        } else {
            // We must have found a cycle otherwise.
            return Err(module_cyclic_dependency_error!(
                dependency_id.address(),
                dependency_id.name()
            ));
        }
    }

    let verified_code = runtime_environment
        .build_verified_module_with_linking_checks(locally_verified_code, &verified_dependencies)?;
    let module = module_cache_with_context.insert_verified_module(
        module_id,
        verified_code,
        module.extension().clone(),
        version,
    )?;
    Ok(module.code().verified().clone())
}
```

**File:** third_party/move/move-vm/runtime/src/storage/environment.rs (L230-245)
```rust
    /// Creates a verified module for a locally verified module. Does not perform linking checks
    /// for module's verified dependencies.
    pub(crate) fn build_verified_module_skip_linking_checks(
        &self,
        locally_verified_module: LocallyVerifiedModule,
    ) -> VMResult<Module> {
        Module::new(
            &self.natives,
            locally_verified_module.1,
            locally_verified_module.0,
            self.struct_name_index_map(),
            self.ty_pool(),
            self.module_id_pool(),
        )
        .map_err(|err| err.finish(Location::Undefined))
    }
```

**File:** third_party/move/move-vm/runtime/src/config.rs (L77-77)
```rust
            enable_lazy_loading: true,
```
