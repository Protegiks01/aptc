# Audit Report

## Title
Consensus-Breaking Configuration Variance: Uncoordinated max_loop_depth Changes Can Cause Chain Splits During Software Upgrades

## Summary
The Move bytecode verifier's `max_loop_depth` parameter is hardcoded in source code rather than governed by on-chain consensus mechanisms. During software upgrades, if a new version changes this value, validators running mixed versions will produce divergent verification results for the same bytecode, causing non-deterministic transaction outcomes and chain splits.

## Finding Description

The vulnerability exists in the bytecode verification layer that runs during Move module publishing. When a transaction publishes a module, all validators must execute the same verification logic and reach identical outcomes to maintain consensus.

The `max_loop_depth` parameter controls loop nesting limits during verification: [1](#0-0) 

This check is invoked during module verification: [2](#0-1) 

The critical issue is that `max_loop_depth` is hardcoded at compile-time in the production configuration: [3](#0-2) 

Unlike other verification parameters (such as `max_type_nodes`, `max_function_return_values`, and `max_type_depth` which are conditional on feature flags), `max_loop_depth` has no on-chain governance mechanism: [4](#0-3) [5](#0-4) 

Bytecode verification occurs during transaction execution, specifically during module loading: [6](#0-5) 

Module publishing is part of transaction execution flow: [7](#0-6) 

**Attack Scenario:**

1. Aptos releases version 2.0 that changes `max_loop_depth` from `Some(5)` to `Some(7)` (or any different value)
2. Validators upgrade gradually—standard practice to maintain liveness
3. At block height N, 60% of validators run version 2.0, 40% run version 1.0
4. An attacker (or even innocently) submits a transaction publishing a module with loop depth = 6
5. Validators running version 2.0 (max_loop_depth=7): Verification passes, module published successfully, transaction status = Success
6. Validators running version 1.0 (max_loop_depth=5): Verification fails with `LOOP_MAX_DEPTH_REACHED`, transaction status = Failed
7. Different transaction outcomes produce different state roots
8. **Chain split occurs**—validators cannot agree on state

This breaks the fundamental invariant: "All validators must produce identical state roots for identical blocks."

## Impact Explanation

**Severity: CRITICAL** (Consensus/Safety violation, Non-recoverable network partition)

This vulnerability directly violates Aptos's core consensus safety guarantee. When validators produce different state roots for the same block, the blockchain cannot reach agreement. This results in:

1. **Permanent Chain Split**: Validators partition into incompatible groups based on their software version
2. **Loss of Consensus**: AptosBFT cannot make progress as validators disagree on block validity
3. **Network Partition**: Requires hard fork and manual intervention to resolve
4. **Fund Freezing**: Users cannot transact during the split period

The impact meets the Critical severity criteria from the bug bounty program:
- "Consensus/Safety violations" ✓
- "Non-recoverable network partition (requires hardfork)" ✓

Unlike transient issues or single-node failures, consensus-level determinism violations affect the entire network and cannot self-heal.

## Likelihood Explanation

**Likelihood: MEDIUM to HIGH** during software upgrade windows

The vulnerability is triggered when:
1. A software update changes the hardcoded `max_loop_depth` value (developer decision)
2. Validators are in mixed-version state (guaranteed during upgrades—validators upgrade gradually to maintain availability)
3. A module with edge-case loop depth is published (attacker-controlled or accidental)

Factors increasing likelihood:
- Aptos has regular software upgrades (documented upgrade process exists)
- Validators upgrade asynchronously to maintain network liveness
- No safeguards prevent `max_loop_depth` changes (it's not documented as immutable)
- Attacker only needs to craft bytecode with specific loop depth—no validator compromise required

Factors decreasing likelihood:
- Requires developers to change `max_loop_depth` in a release
- Currently set to `Some(5)` and may be considered stable
- Compatibility testing may catch divergence (but no specific test validates verifier config consistency)

The vulnerability is **latent** but becomes **active** if any future release changes this parameter. Given Aptos's rapid development and the lack of explicit immutability guarantees, this is a real operational risk.

## Recommendation

**Primary Fix**: Gate `max_loop_depth` behind an on-chain feature flag or gas feature version, ensuring all validators use the same value based on on-chain state rather than compiled code version.

**Implementation**:

```rust
pub fn aptos_prod_verifier_config(gas_feature_version: u64, features: &Features) -> VerifierConfig {
    let sig_checker_v2_fix_script_ty_param_count =
        features.is_enabled(FeatureFlag::SIGNATURE_CHECKER_V2_SCRIPT_FIX);
    let sig_checker_v2_fix_function_signatures = gas_feature_version >= RELEASE_V1_34;
    let enable_enum_types = features.is_enabled(FeatureFlag::ENABLE_ENUM_TYPES);
    let enable_resource_access_control =
        features.is_enabled(FeatureFlag::ENABLE_RESOURCE_ACCESS_CONTROL);
    let enable_function_values = features.is_enabled(FeatureFlag::ENABLE_FUNCTION_VALUES);
    
    // NEW: Gate max_loop_depth behind a feature flag or gas version
    let max_loop_depth = if features.is_enabled(FeatureFlag::INCREASED_LOOP_DEPTH) {
        Some(7)  // New value after feature activation
    } else {
        Some(5)  // Legacy value
    };

    VerifierConfig {
        scope: VerificationScope::Everything,
        max_loop_depth,  // Now governed by on-chain config
        // ... rest of config
    }
}
```

**Alternative Approach**: Add `max_loop_depth` to the on-chain `ExecutionConfig` resource, fetched from state during environment initialization, similar to how gas parameters are managed.

**Additional Safeguards**:
1. Add explicit documentation that `max_loop_depth` must never change without feature flag gating
2. Add compatibility tests that verify all validators produce identical verification results for edge-case bytecode
3. Include verifier config hash in block metadata to detect configuration divergence early

## Proof of Concept

**Reproduction Steps** (requires forge/testnet environment):

1. **Setup**: Deploy two validators running different code versions with different `max_loop_depth` values

2. **Craft malicious module** with loop depth between the two limits:
```move
module 0xCAFE::exploit {
    fun deeply_nested() {
        loop {  // Depth 1
            loop {  // Depth 2
                loop {  // Depth 3
                    loop {  // Depth 4
                        loop {  // Depth 5
                            loop {  // Depth 6 - exceeds old limit, within new limit
                                break
                            };
                            break
                        };
                        break
                    };
                    break
                };
                break
            };
            break
        }
    }
}
```

3. **Submit transaction**: Publish module via transaction to both validators

4. **Observe divergence**:
   - Validator A (max_loop_depth=5): Transaction fails with `LOOP_MAX_DEPTH_REACHED`
   - Validator B (max_loop_depth=7): Transaction succeeds, module published
   - State roots diverge
   - Chain split occurs

**Expected Result**: Validators cannot reach consensus, network partitions

**Validation**: Check block commits—validators will propose different blocks with different state roots, AptosBFT cannot achieve 2f+1 agreement.

---

**Notes**

This vulnerability represents a critical design oversight where a consensus-critical parameter lacks on-chain governance. While currently dormant (all validators run identical code), it becomes exploitable during any software upgrade that modifies `max_loop_depth`. The fix is straightforward: apply the same feature-flag gating pattern already used for other verifier parameters (`max_type_nodes`, `max_function_return_values`, `max_type_depth`).

### Citations

**File:** third_party/move/move-bytecode-verifier/src/control_flow_v5.rs (L19-36)
```rust
pub fn verify(
    verifier_config: &VerifierConfig,
    current_function_opt: Option<FunctionDefinitionIndex>,
    code: &CodeUnit,
) -> PartialVMResult<()> {
    let current_function = current_function_opt.unwrap_or(FunctionDefinitionIndex(0));

    // check fallthrough
    verify_fallthrough(current_function, &code.code)?;

    // check jumps
    let context = &ControlFlowVerifier {
        current_function,
        code: &code.code,
    };
    let labels = instruction_labels(context);
    check_jumps(verifier_config, context, labels)
}
```

**File:** third_party/move/move-bytecode-verifier/src/control_flow_v5.rs (L244-260)
```rust
fn check_loop_depth(
    verifier_config: &VerifierConfig,
    context: &ControlFlowVerifier,
    labels: &[Label],
    loop_depth: &[usize],
) -> PartialVMResult<()> {
    let max_depth = match verifier_config.max_loop_depth {
        Some(depth) => depth,
        None => return Ok(()),
    };
    check_code(context, labels, |_loop_stack, i, _instr| {
        if loop_depth[i as usize] > max_depth {
            return Err(context.error(StatusCode::LOOP_MAX_DEPTH_REACHED, i));
        }
        Ok(())
    })
}
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L155-157)
```rust
    VerifierConfig {
        scope: VerificationScope::Everything,
        max_loop_depth: Some(5),
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L162-166)
```rust
        max_type_nodes: if enable_function_values {
            Some(128)
        } else {
            Some(256)
        },
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L183-192)
```rust
        max_function_return_values: if enable_function_values {
            Some(128)
        } else {
            None
        },
        max_type_depth: if enable_function_values {
            Some(20)
        } else {
            None
        },
```

**File:** third_party/move/move-vm/runtime/src/storage/environment.rs (L178-201)
```rust
    pub fn build_locally_verified_module(
        &self,
        compiled_module: Arc<CompiledModule>,
        module_size: usize,
        module_hash: &[u8; 32],
    ) -> VMResult<LocallyVerifiedModule> {
        if !VERIFIED_MODULES_CACHE.contains(module_hash) {
            let _timer =
                VM_TIMER.timer_with_label("move_bytecode_verifier::verify_module_with_config");

            // For regular execution, we cache already verified modules. Note that this even caches
            // verification for the published modules. This should be ok because as long as the
            // hash is the same, the deployed bytecode and any dependencies are the same, and so
            // the cached verification result can be used.
            move_bytecode_verifier::verify_module_with_config(
                &self.vm_config().verifier_config,
                compiled_module.as_ref(),
            )?;
            check_natives(compiled_module.as_ref())?;
            VERIFIED_MODULES_CACHE.put(*module_hash);
        }

        Ok(LocallyVerifiedModule(compiled_module, module_size))
    }
```

**File:** aptos-move/aptos-vm/README.md (L11-16)
```markdown
2. **Execution:**
   Runs the code specified by the transaction - can be a script or an entry function.
   If transaction payload is a script, it is verified with Move bytecode verifier prior to execution.
   If the payload is an entry function, it is loaded from the code cache (which guarantees that loaded code is verified).
   When the code is verified and loaded, transaction arguments are checked and then the payload is executed via MoveVM that AptosVM wraps. 
   If execution is successful, a change set that can be (but is not yet) applied to the blockchain state is produced.
```
