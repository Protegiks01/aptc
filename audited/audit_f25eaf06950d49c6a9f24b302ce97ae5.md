# Audit Report

## Title
Vault Authentication Token Disclosure via Debug Formatting in Inspection Service Configuration Endpoint

## Summary
The `handle_configuration_request()` function exposes vault authentication tokens through insecure Debug formatting when the configuration endpoint is enabled. The `Token` enum uses standard Debug derivation without sanitization, leaking plaintext vault credentials that provide access to consensus private keys and network authentication secrets.

## Finding Description

The inspection service configuration endpoint at [1](#0-0)  uses `format!("{:?}", node_config)` to serialize the entire node configuration. While the code comments explicitly state that "all secret keys are marked with SilentDisplay and SilentDebug" [2](#0-1) , this protection does not extend to vault authentication tokens.

The vulnerability chain is as follows:

1. `NodeConfig` contains a `consensus` field of type `ConsensusConfig` [3](#0-2) 

2. `ConsensusConfig` contains a `safety_rules` field of type `SafetyRulesConfig` [4](#0-3) 

3. `SafetyRulesConfig` contains a `backend` field of type `SecureBackend` [5](#0-4) 

4. `SecureBackend` has a `Vault(VaultConfig)` variant [6](#0-5) 

5. `VaultConfig` contains a `token` field of type `Token` [7](#0-6) 

6. **Critical Flaw**: The `Token` enum derives Debug without sanitization [8](#0-7)  and has a `FromConfig(String)` variant that contains the plaintext token.

When the configuration endpoint is accessed, the Debug chain propagates through all these types, ultimately exposing the vault token in plaintext as `FromConfig("secret-token-value")`.

The vault token provides authentication to HashiCorp Vault, which stores consensus private keys (BLS12-381) [9](#0-8) , network private keys (x25519) [10](#0-9) , and account private keys (Ed25519) [11](#0-10) .

## Impact Explanation

**Severity: CRITICAL (up to $1,000,000)**

This vulnerability enables **Consensus/Safety violations** - a critical severity category per the Aptos bug bounty program. Specifically:

1. **Consensus Private Key Compromise**: An attacker obtaining the vault token can authenticate to the secure storage and extract the consensus private key used for BLS12-381 signing. With this key, they can:
   - Sign malicious blocks and votes
   - Violate consensus safety by producing conflicting votes
   - Potentially cause chain splits or double-spending

2. **Network Authentication Bypass**: The exposed vault also contains x25519 network private keys, allowing attackers to:
   - Impersonate validator nodes on the network
   - Perform man-in-the-middle attacks on consensus messages
   - Disrupt network connectivity and liveness

3. **Complete Validator Compromise**: Access to all validator cryptographic material effectively grants an attacker complete control over the validator's consensus participation, breaking the fundamental security assumption that private keys remain confidential.

The vulnerability directly violates the **Cryptographic Correctness** invariant: "BLS signatures, VRF, and hash operations must be secure" - by exposing the credentials protecting these cryptographic materials.

## Likelihood Explanation

**Likelihood: Medium-High**

The vulnerability requires two conditions:

1. **Configuration Endpoint Enabled**: The `expose_configuration` flag must be set to true in `inspection_service` config [12](#0-11) . While disabled by default, some operators may enable this for debugging or monitoring purposes.

2. **Vault Token Configuration Method**: The vault token must be configured using `Token::FromConfig(String)` rather than `Token::FromDisk(PathBuf)` [13](#0-12) . While `FromDisk` is preferred for production, `FromConfig` is simpler and may be used in some deployments.

If both conditions are met, the vulnerability is **trivially exploitable** - a single HTTP GET request to the inspection service endpoint returns all secrets in plaintext.

## Recommendation

Implement `SilentDebug` or a custom Debug trait for the `Token` enum to sanitize token values:

```rust
// In config/src/config/secure_backend_config.rs

// Remove Debug from derive macro
#[derive(Clone, Deserialize, PartialEq, Eq, Serialize)]
#[serde(rename_all = "snake_case")]
pub enum Token {
    FromConfig(String),
    FromDisk(PathBuf),
}

// Implement custom Debug that elides token content
impl std::fmt::Debug for Token {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Token::FromConfig(_) => write!(f, "FromConfig(<elided vault token>)"),
            Token::FromDisk(path) => f.debug_tuple("FromDisk").field(path).finish(),
        }
    }
}
```

Additionally, apply the same sanitization to `VaultConfig` to ensure the token field is always elided regardless of how it's accessed.

Consider implementing a broader audit of all configuration structures to ensure no other sensitive fields (API keys, passwords, etc.) are exposed through Debug formatting.

## Proof of Concept

```rust
// Test demonstrating token leakage
#[cfg(test)]
mod token_leak_test {
    use super::*;
    use crate::config::{NodeConfig, ConsensusConfig, SafetyRulesConfig, SecureBackend, VaultConfig, Token};

    #[test]
    fn test_vault_token_exposed_in_debug() {
        // Create a node config with a vault backend using Token::FromConfig
        let sensitive_token = "hvs.CAESI...secret-vault-token...".to_string();
        
        let mut node_config = NodeConfig::default();
        node_config.consensus.safety_rules.backend = SecureBackend::Vault(VaultConfig {
            ca_certificate: None,
            namespace: None,
            renew_ttl_secs: None,
            server: "https://vault.example.com:8200".to_string(),
            token: Token::FromConfig(sensitive_token.clone()),
            disable_cas: None,
            connection_timeout_ms: None,
            response_timeout_ms: None,
        });

        // Simulate what the inspection service does
        let debug_output = format!("{:?}", node_config);
        
        // VULNERABILITY: The token is present in the debug output
        assert!(debug_output.contains(&sensitive_token), 
                "Token should be present in debug output (demonstrating the vulnerability)");
        
        println!("Debug output contains sensitive token: {}", 
                 debug_output.contains(&sensitive_token));
    }
}
```

To exploit in production:
```bash
# If inspection service is enabled on port 9101 (default)
curl http://validator-node:9101/configuration

# The response will contain:
# consensus: ConsensusConfig { 
#   ...
#   safety_rules: SafetyRulesConfig { 
#     backend: Vault(VaultConfig { 
#       ...
#       token: FromConfig("hvs.CAESI...actual-vault-token...")
#     })
#   }
# }
```

## Notes

While cryptographic private keys themselves are properly protected with `SilentDebug` [14](#0-13)  and [15](#0-14) , the authentication credentials used to access those keys are not protected. This creates an indirect but complete compromise path to the validator's cryptographic material.

The vulnerability is particularly severe because vault tokens typically have long expiration times and broad permissions, potentially allowing persistent access to all secrets stored in the vault, not just the validator's keys.

### Citations

**File:** crates/aptos-inspection-service/src/server/configuration.rs (L15-15)
```rust
    let (status_code, body) = if node_config.inspection_service.expose_configuration {
```

**File:** crates/aptos-inspection-service/src/server/configuration.rs (L16-18)
```rust
        // We format the configuration using debug formatting. This is important to
        // prevent secret/private keys from being serialized and leaked (i.e.,
        // all secret keys are marked with SilentDisplay and SilentDebug).
```

**File:** crates/aptos-inspection-service/src/server/configuration.rs (L19-19)
```rust
        let encoded_configuration = format!("{:?}", node_config);
```

**File:** config/src/config/node_config.rs (L45-45)
```rust
    pub consensus: ConsensusConfig,
```

**File:** config/src/config/consensus_config.rs (L51-51)
```rust
    pub safety_rules: SafetyRulesConfig,
```

**File:** config/src/config/safety_rules_config.rs (L26-26)
```rust
    pub backend: SecureBackend,
```

**File:** config/src/config/secure_backend_config.rs (L20-20)
```rust
    Vault(VaultConfig),
```

**File:** config/src/config/secure_backend_config.rs (L67-67)
```rust
    pub token: Token,
```

**File:** config/src/config/secure_backend_config.rs (L100-106)
```rust
#[derive(Clone, Debug, Deserialize, PartialEq, Eq, Serialize)]
#[serde(rename_all = "snake_case")]
pub enum Token {
    FromConfig(String),
    /// This is an absolute path and not relative to data_dir
    FromDisk(PathBuf),
}
```

**File:** config/src/config/identity_config.rs (L30-31)
```rust
    #[serde(skip_serializing_if = "Option::is_none")]
    pub account_private_key: Option<Ed25519PrivateKey>,
```

**File:** config/src/config/identity_config.rs (L33-34)
```rust
    #[serde(skip_serializing_if = "Option::is_none")]
    pub consensus_private_key: Option<bls12381::PrivateKey>,
```

**File:** config/src/config/identity_config.rs (L36-36)
```rust
    pub network_private_key: x25519::PrivateKey,
```

**File:** crates/aptos-crypto/src/x25519.rs (L66-66)
```rust
#[derive(DeserializeKey, SilentDisplay, SilentDebug, SerializeKey)]
```

**File:** crates/aptos-crypto/src/bls12381/bls12381_keys.rs (L41-41)
```rust
#[derive(SerializeKey, DeserializeKey, SilentDebug, SilentDisplay)]
```
