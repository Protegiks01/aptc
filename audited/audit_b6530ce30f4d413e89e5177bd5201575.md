# Audit Report

## Title
Gas Payer Address Can Appear in Secondary Signers Due to Incomplete Duplicate Validation

## Summary
The `contains_duplicate_signers()` function fails to include the `fee_payer_address` when checking for duplicate signers, allowing the same address to appear in both the `secondary_signers` list and as the `fee_payer`. This violates the transaction signer uniqueness invariant and creates potential for signature validation confusion.

## Finding Description

The duplicate signer validation in [1](#0-0)  only checks for duplicates among `secondary_signer_addresses` and the `sender`, but completely omits the `fee_payer_address`: [1](#0-0) 

This check is invoked during transaction validation at [2](#0-1)  before the prologue executes.

**Attack Path:**

1. An attacker crafts a fee payer transaction where `fee_payer_address` equals one of the addresses in `secondary_signer_addresses`
2. The transaction passes the duplicate check since it only validates sender + secondary signers
3. During signature verification [3](#0-2) , the same address's signatures are verified twice - once as a secondary signer and once as the fee payer
4. When the VM creates the `UserTransactionContext` [4](#0-3) , the duplicate address appears in both `secondary_signers` and as `gas_payer`
5. During Move execution, any code calling both `transaction_context::secondary_signers()` [5](#0-4)  and `transaction_context::gas_payer()` [6](#0-5)  will see the same address in both contexts

## Impact Explanation

**Severity: Medium**

While I have confirmed the validation gap exists and allows the signer uniqueness invariant to be violated, the concrete exploitable impact is limited:

1. **Signature Validation Confusion**: The same address must provide two separate authenticators (one for secondary signer role, one for fee payer role), both of which are validated. This adds redundancy but doesn't directly bypass authentication.

2. **Transaction Invariant Violation**: Breaks the implicit invariant that each address should appear at most once in a transaction's signer set, which could lead to unexpected behavior in custom Move modules that assume signer uniqueness.

3. **No Direct Framework Exploit Found**: After examining the Aptos Framework Move code, including multisig accounts [7](#0-6)  and governance systems, I found no code that would be directly exploitable by this double-appearance.

This meets **Medium severity** criteria as a "state inconsistency requiring intervention" - the validation logic has a gap that violates expected invariants, though direct fund loss or consensus violation has not been demonstrated.

## Likelihood Explanation

**Likelihood: Medium**

- **Ease of Exploitation**: Easy - any transaction sender can craft a fee payer transaction with this structure
- **Detection**: The validation gap exists in production code and would allow such transactions
- **Practical Impact**: Limited - requires finding Move code that treats secondary_signers and gas_payer differently in an exploitable way

## Recommendation

Modify the duplicate signer check to include the fee payer address:

```rust
pub fn contains_duplicate_signers(&self) -> bool {
    let mut all_signer_addresses = self.authenticator.secondary_signer_addresses();
    all_signer_addresses.push(self.sender());
    
    // Add fee payer to duplicate check
    if let Some(fee_payer) = self.authenticator.fee_payer_address() {
        all_signer_addresses.push(fee_payer);
    }
    
    let mut s = BTreeSet::new();
    all_signer_addresses.iter().any(|a| !s.insert(*a))
}
```

Apply this fix in [1](#0-0) 

## Proof of Concept

```rust
// Test case to add to verify_txn.rs
#[test]
fn verify_fee_payer_in_secondary_signers() {
    let mut executor = FakeExecutor::from_head_genesis();
    let sender = executor.create_raw_account_data(1_000_010, 10);
    let secondary_signer = executor.create_raw_account_data(100_100, 100);
    let fee_payer = secondary_signer.clone(); // Same as secondary signer

    executor.add_account_data(&sender);
    executor.add_account_data(&secondary_signer);

    // Create fee payer transaction where fee_payer appears in secondary_signers
    let signed_txn = transaction_test_helpers::get_test_fee_payer_txn(
        *sender.address(),
        vec![*secondary_signer.address()], // fee_payer is here
        *fee_payer.address(),                // and also here as fee_payer
        10,
        &sender.account().privkey,
        vec![&secondary_signer.account().privkey],
        &fee_payer.account().privkey,
    );
    
    // Should fail with SIGNERS_CONTAIN_DUPLICATES but currently passes
    assert_prologue_parity!(
        executor.validate_transaction(signed_txn.clone()).status(),
        executor.execute_transaction(signed_txn).status(),
        StatusCode::SIGNERS_CONTAIN_DUPLICATES
    );
}
```

## Notes

The validation gap is confirmed, but the practical exploitability is limited by the absence of framework code that would be compromised by this double-appearance. Custom user-deployed Move modules could potentially be affected if they assume signer uniqueness without explicitly validating it. The fix is straightforward and should be applied to maintain transaction validation invariants.

### Citations

**File:** types/src/transaction/mod.rs (L1320-1325)
```rust
    pub fn contains_duplicate_signers(&self) -> bool {
        let mut all_signer_addresses = self.authenticator.secondary_signer_addresses();
        all_signer_addresses.push(self.sender());
        let mut s = BTreeSet::new();
        all_signer_addresses.iter().any(|a| !s.insert(*a))
    }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1791-1796)
```rust
        if transaction.contains_duplicate_signers() {
            return Err(VMStatus::error(
                StatusCode::SIGNERS_CONTAIN_DUPLICATES,
                None,
            ));
        }
```

**File:** types/src/transaction/authenticator.rs (L175-220)
```rust
            Self::FeePayer {
                sender,
                secondary_signer_addresses,
                secondary_signers,
                fee_payer_address,
                fee_payer_signer,
            } => {
                // In the fee payer model, the fee payer address can be optionally signed. We
                // realized when we designed the fee payer model, that we made it too restrictive
                // by requiring the signature over the fee payer address. So now we need to live in
                // a world where we support a multitude of different solutions. The modern approach
                // assumes that some may sign over the address and others will sign over the zero
                // address, so we verify both and only fail if the signature fails for either of
                // them. The legacy approach is to assume the address of the fee payer is signed
                // over.
                let mut to_verify = vec![sender];
                let _ = secondary_signers
                    .iter()
                    .map(|signer| to_verify.push(signer))
                    .collect::<Vec<_>>();

                let no_fee_payer_address_message = RawTransactionWithData::new_fee_payer(
                    raw_txn.clone(),
                    secondary_signer_addresses.clone(),
                    AccountAddress::ZERO,
                );

                let mut remaining = to_verify
                    .iter()
                    .filter(|verifier| verifier.verify(&no_fee_payer_address_message).is_err())
                    .collect::<Vec<_>>();

                remaining.push(&fee_payer_signer);

                let fee_payer_address_message = RawTransactionWithData::new_fee_payer(
                    raw_txn.clone(),
                    secondary_signer_addresses.clone(),
                    *fee_payer_address,
                );

                for verifier in remaining {
                    verifier.verify(&fee_payer_address_message)?;
                }

                Ok(())
            },
```

**File:** aptos-move/aptos-vm/src/transaction_metadata.rs (L209-222)
```rust
    pub fn as_user_transaction_context(&self) -> UserTransactionContext {
        UserTransactionContext::new(
            self.sender,
            self.secondary_signers.clone(),
            self.fee_payer.unwrap_or(self.sender),
            self.max_gas_amount.into(),
            self.gas_unit_price.into(),
            self.chain_id.id(),
            self.entry_function_payload()
                .map(|entry_func| entry_func.as_entry_function_payload()),
            self.multisig_payload()
                .map(|multisig| multisig.as_multisig_payload()),
            self.transaction_index_kind,
        )
```

**File:** aptos-move/framework/aptos-framework/sources/transaction_context.move (L97-100)
```text
    public fun secondary_signers(): vector<address> {
        assert!(features::transaction_context_extension_enabled(), error::invalid_state(ETRANSACTION_CONTEXT_EXTENSION_NOT_ENABLED));
        secondary_signers_internal()
    }
```

**File:** aptos-move/framework/aptos-framework/sources/transaction_context.move (L107-110)
```text
    public fun gas_payer(): address {
        assert!(features::transaction_context_extension_enabled(), error::invalid_state(ETRANSACTION_CONTEXT_EXTENSION_NOT_ENABLED));
        gas_payer_internal()
    }
```

**File:** aptos-move/framework/aptos-framework/sources/multisig_account.move (L1139-1183)
```text
    fun validate_multisig_transaction(
        owner: &signer, multisig_account: address, payload: vector<u8>) acquires MultisigAccount {
        assert_multisig_account_exists(multisig_account);
        assert_is_owner(owner, multisig_account);
        let sequence_number = last_resolved_sequence_number(multisig_account) + 1;
        assert_transaction_exists(multisig_account, sequence_number);

        if (features::multisig_v2_enhancement_feature_enabled()) {
            assert!(
                can_execute(address_of(owner), multisig_account, sequence_number),
                error::invalid_argument(ENOT_ENOUGH_APPROVALS),
            );
        }
        else {
            assert!(
                can_be_executed(multisig_account, sequence_number),
                error::invalid_argument(ENOT_ENOUGH_APPROVALS),
            );
        };

        // If the transaction payload is not stored on chain, verify that the provided payload matches the hashes stored
        // on chain.
        let multisig_account_resource = borrow_global<MultisigAccount>(multisig_account);
        let transaction = table::borrow(&multisig_account_resource.transactions, sequence_number);
        if (option::is_some(&transaction.payload_hash)) {
            let payload_hash = option::borrow(&transaction.payload_hash);
            assert!(
                sha3_256(payload) == *payload_hash,
                error::invalid_argument(EPAYLOAD_DOES_NOT_MATCH_HASH),
            );
        };

        // If the transaction payload is stored on chain and there is a provided payload,
        // verify that the provided payload matches the stored payload.
        if (features::abort_if_multisig_payload_mismatch_enabled()
            && option::is_some(&transaction.payload)
            && !vector::is_empty(&payload)
        ) {
            let stored_payload = option::borrow(&transaction.payload);
            assert!(
                payload == *stored_payload,
                error::invalid_argument(EPAYLOAD_DOES_NOT_MATCH),
            );
        }
    }
```
