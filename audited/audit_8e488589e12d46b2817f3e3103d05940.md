# Audit Report

## Title
Currency Metadata Inconsistency in Rosetta API Staking Balance Queries

## Summary
The Rosetta API implementation hardcodes `native_coin()` currency metadata when returning staking and delegation pool balances, causing currency metadata mismatches when exchanges configure custom APT currency representations. This can lead to balance aggregation errors and token type confusion in exchange accounting systems.

## Finding Description
The vulnerability exists in how the Rosetta API handles currency metadata across different balance query types. 

In `get_stake_balances()` and `get_delegation_stake_balances()`, the returned `Amount` objects always use `native_coin()` currency regardless of what the caller requested: [1](#0-0) [2](#0-1) 

Similarly, in `get_staking_info()` and `get_delegation_info()`: [3](#0-2) [4](#0-3) 

The `Currency` struct uses all fields including metadata for equality: [5](#0-4) 

**Attack Scenario:**
1. An exchange configures a custom APT currency with `fa_address` metadata via the currency config file
2. The system auto-adds `native_coin()` (without `fa_address`) in `RosettaContext::new()`
3. Both currencies exist in the `HashSet<Currency>` as distinct entries
4. When querying base account balances, `get_base_balances()` respects the requested currency
5. When querying staking account balances, the response always uses `native_coin()` currency metadata
6. Exchange accounting systems treat these as different token types due to metadata mismatch
7. Balance aggregation fails, causing incorrect total balance calculations [6](#0-5) [7](#0-6) 

## Impact Explanation
This issue qualifies as **Medium severity** per the Aptos bug bounty criteria for "State inconsistencies requiring intervention." While no funds are directly lost or stolen, the inconsistent currency metadata can cause:

- **Balance aggregation errors**: Exchanges may fail to correctly sum balances across base and staking accounts
- **Token type confusion**: Accounting systems might treat identical assets as different tokens
- **Missing balance reports**: When filtering for custom currencies, staking balances are silently omitted due to the filter check at: [8](#0-7) [9](#0-8) 

- **User fund visibility issues**: Users may see incorrect available balances, potentially leading to operational errors

## Likelihood Explanation
The likelihood is **Medium** because:
- Exchanges commonly configure custom currency metadata for asset tracking
- The Rosetta API allows loading custom currencies from JSON config files
- The system automatically adds `native_coin()`, creating potential for duplicates
- No warning or validation prevents multiple currency representations of the same asset
- The issue manifests automatically once misconfigured, requiring no active exploitation

## Recommendation
Implement consistent currency handling across all balance query types. Options include:

**Option 1 - Use requested currency metadata:**
```rust
// In get_stake_balances(), accept and use the requested currency
pub async fn get_stake_balances(
    rest_client: &aptos_rest_client::Client,
    owner_account: &AccountIdentifier,
    pool_address: AccountAddress,
    version: u64,
    requested_currency: &Currency, // Add parameter
) -> ApiResult<Option<BalanceResult>> {
    // ... existing code ...
    if let Some(balance) = requested_balance {
        Ok(Some(BalanceResult {
            balance: Some(Amount {
                value: balance,
                currency: requested_currency.clone(), // Use requested
            }),
            lockup_expiration,
        }))
    }
}
```

**Option 2 - Validate unique asset representations:**
Add validation in `RosettaContext::new()` to prevent multiple Currency objects representing the same underlying asset:
```rust
// Reject currencies with same move_type but different fa_address
for currency in currencies.iter() {
    if currency.metadata.as_ref()
        .and_then(|m| m.move_type.as_ref())
        .map(|t| t == "0x1::aptos_coin::AptosCoin")
        .unwrap_or(false) 
    {
        if currency != &native_coin() {
            return Err("Duplicate APT currency with different metadata detected");
        }
    }
}
```

## Proof of Concept
```rust
#[cfg(test)]
mod test {
    use super::*;
    
    #[test]
    fn test_currency_mismatch() {
        // Create custom APT currency with fa_address
        let custom_apt = Currency {
            symbol: "APT".to_string(),
            decimals: 8,
            metadata: Some(CurrencyMetadata {
                move_type: Some("0x1::aptos_coin::AptosCoin".to_string()),
                fa_address: Some("0xa".to_string()),
            }),
        };
        
        let native = native_coin();
        
        // These should represent the same asset but are not equal
        assert_ne!(custom_apt, native);
        
        // HashSet would contain both
        let mut currencies = HashSet::new();
        currencies.insert(custom_apt.clone());
        currencies.insert(native.clone());
        assert_eq!(currencies.len(), 2);
        
        // Filter check would fail for custom currency
        assert!(!currencies.contains(&native) || !currencies.contains(&custom_apt));
        // Staking balance query would skip if filtering for custom_apt only
    }
}
```

## Notes
This vulnerability specifically affects the Rosetta API layer and does not impact core blockchain consensus, execution, or state storage. The underlying APT balances on-chain remain correct and secure. However, the API inconsistency can cause real operational issues for exchanges relying on the Rosetta API for balance tracking and accounting.

### Citations

**File:** crates/aptos-rosetta/src/types/misc.rs (L369-372)
```rust
                balance: Some(Amount {
                    value: balance,
                    currency: native_coin(),
                }),
```

**File:** crates/aptos-rosetta/src/types/misc.rs (L424-427)
```rust
            balance: Some(Amount {
                value: balance,
                currency: native_coin(),
            }),
```

**File:** crates/aptos-rosetta/src/account.rs (L132-141)
```rust
        if currencies_to_lookup.contains(&native_coin()) {
            (balances, lockup_expiration) = get_delegation_info(
                &rest_client,
                &account,
                owner_address,
                pool_address.unwrap(),
                version,
            )
            .await?;
        }
```

**File:** crates/aptos-rosetta/src/account.rs (L148-151)
```rust
        if currencies_to_lookup.contains(&native_coin()) {
            (balances, lockup_expiration, maybe_operators) =
                get_staking_info(&rest_client, &account, owner_address, version).await?;
        }
```

**File:** crates/aptos-rosetta/src/account.rs (L245-248)
```rust
            balances.push(Amount {
                value: total_balance.to_string(),
                currency: native_coin(),
            })
```

**File:** crates/aptos-rosetta/src/account.rs (L284-287)
```rust
                balances.push(Amount {
                    value: balance.value,
                    currency: native_coin(),
                });
```

**File:** crates/aptos-rosetta/src/types/objects.rs (L167-185)
```rust
#[derive(Clone, Debug, Deserialize, Eq, Hash, PartialEq, Serialize)]
pub struct Currency {
    /// Symbol of currency
    pub symbol: String,
    /// Number of decimals to be considered in the currency
    pub decimals: u8,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub metadata: Option<CurrencyMetadata>,
}

#[derive(Clone, Debug, Deserialize, Eq, Hash, PartialEq, Serialize)]
pub struct CurrencyMetadata {
    /// Move coin type e.g. 0x1::aptos_coin::AptosCoin
    #[serde(skip_serializing_if = "Option::is_none")]
    pub move_type: Option<String>,
    /// Fungible Asset Address e.g. 0xA
    #[serde(skip_serializing_if = "Option::is_none")]
    pub fa_address: Option<String>,
}
```

**File:** crates/aptos-rosetta/src/lib.rs (L55-77)
```rust
    pub async fn new(
        rest_client: Option<Arc<aptos_rest_client::Client>>,
        chain_id: ChainId,
        block_cache: Option<Arc<BlockRetriever>>,
        mut currencies: HashSet<Currency>,
    ) -> Self {
        // Always add APT
        currencies.insert(native_coin());

        // Depending on the chain add appropriate USDC
        if chain_id.is_mainnet() {
            currencies.insert(usdc_currency());
        } else if chain_id.is_testnet() {
            currencies.insert(usdc_testnet_currency());
        }

        RosettaContext {
            rest_client,
            chain_id,
            block_cache,
            currencies,
        }
    }
```

**File:** crates/aptos-rosetta/src/main.rs (L241-273)
```rust
    fn supported_currencies(&self) -> HashSet<Currency> {
        let mut supported_currencies = HashSet::new();
        supported_currencies.insert(native_coin());

        if let Some(ref filepath) = self.currency_config_file {
            let file = File::open(filepath).unwrap();
            let currencies: Vec<Currency> = serde_json::from_reader(file).unwrap();
            for item in currencies.into_iter() {
                // Do a safety check on possible currencies on startup
                if item.symbol.as_str() == "" {
                    warn!(
                        "Currency {:?} has an empty symbol, and is being skipped",
                        item
                    );
                } else if let Some(metadata) = item.metadata.as_ref() {
                    if let Some(move_type) = metadata.move_type.as_ref() {
                        if StructTag::from_str(move_type).is_ok() {
                            supported_currencies.insert(item);
                            continue;
                        }
                    }
                    warn!(
                        "Currency {:?} has an invalid metadata coin type, and is being skipped",
                        item
                    );
                } else {
                    supported_currencies.insert(item);
                }
            }
        }

        supported_currencies
    }
```
