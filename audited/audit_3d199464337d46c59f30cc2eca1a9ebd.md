# Audit Report

## Title
Cross-Epoch Confusion in Timeout Signing Allows Protocol Safety Violation

## Summary
The `guarded_sign_timeout_with_qc()` function fails to validate that the timeout's declared epoch matches the epoch of its embedded quorum certificate. This allows validators to sign timeout messages that mix epoch identifiers from one epoch with round numbers from a different epoch, violating consensus safety assumptions.

## Finding Description

The vulnerability exists in the timeout verification and signing flow. When a validator receives a `TwoChainTimeout` message, the system performs several validation steps but critically fails to ensure epoch consistency between the timeout and its quorum certificate. [1](#0-0) 

The `guarded_sign_timeout_with_qc()` function performs these validations:

1. **Line 26**: Verifies `timeout.epoch()` matches the current epoch in SafetyData
2. **Lines 28-30**: Calls `timeout.verify()` which validates the quorum certificate [2](#0-1) 

However, `timeout.verify()` only checks:
- That `hqc_round() < round()`
- That the quorum certificate signatures are valid

**Critical Missing Check**: Neither `timeout.verify()` nor `guarded_sign_timeout_with_qc()` validates that `timeout.epoch == timeout.quorum_cert.certified_block().epoch()`.

The quorum certificate contains a certified BlockInfo with its own epoch: [3](#0-2) 

The signed message is created from `timeout.signing_format()`: [4](#0-3) 

This creates a `TimeoutSigningRepr` with:
- `epoch`: from `timeout.epoch` (unvalidated against QC)
- `round`: from `timeout.round`  
- `hqc_round`: from `timeout.quorum_cert.certified_block().round()` (different epoch!)

**Attack Scenario**:

When validator sets remain unchanged or have significant overlap between epochs (common in Aptos):

1. Epoch X completes with validator set {V1, V2, V3, V4}
2. Epoch X+1 begins with identical validator set {V1, V2, V3, V4}
3. Attacker obtains valid QuorumCert from Epoch X, round 5
4. Attacker crafts malicious `TwoChainTimeout`:
   - `epoch: X+1` (current epoch)
   - `round: 6`
   - `quorum_cert`: QC from Epoch X, round 5
5. Honest validator V1 in Epoch X+1 processes this:
   - `verify_epoch(X+1)` passes ✓ (matches current epoch)
   - `timeout.verify()` passes ✓ (QC signatures verify with same validator set, hqc_round < round)
   - `safe_to_timeout()` passes ✓ (round checks succeed without epoch awareness)
6. Validator signs `TimeoutSigningRepr{epoch: X+1, round: 6, hqc_round: 5}`
7. But `hqc_round: 5` is from Epoch X, not Epoch X+1!

The signed message mixes data from different epochs, violating the semantic invariant that round numbers within a timeout should be from the same epoch.

## Impact Explanation

**Severity: HIGH** - Significant Protocol Violation

This vulnerability allows cross-epoch confusion that can violate consensus safety rules:

1. **Round Monotonicity Violation**: Safety rules like `safe_to_timeout()` assume round numbers are from the same epoch. Cross-epoch timeouts break this assumption. [5](#0-4) 

2. **State Corruption**: The `observe_qc()` function updates safety data without epoch checks, allowing round numbers from different epochs to be mixed: [6](#0-5) 

3. **Consensus Inconsistency**: Different validators might have different interpretations of what "round 5" means (Epoch X vs Epoch X+1), leading to divergent consensus states.

While this requires validator set overlap between epochs, such overlap is common in Aptos. The impact meets the **High Severity** criteria for "Significant protocol violations" per the Aptos bug bounty program.

## Likelihood Explanation

**Likelihood: MEDIUM**

The attack is feasible when:
- Validator sets overlap between consecutive epochs (common - validators don't change every epoch)
- Attacker can observe and replay quorum certificates from previous epochs
- Network allows propagation of maliciously crafted timeout messages

Aptos validator sets frequently remain stable across epochs, as epoch transitions occur for various reasons beyond validator set changes (time-based, governance decisions). This makes the vulnerability exploitable in realistic network conditions.

## Recommendation

Add epoch consistency validation in `TwoChainTimeout::verify()`:

```rust
pub fn verify(&self, validators: &ValidatorVerifier) -> anyhow::Result<()> {
    // NEW: Validate epoch consistency
    ensure!(
        self.epoch == self.quorum_cert.certified_block().epoch(),
        "Timeout epoch {} does not match quorum cert epoch {}",
        self.epoch,
        self.quorum_cert.certified_block().epoch()
    );
    
    // Existing checks
    ensure!(
        self.hqc_round() < self.round(),
        "Timeout round should be larger than the QC round"
    );
    self.quorum_cert.verify(validators)?;
    Ok(())
}
```

This ensures that any timeout message must have an epoch matching its quorum certificate's epoch, preventing cross-epoch confusion.

## Proof of Concept

```rust
// Reproduction test demonstrating the vulnerability
#[test]
fn test_cross_epoch_timeout_signing() {
    use aptos_types::validator_verifier::random_validator_verifier;
    use consensus_types::timeout_2chain::TwoChainTimeout;
    use consensus_types::quorum_cert::QuorumCert;
    use consensus_types::vote_data::VoteData;
    use aptos_types::block_info::BlockInfo;
    use aptos_types::ledger_info::{LedgerInfo, LedgerInfoWithSignatures};
    
    let (signers, verifier) = random_validator_verifier(4, None, false);
    
    // Create a valid QC from Epoch 1, Round 5
    let epoch1_block = BlockInfo::random_with_epoch(1, 5);
    let vote_data = VoteData::new(epoch1_block.clone(), BlockInfo::random_with_epoch(1, 4));
    let mut li = LedgerInfoWithSignatures::new(
        LedgerInfo::new(BlockInfo::empty(), vote_data.hash()),
        PartialSignatures::empty()
    );
    for signer in &signers {
        let sig = signer.sign(li.ledger_info()).unwrap();
        li.add_signature(signer.author(), sig);
    }
    let epoch1_qc = QuorumCert::new(vote_data, li.aggregate_signatures(&verifier).unwrap());
    
    // Create timeout claiming to be from Epoch 2 but with Epoch 1 QC
    let malicious_timeout = TwoChainTimeout::new(
        2,  // Epoch 2 (WRONG - doesn't match QC epoch!)
        6,  // Round 6
        epoch1_qc  // QC from Epoch 1
    );
    
    // This should fail but currently passes!
    // The verify() method doesn't check epoch consistency
    assert!(malicious_timeout.verify(&verifier).is_ok()); // BUG: Should fail!
    
    // The signing_format() produces a cross-epoch message
    let signing_format = malicious_timeout.signing_format();
    assert_eq!(signing_format.epoch, 2);  // Epoch 2
    assert_eq!(signing_format.hqc_round, 5);  // But hqc_round is from Epoch 1!
    
    // This demonstrates the vulnerability: validators would sign a message
    // mixing Epoch 2 identifier with Epoch 1 round numbers
}
```

## Notes

This vulnerability is particularly concerning during epoch transitions when validator sets remain stable. The fix requires adding a single epoch consistency check in the `TwoChainTimeout::verify()` method to ensure the timeout's declared epoch matches its quorum certificate's epoch. This prevents cross-epoch confusion while maintaining all existing safety properties.

### Citations

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L19-51)
```rust
    pub(crate) fn guarded_sign_timeout_with_qc(
        &mut self,
        timeout: &TwoChainTimeout,
        timeout_cert: Option<&TwoChainTimeoutCertificate>,
    ) -> Result<bls12381::Signature, Error> {
        self.signer()?;
        let mut safety_data = self.persistent_storage.safety_data()?;
        self.verify_epoch(timeout.epoch(), &safety_data)?;
        if !self.skip_sig_verify {
            timeout
                .verify(&self.epoch_state()?.verifier)
                .map_err(|e| Error::InvalidTimeout(e.to_string()))?;
        }
        if let Some(tc) = timeout_cert {
            self.verify_tc(tc)?;
        }

        self.safe_to_timeout(timeout, timeout_cert, &safety_data)?;
        if timeout.round() < safety_data.last_voted_round {
            return Err(Error::IncorrectLastVotedRound(
                timeout.round(),
                safety_data.last_voted_round,
            ));
        }
        if timeout.round() > safety_data.last_voted_round {
            self.verify_and_update_last_vote_round(timeout.round(), &mut safety_data)?;
        }
        self.update_highest_timeout_round(timeout, &mut safety_data);
        self.persistent_storage.set_safety_data(safety_data)?;

        let signature = self.sign(&timeout.signing_format())?;
        Ok(signature)
    }
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L121-145)
```rust
    /// Core safety timeout rule for 2-chain protocol. Return success if 1 and 2 are true
    /// 1. round == timeout.qc.round + 1 || round == tc.round + 1
    /// 2. timeout.qc.round >= one_chain_round
    fn safe_to_timeout(
        &self,
        timeout: &TwoChainTimeout,
        maybe_tc: Option<&TwoChainTimeoutCertificate>,
        safety_data: &SafetyData,
    ) -> Result<(), Error> {
        let round = timeout.round();
        let qc_round = timeout.hqc_round();
        let tc_round = maybe_tc.map_or(0, |tc| tc.round());
        if (round == next_round(qc_round)? || round == next_round(tc_round)?)
            && qc_round >= safety_data.one_chain_round
        {
            Ok(())
        } else {
            Err(Error::NotSafeToTimeout(
                round,
                qc_round,
                tc_round,
                safety_data.one_chain_round,
            ))
        }
    }
```

**File:** consensus/consensus-types/src/timeout_2chain.rs (L66-72)
```rust
    pub fn signing_format(&self) -> TimeoutSigningRepr {
        TimeoutSigningRepr {
            epoch: self.epoch(),
            round: self.round(),
            hqc_round: self.hqc_round(),
        }
    }
```

**File:** consensus/consensus-types/src/timeout_2chain.rs (L74-81)
```rust
    pub fn verify(&self, validators: &ValidatorVerifier) -> anyhow::Result<()> {
        ensure!(
            self.hqc_round() < self.round(),
            "Timeout round should be larger than the QC round"
        );
        self.quorum_cert.verify(validators)?;
        Ok(())
    }
```

**File:** types/src/block_info.rs (L27-44)
```rust
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
#[cfg_attr(any(test, feature = "fuzzing"), derive(Arbitrary))]
pub struct BlockInfo {
    /// The epoch to which the block belongs.
    epoch: u64,
    /// The consensus protocol is executed in rounds, which monotonically increase per epoch.
    round: Round,
    /// The identifier (hash) of the block.
    id: HashValue,
    /// The accumulator root hash after executing this block.
    executed_state_id: HashValue,
    /// The version of the latest transaction after executing this block.
    version: Version,
    /// The timestamp this block was proposed by a proposer.
    timestamp_usecs: u64,
    /// An optional field containing the next epoch info
    next_epoch_state: Option<EpochState>,
}
```

**File:** consensus/safety-rules/src/safety_rules.rs (L135-156)
```rust
    pub(crate) fn observe_qc(&self, qc: &QuorumCert, safety_data: &mut SafetyData) -> bool {
        let mut updated = false;
        let one_chain = qc.certified_block().round();
        let two_chain = qc.parent_block().round();
        if one_chain > safety_data.one_chain_round {
            safety_data.one_chain_round = one_chain;
            trace!(
                SafetyLogSchema::new(LogEntry::OneChainRound, LogEvent::Update)
                    .preferred_round(safety_data.one_chain_round)
            );
            updated = true;
        }
        if two_chain > safety_data.preferred_round {
            safety_data.preferred_round = two_chain;
            trace!(
                SafetyLogSchema::new(LogEntry::PreferredRound, LogEvent::Update)
                    .preferred_round(safety_data.preferred_round)
            );
            updated = true;
        }
        updated
    }
```
