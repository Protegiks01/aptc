# Audit Report

## Title
Concurrent Fallback and Commit Sync Notifications Cause State Corruption in Consensus Observer

## Summary
The consensus observer can simultaneously trigger both fallback sync and commit sync operations, allowing both `FallbackSyncCompleted` and `CommitSyncCompleted` notifications to be sent and processed sequentially. This results in conflicting state updates including double epoch transitions, cleared pending blocks being processed, and corrupted execution pipeline state.

## Finding Description

The consensus observer maintains two independent state sync mechanisms:
1. **Fallback sync** - triggered when the observer falls behind or loses subscription health
2. **Commit sync** - triggered when a commit decision for a future epoch/round arrives

The vulnerability exists because `process_commit_decision_message()` fails to check if the system is already in fallback mode before initiating commit sync. [1](#0-0) 

This check only verifies `is_syncing_through_epoch()` (whether a commit sync with epoch transition is active) but does NOT check `in_fallback_mode()` (whether fallback sync is active). This allows the following attack sequence:

**Attack Flow:**
1. Node enters fallback mode via `enter_fallback_mode()`, which calls `sync_for_fallback()` [2](#0-1) 

2. The fallback sync spawns an async task that will run for the configured fallback duration (potentially seconds to minutes) [3](#0-2) 

3. Before fallback completes, a commit decision message arrives from a validator

4. The commit decision processing proceeds to call `sync_to_commit()` since only epoch-transition syncs are blocked [4](#0-3) 

5. The commit sync spawns its own async task [5](#0-4) 

6. Now both `fallback_sync_handle` and `sync_to_commit_handle` are set, with both async tasks running concurrently

7. Both tasks complete and send notifications through the same unbounded channel

8. The notifications are processed sequentially in the main loop [6](#0-5) 

**Conflicting State Updates:**

When `FallbackSyncCompleted` is processed:
- Updates root with fallback synced ledger info [7](#0-6) 

- Potentially calls `end_epoch()` and `wait_for_epoch_start()` if epoch changed [8](#0-7) 

- **Clears ALL pending block state** including the execution pipeline [9](#0-8) 

When `CommitSyncCompleted` is processed:
- Performs its own root validation checks [10](#0-9) 

- **Potentially calls `end_epoch()` and `wait_for_epoch_start()` AGAIN** [11](#0-10) 

- Attempts to process all ordered blocks (which may have been cleared by fallback) [12](#0-11) 

This violates the **State Consistency** invariant - state transitions must be atomic and cannot have conflicting concurrent updates.

## Impact Explanation

**Severity: HIGH** (up to $50,000)

This vulnerability causes:

1. **Consensus Observer Corruption**: The observer enters an inconsistent state where:
   - The root may point to different ledger infos depending on notification order
   - The execution pipeline can be reset multiple times or in conflicting ways
   - Ordered blocks are cleared but then attempted to be finalized

2. **Double Epoch Transitions**: Both handlers can call `execution_client.end_epoch()` and `wait_for_epoch_start()`, potentially causing:
   - Race conditions in the execution client
   - Corrupted epoch state
   - Incorrect epoch initialization

3. **Observer Liveness Failure**: The corrupted state can cause the consensus observer to:
   - Fail to process subsequent blocks
   - Require node restart to recover
   - Lose sync with the network

This qualifies as **High Severity** under "Validator node slowdowns" and "Significant protocol violations" - the consensus observer component can become non-functional, requiring intervention.

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH**

This vulnerability can be triggered through:

1. **Natural Network Conditions**: 
   - Observer falls behind due to network latency → enters fallback mode
   - During fallback (which can take seconds), validators continue producing blocks
   - New commit decision arrives → both syncs active

2. **Malicious Validator Exploitation**:
   - A validator can observe when an observer enters fallback mode
   - Send commit decision messages during fallback period
   - Force the concurrent sync scenario

The attack requires no special privileges - any validator can send commit decisions, and fallback mode is triggered automatically by the observer's own health checks. The fallback duration is configurable but typically long enough (seconds to minutes) for commit decisions to arrive during the window. [13](#0-12) 

## Recommendation

Add a check for fallback mode before starting commit sync. The fix should be applied in `process_commit_decision_message()`:

```rust
// If we're waiting for state sync to transition into a new epoch,
// we should just wait and not issue a new state sync request.
if self.state_sync_manager.is_syncing_through_epoch() {
    info!(...);
    return;
}

// **ADD THIS CHECK:**
// If we're in fallback mode, wait for it to complete before syncing to commit
if self.state_sync_manager.in_fallback_mode() {
    info!(
        LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
            "Already in fallback mode. Dropping commit decision: {:?}!",
            commit_decision.proof_block_info()
        ))
    );
    return;
}

// Otherwise, we should start the state sync process for the commit.
...
```

This ensures only one state sync mechanism is active at a time, preventing conflicting state updates.

## Proof of Concept

```rust
#[tokio::test]
async fn test_concurrent_fallback_and_commit_sync() {
    // Setup consensus observer with mock components
    let (state_sync_sender, mut state_sync_receiver) = 
        tokio::sync::mpsc::unbounded_channel();
    
    let mut observer = setup_test_observer(state_sync_sender);
    
    // Trigger fallback mode - spawns async fallback sync task
    observer.enter_fallback_mode().await;
    assert!(observer.state_sync_manager.in_fallback_mode());
    
    // Before fallback completes, receive commit decision message
    let commit_decision = create_test_commit_decision(epoch: 2, round: 100);
    let peer = create_test_peer();
    
    // Process commit decision - this should check fallback mode but doesn't!
    observer.process_commit_decision_message(
        peer,
        Instant::now(),
        commit_decision
    );
    
    // Now BOTH sync handles are set
    assert!(observer.state_sync_manager.in_fallback_mode());
    assert!(observer.state_sync_manager.is_syncing_to_commit());
    
    // Both tasks will eventually send notifications
    // Wait for both notifications to arrive
    let notification1 = state_sync_receiver.recv().await.unwrap();
    let notification2 = state_sync_receiver.recv().await.unwrap();
    
    // Process both notifications sequentially
    observer.process_state_sync_notification(notification1).await;
    observer.process_state_sync_notification(notification2).await;
    
    // Observer is now in corrupted state:
    // - Root may be inconsistent
    // - Epoch may have transitioned twice
    // - Pending blocks cleared then processed
    // - Execution pipeline in undefined state
}
```

The test demonstrates that both sync mechanisms can be active simultaneously, violating the mutual exclusion invariant that should exist between fallback and commit sync operations.

### Citations

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L237-246)
```rust
    async fn enter_fallback_mode(&mut self) {
        // Terminate all active subscriptions (to ensure we don't process any more messages)
        self.subscription_manager.terminate_all_subscriptions();

        // Clear all the pending block state
        self.clear_pending_block_state().await;

        // Start syncing for the fallback
        self.state_sync_manager.sync_for_fallback();
    }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L507-516)
```rust
            if self.state_sync_manager.is_syncing_through_epoch() {
                info!(
                    LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                        "Already waiting for state sync to reach new epoch: {:?}. Dropping commit decision: {:?}!",
                        self.observer_block_data.lock().root().commit_info(),
                        commit_decision.proof_block_info()
                    ))
                );
                return;
            }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L524-527)
```rust
            // Start state syncing to the commit decision
            self.state_sync_manager
                .sync_to_commit(commit_decision, epoch_changed);
        }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L947-950)
```rust
        // Update the root with the latest synced ledger info
        self.observer_block_data
            .lock()
            .update_root(latest_synced_ledger_info);
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L953-958)
```rust
        let current_epoch_state = self.get_epoch_state();
        if epoch > current_epoch_state.epoch {
            // Wait for the latest epoch to start
            self.execution_client.end_epoch().await;
            self.wait_for_epoch_start().await;
        };
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L961-961)
```rust
        self.clear_pending_block_state().await;
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L994-1023)
```rust
        // Get the block data root epoch and round
        let block_data_root = self.observer_block_data.lock().root();
        let block_data_epoch = block_data_root.ledger_info().epoch();
        let block_data_round = block_data_root.ledger_info().round();

        // If the commit sync notification is behind the block data root, ignore it. This
        // is possible due to a race condition where we started syncing to a newer commit
        // at the same time that state sync sent the notification for a previous commit.
        if (synced_epoch, synced_round) < (block_data_epoch, block_data_round) {
            info!(
                LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                    "Ignoring old commit sync notification for epoch: {}, round: {}! Current root: {:?}",
                    synced_epoch, synced_round, block_data_root
                ))
            );
            return;
        }

        // If the commit sync notification is ahead the block data root, something has gone wrong!
        if (synced_epoch, synced_round) > (block_data_epoch, block_data_round) {
            // Log the error, reset the state sync manager and return early
            error!(
                LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                    "Received invalid commit sync notification for epoch: {}, round: {}! Current root: {:?}",
                    synced_epoch, synced_round, block_data_root
                ))
            );
            self.state_sync_manager.clear_active_commit_sync();
            return;
        }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L1027-1045)
```rust
        let current_epoch_state = self.get_epoch_state();
        if synced_epoch > current_epoch_state.epoch {
            // Wait for the latest epoch to start
            self.execution_client.end_epoch().await;
            self.wait_for_epoch_start().await;

            // Verify the block payloads for the new epoch
            let new_epoch_state = self.get_epoch_state();
            let verified_payload_rounds = self
                .observer_block_data
                .lock()
                .verify_payload_signatures(&new_epoch_state);

            // Order all the pending blocks that are now ready (these were buffered during state sync)
            for payload_round in verified_payload_rounds {
                self.order_ready_pending_block(new_epoch_state.epoch, payload_round)
                    .await;
            }
        };
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L1050-1061)
```rust
        // Process all the newly ordered blocks
        let all_ordered_blocks = self.observer_block_data.lock().get_all_ordered_blocks();
        for (_, (observed_ordered_block, commit_decision)) in all_ordered_blocks {
            // Finalize the ordered block
            let ordered_block = observed_ordered_block.consume_ordered_block();
            self.finalize_ordered_block(ordered_block).await;

            // If a commit decision is available, forward it to the execution pipeline
            if let Some(commit_decision) = commit_decision {
                self.forward_commit_decision(commit_decision.clone());
            }
        }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L1132-1134)
```rust
                Some(state_sync_notification) = state_sync_notification_listener.recv() => {
                    self.process_state_sync_notification(state_sync_notification).await;
                },
```

**File:** consensus/src/consensus_observer/observer/state_sync_manager.rs (L117-187)
```rust
    pub fn sync_for_fallback(&mut self) {
        // Log that we're starting to sync in fallback mode
        info!(
            LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                "Started syncing in fallback mode! Syncing duration: {:?} ms!",
                self.consensus_observer_config.observer_fallback_duration_ms
            ))
        );

        // Update the state sync fallback counter
        metrics::increment_counter_without_labels(&metrics::OBSERVER_STATE_SYNC_FALLBACK_COUNTER);

        // Clone the required components for the state sync task
        let consensus_observer_config = self.consensus_observer_config;
        let execution_client = self.execution_client.clone();
        let sync_notification_sender = self.state_sync_notification_sender.clone();

        // Spawn a task to sync for the fallback
        let (abort_handle, abort_registration) = AbortHandle::new_pair();
        tokio::spawn(Abortable::new(
            async move {
                // Update the state sync metrics now that we're syncing for the fallback
                metrics::set_gauge_with_label(
                    &metrics::OBSERVER_STATE_SYNC_EXECUTING,
                    metrics::STATE_SYNCING_FOR_FALLBACK,
                    1, // We're syncing for the fallback
                );

                // Get the fallback duration
                let fallback_duration =
                    Duration::from_millis(consensus_observer_config.observer_fallback_duration_ms);

                // Sync for the fallback duration
                let latest_synced_ledger_info = match execution_client
                    .clone()
                    .sync_for_duration(fallback_duration)
                    .await
                {
                    Ok(latest_synced_ledger_info) => latest_synced_ledger_info,
                    Err(error) => {
                        error!(LogSchema::new(LogEntry::ConsensusObserver)
                            .message(&format!("Failed to sync for fallback! Error: {:?}", error)));
                        return;
                    },
                };

                // Notify consensus observer that we've synced for the fallback
                let state_sync_notification =
                    StateSyncNotification::fallback_sync_completed(latest_synced_ledger_info);
                if let Err(error) = sync_notification_sender.send(state_sync_notification) {
                    error!(
                        LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                            "Failed to send state sync notification for fallback! Error: {:?}",
                            error
                        ))
                    );
                }

                // Clear the state sync metrics now that we're done syncing
                metrics::set_gauge_with_label(
                    &metrics::OBSERVER_STATE_SYNC_EXECUTING,
                    metrics::STATE_SYNCING_FOR_FALLBACK,
                    0, // We're no longer syncing for the fallback
                );
            },
            abort_registration,
        ));

        // Save the sync task handle
        self.fallback_sync_handle = Some(DropGuard::new(abort_handle));
    }
```

**File:** consensus/src/consensus_observer/observer/state_sync_manager.rs (L190-258)
```rust
    pub fn sync_to_commit(&mut self, commit_decision: CommitDecision, epoch_changed: bool) {
        // Log that we're starting to sync to the commit decision
        info!(
            LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                "Started syncing to commit: {}!",
                commit_decision.proof_block_info()
            ))
        );

        // Get the commit decision epoch and round
        let commit_epoch = commit_decision.epoch();
        let commit_round = commit_decision.round();

        // Clone the required components for the state sync task
        let execution_client = self.execution_client.clone();
        let sync_notification_sender = self.state_sync_notification_sender.clone();

        // Spawn a task to sync to the commit decision
        let (abort_handle, abort_registration) = AbortHandle::new_pair();
        tokio::spawn(Abortable::new(
            async move {
                // Update the state sync metrics now that we're syncing to a commit
                metrics::set_gauge_with_label(
                    &metrics::OBSERVER_STATE_SYNC_EXECUTING,
                    metrics::STATE_SYNCING_TO_COMMIT,
                    1, // We're syncing to a commit decision
                );

                // Sync to the commit decision
                if let Err(error) = execution_client
                    .clone()
                    .sync_to_target(commit_decision.commit_proof().clone())
                    .await
                {
                    error!(
                        LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                            "Failed to sync to commit decision: {:?}! Error: {:?}",
                            commit_decision, error
                        ))
                    );
                    return;
                }

                // Notify consensus observer that we've synced to the commit decision
                let state_sync_notification = StateSyncNotification::commit_sync_completed(
                    commit_decision.commit_proof().clone(),
                );
                if let Err(error) = sync_notification_sender.send(state_sync_notification) {
                    error!(
                        LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                            "Failed to send state sync notification for commit decision epoch: {:?}, round: {:?}! Error: {:?}",
                            commit_epoch, commit_round, error
                        ))
                    );
                }

                // Clear the state sync metrics now that we're done syncing
                metrics::set_gauge_with_label(
                    &metrics::OBSERVER_STATE_SYNC_EXECUTING,
                    metrics::STATE_SYNCING_TO_COMMIT,
                    0, // We're no longer syncing to a commit decision
                );
            },
            abort_registration,
        ));

        // Save the sync task handle
        self.sync_to_commit_handle = Some((DropGuard::new(abort_handle), epoch_changed));
    }
```
