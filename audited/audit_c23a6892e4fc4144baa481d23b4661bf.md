# Audit Report

## Title
Epoch Ending Backup Manifest Lacks Serialization Format Versioning Leading to Backward Compatibility Failures

## Summary
The `EpochEndingBackup` and `EpochEndingChunk` structs lack serialization format versioning mechanisms, making them incompatible with schema evolution. Unlike the transaction backup system which implements explicit versioning (V0/V1), epoch ending manifests have no protection against backward-incompatible changes, potentially rendering all historical backups unreadable after code updates.

## Finding Description

The epoch ending backup system serializes manifests using serde JSON without any version tracking. The `EpochEndingBackup` and `EpochEndingChunk` structs are defined with basic Serialize/Deserialize derives: [1](#0-0) [2](#0-1) 

The backup process serializes these structs to JSON: [3](#0-2) 

The restore process deserializes from JSON: [4](#0-3) 

The critical issue is that the `verify()` function only validates logical consistency: [5](#0-4) 

It performs NO validation of serialization format compatibility. In contrast, the transaction backup system implements explicit versioning: [6](#0-5) 

This versioning pattern with `#[serde(default = "default_to_v0")]` allows backward-compatible schema evolution. The epoch ending backup system **completely lacks** this protection mechanism.

**Failure Scenarios:**

1. **Field Addition**: If developers add a required field to `EpochEndingBackup` or `EpochEndingChunk`, serde deserialization will fail on all historical manifests, making them permanently unreadable.

2. **Field Type Change**: Changing a field type (e.g., `first_epoch: u64` to `first_epoch: String`) causes deserialization failures on existing backups.

3. **Semantic Change**: Changing field semantics without type changes (e.g., waypoints meaning changes from "one per epoch" to "one per 10 epochs") allows deserialization to succeed but causes silent data misinterpretation.

## Impact Explanation

This is a **High Severity** issue per Aptos bug bounty criteria due to significant protocol violations and operational impact:

- **Backup System Fragility**: Epoch ending backups are critical for node recovery and state synchronization. Loss of backup restore capability compromises disaster recovery.

- **Operational Risk**: Network upgrades that include struct changes would invalidate all pre-upgrade backups, forcing operators to choose between keeping old code or losing backup capability.

- **State Inconsistency Risk**: Silent semantic changes could cause waypoint mismatches during restoration, potentially leading to incorrect epoch verification and state inconsistencies.

While this doesn't directly enable fund theft or consensus violations, it represents a **significant protocol violation** by undermining the reliability of the backup/restore infrastructure, which is essential for network resilience.

## Likelihood Explanation

**Medium Likelihood**: 

The transaction backup system has already evolved from V0 to V1 format, proving that backup schema evolution is a real operational need. Without versioning protection, the next schema evolution for epoch ending backups will break backward compatibility.

Developers may not realize the lack of versioning protection when making "simple" struct additions, especially since TransactionChunk already implements the correct pattern but EpochEndingChunk does not follow it.

## Recommendation

Implement explicit versioning for epoch ending backup manifests following the pattern established by `TransactionChunkFormat`:

```rust
#[derive(Clone, Deserialize, Serialize, Debug)]
pub enum EpochEndingChunkFormat {
    V0, // Current format
    // Future versions: V1, V2, etc.
}

fn default_to_v0() -> EpochEndingChunkFormat {
    EpochEndingChunkFormat::V0
}

#[derive(Deserialize, Serialize)]
pub struct EpochEndingChunk {
    pub first_epoch: u64,
    pub last_epoch: u64,
    pub ledger_infos: FileHandle,
    #[serde(default = "default_to_v0")]
    pub format: EpochEndingChunkFormat,
}
```

Similarly for `EpochEndingBackup`:

```rust
#[derive(Clone, Deserialize, Serialize, Debug)]
pub enum EpochEndingBackupFormat {
    V0,
}

fn default_backup_to_v0() -> EpochEndingBackupFormat {
    EpochEndingBackupFormat::V0
}

#[derive(Deserialize, Serialize)]
pub struct EpochEndingBackup {
    pub first_epoch: u64,
    pub last_epoch: u64,
    pub waypoints: Vec<Waypoint>,
    pub chunks: Vec<EpochEndingChunk>,
    #[serde(default = "default_backup_to_v0")]
    pub format: EpochEndingBackupFormat,
}
```

This ensures old manifests without the `format` field default to V0, maintaining backward compatibility while enabling future schema evolution.

## Proof of Concept

```rust
// This test demonstrates the vulnerability
#[test]
fn test_schema_evolution_breaks_compatibility() {
    use serde::{Deserialize, Serialize};
    
    // Simulate old version
    #[derive(Serialize)]
    struct EpochEndingBackupV1 {
        first_epoch: u64,
        last_epoch: u64,
        waypoints: Vec<String>,
    }
    
    // Create and serialize with old format
    let old_manifest = EpochEndingBackupV1 {
        first_epoch: 0,
        last_epoch: 10,
        waypoints: vec!["waypoint_0".to_string()],
    };
    let json = serde_json::to_string(&old_manifest).unwrap();
    
    // Simulate new version with added required field
    #[derive(Deserialize)]
    struct EpochEndingBackupV2 {
        first_epoch: u64,
        last_epoch: u64,
        waypoints: Vec<String>,
        checksum: String, // NEW REQUIRED FIELD
    }
    
    // Attempt to deserialize old manifest with new struct
    let result: Result<EpochEndingBackupV2, _> = serde_json::from_str(&json);
    
    // This FAILS - old backup is now unreadable
    assert!(result.is_err());
    println!("Error: {:?}", result.err());
    // Output: "missing field `checksum`"
}
```

**Notes:**
- The state_snapshot backup system also lacks versioning protection and suffers from the same vulnerability pattern.
- The metadata layer (`EpochEndingBackupMeta`) also lacks format versioning.
- This is a systemic design issue affecting multiple backup types, not just epoch ending backups.

### Citations

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/manifest.rs (L11-16)
```rust
#[derive(Deserialize, Serialize)]
pub struct EpochEndingChunk {
    pub first_epoch: u64,
    pub last_epoch: u64,
    pub ledger_infos: FileHandle,
}
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/manifest.rs (L20-26)
```rust
#[derive(Deserialize, Serialize)]
pub struct EpochEndingBackup {
    pub first_epoch: u64,
    pub last_epoch: u64,
    pub waypoints: Vec<Waypoint>,
    pub chunks: Vec<EpochEndingChunk>,
}
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/manifest.rs (L29-68)
```rust
    pub fn verify(&self) -> Result<()> {
        // check number of waypoints
        ensure!(
            self.first_epoch <= self.last_epoch
                && self.last_epoch - self.first_epoch + 1 == self.waypoints.len() as u64,
            "Malformed manifest. first epoch: {}, last epoch {}, num waypoints {}",
            self.first_epoch,
            self.last_epoch,
            self.waypoints.len(),
        );

        // check chunk ranges
        ensure!(!self.chunks.is_empty(), "No chunks.");
        let mut next_epoch = self.first_epoch;
        for chunk in &self.chunks {
            ensure!(
                chunk.first_epoch == next_epoch,
                "Chunk ranges not continuous. Expected first epoch: {}, actual: {}.",
                next_epoch,
                chunk.first_epoch,
            );
            ensure!(
                chunk.last_epoch >= chunk.first_epoch,
                "Chunk range invalid. [{}, {}]",
                chunk.first_epoch,
                chunk.last_epoch,
            );
            next_epoch = chunk.last_epoch + 1;
        }

        // check last epoch in chunk matches manifest
        ensure!(
            next_epoch - 1 == self.last_epoch, // okay to -1 because chunks is not empty.
            "Last epoch in chunks: {}, in manifest: {}",
            next_epoch - 1,
            self.last_epoch,
        );

        Ok(())
    }
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/backup.rs (L186-193)
```rust
        let (manifest_handle, mut manifest_file) = self
            .storage
            .create_for_write(backup_handle, Self::manifest_name())
            .await?;
        manifest_file
            .write_all(&serde_json::to_vec(&manifest)?)
            .await?;
        manifest_file.shutdown().await?;
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L80-83)
```rust
    async fn preheat_impl(&self) -> Result<EpochEndingRestorePreheatData> {
        let manifest: EpochEndingBackup =
            self.storage.load_json_file(&self.manifest_handle).await?;
        manifest.verify()?;
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/manifest.rs (L9-38)
```rust
#[derive(Clone, Deserialize, Serialize, Debug)]
pub enum TransactionChunkFormat {
    // (Transaction, TransactionInfo, Vec<ContractEvent>, WriteSet)
    V0,
    // (Transaction, PersistedAuxiliaryInfo, TransactionInfo, Vec<ContractEvent>, WriteSet)
    V1,
}

/// A chunk of a transaction backup manifest to represent the
/// [`first_version`, `last_version`] range (right side inclusive).
#[derive(Clone, Deserialize, Serialize, Debug)]
pub struct TransactionChunk {
    pub first_version: Version,
    pub last_version: Version,
    /// Repeated `len(record) + record`, where `record` is BCS serialized tuple
    /// `(Transaction, TransactionInfo)`
    pub transactions: FileHandle,
    /// BCS serialized `(TransactionAccumulatorRangeProof, LedgerInfoWithSignatures)`.
    /// The `TransactionAccumulatorRangeProof` links the transactions to the
    /// `LedgerInfoWithSignatures`, and the `LedgerInfoWithSignatures` can be verified by the
    /// signatures it carries, against the validator set in the epoch. (Hence proper
    /// `EpochEndingBackup` is needed for verification.)
    pub proof: FileHandle,
    #[serde(default = "default_to_v0")]
    pub format: TransactionChunkFormat,
}

fn default_to_v0() -> TransactionChunkFormat {
    TransactionChunkFormat::V0
}
```
