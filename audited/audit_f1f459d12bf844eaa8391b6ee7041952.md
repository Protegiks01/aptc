# Audit Report

## Title
EventSequenceNumberSchema Unbounded Growth Enables Low-Cost Database Exhaustion Attack on Internal Indexer

## Summary
The `EventSequenceNumberSchema` in the internal indexer lacks any pruning mechanism, allowing an attacker to create millions of permanent database entries through economically feasible account creation and event emission. This causes unbounded database bloat and query performance degradation on nodes running the optional internal indexer.

## Finding Description

The `EventSequenceNumberSchema` stores a mapping from `EventKey` to sequence number for V2 events translated to V1 format. [1](#0-0) 

During transaction processing, when V2 events are translated to V1, the system collects unique `EventKey` values and persists them to `EventSequenceNumberSchema`: [2](#0-1) 

**Critical Issue: No Pruning Mechanism**

The event store pruner only deletes `EventByKeySchema` and `EventByVersionSchema` entries, but explicitly does NOT prune `EventSequenceNumberSchema`: [3](#0-2) 

An `EventKey` consists of `(creation_number, account_address)`: [4](#0-3) 

Each account can create up to `MAX_GUID_CREATION_NUM` unique event handles: [5](#0-4) 

**Attack Path:**

1. Attacker creates multiple accounts (cost: ~52,000 octas per account, approximately $0.0005 at $10/APT)
2. For each account, perform standard operations that emit translated V2 events:
   - Coin registration (EventKey with creation_number=0)
   - Coin deposits (EventKey with creation_number=2)
   - Coin withdrawals (EventKey with creation_number=3)
   - Key rotations (EventKey with creation_number=1)
   - Token operations (various creation numbers)
3. Each unique `EventKey` creates a permanent entry in `EventSequenceNumberSchema`
4. These entries are **never pruned**, accumulating indefinitely

**Economic Feasibility:**
- To create 1 million accounts: 1,000,000 × 52,000 octas = 52 billion octas = 520 APT ≈ $5,200
- Each account generates 4-10 unique EventKeys through standard operations
- Total permanent entries: 4-10 million
- Database storage: 160-400 MB of permanent, unprunable data

The internal indexer is disabled by default and experimental: [6](#0-5) 

However, nodes that enable `enable_event_v2_translation: true` are vulnerable to this attack.

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos bug bounty program category "Validator node slowdowns" and "API crashes":

1. **Database Bloat**: Millions of permanent entries consume significant disk space (hundreds of MB to GB)
2. **Query Performance Degradation**: Iterating over `EventSequenceNumberSchema` becomes increasingly slow as the table grows
3. **API Service Disruption**: Nodes providing event-related APIs experience slowdowns and potential crashes
4. **Permanent Damage**: Without pruning, the damage is irreversible short of manual database cleanup or migration

While the internal indexer is optional and disabled by default, nodes that enable it for API services are exposed to this low-cost, high-impact attack. The economic barrier (~$5,200 for severe impact) is low enough for motivated attackers.

## Likelihood Explanation

**Likelihood: Medium-High**

The attack is straightforward to execute:
- No special privileges required
- Uses only standard framework operations (coin registration, deposits, withdrawals)
- Economic cost is low for significant impact
- Automation is trivial (batch account creation and event emission)

**Constraints:**
- Only affects nodes with internal indexer enabled (experimental feature)
- Attacker must pay gas costs (but these are minimal)
- Detection is possible through monitoring database growth rates

## Recommendation

**Immediate Mitigation:**
1. Implement pruning for `EventSequenceNumberSchema` based on configurable retention policies
2. Add database size monitoring and alerting for internal indexer growth
3. Consider implementing rate limits on new account creation per block

**Long-term Solution:**
Refactor `EventSequenceNumberSchema` to use one of these approaches:
- **Time-based TTL**: Entries expire after a configurable period
- **LRU Cache**: Keep only recently accessed entries in persistent storage
- **Versioned Storage**: Store sequence numbers per-version and enable pruning
- **Size Limits**: Enforce maximum table size with automatic cleanup of oldest entries

**Code Fix Example:**
Add pruning logic in `event_store_pruner.rs`:

```rust
// In EventStorePruner::prune(), after line 59, add:
if let Some(indexer_db) = self.indexer_db() {
    if indexer_db.event_v2_translation_enabled() {
        // Prune EventSequenceNumberSchema entries for events 
        // that haven't been emitted in the last N versions
        self.prune_stale_event_sequence_numbers(
            current_progress, 
            target_version,
            indexer_batch.as_mut().unwrap()
        )?;
    }
}
```

## Proof of Concept

**Rust Test Scenario:**

```rust
// In storage/indexer/src/db_indexer.rs tests
#[test]
fn test_event_sequence_number_unbounded_growth() {
    // Setup: Initialize internal indexer with V2 translation enabled
    let config = InternalIndexerDBConfig::new(
        false, true, true, 0, false, 1000
    );
    
    // Step 1: Create 10,000 accounts
    for i in 0..10_000 {
        let account = create_test_account(i);
        
        // Step 2: For each account, emit coin events
        // - CoinRegister (creation_number=0)
        // - CoinDeposit (creation_number=2)
        // - CoinWithdraw (creation_number=3)
        emit_coin_events(&account);
    }
    
    // Step 3: Verify EventSequenceNumberSchema has 30,000+ entries
    let mut iter = indexer_db.iter::<EventSequenceNumberSchema>().unwrap();
    iter.seek_to_first();
    let count = iter.count();
    assert!(count >= 30_000); // 3 event types × 10,000 accounts
    
    // Step 4: Trigger pruning
    prune_old_events(start_version, end_version);
    
    // Step 5: Verify EventSequenceNumberSchema entries NOT pruned
    let mut iter = indexer_db.iter::<EventSequenceNumberSchema>().unwrap();
    iter.seek_to_first();
    let count_after_prune = iter.count();
    
    // BUG: Entries remain after pruning
    assert_eq!(count_after_prune, count); 
    
    // Database bloat persists indefinitely
}
```

**Notes:**
- This vulnerability only affects nodes that explicitly enable the experimental internal indexer with `enable_event_v2_translation: true`
- The default configuration is safe (feature disabled)
- Nodes running this feature for API services are at risk
- Economic cost acts as a partial deterrent but is not prohibitive for determined attackers

### Citations

**File:** storage/indexer_schemas/src/schema/event_sequence_number/mod.rs (L4-10)
```rust
//! This module defines physical storage schema for event sequence numbers for associated event keys,
//! specifically for translated v1 events.
//!
//! ```text
//! |<--key---->|<-value->|
//! | event_key | seq_num |
//! ```
```

**File:** storage/indexer/src/db_indexer.rs (L511-521)
```rust
            for event_key in event_keys {
                batch
                    .put::<EventSequenceNumberSchema>(
                        &event_key,
                        &self
                            .event_v2_translation_engine
                            .get_cached_sequence_number(&event_key)
                            .unwrap_or(0),
                    )
                    .expect("Failed to put events by key to a batch");
            }
```

**File:** storage/aptosdb/src/ledger_db/event_db.rs (L206-217)
```rust
            if let Some(ref mut batch) = indices_batch {
                for event in events {
                    if let ContractEvent::V1(v1) = event {
                        batch.delete::<EventByKeySchema>(&(*v1.key(), v1.sequence_number()))?;
                        batch.delete::<EventByVersionSchema>(&(
                            *v1.key(),
                            current_version,
                            v1.sequence_number(),
                        ))?;
                    }
                }
            }
```

**File:** types/src/event.rs (L10-16)
```rust
/// A struct that represents a globally unique id for an Event stream that a user can listen to.
/// By design, the lower part of EventKey is the same as account address.
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub struct EventKey {
    creation_number: u64,
    account_address: AccountAddress,
}
```

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L224-225)
```text
    /// Explicitly separate the GUID space between Object and Account to prevent accidental overlap.
    const MAX_GUID_CREATION_NUM: u64 = 0x4000000000000;
```

**File:** config/src/config/internal_indexer_db_config.rs (L69-79)
```rust
impl Default for InternalIndexerDBConfig {
    fn default() -> Self {
        Self {
            enable_transaction: false,
            enable_event: false,
            enable_event_v2_translation: false,
            event_v2_translation_ignores_below_version: 0,
            enable_statekeys: false,
            batch_size: 10_000,
        }
    }
```
