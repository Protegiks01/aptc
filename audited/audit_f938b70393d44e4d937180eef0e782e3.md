# Audit Report

## Title
Stale State Injection via Unauthenticated HTTP Headers in REST Client

## Summary
The `State::from_headers()` function in the Aptos REST client accepts blockchain state information from HTTP response headers without any validation that the state is current or hasn't been replayed. An attacker with MITM capabilities or operating a malicious fullnode can replay old valid headers to cause clients to accept stale state as current, enabling transaction expiration bypasses, stale data decisions, and client-side denial of service.

## Finding Description

The `State::from_headers()` function extracts critical blockchain state from HTTP headers with zero validation: [1](#0-0) 

The function parses headers like `X-Aptos-Ledger-Version`, `X-Aptos-Ledger-Timestamp`, and `X-Aptos-Epoch` but performs no checks that:
- The version is monotonically increasing from previously seen state
- The timestamp is recent or within acceptable bounds
- The state hasn't been replayed from an earlier response
- Any cryptographic proof validates the state

This extracted state is then used throughout the REST client for critical decisions. The `parse_state()` helper directly calls this function: [2](#0-1) 

The state is attached to all API responses and used in security-critical logic, particularly in transaction expiration checks: [3](#0-2) 

**Attack Scenario:**

1. User submits a transaction at time T₀ with expiration at T₀ + 300 seconds
2. User calls `wait_for_transaction()` which polls the fullnode
3. Real blockchain time advances to T₀ + 301 seconds - transaction has expired
4. Attacker (MITM or malicious fullnode) replays old response headers showing timestamp at T₀ + 100 seconds
5. Client's expiration check at line 781/789 compares: `expiration_timestamp_secs <= state.timestamp_usecs / 1_000_000`
6. Check evaluates: `300 <= 100` (false), so client believes transaction hasn't expired
7. Client continues waiting indefinitely for a transaction that will never commit

**Contrast with Proper Validation:**

The codebase includes `TrustedState` which demonstrates proper state validation with cryptographic proofs: [4](#0-3) 

The `TrustedState` implementation explicitly enforces: *"stale responses should always be rejected"* and validates state advancement cryptographically. However, the REST client does not use this system - it has no cryptographic validation or state monotonicity checks whatsoever. [5](#0-4) 

## Impact Explanation

**Severity: Medium to High**

This vulnerability enables multiple attack vectors:

1. **Transaction Expiration Bypass**: Clients incorrectly wait for expired transactions, causing application hangs and DoS
2. **Stale Balance Queries**: Applications querying account balances receive outdated information, potentially causing incorrect transfer decisions
3. **Sequence Number Confusion**: Clients fetch stale sequence numbers, leading to transaction submission failures
4. **Version Rollback**: Clients can be shown arbitrary past versions of blockchain state

While this doesn't directly cause fund loss or consensus violations (on-chain validation still occurs), it violates the fundamental security property that **clients must be able to trust the freshness of state information**. This falls under:

- **High Severity** considerations: Significant protocol violation (clients trusting unverified state)
- **Medium Severity**: State inconsistencies in client view requiring manual intervention

The impact is amplified because many application developers will use this REST client without realizing it provides zero state freshness guarantees.

## Likelihood Explanation

**Likelihood: Medium**

Attack requirements:
- Attacker needs MITM position (HTTP interception) OR ability to run malicious fullnode
- If HTTPS without certificate pinning: possible via compromised CA, malicious proxy, or DNS attacks
- If client connects to untrusted/public fullnodes: trivially exploitable

Many deployment scenarios meet these conditions:
- Mobile/web applications connecting to public RPC endpoints
- Development environments using test fullnodes
- Applications without proper TLS certificate validation

The attack is straightforward - simply replay old but valid HTTP responses. No cryptographic operations or complex exploit chains required.

## Recommendation

Implement state validation with monotonicity checks and optionally integrate cryptographic verification:

**Minimum Fix - Add state monotonicity checking:**

```rust
// Add to State struct
impl State {
    pub fn validate_progression(&self, previous: Option<&State>) -> anyhow::Result<()> {
        if let Some(prev) = previous {
            // Verify version advances
            if self.version < prev.version {
                anyhow::bail!(
                    "State version regressed: {} < {}. Possible replay attack.",
                    self.version, prev.version
                );
            }
            
            // Verify timestamp doesn't go backwards significantly
            if self.timestamp_usecs + 60_000_000 < prev.timestamp_usecs {
                anyhow::bail!(
                    "State timestamp regressed: {} < {}. Possible replay attack.",
                    self.timestamp_usecs, prev.timestamp_usecs
                );
            }
            
            // Verify chain ID consistency
            if self.chain_id != prev.chain_id {
                anyhow::bail!(
                    "Chain ID changed: {} != {}",
                    self.chain_id, prev.chain_id
                );
            }
        }
        Ok(())
    }
}
```

**Better Fix - Add client-side state tracking:**

```rust
pub struct Client {
    inner: ReqwestClient,
    base_url: Url,
    version_path_base: String,
    last_verified_state: Arc<RwLock<Option<State>>>,  // Track last seen state
}

async fn check_response(&self, response: reqwest::Response) -> AptosResult<(reqwest::Response, State)> {
    if !response.status().is_success() {
        Err(parse_error(response).await)
    } else {
        let state = parse_state(&response)?;
        
        // Validate state progression
        let last_state = self.last_verified_state.read().unwrap();
        state.validate_progression(last_state.as_ref())?;
        
        // Update tracked state
        *self.last_verified_state.write().unwrap() = Some(state.clone());
        
        Ok((response, state))
    }
}
```

**Best Fix - Integrate TrustedState for cryptographic verification:**

For security-critical applications, provide an option to use the existing `TrustedState` system with state proofs for cryptographic verification of state transitions.

## Proof of Concept

```rust
use aptos_rest_client::State;
use reqwest::header::HeaderMap;

#[test]
fn test_replay_attack() {
    // Simulate initial state at version 1000, timestamp T1
    let mut headers1 = HeaderMap::new();
    headers1.insert("X-Aptos-Chain-Id", "1".parse().unwrap());
    headers1.insert("X-Aptos-Ledger-Version", "1000".parse().unwrap());
    headers1.insert("X-Aptos-Ledger-Timestamp", "1700000000000000".parse().unwrap());
    headers1.insert("X-Aptos-Epoch", "100".parse().unwrap());
    headers1.insert("X-Aptos-Ledger-Oldest-Version", "1".parse().unwrap());
    headers1.insert("X-Aptos-Block-Height", "500".parse().unwrap());
    headers1.insert("X-Aptos-Oldest-Block-Height", "1".parse().unwrap());
    
    let state1 = State::from_headers(&headers1).unwrap();
    println!("State 1: version={}, timestamp={}", state1.version, state1.timestamp_usecs);
    
    // Simulate attacker replaying OLDER state at version 900, timestamp T0 < T1
    let mut headers0 = HeaderMap::new();
    headers0.insert("X-Aptos-Chain-Id", "1".parse().unwrap());
    headers0.insert("X-Aptos-Ledger-Version", "900".parse().unwrap());  // OLDER version
    headers0.insert("X-Aptos-Ledger-Timestamp", "1699900000000000".parse().unwrap()); // OLDER timestamp
    headers0.insert("X-Aptos-Epoch", "100".parse().unwrap());
    headers0.insert("X-Aptos-Ledger-Oldest-Version", "1".parse().unwrap());
    headers0.insert("X-Aptos-Block-Height", "490".parse().unwrap());
    headers0.insert("X-Aptos-Oldest-Block-Height", "1".parse().unwrap());
    
    // Current implementation accepts replayed old state without error
    let state0 = State::from_headers(&headers0).unwrap();
    println!("State 0 (REPLAYED OLD): version={}, timestamp={}", state0.version, state0.timestamp_usecs);
    
    // BUG: No error even though version regressed from 1000 to 900
    assert!(state0.version < state1.version);  // This demonstrates the vulnerability
    println!("VULNERABILITY: Accepted state version {} after seeing version {}", 
             state0.version, state1.version);
}
```

This test demonstrates that the client accepts a replayed response with an older version and timestamp without any validation or error.

## Notes

- This vulnerability is specific to the REST client SDK (`aptos-rest-client`), not the validator nodes or consensus layer
- The codebase includes proper state verification via `TrustedState` for light clients, but the REST client doesn't use it
- Applications using this SDK under the assumption of state freshness are vulnerable
- Defense in depth principle is violated - even with HTTPS, there's no protection against malicious fullnodes
- The issue affects all client applications using `aptos-rest-client` for state-dependent decisions

### Citations

**File:** crates/aptos-rest-client/src/state.rs (L23-102)
```rust
    pub fn from_headers(headers: &reqwest::header::HeaderMap) -> anyhow::Result<Self> {
        let maybe_chain_id = headers
            .get(X_APTOS_CHAIN_ID)
            .and_then(|h| h.to_str().ok())
            .and_then(|s| s.parse().ok());
        let maybe_version = headers
            .get(X_APTOS_LEDGER_VERSION)
            .and_then(|h| h.to_str().ok())
            .and_then(|s| s.parse().ok());
        let maybe_timestamp = headers
            .get(X_APTOS_LEDGER_TIMESTAMP)
            .and_then(|h| h.to_str().ok())
            .and_then(|s| s.parse().ok());
        let maybe_epoch = headers
            .get(X_APTOS_EPOCH)
            .and_then(|h| h.to_str().ok())
            .and_then(|s| s.parse().ok());
        let maybe_oldest_ledger_version = headers
            .get(X_APTOS_LEDGER_OLDEST_VERSION)
            .and_then(|h| h.to_str().ok())
            .and_then(|s| s.parse().ok());
        let maybe_block_height = headers
            .get(X_APTOS_BLOCK_HEIGHT)
            .and_then(|h| h.to_str().ok())
            .and_then(|s| s.parse().ok());
        let maybe_oldest_block_height = headers
            .get(X_APTOS_OLDEST_BLOCK_HEIGHT)
            .and_then(|h| h.to_str().ok())
            .and_then(|s| s.parse().ok());
        let cursor = headers
            .get(X_APTOS_CURSOR)
            .and_then(|h| h.to_str().ok())
            .map(|s| s.to_string());

        let state = if let (
            Some(chain_id),
            Some(version),
            Some(timestamp_usecs),
            Some(epoch),
            Some(oldest_ledger_version),
            Some(block_height),
            Some(oldest_block_height),
            cursor,
        ) = (
            maybe_chain_id,
            maybe_version,
            maybe_timestamp,
            maybe_epoch,
            maybe_oldest_ledger_version,
            maybe_block_height,
            maybe_oldest_block_height,
            cursor,
        ) {
            Self {
                chain_id,
                epoch,
                version,
                timestamp_usecs,
                oldest_ledger_version,
                block_height,
                oldest_block_height,
                cursor,
            }
        } else {
            anyhow::bail!(
                "Failed to build State from headers due to missing values in response. \
                Chain ID: {:?}, Version: {:?}, Timestamp: {:?}, Epoch: {:?}, \
                Oldest Ledger Version: {:?}, Block Height: {:?} Oldest Block Height: {:?}",
                maybe_chain_id,
                maybe_version,
                maybe_timestamp,
                maybe_epoch,
                maybe_oldest_ledger_version,
                maybe_block_height,
                maybe_oldest_block_height,
            )
        };

        Ok(state)
    }
```

**File:** crates/aptos-rest-client/src/lib.rs (L779-806)
```rust
                Ok(WaitForTransactionResult::Pending(state)) => {
                    reached_mempool = true;
                    if expiration_timestamp_secs <= state.timestamp_usecs / 1_000_000 {
                        return Err(anyhow!("Transaction expired. It is guaranteed it will not be committed on chain.").into());
                    }
                    chain_timestamp_usecs = Some(state.timestamp_usecs);
                },
                Ok(WaitForTransactionResult::NotFound(error)) => {
                    if let RestError::Api(aptos_error_response) = error {
                        if let Some(state) = aptos_error_response.state {
                            if expiration_timestamp_secs <= state.timestamp_usecs / 1_000_000 {
                                if reached_mempool {
                                    return Err(anyhow!("Used to be pending and now not found. Transaction expired. It is guaranteed it will not be committed on chain.").into());
                                } else {
                                    // We want to know whether we ever got Pending state from the mempool,
                                    // to warn in case we didn't.
                                    // Unless we are calling endpoint that is a very large load-balanced pool of nodes,
                                    // we should always see pending after submitting a transaction.
                                    // (i.e. if we hit the node we submitted a transaction to,
                                    // it shouldn't return NotFound on the first call)
                                    //
                                    // At the end, when the expiration happens, we might get NotFound or Pending
                                    // based on whether GC run on the full node to remove expired transaction,
                                    // so that information is not useful. So we need to keep this variable as state.
                                    return Err(anyhow!("Transaction expired, without being seen in mempool. It is guaranteed it will not be committed on chain.").into());
                                }
                            }
                            chain_timestamp_usecs = Some(state.timestamp_usecs);
```

**File:** crates/aptos-rest-client/src/lib.rs (L1645-1656)
```rust
    async fn check_response(
        &self,
        response: reqwest::Response,
    ) -> AptosResult<(reqwest::Response, State)> {
        if !response.status().is_success() {
            Err(parse_error(response).await)
        } else {
            let state = parse_state(&response)?;

            Ok((response, state))
        }
    }
```

**File:** crates/aptos-rest-client/src/lib.rs (L1976-1978)
```rust
fn parse_state(response: &reqwest::Response) -> AptosResult<State> {
    Ok(State::from_headers(response.headers())?)
}
```

**File:** types/src/trusted_state.rs (L152-159)
```rust
        // Abort early if the response is stale.
        let curr_version = self.version();
        let target_version = latest_li.ledger_info().version();
        ensure!(
            target_version >= curr_version,
            "The target latest ledger info version is stale ({}) and behind our current trusted version ({})",
            target_version, curr_version,
        );
```
