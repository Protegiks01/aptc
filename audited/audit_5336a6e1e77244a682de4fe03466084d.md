# Audit Report

## Title
Race Condition in Resource Group Initialization Causes Base Value Corruption in Parallel Execution

## Summary
The `set_raw_base_values()` function in `versioned_group_data.rs` writes `size_entries` before `group_tags` and base values, violating the documented "size after data" invariant. This allows concurrent readers to observe an initialized group (via `contains_key()` on `group_sizes`) before data is populated, triggering erroneous `TagNotFound` errors that cause valid base values to be replaced with deletion markers.

## Finding Description

The vulnerability exists in the initialization sequence within `set_raw_base_values()`: [1](#0-0) 

The function performs non-atomic writes across three separate data structures (`group_sizes`, `group_tags`, and `values`). While `group_sizes` is locked via DashMap's `entry().or_default()`, this only protects that specific entry's modifications. Once `or_default()` executes, the entry **exists** in the map and is visible to `contains_key()` checks from other threads, even though the lock is still held for content modifications.

**Race Condition Sequence:**

1. **Thread A** (initializing): Calls `entry().or_default()` which immediately inserts an empty `VersionedGroupSize` into `group_sizes[X]` and acquires lock
2. **Thread A**: Inserts size entry at line 173
3. **Thread B** (reading concurrently): Checks `group_sizes.contains_key(X)` → returns **TRUE** (entry exists)
4. **Thread A**: Not yet at lines 175-181 (tags/values not inserted)
5. **Thread B**: Attempts to fetch tag data → **NOT FOUND**
6. **Thread B**: Receives `TagNotFound` error due to initialized=true, data=Uninitialized [2](#0-1) 

7. **Thread B** handles `TagNotFound` by inserting a deletion marker: [3](#0-2) 

8. **Thread A**: Finally inserts actual base value from storage
9. **Corruption**: In `set_base_value()`, when Thread A's `RawFromStorage` encounters Thread B's `Exchanged` (deletion), it's **ignored**: [4](#0-3) 

This violates the documented invariant stated in read methods: [5](#0-4) 

The comment explicitly states "we always write size after data," but `set_raw_base_values()` does the **opposite** (size at line 173, data at lines 175-181). In contrast, `write_v2()` correctly writes data first: [6](#0-5) 

## Impact Explanation

**Severity: Medium** - State inconsistencies requiring intervention

**Broken Invariant:** Deterministic Execution - validators executing the same block in parallel may observe different MVHashMap states depending on race timing.

**Concrete Impact:**
- Valid base values from storage are permanently replaced with deletion markers for the block's execution lifetime
- Transactions reading affected resources will observe non-existent resources when they actually exist in storage
- Causes validation failures and forced re-executions in BlockSTM
- In pathological cases with high contention on resource group initialization, could degrade to sequential execution or cause temporary liveness issues

While BlockSTM's validation mechanism should eventually recover, the corruption persists throughout the block execution window, causing:
1. Wasted computation from failed validations
2. Performance degradation from repeated re-executions
3. Potential for cascading validation failures if many transactions depend on the corrupted resource

## Likelihood Explanation

**Likelihood: Medium**

The vulnerability triggers when:
1. Parallel execution is active (standard in Aptos)
2. One transaction initializes a resource group from storage (`GroupReadResult::Uninitialized` → `initialize_mvhashmap_base_group_contents`)
3. Another transaction concurrently reads a tag from the same group during the narrow window between size insertion (line 173) and data insertion (lines 175-181)

**Factors increasing likelihood:**
- High transaction throughput increases parallel execution contention
- Large resource groups (many tags) widen the vulnerability window
- Common access patterns to newly-loaded resource groups

**Factors reducing likelihood:**
- The timing window is narrow (lines 173-175)
- Requires specific transaction scheduling by BlockSTM

The race is not directly controllable by attackers but occurs naturally under load.

## Recommendation

**Fix: Reverse the write order** to match the documented invariant - write data before size.

Move the size insertion to **after** tag and value insertion:

```rust
pub fn set_raw_base_values(
    &self,
    group_key: K,
    base_values: Vec<(T, V)>,
) -> anyhow::Result<()> {
    let mut group_sizes = self.group_sizes.entry(group_key.clone()).or_default();

    if let Vacant(entry) = group_sizes.size_entries.entry(ShiftedTxnIndex::zero_idx()) {
        // Compute group size
        let group_size = group_size_as_sum::<T>(
            base_values
                .iter()
                .flat_map(|(tag, value)| value.bytes().map(|b| (tag.clone(), b.len()))),
        )?;

        // FIRST: Insert tags and values (data)
        let mut superset_tags = self.group_tags.entry(group_key.clone()).or_default();
        for (tag, value) in base_values.into_iter() {
            superset_tags.insert(tag.clone());
            self.values.set_base_value(
                (group_key.clone(), tag),
                ValueWithLayout::RawFromStorage(Arc::new(value)),
            );
        }
        
        // THEN: Insert size (now data is visible first)
        entry.insert(SizeEntry::new(SizeAndDependencies::from_size(group_size)));
    }

    Ok(())
}
```

This ensures readers checking `group_sizes.contains_key()` will only see TRUE **after** data is already in `values`, preventing `TagNotFound` errors for valid base values.

## Proof of Concept

The race condition can be demonstrated with a concurrent test:

```rust
// Concurrent initialization and read test
#[test]
fn test_initialization_race_condition() {
    use std::sync::{Arc, Barrier};
    use std::thread;
    
    let group_data = Arc::new(VersionedGroupData::<KeyType, usize, TestValue>::empty());
    let barrier = Arc::new(Barrier::new(2));
    let group_key = KeyType(b"/test/group".to_vec());
    
    // Thread 1: Initialize with base value
    let gd1 = group_data.clone();
    let b1 = barrier.clone();
    let gk1 = group_key.clone();
    let t1 = thread::spawn(move || {
        b1.wait(); // Sync start
        gd1.set_raw_base_values(
            gk1,
            vec![(1, TestValue::creation_with_len(100))],
        )
    });
    
    // Thread 2: Read immediately after initialization starts
    let gd2 = group_data.clone();
    let b2 = barrier.clone();
    let gk2 = group_key.clone();
    let t2 = thread::spawn(move || {
        b2.wait(); // Sync start
        // Small delay to hit the race window
        std::thread::sleep(Duration::from_micros(1));
        gd2.fetch_tagged_data_no_record(&gk2, &1, 5)
    });
    
    t1.join().unwrap().unwrap();
    let result = t2.join().unwrap();
    
    // In vulnerable code: may get TagNotFound even though base value exists
    // After fix: should consistently get Uninitialized or the actual value
}
```

**Note:** This test demonstrates the race condition exists but requires precise timing to trigger reliably in practice. The bug manifests as non-deterministic `TagNotFound` errors during high-concurrency resource group initialization.

### Citations

**File:** aptos-move/mvhashmap/src/versioned_group_data.rs (L155-183)
```rust
        let mut group_sizes = self.group_sizes.entry(group_key.clone()).or_default();

        // Currently the size & value are written while holding the sizes lock.
        if let Vacant(entry) = group_sizes.size_entries.entry(ShiftedTxnIndex::zero_idx()) {
            // Perform group size computation if base not already provided.
            let group_size = group_size_as_sum::<T>(
                base_values
                    .iter()
                    .flat_map(|(tag, value)| value.bytes().map(|b| (tag.clone(), b.len()))),
            )
            .map_err(|e| {
                anyhow!(
                    "Tag serialization error in resource group at {:?}: {:?}",
                    group_key.clone(),
                    e
                )
            })?;

            entry.insert(SizeEntry::new(SizeAndDependencies::from_size(group_size)));

            let mut superset_tags = self.group_tags.entry(group_key.clone()).or_default();
            for (tag, value) in base_values.into_iter() {
                superset_tags.insert(tag.clone());
                self.values.set_base_value(
                    (group_key.clone(), tag),
                    ValueWithLayout::RawFromStorage(Arc::new(value)),
                );
            }
        }
```

**File:** aptos-move/mvhashmap/src/versioned_group_data.rs (L270-275)
```rust
        let (_, mut invalidated_dependencies) =
            self.data_write_impl::<true>(&group_key, txn_idx, incarnation, values, prev_tags)?;

        // We write data first, without holding the sizes lock, then write size.
        // Hence when size is observed, values should already be written.
        let mut group_sizes = self.group_sizes.get_mut(&group_key).ok_or_else(|| {
```

**File:** aptos-move/mvhashmap/src/versioned_group_data.rs (L423-428)
```rust
        // We are accessing group_sizes and values non-atomically, hence the order matters.
        // It is important that initialization check happens before fetch data below. O.w.
        // we could incorrectly get a TagNotFound error (do not find data, but then find
        // size initialized in between the calls). In fact, we always write size after data,
        // and sometimes (e.g. during initialization) even hold the sizes lock during writes.
        // It is fine to observe initialized = false, but find data, in convert_tagged_data.
```

**File:** aptos-move/mvhashmap/src/versioned_group_data.rs (L676-687)
```rust
    fn convert_tagged_data(
        &self,
        data_value: anyhow::Result<MVDataOutput<V>, MVDataError>,
        initialized: bool,
    ) -> Result<(Version, ValueWithLayout<V>), MVGroupError> {
        match data_value {
            Ok(MVDataOutput::Versioned(version, value)) => Ok((version, value)),
            Err(MVDataError::Uninitialized) => Err(if initialized {
                MVGroupError::TagNotFound
            } else {
                MVGroupError::Uninitialized
            }),
```

**File:** aptos-move/block-executor/src/view.rs (L815-827)
```rust
                Err(TagNotFound) => {
                    // TagNotFound means group was initialized (o.w. Uninitialized branch
                    // would be visited), but the tag didn't exist. So record an empty resource
                    // as a base value, and do continue to retry the read.
                    self.versioned_map
                        .group_data()
                        .update_tagged_base_value_with_layout(
                            group_key.clone(),
                            resource_tag.clone(),
                            TransactionWrite::from_state_value(None),
                            None,
                        );
                    continue;
```

**File:** aptos-move/mvhashmap/src/versioned_data.rs (L586-588)
```rust
                        (Exchanged(_, _), RawFromStorage(_)) => {
                            // Stored value contains more info, nothing to do.
                        },
```
