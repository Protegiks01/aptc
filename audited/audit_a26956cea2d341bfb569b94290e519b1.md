# Audit Report

## Title
Non-Atomic min_readable_version Update During Fast Sync Causes Persistent Storage Metadata Inconsistency

## Summary
The `save_min_readable_version()` function updates in-memory state and disk state in separate, non-atomic operations. A crash during `finalize_state_snapshot()` after ledger commit but before pruner metadata is persisted causes permanent divergence between the database's committed state and the pruners' min_readable_version, violating the state consistency invariant.

## Finding Description

During fast sync restoration, `finalize_state_snapshot()` performs multiple sequential non-atomic operations: [1](#0-0) 

The ledger data is committed atomically at line 223, setting `LedgerCommitProgress` to the snapshot version. Then, four separate calls to `save_min_readable_version()` update each pruner sequentially.

Each `save_min_readable_version()` implementation performs two distinct operations: [2](#0-1) 

Line 81-82 updates the in-memory `AtomicVersion`, while line 88 writes to disk via `write_pruner_progress()`. These are NOT atomic - a crash between them creates divergence.

The disk write uses RocksDB's `put()` operation: [3](#0-2) 

**Crash Scenario:**
1. Fast sync completes, calling `finalize_state_snapshot(version=10000)`
2. Line 223: Ledger data committed atomically, `LedgerCommitProgress=10000` ✓
3. Line 225: `ledger_pruner.save_min_readable_version(10000)` begins
4. Memory updated: `min_readable_version=10000` ✓
5. **CRASH** before `write_pruner_progress()` completes
6. On restart: `LedgerCommitProgress=10000` but `min_readable_version=100` (old disk value)

The pruner's min_readable_version is loaded from disk on initialization: [4](#0-3) [5](#0-4) 

After restart, the node has committed data up to version 10000, but pruners believe min_readable_version is 100. When clients request versions 100-9999 (which were replaced by the snapshot): [6](#0-5) 

The check passes (`5000 >= 100`), but the data doesn't exist or is stale, causing read failures or returning incorrect data.

**Invariant Violation:** This breaks the **State Consistency** invariant - the min_readable_version metadata no longer accurately reflects available data, and state metadata is inconsistent with actual database state.

## Impact Explanation

**Medium Severity** per Aptos bug bounty criteria: "State inconsistencies requiring intervention."

The inconsistency is permanent and requires manual intervention to fix. Different nodes crashing at different points during fast sync will have different min_readable_version values, causing:

1. **Inconsistent query responses** - some nodes claim version 100+ is available, others claim version 10000+
2. **Failed reads with inconsistent error messages** - reads that should fail with "pruned" errors instead fail with "not found" errors
3. **Potential consensus divergence** - if this inconsistent metadata affects validator behavior in subsequent operations

While not an immediate consensus safety violation, the persistent metadata inconsistency creates an undefined system state that could cascade into more severe issues.

## Likelihood Explanation

**High likelihood** of occurrence in production:
- Fast sync is a common operation for new validators and archive nodes
- System crashes during long-running operations are not rare (power failures, OOM, hardware issues)
- The vulnerability window spans 4 sequential disk writes across multiple pruners
- No automatic recovery mechanism exists - the inconsistency persists indefinitely

## Recommendation

Make `save_min_readable_version()` atomic by combining all pruner updates into a single database transaction:

```rust
fn finalize_state_snapshot(...) -> Result<()> {
    // ... existing code ...
    
    self.ledger_db.write_schemas(ledger_db_batch)?;
    
    // NEW: Atomic batch for all pruner metadata
    let mut pruner_batch = SchemaBatch::new();
    pruner_batch.put::<DbMetadataSchema>(
        &DbMetadataKey::LedgerPrunerProgress,
        &DbMetadataValue::Version(version)
    )?;
    // Add all other pruner progress keys to same batch
    self.ledger_db.metadata_db().write_schemas(pruner_batch)?;
    
    // THEN update in-memory state after disk commit succeeds
    self.ledger_pruner.update_min_readable_version_memory_only(version);
    self.state_store.state_merkle_pruner.update_min_readable_version_memory_only(version);
    self.state_store.epoch_snapshot_pruner.update_min_readable_version_memory_only(version);
    self.state_store.state_kv_pruner.update_min_readable_version_memory_only(version);
    
    // ... rest of function
}
```

Alternatively, add recovery logic on restart to validate and fix min_readable_version against `LedgerCommitProgress`.

## Proof of Concept

```rust
#[test]
fn test_finalize_snapshot_crash_inconsistency() {
    // 1. Initialize DB with data up to version 100
    let db = setup_db_with_version(100);
    
    // 2. Simulate fast sync to version 10000
    let snapshot_version = 10000;
    let output = create_snapshot_output(snapshot_version);
    let ledger_infos = create_ledger_infos(snapshot_version);
    
    // 3. Begin finalize_state_snapshot
    // This would commit ledger data atomically
    db.ledger_db.write_schemas(ledger_db_batch).unwrap();
    
    // 4. Start save_min_readable_version but don't complete disk write
    // Simulate by only updating memory
    db.ledger_pruner.min_readable_version.store(snapshot_version, Ordering::SeqCst);
    // DON'T call write_pruner_progress() - simulating crash
    
    // 5. Simulate restart by reopening DB
    drop(db);
    let db_restarted = open_db_from_disk();
    
    // 6. Verify inconsistency
    let commit_progress = db_restarted.get_synced_version().unwrap();
    let min_readable = db_restarted.ledger_pruner.get_min_readable_version();
    
    assert_eq!(commit_progress, 10000);  // From disk
    assert_eq!(min_readable, 100);       // Old value from disk
    
    // 7. Demonstrate broken invariant
    let result = db_restarted.get_transaction_by_version(5000);
    // Should fail with "pruned" error but passes min_readable check
    // Then fails with "not found" - inconsistent behavior
}
```

### Citations

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L220-234)
```rust
            // Apply the change set writes to the database (atomically) and update in-memory state
            //
            // state kv and SMT should use shared way of committing.
            self.ledger_db.write_schemas(ledger_db_batch)?;

            self.ledger_pruner.save_min_readable_version(version)?;
            self.state_store
                .state_merkle_pruner
                .save_min_readable_version(version)?;
            self.state_store
                .epoch_snapshot_pruner
                .save_min_readable_version(version)?;
            self.state_store
                .state_kv_pruner
                .save_min_readable_version(version)?;
```

**File:** storage/aptosdb/src/pruner/ledger_pruner/ledger_pruner_manager.rs (L80-89)
```rust
    fn save_min_readable_version(&self, min_readable_version: Version) -> Result<()> {
        self.min_readable_version
            .store(min_readable_version, Ordering::SeqCst);

        PRUNER_VERSIONS
            .with_label_values(&["ledger_pruner", "min_readable"])
            .set(min_readable_version as i64);

        self.ledger_db.write_pruner_progress(min_readable_version)
    }
```

**File:** storage/aptosdb/src/pruner/ledger_pruner/ledger_pruner_manager.rs (L122-138)
```rust

        let min_readable_version =
            pruner_utils::get_ledger_pruner_progress(&ledger_db).expect("Must succeed.");

        PRUNER_VERSIONS
            .with_label_values(&["ledger_pruner", "min_readable"])
            .set(min_readable_version as i64);

        Self {
            ledger_db,
            prune_window: ledger_pruner_config.prune_window,
            pruner_worker,
            pruning_batch_size: ledger_pruner_config.batch_size,
            latest_version: Arc::new(Mutex::new(min_readable_version)),
            user_pruning_window_offset: ledger_pruner_config.user_pruning_window_offset,
            min_readable_version: AtomicVersion::new(min_readable_version),
        }
```

**File:** storage/aptosdb/src/ledger_db/event_db.rs (L47-52)
```rust
    pub(super) fn write_pruner_progress(&self, version: Version) -> Result<()> {
        self.db.put::<DbMetadataSchema>(
            &DbMetadataKey::EventPrunerProgress,
            &DbMetadataValue::Version(version),
        )
    }
```

**File:** storage/aptosdb/src/pruner/pruner_utils.rs (L19-21)
```rust
pub(crate) fn get_ledger_pruner_progress(ledger_db: &LedgerDb) -> Result<Version> {
    Ok(ledger_db.metadata_db().get_pruner_progress().unwrap_or(0))
}
```

**File:** storage/aptosdb/src/db/aptosdb_internal.rs (L261-271)
```rust
    pub(super) fn error_if_ledger_pruned(&self, data_type: &str, version: Version) -> Result<()> {
        let min_readable_version = self.ledger_pruner.get_min_readable_version();
        ensure!(
            version >= min_readable_version,
            "{} at version {} is pruned, min available version is {}.",
            data_type,
            version,
            min_readable_version
        );
        Ok(())
    }
```
