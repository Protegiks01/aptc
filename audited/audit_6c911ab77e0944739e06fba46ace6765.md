# Audit Report

## Title
Hardcoded Transaction Expiration Offset Causes Premature Timeout for Custom-Duration Transactions

## Summary
The `wait_for_transactions()` helper function hardcodes a 30-second expiration offset regardless of the actual transaction's expiration duration, causing transactions with custom expiration times (>30 seconds) to be prematurely marked as expired before their actual expiration timestamp.

## Finding Description

The `wait_for_transactions()` function in `crates/aptos/src/common/utils.rs` accepts only transaction hashes and recalculates the expiration timestamp as `current_time + 30` seconds, without access to the actual transaction's expiration. [1](#0-0) 

However, transactions in Aptos can be created with custom expiration durations via the `--expiration-secs` CLI parameter, which is stored in `GasOptions.expiration_secs` with a default of 30 seconds but configurable to any value. [2](#0-1) 

When building transactions, the `TransactionFactory` uses this custom expiration value: [3](#0-2) 

The actual expiration timestamp is calculated as `current_time + expiration_secs`: [4](#0-3) 

The `wait_for_transaction_by_hash_inner()` function checks if a transaction has expired by comparing the provided `expiration_timestamp_secs` against the chain's timestamp. If `expiration_timestamp_secs <= chain_timestamp`, it returns an expiration error. [5](#0-4) 

**The vulnerability:** If a user creates a transaction with a 60-second expiration, but `wait_for_transactions()` is called with its hash, the function will use `sys_time = current_time + 30` instead of the actual `current_time + 60`. At the 30-second mark, the function will mark the transaction as expired even though it has 30 more seconds to commit.

**Contrast with correct implementation:** The `wait_for_signed_transaction()` method correctly extracts the expiration from the transaction object rather than recalculating it. [6](#0-5) 

## Impact Explanation
This is a **Low severity** issue as indicated in the security question. It represents a non-critical implementation bug that:
- Does not cause loss of funds
- Does not violate consensus safety
- Does not enable state corruption attacks
- Does not affect validator operations

The impact is limited to poor user experience where transactions with custom expiration durations may be reported as "expired" prematurely, even though they still have time remaining on-chain.

## Likelihood Explanation
The likelihood of this issue manifesting is **very low** because:
1. The `wait_for_transactions()` function appears to be unused in the current codebase (no callers found)
2. The primary transaction submission flow uses `wait_for_signed_transaction()` which correctly handles expiration [7](#0-6) 
3. Users would need to both set custom expiration AND somehow trigger this specific helper function

## Recommendation

**Option 1:** Deprecate and remove the `wait_for_transactions()` helper function since it's unused and has an unfixable design flaw (it only receives hashes without expiration information).

**Option 2:** If the function must be retained, modify its signature to accept expiration timestamps along with hashes:

```rust
pub async fn wait_for_transactions(
    client: &aptos_rest_client::Client,
    transactions: Vec<(HashValue, u64)>, // (hash, expiration_timestamp_secs)
) -> CliTypedResult<()> {
    for (hash, expiration_timestamp_secs) in transactions {
        client
            .wait_for_transaction_by_hash(
                hash.into(),
                expiration_timestamp_secs, // Use actual expiration
                Some(Duration::from_secs(60)),
                None,
            )
            .await?;
    }
    Ok(())
}
```

**Option 3:** Accept that this helper assumes default 30-second expiration and document it clearly, restricting its use to default-expiration transactions only.

## Proof of Concept

While a full PoC cannot be easily constructed due to the function being unused in production code, the logical flow can be demonstrated:

```rust
// Hypothetical scenario
// 1. User creates transaction with 60-second expiration
let transaction_factory = TransactionFactory::new(chain_id)
    .with_transaction_expiration_time(60); // Custom 60-second expiration

let signed_txn = /* ... sign transaction ... */;
let hash = signed_txn.committed_hash();

// Transaction actual expiration: T0 + 60 seconds

// 2. Hypothetically call wait_for_transactions with just the hash
wait_for_transactions(&client, vec![hash]).await?;
// This calculates: sys_time = current_time + 30
// Uses: T0 + 30 instead of actual T0 + 60

// 3. At T0 + 30, function returns "Transaction expired"
//    But transaction doesn't actually expire until T0 + 60
//    Transaction lost 30 seconds of commit opportunity
```

**Notes:**

This issue is a **usability/reliability bug** rather than a security vulnerability. The severity classification as "Low" in the original security question is accurate. The function's design flaw is that it operates on hashes alone without the contextual information (expiration timestamps) needed to correctly monitor transaction status. The 60-second timeout and 30-second sys_time offset are properly coordinated for DEFAULT 30-second expirations, but fail for custom expiration durations, creating the edge case mentioned in the security question.

### Citations

**File:** crates/aptos/src/common/utils.rs (L473-493)
```rust
pub async fn wait_for_transactions(
    client: &aptos_rest_client::Client,
    hashes: Vec<HashValue>,
) -> CliTypedResult<()> {
    let sys_time = SystemTime::now()
        .duration_since(SystemTime::UNIX_EPOCH)
        .map_err(|e| CliError::UnexpectedError(e.to_string()))?
        .as_secs()
        + 30;
    for hash in hashes {
        client
            .wait_for_transaction_by_hash(
                hash.into(),
                sys_time,
                Some(Duration::from_secs(60)),
                None,
            )
            .await?;
    }
    Ok(())
}
```

**File:** crates/aptos/src/common/types.rs (L1757-1761)
```rust
    /// Number of seconds to expire the transaction
    ///
    /// This is the number of seconds from the current local computer time.
    #[clap(long, default_value_t = DEFAULT_EXPIRATION_SECS)]
    pub expiration_secs: u64,
```

**File:** crates/aptos/src/common/types.rs (L2045-2048)
```rust
        let transaction_factory = TransactionFactory::new(chain_id)
            .with_gas_unit_price(gas_unit_price)
            .with_max_gas_amount(max_gas)
            .with_transaction_expiration_time(self.gas_options.expiration_secs);
```

**File:** crates/aptos/src/common/types.rs (L2117-2120)
```rust
        let response = client
            .wait_for_signed_transaction(&transaction)
            .await
            .map_err(|err| CliError::ApiError(err.to_string()))?;
```

**File:** sdk/src/transaction_builder.rs (L375-390)
```rust
    fn expiration_timestamp(&self) -> u64 {
        match self.transaction_expiration {
            TransactionExpiration::Relative {
                expiration_duration,
            } => {
                std::time::SystemTime::now()
                    .duration_since(std::time::UNIX_EPOCH)
                    .unwrap()
                    .as_secs()
                    + expiration_duration
            },
            TransactionExpiration::Absolute {
                expiration_timestamp,
            } => expiration_timestamp,
        }
    }
```

**File:** crates/aptos-rest-client/src/lib.rs (L711-723)
```rust
    pub async fn wait_for_signed_transaction(
        &self,
        transaction: &SignedTransaction,
    ) -> AptosResult<Response<Transaction>> {
        let expiration_timestamp = transaction.expiration_timestamp_secs();
        self.wait_for_transaction_by_hash(
            transaction.committed_hash(),
            expiration_timestamp,
            Some(DEFAULT_MAX_SERVER_LAG_WAIT_DURATION),
            None,
        )
        .await
    }
```

**File:** crates/aptos-rest-client/src/lib.rs (L779-783)
```rust
                Ok(WaitForTransactionResult::Pending(state)) => {
                    reached_mempool = true;
                    if expiration_timestamp_secs <= state.timestamp_usecs / 1_000_000 {
                        return Err(anyhow!("Transaction expired. It is guaranteed it will not be committed on chain.").into());
                    }
```
