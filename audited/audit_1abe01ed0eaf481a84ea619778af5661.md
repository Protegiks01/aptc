# Audit Report

## Title
Storage Service Returns Error Instead of Empty Response for Zero Max Bytes in Transaction Data Requests

## Summary

When a `GetTransactionDataWithProofRequest` is sent with `max_response_bytes=0` for transaction data (not transaction outputs), the storage service returns an error from the Merkle accumulator instead of gracefully handling the empty response case. This creates an inconsistency where transaction output requests properly handle zero bytes but transaction requests fail.

## Finding Description

The storage service handles `GetTransactionDataWithProofRequest` differently depending on the request type. When `max_response_bytes` is set to 0:

**For Transaction Data Requests:** [1](#0-0) 

The request flows through `get_transaction_data_with_proof` which applies `min()` to cap the max bytes [2](#0-1) , then calls `get_transactions_with_proof_by_size`.

Inside `get_transactions_with_proof_by_size`, a `ResponseDataProgressTracker` is created [3](#0-2) . When `max_response_size` is 0, the tracker's `is_response_complete()` method immediately returns true [4](#0-3)  because `serialized_data_size (0) >= max_response_size (0)`. This causes the while loop [5](#0-4)  to never execute, leaving `transactions` as an empty vector.

The code then attempts to create an accumulator range proof without checking if the transactions list is empty [6](#0-5) . This calls into the database layer [7](#0-6) , which wraps the `first_version` in `Some()` and calls the accumulator's `get_range_proof` with `num_leaves=0`.

The Merkle accumulator validation logic rejects this combination [8](#0-7) : when `first_leaf_index` is `Some(value)` but `num_leaves` is 0, it returns an error at lines 417-420: "num_leaves is zero while first_leaf_index is not None."

**For Transaction Output Requests:** [9](#0-8) 

The code explicitly checks if `num_fetched_outputs == 0` and uses `AccumulatorRangeProof::new_empty()` instead of attempting to fetch a proof from storage. This is the correct behavior.

**Attack Path:**
1. Malicious peer or buggy client sends `GetTransactionDataWithProofRequest` with `max_response_bytes=0` and type `TransactionData` or `TransactionOrOutputData`
2. Storage service processes request through `get_transactions_with_proof_by_size`
3. Empty transactions vector is created due to zero-byte limit
4. Accumulator proof creation fails with error
5. Error is returned to client instead of valid empty response

## Impact Explanation

This qualifies as **Medium Severity** per Aptos bug bounty criteria ("State inconsistencies requiring intervention"):

1. **State Sync Availability Impact**: Clients that send `max_response_bytes=0` (whether accidentally or intentionally) receive errors instead of valid empty responses, breaking state synchronization
2. **API Inconsistency**: Transaction data and transaction output requests handle the same edge case differently, violating API contract expectations
3. **Resource Waste**: Malicious peers could repeatedly send such requests to generate error logs and waste server processing cycles
4. **Developer Confusion**: The error message "num_leaves is zero while first_leaf_index is not None" doesn't indicate the root cause is `max_response_bytes=0`

While this doesn't directly affect consensus, funds, or critical blockchain operations, it degrades the state sync service availability and creates an exploitable inconsistency.

## Likelihood Explanation

**High likelihood** of occurrence:

1. **Easy to trigger**: Any peer can send a `GetTransactionDataWithProofRequest` with `max_response_bytes=0`
2. **No special permissions required**: Unprivileged network peers can make this request
3. **Accidental triggers possible**: Client implementations with bugs (e.g., uninitialized values, integer underflow) might inadvertently send zero
4. **Already inconsistent**: The fact that outputs handle it correctly but transactions don't suggests this was overlooked during development

## Recommendation

Add a check for empty transactions before creating the accumulator range proof, matching the behavior of transaction outputs:

In `get_transactions_with_proof_by_size` (around line 474), change:

```rust
let accumulator_range_proof = self.storage.get_transaction_accumulator_range_proof(
    start_version,
    transactions.len() as u64,
    proof_version,
)?;
```

To:

```rust
let accumulator_range_proof = if transactions.is_empty() {
    AccumulatorRangeProof::new_empty()
} else {
    self.storage.get_transaction_accumulator_range_proof(
        start_version,
        transactions.len() as u64,
        proof_version,
    )?
};
```

This matches the defensive pattern already used in `get_transaction_outputs_with_proof_by_size`.

## Proof of Concept

```rust
#[test]
fn test_zero_max_bytes_transaction_data_request() {
    use aptos_storage_service_types::requests::{
        DataRequest, GetTransactionDataWithProofRequest,
        TransactionDataRequestType, TransactionData,
    };
    
    // Setup: Create a storage reader with some transactions
    let (storage, _) = setup_storage_with_transactions(100);
    let config = StorageServiceConfig::default();
    let time_service = TimeService::real();
    let storage_reader = StorageReader::new(config, storage, time_service);
    
    // Create a request with max_response_bytes = 0
    let request = GetTransactionDataWithProofRequest {
        transaction_data_request_type: TransactionDataRequestType::TransactionData(
            TransactionData { include_events: false }
        ),
        proof_version: 99,
        start_version: 50,
        end_version: 60,
        max_response_bytes: 0, // Zero bytes!
    };
    
    // Attempt to process the request
    let result = storage_reader.get_transaction_data_with_proof(&request);
    
    // This should succeed with an empty response, but instead returns error:
    // "num_leaves is zero while first_leaf_index is not None"
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("num_leaves is zero"));
    
    // Compare with transaction outputs - this should work correctly
    let output_request = GetTransactionDataWithProofRequest {
        transaction_data_request_type: TransactionDataRequestType::TransactionOutputData,
        proof_version: 99,
        start_version: 50,
        end_version: 60,
        max_response_bytes: 0,
    };
    
    let output_result = storage_reader.get_transaction_data_with_proof(&output_request);
    assert!(output_result.is_ok()); // Outputs handle it correctly!
}
```

## Notes

This vulnerability does not cause division by zero errors (the security question's first concern), as the only division operation divides `num_transactions_to_fetch`, not `max_response_bytes` [10](#0-9) .

However, it does cause the server to return error responses when `max_response_bytes=0` is set for transaction data requests, while transaction output requests handle the same case correctly. This inconsistency and the resulting errors constitute a valid Medium-severity bug affecting state sync availability.

### Citations

**File:** state-sync/storage-service/server/src/storage.rs (L410-415)
```rust
        let mut response_progress_tracker = ResponseDataProgressTracker::new(
            num_transactions_to_fetch,
            max_response_size,
            self.config.max_storage_read_wait_time_ms,
            self.time_service.clone(),
        );
```

**File:** state-sync/storage-service/server/src/storage.rs (L418-471)
```rust
        while !response_progress_tracker.is_response_complete() {
            match multizip_iterator.next() {
                Some((Ok(transaction), Ok(info), Ok(events), Ok(persisted_auxiliary_info))) => {
                    // Calculate the number of serialized bytes for the data items
                    let num_transaction_bytes = get_num_serialized_bytes(&transaction)
                        .map_err(|error| Error::UnexpectedErrorEncountered(error.to_string()))?;
                    let num_info_bytes = get_num_serialized_bytes(&info)
                        .map_err(|error| Error::UnexpectedErrorEncountered(error.to_string()))?;
                    let num_events_bytes = get_num_serialized_bytes(&events)
                        .map_err(|error| Error::UnexpectedErrorEncountered(error.to_string()))?;
                    let num_auxiliary_info_bytes =
                        get_num_serialized_bytes(&persisted_auxiliary_info).map_err(|error| {
                            Error::UnexpectedErrorEncountered(error.to_string())
                        })?;

                    // Add the data items to the lists
                    let total_serialized_bytes = num_transaction_bytes
                        + num_info_bytes
                        + num_events_bytes
                        + num_auxiliary_info_bytes;
                    if response_progress_tracker
                        .data_items_fits_in_response(true, total_serialized_bytes)
                    {
                        transactions.push(transaction);
                        transaction_infos.push(info);
                        transaction_events.push(events);
                        persisted_auxiliary_infos.push(persisted_auxiliary_info);

                        response_progress_tracker.add_data_item(total_serialized_bytes);
                    } else {
                        break; // Cannot add any more data items
                    }
                },
                Some((Err(error), _, _, _))
                | Some((_, Err(error), _, _))
                | Some((_, _, Err(error), _))
                | Some((_, _, _, Err(error))) => {
                    return Err(Error::StorageErrorEncountered(error.to_string()));
                },
                None => {
                    // Log a warning that the iterators did not contain all the expected data
                    warn!(
                        "The iterators for transactions, transaction infos, events and \
                        persisted auxiliary infos are missing data! Start version: {:?}, \
                        end version: {:?}, num transactions to fetch: {:?}, num fetched: {:?}.",
                        start_version,
                        end_version,
                        num_transactions_to_fetch,
                        transactions.len()
                    );
                    break;
                },
            }
        }
```

**File:** state-sync/storage-service/server/src/storage.rs (L474-478)
```rust
        let accumulator_range_proof = self.storage.get_transaction_accumulator_range_proof(
            start_version,
            transactions.len() as u64,
            proof_version,
        )?;
```

**File:** state-sync/storage-service/server/src/storage.rs (L550-553)
```rust
                let new_num_transactions_to_fetch = num_transactions_to_fetch / 2;
                debug!("The request for {:?} transactions was too large (num bytes: {:?}, limit: {:?}). Retrying with {:?}.",
                    num_transactions_to_fetch, num_bytes, max_response_size, new_num_transactions_to_fetch);
                num_transactions_to_fetch = new_num_transactions_to_fetch; // Try again with half the amount of data
```

**File:** state-sync/storage-service/server/src/storage.rs (L700-708)
```rust
        let accumulator_range_proof = if num_fetched_outputs == 0 {
            AccumulatorRangeProof::new_empty() // Return an empty proof if no outputs were fetched
        } else {
            self.storage.get_transaction_accumulator_range_proof(
                start_version,
                num_fetched_outputs as u64,
                proof_version,
            )?
        };
```

**File:** state-sync/storage-service/server/src/storage.rs (L1140-1192)
```rust
    fn get_transaction_data_with_proof(
        &self,
        transaction_data_with_proof_request: &GetTransactionDataWithProofRequest,
    ) -> aptos_storage_service_types::Result<TransactionDataWithProofResponse, Error> {
        // Extract the data versions from the request
        let proof_version = transaction_data_with_proof_request.proof_version;
        let start_version = transaction_data_with_proof_request.start_version;
        let end_version = transaction_data_with_proof_request.end_version;

        // Calculate the max response size to use
        let max_response_bytes = min(
            transaction_data_with_proof_request.max_response_bytes,
            self.config.max_network_chunk_bytes_v2,
        );

        // Fetch the transaction data based on the request type
        match transaction_data_with_proof_request.transaction_data_request_type {
            TransactionDataRequestType::TransactionData(request) => {
                // Get the transaction list with proof
                self.get_transactions_with_proof_by_size(
                    proof_version,
                    start_version,
                    end_version,
                    request.include_events,
                    max_response_bytes,
                    self.config.enable_size_and_time_aware_chunking,
                )
            },
            TransactionDataRequestType::TransactionOutputData => {
                // Get the transaction output list with proof
                self.get_transaction_outputs_with_proof_by_size(
                    proof_version,
                    start_version,
                    end_version,
                    max_response_bytes,
                    false,
                    self.config.enable_size_and_time_aware_chunking,
                )
            },
            TransactionDataRequestType::TransactionOrOutputData(request) => {
                // Get the transaction or output list with proof
                self.get_transactions_or_outputs_with_proof_by_size(
                    proof_version,
                    start_version,
                    end_version,
                    request.include_events,
                    0, // Fetch all outputs, or return transactions
                    max_response_bytes,
                    self.config.enable_size_and_time_aware_chunking,
                )
            },
        }
    }
```

**File:** state-sync/storage-service/server/src/storage.rs (L1416-1434)
```rust
    pub fn is_response_complete(&self) -> bool {
        // If we have fetched all the items, the response is complete
        if self.num_items_fetched >= self.num_items_to_fetch {
            return true;
        }

        // If the serialized data size exceeds the maximum, the response is complete
        if self.serialized_data_size >= self.max_response_size {
            return true;
        }

        // If the storage read duration exceeds the maximum, the response is complete
        if self.overflowed_storage_read_duration() {
            return true;
        }

        // Otherwise, the response is not yet complete
        false
    }
```

**File:** storage/aptosdb/src/db/aptosdb_reader.rs (L548-560)
```rust
    fn get_transaction_accumulator_range_proof(
        &self,
        first_version: Version,
        limit: u64,
        ledger_version: Version,
    ) -> Result<TransactionAccumulatorRangeProof> {
        gauged_api("get_transaction_accumulator_range_proof", || {
            self.error_if_ledger_pruned("Transaction", first_version)?;

            self.ledger_db
                .transaction_accumulator_db()
                .get_transaction_range_proof(Some(first_version), limit, ledger_version)
        })
```

**File:** storage/accumulator/src/lib.rs (L403-434)
```rust
    fn get_range_proof_positions(
        &self,
        first_leaf_index: Option<u64>,
        num_leaves: LeafCount,
    ) -> Result<(Vec<Position>, Vec<Position>)> {
        if first_leaf_index.is_none() {
            ensure!(
                num_leaves == 0,
                "num_leaves is not zero while first_leaf_index is None.",
            );
            return Ok((Vec::new(), Vec::new()));
        }

        let first_leaf_index = first_leaf_index.expect("first_leaf_index should not be None.");
        ensure!(
            num_leaves > 0,
            "num_leaves is zero while first_leaf_index is not None.",
        );
        let last_leaf_index = first_leaf_index
            .checked_add(num_leaves - 1)
            .ok_or_else(|| format_err!("Requesting too many leaves."))?;
        ensure!(
            last_leaf_index < self.num_leaves,
            "Invalid last_leaf_index: {}, num_leaves: {}",
            last_leaf_index,
            self.num_leaves,
        );

        let left_siblings = self.get_sibling_positions(first_leaf_index, |p| p.is_left_child());
        let right_siblings = self.get_sibling_positions(last_leaf_index, |p| p.is_right_child());
        Ok((left_siblings, right_siblings))
    }
```
