# Audit Report

## Title
Private Key Leakage Through Structured Logging Serialization Bypass

## Summary
The `SilentDebug` derive macro at line 26 of `secp256k1_ecdsa.rs` successfully redacts private keys in Debug and Display contexts, but a critical bypass exists through the structured logging system's serde serialization path. When developers use structured logging without the `?` or `%` prefix (e.g., `info!(key = private_key)`), private keys are serialized to JSON as plaintext hex strings, completely bypassing the redaction protection. [1](#0-0) 

## Finding Description

The `PrivateKey` struct derives both `SilentDebug` (for redaction) and `SerializeKey` (for configuration serialization), creating a conflict in security guarantees. [2](#0-1) 

The `SilentDebug` macro generates a Debug implementation that redacts the private key value, outputting `<elided secret for PrivateKey>`.

However, the structured logging system in aptos-logger uses three different capture methods based on syntax: [3](#0-2) 

When using `key = value` syntax (lines 152-163), it calls `Value::from_serde`, which triggers JSON serialization: [4](#0-3) [5](#0-4) 

The `JsonVisitor` serializes `Value::Serde` using `serde_json::to_value()`, which is a human-readable serializer. For PrivateKey, this triggers the `SerializeKey` implementation: [6](#0-5) 

Which calls `to_encoded_string()`: [7](#0-6) 

This encodes the private key bytes as a hex string with "0x" prefix, exposing the full private key material in log output.

## Impact Explanation

**Severity: High** (but requires developer error to trigger)

If triggered, this vulnerability would lead to:
- **Direct private key exposure** in log files
- **Loss of funds**: Attackers with log access can extract keys and sign unauthorized transactions
- **Validator compromise**: If validator private keys are logged, consensus security is compromised

However, this requires:
1. Developer mistake (using `key = value` instead of `key = ?value`)
2. Attacker access to log files (which may be stored in centralized logging systems)

While the impact of key leakage is Critical (potential loss of funds), the requirement for developer error and log access reduces this to **High severity** per the bug bounty criteria for "significant protocol violations."

## Likelihood Explanation

**Likelihood: Low to Medium**

- **Low** in production code: Developers are generally aware of sensitive data handling
- **Medium** in debugging scenarios: Developers may temporarily add logs for debugging and forget to use `?` prefix
- **Higher** risk: Log aggregation systems often have broader access than intended

The vulnerability becomes more likely when:
- New developers unfamiliar with the logging API conventions
- Urgent debugging scenarios under time pressure
- Automated logging of error contexts that include key material

## Recommendation

**1. Make serialization of private keys fail-safe by default:**

Implement a custom `Serialize` implementation that always redacts, similar to `SilentDebug`:

```rust
impl serde::Serialize for PrivateKey {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        // Always redact private keys, even in serialization contexts
        serializer.serialize_str("<elided secret for PrivateKey>")
    }
}
```

**2. Separate configuration serialization from logging:**

Create a separate `ConfigPrivateKey` wrapper type for configuration contexts where serialization is intentionally needed:

```rust
pub struct ConfigPrivateKey(PrivateKey);

impl serde::Serialize for ConfigPrivateKey {
    // Only this type can serialize actual key bytes
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // Use SerializeKey derive behavior
        self.0.to_encoded_string()
            .map_err(<S::Error as serde::ser::Error>::custom)
            .and_then(|str| serializer.serialize_str(&str[..]))
    }
}
```

**3. Add compile-time warnings:**

Add documentation and possibly a `#[deprecated]` attribute on direct PrivateKey serialization contexts.

## Proof of Concept

```rust
#[cfg(test)]
mod test {
    use aptos_crypto::{secp256k1_ecdsa::PrivateKey, traits::Uniform};
    use aptos_logger::{info, debug};
    use rand::SeedableRng;

    #[test]
    fn test_private_key_leakage_via_logging() {
        aptos_logger::AptosDataBuilder::new()
            .level(aptos_logger::Level::Debug)
            .init();
            
        let mut rng = rand::rngs::StdRng::from_seed([0u8; 32]);
        let private_key = PrivateKey::generate(&mut rng);
        
        // SAFE: Uses Debug trait, key is redacted
        debug!(private_key = ?private_key);
        // Output: {"private_key": "<elided secret for PrivateKey>"}
        
        // UNSAFE: Uses Serialize trait, key is exposed!
        info!(private_key = private_key);
        // Output: {"private_key": "0x<64_hex_chars_of_actual_key>"}
        
        // To verify the leak, check log output for hex-encoded key
        let key_bytes = private_key.to_bytes();
        let expected_hex = format!("0x{}", hex::encode(&key_bytes));
        
        // The log file will contain the expected_hex string
        println!("Key leaked as: {}", expected_hex);
    }
}
```

## Notes

After thorough investigation, while this represents a **genuine design flaw** in the interaction between `SilentDebug` and `SerializeKey` derive macros, I must note that:

1. **No exploitable production code paths were found** where this vulnerability is actually triggered
2. The vulnerability **requires developer error** (wrong logging syntax)  
3. It **cannot be exploited by external attackers** without first compromising log access

Per the strict validation criteria requiring "exploitable by unprivileged attacker" and "realistic attack path," this is more accurately classified as an **API misuse vulnerability** or **defense-in-depth weakness** rather than a directly exploitable bug.

The `SilentDebug` macro **does properly redact** private key material in:
- Debug output (`{:?}`)
- Display output (`{}`)
- Error messages using Debug formatting
- Panic! output using Debug formatting
- Structured logging with `?` or `%` prefix

The vulnerability only manifests when developers explicitly choose the wrong logging syntax, which requires internal developer error rather than external exploitation.

**Final Assessment: While this represents a security weakness worth addressing, it does not meet the strict criteria for a bug bounty submission as it requires developer error and cannot be exploited by untrusted external actors.**

### Citations

**File:** crates/aptos-crypto/src/secp256k1_ecdsa.rs (L26-28)
```rust
#[derive(DeserializeKey, Eq, PartialEq, SerializeKey, SilentDebug, SilentDisplay)]
#[key_name("Secp256k1EcdsaPrivateKey")]
pub struct PrivateKey(pub(crate) libsecp256k1::SecretKey);
```

**File:** crates/aptos-crypto-derive/src/lib.rs (L128-143)
```rust
#[proc_macro_derive(SilentDebug)]
pub fn silent_debug(source: TokenStream) -> TokenStream {
    let ast: DeriveInput = syn::parse(source).expect("Incorrect macro input");
    let name = &ast.ident;
    let (impl_generics, ty_generics, where_clause) = ast.generics.split_for_impl();

    quote! {
        // In order to ensure that secrets are never leaked, Debug is elided
        impl #impl_generics ::std::fmt::Debug for #name #ty_generics #where_clause {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                write!(f, "<elided secret for {}>", stringify!(#name))
            }
        }
    }
    .into()
}
```

**File:** crates/aptos-crypto-derive/src/lib.rs (L191-209)
```rust
        impl ::serde::Serialize for #name {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: ::serde::Serializer,
            {
                if serializer.is_human_readable() {
                    self.to_encoded_string()
                        .map_err(<S::Error as ::serde::ser::Error>::custom)
                        .and_then(|str| serializer.serialize_str(&str[..]))
                } else {
                    // See comment in deserialize_key.
                    serializer.serialize_newtype_struct(
                        #name_string,
                        serde_bytes::Bytes::new(&ValidCryptoMaterial::to_bytes(self).as_slice()),
                    )
                }
            }
        }
    }
```

**File:** crates/aptos-logger/src/macros.rs (L152-163)
```rust
    (@ { $(,)* $($out:expr),* }, $($k:ident).+ = $val:expr, $($args:tt)*) => {
        $crate::schema!(
            @ { $($out),*, &$crate::KeyValue::new($crate::__log_stringify!($($k).+), $crate::Value::from_serde(&$val)) },
            $($args)*
        )
    };

    (@ { $(,)* $($out:expr),* }, $($k:ident).+ = $val:expr) => {
        $crate::schema!(
            @ { $($out),*, &$crate::KeyValue::new($crate::__log_stringify!($($k).+), $crate::Value::from_serde(&$val)) },
        )
    };
```

**File:** crates/aptos-logger/src/kv.rs (L36-41)
```rust
#[derive(Clone, Copy)]
pub enum Value<'v> {
    Debug(&'v dyn fmt::Debug),
    Display(&'v dyn fmt::Display),
    Serde(&'v dyn erased_serde::Serialize),
}
```

**File:** crates/aptos-logger/src/aptos_logger.rs (L176-183)
```rust
                    Value::Serde(s) => match serde_json::to_value(s) {
                        Ok(value) => value,
                        Err(e) => {
                            // Log and skip the value that can't be serialized
                            eprintln!("error serializing structured log: {} for key {:?}", e, key);
                            return;
                        },
                    },
```

**File:** crates/aptos-crypto/src/traits/mod.rs (L101-104)
```rust
    /// A function to encode into hex-string after serializing.
    fn to_encoded_string(&self) -> Result<String> {
        Ok(format!("0x{}", ::hex::encode(self.to_bytes())))
    }
```
