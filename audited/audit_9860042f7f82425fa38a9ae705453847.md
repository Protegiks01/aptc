# Audit Report

## Title
Missing Constant-Time Verification for Secret-Dependent Cryptographic Operations in Batch Encryption

## Summary
The `aptos-batch-encryption` crate performs scalar multiplication with validator secret shares in `derive_decryption_key_share()` but lacks constant-time verification tests. While Criterion benchmarks measure performance, they cannot detect timing side-channels that could leak secret information. The codebase has established constant-time testing infrastructure (dudect) used elsewhere but not applied here.

## Finding Description

The batch encryption system performs cryptographic operations with secret validator key shares during consensus block decryption. Specifically, `BIBEMasterSecretKeyShare::derive_decryption_key_share()` performs elliptic curve scalar multiplication where the scalar is a secret Shamir share: [1](#0-0) 

This operation is called in the production consensus decryption pipeline: [2](#0-1) 

The benchmarks use Criterion, which measures wall-clock time for performance optimization: [3](#0-2) 

Criterion cannot detect whether operations execute in constant time relative to secret inputs. The codebase already has proper constant-time testing infrastructure using the dudect statistical framework: [4](#0-3) 

The pepper service enforces constant-time verification at startup: [5](#0-4) 

However, this verification only covers `blstrs` and `zkcrypto` libraries, not the `arkworks` library used by batch-encryption. The secure coding guidelines mandate using only `aptos-crypto` primitives: [6](#0-5) 

Yet the batch-encryption crate uses arkworks directly without constant-time verification.

## Impact Explanation

**High Severity** - This represents a significant protocol security gap. If the underlying arkworks scalar multiplication implementation is variable-time (timing-dependent on scalar values), an attacker with timing oracle access could potentially:

1. Observe timing variations in validator `derive_decryption_key_share()` operations
2. Extract statistical information about secret Shamir share values  
3. With sufficient observations across multiple validators, potentially reconstruct threshold shares
4. Compromise the batch encryption scheme used for encrypted transactions

This violates **Cryptographic Correctness** (Invariant #10) and could enable unauthorized transaction decryption. While not an immediate consensus safety break, it undermines the security foundation of the encrypted transaction system.

## Likelihood Explanation

**Medium Likelihood** - The attack requires:

1. **Variable-time implementation**: Arkworks may use optimized variable-time algorithms (indicated by the existence of only blstrs/zkcrypto constant-time tests, not arkworks)
2. **Timing oracle access**: Network-level timing measurements or validator co-location
3. **Statistical analysis**: Sophisticated cryptanalysis over many observations
4. **Threshold breach**: Compromising enough validator shares

The sophisticated nature of timing attacks makes this less likely than direct vulnerabilities, but the missing security verification represents a concerning gap in defense-in-depth, especially given that the proper testing infrastructure exists but is unused.

## Recommendation

1. **Add dudect-based constant-time tests** for batch-encryption scalar multiplication operations, similar to existing tests for blstrs:

```rust
// In crates/aptos-batch-encryption/src/constant_time/mod.rs
pub mod arkworks_scalar_mul;

// Run dudect statistical tests on BIBEMasterSecretKeyShare::derive_decryption_key_share
```

2. **Verify arkworks constant-time properties** or migrate to proven constant-time implementations if variable-time behavior is confirmed

3. **Add startup verification** in consensus nodes similar to pepper service verification

4. **Document cryptographic security properties** of all operations handling secret key material

5. **Audit all arkworks usage** to ensure secret-dependent operations are constant-time

## Proof of Concept

A complete PoC demonstrating exploitable timing leakage cannot be provided without:
1. Confirming arkworks scalar multiplication is variable-time through implementation analysis
2. Building a timing oracle infrastructure
3. Performing statistical timing attack analysis

However, the testing gap can be demonstrated by showing that running the existing benchmarks provides no constant-time assurance:

```bash
# This measures performance but NOT constant-time properties
cargo bench --bench fptx -- derive_decryption_key_share

# The proper constant-time test that SHOULD exist but doesn't:
cargo test --release test_arkworks_derive_key_share_is_constant_time -- --ignored --nocapture
```

The absence of the second test represents the security verification gap.

## Notes

This finding highlights a **testing and verification gap** rather than a confirmed exploitable vulnerability. The actual exploitability depends on whether arkworks implementations are variable-time, which requires deeper analysis. However, the inconsistent application of constant-time verification (present for blstrs/zkcrypto, absent for arkworks) in secret-handling operations represents a security hardening opportunity that should be addressed given the critical nature of validator key material.

### Citations

**File:** crates/aptos-batch-encryption/src/shared/key_derivation.rs (L107-115)
```rust
    pub fn derive_decryption_key_share(&self, digest: &Digest) -> Result<BIBEDecryptionKeyShare> {
        let hashed_encryption_key: G1Affine = symmetric::hash_g2_element(self.mpk_g2)?;

        Ok((self.player, BIBEDecryptionKeyShareValue {
            signature_share_eval: G1Affine::from(
                (digest.as_g1() + hashed_encryption_key) * self.shamir_share_eval,
            ),
        }))
    }
```

**File:** consensus/src/pipeline/decryption_pipeline_builder.rs (L103-103)
```rust
        let derived_key_share = FPTXWeighted::derive_decryption_key_share(&msk_share, &digest)?;
```

**File:** crates/aptos-batch-encryption/benches/fptx.rs (L136-166)
```rust
pub fn derive_decryption_key_share(c: &mut Criterion) {
    let mut group = c.benchmark_group("FPTX::derive_decryption_key_share");
    let batch_size = 128;

    for n in [128, 256, 512, 1024] {
        let t = n * 2 / 3 + 1;
        let mut rng = thread_rng();
        let tc = ShamirThresholdConfig::new(t, n);
        let (ek, dk, _, msk_shares) =
            FPTX::setup_for_testing(rng.r#gen(), batch_size, 1, &tc).unwrap();

        let msg: String = String::from("hi");
        let associated_data = String::from("");

        let cts: Vec<<FPTX as BatchThresholdEncryption>::Ciphertext> = (0..batch_size)
            .map(|_| FPTX::encrypt(&ek, &mut rng, &msg, &associated_data).unwrap())
            .collect();

        let (d, _) = FPTX::digest(&dk, &cts, 0).unwrap();

        let msk_share = &msk_shares[0];

        group.bench_with_input(
            BenchmarkId::from_parameter(format!("n={}, t={}", n, t)),
            &(msk_share, d),
            |b, input| {
                b.iter(|| FPTX::derive_decryption_key_share(input.0, &input.1));
            },
        );
    }
}
```

**File:** crates/aptos-crypto/src/constant_time/blstrs_scalar_mul.rs (L16-26)
```rust
/// Runs a statistical test to check that blst's scalar multiplication on G1 is constant time
/// This function pick random bases for all scalar multiplications.
pub fn run_bench_with_random_bases(runner: &mut CtRunner, rng: &mut BenchRng) {
    build_and_run_bench(runner, rng, true, N);
}

/// Runs a statistical test to check that blst's scalar multiplication on G1 is constant time
/// This function keeps the multiplied base the same: the generator of G1.
pub fn run_bench_with_fixed_bases(runner: &mut CtRunner, rng: &mut BenchRng) {
    build_and_run_bench(runner, rng, false, N);
}
```

**File:** keyless/pepper/service/src/main.rs (L402-410)
```rust
    // Verify constant-time scalar multiplication if in production.
    if args.local_development_mode {
        info!(
            "Constant-time scalar multiplication verification skipped in local development mode."
        );
    } else {
        info!("Verifying constant-time scalar multiplication...");
        verify_constant_time_scalar_multiplication();
    }
```

**File:** RUST_SECURE_CODING.md (L136-137)
```markdown

Use exclusively the cryptographic primitives exposed by the `aptos-crypto` crate.
```
