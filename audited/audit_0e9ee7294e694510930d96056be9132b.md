# Audit Report

## Title
Memory Exhaustion via Unbounded RandomizedPKs Deserialization in DKG Randomness Protocol

## Summary
The `RandomizedPKs` struct uses derived `Serialize`/`Deserialize` traits without pre-deserialization size validation, allowing a malicious validator to send oversized `rks` vectors that cause memory exhaustion on peer validators before validation occurs.

## Finding Description

The `RandomizedPKs` struct in the Pinkas weighted VUF implementation lacks size validation before deserialization. [1](#0-0) 

During the randomness generation protocol, validators exchange `AugmentedData` containing `RandomizedPKs` (delta). When peer validators receive these messages, deserialization occurs via unbounded BCS deserialization before any size checks. [2](#0-1) 

The attack path is:

1. **Message Creation**: Malicious validator creates `AugmentedData` with a `RandomizedPKs` containing `pi: G1Projective` (48 bytes) and `rks: Vec<G1Projective>` with ~1.4 million elements (approaching the 64 MiB network limit). [3](#0-2) 

2. **Network Transmission**: The oversized message is sent to peer validators through the randomness protocol.

3. **Unbounded Deserialization**: Receiving validators deserialize the `AugmentedData`, which allocates memory for the entire `rks` vector (up to 64 MB) during BCS deserialization. Each `G1Projective` requires 48 bytes in compressed form.

4. **Delayed Validation**: Only AFTER deserialization and memory allocation does validation occur in `derive_apk`, which calls `augment_pubkey`. [4](#0-3) 

5. **Length Check Fails**: The `augment_pubkey` function checks if `delta.rks.len() == pk.len()`, where `pk.len()` is the legitimate share count (typically 1-1000 based on validator weight). [5](#0-4) 

6. **Memory Already Allocated**: The validation fails and returns an error, but 64 MB has already been allocated and must be freed. Repeated attacks exhaust memory.

**Invariant Violation**: This breaks Invariant #9 (Resource Limits) - the deserialization process does not respect memory constraints, allowing unbounded allocation before validation.

**Expected vs. Malicious Behavior**:
- Expected: `rks.len()` equals validator weight (1-1000 elements, ~48 KB - 48 KB)
- Malicious: `rks.len()` â‰ˆ 1,398,102 elements (64 MB)
- Amplification: 1000x-1,000,000x

## Impact Explanation

This is **High Severity** per Aptos bug bounty criteria because it enables "Validator node slowdowns" through memory exhaustion attacks. A malicious validator can:

- Send multiple oversized `AugmentedData` messages to peer validators
- Force allocation of 64 MB per message before validation rejects it
- Cause memory pressure, slowdowns, and potential node crashes
- Disrupt consensus if enough validators are affected simultaneously

The impact is not Critical because:
- Requires malicious validator access (not exploitable by unprivileged users)
- Does not directly compromise consensus safety or steal funds
- Memory is eventually freed after validation fails
- Requires sustained attack to maintain impact

However, it qualifies as High Severity because memory exhaustion can degrade validator performance and potentially cause crashes, affecting network health under BFT assumptions (up to 1/3 Byzantine validators).

## Likelihood Explanation

**Likelihood: Medium-High**

The attack is likely to occur because:
- **Low Technical Barrier**: Creating oversized vectors is trivial for a malicious validator
- **No Rate Limiting**: The code shows no rate limiting on `AugmentedData` messages
- **BFT Assumption**: Aptos assumes up to 1/3 malicious validators, making this threat model realistic
- **Detectable but Not Preventable**: Victims can detect the attack after deserialization, but memory has already been allocated

The attack requires:
- Malicious validator with network access (satisfied under BFT threat model)
- Ability to send messages during randomness protocol epochs
- No specialized knowledge - basic understanding of serialization

## Recommendation

Implement pre-deserialization size validation for `RandomizedPKs`. Add a custom `Deserialize` implementation that checks vector length before allocating memory:

```rust
// In crates/aptos-dkg/src/weighted_vuf/pinkas/mod.rs

// Add after line 42
const MAX_RKS_LENGTH: usize = 10000; // Conservative upper bound based on max validator weight

impl<'de> Deserialize<'de> for RandomizedPKs {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::{self, SeqAccess, Visitor};
        
        struct RandomizedPKsVisitor;
        
        impl<'de> Visitor<'de> for RandomizedPKsVisitor {
            type Value = RandomizedPKs;
            
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RandomizedPKs")
            }
            
            fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>
            where
                A: SeqAccess<'de>,
            {
                let pi = seq.next_element()?
                    .ok_or_else(|| de::Error::invalid_length(0, &self))?;
                    
                let rks_len = seq.size_hint().unwrap_or(0);
                if rks_len > MAX_RKS_LENGTH {
                    return Err(de::Error::custom(format!(
                        "rks length {} exceeds maximum {}", 
                        rks_len, 
                        MAX_RKS_LENGTH
                    )));
                }
                
                let rks = seq.next_element()?
                    .ok_or_else(|| de::Error::invalid_length(1, &self))?;
                    
                Ok(RandomizedPKs { pi, rks })
            }
        }
        
        deserializer.deserialize_struct(
            "RandomizedPKs",
            &["pi", "rks"],
            RandomizedPKsVisitor,
        )
    }
}
```

Alternatively, add validation at the network layer before BCS deserialization by checking the serialized size and rejecting oversized messages.

## Proof of Concept

```rust
// Add to crates/aptos-dkg/src/weighted_vuf/pinkas/mod.rs test module

#[cfg(test)]
mod security_tests {
    use super::*;
    use blstrs::G1Projective;
    use group::Group;
    
    #[test]
    fn test_oversized_randomized_pks_memory_exhaustion() {
        // Simulate malicious validator creating oversized RandomizedPKs
        let malicious_rks_count = 1_000_000; // 1 million elements
        
        let pi = G1Projective::generator();
        let mut rks = Vec::with_capacity(malicious_rks_count);
        for _ in 0..malicious_rks_count {
            rks.push(G1Projective::generator());
        }
        
        let malicious_rpks = RandomizedPKs { pi, rks };
        
        // Serialize (this is what attacker sends)
        let serialized = bcs::to_bytes(&malicious_rpks).unwrap();
        println!("Serialized size: {} bytes ({} MB)", 
                 serialized.len(), 
                 serialized.len() / (1024 * 1024));
        
        // Deserialize (this is what victim does)
        // This allocates ~48 MB before any validation
        let start_mem = std::mem::size_of_val(&serialized);
        let deserialized: RandomizedPKs = bcs::from_bytes(&serialized).unwrap();
        let end_mem = std::mem::size_of_val(&deserialized.rks) * deserialized.rks.len();
        
        println!("Memory allocated during deserialization: {} bytes ({} MB)",
                 end_mem,
                 end_mem / (1024 * 1024));
        
        // Validation only happens here, AFTER memory allocation
        // In real code, augment_pubkey would check: delta.rks.len() == pk.len()
        // where pk.len() is typically 1-1000, so this would fail
        assert!(deserialized.rks.len() > 1000, 
                "Malicious oversized vector successfully deserialized");
    }
}
```

**Notes**:
- The vulnerability is exploitable under the BFT threat model assuming up to 1/3 malicious validators
- Individual `G1Projective` deserialization includes curve/subgroup validation, but vector length is unchecked [6](#0-5) 
- Network layer has 64 MiB message size limit, but this still allows ~1.4M element vectors
- Current legitimate use cases have rks vectors with 1-1000 elements based on validator weights derived from stakes [7](#0-6)

### Citations

**File:** crates/aptos-dkg/src/weighted_vuf/pinkas/mod.rs (L38-42)
```rust
#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub struct RandomizedPKs {
    pi: G1Projective,       // \hat{g}^{r}
    rks: Vec<G1Projective>, // g^{r \sk_i}, for all shares i
}
```

**File:** crates/aptos-dkg/src/weighted_vuf/pinkas/mod.rs (L114-120)
```rust
        if delta.rks.len() != pk.len() {
            bail!(
                "Expected PKs and RKs to be of the same length. Got {} and {}, respectively.",
                delta.rks.len(),
                pk.len()
            );
        }
```

**File:** consensus/src/rand/rand_gen/types.rs (L46-49)
```rust
pub struct AugmentedData {
    delta: Delta,
    fast_delta: Option<Delta>,
}
```

**File:** consensus/src/rand/rand_gen/types.rs (L656-659)
```rust
    fn derive_apk(&self, peer: &Author, delta: Delta) -> anyhow::Result<APK> {
        let apk = WVUF::augment_pubkey(&self.vuf_pp, self.get_pk_share(peer).clone(), delta)?;
        Ok(apk)
    }
```

**File:** network/framework/src/constants.rs (L21-21)
```rust
pub const MAX_MESSAGE_SIZE: usize = 64 * 1024 * 1024; /* 64 MiB */
```

**File:** crates/aptos-dkg/src/pvss/das/weighted_protocol.rs (L86-89)
```rust
        // NOTE: The `serde` implementation in `blstrs` already performs the necessary point validation
        // by ultimately calling `GroupEncoding::from_bytes`.
        bcs::from_bytes::<Transcript>(bytes).map_err(|_| CryptoMaterialError::DeserializationError)
    }
```

**File:** types/src/dkg/real_dkg/rounding/mod.rs (L98-106)
```rust
        let wconfig = WeightedConfigBlstrs::new(
            profile.reconstruct_threshold_in_weights as usize,
            profile
                .validator_weights
                .iter()
                .map(|w| *w as usize)
                .collect(),
        )
        .unwrap();
```
