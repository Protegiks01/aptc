# Audit Report

## Title
JWK Consensus Config Buffer Overwrite During DKG-Based Reconfiguration

## Summary
Multiple JWK consensus configuration proposals can execute within the same epoch when DKG-based reconfiguration is enabled, causing later proposals to silently overwrite earlier proposals' buffered configurations without validation. This results in governance-approved configurations being lost and never applied to the blockchain.

## Finding Description

The vulnerability occurs in the interaction between the JWK consensus config buffering mechanism and the asynchronous DKG-based reconfiguration process.

**Root Cause:**

When `generate_jwk_consensus_config_update_proposal()` generates a governance proposal, it produces a script that:
1. Calls `jwk_consensus_config::set_for_next_epoch()` to buffer a configuration
2. Calls `aptos_governance::reconfigure()` to trigger epoch transition [1](#0-0) 

The `set_for_next_epoch()` function directly calls `config_buffer::upsert()` without any validation: [2](#0-1) 

The `config_buffer::upsert()` function uses `simple_map::upsert()` which silently overwrites any existing buffered value: [3](#0-2) 

When DKG-based reconfiguration is enabled, `aptos_governance::reconfigure()` calls `try_start()` instead of `finish()`: [4](#0-3) 

The `try_start()` function initiates DKG but does NOT immediately complete the epoch transition. If called again while DKG is already in progress for the current epoch, it returns early without error: [5](#0-4) 

**Attack Scenario:**

1. **Epoch N, Block B1**: Multi-step Proposal A, Step 1 executes:
   - Buffers JWK config A via `config_buffer::upsert()`
   - Calls `reconfigure()` which invokes `try_start()`, initiating DKG
   - Epoch remains N, reconfiguration state becomes "in progress"

2. **Epoch N, Block B2** (DKG still running): Proposal A Step 2 OR separate Proposal B executes:
   - Buffers JWK config B via `config_buffer::upsert()`, **overwriting config A**
   - Calls `reconfigure()` which invokes `try_start()` again
   - `try_start()` detects DKG already in progress for epoch N, returns early
   - No error is raised; the proposal appears to succeed

3. **Later**: DKG completes, `finish()` is called:
   - Extracts the buffered config via `config_buffer::extract_v2()`
   - Only config B exists in the buffer; **config A was lost** [6](#0-5) 

**Invariant Violation:**

This breaks the **Governance Integrity** invariant: approved governance proposals must execute as voted upon. The blockchain applies a different configuration than what was approved by governance, silently discarding legitimate governance decisions.

There is no mechanism preventing governance proposal execution during reconfiguration - `reconfiguration_state::is_in_progress()` is only checked in the staking module, not in governance or config modules: [7](#0-6) 

## Impact Explanation

**Severity: High** (up to $50,000 per Aptos Bug Bounty)

This qualifies as a **"Significant protocol violation"** under High Severity criteria because:

1. **Governance Integrity Compromise**: Governance-approved proposals are silently ignored, undermining the blockchain's governance mechanism
2. **Silent Failure**: No error is raised; proposals appear to execute successfully while their configurations are discarded
3. **Consensus Impact**: JWK consensus configs control JSON Web Key validation for authentication, affecting consensus security
4. **Non-deterministic Behavior**: Which proposal "wins" depends on execution timing, not governance rules

This could lead to:
- Security configurations being silently not applied
- Validators operating under different assumptions about active configurations
- Loss of trust in the governance system

## Likelihood Explanation

**Likelihood: Medium-High**

This vulnerability occurs when:
1. The `RECONFIGURE_WITH_DKG` feature is enabled (production configuration)
2. Multiple JWK config proposals pass governance within a short timeframe
3. Both execute within the same epoch while DKG is running

**Factors increasing likelihood:**
- DKG sessions can span multiple blocks (typically several seconds to minutes)
- Multi-step proposals are specifically designed to execute across multiple transactions
- No warning or error is raised when configs are overwritten
- Governance participants have no visibility into the buffer state

**Factors decreasing likelihood:**
- Requires multiple JWK config proposals to be approved and executed in rapid succession
- Governance voting typically has delays between proposals

## Recommendation

**Option 1: Prevent buffer overwrites (Recommended)**

Add a check in `config_buffer::upsert()` to abort if a value is already buffered:

```move
public(friend) fun upsert<T: drop + store>(config: T) acquires PendingConfigs {
    let configs = borrow_global_mut<PendingConfigs>(@aptos_framework);
    let key = type_info::type_name<T>();
    
    // Abort if already buffered to prevent silent overwrites
    assert!(
        !simple_map::contains_key(&configs.configs, &key),
        error::already_exists(ECONFIG_ALREADY_BUFFERED)
    );
    
    let value = any::pack(config);
    simple_map::add(&mut configs.configs, key, value);
}
```

**Option 2: Block governance execution during reconfiguration**

Add a check in `resolve()` and `resolve_multi_step_proposal()`:

```move
public fun resolve_multi_step_proposal(...) {
    assert!(
        !reconfiguration_state::is_in_progress(),
        error::invalid_state(ERECONFIGURATION_IN_PROGRESS)
    );
    // ... rest of function
}
```

**Option 3: Make `try_start()` abort instead of silently returning**

Modify `try_start()` to abort if reconfiguration is already in progress for the current epoch, making the second proposal fail explicitly rather than silently.

## Proof of Concept

```move
#[test(framework = @aptos_framework)]
fun test_jwk_config_buffer_overwrite(framework: &signer) {
    use aptos_framework::jwk_consensus_config;
    use aptos_framework::config_buffer;
    use aptos_framework::reconfiguration_with_dkg;
    use aptos_framework::reconfiguration_state;
    use std::features;
    use std::string::utf8;
    
    // Initialize required modules
    features::change_feature_flags_for_testing(
        framework, 
        vector[features::get_reconfigure_with_dkg_feature()], 
        vector[]
    );
    reconfiguration_state::initialize_for_testing(framework);
    config_buffer::initialize(framework);
    jwk_consensus_config::initialize(framework, jwk_consensus_config::new_off());
    
    // Create two different JWK configs
    let config_a = jwk_consensus_config::new_v1(vector[
        jwk_consensus_config::new_oidc_provider(utf8(b"ProviderA"), utf8(b"https://a.com"))
    ]);
    let config_b = jwk_consensus_config::new_v1(vector[
        jwk_consensus_config::new_oidc_provider(utf8(b"ProviderB"), utf8(b"https://b.com"))
    ]);
    
    // Proposal 1: Set config A and start DKG
    jwk_consensus_config::set_for_next_epoch(framework, config_a);
    assert!(config_buffer::does_exist<JWKConsensusConfig>(), 1);
    reconfiguration_with_dkg::try_start(); // Starts DKG, doesn't finish epoch
    
    // Verify reconfiguration is in progress
    assert!(reconfiguration_state::is_in_progress(), 2);
    
    // Proposal 2: Set config B in the same epoch (overwrites A!)
    jwk_consensus_config::set_for_next_epoch(framework, config_b);
    reconfiguration_with_dkg::try_start(); // Returns early, no error
    
    // Complete the reconfiguration
    reconfiguration_with_dkg::finish(framework);
    
    // BUG: Only config B was applied, config A was lost
    // Expected: Both configs should be applied OR second should abort
    // Actual: config_a silently discarded without error
}
```

## Notes

This vulnerability only manifests when the `RECONFIGURE_WITH_DKG` feature flag is enabled. With synchronous reconfiguration (DKG disabled), `reconfigure()` immediately calls `finish()` which extracts and applies the buffered config, transitioning to the next epoch before any subsequent proposal can execute.

The issue affects all on-chain configs using the `config_buffer` pattern, not just JWK consensus configs. Other affected configs include: `ConsensusConfig`, `ExecutionConfig`, `GasSchedule`, `Features`, `JWKs`, `KeylessAccount`, and randomness-related configs.

### Citations

**File:** aptos-move/aptos-release-builder/src/components/jwk_consensus_config.rs (L39-44)
```rust
                        "jwk_consensus_config::set_for_next_epoch({}, config);",
                        signer_arg
                    );
                },
            }
            emitln!(writer, "aptos_governance::reconfigure({});", signer_arg);
```

**File:** aptos-move/framework/aptos-framework/sources/configs/jwk_consensus_config.move (L62-65)
```text
    public fun set_for_next_epoch(framework: &signer, config: JWKConsensusConfig) {
        system_addresses::assert_aptos_framework(framework);
        config_buffer::upsert(config);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/config_buffer.move (L65-70)
```text
    public(friend) fun upsert<T: drop + store>(config: T) acquires PendingConfigs {
        let configs = borrow_global_mut<PendingConfigs>(@aptos_framework);
        let key = type_info::type_name<T>();
        let value = any::pack(config);
        simple_map::upsert(&mut configs.configs, key, value);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L685-692)
```text
    public entry fun reconfigure(aptos_framework: &signer) {
        system_addresses::assert_aptos_framework(aptos_framework);
        if (consensus_config::validator_txn_enabled() && randomness_config::enabled()) {
            reconfiguration_with_dkg::try_start();
        } else {
            reconfiguration_with_dkg::finish(aptos_framework);
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/reconfiguration_with_dkg.move (L24-40)
```text
    public(friend) fun try_start() {
        let incomplete_dkg_session = dkg::incomplete_session();
        if (option::is_some(&incomplete_dkg_session)) {
            let session = option::borrow(&incomplete_dkg_session);
            if (dkg::session_dealer_epoch(session) == reconfiguration::current_epoch()) {
                return
            }
        };
        reconfiguration_state::on_reconfig_start();
        let cur_epoch = reconfiguration::current_epoch();
        dkg::start(
            cur_epoch,
            randomness_config::current(),
            stake::cur_validator_consensus_infos(),
            stake::next_validator_consensus_infos(),
        );
    }
```

**File:** aptos-move/framework/aptos-framework/sources/reconfiguration_with_dkg.move (L46-61)
```text
    public(friend) fun finish(framework: &signer) {
        system_addresses::assert_aptos_framework(framework);
        dkg::try_clear_incomplete_session(framework);
        consensus_config::on_new_epoch(framework);
        execution_config::on_new_epoch(framework);
        gas_schedule::on_new_epoch(framework);
        std::version::on_new_epoch(framework);
        features::on_new_epoch(framework);
        jwk_consensus_config::on_new_epoch(framework);
        jwks::on_new_epoch(framework);
        keyless_account::on_new_epoch(framework);
        randomness_config_seqnum::on_new_epoch(framework);
        randomness_config::on_new_epoch(framework);
        randomness_api_v0_config::on_new_epoch(framework);
        reconfiguration::reconfigure();
    }
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1910-1912)
```text
    fun assert_reconfig_not_in_progress() {
        assert!(!reconfiguration_state::is_in_progress(), error::invalid_state(ERECONFIGURATION_IN_PROGRESS));
    }
```
