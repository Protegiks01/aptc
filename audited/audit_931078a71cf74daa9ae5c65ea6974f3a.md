# Audit Report

## Title
Consensus DoS via Unchecked Author Address in SecretShare Verification Leading to Validator Crashes

## Summary
The `get_id()` function in `types/src/secret_sharing.rs` uses `.expect()` to retrieve validator indices, causing a panic when processing SecretShare messages with invalid author addresses. This panic triggers the global crash handler, terminating validator nodes. A malicious validator can exploit this to cause repeated crashes of honest validators, leading to consensus liveness failure.

## Finding Description

The vulnerability exists in the secret sharing verification flow during consensus rounds. When validators exchange SecretShare messages as part of the consensus protocol, the receiving validator must verify the cryptographic validity of incoming shares. [1](#0-0) 

The `get_id()` function assumes all authors are present in the validator set and uses `.expect()` which panics if the lookup fails. During verification, this function is called without prior validation of the author address: [2](#0-1) 

The attack propagates through the consensus verification pipeline:

1. Incoming SecretShare messages are received via the network layer and queued for verification: [3](#0-2) 

2. The `verification_task` deserializes and verifies messages: [4](#0-3) 

3. Verification calls the vulnerable code path: [5](#0-4) 

4. When the panic occurs, the global crash handler terminates the validator process: [6](#0-5) 

The crash handler is installed at validator startup: [7](#0-6) 

**Attack Scenario:**
A malicious validator crafts a SecretShare message with an `author` field set to an AccountAddress not present in the current validator set (e.g., a random address or address from a previous epoch). When honest validators receive this message during consensus, the verification process panics at `get_id()`, triggering process termination. The attacker can repeat this continuously across consensus rounds.

## Impact Explanation

This vulnerability qualifies as **Critical Severity** under the Aptos Bug Bounty program criteria:
- **Total loss of liveness/network availability**: A malicious validator can systematically crash honest validators, preventing the network from reaching consensus and processing transactions
- **Consensus violation**: Repeated validator crashes prevent block finalization, violating the liveness guarantee of AptosBFT consensus

The impact is amplified because:
1. The attack can be executed repeatedly without resource cost to the attacker
2. Each malicious message crashes the target validator, requiring manual restart
3. With 1/3 of validators crashed, consensus cannot make progress
4. Even with fewer crashes, network performance degrades significantly

## Likelihood Explanation

**Likelihood: High**

The attack is highly likely to succeed because:

1. **Low technical barrier**: Crafting a malicious SecretShare only requires setting an invalid author address in the message structure
2. **No cryptographic requirements**: The panic occurs before cryptographic verification, so no valid signatures or proofs are needed
3. **Automated exploitation**: An attacker can automate sending malicious shares continuously
4. **No detection before crash**: There's no pre-validation of the author address before the panic-inducing code path

**However**, this vulnerability requires the attacker to be a validator in the active set, which significantly impacts the realistic threat model. The validation checklist requires "no validator insider access required," which this attack does not satisfy.

## Recommendation

Replace the `.expect()` call with proper error handling:

```rust
pub fn get_id(&self, peer: &Author) -> anyhow::Result<usize> {
    self.validator
        .address_to_validator_index()
        .get(peer)
        .copied()
        .ok_or_else(|| anyhow::anyhow!("Author {:?} not in validator set", peer))
}
```

Update all callers to handle the `Result`:

```rust
pub fn verify(&self, config: &SecretShareConfig) -> anyhow::Result<()> {
    let index = config.get_id(self.author())?;
    let decryption_key_share = self.share().clone();
    ensure!(index < config.verification_keys.len(), "Index out of bounds");
    config.verification_keys[index]
        .verify_decryption_key_share(&self.metadata.digest, &decryption_key_share)?;
    Ok(())
}
```

Additionally, add author validation at message receipt:

```rust
// In verification_task or handle_incoming_msg
ensure!(
    epoch_state.verifier.address_to_validator_index().contains_key(share.author()),
    "Share author not in current validator set"
);
```

## Proof of Concept

```rust
#[cfg(test)]
mod test {
    use super::*;
    use aptos_types::account_address::AccountAddress;
    
    #[test]
    #[should_panic(expected = "Peer should be in the index!")]
    fn test_get_id_panics_on_invalid_author() {
        // Setup: Create a SecretShareConfig with a validator set
        let validator_verifier = create_test_validator_verifier(vec![
            AccountAddress::from_hex_literal("0x1").unwrap(),
            AccountAddress::from_hex_literal("0x2").unwrap(),
        ]);
        
        let config = SecretShareConfig::new(
            /* ... config parameters ... */
            Arc::new(validator_verifier),
            /* ... */
        );
        
        // Attack: Query with an author not in the validator set
        let invalid_author = AccountAddress::from_hex_literal("0x999").unwrap();
        let _ = config.get_id(&invalid_author); // This panics!
    }
    
    #[tokio::test]
    async fn test_malicious_share_crashes_verification() {
        // Setup verification task with real validator set
        let (tx, mut rx) = unbounded();
        let epoch_state = create_test_epoch_state();
        let config = create_test_config();
        
        // Start verification task
        tokio::spawn(async move {
            verification_task(epoch_state, rx, tx, config, executor).await;
        });
        
        // Attack: Send share with invalid author
        let malicious_share = SecretShare::new(
            AccountAddress::from_hex_literal("0x999").unwrap(), // Invalid
            metadata,
            share_data,
        );
        
        let msg = SecretShareMessage::Share(malicious_share);
        
        // This should cause the verification task to panic
        // and with crash handler enabled, crash the process
        send_to_verification_task(msg).await;
    }
}
```

## Notes

**Critical Issue with Scope**: While this vulnerability is technically valid and exploitable, it **fails the validation checklist requirement** that the attack be "exploitable by unprivileged attacker (no validator insider access required)." 

The attack requires a malicious validator to send crafted SecretShare messages through the consensus network, which is restricted to authenticated validators only. Non-validators cannot access this attack surface.

Given the strict validation criteria that exclude insider threats unless explicitly explored, and the explicit requirement for "no validator insider access required," this finding does not meet the reportability threshold despite being a legitimate technical vulnerability.

The TODO comment in the code acknowledges the missing bounds check, but the more critical issue is the panic-on-invalid-input behavior that violates defensive programming principles for consensus-critical code.

### Citations

**File:** types/src/secret_sharing.rs (L75-82)
```rust
    pub fn verify(&self, config: &SecretShareConfig) -> anyhow::Result<()> {
        let index = config.get_id(self.author());
        let decryption_key_share = self.share().clone();
        // TODO(ibalajiarun): Check index out of bounds
        config.verification_keys[index]
            .verify_decryption_key_share(&self.metadata.digest, &decryption_key_share)?;
        Ok(())
    }
```

**File:** types/src/secret_sharing.rs (L172-178)
```rust
    pub fn get_id(&self, peer: &Author) -> usize {
        *self
            .validator
            .address_to_validator_index()
            .get(peer)
            .expect("Peer should be in the index!")
    }
```

**File:** consensus/src/network.rs (L920-936)
```rust
                        ConsensusMsg::SecretShareMsg(req) => {
                            let (tx, _rx) = oneshot::channel();
                            let req_with_callback = IncomingRpcRequest::SecretShareRequest(
                                IncomingSecretShareRequest {
                                    req,
                                    sender: peer_id,
                                    protocol: RPC[0],
                                    response_sender: tx,
                                },
                            );
                            if let Err(e) = self.rpc_tx.push(
                                (peer_id, discriminant(&req_with_callback)),
                                (peer_id, req_with_callback),
                            ) {
                                warn!(error = ?e, "aptos channel closed");
                            };
                        },
```

**File:** consensus/src/rand/secret_sharing/secret_share_manager.rs (L205-235)
```rust
    async fn verification_task(
        epoch_state: Arc<EpochState>,
        mut incoming_rpc_request: aptos_channel::Receiver<Author, IncomingSecretShareRequest>,
        verified_msg_tx: UnboundedSender<SecretShareRpc>,
        config: SecretShareConfig,
        bounded_executor: BoundedExecutor,
    ) {
        while let Some(dec_msg) = incoming_rpc_request.next().await {
            let tx = verified_msg_tx.clone();
            let epoch_state_clone = epoch_state.clone();
            let config_clone = config.clone();
            bounded_executor
                .spawn(async move {
                    match bcs::from_bytes::<SecretShareMessage>(dec_msg.req.data()) {
                        Ok(msg) => {
                            if msg.verify(&epoch_state_clone, &config_clone).is_ok() {
                                let _ = tx.unbounded_send(SecretShareRpc {
                                    msg,
                                    protocol: dec_msg.protocol,
                                    response_sender: dec_msg.response_sender,
                                });
                            }
                        },
                        Err(e) => {
                            warn!("Invalid dec message: {}", e);
                        },
                    }
                })
                .await;
        }
    }
```

**File:** consensus/src/rand/secret_sharing/network_messages.rs (L28-38)
```rust
    pub fn verify(
        &self,
        epoch_state: &EpochState,
        config: &SecretShareConfig,
    ) -> anyhow::Result<()> {
        ensure!(self.epoch() == epoch_state.epoch);
        match self {
            SecretShareMessage::RequestShare(_) => Ok(()),
            SecretShareMessage::Share(share) => share.verify(config),
        }
    }
```

**File:** crates/crash-handler/src/lib.rs (L26-58)
```rust
pub fn setup_panic_handler() {
    panic::set_hook(Box::new(move |pi: &PanicHookInfo<'_>| {
        handle_panic(pi);
    }));
}

// Formats and logs panic information
fn handle_panic(panic_info: &PanicHookInfo<'_>) {
    // The Display formatter for a PanicHookInfo contains the message, payload and location.
    let details = format!("{}", panic_info);
    let backtrace = format!("{:#?}", Backtrace::new());

    let info = CrashInfo { details, backtrace };
    let crash_info = toml::to_string_pretty(&info).unwrap();
    error!("{}", crash_info);
    // TODO / HACK ALARM: Write crash info synchronously via eprintln! to ensure it is written before the process exits which error! doesn't guarantee.
    // This is a workaround until https://github.com/aptos-labs/aptos-core/issues/2038 is resolved.
    eprintln!("{}", crash_info);

    // Wait till the logs have been flushed
    aptos_logger::flush();

    // Do not kill the process if the panics happened at move-bytecode-verifier.
    // This is safe because the `state::get_state()` uses a thread_local for storing states. Thus the state can only be mutated to VERIFIER by the thread that's running the bytecode verifier.
    //
    // TODO: once `can_unwind` is stable, we should assert it. See https://github.com/rust-lang/rust/issues/92988.
    if state::get_state() == VMState::VERIFIER || state::get_state() == VMState::DESERIALIZER {
        return;
    }

    // Kill the process
    process::exit(12);
}
```

**File:** aptos-node/src/lib.rs (L233-234)
```rust
    // Setup panic handler
    aptos_crash_handler::setup_panic_handler();
```
