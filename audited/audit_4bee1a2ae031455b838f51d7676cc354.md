# Audit Report

## Title
Zero Gas Price Validation Bypass Enabling Free Transaction Execution

## Summary
The `min_price_per_gas_unit` validation logic contains a fundamental flaw that fails to reject transactions with `gas_unit_price=0` when `min_price_per_gas_unit` is set to 0. If governance updates the gas schedule to set `min_price_per_gas_unit=0`, attackers can execute unlimited transactions without paying any fees, breaking the blockchain's economic security model.

## Finding Description

The vulnerability exists in the gas price validation check that compares the submitted transaction's gas price against the on-chain minimum: [1](#0-0) 

The check uses a less-than comparison on unsigned integers (u64). When `min_price_per_gas_unit` is 0, the condition `txn_metadata.gas_unit_price() < 0` is **always false** because u64 values cannot be less than zero. This allows transactions with `gas_unit_price=0` to pass validation.

The `min_price_per_gas_unit` parameter is defined with a TODO comment acknowledging this issue: [2](#0-1) 

The default value comes from `aptos_global_constants::GAS_UNIT_PRICE`: [3](#0-2) 

While production defaults to 100, governance can update the gas schedule to any value including 0. The gas schedule update functions contain TODO comments indicating validation is **not implemented**: [4](#0-3) [5](#0-4) 

When transactions with `gas_unit_price=0` execute, the fee calculation in the epilogue results in zero fees: [6](#0-5) 

Evidence from test code confirms this behavior is known: [7](#0-6) 

There is also evidence that zero gas prices bypass certain validation checks: [8](#0-7) 

**Attack Path:**
1. Governance proposes updating the gas schedule with `min_price_per_gas_unit=0` (no validation prevents this)
2. Proposal is approved and executed via `gas_schedule::set_for_next_epoch()`
3. At next epoch, the new gas schedule takes effect
4. Attacker submits transactions with `gas_unit_price=0`
5. Validation check at line 178 passes (0 < 0 = false)
6. Transaction executes consuming computational resources
7. Epilogue calculates `transaction_fee_amount = 0 * gas_used = 0`
8. No fees are burned, attacker receives free computation

## Impact Explanation

**Critical Severity** - This vulnerability enables:

1. **Economic Security Bypass**: Attackers can execute unlimited transactions without paying gas fees, breaking the fundamental economic model that prevents spam and resource exhaustion
2. **Resource Exhaustion**: Free transactions enable network-wide DoS through storage bombing, computation exhaustion, and mempool flooding
3. **Validator Impact**: Validators process transactions without compensation, potentially forcing them offline
4. **State Bloat**: Free storage operations enable unbounded state growth
5. **Invariant Violation**: Breaks Critical Invariant #9 (Resource Limits) and #7 (Transaction Validation)

This qualifies as **Critical** per the bug bounty program because it enables loss of funds (validators work without payment), total loss of liveness (network spam), and consensus violations (deterministic execution breaks if nodes run out of resources at different rates).

## Likelihood Explanation

**Medium-to-High Likelihood:**

1. **Governance Risk**: Gas schedule updates are a routine governance activity. A mistake (wrong parameter value, accidental zero) or malicious proposal could set `min_price_per_gas_unit=0`
2. **No Validation**: Multiple TODO comments confirm that gas schedule consistency checks are **not implemented**, making mistakes easy
3. **Test Mode Default**: In test/development environments, `GAS_UNIT_PRICE` defaults to 0, creating risk if test configurations are deployed
4. **Known Issue**: The TODO comment and test case prove developers are aware this is problematic but haven't fixed it

The vulnerability requires governance action, but governance mistakes are realistic given:
- Complex parameter spaces in gas schedules
- No automated validation preventing zero values
- Pressure to reduce fees (could accidentally set to zero)

## Recommendation

**Immediate Fix:**

1. **Add Validation to Gas Schedule Updates**: Implement the TODO checks to enforce `min_price_per_gas_unit > 0`

```rust
// In gas_schedule.move - implement the TODO checks
public fun set_for_next_epoch(aptos_framework: &signer, gas_schedule_blob: vector<u8>) acquires GasScheduleV2 {
    system_addresses::assert_aptos_framework(aptos_framework);
    assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));
    let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
    
    // NEW: Validate gas schedule consistency
    validate_gas_schedule_consistency(&new_gas_schedule);
    
    if (exists<GasScheduleV2>(@aptos_framework)) {
        let cur_gas_schedule = borrow_global<GasScheduleV2>(@aptos_framework);
        assert!(
            new_gas_schedule.feature_version >= cur_gas_schedule.feature_version,
            error::invalid_argument(EINVALID_GAS_FEATURE_VERSION)
        );
    };
    config_buffer::upsert(new_gas_schedule);
}

fun validate_gas_schedule_consistency(schedule: &GasScheduleV2) {
    // Extract and validate min_price_per_gas_unit from entries
    // assert!(min_price > 0, EINVALID_GAS_SCHEDULE);
    // assert!(min_price <= max_price, EINVALID_GAS_SCHEDULE);
}
```

2. **Fix Validation Logic**: Use a proper check that handles the zero case:

```rust
// In gas.rs - fix the validation check
if txn_metadata.gas_unit_price() < txn_gas_params.min_price_per_gas_unit {
    speculative_warn!(
        log_context,
        format!(
            "[VM] Gas unit error; min {}, submitted {}",
            txn_gas_params.min_price_per_gas_unit,
            txn_metadata.gas_unit_price()
        ),
    );
    return Err(VMStatus::error(
        StatusCode::GAS_UNIT_PRICE_BELOW_MIN_BOUND,
        None,
    ));
}
// Add explicit check for zero if min is zero (defense in depth)
if u64::from(txn_gas_params.min_price_per_gas_unit) == 0 
    && txn_metadata.gas_unit_price().is_zero() {
    // Decide policy: either reject or set a hardcoded minimum
    return Err(VMStatus::error(
        StatusCode::GAS_UNIT_PRICE_BELOW_MIN_BOUND,
        None,
    ));
}
```

3. **Set Production Minimum**: Update the default to enforce `min_price_per_gas_unit >= 1` in all environments

## Proof of Concept

```rust
// Rust PoC demonstrating the validation bypass
#[test]
fn test_zero_min_price_allows_zero_gas_price() {
    use aptos_gas_schedule::TransactionGasParameters;
    use aptos_types::transaction::TransactionMetadata;
    
    // Create gas parameters with min_price = 0
    let mut gas_params = TransactionGasParameters::initial();
    gas_params.min_price_per_gas_unit = FeePerGasUnit::new(0);
    
    // Create transaction with gas_unit_price = 0
    let txn_metadata = TransactionMetadata {
        gas_unit_price: FeePerGasUnit::new(0),
        max_gas_amount: Gas::new(1000000),
        // ... other fields
    };
    
    // Validation check
    let below_min = txn_metadata.gas_unit_price() < gas_params.min_price_per_gas_unit;
    
    // This assertion passes, proving the bypass
    assert!(!below_min); // 0 < 0 = false, so validation passes!
    
    // Fee calculation in epilogue
    let gas_used = 100000u64;
    let transaction_fee_amount = u64::from(txn_metadata.gas_unit_price) * gas_used;
    
    // This assertion passes, proving free execution
    assert_eq!(transaction_fee_amount, 0); // 0 * 100000 = 0
}
```

**Move PoC - Governance Proposal Exploit:**

```move
// Governance proposal script to set min_price_per_gas_unit to 0
script {
    use aptos_framework::gas_schedule;
    use aptos_framework::aptos_governance;
    
    fun exploit_zero_min_price(framework: signer) {
        // Craft gas schedule with min_price_per_gas_unit = 0
        let malicious_gas_schedule = create_gas_schedule_with_zero_min_price();
        
        // No validation prevents this!
        gas_schedule::set_for_next_epoch(&framework, malicious_gas_schedule);
        aptos_governance::reconfigure(&framework);
        
        // After next epoch, attackers can submit transactions with gas_price=0
    }
}
```

## Notes

This vulnerability requires governance action to trigger, but represents a **critical design flaw** in the validation logic that cannot enforce a minimum gas price of zero. The multiple TODO comments and lack of validation in gas schedule updates create realistic risk of misconfiguration. The fix requires both improving validation logic and implementing proper gas schedule consistency checks that were explicitly marked as TODO items.

### Citations

**File:** aptos-move/aptos-vm/src/gas.rs (L174-192)
```rust
    // The submitted gas price is less than the minimum gas unit price set by the VM.
    // NB: MIN_PRICE_PER_GAS_UNIT may equal zero, but need not in the future. Hence why
    // we turn off the clippy warning.
    #[allow(clippy::absurd_extreme_comparisons)]
    let below_min_bound = txn_metadata.gas_unit_price() < txn_gas_params.min_price_per_gas_unit;
    if below_min_bound {
        speculative_warn!(
            log_context,
            format!(
                "[VM] Gas unit error; min {}, submitted {}",
                txn_gas_params.min_price_per_gas_unit,
                txn_metadata.gas_unit_price()
            ),
        );
        return Err(VMStatus::error(
            StatusCode::GAS_UNIT_PRICE_BELOW_MIN_BOUND,
            None,
        ));
    }
```

**File:** aptos-move/aptos-vm/src/gas.rs (L210-219)
```rust
    // If this is for a potentially new account, ensure there's enough gas to cover storage, execution, and IO costs.
    // TODO: This isn't the cleaning code, thus we localize it just here and will remove it
    // once accountv2 is available and we no longer need to create accounts.
    let gas_unit_price: u64 = txn_metadata.gas_unit_price().into();
    if crate::aptos_vm::should_create_account_resource(
        txn_metadata,
        features,
        resolver,
        module_storage,
    )? && (gas_unit_price != 0 || !features.is_default_account_resource_enabled())
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L59-65)
```rust
        // The minimum gas price that a transaction can be submitted with.
        // TODO(Gas): should probably change this to something > 0
        [
            min_price_per_gas_unit: FeePerGasUnit,
            "min_price_per_gas_unit",
            aptos_global_constants::GAS_UNIT_PRICE
        ],
```

**File:** config/global-constants/src/lib.rs (L20-26)
```rust
// TODO(Gas): double check if this right
// Definitions of global gas constants

#[cfg(any(test, feature = "testing"))]
pub const GAS_UNIT_PRICE: u64 = 0;
#[cfg(not(any(test, feature = "testing")))]
pub const GAS_UNIT_PRICE: u64 = 100;
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L42-50)
```text
    /// Only called during genesis.
    public(friend) fun initialize(aptos_framework: &signer, gas_schedule_blob: vector<u8>) {
        system_addresses::assert_aptos_framework(aptos_framework);
        assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));

        // TODO(Gas): check if gas schedule is consistent
        let gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
        move_to<GasScheduleV2>(aptos_framework, gas_schedule);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L62-77)
```text
        if (exists<GasScheduleV2>(@aptos_framework)) {
            let gas_schedule = borrow_global_mut<GasScheduleV2>(@aptos_framework);
            let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
            assert!(new_gas_schedule.feature_version >= gas_schedule.feature_version,
                error::invalid_argument(EINVALID_GAS_FEATURE_VERSION));
            // TODO(Gas): check if gas schedule is consistent
            *gas_schedule = new_gas_schedule;
        }
        else {
            if (exists<GasSchedule>(@aptos_framework)) {
                _ = move_from<GasSchedule>(@aptos_framework);
            };
            let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
            // TODO(Gas): check if gas schedule is consistent
            move_to<GasScheduleV2>(aptos_framework, new_gas_schedule);
        };
```

**File:** aptos-move/framework/aptos-framework/sources/transaction_validation.move (L596-603)
```text
        assert!(txn_max_gas_units >= gas_units_remaining, error::invalid_argument(EOUT_OF_GAS));
        let gas_used = txn_max_gas_units - gas_units_remaining;

        assert!(
            (txn_gas_price as u128) * (gas_used as u128) <= MAX_U64,
            error::out_of_range(EOUT_OF_GAS)
        );
        let transaction_fee_amount = txn_gas_price * gas_used;
```

**File:** vm-validator/src/unit_tests/vm_validator_test.rs (L252-278)
```rust
// NB: This test is designed to fail if/when we bump the minimum gas price to be non-zero. You will
// then need to update this price here in order to make the test pass -- uncomment the commented
// out assertion and remove the current failing assertion in this case.
#[test]
fn test_validate_max_gas_price_below_bounds() {
    let vm_validator = TestValidator::new();

    let address = account_config::aptos_test_root_address();
    let program = aptos_stdlib::aptos_coin_transfer(address, 100);
    let transaction = transaction_test_helpers::get_test_signed_transaction(
        address,
        1,
        &aptos_vm_genesis::GENESIS_KEYPAIR.0,
        aptos_vm_genesis::GENESIS_KEYPAIR.1.clone(),
        Some(program),
        // Initial Time was set to 0 with a TTL 86400 secs.
        40000,
        0, /* max gas price */
        None,
    );
    let ret = vm_validator.validate_transaction(transaction).unwrap();
    assert_eq!(ret.status(), None);
    //assert_eq!(
    //    ret.status().unwrap().major_status,
    //    StatusCode::GAS_UNIT_PRICE_BELOW_MIN_BOUND
    //);
}
```
