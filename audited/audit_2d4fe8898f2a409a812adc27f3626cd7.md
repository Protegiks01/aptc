# Audit Report

## Title
Consensus Observer Block Store Manipulation via Unverified Future Epoch Commit Decisions

## Summary
A malicious subscribed peer can send commit decisions with crafted epoch/round values for future epochs, bypassing signature verification and causing the consensus observer to incorrectly manipulate its block store. This leads to state inconsistency and liveness failures on observer nodes.

## Finding Description

The consensus observer processes commit decisions differently based on their epoch, creating a critical verification bypass for future epoch commits.

**Verification Bypass for Future Epochs:**

When processing commit decisions, the code only verifies signatures if the commit epoch matches the current epoch: [1](#0-0) 

For future epoch commits (line 503-527), the code explicitly skips verification and directly processes the unverified commit decision: [2](#0-1) 

The TODO comment at line 497 acknowledges this problematic handling: "identify the best way to handle an invalid commit decision for a future epoch."

**Dangerous Block Store Manipulation:**

The unverified commit decision is passed to `update_blocks_for_state_sync_commit()`, which updates the root ledger info and removes blocks: [3](#0-2) 

The `remove_blocks_for_commit()` function uses `BTreeMap::split_off()` with attacker-controlled epoch/round values: [4](#0-3) 

**Attack Scenarios:**

1. **Remove ALL blocks**: Attacker sends `CommitDecision` with `epoch = u64::MAX, round = u64::MAX`. The `split_off(&(u64::MAX, u64::MAX))` returns an empty map since no blocks have epoch/round >= u64::MAX. Assignment at lines 118-120 replaces `ordered_blocks` with this empty map, losing all pending blocks.

2. **Remove NO blocks**: Attacker sends `CommitDecision` with `epoch = 0, round = 0`. The `split_off(&(0, 1))` returns all blocks (since all legitimate blocks have higher keys), keeping blocks that should be removed and causing memory accumulation until hitting the `max_num_pending_blocks` limit: [5](#0-4) 

The vulnerability also corrupts the root ledger info with unverified data: [6](#0-5) 

## Impact Explanation

**Severity: HIGH** - This aligns with "Validator Node Slowdowns (High)" category in the Aptos bug bounty program.

Impact on consensus observer nodes:

1. **Liveness Failures**: Removing all pending blocks (Scenario A) disrupts the execution pipeline. The observer cannot process legitimate consensus progress until state sync completes, causing significant operational delays.

2. **State Inconsistency**: The observer's internal state (ordered blocks and root ledger info) becomes inconsistent with actual consensus progress, violating state management invariants and potentially affecting downstream systems that rely on observer data.

3. **Resource Exhaustion**: Keeping all blocks (Scenario B) causes unbounded memory growth until the `max_num_pending_blocks` limit is reached, after which new legitimate blocks are dropped, preventing the observer from tracking consensus.

4. **Root State Corruption**: Updating the root ledger info with unverified commit proofs corrupts the node's view of committed state, affecting all subsequent processing.

While this does not directly cause fund loss or affect validator consensus, it significantly degrades the functionality of VFN (Validator Full Node) observers, which are critical for network observability and transaction processing.

## Likelihood Explanation

**Likelihood: Medium-High**

The attack requires:
- Attacker operates a network peer that supports the ConsensusObserver protocol
- Observer node subscribes to the attacker's peer (based on distance/latency metrics)
- No special timing, race conditions, or sophisticated techniques needed

From the subscription mechanism, any peer that supports the protocol can be selected as a subscription target: [7](#0-6) 

There are no authorization checks verifying that publishers are legitimate validators. The verification bypass for future epochs is deterministic and always occurs when the commit epoch differs from the current epoch.

## Recommendation

Implement signature verification for all commit decisions regardless of epoch:

```rust
// In process_commit_decision_message(), before line 500:
// Always verify commit proof signatures
if let Err(error) = commit_decision.verify_commit_proof(&epoch_state) {
    error!(LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
        "Failed to verify future epoch commit decision! Ignoring: {:?}, Error: {:?}",
        commit_decision.proof_block_info(), error
    )));
    increment_invalid_message_counter(&peer_network_id, metrics::COMMIT_DECISION_LABEL);
    return;
}
```

Additionally, add bounds checking in `remove_blocks_for_commit()`:

```rust
// Validate epoch/round are within reasonable bounds
if split_off_epoch > current_epoch + 1 || split_off_round > MAX_REASONABLE_ROUND {
    warn!("Invalid commit epoch/round, skipping block removal");
    return;
}
```

## Proof of Concept

The following demonstrates the vulnerability (conceptual Rust test):

```rust
#[test]
fn test_unverified_future_epoch_attack() {
    // Setup observer with some pending blocks
    let mut observer = setup_test_observer();
    insert_test_blocks(&mut observer, 10);
    
    // Attacker crafts malicious commit decision
    let malicious_commit = CommitDecision::new(
        create_ledger_info(u64::MAX, u64::MAX)  // Crafted epoch/round
    );
    
    // Process as future epoch (bypasses verification)
    observer.process_commit_decision_message(
        attacker_peer_id(),
        Instant::now(),
        malicious_commit
    );
    
    // Verify all blocks were removed
    assert_eq!(observer.observer_block_data.lock().get_all_ordered_blocks().len(), 0);
}
```

---

**Notes:**
- The vulnerability affects consensus observer nodes (VFNs and monitoring nodes), not validator consensus directly
- The verification bypass is explicitly acknowledged in the TODO comment at line 497
- Defense in depth principle is violated by skipping signature verification for future epochs
- No authorization mechanism restricts who can be a consensus publisher

### Citations

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L466-495)
```rust
        // If the commit decision is for the current epoch, verify and process it
        let epoch_state = self.get_epoch_state();
        if commit_epoch == epoch_state.epoch {
            // Verify the commit decision
            if let Err(error) = commit_decision.verify_commit_proof(&epoch_state) {
                // Log the error and update the invalid message counter
                error!(
                    LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                        "Failed to verify commit decision! Ignoring: {:?}, from peer: {:?}. Error: {:?}",
                        commit_decision.proof_block_info(),
                        peer_network_id,
                        error
                    ))
                );
                increment_invalid_message_counter(&peer_network_id, metrics::COMMIT_DECISION_LABEL);
                return;
            }

            // Update the latency metrics for commit processing
            update_message_processing_latency_metrics(
                message_received_time,
                &peer_network_id,
                metrics::COMMIT_DECISION_LABEL,
            );

            // Update the pending blocks with the commit decision
            if self.process_commit_decision_for_pending_block(&commit_decision) {
                return; // The commit decision was successfully processed
            }
        }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L497-527)
```rust
        // TODO: identify the best way to handle an invalid commit decision
        // for a future epoch. In such cases, we currently rely on state sync.

        // Otherwise, we failed to process the commit decision. If the commit
        // is for a future epoch or round, we need to state sync.
        let last_block = self.observer_block_data.lock().get_last_ordered_block();
        let epoch_changed = commit_epoch > last_block.epoch();
        if epoch_changed || commit_round > last_block.round() {
            // If we're waiting for state sync to transition into a new epoch,
            // we should just wait and not issue a new state sync request.
            if self.state_sync_manager.is_syncing_through_epoch() {
                info!(
                    LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                        "Already waiting for state sync to reach new epoch: {:?}. Dropping commit decision: {:?}!",
                        self.observer_block_data.lock().root().commit_info(),
                        commit_decision.proof_block_info()
                    ))
                );
                return;
            }

            // Otherwise, we should start the state sync process for the commit.
            // Update the block data (to the commit decision).
            self.observer_block_data
                .lock()
                .update_blocks_for_state_sync_commit(&commit_decision);

            // Start state syncing to the commit decision
            self.state_sync_manager
                .sync_to_commit(commit_decision, epoch_changed);
        }
```

**File:** consensus/src/consensus_observer/observer/block_data.rs (L275-291)
```rust
    pub fn update_blocks_for_state_sync_commit(&mut self, commit_decision: &CommitDecision) {
        // Get the commit proof, epoch and round
        let commit_proof = commit_decision.commit_proof();
        let commit_epoch = commit_decision.epoch();
        let commit_round = commit_decision.round();

        // Update the root
        self.update_root(commit_proof.clone());

        // Update the block payload store
        self.block_payload_store
            .remove_blocks_for_epoch_round(commit_epoch, commit_round);

        // Update the ordered block store
        self.ordered_block_store
            .remove_blocks_for_commit(commit_proof);
    }
```

**File:** consensus/src/consensus_observer/observer/ordered_blocks.rs (L77-88)
```rust
        // Verify that the number of ordered blocks doesn't exceed the maximum
        let max_num_ordered_blocks = self.consensus_observer_config.max_num_pending_blocks as usize;
        if self.ordered_blocks.len() >= max_num_ordered_blocks {
            warn!(
                LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                    "Exceeded the maximum number of ordered blocks: {:?}. Dropping block: {:?}.",
                    max_num_ordered_blocks,
                    observed_ordered_block.ordered_block().proof_block_info()
                ))
            );
            return; // Drop the block if we've exceeded the maximum
        }
```

**File:** consensus/src/consensus_observer/observer/ordered_blocks.rs (L112-124)
```rust
    pub fn remove_blocks_for_commit(&mut self, commit_ledger_info: &LedgerInfoWithSignatures) {
        // Determine the epoch and round to split off
        let split_off_epoch = commit_ledger_info.ledger_info().epoch();
        let split_off_round = commit_ledger_info.commit_info().round().saturating_add(1);

        // Remove the blocks from the ordered blocks
        self.ordered_blocks = self
            .ordered_blocks
            .split_off(&(split_off_epoch, split_off_round));

        // Update the highest committed epoch and round
        self.update_highest_committed_epoch_round(commit_ledger_info);
    }
```

**File:** consensus/src/consensus_observer/observer/subscription_utils.rs (L283-294)
```rust
pub fn sort_peers_by_subscription_optimality(
    peers_and_metadata: &HashMap<PeerNetworkId, PeerMetadata>,
) -> Vec<PeerNetworkId> {
    // Group peers and latencies by validator distance, i.e., distance -> [(peer, latency)]
    let mut unsupported_peers = Vec::new();
    let mut peers_and_latencies_by_distance = BTreeMap::new();
    for (peer_network_id, peer_metadata) in peers_and_metadata {
        // Verify that the peer supports consensus observer
        if !supports_consensus_observer(peer_metadata) {
            unsupported_peers.push(*peer_network_id);
            continue; // Skip the peer
        }
```
