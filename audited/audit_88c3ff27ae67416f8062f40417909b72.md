# Audit Report

## Title
Index Out of Bounds Panic in RestDebuggerInterface::get_version_by_account_sequence()

## Summary
The `get_version_by_account_sequence()` function in the REST debugger interface contains an index out of bounds vulnerability that causes a panic when querying for non-existent account/sequence number pairs, violating the function's contract to return `Option<Version>`.

## Finding Description

The `AptosDebugger::get_version_by_account_sequence()` function delegates to underlying trait implementations. [1](#0-0) 

There are two implementations of this trait method:

1. **DBDebuggerInterface** (database backend) - Correctly handles the None case [2](#0-1) 

2. **RestDebuggerInterface** (REST API backend) - Contains the vulnerability [3](#0-2) 

The RestDebuggerInterface implementation blindly accesses index `[0]` on the result vector without checking if it's empty. When the REST API returns an empty vector (which is valid per the storage interface specification [4](#0-3) ), this causes a panic with "index out of bounds".

The function signature promises to return `Result<Option<Version>>`, indicating it should gracefully handle the case where no transaction exists by returning `Ok(None)`. However, the RestDebuggerInterface implementation violates this contract by panicking instead.

**Attack Scenario:**
1. User runs aptos-debugger with REST interface (e.g., `AptosDebugger::rest_client()`)
2. User queries for a transaction with an account/sequence pair that doesn't exist
3. REST API returns empty transaction list
4. Code attempts to access `[0]` on empty vector
5. Debugger crashes with panic

## Impact Explanation

This is a **Low Severity** issue per Aptos bug bounty criteria:
- Falls under "Non-critical implementation bugs"
- Causes denial of service for the debugger tool only
- Does NOT affect validator nodes, consensus, or the blockchain network
- Does NOT cause fund loss or state inconsistencies
- Only impacts developers/operators using the debugging tool

The debugger is a development/operational tool, not part of the core blockchain infrastructure. While the panic is undesirable and violates proper error handling, it does not pose a security risk to the Aptos network.

## Likelihood Explanation

**High likelihood** of occurrence:
- Any query for a non-existent sequence number will trigger the panic
- Common scenario: querying for future sequence numbers or checking if an account has any transactions
- No special conditions or race conditions required
- 100% reproducible with any account/sequence pair that has no corresponding transaction

## Recommendation

Fix the RestDebuggerInterface implementation to match the DBDebuggerInterface behavior:

```rust
async fn get_version_by_account_sequence(
    &self,
    account: AccountAddress,
    seq: u64,
) -> Result<Option<Version>> {
    let transactions = self.0
        .get_account_ordered_transactions_bcs(account, Some(seq), None)
        .await?
        .into_inner();
    
    Ok(transactions.first().map(|txn| txn.version))
}
```

This safely handles empty results by using `.first()` which returns `Option<&T>`, then mapping to extract the version.

## Proof of Concept

```rust
#[tokio::test]
async fn test_get_version_by_account_sequence_none_case() {
    use aptos_rest_client::Client;
    use aptos_types::account_address::AccountAddress;
    use aptos_move::aptos_debugger::AptosDebugger;
    
    // Setup REST client pointing to testnet or local node
    let rest_client = Client::new(url::Url::parse("https://fullnode.testnet.aptoslabs.com").unwrap());
    let debugger = AptosDebugger::rest_client(rest_client).unwrap();
    
    // Query for a very high sequence number that doesn't exist
    let fake_account = AccountAddress::from_hex_literal("0xCAFE").unwrap();
    let result = debugger.get_version_by_account_sequence(fake_account, 999999999).await;
    
    // This will panic with "index out of bounds: the len is 0 but the index is 0"
    // Expected: Ok(None)
    // Actual: panic!
    match result {
        Ok(None) => println!("Correctly returned None"),
        Ok(Some(v)) => println!("Unexpectedly found version: {}", v),
        Err(e) => println!("Error (acceptable): {}", e),
    }
}
```

## Notes

While this is a genuine bug that should be fixed, it does **not meet the Critical/High/Medium severity threshold** required by the validation checklist. The issue is confined to the debugging tooling layer and does not impact blockchain consensus, validator operations, fund security, or network availability.

The DBDebuggerInterface implementation demonstrates the correct pattern that should be followed. The inconsistency between the two implementations suggests this was an oversight rather than an intentional design choice.

### Citations

**File:** aptos-move/aptos-debugger/src/aptos_debugger.rs (L367-375)
```rust
    pub async fn get_version_by_account_sequence(
        &self,
        account: AccountAddress,
        seq: u64,
    ) -> anyhow::Result<Option<Version>> {
        self.debugger
            .get_version_by_account_sequence(account, seq)
            .await
    }
```

**File:** aptos-move/aptos-validator-interface/src/storage_interface.rs (L119-131)
```rust
    async fn get_version_by_account_sequence(
        &self,
        account: AccountAddress,
        seq: u64,
    ) -> Result<Option<Version>> {
        let ledger_version = self.get_latest_ledger_info_version().await?;
        self.0
            .get_account_ordered_transaction(account, seq, false, ledger_version)
            .map_or_else(
                |e| Err(anyhow::Error::from(e)),
                |tp| Ok(tp.map(|e| e.version)),
            )
    }
```

**File:** aptos-move/aptos-validator-interface/src/rest_interface.rs (L357-369)
```rust
    async fn get_version_by_account_sequence(
        &self,
        account: AccountAddress,
        seq: u64,
    ) -> Result<Option<Version>> {
        Ok(Some(
            self.0
                .get_account_ordered_transactions_bcs(account, Some(seq), None)
                .await?
                .into_inner()[0]
                .version,
        ))
    }
```

**File:** types/src/transaction/mod.rs (L2861-2874)
```rust
pub struct AccountOrderedTransactionsWithProof(pub Vec<TransactionWithProof>);

impl AccountOrderedTransactionsWithProof {
    pub fn new(txns_with_proofs: Vec<TransactionWithProof>) -> Self {
        Self(txns_with_proofs)
    }

    pub fn new_empty() -> Self {
        Self::new(Vec::new())
    }

    pub fn is_empty(&self) -> bool {
        self.0.is_empty()
    }
```
