# Audit Report

## Title
Limiter Composition Bug in `view_resource_with_limit()` Allows Resource Limit Bypass

## Summary
The `view_resource_with_limit()` function in the move-resource-viewer library incorrectly creates a fresh limiter for type resolution instead of using the provided limit parameter, allowing composed operations to exceed intended global resource limits.

## Finding Description

The move-resource-viewer library provides a `Limiter` mechanism to prevent resource exhaustion during Move value annotation. The `view_resource_with_limit()` function is designed to allow callers to enforce resource usage limits across multiple operations by sharing a single `Limiter` instance.

However, the implementation has a critical composition bug: [1](#0-0) 

At line 350, the function creates a new `Limiter::default()` with a fresh 100MB budget for type resolution, completely bypassing the caller-provided `limit` parameter. Only the annotation phase (line 353) uses the provided limiter.

This contrasts with the correct implementation in `view_value()`: [2](#0-1) 

The `view_value()` function correctly uses a single limiter for both type resolution and value annotation.

The Limiter's charge mechanism is defined as: [3](#0-2) 

**Attack Scenario:**
While `view_resource_with_limit()` is currently not called in the production codebase, it is a **public API function** that could be used by:
1. Future indexer implementations processing multiple resources with a shared budget
2. API endpoints that need to limit total resource processing
3. External tools built on the move-resource-viewer library

An attacker could exploit this by:
1. Submitting resources with deeply nested type hierarchies that consume significant memory during type resolution
2. If a service uses `view_resource_with_limit()` with a shared limiter (e.g., 50MB total budget for 10 resources)
3. Each call consumes: 100MB (type resolution) + share of 50MB (annotation) = up to 1050MB total instead of 50MB

## Impact Explanation

This vulnerability falls under **Medium Severity** per the Aptos bug bounty criteria as it enables:
- **Resource exhaustion attacks** on nodes using the function
- **State inconsistencies requiring intervention** if indexer operations fail mid-batch
- Violation of **Resource Limits invariant (#9)**: "All operations must respect gas, storage, and computational limits"

The bug currently has **limited impact** because:
- The function is not used in production code paths
- Current usage through `view_resource()` creates independent limiters per call
- The Aptos wrapper does not expose this function: [4](#0-3) 

However, it remains a **latent vulnerability** in a public API that could be triggered if future code adopts the function for its intended use case (shared limit enforcement).

## Likelihood Explanation

**Current Likelihood: Low**
- Function exists but is not called in any production code path
- Requires future adoption or external usage to be exploitable

**Future Likelihood: Medium** 
- The function's signature clearly indicates its intended use case
- Developers might naturally use it when implementing batch processing with resource limits
- The bug is non-obvious and would likely not be caught in code review

## Recommendation

Fix the bug by using the provided limiter for type resolution:

```rust
pub fn view_resource_with_limit(
    &self,
    tag: &StructTag,
    blob: &[u8],
    limit: &mut Limiter,
) -> anyhow::Result<AnnotatedMoveStruct> {
    // FIX: Use the provided limit instead of creating a new one
    let ty = self.resolve_struct_tag(tag, limit)?;
    let struct_def = (ty.as_ref()).try_into().map_err(into_vm_status)?;
    let move_struct = MoveStruct::simple_deserialize(blob, &struct_def)?;
    self.annotate_struct(&move_struct, &ty, limit)
}
```

Similarly, fix `move_struct_fields()` if it ever needs to accept a limit parameter: [5](#0-4) 

## Proof of Concept

```rust
#[cfg(test)]
mod test {
    use super::*;
    use move_core_types::{account_address::AccountAddress, identifier::Identifier, language_storage::StructTag};
    
    #[test]
    fn test_limiter_composition_bug() {
        // Create a test annotator
        let state_view = /* mock state view */;
        let annotator = MoveValueAnnotator::new(state_view);
        
        // Create a limiter with only 1MB budget
        let mut shared_limit = Limiter(1_000_000);
        
        // Create a resource with complex nested types that require
        // significant type resolution work (>1MB)
        let tag = StructTag {
            address: AccountAddress::ONE,
            module: Identifier::new("test").unwrap(),
            name: Identifier::new("ComplexStruct").unwrap(),
            type_args: vec![/* deeply nested type args */],
        };
        let blob = /* serialized complex struct */;
        
        // This should fail due to 1MB limit, but succeeds because
        // type resolution gets a fresh 100MB limit
        let result = annotator.view_resource_with_limit(&tag, &blob, &mut shared_limit);
        
        // BUG: This succeeds even though type resolution consumed >1MB
        // because resolve_struct_tag() used Limiter::default() instead of shared_limit
        assert!(result.is_ok());
    }
}
```

**Notes:**
While this is a valid bug that breaks the limiter composition invariant, its **exploitability is currently limited** because the function is not used in production code. However, it represents a **design flaw in a public API** that should be fixed to prevent future vulnerabilities when the function is adopted for its intended use case of enforcing global resource limits across composed operations.

### Citations

**File:** third_party/move/tools/move-resource-viewer/src/lib.rs (L344-354)
```rust
    pub fn view_resource_with_limit(
        &self,
        tag: &StructTag,
        blob: &[u8],
        limit: &mut Limiter,
    ) -> anyhow::Result<AnnotatedMoveStruct> {
        let ty = self.resolve_struct_tag(tag, &mut Limiter::default())?;
        let struct_def = (ty.as_ref()).try_into().map_err(into_vm_status)?;
        let move_struct = MoveStruct::simple_deserialize(blob, &struct_def)?;
        self.annotate_struct(&move_struct, &ty, limit)
    }
```

**File:** third_party/move/tools/move-resource-viewer/src/lib.rs (L356-362)
```rust
    pub fn move_struct_fields(
        &self,
        tag: &StructTag,
        blob: &[u8],
    ) -> anyhow::Result<(Option<Identifier>, Vec<(Identifier, MoveValue)>)> {
        let ty = self.resolve_struct_tag(tag, &mut Limiter::default())?;
        let struct_def = (ty.as_ref()).try_into().map_err(into_vm_status)?;
```

**File:** third_party/move/tools/move-resource-viewer/src/lib.rs (L685-689)
```rust
    pub fn view_value(&self, ty_tag: &TypeTag, blob: &[u8]) -> anyhow::Result<AnnotatedMoveValue> {
        let mut limit = Limiter::default();
        let ty = self.resolve_type_impl(ty_tag, &mut limit)?;
        self.view_value_by_fat_type(&ty, blob, &mut limit)
    }
```

**File:** third_party/move/tools/move-resource-viewer/src/limit.rs (L10-21)
```rust
pub struct Limiter(usize);

impl Limiter {
    pub fn charge(&mut self, cost: usize) -> PartialVMResult<()> {
        if self.0 < cost {
            return Err(PartialVMError::new(StatusCode::ABORTED)
                .with_message("Query exceeds size limit".to_string()));
        }
        self.0 -= cost;
        Ok(())
    }
}
```

**File:** aptos-move/aptos-resource-viewer/src/lib.rs (L68-74)
```rust
    pub fn view_resource(
        &self,
        tag: &StructTag,
        blob: &[u8],
    ) -> anyhow::Result<AnnotatedMoveStruct> {
        self.0.view_resource(tag, blob)
    }
```
