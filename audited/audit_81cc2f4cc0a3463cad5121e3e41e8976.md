# Audit Report

## Title
Byzantine Validator Can Cause Consensus Divergence Through Equivocating Certified Augmented Data in Randomness Generation

## Summary
The `add_certified_aug_data` function in the randomness generation module fails to perform equivocation checks when receiving certified augmented data from the same validator. A Byzantine validator can exploit this by partitioning the reliable broadcast protocol to get different validator subsets to sign different augmented data, then distribute different valid certificates to different nodes. This causes nodes to derive different augmented public keys (APKs) for randomness verification, leading to consensus divergence where validators produce different randomness values for the same round.

## Finding Description

The vulnerability exists in the `AugDataStore::add_certified_aug_data` method in the randomness generation consensus module. [1](#0-0) 

When a node receives certified augmented data, the function checks if it already has certified data from that validator and immediately returns success without verifying that the new data matches the existing data. [2](#0-1) 

This contrasts with the `add_aug_data` method which correctly performs an equivocation check by verifying that any existing data from the same author matches the newly received data. [3](#0-2) 

A Byzantine validator can exploit this through the following attack:

1. **Partition Reliable Broadcast (Phase 1)**: During the augmented data broadcast phase, the Byzantine validator sends different `AugData` objects containing different `Delta` values to different subsets of honest validators. [4](#0-3) 

2. **Collect Signatures**: Each honest validator subset receives their version, verifies it, stores it locally (passing the per-validator equivocation check), and returns a signature. [5](#0-4) 

3. **Create Multiple Valid Certificates**: The Byzantine validator aggregates the signatures from each subset to create multiple `CertifiedAugData` objects, each containing different `AugData` but each having sufficient quorum signatures for their specific content. [6](#0-5) 

4. **Distribute Different Certificates**: The Byzantine validator sends different `CertifiedAugData` versions to different nodes. Each certificate passes signature verification because the signatures are cryptographically valid for that specific `AugData`. [7](#0-6) 

5. **Nodes Accept Without Equivocation Check**: When nodes receive certified augmented data, they process it through `add_certified_aug_data`, which calls `augment()` to derive and store the APK. [8](#0-7) 

6. **Different APKs Stored**: The `augment` method calls `add_certified_delta`, which derives an augmented public key from the delta and calls `add_certified_apk` to store it. [9](#0-8) 

7. **No APK Equivocation Check**: The `add_certified_apk` function also fails to validate that a newly added APK matches an existing one - it simply returns success if already set. [10](#0-9) 

8. **Consensus Divergence**: Different nodes now have different APKs for the Byzantine validator. These APKs are used to verify randomness shares in `Share::verify`. [11](#0-10) 

9. **Different Randomness Output**: The different APKs are also used in `Share::aggregate` to produce the final randomness value. [12](#0-11) 

Different APKs lead to different share verification results and different aggregated randomness outputs, breaking the fundamental consensus invariant that all validators must produce identical state for identical blocks.

## Impact Explanation

This vulnerability constitutes a **Critical Severity** consensus safety violation under the Aptos bug bounty program's "Consensus/Safety violations" category (up to $1,000,000).

The attack enables a single Byzantine validator (within the < 1/3 Byzantine fault tolerance assumption) to cause consensus divergence by:

1. **Breaking Deterministic Execution**: Different validators will produce different randomness values for the same round, leading to different state roots when blocks depend on that randomness.

2. **Violating Consensus Safety**: The network can split into partitions that have different certified augmented data for the Byzantine validator, causing them to accept different randomness values and potentially fork the chain.

3. **Requiring Manual Intervention**: Chain splits from consensus divergence typically require manual intervention or hard fork to resolve, as the validators cannot automatically reconcile different committed state.

The severity is critical because randomness is a core consensus primitive in Aptos. Any divergence in randomness values directly translates to consensus failure, which could enable double-spending and other attacks that exploit the chain split.

## Likelihood Explanation

The likelihood of exploitation is **MEDIUM to HIGH**:

**Requirements for exploitation:**
- One Byzantine validator (within the < 1/3 Byzantine fault tolerance assumption that Aptos security model explicitly considers)
- Ability to control network message delivery to send different messages to different validator subsets during the reliable broadcast protocol

**Attack Complexity:**
- **Moderate** - The Byzantine validator must partition the reliable broadcast in Phase 1 to get different validators to sign different augmented data
- Each subset must provide enough signatures to meet quorum threshold
- The Byzantine validator then distributes different certified versions to different nodes
- All certificates are individually cryptographically valid, making detection difficult

**Detection Difficulty:**
- No obvious on-chain evidence since each certificate is individually valid with proper quorum signatures
- The equivocation only becomes apparent when comparing what different nodes received
- Manifests downstream as consensus divergence rather than an obvious protocol violation

**Feasibility:**
- Byzantine validators are explicitly assumed in the BFT threat model
- Network-level message control is feasible for a validator participating in the consensus protocol
- The attack doesn't require breaking cryptographic primitives or compromising other validators
- Constructing multiple valid certificates from different signature subsets is straightforward once different validators have signed different data

## Recommendation

Add explicit equivocation checks in both `add_certified_aug_data` and `add_certified_apk` to match the protection already present in `add_aug_data`:

```rust
pub fn add_certified_aug_data(
    &mut self,
    certified_data: CertifiedAugData<D>,
) -> anyhow::Result<CertifiedAugDataAck> {
    if let Some(existing_data) = self.certified_data.get(certified_data.author()) {
        ensure!(
            existing_data == &certified_data,
            "[AugDataStore] equivocate certified data from {}",
            certified_data.author()
        );
        return Ok(CertifiedAugDataAck::new(self.epoch));
    }
    self.db.save_certified_aug_data(&certified_data)?;
    certified_data
        .data()
        .augment(&self.config, &self.fast_config, certified_data.author());
    self.certified_data
        .insert(*certified_data.author(), certified_data);
    Ok(CertifiedAugDataAck::new(self.epoch))
}
```

Similarly, update `add_certified_apk` in `RandKeys`:

```rust
pub fn add_certified_apk(&self, index: usize, apk: APK) -> anyhow::Result<()> {
    assert!(index < self.certified_apks.len());
    if let Some(existing_apk) = self.certified_apks[index].get() {
        ensure!(
            existing_apk == &apk,
            "Equivocating APK detected for validator index {}",
            index
        );
        return Ok(());
    }
    self.certified_apks[index].set(apk).unwrap();
    Ok(())
}
```

## Proof of Concept

A complete proof of concept would require:
1. Setting up a test network with multiple validators including one Byzantine validator
2. Having the Byzantine validator implement the partitioned broadcast strategy to send different `AugData` to different validator subsets
3. Demonstrating that different validators store different APKs
4. Showing that subsequent randomness generation produces different values on different validators

The core vulnerability can be verified by code inspection showing the missing equivocation checks and tracing the execution path from `add_certified_aug_data` through APK derivation to randomness generation.

### Citations

**File:** consensus/src/rand/rand_gen/aug_data_store.rs (L102-115)
```rust
    pub fn add_aug_data(&mut self, data: AugData<D>) -> anyhow::Result<AugDataSignature> {
        if let Some(existing_data) = self.data.get(data.author()) {
            ensure!(
                existing_data == &data,
                "[AugDataStore] equivocate data from {}",
                data.author()
            );
        } else {
            self.db.save_aug_data(&data)?;
        }
        let sig = AugDataSignature::new(self.epoch, self.signer.sign(&data)?);
        self.data.insert(*data.author(), data);
        Ok(sig)
    }
```

**File:** consensus/src/rand/rand_gen/aug_data_store.rs (L117-131)
```rust
    pub fn add_certified_aug_data(
        &mut self,
        certified_data: CertifiedAugData<D>,
    ) -> anyhow::Result<CertifiedAugDataAck> {
        if self.certified_data.contains_key(certified_data.author()) {
            return Ok(CertifiedAugDataAck::new(self.epoch));
        }
        self.db.save_certified_aug_data(&certified_data)?;
        certified_data
            .data()
            .augment(&self.config, &self.fast_config, certified_data.author());
        self.certified_data
            .insert(*certified_data.author(), certified_data);
        Ok(CertifiedAugDataAck::new(self.epoch))
    }
```

**File:** consensus/src/rand/rand_gen/rand_manager.rs (L305-346)
```rust
    async fn broadcast_aug_data(&mut self) -> DropGuard {
        let data = self
            .aug_data_store
            .get_my_aug_data()
            .unwrap_or_else(|| D::generate(&self.config, &self.fast_config));
        // Add it synchronously to avoid race that it sends to others but panics before it persists locally.
        self.aug_data_store
            .add_aug_data(data.clone())
            .expect("Add self aug data should succeed");
        let aug_ack = AugDataCertBuilder::new(data.clone(), self.epoch_state.clone());
        let rb = self.reliable_broadcast.clone();
        let rb2 = self.reliable_broadcast.clone();
        let validators = self.epoch_state.verifier.get_ordered_account_addresses();
        let maybe_existing_certified_data = self.aug_data_store.get_my_certified_aug_data();
        let phase1 = async move {
            if let Some(certified_data) = maybe_existing_certified_data {
                info!("[RandManager] Already have certified aug data");
                return certified_data;
            }
            info!("[RandManager] Start broadcasting aug data");
            info!(LogSchema::new(LogEvent::BroadcastAugData)
                .author(*data.author())
                .epoch(data.epoch()));
            let certified_data = rb.broadcast(data, aug_ack).await.expect("cannot fail");
            info!("[RandManager] Finish broadcasting aug data");
            certified_data
        };
        let ack_state = Arc::new(CertifiedAugDataAckState::new(validators.into_iter()));
        let task = phase1.then(|certified_data| async move {
            info!(LogSchema::new(LogEvent::BroadcastCertifiedAugData)
                .author(*certified_data.author())
                .epoch(certified_data.epoch()));
            info!("[RandManager] Start broadcasting certified aug data");
            rb2.broadcast(certified_data, ack_state)
                .await
                .expect("Broadcast cannot fail");
            info!("[RandManager] Finish broadcasting certified aug data");
        });
        let (abort_handle, abort_registration) = AbortHandle::new_pair();
        tokio::spawn(Abortable::new(task, abort_registration));
        DropGuard::new(abort_handle)
    }
```

**File:** consensus/src/rand/rand_gen/reliable_broadcast_state.rs (L25-67)
```rust
pub struct AugDataCertBuilder<D> {
    epoch_state: Arc<EpochState>,
    aug_data: AugData<D>,
    partial_signatures: Mutex<PartialSignatures>,
}

impl<D> AugDataCertBuilder<D> {
    pub fn new(aug_data: AugData<D>, epoch_state: Arc<EpochState>) -> Arc<Self> {
        Arc::new(Self {
            epoch_state,
            aug_data,
            partial_signatures: Mutex::new(PartialSignatures::empty()),
        })
    }
}

impl<S: TShare, D: TAugmentedData> BroadcastStatus<RandMessage<S, D>, RandMessage<S, D>>
    for Arc<AugDataCertBuilder<D>>
{
    type Aggregated = CertifiedAugData<D>;
    type Message = AugData<D>;
    type Response = AugDataSignature;

    fn add(&self, peer: Author, ack: Self::Response) -> anyhow::Result<Option<Self::Aggregated>> {
        ack.verify(peer, &self.epoch_state.verifier, &self.aug_data)?;
        let mut parital_signatures_guard = self.partial_signatures.lock();
        parital_signatures_guard.add_signature(peer, ack.into_signature());
        let qc_aug_data = self
            .epoch_state
            .verifier
            .check_voting_power(parital_signatures_guard.signatures().keys(), true)
            .ok()
            .map(|_| {
                let aggregated_signature = self
                    .epoch_state
                    .verifier
                    .aggregate_signatures(parital_signatures_guard.signatures_iter())
                    .expect("Signature aggregation should succeed");
                CertifiedAugData::new(self.aug_data.clone(), aggregated_signature)
            });
        Ok(qc_aug_data)
    }
}
```

**File:** consensus/src/rand/rand_gen/types.rs (L52-81)
```rust
    fn verify(
        &self,
        rand_config: &RandConfig,
        rand_metadata: &RandMetadata,
        author: &Author,
    ) -> anyhow::Result<()> {
        let index = *rand_config
            .validator
            .address_to_validator_index()
            .get(author)
            .ok_or_else(|| anyhow!("Share::verify failed with unknown author"))?;
        let maybe_apk = &rand_config.keys.certified_apks[index];
        if let Some(apk) = maybe_apk.get() {
            WVUF::verify_share(
                &rand_config.vuf_pp,
                apk,
                bcs::to_bytes(&rand_metadata)
                    .map_err(|e| anyhow!("Serialization failed: {}", e))?
                    .as_slice(),
                &self.share,
            )?;
        } else {
            bail!(
                "[RandShare] No augmented public key for validator id {}, {}",
                index,
                author
            );
        }
        Ok(())
    }
```

**File:** consensus/src/rand/rand_gen/types.rs (L97-148)
```rust
    fn aggregate<'a>(
        shares: impl Iterator<Item = &'a RandShare<Self>>,
        rand_config: &RandConfig,
        rand_metadata: RandMetadata,
    ) -> anyhow::Result<Randomness>
    where
        Self: Sized,
    {
        let timer = std::time::Instant::now();
        let mut apks_and_proofs = vec![];
        for share in shares {
            let id = rand_config
                .validator
                .address_to_validator_index()
                .get(share.author())
                .copied()
                .ok_or_else(|| {
                    anyhow!(
                        "Share::aggregate failed with invalid share author: {}",
                        share.author
                    )
                })?;
            let apk = rand_config
                .get_certified_apk(share.author())
                .ok_or_else(|| {
                    anyhow!(
                        "Share::aggregate failed with missing apk for share from {}",
                        share.author
                    )
                })?;
            apks_and_proofs.push((Player { id }, apk.clone(), share.share().share));
        }

        let proof = WVUF::aggregate_shares(&rand_config.wconfig, &apks_and_proofs);
        let metadata_serialized = bcs::to_bytes(&rand_metadata).map_err(|e| {
            anyhow!("Share::aggregate failed with metadata serialization error: {e}")
        })?;
        let eval = WVUF::derive_eval(
            &rand_config.wconfig,
            &rand_config.vuf_pp,
            metadata_serialized.as_slice(),
            &rand_config.get_all_certified_apk(),
            &proof,
            THREAD_MANAGER.get_exe_cpu_pool(),
        )
        .map_err(|e| anyhow!("Share::aggregate failed with WVUF derive_eval error: {e}"))?;
        debug!("WVUF derivation time: {} ms", timer.elapsed().as_millis());
        let eval_bytes = bcs::to_bytes(&eval)
            .map_err(|e| anyhow!("Share::aggregate failed with eval serialization error: {e}"))?;
        let rand_bytes = Sha3_256::digest(eval_bytes.as_slice()).to_vec();
        Ok(Randomness::new(rand_metadata, rand_bytes))
    }
```

**File:** consensus/src/rand/rand_gen/types.rs (L178-194)
```rust
    fn augment(
        &self,
        rand_config: &RandConfig,
        fast_rand_config: &Option<RandConfig>,
        author: &Author,
    ) {
        let AugmentedData { delta, fast_delta } = self;
        rand_config
            .add_certified_delta(author, delta.clone())
            .expect("Add delta should succeed");

        if let (Some(config), Some(fast_delta)) = (fast_rand_config, fast_delta) {
            config
                .add_certified_delta(author, fast_delta.clone())
                .expect("Add delta for fast path should succeed");
        }
    }
```

**File:** consensus/src/rand/rand_gen/types.rs (L529-563)
```rust
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct CertifiedAugData<D> {
    aug_data: AugData<D>,
    signatures: AggregateSignature,
}

impl<D: TAugmentedData> CertifiedAugData<D> {
    pub fn new(aug_data: AugData<D>, signatures: AggregateSignature) -> Self {
        Self {
            aug_data,
            signatures,
        }
    }

    pub fn epoch(&self) -> u64 {
        self.aug_data.epoch()
    }

    pub fn id(&self) -> AugDataId {
        self.aug_data.id()
    }

    pub fn author(&self) -> &Author {
        self.aug_data.author()
    }

    pub fn verify(&self, verifier: &ValidatorVerifier) -> anyhow::Result<()> {
        verifier.verify_multi_signatures(&self.aug_data, &self.signatures)?;
        Ok(())
    }

    pub fn data(&self) -> &D {
        &self.aug_data.data
    }
}
```

**File:** consensus/src/rand/rand_gen/types.rs (L661-665)
```rust
    pub fn add_certified_delta(&self, peer: &Author, delta: Delta) -> anyhow::Result<()> {
        let apk = self.derive_apk(peer, delta)?;
        self.add_certified_apk(peer, apk)?;
        Ok(())
    }
```

**File:** consensus/src/rand/rand_gen/network_messages.rs (L50-52)
```rust
            RandMessage::CertifiedAugData(certified_aug_data) => {
                certified_aug_data.verify(&epoch_state.verifier)
            },
```

**File:** types/src/randomness.rs (L128-135)
```rust
    pub fn add_certified_apk(&self, index: usize, apk: APK) -> anyhow::Result<()> {
        assert!(index < self.certified_apks.len());
        if self.certified_apks[index].get().is_some() {
            return Ok(());
        }
        self.certified_apks[index].set(apk).unwrap();
        Ok(())
    }
```
