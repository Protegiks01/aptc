# Audit Report

## Title
Backup Coordinator Process Crash on Future Panic - No Graceful Recovery

## Summary
The `BufferedX` stream implementation and its underlying `FuturesUnorderedX` component lack panic recovery mechanisms. When any future panics during polling, the entire backup coordinator process terminates via the global panic handler, halting all backup operations until manual restart.

## Finding Description

The `FuturesUnorderedX::poll_next` implementation does not handle panics that occur during future polling: [1](#0-0) 

When `self.in_progress.poll_next_unpin(cx)` is called and a contained future panics, the panic propagates upward through the polling chain without any recovery mechanism. The Aptos codebase uses a global panic handler that terminates the process: [2](#0-1) 

This affects critical backup operations including state snapshot backups and transaction backups: [3](#0-2) [4](#0-3) 

The backup coordinator runs these operations continuously: [5](#0-4) 

## Impact Explanation

This issue qualifies as **High Severity** per Aptos bug bounty criteria due to:

1. **API crashes**: The backup coordinator process terminates completely on any panic
2. **Operational disruption**: All backup operations (state snapshots, transaction backups, epoch endings) halt simultaneously
3. **Data loss risk**: In-progress backups are lost, creating gaps in disaster recovery coverage
4. **No automatic recovery**: Requires manual operator intervention to restart the coordinator

While this doesn't directly affect blockchain consensus or validator operations, backup infrastructure is critical for disaster recovery. Extended downtime increases risk of data loss in catastrophic scenarios.

## Likelihood Explanation

**Likelihood: Medium**

Panics in production Rust code are uncommon but not impossible:
- Third-party dependency bugs (tokio, futures crate, storage backends)
- Out-of-memory conditions during large state snapshots
- Unexpected edge cases in async I/O operations
- Hardware/OS-level failures

The backup operations use proper `Result` error handling, but panics can still occur from:
- Memory allocation failures
- Stack overflows in deeply nested operations
- Bugs in external crates
- Hardware exceptions

## Recommendation

Implement panic recovery using `std::panic::catch_unwind` with `AssertUnwindSafe` wrapper around future polling:

```rust
use std::panic::{catch_unwind, AssertUnwindSafe};

fn poll_next(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<Self::Item>> {
    while self.in_progress.len() < self.max_in_progress {
        match catch_unwind(AssertUnwindSafe(|| {
            self.in_progress.poll_next_unpin(cx)
        })) {
            Ok(Poll::Ready(Some(output))) => {
                self.queued_outputs.push_back(output);
                if let Some(future) = self.queued.pop_front() {
                    self.in_progress.push(future)
                }
            }
            Ok(Poll::Ready(None)) | Ok(Poll::Pending) => break,
            Err(panic_err) => {
                // Log panic and continue processing other futures
                error!("Future panicked during polling: {:?}", panic_err);
                // Ensure concurrency invariant is maintained
                if let Some(future) = self.queued.pop_front() {
                    self.in_progress.push(future)
                }
            }
        }
    }
    // ... rest of implementation
}
```

Additionally, implement health monitoring and automatic restart mechanisms at the coordinator level to detect and recover from crashes.

## Proof of Concept

```rust
#[cfg(test)]
mod panic_test {
    use super::*;
    use futures::stream;
    use tokio::runtime::Runtime;
    
    #[test]
    #[should_panic(expected = "Test panic")]
    fn test_panic_in_buffered_future() {
        let rt = Runtime::new().unwrap();
        rt.block_on(async {
            let panic_stream = stream::iter(vec![
                async { Ok(1) },
                async { panic!("Test panic in future") },
                async { Ok(3) },
            ]);
            
            // This will panic and terminate the process
            // Without proper panic handling, futures after the panic
            // never execute
            let results: Vec<_> = panic_stream
                .try_buffered_x(3, 2)
                .try_collect()
                .await
                .unwrap();
            
            // This assertion never executes due to panic
            assert_eq!(results.len(), 2);
        });
    }
}
```

**Notes**

This vulnerability affects backup infrastructure reliability rather than blockchain consensus. The current implementation follows fail-fast principles (process termination on panic), which is safer than continuing with corrupted state. However, for critical disaster recovery infrastructure, graceful degradation with panic isolation would provide better operational resilience. The issue is specific to the backup CLI and does not affect validator consensus operations or the core blockchain protocol.

### Citations

**File:** storage/backup/backup-cli/src/utils/stream/futures_unordered_x.rs (L70-87)
```rust
    fn poll_next(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<Self::Item>> {
        // Collect outputs from newly finished futures from the underlying `FuturesUnordered`.
        while let Poll::Ready(Some(output)) = self.in_progress.poll_next_unpin(cx) {
            self.queued_outputs.push_back(output);
            // Concurrency is now below `self.max_in_progress`, kick off a queued one, if any.
            if let Some(future) = self.queued.pop_front() {
                self.in_progress.push(future)
            }
        }

        if let Some(output) = self.queued_outputs.pop_front() {
            Poll::Ready(Some(output))
        } else if self.in_progress.is_empty() {
            Poll::Ready(None)
        } else {
            Poll::Pending
        }
    }
```

**File:** crates/crash-handler/src/lib.rs (L26-58)
```rust
pub fn setup_panic_handler() {
    panic::set_hook(Box::new(move |pi: &PanicHookInfo<'_>| {
        handle_panic(pi);
    }));
}

// Formats and logs panic information
fn handle_panic(panic_info: &PanicHookInfo<'_>) {
    // The Display formatter for a PanicHookInfo contains the message, payload and location.
    let details = format!("{}", panic_info);
    let backtrace = format!("{:#?}", Backtrace::new());

    let info = CrashInfo { details, backtrace };
    let crash_info = toml::to_string_pretty(&info).unwrap();
    error!("{}", crash_info);
    // TODO / HACK ALARM: Write crash info synchronously via eprintln! to ensure it is written before the process exits which error! doesn't guarantee.
    // This is a workaround until https://github.com/aptos-labs/aptos-core/issues/2038 is resolved.
    eprintln!("{}", crash_info);

    // Wait till the logs have been flushed
    aptos_logger::flush();

    // Do not kill the process if the panics happened at move-bytecode-verifier.
    // This is safe because the `state::get_state()` uses a thread_local for storing states. Thus the state can only be mutated to VERIFIER by the thread that's running the bytecode verifier.
    //
    // TODO: once `can_unwind` is stable, we should assert it. See https://github.com/rust-lang/rust/issues/92988.
    if state::get_state() == VMState::VERIFIER || state::get_state() == VMState::DESERIALIZER {
        return;
    }

    // Kill the process
    process::exit(12);
}
```

**File:** storage/backup/backup-cli/src/backup_types/state_snapshot/backup.rs (L253-266)
```rust
        let chunks: Vec<_> = chunk_manifest_fut_stream
            .try_buffered_x(8, 4) // 4 concurrently, at most 8 results in buffer.
            .map_ok(|chunk_manifest| {
                let last_idx = chunk_manifest.last_idx;
                info!(
                    last_idx = last_idx,
                    values_per_second =
                        ((last_idx + 1) as f64 / start.elapsed().as_secs_f64()) as u64,
                    "Chunk written."
                );
                chunk_manifest
            })
            .try_collect()
            .await?;
```

**File:** storage/backup/backup-cli/src/metadata/cache.rs (L184-189)
```rust
        .buffered_x(
            concurrent_downloads * 2, /* buffer size */
            concurrent_downloads,     /* concurrency */
        )
        .collect::<Result<Vec<_>>>()
        .await?;
```

**File:** storage/backup/backup-cli/src/coordinators/backup.rs (L161-175)
```rust
        info!("Backup coordinator started.");
        let mut all_work = stream::select_all(vec![
            watch_db_state,
            backup_epoch_endings,
            backup_state_snapshots,
            backup_transactions,
        ]);

        loop {
            all_work
                .next()
                .await
                .ok_or_else(|| anyhow!("Must be a bug: we never returned None."))?
        }
    }
```
