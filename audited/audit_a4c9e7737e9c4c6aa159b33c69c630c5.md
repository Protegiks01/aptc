# Audit Report

## Title
TOCTOU Vulnerability in JWK Consensus Config Validation Allows Updates After Feature Disable

## Summary
A Time-of-Check-Time-of-Use (TOCTOU) race condition exists between consensus validation and execution of ObservedJWKUpdate validator transactions. When a DKG reconfiguration disables JWK consensus mid-block, subsequent JWK update transactions in the same block are still executed despite the feature being disabled, violating protocol invariants.

## Finding Description

The vulnerability occurs due to a temporal gap between consensus-time validation and execution-time processing of validator transactions:

**Time of Check (Consensus Layer):**
The consensus layer validates ObservedJWKUpdate transactions using a cached `OnChainJWKConsensusConfig` stored in the `RoundManager` struct. [1](#0-0) 

This cached config is set during epoch initialization and remains immutable throughout the epoch. The validation occurs in the proposal verification flow: [2](#0-1) 

The `is_vtxn_expected()` function checks if JWK consensus is enabled using this cached config: [3](#0-2) 

**Time of Use (Execution Layer):**
Block execution follows a strict ordering defined in `combine_to_input_transactions()`: [4](#0-3) 

This ordering is: BlockMetadata → ValidatorTransactions → UserTransactions.

During reconfiguration with DKG, the `finish_with_dkg_result()` function applies pending on-chain config changes, including JWK consensus configuration: [5](#0-4) 

The critical issue is that `process_jwk_update_inner()` in the VM does NOT re-validate whether JWK consensus is currently enabled: [6](#0-5) 

It only validates version correctness, voting power, and cryptographic signatures, but never checks `OnChainJWKConsensusConfig`.

**Attack Scenario:**
1. Governance stages a config change to disable JWK consensus via `set_for_next_epoch()` [7](#0-6) 
2. DKG completes during a block where JWK consensus manager has submitted an ObservedJWKUpdate
3. A block contains: [BlockMetadata, DKGResult, ObservedJWKUpdate]
4. Consensus validates the entire block using the OLD config (JWK enabled)
5. During execution:
   - DKGResult transaction calls `on_new_epoch()` which applies the NEW config (JWK disabled) [8](#0-7) 
   - ObservedJWKUpdate transaction executes immediately after WITHOUT re-checking the config
   - JWK update is applied to on-chain state even though the feature is now disabled

## Impact Explanation

**Severity: High** per Aptos bug bounty criteria for "Significant protocol violations"

**Specific Impacts:**
1. **Protocol Invariant Violation:** JWK updates are applied when JWK consensus is explicitly disabled, violating the system's access control invariants
2. **State Consistency Risk:** Different validator nodes may have divergent expectations about whether JWK updates should be processed
3. **Governance Bypass:** Feature flags designed to control protocol behavior can be circumvented during the critical window of reconfiguration
4. **Deterministic Execution Risk:** If the timing varies between nodes (e.g., due to network delays in validator transaction propagation), different nodes could process different sets of JWK updates, potentially breaking consensus

This does not meet Critical severity because it does not directly cause fund loss or permanent network partition, but it represents a significant protocol violation that undermines governance controls.

## Likelihood Explanation

**Likelihood: Medium**

**Required Conditions:**
1. An active governance proposal to disable JWK consensus (via config buffer update)
2. DKG completion timing coincides with JWK update submissions
3. Both DKGResult and ObservedJWKUpdate transactions included in the same block

**Analysis:**
- The scenario does NOT require malicious behavior - it can occur through legitimate operations
- Governance proposals to modify JWK consensus config are rare but valid administrative actions
- DKG completion is a regular epoch-transition event
- The window of opportunity exists whenever these two events coincide
- The likelihood increases during planned protocol upgrades or security responses where JWK consensus might need to be disabled

While not guaranteed to occur, the combination of events is plausible during normal network operation, especially during governance-driven feature flag updates.

## Recommendation

**Solution:** Add an execution-time validation check in `process_jwk_update_inner()` to verify JWK consensus is currently enabled by reading the latest on-chain config.

**Implementation:**
```rust
// In aptos-move/aptos-vm/src/validator_txns/jwk.rs
fn process_jwk_update_inner(
    &self,
    resolver: &impl AptosMoveResolver,
    module_storage: &impl AptosModuleStorage,
    log_context: &AdapterLogSchema,
    session_id: SessionId,
    update: jwks::QuorumCertifiedUpdate,
) -> Result<(VMStatus, VMOutput), ExecutionFailure> {
    // Load resources.
    let validator_set =
        ValidatorSet::fetch_config(resolver).ok_or(Expected(MissingResourceValidatorSet))?;
    let observed_jwks =
        ObservedJWKs::fetch_config(resolver).ok_or(Expected(MissingResourceObservedJWKs))?;
    
    // ADD THIS CHECK: Verify JWK consensus is currently enabled
    let jwk_config = OnChainJWKConsensusConfig::fetch_config(resolver)
        .ok_or(Expected(JWKConsensusDisabled))?;
    if !jwk_config.jwk_consensus_enabled() {
        return Err(Expected(JWKConsensusDisabled));
    }
    
    // ... rest of validation ...
}
```

**Additional Changes:**
1. Add new `ExpectedFailure` variant: `JWKConsensusDisabled = 0x010106`
2. Consider similar checks for other validator transaction types that depend on feature flags

**Alternative Mitigation:**
Order validator transactions in blocks such that reconfiguration transactions (DKGResult) are always placed in separate blocks from feature-dependent transactions (ObservedJWKUpdate). However, this adds complexity to block construction and may impact liveness.

## Proof of Concept

```rust
// Test to demonstrate the TOCTOU vulnerability
// Add to aptos-move/aptos-vm/src/validator_txns/jwk.rs tests

#[test]
fn test_jwk_update_after_disable_via_dkg() {
    use aptos_types::on_chain_config::OnChainJWKConsensusConfig;
    use aptos_types::jwks::QuorumCertifiedUpdate;
    use aptos_state_view::TStateView;
    
    // 1. Setup: Initialize state with JWK consensus ENABLED
    let mut state_view = MockStateView::new();
    let jwk_config_enabled = OnChainJWKConsensusConfig::default_enabled();
    state_view.set_config(jwk_config_enabled);
    
    // 2. Create a valid ObservedJWKUpdate transaction
    let jwk_update = create_test_jwk_update(); // Helper function
    
    // 3. Simulate DKG reconfiguration that DISABLES JWK consensus
    // This mimics what happens when DKGResult executes and calls on_new_epoch()
    let jwk_config_disabled = OnChainJWKConsensusConfig::Off;
    state_view.set_config(jwk_config_disabled);
    
    // 4. Execute the ObservedJWKUpdate transaction
    let vm = AptosVM::new(&state_view);
    let result = vm.process_jwk_update(
        &state_view,
        &module_storage,
        &log_context,
        session_id,
        jwk_update,
    );
    
    // 5. VULNERABILITY: Transaction executes successfully even though
    // JWK consensus is now disabled
    assert!(result.is_ok()); // This should fail but doesn't!
    
    // 6. EXPECTED BEHAVIOR: Transaction should be rejected with JWKConsensusDisabled error
    // After fix, this should be:
    // assert!(matches!(result, Err(Expected(JWKConsensusDisabled))));
}
```

**Reproduction Steps:**
1. Deploy Aptos testnet with JWK consensus enabled
2. Submit governance proposal: `jwk_consensus_config::set_for_next_epoch(&framework, new_off())`
3. Wait for proposal approval and DKG session to start
4. Submit ObservedJWKUpdate from JWK consensus manager
5. Ensure both DKGResult and ObservedJWKUpdate are in the same block
6. Observe that ObservedJWKUpdate executes successfully despite config change
7. Verify on-chain state shows JWK update applied with JWK consensus disabled

### Citations

**File:** consensus/src/round_manager.rs (L318-318)
```rust
    jwk_consensus_config: OnChainJWKConsensusConfig,
```

**File:** consensus/src/round_manager.rs (L1126-1137)
```rust
        if let Some(vtxns) = proposal.validator_txns() {
            for vtxn in vtxns {
                let vtxn_type_name = vtxn.type_name();
                ensure!(
                    is_vtxn_expected(&self.randomness_config, &self.jwk_consensus_config, vtxn),
                    "unexpected validator txn: {:?}",
                    vtxn_type_name
                );
                vtxn.verify(self.epoch_state.verifier.as_ref())
                    .context(format!("{} verify failed", vtxn_type_name))?;
            }
        }
```

**File:** consensus/src/util/mod.rs (L15-24)
```rust
pub fn is_vtxn_expected(
    randomness_config: &OnChainRandomnessConfig,
    jwk_consensus_config: &OnChainJWKConsensusConfig,
    vtxn: &ValidatorTransaction,
) -> bool {
    match vtxn {
        ValidatorTransaction::DKGResult(_) => randomness_config.randomness_enabled(),
        ValidatorTransaction::ObservedJWKUpdate(_) => jwk_consensus_config.jwk_consensus_enabled(),
    }
}
```

**File:** consensus/consensus-types/src/block.rs (L553-566)
```rust
    pub fn combine_to_input_transactions(
        validator_txns: Vec<ValidatorTransaction>,
        txns: Vec<SignedTransaction>,
        metadata: BlockMetadataExt,
    ) -> Vec<Transaction> {
        once(Transaction::from(metadata))
            .chain(
                validator_txns
                    .into_iter()
                    .map(Transaction::ValidatorTransaction),
            )
            .chain(txns.into_iter().map(Transaction::UserTransaction))
            .collect()
    }
```

**File:** aptos-move/framework/aptos-framework/sources/reconfiguration_with_dkg.move (L46-61)
```text
    public(friend) fun finish(framework: &signer) {
        system_addresses::assert_aptos_framework(framework);
        dkg::try_clear_incomplete_session(framework);
        consensus_config::on_new_epoch(framework);
        execution_config::on_new_epoch(framework);
        gas_schedule::on_new_epoch(framework);
        std::version::on_new_epoch(framework);
        features::on_new_epoch(framework);
        jwk_consensus_config::on_new_epoch(framework);
        jwks::on_new_epoch(framework);
        keyless_account::on_new_epoch(framework);
        randomness_config_seqnum::on_new_epoch(framework);
        randomness_config::on_new_epoch(framework);
        randomness_api_v0_config::on_new_epoch(framework);
        reconfiguration::reconfigure();
    }
```

**File:** aptos-move/aptos-vm/src/validator_txns/jwk.rs (L100-179)
```rust
    fn process_jwk_update_inner(
        &self,
        resolver: &impl AptosMoveResolver,
        module_storage: &impl AptosModuleStorage,
        log_context: &AdapterLogSchema,
        session_id: SessionId,
        update: jwks::QuorumCertifiedUpdate,
    ) -> Result<(VMStatus, VMOutput), ExecutionFailure> {
        // Load resources.
        let validator_set =
            ValidatorSet::fetch_config(resolver).ok_or(Expected(MissingResourceValidatorSet))?;
        let observed_jwks =
            ObservedJWKs::fetch_config(resolver).ok_or(Expected(MissingResourceObservedJWKs))?;

        let mut jwks_by_issuer: HashMap<Issuer, ProviderJWKs> =
            observed_jwks.into_providers_jwks().into();
        let issuer = update.update.issuer.clone();
        let on_chain = jwks_by_issuer
            .entry(issuer.clone())
            .or_insert_with(|| ProviderJWKs::new(issuer));
        let verifier = ValidatorVerifier::from(&validator_set);

        let QuorumCertifiedUpdate {
            update: observed,
            multi_sig,
        } = update;

        // Check version.
        if on_chain.version + 1 != observed.version {
            return Err(Expected(IncorrectVersion));
        }

        let authors = multi_sig.get_signers_addresses(&verifier.get_ordered_account_addresses());

        // Check voting power.
        verifier
            .check_voting_power(authors.iter(), true)
            .map_err(|_| Expected(NotEnoughVotingPower))?;

        // Verify multi-sig.
        verifier
            .verify_multi_signatures(&observed, &multi_sig)
            .map_err(|_| Expected(MultiSigVerificationFailed))?;

        // All verification passed. Apply the `observed`.
        let mut gas_meter = UnmeteredGasMeter;
        let mut session = self.new_session(resolver, session_id, None);
        let args = vec![
            MoveValue::Signer(AccountAddress::ONE),
            vec![observed].as_move_value(),
        ];

        let traversal_storage = TraversalStorage::new();
        session
            .execute_function_bypass_visibility(
                &JWKS_MODULE,
                UPSERT_INTO_OBSERVED_JWKS,
                vec![],
                serialize_values(&args),
                &mut gas_meter,
                &mut TraversalContext::new(&traversal_storage),
                module_storage,
            )
            .map_err(|e| {
                expect_only_successful_execution(e, UPSERT_INTO_OBSERVED_JWKS.as_str(), log_context)
            })
            .map_err(|r| Unexpected(r.unwrap_err()))?;

        let output = get_system_transaction_output(
            session,
            module_storage,
            &self
                .storage_gas_params(log_context)
                .map_err(Unexpected)?
                .change_set_configs,
        )
        .map_err(Unexpected)?;

        Ok((VMStatus::Executed, output))
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/jwk_consensus_config.move (L62-65)
```text
    public fun set_for_next_epoch(framework: &signer, config: JWKConsensusConfig) {
        system_addresses::assert_aptos_framework(framework);
        config_buffer::upsert(config);
    }
```
