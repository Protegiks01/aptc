# Audit Report

## Title
Double-Counting of Block Gas Metrics Due to Parallel-to-Sequential Execution Fallback

## Summary
The `update_block_gas_counters` function can be called multiple times for the same block when parallel execution completes successfully but subsequently fails during finalization, causing the system to fall back to sequential execution and record metrics twice in Prometheus monitoring systems.

## Finding Description

The vulnerability occurs in the block execution fallback mechanism. When a block is executed:

1. **Parallel Execution Records Metrics**: During parallel execution (BlockSTM v1 or v2), when transactions are committed, the `finish_parallel_update_counters_and_log_info()` function is called [1](#0-0) , which invokes `update_block_gas_counters()` [2](#0-1)  to record metrics to Prometheus histograms.

2. **Finalization Can Fail**: After parallel execution completes and metrics are recorded, the `finalize_parallel_execution()` function is called [3](#0-2) . This function can fail with various errors [4](#0-3) , including code invariant errors, final results mismatches, or block epilogue validation failures.

3. **Module Cache Insertion Can Fail**: Additionally, after successful finalization, the `insert_verified()` call can fail [5](#0-4) , which also sets the `has_error` flag.

4. **Fallback to Sequential Execution**: When either of these failures occurs, parallel execution returns `Err(())` [6](#0-5) . The `execute_block()` function catches this error [7](#0-6)  and, if `allow_fallback` is enabled [8](#0-7) , falls back to sequential execution [9](#0-8) .

5. **Sequential Execution Records Metrics Again**: Sequential execution completes and calls `finish_sequential_update_counters_and_log_info()` [10](#0-9) , which again calls `update_block_gas_counters()` for the same block, recording the metrics a second time.

The `update_block_gas_counters()` function uses Prometheus histogram `observe_with()` calls [11](#0-10) , which accumulate observations. Multiple calls for the same block cause double-counting in monitoring dashboards.

## Impact Explanation

This issue is classified as **Medium** severity because it affects operational monitoring and observability, which are critical for validator operators to make informed decisions about capacity planning, alerting, and incident response. While it does not directly compromise consensus safety or cause funds loss, it creates "state inconsistencies requiring intervention" in the monitoring layer, which aligns with the Medium severity category.

Incorrect metrics can lead to:
- False capacity alerts causing unnecessary operational responses
- Incorrect gas usage trends misleading capacity planning decisions
- Inflated block gas consumption metrics affecting economic analysis
- Potential automated systems making decisions based on incorrect data

However, this does not reach High severity as it does not cause validator slowdowns, API crashes, or significant protocol violations, and it does not reach Critical severity as it does not affect consensus, funds, or network availability.

## Likelihood Explanation

The likelihood of this occurring is **Low to Medium**:

- **Triggering Condition**: Requires parallel execution to complete successfully (recording metrics) but then fail during finalization or module cache insertion
- **Error Scenarios**: Most finalization errors are code invariant errors suggesting programmer bugs rather than normal execution paths
- **Failpoint Exists**: A deliberate failpoint exists for testing this scenario [12](#0-11) 
- **Production Occurrence**: While rare, code invariant violations and module cache errors can occur in production under certain conditions

The issue is not directly exploitable by external attackers but occurs due to internal error handling paths that can be triggered by specific runtime conditions.

## Recommendation

**Solution**: Add a flag to track whether metrics have been recorded and prevent duplicate recording:

```rust
// In BlockGasLimitProcessor struct
pub struct BlockGasLimitProcessor<T: Transaction> {
    // ... existing fields ...
    metrics_recorded: bool,
}

// In finish_update_counters_and_log_info
fn finish_update_counters_and_log_info(
    &mut self,  // Changed to &mut
    is_parallel: bool,
    num_committed: u32,
    num_total: u32,
    num_workers: usize,
) {
    if self.metrics_recorded {
        warn!("Metrics already recorded for this block, skipping duplicate recording");
        return;
    }
    
    // ... existing metric recording code ...
    
    self.metrics_recorded = true;
}
```

Alternatively, refactor the code to only record metrics once after the final successful execution mode is determined, rather than during both parallel and sequential execution paths.

## Proof of Concept

```rust
// Test demonstrating double metric recording
#[test]
fn test_parallel_failure_causes_double_metrics() {
    // Setup block executor with fallback enabled
    let config = BlockExecutorConfig {
        local: LocalExecutorConfig {
            concurrency_level: 4,
            allow_fallback: true,
            ..Default::default()
        },
        ..Default::default()
    };
    
    let executor = BlockExecutor::new(config);
    
    // Create a block that will trigger parallel execution
    let block = create_test_block_with_transactions(100);
    
    // Inject failpoint to trigger error after parallel metrics recorded
    fail::cfg("commit-all-halt-err", "return").unwrap();
    
    // Record initial metric counts
    let initial_block_gas_count = get_histogram_sample_count("aptos_execution_block_gas");
    
    // Execute block - parallel will succeed and record metrics, then fail,
    // causing fallback to sequential which records metrics again
    let result = executor.execute_block(&block, &base_view, &metadata, &mut cache);
    
    assert!(result.is_ok());
    
    // Verify metrics were recorded twice (once for parallel, once for sequential)
    let final_block_gas_count = get_histogram_sample_count("aptos_execution_block_gas");
    assert_eq!(final_block_gas_count, initial_block_gas_count + 2);
    
    fail::remove("commit-all-halt-err");
}
```

## Notes

This vulnerability represents a monitoring accuracy issue rather than a direct security threat to consensus or execution correctness. The actual block execution remains deterministic and correct regardless of which execution mode succeeds. However, accurate metrics are essential for operational decision-making in production blockchain environments, and double-counting can lead to misleading dashboards and false alerts that impact validator operations.

### Citations

**File:** aptos-move/block-executor/src/txn_last_input_output.rs (L388-392)
```rust
            block_limit_processor.finish_parallel_update_counters_and_log_info(
                txn_idx + 1,
                num_txns,
                num_workers,
            );
```

**File:** aptos-move/block-executor/src/txn_last_input_output.rs (L396-399)
```rust
            fail_point!("commit-all-halt-err", |_| Err(code_invariant_error(
                "fail points: Last committed transaction halted"
            )
            .into()));
```

**File:** aptos-move/block-executor/src/limit_processor.rs (L216-222)
```rust
        counters::update_block_gas_counters(
            &self.accumulated_fee_statement,
            accumulated_effective_block_gas,
            accumulated_approx_output_size,
            num_committed as usize,
            is_parallel,
        );
```

**File:** aptos-move/block-executor/src/executor.rs (L1571-1613)
```rust
            return Err(code_invariant_error(
                "BlockSTMv2: Commit tasks not drained after parallel execution",
            ));
        }

        if final_results.dereference().len() != num_txns + 1 {
            // If this error fires, then the final results length mismatch is
            // due to a bug in the executor.
            return Err(code_invariant_error(format!(
                "Final results length mismatch: {} != {} + 1",
                final_results.dereference().len(),
                num_txns
            )));
        }

        // TODO: test block epilogue append logic once its generation is made a trait
        // method on T (and can be easily mocked).
        if let Some(epilogue_txn_idx) = *shared_sync_params
            .maybe_block_epilogue_txn_idx
            .dereference()
        {
            if epilogue_txn_idx == 0
                || epilogue_txn_idx as usize > num_txns
                || !final_results.dereference()[epilogue_txn_idx as usize - 1]
                    .check_materialization()?
                || final_results.dereference()[epilogue_txn_idx as usize - 1]
                    .after_materialization()?
                    .has_new_epoch_event()
            {
                // If this error fires, and epilogue_txn_idx is not 0 or > num_txns,
                // then is_retry_check_after_commit would have created a panic error,
                // internally logging the reason.
                return Err(code_invariant_error(format!(
                            "Output preceding epilogue txn {} must neither be retry nor have new epoch event",
                            epilogue_txn_idx
                        )));
            }
            if final_results.dereference()[epilogue_txn_idx as usize].check_materialization()? {
                return Err(code_invariant_error(format!(
                    "Output at epilogue txn index {} must be placeholder (is_retry set)",
                    epilogue_txn_idx
                )));
            }
```

**File:** aptos-move/block-executor/src/executor.rs (L1967-1975)
```rust
            match self.finalize_parallel_execution(
                maybe_executor.into_inner(),
                signature_verified_block,
                scheduler.pop_from_commit_queue().is_ok(),
                transaction_slice_metadata,
                SchedulerWrapper::V1(&scheduler, &skip_module_reads_validation),
                module_cache_manager_guard.environment(),
                &shared_sync_params,
            ) {
```

**File:** aptos-move/block-executor/src/executor.rs (L1980-1983)
```rust
                        module_cache_manager_guard
                            .module_cache_mut()
                            .insert_verified(versioned_cache.take_modules_iter())
                            .is_err(),
```

**File:** aptos-move/block-executor/src/executor.rs (L1994-1995)
```rust
        if has_error {
            return Err(());
```

**File:** aptos-move/block-executor/src/executor.rs (L2535-2538)
```rust
        block_limit_processor.finish_sequential_update_counters_and_log_info(
            ret.len() as u32,
            num_txns as u32 + block_epilogue_txn.as_ref().map_or(0, |_| 1),
        );
```

**File:** aptos-move/block-executor/src/executor.rs (L2576-2579)
```rust
            // If parallel gave us result, return it
            if let Ok(output) = parallel_result {
                return Ok(output);
            }
```

**File:** aptos-move/block-executor/src/executor.rs (L2581-2583)
```rust
            if !self.config.local.allow_fallback {
                panic!("Parallel execution failed and fallback is not allowed");
            }
```

**File:** aptos-move/block-executor/src/executor.rs (L2600-2606)
```rust
        let sequential_result = self.execute_transactions_sequential(
            signature_verified_block,
            base_view,
            transaction_slice_metadata,
            module_cache_manager_guard,
            false,
        );
```

**File:** aptos-move/block-executor/src/counters.rs (L304-309)
```rust
    observe_gas(&BLOCK_GAS, mode_str, accumulated_fee_statement);
    BLOCK_COMMITTED_TXNS.observe_with(&[mode_str], num_committed as f64);

    EFFECTIVE_BLOCK_GAS.observe_with(&[mode_str], accumulated_effective_gas as f64);

    APPROX_BLOCK_OUTPUT_SIZE.observe_with(&[mode_str], accumulated_approx_output_size as f64);
```
