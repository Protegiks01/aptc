# Audit Report

## Title
Legacy Token Standard Allows Zero Royalty Denominator Causing Division-by-Zero in Marketplace Contracts

## Summary
The legacy token standard (`0x3::token`) in Aptos framework fails to validate that `royalty_points_denominator` is non-zero when creating token royalty data. This allows malicious or careless token creators to create tokens with a (0, 0) royalty configuration, which propagates through the indexer into the database and causes division-by-zero transaction aborts in marketplace contracts that calculate royalty payments. [1](#0-0) 

## Finding Description

The vulnerability exists in the `create_royalty()` function of the legacy token module, which only validates that the numerator does not exceed the denominator, but fails to check if the denominator is zero: [2](#0-1) 

This allows a token creator to call `create_tokendata()` with `royalty_points_denominator = 0` and `royalty_points_numerator = 0`, since the validation `0 <= 0` passes: [3](#0-2) 

The token is then created with an invalid royalty structure: [4](#0-3) 

The indexer faithfully stores this invalid data in the database without additional validation: [5](#0-4) [6](#0-5) 

When marketplace contracts attempt to calculate royalty payments using direct division, they encounter runtime division-by-zero errors that abort the transaction: [7](#0-6) 

In contrast, the modern token objects standard (`0x4::royalty`) correctly validates against zero denominator: [8](#0-7) 

## Impact Explanation

This is a **High severity** vulnerability based on the following impact:

1. **Token Trading DoS**: Tokens created with zero denominator royalty become non-tradeable in marketplace contracts that perform direct division, causing transaction aborts and preventing legitimate trades.

2. **Protocol Violation**: The invariant that royalty percentages must be well-formed rational numbers (numerator/denominator) is violated, allowing mathematically invalid data to persist in the blockchain state and indexer database.

3. **Core Framework Issue**: The vulnerability exists in the core Aptos token framework that is used by production applications, not just example code.

4. **Malicious Exploitation**: Attackers can intentionally create tokens with zero denominator to make them non-tradeable in certain marketplaces, or to discover which marketplaces lack defensive checks.

While this does not directly cause fund loss or consensus violations, it represents a **significant protocol violation** and can cause **API/application crashes** (transaction aborts), which aligns with the High severity criteria in the Aptos bug bounty program.

## Likelihood Explanation

**Likelihood: Medium-High**

- **Ease of Exploitation**: Any user can create a legacy token with zero denominator royalty by simply calling `create_tokendata()` with appropriate parameters. No special privileges required.

- **Detection Difficulty**: The vulnerability is not immediately obvious and can be accidentally triggered by developers who don't realize zero is an invalid denominator.

- **Affected Systems**: All legacy tokens (0x3::token) are vulnerable. While the modern standard (0x4::royalty) is fixed, many existing tokens and applications still use the legacy standard.

- **Mitigation Coverage**: Some marketplace contracts (like `listing.move`) use defensive programming with the `bounded_percentage()` helper, but not all: [9](#0-8) 

## Recommendation

**Immediate Fix**: Add zero denominator validation to the legacy token module's `create_royalty()` function:

```move
public fun create_royalty(royalty_points_numerator: u64, royalty_points_denominator: u64, payee_address: address): Royalty {
    assert!(royalty_points_denominator != 0, error::invalid_argument(EROYALTY_DENOMINATOR_IS_ZERO));
    assert!(royalty_points_numerator <= royalty_points_denominator, error::invalid_argument(EINVALID_ROYALTY_NUMERATOR_DENOMINATOR));
    Royalty {
        royalty_points_numerator,
        royalty_points_denominator,
        payee_address
    }
}
```

Define the new error constant:
```move
const EROYALTY_DENOMINATOR_IS_ZERO: u64 = 37;
```

**Additional Recommendations**:
1. Add similar validation to `create_tokendata()` for defense in depth
2. Add indexer-level validation warnings (non-blocking) for data quality monitoring
3. Document best practices for marketplace contracts to use defensive royalty calculations
4. Consider deprecation path for legacy token standard in favor of the secure modern standard

## Proof of Concept

```move
#[test]
#[expected_failure(abort_code = 0x10025, location = aptos_token::token)] // Should fail but currently passes
fun test_create_token_with_zero_royalty_denominator() {
    let creator = @0xcafe;
    account::create_account_for_test(creator);
    
    // Create collection
    token::create_collection(
        &signer::create_signer_for_testing(creator),
        string::utf8(b"Test Collection"),
        string::utf8(b"Description"),
        string::utf8(b"https://test.com"),
        1000,
        vector[false, false, false]
    );
    
    // This should fail but currently succeeds - creating token with (0, 0) royalty
    let token_data_id = token::create_tokendata(
        &signer::create_signer_for_testing(creator),
        string::utf8(b"Test Collection"),
        string::utf8(b"Test Token"),
        string::utf8(b"Description"),
        100,
        string::utf8(b"https://test.com"),
        creator,
        0,  // denominator = 0 (INVALID!)
        0,  // numerator = 0
        token::create_token_mutability_config(&vector[false, false, false, false, false]),
        vector[],
        vector[],
        vector[]
    );
    
    // Now attempt to calculate royalty in a marketplace scenario
    let price = 1000;
    let royalty = token::get_royalty(token_data_id);
    let numerator = token::get_royalty_numerator(&royalty);
    let denominator = token::get_royalty_denominator(&royalty);
    
    // This will cause division by zero abort!
    let royalty_charge = price * numerator / denominator;  // CRASH!
}
```

**Notes:**
- This vulnerability affects only the legacy token standard (`0x3::token`)
- The modern token objects standard (`0x4::royalty`) has proper validation
- The indexer correctly stores the data as-is without crashing, but the invalid data causes downstream application failures
- Answer to the specific question: **No, numerator cannot exceed denominator** (this is validated), but **yes, zero denominator can cause division-by-zero errors**

### Citations

**File:** aptos-move/framework/aptos-token/sources/token.move (L1001-1010)
```text
    public fun create_royalty(royalty_points_numerator: u64, royalty_points_denominator: u64, payee_address: address): Royalty {
        assert!(royalty_points_numerator <= royalty_points_denominator, error::invalid_argument(EINVALID_ROYALTY_NUMERATOR_DENOMINATOR));
        // Question[Orderless]: Is it okay to remove this check to accommodate stateless accounts?
        // assert!(account::exists_at(payee_address), error::invalid_argument(EROYALTY_PAYEE_ACCOUNT_DOES_NOT_EXIST));
        Royalty {
            royalty_points_numerator,
            royalty_points_denominator,
            payee_address
        }
    }
```

**File:** aptos-move/framework/aptos-token/sources/token.move (L1267-1267)
```text
        assert!(royalty_points_numerator <= royalty_points_denominator, error::invalid_argument(EINVALID_ROYALTY_NUMERATOR_DENOMINATOR));
```

**File:** aptos-move/framework/aptos-token/sources/token.move (L1304-1304)
```text
            royalty: create_royalty(royalty_points_numerator, royalty_points_denominator, royalty_payee_address),
```

**File:** crates/indexer/src/models/token_models/token_datas.rs (L118-125)
```rust
                        royalty_points_numerator: token_data
                            .royalty
                            .royalty_points_numerator
                            .clone(),
                        royalty_points_denominator: token_data
                            .royalty
                            .royalty_points_denominator
                            .clone(),
```

**File:** crates/indexer/src/schema.rs (L335-336)
```rust
        royalty_points_numerator -> Numeric,
        royalty_points_denominator -> Numeric,
```

**File:** aptos-move/move-examples/marketplace/sources/token_offer.move (L384-384)
```text
        let royalty_charge = price * royalty_numerator / royalty_denominator;
```

**File:** aptos-move/framework/aptos-token-objects/sources/royalty.move (L54-58)
```text
    public fun create(numerator: u64, denominator: u64, payee_address: address): Royalty {
        assert!(denominator != 0, error::out_of_range(EROYALTY_DENOMINATOR_IS_ZERO));
        assert!(numerator <= denominator, error::out_of_range(EROYALTY_EXCEEDS_MAXIMUM));

        Royalty { numerator, denominator, payee_address }
```

**File:** aptos-move/move-examples/marketplace/sources/listing.move (L292-299)
```text
    /// Calculates a bounded percentage that can't go over 100% and handles 0 denominator as 0
    public inline fun bounded_percentage(amount: u64, numerator: u64, denominator: u64): u64 {
        if (denominator == 0) {
            0
        } else {
            math64::min(amount, math64::mul_div(amount, numerator, denominator))
        }
    }
```
