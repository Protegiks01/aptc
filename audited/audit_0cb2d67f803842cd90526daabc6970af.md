# Audit Report

## Title
Native Struct Bypass Causes Validator Node Crash via Unvalidated Module Publishing

## Summary
The bytecode verifier fails to prevent user modules from declaring native structs, which are explicitly marked as removed in the runtime. When such modules are published and loaded, the runtime loader triggers a panic via `unreachable!()`, causing validator node crashes. This bypasses all struct field validation checks and violates the Move VM safety invariant.

## Finding Description

The vulnerability exists across three critical components:

1. **Verification Bypass**: In the signature verifier, native structs completely bypass validation: [1](#0-0) 

2. **Missing Native Struct Check**: The native validation logic only checks native functions, not native structs: [2](#0-1) 

3. **Runtime Panic**: When the module loader encounters a native struct during execution, it panics: [3](#0-2) 

**Attack Flow:**
1. Attacker crafts a module with `StructFieldInformation::Native` in the bytecode
2. Module passes all bytecode verification checks because native structs are skipped
3. Module passes native validation because it only checks native functions
4. During transaction execution or module loading, `Module::new()` is called
5. `make_struct_type()` hits the `unreachable!()` panic for native structs
6. The panic occurs outside the VMState::VERIFIER context, so the crash handler kills the validator process: [4](#0-3) 

This breaks the **Move VM Safety** invariant (bytecode execution must respect safety constraints) and the **Deterministic Execution** invariant (all validators must execute identically without crashing).

## Impact Explanation

**High Severity** - This qualifies under the "Validator node slowdowns" and "Significant protocol violations" categories. A malicious actor can:

- Publish a module with native structs that passes all verification
- Cause any validator executing a transaction that loads this module to crash
- Trigger coordinated crashes across multiple validators if they attempt to execute transactions involving the malicious module
- Potentially cause liveness issues if enough validators crash simultaneously

While not a direct consensus safety violation, this enables a Denial of Service attack against validator infrastructure that can impact network availability and violates critical VM safety guarantees.

## Likelihood Explanation

**High Likelihood** - The attack is straightforward to execute:
- Requires only the ability to publish a module (standard user capability)
- No special privileges or validator access needed
- The vulnerability is deterministic and reproducible
- Multiple verification layers fail to catch the issue
- The runtime comment explicitly states "native structs have been removed," indicating they should not exist, yet no validation prevents them

The only cost barrier is the gas fee for module publishing, which is nominal compared to the impact.

## Recommendation

Add explicit validation to reject native structs in user modules. Implement a check in `native_validation.rs`:

```rust
pub(crate) fn validate_module_natives(modules: &[CompiledModule]) -> VMResult<()> {
    for module in modules {
        let module_address = module.self_addr();
        
        // Check native functions
        for native in module.function_defs().iter().filter(|def| def.is_native()) {
            if native.is_entry || !module_address.is_special() {
                return Err(
                    PartialVMError::new(StatusCode::USER_DEFINED_NATIVE_NOT_ALLOWED)
                        .with_message("Cannot publish native function to non-special address".to_string())
                        .finish(Location::Module(module.self_id())),
                );
            }
        }
        
        // NEW: Check native structs
        if let Some(struct_defs) = module.struct_defs() {
            for struct_def in struct_defs {
                if matches!(struct_def.field_information, StructFieldInformation::Native) {
                    if !module_address.is_special() {
                        return Err(
                            PartialVMError::new(StatusCode::USER_DEFINED_NATIVE_NOT_ALLOWED)
                                .with_message("Cannot publish native struct to non-special address".to_string())
                                .finish(Location::Module(module.self_id())),
                        );
                    }
                }
            }
        }
    }
    Ok(())
}
```

## Proof of Concept

Create a Rust test that constructs a module with a native struct:

```rust
use move_binary_format::file_format::*;
use move_bytecode_verifier::verify_module;
use move_core_types::{account_address::AccountAddress, identifier::Identifier};

#[test]
fn test_native_struct_bypass() {
    let module = CompiledModule {
        version: 7,
        self_module_handle_idx: ModuleHandleIndex(0),
        module_handles: vec![ModuleHandle {
            address: AddressIdentifierIndex(0),
            name: IdentifierIndex(0),
        }],
        struct_handles: vec![StructHandle {
            module: ModuleHandleIndex(0),
            name: IdentifierIndex(1),
            abilities: AbilitySet::EMPTY,
            type_parameters: vec![],
        }],
        function_handles: vec![],
        field_handles: vec![],
        friend_decls: vec![],
        struct_def_instantiations: vec![],
        function_instantiations: vec![],
        field_instantiations: vec![],
        signatures: vec![Signature(vec![])],
        identifiers: vec![
            Identifier::new("test_module").unwrap(),
            Identifier::new("MaliciousNativeStruct").unwrap(),
        ],
        address_identifiers: vec![AccountAddress::random()],
        constant_pool: vec![],
        metadata: vec![],
        struct_defs: vec![StructDefinition {
            struct_handle: StructHandleIndex(0),
            field_information: StructFieldInformation::Native,  // MALICIOUS
        }],
        function_defs: vec![],
        struct_variant_handles: vec![],
        struct_variant_instantiations: vec![],
        variant_field_handles: vec![],
        variant_field_instantiations: vec![],
    };

    // This should fail but currently passes verification
    let result = verify_module(&module);
    assert!(result.is_ok(), "Module with native struct passed verification");
    
    // When loaded by runtime, this will panic:
    // thread 'main' panicked at 'native structs have been removed'
}
```

**Notes**

The vulnerability exists because native structs were intended to be removed from the Move VM but the validation logic was never updated to explicitly reject them during module publishing. All verification passes (bounds checking, signature verification, duplication checking) skip native structs without validation, while the runtime explicitly panics when encountering them. This creates a critical gap where invalid bytecode can pass verification and cause runtime crashes.

### Citations

**File:** third_party/move/move-bytecode-verifier/src/signature_v2.rs (L1084-1085)
```rust
        match &struct_def.field_information {
            StructFieldInformation::Native => Ok(()),
```

**File:** aptos-move/aptos-vm/src/verifier/native_validation.rs (L12-27)
```rust
pub(crate) fn validate_module_natives(modules: &[CompiledModule]) -> VMResult<()> {
    for module in modules {
        let module_address = module.self_addr();
        for native in module.function_defs().iter().filter(|def| def.is_native()) {
            if native.is_entry || !module_address.is_special() {
                return Err(
                    PartialVMError::new(StatusCode::USER_DEFINED_NATIVE_NOT_ALLOWED)
                        .with_message(
                            "Cannot publish native function to non-special address".to_string(),
                        )
                        .finish(Location::Module(module.self_id())),
                );
            }
        }
    }
    Ok(())
```

**File:** third_party/move/move-vm/runtime/src/loader/modules.rs (L452-453)
```rust
        let layout = match &struct_def.field_information {
            StructFieldInformation::Native => unreachable!("native structs have been removed"),
```

**File:** crates/crash-handler/src/lib.rs (L48-57)
```rust
    // Do not kill the process if the panics happened at move-bytecode-verifier.
    // This is safe because the `state::get_state()` uses a thread_local for storing states. Thus the state can only be mutated to VERIFIER by the thread that's running the bytecode verifier.
    //
    // TODO: once `can_unwind` is stable, we should assert it. See https://github.com/rust-lang/rust/issues/92988.
    if state::get_state() == VMState::VERIFIER || state::get_state() == VMState::DESERIALIZER {
        return;
    }

    // Kill the process
    process::exit(12);
```
