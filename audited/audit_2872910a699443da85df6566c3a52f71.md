# Audit Report

## Title
Unrestricted Cross-Network Information Disclosure in Peer Monitoring Service Enables Network Topology Mapping for Sybil Attacks

## Summary
The `GetNetworkInformation` RPC endpoint in the peer monitoring service discloses complete network topology information to any connected peer, including cross-network peer connections. Untrusted public network peers can query VFNs and fullnodes to obtain validator network connection details, peer roles, and network addresses across all network boundaries, enabling comprehensive network mapping for Sybil attack positioning and targeted attacks.

## Finding Description
The peer monitoring service implements a `GetNetworkInformation` request handler that returns detailed connection metadata for all peers connected to a node. The vulnerability manifests through three critical design flaws:

**1. No Access Control**: The service accepts requests from any connected peer without verifying trust level or peer role. [1](#0-0) 

**2. Cross-Network Information Leakage**: The `get_network_information()` handler calls `get_connected_peers_and_metadata()` which iterates through ALL networks and returns ALL connected peers regardless of which network the request originated from. [2](#0-1) 

The underlying `get_connected_peers_and_metadata()` method explicitly iterates through all networks without filtering: [3](#0-2) 

**3. Permissive Connection Policy**: Public fullnodes use `HandshakeAuthMode::MaybeMutual` which accepts connections from unknown peers, assigning them `PeerRole::Unknown` but granting full protocol access. [4](#0-3) 

**Attack Scenario**:
1. Attacker creates multiple Sybil nodes and connects them to public fullnodes (allowed by MaybeMutual mode)
2. Attacker sends `GetNetworkInformation` requests to VFNs via their public network interfaces
3. VFN responds with NetworkInformationResponse containing ALL connected peers including:
   - Validator network connections (PeerNetworkId with NetworkId::Validator)
   - Network addresses, Peer IDs, and Peer roles
   - Distance from validators metric
4. Attacker recursively queries discovered nodes to build complete network graph
5. Attacker identifies optimal Sybil node placement for eclipse attacks, routing manipulation, or targeted DoS

**Disclosed Information**: [5](#0-4) 

The response includes sensitive topology data: connected peer network addresses, cryptographic peer identities, role classifications (Validator, ValidatorFullNode, Unknown), and network depth metrics.

## Impact Explanation
This qualifies as **Medium Severity** under the Aptos Bug Bounty program criteria for "network protocol attacks" and "state inconsistencies requiring intervention."

**Direct Impact**:
- Complete network topology disclosure to untrusted actors
- Validator connection patterns revealed through VFN queries
- Network addressing and routing structure exposed
- Peer role classifications leaked (identifying high-value targets)

**Enablement of Secondary Attacks**:
- **Eclipse Attacks**: Attacker positions Sybil nodes to isolate victims by understanding connection patterns
- **Targeted Resource Exhaustion**: Identification of high-connectivity nodes for amplification attacks  
- **Validator Reconnaissance**: Discovery of validator network addresses for focused attack campaigns
- **Route Manipulation**: Understanding of network topology enables BGP-style routing attacks

While this does not directly cause consensus violations or fund loss, it fundamentally undermines the network's security assumptions about topology privacy and enables sophisticated network-layer attacks that could lead to liveness degradation or consensus disruption.

## Likelihood Explanation
**Likelihood: HIGH**

The attack is trivial to execute:
- No special credentials or validator access required
- Standard RPC call over established connection
- Public fullnodes designed to accept unknown peer connections
- No rate limiting or suspicious activity detection on this endpoint
- Information immediately usable for attack planning

The vulnerability is currently exploitable on all production Aptos nodes running the peer monitoring service with default configurations.

## Recommendation
Implement network-scoped information filtering with access controls:

**1. Filter by Request Origin Network**:
Modify `get_network_information()` to only return peers from the same network as the requesting peer:

```rust
fn get_network_information(&self, request_network_id: NetworkId) -> Result<PeerMonitoringServiceResponse, Error> {
    let all_peers_and_metadata = self.peers_and_metadata.get_connected_peers_and_metadata()?;
    
    // Filter to only peers from the same network as the requester
    let connected_peers = all_peers_and_metadata
        .into_iter()
        .filter(|(peer_network_id, _)| peer_network_id.network_id() == request_network_id)
        .map(|(peer, metadata)| {
            let connection_metadata = metadata.get_connection_metadata();
            (peer, ConnectionMetadata::new(
                connection_metadata.addr,
                connection_metadata.remote_peer_id,
                connection_metadata.role,
            ))
        })
        .collect();
    
    // ... rest of implementation
}
```

**2. Implement Trust-Based Access Control**:
Restrict detailed network information to trusted peers only, providing minimal data to Unknown peers:

```rust
fn get_network_information(&self, peer_role: PeerRole) -> Result<PeerMonitoringServiceResponse, Error> {
    if !matches!(peer_role, PeerRole::Validator | PeerRole::ValidatorFullNode) {
        // Return minimal information for untrusted peers
        return Ok(PeerMonitoringServiceResponse::NetworkInformation(
            NetworkInformationResponse {
                connected_peers: BTreeMap::new(), // Don't disclose peer list
                distance_from_validators: MAX_DISTANCE_FROM_VALIDATORS, // Generic distance
            }
        ));
    }
    // Full information for trusted peers
    // ... existing implementation
}
```

**3. Add Configuration Option**:
Provide `expose_network_topology` configuration flag (default: false) for operators who explicitly want to expose this information for monitoring purposes.

## Proof of Concept

```rust
use aptos_config::network_id::{NetworkId, PeerNetworkId};
use aptos_network::application::storage::PeersAndMetadata;
use aptos_peer_monitoring_service_types::{
    request::PeerMonitoringServiceRequest,
    response::PeerMonitoringServiceResponse,
};
use aptos_types::PeerId;

#[tokio::test]
async fn test_cross_network_information_disclosure() {
    // Setup: Create a VFN with connections on both VFN network (to validator) 
    // and Public network (to public peers)
    let vfn_peer_id = PeerId::random();
    let validator_peer_id = PeerId::random();
    let public_peer_id = PeerId::random();
    
    // VFN is connected to validator on VFN network
    let validator_peer_network_id = PeerNetworkId::new(NetworkId::Vfn, validator_peer_id);
    
    // VFN is also connected to unknown peer on Public network
    let public_peer_network_id = PeerNetworkId::new(NetworkId::Public, public_peer_id);
    
    // Simulate attacker (unknown public peer) sending GetNetworkInformation request
    let request = PeerMonitoringServiceRequest::GetNetworkInformation;
    
    // The response will include BOTH the validator connection (VFN network)
    // AND the public peer connection (Public network), exposing cross-network topology
    let response = send_request_to_vfn(public_peer_network_id, request).await.unwrap();
    
    if let PeerMonitoringServiceResponse::NetworkInformation(info) = response {
        // VULNERABILITY: Public peer can see validator connections
        assert!(info.connected_peers.contains_key(&validator_peer_network_id));
        
        // Extract validator network address leaked to untrusted peer
        let validator_metadata = &info.connected_peers[&validator_peer_network_id];
        println!("Leaked validator address: {:?}", validator_metadata.network_address);
        println!("Leaked validator role: {:?}", validator_metadata.peer_role);
        
        // Attacker now knows validator network topology
    }
}
```

## Notes

The vulnerability exists because `PeersAndMetadata` is a global structure shared across all network interfaces on a node, and the response handler makes no attempt to scope the returned information to the requesting network context. While the `network_id` parameter is passed to `Handler::call()`, it's only used for metrics and logging, not for filtering the peer list in the response.

This represents a clear violation of network boundary isolation where public network interfaces should not expose private network (VFN/Validator) connection details. The vulnerability is particularly severe for VFNs which maintain connections on both private validator networks and public networks simultaneously.

### Citations

**File:** peer-monitoring-service/server/src/lib.rs (L155-182)
```rust
    pub fn call(
        &self,
        network_id: NetworkId,
        request: PeerMonitoringServiceRequest,
    ) -> Result<PeerMonitoringServiceResponse> {
        // Update the request count
        increment_counter(
            &metrics::PEER_MONITORING_REQUESTS_RECEIVED,
            network_id,
            request.get_label(),
        );

        // Time the request processing (the timer will stop when it's dropped)
        let _timer = start_timer(
            &metrics::PEER_MONITORING_REQUEST_PROCESSING_LATENCY,
            network_id,
            request.get_label(),
        );

        // Process the request
        let response = match &request {
            PeerMonitoringServiceRequest::GetNetworkInformation => self.get_network_information(),
            PeerMonitoringServiceRequest::GetServerProtocolVersion => {
                self.get_server_protocol_version()
            },
            PeerMonitoringServiceRequest::GetNodeInformation => self.get_node_information(),
            PeerMonitoringServiceRequest::LatencyPing(request) => self.handle_latency_ping(request),
        };
```

**File:** peer-monitoring-service/server/src/lib.rs (L217-248)
```rust
    fn get_network_information(&self) -> Result<PeerMonitoringServiceResponse, Error> {
        // Get the connected peers
        let connected_peers_and_metadata =
            self.peers_and_metadata.get_connected_peers_and_metadata()?;
        let connected_peers = connected_peers_and_metadata
            .into_iter()
            .map(|(peer, metadata)| {
                let connection_metadata = metadata.get_connection_metadata();
                (
                    peer,
                    ConnectionMetadata::new(
                        connection_metadata.addr,
                        connection_metadata.remote_peer_id,
                        connection_metadata.role,
                    ),
                )
            })
            .collect();

        // Get the distance from the validators
        let distance_from_validators =
            get_distance_from_validators(&self.base_config, self.peers_and_metadata.clone());

        // Create and return the response
        let network_information_response = NetworkInformationResponse {
            connected_peers,
            distance_from_validators,
        };
        Ok(PeerMonitoringServiceResponse::NetworkInformation(
            network_information_response,
        ))
    }
```

**File:** network/framework/src/application/storage.rs (L108-125)
```rust
    pub fn get_connected_peers_and_metadata(
        &self,
    ) -> Result<HashMap<PeerNetworkId, PeerMetadata>, Error> {
        // Get the cached peers and metadata
        let cached_peers_and_metadata = self.cached_peers_and_metadata.load();

        // Collect all connected peers
        let mut connected_peers_and_metadata = HashMap::new();
        for (network_id, peers_and_metadata) in cached_peers_and_metadata.iter() {
            for (peer_id, peer_metadata) in peers_and_metadata.iter() {
                if peer_metadata.is_connected() {
                    let peer_network_id = PeerNetworkId::new(*network_id, *peer_id);
                    connected_peers_and_metadata.insert(peer_network_id, peer_metadata.clone());
                }
            }
        }
        Ok(connected_peers_and_metadata)
    }
```

**File:** network/framework/src/noise/handshake.rs (L384-427)
```rust
            HandshakeAuthMode::MaybeMutual(peers_and_metadata) => {
                let trusted_peers = peers_and_metadata.get_trusted_peers(&network_id)?;
                let trusted_peer = trusted_peers.get(&remote_peer_id).cloned();
                match trusted_peer {
                    Some(peer) => {
                        Self::authenticate_inbound(remote_peer_short, &peer, &remote_public_key)
                    },
                    None => {
                        // The peer is not in the trusted peer set. Verify that the Peer ID is
                        // constructed correctly from the public key.
                        let derived_remote_peer_id =
                            aptos_types::account_address::from_identity_public_key(
                                remote_public_key,
                            );
                        if derived_remote_peer_id != remote_peer_id {
                            // The peer ID is not constructed correctly from the public key
                            Err(NoiseHandshakeError::ClientPeerIdMismatch(
                                remote_peer_short,
                                remote_peer_id,
                                derived_remote_peer_id,
                            ))
                        } else {
                            // Try to infer the role from the network context
                            if self.network_context.role().is_validator() {
                                if network_id.is_vfn_network() {
                                    // Inbound connections to validators on the VFN network must be VFNs
                                    Ok(PeerRole::ValidatorFullNode)
                                } else {
                                    // Otherwise, they're unknown. Validators will connect through
                                    // authenticated channels (on the validator network) so shouldn't hit
                                    // this, and PFNs will connect on public networks (which aren't common).
                                    Ok(PeerRole::Unknown)
                                }
                            } else {
                                // We're a VFN or PFN. VFNs get no inbound connections on the vfn network
                                // (so the peer won't be a validator). Thus, we're on the public network
                                // so mark the peer as unknown.
                                Ok(PeerRole::Unknown)
                            }
                        }
                    },
                }
            },
        }?;
```

**File:** peer-monitoring-service/types/src/response.rs (L50-85)
```rust
/// A response for the network information request
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
pub struct NetworkInformationResponse {
    pub connected_peers: BTreeMap<PeerNetworkId, ConnectionMetadata>, // Connected peers
    pub distance_from_validators: u64, // The distance of the peer from the validator set
}

// Display formatting provides a high-level summary of the response
impl Display for NetworkInformationResponse {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "{{ num_connected_peers: {:?}, distance_from_validators: {:?} }}",
            self.connected_peers.len(),
            self.distance_from_validators,
        )
    }
}

/// Simple connection metadata associated with each peer
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
pub struct ConnectionMetadata {
    pub network_address: NetworkAddress,
    pub peer_id: PeerId,
    pub peer_role: PeerRole,
}

impl ConnectionMetadata {
    pub fn new(network_address: NetworkAddress, peer_id: PeerId, peer_role: PeerRole) -> Self {
        Self {
            network_address,
            peer_id,
            peer_role,
        }
    }
}
```
