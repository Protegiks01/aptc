# Audit Report

## Title
Panic-Induced Denial of Service via Removed Validator Secret Shares

## Summary
When validators leave the validator set during epoch transitions, the secret sharing verification code uses `.expect()` to retrieve their validator index, causing a panic when they are not found. This allows removed validators to crash verification tasks by sending secret share messages, leading to resource exhaustion and disruption of the randomness generation subsystem.

## Finding Description

The secret sharing mechanism fails to gracefully handle messages from validators who have left the validator set. The vulnerability exists in the `get_id()` function which is called during share verification: [1](#0-0) 

The verification flow proceeds as follows:

1. A `SecretShareMessage` arrives at the verification task [2](#0-1) 

2. The message epoch is validated against the current epoch state [3](#0-2) 

3. For share messages, `share.verify(config)` is invoked [4](#0-3) 

4. The verification calls `config.get_id(self.author())` which panics if the author is not in the current validator set

**Attack Scenario:**
- Validator V participates in epoch N
- V leaves the validator set (not in epoch N+1) 
- V crafts a `SecretShareMessage::Share` with their address as author and epoch set to N+1
- V sends this message to active validators
- Receiving nodes attempt verification, which calls `get_id(V's address)`
- Since V is not in epoch N+1's validator set, the HashMap lookup returns `None`
- The `.expect("Peer should be in the index!")` panics, crashing the verification task

The same vulnerability exists in two other locations: [5](#0-4) [6](#0-5) 

Notably, there is a TODO comment acknowledging the need for bounds checking: [7](#0-6) 

## Impact Explanation

This vulnerability represents **High Severity** per the Aptos bug bounty criteria:

1. **Validator Node Slowdowns/Disruption**: Each malicious message spawns a verification task that panics, consuming resources from the bounded executor
2. **Randomness Generation Disruption**: The secret sharing mechanism is part of the randomness generation subsystem. Repeated panics could prevent proper secret aggregation
3. **Resource Exhaustion**: A removed validator can spam messages to exhaust the bounded executor's task pool

While this does not directly break consensus safety or cause fund loss, it represents a significant protocol violation affecting validator node stability and the availability of the randomness subsystem.

## Likelihood Explanation

**Likelihood: Medium to High**

**Attack Requirements:**
- The attacker must be a former validator (had consensus keys for a previous epoch)
- The attacker must be able to send network messages to current validators
- No cryptographic material for the current epoch is required (panic occurs before cryptographic verification)

**Ease of Exploitation:**
- Simple to execute: craft a message with the former validator's address and current epoch
- No complex timing or state manipulation required
- Can be repeated continuously for sustained DoS effect

**Mitigating Factors:**
- Requires the attacker to have been a validator in a previous epoch
- Network-level DoS protections may rate-limit message processing

## Recommendation

Replace all `.expect()` calls with proper error handling that returns `Result` types:

**Fix for `types/src/secret_sharing.rs`:**
```rust
pub fn get_id(&self, peer: &Author) -> anyhow::Result<usize> {
    self.validator
        .address_to_validator_index()
        .get(peer)
        .copied()
        .ok_or_else(|| anyhow::anyhow!("Validator {} not in current validator set", peer))
}

pub fn verify(&self, config: &SecretShareConfig) -> anyhow::Result<()> {
    let index = config.get_id(self.author())?;
    ensure!(index < config.verification_keys.len(), 
            "Validator index {} out of bounds", index);
    let decryption_key_share = self.share().clone();
    config.verification_keys[index]
        .verify_decryption_key_share(&self.metadata.digest, &decryption_key_share)?;
    Ok(())
}
```

Apply the same pattern to:
- `consensus/src/rand/secret_sharing/types.rs`
- `consensus/src/rand/rand_gen/types.rs`

Ensure all call sites properly handle the `Result` return type, logging warnings for invalid validators rather than panicking.

## Proof of Concept

```rust
#[cfg(test)]
mod test {
    use super::*;
    use aptos_types::validator_verifier::ValidatorVerifier;
    
    #[test]
    #[should_panic(expected = "Peer should be in the index!")]
    fn test_removed_validator_causes_panic() {
        // Create a validator set with only validator A
        let validator_a = AccountAddress::random();
        let validator_b = AccountAddress::random(); // Removed validator
        
        let mut validator_infos = vec![];
        // Only add validator A to the current epoch
        validator_infos.push(create_validator_info(validator_a, 1));
        let verifier = ValidatorVerifier::new(validator_infos);
        
        // Create SecretShareConfig for current epoch
        let config = SecretShareConfig::new(
            validator_a,
            10, // epoch
            Arc::new(verifier),
            create_test_digest_key(),
            create_test_msk_share(),
            vec![create_test_verification_key()],
            create_test_threshold_config(1, 1),
            create_test_encryption_key(),
        );
        
        // Create a share from removed validator B
        let malicious_share = SecretShare::new(
            validator_b, // Author is removed validator
            SecretShareMetadata {
                epoch: 10,
                round: 1,
                timestamp: 0,
                block_id: HashValue::zero(),
                digest: vec![],
            },
            create_test_secret_key_share(),
        );
        
        // This will panic because validator_b is not in the current validator set
        let _ = malicious_share.verify(&config);
    }
}
```

**Steps to reproduce:**
1. Set up a validator set for epoch N with validator V
2. Transition to epoch N+1 where V is not in the validator set  
3. Have V send a `SecretShareMessage::Share` with epoch N+1
4. Observe the panic in the verification task when `get_id()` is called

**Notes**

The vulnerability exists because the code assumes all share authors are in the current validator set, using `.expect()` for a lookup that should gracefully fail. During epoch transitions, the validator set changes but the verification code does not check validator membership before attempting index lookups. This violates the proper handling of state transitions (validator departure) and allows removed validators to disrupt the secret sharing subsystem through panic-induced DoS attacks.

### Citations

**File:** types/src/secret_sharing.rs (L75-82)
```rust
    pub fn verify(&self, config: &SecretShareConfig) -> anyhow::Result<()> {
        let index = config.get_id(self.author());
        let decryption_key_share = self.share().clone();
        // TODO(ibalajiarun): Check index out of bounds
        config.verification_keys[index]
            .verify_decryption_key_share(&self.metadata.digest, &decryption_key_share)?;
        Ok(())
    }
```

**File:** types/src/secret_sharing.rs (L172-178)
```rust
    pub fn get_id(&self, peer: &Author) -> usize {
        *self
            .validator
            .address_to_validator_index()
            .get(peer)
            .expect("Peer should be in the index!")
    }
```

**File:** consensus/src/rand/secret_sharing/secret_share_manager.rs (L205-235)
```rust
    async fn verification_task(
        epoch_state: Arc<EpochState>,
        mut incoming_rpc_request: aptos_channel::Receiver<Author, IncomingSecretShareRequest>,
        verified_msg_tx: UnboundedSender<SecretShareRpc>,
        config: SecretShareConfig,
        bounded_executor: BoundedExecutor,
    ) {
        while let Some(dec_msg) = incoming_rpc_request.next().await {
            let tx = verified_msg_tx.clone();
            let epoch_state_clone = epoch_state.clone();
            let config_clone = config.clone();
            bounded_executor
                .spawn(async move {
                    match bcs::from_bytes::<SecretShareMessage>(dec_msg.req.data()) {
                        Ok(msg) => {
                            if msg.verify(&epoch_state_clone, &config_clone).is_ok() {
                                let _ = tx.unbounded_send(SecretShareRpc {
                                    msg,
                                    protocol: dec_msg.protocol,
                                    response_sender: dec_msg.response_sender,
                                });
                            }
                        },
                        Err(e) => {
                            warn!("Invalid dec message: {}", e);
                        },
                    }
                })
                .await;
        }
    }
```

**File:** consensus/src/rand/secret_sharing/network_messages.rs (L28-38)
```rust
    pub fn verify(
        &self,
        epoch_state: &EpochState,
        config: &SecretShareConfig,
    ) -> anyhow::Result<()> {
        ensure!(self.epoch() == epoch_state.epoch);
        match self {
            SecretShareMessage::RequestShare(_) => Ok(()),
            SecretShareMessage::Share(share) => share.verify(config),
        }
    }
```

**File:** consensus/src/rand/secret_sharing/types.rs (L75-81)
```rust
    pub fn get_id(&self, peer: &Author) -> usize {
        *self
            .validator
            .address_to_validator_index()
            .get(peer)
            .expect("Peer should be in the index!")
    }
```

**File:** consensus/src/rand/rand_gen/types.rs (L630-636)
```rust
    pub fn get_id(&self, peer: &Author) -> usize {
        *self
            .validator
            .address_to_validator_index()
            .get(peer)
            .expect("Peer should be in the index!")
    }
```
