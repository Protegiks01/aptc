# Audit Report

## Title
Epoch Boundary Validation Bypass in State Sync Data Streaming Service

## Summary
The `update_stream_version_and_epoch()` function in the data streaming service fails to properly validate epoch boundaries when processing subscription or optimistic fetch responses. This allows the version field to advance past an epoch boundary while the epoch field remains unchanged, creating a version-epoch mismatch that can lead to state inconsistencies across nodes.

## Finding Description

The vulnerability exists in how `ContinuousTransactionStreamEngine::update_stream_version_and_epoch()` handles epoch transitions. The function only increments the epoch when two conditions are **both** satisfied: [1](#0-0) 

The critical issue is that for subscription and optimistic fetch responses, the `target_ledger_info` parameter comes from the peer's response payload, not from the node's internally managed `current_target_ledger_info`: [2](#0-1) 

The target is extracted directly from the response: [3](#0-2) 

**Attack Scenario:**

1. Node is at version 995, epoch 5
2. Epoch 5 ends at version 1000 (epoch boundary)
3. Node sends a subscription request with `known_version=995, known_epoch=5`
4. Malicious or buggy peer responds with:
   - NewTransactionsWithProof containing versions 996-1005 (crossing the epoch boundary at 1000)
   - `target_ledger_info` pointing to version 2000, epoch 6, `ends_epoch=false`
5. The system calls `update_stream_version_and_epoch(996, 1005, target_from_peer, 1005)`
6. Evaluation: `1005 == 2000 && false` = **FALSE**
7. Result: `next_stream_epoch` remains at 5, but `next_stream_version` becomes 1006
8. The node now has `(version=1006, epoch=5)` when version 1006 actually belongs to epoch 6

This violates the fundamental invariant that version and epoch fields must remain synchronized across epoch boundaries. Different nodes receiving different responses could end up with different version-epoch mappings, leading to consensus disagreements.

## Impact Explanation

This vulnerability has **High** severity impact:

**State Inconsistency:** Nodes can have inconsistent version-epoch tracking, causing them to disagree on which epoch a particular version belongs to. This breaks the "State Consistency" invariant that state transitions must be atomic and verifiable.

**Consensus Violations:** The mismatch can cause validators to fail to reach consensus on blocks if they disagree about epoch boundaries. Since epoch-specific logic (like validator set changes, rewards, and reconfiguration events) depends on accurate epoch tracking, this can lead to:
- Nodes rejecting valid blocks because they appear to be from the "wrong" epoch
- Inability to properly verify epoch-ending proofs
- Failures in state synchronization when nodes compare epoch information

**Protocol Violation:** This represents a significant protocol violation where the data streaming service, which is critical for state sync, can propagate incorrect state information. This affects the "Deterministic Execution" invariant as nodes may execute transactions differently based on their epoch understanding.

While not reaching Critical severity (no direct fund loss or complete network halt), it qualifies as **High Severity** per the bug bounty criteria: "Significant protocol violations" and potential for "validator node slowdowns" as nodes struggle with inconsistent state.

## Likelihood Explanation

**Likelihood: Medium to High**

**Attacker Requirements:**
- Ability to serve as a peer in the Aptos network (low barrier)
- No privileged access required
- Can craft responses to subscription/optimistic fetch requests

**Exploit Complexity: Low to Medium**
- Straightforward to craft a malicious response with incorrect target ledger info
- The vulnerable code path is frequently executed during normal state sync operations
- Any truncated or malformed response during epoch transitions could trigger this

**Scenarios:**
1. **Malicious Peer:** An attacker operates a node that intentionally provides incorrect target ledger info in subscription responses
2. **Network Issues:** Partial responses or network corruption during epoch transitions could accidentally trigger this
3. **Implementation Bugs:** Bugs in peer implementations could inadvertently send incorrect target information

The vulnerability is likely to be triggered because:
- State sync with subscription streams is a common operation
- Epoch transitions occur regularly in the network
- The code doesn't validate that the peer-provided target ledger info is consistent with actual epoch boundaries

## Recommendation

**Fix 1: Validate Target Ledger Info Against Known Epoch Boundaries**

When processing new data responses, the system should validate that the received data doesn't cross an epoch boundary, or properly update the epoch based on the actual data received, not solely on the target ledger info. [4](#0-3) 

**Proposed Solution:**

Add validation in `update_stream_version_and_epoch()` to detect when `last_received_version` crosses an epoch boundary, independent of the target ledger info. The function should:

1. Check if the received data spans across the known epoch ending version
2. If it does, request the appropriate epoch ending ledger info first before processing data past the boundary
3. Validate that the peer-provided target ledger info is consistent with locally known epoch boundaries

**Fix 2: Use Internal Target for Epoch Decisions**

For subscription/optimistic fetch responses, maintain and use `self.current_target_ledger_info` for epoch boundary decisions instead of the peer-provided target. Only use the peer's target for proof verification, not for epoch tracking.

**Fix 3: Add Epoch Boundary Validation**

Before updating `next_stream_version_and_epoch`, verify that the new version is consistent with the epoch:
- If version crosses a known epoch boundary, ensure epoch is incremented
- Reject responses that claim to contain data spanning multiple epochs without proper epoch ending ledger infos
- Add assertions to detect version-epoch mismatches early

## Proof of Concept

```rust
// Test demonstrating the vulnerability
#[tokio::test]
async fn test_epoch_mismatch_on_subscription_response() {
    // Setup: Node at version 995, epoch 5
    // Epoch 5 ends at version 1000
    
    let mut stream_engine = create_continuous_stream_engine(
        known_version: 995,
        known_epoch: 5,
    );
    
    // Simulate subscription response crossing epoch boundary
    let response = create_new_transactions_response(
        start_version: 996,
        end_version: 1005,  // Crosses epoch boundary at 1000
        target_version: 2000,  // Target NOT at epoch boundary
        target_epoch: 6,
        target_ends_epoch: false,
    );
    
    // Process the response
    stream_engine.create_notification_for_subscription_data(
        0,  // subscription_stream_index
        response,
        notification_id_generator,
    );
    
    // Verify the bug: version is 1006 but epoch is still 5
    let (next_version, next_epoch) = stream_engine.next_stream_version_and_epoch;
    
    assert_eq!(next_version, 1006);  // Version advanced past epoch boundary
    assert_eq!(next_epoch, 5);       // BUG: Epoch should be 6!
    
    // This demonstrates version 1006 is incorrectly associated with epoch 5
    // when it should be in epoch 6, violating the epoch boundary invariant
}
```

The proof of concept would need to be integrated into the existing test suite at: [5](#0-4) 

## Notes

This vulnerability is particularly concerning because:

1. **Silent Failure:** The mismatch doesn't trigger immediate errors but propagates through the system
2. **Consensus Impact:** Different nodes may have different version-epoch mappings, leading to disagreement
3. **Widespread Effect:** Affects all nodes using subscription-based state sync during epoch transitions
4. **Attack Surface:** Any peer can potentially trigger this, making it widely exploitable

The fix requires careful coordination between the data streaming service's internal epoch tracking and the peer-provided information, with proper validation at epoch boundaries.

### Citations

**File:** state-sync/data-streaming-service/src/stream_engine.rs (L1-1)
```rust
// Copyright (c) Aptos Foundation
```

**File:** state-sync/data-streaming-service/src/stream_engine.rs (L599-622)
```rust
    fn create_notification_for_new_data(
        &mut self,
        first_version: u64,
        client_response_payload: ResponsePayload,
        notification_id_generator: Arc<U64IdGenerator>,
    ) -> Result<DataNotification, Error> {
        // Calculate the number of data items and target ledger info
        let (num_versions, target_ledger_info) =
            extract_new_versions_and_target(&client_response_payload)?;

        // Calculate the last version (last_version = first_version + num_versions - 1)
        let last_version = first_version
            .checked_add(num_versions as u64)
            .and_then(|v| v.checked_sub(1))
            .ok_or_else(|| Error::IntegerOverflow("Last version has overflown!".into()))?;

        // Update the request and stream versions
        self.update_request_version_and_epoch(last_version, &target_ledger_info)?;
        self.update_stream_version_and_epoch(
            first_version,
            last_version,
            &target_ledger_info,
            last_version,
        )?;
```

**File:** state-sync/data-streaming-service/src/stream_engine.rs (L1035-1084)
```rust
    fn update_stream_version_and_epoch(
        &mut self,
        request_start_version: Version,
        request_end_version: Version,
        target_ledger_info: &LedgerInfoWithSignatures,
        last_received_version: Version,
    ) -> Result<(), Error> {
        // Verify the client request indices
        let (next_stream_version, mut next_stream_epoch) = self.next_stream_version_and_epoch;
        verify_client_request_indices(
            next_stream_version,
            request_start_version,
            request_end_version,
        )?;

        // Update the next stream version and epoch
        if last_received_version == target_ledger_info.ledger_info().version()
            && target_ledger_info.ledger_info().ends_epoch()
        {
            next_stream_epoch = next_stream_epoch
                .checked_add(1)
                .ok_or_else(|| Error::IntegerOverflow("Next stream epoch has overflown!".into()))?;
        }
        let next_stream_version = last_received_version
            .checked_add(1)
            .ok_or_else(|| Error::IntegerOverflow("Next stream version has overflown!".into()))?;
        self.next_stream_version_and_epoch = (next_stream_version, next_stream_epoch);

        // Check if the stream is now complete
        let stream_request_target = match &self.request {
            StreamRequest::ContinuouslyStreamTransactions(request) => request.target.clone(),
            StreamRequest::ContinuouslyStreamTransactionOutputs(request) => request.target.clone(),
            StreamRequest::ContinuouslyStreamTransactionsOrOutputs(request) => {
                request.target.clone()
            },
            request => invalid_stream_request!(request),
        };
        if let Some(target) = stream_request_target {
            if last_received_version >= target.ledger_info().version() {
                self.stream_is_complete = true;
            }
        }

        // Update the current target ledger info if we've hit it
        if last_received_version >= target_ledger_info.ledger_info().version() {
            self.current_target_ledger_info = None;
        }

        Ok(())
    }
```

**File:** state-sync/data-streaming-service/src/stream_engine.rs (L2269-2305)
```rust
fn extract_new_versions_and_target(
    client_response_payload: &ResponsePayload,
) -> Result<(usize, LedgerInfoWithSignatures), Error> {
    // Extract the number of new versions and the target ledger info
    let (num_versions, target_ledger_info) = match &client_response_payload {
        ResponsePayload::NewTransactionsWithProof((
            transactions_with_proof,
            target_ledger_info,
        )) => (
            transactions_with_proof.get_num_transactions(),
            target_ledger_info.clone(),
        ),
        ResponsePayload::NewTransactionOutputsWithProof((
            outputs_with_proof,
            target_ledger_info,
        )) => (
            outputs_with_proof.get_num_outputs(),
            target_ledger_info.clone(),
        ),
        response_payload => {
            // TODO(joshlind): eventually we want to notify the data client of the bad response
            return Err(Error::AptosDataClientResponseIsInvalid(format!(
                "Expected new transactions or outputs but got: {:?}",
                response_payload
            )));
        },
    };

    // Ensure that we have at least one data item
    if num_versions == 0 {
        // TODO(joshlind): eventually we want to notify the data client of the bad response
        return Err(Error::AptosDataClientResponseIsInvalid(
            "Received an empty transaction or output list!".into(),
        ));
    }

    Ok((num_versions, target_ledger_info))
```
