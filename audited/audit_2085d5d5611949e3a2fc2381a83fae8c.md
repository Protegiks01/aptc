# Audit Report

## Title
Mempool Configuration Information Disclosure via API Error Messages

## Summary
The `create_internal()` function in `api/src/transactions.rs` exposes internal node configuration parameters through unfiltered mempool error messages returned in API responses, allowing attackers to fingerprint nodes and plan targeted attacks.

## Finding Description

The API directly exposes `mempool_status.message` to external users without sanitization. When the mempool rejects transactions, detailed error messages containing internal configuration values are returned in the JSON response. [1](#0-0) 

The mempool status messages are constructed in the transaction store with detailed configuration information: [2](#0-1) [3](#0-2) [4](#0-3) 

These messages expose:
1. **Total mempool capacity** (`capacity`) - default 2,000,000
2. **Per-user sequence number transaction limit** (`capacity_per_user`) - default 100
3. **Per-user orderless transaction limit** (`orderless_txn_capacity_per_user`) - default 1,000
4. **Current mempool size** - real-time state information [5](#0-4) 

The configuration differs between node types (validators vs fullnodes), allowing node fingerprinting: [6](#0-5) 

The error structure directly serializes these messages to JSON: [7](#0-6) 

## Impact Explanation

This is a **Low Severity** information disclosure vulnerability per Aptos bug bounty criteria. It enables:

1. **Node Fingerprinting**: Attackers can distinguish between validator, VFN, and PFN nodes based on different default configurations
2. **Targeted DoS Planning**: Knowing exact capacity limits allows precise calculation of resources needed for mempool flooding
3. **Configuration Intelligence**: Custom node configurations are revealed, exposing operational details
4. **State Monitoring**: Current mempool size provides real-time operational state

While this doesn't directly compromise consensus, funds, or availability, it reduces the security-through-obscurity of node configurations and enables more sophisticated attacks.

## Likelihood Explanation

**Likelihood: High**

Any attacker can trigger these error messages by:
1. Submitting multiple transactions from the same account to hit `capacity_per_user` limit
2. Filling the mempool to trigger the global capacity message
3. Submitting transactions with old sequence numbers

No special permissions or resources required. The information is immediately available to any API user.

## Recommendation

Sanitize error messages before exposing them in API responses. Replace specific configuration values with generic messages:

```rust
async fn create_internal(&self, txn: SignedTransaction) -> Result<(), AptosError> {
    let (mempool_status, vm_status_opt) = self
        .context
        .submit_transaction(txn)
        .await
        .context("Mempool failed to initially evaluate submitted transaction")
        .map_err(|err| {
            aptos_api_types::AptosError::new_with_error_code(err, AptosErrorCode::InternalError)
        })?;
    
    match mempool_status.code {
        MempoolStatusCode::Accepted => Ok(()),
        MempoolStatusCode::MempoolIsFull | MempoolStatusCode::TooManyTransactions => {
            Err(AptosError::new_with_error_code(
                "Mempool is full. Please retry later.", // Sanitized message
                AptosErrorCode::MempoolIsFull,
            ))
        },
        MempoolStatusCode::InvalidSeqNumber => Err(AptosError::new_with_error_code(
            "Invalid sequence number", // Sanitized message
            AptosErrorCode::SequenceNumberTooOld,
        )),
        // ... sanitize other cases similarly
    }
}
```

## Proof of Concept

**Step 1**: Submit transaction to full mempool or exceed per-user limit:

```bash
curl -X POST https://fullnode.mainnet.aptoslabs.com/v1/transactions \
  -H "Content-Type: application/json" \
  -d '{
    "sender": "0x1",
    "sequence_number": "0",
    "max_gas_amount": "1000",
    "gas_unit_price": "1",
    "expiration_timestamp_secs": "99999999999",
    "payload": {
      "type": "entry_function_payload",
      "function": "0x1::coin::transfer",
      "type_arguments": ["0x1::aptos_coin::AptosCoin"],
      "arguments": ["0x2", "1000"]
    },
    "signature": { ... }
  }'
```

**Step 2**: Observe response containing configuration details:

```json
{
  "message": "Mempool is full. Mempool size: 1999500, Capacity: 2000000",
  "error_code": "mempool_is_full",
  "vm_error_code": null
}
```

This reveals exact capacity configuration (2,000,000) and current state (1,999,500 transactions).

## Notes

This vulnerability is correctly classified as **Low Severity** because it's a minor information leak that doesn't directly compromise funds, consensus, or availability. However, it does leak operational configuration that should remain internal, enabling more informed attacks against the node.

### Citations

**File:** api/src/transactions.rs (L1438-1491)
```rust
    async fn create_internal(&self, txn: SignedTransaction) -> Result<(), AptosError> {
        let (mempool_status, vm_status_opt) = self
            .context
            .submit_transaction(txn)
            .await
            .context("Mempool failed to initially evaluate submitted transaction")
            .map_err(|err| {
                aptos_api_types::AptosError::new_with_error_code(err, AptosErrorCode::InternalError)
            })?;
        match mempool_status.code {
            MempoolStatusCode::Accepted => Ok(()),
            MempoolStatusCode::MempoolIsFull | MempoolStatusCode::TooManyTransactions => {
                Err(AptosError::new_with_error_code(
                    &mempool_status.message,
                    AptosErrorCode::MempoolIsFull,
                ))
            },
            MempoolStatusCode::VmError => {
                if let Some(status) = vm_status_opt {
                    Err(AptosError::new_with_vm_status(
                        format!(
                            "Invalid transaction: Type: {:?} Code: {:?}",
                            status.status_type(),
                            status
                        ),
                        AptosErrorCode::VmError,
                        status,
                    ))
                } else {
                    Err(AptosError::new_with_vm_status(
                        "Invalid transaction: unknown",
                        AptosErrorCode::VmError,
                        StatusCode::UNKNOWN_STATUS,
                    ))
                }
            },
            MempoolStatusCode::InvalidSeqNumber => Err(AptosError::new_with_error_code(
                mempool_status.message,
                AptosErrorCode::SequenceNumberTooOld,
            )),
            MempoolStatusCode::InvalidUpdate => Err(AptosError::new_with_error_code(
                mempool_status.message,
                AptosErrorCode::InvalidTransactionUpdate,
            )),
            MempoolStatusCode::UnknownStatus => Err(AptosError::new_with_error_code(
                format!("Transaction was rejected with status {}", mempool_status,),
                AptosErrorCode::InternalError,
            )),
            MempoolStatusCode::RejectedByFilter => Err(AptosError::new_with_error_code(
                mempool_status.message,
                AptosErrorCode::RejectedByFilter,
            )),
        }
    }
```

**File:** mempool/src/core_mempool/transaction_store.rs (L312-316)
```rust
            return MempoolStatus::new(MempoolStatusCode::MempoolIsFull).with_message(format!(
                "Mempool is full. Mempool size: {}, Capacity: {}",
                self.system_ttl_index.size(),
                self.capacity,
            ));
```

**File:** mempool/src/core_mempool/transaction_store.rs (L325-331)
```rust
                        return MempoolStatus::new(MempoolStatusCode::TooManyTransactions).with_message(
                            format!(
                                "Mempool over capacity for account. Number of seq number transactions from account: {} Capacity per account: {}",
                                txns.seq_num_txns_len() ,
                                self.capacity_per_user,
                            ),
                        );
```

**File:** mempool/src/core_mempool/transaction_store.rs (L336-342)
```rust
                        return MempoolStatus::new(MempoolStatusCode::TooManyTransactions).with_message(
                            format!(
                                "Mempool over capacity for account. Number of orderless transactions from account: {} Capacity per account: {}",
                                txns.orderless_txns_len(),
                                self.orderless_txn_capacity_per_user,
                            ),
                        );
```

**File:** config/src/config/mempool_config.rs (L41-106)
```rust
pub struct MempoolConfig {
    /// Maximum number of transactions allowed in the Mempool
    pub capacity: usize,
    /// Maximum number of bytes allowed in the Mempool
    pub capacity_bytes: usize,
    /// Maximum number of sequence number based transactions allowed in the Mempool per user
    pub capacity_per_user: usize,
    /// Number of failover peers to broadcast to when the primary network is alive
    pub default_failovers: usize,
    /// Whether or not to enable intelligent peer prioritization
    pub enable_intelligent_peer_prioritization: bool,
    /// The maximum number of broadcasts sent to a single peer that are pending a response ACK at any point.
    pub max_broadcasts_per_peer: usize,
    /// Maximum number of inbound network messages to the Mempool application
    pub max_network_channel_size: usize,
    /// The maximum amount of time a node can be out of sync before being considered unhealthy
    pub max_sync_lag_before_unhealthy_secs: usize,
    /// The interval to take a snapshot of the mempool to logs, only used when trace logging is enabled
    pub mempool_snapshot_interval_secs: u64,
    /// The maximum amount of time to wait for an ACK of Mempool submission to an upstream node.
    pub shared_mempool_ack_timeout_ms: u64,
    /// The amount of time to backoff between retries of Mempool submission to an upstream node.
    pub shared_mempool_backoff_interval_ms: u64,
    /// Maximum number of transactions to batch for a Mempool submission to an upstream node.
    pub shared_mempool_batch_size: usize,
    /// Maximum number of bytes to batch for a Mempool submission to an upstream node.
    pub shared_mempool_max_batch_bytes: u64,
    /// Maximum Mempool inbound message workers.  Controls concurrency of Mempool consumption.
    pub shared_mempool_max_concurrent_inbound_syncs: usize,
    /// Interval to broadcast to upstream nodes.
    pub shared_mempool_tick_interval_ms: u64,
    /// Interval to update peers in shared mempool.
    pub shared_mempool_peer_update_interval_ms: u64,
    /// Interval to update peer priorities in shared mempool (seconds).
    pub shared_mempool_priority_update_interval_secs: u64,
    /// The amount of time to wait after transaction insertion to broadcast to a failover peer.
    pub shared_mempool_failover_delay_ms: u64,
    /// Number of seconds until the transaction will be removed from the Mempool ignoring if the transaction has expired.
    ///
    /// This ensures that the Mempool isn't just full of non-expiring transactions that are way off into the future.
    pub system_transaction_timeout_secs: u64,
    /// Interval to garbage collect and remove transactions that have expired from the Mempool.
    pub system_transaction_gc_interval_ms: u64,
    /// Gas unit price buckets for broadcasting to upstream nodes.
    ///
    /// Overriding this won't make much of a difference if the upstream nodes don't match.
    pub broadcast_buckets: Vec<u64>,
    pub eager_expire_threshold_ms: Option<u64>,
    pub eager_expire_time_ms: u64,
    /// Uses the BroadcastTransactionsRequestWithReadyTime instead of BroadcastTransactionsRequest when sending
    /// mempool transactions to upstream nodes.
    pub include_ready_time_in_broadcast: bool,
    pub usecase_stats_num_blocks_to_track: usize,
    pub usecase_stats_num_top_to_track: usize,
    /// We divide the transactions into buckets based on hash of the sender address.
    /// This is the number of sender buckets we use.
    pub num_sender_buckets: u8,
    /// Load balancing configuration for the mempool. This is used only by PFNs.
    pub load_balancing_thresholds: Vec<LoadBalancingThresholdConfig>,
    /// When the load is low, PFNs send all the mempool traffic to only one upstream FN. When the load increases suddenly, PFNs will take
    /// up to 10 minutes (shared_mempool_priority_update_interval_secs) to enable the load balancing. If this flag is enabled,
    /// then the PFNs will always do load balancing irrespective of the load.
    pub enable_max_load_balancing_at_any_load: bool,
    /// Maximum number of orderless transactions allowed in the Mempool per user
    pub orderless_txn_capacity_per_user: usize,
}
```

**File:** config/src/config/mempool_config.rs (L196-214)
```rust
        // Change the default configs for VFNs
        let mut modified_config = false;
        if node_type.is_validator() {
            // Set the max_broadcasts_per_peer to 2 (default is 20)
            if local_mempool_config_yaml["max_broadcasts_per_peer"].is_null() {
                mempool_config.max_broadcasts_per_peer = 2;
                modified_config = true;
            }
            // Set the batch size per broadcast to 200 (default is 300)
            if local_mempool_config_yaml["shared_mempool_batch_size"].is_null() {
                mempool_config.shared_mempool_batch_size = 200;
                modified_config = true;
            }
            // Set the number of sender buckets for load balancing to 1 (default is 4)
            if local_mempool_config_yaml["num_sender_buckets"].is_null() {
                mempool_config.num_sender_buckets = 1;
                modified_config = true;
            }
        }
```

**File:** api/types/src/error.rs (L11-18)
```rust
#[derive(Debug, Clone, Serialize, Deserialize, Object)]
pub struct AptosError {
    /// A message describing the error
    pub message: String,
    pub error_code: AptosErrorCode,
    /// A code providing VM error details when submitting transactions to the VM
    pub vm_error_code: Option<u64>,
}
```
