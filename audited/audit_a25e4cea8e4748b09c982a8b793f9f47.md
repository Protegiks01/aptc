# Audit Report

## Title
Missing Epoch Validation in Timeout Certificate Verification Allows Cross-Epoch TC Acceptance

## Summary
Timeout certificates from epoch N can be accepted and stored in epoch N+1 due to missing epoch validation in the `verify_tc()` function and `insert_2chain_timeout_certificate()` method. This violates epoch isolation invariants in the AptosBFT consensus protocol.

## Finding Description

The AptosBFT consensus protocol fails to properly validate the epoch of timeout certificates (TCs) when they are received via SyncInfo messages. This creates a vulnerability where TCs from epoch N can be accepted and persisted in epoch N+1, violating epoch isolation.

**Vulnerable Code Path:**

When a node receives a SyncInfo message containing a timeout certificate, the verification flow has three critical gaps:

1. **SyncInfo Verification** - The `SyncInfo::verify()` method only checks that the TC's epoch matches the HQC's epoch, but does NOT validate against the current epoch: [1](#0-0) 

2. **TC Insertion** - The `insert_2chain_timeout_certificate()` method only validates round numbers with no epoch check: [2](#0-1) 

3. **SafetyRules TC Verification** - The `verify_tc()` function only verifies cryptographic signatures against the current validator set, without checking if the TC's epoch matches the current epoch: [3](#0-2) 

**Contrast with Proper Epoch Validation:**

The codebase properly validates epochs for timeout messages (not certificates): [4](#0-3) 

**Attack Scenario:**

1. Attacker obtains a valid TC from epoch N
2. Network transitions to epoch N+1
3. During recovery, nodes correctly filter out old TCs: [5](#0-4) 

4. However, during normal operation via `sync_up()`, attacker sends a SyncInfo with HQC and TC both from epoch N: [6](#0-5) 

5. The SyncInfo passes verification because TC.epoch == HQC.epoch (both epoch N)
6. If validator sets have significant overlap, signatures from epoch N verify against epoch N+1's verifier
7. The TC gets inserted via `add_certs()`: [7](#0-6) 

**Broken Invariant:**

This violates the consensus safety invariant that consensus artifacts must be properly scoped to their respective epochs to prevent cross-epoch interference.

## Impact Explanation

**Severity: Medium**

This qualifies as Medium severity under Aptos bug bounty criteria:

1. **State Inconsistency**: The system accepts and persists timeout certificates from incorrect epochs, causing protocol state inconsistency requiring operator intervention

2. **Epoch Isolation Violation**: A fundamental protocol principle is violated - consensus artifacts should be strictly scoped to their epochs

3. **Limited Direct Exploit**: While the TC is accepted and stored, actual exploitation is constrained because:
   - Rounds reset to 0 when epochs change: [8](#0-7) 
   
   - Safety rules enforce round-based constraints that prevent old TCs from satisfying safety conditions: [9](#0-8) 

4. **No Direct Consensus Break**: The vulnerability doesn't directly enable double-signing or chain forks, as safety rules still enforce round-based constraints

However, this represents a significant protocol violation that undermines epoch transition correctness and could be leveraged in combination with other vulnerabilities.

## Likelihood Explanation

**Likelihood: Medium**

The vulnerability is moderately likely to occur because:

1. **Prerequisite Conditions:**
   - Validator set must have significant overlap between epochs (common in practice)
   - Attacker needs access to valid TCs from previous epochs (publicly broadcast)
   - Can be triggered during normal operation, not just edge cases

2. **Ease of Exploitation:**
   - No special validator privileges required
   - Can be triggered by any network participant via SyncInfo messages
   - Attack path is straightforward once conditions are met

3. **Detection Difficulty:**
   - Protocol doesn't explicitly flag cross-epoch TCs as invalid
   - Logs show normal TC insertion behavior
   - Operators may not notice epoch mismatch without detailed inspection

## Recommendation

Add epoch validation at multiple layers:

1. **In SyncInfo::verify()**: Check that all certificates match the expected current epoch, not just internal consistency
2. **In insert_2chain_timeout_certificate()**: Validate TC epoch matches current epoch before insertion
3. **In SafetyRules::verify_tc()**: Add explicit epoch check similar to timeout message verification

Example fix for `verify_tc()`:
```rust
fn verify_tc(&self, tc: &TwoChainTimeoutCertificate) -> Result<(), Error> {
    let epoch_state = self.epoch_state()?;
    let safety_data = self.persistent_storage.safety_data()?;
    
    // Add epoch validation
    if tc.epoch() != safety_data.epoch {
        return Err(Error::IncorrectEpoch(tc.epoch(), safety_data.epoch));
    }
    
    if !self.skip_sig_verify {
        tc.verify(&epoch_state.verifier)
            .map_err(|e| Error::InvalidTimeoutCertificate(e.to_string()))?;
    }
    Ok(())
}
```

## Proof of Concept

The vulnerability can be demonstrated through the following flow:

1. In epoch N, capture a valid TC with signatures from validators
2. Wait for epoch transition to N+1 (with validator set having >67% overlap)
3. Construct SyncInfo with:
   - HQC from epoch N
   - TC from epoch N  
4. Send SyncInfo to validators in epoch N+1
5. Observe that TC gets accepted and stored despite being from wrong epoch
6. Verify stored TC has epoch N in database while current epoch is N+1

The TC will be accepted through the verified code paths without epoch validation, violating the epoch isolation invariant.

### Citations

**File:** consensus/consensus-types/src/sync_info.rs (L138-150)
```rust
    pub fn verify(&self, validator: &ValidatorVerifier) -> anyhow::Result<()> {
        let epoch = self.highest_quorum_cert.certified_block().epoch();
        ensure!(
            epoch == self.highest_ordered_cert().commit_info().epoch(),
            "Multi epoch in SyncInfo - HOC and HQC"
        );
        ensure!(
            epoch == self.highest_commit_cert().commit_info().epoch(),
            "Multi epoch in SyncInfo - HOC and HCC"
        );
        if let Some(tc) = &self.highest_2chain_timeout_cert {
            ensure!(epoch == tc.epoch(), "Multi epoch in SyncInfo - TC and HQC");
        }
```

**File:** consensus/src/block_storage/block_store.rs (L560-575)
```rust
    pub fn insert_2chain_timeout_certificate(
        &self,
        tc: Arc<TwoChainTimeoutCertificate>,
    ) -> anyhow::Result<()> {
        let cur_tc_round = self
            .highest_2chain_timeout_cert()
            .map_or(0, |tc| tc.round());
        if tc.round() <= cur_tc_round {
            return Ok(());
        }
        self.storage
            .save_highest_2chain_timeout_cert(tc.as_ref())
            .context("Timeout certificate insert failed when persisting to DB")?;
        self.inner.write().replace_2chain_timeout_cert(tc);
        Ok(())
    }
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L19-26)
```rust
    pub(crate) fn guarded_sign_timeout_with_qc(
        &mut self,
        timeout: &TwoChainTimeout,
        timeout_cert: Option<&TwoChainTimeoutCertificate>,
    ) -> Result<bls12381::Signature, Error> {
        self.signer()?;
        let mut safety_data = self.persistent_storage.safety_data()?;
        self.verify_epoch(timeout.epoch(), &safety_data)?;
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L121-145)
```rust
    /// Core safety timeout rule for 2-chain protocol. Return success if 1 and 2 are true
    /// 1. round == timeout.qc.round + 1 || round == tc.round + 1
    /// 2. timeout.qc.round >= one_chain_round
    fn safe_to_timeout(
        &self,
        timeout: &TwoChainTimeout,
        maybe_tc: Option<&TwoChainTimeoutCertificate>,
        safety_data: &SafetyData,
    ) -> Result<(), Error> {
        let round = timeout.round();
        let qc_round = timeout.hqc_round();
        let tc_round = maybe_tc.map_or(0, |tc| tc.round());
        if (round == next_round(qc_round)? || round == next_round(tc_round)?)
            && qc_round >= safety_data.one_chain_round
        {
            Ok(())
        } else {
            Err(Error::NotSafeToTimeout(
                round,
                qc_round,
                tc_round,
                safety_data.one_chain_round,
            ))
        }
    }
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L180-188)
```rust
    fn verify_tc(&self, tc: &TwoChainTimeoutCertificate) -> Result<(), Error> {
        let epoch_state = self.epoch_state()?;

        if !self.skip_sig_verify {
            tc.verify(&epoch_state.verifier)
                .map_err(|e| Error::InvalidTimeoutCertificate(e.to_string()))?;
        }
        Ok(())
    }
```

**File:** consensus/src/persistent_liveness_storage.rs (L414-417)
```rust
            highest_2chain_timeout_certificate: match highest_2chain_timeout_cert {
                Some(tc) if tc.epoch() == epoch => Some(tc),
                _ => None,
            },
```

**File:** consensus/src/round_manager.rs (L878-896)
```rust
    async fn sync_up(&mut self, sync_info: &SyncInfo, author: Author) -> anyhow::Result<()> {
        let local_sync_info = self.block_store.sync_info();
        if sync_info.has_newer_certificates(&local_sync_info) {
            info!(
                self.new_log(LogEvent::ReceiveNewCertificate)
                    .remote_peer(author),
                "Local state {},\n remote state {}", local_sync_info, sync_info
            );
            // Some information in SyncInfo is ahead of what we have locally.
            // First verify the SyncInfo (didn't verify it in the yet).
            sync_info.verify(&self.epoch_state.verifier).map_err(|e| {
                error!(
                    SecurityEvent::InvalidSyncInfoMsg,
                    sync_info = sync_info,
                    remote_peer = author,
                    error = ?e,
                );
                VerifyError::from(e)
            })?;
```

**File:** consensus/src/block_storage/sync_manager.rs (L169-171)
```rust
        if let Some(tc) = sync_info.highest_2chain_timeout_cert() {
            self.insert_2chain_timeout_certificate(Arc::new(tc.clone()))?;
        }
```

**File:** consensus/src/liveness/round_state.rs (L202-206)
```rust
        Self {
            time_interval,
            highest_ordered_round: 0,
            current_round: 0,
            current_round_deadline: time_service.get_current_timestamp(),
```
