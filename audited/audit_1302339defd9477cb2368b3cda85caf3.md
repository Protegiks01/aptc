# Audit Report

## Title
Peer Role Inference Bypass Allows Unauthenticated Peers to Poison Network Monitoring Data on Validator VFN Networks

## Summary
Validators using MaybeMutual authentication on VFN networks incorrectly trust role information inferred from network context rather than cryptographic authentication. This allows unknown peers to exploit the monitoring service's validation logic and inject poisoned network topology data by claiming to be Validator Full Nodes (VFNs) at distance 1 from validators.

## Finding Description

The vulnerability exists in the interaction between three components:

**1. VFN Network Authentication Mode**

Validators use `MaybeMutual` authentication mode on VFN networks (mutual_authentication defaults to false for `NetworkId::Vfn`): [1](#0-0) 

**2. Peer Role Inference Without Authentication**

When an unknown peer (not in trusted peer set) connects to a validator on the VFN network, the noise handshake **infers** their role as `ValidatorFullNode` based solely on network context, without cryptographic verification: [2](#0-1) 

**3. Monitoring Service Trusts Inferred Role**

The `NetworkInfoState` validation logic trusts this inferred role to validate the peer's self-reported `distance_from_validators`: [3](#0-2) 

**Attack Execution Path:**

1. Attacker establishes connection to validator on VFN network as unknown peer
2. Handshake completes successfully using MaybeMutual auth (lines 384-426 in handshake.rs)
3. Since attacker is not in trusted peer set, but connecting on VFN network to a validator, role is inferred as `PeerRole::ValidatorFullNode`
4. This inferred role is stored in `ConnectionMetadata.role` and used to create `PeerMetadata`
5. Attacker sends `PeerMonitoringServiceResponse::NetworkInformation` with `distance_from_validators = 1` and arbitrary `connected_peers` data
6. Validation at line 128-135 checks: `peer_is_vfn = peer_metadata.get_connection_metadata().role.is_vfn()` â†’ returns **TRUE** (due to inferred role)
7. Both validation checks pass, malicious data is stored via `record_network_info_response()` at line 157

The peer metadata passed to `handle_monitoring_service_response()` at line 147 in peer_state.rs originates from this unauthenticated inference: [4](#0-3) 

## Impact Explanation

**High Severity** - Significant Protocol Violation

This vulnerability allows attackers to:

1. **Poison Network Topology Data**: Inject false information about network distance from validators and connected peer counts
2. **Manipulate Peer Reputation**: Corrupt monitoring state used for peer health assessment and selection decisions
3. **Degrade Network Quality**: Validators make peer selection decisions based on poisoned monitoring metadata, potentially degrading network connectivity quality
4. **Scale Attack**: Any number of malicious peers can simultaneously inject false data

While this does not directly compromise consensus or cause fund loss, it represents a **significant protocol violation** where validators trust unauthenticated peer-reported data, meeting the High severity criteria per the Aptos bug bounty program.

## Likelihood Explanation

**High Likelihood** - Easy to exploit with minimal requirements:

1. **No Authentication Required**: Attacker needs no trusted peer credentials
2. **Simple Network Access**: Only requires ability to establish TCP connection to validator VFN network
3. **Default Configuration**: Vulnerability exists in default validator configuration (VFN network uses MaybeMutual by default)
4. **No Rate Limiting**: No inherent limits on number of malicious peers that can connect
5. **Persistent Impact**: Poisoned data persists in monitoring state until overwritten

## Recommendation

**Fix 1: Require VFNs in Trusted Peer Set**

Configure validators to use Mutual authentication on VFN networks and only accept connections from explicitly trusted VFNs. This eliminates role inference for unknown peers.

**Fix 2: Additional Validation for Inferred Roles**

Add validation logic to reject monitoring data from peers with inferred (non-authenticated) roles:

```rust
// In NetworkInfoState::handle_monitoring_service_response()
// After line 114, add:

// Reject monitoring data from unauthenticated peers with inferred roles
let peer_is_authenticated = match self.network_monitoring_config.require_authenticated_peers {
    true => {
        // Check if peer is in trusted peer set
        // Only accept data from authenticated VFNs, not inferred roles
        peer_metadata.is_authenticated() // Would need to add this field to track authentication status
    },
    false => true, // Allow for backwards compatibility
};

if !peer_is_authenticated && network_info_response.distance_from_validators <= 1 {
    warn!(LogSchema::new(LogEntry::NetworkInfoRequest)
        .event(LogEvent::InvalidResponse)
        .peer(peer_network_id)
        .message("Rejecting monitoring data from unauthenticated peer claiming low distance"));
    self.handle_request_failure();
    return;
}
```

**Fix 3: Add Authentication Status Tracking**

Extend `ConnectionMetadata` to track whether the peer role was authenticated or inferred, and use this in validation decisions.

## Proof of Concept

```rust
// Test demonstrating the vulnerability
#[test]
fn test_unknown_peer_network_info_poisoning() {
    use aptos_config::config::{NodeConfig, PeerRole, RoleType};
    use aptos_network::application::metadata::PeerMetadata;
    use aptos_netcore::transport::ConnectionOrigin;
    use aptos_network::protocols::wire::handshake::v1::{MessagingProtocolVersion, ProtocolIdSet};
    use aptos_network::transport::{ConnectionId, ConnectionMetadata};
    use aptos_peer_monitoring_service_types::response::{
        NetworkInformationResponse, PeerMonitoringServiceResponse
    };
    use aptos_types::network_address::NetworkAddress;
    use std::str::FromStr;

    // Setup: Create a validator's network info state
    let node_config = NodeConfig {
        base: aptos_config::config::BaseConfig {
            role: RoleType::Validator,
            ..Default::default()
        },
        ..Default::default()
    };
    let time_service = aptos_time_service::TimeService::mock();
    let mut network_info_state = NetworkInfoState::new(node_config, time_service);

    // Attack: Create an unknown peer (not in trusted set) connecting on VFN network
    // This peer's role would be INFERRED as ValidatorFullNode by the handshake
    let peer_network_id = PeerNetworkId::new(NetworkId::Vfn, PeerId::random());
    let connection_metadata = ConnectionMetadata::new(
        peer_network_id.peer_id(),
        ConnectionId::default(),
        NetworkAddress::from_str("/ip4/1.2.3.4/tcp/6182").unwrap(),
        ConnectionOrigin::Inbound,
        MessagingProtocolVersion::V1,
        ProtocolIdSet::empty(),
        PeerRole::ValidatorFullNode, // This role was INFERRED, not authenticated!
    );
    let peer_metadata = PeerMetadata::new(connection_metadata);

    // Attack payload: Claim to be at distance 1 from validators
    let malicious_response = PeerMonitoringServiceResponse::NetworkInformation(
        NetworkInformationResponse {
            connected_peers: Default::default(),
            distance_from_validators: 1, // FALSE claim - this peer is not a real VFN
        }
    );

    // Execute: Send the malicious monitoring response
    network_info_state.handle_monitoring_service_response(
        &peer_network_id,
        peer_metadata,
        PeerMonitoringServiceRequest::GetNetworkInformation,
        malicious_response,
        0.0,
    );

    // Verify: The poisoned data was accepted and stored!
    let stored_response = network_info_state.get_latest_network_info_response().unwrap();
    assert_eq!(stored_response.distance_from_validators, 1); // Poisoned data accepted!
    
    // This demonstrates that unauthenticated peers can poison monitoring state
    // by exploiting the role inference logic on VFN networks.
}
```

**Notes**

The root cause is a **trust boundary violation** where the monitoring service validation assumes that `PeerMetadata.role` represents an authenticated peer role, but the noise handshake can populate this field through inference rather than cryptographic verification. This breaks the security assumption that only authenticated VFNs can report `distance_from_validators = 1`.

The vulnerability affects all validators running default configurations with VFN networks, as `mutual_authentication` defaults to `false` for `NetworkId::Vfn` networks, enabling the MaybeMutual authentication mode that performs role inference.

### Citations

**File:** config/src/config/network_config.rs (L135-143)
```rust
    pub fn network_with_id(network_id: NetworkId) -> NetworkConfig {
        let mutual_authentication = network_id.is_validator_network();
        let mut config = Self {
            discovery_method: DiscoveryMethod::None,
            discovery_methods: Vec::new(),
            identity: Identity::None,
            listen_address: "/ip4/0.0.0.0/tcp/6180".parse().unwrap(),
            mutual_authentication,
            network_id,
```

**File:** network/framework/src/noise/handshake.rs (L406-422)
```rust
                            // Try to infer the role from the network context
                            if self.network_context.role().is_validator() {
                                if network_id.is_vfn_network() {
                                    // Inbound connections to validators on the VFN network must be VFNs
                                    Ok(PeerRole::ValidatorFullNode)
                                } else {
                                    // Otherwise, they're unknown. Validators will connect through
                                    // authenticated channels (on the validator network) so shouldn't hit
                                    // this, and PFNs will connect on public networks (which aren't common).
                                    Ok(PeerRole::Unknown)
                                }
                            } else {
                                // We're a VFN or PFN. VFNs get no inbound connections on the vfn network
                                // (so the peer won't be a validator). Thus, we're on the public network
                                // so mark the peer as unknown.
                                Ok(PeerRole::Unknown)
                            }
```

**File:** peer-monitoring-service/client/src/peer_states/network_info.rs (L116-157)
```rust
        // Sanity check the response depth from the peer metadata
        let network_id = peer_network_id.network_id();
        let is_valid_depth = match network_info_response.distance_from_validators {
            0 => {
                // Verify the peer is a validator and has the correct network id
                let peer_is_validator = peer_metadata.get_connection_metadata().role.is_validator();
                let peer_has_correct_network = match self.base_config.role {
                    RoleType::Validator => network_id.is_validator_network(), // We're a validator
                    RoleType::FullNode => network_id.is_vfn_network(),        // We're a VFN
                };
                peer_is_validator && peer_has_correct_network
            },
            1 => {
                // Verify the peer is a VFN and has the correct network id
                let peer_is_vfn = peer_metadata.get_connection_metadata().role.is_vfn();
                let peer_has_correct_network = match self.base_config.role {
                    RoleType::Validator => network_id.is_vfn_network(), // We're a validator
                    RoleType::FullNode => network_id.is_public_network(), // We're a VFN or PFN
                };
                peer_is_vfn && peer_has_correct_network
            },
            distance_from_validators => {
                // The distance must be less than or equal to the max
                distance_from_validators <= MAX_DISTANCE_FROM_VALIDATORS
            },
        };

        // If the depth did not pass our sanity checks, handle a failure
        if !is_valid_depth {
            warn!(LogSchema::new(LogEntry::NetworkInfoRequest)
                .event(LogEvent::InvalidResponse)
                .peer(peer_network_id)
                .message(&format!(
                    "Peer returned invalid depth from validators: {}",
                    network_info_response.distance_from_validators
                )));
            self.handle_request_failure();
            return;
        }

        // Store the new latency ping result
        self.record_network_info_response(network_info_response);
```

**File:** peer-monitoring-service/client/src/peer_states/peer_state.rs (L145-151)
```rust
            peer_state_value.write().handle_monitoring_service_response(
                &peer_network_id,
                peer_metadata,
                monitoring_service_request.clone(),
                monitoring_service_response,
                request_duration_secs,
            );
```
