# Audit Report

## Title
Gas Price Manipulation Bypasses Transaction Deduplication Leading to Validator Resource Exhaustion

## Summary
The transaction deduplication mechanism in Aptos consensus uses `(committed_hash, authenticator)` as the deduplication key. Since `gas_unit_price` is part of the `RawTransaction` that gets hashed, transactions with identical sender, sequence number, and payload but different gas prices are treated as distinct transactions. An attacker can exploit this by submitting the same transaction with different gas prices to different validators, causing all variants to be included in a block and waste validator resources on redundant validation work.

## Finding Description

The vulnerability exists in the transaction deduplication logic that runs before block execution. The deduplication uses the transaction's `committed_hash()` combined with the authenticator as the unique identifier. [1](#0-0) 

The `committed_hash()` function hashes the entire `SignedTransaction`, which includes the `RawTransaction`: [2](#0-1) 

The `RawTransaction` struct includes `gas_unit_price` as a field: [3](#0-2) 

This means two transactions with the same sender, sequence number, and payload but different `gas_unit_price` values will have:
- Different `RawTransaction` content → different hash
- Different signatures (since signatures are over the `RawTransaction`)
- Different `(committed_hash, authenticator)` pairs → bypass deduplication

**Attack Execution Path:**

1. Attacker submits Transaction A (sender=0xABCD, sequence_number=10, payload=X, gas_price=100) to Validator 1's mempool
2. Attacker submits Transaction A (sender=0xABCD, sequence_number=10, payload=X, gas_price=200) to Validator 2's mempool
3. Validator 1's quorum store creates Batch_1 containing the gas_price=100 version
4. Validator 2's quorum store creates Batch_2 containing the gas_price=200 version

The quorum store tracks transactions using `TransactionSummary` which includes the hash: [4](#0-3) 

5. Block leader pulls both batches into a single block
6. Deduplication runs during block preparation: [5](#0-4) 

7. Both transactions pass deduplication (different hashes)
8. Both undergo signature verification in parallel during block preparation: [6](#0-5) 

9. Both undergo prologue validation
10. The first transaction executes successfully
11. The second transaction fails with `SEQUENCE_NUMBER_TOO_OLD` and is discarded: [7](#0-6) 

**Invariant Violations:**

This breaks the **Resource Limits** invariant: "All operations must respect gas, storage, and computational limits." The attack forces validators to perform redundant signature verification and prologue validation on duplicate transactions, consuming CPU cycles without legitimate purpose.

## Impact Explanation

**Severity: High** (per Aptos bug bounty criteria for "Validator node slowdowns" and "Significant protocol violations")

The attack causes:

1. **Validator CPU Exhaustion**: Each duplicate transaction undergoes expensive signature verification (cryptographic operations) and prologue validation (Move VM session execution), consuming significant CPU resources

2. **Block Space Wastage**: Invalid duplicate transactions occupy block space that could otherwise contain valid transactions, reducing network throughput

3. **Network Bandwidth Waste**: Duplicate transactions are propagated through the quorum store network and stored by multiple validators

4. **Scalable DoS Attack**: An attacker can multiply the effect by submitting N variants of the same transaction with different gas prices, forcing validators to process N× the normal workload

The attack does not directly steal funds or break consensus safety, but it significantly degrades validator performance and network efficiency, meeting the High severity criteria.

## Likelihood Explanation

**Likelihood: High**

The attack is highly feasible because:

1. **No Special Access Required**: Any user can submit transactions to multiple validators' public mempool endpoints
2. **Low Cost**: The attacker only pays gas for the one transaction that succeeds; failed duplicates are discarded without gas charges
3. **Easy to Execute**: The attacker simply needs to sign the same transaction with different `gas_unit_price` values and submit to different endpoints
4. **Difficult to Detect**: The transactions appear legitimate until execution reveals the sequence number conflict
5. **No Rate Limiting**: Individual validators cannot distinguish attack traffic from legitimate gas price bumps

## Recommendation

Implement deduplication based on `(sender, sequence_number)` or `(sender, replay_protector)` for sequence-number-based transactions, rather than `(committed_hash, authenticator)`. This would catch all variants of the same logical transaction regardless of gas price differences.

**Proposed Fix:**

Modify the deduplication logic to use semantic transaction identity:

```rust
// In consensus/src/txn_hash_and_authenticator_deduper.rs
// Change the dedup key from (hash, authenticator) to (sender, replay_protector)

pub(crate) fn dedup(&self, transactions: Vec<SignedTransaction>) -> Vec<SignedTransaction> {
    let _timer = TXN_DEDUP_SECONDS.start_timer();
    let mut seen = HashSet::new();
    let mut num_duplicates: usize = 0;
    
    let filtered: Vec<_> = transactions
        .into_iter()
        .filter_map(|txn| {
            let key = (txn.sender(), txn.replay_protector());
            if seen.insert(key) {
                Some(txn)
            } else {
                num_duplicates += 1;
                None
            }
        })
        .collect();
    
    TXN_DEDUP_FILTERED.observe(num_duplicates as f64);
    filtered
}
```

**Note**: The current implementation comment states that both hash and authenticator are needed "because dedup happens before signatures are verified." However, since signature verification now occurs during block preparation before execution, the dedup logic could be moved after signature verification, or the key could be simplified to use semantic identity.

## Proof of Concept

```rust
// Rust test demonstrating the vulnerability
#[test]
fn test_gas_price_dedup_bypass() {
    use aptos_types::transaction::{RawTransaction, SignedTransaction};
    use aptos_crypto::ed25519::{Ed25519PrivateKey, Ed25519PublicKey};
    use aptos_keygen::KeyGen;
    
    let deduper = TxnHashAndAuthenticatorDeduper::new();
    
    // Create account
    let (privkey, pubkey) = KeyGen::from_os_rng().generate_ed25519_keypair();
    let sender = aptos_types::account_address::from_public_key(&pubkey);
    
    // Create same transaction with different gas prices
    let txn_gas_100 = RawTransaction::new_script(
        sender,
        0, // sequence_number
        Script::new(vec![], vec![], vec![]),
        500_000,
        100, // gas_unit_price
        u64::MAX,
        ChainId::new(10),
    ).sign(&privkey, pubkey.clone()).unwrap().into_inner();
    
    let txn_gas_200 = RawTransaction::new_script(
        sender,
        0, // Same sequence_number
        Script::new(vec![], vec![], vec![]),
        500_000,
        200, // Different gas_unit_price
        u64::MAX,
        ChainId::new(10),
    ).sign(&privkey, pubkey).unwrap().into_inner();
    
    // Verify they have different hashes
    assert_ne!(txn_gas_100.committed_hash(), txn_gas_200.committed_hash());
    
    // Submit both to deduper
    let txns = vec![txn_gas_100.clone(), txn_gas_200.clone()];
    let deduped = deduper.dedup(txns);
    
    // VULNERABILITY: Both transactions pass deduplication
    assert_eq!(deduped.len(), 2);
    assert_eq!(deduped[0].committed_hash(), txn_gas_100.committed_hash());
    assert_eq!(deduped[1].committed_hash(), txn_gas_200.committed_hash());
    
    // In a real scenario, both would undergo signature verification
    // and prologue validation, wasting validator resources
}
```

## Notes

This vulnerability is a fundamental design issue in the deduplication mechanism. The current approach was likely chosen to handle edge cases where transactions might have different signatures (e.g., bad actors submitting invalid signatures), but it creates an exploitable resource exhaustion vector. The fix requires careful consideration of transaction identity semantics and may need coordination with mempool's gas price bump feature, which legitimately replaces transactions with higher gas prices.

### Citations

**File:** consensus/src/txn_hash_and_authenticator_deduper.rs (L68-69)
```rust
                true => Some((txn.committed_hash(), txn.authenticator())),
                false => None,
```

**File:** types/src/transaction/mod.rs (L179-205)
```rust
pub struct RawTransaction {
    /// Sender's address.
    sender: AccountAddress,

    /// Sequence number of this transaction. This must match the sequence number
    /// stored in the sender's account at the time the transaction executes.
    sequence_number: u64,

    /// The transaction payload, e.g., a script to execute.
    payload: TransactionPayload,

    /// Maximal total gas to spend for this transaction.
    max_gas_amount: u64,

    /// Price to be paid per gas unit.
    gas_unit_price: u64,

    /// Expiration timestamp for this transaction, represented
    /// as seconds from the Unix Epoch. If the current blockchain timestamp
    /// is greater than or equal to this time, then the transaction has
    /// expired and will be discarded. This can be set to a large value far
    /// in the future to indicate that a transaction does not expire.
    expiration_timestamp_secs: u64,

    /// Chain ID of the Aptos network this transaction is intended for.
    chain_id: ChainId,
}
```

**File:** types/src/transaction/mod.rs (L1335-1339)
```rust
    pub fn committed_hash(&self) -> HashValue {
        *self
            .committed_hash
            .get_or_init(|| Transaction::UserTransaction(self.clone()).hash())
    }
```

**File:** consensus/consensus-types/src/common.rs (L38-42)
```rust
pub struct TransactionSummary {
    pub sender: AccountAddress,
    pub replay_protector: ReplayProtector,
    pub hash: HashValue,
}
```

**File:** consensus/src/block_preparer.rs (L99-99)
```rust
            let deduped_txns = txn_deduper.dedup(filtered_txns);
```

**File:** execution/executor-benchmark/src/block_preparation.rs (L76-87)
```rust
        let sig_verified_txns: Vec<SignatureVerifiedTransaction> =
            self.sig_verify_pool.install(|| {
                let _timer = TIMER.timer_with(&["sig_verify"]);

                let num_txns = txns.len();
                NUM_TXNS.inc_with_by(&["sig_verify"], num_txns as u64);

                txns.into_par_iter()
                    .with_min_len(optimal_min_len(num_txns, SIG_VERIFY_RAYON_MIN_THRESHOLD))
                    .map(|t| t.into())
                    .collect::<Vec<_>>()
            });
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L626-628)
```rust
            TransactionStatus::Discard(status_code) => {
                let discarded_output = discarded_output(status_code);
                (error_vm_status, discarded_output)
```
