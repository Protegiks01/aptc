# Audit Report

## Title
Missing Version Monotonicity Validation in SafetyRules Commit Vote Signing Enables Potential Ledger Rollback

## Summary
The `guarded_sign_commit_vote` function in SafetyRules does not validate that `new_ledger_info.version()` is greater than or equal to `old_ledger_info.version()` before signing commit votes. This violates defense-in-depth principles and could enable ledger version rollback if combined with execution engine bugs or storage layer bypasses.

## Finding Description
The SafetyRules module is responsible for enforcing consensus safety properties before signing any consensus messages. When signing commit votes, the `guarded_sign_commit_vote` function receives an ordered ledger info and a new ledger info with execution results, then signs the new ledger info after validation. [1](#0-0) 

The function performs three main validations:
1. Verifies the old ledger info is ordered-only (or matches new commit info for fast-forward sync)
2. Validates ordered-only fields match via `match_ordered_only()`
3. Verifies signatures on the ordered ledger info

However, the `match_ordered_only()` function only checks epoch, round, id, and timestamp - it explicitly does NOT check the version field: [2](#0-1) 

The version field represents the transaction version at which the block was committed: [3](#0-2) 

**Ledger version monotonicity** is a fundamental blockchain invariant - versions must always increase to prevent transaction rollback and double-spending. If a commit vote is signed where `new_ledger_info.version() < old_ledger_info.version()`, this would violate this critical invariant.

The attack scenario:
1. A buggy execution engine or malicious validator creates a `new_ledger_info` with version less than `old_ledger_info.version()`
2. SafetyRules signs this commit vote because it only validates epoch/round/id/timestamp matching
3. The signed commit vote is broadcast to other validators
4. If 2f+1 validators sign it (all with the same vulnerability), it forms a quorum certificate
5. Storage layer would reject it, but SafetyRules has already violated its responsibility

The test suite confirms this gap - there is no test case validating version regression: [4](#0-3) 

## Impact Explanation
This constitutes a **High Severity** vulnerability (potentially Critical if storage bypass exists) for the following reasons:

1. **Consensus Safety Violation**: If the storage layer validation is bypassed or contains bugs, this would enable ledger version rollback attacks, allowing:
   - Transaction uncommitment
   - Double-spending
   - Complete blockchain state rollback
   - Violation of fundamental blockchain immutability

2. **Defense-in-Depth Failure**: SafetyRules is explicitly designed to be the first line of defense for consensus safety. It should enforce ALL safety properties before signing, not rely on downstream validation. The storage layer check exists here: [5](#0-4) 

But SafetyRules should independently enforce this invariant as its primary responsibility.

3. **Resource Waste**: Even with storage rejection, invalid commit votes consume network bandwidth and processing resources across all validators.

## Likelihood Explanation
**Likelihood: Low to Medium**

The vulnerability requires one of the following conditions:
- A bug in the execution engine that produces incorrect version numbers
- A separate bug that bypasses storage layer validation
- A malicious validator with ability to manipulate execution results

However, the missing validation is a clear violation of SafetyRules' design contract and represents a critical gap in the defense-in-depth architecture.

## Recommendation
Add explicit version monotonicity validation in `guarded_sign_commit_vote` before signing:

```rust
fn guarded_sign_commit_vote(
    &mut self,
    ledger_info: LedgerInfoWithSignatures,
    new_ledger_info: LedgerInfo,
) -> Result<bls12381::Signature, Error> {
    self.signer()?;

    let old_ledger_info = ledger_info.ledger_info();

    // Existing checks...
    if !old_ledger_info.commit_info().is_ordered_only()
        && old_ledger_info.commit_info() != new_ledger_info.commit_info()
    {
        return Err(Error::InvalidOrderedLedgerInfo(old_ledger_info.to_string()));
    }

    if !old_ledger_info
        .commit_info()
        .match_ordered_only(new_ledger_info.commit_info())
    {
        return Err(Error::InconsistentExecutionResult(
            old_ledger_info.commit_info().to_string(),
            new_ledger_info.commit_info().to_string(),
        ));
    }

    // ADD VERSION MONOTONICITY CHECK
    if new_ledger_info.version() < old_ledger_info.version() {
        return Err(Error::InvalidLedgerInfo(format!(
            "Version regression detected: new version {} < old version {}",
            new_ledger_info.version(),
            old_ledger_info.version()
        )));
    }

    // Signature verification...
    if !self.skip_sig_verify {
        ledger_info
            .verify_signatures(&self.epoch_state()?.verifier)
            .map_err(|error| Error::InvalidQuorumCertificate(error.to_string()))?;
    }

    let signature = self.sign(&new_ledger_info)?;
    Ok(signature)
}
```

Additionally, add a corresponding error variant to the Error enum: [6](#0-5) 

## Proof of Concept

```rust
#[test]
fn test_sign_commit_vote_version_regression() {
    use crate::test_utils;
    use aptos_crypto::hash::ACCUMULATOR_PLACEHOLDER_HASH;
    
    let (mut safety_rules, signer) = test_utils::make_safety_rules();
    let (proof, genesis_qc) = test_utils::make_genesis(&signer);
    safety_rules.initialize(&proof).unwrap();
    
    let round = genesis_qc.certified_block().round();
    
    // Create a chain: genesis -- a1 -- a2 -- a3
    let a1 = test_utils::make_proposal_with_qc(round + 1, genesis_qc, &signer);
    let a2 = test_utils::make_proposal_with_parent(round + 2, &a1, None, &signer);
    let a3 = test_utils::make_proposal_with_parent(round + 3, &a2, Some(&a1), &signer);
    
    // Get the ordered ledger info from a3's QC (for block a1)
    let ordered_ledger_info = a3.block().quorum_cert().ledger_info().clone();
    
    // Create a malicious new ledger info with LOWER version (version regression)
    let old_version = ordered_ledger_info.ledger_info().version();
    let malicious_block_info = a1.block().gen_block_info(
        *ACCUMULATOR_PLACEHOLDER_HASH,
        old_version - 1,  // VERSION REGRESSION!
        None,
    );
    let malicious_ledger_info = LedgerInfo::new(
        malicious_block_info,
        ordered_ledger_info.ledger_info().consensus_data_hash(),
    );
    
    // BUG: This should fail but currently succeeds!
    // SafetyRules signs a commit vote with version regression
    let result = safety_rules.sign_commit_vote(
        ordered_ledger_info,
        malicious_ledger_info,
    );
    
    // This assertion should pass (the bug allows signing)
    // but SHOULD fail with proper version validation
    assert!(result.is_ok(), "BUG: SafetyRules signed a commit vote with version regression!");
}
```

## Notes
This vulnerability demonstrates a critical gap in SafetyRules' validation logic. While the storage layer provides a safety net through its own version monotonicity check, the SafetyRules module must independently enforce this fundamental invariant as part of its core responsibility. The missing validation violates defense-in-depth principles and could enable ledger rollback attacks if combined with other vulnerabilities in the execution or storage layers.

### Citations

**File:** consensus/safety-rules/src/safety_rules.rs (L372-418)
```rust
    fn guarded_sign_commit_vote(
        &mut self,
        ledger_info: LedgerInfoWithSignatures,
        new_ledger_info: LedgerInfo,
    ) -> Result<bls12381::Signature, Error> {
        self.signer()?;

        let old_ledger_info = ledger_info.ledger_info();

        if !old_ledger_info.commit_info().is_ordered_only()
            // When doing fast forward sync, we pull the latest blocks and quorum certs from peers
            // and store them in storage. We then compute the root ordered cert and root commit cert
            // from storage and start the consensus from there. But given that we are not storing the
            // ordered cert obtained from order votes in storage, instead of obtaining the root ordered cert
            // from storage, we set root ordered cert to commit certificate.
            // This means, the root ordered cert will not have a dummy executed_state_id in this case.
            // To handle this, we do not raise error if the old_ledger_info.commit_info() matches with
            // new_ledger_info.commit_info().
            && old_ledger_info.commit_info() != new_ledger_info.commit_info()
        {
            return Err(Error::InvalidOrderedLedgerInfo(old_ledger_info.to_string()));
        }

        if !old_ledger_info
            .commit_info()
            .match_ordered_only(new_ledger_info.commit_info())
        {
            return Err(Error::InconsistentExecutionResult(
                old_ledger_info.commit_info().to_string(),
                new_ledger_info.commit_info().to_string(),
            ));
        }

        // Verify that ledger_info contains at least 2f + 1 dostinct signatures
        if !self.skip_sig_verify {
            ledger_info
                .verify_signatures(&self.epoch_state()?.verifier)
                .map_err(|error| Error::InvalidQuorumCertificate(error.to_string()))?;
        }

        // TODO: add guarding rules in unhappy path
        // TODO: add extension check

        let signature = self.sign(&new_ledger_info)?;

        Ok(signature)
    }
```

**File:** types/src/block_info.rs (L38-39)
```rust
    /// The version of the latest transaction after executing this block.
    version: Version,
```

**File:** types/src/block_info.rs (L196-204)
```rust
    pub fn match_ordered_only(&self, executed_block_info: &BlockInfo) -> bool {
        self.epoch == executed_block_info.epoch
            && self.round == executed_block_info.round
            && self.id == executed_block_info.id
            && (self.timestamp_usecs == executed_block_info.timestamp_usecs
            // executed block info has changed its timestamp because it's a reconfiguration suffix
                || (self.timestamp_usecs > executed_block_info.timestamp_usecs
                    && executed_block_info.has_reconfiguration()))
    }
```

**File:** consensus/safety-rules/src/tests/suite.rs (L846-936)
```rust
fn test_sign_commit_vote(constructor: &Callback) {
    // we construct a chain of proposals
    // genesis -- a1 -- a2 -- a3

    let (mut safety_rules, signer) = constructor();
    let (proof, genesis_qc) = test_utils::make_genesis(&signer);

    let round = genesis_qc.certified_block().round();
    safety_rules.initialize(&proof).unwrap();

    let a1 = test_utils::make_proposal_with_qc(round + 1, genesis_qc, &signer);
    let a2 = make_proposal_with_parent(round + 2, &a1, None, &signer);
    let a3 = make_proposal_with_parent(round + 3, &a2, Some(&a1), &signer);

    // now we try to agree on a1's execution result
    let ledger_info_with_sigs = a3.block().quorum_cert().ledger_info();
    // make sure this is for a1
    assert!(ledger_info_with_sigs
        .ledger_info()
        .commit_info()
        .match_ordered_only(
            &a1.block()
                .gen_block_info(*ACCUMULATOR_PLACEHOLDER_HASH, 0, None,)
        ));

    assert!(safety_rules
        .sign_commit_vote(
            ledger_info_with_sigs.clone(),
            ledger_info_with_sigs.ledger_info().clone()
        )
        .is_ok());

    // check empty ledger info
    assert!(matches!(
        safety_rules
            .sign_commit_vote(
                a2.block().quorum_cert().ledger_info().clone(),
                a3.block().quorum_cert().ledger_info().ledger_info().clone()
            )
            .unwrap_err(),
        Error::InvalidOrderedLedgerInfo(_)
    ));

    // non-dummy blockinfo test
    assert!(matches!(
        safety_rules
            .sign_commit_vote(
                LedgerInfoWithSignatures::new(
                    LedgerInfo::new(
                        a1.block().gen_block_info(
                            *ACCUMULATOR_PLACEHOLDER_HASH,
                            100, // non-dummy value
                            None
                        ),
                        ledger_info_with_sigs.ledger_info().consensus_data_hash()
                    ),
                    AggregateSignature::empty(),
                ),
                ledger_info_with_sigs.ledger_info().clone()
            )
            .unwrap_err(),
        Error::InvalidOrderedLedgerInfo(_)
    ));

    // empty signature test
    assert!(matches!(
        safety_rules
            .sign_commit_vote(
                LedgerInfoWithSignatures::new(
                    ledger_info_with_sigs.ledger_info().clone(),
                    AggregateSignature::empty(),
                ),
                ledger_info_with_sigs.ledger_info().clone()
            )
            .unwrap_err(),
        Error::InvalidQuorumCertificate(_)
    ));

    // inconsistent ledger_info test
    let bad_ledger_info = LedgerInfo::new(
        BlockInfo::random(ledger_info_with_sigs.ledger_info().round()),
        ledger_info_with_sigs.ledger_info().consensus_data_hash(),
    );

    assert!(matches!(
        safety_rules
            .sign_commit_vote(ledger_info_with_sigs.clone(), bad_ledger_info,)
            .unwrap_err(),
        Error::InconsistentExecutionResult(_, _)
    ));
}
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L525-530)
```rust
        ensure!(
            old_committed_ver.is_none() || version_to_commit >= old_committed_ver.unwrap(),
            "Version too old to commit. Committed: {:?}; Trying to commit with LI: {}",
            old_committed_ver,
            version_to_commit,
        );
```

**File:** consensus/safety-rules/src/error.rs (L8-63)
```rust
#[derive(Clone, Debug, Deserialize, Error, PartialEq, Eq, Serialize)]
/// Different reasons for proposal rejection
pub enum Error {
    #[error("Provided epoch, {0}, does not match expected epoch, {1}")]
    IncorrectEpoch(u64, u64),
    #[error("block has next round that wraps around: {0}")]
    IncorrectRound(u64),
    #[error("Provided round, {0}, is incompatible with last voted round, {1}")]
    IncorrectLastVotedRound(u64, u64),
    #[error("Provided round, {0}, is incompatible with preferred round, {1}")]
    IncorrectPreferredRound(u64, u64),
    #[error("Unable to verify that the new tree extends the parent: {0}")]
    InvalidAccumulatorExtension(String),
    #[error("Invalid EpochChangeProof: {0}")]
    InvalidEpochChangeProof(String),
    #[error("Internal error: {0}")]
    InternalError(String),
    #[error("No next_epoch_state specified in the provided Ledger Info")]
    InvalidLedgerInfo,
    #[error("Invalid proposal: {0}")]
    InvalidProposal(String),
    #[error("Invalid QC: {0}")]
    InvalidQuorumCertificate(String),
    #[error("{0} is not set, SafetyRules is not initialized")]
    NotInitialized(String),
    #[error("Does not satisfy order vote rule. Block Round {0}, Highest Timeout Round {1}")]
    NotSafeForOrderVote(u64, u64),
    #[error("Data not found in secure storage: {0}")]
    SecureStorageMissingDataError(String),
    #[error("Unexpected error returned by secure storage: {0}")]
    SecureStorageUnexpectedError(String),
    #[error("Serialization error: {0}")]
    SerializationError(String),
    #[error("Validator key not found: {0}")]
    ValidatorKeyNotFound(String),
    #[error("The validator is not in the validator set. Address not in set: {0}")]
    ValidatorNotInSet(String),
    #[error("Vote proposal missing expected signature")]
    VoteProposalSignatureNotFound,
    #[error("Does not satisfy 2-chain voting rule. Round {0}, Quorum round {1}, TC round {2},  HQC round in TC {3}")]
    NotSafeToVote(u64, u64, u64, u64),
    #[error("Does not satisfy 2-chain timeout rule. Round {0}, Quorum round {1}, TC round {2}, one-chain round {3}")]
    NotSafeToTimeout(u64, u64, u64, u64),
    #[error("Invalid TC: {0}")]
    InvalidTimeoutCertificate(String),
    #[error("Inconsistent Execution Result: Ordered BlockInfo doesn't match executed BlockInfo. Ordered: {0}, Executed: {1}")]
    InconsistentExecutionResult(String, String),
    #[error("Invalid Ordered LedgerInfoWithSignatures: Empty or at least one of executed_state_id, version, or epoch_state are not dummy value: {0}")]
    InvalidOrderedLedgerInfo(String),
    #[error("Waypoint out of date: Previous waypoint version {0}, updated version {1}, current epoch {2}, provided epoch {3}")]
    WaypointOutOfDate(u64, u64, u64, u64),
    #[error("Invalid Timeout: {0}")]
    InvalidTimeout(String),
    #[error("Incorrect 1-chain Quorum Certificate provided for signing order votes. Quorum Certificate: {0}, block id: {1}")]
    InvalidOneChainQuorumCertificate(HashValue, HashValue),
}
```
