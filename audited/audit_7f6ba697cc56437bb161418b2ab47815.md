# Audit Report

## Title
Indexer Crash Loop Due to Unhandled Deserialization Errors in Coin Balance Processing

## Summary
The Aptos indexer contains improper error handling in the coin balance processing pipeline that causes the entire indexer service to crash when encountering resources that fail deserialization. This creates a crash loop preventing all subsequent transactions from being indexed, leading to stale balance data and API service disruption.

## Finding Description

The vulnerability exists in the coin balance processing flow where errors are improperly handled using `.unwrap()` instead of proper error propagation: [1](#0-0) 

When `CoinBalance::from_write_resource()` encounters a deserialization error, it propagates up from: [2](#0-1) 

The error originates from `CoinResource::from_resource()` when `serde_json::from_value()` fails: [3](#0-2) 

The `.unwrap()` causes a panic that crashes the spawned processing task. The runtime catches this and panics the entire process: [4](#0-3) 

When the indexer restarts, it retries from the last checkpoint, encountering the same transaction and crashing again - creating an unrecoverable crash loop.

**Deserialization failures can occur when:**
1. Protocol upgrades change `CoinStore` or `CoinInfo` resource structures without corresponding indexer code updates
2. Resource data on-chain contains unexpected field types or missing required fields
3. Edge cases in resource data that don't match Rust struct definitions

## Impact Explanation

This qualifies as **High Severity** under the Aptos bug bounty program criteria for "API crashes" and "Significant protocol violations":

1. **Service Disruption**: The indexer becomes completely non-functional, unable to process any transactions past the problematic one
2. **Data Inconsistency**: All coin balance data becomes progressively stale as new transactions cannot be indexed
3. **API Unavailability**: Applications relying on the indexer API receive outdated balance information, potentially causing incorrect behavior in wallets, DeFi protocols, and explorers
4. **Manual Intervention Required**: Recovery requires code changes or manual transaction skipping, not automatic recovery

The impact is limited to the indexer (off-chain query infrastructure) and does **not** affect:
- Blockchain consensus or validator operations
- Transaction execution or blockchain state
- User funds or asset security

## Likelihood Explanation

**Likelihood: Medium-High**

This issue is likely to occur during:
1. **Protocol Upgrades**: When the Aptos Framework's Move code is upgraded but indexer Rust code lags behind (common in rapid development)
2. **Backward Compatibility Breaks**: New resource structures that aren't backward compatible with older indexer versions
3. **Edge Cases**: Unexpected data patterns that violate struct field requirements

The same pattern exists in multiple places throughout the indexer codebase, increasing the attack surface: [5](#0-4) [6](#0-5) [7](#0-6) 

## Recommendation

Replace all `.unwrap()` calls with proper error handling that logs errors and continues processing rather than crashing:

**In `coin_activities.rs` function `from_transaction()`:**

```rust
// Replace lines 133-140 with:
let (maybe_coin_info, maybe_coin_balance_data) = 
    if let APIWriteSetChange::WriteResource(write_resource) = wsc {
        let coin_info = match CoinInfo::from_write_resource(
            write_resource, 
            txn_version, 
            txn_timestamp
        ) {
            Ok(info) => info,
            Err(e) => {
                aptos_logger::warn!(
                    transaction_version = txn_version,
                    error = ?e,
                    "Failed to parse CoinInfo from write resource, skipping"
                );
                None
            }
        };
        
        let coin_balance = match CoinBalance::from_write_resource(
            write_resource,
            txn_version,
            txn_timestamp,
        ) {
            Ok(balance) => balance,
            Err(e) => {
                aptos_logger::warn!(
                    transaction_version = txn_version,
                    error = ?e,
                    "Failed to parse CoinBalance from write resource, skipping"
                );
                None
            }
        };
        
        (coin_info, coin_balance)
    } else {
        (None, None)
    };
```

Apply the same pattern to lines 154 and 182. This ensures:
- Errors are logged with full context for debugging
- Individual resource parsing failures don't crash the entire indexer
- Transaction processing continues for other resources
- Monitoring can alert on increased error rates

## Proof of Concept

**Scenario**: Simulate a protocol upgrade where `CoinStore` adds a new required field:

```rust
// Test in crates/indexer/src/models/coin_models/coin_balances.rs
#[cfg(test)]
mod tests {
    use super::*;
    use aptos_api_types::*;
    use serde_json::json;
    
    #[test]
    #[should_panic(expected = "missing field")]
    fn test_malformed_coin_store_causes_panic() {
        // Simulate a CoinStore resource with missing required field
        let malformed_data = json!({
            "coin": {
                "value": "1000"
            },
            "deposit_events": {
                "guid": {
                    "id": {
                        "addr": "0x1",
                        "creation_num": "0"
                    }
                }
            }
            // Missing withdraw_events - required field
        });
        
        let write_resource = WriteResource {
            address: Address::from_hex_literal("0x1").unwrap(),
            state_key_hash: "0x00".to_string(),
            data: MoveResource {
                typ: MoveStructTag {
                    address: Address::from_hex_literal("0x1").unwrap(),
                    module: "coin".parse().unwrap(),
                    name: "CoinStore".parse().unwrap(),
                    generic_type_params: vec![],
                },
                data: malformed_data,
            },
        };
        
        // This will panic due to unwrap() on error
        CoinBalance::from_write_resource(&write_resource, 1, 
            chrono::NaiveDateTime::from_timestamp_opt(0, 0).unwrap())
            .unwrap();
    }
}
```

**Reproduction Steps:**
1. Deploy updated Move framework with modified `CoinStore` structure
2. Execute transaction that creates/updates a `CoinStore` resource
3. Start indexer with outdated Rust code
4. Observe panic and crash loop in indexer logs
5. Verify no transactions after the problematic one are indexed

## Notes

**Important Context:**

This vulnerability affects the **indexer service** (off-chain query infrastructure), **not the core blockchain**. The blockchain continues to operate normally with proper consensus, execution, and state management. However, the issue still warrants High severity classification because:

1. The indexer is critical infrastructure for ecosystem applications (wallets, explorers, DeFi)
2. Crash loops require manual intervention and cannot self-recover
3. The pattern violates Aptos coding guidelines that explicitly prohibit `.unwrap()` in production code
4. Similar patterns exist throughout the indexer codebase, multiplying the risk

The fix is straightforward but requires systematic review of all error handling patterns in the indexer codebase to prevent similar issues.

### Citations

**File:** crates/indexer/src/models/coin_models/coin_activities.rs (L134-134)
```rust
                            .unwrap(),
```

**File:** crates/indexer/src/models/coin_models/coin_activities.rs (L135-140)
```rust
                        CoinBalance::from_write_resource(
                            write_resource,
                            txn_version,
                            txn_timestamp,
                        )
                        .unwrap(),
```

**File:** crates/indexer/src/models/coin_models/coin_activities.rs (L154-154)
```rust
                .unwrap()
```

**File:** crates/indexer/src/models/coin_models/coin_activities.rs (L182-182)
```rust
                CoinEvent::from_event(event_type.as_str(), &event.data, txn_version).unwrap()
```

**File:** crates/indexer/src/models/coin_models/coin_balances.rs (L53-53)
```rust
        match &CoinResource::from_write_resource(write_resource, txn_version)? {
```

**File:** crates/indexer/src/models/coin_models/coin_utils.rs (L189-209)
```rust
    pub fn from_resource(
        data_type: &str,
        data: &serde_json::Value,
        txn_version: i64,
    ) -> Result<CoinResource> {
        match data_type {
            "0x1::coin::CoinInfo" => serde_json::from_value(data.clone())
                .map(|inner| Some(CoinResource::CoinInfoResource(inner))),
            "0x1::coin::CoinStore" => serde_json::from_value(data.clone())
                .map(|inner| Some(CoinResource::CoinStoreResource(inner))),
            _ => Ok(None),
        }
        .context(format!(
            "version {} failed! failed to parse type {}, data {:?}",
            txn_version, data_type, data
        ))?
        .context(format!(
            "Resource unsupported! Call is_resource_supported first. version {} type {}",
            txn_version, data_type
        ))
    }
```

**File:** crates/indexer/src/runtime.rs (L216-219)
```rust
        let batches = match futures::future::try_join_all(tasks).await {
            Ok(res) => res,
            Err(err) => panic!("Error processing transaction batches: {:?}", err),
        };
```
