# Audit Report

## Title
Mutex Poisoning via Channel Send Panic in gRPC Network Service Leading to Permanent DoS

## Summary
The `SimpleMsgExchangeSvc` gRPC service implementation contains a critical flaw where panicking during message handling while holding a mutex lock causes mutex poisoning, permanently breaking the entire network service for all message types.

## Finding Description

The vulnerability exists in the gRPC network message service implementation used by Aptos's remote executor networking layer. The issue stems from improper error handling when sending messages through crossbeam channels combined with Rust's mutex poisoning mechanism. [1](#0-0) 

The async handler calls the trait implementation which acquires a mutex lock and attempts to send messages: [2](#0-1) 

The critical vulnerability occurs at the mutex lock acquisition and channel send operation: [3](#0-2) 

**Attack Path:**

1. The `NetworkController` creates inbound channels using crossbeam's unbounded channels: [4](#0-3) [5](#0-4) 

2. The `Receiver` is returned to application code, while the `Sender` is stored in the `inbound_handlers` HashMap protected by a `Mutex`.

3. If the application code crashes, restarts, or otherwise drops the `Receiver`, the channel becomes disconnected.

4. When an attacker sends a gRPC `NetworkMessage` with a `message_type` corresponding to the dropped receiver, the service:
   - Acquires the mutex lock via `self.inbound_handlers.lock().unwrap()`
   - Retrieves the sender from the HashMap
   - Due to Rust's temporary lifetime extension rules, the `MutexGuard` remains alive for the entire `if let` block
   - Attempts to send to the disconnected channel: `handler.send(msg).unwrap()`
   - The crossbeam channel returns `Err` when the receiver is dropped
   - The `.unwrap()` panics **while the mutex lock is still held**

5. When a panic occurs while holding a mutex lock in Rust, the mutex becomes **poisoned**.

6. All subsequent gRPC requests attempt to acquire the same mutex and panic immediately when calling `.unwrap()` on the poisoned mutex, **regardless of message type**.

7. The tokio executor continues running (async executors don't get "poisoned"), but every incoming request fails with a panic, effectively creating a permanent DoS condition.

**Invariants Broken:**
- **Resource Limits**: The service fails to gracefully handle resource cleanup (dropped receivers)
- **Service Availability**: The network communication service becomes permanently unavailable
- **Protocol Integrity**: Network message routing fails completely

## Impact Explanation

This is a **High Severity** vulnerability according to the Aptos Bug Bounty criteria:

- **API Crashes**: The gRPC network service becomes completely unusable, with all requests failing
- **Validator Node Impact**: If validators use this service for networking, they cannot communicate, potentially affecting consensus
- **Significant Protocol Violation**: Complete breakdown of the network message routing system

The vulnerability causes:
1. **Permanent Service Disruption**: Once triggered, requires node restart to recover
2. **Cascading Failure**: A single dropped receiver can break all message types
3. **Network Partition Risk**: If multiple nodes are affected, network communication breaks down

It doesn't reach Critical severity because:
- No direct loss of funds
- Doesn't break consensus safety guarantees (validators can still use other networking layers)
- Recoverable with node restart
- Requires specific preconditions (dropped receiver + knowledge of message type)

## Likelihood Explanation

**Likelihood: Medium-High**

The vulnerability is likely to occur because:

1. **Normal Operations**: Receivers can be legitimately dropped during:
   - Service restarts or reconfigurations
   - Component crashes or failures
   - Resource cleanup operations
   - Graceful shutdowns if not handled carefully

2. **No Cleanup Mechanism**: The code has no mechanism to remove senders from the HashMap when their corresponding receivers are dropped: [6](#0-5) 

3. **Simple Exploitation**: Once a receiver is dropped (whether by accident or design), any remote client can trigger the vulnerability by sending a single NetworkMessage with the corresponding message_type.

4. **Persistent Effect**: The mutex poisoning is permanent until the process restarts.

The same vulnerability pattern exists in multiple locations: [7](#0-6) 

## Recommendation

**Immediate Fix:** Replace `.unwrap()` calls with proper error handling that doesn't panic while holding locks.

**Solution 1 - Graceful Error Handling:**
```rust
async fn simple_msg_exchange(
    &self,
    request: Request<NetworkMessage>,
) -> Result<Response<Empty>, Status> {
    let _timer = NETWORK_HANDLER_TIMER
        .with_label_values(&[&self.self_addr.to_string(), "inbound_msgs"])
        .start_timer();
    let remote_addr = request.remote_addr();
    let network_message = request.into_inner();
    let msg = Message::new(network_message.message);
    let message_type = MessageType::new(network_message.message_type);

    // Don't panic on lock failure - return gRPC error instead
    let handlers = self.inbound_handlers.lock()
        .map_err(|e| Status::internal(format!("Handler lock poisoned: {}", e)))?;
    
    if let Some(handler) = handlers.get(&message_type) {
        // Don't panic on send failure - return gRPC error instead
        handler.send(msg)
            .map_err(|e| Status::internal(format!("Channel disconnected: {:?}", e)))?;
    } else {
        error!(
            "No handler registered for sender: {:?} and msg type {:?}",
            remote_addr, message_type
        );
        return Err(Status::not_found("Handler not registered"));
    }
    Ok(Response::new(Empty {}))
}
```

**Solution 2 - Automatic Cleanup:**
Implement a mechanism to detect and remove senders for dropped receivers, possibly using weak references or periodic cleanup tasks.

**Solution 3 - Use Aptos's Infallible Mutex:**
The codebase already has a poison-resistant mutex wrapper that could be used instead of `std::sync::Mutex`.

## Proof of Concept

```rust
#[cfg(test)]
mod vulnerability_test {
    use super::*;
    use std::net::{IpAddr, Ipv4Addr, SocketAddr};
    use aptos_config::utils;

    #[test]
    #[should_panic(expected = "poisoned")]
    fn test_mutex_poisoning_via_dropped_receiver() {
        // Setup server
        let server_addr = SocketAddr::new(
            IpAddr::V4(Ipv4Addr::LOCALHOST), 
            utils::get_available_port()
        );
        let message_type = "test_type".to_string();
        let server_handlers: Arc<Mutex<HashMap<MessageType, Sender<Message>>>> =
            Arc::new(Mutex::new(HashMap::new()));

        // Create channel and register handler
        let (msg_tx, msg_rx) = crossbeam_channel::unbounded();
        server_handlers
            .lock()
            .unwrap()
            .insert(MessageType::new(message_type.clone()), msg_tx);
        
        // Start gRPC server
        let server = GRPCNetworkMessageServiceServerWrapper::new(
            server_handlers.clone(), 
            server_addr
        );
        let rt = Runtime::new().unwrap();
        let (server_shutdown_tx, server_shutdown_rx) = oneshot::channel();
        server.start(&rt, "test".to_string(), server_addr, 1000, server_shutdown_rx);

        // Wait for server to start
        std::thread::sleep(std::time::Duration::from_millis(50));

        // Create client
        let mut grpc_client = GRPCNetworkMessageServiceClientWrapper::new(&rt, server_addr);
        let client_addr = SocketAddr::new(
            IpAddr::V4(Ipv4Addr::LOCALHOST), 
            utils::get_available_port()
        );

        // STEP 1: Drop the receiver (simulates service crash/restart)
        drop(msg_rx);

        // STEP 2: Send a message - this will panic and poison the mutex
        rt.block_on(async {
            grpc_client
                .send_message(
                    client_addr,
                    Message::new(vec![1, 2, 3]),
                    &MessageType::new(message_type.clone()),
                )
                .await;
        });

        // STEP 3: Try to send another message - mutex is now poisoned
        // This will panic even with a different message type because the mutex is poisoned
        rt.block_on(async {
            grpc_client
                .send_message(
                    client_addr,
                    Message::new(vec![4, 5, 6]),
                    &MessageType::new("different_type".to_string()),
                )
                .await;
        });

        server_shutdown_tx.send(()).unwrap();
    }
}
```

## Notes

The vulnerability is particularly insidious because:
1. The mutex poisoning affects **all** message types, not just the one with the dropped receiver
2. The generated tonic code correctly isolates panics to individual futures, but the implementation's mutex poisoning creates a shared failure point
3. The same pattern appears in multiple locations in the `secure/net` module
4. Normal Rust async runtime behavior (task-level panic isolation) doesn't prevent the mutex-level failure propagation

This demonstrates why using `.unwrap()` in service handlers is dangerous - proper error handling should return gRPC errors rather than panicking.

### Citations

**File:** protos/rust/src/pb/aptos.remote_executor.v1.tonic.rs (L224-237)
```rust
                        fn call(
                            &mut self,
                            request: tonic::Request<super::NetworkMessage>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as NetworkMessageService>::simple_msg_exchange(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
```

**File:** secure/net/src/grpc_network_service/mod.rs (L93-115)
```rust
    async fn simple_msg_exchange(
        &self,
        request: Request<NetworkMessage>,
    ) -> Result<Response<Empty>, Status> {
        let _timer = NETWORK_HANDLER_TIMER
            .with_label_values(&[&self.self_addr.to_string(), "inbound_msgs"])
            .start_timer();
        let remote_addr = request.remote_addr();
        let network_message = request.into_inner();
        let msg = Message::new(network_message.message);
        let message_type = MessageType::new(network_message.message_type);

        if let Some(handler) = self.inbound_handlers.lock().unwrap().get(&message_type) {
            // Send the message to the registered handler
            handler.send(msg).unwrap();
        } else {
            error!(
                "No handler registered for sender: {:?} and msg type {:?}",
                remote_addr, message_type
            );
        }
        Ok(Response::new(Empty {}))
    }
```

**File:** secure/net/src/network_controller/mod.rs (L8-8)
```rust
use crossbeam_channel::{unbounded, Receiver, Sender};
```

**File:** secure/net/src/network_controller/mod.rs (L128-137)
```rust
    pub fn create_inbound_channel(&mut self, message_type: String) -> Receiver<Message> {
        let (inbound_sender, inbound_receiver) = unbounded();

        self.inbound_handler
            .lock()
            .unwrap()
            .register_handler(message_type, inbound_sender);

        inbound_receiver
    }
```

**File:** secure/net/src/network_controller/inbound_handler.rs (L34-42)
```rust
    pub fn register_handler(&self, message_type: String, sender: Sender<Message>) {
        assert!(!self
            .inbound_handlers
            .lock()
            .unwrap()
            .contains_key(&MessageType::new(message_type.clone())));
        let mut inbound_handlers = self.inbound_handlers.lock().unwrap();
        inbound_handlers.insert(MessageType::new(message_type), sender);
    }
```

**File:** secure/net/src/network_controller/inbound_handler.rs (L66-74)
```rust
    pub fn send_incoming_message_to_handler(&self, message_type: &MessageType, message: Message) {
        // Check if there is a registered handler for the sender
        if let Some(handler) = self.inbound_handlers.lock().unwrap().get(message_type) {
            // Send the message to the registered handler
            handler.send(message).unwrap();
        } else {
            warn!("No handler registered for message type: {:?}", message_type);
        }
    }
```
