# Audit Report

## Title
Governance-Triggered Network Halt via VM Binary Format Version Downgrade

## Summary
The Aptos blockchain allows governance proposals to disable VM binary format version feature flags (V6-V10) without any protection mechanisms. A malicious governance proposal that disables `VM_BINARY_FORMAT_V9` would force validators to reject all modules compiled with bytecode version 9, including the Aptos Framework itself, resulting in complete network halt requiring a hardfork to recover.

## Finding Description

The vulnerability exists in the interaction between three components:

**1. Unprotected Feature Flags**

The VM binary format version flags can be freely disabled through governance: [1](#0-0) [2](#0-1) [3](#0-2) [4](#0-3) [5](#0-4) 

Unlike critical security features that have explicit "cannot be disabled" protections: [6](#0-5) [7](#0-6) [8](#0-7) 

The VM binary format flags lack any such protection.

**2. Version Downgrade Mechanism**

The `get_max_binary_format_version()` function returns the highest enabled version in descending order: [9](#0-8) 

This value directly controls which bytecode versions are accepted by the deserializer.

**3. Governance Control Path**

Governance can modify feature flags through standard proposals: [10](#0-9) 

The underlying function accepts both enable and disable vectors without validation: [11](#0-10) [12](#0-11) 

**4. Runtime Enforcement**

The max binary format version is used during module deserialization to reject incompatible bytecode: [13](#0-12) 

This check occurs every time modules are loaded from storage during transaction execution: [14](#0-13) 

**Attack Scenario:**

1. Attacker creates a governance proposal to disable `VM_BINARY_FORMAT_V9` (feature flag #102)
2. Proposal passes through social engineering or attacker's voting power
3. At next epoch boundary, `on_new_epoch()` applies the change
4. `get_max_binary_format_version()` now returns `VERSION_8` instead of `VERSION_9`
5. When any transaction executes:
   - VM attempts to load framework modules (compiled with VERSION_9 by default)
   - Deserializer checks: `version (9) > max_version (8)` 
   - Returns `UNKNOWN_VERSION` error
   - Transaction execution fails
6. All validators experience the same failure
7. Network cannot process any transactions - complete halt

**Invariant Violations:**

- **Liveness**: Network cannot process transactions (Invariant #1: Deterministic Execution fails across all validators)
- **Consensus Safety**: Unable to reach consensus on new blocks (Invariant #2)
- **State Consistency**: Cannot execute state transitions (Invariant #4)

## Impact Explanation

This vulnerability qualifies as **Critical Severity** under the Aptos Bug Bounty Program:

**"Total loss of liveness/network availability"** - The entire Aptos network would halt indefinitely. No transactions could be processed, no blocks could be produced, and no state transitions could occur.

**"Non-recoverable network partition (requires hardfork)"** - Recovery requires either:
- A hardfork to re-enable the feature flag
- A hardfork to redeploy all framework modules with older bytecode version
- Emergency intervention by core developers

**Impact Scope:**
- **Affected Nodes**: 100% of validators and fullnodes
- **Affected Users**: All network participants  
- **Affected Applications**: All dApps and services
- **Recovery Time**: Days to weeks (requires hardfork coordination)
- **Financial Impact**: Massive (network downtime, loss of confidence, emergency response costs)

## Likelihood Explanation

**Attack Complexity: Medium**

The attack requires:
1. Creating a governance proposal (standard mechanism, publicly documented)
2. Getting the proposal to pass (requires voting power OR social engineering)

**Attacker Requirements:**

- **Minimum Voting Power**: Depends on governance parameters, but decentralized governance means no single entity should have absolute control
- **Social Engineering**: Malicious proposal could be disguised as a "security upgrade" or "optimization"
- **Knowledge**: Attacker needs understanding of VM versioning system and governance mechanism

**Likelihood Assessment: Medium to High**

While governance attacks are difficult, several factors increase likelihood:
- Governance participants may not fully understand technical implications
- Proposal could be disguised within a bundle of legitimate changes
- No technical safeguards exist (purely relies on governance vigilance)
- Historical precedent: Other blockchains have suffered from governance attacks

**Detection Difficulty: High**

The attack is not immediately visible:
- Proposal appears as legitimate feature flag change
- Impact only manifests at epoch boundary
- No on-chain indicators warn of impending failure

## Recommendation

**Immediate Fix: Mark VM Binary Format Version Flags as Non-Disableable**

Add explicit protections preventing downgrade of VM binary format versions:

1. **In Move Framework** (`features.move`):

Add protection similar to other critical features:

```move
const VM_BINARY_FORMAT_V6: u64 = 5;
const VM_BINARY_FORMAT_V7: u64 = 40;
const VM_BINARY_FORMAT_V8: u64 = 86;
const VM_BINARY_FORMAT_V9: u64 = 102;
const VM_BINARY_FORMAT_V10: u64 = 106;

public fun get_vm_binary_format_v6(): u64 {
    abort error::invalid_argument(EFEATURE_CANNOT_BE_DISABLED)
}
// Similar for V7, V8, V9, V10

public fun vm_binary_format_v6_enabled(): bool {
    true // Always enabled
}
// Similar for other versions
```

2. **Add Validation in `apply_diff()`**:

```move
fun apply_diff(features: &mut vector<u8>, enable: vector<u64>, disable: vector<u64>) {
    // Validate that critical features are not being disabled
    let critical_features = vector[
        VM_BINARY_FORMAT_V6,
        VM_BINARY_FORMAT_V7,
        VM_BINARY_FORMAT_V8,
        VM_BINARY_FORMAT_V9,
        VM_BINARY_FORMAT_V10,
    ];
    
    disable.for_each_ref(|feature| {
        assert!(
            !critical_features.contains(feature),
            error::invalid_argument(EFEATURE_CANNOT_BE_DISABLED)
        );
    });
    
    enable.for_each(|feature| {
        set(features, feature, true);
    });
    disable.for_each(|feature| {
        set(features, feature, false);
    });
}
```

3. **Add Rust-Side Validation**:

In `get_max_binary_format_version()`, add a minimum version check:

```rust
pub fn get_max_binary_format_version(&self) -> u32 {
    let version = if self.is_enabled(FeatureFlag::VM_BINARY_FORMAT_V10) {
        file_format_common::VERSION_10
    } else if self.is_enabled(FeatureFlag::VM_BINARY_FORMAT_V9) {
        file_format_common::VERSION_9
    } else if self.is_enabled(FeatureFlag::VM_BINARY_FORMAT_V8) {
        file_format_common::VERSION_8
    } else if self.is_enabled(FeatureFlag::VM_BINARY_FORMAT_V7) {
        file_format_common::VERSION_7
    } else if self.is_enabled(FeatureFlag::VM_BINARY_FORMAT_V6) {
        file_format_common::VERSION_6
    } else {
        file_format_common::VERSION_5
    };
    
    // Enforce minimum version to prevent network halt
    const MIN_SAFE_VERSION: u32 = file_format_common::VERSION_9;
    std::cmp::max(version, MIN_SAFE_VERSION)
}
```

## Proof of Concept

**Governance Proposal Script** (would be executed via `aptos_governance::create_proposal`):

```move
script {
    use std::features;
    use aptos_framework::aptos_governance;
    
    fun malicious_downgrade_proposal(framework: &signer) {
        let enable = vector::empty<u64>();
        let disable = vector[102]; // VM_BINARY_FORMAT_V9
        
        // This would pass without protections
        features::change_feature_flags_for_next_epoch(
            framework,
            enable,
            disable
        );
        
        aptos_governance::reconfigure(framework);
        // Network halts at next epoch boundary
    }
}
```

**Expected Behavior After Attack:**

1. Proposal executes successfully
2. At next epoch boundary, `VM_BINARY_FORMAT_V9` is disabled
3. Next transaction execution attempts to load any framework module
4. Deserializer encounters version 9 bytecode but `max_version = 8`
5. Error: `StatusCode::UNKNOWN_VERSION` with message "bytecode version 9 unsupported"
6. Transaction execution aborts
7. All subsequent transactions fail identically
8. Network cannot produce new blocks (no successful transactions)
9. Complete network halt

**Validation Steps:**

1. Check current framework bytecode version in production (expected: VERSION_9)
2. Verify no protections exist on VM binary format flags
3. Simulate governance proposal to disable flag
4. Observe module loading failures post-epoch
5. Confirm network-wide impact

---

**Notes:**

- This vulnerability exists because VM version management was designed for forward compatibility (enabling new versions) but lacks protection against malicious downgrades
- The fix requires both Move and Rust changes to ensure defense-in-depth
- Once framework modules are deployed with a given version, that version must remain supported indefinitely
- Similar protection should be applied to other version-critical features in the future

### Citations

**File:** types/src/on_chain_config/aptos_features.rs (L24-24)
```rust
    VM_BINARY_FORMAT_V6 = 5,
```

**File:** types/src/on_chain_config/aptos_features.rs (L37-38)
```rust
    /// Enabled on mainnet and cannot be disabled
    _SIGNATURE_CHECKER_V2 = 18,
```

**File:** types/src/on_chain_config/aptos_features.rs (L60-60)
```rust
    VM_BINARY_FORMAT_V7 = 40,
```

**File:** types/src/on_chain_config/aptos_features.rs (L79-80)
```rust
    /// Enabled on mainnet, can never be disabled.
    _REJECT_UNSTABLE_BYTECODE = 58,
```

**File:** types/src/on_chain_config/aptos_features.rs (L93-94)
```rust
    /// Enabled on mainnet, cannot be disabled.
    _LIMIT_VM_TYPE_SIZE = 69,
```

**File:** types/src/on_chain_config/aptos_features.rs (L135-135)
```rust
    VM_BINARY_FORMAT_V8 = 86,
```

**File:** types/src/on_chain_config/aptos_features.rs (L157-157)
```rust
    VM_BINARY_FORMAT_V9 = 102,
```

**File:** types/src/on_chain_config/aptos_features.rs (L165-165)
```rust
    VM_BINARY_FORMAT_V10 = 106,
```

**File:** types/src/on_chain_config/aptos_features.rs (L485-499)
```rust
    pub fn get_max_binary_format_version(&self) -> u32 {
        if self.is_enabled(FeatureFlag::VM_BINARY_FORMAT_V10) {
            file_format_common::VERSION_10
        } else if self.is_enabled(FeatureFlag::VM_BINARY_FORMAT_V9) {
            file_format_common::VERSION_9
        } else if self.is_enabled(FeatureFlag::VM_BINARY_FORMAT_V8) {
            file_format_common::VERSION_8
        } else if self.is_enabled(FeatureFlag::VM_BINARY_FORMAT_V7) {
            file_format_common::VERSION_7
        } else if self.is_enabled(FeatureFlag::VM_BINARY_FORMAT_V6) {
            file_format_common::VERSION_6
        } else {
            file_format_common::VERSION_5
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L714-718)
```text
    public fun toggle_features(aptos_framework: &signer, enable: vector<u64>, disable: vector<u64>) {
        system_addresses::assert_aptos_framework(aptos_framework);
        features::change_feature_flags_for_next_epoch(aptos_framework, enable, disable);
        reconfigure(aptos_framework);
    }
```

**File:** aptos-move/framework/move-stdlib/sources/configs/features.move (L805-828)
```text
    public fun change_feature_flags_for_next_epoch(
        framework: &signer,
        enable: vector<u64>,
        disable: vector<u64>
    ) acquires PendingFeatures, Features {
        assert!(signer::address_of(framework) == @std, error::permission_denied(EFRAMEWORK_SIGNER_NEEDED));

        // Figure out the baseline feature vec that the diff will be applied to.
        let new_feature_vec = if (exists<PendingFeatures>(@std)) {
            // If there is a buffered feature vec, use it as the baseline.
            let PendingFeatures { features } = move_from<PendingFeatures>(@std);
            features
        } else if (exists<Features>(@std)) {
            // Otherwise, use the currently effective feature flag vec as the baseline, if it exists.
            Features[@std].features
        } else {
            // Otherwise, use an empty feature vec.
            vector[]
        };

        // Apply the diff and save it to the buffer.
        apply_diff(&mut new_feature_vec, enable, disable);
        move_to(framework, PendingFeatures { features: new_feature_vec });
    }
```

**File:** aptos-move/framework/move-stdlib/sources/configs/features.move (L874-881)
```text
    fun apply_diff(features: &mut vector<u8>, enable: vector<u64>, disable: vector<u64>) {
        enable.for_each(|feature| {
            set(features, feature, true);
        });
        disable.for_each(|feature| {
            set(features, feature, false);
        });
    }
```

**File:** third_party/move/move-binary-format/src/file_format_common.rs (L617-619)
```rust
            if version == 0 || version > u32::min(max_version, VERSION_MAX) {
                Err(PartialVMError::new(StatusCode::UNKNOWN_VERSION)
                    .with_message(format!("bytecode version {} unsupported", version)))
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L137-142)
```rust
pub fn aptos_prod_deserializer_config(features: &Features) -> DeserializerConfig {
    DeserializerConfig::new(
        features.get_max_binary_format_version(),
        features.get_max_identifier_size(),
    )
}
```
