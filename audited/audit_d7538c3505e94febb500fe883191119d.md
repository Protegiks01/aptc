# Audit Report

## Title
State Snapshot Finalization Metadata Inconsistency Leading to Incorrect Pruning Boundary After Crash Recovery

## Summary
The `save_min_readable_version()` function in `StateKvPrunerManager` updates in-memory state before persisting to disk. If disk persistence fails but the node continues operating and later crashes, restart will load stale metadata, causing the node to incorrectly accept queries for data that doesn't exist in the database.

## Finding Description

The vulnerability exists in the non-atomic update pattern in `save_min_readable_version()`: [1](#0-0) 

The function updates in-memory `min_readable_version` (line 58-59) **before** attempting disk persistence (line 65). This violates atomicity because:

1. If `write_pruner_progress()` fails after in-memory update, the function returns an error but in-memory state remains modified
2. The node continues operating with the updated in-memory value
3. On crash and restart, the old disk value is loaded [2](#0-1) 

**Critical Context - State Snapshot Finalization:**

During state snapshot restoration, `finalize_state_snapshot()` applies a snapshot containing only data from a specific version onwards: [3](#0-2) 

After committing snapshot data, it calls `save_min_readable_version()` to record that earlier versions are unavailable. If this metadata update fails on disk but succeeds in memory, and the node crashes: [4](#0-3) 

On restart, `get_state_kv_pruner_progress()` loads the old (lower) version from disk, causing the node to believe data before the snapshot is available when it isn't.

**State Access Violation:**

The pruning check uses the loaded min_readable_version to validate requests: [5](#0-4) 

With incorrect (too low) min_readable_version, queries for missing versions bypass the pruning check and reach the database, returning `None` instead of a proper "data pruned" error.

## Impact Explanation

**Medium Severity** - State inconsistencies requiring intervention:

1. **Incorrect API Responses**: Nodes return "state not found" for versions that should return "data pruned", violating API contract
2. **State Sync Integrity**: Nodes may serve incomplete state snapshots to syncing nodes, claiming availability of non-existent historical data
3. **Validator Consistency Risk**: While not directly causing consensus failure, validators with incorrect metadata may provide inconsistent responses to state queries from other nodes
4. **Recovery Complexity**: Operators must manually identify and correct the min_readable_version metadata after discovering the inconsistency

This doesn't cause fund loss or consensus safety violations, but creates operational inconsistencies requiring manual intervention, meeting Medium severity criteria.

## Likelihood Explanation

**Moderate Likelihood:**

1. **Trigger Conditions**: Requires disk I/O failure (disk full, hardware error, filesystem issues) during state snapshot finalization - uncommon but realistic in production
2. **Timing Window**: Must occur between in-memory update and disk persistence, followed by node crash before correction - narrow but possible
3. **Detection Difficulty**: Issue is silent until queries for missing data expose the inconsistency, potentially going unnoticed initially
4. **Frequency**: State snapshots are applied during fast sync and recovery operations, creating regular exposure windows

While not trivially exploitable by attackers, this is a realistic failure scenario in production environments with hardware issues or resource constraints.

## Recommendation

Implement atomic update pattern by persisting to disk **before** updating in-memory state, with proper rollback on failure:

```rust
fn save_min_readable_version(&self, min_readable_version: Version) -> Result<()> {
    // Persist to disk FIRST
    self.state_kv_db.write_pruner_progress(min_readable_version)?;
    
    // Only update in-memory state after successful disk write
    self.min_readable_version
        .store(min_readable_version, Ordering::SeqCst);

    PRUNER_VERSIONS
        .with_label_values(&["state_kv_pruner", "min_readable"])
        .set(min_readable_version as i64);

    Ok(())
}
```

This ensures in-memory and disk state remain consistent. If disk write fails, in-memory state is never updated and the error propagates correctly.

**Alternative**: Wrap in a transaction that can rollback in-memory state on persistence failure, though the simpler approach above is preferred.

## Proof of Concept

```rust
#[cfg(test)]
mod test_save_min_readable_version_consistency {
    use super::*;
    use std::sync::Arc;
    
    #[test]
    fn test_persistence_failure_leaves_inconsistent_state() {
        // Setup: Create StateKvPrunerManager with initial min_readable_version = 0
        let state_kv_db = Arc::new(StateKvDb::new(/* ... */));
        let manager = StateKvPrunerManager::new(
            state_kv_db.clone(),
            LedgerPrunerConfig {
                enable: true,
                prune_window: 100000,
                batch_size: 1000,
                ..Default::default()
            }
        );
        
        assert_eq!(manager.get_min_readable_version(), 0);
        
        // Simulate state snapshot finalization at version 1000
        // Step 1: Snapshot data is committed successfully
        // (not shown - would write state data for version 1000)
        
        // Step 2: Inject disk failure for metadata persistence
        // (In real scenario: disk full, I/O error, etc.)
        // Mock write_pruner_progress to fail:
        // state_kv_db.metadata_db().inject_write_failure();
        
        // Step 3: Call save_min_readable_version(1000) - will fail on disk
        let result = manager.save_min_readable_version(1000);
        assert!(result.is_err()); // Disk write failed
        
        // BUG: In-memory state is already updated despite failure!
        assert_eq!(manager.get_min_readable_version(), 1000); // ❌ Should be 0
        
        // Step 4: Simulate node restart
        // Re-create manager (loads from disk)
        let manager_after_restart = StateKvPrunerManager::new(
            state_kv_db.clone(),
            LedgerPrunerConfig {
                enable: true,
                prune_window: 100000,
                batch_size: 1000,
                ..Default::default()
            }
        );
        
        // Loaded old value from disk
        assert_eq!(manager_after_restart.get_min_readable_version(), 0);
        
        // Step 5: Query for version 500 (which doesn't exist in snapshot)
        // Should return "pruned" error but passes pruning check
        // because min_readable_version = 0 (instead of 1000)
        let query_result = state_kv_db.get_state_value_with_version_by_version(
            &some_state_key,
            500
        );
        
        // Returns None (not found) instead of proper "pruned" error ❌
        assert_eq!(query_result.unwrap(), None);
        
        // Expected behavior: Should reject with "data at version 500 is pruned,
        // min available version is 1000"
    }
}
```

**Notes**

The vulnerability requires additional context beyond the immediate code:

1. **Initialization Context**: The `min_readable_version` is loaded from disk during `StateKvPrunerManager::new()` [6](#0-5) 

2. **Usage in State Sync**: The trait comment explicitly states this is "Only used at the end of fast sync" [7](#0-6) 

3. **Actual Pruning**: The background pruner worker persists progress atomically within each batch [8](#0-7) , making this specific issue isolated to the fast sync finalization path.

This is a real consistency bug that violates state management invariants and should be fixed, though it requires specific failure conditions to manifest.

### Citations

**File:** storage/aptosdb/src/pruner/state_kv_pruner/state_kv_pruner_manager.rs (L57-66)
```rust
    fn save_min_readable_version(&self, min_readable_version: Version) -> Result<()> {
        self.min_readable_version
            .store(min_readable_version, Ordering::SeqCst);

        PRUNER_VERSIONS
            .with_label_values(&["state_kv_pruner", "min_readable"])
            .set(min_readable_version as i64);

        self.state_kv_db.write_pruner_progress(min_readable_version)
    }
```

**File:** storage/aptosdb/src/pruner/state_kv_pruner/state_kv_pruner_manager.rs (L94-99)
```rust
        let min_readable_version =
            pruner_utils::get_state_kv_pruner_progress(&state_kv_db).expect("Must succeed.");

        PRUNER_VERSIONS
            .with_label_values(&["state_kv_pruner", "min_readable"])
            .set(min_readable_version as i64);
```

**File:** storage/aptosdb/src/state_kv_db.rs (L217-222)
```rust
    pub(crate) fn write_pruner_progress(&self, version: Version) -> Result<()> {
        self.state_kv_metadata_db.put::<DbMetadataSchema>(
            &DbMetadataKey::StateKvPrunerProgress,
            &DbMetadataValue::Version(version),
        )
    }
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L225-234)
```rust
            self.ledger_pruner.save_min_readable_version(version)?;
            self.state_store
                .state_merkle_pruner
                .save_min_readable_version(version)?;
            self.state_store
                .epoch_snapshot_pruner
                .save_min_readable_version(version)?;
            self.state_store
                .state_kv_pruner
                .save_min_readable_version(version)?;
```

**File:** storage/aptosdb/src/pruner/pruner_utils.rs (L23-29)
```rust
pub(crate) fn get_state_kv_pruner_progress(state_kv_db: &StateKvDb) -> Result<Version> {
    Ok(get_progress(
        state_kv_db.metadata_db(),
        &DbMetadataKey::StateKvPrunerProgress,
    )?
    .unwrap_or(0))
}
```

**File:** storage/aptosdb/src/db/aptosdb_internal.rs (L305-315)
```rust
    pub(super) fn error_if_state_kv_pruned(&self, data_type: &str, version: Version) -> Result<()> {
        let min_readable_version = self.state_store.state_kv_pruner.get_min_readable_version();
        ensure!(
            version >= min_readable_version,
            "{} at version {} is pruned, min available version is {}.",
            data_type,
            version,
            min_readable_version
        );
        Ok(())
    }
```

**File:** storage/aptosdb/src/pruner/pruner_manager.rs (L33-35)
```rust
    // Only used at the end of fast sync to store the min_readable_version to db and update the
    // in memory progress.
    fn save_min_readable_version(&self, min_readable_version: Version) -> Result<()>;
```

**File:** storage/aptosdb/src/pruner/state_kv_pruner/state_kv_metadata_pruner.rs (L67-72)
```rust
        batch.put::<DbMetadataSchema>(
            &DbMetadataKey::StateKvPrunerProgress,
            &DbMetadataValue::Version(target_version),
        )?;

        self.state_kv_db.metadata_db().write_schemas(batch)
```
