# Audit Report

## Title
Bytecode Version Lower Bound Not Validated - Unsupported Script Versions Accepted by Deserializer

## Summary
The Move bytecode deserializer fails to validate that script versions meet the minimum supported version (VERSION_MIN = 5). This allows scripts compiled with deprecated bytecode versions 1-4 to be deserialized and executed, even though these versions have different security properties and verification semantics that are no longer officially supported.

## Finding Description

The vulnerability exists in the version validation logic during bytecode deserialization. The system explicitly defines `VERSION_MIN = VERSION_5 = 5` as the minimum supported bytecode version, [1](#0-0)  yet the deserializer only validates the upper bound.

In `VersionedBinary::new()`, the version check is: [2](#0-1) 

This check only rejects `version == 0` or `version > max_version`, but does **not** reject versions below VERSION_MIN (versions 1, 2, 3, 4).

In contrast, the serializer correctly validates both bounds: [3](#0-2) 

**Different versions have fundamentally different security semantics:**

1. **Signer Type Handling**: VERSION_1 requires `&signer` references while VERSION_2+ uses value type `signer`: [4](#0-3) 

2. **Script Verification**: VERSION_5+ returns early without signature checks, while older versions apply legacy validation: [5](#0-4) 

3. **Feature Availability**: Each version introduced new features (VERSION_2: friend declarations, VERSION_3: phantom types, VERSION_4: vector operations) that should not be available in earlier versions.

The `deserialize_into_script()` function in the eager loader calls this vulnerable version check: [6](#0-5) 

## Impact Explanation

This is a **High Severity** vulnerability based on the Aptos bug bounty criteria for "Significant protocol violations." The impact includes:

1. **Protocol Invariant Violation**: The explicit VERSION_MIN constraint is bypassed, allowing execution of officially unsupported bytecode versions.

2. **Non-Deterministic Execution Risk**: Different bytecode versions have different verification and execution semantics. If validators have inconsistent handling of legacy versions, this could lead to consensus splits.

3. **Security Property Bypass**: Each version upgrade addressed specific security concerns. Allowing older versions bypasses these improvements.

4. **Verification Inconsistency**: The verifier applies version-specific logic, meaning a VERSION_1 script would execute under legacy rules while the system expects VERSION_5+ semantics.

While this doesn't directly cause fund loss, it violates the "Deterministic Execution" invariant (all validators must produce identical state roots) and "Move VM Safety" invariant (bytecode execution must follow defined rules).

## Likelihood Explanation

**Likelihood: Medium to High**

- **Attacker Requirements**: Only requires ability to submit transactions with crafted bytecode - no special privileges needed.
- **Complexity**: Low - simply compile or construct a script with version 1-4 in the binary header.
- **Detection**: The vulnerability is in production code and not covered by existing tests, which only validate the upper bound: [7](#0-6) 

The actual exploitability depends on whether legacy version handling creates observable differences in execution outcomes across validators.

## Recommendation

Add lower bound validation to match the serializer's check. In `VersionedBinary::new()`, change the validation to:

```rust
if version == 0 || version < VERSION_MIN || version > u32::min(max_version, VERSION_MAX) {
    Err(PartialVMError::new(StatusCode::UNKNOWN_VERSION)
        .with_message(format!("bytecode version {} unsupported (must be {}-{})", 
                             version, VERSION_MIN, u32::min(max_version, VERSION_MAX))))
} else {
    Ok((
        Self {
            version,
            max_identifier_size,
            binary,
        },
        cursor,
    ))
}
```

Apply the same fix to `VersionedCursor::new()` which uses the same validation logic.

## Proof of Concept

**Reproduction Steps:**

1. Create a test script and serialize it with an unsupported version:

```rust
use move_binary_format::file_format::basic_test_script;
use move_binary_format::file_format_common::{VERSION_1, VERSION_MIN};
use move_binary_format::CompiledScript;

#[test]
fn test_old_version_accepted() {
    let script = basic_test_script();
    
    // Serialize with VERSION_1 (below VERSION_MIN = 5)
    let mut bytecode_v1 = vec![];
    script.serialize_for_version(Some(VERSION_1), &mut bytecode_v1).unwrap();
    
    // This should FAIL but currently SUCCEEDS
    let result = CompiledScript::deserialize_with_config(
        &bytecode_v1,
        &DeserializerConfig::new(VERSION_MIN, IDENTIFIER_SIZE_MAX)
    );
    
    // Expected: Err with UNKNOWN_VERSION
    // Actual: Ok (vulnerability)
    assert!(result.is_ok()); // This assertion passes, demonstrating the bug
}
```

2. The test demonstrates that a VERSION_1 script is accepted even though VERSION_MIN = 5, violating the minimum version constraint.

3. To verify the security impact, examine the different verification paths taken for old vs. new versions in the script signature verifier.

**Expected Behavior**: Deserialization should reject the VERSION_1 script with `StatusCode::UNKNOWN_VERSION`.

**Actual Behavior**: The script is accepted and deserialized successfully, bypassing the VERSION_MIN constraint.

## Notes

The vulnerability exists in the Move binary format library shared across Move implementations. The documentation explicitly states versions below VERSION_5 are deprecated: [8](#0-7) 

The fix requires coordination to ensure the lower bound check doesn't break any legitimate use cases, though by definition, versions below VERSION_MIN should not be in production use.

### Citations

**File:** third_party/move/move-binary-format/src/file_format_common.rs (L519-537)
```rust
/// Version 2: changes compared with version 1
///  + function visibility stored in separate byte before the flags byte
///  + the flags byte now contains only the is_native information (at bit 0x2)
///  + new visibility modifiers for "friend" and "script" functions
///  + friend list for modules
pub const VERSION_2: u32 = 2;

/// Version 3: changes compared with version 2
///  + phantom type parameters
pub const VERSION_3: u32 = 3;

/// Version 4: changes compared with version 3
///  + bytecode for vector operations
pub const VERSION_4: u32 = 4;

/// Version 5: changes compared with version 4
///  +/- script and public(script) verification is now adapter specific
///  + metadata
pub const VERSION_5: u32 = 5;
```

**File:** third_party/move/move-binary-format/src/file_format_common.rs (L562-562)
```rust
pub const VERSION_MIN: u32 = VERSION_5;
```

**File:** third_party/move/move-binary-format/src/file_format_common.rs (L617-619)
```rust
            if version == 0 || version > u32::min(max_version, VERSION_MAX) {
                Err(PartialVMError::new(StatusCode::UNKNOWN_VERSION)
                    .with_message(format!("bytecode version {} unsupported", version)))
```

**File:** third_party/move/move-binary-format/src/serializer.rs (L261-271)
```rust
fn validate_version(version: u32) -> Result<()> {
    if !(VERSION_MIN..=VERSION_MAX).contains(&version) {
        bail!(
            "The requested bytecode version {} is not supported. Only {} to {} are.",
            version,
            VERSION_MIN,
            VERSION_MAX
        )
    } else {
        Ok(())
    }
```

**File:** third_party/move/move-bytecode-verifier/src/script_signature.rs (L40-42)
```rust
    if script.version >= VERSION_5 {
        return Ok(());
    }
```

**File:** third_party/move/move-bytecode-verifier/src/script_signature.rs (L162-172)
```rust
    let all_args_have_valid_type = if resolver.version() <= VERSION_1 {
        parameters
            .iter()
            .skip_while(|typ| matches!(typ, S::Reference(inner) if matches!(&**inner, S::Signer)))
            .all(|typ| typ.is_valid_for_constant())
    } else {
        parameters
            .iter()
            .skip_while(|typ| matches!(typ, S::Signer))
            .all(|typ| typ.is_valid_for_constant())
    };
```

**File:** third_party/move/move-vm/runtime/src/storage/loader/eager.rs (L97-103)
```rust
                let deserialized_script = self
                    .runtime_environment()
                    .deserialize_into_script(serialized_script)?;
                self.module_storage
                    .insert_deserialized_script(hash, deserialized_script)
            },
        })
```

**File:** third_party/move/move-vm/integration-tests/src/tests/binary_format_version.rs (L75-107)
```rust
fn test_run_script_with_custom_max_binary_format_version() {
    let s = basic_test_script();

    let new_version = VERSION_MAX;
    let mut b_new = vec![];
    s.serialize_for_version(Some(new_version), &mut b_new)
        .unwrap();

    let old_version = new_version - 1;
    let mut b_old = vec![];
    s.serialize_for_version(Some(old_version), &mut b_old)
        .unwrap();

    // Should accept both modules with the default settings.
    {
        let storage = initialize_storage_with_binary_format_version(new_version);
        let result_new = execute_script_for_test(&storage, &b_new, &[], vec![]);
        let result_old = execute_script_for_test(&storage, &b_old, &[], vec![]);
        assert!(result_new.is_ok() && result_old.is_ok());
    }

    // Should reject the module with newer version with max binary format version being set to the
    // smaller one.
    {
        let storage = initialize_storage_with_binary_format_version(old_version);
        let status_new = execute_script_for_test(&storage, &b_new, &[], vec![])
            .unwrap_err()
            .major_status();
        assert_eq!(status_new, StatusCode::CODE_DESERIALIZATION_ERROR);

        let result_old = execute_script_for_test(&storage, &b_old, &[], vec![]);
        assert_ok!(result_old);
    }
```
