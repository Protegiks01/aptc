# Audit Report

## Title
Indexer Stale Data Vulnerability: Silent Failure When Processing Inactive Share Deletions

## Summary
The indexer's `get_inactive_share_from_delete_table_item` function contains inconsistent error handling that silently skips deletion operations when database lookups fail, leading to persistent stale data showing delegators have inactive shares they no longer possess on-chain.

## Finding Description

The indexer processes delegation pool inactive share transactions through a two-layer table mapping system. When a delegator withdraws inactive shares (generating a `DeleteTableItem`), the indexer must look up the staking pool address to update the delegator's balance to zero. [1](#0-0) 

The vulnerability exists in lines 210-221 where the database fallback query is wrapped in error-swallowing logic. When `get_staking_pool_from_inactive_share_handle` fails, instead of propagating the error (as done in the write case), it logs a message and returns `Ok(None)`, causing the deletion to be silently skipped.

This contrasts with the write path: [2](#0-1) 

In lines 126-129, the write case properly propagates errors using `.context()` and the `?` operator, causing the indexer to fail-fast rather than continue with stale data.

Additionally, line 235 contains a secondary bug where `parent_table_handle` is incorrectly set to `table_handle` instead of `inactive_pool_handle`, inconsistent with line 159 in the write case. [3](#0-2) 

**Triggering Scenarios:**
1. Indexer restarts with transaction gaps, processing deletions before their corresponding creation records are indexed
2. Database corruption or loss of historical entries  
3. Race conditions in batch processing where T1 creates an inactive pool and T2 deletes from it in different batches
4. Table handle mapping missing from database due to failed prior transactions [4](#0-3) 

The database lookup retries multiple times but ultimately fails if no matching `parent_table_handle` entry exists.

## Impact Explanation

**Severity: Medium** per Aptos bug bounty criteria - "State inconsistencies requiring intervention"

**Impact:**
- Indexer database shows delegators possess inactive shares that were withdrawn on-chain
- API queries return incorrect balances, misleading users and applications
- Downstream services (wallets, explorers, analytics) display false staking positions
- Requires manual database backfill or reindexing to correct
- Does not affect actual blockchain state or validator operations

This breaks the **State Consistency** invariant for the indexer layer, though the blockchain itself remains consistent.

## Likelihood Explanation

**Likelihood: Medium-High**

The error message "You probably should backfill db" indicates this is a known operational scenario that developers anticipated. This can occur:

- During normal indexer operations after crashes/restarts
- In high-throughput scenarios with batch processing race conditions  
- When indexer lags behind blockchain tip and processes transactions out of order
- After database maintenance or partial data recovery

While not directly exploitable by external attackers (they cannot control table handles or database state), this will naturally occur during operational disruptions, making it a reliability issue rather than a targeted attack vector.

## Recommendation

**Fix 1: Propagate errors consistently** [5](#0-4) 

Change lines 209-224 to propagate errors like the write case:

```rust
let pool_address = match inactive_pool_to_staking_pool
    .get(&inactive_pool_handle)
    .map(|metadata| metadata.staking_pool_address.clone())
{
    Some(pool_address) => pool_address,
    None => {
        Self::get_staking_pool_from_inactive_share_handle(conn, &inactive_pool_handle)
            .context(format!(
                "Failed to get staking pool address from inactive share handle {}, txn version {}",
                inactive_pool_handle, txn_version
            ))?
    },
};
```

**Fix 2: Correct parent_table_handle**

Change line 235 from `parent_table_handle: table_handle` to `parent_table_handle: inactive_pool_handle` for consistency with line 159.

## Proof of Concept

This requires an indexer environment setup:

```rust
// Scenario: Process deletion before creation is committed
// 1. Start indexer processing batch of transactions
// 2. Transaction T1 creates inactive shares (not yet in DB)
// 3. Transaction T2 deletes those shares (in same or next batch)
// 4. When processing T2's DeleteTableItem:
//    - inactive_pool_to_staking_pool doesn't have the mapping (T1 not processed)
//    - Database query fails (T1 not committed)
//    - Returns Ok(None), skipping deletion
// 5. Later T1 gets committed, showing shares exist
// 6. Database permanently shows stale data

// To reproduce:
// 1. Setup indexer with delegation pool transactions
// 2. Clear database entries for specific inactive_table_handle
// 3. Send withdrawal transaction for that pool
// 4. Observe: deletion silently fails with error log
// 5. Query current_delegator_balances - shows non-zero shares
// 6. Query on-chain state - shows zero shares (correct)
```

**Notes**

This is a **data consistency issue** in the indexer, not a consensus or blockchain vulnerability. The actual on-chain state remains correct and secure. However, it violates the indexer's guarantee of accurately reflecting on-chain state, requiring operational intervention to fix. The inconsistent error handling between write and delete operations creates a reliability gap where deletions can be silently lost.

### Citations

**File:** crates/indexer/src/models/stake_models/delegator_balances.rs (L107-164)
```rust
    pub fn get_inactive_share_from_write_table_item(
        write_table_item: &APIWriteTableItem,
        txn_version: i64,
        inactive_pool_to_staking_pool: &ShareToStakingPoolMapping,
        inactive_share_to_pool: &ShareToPoolMapping,
        conn: &mut PgPoolConnection,
    ) -> anyhow::Result<Option<Self>> {
        let table_handle = standardize_address(&write_table_item.handle.to_string());
        // The mapping will tell us if the table item belongs to an inactive pool
        if let Some(pool_balance) = inactive_share_to_pool.get(&table_handle) {
            // If it is, we need to get the inactive staking pool handle and use it to look up the staking pool
            let inactive_pool_handle = pool_balance.parent_table_handle.clone();

            let pool_address = match inactive_pool_to_staking_pool
                .get(&inactive_pool_handle)
                .map(|metadata| metadata.staking_pool_address.clone())
            {
                Some(pool_address) => pool_address,
                None => {
                    Self::get_staking_pool_from_inactive_share_handle(conn, &inactive_pool_handle)
                        .context(format!("Failed to get staking pool address from inactive share handle {}, txn version {}",
                        inactive_pool_handle, txn_version
                    ))?
                },
            };
            let delegator_address = standardize_address(&write_table_item.key.to_string());
            let data = write_table_item.data.as_ref().unwrap_or_else(|| {
                panic!(
                    "This table item should be an active share item, table_item {:?}, version {}",
                    write_table_item, txn_version
                )
            });
            let shares = data
                .value
                .as_str()
                .map(|s| s.parse::<BigDecimal>())
                .context(format!(
                    "value is not a string: {:?}, table_item {:?}, version {}",
                    data.value, write_table_item, txn_version
                ))?
                .context(format!(
                    "cannot parse string as u64: {:?}, version {}",
                    data.value, txn_version
                ))?;
            let shares = shares / &pool_balance.scaling_factor;
            Ok(Some(Self {
                delegator_address,
                pool_address,
                pool_type: "inactive_shares".to_string(),
                table_handle: table_handle.clone(),
                last_transaction_version: txn_version,
                shares,
                parent_table_handle: inactive_pool_handle,
            }))
        } else {
            Ok(None)
        }
    }
```

**File:** crates/indexer/src/models/stake_models/delegator_balances.rs (L191-239)
```rust
    pub fn get_inactive_share_from_delete_table_item(
        delete_table_item: &APIDeleteTableItem,
        txn_version: i64,
        inactive_pool_to_staking_pool: &ShareToStakingPoolMapping,
        inactive_share_to_pool: &ShareToPoolMapping,
        conn: &mut PgPoolConnection,
    ) -> anyhow::Result<Option<Self>> {
        let table_handle = standardize_address(&delete_table_item.handle.to_string());
        // The mapping will tell us if the table item belongs to an inactive pool
        if let Some(pool_balance) = inactive_share_to_pool.get(&table_handle) {
            // If it is, we need to get the inactive staking pool handle and use it to look up the staking pool
            let inactive_pool_handle = pool_balance.parent_table_handle.clone();

            let pool_address = match inactive_pool_to_staking_pool
                .get(&inactive_pool_handle)
                .map(|metadata| metadata.staking_pool_address.clone())
            {
                Some(pool_address) => pool_address,
                None => {
                    match Self::get_staking_pool_from_inactive_share_handle(
                        conn,
                        &inactive_pool_handle,
                    ) {
                        Ok(pool) => pool,
                        Err(_) => {
                            aptos_logger::error!(
                                transaction_version = txn_version,
                                lookup_key = &inactive_pool_handle,
                                "Failed to get staking pool address from inactive share handle. You probably should backfill db.",
                            );
                            return Ok(None);
                        },
                    }
                },
            };
            let delegator_address = standardize_address(&delete_table_item.key.to_string());

            return Ok(Some(Self {
                delegator_address,
                pool_address,
                pool_type: "inactive_shares".to_string(),
                table_handle: table_handle.clone(),
                last_transaction_version: txn_version,
                shares: BigDecimal::zero(),
                parent_table_handle: table_handle,
            }));
        }
        Ok(None)
    }
```

**File:** crates/indexer/src/models/stake_models/delegator_balances.rs (L298-315)
```rust
    pub fn get_staking_pool_from_inactive_share_handle(
        conn: &mut PgPoolConnection,
        table_handle: &str,
    ) -> anyhow::Result<String> {
        let mut retried = 0;
        while retried < QUERY_RETRIES {
            retried += 1;
            match CurrentDelegatorBalanceQuery::get_by_inactive_share_handle(conn, table_handle) {
                Ok(current_delegator_balance) => return Ok(current_delegator_balance.pool_address),
                Err(_) => {
                    std::thread::sleep(std::time::Duration::from_millis(QUERY_RETRY_DELAY_MS));
                },
            }
        }
        Err(anyhow::anyhow!(
            "Failed to get staking pool address from inactive share handle"
        ))
    }
```
