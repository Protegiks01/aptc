# Audit Report

## Title
Event V2-to-V1 Translation Cache Poisoning via Incorrect State Version Lookups

## Summary
The event translation system permanently stores incorrect V1 event translations in the database when the internal indexer processes historical transactions while reading state from the latest version instead of the historical transaction version. This causes persistent data corruption affecting all users querying translated events.

## Finding Description

The `EventV2TranslationEngine` incorrectly uses `latest_state_checkpoint_view()` when translating V2 events to V1 format, reading the current blockchain state instead of the historical state at the transaction's version. [1](#0-0) 

When the internal indexer processes transactions asynchronously (catching up from older versions), it translates events using the latest state to determine event keys and sequence numbers: [2](#0-1) 

These incorrectly translated events are permanently stored in `TranslatedV1EventSchema`: [3](#0-2) 

**Attack Scenario:**

1. User A has a `CoinStore<AptosCoin>` resource at address `0xA` at transaction version 1000
2. Transaction at version 1000 emits a `CoinDeposit` V2 event
3. At version 1000, the CoinStore has deposit event handle with key `K1` and counter 50
4. At version 5000, user A rotates their account or the resource structure changes, resulting in deposit event handle with key `K2` and counter 100
5. The internal indexer processes version 1000 while the main database is at version 5000+
6. The translator reads CoinStore from version 5000 (latest state) and extracts key `K2` and sequence number 100
7. The translated V1 event is stored with incorrect key `K2` and sequence `100` instead of correct `K1` and `50`
8. All users querying events at version 1000 receive permanently corrupted data

The vulnerability exists because the indexer service runs asynchronously and can lag behind the main database: [4](#0-3) 

The correct implementation exists (`state_view_at_version()`) but is not used: [5](#0-4) 

## Impact Explanation

**Medium Severity** - This vulnerability causes state inconsistencies requiring intervention:

1. **Persistent Data Corruption**: Incorrectly translated events are permanently stored in the database with no automatic detection or correction mechanism
2. **Cross-User Impact**: All users (not just the attacker) receive incorrect event data when querying affected transaction versions
3. **Historical Data Integrity**: Applications relying on event history (analytics, explorers, wallets) receive corrupted data
4. **No Consensus Impact**: Does not affect consensus directly as this only impacts the indexer, not the canonical blockchain state

This meets the Medium severity criteria: "State inconsistencies requiring intervention" as the indexed data becomes permanently inconsistent with the actual blockchain state.

## Likelihood Explanation

**High Likelihood** - This vulnerability occurs naturally under normal operating conditions:

1. **Common Scenario**: The internal indexer regularly catches up after node restarts, fast sync, or falling behind
2. **Legitimate Resource Changes**: Users legitimately rotate accounts, modify resources, or upgrade contracts between transaction versions
3. **No Malicious Intent Required**: The bug manifests without any deliberate attack, purely from the timing between indexing and resource state changes
4. **Affects All Events**: Any V2 event type that relies on reading on-chain resources for translation is vulnerable (CoinDeposit, CoinWithdraw, TokenMutation, etc.)

The vulnerability triggers whenever:
- Indexer processes old transactions (version V)
- Resources referenced in those events have changed between V and current version L
- No validation exists to detect the mismatch

## Recommendation

Modify `EventV2TranslationEngine` to accept and use the transaction version when translating events. The translator should read state at the specific transaction version, not the latest version.

**Fix for `event_v2_translator.rs`:**

Modify the `get_state_value_bytes_for_resource` method to accept a version parameter:

```rust
pub fn get_state_value_bytes_for_resource(
    &self,
    address: &AccountAddress,
    struct_tag: &StructTag,
    version: Version,  // Add version parameter
) -> Result<Option<Bytes>> {
    let state_view = self
        .main_db_reader
        .state_view_at_version(Some(version))?;  // Use versioned state view
    let state_key = StateKey::resource(address, struct_tag)?;
    let maybe_state_value = state_view.get_state_value(&state_key)?;
    Ok(maybe_state_value.map(|state_value| state_value.bytes().clone()))
}
```

Similarly update `get_state_value_bytes_for_object_group_resource` and all translator implementations to pass the transaction version.

**Fix for `db_indexer.rs`:**

Pass the transaction version to the translator:

```rust
if let Some(translated_v1_event) =
    self.translate_event_v2_to_v1_at_version(v2, version).map_err(|e| {
        anyhow::anyhow!(
            "Failed to translate event: {:?}. Error: {}",
            v2,
            e
        )
    })?
```

Add a new method `translate_event_v2_to_v1_at_version()` that passes the version through the translation chain.

## Proof of Concept

```rust
// Rust test demonstrating the vulnerability
#[cfg(test)]
mod tests {
    use super::*;
    
    #[tokio::test]
    async fn test_event_translation_cache_poisoning() {
        // 1. Setup: Create account with CoinStore at version 1000
        let account = AccountAddress::random();
        let mut db = MockDbReader::new();
        
        // At version 1000: CoinStore with event handle key K1
        let coin_store_v1000 = create_coin_store_with_key(KEY_1);
        db.insert_state_at_version(1000, account, coin_store_v1000);
        
        // At version 5000: CoinStore with event handle key K2 (after account rotation)
        let coin_store_v5000 = create_coin_store_with_key(KEY_2);
        db.insert_state_at_version(5000, account, coin_store_v5000);
        
        // 2. Create V2 CoinDeposit event at version 1000
        let v2_event = create_coin_deposit_event(account, 100);
        
        // 3. Set current version to 5000 (indexer catching up)
        db.set_latest_version(5000);
        
        // 4. Translate event at version 1000 using current implementation
        let translator = EventV2TranslationEngine::new(Arc::new(db), Arc::new(DB::new()));
        let translated = translator.translate_event_v2_to_v1(&v2_event).unwrap();
        
        // 5. Verify the bug: translation used KEY_2 from version 5000
        // instead of KEY_1 from version 1000
        assert_eq!(translated.key(), &KEY_2); // BUG: Wrong key!
        assert_ne!(translated.key(), &KEY_1); // Should have been KEY_1
        
        // 6. This incorrect translation would be stored permanently in database
        // affecting all users querying events at version 1000
    }
}
```

The test demonstrates that when the indexer processes a transaction from version 1000 while the database is at version 5000, the translation reads state from version 5000, producing an incorrect translation that gets permanently cached.

## Notes

This vulnerability represents a fundamental design flaw in the event translation architecture. The system was designed to cache translations for performance, but failed to ensure that translations use the correct historical state. This violates the State Consistency invariant as indexed state becomes inconsistent with canonical blockchain state.

The fix requires passing version context through the entire translation pipeline and using versioned state views. All existing incorrect translations in deployed nodes would need to be recomputed after the fix is deployed.

### Citations

**File:** storage/indexer/src/event_v2_translator.rs (L202-214)
```rust
    pub fn get_state_value_bytes_for_resource(
        &self,
        address: &AccountAddress,
        struct_tag: &StructTag,
    ) -> Result<Option<Bytes>> {
        let state_view = self
            .main_db_reader
            .latest_state_checkpoint_view()
            .expect("Failed to get state view");
        let state_key = StateKey::resource(address, struct_tag)?;
        let maybe_state_value = state_view.get_state_value(&state_key)?;
        Ok(maybe_state_value.map(|state_value| state_value.bytes().clone()))
    }
```

**File:** storage/indexer/src/db_indexer.rs (L294-302)
```rust
    pub fn get_translated_v1_event_by_version_and_index(
        &self,
        version: Version,
        index: u64,
    ) -> Result<ContractEventV1> {
        self.db
            .get::<TranslatedV1EventSchema>(&(version, index))?
            .ok_or_else(|| AptosDbError::NotFound(format!("Event {} of Txn {}", index, version)))
    }
```

**File:** storage/indexer/src/db_indexer.rs (L448-483)
```rust
                    if self.indexer_db.event_v2_translation_enabled() {
                        if let ContractEvent::V2(v2) = event {
                            if let Some(translated_v1_event) =
                                self.translate_event_v2_to_v1(v2).map_err(|e| {
                                    anyhow::anyhow!(
                                        "Failed to translate event: {:?}. Error: {}",
                                        v2,
                                        e
                                    )
                                })?
                            {
                                let key = *translated_v1_event.key();
                                let sequence_number = translated_v1_event.sequence_number();
                                self.event_v2_translation_engine
                                    .cache_sequence_number(&key, sequence_number);
                                event_keys.insert(key);
                                batch
                                    .put::<EventByKeySchema>(
                                        &(key, sequence_number),
                                        &(version, idx as u64),
                                    )
                                    .expect("Failed to put events by key to a batch");
                                batch
                                    .put::<EventByVersionSchema>(
                                        &(key, version, sequence_number),
                                        &(idx as u64),
                                    )
                                    .expect("Failed to put events by version to a batch");
                                batch
                                    .put::<TranslatedV1EventSchema>(
                                        &(version, idx as u64),
                                        &translated_v1_event,
                                    )
                                    .expect("Failed to put translated v1 events to a batch");
                            }
                        }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-table-info/src/internal_indexer_db_service.rs (L167-199)
```rust
    pub async fn run(&mut self, node_config: &NodeConfig) -> Result<()> {
        let mut start_version = self.get_start_version(node_config).await?;
        let mut target_version = self.db_indexer.main_db_reader.ensure_synced_version()?;
        let mut step_timer = std::time::Instant::now();

        loop {
            if target_version <= start_version {
                match self.update_receiver.changed().await {
                    Ok(_) => {
                        (step_timer, target_version) = *self.update_receiver.borrow();
                    },
                    Err(e) => {
                        panic!("Failed to get update from update_receiver: {}", e);
                    },
                }
            }
            let next_version = self.db_indexer.process(start_version, target_version)?;
            INDEXER_DB_LATENCY.set(step_timer.elapsed().as_millis() as i64);
            log_grpc_step(
                SERVICE_TYPE,
                IndexerGrpcStep::InternalIndexerDBProcessed,
                Some(start_version as i64),
                Some(next_version as i64),
                None,
                None,
                Some(step_timer.elapsed().as_secs_f64()),
                None,
                Some((next_version - start_version) as i64),
                None,
            );
            start_version = next_version;
        }
    }
```

**File:** storage/storage-interface/src/state_store/state_view/db_state_view.rs (L93-105)
```rust
pub trait DbStateViewAtVersion {
    fn state_view_at_version(&self, version: Option<Version>) -> StateViewResult<DbStateView>;
}

impl DbStateViewAtVersion for Arc<dyn DbReader> {
    fn state_view_at_version(&self, version: Option<Version>) -> StateViewResult<DbStateView> {
        Ok(DbStateView {
            db: self.clone(),
            version,
            maybe_verify_against_state_root_hash: None,
        })
    }
}
```
