# Audit Report

## Title
Indexer Main Loop CPU Spinning on Empty Batches

## Summary
The indexer's main processing loop in `runtime.rs` continuously spins without sleeping when all transaction batches are empty, causing unnecessary CPU consumption and database connection attempts when the indexer has caught up with the blockchain tip.

## Finding Description

The indexer architecture consists of two asynchronous components:

1. **Background Fetcher Task** (`fetcher.rs`): Runs independently, fetches transactions from storage, and places them in a channel. When caught up, it properly sleeps before retrying. [1](#0-0) 

2. **Main Processing Loop** (`runtime.rs`): Spawns tasks that consume from the channel and process transactions. [2](#0-1) 

The vulnerability occurs in the main processing loop. When the indexer has caught up with the chain and the transaction channel is empty:

**Step 1**: The loop spawns `processor_tasks` concurrent tasks calling `process_next_batch()`. [3](#0-2) 

**Step 2**: Each task calls `fetch_next_batch()`, which performs a **non-blocking** `try_next()` on the empty channel, immediately returning an empty vector. [4](#0-3) 

**Step 3**: `process_next_batch()` detects the empty batch and returns `(0, None)` immediately without delay. [5](#0-4) 

**Step 4**: The main loop processes all `None` results and continues to the next iteration with **no sleep or backoff mechanism**. [6](#0-5) 

**Step 5**: Additionally, when all batches are empty, `batch_end_version` remains at its initial value of 0, causing an unnecessary database update call. [7](#0-6) 

This creates a tight busy-wait loop that wastes CPU cycles continuously when the indexer is caught up, despite the background fetcher having proper sleep mechanisms.

## Impact Explanation

This qualifies as **Low Severity** per the Aptos bug bounty program under "Non-critical implementation bugs". 

The issue does NOT cause:
- Consensus violations or safety breaks
- Loss of funds or state corruption  
- Validator node disruption (indexers run separately from validators)
- Network availability issues
- Data loss or processing errors

The issue DOES cause:
- Unnecessary CPU consumption (busy-wait at near 100% when caught up)
- Wasteful database connection attempts with version 0
- Inefficient resource utilization in indexer infrastructure

This is a performance/efficiency bug rather than a security vulnerability. It does not meet the validation criteria for reportable security issues (Critical/High/Medium severity with demonstrated security harm).

## Likelihood Explanation

This occurs **automatically and continuously** whenever an indexer catches up to the current blockchain tip, which is the normal steady-state operation. Frequency depends on:
- Block production rate vs indexer processing speed
- During quiet periods with few transactions, the indexer will frequently be caught up
- Multiple processor tasks amplify the spinning (default configuration spawns multiple concurrent tasks)

## Recommendation

Add a sleep delay in the main loop when all batches return empty:

```rust
// After line 249 in runtime.rs
if num_res == 0 {
    // All batches were empty, indexer is caught up
    tokio::time::sleep(Duration::from_millis(100)).await;
    continue;
}
```

Additionally, skip database update when no transactions were processed:

```rust
// Before line 251 in runtime.rs  
if batch_end_version > 0 {
    tailer.update_last_processed_version(&processor_name, batch_end_version)
        .unwrap_or_else(|e| { /* error handling */ });
}
```

## Proof of Concept

```rust
// Run the indexer and observe CPU usage when caught up to chain tip:
// 1. Start a local testnet with slow block production (1 block/10 seconds)
// 2. Start the indexer with default config
// 3. Wait for indexer to catch up 
// 4. Observe CPU usage remains high (80-100%) despite no new transactions
// 5. Check logs showing continuous empty batch processing without delays

// Verify via system monitoring:
// top -p $(pgrep -f "indexer")
// Expected: CPU usage near 100% when caught up
// After fix: CPU usage drops to near 0% when caught up
```

---

**Notes**: While this is a confirmed implementation bug that causes resource waste, it does not meet the strict validation criteria for security vulnerabilities requiring "clear security harm" to consensus, funds, or availability. It is correctly classified as Low severity per the original security question marking.

### Citations

**File:** crates/indexer/src/indexer/fetcher.rs (L54-77)
```rust
    async fn ensure_highest_known_version(&mut self) {
        let mut empty_loops = 0;
        while self.highest_known_version == 0 || self.current_version > self.highest_known_version {
            if empty_loops > 0 {
                tokio::time::sleep(self.options.starting_retry_time).await;
            }
            empty_loops += 1;
            if let Err(err) = self.set_highest_known_version() {
                error!(
                    error = format!("{:?}", err),
                    "Failed to set highest known version"
                );
                continue;
            } else {
                sample!(
                    SampleRate::Frequency(10),
                    aptos_logger::info!(
                        highest_known_version = self.highest_known_version,
                        "Found new highest known version",
                    )
                );
            }
        }
    }
```

**File:** crates/indexer/src/indexer/fetcher.rs (L438-449)
```rust
    async fn fetch_next_batch(&mut self) -> Vec<Transaction> {
        // try_next is nonblocking unlike next. It'll try to fetch the next one and return immediately.
        match self.transaction_receiver.try_next() {
            Ok(Some(transactions)) => transactions,
            Ok(None) => {
                // We never close the channel, so this should never happen
                panic!("Transaction fetcher channel closed");
            },
            // The error here is when the channel is empty which we definitely expect.
            Err(_) => vec![],
        }
    }
```

**File:** crates/indexer/src/runtime.rs (L209-280)
```rust
    loop {
        let mut tasks = vec![];
        for _ in 0..processor_tasks {
            let other_tailer = tailer.clone();
            let task = tokio::spawn(async move { other_tailer.process_next_batch().await });
            tasks.push(task);
        }
        let batches = match futures::future::try_join_all(tasks).await {
            Ok(res) => res,
            Err(err) => panic!("Error processing transaction batches: {:?}", err),
        };

        let mut batch_start_version = u64::MAX;
        let mut batch_end_version = 0;
        let mut num_res = 0;

        for (num_txn, res) in batches {
            let processed_result: ProcessingResult = match res {
                // When the batch is empty b/c we're caught up, continue to next batch
                None => continue,
                Some(Ok(res)) => res,
                Some(Err(tpe)) => {
                    let (err, start_version, end_version, _) = tpe.inner();
                    error!(
                        processor_name = processor_name,
                        start_version = start_version,
                        end_version = end_version,
                        error =? err,
                        "Error processing batch!"
                    );
                    panic!(
                        "Error in '{}' while processing batch: {:?}",
                        processor_name, err
                    );
                },
            };
            batch_start_version =
                std::cmp::min(batch_start_version, processed_result.start_version);
            batch_end_version = std::cmp::max(batch_end_version, processed_result.end_version);
            num_res += num_txn;
        }

        tailer
            .update_last_processed_version(&processor_name, batch_end_version)
            .unwrap_or_else(|e| {
                error!(
                    processor_name = processor_name,
                    end_version = batch_end_version,
                    error = format!("{:?}", e),
                    "Failed to update last processed version!"
                );
                panic!("Failed to update last processed version: {:?}", e);
            });

        ma.tick_now(num_res);

        versions_processed += num_res;
        if emit_every != 0 {
            let new_base: u64 = versions_processed / emit_every;
            if base != new_base {
                base = new_base;
                info!(
                    processor_name = processor_name,
                    batch_start_version = batch_start_version,
                    batch_end_version = batch_end_version,
                    versions_processed = versions_processed,
                    tps = (ma.avg() * 1000.0) as u64,
                    "Processed batch version"
                );
            }
        }
    }
```

**File:** crates/indexer/src/indexer/tailer.rs (L133-137)
```rust
        let num_txns = transactions.len() as u64;
        // When the batch is empty b/c we're caught up
        if num_txns == 0 {
            return (0, None);
        }
```
