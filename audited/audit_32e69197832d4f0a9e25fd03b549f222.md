# Audit Report

## Title
IP Allowlist Bypasser Enables Unlimited Sybil Account Creation Without Rate Limiting

## Summary
The IP allowlist bypasser in the Aptos faucet allows requests from allowlisted IPs to completely bypass all rate limiting and anti-abuse mechanisms. An attacker with access to an allowlisted IP can create and fund an unlimited number of accounts, enabling Sybil attacks on applications that rely on the faucet for user onboarding.

## Finding Description

The faucet's IP allowlist bypasser is designed to allow certain trusted IPs to skip validation checks. However, the implementation has a critical flaw: it bypasses **all** checkers including rate limiters, and crucially, it also skips the completion step where request tracking would normally occur. [1](#0-0) 

The bypasser simply checks if the source IP is in the allowlist. When this returns true, the request handling flow in the fund endpoint bypasses all security controls: [2](#0-1) 

When any bypasser returns true, the request immediately returns with `bypass=true`, skipping all checkers. The critical impact occurs in two places:

1. **No checker validation**: Rate limiters like `MemoryRatelimitChecker` and `RedisRatelimitChecker` are never executed [3](#0-2) 

2. **No request tracking**: The completion step that records requests in storage is skipped entirely when bypass is true: [4](#0-3) 

This means rate limiters like `MemoryRatelimitChecker` that track requests per IP are never invoked: [5](#0-4) 

**Attack Scenario:**
1. Attacker gains access to an IP on the allowlist (e.g., through compromised CI infrastructure, or if a broad range like an entire cloud provider is allowlisted)
2. Attacker sends thousands of requests to `/fund` endpoint, each with a different `address`, `auth_key`, or `pub_key` parameter
3. Each request bypasses all rate limiting and gets funded up to the configured `maximum_amount_with_bypass` (or `maximum_amount` if not set)
4. No tracking occurs in Redis or memory-based storage
5. Result: Thousands of funded accounts created from a single IP, enabling Sybil attacks

## Impact Explanation

This is a **HIGH severity** vulnerability based on Aptos bug bounty criteria:

1. **Economic Attack**: An attacker can drain significant funds from the faucet by creating unlimited accounts. While the faucet is typically used for test networks, production faucets for airdrops or promotional campaigns could lose substantial funds.

2. **Sybil Attack Enablement**: Applications built on Aptos that use the faucet for user onboarding (common in testnets and early mainnet phases) can be attacked. Each funded account can participate in:
   - Governance voting (if test governance is enabled)
   - Airdrops (one claim per account)
   - Referral programs
   - Beta testing programs with per-account limits
   - Any mechanism that counts unique accounts

3. **Protocol Impact**: While this doesn't directly affect consensus, it undermines the faucet's role as a controlled entry point for new users, which is critical infrastructure for ecosystem growth.

The vulnerability maps to "Significant protocol violations" under High Severity ($50,000 category) as it breaks the fundamental security assumption that rate limiting protects against abuse.

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH**

The attack requires:
- Access to an IP on the allowlist
- Basic HTTP request capabilities

Factors increasing likelihood:
1. **Broad Allowlists**: Organizations often allowlist entire IP ranges for convenience (e.g., `/24` CIDR blocks for CI/CD infrastructure)
2. **Cloud Infrastructure**: If cloud provider IPs are allowlisted, attackers could spawn instances in those ranges
3. **Compromised Infrastructure**: CI/CD systems, developer machines, or other trusted infrastructure could be compromised
4. **Configuration Files**: The test configuration shows allowlists are file-based and may be broadly configured [6](#0-5) 

Factors decreasing likelihood:
1. Allowlists are typically restricted to known, controlled IPs
2. Production deployments may not use IP allowlist bypassers at all

However, even if used only in test/staging environments, Sybil attacks can still cause significant harm to testing programs, airdrops, and ecosystem initiatives.

## Recommendation

**Option 1: Add Separate Rate Limiting for Bypassed Requests (Recommended)**

Implement a separate rate limiting mechanism specifically for bypassed requests. This maintains the convenience of allowlisting while preventing abuse:

```rust
// In bypasser/ip_allowlist.rs
pub struct IpAllowlistBypasser {
    manager: IpRangeManager,
    // Add rate limiting for bypassed requests
    bypassed_requests_limiter: Mutex<HashMap<IpAddr, (u32, u64)>>, // (count, day)
    max_bypassed_requests_per_day: u32,
}

impl IpAllowlistBypasser {
    pub fn new(config: IpRangeManagerConfig, max_bypassed_requests_per_day: u32) -> Result<Self> {
        Ok(Self {
            manager: IpRangeManager::new(config)?,
            bypassed_requests_limiter: Mutex::new(HashMap::new()),
            max_bypassed_requests_per_day,
        })
    }
}

#[async_trait]
impl BypasserTrait for IpAllowlistBypasser {
    async fn request_can_bypass(&self, data: CheckerData) -> Result<bool> {
        if !self.manager.contains_ip(&data.source_ip) {
            return Ok(false);
        }
        
        // Check rate limit for this allowlisted IP
        let current_day = days_since_tap_epoch(get_current_time_secs());
        let mut limiter = self.bypassed_requests_limiter.lock().await;
        let entry = limiter.entry(data.source_ip).or_insert((0, current_day));
        
        // Reset counter if new day
        if entry.1 < current_day {
            *entry = (0, current_day);
        }
        
        if entry.0 >= self.max_bypassed_requests_per_day {
            return Ok(false); // Reject if limit exceeded
        }
        
        entry.0 += 1;
        Ok(true)
    }
}
```

**Option 2: Selective Bypassing**

Modify the bypasser to only skip certain checkers (e.g., CAPTCHA) while still enforcing rate limits:

```rust
// Add a method to BypasserTrait
pub trait BypasserTrait {
    async fn request_can_bypass(&self, data: CheckerData) -> Result<bool>;
    
    // New method: specify which checkers to skip
    fn checkers_to_skip(&self) -> Vec<CheckerType> {
        vec![] // Default: bypass all if request_can_bypass returns true
    }
}

// Modify fund.rs to respect selective bypassing
// Instead of skipping ALL checkers, only skip those returned by checkers_to_skip()
```

**Option 3: Remove Bypass of Complete Step**

At minimum, always call the complete step even for bypassed requests to ensure tracking:

```rust
// In fund.rs, line 332, change:
if !bypass {
    // complete step
}

// To:
// Always run complete step for tracking, even if bypassed
let complete_data = CompleteData { ... };
for checker in &self.checkers {
    checker.complete(complete_data.clone()).await?;
}
```

## Proof of Concept

```rust
// Rust PoC demonstrating the vulnerability
use std::net::IpAddr;
use std::str::FromStr;

#[tokio::test]
async fn test_ip_allowlist_bypass_sybil_attack() {
    // Setup faucet with IP allowlist bypasser
    let allowlisted_ip = IpAddr::from_str("192.168.1.100").unwrap();
    
    // Write allowlist file
    let allowlist_file = "/tmp/test_allowlist.txt";
    std::fs::write(allowlist_file, "192.168.1.100/32\n").unwrap();
    
    // Configure faucet with IP allowlist and rate limiter
    let config = r#"
    bypasser_configs:
      - type: "IpAllowlist"
        file: "/tmp/test_allowlist.txt"
    checker_configs:
      - type: "MemoryRatelimit"
        max_requests_per_day: 5  # Only 5 requests per day
    funder_config:
      type: "MintFunder"
      maximum_amount: 100000000000
    "#;
    
    // Simulate 100 fund requests from the allowlisted IP
    // Each request targets a different account address
    let mut funded_accounts = vec![];
    for i in 0..100 {
        let receiver_address = format!("0x{:064x}", i);
        
        // Make fund request
        let request = FundRequest {
            amount: Some(100000000000),
            address: Some(receiver_address.clone()),
            auth_key: None,
            pub_key: None,
        };
        
        // Request from allowlisted IP - should bypass rate limiter
        let result = fund_endpoint(request, allowlisted_ip).await;
        
        // Assert: Request succeeds even though we exceeded max_requests_per_day
        assert!(result.is_ok(), "Request {} failed: {:?}", i, result);
        funded_accounts.push(receiver_address);
    }
    
    // Verify: 100 accounts were funded from a single IP
    // despite rate limit of 5 per day
    assert_eq!(funded_accounts.len(), 100);
    println!("✓ Sybil attack successful: Created {} funded accounts from single IP", 
             funded_accounts.len());
    
    // Now try from non-allowlisted IP - should fail after 5 requests
    let normal_ip = IpAddr::from_str("192.168.1.200").unwrap();
    let mut normal_requests = 0;
    for i in 100..110 {
        let request = FundRequest {
            amount: Some(100000000000),
            address: Some(format!("0x{:064x}", i)),
            auth_key: None,
            pub_key: None,
        };
        
        if fund_endpoint(request, normal_ip).await.is_ok() {
            normal_requests += 1;
        }
    }
    
    // Verify: Only 5 requests succeeded from normal IP
    assert_eq!(normal_requests, 5);
    println!("✓ Rate limiting works for non-allowlisted IPs: {} requests succeeded", 
             normal_requests);
}
```

## Notes

**Additional Context:**

1. **Configuration Risk**: The vulnerability is exacerbated by the flexibility of IP range configuration. CIDR notation allows broad ranges to be allowlisted: [7](#0-6) 

2. **Maximum Amount Consideration**: While there is a `maximum_amount_with_bypass` option that can limit the amount per request, this does NOT prevent the Sybil attack - it only limits the funds per account: [8](#0-7) 

3. **Scope Note**: While this vulnerability is in the faucet service (not the core blockchain consensus/execution layer), it still represents a significant security issue for the Aptos ecosystem, as the faucet is critical infrastructure for user onboarding and testing.

### Citations

**File:** crates/aptos-faucet/core/src/bypasser/ip_allowlist.rs (L24-29)
```rust
#[async_trait]
impl BypasserTrait for IpAllowlistBypasser {
    async fn request_can_bypass(&self, data: CheckerData) -> Result<bool> {
        Ok(self.manager.contains_ip(&data.source_ip))
    }
}
```

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L244-259)
```rust
        // See if this request meets the criteria to bypass checkers / storage.
        for bypasser in &self.bypassers {
            if bypasser
                .request_can_bypass(checker_data.clone())
                .await
                .map_err(|e| {
                    AptosTapError::new_with_error_code(e, AptosTapErrorCode::BypasserError)
                })?
            {
                info!(
                    "Allowing request from {} to bypass checks / storage",
                    source_ip
                );
                return Ok((checker_data, true, permit));
            }
        }
```

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L261-279)
```rust
        // Ensure request passes checkers.
        let mut rejection_reasons = Vec::new();
        for checker in &self.checkers {
            rejection_reasons.extend(checker.check(checker_data.clone(), dry_run).await.map_err(
                |e| AptosTapError::new_with_error_code(e, AptosTapErrorCode::CheckerError),
            )?);
            if !rejection_reasons.is_empty() && self.return_rejections_early {
                break;
            }
        }

        if !rejection_reasons.is_empty() {
            return Err(AptosTapError::new(
                format!("Request rejected by {} checkers", rejection_reasons.len()),
                AptosTapErrorCode::Rejected,
            )
            .rejection_reasons(rejection_reasons));
        }

```

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L328-347)
```rust

        // Give all Checkers the chance to run the completion step. We should
        // monitor for failures in these steps because they could lead to an
        // unintended data state.
        if !bypass {
            let response_is_500 = match &fund_result {
                Ok(_) => false,
                Err(e) => e.error_code.status().is_server_error(),
            };
            let complete_data = CompleteData {
                checker_data,
                txn_hashes: txn_hashes.clone(),
                response_is_500,
            };
            for checker in &self.checkers {
                checker.complete(complete_data.clone()).await.map_err(|e| {
                    AptosTapError::new_with_error_code(e, AptosTapErrorCode::CheckerError)
                })?;
            }
        }
```

**File:** crates/aptos-faucet/core/src/checkers/memory_ratelimit.rs (L66-91)
```rust
#[async_trait]
impl CheckerTrait for MemoryRatelimitChecker {
    async fn check(
        &self,
        data: CheckerData,
        dry_run: bool,
    ) -> Result<Vec<RejectionReason>, AptosTapError> {
        self.clear_if_new_day().await;

        let mut ip_to_requests_today = self.ip_to_requests_today.lock().await;

        let requests_today = ip_to_requests_today.get_or_insert_mut(data.source_ip, || 1);
        if *requests_today >= self.max_requests_per_day {
            return Ok(vec![RejectionReason::new(
                format!(
                    "IP {} has exceeded the daily limit of {} requests",
                    data.source_ip, self.max_requests_per_day
                ),
                RejectionReasonCode::UsageLimitExhausted,
            )]);
        } else if !dry_run {
            *requests_today += 1;
        }

        Ok(vec![])
    }
```

**File:** crates/aptos-faucet/configs/testing_bypassers.yaml (L6-10)
```yaml
bypasser_configs:
  - type: "AuthToken"
    file: "/tmp/auth_tokens.txt"
  - type: "IpAllowlist"
    file: "/tmp/ip_allowlist.txt"
```

**File:** crates/aptos-faucet/core/src/common/ip_range_manager.rs (L23-53)
```rust
impl IpRangeManager {
    pub fn new(config: IpRangeManagerConfig) -> Result<Self> {
        let file = File::open(&config.file)
            .with_context(|| format!("Failed to open {}", config.file.to_string_lossy()))?;

        let mut ipv4_list = IpRange::<Ipv4Net>::new();
        let mut ipv6_list = IpRange::<Ipv6Net>::new();
        for line in std::io::BufReader::new(file).lines() {
            let line = line?;
            if line.starts_with('#') || line.starts_with("//") || line.is_empty() {
                continue;
            }
            match line.parse::<Ipv4Net>() {
                Ok(ipv4_net) => {
                    ipv4_list.add(ipv4_net);
                },
                Err(_) => match line.parse::<Ipv6Net>() {
                    Ok(ipv6_net) => {
                        ipv6_list.add(ipv6_net);
                    },
                    Err(_) => {
                        bail!("Failed to parse line as IPv4 or IPv6 range: {}", line);
                    },
                },
            }
        }
        Ok(Self {
            ipv4_list,
            ipv6_list,
        })
    }
```

**File:** crates/aptos-faucet/core/src/funder/common.rs (L176-186)
```rust
    pub fn get_maximum_amount(
        &self,
        // True if a Bypasser let the request bypass the Checkers.
        did_bypass_checkers: bool,
    ) -> Option<u64> {
        match (self.maximum_amount_with_bypass, did_bypass_checkers) {
            (Some(max), true) => Some(max),
            _ => self.maximum_amount,
        }
    }
}
```
