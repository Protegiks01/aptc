# Audit Report

## Title
Mempool Resource Exhaustion via Unbounded Sequence Number Gap Acceptance

## Summary

The mempool accepts transactions with arbitrarily large sequence number gaps without upper bound validation, allowing attackers to exhaust per-account transaction capacity and mempool resources with transactions that will never execute.

## Finding Description

The mempool's `add_txn()` function in `mempool.rs` and the `insert()` function in `transaction_store.rs` validate that incoming transaction sequence numbers are not less than the current account sequence number, but impose **no upper bound** on how far ahead sequence numbers can be. [1](#0-0) [2](#0-1) 

The only capacity check enforced is the per-user transaction count limit (`capacity_per_user`, default 100): [3](#0-2) [4](#0-3) 

**Attack Scenario:**

1. Account A has current sequence number: 5
2. Attacker submits 100 transactions with sequence numbers: [1000000005, 1000000006, ..., 1000000104]
3. All transactions pass mempool validation (they satisfy `txn_seq_num >= account_sequence_number`)
4. Transactions are stored in `AccountTransactions::sequence_number_transactions` (a BTreeMap): [5](#0-4) 

5. All transactions are placed in the `ParkingLotIndex` as "not ready" because of the massive sequence gap: [6](#0-5) 

6. Account A now has 100/100 transactions in mempool and **cannot submit any legitimate transactions**
7. When consensus attempts to execute these parked transactions, they fail during prologue validation with `PROLOGUE_ESEQUENCE_NUMBER_TOO_NEW`: [7](#0-6) 

8. **Critical flaw**: Transactions rejected with `SEQUENCE_NUMBER_TOO_NEW` are **NOT removed from mempool** - they are kept under the assumption they might become ready later: [8](#0-7) 

9. These transactions remain in mempool until TTL expiration (default 600 seconds): [9](#0-8) 

**Broken Invariant:**

This violates the **Resource Limits** invariant: "All operations must respect gas, storage, and computational limits." The mempool accepts and retains transactions that consume resources but can never execute.

## Impact Explanation

**High Severity** per Aptos Bug Bounty criteria:

1. **Per-Account Denial of Service**: Attackers can prevent specific accounts from submitting legitimate transactions by exhausting their mempool quota with non-executable transactions

2. **Mempool Resource Exhaustion**: With sufficient accounts, attackers can fill the global mempool (capacity: 2,000,000 transactions) with parked transactions that consume:
   - Memory for transaction storage
   - CPU for parking lot management
   - Index overhead (estimated per-transaction: `TXN_INDEX_ESTIMATED_BYTES`) [10](#0-9) 

3. **Validator Node Slowdowns**: Managing large numbers of parked transactions impacts mempool operations, garbage collection, and transaction retrieval

4. **No Cost to Attacker**: Transactions never execute, so no gas fees are paid. The only cost is transaction creation and network submission

5. **Network-Wide Impact**: Attack can be replicated across ~20,000 accounts to fill the entire mempool

## Likelihood Explanation

**High Likelihood**:

- **Easy to Execute**: Attacker only needs to craft and submit transactions with large sequence numbers through standard RPC endpoints
- **Low Cost**: No gas fees since transactions don't execute
- **No Special Privileges**: Any user can submit transactions to mempool
- **Difficult to Detect**: Parked transactions appear legitimate until execution attempt
- **Persistent**: Transactions remain for full TTL duration (10 minutes by default)

## Recommendation

Implement a maximum sequence number gap limit during mempool admission. Add validation in both `mempool.rs::add_txn()` and `transaction_store.rs::insert()`:

```rust
const MAX_SEQUENCE_NUMBER_GAP: u64 = 100; // Configurable via MempoolConfig

// In add_txn() and insert(), after existing sequence number validation:
if let ReplayProtector::SequenceNumber(txn_seq_num) = txn.replay_protector() {
    match &account_sequence_number {
        Some(account_sequence_number) => {
            // Existing check
            if txn_seq_num < *account_sequence_number {
                return MempoolStatus::new(MempoolStatusCode::InvalidSeqNumber)
                    .with_message(...);
            }
            
            // NEW: Check for excessive sequence number gap
            if txn_seq_num >= account_sequence_number + MAX_SEQUENCE_NUMBER_GAP {
                return MempoolStatus::new(MempoolStatusCode::InvalidSeqNumber)
                    .with_message(format!(
                        "Sequence number {} too far ahead of current sequence number {}. Maximum gap: {}",
                        txn_seq_num, account_sequence_number, MAX_SEQUENCE_NUMBER_GAP
                    ));
            }
        },
        None => { /* existing error handling */ }
    }
}
```

Add corresponding configuration field:

```rust
// In config/src/config/mempool_config.rs
pub struct MempoolConfig {
    // ... existing fields ...
    /// Maximum allowed gap between transaction sequence number and account sequence number
    pub max_sequence_number_gap: u64,
}

impl Default for MempoolConfig {
    fn default() -> MempoolConfig {
        MempoolConfig {
            // ... existing defaults ...
            max_sequence_number_gap: 100,
        }
    }
}
```

## Proof of Concept

```rust
#[test]
fn test_sequence_number_gap_dos_attack() {
    use aptos_types::transaction::SignedTransaction;
    use aptos_mempool::core_mempool::mempool::Mempool;
    use aptos_config::config::NodeConfig;
    
    let config = NodeConfig::default();
    let mut mempool = Mempool::new(&config);
    
    // Setup: Account with sequence number 5
    let account = AccountAddress::random();
    let account_seq_num = 5u64;
    
    // Attack: Submit 100 transactions with sequence numbers billions ahead
    let mut accepted_count = 0;
    for i in 0..100 {
        let txn_seq_num = 1_000_000_000 + i;
        let txn = create_test_transaction(account, txn_seq_num);
        
        let status = mempool.add_txn(
            txn,
            0, // ranking_score
            Some(account_seq_num),
            TimelineState::NotReady,
            true, // client_submitted
            None, // ready_time_at_sender
            None, // priority
        );
        
        if status.code == MempoolStatusCode::Accepted {
            accepted_count += 1;
        }
    }
    
    // Verify vulnerability: All 100 transactions accepted
    assert_eq!(accepted_count, 100);
    
    // Verify impact: Legitimate transaction at sequence 5 cannot be added
    let legitimate_txn = create_test_transaction(account, account_seq_num);
    let status = mempool.add_txn(
        legitimate_txn,
        0,
        Some(account_seq_num),
        TimelineState::NotReady,
        true,
        None,
        None,
    );
    
    // Account capacity exceeded - legitimate transaction rejected
    assert_eq!(status.code, MempoolStatusCode::TooManyTransactions);
    
    println!("âœ— VULNERABILITY CONFIRMED: Account DoS via sequence number gap exploitation");
}
```

## Notes

This vulnerability represents a critical mempool design flaw where admission validation is insufficient to prevent resource exhaustion attacks. The lack of sequence number gap limits, combined with the policy of retaining `SEQUENCE_NUMBER_TOO_NEW` transactions, creates an exploitable DoS vector that affects both individual accounts and network-wide mempool capacity. The recommended fix should be implemented with careful consideration of legitimate use cases where users may submit multiple future transactions.

### Citations

**File:** mempool/src/core_mempool/mempool.rs (L119-123)
```rust
        if *reason == DiscardedVMStatus::SEQUENCE_NUMBER_TOO_NEW {
            self.log_reject_transaction(sender, replay_protector, counters::COMMIT_IGNORED_LABEL);
            // Do not remove the transaction from mempool
            return;
        }
```

**File:** mempool/src/core_mempool/mempool.rs (L309-330)
```rust
        if let ReplayProtector::SequenceNumber(txn_seq_num) = txn.replay_protector() {
            // don't accept old transactions (e.g. seq is less than account's current seq_number)
            match &account_sequence_number {
                Some(account_sequence_number) => {
                    if txn_seq_num < *account_sequence_number {
                        return MempoolStatus::new(MempoolStatusCode::InvalidSeqNumber)
                            .with_message(format!(
                                "transaction sequence number is {}, current sequence number is  {}",
                                txn_seq_num, account_sequence_number,
                            ));
                    }
                },
                None => {
                    return MempoolStatus::new(MempoolStatusCode::InvalidSeqNumber).with_message(
                        format!(
                            "transaction has sequence number {}, but not sequence number provided for sender's account",
                            txn_seq_num,
                        ),
                    );
                },
            }
        };
```

**File:** mempool/src/core_mempool/transaction_store.rs (L37-40)
```rust
pub const TXN_INDEX_ESTIMATED_BYTES: usize = size_of::<crate::core_mempool::index::OrderedQueueKey>() // priority_index
    + size_of::<crate::core_mempool::index::TTLOrderingKey>() * 2 // expiration_time_index + system_ttl_index
    + (size_of::<u64>() * 3 + size_of::<AccountAddress>()) // timeline_index
    + (size_of::<HashValue>() + size_of::<u64>() + size_of::<AccountAddress>()); // hash_index
```

**File:** mempool/src/core_mempool/transaction_store.rs (L296-308)
```rust
        if let ReplayProtector::SequenceNumber(txn_seq_num) = txn.get_replay_protector() {
            let acc_seq_num = account_sequence_number.expect(
                "Account sequence number is always provided for transactions with sequence number",
            );
            self.clean_committed_transactions_below_account_seq_num(&address, acc_seq_num);
            if txn_seq_num < acc_seq_num {
                return MempoolStatus::new(MempoolStatusCode::InvalidSeqNumber).with_message(
                    format!(
                        "transaction sequence number is {}, current sequence number is  {}",
                        txn_seq_num, acc_seq_num,
                    ),
                );
            }
```

**File:** mempool/src/core_mempool/transaction_store.rs (L322-333)
```rust
            match txn_replay_protector {
                ReplayProtector::SequenceNumber(_) => {
                    if txns.seq_num_txns_len() >= self.capacity_per_user {
                        return MempoolStatus::new(MempoolStatusCode::TooManyTransactions).with_message(
                            format!(
                                "Mempool over capacity for account. Number of seq number transactions from account: {} Capacity per account: {}",
                                txns.seq_num_txns_len() ,
                                self.capacity_per_user,
                            ),
                        );
                    }
                },
```

**File:** mempool/src/core_mempool/transaction_store.rs (L603-633)
```rust
    fn process_ready_seq_num_based_transactions(
        &mut self,
        address: &AccountAddress,
        account_sequence_num: u64,
    ) {
        let mut min_seq = account_sequence_num;
        while self.process_ready_transaction(address, ReplayProtector::SequenceNumber(min_seq)) {
            min_seq += 1;
        }

        if let Some(txns) = self.transactions.get_mut(address) {
            let mut parking_lot_txns = 0;
            for (_, txn) in txns.seq_num_range_mut((Bound::Excluded(min_seq), Bound::Unbounded)) {
                match txn.timeline_state {
                    TimelineState::Ready(_) => {},
                    _ => {
                        self.parking_lot_index.insert(txn);
                        parking_lot_txns += 1;
                    },
                }
            }

            trace!(
                LogSchema::new(LogEntry::ProcessReadyTxns).account(*address),
                first_ready_seq_num = account_sequence_num,
                last_ready_seq_num = min_seq,
                num_parked_txns = parking_lot_txns,
            );
            self.track_indices();
        }
    }
```

**File:** config/src/config/mempool_config.rs (L123-123)
```rust
            capacity_per_user: 100,
```

**File:** config/src/config/mempool_config.rs (L129-129)
```rust
            system_transaction_timeout_secs: 600,
```

**File:** mempool/src/core_mempool/index.rs (L27-30)
```rust
pub struct AccountTransactions {
    nonce_transactions: BTreeMap<u64 /* Nonce */, MempoolTransaction>,
    sequence_number_transactions: BTreeMap<u64 /* Sequence number */, MempoolTransaction>,
}
```

**File:** aptos-move/framework/aptos-framework/sources/transaction_validation.move (L238-241)
```text
            assert!(
                txn_sequence_number == account_sequence_number,
                error::invalid_argument(PROLOGUE_ESEQUENCE_NUMBER_TOO_NEW)
            );
```
