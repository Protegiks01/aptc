# Audit Report

## Title
Unbounded BCS Deserialization in JWK Consensus Leading to Validator CPU DoS

## Summary
The `try_from_issuer_level_repr()` function in the JWK consensus module lacks input size validation, allowing arbitrarily large JWK payloads from OIDC providers to cause excessive CPU usage during BCS deserialization, potentially degrading validator performance.

## Finding Description

The vulnerability exists in the JWK consensus data flow where validators fetch JSON Web Keys from external OIDC providers. The system fails to enforce size limits at multiple critical points: [1](#0-0) 

When `new_rb_request()` is invoked, it calls `try_from_issuer_level_repr()` which performs BCS deserialization without size bounds: [2](#0-1) 

This function calls `JWK::try_from()` which invokes `MoveAny::unpack()`: [3](#0-2) 

The unpacking performs BCS deserialization: [4](#0-3) 

The JWK structures themselves have unbounded fields: [5](#0-4) [6](#0-5) 

The HTTP fetching has no size constraints: [7](#0-6) 

**Attack Vector**: A malicious or compromised OIDC provider in the `SupportedOIDCProviders` list can return JWKs with multi-megabyte fields (e.g., RSA modulus `n` of 50MB instead of 256 bytes, or `UnsupportedJWK.payload` of 100MB). When validators fetch these, the BCS deserialization in `try_from_issuer_level_repr()` consumes excessive CPU cycles proportional to the payload size.

## Impact Explanation

This qualifies as **High Severity** under the Aptos bug bounty program's "Validator node slowdowns" category. The impact includes:

1. **Performance Degradation**: Each validator processing the malicious JWK payload experiences CPU spikes during BCS deserialization
2. **Consensus Delays**: If multiple validators are affected simultaneously, consensus round times increase
3. **Resource Exhaustion**: Sustained attacks with multiple large JWK updates can accumulate CPU usage

While the Move framework enforces a 2KB limit for federated JWKs, no equivalent limit exists for system-level JWKs: [8](#0-7) 

The 2MB validator transaction limit is enforced AFTER deserialization, not before, providing no protection at this stage.

## Likelihood Explanation

**Likelihood: Medium-to-High** if a malicious provider is added, **Low** under normal circumstances.

Prerequisites for exploitation:
1. The malicious OIDC provider must be added to `SupportedOIDCProviders` (requires governance approval), OR
2. A legitimate provider (Google, Facebook, etc.) must be compromised, OR  
3. Man-in-the-middle attack on HTTP connections (though validators should use HTTPS)

However, once a malicious provider is in the list, exploitation is trivial and guaranteed to affect all validators monitoring that provider.

## Recommendation

Implement defense-in-depth size validation at multiple layers:

**1. Add HTTP response size limits in JWK fetching:**
```rust
// In crates/jwk-utils/src/lib.rs
const MAX_JWK_RESPONSE_SIZE_BYTES: usize = 1024 * 1024; // 1 MB

pub async fn fetch_jwks_from_jwks_uri(
    my_addr: Option<AccountAddress>,
    jwks_uri: &str,
) -> Result<Vec<JWK>> {
    let client = reqwest::Client::new();
    let mut request_builder = client.get(jwks_uri);
    if let Some(addr) = my_addr {
        request_builder = request_builder.header(COOKIE, addr.to_hex());
    }
    let response = request_builder.send().await?;
    
    // Check content length before downloading
    if let Some(content_length) = response.content_length() {
        ensure!(
            content_length <= MAX_JWK_RESPONSE_SIZE_BYTES as u64,
            "JWK response too large: {} bytes", content_length
        );
    }
    
    let JWKsResponse { keys } = response.json().await?;
    let jwks = keys.into_iter().map(JWK::from).collect();
    Ok(jwks)
}
```

**2. Add field size validation in RSA_JWK:**
```rust
// In types/src/jwks/rsa/mod.rs
const MAX_JWK_FIELD_SIZE: usize = 4096; // 4 KB per field

impl RSA_JWK {
    pub fn validate_sizes(&self) -> anyhow::Result<()> {
        ensure!(self.kid.len() <= MAX_JWK_FIELD_SIZE, "kid too large");
        ensure!(self.kty.len() <= MAX_JWK_FIELD_SIZE, "kty too large");
        ensure!(self.alg.len() <= MAX_JWK_FIELD_SIZE, "alg too large");
        ensure!(self.e.len() <= MAX_JWK_FIELD_SIZE, "e too large");
        ensure!(self.n.len() <= MAX_JWK_FIELD_SIZE, "n too large");
        Ok(())
    }
}
```

**3. Add early validation in `try_from_issuer_level_repr()`:**
```rust
// In types/src/jwks/mod.rs
pub fn try_from_issuer_level_repr(repr: &ProviderJWKs) -> anyhow::Result<Self> {
    ensure!(repr.jwks.len() == 1, "wrapped repr should have exactly 1 jwk");
    
    // Add BCS size check before deserialization
    let data_size = repr.jwks[0].variant.data.len();
    const MAX_JWK_DATA_SIZE: usize = 8192; // 8 KB
    ensure!(data_size <= MAX_JWK_DATA_SIZE, "JWK data too large: {} bytes", data_size);
    
    let jwk = JWK::try_from(&repr.jwks[0])
        .context("try_from_issuer_level_repr failed on JWK")?;
    
    // Validate field sizes after deserialization
    if let JWK::RSA(ref rsa) = jwk {
        rsa.validate_sizes()?;
    }
    
    let base_version = repr.version.checked_sub(1)
        .context("try_from_issuer_level_repr on version")?;
    Ok(Self {
        issuer: repr.issuer.clone(),
        base_version,
        kid: jwk.id(),
        to_upsert: match jwk {
            JWK::Unsupported(unsupported)
                if unsupported.payload.as_slice() == DELETE_COMMAND_INDICATOR.as_bytes() =>
            {
                None
            },
            _ => Some(jwk),
        },
    })
}
```

## Proof of Concept

```rust
#[test]
fn test_large_jwk_dos() {
    use aptos_types::jwks::{ProviderJWKs, jwk::{JWKMoveStruct, JWK}, rsa::RSA_JWK};
    use crate::move_any::Any;
    
    // Create a malicious RSA JWK with an extremely large modulus
    let large_modulus = "A".repeat(10 * 1024 * 1024); // 10 MB string
    let malicious_jwk = RSA_JWK {
        kid: "malicious".to_string(),
        kty: "RSA".to_string(),
        alg: "RS256".to_string(),
        e: "AQAB".to_string(),
        n: large_modulus,
    };
    
    // Pack into JWKMoveStruct
    let jwk_move = JWKMoveStruct::from(JWK::RSA(malicious_jwk));
    
    // Create ProviderJWKs payload
    let payload = ProviderJWKs {
        issuer: b"https://malicious.com".to_vec(),
        version: 1,
        jwks: vec![jwk_move],
    };
    
    // Measure CPU time for deserialization
    let start = std::time::Instant::now();
    let result = KeyLevelUpdate::try_from_issuer_level_repr(&payload);
    let elapsed = start.elapsed();
    
    // This will take significant time (seconds) due to large payload
    println!("Deserialization took: {:?}", elapsed);
    assert!(elapsed.as_secs() > 1, "DoS successful: CPU time exceeded 1 second");
}
```

## Notes

This vulnerability demonstrates a defense-in-depth failure where trusted external data sources (OIDC providers approved by governance) are not validated for resource consumption. While the `SupportedOIDCProviders` list is governance-controlled and theoretically trusted, the principle of least privilege demands that even trusted inputs be bounded to prevent accidental or malicious resource exhaustion. The existence of `MAX_FEDERATED_JWKS_SIZE_BYTES` (2KB limit) for dapp-owned JWKs shows the developers recognized this concern but failed to apply it consistently to system-level JWKs.

### Citations

**File:** crates/aptos-jwk-consensus/src/mode/per_key.rs (L32-40)
```rust
    fn new_rb_request(
        epoch: u64,
        payload: &ProviderJWKs,
    ) -> anyhow::Result<ObservedKeyLevelUpdateRequest> {
        let KeyLevelUpdate { issuer, kid, .. } =
            KeyLevelUpdate::try_from_issuer_level_repr(payload)
                .context("new_rb_request failed with repr translation")?;
        Ok(ObservedKeyLevelUpdateRequest { epoch, issuer, kid })
    }
```

**File:** types/src/jwks/mod.rs (L360-384)
```rust
    pub fn try_from_issuer_level_repr(repr: &ProviderJWKs) -> anyhow::Result<Self> {
        ensure!(
            repr.jwks.len() == 1,
            "wrapped repr of a key-level update should have exactly 1 jwk"
        );
        let jwk =
            JWK::try_from(&repr.jwks[0]).context("try_from_issuer_level_repr failed on JWK")?;
        let base_version = repr
            .version
            .checked_sub(1)
            .context("try_from_issuer_level_repr on version")?;
        Ok(Self {
            issuer: repr.issuer.clone(),
            base_version,
            kid: jwk.id(),
            to_upsert: match jwk {
                JWK::Unsupported(unsupported)
                    if unsupported.payload.as_slice() == DELETE_COMMAND_INDICATOR.as_bytes() =>
                {
                    None
                },
                _ => Some(jwk),
            },
        })
    }
```

**File:** types/src/jwks/jwk/mod.rs (L102-122)
```rust
impl TryFrom<&JWKMoveStruct> for JWK {
    type Error = anyhow::Error;

    fn try_from(value: &JWKMoveStruct) -> Result<Self, Self::Error> {
        match value.variant.type_name.as_str() {
            RSA_JWK::MOVE_TYPE_NAME => {
                let rsa_jwk =
                    MoveAny::unpack(RSA_JWK::MOVE_TYPE_NAME, value.variant.clone()).map_err(|e|anyhow!("converting from jwk move struct to jwk failed with move any to rsa unpacking error: {e}"))?;
                Ok(Self::RSA(rsa_jwk))
            },
            UnsupportedJWK::MOVE_TYPE_NAME => {
                let unsupported_jwk =
                    MoveAny::unpack(UnsupportedJWK::MOVE_TYPE_NAME, value.variant.clone()).map_err(|e|anyhow!("converting from jwk move struct to jwk failed with move any to unsupported unpacking error: {e}"))?;
                Ok(Self::Unsupported(unsupported_jwk))
            },
            _ => Err(anyhow!(
                "converting from jwk move struct to jwk failed with unknown variant"
            )),
        }
    }
}
```

**File:** types/src/move_any.rs (L25-33)
```rust
    pub fn unpack<T: DeserializeOwned>(move_name: &str, x: Any) -> anyhow::Result<T> {
        let Any { type_name, data } = x;
        if type_name == move_name {
            let y = bcs::from_bytes::<T>(&data)?;
            Ok(y)
        } else {
            bail!("type mismatch")
        }
    }
```

**File:** types/src/jwks/rsa/mod.rs (L18-25)
```rust
#[derive(Clone, Debug, Hash, PartialEq, Eq, Serialize, Deserialize, Object)]
pub struct RSA_JWK {
    pub kid: String,
    pub kty: String,
    pub alg: String,
    pub e: String,
    pub n: String,
}
```

**File:** types/src/jwks/unsupported/mod.rs (L14-17)
```rust
pub struct UnsupportedJWK {
    pub id: Vec<u8>,
    pub payload: Vec<u8>,
}
```

**File:** crates/jwk-utils/src/lib.rs (L25-37)
```rust
pub async fn fetch_jwks_from_jwks_uri(
    my_addr: Option<AccountAddress>,
    jwks_uri: &str,
) -> Result<Vec<JWK>> {
    let client = reqwest::Client::new();
    let mut request_builder = client.get(jwks_uri);
    if let Some(addr) = my_addr {
        request_builder = request_builder.header(COOKIE, addr.to_hex());
    }
    let JWKsResponse { keys } = request_builder.send().await?.json().await?;
    let jwks = keys.into_iter().map(JWK::from).collect();
    Ok(jwks)
}
```

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L31-33)
```text
    /// We limit the size of a `PatchedJWKs` resource installed by a dapp owner for federated keyless accounts.
    /// Note: If too large, validators waste work reading it for invalid TXN signatures.
    const MAX_FEDERATED_JWKS_SIZE_BYTES: u64 = 2 * 1024; // 2 KiB
```
