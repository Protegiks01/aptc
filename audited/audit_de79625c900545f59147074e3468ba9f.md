# Audit Report

## Title
Missing Service Readiness Validation in Indexer-gRPC Bootstrap Causes Denial of Service

## Summary
The indexer-grpc-fullnode service starts accepting client requests without validating that required indexer components are properly configured. When clients connect to a misconfigured service, their requests hang indefinitely in an error loop, causing a denial of service.

## Finding Description

The `bootstrap()` function in the indexer-grpc-fullnode service lacks validation to ensure the service is ready before starting the gRPC server. [1](#0-0) 

The function accepts an `indexer_reader: Option<Arc<dyn IndexerReader>>` parameter and immediately starts the gRPC server without validating:
1. Whether the database is synced with the blockchain
2. Whether required indexer components are available and properly configured
3. Whether the indexer_reader contains all necessary sub-components

The service has a **hard dependency** on the table_info_reader component: [2](#0-1) 

However, the configuration sanitizer only validates that **at least one** indexer source is enabled: [3](#0-2) 

This creates a vulnerability where a node can be configured with:
- `storage.enable_indexer = true` (passes validation)
- `indexer_table_info.table_info_service_mode = disabled`

In this scenario, `IndexerReaders` will be created with only `db_indexer_reader` present: [4](#0-3) 

When a client connects and requests transactions, the service attempts to get the table info version, which returns an error: [5](#0-4) 

This error is caught and the service enters an **infinite retry loop**: [6](#0-5) 

**Attack Path:**
1. Node operator misconfigures indexer-grpc with only internal indexer enabled
2. Configuration validation passes (sanitizer accepts this)
3. gRPC server starts successfully and accepts connections
4. Client sends GetTransactionsFromNode request
5. Service enters infinite error loop attempting to read table info
6. Client request hangs indefinitely
7. All subsequent client requests hang, causing complete service unavailability

## Impact Explanation

This is a **Medium severity** denial of service vulnerability affecting the indexer-grpc service availability:

- **Service Unavailability**: Once a misconfigured node is deployed, all client requests hang indefinitely, rendering the indexer service completely unusable
- **No Fail-Fast Behavior**: The service appears healthy (server starts, accepts connections) but silently fails on every request
- **Cascading Impact**: Multiple clients connecting to the misconfigured service will all hang, potentially exhausting client resources and affecting downstream systems
- **Difficult to Diagnose**: The infinite loop with error logging makes it unclear to operators what the root cause is

Per Aptos bug bounty criteria, this falls under **Medium Severity** as it creates "state inconsistencies requiring intervention" - the service is running but non-functional, requiring configuration changes and restart to resolve.

## Likelihood Explanation

**High Likelihood** - This vulnerability can easily occur in production:

1. **Valid Configuration**: The misconfiguration passes all validation checks, so operators receive no warnings
2. **Intuitive Mistake**: Operators might reasonably enable only the internal indexer without realizing the table info service is a hard requirement
3. **Silent Failure**: The service starts successfully, hiding the misconfiguration until clients connect
4. **No Documentation**: There's no clear documentation indicating that table_info_service is mandatory for indexer-grpc operation

The vulnerability requires no attacker sophistication - any normal client request triggers the DoS condition.

## Recommendation

**Add comprehensive validation to the `bootstrap()` function** to verify all required components are available before starting the gRPC server:

```rust
pub fn bootstrap(
    config: &NodeConfig,
    chain_id: ChainId,
    db: Arc<dyn DbReader>,
    mp_sender: MempoolClientSender,
    indexer_reader: Option<Arc<dyn IndexerReader>>,
    port_tx: Option<oneshot::Sender<u16>>,
) -> Option<Runtime> {
    if !config.indexer_grpc.enabled {
        return None;
    }

    // VALIDATION: Ensure indexer_reader is configured
    let indexer_reader = indexer_reader.expect(
        "indexer_reader must be configured when indexer_grpc is enabled"
    );

    // VALIDATION: Verify table_info_reader is available
    if indexer_reader.get_latest_table_info_ledger_version().is_err() {
        panic!(
            "Table info reader is required but not available. \
             Enable indexer_table_info.table_info_service_mode to use indexer-grpc."
        );
    }

    // VALIDATION: Verify database has data
    if db.get_latest_ledger_info().is_err() {
        panic!("Database is not initialized. Cannot start indexer-grpc service.");
    }

    // Continue with server initialization...
}
```

**Update the configuration sanitizer** to enforce the table_info_service requirement:

```rust
impl ConfigSanitizer for IndexerGrpcConfig {
    fn sanitize(
        node_config: &NodeConfig,
        _node_type: NodeType,
        _chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        if !node_config.indexer_grpc.enabled {
            return Ok(());
        }

        // Require table_info_service for indexer-grpc operation
        if !node_config.indexer_table_info.table_info_service_mode.is_enabled() {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "indexer_table_info.table_info_service_mode must be enabled when indexer_grpc is enabled"
                    .to_string(),
            ));
        }

        Ok(())
    }
}
```

## Proof of Concept

**Configuration File** (`node_config.yaml`):
```yaml
indexer_grpc:
  enabled: true
  address: "0.0.0.0:50051"

storage:
  enable_indexer: true

indexer_table_info:
  table_info_service_mode: "Disabled"
```

**Steps to Reproduce:**
1. Configure an Aptos fullnode with the above configuration
2. Start the node - it will start successfully
3. Connect a client and send a `GetTransactionsFromNode` request:
   ```rust
   let request = GetTransactionsFromNodeRequest {
       starting_version: Some(1000),
       transactions_count: Some(100),
   };
   client.get_transactions_from_node(request).await;
   ```
4. Observe: The request hangs indefinitely
5. Check logs: Repeated errors "Failed to set highest known version" with "Table info reader is not available"
6. All subsequent client requests exhibit the same hanging behavior

**Expected vs Actual Behavior:**
- **Expected**: Service either fails to start with clear error message, or handles requests successfully
- **Actual**: Service starts successfully but all client requests hang indefinitely in an error loop

## Notes

This vulnerability specifically affects the indexer-grpc-fullnode service's readiness validation. While the `ensure_highest_known_version()` mechanism provides protection against unsynced databases by waiting for data availability, it fails catastrophically when required components are missing entirely. The root cause is the missing validation at service bootstrap time, allowing invalid configurations to deploy successfully.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/runtime.rs (L36-135)
```rust
pub fn bootstrap(
    config: &NodeConfig,
    chain_id: ChainId,
    db: Arc<dyn DbReader>,
    mp_sender: MempoolClientSender,
    indexer_reader: Option<Arc<dyn IndexerReader>>,
    port_tx: Option<oneshot::Sender<u16>>,
) -> Option<Runtime> {
    if !config.indexer_grpc.enabled {
        return None;
    }

    let runtime = aptos_runtimes::spawn_named_runtime("indexer-grpc".to_string(), None);

    let node_config = config.clone();

    let address = node_config.indexer_grpc.address;
    let use_data_service_interface = node_config.indexer_grpc.use_data_service_interface;
    let processor_task_count = node_config
        .indexer_grpc
        .processor_task_count
        .unwrap_or_else(|| get_default_processor_task_count(use_data_service_interface));
    let processor_batch_size = node_config.indexer_grpc.processor_batch_size;
    let output_batch_size = node_config.indexer_grpc.output_batch_size;
    let transaction_channel_size = node_config.indexer_grpc.transaction_channel_size;
    let max_transaction_filter_size_bytes =
        node_config.indexer_grpc.max_transaction_filter_size_bytes;

    runtime.spawn(async move {
        let context = Arc::new(Context::new(
            chain_id,
            db,
            mp_sender,
            node_config,
            indexer_reader,
        ));
        let service_context = ServiceContext {
            context: context.clone(),
            processor_task_count,
            processor_batch_size,
            output_batch_size,
            transaction_channel_size,
            max_transaction_filter_size_bytes,
        };
        // If we are here, we know indexer grpc is enabled.
        let server = FullnodeDataService {
            service_context: service_context.clone(),
            abort_handle: Arc::new(AtomicBool::new(false)),
        };
        let localnet_data_server = LocalnetDataService { service_context };

        let reflection_service = tonic_reflection::server::Builder::configure()
            // Note: It is critical that the file descriptor set is registered for every
            // file that the top level API proto depends on recursively. If you don't,
            // compilation will still succeed but reflection will fail at runtime.
            //
            // TODO: Add a test for this / something in build.rs, this is a big footgun.
            .register_encoded_file_descriptor_set(INDEXER_V1_FILE_DESCRIPTOR_SET)
            .register_encoded_file_descriptor_set(TRANSACTION_V1_TESTING_FILE_DESCRIPTOR_SET)
            .register_encoded_file_descriptor_set(UTIL_TIMESTAMP_FILE_DESCRIPTOR_SET)
            .build_v1()
            .expect("Failed to build reflection service");

        let reflection_service_clone = reflection_service.clone();

        let tonic_server = Server::builder()
            .http2_keepalive_interval(Some(std::time::Duration::from_secs(60)))
            .http2_keepalive_timeout(Some(std::time::Duration::from_secs(5)))
            .add_service(reflection_service_clone);

        let router = match use_data_service_interface {
            false => {
                let svc = FullnodeDataServer::new(server)
                    .send_compressed(CompressionEncoding::Zstd)
                    .accept_compressed(CompressionEncoding::Zstd)
                    .accept_compressed(CompressionEncoding::Gzip);
                tonic_server.add_service(svc)
            },
            true => {
                let svc = RawDataServer::new(localnet_data_server)
                    .send_compressed(CompressionEncoding::Zstd)
                    .accept_compressed(CompressionEncoding::Zstd)
                    .accept_compressed(CompressionEncoding::Gzip);
                tonic_server.add_service(svc)
            },
        };

        let listener = TcpListener::bind(address).await.unwrap();
        if let Some(port_tx) = port_tx {
            port_tx.send(listener.local_addr().unwrap().port()).unwrap();
        }
        let incoming = TcpIncoming::from_listener(listener, false, None).unwrap();

        // Make port into a config
        router.serve_with_incoming(incoming).await.unwrap();

        info!(address = address, "[indexer-grpc] Started GRPC server");
    });
    Some(runtime)
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/stream_coordinator.rs (L532-546)
```rust
    pub fn set_highest_known_version(&mut self) -> anyhow::Result<()> {
        let info = self.context.get_latest_ledger_info_wrapped()?;
        let latest_table_info_version = self
            .context
            .indexer_reader
            .as_ref()
            .expect("Table info reader not set")
            .get_latest_table_info_ledger_version()?
            .expect("Table info ledger version not set");

        self.highest_known_version =
            std::cmp::min(info.ledger_version.0, latest_table_info_version);

        Ok(())
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/stream_coordinator.rs (L550-579)
```rust
    async fn ensure_highest_known_version(&mut self) -> bool {
        let mut empty_loops = 0;
        while self.highest_known_version == 0 || self.current_version > self.highest_known_version {
            if let Some(abort_handle) = self.abort_handle.as_ref() {
                if abort_handle.load(Ordering::SeqCst) {
                    return false;
                }
            }
            if empty_loops > 0 {
                tokio::time::sleep(Duration::from_millis(RETRY_TIME_MILLIS)).await;
            }
            empty_loops += 1;
            if let Err(err) = self.set_highest_known_version() {
                error!(
                    error = format!("{:?}", err),
                    "[Indexer Fullnode] Failed to set highest known version"
                );
                continue;
            } else {
                sample!(
                    SampleRate::Frequency(10),
                    info!(
                        highest_known_version = self.highest_known_version,
                        "[Indexer Fullnode] Found new highest known version",
                    )
                );
            }
        }
        true
    }
```

**File:** config/src/config/indexer_grpc_config.rs (L115-125)
```rust
        if !node_config.storage.enable_indexer
            && !node_config
                .indexer_table_info
                .table_info_service_mode
                .is_enabled()
        {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "storage.enable_indexer must be true or indexer_table_info.table_info_service_mode must be IndexingOnly if indexer_grpc.enabled is true".to_string(),
            ));
        }
```

**File:** storage/indexer/src/indexer_reader.rs (L27-39)
```rust
    pub fn new(
        table_info_reader: Option<Arc<IndexerAsyncV2>>,
        db_indexer_reader: Option<Arc<DBIndexer>>,
    ) -> Option<Self> {
        if table_info_reader.is_none() && db_indexer_reader.is_none() {
            None
        } else {
            Some(Self {
                table_info_reader,
                db_indexer_reader,
            })
        }
    }
```

**File:** storage/indexer/src/indexer_reader.rs (L61-66)
```rust
    fn get_latest_table_info_ledger_version(&self) -> anyhow::Result<Option<Version>> {
        if let Some(table_info_reader) = &self.table_info_reader {
            return Ok(Some(table_info_reader.next_version()));
        }
        anyhow::bail!("Table info reader is not available")
    }
```
