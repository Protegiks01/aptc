# Audit Report

## Title
Critical Waypoint Validation Bypass Allows Malicious Backup Restoration Without Cryptographic Verification

## Summary
The `TrustedWaypointOpt` validation mechanism accepts attacker-provided waypoints from command-line arguments without any cryptographic verification, signature validation, or chain-to-genesis proof. When trusted waypoints are provided during backup restoration or verification, BLS signature verification is completely bypassed, allowing an attacker who compromises backup storage to restore a malicious blockchain state by providing matching waypoints.

## Finding Description

The vulnerability exists across multiple components of the backup/restore system:

**1. Waypoint Acceptance Without Validation** [1](#0-0) 

The `TrustedWaypointOpt` struct accepts waypoints via CLI flag with no cryptographic validation beyond parsing.

**2. Insufficient Verification Logic** [2](#0-1) 

The `verify()` method only checks for duplicate versions, performing no cryptographic validation, signature verification, or chain-to-genesis proof.

**3. Signature Verification Bypass - First Location** [3](#0-2) 

When a trusted waypoint exists for a LedgerInfo version, the code skips BLS signature verification and only checks hash equality. Otherwise, it verifies signatures via `verify(&li)`.

**4. Signature Verification Bypass - Second Location** [4](#0-3) 

During epoch history restoration, if a trusted waypoint is found, signature verification is skipped again.

**5. Signature Verification Bypass - Third Location** [5](#0-4) 

The `EpochHistory::verify_ledger_info()` method bypasses signature verification for any LedgerInfo at a trusted waypoint version.

**6. Integration Points** [6](#0-5) [7](#0-6) 

The verification coordinator accepts these unvalidated waypoints and passes them throughout the restoration process.

**Attack Path:**

1. Attacker compromises backup storage infrastructure (S3 bucket, GCS, Azure, etc.)
2. Attacker creates malicious backup data with fabricated LedgerInfos
3. Attacker computes waypoints (version:hash pairs) matching the fake LedgerInfos
4. Attacker tricks node operator into using these waypoints via:
   - Compromised documentation
   - Malicious configuration examples
   - Social engineering
   - MITM on waypoint distribution
5. Operator runs: `aptos-db-tool backup verify --trust-waypoint <malicious_waypoint> ...`
6. System accepts malicious backup because:
   - Hash in waypoint matches hash in fake LedgerInfo ✓
   - BLS signature verification is SKIPPED (trusted waypoint bypass)
   - No proof waypoint chains to genesis
   - No cryptographic signature on waypoint itself
7. Malicious blockchain state is restored, violating consensus safety

**Broken Invariants:**
- **Consensus Safety**: Different nodes could restore different blockchain histories
- **State Consistency**: State transitions not verified via proper signature validation  
- **Cryptographic Correctness**: BLS signature verification bypassed entirely

## Impact Explanation

This vulnerability meets **Critical Severity** criteria per Aptos Bug Bounty program:

**Consensus/Safety Violations**: An attacker can cause different nodes to restore completely different blockchain states. If multiple operators independently restore from compromised backups with different malicious waypoints, the network experiences non-recoverable state divergence requiring a hard fork.

**Loss of Funds**: Malicious state can include fabricated account balances, allowing theft of any amount of tokens. The attacker controls the entire state tree content.

**Non-Recoverable Network Partition**: Once nodes restore from different malicious backups, they have fundamentally different states that cannot reconcile through normal consensus, requiring emergency intervention.

The impact is **total compromise** of any node performing restoration with attacker-influenced waypoints. Unlike typical backup corruption which would be caught by signature verification, this bypass makes detection impossible at the technical level.

## Likelihood Explanation

**Moderate-to-High Likelihood** due to:

1. **Backup Infrastructure Compromise**: Cloud storage misconfigurations are common. S3 bucket breaches, exposed credentials, or compromised CI/CD pipelines provide backup write access.

2. **Waypoint Distribution Weakness**: Operators must obtain waypoints from external sources. Attack vectors include:
   - Documentation website compromise
   - GitHub repository compromise  
   - DNS hijacking of waypoint distribution endpoints
   - Man-in-the-middle attacks on HTTP connections
   - Malicious forum posts/support responses

3. **Operational Complexity**: Node operators may not fully understand that waypoints MUST come from cryptographically verified sources. Automation scripts might fetch waypoints from untrusted locations.

4. **No Technical Defense**: The system provides zero technical validation. An operator cannot distinguish legitimate from malicious waypoints without external verification.

5. **Realistic Scenario**: During disaster recovery, operators are under pressure and may trust waypoints from seemingly legitimate but compromised sources.

The attack does not require validator key compromise, consensus bugs, or 51% attacks. It exploits a design-level absence of cryptographic validation.

## Recommendation

Implement cryptographic validation of waypoints:

**Option 1: Waypoint Signatures (Preferred)**
```rust
pub struct SignedWaypoint {
    waypoint: Waypoint,
    signatures: BTreeMap<AccountAddress, Ed25519Signature>,
    // Signatures from threshold of well-known authorities
}

impl TrustedWaypointOpt {
    pub fn verify(self) -> Result<HashMap<Version, Waypoint>> {
        let mut trusted_waypoints = HashMap::new();
        for signed_wp in self.trust_waypoint {
            // Verify signatures from known authorities (e.g., Aptos Foundation keys)
            signed_wp.verify_signatures(&AUTHORITY_KEYS)?;
            let wp = signed_wp.waypoint;
            // ... rest of validation
        }
        Ok(trusted_waypoints)
    }
}
```

**Option 2: Chain-to-Genesis Verification**
```rust
impl TrustedWaypointOpt {
    pub fn verify(self, genesis_waypoint: Waypoint) -> Result<HashMap<Version, Waypoint>> {
        // Require proof that each waypoint chains back to genesis
        for wp in &self.trust_waypoint {
            if wp.version() != 0 {
                ensure!(
                    epoch_history.verify_chain_to_genesis(wp, genesis_waypoint)?,
                    "Waypoint does not chain to genesis: {}", wp
                );
            }
        }
        // ... rest of validation
    }
}
```

**Option 3: Mandatory Explicit Acknowledgment**
```rust
// For non-genesis waypoints, require additional confirmation
#[clap(long = "trust-waypoint-unsafe")]
pub trust_waypoint_unsafe: Vec<Waypoint>,

// Log prominent warnings
warn!("SECURITY WARNING: Using unverified waypoints bypasses signature verification");
warn!("Ensure waypoints obtained from cryptographically verified source");
```

**Additional Hardening:**
- Embed well-known waypoints in the binary (genesis, major network upgrades)
- Implement waypoint certificate chain similar to TLS certificates
- Add rate limiting on restore operations
- Require multi-party approval for non-genesis waypoints in production

## Proof of Concept

```rust
// File: malicious_waypoint_poc.rs
use aptos_backup_cli::utils::TrustedWaypointOpt;
use aptos_types::{
    waypoint::Waypoint,
    ledger_info::{LedgerInfo, LedgerInfoWithSignatures},
    block_info::BlockInfo,
    aggregate_signature::AggregateSignature,
};
use aptos_crypto::HashValue;

#[test]
fn test_malicious_waypoint_accepted() {
    // 1. Attacker creates fake LedgerInfo
    let fake_block_info = BlockInfo::new(
        999,           // fake epoch
        0,             // round
        HashValue::random(), // fake block id
        HashValue::random(), // fake accumulator - MALICIOUS STATE
        1000000,       // version
        1000000000,    // timestamp
        None,          // no epoch state to avoid additional checks
    );
    let fake_ledger_info = LedgerInfo::new(fake_block_info, HashValue::zero());
    
    // 2. Attacker computes waypoint matching the fake data
    let malicious_waypoint = Waypoint::new_any(&fake_ledger_info);
    
    // 3. Attacker provides via CLI: --trust-waypoint 1000000:<computed_hash>
    let opt = TrustedWaypointOpt {
        trust_waypoint: vec![malicious_waypoint],
    };
    
    // 4. Verification accepts it without any cryptographic validation!
    let result = opt.verify();
    assert!(result.is_ok()); // ❌ ACCEPTED WITHOUT VALIDATION
    
    let trusted_waypoints = result.unwrap();
    assert_eq!(trusted_waypoints.len(), 1);
    assert!(trusted_waypoints.contains_key(&1000000));
    
    // 5. During restore, this waypoint will cause signature verification bypass
    // The malicious backup with fake_ledger_info will be accepted because:
    // - Hash matches (attacker computed it)
    // - Signature verification is SKIPPED (trusted waypoint)
    // - No chain-to-genesis verification performed
    // - No cryptographic proof of waypoint legitimacy
    
    println!("❌ VULNERABILITY CONFIRMED:");
    println!("Malicious waypoint {} accepted without validation", malicious_waypoint);
    println!("Will bypass signature verification during restore");
    println!("Allows restoration of completely fabricated blockchain state");
}

// Demonstration that signature bypass occurs
#[test]
fn test_signature_verification_bypassed() {
    use std::collections::HashMap;
    use std::sync::Arc;
    
    // Setup trusted waypoint
    let version = 1000u64;
    let malicious_waypoint = Waypoint { version, value: HashValue::random() };
    let mut trusted_waypoints = HashMap::new();
    trusted_waypoints.insert(version, malicious_waypoint);
    let trusted_waypoints = Arc::new(trusted_waypoints);
    
    // In epoch_ending/restore.rs line 129-146:
    // if let Some(wp_trusted) = self.trusted_waypoints.get(&wp_li.version())
    //     => Signature verification SKIPPED ✓
    // else
    //     => pre_li.verify(&li)? would check signatures
    
    // With trusted waypoint: NO SIGNATURE VERIFICATION
    // Without trusted waypoint: SIGNATURE VERIFICATION REQUIRED
    
    assert!(trusted_waypoints.contains_key(&version));
    println!("✓ Trusted waypoint present => Signature verification will be BYPASSED");
}
```

**Compilation:** Place in `storage/backup/backup-cli/tests/` directory and run `cargo test malicious_waypoint_poc`

**Expected Result:** Tests pass, demonstrating waypoints are accepted without validation and bypass signature verification.

## Notes

While the code comment explicitly states "signatures are NOT checked" for trusted waypoints, this design choice creates a critical security vulnerability. The intended use case (handling writeset transactions) could be addressed through signed waypoints or other cryptographic mechanisms rather than complete validation bypass.

The vulnerability is particularly severe because:
1. It provides no defense in depth against backup infrastructure compromise
2. Operators have no technical means to verify waypoint authenticity
3. The impact affects consensus safety, not just individual node security
4. Recovery from exploitation requires network-wide coordination (hard fork)

This represents a systemic weakness in the backup/restore security model that should be addressed through cryptographic hardening rather than operational procedures alone.

### Citations

**File:** storage/backup/backup-cli/src/utils/mod.rs (L332-346)
```rust
pub struct TrustedWaypointOpt {
    #[clap(
        long,
        help = "(multiple) When provided, an epoch ending LedgerInfo at the waypoint version will be \
        checked against the hash in the waypoint, but signatures on it are NOT checked. \
        Use this for two purposes: \
        1. set the genesis or the latest waypoint to confirm the backup is compatible. \
        2. set waypoints at versions where writeset transactions were used to overwrite the \
        validator set, so that the signature check is skipped. \
        N.B. LedgerInfos are verified only when restoring / verifying the epoch ending backups, \
        i.e. they are NOT checked at all when doing one-shot restoring of the transaction \
        and state backups."
    )]
    pub trust_waypoint: Vec<Waypoint>,
}
```

**File:** storage/backup/backup-cli/src/utils/mod.rs (L348-363)
```rust
impl TrustedWaypointOpt {
    pub fn verify(self) -> Result<HashMap<Version, Waypoint>> {
        let mut trusted_waypoints = HashMap::new();
        for w in self.trust_waypoint {
            trusted_waypoints
                .insert(w.version(), w)
                .map_or(Ok(()), |w| {
                    Err(AptosDbError::Other(format!(
                        "Duplicated waypoints at version {}",
                        w.version()
                    )))
                })?;
        }
        Ok(trusted_waypoints)
    }
}
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L129-147)
```rust
                if let Some(wp_trusted) = self.trusted_waypoints.get(&wp_li.version()) {
                    ensure!(
                        *wp_trusted == wp_li,
                        "Waypoints don't match. In backup: {}, trusted: {}",
                        wp_li,
                        wp_trusted,
                    );
                } else if let Some(pre_li) = previous_li {
                    pre_li
                        .ledger_info()
                        .next_epoch_state()
                        .ok_or_else(|| {
                            anyhow!(
                                "Next epoch state not found from LI at epoch {}.",
                                pre_li.ledger_info().epoch()
                            )
                        })?
                        .verify(&li)?;
                }
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L228-239)
```rust
            if self
                .controller
                .trusted_waypoints
                .get(&first_li.ledger_info().version())
                .is_none()
            {
                li.next_epoch_state()
                    .ok_or_else(|| {
                        anyhow!("Previous epoch ending LedgerInfo doesn't end an epoch")
                    })?
                    .verify(first_li)?;
            }
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L294-310)
```rust
        } else if let Some(wp_trusted) = self
            .trusted_waypoints
            .get(&li_with_sigs.ledger_info().version())
        {
            let wp_li = Waypoint::new_any(li_with_sigs.ledger_info());
            ensure!(
                *wp_trusted == wp_li,
                "Waypoints don't match. In backup: {}, trusted: {}",
                wp_li,
                wp_trusted,
            );
        } else {
            self.epoch_endings[epoch as usize - 1]
                .next_epoch_state()
                .ok_or_else(|| anyhow!("Shouldn't contain non- epoch bumping LIs."))?
                .verify(li_with_sigs)?;
        };
```

**File:** storage/db-tool/src/backup.rs (L129-129)
```rust
    trusted_waypoints_opt: TrustedWaypointOpt,
```

**File:** storage/db-tool/src/backup.rs (L241-241)
```rust
                    opt.trusted_waypoints_opt,
```
