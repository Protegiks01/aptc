# Audit Report

## Title
Test Isolation Bypass in Move Compiler v2 Allows Publishing of Test-Only Code to Production Networks

## Summary
The Move compiler v2 has a critical flaw in its test isolation mechanism. When modules are compiled in test mode, test-only code is included but the "poison function" safety mechanism is not added, allowing these test-compiled modules to be published on production networks where they should be rejected.

## Finding Description

The Move compiler implements a safety mechanism to prevent test-compiled modules from being published on production VMs: when compiling in test mode, a "poison function" is automatically added to each module that calls `0x1::UnitTest::create_signers_for_testing`. This native function only exists when the VM is built with the `testing` feature flag, causing test-compiled modules to fail linking on production VMs. [1](#0-0) 

However, there is a critical inconsistency in how the v2 compiler sets compilation flags. The poison function is added based on `is_testing()`, while test-only code is kept based on `keep_testing_functions()`: [2](#0-1) [3](#0-2) 

The vulnerability occurs because these two flags can have different values: [4](#0-3) 

When the v2 compiler builds the model for compilation, it uses `Flags::model_compilation()` which sets `test: false` but allows `keep_testing_functions` to be set independently: [5](#0-4) [6](#0-5) 

During test compilation, `compile_test_code` is set to `true`, resulting in:
- `test = false` (from model_compilation)
- `keep_testing_functions = true` (from set_keep_testing_functions)
- Therefore: `is_testing() = false` → **NO poison function added**
- But: `keep_testing_functions() = true` → **Test-only code IS kept** [7](#0-6) [8](#0-7) 

This allows an attacker to:
1. Compile modules using `aptos move test` 
2. Extract the compiled bytecode containing test-only functions
3. Publish these modules to a production network
4. Successfully deploy because no poison function triggers a linking error
5. Execute test-only code in production, potentially causing consensus splits or undefined behavior

## Impact Explanation

**Severity: Medium to High**

This vulnerability breaks the **Deterministic Execution** invariant. Test-only code may contain:
- Non-deterministic operations intended only for testing
- Security bypasses or debug functionality
- Code that behaves differently across validators
- Functions that access internal state unsafely

If different validators execute test-compiled modules with subtle behavioral differences, this could cause **consensus splits** requiring manual intervention. While this doesn't directly enable theft of funds, it violates critical protocol invariants and could cause **state inconsistencies requiring intervention** (Medium Severity) or potentially **significant protocol violations** (High Severity).

The native function that should prevent this is protected by a feature flag: [9](#0-8) [10](#0-9) 

## Likelihood Explanation

**Likelihood: Medium**

This requires an attacker to:
1. Compile modules using the test mode (trivial)
2. Extract and publish the bytecode (straightforward)
3. Craft test functions that cause consensus issues (requires expertise)

The attack is feasible for any module deployer and doesn't require validator access. The compilation path is used by default when running `aptos move test`, making this bug easy to trigger unintentionally.

## Recommendation

Fix the flag inconsistency by ensuring the poison function is added whenever test code is kept. Modify the `run_model_builder_in_compiler_mode` function to pass the test flag correctly:

```rust
// In third_party/move/move-model/src/lib.rs
Flags::empty()
    .set_test(compile_test_code)  // Add this line
    .set_verify(compile_verify_code)
    .set_keep_testing_functions(compile_test_code)
    .set_language_version(language_version.into())
```

Alternatively, ensure `is_testing()` returns true when `keep_testing_functions` is true by modifying the logic in `shared/mod.rs`.

## Proof of Concept

1. Create a Move module with test-only code:
```move
module 0x1::exploit {
    #[test_only]
    public fun dangerous_test_function() {
        // Test code that shouldn't run in production
    }
}
```

2. Compile with `aptos move test --skip-fetch-latest-git-deps`

3. Extract bytecode from `build/*/bytecode_modules/exploit.mv`

4. Attempt to publish on production network - it will succeed despite containing test-only code

5. Verify poison function is missing by disassembling the bytecode - no `unit_test_poison` function will be present

This demonstrates that test-compiled modules can be published to production networks, violating the test isolation guarantee.

### Citations

**File:** third_party/move/move-compiler-v2/legacy-move-compiler/src/unit_test/filter_test_members.rs (L47-54)
```rust
        // instrument the test poison
        if !self.env.flags().is_testing() {
            return Some(module_def);
        }

        let poison_function = create_test_poison(module_def.loc);
        module_def.members.push(poison_function);
        Some(module_def)
```

**File:** third_party/move/move-compiler-v2/legacy-move-compiler/src/unit_test/filter_test_members.rs (L165-169)
```rust
/// If a module is being compiled in test mode, create a dummy function that calls a native
/// function `0x1::UnitTest::create_signers_for_testing` that only exists if the VM is being run
/// with the "unit_test" feature flag set. This will then cause the module to fail to link if
/// an attempt is made to publish a module that has been compiled in test mode on a VM that is not
/// running in test mode.
```

**File:** third_party/move/move-compiler-v2/legacy-move-compiler/src/unit_test/filter_test_members.rs (L224-235)
```rust
fn should_remove_node(env: &CompilationEnv, attrs: &[P::Attributes], is_source_def: bool) -> bool {
    use known_attributes::TestingAttribute;
    let flattened_attrs: Vec<_> = attrs.iter().flat_map(test_attributes).collect();
    let is_test_only = flattened_attrs
        .iter()
        .any(|attr| matches!(attr.1, TestingAttribute::Test | TestingAttribute::TestOnly));
    is_test_only && !env.flags().keep_testing_functions()
        || (!is_source_def
            && flattened_attrs
                .iter()
                .any(|attr| attr.1 == TestingAttribute::Test))
}
```

**File:** third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/mod.rs (L438-447)
```rust
    pub fn model_compilation() -> Self {
        Self {
            test: false,
            verify: true,
            shadow: true, // allows overlapping between sources and deps
            keep_testing_functions: true,
            lang_v2: true,
            ..Self::empty()
        }
    }
```

**File:** third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/mod.rs (L474-480)
```rust
    pub fn is_testing(&self) -> bool {
        self.test
    }

    pub fn keep_testing_functions(&self) -> bool {
        self.test || self.keep_testing_functions
    }
```

**File:** third_party/move/move-model/src/lib.rs (L99-109)
```rust
            compile_for_testing: compile_test_code,
            ..ModelBuilderOptions::default()
        },
        Flags::model_compilation()
            .set_warn_of_deprecation_use(warn_of_deprecation_use)
            .set_warn_of_deprecation_use_in_aptos_libs(warn_of_deprecation_use_in_aptos_libs)
            .set_skip_attribute_checks(skip_attribute_checks)
            .set_verify(compile_verify_code)
            .set_keep_testing_functions(compile_test_code)
            .set_language_version(language_version.into()),
        known_attributes,
```

**File:** third_party/move/tools/move-package/src/compilation/compiled_package.rs (L585-589)
```rust
        let mut flags = if resolution_graph.build_options.test_mode {
            Flags::testing()
        } else {
            Flags::empty()
        };
```

**File:** third_party/move/tools/move-package/src/compilation/compiled_package.rs (L664-664)
```rust
                        compile_test_code: flags.keep_testing_functions(),
```

**File:** third_party/move/move-stdlib/src/natives/mod.rs (L79-85)
```rust
            #[cfg(feature = "testing")]
            unit_test: unit_test::GasParameters {
                create_signers_for_testing: unit_test::CreateSignersForTestingGasParameters {
                    base_cost: 0.into(),
                    unit_cost: 0.into(),
                },
            },
```

**File:** third_party/move/move-stdlib/src/natives/mod.rs (L109-112)
```rust
    #[cfg(feature = "testing")]
    {
        add_natives!("unit_test", unit_test::make_all(gas_params.unit_test));
    }
```
