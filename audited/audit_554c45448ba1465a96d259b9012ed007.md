# Audit Report

## Title
Race Condition in OnDiskStorage SecureBackend Can Corrupt Waypoint Data Under Concurrent Access

## Summary
The `OnDiskStorage` implementation lacks file-level locking mechanisms, allowing multiple Storage instances accessing the same file path to trigger lost-update race conditions that can corrupt critical waypoint data. While production configurations typically avoid this pattern, misconfigured nodes or nodes using OnDiskStorage for SafetyRules can experience waypoint corruption leading to consensus failures.

## Finding Description

The vulnerability exists in how `SecureBackend` storage is accessed when using `OnDiskStorage`. 

In [1](#0-0) , the `WaypointConfig::FromStorage` variant creates a **new** `Storage` instance on each call to `waypoint()`. This means multiple invocations create separate Storage objects pointing to the same underlying file.

The `OnDiskStorage` implementation uses a read-modify-write pattern without file locking: [2](#0-1) 

The `set()` operation performs:
1. Read entire file into memory
2. Modify data structure  
3. Write to temp file and atomic rename

The `read()` operation similarly opens, reads, and closes the file without maintaining any locks: [3](#0-2) 

**Race Condition Scenario:**

When SafetyRules storage backend uses the same file path as base config waypoint storage (or multiple threads access waypoint config):

1. Thread A creates Storage instance, calls `read()` to get current waypoint
2. Thread B creates Storage instance, calls `set_waypoint()` which also calls `read()`
3. Thread A completes read, Thread B completes read (both see same state)
4. Thread B modifies in memory, calls `write()` with updated waypoint
5. Thread A modifies different key, calls `write()` - **overwrites Thread B's update**

The atomic `fs::rename()` in [4](#0-3)  prevents partial writes but does NOT prevent lost updates between competing processes/threads.

**Waypoint Usage in Safety Rules:**

The vulnerability is particularly critical because SafetyRules uses waypoint for consensus safety: [5](#0-4) [6](#0-5) 

If waypoint updates are lost during epoch transitions or concurrent safety rules operations, nodes may:
- Use stale waypoints for epoch change verification
- Fail to properly validate epoch proofs
- Diverge on accepted blockchain state

**Existing Awareness:**

The codebase contains a proper file locking implementation for other use cases: [7](#0-6) 

However, OnDiskStorage documentation acknowledges its limitations: [8](#0-7) 

## Impact Explanation

**Severity: Medium**

While waypoint corruption could theoretically cause consensus violations (Critical severity), this issue has several mitigating factors:

1. **Configuration-Dependent**: Default production configurations use file-based waypoint loading, not OnDiskStorage: [9](#0-8) 

2. **Documented Limitation**: The code explicitly states OnDiskStorage is not for production

3. **Limited Attack Surface**: Requires node operator misconfiguration or concurrent access patterns

**Potential Impact:**
- State Consistency invariant violation (corrupted waypoint data)
- Consensus liveness failure (nodes reject valid epoch proofs with stale waypoints)
- Node availability issues (restart failures due to corrupted storage)

This meets **Medium Severity** criteria: "State inconsistencies requiring intervention" rather than Critical as it requires specific deployment patterns and doesn't directly enable fund theft or network-wide consensus breaks.

## Likelihood Explanation

**Likelihood: Low-Medium**

The vulnerability requires:
1. Node configured to use `WaypointConfig::FromStorage` with `OnDiskStorage` backend
2. Concurrent access from multiple threads/processes to the same file
3. Timing overlap during read-modify-write operations

**Factors reducing likelihood:**
- Production configs typically use `from_file` for base waypoint
- SafetyRules uses separate storage file (`secure-data.json`)
- Single-process nodes with RwLock-protected SafetyRules reduce concurrency

**Factors increasing likelihood:**
- Multi-process deployments sharing storage
- Node restarts during active epoch transitions
- Operational scripts modifying storage while node is running

## Recommendation

**Solution 1: Add File Locking to OnDiskStorage**

Implement file-level locking using the existing `fs2` crate (already in dependencies):

```rust
use fs2::FileExt;

impl OnDiskStorage {
    fn read(&self) -> Result<HashMap<String, Value>, Error> {
        let mut file = File::open(&self.file_path)?;
        file.lock_shared()?; // Acquire shared read lock
        let mut contents = String::new();
        file.read_to_string(&mut contents)?;
        file.unlock()?;
        // ... rest of implementation
    }

    fn write(&self, data: &HashMap<String, Value>) -> Result<(), Error> {
        let contents = serde_json::to_vec(data)?;
        let mut file = File::create(self.temp_path.path())?;
        file.lock_exclusive()?; // Acquire exclusive write lock
        file.write_all(&contents)?;
        fs::rename(&self.temp_path, &self.file_path)?;
        // Lock automatically released on drop
        Ok(())
    }
}
```

**Solution 2: Strengthen Documentation and Add Runtime Checks**

If OnDiskStorage remains test-only, add runtime checks to prevent production usage:

```rust
impl OnDiskStorage {
    pub fn new(file_path: PathBuf) -> Self {
        #[cfg(not(test))]
        warn!("OnDiskStorage is not recommended for production use. Use Vault or other secure backends.");
        
        // ... existing implementation
    }
}
```

**Solution 3: Cache Storage Instance in WaypointConfig**

Instead of creating new Storage instances on each `waypoint()` call, cache a single instance with proper synchronization.

## Proof of Concept

```rust
// Reproduction test demonstrating the race condition
#[test]
fn test_ondisk_storage_race_condition() {
    use std::sync::Arc;
    use std::thread;
    use aptos_secure_storage::{KVStorage, OnDiskStorage};
    use aptos_temppath::TempPath;
    
    let temp_path = TempPath::new();
    temp_path.create_as_file().unwrap();
    let path = temp_path.path().to_path_buf();
    
    // Simulate two threads accessing same storage file
    let path1 = path.clone();
    let path2 = path.clone();
    
    let handle1 = thread::spawn(move || {
        let mut storage = OnDiskStorage::new(path1);
        for i in 0..100 {
            storage.set(&format!("key1_{}", i), i).unwrap();
        }
    });
    
    let handle2 = thread::spawn(move || {
        let mut storage = OnDiskStorage::new(path2);
        for i in 0..100 {
            storage.set(&format!("key2_{}", i), i).unwrap();
        }
    });
    
    handle1.join().unwrap();
    handle2.join().unwrap();
    
    // Verify: some writes will be lost due to race condition
    let storage = OnDiskStorage::new(path);
    let mut found_key1 = 0;
    let mut found_key2 = 0;
    
    for i in 0..100 {
        if storage.get::<i32>(&format!("key1_{}", i)).is_ok() {
            found_key1 += 1;
        }
        if storage.get::<i32>(&format!("key2_{}", i)).is_ok() {
            found_key2 += 1;
        }
    }
    
    // Without locking, not all writes will be present
    println!("Found key1 entries: {}/100", found_key1);
    println!("Found key2 entries: {}/100", found_key2);
    assert!(found_key1 < 100 || found_key2 < 100, "Race condition should cause data loss");
}
```

## Notes

**Key Observations:**

1. The vulnerability is real and present in the codebase, but production deployments are configured to avoid it by default

2. SafetyRules uses OnDiskStorage in production configs, but maintains a single Storage instance protected by RwLock: [10](#0-9) 

3. The codebase already has appropriate file locking patterns for critical operations (package cache), indicating this could be fixed similarly

4. The atomic rename in `write()` prevents reading partial writes but does not prevent lost updates in concurrent write scenarios

**Mitigation Status:**
- Default configs minimize risk by using file-based waypoint loading
- Runtime protection via RwLock around SafetyRules reduces concurrent access
- Documentation warns against production use

**Recommendation Priority:** Medium - Should be fixed to prevent misconfiguration issues, but not an immediate critical threat given current deployment patterns.

### Citations

**File:** config/src/config/base_config.rs (L99-106)
```rust
            WaypointConfig::FromStorage(backend) => {
                let storage: Storage = backend.into();
                let waypoint = storage
                    .get::<Waypoint>(aptos_global_constants::WAYPOINT)
                    .expect("Unable to read waypoint")
                    .value;
                Some(waypoint)
            },
```

**File:** secure/storage/src/on_disk.rs (L16-22)
```rust
/// OnDiskStorage represents a key value store that is persisted to the local filesystem and is
/// intended for single threads (or must be wrapped by a Arc<RwLock<>>). This provides no permission
/// checks and simply offers a proof of concept to unblock building of applications without more
/// complex data stores. Internally, it reads and writes all data to a file, which means that it
/// must make copies of all key material which violates the code base. It violates it because
/// the anticipation is that data stores would securely handle key material. This should not be used
/// in production.
```

**File:** secure/storage/src/on_disk.rs (L53-62)
```rust
    fn read(&self) -> Result<HashMap<String, Value>, Error> {
        let mut file = File::open(&self.file_path)?;
        let mut contents = String::new();
        file.read_to_string(&mut contents)?;
        if contents.is_empty() {
            return Ok(HashMap::new());
        }
        let data = serde_json::from_str(&contents)?;
        Ok(data)
    }
```

**File:** secure/storage/src/on_disk.rs (L64-70)
```rust
    fn write(&self, data: &HashMap<String, Value>) -> Result<(), Error> {
        let contents = serde_json::to_vec(data)?;
        let mut file = File::create(self.temp_path.path())?;
        file.write_all(&contents)?;
        fs::rename(&self.temp_path, &self.file_path)?;
        Ok(())
    }
```

**File:** secure/storage/src/on_disk.rs (L85-93)
```rust
    fn set<V: Serialize>(&mut self, key: &str, value: V) -> Result<(), Error> {
        let now = self.time_service.now_secs();
        let mut data = self.read()?;
        data.insert(
            key.to_string(),
            serde_json::to_value(GetResponse::new(value, now))?,
        );
        self.write(&data)
    }
```

**File:** consensus/safety-rules/src/persistent_safety_storage.rs (L172-175)
```rust
    pub fn waypoint(&self) -> Result<Waypoint, Error> {
        let _timer = counters::start_timer("get", WAYPOINT);
        Ok(self.internal_store.get(WAYPOINT).map(|v| v.value)?)
    }
```

**File:** consensus/safety-rules/src/persistent_safety_storage.rs (L177-185)
```rust
    pub fn set_waypoint(&mut self, waypoint: &Waypoint) -> Result<(), Error> {
        let _timer = counters::start_timer("set", WAYPOINT);
        counters::set_state(counters::WAYPOINT_VERSION, waypoint.version() as i64);
        self.internal_store.set(WAYPOINT, waypoint)?;
        info!(
            logging::SafetyLogSchema::new(LogEntry::Waypoint, LogEvent::Update).waypoint(*waypoint)
        );
        Ok(())
    }
```

**File:** third_party/move/tools/move-package-cache/src/file_lock.rs (L15-22)
```rust
/// A file-based lock to ensure exclusive access to certain resources.
///
/// This is used by the package cache to ensure only one process can mutate a cached repo, checkout,
/// or on-chain package at a time.
pub struct FileLock {
    file: Option<File>,
    path: PathBuf,
}
```

**File:** terraform/helm/aptos-node/files/configs/validator-base.yaml (L5-8)
```yaml
base:
  role: validator
  waypoint:
    from_file: /opt/aptos/genesis/waypoint.txt
```

**File:** consensus/safety-rules/src/safety_rules_manager.rs (L131-136)
```rust
    pub fn new_local(storage: PersistentSafetyStorage) -> Self {
        let safety_rules = SafetyRules::new(storage, true);
        Self {
            internal_safety_rules: SafetyRulesWrapper::Local(Arc::new(RwLock::new(safety_rules))),
        }
    }
```
