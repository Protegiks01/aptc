# Audit Report

## Title
Zero Gas Schedule Governance Attack Enabling Complete Economic Breakdown

## Summary
The gas schedule update mechanism lacks validation of gas parameter values, allowing a malicious governance proposal to set all gas costs to zero. This would enable unlimited free operations, causing complete economic breakdown and network resource exhaustion.

## Finding Description

The Aptos gas schedule system provides a `zeros()` function that creates gas parameters with all values set to zero. While intended for testing, the governance proposal system lacks validation to prevent a zero gas schedule from being deployed on-chain. [1](#0-0) 

The gas schedule loading mechanism starts with a `zeros()` base and overwrites values from the on-chain schedule: [2](#0-1) 

The Move governance module explicitly documents missing validation with TODO comments: [3](#0-2) 

The only validation checks are:
1. Gas schedule blob is non-empty
2. Feature version doesn't decrease [4](#0-3) 

During transaction execution, gas charging subtracts zero from the balance and all limit checks pass since both used and max values are zero: [5](#0-4) 

The validation in `check_gas` would require transactions to have `max_gas_amount=0` (since `maximum_number_of_gas_units` would be 0), but intrinsic gas would also be zero, allowing this: [6](#0-5) 

## Impact Explanation

This vulnerability achieves **Critical Severity** under multiple categories:

1. **Complete Economic Breakdown**: All transaction fees become zero, destroying the fee market and validator incentives
2. **Total Loss of Liveness**: Unlimited free operations enable network-wide DoS through transaction spam
3. **State Bloat Attacks**: Attackers can create unlimited storage entries for free, exhausting node resources
4. **Consensus Impact**: While validators maintain consensus on the zero gas schedule, the network becomes unusable

This breaks critical invariants:
- **Resource Limits**: "All operations must respect gas, storage, and computational limits" - violated completely
- **Move VM Safety**: "Bytecode execution must respect gas limits" - zero limits disable all protection

## Likelihood Explanation

**Likelihood: Low** but **Impact: Critical** = **Overall Severity: Medium to High**

The attack requires:
1. Creating a governance proposal with a zero gas schedule (technically trivial)
2. Obtaining >50% voting power to pass the proposal (difficult, requires validator collusion or compromise)
3. Executing the proposal and waiting for next epoch

While this falls under governance-based attacks, it differs from a pure "51% attack" because:
- It exploits a **missing validation bug**, not game-theoretic assumptions
- A single compromised governance key or bug in proposal generation could trigger it
- Social engineering of validators who don't review technical details is possible
- Once deployed, recovery requires a hard fork

The TODO comments confirm this is a **known missing feature**, not intentional design.

## Recommendation

**Immediate Fix:** Add comprehensive validation in the gas schedule module:

```move
// In gas_schedule.move, add after line 93:
fun validate_gas_schedule(gas_schedule: &GasScheduleV2) {
    let i = 0;
    let len = vector::length(&gas_schedule.entries);
    
    // Check critical parameters are non-zero
    let critical_params = vector[
        b"txn.maximum_number_of_gas_units",
        b"txn.max_execution_gas",
        b"txn.max_io_gas",
        b"txn.min_price_per_gas_unit",
        b"instr.nop", // Basic instruction cost
    ];
    
    while (i < len) {
        let entry = vector::borrow(&gas_schedule.entries, i);
        let key = &entry.key;
        let val = entry.val;
        
        if (vector::contains(&critical_params, key)) {
            assert!(val > 0, error::invalid_argument(EINVALID_GAS_SCHEDULE));
        };
        i = i + 1;
    };
}

// Call in set_for_next_epoch after line 94:
validate_gas_schedule(&new_gas_schedule);
```

**Additional Safeguards:**
1. Implement Rust-side validation when loading gas parameters
2. Add governance proposal review requirements for gas schedule changes
3. Implement rate limiting on gas schedule updates
4. Add monitoring alerts for suspicious gas parameter changes

## Proof of Concept

```rust
// Test demonstrating zero gas schedule acceptance
#[test]
fn test_zero_gas_schedule_accepted() {
    use aptos_gas_schedule::{AptosGasParameters, ToOnChainGasSchedule};
    use aptos_types::on_chain_config::GasScheduleV2;
    
    // Create a zero gas schedule
    let zero_params = AptosGasParameters::zeros();
    let entries = zero_params.to_on_chain_gas_schedule(LATEST_GAS_FEATURE_VERSION);
    
    // All entries should be zero
    for (key, val) in &entries {
        assert_eq!(*val, 0, "Parameter {} should be zero", key);
    }
    
    // This gas schedule would be accepted by the Move module since:
    // 1. The blob is non-empty (passes check at line 93)
    // 2. It deserializes successfully
    // 3. No validation checks the actual values
    let gas_schedule = GasScheduleV2 {
        feature_version: LATEST_GAS_FEATURE_VERSION,
        entries,
    };
    
    // Serialize to blob format that would be passed to governance
    let blob = bcs::to_bytes(&gas_schedule).unwrap();
    assert!(!blob.is_empty()); // Passes the only validation
    
    // In production, this would be accepted by set_for_next_epoch()
    // and applied at the next epoch, enabling free operations
}
```

## Notes

The vulnerability exists at the intersection of:
1. **Missing validation** in the gas schedule governance module (confirmed by TODO comments)
2. **Permissive loading logic** that accepts any values including zero
3. **Arithmetic properties** where zero costs bypass all limit checks

While exploitation requires governance control, this represents a **defense-in-depth failure**: critical system parameters should have invariant validation regardless of the threat model assumptions about governance participants.

### Citations

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/mod.rs (L68-73)
```rust
    pub fn zeros() -> Self {
        Self {
            vm: VMGasParameters::zeros(),
            natives: NativeGasParameters::zeros(),
        }
    }
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/macros.rs (L34-45)
```rust
            fn from_on_chain_gas_schedule(gas_schedule: &std::collections::BTreeMap<String, u64>, feature_version: u64) -> Result<Self, String> {
                let mut params = $params_name::zeros();

                $(
                    if let Some(key) = $crate::gas_schedule::macros::define_gas_parameters_extract_key_at_version!($key_bindings, feature_version) {
                        let name = format!("{}.{}", $prefix, key);
                        params.$name = gas_schedule.get(&name).cloned().ok_or_else(|| format!("Gas parameter {} does not exist. Feature version: {}.", name, feature_version))?.into();
                    }
                )*

                Ok(params)
            }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L43-49)
```text
    public(friend) fun initialize(aptos_framework: &signer, gas_schedule_blob: vector<u8>) {
        system_addresses::assert_aptos_framework(aptos_framework);
        assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));

        // TODO(Gas): check if gas schedule is consistent
        let gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
        move_to<GasScheduleV2>(aptos_framework, gas_schedule);
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L91-103)
```text
    public fun set_for_next_epoch(aptos_framework: &signer, gas_schedule_blob: vector<u8>) acquires GasScheduleV2 {
        system_addresses::assert_aptos_framework(aptos_framework);
        assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));
        let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
        if (exists<GasScheduleV2>(@aptos_framework)) {
            let cur_gas_schedule = borrow_global<GasScheduleV2>(@aptos_framework);
            assert!(
                new_gas_schedule.feature_version >= cur_gas_schedule.feature_version,
                error::invalid_argument(EINVALID_GAS_FEATURE_VERSION)
            );
        };
        config_buffer::upsert(new_gas_schedule);
    }
```

**File:** aptos-move/aptos-gas-meter/src/algebra.rs (L173-208)
```rust
    fn charge_execution(
        &mut self,
        abstract_amount: impl GasExpression<VMGasParameters, Unit = InternalGasUnit> + Debug,
    ) -> PartialVMResult<()> {
        self.counter_for_kill_switch += 1;
        if self.counter_for_kill_switch & 3 == 0
            && self.block_synchronization_kill_switch.interrupt_requested()
        {
            return Err(
                PartialVMError::new(StatusCode::SPECULATIVE_EXECUTION_ABORT_ERROR)
                    .with_message("Interrupted from block synchronization view".to_string()),
            );
        }

        let amount = abstract_amount.evaluate(self.feature_version, &self.vm_gas_params);

        match self.balance.checked_sub(amount) {
            Some(new_balance) => {
                self.balance = new_balance;
                self.execution_gas_used += amount;
            },
            None => {
                let old_balance = self.balance;
                self.balance = 0.into();
                if self.feature_version >= 12 {
                    self.execution_gas_used += old_balance;
                }
                return Err(PartialVMError::new(StatusCode::OUT_OF_GAS));
            },
        };

        if self.feature_version >= 7 && self.execution_gas_used > self.max_execution_gas {
            Err(PartialVMError::new(StatusCode::EXECUTION_LIMIT_REACHED))
        } else {
            Ok(())
        }
```

**File:** aptos-move/aptos-vm/src/gas.rs (L126-172)
```rust
    if txn_metadata.max_gas_amount() > txn_gas_params.maximum_number_of_gas_units {
        speculative_warn!(
            log_context,
            format!(
                "[VM] Gas unit error; max {}, submitted {}",
                txn_gas_params.maximum_number_of_gas_units,
                txn_metadata.max_gas_amount()
            ),
        );
        return Err(VMStatus::error(
            StatusCode::MAX_GAS_UNITS_EXCEEDS_MAX_GAS_UNITS_BOUND,
            None,
        ));
    }

    // The submitted transactions max gas units needs to be at least enough to cover the
    // intrinsic cost of the transaction as calculated against the size of the
    // underlying `RawTransaction`.
    let keyless = if txn_metadata.is_keyless() {
        KEYLESS_BASE_COST.evaluate(gas_feature_version, &gas_params.vm)
    } else {
        InternalGas::zero()
    };
    let slh_dsa_sha2_128s = if txn_metadata.is_slh_dsa_sha2_128s() {
        SLH_DSA_SHA2_128S_BASE_COST.evaluate(gas_feature_version, &gas_params.vm)
    } else {
        InternalGas::zero()
    };
    let intrinsic_gas = txn_gas_params
        .calculate_intrinsic_gas(raw_bytes_len)
        .evaluate(gas_feature_version, &gas_params.vm);
    let total_rounded: Gas =
        (intrinsic_gas + keyless + slh_dsa_sha2_128s).to_unit_round_up_with_params(txn_gas_params);
    if txn_metadata.max_gas_amount() < total_rounded {
        speculative_warn!(
            log_context,
            format!(
                "[VM] Gas unit error; min {}, submitted {}",
                total_rounded,
                txn_metadata.max_gas_amount()
            ),
        );
        return Err(VMStatus::error(
            StatusCode::MAX_GAS_UNITS_BELOW_MIN_TRANSACTION_GAS_UNITS,
            None,
        ));
    }
```
