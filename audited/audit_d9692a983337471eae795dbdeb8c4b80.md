# Audit Report

## Title
Consensus Split Vulnerability via Silent Configuration Fallback During Epoch Transitions

## Summary
When `OnChainConsensusConfig` deserialization fails during epoch transitions, validators silently fall back to incompatible default configurations, causing them to generate different `LedgerInfo` signatures that cannot be aggregated, resulting in a complete consensus split and network partition.

## Finding Description

The vulnerability exists in the epoch initialization logic where on-chain consensus configuration parsing failures are handled with a silent fallback to default values. [1](#0-0) 

When `payload.get()` fails to deserialize `OnChainConsensusConfig`, the code only logs a warning and falls back to `OnChainConsensusConfig::default()`. The critical issue is that the default configuration has fundamentally incompatible consensus parameters compared to typical on-chain configurations. [2](#0-1) 

The default implementation sets `order_vote_enabled = false` through `ConsensusAlgorithmConfig::default_if_missing()`: [3](#0-2) 

However, genesis configurations and most production networks use `order_vote_enabled = true`: [4](#0-3) 

The `order_vote_enabled` flag fundamentally changes how validators generate commit ledger information. When creating commit votes, the consensus data hash is set differently: [5](#0-4) 

This creates distinct `LedgerInfo` objects with different `consensus_data_hash` values, which affects the cryptographic hash of the entire structure: [6](#0-5) 

When validators attempt to aggregate signatures, the `SignatureAggregator` verifies signatures against the specific `LedgerInfo` hash: [7](#0-6) 

**Exploitation Path:**

1. Network operates with `OnChainConsensusConfig::V5` containing `order_vote_enabled = true`
2. During a rolling upgrade, some validators run older binaries that only understand V1-V4
3. Epoch transition occurs, triggering `start_new_epoch()`
4. Updated validators successfully parse V5 → use `order_vote_enabled = true`
5. Older validators fail to deserialize V5 → fall back to default → use `order_vote_enabled = false`
6. When voting on blocks:
   - Group A creates `LedgerInfo` with `consensus_data_hash = HashValue::zero()`
   - Group B creates `LedgerInfo` with `consensus_data_hash = <actual hash>`
7. Validators sign different `LedgerInfo` hashes
8. Signature aggregation fails - no group can reach 2f+1 quorum
9. **Consensus completely stalls → network partition**

This same pattern exists in multiple components: [8](#0-7) 

## Impact Explanation

**Critical Severity** - This vulnerability satisfies multiple Critical severity criteria from the Aptos bug bounty:

1. **Consensus/Safety Violations**: Breaks the fundamental AptosBFT safety invariant that all honest validators must agree on the same blocks
2. **Non-recoverable Network Partition**: Validators cannot aggregate signatures across the split, requiring hardfork intervention to recover
3. **Total Loss of Liveness**: Once the split occurs, no new blocks can be committed as neither group reaches 2f+1 quorum

The vulnerability violates the "Deterministic Execution" and "Consensus Safety" invariants - validators processing identical on-chain state reach incompatible consensus states.

## Likelihood Explanation

**High Likelihood** during normal network operations:

1. **Rolling Upgrades**: Standard operational practice where validators upgrade binaries gradually
2. **Configuration Evolution**: The codebase shows 5 config versions (V1-V5), indicating active evolution
3. **No Failure Detection**: Silent fallback means operators have no visibility into the misconfiguration until consensus fails
4. **BCS Deserialization Strictness**: Binary serialization fails completely on unknown enum variants rather than gracefully degrading

The double-BCS deserialization requirement increases fragility: [9](#0-8) 

## Recommendation

**Immediate Fix**: Validators MUST NOT continue operation with incompatible consensus configurations. Replace silent fallback with consensus-critical assertion:

```rust
let consensus_config = onchain_consensus_config.unwrap_or_else(|e| {
    error!("CRITICAL: Failed to parse on-chain consensus config: {}", e);
    panic!(
        "Cannot start epoch {} with unparseable consensus config. \
         This validator's binary may be incompatible with the on-chain configuration. \
         Upgrade required before participating in consensus.",
        epoch_state.epoch
    );
});
```

**Additional Safeguards**:

1. **Version Compatibility Checks**: Add explicit version range validation before epoch transitions
2. **Configuration Validation**: Verify critical consensus parameters (like `order_vote_enabled`) match expected network state
3. **Pre-flight Checks**: Governance proposals that update consensus config should validate all active validators can parse the new config
4. **Monitoring**: Add metrics for config parsing failures to detect issues before epoch boundary

## Proof of Concept

**Reproduction Steps**:

1. Initialize network with `OnChainConsensusConfig::V5` (order_vote_enabled=true)
2. Deploy validator subset running binary compiled with only V1-V4 support (simulate by modifying enum)
3. Trigger epoch transition via governance or natural epoch boundary
4. Observe in logs:
   - New validators: Successfully parse config
   - Old validators: "Failed to read on-chain consensus config" warning
5. Monitor consensus:
   - Validators create incompatible `LedgerInfo` objects
   - Signature aggregation fails with voting power errors
   - Network cannot commit new blocks
   - Consensus permanently stalled

**Verification**:

Compare `LedgerInfo` hashes generated by validators in each group - they will be cryptographically distinct despite voting on the same block, proving the consensus split.

### Citations

**File:** consensus/src/epoch_manager.rs (L1178-1201)
```rust
        let onchain_consensus_config: anyhow::Result<OnChainConsensusConfig> = payload.get();
        let onchain_execution_config: anyhow::Result<OnChainExecutionConfig> = payload.get();
        let onchain_randomness_config_seq_num: anyhow::Result<RandomnessConfigSeqNum> =
            payload.get();
        let randomness_config_move_struct: anyhow::Result<RandomnessConfigMoveStruct> =
            payload.get();
        let onchain_jwk_consensus_config: anyhow::Result<OnChainJWKConsensusConfig> = payload.get();
        let dkg_state = payload.get::<DKGState>();

        if let Err(error) = &onchain_consensus_config {
            warn!("Failed to read on-chain consensus config {}", error);
        }

        if let Err(error) = &onchain_execution_config {
            warn!("Failed to read on-chain execution config {}", error);
        }

        if let Err(error) = &randomness_config_move_struct {
            warn!("Failed to read on-chain randomness config {}", error);
        }

        self.epoch_state = Some(epoch_state.clone());

        let consensus_config = onchain_consensus_config.unwrap_or_default();
```

**File:** types/src/on_chain_config/consensus_config.rs (L30-36)
```rust
    pub fn default_for_genesis() -> Self {
        Self::JolteonV2 {
            main: ConsensusConfigV1::default(),
            quorum_store_enabled: true,
            order_vote_enabled: true,
        }
    }
```

**File:** types/src/on_chain_config/consensus_config.rs (L46-52)
```rust
    pub fn default_if_missing() -> Self {
        Self::JolteonV2 {
            main: ConsensusConfigV1::default(),
            quorum_store_enabled: true,
            order_vote_enabled: false,
        }
    }
```

**File:** types/src/on_chain_config/consensus_config.rs (L443-450)
```rust
impl Default for OnChainConsensusConfig {
    fn default() -> Self {
        OnChainConsensusConfig::V4 {
            alg: ConsensusAlgorithmConfig::default_if_missing(),
            vtxn: ValidatorTxnConfig::default_if_missing(),
            window_size: DEFAULT_WINDOW_SIZE,
        }
    }
```

**File:** types/src/on_chain_config/consensus_config.rs (L464-468)
```rust
    fn deserialize_into_config(bytes: &[u8]) -> Result<Self> {
        let raw_bytes: Vec<u8> = bcs::from_bytes(bytes)?;
        bcs::from_bytes(&raw_bytes)
            .map_err(|e| format_err!("[on-chain config] Failed to deserialize into config: {}", e))
    }
```

**File:** consensus/src/pipeline/buffer_item.rs (L25-38)
```rust
fn generate_commit_ledger_info(
    commit_info: &BlockInfo,
    ordered_proof: &LedgerInfoWithSignatures,
    order_vote_enabled: bool,
) -> LedgerInfo {
    LedgerInfo::new(
        commit_info.clone(),
        if order_vote_enabled {
            HashValue::zero()
        } else {
            ordered_proof.ledger_info().consensus_data_hash()
        },
    )
}
```

**File:** types/src/ledger_info.rs (L51-59)
```rust
#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize, CryptoHasher, BCSCryptoHash)]
#[cfg_attr(any(test, feature = "fuzzing"), derive(Arbitrary))]
pub struct LedgerInfo {
    commit_info: BlockInfo,

    /// Hash of consensus specific data that is opaque to all parts of the system other than
    /// consensus.
    consensus_data_hash: HashValue,
}
```

**File:** types/src/ledger_info.rs (L517-535)
```rust
    pub fn aggregate_and_verify(
        &mut self,
        verifier: &ValidatorVerifier,
    ) -> Result<(T, AggregateSignature), VerifyError> {
        let aggregated_sig = self.try_aggregate(verifier)?;

        match verifier.verify_multi_signatures(&self.data, &aggregated_sig) {
            Ok(_) => {
                // We are not marking all the signatures as "verified" here, as two malicious
                // voters can collude and create a valid aggregated signature.
                Ok((self.data.clone(), aggregated_sig))
            },
            Err(_) => {
                self.filter_invalid_signatures(verifier);

                let aggregated_sig = self.try_aggregate(verifier)?;
                Ok((self.data.clone(), aggregated_sig))
            },
        }
```

**File:** consensus/src/consensus_observer/observer/epoch_state.rs (L157-166)
```rust
    let onchain_consensus_config: anyhow::Result<OnChainConsensusConfig> = on_chain_configs.get();
    if let Err(error) = &onchain_consensus_config {
        error!(
            LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                "Failed to read on-chain consensus config! Error: {:?}",
                error
            ))
        );
    }
    let consensus_config = onchain_consensus_config.unwrap_or_default();
```
