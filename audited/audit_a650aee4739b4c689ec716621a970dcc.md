# Audit Report

## Title
Telemetry Service ValidatorSet Response Tampering - No Cryptographic Verification Enables Validator Impersonation

## Summary
The telemetry service's `update_for_chain()` function retrieves the ValidatorSet from a REST API endpoint without any cryptographic verification beyond TLS. This allows a MITM attacker (via HTTP configuration, TLS compromise, DNS poisoning, or compromised "trusted" full node) to inject malicious validator public keys into the authentication cache, enabling unauthorized actors to authenticate as legitimate validators and poison telemetry data.

## Finding Description

The vulnerability exists in the telemetry service's validator cache updater mechanism. The service is designed to authenticate validators and validator fullnodes by maintaining a cache of legitimate validator public keys, which it fetches periodically from a configured "trusted full node" via REST API.

**The Critical Flaw**: The REST API response containing the ValidatorSet is not cryptographically verified at the application level. The system relies exclusively on TLS for transport security, with no state proofs, Merkle proofs, or signature verification of the validator set data itself. [1](#0-0) 

The `update_for_chain()` function creates a REST client and calls `get_account_resource_bcs()` to retrieve the ValidatorSet from the on-chain resource at `0x1::stake::ValidatorSet`. The response is then directly used without verification: [2](#0-1) 

The REST client implementation shows no cryptographic verification is performed: [3](#0-2) [4](#0-3) 

The response parsing only extracts HTTP headers without any signature verification: [5](#0-4) 

The REST API endpoint itself returns raw data from the local database without including state proofs: [6](#0-5) 

**Attack Path**:

1. **Configuration Accepts HTTP**: The system accepts both HTTP and HTTPS URLs in configuration, with no enforcement: [7](#0-6) 

2. **MITM Attack**: An attacker intercepts the REST API request through:
   - Direct MITM if HTTP is configured
   - TLS compromise (malicious CA, corporate interception proxy, compromised certificates)
   - DNS poisoning to redirect to attacker-controlled server
   - Compromising the "trusted full node" itself

3. **Validator Set Injection**: Attacker modifies the ValidatorSet response to include their own public keys alongside or replacing legitimate validator keys

4. **Authentication Bypass**: The tampered validator set is cached and used for authentication: [8](#0-7) 

5. **JWT Token Issuance**: The attacker authenticates using their injected keys and receives JWT tokens with validator privileges: [9](#0-8) 

6. **Impact**: The attacker can now send telemetry data that appears to originate from legitimate validators, poisoning monitoring systems, triggering false alerts, or affecting operational decisions based on telemetry.

## Impact Explanation

**Severity: CRITICAL** (per Aptos Bug Bounty criteria)

This vulnerability qualifies as Critical severity because:

1. **Authentication Bypass**: It completely circumvents the validator authentication mechanism of the telemetry service, violating the Access Control invariant that requires protected system components to verify identities cryptographically.

2. **Validator Impersonation**: Attackers can impersonate legitimate validators without compromising validator keys or infrastructure, enabling them to inject malicious telemetry data into monitoring systems.

3. **Security Monitoring Compromise**: The telemetry service is a critical security and operational component that collects metrics, logs, and events from validators. Poisoning this data can:
   - Mask real security incidents by injecting fake "healthy" metrics
   - Trigger false alerts causing operational chaos
   - Manipulate validator reputation systems if they rely on telemetry data
   - Provide false security assurances to operators

4. **Network-Wide Impact**: This affects ALL validators that rely on the compromised telemetry service, as it serves the entire network, making it a single point of failure for authentication integrity.

While this doesn't directly lead to consensus violations or fund theft, it represents a **Significant Protocol Violation** affecting authentication and access control across the validator network. Under the bug bounty program, authentication bypasses that allow impersonation of privileged actors in critical infrastructure components qualify for Critical severity consideration.

## Likelihood Explanation

**Likelihood: MEDIUM to HIGH**

The likelihood is elevated due to multiple realistic attack vectors:

1. **Misconfiguration Risk**: Operators may accidentally configure HTTP URLs for testing/development and forget to switch to HTTPS in production (as shown in the test configuration example).

2. **Enterprise Environments**: Many enterprise deployments use TLS interception proxies for security monitoring, making TLS compromise a realistic scenario.

3. **Certificate Trust Issues**: Operators must trust the entire certificate chain of the "trusted full node", and compromised certificate authorities remain a real threat vector.

4. **DNS Attacks**: DNS poisoning or cache poisoning attacks could redirect the telemetry service to an attacker-controlled endpoint without the operator's knowledge.

5. **Supply Chain**: If the "trusted full node" itself is compromised (e.g., through infrastructure breaches or malicious operators), it can serve tampered validator sets directly.

The attack requires either:
- Network position for MITM (moderate difficulty)
- DNS compromise (moderate difficulty)  
- TLS compromise (difficult but possible)
- Full node compromise (difficult)

The lack of defense-in-depth (no application-level verification) means a single-point compromise enables the full attack.

## Recommendation

**Implement Application-Level Cryptographic Verification using State Proofs**

The telemetry service should verify ValidatorSet data using the same state proof mechanism available in the storage layer:

1. **Extend REST API** to return state proofs with account resources:
   - Add `get_account_resource_with_proof` endpoint that returns both the resource and its SparseMerkleProofExt
   - Include LedgerInfoWithSignatures in the response for epoch verification

2. **Implement Proof Verification in Telemetry Service**:
```rust
// In validator_cache.rs update_for_chain()
async fn update_for_chain(
    &self,
    chain_name: &ChainCommonName,
    url: &str,
) -> Result<(), ValidatorCacheUpdateError> {
    let client = aptos_rest_client::Client::new(Url::parse(url)?);
    
    // Request resource WITH proof
    let (validator_set, proof, ledger_info_with_sigs) = client
        .get_account_resource_with_proof_bcs(
            CORE_CODE_ADDRESS, 
            "0x1::stake::ValidatorSet"
        )
        .await?;
    
    // Verify the proof against trusted validator set
    // (bootstrap from genesis or previous verified epoch)
    let verifier = self.get_or_bootstrap_verifier(chain_id)?;
    
    // Verify ledger info signatures
    ledger_info_with_sigs.verify_signatures(&verifier)?;
    
    // Verify state proof
    proof.verify(
        ledger_info_with_sigs.ledger_info().state_root(),
        StateKey::account_resource(CORE_CODE_ADDRESS, ValidatorSet::struct_tag()),
        Some(&bcs::to_bytes(&validator_set)?)
    )?;
    
    // Only use verified data
    // ... rest of caching logic
}
```

3. **Enforce HTTPS**: Add configuration validation to reject non-HTTPS URLs in production builds:
```rust
if !url.starts_with("https://") && !cfg!(test) {
    return Err(ValidatorCacheUpdateError::InsecureUrl);
}
```

4. **Certificate Pinning**: Consider implementing certificate pinning for well-known Aptos Labs endpoints to prevent CA compromise.

5. **Fallback Mechanism**: Maintain multiple trusted full nodes and cross-verify responses for defense-in-depth.

## Proof of Concept

```rust
// Test demonstrating unverified validator set injection
// File: crates/aptos-telemetry-service/src/validator_cache.rs (add to tests module)

#[tokio::test]
async fn test_validator_set_tampering_via_mitm() {
    use aptos_crypto::{bls12381::{PrivateKey, PublicKey}, test_utils::KeyPair, Uniform};
    use aptos_types::{
        validator_config::ValidatorConfig, 
        validator_info::ValidatorInfo,
        on_chain_config::ValidatorSet,
        PeerId,
    };
    use httpmock::MockServer;
    use rand_core::OsRng;

    let mut rng = OsRng;
    
    // Create legitimate validator
    let legit_keypair = KeyPair::<PrivateKey, PublicKey>::generate(&mut rng);
    let legit_peer_id = PeerId::random();
    let legit_validator = ValidatorInfo::new(
        legit_peer_id,
        100,
        ValidatorConfig::new(
            legit_keypair.public_key,
            vec![0, 1], // valid addresses
            vec![0, 1],
            1,
        ),
    );
    
    // Create attacker's validator with malicious keys
    let attacker_keypair = KeyPair::<PrivateKey, PublicKey>::generate(&mut rng);
    let attacker_peer_id = PeerId::random();
    let attacker_validator = ValidatorInfo::new(
        attacker_peer_id,
        100,
        ValidatorConfig::new(
            attacker_keypair.public_key,
            vec![1, 2], // attacker addresses
            vec![1, 2],
            1,
        ),
    );
    
    // MITM attacker injects both validators
    let tampered_set = ValidatorSet::new(vec![
        legit_validator.clone(),
        attacker_validator.clone(), // INJECTED
    ]);

    // Mock server simulates MITM or compromised full node
    let server = MockServer::start();
    server.mock(|when, then| {
        when.method("GET")
            .path("/v1/accounts/0000000000000000000000000000000000000000000000000000000000000001/resource/0x1::stake::ValidatorSet");
        then.status(200)
            .body(bcs::to_bytes(&tampered_set).unwrap())
            .header(X_APTOS_CHAIN_ID, "4")
            .header(X_APTOS_EPOCH, "10")
            .header(X_APTOS_LEDGER_VERSION, "100");
    });

    let mut fullnodes = HashMap::new();
    fullnodes.insert("testnet".into(), server.base_url());

    let updater = PeerSetCacheUpdater::new(
        Arc::new(RwLock::new(HashMap::new())),
        Arc::new(RwLock::new(HashMap::new())),
        fullnodes,
        Duration::from_secs(10),
    );

    // Execute the vulnerable update
    updater.update().await;

    // VULNERABILITY DEMONSTRATED: Attacker's keys are now cached
    let cached_validators = updater.validators.read();
    let (_, peer_set) = cached_validators.get(&ChainId::new(4)).unwrap();
    
    // Attacker can now authenticate as this peer
    assert!(peer_set.contains_key(&attacker_peer_id));
    assert!(peer_set.contains_key(&legit_peer_id));
    
    println!("VULNERABILITY: Tampered validator set accepted without verification!");
    println!("Attacker peer ID {} cached alongside legitimate validators", attacker_peer_id);
}
```

## Notes

This vulnerability represents a critical gap in the defense-in-depth strategy. While TLS provides transport security, blockchain systems should never rely solely on TLS for critical authentication data. The Aptos storage layer already implements state proofs and Merkle verification for exactly this purpose, but this capability is not exposed through the REST API or utilized by the telemetry service.

The fix requires coordinated changes across:
1. Storage layer (already has proof generation)
2. REST API (expose proof-enabled endpoints)
3. REST client library (add proof verification methods)
4. Telemetry service (implement verification logic)

This is a defense-in-depth failure rather than a cryptographic weakness, but the security impact is severe given the telemetry service's role in validator authentication and network monitoring.

### Citations

**File:** crates/aptos-telemetry-service/src/validator_cache.rs (L86-98)
```rust
    async fn update_for_chain(
        &self,
        chain_name: &ChainCommonName,
        url: &str,
    ) -> Result<(), ValidatorCacheUpdateError> {
        let client = aptos_rest_client::Client::new(Url::parse(url).map_err(|e| {
            error!("invalid url for chain_id {}: {}", chain_name, e);
            ValidatorCacheUpdateError::InvalidUrl
        })?);
        let response: Response<ValidatorSet> = client
            .get_account_resource_bcs(CORE_CODE_ADDRESS, "0x1::stake::ValidatorSet")
            .await
            .map_err(ValidatorCacheUpdateError::RestError)?;
```

**File:** crates/aptos-telemetry-service/src/validator_cache.rs (L100-114)
```rust
        let (peer_addrs, state) = response.into_parts();

        let chain_id = ChainId::new(state.chain_id);

        let mut validator_cache = self.validators.write();
        let mut vfn_cache = self.validator_fullnodes.write();

        let validator_peers: PeerSet = peer_addrs
            .clone()
            .into_iter()
            .filter_map(|validator_info| -> Option<(PeerId, Peer)> {
                validator_info
                    .config()
                    .validator_network_addresses()
                    .map(|addresses| {
```

**File:** crates/aptos-rest-client/src/lib.rs (L1209-1220)
```rust
    pub async fn get_account_resource_bcs<T: DeserializeOwned>(
        &self,
        address: AccountAddress,
        resource_type: &str,
    ) -> AptosResult<Response<T>> {
        let url = self.build_path(&format!(
            "accounts/{}/resource/{}",
            address.to_hex(),
            resource_type
        ))?;
        let response = self.get_bcs(url).await?;
        Ok(response.and_then(|inner| bcs::from_bytes(&inner))?)
```

**File:** crates/aptos-rest-client/src/lib.rs (L1687-1690)
```rust
    async fn get_bcs(&self, url: Url) -> AptosResult<Response<bytes::Bytes>> {
        let response = self.inner.get(url).header(ACCEPT, BCS).send().await?;
        self.check_and_parse_bcs_response(response).await
    }
```

**File:** crates/aptos-rest-client/src/state.rs (L23-102)
```rust
    pub fn from_headers(headers: &reqwest::header::HeaderMap) -> anyhow::Result<Self> {
        let maybe_chain_id = headers
            .get(X_APTOS_CHAIN_ID)
            .and_then(|h| h.to_str().ok())
            .and_then(|s| s.parse().ok());
        let maybe_version = headers
            .get(X_APTOS_LEDGER_VERSION)
            .and_then(|h| h.to_str().ok())
            .and_then(|s| s.parse().ok());
        let maybe_timestamp = headers
            .get(X_APTOS_LEDGER_TIMESTAMP)
            .and_then(|h| h.to_str().ok())
            .and_then(|s| s.parse().ok());
        let maybe_epoch = headers
            .get(X_APTOS_EPOCH)
            .and_then(|h| h.to_str().ok())
            .and_then(|s| s.parse().ok());
        let maybe_oldest_ledger_version = headers
            .get(X_APTOS_LEDGER_OLDEST_VERSION)
            .and_then(|h| h.to_str().ok())
            .and_then(|s| s.parse().ok());
        let maybe_block_height = headers
            .get(X_APTOS_BLOCK_HEIGHT)
            .and_then(|h| h.to_str().ok())
            .and_then(|s| s.parse().ok());
        let maybe_oldest_block_height = headers
            .get(X_APTOS_OLDEST_BLOCK_HEIGHT)
            .and_then(|h| h.to_str().ok())
            .and_then(|s| s.parse().ok());
        let cursor = headers
            .get(X_APTOS_CURSOR)
            .and_then(|h| h.to_str().ok())
            .map(|s| s.to_string());

        let state = if let (
            Some(chain_id),
            Some(version),
            Some(timestamp_usecs),
            Some(epoch),
            Some(oldest_ledger_version),
            Some(block_height),
            Some(oldest_block_height),
            cursor,
        ) = (
            maybe_chain_id,
            maybe_version,
            maybe_timestamp,
            maybe_epoch,
            maybe_oldest_ledger_version,
            maybe_block_height,
            maybe_oldest_block_height,
            cursor,
        ) {
            Self {
                chain_id,
                epoch,
                version,
                timestamp_usecs,
                oldest_ledger_version,
                block_height,
                oldest_block_height,
                cursor,
            }
        } else {
            anyhow::bail!(
                "Failed to build State from headers due to missing values in response. \
                Chain ID: {:?}, Version: {:?}, Timestamp: {:?}, Epoch: {:?}, \
                Oldest Ledger Version: {:?}, Block Height: {:?} Oldest Block Height: {:?}",
                maybe_chain_id,
                maybe_version,
                maybe_timestamp,
                maybe_epoch,
                maybe_oldest_ledger_version,
                maybe_block_height,
                maybe_oldest_block_height,
            )
        };

        Ok(state)
    }
```

**File:** api/src/state.rs (L274-327)
```rust
    fn resource(
        &self,
        accept_type: &AcceptType,
        address: Address,
        resource_type: MoveStructTag,
        ledger_version: Option<u64>,
    ) -> BasicResultWith404<MoveResource> {
        let tag: StructTag = (&resource_type)
            .try_into()
            .context("Failed to parse given resource type")
            .map_err(|err| {
                BasicErrorWith404::bad_request_with_code_no_info(err, AptosErrorCode::InvalidInput)
            })?;

        let (ledger_info, ledger_version, state_view) = self.context.state_view(ledger_version)?;
        let bytes = state_view
            .as_converter(self.context.db.clone(), self.context.indexer_reader.clone())
            .find_resource(&state_view, address, &tag)
            .context(format!(
                "Failed to query DB to check for {} at {}",
                tag.to_canonical_string(),
                address
            ))
            .map_err(|err| {
                BasicErrorWith404::internal_with_code(
                    err,
                    AptosErrorCode::InternalError,
                    &ledger_info,
                )
            })?
            .ok_or_else(|| resource_not_found(address, &tag, ledger_version, &ledger_info))?;

        match accept_type {
            AcceptType::Json => {
                let resource = state_view
                    .as_converter(self.context.db.clone(), self.context.indexer_reader.clone())
                    .try_into_resource(&tag, &bytes)
                    .context("Failed to deserialize resource data retrieved from DB")
                    .map_err(|err| {
                        BasicErrorWith404::internal_with_code(
                            err,
                            AptosErrorCode::InternalError,
                            &ledger_info,
                        )
                    })?;

                BasicResponse::try_from_json((resource, &ledger_info, BasicResponseStatus::Ok))
            },
            AcceptType::Bcs => BasicResponse::try_from_encoded((
                bytes.to_vec(),
                &ledger_info,
                BasicResponseStatus::Ok,
            )),
        }
```

**File:** crates/aptos-telemetry-service/e2e-test/telemetry-config.yaml (L10-14)
```yaml
trusted_full_node_addresses:
  mainnet: "https://api.mainnet.aptoslabs.com"
  testnet: "https://api.testnet.aptoslabs.com"
  devnet: "https://api.devnet.aptoslabs.com"
update_interval: 300
```

**File:** crates/aptos-telemetry-service/src/auth.rs (L72-86)
```rust
    let (epoch, peer_role) = match cache.read().get(&body.chain_id) {
        Some((epoch, peer_set)) => {
            match peer_set.get(&body.peer_id) {
                Some(peer) => {
                    let remote_public_key = &remote_public_key;
                    if !peer.keys.contains(remote_public_key) {
                        warn!("peer found in peer set but public_key is not found. request body: {}, role_type: {}, peer_id: {}, received public_key: {}", body.chain_id, body.role_type, body.peer_id, remote_public_key);
                        return Err(reject::custom(ServiceError::forbidden(
                            ServiceErrorCode::AuthError(
                                AuthError::PeerPublicKeyNotFound,
                                body.chain_id,
                            ),
                        )));
                    }
                    Ok((*epoch, peer.role))
```

**File:** crates/aptos-telemetry-service/src/auth.rs (L137-151)
```rust
    let token = create_jwt_token(
        context.jwt_service(),
        body.chain_id,
        body.peer_id,
        node_type,
        epoch,
        body.run_uuid,
    )
    .map_err(|e| {
        error!("unable to create jwt token: {}", e);
        reject::custom(ServiceError::internal(ServiceErrorCode::AuthError(
            AuthError::from(e),
            body.chain_id,
        )))
    })?;
```
