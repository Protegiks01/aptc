# Audit Report

## Title
Sensitive Credentials Exposed Through Debug Logging in NFT Metadata Crawler Configuration

## Summary
The NFT Metadata Crawler logs its entire configuration structure using debug formatting at startup, which exposes sensitive credentials including database passwords, cloud service API keys, and authentication tokens to log files. These logs are typically accessible through logging systems, container platforms, or backup storage, creating an information disclosure vulnerability.

## Finding Description

The `NFTMetadataCrawlerConfig::run()` function logs the complete configuration structure using Rust's debug formatting: [1](#0-0) 

The `NFTMetadataCrawlerConfig` structure contains a `database_url` field that typically includes embedded credentials in the PostgreSQL connection string format: [2](#0-1) 

Additionally, the `server_config` field is an enum with variants containing multiple sensitive credentials: [3](#0-2) 

The `ParserConfig` variant exposes Google Cloud credentials and IPFS authentication keys: [4](#0-3) 

The `AssetUploaderWorkerConfig` variant exposes Cloudflare API credentials: [5](#0-4) 

The logging system is configured to output JSON-formatted logs to stdout by default, which are typically captured by log aggregation systems: [6](#0-5) 

Since all configuration structures derive the `Debug` trait without custom implementations, the default debug formatter will print all fields including sensitive credentials when the struct is logged with `{:?}`.

## Impact Explanation

This vulnerability constitutes an information disclosure issue that exposes multiple categories of sensitive credentials:

1. **Database credentials** embedded in `database_url` (username and password)
2. **Cloudflare API authentication keys** for image service manipulation
3. **Google Cloud application credentials** (path disclosure, potentially credentials themselves)
4. **IPFS authentication keys** for decentralized storage access

An attacker who gains access to log files through common attack vectors (misconfigured log aggregation systems, compromised monitoring infrastructure, accessible container logs, or backup systems) could leverage these credentials to:

- Access and manipulate NFT metadata stored in the PostgreSQL database
- Delete or replace NFT images through the Cloudflare API
- Access cloud storage resources via Google Cloud credentials
- Manipulate IPFS-hosted content using authentication keys

While this does not directly compromise blockchain consensus or cause fund loss, it represents a **Medium severity** information disclosure vulnerability as categorized in the security question, because it could lead to:
- Data integrity issues affecting NFT metadata displayed to users
- Service disruption of the NFT metadata infrastructure
- Unauthorized access to multiple third-party services
- Potential for lateral movement into other infrastructure components

## Likelihood Explanation

The likelihood of exploitation is **moderate to high** because:

1. **Log accessibility is common**: Production logs are frequently accessible through:
   - Container orchestration platforms (Kubernetes pods, Docker containers)
   - Centralized logging systems (ELK stack, Splunk, CloudWatch)
   - Log backup and archival systems with weaker access controls
   - Developer machines with access to production logs for debugging

2. **Credentials are logged on every startup**: The vulnerability is triggered automatically whenever the service starts, ensuring credentials appear in logs without requiring specific conditions.

3. **No redaction mechanisms**: The code lacks any credential sanitization or redaction logic before logging.

4. **JSON format increases discoverability**: The structured JSON logging format makes credentials easily parseable and discoverable by automated tools.

## Recommendation

Implement a custom `Debug` implementation for `NFTMetadataCrawlerConfig` and related configuration structures that redacts sensitive fields:

```rust
impl std::fmt::Debug for NFTMetadataCrawlerConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("NFTMetadataCrawlerConfig")
            .field("database_url", &"[REDACTED]")
            .field("server_port", &self.server_port)
            .field("server_config", &"[REDACTED]")
            .finish()
    }
}
```

Similarly implement custom `Debug` traits for `ParserConfig` and `AssetUploaderWorkerConfig` to redact sensitive fields like `google_application_credentials`, `ipfs_auth_key`, and `cloudflare_auth_key`.

Alternatively, remove the debug logging statement entirely at line 88, or change it to log only non-sensitive configuration parameters explicitly:

```rust
info!(
    "[NFT Metadata Crawler] Starting with server_port: {}, server_type: {}",
    self.server_port,
    match &self.server_config {
        ServerConfig::Parser(_) => "Parser",
        ServerConfig::AssetUploaderWorker(_) => "AssetUploaderWorker",
        ServerConfig::AssetUploaderApi => "AssetUploaderApi",
        ServerConfig::AssetUploaderThrottler(_) => "AssetUploaderThrottler",
    }
);
```

## Proof of Concept

**Steps to reproduce:**

1. Create a configuration file with real credentials:
```yaml
health_check_port: 8080
server_config:
  database_url: "postgresql://admin:SecretPassword123@db.example.com:5432/nftdb"
  server_port: 8081
  server_config:
    type: "AssetUploaderWorker"
    cloudflare_auth_key: "a1b2c3d4e5f6g7h8i9j0"
    cloudflare_account_id: "1234567890abcdef"
```

2. Start the NFT Metadata Crawler service with this configuration

3. Observe the startup logs - they will contain:
```json
{
  "timestamp": "2024-01-01T00:00:00.000Z",
  "level": "INFO",
  "message": "[NFT Metadata Crawler] Starting with config: NFTMetadataCrawlerConfig { database_url: \"postgresql://admin:SecretPassword123@db.example.com:5432/nftdb\", server_port: 8081, server_config: AssetUploaderWorker(AssetUploaderWorkerConfig { cloudflare_auth_key: \"a1b2c3d4e5f6g7h8i9j0\", cloudflare_account_id: \"1234567890abcdef\" }) }"
}
```

4. The plaintext credentials are now visible in log files, monitoring dashboards, and any log aggregation systems.

**Notes**

This vulnerability is specific to the NFT Metadata Crawler service, which is part of the Aptos ecosystem infrastructure rather than core consensus/blockchain operations. While it doesn't directly compromise blockchain security or consensus mechanisms, it represents a significant operational security risk for the NFT metadata infrastructure. The exposed credentials could enable attackers to manipulate NFT metadata, disrupt services, or pivot to other infrastructure components.

The issue should be addressed by implementing proper credential redaction in logging statements across all configuration structures that contain sensitive authentication material.

### Citations

**File:** ecosystem/nft-metadata-crawler/src/config.rs (L30-37)
```rust
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "type")]
pub enum ServerConfig {
    Parser(ParserConfig),
    AssetUploaderWorker(AssetUploaderWorkerConfig),
    AssetUploaderApi,
    AssetUploaderThrottler(AssetUploaderThrottlerConfig),
}
```

**File:** ecosystem/nft-metadata-crawler/src/config.rs (L40-46)
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct NFTMetadataCrawlerConfig {
    pub database_url: String,
    pub server_port: u16,
    pub server_config: ServerConfig,
}
```

**File:** ecosystem/nft-metadata-crawler/src/config.rs (L88-88)
```rust
        info!("[NFT Metadata Crawler] Starting with config: {:?}", self);
```

**File:** ecosystem/nft-metadata-crawler/src/parser/config.rs (L10-30)
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ParserConfig {
    pub google_application_credentials: Option<String>,
    pub bucket: String,
    pub cdn_prefix: String,
    pub ipfs_prefix: String,
    pub ipfs_auth_key: Option<String>,
    #[serde(default = "ParserConfig::default_max_file_size_bytes")]
    pub max_file_size_bytes: u32,
    #[serde(default = "ParserConfig::default_image_quality")]
    pub image_quality: u8, // Quality up to 100
    #[serde(default = "ParserConfig::default_max_image_dimensions")]
    pub max_image_dimensions: u32,
    #[serde(default = "ParserConfig::default_max_num_parse_retries")]
    pub max_num_parse_retries: i32,
    #[serde(default)]
    pub ack_parsed_uris: bool,
    #[serde(default)]
    pub uri_blacklist: Vec<String>,
}
```

**File:** ecosystem/nft-metadata-crawler/src/asset_uploader/worker/config.rs (L7-14)
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct AssetUploaderWorkerConfig {
    /// Cloudflare API key
    pub cloudflare_auth_key: String,
    /// Cloudflare Account ID provided at the images home page used to authenticate requests
    pub cloudflare_account_id: String,
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-server-framework/src/lib.rs (L174-193)
```rust
pub fn setup_logging(make_writer: Option<Box<dyn Fn() -> Box<dyn std::io::Write> + Send + Sync>>) {
    let env_filter = EnvFilter::try_from_default_env()
        .or_else(|_| EnvFilter::try_new("info"))
        .unwrap();

    let subscriber = tracing_subscriber::fmt()
        .json()
        .flatten_event(true)
        .with_file(true)
        .with_line_number(true)
        .with_thread_ids(true)
        .with_target(false)
        .with_thread_names(true)
        .with_env_filter(env_filter);

    match make_writer {
        Some(w) => subscriber.with_writer(w).init(),
        None => subscriber.init(),
    }
}
```
