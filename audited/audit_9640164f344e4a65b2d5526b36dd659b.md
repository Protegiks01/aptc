# Audit Report

## Title
BCS Serialization DoS: Unbounded Iteration Without Gas Metering Enables Validator Slowdown

## Summary
The `native_to_bytes()` function performs BCS serialization without incremental gas checking during the serialization loop, charging gas only after all work completes. This violates the codebase's documented security principle and allows attackers to force validators to expend CPU cycles on serialization before gas validation, causing deterministic validator slowdowns.

## Finding Description

The vulnerability exists in the BCS native function implementation where gas is charged **after** rather than **before** the expensive serialization operation. [1](#0-0) 

The serialization at lines 97-100 delegates to `ValueSerDeContext::serialize()`, which performs a complete BCS serialization of the value. Only at lines 110-111, **after** serialization completes, is gas charged based on the output size.

This directly violates the documented security principle in the codebase: [2](#0-1) 

The documentation explicitly states: "this function **MUST** always be called **BEFORE** executing **any** gas-metered operation or library call within a native function."

The serialization implementation iterates through vector elements without any iteration count checks: [3](#0-2) 

The loop at lines 4901-4909 iterates through all elements without checking iteration count or charging incremental gas. The only limit enforced is nesting depth (128 levels), not element count: [4](#0-3) [5](#0-4) 

**Attack Execution Path:**

1. Attacker creates a Move transaction that allocates a large vector within memory quota limits
2. The memory quota allows up to 10,000,000 abstract value size units (~1.25M u64 values): [6](#0-5) 
3. Transaction calls `bcs::to_bytes()` on this vector
4. All validators execute the transaction deterministically
5. Serialization iterates through all elements without any gas checks
6. CPU time is spent proportional to vector size **before** gas validation
7. Gas is charged only after serialization completes
8. Even if the transaction fails with OUT_OF_GAS, validators have already done the work
9. Multiple such transactions in a block compound the slowdown

## Impact Explanation

This vulnerability meets **HIGH severity** criteria per the Aptos bug bounty program category: **"Validator Node Slowdowns"**.

**Specific Impact:**
- **Deterministic Validator Slowdown**: All validators must perform identical serialization work synchronously, creating a network-wide bottleneck
- **Consensus Performance Degradation**: Block processing time increases with malicious transactions
- **Resource Exhaustion Before Validation**: CPU cycles consumed before proper gas limit enforcement
- **Economic Asymmetry**: Attackers pay normal gas for vector creation but force disproportionate serialization work from validators

**Quantification:**
With the 10MB memory quota, attackers can create vectors with over 1 million u64 elements. Even at modern CPU speeds (100 nanoseconds per element conservative estimate), serializing 1M elements takes ~100ms per transaction. Multiple such transactions per block create cumulative latency that affects consensus throughput across all validators.

## Likelihood Explanation

**Likelihood: HIGH**

**Attacker Requirements:**
- Standard transaction submission capability (any Aptos user)
- No validator access or special permissions needed
- No collusion required

**Feasibility:**
- Trivially implementable in Move
- Deterministic and reproducible on every execution
- No race conditions or timing dependencies
- Can be automated and repeated continuously

**Cost-Benefit Analysis:**
- Attack cost: Normal transaction gas fees
- Attack impact: Network-wide validator slowdown
- Amplification: Multiple transactions compound the effect
- Validators do work even if transactions ultimately fail with OUT_OF_GAS

## Recommendation

Implement incremental gas charging during BCS serialization by checking gas limits periodically within the serialization loop. Options include:

1. **Charge gas upfront based on estimated size**: Charge conservative gas estimate before serialization, refund difference after
2. **Periodic gas checks during iteration**: Check gas meter every N iterations (e.g., every 1000 elements)
3. **Iteration count limit**: Impose maximum iteration count per serialization call
4. **Hybrid approach**: Combine upfront charging with periodic validation

The fix should ensure gas is charged **before** expensive CPU work begins, consistent with the documented security principle.

## Proof of Concept

```move
module attacker::dos_attack {
    use std::bcs;
    use std::vector;

    public entry fun cause_slowdown() {
        // Create large vector within memory quota
        let vec = vector::empty<u64>();
        let i = 0;
        // Allocate ~1M elements (8MB for u64s)
        while (i < 1000000) {
            vector::push_back(&mut vec, i);
            i = i + 1;
        };
        
        // Force expensive serialization before gas validation
        let _serialized = bcs::to_bytes(&vec);
        // Gas is only charged AFTER serialization completes
    }
}
```

Submit multiple transactions calling this function to cause cumulative validator slowdown. All validators must serialize the full vector before gas validation occurs.

## Notes

This vulnerability represents a clear deviation from the documented security principle that gas must be charged before expensive operations. The work-before-validation pattern creates an exploitable asymmetry where attackers can force validators to expend significant CPU resources before gas limits are enforced, meeting the HIGH severity criteria for "Validator Node Slowdowns" per the Aptos bug bounty program.

### Citations

**File:** aptos-move/framework/move-stdlib/src/natives/bcs.rs (L97-111)
```rust
    let serialized_value = match ValueSerDeContext::new(max_value_nest_depth)
        .with_legacy_signer()
        .with_func_args_deserialization(&function_value_extension)
        .serialize(&val, &layout)?
    {
        Some(serialized_value) => serialized_value,
        None => {
            context.charge(BCS_TO_BYTES_FAILURE)?;
            return Err(SafeNativeError::Abort {
                abort_code: NFE_BCS_SERIALIZATION_FAILURE,
            });
        },
    };
    context
        .charge(BCS_TO_BYTES_PER_BYTE_SERIALIZED * NumBytes::new(serialized_value.len() as u64))?;
```

**File:** aptos-move/aptos-native-interface/src/context.rs (L69-73)
```rust
    /// Always remember: first charge gas, then execute!
    ///
    /// In other words, this function **MUST** always be called **BEFORE** executing **any**
    /// gas-metered operation or library call within a native function.
    #[must_use = "must always propagate the error returned by this function to the native function that called it using the ? operator"]
```

**File:** third_party/move/move-vm/types/src/values/values_impl.rs (L57-57)
```rust
pub const DEFAULT_MAX_VM_VALUE_NESTED_DEPTH: u64 = 128;
```

**File:** third_party/move/move-vm/types/src/values/values_impl.rs (L4838-4838)
```rust
        self.ctx.check_depth(self.depth).map_err(S::Error::custom)?;
```

**File:** third_party/move/move-vm/types/src/values/values_impl.rs (L4898-4910)
```rust
                    (_, Container::Vec(r)) => {
                        let v = r.borrow();
                        let mut t = serializer.serialize_seq(Some(v.len()))?;
                        for value in v.iter() {
                            t.serialize_element(&SerializationReadyValue {
                                ctx: self.ctx,
                                layout,
                                value,
                                depth: self.depth + 1,
                            })?;
                        }
                        t.end()
                    },
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L142-142)
```rust
        [memory_quota: AbstractValueSize, { 1.. => "memory_quota" }, 10_000_000],
```
