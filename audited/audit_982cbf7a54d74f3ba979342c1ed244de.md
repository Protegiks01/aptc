# Audit Report

## Title
Genesis Validator Host Uniqueness Bypass via IP Format Variation

## Summary
The `validate_validators()` function's host uniqueness check can be bypassed by using different string representations of the same IP address (e.g., "localhost", "127.0.0.1", "::1"), allowing multiple validators to be configured on the same physical host during genesis setup, defeating network decentralization requirements.

## Finding Description

The genesis validation logic enforces unique validator hosts through a `HashSet<HostAndPort>` check. However, this check is purely string-based and can be bypassed using different IP address formats representing the same physical host. [1](#0-0) 

The root cause lies in how `HostAndPort` implements equality and hashing. The `HostAndPort` struct contains a `DnsName` field which is a simple newtype wrapper around `String`: [2](#0-1) 

Since `DnsName` derives `Eq`, `Hash`, and `PartialEq`, it uses direct string comparison without any normalization or canonicalization: [3](#0-2) 

The validation only checks basic properties (non-empty, length, no '/' characters, ASCII) but performs no IP address normalization. This means:
- "localhost" vs "127.0.0.1" vs "::1" are treated as different hosts
- "192.168.1.1" vs "::ffff:192.168.1.1" (IPv4-mapped IPv6) are different
- Any DNS name vs its resolved IP are different

**Attack Scenario:**
During genesis setup, a malicious participant could:
1. Register validator A with `validator_host: "localhost:6180"`
2. Register validator B with `validator_host: "127.0.0.1:6181"`
3. Register validator C with `validator_host: "::1:6182"`

All three pass the uniqueness validation but run on the same physical machine. This also affects full node host validation: [4](#0-3) 

The same vulnerability exists when the code checks that validator_host differs from full_node_host: [5](#0-4) 

An attacker could set `validator_host: "localhost:6180"` and `full_node_host: "127.0.0.1:6181"`, bypassing the check despite both running on the same machine.

## Impact Explanation

This vulnerability qualifies as **HIGH severity** under the Aptos bug bounty program ("Significant protocol violations") because:

1. **Violates Decentralization Invariant**: The explicit purpose of unique host validation is to ensure validators run on different physical machines. Bypassing this defeats a fundamental blockchain security requirement.

2. **Enables Sybil Attacks at Genesis**: An attacker controlling multiple validator slots on a single machine could:
   - Represent multiple "independent" validators with combined voting power
   - If controlling â‰¥1/3 of stake, compromise consensus safety
   - Create a single point of failure affecting multiple validators

3. **Irreversible After Genesis**: Once genesis is complete, this misconfiguration cannot be corrected without a hard fork, as the initial validator set is permanently established.

4. **Bypasses Explicit Security Control**: The code explicitly checks for unique hosts, indicating this is a recognized security requirement that can be completely circumvented.

While this doesn't directly lead to fund theft (not CRITICAL), it fundamentally weakens the network's Byzantine fault tolerance assumptions and could enable consensus manipulation.

## Likelihood Explanation

**Likelihood: MEDIUM to HIGH**

**Required Attacker Access:**
- Participation in genesis setup process
- Ability to submit validator configurations
- Does NOT require special cryptographic materials or validator keys beyond normal genesis participation

**Attack Complexity:**
- TRIVIAL: Simply specify different IP string formats for the same host
- No sophisticated technical knowledge required
- No cryptographic attacks needed

**Detection Difficulty:**
- Hard to detect during genesis setup unless IP addresses are actively resolved and compared
- After genesis, validators appear as independent entities in the validator set

The main barrier is that the attacker must be involved in the genesis process, which typically involves some level of trust. However, in permissionless or semi-permissionless genesis scenarios, this could be easily exploited.

## Recommendation

Implement IP address normalization and canonicalization in the `HostAndPort` or `DnsName` validation logic:

1. **Resolve and normalize IP addresses** before comparison:
   - Convert DNS names to their IP addresses
   - Normalize localhost representations to a canonical form (e.g., always use 127.0.0.1)
   - Handle IPv4-mapped IPv6 addresses by converting to canonical IPv4
   - Convert IPv6 addresses to canonical form

2. **Implement custom `Eq` and `Hash` for `DnsName`** that performs semantic IP comparison rather than string comparison

3. **Add explicit validation** in `validate_validators()` that attempts to resolve and compare IP addresses:

```rust
// In types/src/network_address/mod.rs
impl HostAndPort {
    pub fn canonical_host(&self) -> Result<IpAddr, ParseError> {
        let host_str = self.host.as_ref();
        
        // Try parsing as IP first
        if let Ok(ip) = IpAddr::from_str(host_str) {
            return Ok(normalize_ip(ip));
        }
        
        // For DNS names, attempt resolution
        // Or store as-is but warn about potential bypass
        // ...
    }
}

fn normalize_ip(ip: IpAddr) -> IpAddr {
    match ip {
        IpAddr::V6(ipv6) => {
            // Convert IPv4-mapped IPv6 to IPv4
            if let Some(ipv4) = ipv6.to_ipv4_mapped() {
                IpAddr::V4(ipv4)
            } else {
                IpAddr::V6(ipv6)
            }
        }
        IpAddr::V4(ipv4) => IpAddr::V4(ipv4),
    }
}
```

4. **Update validation logic** to use canonical IP comparison in the HashSet or add additional checks.

## Proof of Concept

```rust
// Test demonstrating the vulnerability
// Add to crates/aptos/src/genesis/tests.rs

#[test]
fn test_host_uniqueness_bypass() {
    use aptos_genesis::config::HostAndPort;
    use std::collections::HashSet;
    use std::str::FromStr;

    let mut unique_hosts = HashSet::new();
    
    // These all represent localhost but are treated as different
    let localhost = HostAndPort::from_str("localhost:6180").unwrap();
    let ipv4_localhost = HostAndPort::from_str("127.0.0.1:6180").unwrap();
    let ipv6_localhost = HostAndPort::from_str("::1:6180").unwrap();
    
    // All three insert successfully despite being the same physical host
    assert!(unique_hosts.insert(localhost.clone()));
    assert!(unique_hosts.insert(ipv4_localhost.clone()));
    assert!(unique_hosts.insert(ipv6_localhost.clone()));
    
    // Verification: all three are considered unique
    assert_eq!(unique_hosts.len(), 3);
    
    // But they all resolve to the same host
    assert_ne!(localhost, ipv4_localhost); // Should be equal after normalization
    assert_ne!(localhost, ipv6_localhost); // Should be equal after normalization
    assert_ne!(ipv4_localhost, ipv6_localhost); // Should be equal after normalization
    
    println!("VULNERABILITY CONFIRMED: Same physical host bypasses uniqueness check");
    println!("localhost: {:?}", localhost);
    println!("127.0.0.1: {:?}", ipv4_localhost);
    println!("::1: {:?}", ipv6_localhost);
}

#[test]
fn test_ipv4_mapped_ipv6_bypass() {
    use aptos_genesis::config::HostAndPort;
    use std::collections::HashSet;
    use std::str::FromStr;

    let mut unique_hosts = HashSet::new();
    
    // Same IP in different formats
    let ipv4 = HostAndPort::from_str("192.168.1.1:6180").unwrap();
    let ipv4_mapped = HostAndPort::from_str("::ffff:192.168.1.1:6180").unwrap();
    
    // Both insert successfully despite representing same address
    assert!(unique_hosts.insert(ipv4.clone()));
    assert!(unique_hosts.insert(ipv4_mapped.clone()));
    
    assert_eq!(unique_hosts.len(), 2);
    assert_ne!(ipv4, ipv4_mapped); // Should be equal after normalization
    
    println!("VULNERABILITY CONFIRMED: IPv4-mapped IPv6 bypasses uniqueness check");
}
```

**Notes**
- This vulnerability affects both mainnet and testnet genesis configurations
- The issue also impacts the full_node_host uniqueness validation using the same mechanism
- Current test suite uses different ports for each validator, masking this vulnerability
- Exploitation requires genesis participation but no other special privileges
- Post-genesis, the misconfiguration is permanent without a hard fork

### Citations

**File:** crates/aptos/src/genesis/mod.rs (L736-742)
```rust
            if !unique_hosts.insert(validator.validator_host.as_ref().unwrap().clone()) {
                errors.push(CliError::UnexpectedError(format!(
                    "Validator {} has a repeated validator host {:?}",
                    name,
                    validator.validator_host.as_ref().unwrap()
                )));
            }
```

**File:** crates/aptos/src/genesis/mod.rs (L794-800)
```rust
                    if validator_host == full_node_host {
                        errors.push(CliError::UnexpectedError(format!(
                            "Validator {} has a validator and a full node host that are the same {:?}",
                            name,
                            validator_host
                        )));
                    }
```

**File:** crates/aptos/src/genesis/mod.rs (L801-807)
```rust
                    if !unique_hosts.insert(validator.full_node_host.as_ref().unwrap().clone()) {
                        errors.push(CliError::UnexpectedError(format!(
                            "Validator {} has a repeated full node host {:?}",
                            name,
                            validator.full_node_host.as_ref().unwrap()
                        )));
                    }
```

**File:** types/src/network_address/mod.rs (L148-149)
```rust
#[derive(Clone, Debug, Eq, Hash, PartialEq, Serialize)]
pub struct DnsName(String);
```

**File:** types/src/network_address/mod.rs (L667-679)
```rust
    fn validate(s: &str) -> Result<(), ParseError> {
        if s.is_empty() {
            Err(ParseError::EmptyDnsNameString)
        } else if s.len() > MAX_DNS_NAME_SIZE {
            Err(ParseError::DnsNameTooLong(s.len()))
        } else if s.contains('/') {
            Err(ParseError::InvalidDnsNameCharacter)
        } else if !s.is_ascii() {
            Err(ParseError::DnsNameNonASCII(s.into()))
        } else {
            Ok(())
        }
    }
```
