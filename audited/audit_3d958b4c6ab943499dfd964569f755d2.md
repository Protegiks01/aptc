# Audit Report

## Title
Unbounded BCS Deserialization of ValidatorConfig Network Addresses During Epoch Transitions

## Summary
The `ValidatorConfig` struct contains `Vec<u8>` fields for network addresses that are deserialized without size limits during epoch transitions. While individual writes are capped at 1MB, the aggregate size across all validators in the ValidatorSet can reach hundreds of megabytes, causing memory and CPU exhaustion when all nodes simultaneously deserialize this data during reconfiguration events.

## Finding Description

The vulnerability exists in a multi-layer deserialization process:

**Layer 1 - OnChainConfig Deserialization:**
When nodes fetch `ValidatorSet` during epoch transitions or state sync, the deserialization uses `bcs::from_bytes()` without size limits: [1](#0-0) 

**Layer 2 - ValidatorConfig Structure:**
Each `ValidatorConfig` contains unbounded `Vec<u8>` fields that store BCS-serialized network addresses: [2](#0-1) 

**Layer 3 - Network Address Deserialization:**
When processing validators, these `Vec<u8>` fields are deserialized again without limits: [3](#0-2) 

**Layer 4 - Write-Time Limits:**
While transaction validation limits individual writes to 1MB per field: [4](#0-3) 

The aggregate size is unbounded because:
- ValidatorSet can have up to 65,536 validators: [5](#0-4) 
- Each validator can have 1MB `network_addresses` + 1MB `fullnode_addresses` = 2MB per validator
- Total potential: 131 GB of address data across max validators

**Attack Path:**
1. Validator operators call `update_network_and_fullnode_addresses()` with maximum-sized address data (1MB each): [6](#0-5) 

2. During epoch transition, all nodes fetch ValidatorSet: [7](#0-6) 

3. Each node deserializes the entire ValidatorSet simultaneously, allocating memory for all `Vec<u8>` fields

4. When extracting network addresses, secondary deserialization occurs: [8](#0-7) 

**Broken Invariants:**
- **Resource Limits** (#9): Deserialization does not respect computational/memory limits
- **Deterministic Execution** (#1): Memory exhaustion could cause non-deterministic node failures
- **State Consistency** (#4): Nodes may crash during epoch transition, preventing state synchronization

## Impact Explanation

**High Severity** - Validator node slowdowns and potential crashes during epoch transitions.

With a realistic validator set of 100 validators, each with maximum-sized addresses (2MB):
- Total data to deserialize: 200MB per node
- Every node must deserialize this simultaneously during epoch changes
- Causes:
  - **Memory exhaustion**: 200MB+ allocated during deserialization
  - **CPU exhaustion**: BCS deserialization of hundreds of megabytes
  - **Network synchronization delays**: All nodes experience slowdown simultaneously

This maps to the **High Severity** category: "Validator node slowdowns" and could escalate to network-wide liveness issues if enough nodes experience resource exhaustion during critical epoch transitions.

## Likelihood Explanation

**Moderate likelihood:**

**Prerequisites:**
- Requires validator operators to set large network address fields (legitimate operator action)
- Only manifests with sufficient validators using maximum-sized addresses
- Triggers automatically during every epoch transition once conditions are met

**Mitigating factors:**
- Requires coordination among multiple validator operators (though each acts independently)
- Gas costs make 1MB addresses expensive to store
- Current validator sets are smaller than the pathological case

**Amplifying factors:**
- No runtime validation of address field sizes during reads
- All nodes affected simultaneously during epoch transitions
- Network discovery system processes all validators automatically

## Recommendation

Implement size validation at deserialization time to prevent resource exhaustion:

**Option 1: Add size limits to OnChainConfig deserialization**
```rust
// In types/src/on_chain_config/mod.rs
fn deserialize_into_config(bytes: &[u8]) -> Result<Self> {
    const MAX_CONFIG_SIZE: usize = 10 << 20; // 10 MB max per config
    if bytes.len() > MAX_CONFIG_SIZE {
        return Err(format_err!("Config exceeds maximum size"));
    }
    Self::deserialize_default_impl(bytes)
}
```

**Option 2: Add per-validator limits in ValidatorConfig**
```rust
// In types/src/validator_config.rs
pub fn validator_network_addresses(&self) -> Result<Vec<NetworkAddress>, bcs::Error> {
    const MAX_ADDRESS_SIZE: usize = 64 << 10; // 64 KB reasonable max
    if self.validator_network_addresses.len() > MAX_ADDRESS_SIZE {
        return Err(bcs::Error::Custom("Address field exceeds size limit".into()));
    }
    bcs::from_bytes(&self.validator_network_addresses)
}
```

**Option 3: Add aggregate limits in ValidatorSet processing**
```rust
// In network/discovery/src/validator_set.rs
const MAX_TOTAL_ADDRESS_DATA: usize = 50 << 20; // 50 MB total
let mut total_size = 0;
for info in node_set.into_iter() {
    let config = info.into_config();
    total_size += config.validator_network_addresses.len() + 
                  config.fullnode_network_addresses.len();
    if total_size > MAX_TOTAL_ADDRESS_DATA {
        return Err(DiscoveryError::AddressDataExceedsLimit);
    }
    // ... continue processing
}
```

## Proof of Concept

```rust
// Rust reproduction demonstrating memory exhaustion
use aptos_types::{
    validator_config::ValidatorConfig,
    validator_info::ValidatorInfo,
    on_chain_config::ValidatorSet,
};

#[test]
fn test_validatorconfig_deserialization_bomb() {
    // Simulate 100 validators with maximum-sized address fields
    let mut validators = Vec::new();
    
    for i in 0..100 {
        let consensus_key = bls12381::PrivateKey::generate_for_testing().public_key();
        
        // Create 1MB of address data (maximum allowed by write limits)
        let large_addresses = vec![0u8; 1 << 20]; // 1 MB
        
        let config = ValidatorConfig::new(
            consensus_key,
            large_addresses.clone(), // validator_network_addresses
            large_addresses,         // fullnode_network_addresses
            i,
        );
        
        validators.push(ValidatorInfo::new(
            AccountAddress::random(),
            100,
            config,
        ));
    }
    
    let validator_set = ValidatorSet::new(validators);
    
    // Serialize the ValidatorSet (simulating on-chain storage)
    let serialized = bcs::to_bytes(&validator_set).unwrap();
    println!("Serialized size: {} MB", serialized.len() / (1 << 20));
    
    // Deserialize (simulating epoch transition read)
    // This will allocate ~200MB+ of memory without any size checks
    let start = std::time::Instant::now();
    let _deserialized: ValidatorSet = bcs::from_bytes(&serialized).unwrap();
    println!("Deserialization took: {:?}", start.elapsed());
    
    // Process network addresses (secondary deserialization)
    for validator in _deserialized.into_iter() {
        let config = validator.into_config();
        // This triggers second BCS deserialization
        let _ = config.validator_network_addresses(); // Potential panic on resource exhaustion
        let _ = config.fullnode_network_addresses();
    }
}
```

**Expected behavior:** Test demonstrates that deserialization allocates hundreds of megabytes without validation, confirming the vulnerability in resource-constrained environments.

## Notes

This vulnerability exists at the intersection of Move's on-chain storage limits (which cap individual writes) and Rust's deserialization path (which lacks aggregate limits). While individual validator operators act within protocol limits, the cumulative effect creates a resource exhaustion vector during synchronized epoch transitions across all nodes.

### Citations

**File:** types/src/on_chain_config/mod.rs (L162-165)
```rust
    fn deserialize_default_impl(bytes: &[u8]) -> Result<Self> {
        bcs::from_bytes::<Self>(bytes)
            .map_err(|e| format_err!("[on-chain config] Failed to deserialize into config: {}", e))
    }
```

**File:** types/src/validator_config.rs (L36-43)
```rust
pub struct ValidatorConfig {
    pub consensus_public_key: bls12381::PublicKey,
    /// This is an bcs serialized `Vec<NetworkAddress>`
    pub validator_network_addresses: Vec<u8>,
    /// This is an bcs serialized `Vec<NetworkAddress>`
    pub fullnode_network_addresses: Vec<u8>,
    pub validator_index: u64,
}
```

**File:** types/src/validator_config.rs (L60-66)
```rust
    pub fn fullnode_network_addresses(&self) -> Result<Vec<NetworkAddress>, bcs::Error> {
        bcs::from_bytes(&self.fullnode_network_addresses)
    }

    pub fn validator_network_addresses(&self) -> Result<Vec<NetworkAddress>, bcs::Error> {
        bcs::from_bytes(&self.validator_network_addresses)
    }
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L154-157)
```rust
            max_bytes_per_write_op: NumBytes,
            { 5.. => "max_bytes_per_write_op" },
            1 << 20, // a single state item is 1MB max
        ],
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L98-100)
```text
    /// Limit the maximum size to u16::max, it's the current limit of the bitvec
    /// https://github.com/aptos-labs/aptos-core/blob/main/crates/aptos-bitvec/src/lib.rs#L20
    const MAX_VALIDATOR_SET_SIZE: u64 = 65536;
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L955-971)
```text
    public entry fun update_network_and_fullnode_addresses(
        operator: &signer,
        pool_address: address,
        new_network_addresses: vector<u8>,
        new_fullnode_addresses: vector<u8>,
    ) acquires StakePool, ValidatorConfig {
        check_stake_permission(operator);
        assert_reconfig_not_in_progress();
        assert_stake_pool_exists(pool_address);
        let stake_pool = borrow_global_mut<StakePool>(pool_address);
        assert!(signer::address_of(operator) == stake_pool.operator_address, error::unauthenticated(ENOT_OPERATOR));
        assert!(exists<ValidatorConfig>(pool_address), error::not_found(EVALIDATOR_CONFIG));
        let validator_info = borrow_global_mut<ValidatorConfig>(pool_address);
        let old_network_addresses = validator_info.network_addresses;
        validator_info.network_addresses = new_network_addresses;
        let old_fullnode_addresses = validator_info.fullnode_addresses;
        validator_info.fullnode_addresses = new_fullnode_addresses;
```

**File:** network/discovery/src/validator_set.rs (L71-73)
```rust
        let node_set: ValidatorSet = payload
            .get()
            .expect("failed to get ValidatorSet from payload");
```

**File:** network/discovery/src/validator_set.rs (L122-129)
```rust
                config
                    .validator_network_addresses()
                    .map_err(anyhow::Error::from)
            } else {
                config
                    .fullnode_network_addresses()
                    .map_err(anyhow::Error::from)
            }
```
