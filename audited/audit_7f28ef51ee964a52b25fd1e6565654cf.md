# Audit Report

## Title
Invalid RSA Public Key Parameters Accepted in JWK Consensus Leading to Keyless Account DoS

## Summary
The JWK consensus mechanism accepts RSA public keys (`n` modulus and `e` exponent) without validating that they are valid base64-encoded values or mathematically valid RSA parameters. This allows malicious or compromised OIDC providers to poison the on-chain `ObservedJWKs` state with invalid cryptographic material, causing denial-of-service for all keyless account users of that provider and potentially crashing validators during transaction execution.

## Finding Description
The vulnerability exists across multiple layers of the JWK consensus pipeline where RSA public key parameters are never validated before being committed to on-chain state.

**Attack Flow:**

1. **JWK Fetching Without Validation**: When validators fetch JWKs from OIDC providers, the conversion only validates that fields are present and are strings, but not that `n` and `e` contain valid base64 or valid RSA parameters. [1](#0-0) 

2. **RSA_JWK Parsing Lacks Cryptographic Validation**: The `RSA_JWK::try_from` implementation only checks field presence, string types, and that `kty == "RSA"`. No validation of base64 decoding or RSA parameter validity occurs. [2](#0-1) 

3. **Consensus Accepts Invalid Data**: The JWK manager processes observations and signs them without any validation of the cryptographic parameters. [3](#0-2) 

4. **Critical Failure Point in VM**: When keyless transactions are validated in the VM, the invalid RSA parameters are used to verify JWT signatures. The call to `DecodingKey::from_rsa_components(&self.n, &self.e)` will fail or potentially panic with invalid input. [4](#0-3) [5](#0-4) 

**Broken Invariants:**
- **Cryptographic Correctness**: Invalid RSA public keys violate the assumption that all cryptographic material is well-formed
- **Deterministic Execution**: If the external `jsonwebtoken` library panics instead of returning errors, different validator nodes could behave inconsistently
- **State Consistency**: On-chain state contains invalid cryptographic material that cannot be used

**Attack Scenario:**
1. Attacker controls or compromises an OIDC provider's JWK endpoint (e.g., `https://malicious-provider.com/.well-known/jwks.json`)
2. Serves RSA JWKs with invalid base64 in `n` field (e.g., `"n": "!@#$%INVALID%$#@!"`) or `e` field
3. All validators independently fetch this invalid JWK
4. Each validator signs their observation and participates in consensus
5. Quorum is reached and invalid JWK is committed to `ObservedJWKs` resource on-chain
6. Any user attempting to authenticate using keyless accounts with this OIDC provider will have transactions fail at signature verification
7. If `DecodingKey::from_rsa_components` panics instead of returning an error, validators crash during transaction execution

## Impact Explanation
**HIGH Severity** per Aptos bug bounty criteria:

1. **Validator Node Slowdowns/Crashes**: If the `jsonwebtoken` crate's `DecodingKey::from_rsa_components` panics on invalid input, validators will crash when processing keyless transactions using the poisoned JWKs. Even if it returns errors, repeated failed transactions create processing overhead.

2. **Significant Protocol Violations**: The consensus mechanism accepts and commits invalid cryptographic material, violating the protocol's assumption that all on-chain JWKs are usable for signature verification.

3. **Denial of Service**: All users with keyless accounts tied to the affected OIDC provider cannot authenticate or submit transactions. This affects potentially thousands of users and persists until governance intervention.

4. **Governance Burden**: Fixing requires an on-chain governance proposal to update the `ObservedJWKs` resource, which is slow (days to weeks) and requires coordination.

5. **Consensus State Pollution**: Once committed, the invalid data is replicated across all validators and historical state, requiring special handling.

## Likelihood Explanation
**HIGH Likelihood**:

1. **Low Attacker Requirements**: Attacker only needs to compromise or control one OIDC provider's JWK endpoint. No validator insider access needed.

2. **No Input Validation**: There are no validation checks in the entire pipeline from fetching to consensus commitment. [6](#0-5) 

3. **External Dependency Risk**: Real-world OIDC providers could accidentally serve malformed JWKs due to bugs, misconfigurations, or temporary glitches.

4. **Persistent Impact**: Once committed, the impact persists until governance action, making this a reliable attack vector.

## Recommendation
Add validation at multiple layers:

1. **Immediate Validation in RSA_JWK Parsing**: Validate base64 decoding and RSA parameter constraints during `try_from`:

```rust
impl TryFrom<&serde_json::Value> for RSA_JWK {
    type Error = anyhow::Error;
    
    fn try_from(json_value: &serde_json::Value) -> Result<Self, Self::Error> {
        // ... existing field extraction code ...
        
        let ret = Self { kty, kid, alg, e, n };
        
        // NEW: Validate base64 and RSA parameters
        ret.validate_rsa_parameters()?;
        
        Ok(ret)
    }
}

impl RSA_JWK {
    fn validate_rsa_parameters(&self) -> Result<()> {
        // Validate n is valid base64 and correct size
        let modulus = base64::decode_config(&self.n, URL_SAFE_NO_PAD)
            .context("Modulus 'n' is not valid base64")?;
        ensure!(
            modulus.len() == Self::RSA_MODULUS_BYTES,
            "Modulus must be exactly {} bytes, got {}",
            Self::RSA_MODULUS_BYTES,
            modulus.len()
        );
        
        // Validate e is valid base64
        let exponent = base64::decode_config(&self.e, URL_SAFE_NO_PAD)
            .context("Exponent 'e' is not valid base64")?;
        ensure!(!exponent.is_empty(), "Exponent cannot be empty");
        
        // Optionally: Test that DecodingKey can be constructed
        DecodingKey::from_rsa_components(&self.n, &self.e)
            .context("RSA parameters cannot construct valid decoding key")?;
        
        Ok(())
    }
}
```

2. **Validation in JWK Observer**: Add validation before signing observations in the JWK manager to reject invalid JWKs early.

3. **Move Framework Validation**: Add validation in the `new_rsa_jwk` function in `jwks.move` to enforce constraints at the smart contract level.

4. **Safe Error Handling**: Ensure all paths that use RSA JWKs properly handle errors from `DecodingKey::from_rsa_components` without panicking: [7](#0-6) 

## Proof of Concept

```rust
#[test]
fn test_invalid_base64_in_rsa_jwk_rejected() {
    // Invalid base64 with special characters
    let json_str = r#"{
        "alg": "RS256",
        "kid": "test-key",
        "e": "AQAB",
        "use": "sig",
        "kty": "RSA",
        "n": "!@#$%^&*()_INVALID_BASE64"
    }"#;
    let json = serde_json::Value::from_str(json_str).unwrap();
    
    // Currently PASSES but should FAIL
    let result = RSA_JWK::try_from(&json);
    assert!(result.is_ok()); // BUG: Accepts invalid base64
    
    // Now try to use it for signature verification
    let rsa_jwk = result.unwrap();
    let result = rsa_jwk.verify_signature_without_exp_check("dummy.jwt.token");
    
    // This will fail or panic when DecodingKey::from_rsa_components is called
    // Demonstrating that invalid JWKs can reach consensus but fail at usage time
    assert!(result.is_err());
}

#[test]
fn test_invalid_modulus_size_rejected() {
    // Valid base64 but wrong size (should be 256 bytes)
    let json_str = r#"{
        "alg": "RS256",
        "kid": "test-key",
        "e": "AQAB",
        "use": "sig",
        "kty": "RSA",
        "n": "dGVzdA"
    }"#; // "test" in base64, only 4 bytes
    let json = serde_json::Value::from_str(json_str).unwrap();
    
    // Currently PASSES but should FAIL
    let result = RSA_JWK::try_from(&json);
    assert!(result.is_ok()); // BUG: Accepts wrong size modulus
}
```

## Notes
This vulnerability is particularly serious because:
1. It affects the consensus layer, not just individual nodes
2. The impact is persistent and requires governance to fix
3. It can be triggered by any compromised or buggy OIDC provider
4. There are no existing test cases validating RSA parameter correctness
5. The validation in `to_poseidon_scalar` (which checks modulus size) is only called in the ZK proof path, not during JWK consensus [8](#0-7)

### Citations

**File:** crates/jwk-utils/src/lib.rs (L25-36)
```rust
pub async fn fetch_jwks_from_jwks_uri(
    my_addr: Option<AccountAddress>,
    jwks_uri: &str,
) -> Result<Vec<JWK>> {
    let client = reqwest::Client::new();
    let mut request_builder = client.get(jwks_uri);
    if let Some(addr) = my_addr {
        request_builder = request_builder.header(COOKIE, addr.to_hex());
    }
    let JWKsResponse { keys } = request_builder.send().await?.json().await?;
    let jwks = keys.into_iter().map(JWK::from).collect();
    Ok(jwks)
```

**File:** types/src/jwks/rsa/mod.rs (L89-95)
```rust
    pub fn verify_signature_without_exp_check(&self, jwt_token: &str) -> Result<TokenData<Claims>> {
        let mut validation = Validation::new(Algorithm::RS256);
        validation.validate_exp = false;
        let key = &DecodingKey::from_rsa_components(&self.n, &self.e)?;
        let claims = jsonwebtoken::decode::<Claims>(jwt_token, key, &validation)?;
        Ok(claims)
    }
```

**File:** types/src/jwks/rsa/mod.rs (L102-125)
```rust
    pub fn to_poseidon_scalar(&self) -> Result<ark_bn254::Fr> {
        let mut modulus = base64::decode_config(&self.n, URL_SAFE_NO_PAD)?;
        // The circuit only supports RSA256
        if modulus.len() != Self::RSA_MODULUS_BYTES {
            bail!(
                "Wrong modulus size, must be {} bytes",
                Self::RSA_MODULUS_BYTES
            );
        }

        // This is done to match the circuit, which requires the modulus in a verify specific format
        // due to how RSA verification is implemented
        modulus.reverse();

        let mut scalars = modulus
            .chunks(24) // Pack 3 64 bit limbs per scalar, so chunk into 24 bytes per scalar
            .map(|chunk| {
                poseidon_bn254::keyless::pack_bytes_to_one_scalar(chunk)
                    .expect("chunk converts to scalar")
            })
            .collect::<Vec<ark_bn254::Fr>>();
        scalars.push(ark_bn254::Fr::from(Self::RSA_MODULUS_BYTES as i32));
        poseidon_bn254::hash_scalars(scalars)
    }
```

**File:** types/src/jwks/rsa/mod.rs (L132-177)
```rust
impl TryFrom<&serde_json::Value> for RSA_JWK {
    type Error = anyhow::Error;

    fn try_from(json_value: &serde_json::Value) -> Result<Self, Self::Error> {
        let kty = json_value
            .get("kty")
            .ok_or_else(|| anyhow!("Field `kty` not found"))?
            .as_str()
            .ok_or_else(|| anyhow!("Field `kty` is not a string"))?
            .to_string();

        ensure!(
            kty.as_str() == "RSA",
            "json to rsa jwk conversion failed with incorrect kty"
        );

        let ret = Self {
            kty,
            kid: json_value
                .get("kid")
                .ok_or_else(|| anyhow!("Field `kid` not found"))?
                .as_str()
                .ok_or_else(|| anyhow!("Field `kid` is not a string"))?
                .to_string(),
            alg: json_value
                .get("alg")
                .ok_or_else(|| anyhow!("Field `alg` not found"))?
                .as_str()
                .ok_or_else(|| anyhow!("Field `alg` is not a string"))?
                .to_string(),
            e: json_value
                .get("e")
                .ok_or_else(|| anyhow!("Field `e` not found"))?
                .as_str()
                .ok_or_else(|| anyhow!("Field `e` is not a string"))?
                .to_string(),
            n: json_value
                .get("n")
                .ok_or_else(|| anyhow!("Field `n` not found"))?
                .as_str()
                .ok_or_else(|| anyhow!("Field `n` is not a string"))?
                .to_string(),
        };

        Ok(ret)
    }
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager/mod.rs (L184-228)
```rust
    pub fn process_new_observation(
        &mut self,
        issuer: Issuer,
        jwks: Vec<JWKMoveStruct>,
    ) -> Result<()> {
        debug!(
            epoch = self.epoch_state.epoch,
            issuer = String::from_utf8(issuer.clone()).ok(),
            "Processing new observation."
        );
        let state = self.states_by_issuer.entry(issuer.clone()).or_default();
        state.observed = Some(jwks.clone());
        if state.observed.as_ref() != state.on_chain.as_ref().map(ProviderJWKs::jwks) {
            let observed = ProviderJWKs {
                issuer: issuer.clone(),
                version: state.on_chain_version() + 1,
                jwks,
            };
            let signature = self
                .consensus_key
                .sign(&observed)
                .context("process_new_observation failed with signing error")?;
            let abort_handle = self
                .update_certifier
                .start_produce(
                    self.epoch_state.clone(),
                    observed.clone(),
                    self.qc_update_tx.clone(),
                )
                .context(
                    "process_new_observation failed with update_certifier.start_produce failure",
                )?;
            state.consensus_state = ConsensusState::InProgress {
                my_proposal: ObservedUpdate {
                    author: self.my_addr,
                    observed: observed.clone(),
                    signature,
                },
                abort_handle_wrapper: QuorumCertProcessGuard::new(abort_handle),
            };
            info!("[JWK] update observed, update={:?}", observed);
        }

        Ok(())
    }
```

**File:** aptos-move/aptos-vm/src/keyless_validation.rs (L390-395)
```rust
                    // We are now ready to verify the RSA signature
                    openid_sig
                        .verify_jwt_signature(rsa_jwk, &signature.jwt_header_json)
                        .map_err(|_| {
                            invalid_signature!("RSA signature verification failed for OpenIdSig")
                        })?;
```

**File:** types/src/jwks/rsa/tests.rs (L12-75)
```rust
fn convert_json_to_rsa_jwk() {
    // Valid JWK JSON should be accepted.
    let json_str =
        r#"{"alg": "RS256", "kid": "kid1", "e": "AQAB", "use": "sig", "kty": "RSA", "n": "13131"}"#;
    let json = serde_json::Value::from_str(json_str).unwrap();
    let actual = RSA_JWK::try_from(&json);
    let expected = RSA_JWK::new_from_strs("kid1", "RSA", "RS256", "AQAB", "13131");
    assert_eq!(expected, actual.unwrap());

    // JWK JSON without `kid` should be rejected.
    let json_str = r#"{"alg": "RS256", "e": "AQAB", "use": "sig", "kty": "RSA", "n": "13131"}"#;
    let json = serde_json::Value::from_str(json_str).unwrap();
    assert!(RSA_JWK::try_from(&json).is_err());

    // JWK JSON with wrong `kid` type should be rejected.
    let json_str =
        r#"{"alg": "RS256", "kid": {}, "e": "AQAB", "use": "sig", "kty": "RSA", "n": "13131"}"#;
    let json = serde_json::Value::from_str(json_str).unwrap();
    assert!(RSA_JWK::try_from(&json).is_err());

    // JWK JSON without `alg` should be rejected.
    let json_str = r#"{"kid": "kid1", "e": "AQAB", "use": "sig", "kty": "RSA", "n": "13131"}"#;
    let json = serde_json::Value::from_str(json_str).unwrap();
    assert!(RSA_JWK::try_from(&json).is_err());

    // JWK JSON with wrong `alg` type should be rejected.
    let json_str =
        r#"{"alg": 0, "kid": "kid1", "e": "AQAB", "use": "sig", "kty": "RSA", "n": "13131"}"#;
    let json = serde_json::Value::from_str(json_str).unwrap();
    assert!(RSA_JWK::try_from(&json).is_err());

    // JWK JSON without `kty` should be rejected.
    let json_str = r#"{"alg": "RS256", "kid": "kid1", "e": "AQAB", "use": "sig", "n": "13131"}"#;
    let json = serde_json::Value::from_str(json_str).unwrap();
    assert!(RSA_JWK::try_from(&json).is_err());

    // JWK JSON with wrong `kty` value should be rejected.
    let json_str =
        r#"{"alg": "RS256", "kid": "kid1", "e": "AQAB", "use": "sig", "kty": "RSB", "n": "13131"}"#;
    let json = serde_json::Value::from_str(json_str).unwrap();
    assert!(RSA_JWK::try_from(&json).is_err());

    // JWK JSON without `e` should be rejected.
    let json_str = r#"{"alg": "RS256", "kid": "kid1", "use": "sig", "kty": "RSA", "n": "13131"}"#;
    let json = serde_json::Value::from_str(json_str).unwrap();
    assert!(RSA_JWK::try_from(&json).is_err());

    // JWK JSON with wrong `e` type should be rejected.
    let json_str =
        r#"{"alg": "RS256", "kid": "kid1", "e": 65537, "use": "sig", "kty": "RSA", "n": "13131"}"#;
    let json = serde_json::Value::from_str(json_str).unwrap();
    assert!(RSA_JWK::try_from(&json).is_err());

    // JWK JSON without `n` should be rejected.
    let json_str = r#"{"alg": "RS256", "kid": "kid1", "e": "AQAB", "use": "sig", "kty": "RSA"}"#;
    let json = serde_json::Value::from_str(json_str).unwrap();
    assert!(RSA_JWK::try_from(&json).is_err());

    // JWK JSON with wrong `n` type should be rejected.
    let json_str =
        r#"{"alg": "RS256", "kid": "kid1", "e": "AQAB", "use": "sig", "kty": "RSA", "n": false}"#;
    let json = serde_json::Value::from_str(json_str).unwrap();
    assert!(RSA_JWK::try_from(&json).is_err());
}
```

**File:** types/src/keyless/openid_sig.rs (L126-139)
```rust
    pub fn verify_jwt_signature(
        &self,
        rsa_jwk: &RSA_JWK,
        jwt_header_json: &str,
    ) -> anyhow::Result<()> {
        let jwt_b64 = format!(
            "{}.{}.{}",
            base64url_encode_str(jwt_header_json),
            base64url_encode_str(&self.jwt_payload_json),
            base64url_encode_bytes(&self.jwt_sig)
        );
        rsa_jwk.verify_signature_without_exp_check(&jwt_b64)?;
        Ok(())
    }
```
