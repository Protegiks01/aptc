# Audit Report

## Title
Gas Undercharging Vulnerability in BLS12-381 Public Key Subgroup Check Operation

## Summary
The `bls12381_pk_subgroub_check` function incorrectly charges `BLS12381_PER_PUBKEY_DESERIALIZE` (400,684 gas) instead of `BLS12381_PER_PUBKEY_SUBGROUP_CHECK` (1,360,120 gas), resulting in a 959,436 gas undercharge (~70.6% discount) per operation. This allows attackers to consume significantly more computational resources than they pay for, enabling validator node resource exhaustion attacks.

## Finding Description

The BLS12-381 gas metering implementation contains a critical bug where the wrong gas parameter constant is used for the public key subgroup check operation.

**Root Cause**: The function charges using the wrong constant: [1](#0-0) 

**Expected Behavior**: The function should charge `BLS12381_PER_PUBKEY_SUBGROUP_CHECK` as defined in the GasParameters struct: [2](#0-1) 

The correct gas value is 1,360,120 gas units: [3](#0-2) 

**Actual Behavior**: It charges `BLS12381_PER_PUBKEY_DESERIALIZE` (400,684 gas): [4](#0-3) 

**Attack Path**:

1. Attacker calls `bls12381::public_key_from_bytes()` from Move code: [5](#0-4) 

2. This invokes the native function `validate_pubkey_internal`: [6](#0-5) 

3. Which calls `native_bls12381_validate_pubkey` that executes the buggy subgroup check: [7](#0-6) 

4. Alternatively, via `verify_normal_signature()`: [8](#0-7) 

Which calls the helper with `check_pk_subgroup = true`: [9](#0-8) 

Leading to the buggy function call: [10](#0-9) 

5. The buggy function performs the expensive `pk.subgroup_check()` operation: [11](#0-10) 

**Developer Intent Confirmed**: Function comments explicitly document that `per_pubkey_subgroup_check_cost` should be charged: [12](#0-11) [13](#0-12) 

**Comparison with Correct Implementation**: The signature subgroup check correctly uses the appropriate constant: [14](#0-13) 

## Impact Explanation

**Severity: High** (per Aptos Bug Bounty: "Validator node slowdowns")

This vulnerability enables resource exhaustion attacks against validator nodes. The subgroup check is computationally expensive, taking approximately 39 microseconds per call: [15](#0-14) 

**Quantified Impact**:
- **Gas Undercharge**: 959,436 gas per operation (70.6% of correct cost)
- **Computational Asymmetry**: Attacker pays ~400K gas but consumes ~1.36M gas worth of CPU
- **Attack Multiplier**: Attacker can perform ~3.4x more operations than paid for, directly impacting validator CPU resources

**Attack Scenario**:
An attacker crafts transactions repeatedly calling these public Move functions with valid BLS12-381 points. Each call triggers the undercharged subgroup check, allowing the attacker to:
1. Slow down validator block processing by consuming excessive CPU cycles
2. Reduce network transaction throughput
3. Increase block processing time, affecting liveness
4. Cause sustained validator performance degradation

This directly matches the Aptos Bug Bounty HIGH severity category: "Validator node slowdowns" (up to $50,000).

## Likelihood Explanation

**Likelihood: High**

- **No Privileges Required**: Any user can submit transactions calling these public Move functions
- **Easy to Exploit**: Simply call `bls12381::public_key_from_bytes()` repeatedly with valid BLS12-381 public key bytes
- **Low Detection**: Appears as legitimate cryptographic operations
- **Repeatable**: Can execute across multiple transactions or within single large transactions
- **Economic Incentive**: Attack is ~70% cheaper than it should be, making sustained attacks economically viable

The bug has been present since BLS12-381 native functions were implemented and affects all nodes processing transactions containing these calls.

## Recommendation

Change line 158 to charge the correct gas constant:

```rust
context.charge(BLS12381_PER_PUBKEY_SUBGROUP_CHECK * NumArgs::one())?;
```

This aligns the implementation with the documented behavior and ensures proper gas metering for the expensive subgroup check operation.

## Proof of Concept

```move
#[test(account = @0x1)]
public fun test_gas_undercharge_exploit(account: &signer) {
    // Valid BLS12-381 G1 point (48 bytes)
    let valid_pk = x"ae3cd9403b69c20a0d455fd860e977fe6ee7140a7f091f26c860f2caccd3e0a7a7365798ac10df776675b3a67db8faa1";
    
    // Each call triggers undercharged subgroup check
    // Should cost 1,360,120 gas but only charges 400,684 gas
    let pk_opt = bls12381::public_key_from_bytes(valid_pk);
    assert!(option::is_some(&pk_opt), 1);
    
    // Attacker can repeat this many times in a transaction
    // consuming 3.4x more validator CPU than paid for
}
```

**Notes**:
- The gas parameter `bls12381_per_pubkey_subgroup_check` is defined but the corresponding uppercase constant `BLS12381_PER_PUBKEY_SUBGROUP_CHECK` is never used in the codebase, confirming this is an undetected implementation bug
- Both Move functions (`public_key_from_bytes` and `verify_normal_signature`) are publicly accessible
- The vulnerability affects current mainnet configuration and all validator nodes
- This is NOT a network DoS attack but a gas metering bug enabling computational resource exhaustion

### Citations

**File:** aptos-move/framework/src/natives/cryptography/bls12381.rs (L55-55)
```rust
    pub per_pubkey_subgroup_check: InternalGasPerArg,
```

**File:** aptos-move/framework/src/natives/cryptography/bls12381.rs (L157-157)
```rust
    // NOTE(Gas): constant-time; around 39 microseconds on Apple M1
```

**File:** aptos-move/framework/src/natives/cryptography/bls12381.rs (L158-158)
```rust
    context.charge(BLS12381_PER_PUBKEY_DESERIALIZE * NumArgs::one())?;
```

**File:** aptos-move/framework/src/natives/cryptography/bls12381.rs (L160-160)
```rust
    Ok(pk.subgroup_check().is_ok())
```

**File:** aptos-move/framework/src/natives/cryptography/bls12381.rs (L168-168)
```rust
    context.charge(BLS12381_PER_SIG_SUBGROUP_CHECK * NumArgs::one())?;
```

**File:** aptos-move/framework/src/natives/cryptography/bls12381.rs (L196-196)
```rust
///                     +? ( per_pubkey_subgroup_check_cost * check_pk_subgroup
```

**File:** aptos-move/framework/src/natives/cryptography/bls12381.rs (L225-226)
```rust
    if check_pk_subgroup && !bls12381_pk_subgroub_check(&pk, context)? {
        return Ok(smallvec![Value::bool(false)]);
```

**File:** aptos-move/framework/src/natives/cryptography/bls12381.rs (L387-387)
```rust
 *   gas cost: base_cost + per_pubkey_deserialize_cost +? per_pubkey_subgroup_check_cost
```

**File:** aptos-move/framework/src/natives/cryptography/bls12381.rs (L409-409)
```rust
    let valid = bls12381_pk_subgroub_check(&pk, context)?;
```

**File:** aptos-move/framework/src/natives/cryptography/bls12381.rs (L544-545)
```rust
    let check_pk_subgroup = true;
    bls12381_verify_signature_helper(context, ty_args, arguments, check_pk_subgroup)
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/aptos_framework.rs (L174-174)
```rust
        [bls12381_per_pubkey_deserialize: InternalGasPerArg, "bls12381.per_pubkey_deserialize", 400684],
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/aptos_framework.rs (L176-176)
```rust
        [bls12381_per_pubkey_subgroup_check: InternalGasPerArg, "bls12381.per_pubkey_subgroup_check", 1360120],
```

**File:** aptos-move/framework/aptos-stdlib/sources/cryptography/bls12381.move (L87-95)
```text
    public fun public_key_from_bytes(bytes: vector<u8>): Option<PublicKey> {
        if (validate_pubkey_internal(bytes)) {
            option::some(PublicKey {
                bytes
            })
        } else {
            option::none<PublicKey>()
        }
    }
```

**File:** aptos-move/framework/aptos-stdlib/sources/cryptography/bls12381.move (L229-235)
```text
    public fun verify_normal_signature(
        signature: &Signature,
        public_key: &PublicKey,
        message: vector<u8>
    ): bool {
        verify_normal_signature_internal(signature.bytes, public_key.bytes, message)
    }
```

**File:** aptos-move/framework/aptos-stdlib/sources/cryptography/bls12381.move (L390-390)
```text
    native fun validate_pubkey_internal(public_key: vector<u8>): bool;
```
