# Audit Report

## Title
Metrics Endpoint Blocking Vulnerability: Synchronous Encoding on Async Runtime Causes Service Unavailability

## Summary
The inspection service's metrics endpoints (`/metrics` and `/json_metrics`) perform blocking synchronous operations (metric gathering and encoding) directly on tokio async worker threads without using `spawn_blocking()`. This allows concurrent requests to exhaust all worker threads, making the entire inspection service—including critical health monitoring endpoints—unresponsive for extended periods.

## Finding Description

The vulnerability exists in the metrics encoding flow where CPU-intensive synchronous operations execute on async runtime worker threads: [1](#0-0) [2](#0-1) 

The handlers are called from an async context without proper isolation: [3](#0-2) 

The runtime is configured with default worker threads and no request concurrency limits: [4](#0-3) [5](#0-4) 

**Attack Scenario:**

1. Attacker (or even legitimate monitoring systems) sends concurrent HTTP GET requests to `/metrics` or `/json_metrics`
2. Each request triggers synchronous blocking operations:
   - `aptos_metrics_core::gather()` - collects all metrics from Prometheus registry
   - `encoder.encode()` - iterates through all metric families and encodes them
3. The codebase explicitly warns about metric families with >2000 dimensions, indicating this can be CPU-intensive: [6](#0-5) 

4. Without `spawn_blocking()`, these operations execute on tokio worker threads
5. With enough concurrent requests, all worker threads become blocked
6. New requests (including `/consensus_health_check` and other critical endpoints) queue indefinitely
7. Validator health monitoring becomes unavailable

**Broken Invariant:** Resource Limits - All operations must respect computational limits. The blocking operations violate this by monopolizing async runtime threads without proper isolation.

## Impact Explanation

This vulnerability fits **Medium Severity** per the Aptos bug bounty program criteria:

- **Not Critical**: Does not affect consensus safety, cause fund loss, or create non-recoverable network partitions
- **Not High**: While it impacts validator monitoring, the validator node's core functionality (consensus participation, block production) continues unaffected
- **Medium Impact**: Creates operational issues requiring intervention:
  - Validator operators lose visibility into node health via the inspection service
  - Health check endpoint (`/consensus_health_check`) becomes unavailable, preventing automated monitoring systems from detecting consensus failures
  - Requires manual intervention (service restart) to restore monitoring capabilities

The security question itself categorizes this as Medium severity, which aligns with operational degradation that doesn't directly impact consensus or fund security.

## Likelihood Explanation

**High Likelihood:**

- **Low Attacker Skill**: Exploiting requires only sending HTTP GET requests to publicly exposed endpoints
- **No Authentication Required**: The inspection service listens on port 9101 with no authentication: [7](#0-6) 

- **No Rate Limiting**: No connection limits or concurrency controls exist: [8](#0-7) 

- **Legitimate Trigger**: Even without malicious intent, multiple monitoring systems polling metrics simultaneously can trigger this condition
- **Evidence of Real Concern**: The codebase contains warnings about high metric cardinality (>2000 dimensions), indicating this is a known performance concern: [9](#0-8) 

## Recommendation

Wrap the blocking metric operations in `tokio::task::spawn_blocking()` to isolate them from async worker threads:

```rust
// In crates/aptos-inspection-service/src/server/metrics.rs

pub async fn handle_json_metrics_request() -> (StatusCode, Body, String) {
    let buffer = tokio::task::spawn_blocking(|| {
        utils::get_encoded_metrics(JsonEncoder)
    })
    .await
    .unwrap_or_else(|_| {
        error!("Failed to join metric encoding task");
        vec![]
    });
    (StatusCode::OK, Body::from(buffer), CONTENT_TYPE_JSON.into())
}

pub async fn handle_metrics_request() -> (StatusCode, Body, String) {
    let buffer = tokio::task::spawn_blocking(|| {
        utils::get_encoded_metrics(TextEncoder::new())
    })
    .await
    .unwrap_or_else(|_| {
        error!("Failed to join metric encoding task");
        vec![]
    });
    (StatusCode::OK, Body::from(buffer), CONTENT_TYPE_TEXT.into())
}
```

Update function signatures to async: [10](#0-9) 

Additionally, consider adding:
1. **Request timeout**: Use `tokio::time::timeout()` to limit encoding duration
2. **Concurrency limits**: Implement semaphore-based rate limiting for metrics endpoints
3. **Connection limits**: Configure hyper server with `http1_max_buf_size()` and connection limits

## Proof of Concept

```rust
// Reproduction test demonstrating worker thread exhaustion
// Add to crates/aptos-inspection-service/src/server/tests.rs

#[tokio::test(flavor = "multi_thread", worker_threads = 2)]
async fn test_concurrent_metrics_blocking() {
    use std::time::{Duration, Instant};
    
    // Start inspection service with 2 worker threads
    let node_config = NodeConfig::default();
    let (client, _peers_and_metadata) = create_test_client();
    
    start_inspection_service(
        node_config.clone(),
        client.clone(),
        _peers_and_metadata,
    );
    
    // Wait for service to start
    tokio::time::sleep(Duration::from_millis(100)).await;
    
    // Send 10 concurrent requests (more than worker threads)
    let client = reqwest::Client::new();
    let url = format!("http://{}:{}/metrics", 
        node_config.inspection_service.address,
        node_config.inspection_service.port);
    
    let start = Instant::now();
    let mut handles = vec![];
    
    for _ in 0..10 {
        let client = client.clone();
        let url = url.clone();
        let handle = tokio::spawn(async move {
            client.get(&url).send().await
        });
        handles.push(handle);
    }
    
    // All requests should complete within reasonable time
    // If blocking occurs, some requests will timeout
    let timeout_duration = Duration::from_secs(5);
    let results = tokio::time::timeout(
        timeout_duration,
        futures::future::join_all(handles),
    ).await;
    
    match results {
        Ok(_) => println!("All requests completed in {:?}", start.elapsed()),
        Err(_) => {
            panic!("Worker threads blocked! Requests did not complete within {:?}", 
                timeout_duration);
        }
    }
}
```

**Manual reproduction steps:**
1. Start an Aptos validator node with inspection service enabled
2. Use a tool like `ab` (Apache Bench) or `wrk` to send concurrent requests:
   ```bash
   ab -n 1000 -c 50 http://localhost:9101/metrics
   ```
3. Observe response times increase significantly as worker threads block
4. During the load test, attempt to access `/consensus_health_check` - it will be delayed or timeout
5. Monitor with: `curl -w "@curl-format.txt" http://localhost:9101/metrics`

**Notes**

This vulnerability demonstrates a common async/sync mismatch pattern where blocking operations execute on async runtimes. While validator consensus continues unaffected, the inability to monitor validator health creates operational blind spots that could mask actual consensus or liveness failures. The fix is straightforward but requires changing handler signatures to async and using `spawn_blocking()` for CPU-intensive encoding work.

### Citations

**File:** crates/aptos-inspection-service/src/server/utils.rs (L32-47)
```rust
pub fn get_encoded_metrics(encoder: impl Encoder) -> Vec<u8> {
    // Gather and encode the metrics
    let metric_families = get_metric_families();
    let mut encoded_buffer = vec![];
    if let Err(error) = encoder.encode(&metric_families, &mut encoded_buffer) {
        error!("Failed to encode metrics! Error: {}", error);
        return vec![];
    }

    // Update the total metric bytes counter
    NUM_METRICS
        .with_label_values(&["total_bytes"])
        .inc_by(encoded_buffer.len() as u64);

    encoded_buffer
}
```

**File:** crates/aptos-inspection-service/src/server/utils.rs (L56-67)
```rust
    for metric_family in &metric_families {
        let family_count = metric_family.get_metric().len();
        if family_count > 2000 {
            families_over_2000 = families_over_2000.saturating_add(1);
            let name = metric_family.get_name();
            warn!(
                count = family_count,
                metric_family = name,
                "Metric Family '{}' over 2000 dimensions '{}'",
                name,
                family_count
            );
```

**File:** crates/aptos-inspection-service/src/server/metrics.rs (L66-76)
```rust
/// Handles a new metrics request (with JSON encoding)
pub fn handle_json_metrics_request() -> (StatusCode, Body, String) {
    let buffer = utils::get_encoded_metrics(JsonEncoder);
    (StatusCode::OK, Body::from(buffer), CONTENT_TYPE_JSON.into())
}

/// Handles a new metrics request (with text encoding)
pub fn handle_metrics_request() -> (StatusCode, Body, String) {
    let buffer = utils::get_encoded_metrics(TextEncoder::new());
    (StatusCode::OK, Body::from(buffer), CONTENT_TYPE_TEXT.into())
}
```

**File:** crates/aptos-inspection-service/src/server/mod.rs (L72-73)
```rust
    let runtime = aptos_runtimes::spawn_named_runtime("inspection".into(), None);

```

**File:** crates/aptos-inspection-service/src/server/mod.rs (L104-146)
```rust
async fn serve_requests(
    req: Request<Body>,
    node_config: NodeConfig,
    aptos_data_client: AptosDataClient,
    peers_and_metadata: Arc<PeersAndMetadata>,
) -> Result<Response<Body>, hyper::Error> {
    // Process the request and get the response components
    let (status_code, body, content_type) = match req.uri().path() {
        CONFIGURATION_PATH => {
            // /configuration
            // Exposes the node configuration
            configuration::handle_configuration_request(&node_config)
        },
        CONSENSUS_HEALTH_CHECK_PATH => {
            // /consensus_health_check
            // Exposes the consensus health check
            metrics::handle_consensus_health_check(&node_config).await
        },
        FORGE_METRICS_PATH => {
            // /forge_metrics
            // Exposes forge encoded metrics
            metrics::handle_forge_metrics()
        },
        IDENTITY_INFORMATION_PATH => {
            // /identity_information
            // Exposes the identity information of the node
            identity_information::handle_identity_information_request(&node_config)
        },
        INDEX_PATH => {
            // /
            // Exposes the index and list of available endpoints
            index::handle_index_request()
        },
        JSON_METRICS_PATH => {
            // /json_metrics
            // Exposes JSON encoded metrics
            metrics::handle_json_metrics_request()
        },
        METRICS_PATH => {
            // /metrics
            // Exposes text encoded metrics
            metrics::handle_metrics_request()
        },
```

**File:** crates/aptos-runtimes/src/lib.rs (L27-62)
```rust
    const MAX_BLOCKING_THREADS: usize = 64;

    // Verify the given name has an appropriate length
    if thread_name.len() > MAX_THREAD_NAME_LENGTH {
        panic!(
            "The given runtime thread name is too long! Max length: {}, given name: {}",
            MAX_THREAD_NAME_LENGTH, thread_name
        );
    }

    // Create the runtime builder
    let atomic_id = AtomicUsize::new(0);
    let thread_name_clone = thread_name.clone();
    let mut builder = Builder::new_multi_thread();
    builder
        .thread_name_fn(move || {
            let id = atomic_id.fetch_add(1, Ordering::SeqCst);
            format!("{}-{}", thread_name_clone, id)
        })
        .on_thread_start(on_thread_start)
        .disable_lifo_slot()
        // Limit concurrent blocking tasks from spawn_blocking(), in case, for example, too many
        // Rest API calls overwhelm the node.
        .max_blocking_threads(MAX_BLOCKING_THREADS)
        .enable_all();
    if let Some(num_worker_threads) = num_worker_threads {
        builder.worker_threads(num_worker_threads);
    }

    // Spawn and return the runtime
    builder.build().unwrap_or_else(|error| {
        panic!(
            "Failed to spawn named runtime! Name: {:?}, Error: {:?}",
            thread_name, error
        )
    })
```

**File:** config/src/config/inspection_service_config.rs (L15-24)
```rust
#[derive(Clone, Debug, Deserialize, PartialEq, Eq, Serialize)]
#[serde(default, deny_unknown_fields)]
pub struct InspectionServiceConfig {
    pub address: String,
    pub port: u16,
    pub expose_configuration: bool,
    pub expose_identity_information: bool,
    pub expose_peer_information: bool,
    pub expose_system_information: bool,
}
```

**File:** config/src/config/inspection_service_config.rs (L26-36)
```rust
impl Default for InspectionServiceConfig {
    fn default() -> InspectionServiceConfig {
        InspectionServiceConfig {
            address: "0.0.0.0".to_string(),
            port: 9101,
            expose_configuration: false,
            expose_identity_information: true,
            expose_peer_information: true,
            expose_system_information: true,
        }
    }
```

**File:** crates/aptos-faucet/metrics-server/src/gather_metrics.rs (L20-33)
```rust
    // Take metrics of metric gathering so we know possible overhead of this process
    for metric_family in &metric_families {
        let family_count = metric_family.get_metric().len();
        if family_count > 2000 {
            families_over_2000 = families_over_2000.saturating_add(1);
            let name = metric_family.get_name();
            warn!(
                count = family_count,
                metric_family = name,
                "Metric Family '{}' over 2000 dimensions '{}'",
                name,
                family_count
            );
        }
```
