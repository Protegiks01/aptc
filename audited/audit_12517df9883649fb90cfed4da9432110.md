# Audit Report

## Title
Missing Validation: Zero Minimum Stake Allows Ghost Staking Contracts

## Summary
The `staking_config.move` module's `validate_required_stake` function does not enforce that `minimum_stake` must be greater than zero. If governance sets `minimum_stake` to 0, users can create staking contracts with zero APT, leading to ghost contracts that consume state storage and potentially bloat the validator set without contributing to network security.

## Finding Description

The vulnerability exists in the staking configuration validation logic. When governance updates the minimum stake requirement, the validation function only checks that `minimum_stake <= maximum_stake && maximum_stake > 0`, explicitly allowing `minimum_stake` to be 0. [1](#0-0) 

This creates a vulnerability chain:

1. Governance can set `minimum_stake = 0` through the `update_required_stake` function [2](#0-1) 

2. When creating staking contracts, the validation checks `principal >= min_stake_required` [3](#0-2) 

3. If `min_stake_required = 0`, zero-amount staking contracts pass validation and are created successfully

4. Zero-stake validators can join the validator set when `minimum_stake = 0` [4](#0-3) 

Each zero-amount contract creates multiple resources consuming state storage: StakePool, ValidatorConfig, Staker resource, event handles, and a resource account.

## Impact Explanation

This is a **Low severity** issue (per the question classification) because:

1. **Requires governance misconfiguration**: Exploitation requires governance to first set `minimum_stake = 0`, which is economically irrational for production networks
2. **Limited direct impact**: Zero-stake validators have 0 voting power and don't affect consensus decisions
3. **Economic disincentives**: Attackers pay gas for each ghost contract creation
4. **State bloat**: Primary concern is unnecessary state storage consumption and potential validator set bloating

However, it represents a missing defensive validation that could prevent problematic configurations entirely.

## Likelihood Explanation

The likelihood is **Very Low** in production because:
- Governance (a trusted entity) would need to vote to set `minimum_stake = 0`
- Production networks maintain high minimum stake requirements (typically 1M+ APT)
- The economic security model of the network depends on non-zero minimum stake
- Test environments intentionally use `minimum_stake = 0` for flexibility [5](#0-4) 

## Recommendation

Add explicit validation that `minimum_stake > 0` in the `validate_required_stake` function:

```move
fun validate_required_stake(minimum_stake: u64, maximum_stake: u64) {
    assert!(minimum_stake > 0, error::invalid_argument(EZERO_MINIMUM_STAKE));
    assert!(minimum_stake <= maximum_stake && maximum_stake > 0, error::invalid_argument(EINVALID_STAKE_RANGE));
}
```

Add a new error constant:
```move
const EZERO_MINIMUM_STAKE: u64 = 11;
```

For test environments requiring `minimum_stake = 0`, use the existing `#[test_only]` `initialize_for_test` function which bypasses validation.

## Proof of Concept

```move
#[test(aptos_framework = @aptos_framework, user = @0x123)]
fun test_zero_amount_staking_contract_when_min_stake_zero(
    aptos_framework: &signer,
    user: &signer
) {
    // Setup: Initialize staking config with minimum_stake = 0
    staking_config::initialize_for_test(aptos_framework, 0, 1000000, 7200, true, 1, 100, 10);
    
    // Verify minimum_stake is 0
    let config = staking_config::get();
    let (min_stake, _) = staking_config::get_required_stake(&config);
    assert!(min_stake == 0, 1);
    
    // User creates staking contract with amount = 0
    // This should ideally fail but currently succeeds when minimum_stake = 0
    staking_contract::create_staking_contract(
        user,
        @0x456,  // operator
        @0x789,  // voter  
        0,       // amount = 0 (GHOST CONTRACT)
        10,      // commission_percentage
        vector::empty()
    );
    
    // Ghost contract successfully created, consuming storage
    assert!(staking_contract::staking_contract_exists(signer::address_of(user), @0x456), 2);
}
```

## Notes

This finding represents a **defense-in-depth** weakness rather than an immediately exploitable vulnerability. While the code technically allows `minimum_stake = 0`, production deployments maintain high minimum stake values through governance. The recommendation enforces this invariant at the protocol level, preventing misconfiguration regardless of governance actions.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/configs/staking_config.move (L274-285)
```text
    public fun update_required_stake(
        aptos_framework: &signer,
        minimum_stake: u64,
        maximum_stake: u64,
    ) acquires StakingConfig {
        system_addresses::assert_aptos_framework(aptos_framework);
        validate_required_stake(minimum_stake, maximum_stake);

        let staking_config = borrow_global_mut<StakingConfig>(@aptos_framework);
        staking_config.minimum_stake = minimum_stake;
        staking_config.maximum_stake = maximum_stake;
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/staking_config.move (L372-374)
```text
    fun validate_required_stake(minimum_stake: u64, maximum_stake: u64) {
        assert!(minimum_stake <= maximum_stake && maximum_stake > 0, error::invalid_argument(EINVALID_STAKE_RANGE));
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/staking_config.move (L409-409)
```text
        initialize_for_test(&aptos_framework, 0, 1, 1, false, 1, 1, 1);
```

**File:** aptos-move/framework/aptos-framework/sources/staking_contract.move (L417-423)
```text
        let (min_stake_required, _) =
            staking_config::get_required_stake(&staking_config::get());
        let principal = coin::value(&coins);
        assert!(
            principal >= min_stake_required,
            error::invalid_argument(EINSUFFICIENT_STAKE_AMOUNT)
        );
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1072-1076)
```text
        let config = staking_config::get();
        let (minimum_stake, maximum_stake) = staking_config::get_required_stake(&config);
        let voting_power = get_next_epoch_voting_power(stake_pool);
        assert!(voting_power >= minimum_stake, error::invalid_argument(ESTAKE_TOO_LOW));
        assert!(voting_power <= maximum_stake, error::invalid_argument(ESTAKE_TOO_HIGH));
```
