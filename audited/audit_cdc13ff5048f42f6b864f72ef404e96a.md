# Audit Report

## Title
IPv4-Mapped IPv6 Address Bypass in Faucet IP Allowlist/Blocklist Implementation

## Summary
The faucet's IP range management system treats IPv4 and IPv6 addresses as completely separate entities, failing to canonicalize IPv4-mapped IPv6 addresses (e.g., `::ffff:192.0.2.1`). This allows attackers to bypass IP blocklists and causes legitimate users to be denied by IP allowlists when the same logical IP address is presented in different formats.

## Finding Description
The `IpRangeManager` implementation separates IPv4 and IPv6 address checking into distinct lists without any canonicalization of IPv4-mapped IPv6 addresses. [1](#0-0) 

When a client connects to the faucet, their source IP is extracted and checked against configured allowlists and blocklists. [2](#0-1) 

The same separation occurs in the IP blocklist checker: [3](#0-2) 

**Attack Scenario:**

1. An attacker's IPv4 address `1.2.3.4` is added to the IP blocklist
2. The faucet is configured to listen on `::` (all addresses, supporting both IPv4 and IPv6)
3. When the attacker connects from IPv4, the OS may represent this as IPv4-mapped IPv6: `::ffff:1.2.3.4`
4. The blocklist check at line 41-46 checks the IPv6 list, which doesn't contain the mapped address
5. The attacker bypasses the blocklist and gains faucet access

**Reverse Scenario (Denial of Service):**

1. A legitimate internal service at `10.0.0.5` is added to the IP allowlist (IPv4 format)
2. The service connects via IPv6, represented as `::ffff:10.0.0.5`
3. The allowlist check at line 58 checks the IPv6 list, which is empty
4. The legitimate service is denied access

**Testing Gap:**

The existing integration tests create empty IP lists and never test actual IPv4/IPv6 address matching: [4](#0-3) [5](#0-4) 

There are no tests validating IPv4-mapped IPv6 address handling or cross-protocol IP range matching.

## Impact Explanation
This is assessed as **Medium severity** because:

1. **Access Control Bypass**: Attackers can circumvent IP blocklists, violating security controls designed to prevent abuse
2. **Limited Scope**: The vulnerability only affects the faucet service (testnet token distribution), not consensus, mainnet funds, or core blockchain operations
3. **Configuration Dependent**: Exploitation requires the faucet to be deployed listening on IPv6 addresses (default is IPv4-only at `0.0.0.0`)
4. **Denial of Service**: Legitimate users may be incorrectly denied service if IP formats don't match allowlist configuration

Per Aptos bug bounty criteria, this fits **Medium Severity** as it represents limited access control manipulation requiring specific deployment configuration, but does not affect consensus, validator operations, or mainnet funds.

## Likelihood Explanation
The likelihood is **Medium** because:

**Factors Increasing Likelihood:**
- Modern dual-stack networking is increasingly common
- Operators may deploy on IPv6 for scalability
- The code has no IPv4-mapped IPv6 handling whatsoever
- The testing gap means this has never been validated

**Factors Decreasing Likelihood:**
- Default configuration is IPv4-only (`0.0.0.0`)
- Many deployments use reverse proxies that may normalize addresses
- The faucet is typically deployed in controlled environments

The vulnerability is **definitely exploitable** if the faucet is configured to listen on `::`, but requires this non-default configuration.

## Recommendation
Implement IP address canonicalization to normalize IPv4-mapped IPv6 addresses before checking against allowlists/blocklists:

```rust
pub fn contains_ip(&self, ip: &IpAddr) -> bool {
    // Canonicalize IPv4-mapped IPv6 addresses to IPv4
    let canonical_ip = match ip {
        IpAddr::V6(ipv6) => {
            // Check if this is an IPv4-mapped IPv6 address (::ffff:0:0/96)
            if let Some(ipv4) = ipv6.to_ipv4_mapped() {
                IpAddr::V4(ipv4)
            } else {
                IpAddr::V6(*ipv6)
            }
        }
        IpAddr::V4(ipv4) => IpAddr::V4(*ipv4),
    };

    match canonical_ip {
        IpAddr::V4(ipv4) => self.ipv4_list.contains(&ipv4),
        IpAddr::V6(ipv6) => self.ipv6_list.contains(&ipv6),
    }
}
```

**Additional Recommendations:**
1. Add comprehensive tests for IPv4-mapped IPv6 addresses
2. Document the canonicalization behavior in configuration examples
3. Consider logging when IPv4-mapped addresses are detected for operational awareness

## Proof of Concept

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use std::fs::File;
    use std::io::Write;
    use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};
    use tempfile::NamedTempFile;

    #[test]
    fn test_ipv4_mapped_ipv6_blocklist_bypass() {
        // Create a blocklist with an IPv4 address
        let mut temp_file = NamedTempFile::new().unwrap();
        writeln!(temp_file, "192.0.2.1/32").unwrap();
        
        let config = IpRangeManagerConfig {
            file: temp_file.path().to_path_buf(),
        };
        
        let manager = IpRangeManager::new(config).unwrap();
        
        // The IPv4 address should be blocked
        let ipv4_addr = IpAddr::V4(Ipv4Addr::new(192, 0, 2, 1));
        assert!(manager.contains_ip(&ipv4_addr), "IPv4 address should be in blocklist");
        
        // The IPv4-mapped IPv6 equivalent should ALSO be blocked, but currently ISN'T
        let ipv4_mapped_ipv6 = IpAddr::V6(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc000, 0x201));
        
        // This assertion FAILS - demonstrating the vulnerability
        assert!(
            manager.contains_ip(&ipv4_mapped_ipv6),
            "IPv4-mapped IPv6 address should be blocked but bypasses the blocklist"
        );
    }

    #[test]
    fn test_ipv4_allowlist_ipv6_denial() {
        // Create an allowlist with an IPv4 address
        let mut temp_file = NamedTempFile::new().unwrap();
        writeln!(temp_file, "10.0.0.0/24").unwrap();
        
        let config = IpRangeManagerConfig {
            file: temp_file.path().to_path_buf(),
        };
        
        let manager = IpRangeManager::new(config).unwrap();
        
        // The IPv4 address should be allowed
        let ipv4_addr = IpAddr::V4(Ipv4Addr::new(10, 0, 0, 5));
        assert!(manager.contains_ip(&ipv4_addr), "IPv4 address should be in allowlist");
        
        // The IPv4-mapped IPv6 equivalent should ALSO be allowed, but currently ISN'T
        let ipv4_mapped_ipv6 = IpAddr::V6(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0x0a00, 0x0005));
        
        // This assertion FAILS - demonstrating denial of legitimate users
        assert!(
            manager.contains_ip(&ipv4_mapped_ipv6),
            "IPv4-mapped IPv6 address should be allowed but is denied"
        );
    }
}
```

## Notes

While this vulnerability exists in the faucet component (not a consensus-critical system), it represents a real access control bypass that could be exploited in production deployments configured for IPv6. The complete absence of tests for IPv4-mapped IPv6 addresses confirms this is an overlooked edge case in the implementation.

The fix is straightforward: canonicalize IPv4-mapped IPv6 addresses to their IPv4 equivalents before performing range checks. This ensures consistent behavior regardless of how the client's IP address is represented by the networking stack.

### Citations

**File:** crates/aptos-faucet/core/src/common/ip_range_manager.rs (L55-60)
```rust
    pub fn contains_ip(&self, ip: &IpAddr) -> bool {
        match ip {
            IpAddr::V4(ipv4) => self.ipv4_list.contains(ipv4),
            IpAddr::V6(ipv6) => self.ipv6_list.contains(ipv6),
        }
    }
```

**File:** crates/aptos-faucet/core/src/bypasser/ip_allowlist.rs (L25-29)
```rust
impl BypasserTrait for IpAllowlistBypasser {
    async fn request_can_bypass(&self, data: CheckerData) -> Result<bool> {
        Ok(self.manager.contains_ip(&data.source_ip))
    }
}
```

**File:** crates/aptos-faucet/core/src/checkers/ip_blocklist.rs (L32-49)
```rust
        match &data.source_ip {
            IpAddr::V4(source_ip) => {
                if self.manager.ipv4_list.contains(source_ip) {
                    return Ok(vec![RejectionReason::new(
                        format!("IP {} is in blocklist", source_ip),
                        RejectionReasonCode::IpInBlocklist,
                    )]);
                }
            },
            IpAddr::V6(source_ip) => {
                if self.manager.ipv6_list.contains(source_ip) {
                    return Ok(vec![RejectionReason::new(
                        format!("IP {} is in blocklist", source_ip),
                        RejectionReasonCode::IpInBlocklist,
                    )]);
                }
            },
        }
```

**File:** crates/aptos-faucet/core/src/server/run.rs (L544-544)
```rust
        make_ip_allowlist(&[])?;
```

**File:** crates/aptos-faucet/core/src/server/run.rs (L580-580)
```rust
        make_ip_blocklist(&[])?;
```
