# Audit Report

## Title
Captcha Solution Transfer Attack - Missing Session Binding in Faucet CAPTCHA Implementation

## Summary
The `/request_captcha` endpoint does not bind captcha challenges to any session, IP address, or request context, allowing captcha solutions to be transferred between different users and reused by automated bots to bypass the anti-automation protection.

## Finding Description

The faucet's TapCaptchaChecker implements an in-house CAPTCHA system to prevent automated abuse. The flow works as follows:

1. User calls `/request_captcha` which generates a random u32 key and captcha image
2. The challenge is stored in a global in-memory HashMap mapping key â†’ solution
3. User solves the captcha and submits key + solution via headers `CAPTCHA_KEY` and `CAPTCHA_VALUE` to `/fund`
4. The checker validates by looking up the key and comparing solutions [1](#0-0) 

The critical vulnerability is that the captcha challenge is stored with **no binding** to:
- Source IP address
- Session identifier  
- Receiver account address
- Request timestamp
- Any contextual information [2](#0-1) 

The validation only checks if the key exists and the solution matches: [3](#0-2) 

**Attack Scenario:**
1. Attacker requests 100 captchas from `/request_captcha`, obtaining 100 (key, image) pairs
2. Attacker solves all captchas (or outsources to solving service), getting 100 (key, solution) pairs
3. Attacker distributes these pre-solved captchas to bot network
4. Each bot makes `/fund` request with different (CAPTCHA_KEY, CAPTCHA_VALUE) headers
5. All bots bypass captcha without solving anything themselves

The code comments acknowledge reliance on external infrastructure: [4](#0-3) 

However, cookie-based sticky routing is for availability/correctness, **not security**. The application itself enforces no session binding.

## Impact Explanation

This is a **Medium severity** issue because:

- Allows complete bypass of CAPTCHA anti-bot protection through solution transfer/reuse
- Enables automated bot networks to drain testnet faucet resources
- Defeats the security control's intended purpose (proving human interaction)
- However, impact limited to testnet token distribution, not mainnet funds or consensus
- Other rate limiting mechanisms (IP-based, storage-based checkers) may provide partial protection

Per Aptos bug bounty Medium severity criteria: "Limited funds loss or manipulation" - this allows manipulation of testnet fund distribution rates.

## Likelihood Explanation

**High likelihood** of exploitation:
- Trivial to execute - requires only HTTP requests with correct headers
- No special privileges or infrastructure needed
- Captcha solving services readily available
- Bot networks can easily parallelize requests
- No cryptographic or complex attack requirements

## Recommendation

Bind captcha challenges to request context by:

1. **Add session/nonce binding:** Include source IP, timestamp, and random nonce when creating challenge
2. **Store contextual data:** Modify CaptchaManager.challenges to store `HashMap<u32, (String, ChallengeContext)>` where ChallengeContext includes IP, timestamp, nonce
3. **Validate context on check:** Compare stored context with actual request context
4. **Add expiration:** Auto-remove challenges after configurable timeout (e.g., 5 minutes)

**Example Fix:**

```rust
pub struct ChallengeContext {
    solution: String,
    source_ip: IpAddr,
    created_at: u64,
    nonce: String,
}

pub fn create_challenge(&mut self, source_ip: IpAddr) -> Result<(u32, Vec<u8>, String)> {
    let key = rand::thread_rng().gen_range(0, u32::MAX - 1);
    let nonce = uuid::Uuid::new_v4().to_string();
    // ... generate captcha ...
    self.challenges.insert(key, ChallengeContext {
        solution: name,
        source_ip,
        created_at: get_current_time_secs(),
        nonce: nonce.clone(),
    });
    Ok((key, image, nonce))
}

pub fn check_challenge(&mut self, key: u32, value: &str, 
                       source_ip: IpAddr, nonce: &str) -> Result<bool> {
    match self.challenges.get(&key) {
        Some(ctx) => {
            if ctx.source_ip != source_ip || ctx.nonce != nonce {
                bail!("Captcha context mismatch");
            }
            // ... rest of validation ...
        }
    }
}
```

## Proof of Concept

```bash
#!/bin/bash

# Step 1: Request captcha as User A
RESPONSE=$(curl -s -v http://faucet-endpoint/request_captcha 2>&1)
CAPTCHA_KEY=$(echo "$RESPONSE" | grep -i "captcha_key:" | awk '{print $3}')
# Download and solve captcha to get SOLUTION

# Step 2: Transfer (KEY, SOLUTION) to User B on different IP
# User B makes funding request using User A's captcha
curl -H 'Content-Type: application/json' \
     -H "CAPTCHA_KEY: $CAPTCHA_KEY" \
     -H "CAPTCHA_VALUE: $SOLUTION" \
     -d '{"address": "0xUserB_Address"}' \
     -X POST http://faucet-endpoint/fund

# Result: User B successfully bypasses captcha without solving it
# This can be repeated with bot network using pre-solved captchas
```

**Rust Test Reproduction:**
```rust
#[tokio::test]
async fn test_captcha_transfer_attack() {
    let mut manager = CaptchaManager::new();
    
    // User A requests captcha
    let (key, _image) = manager.create_challenge().unwrap();
    
    // Simulate solving captcha
    let solution = manager.challenges.get(&key).unwrap().clone();
    
    // User B (different context) uses User A's solution
    let result = manager.check_challenge(key, &solution).unwrap();
    
    // Attack succeeds - no context validation
    assert!(result);
}
```

### Citations

**File:** crates/aptos-faucet/core/src/endpoints/captcha.rs (L40-58)
```rust
    async fn request_captcha(&self) -> Result<Response<Binary<Vec<u8>>>, AptosTapErrorResponse> {
        if !self.enabled {
            return Err(AptosTapError::new(
                "The CaptchaChecker is not enabled".to_string(),
                AptosTapErrorCode::EndpointNotEnabled,
            )
            .into());
        }
        let mut captcha_manager = self.captcha_manager.lock().await;
        let (key, image) = match captcha_manager.create_challenge() {
            Ok((key, image)) => (key, image),
            Err(e) => {
                return Err(
                    AptosTapError::new_with_error_code(e, AptosTapErrorCode::CheckerError).into(),
                );
            },
        };
        Ok(Response::new(Binary(image)).header(CAPTCHA_KEY, key))
    }
```

**File:** crates/aptos-faucet/core/src/checkers/tap_captcha.rs (L121-124)
```rust
/// CaptchaManager is responsible for creating captcha challenges and later
/// checking them. We do this in memory for now (meaning clients should use
/// cookies to benefit from cookie based sticky routing), but we could make
/// a trait and implement a storage backed version down the line.
```

**File:** crates/aptos-faucet/core/src/checkers/tap_captcha.rs (L142-162)
```rust
    pub fn create_challenge(&mut self) -> Result<(u32, Vec<u8>)> {
        // Generate a random key.
        let key = rand::thread_rng().gen_range(0, u32::MAX - 1);

        // Generate a captcha.
        let (name, image) = Captcha::new()
            .add_chars(5)
            .apply_filter(Noise::new(0.4))
            .apply_filter(Wave::new(4.0, 6.0).vertical())
            .apply_filter(Wave::new(3.0, 2.0).horizontal())
            .apply_filter(Grid::new(10, 6))
            .apply_filter(Dots::new(8))
            .as_tuple()
            .context("Failed to generate captcha")?;

        // Store the captcha information.
        self.challenges.insert(key, name);

        // Return (key, <captcha as base64>).
        Ok((key, image))
    }
```

**File:** crates/aptos-faucet/core/src/checkers/tap_captcha.rs (L165-177)
```rust
    pub fn check_challenge(&mut self, key: u32, value: &str) -> Result<bool> {
        match self.challenges.get(&key) {
            Some(captcha) => {
                if captcha == value {
                    self.challenges.remove(&key);
                    Ok(true)
                } else {
                    Ok(false)
                }
            },
            None => bail!("Captcha key unknown: {}", key),
        }
    }
```
