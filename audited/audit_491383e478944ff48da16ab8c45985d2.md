# Audit Report

## Title
Node Checker Accepts Unencrypted HTTP URLs for Metrics Fetching, Enabling MITM Manipulation of Health Check Results

## Summary
The Aptos Node Checker's `MetricsProvider` accepts both HTTP and HTTPS URLs when fetching node metrics, including peer connection counts used by `MinimumPeersChecker`. While reqwest's default behavior correctly verifies TLS certificates when HTTPS is used, the system lacks validation to enforce HTTPS-only connections. This allows deployment configurations using HTTP URLs, where MITM attackers can intercept and manipulate metrics data, including the `aptos_connections` metric that determines whether a node has sufficient peer connectivity.

## Finding Description

The security question asks whether TLS certificates are verified when fetching metrics. The technical answer is nuanced:

**When HTTPS is used**: Yes, TLS certificates ARE verified by default. The reqwest client (v0.11.11) uses the `native-tls` backend by default, which validates certificates against the system's certificate store. [1](#0-0) 

**The actual vulnerability**: The system does not enforce HTTPS and accepts HTTP URLs, completely bypassing TLS protection.

The vulnerable code flow:

1. **URL acceptance without scheme validation**: The `NodeAddress` struct accepts any URL scheme with no HTTPS enforcement [2](#0-1) 

2. **API documentation encourages HTTP**: The API endpoint explicitly shows HTTP examples in comments [3](#0-2) 

3. **reqwest client built without TLS enforcement**: The metrics client is created with only timeout and cookie configuration, no scheme validation [4](#0-3) 

4. **Metrics fetched via HTTP**: When an HTTP URL is provided, metrics are fetched over unencrypted connection [5](#0-4) 

5. **Connection counts used for health decisions**: The `MinimumPeersChecker` relies on these metrics to determine node health [6](#0-5) 

**Attack Scenario**:
- Node operator configures node-checker with HTTP URL (following documentation examples)
- Attacker on network path intercepts HTTP requests to `/metrics` endpoint  
- Attacker modifies `aptos_connections{direction="inbound"}` and `aptos_connections{direction="outbound"}` values
- Node checker receives fake connection counts and makes incorrect health assessments

## Impact Explanation

**However**, this issue does NOT meet the Aptos Bug Bounty severity criteria:

The node-checker is an **operational monitoring tool** in the `ecosystem/` directory, not a core blockchain protocol component. It does not affect:
- ❌ Consensus safety or liveness
- ❌ Transaction execution or state management  
- ❌ On-chain governance or staking
- ❌ Fund security or validator operations
- ❌ Network-level protocol functionality

The impact is limited to:
- ✓ Operational monitoring accuracy
- ✓ Health check result manipulation (non-binding)
- ✓ Potential misconfiguration of monitoring systems

This does **not** break any of the critical invariants listed in the audit scope (deterministic execution, consensus safety, Move VM safety, state consistency, governance integrity, etc.).

## Likelihood Explanation

**High likelihood** that operators use HTTP based on:
- Documentation examples show HTTP URLs exclusively
- No validation warnings when HTTP is used
- Default behavior accepts any scheme

**However**, the security impact is **low** because:
- Node-checker results are informational, not consensus-critical
- Does not affect validator operations or protocol execution
- No direct path to fund loss or network partition

## Recommendation

While not a core protocol vulnerability, best practices suggest:

```rust
pub fn get_metrics_client(&self, timeout: Duration) -> Result<reqwest::Client> {
    match self.metrics_port {
        Some(_) => {
            // Validate HTTPS scheme
            if self.url.scheme() != "https" {
                return Err(anyhow!(
                    "Metrics URL must use HTTPS scheme for secure communication. Got: {}",
                    self.url.scheme()
                ));
            }
            
            Ok(reqwest::ClientBuilder::new()
                .timeout(timeout)
                .cookie_provider(self.cookie_store.clone())
                .tls_built_in_root_certs(true)  // Explicit TLS config
                .build()
                .unwrap())
        },
        None => Err(anyhow!(
            "Cannot build metrics client without a metrics port"
        )),
    }
}
```

## Proof of Concept

This is a configuration issue demonstrable through API usage:

```bash
# Current behavior - accepts HTTP without warning
curl "http://node-checker.example.com/check?\
  baseline_configuration_id=devnet_fullnode&\
  node_url=http://target-node.example.com&\
  metrics_port=9101"

# MITM attacker can intercept and modify:
# aptos_connections{direction="inbound"} = 999
# aptos_connections{direction="outbound"} = 999
# Result: Unhealthy node appears healthy
```

---

## Notes

**Critical Clarification**: This is **NOT a vulnerability in TLS certificate verification**. When HTTPS is used, reqwest correctly verifies certificates through native-tls by default. The issue is that HTTP (no TLS) is permitted.

**Scope Assessment**: The node-checker is an ecosystem monitoring tool, not part of the core Aptos blockchain protocol (consensus, execution, storage, governance, staking). While accepting HTTP is a security best practice violation, it does not constitute a vulnerability meeting the Aptos Bug Bounty criteria of Critical, High, or Medium severity affecting core blockchain functionality.

Per the audit requirements focusing on "consensus, execution, storage, governance, and staking components," this operational tooling issue falls outside the primary security scope.

### Citations

**File:** Cargo.toml (L761-767)
```text
reqwest = { version = "0.11.11", features = [
    "blocking",
    "cookies",
    "json",
    "multipart",
    "stream",
] }
```

**File:** ecosystem/node-checker/src/configuration/node_address.rs (L14-35)
```rust
pub struct NodeAddress {
    /// Target URL. This should include a scheme (e.g. http://). If there is no
    /// scheme, we will prepend http://.
    pub url: Url,

    /// API port.
    api_port: Option<u16>,

    /// Metrics port.
    metrics_port: Option<u16>,

    /// Validator communication port.
    noise_port: Option<u16>,

    /// Public key for the node. This is used for the HandshakeChecker.
    /// If that Checker is not enabled, this is not necessary.
    public_key: Option<x25519::PublicKey>,

    // Cookie store.
    #[serde(skip)]
    cookie_store: Arc<Jar>,
}
```

**File:** ecosystem/node-checker/src/configuration/node_address.rs (L94-105)
```rust
    pub fn get_metrics_client(&self, timeout: Duration) -> Result<reqwest::Client> {
        match self.metrics_port {
            Some(_) => Ok(reqwest::ClientBuilder::new()
                .timeout(timeout)
                .cookie_provider(self.cookie_store.clone())
                .build()
                .unwrap()),
            None => Err(anyhow!(
                "Cannot build metrics client without a metrics port"
            )),
        }
    }
```

**File:** ecosystem/node-checker/src/server/api.rs (L34-35)
```rust
        /// The URL of the node to check, e.g. http://44.238.19.217 or http://fullnode.mysite.com
        node_url: Query<Url>,
```

**File:** ecosystem/node-checker/src/provider/metrics.rs (L59-85)
```rust
    pub async fn get_scrape(&self) -> Result<Scrape, ProviderError> {
        let response = self
            .client
            .get(self.metrics_url.clone())
            .send()
            .await
            .with_context(|| format!("Failed to get data from {}", self.metrics_url))
            .map_err(|e| ProviderError::RetryableEndpointError("/metrics", e))?;
        let body = response
            .text()
            .await
            .with_context(|| {
                format!(
                    "Failed to process response body from {} as text",
                    self.metrics_url
                )
            })
            .map_err(|e| ProviderError::ParseError(anyhow!(e)))?;
        Scrape::parse(body.lines().map(|l| Ok(l.to_string())))
            .with_context(|| {
                format!(
                    "Failed to parse response text from {} as a Prometheus scrape",
                    self.metrics_url
                )
            })
            .map_err(|e| ProviderError::ParseError(anyhow!(e)))
    }
```

**File:** ecosystem/node-checker/src/checker/minimum_peers.rs (L104-142)
```rust
    async fn check(
        &self,
        providers: &ProviderCollection,
    ) -> Result<Vec<CheckResult>, CheckerError> {
        let target_metrics_provider = get_provider!(
            providers.target_metrics_provider,
            self.config.common.required,
            MetricsProvider
        );
        let scrape = match target_metrics_provider.provide().await {
            Ok(scrape) => scrape,
            Err(e) => {
                return Ok(vec![Self::build_result(
                    "Failed to check node peers".to_string(),
                    0,
                    format!("Failed to scrape metrics from your node: {:#}", e),
                )])
            },
        };
        let (inbound_connections, outbound_connections) = match get_metrics(&scrape) {
            Ok((inbound_connections, outbound_connections)) => {
                (inbound_connections, outbound_connections)
            },
            Err(evaluation_results) => return Ok(evaluation_results),
        };

        Ok(vec![
            self.build_evaluation(
                inbound_connections,
                self.config.minimum_peers_inbound,
                &ConnectionType::Inbound,
            ),
            self.build_evaluation(
                outbound_connections,
                self.config.minimum_peers_outbound,
                &ConnectionType::Outbound,
            ),
        ])
    }
```
