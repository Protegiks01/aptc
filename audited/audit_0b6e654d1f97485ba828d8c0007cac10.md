# Audit Report

## Title
Git Credential Exposure in Move CLI Dependency Download

## Summary
The Move CLI's dependency download functionality explicitly prints git URLs to stdout, which exposes embedded credentials when developers configure private git dependencies using URL-embedded authentication (e.g., `https://username:password@github.com/org/repo.git`). This credential leakage occurs during normal build operations and can expose sensitive credentials in terminal output, CI/CD logs, and log aggregation systems.

## Finding Description

When the Move CLI downloads git dependencies via `download_deps_for_package()`, it writes the raw git URL directly to stdout before performing git operations. [1](#0-0) 

The git URL is extracted from the dependency's `GitInfo` structure, which stores the URL exactly as parsed from the `Move.toml` manifest file. [2](#0-1) 

When parsing dependencies from `Move.toml`, the git URL is read directly as a string without any sanitization or credential stripping. [3](#0-2) 

**Attack Scenario:**

1. Developer configures a private git dependency in `Move.toml`:
```toml
[dependencies]
PrivatePackage = { git = "https://token:ghp_xxxxxxxxxxxxx@github.com/org/private-repo.git", rev = "main" }
```

2. Developer runs `aptos move build` or `aptos move build --fetch-deps-only`. [4](#0-3) 

3. The output displays:
```
FETCHING GIT DEPENDENCY https://token:ghp_xxxxxxxxxxxxx@github.com/org/private-repo.git
```

4. Credentials are now exposed in:
   - Terminal history
   - CI/CD build logs (GitHub Actions, GitLab CI, Jenkins, etc.)
   - Log aggregation systems (Splunk, DataDog, CloudWatch, etc.)
   - Screen recordings or screenshots
   - Shared terminal sessions

The same credential exposure occurs when updating existing dependencies. [5](#0-4) 

## Impact Explanation

This vulnerability enables **credential theft** through passive observation of build outputs. According to the security question scope, this is classified as **High** severity for git credential theft.

While this doesn't directly compromise blockchain consensus or validator operations, it creates a **supply chain attack vector**:

1. **Exposed Credentials**: Attackers gaining access to build logs can extract authentication tokens for private repositories
2. **Dependency Manipulation**: With stolen credentials, attackers could modify private dependencies to inject malicious code
3. **Ecosystem Compromise**: Compromised dependencies could affect multiple projects in the Aptos ecosystem
4. **CI/CD Exposure**: Modern CI/CD systems often log build output, making credentials accessible to anyone with log access

This falls under security issues affecting the Aptos development ecosystem and tooling infrastructure, which can indirectly impact the security of deployed applications.

## Likelihood Explanation

**Likelihood: MEDIUM to HIGH**

- **Common Practice**: While embedding credentials in URLs is discouraged, it remains a common pattern for:
  - CI/CD automation accessing private repositories
  - Personal access tokens for private dependencies
  - Legacy authentication methods
  
- **Automatic Trigger**: The vulnerability triggers automatically during normal build operationsâ€”no special flags or conditions required

- **Wide Exposure Surface**: Build logs are commonly:
  - Stored in CI/CD platforms with broad access permissions
  - Aggregated in centralized logging systems
  - Retained for extended periods for debugging purposes
  - Shared in troubleshooting contexts

- **Silent Failure**: Users may not realize their credentials are being leaked, as the output appears to be normal informational messages

## Recommendation

**Immediate Fix**: Sanitize git URLs before displaying them by stripping embedded credentials.

Add a URL sanitization function in `third_party/move/tools/move-package/src/resolution/resolution_graph.rs`:

```rust
fn sanitize_git_url(url: &str) -> String {
    // Parse URL and strip credentials
    if let Ok(mut parsed) = url::Url::parse(url) {
        parsed.set_username("").ok();
        parsed.set_password(None).ok();
        parsed.to_string()
    } else {
        // If parsing fails, replace entire URL with placeholder
        "[REDACTED]".to_string()
    }
}
```

Then modify the output statements to use the sanitized URL:

```rust
// Line 564-569
writeln!(
    writer,
    "{} {}",
    "FETCHING GIT DEPENDENCY".bold().green(),
    sanitize_git_url(git_url),
)?;

// Line 599-604
writeln!(
    writer,
    "{} {}",
    "UPDATING GIT DEPENDENCY".bold().green(),
    sanitize_git_url(git_url),
)?;
```

**Additional Recommendations:**
1. Add warnings in documentation against using embedded credentials
2. Consider supporting git credential helpers as the preferred authentication method
3. Add detection for credential patterns in URLs and warn users explicitly

## Proof of Concept

**Setup:**

1. Create a test Move package with `Move.toml`:
```toml
[package]
name = "TestPackage"
version = "1.0.0"

[dependencies]
PrivateDep = { git = "https://testuser:secrettoken123@github.com/test/private.git", rev = "main" }
```

2. Run the Move CLI build command:
```bash
aptos move build --fetch-deps-only
```

**Expected Vulnerable Output:**
```
FETCHING GIT DEPENDENCY https://testuser:secrettoken123@github.com/test/private.git
```

**Expected Fixed Output:**
```
FETCHING GIT DEPENDENCY https://github.com/test/private.git
```

**Verification Steps:**
1. Observe that credentials appear in terminal output
2. Check that credentials appear in redirected output: `aptos move build --fetch-deps-only > build.log 2>&1`
3. Confirm credentials are visible in `build.log`
4. In CI/CD environment, verify credentials appear in build logs

This demonstrates that credentials embedded in git URLs are exposed through normal build operations without any warning to the user.

## Notes

While the git operations themselves properly suppress stdout/stderr (preventing git from leaking credentials), [6](#0-5)  the Move CLI explicitly prints the raw URL before invoking git, creating the vulnerability.

The issue affects all users of the Move CLI who have private git dependencies configured with embedded credentials, which is a realistic scenario in enterprise and private development environments.

### Citations

**File:** third_party/move/tools/move-package/src/resolution/resolution_graph.rs (L557-560)
```rust
        if let Some(git_info) = &dep.git_info {
            let git_url = git_info.git_url.as_str();
            let git_rev = git_info.git_rev.as_str();
            let git_path = &git_info.download_to.display().to_string();
```

**File:** third_party/move/tools/move-package/src/resolution/resolution_graph.rs (L564-569)
```rust
                writeln!(
                    writer,
                    "{} {}",
                    "FETCHING GIT DEPENDENCY".bold().green(),
                    git_url,
                )?;
```

**File:** third_party/move/tools/move-package/src/resolution/resolution_graph.rs (L599-604)
```rust
                writeln!(
                    writer,
                    "{} {}",
                    "UPDATING GIT DEPENDENCY".bold().green(),
                    git_url,
                )?;
```

**File:** third_party/move/tools/move-package/src/source_package/manifest_parser.rs (L365-381)
```rust
                    let git_url = git
                        .as_str()
                        .ok_or_else(|| anyhow::anyhow!("Git URL not a string"))?;
                    let local_path = git_repo_cache_path(git_url, rev_name.as_str());
                    let subdir = PathBuf::from(match table.remove("subdir") {
                        None => "".to_string(),
                        Some(path) => path
                            .as_str()
                            .ok_or_else(|| format_err!("'subdir' not a string"))?
                            .to_string(),
                    });
                    git_info = Some(PM::GitInfo {
                        git_url: Symbol::from(git_url),
                        git_rev: rev_name,
                        subdir: subdir.clone(),
                        download_to: local_path.clone(),
                    });
```

**File:** third_party/move/tools/move-cli/src/base/build.rs (L22-22)
```rust
            config.download_deps_for_package(&rerooted_path, &mut std::io::stdout())?;
```

**File:** third_party/move/tools/move-package/src/resolution/git.rs (L28-32)
```rust
    let status = Command::new("git")
        .args(["clone", url, target_path])
        .stdout(Stdio::null())
        .stderr(Stdio::null())
        .status()
```
