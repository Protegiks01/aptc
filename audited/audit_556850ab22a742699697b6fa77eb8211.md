# Audit Report

## Title
Fork Replay Attack: Identical SessionIds Enable Object Address Collision Across Blockchain Forks

## Summary
The `SessionId::txn_meta()` function constructs session identifiers using only transaction-specific data (sender, sequence number, script hash) without including any blockchain fork-distinguishing information such as block hash, epoch, or round. This allows transactions from an abandoned fork to be replayed on the canonical chain with identical SessionIds, leading to deterministic object address collisions and violation of uniqueness guarantees in the Aptos object model.

## Finding Description

The `SessionId` enum is used throughout the Aptos VM to track and identify execution sessions. [1](#0-0) 

The `txn_meta()` function creates a SessionId containing only the sender address, sequence number (or nonce), and script hashâ€”no fork-specific information. [2](#0-1) 

This SessionId is hashed to create a `session_hash` that serves as the "transaction hash" exposed to Move code via the `transaction_context` native module. [3](#0-2) 

The session_hash is used to generate Aptos Unique Identifiers (AUIDs) for object addresses. [4](#0-3) 

The object framework uses these AUIDs with an explicit guarantee: "we can guarantee the same unique address can never be regenerated with future txs". [5](#0-4) 

**Attack Scenario:**

1. A blockchain fork occurs at block N, creating Fork A (canonical) and Fork B (abandoned)
2. Attacker submits transaction T with parameters (sender=Alice, seq=5, script=CreateObject)
3. Transaction T executes on Fork B at block N+1:
   - SessionId = `Txn { sender: Alice, sequence_number: 5, script_hash: hash(CreateObject) }`
   - Object created at address = `sha3_256(hash(SessionId) || 1 || 0xFB)`
   - Alice's sequence number incremented to 6
4. Fork B is abandoned, Fork A becomes canonical
5. State reverts to block N (Alice's sequence number back to 5)
6. Attacker replays transaction T on Fork A:
   - **Identical SessionId** (same sender, sequence, script)
   - **Identical session_hash**
   - **Identical object address** created

While chain_id validation prevents cross-chain replay, [6](#0-5)  it does not prevent replay from abandoned fork to canonical fork since both forks share the same chain_id.

## Impact Explanation

**Severity: Medium to High**

This vulnerability breaks the **Deterministic Execution** invariant and the documented uniqueness guarantee of the Aptos object model. The impact includes:

1. **Object Address Collision**: Applications relying on `create_object()` for unique address generation may experience collisions if transactions are replayed across forks, potentially causing transaction failures or unexpected state.

2. **Protocol Assumption Violations**: Smart contracts and system components that assume object addresses are globally unique across all execution contexts may behave incorrectly when the same address appears on different forks.

3. **State Inconsistency Window**: During fork resolution, different validators may have conflicting views of which objects exist at specific addresses, temporarily breaking consensus on state validity.

4. **Determinism Failures**: If applications use `get_txn_hash()` for uniqueness checks or as map keys, identical hashes across forks can cause non-deterministic behavior during fork reconciliation.

While this requires a fork to occur (which AptosBFT is designed to prevent under <1/3 Byzantine validators), forks can happen due to network partitions, software bugs, or epoch transition edge cases. The lack of fork-specific identifiers in SessionIds makes replay attacks inevitable once forks occur.

## Likelihood Explanation

**Likelihood: Low to Medium**

- **Prerequisites**: Requires a blockchain fork to occur, which is rare under normal AptosBFT operation
- **Attacker Complexity**: Low - any user who submitted a transaction on the abandoned fork can replay it
- **Detection Difficulty**: High - identical SessionIds make replay difficult to distinguish from legitimate retransmission
- **Exploitability**: Once a fork occurs, replay is automatic if users resubmit transactions

Forks are uncommon but not impossible in production blockchain systems due to edge cases in consensus, network partitions during validator set changes, or software bugs during upgrades.

## Recommendation

**Solution**: Include fork-distinguishing information in SessionId construction by incorporating block metadata.

Modify `SessionId::txn_meta()` to include the current block hash or epoch+round: [2](#0-1) 

Extend the `Txn` variant to include `block_hash: HashValue` or `epoch_round: (u64, u64)`, and pass this information from the block execution context through `TransactionMetadata`.

Alternatively, incorporate block metadata into the AUID generation process: [7](#0-6) 

Modify the `auid()` function to include block-specific data: `txn_hash || auid_counter || block_hash`.

This ensures that transactions from different forks generate distinct SessionIds and object addresses, preserving the uniqueness guarantee across all execution contexts.

## Proof of Concept

```move
// Module demonstrating fork replay vulnerability
module attacker::fork_replay_poc {
    use aptos_framework::object;
    use std::signer;

    public entry fun create_unique_object(creator: &signer) {
        // This is supposed to create a unique object address
        let constructor_ref = object::create_object(signer::address_of(creator));
        // Object created at deterministic address based only on SessionId
        // If transaction replayed on different fork with same SessionId,
        // identical address is generated, violating uniqueness guarantee
    }
}

// Execution steps:
// 1. Submit create_unique_object transaction on Fork B
// 2. Fork B abandoned
// 3. Resubmit same transaction on Fork A
// 4. Identical object address generated (same SessionId hash)
// 5. Uniqueness guarantee violated
```

**Notes**

The vulnerability stems from the architectural decision to use only transaction-local data in SessionId construction. While sequence numbers prevent replay within a single fork, the absence of block-specific identifiers allows cross-fork replay with identical session hashes. This affects any Move code relying on `transaction_context::get_txn_hash()` or `transaction_context::generate_auid_address()` for uniqueness, including the core object framework used throughout the Aptos ecosystem.

### Citations

**File:** aptos-move/aptos-vm/src/move_vm_ext/session/session_id.rs (L14-20)
```rust
#[derive(BCSCryptoHash, Clone, CryptoHasher, Deserialize, Serialize)]
pub enum SessionId {
    Txn {
        sender: AccountAddress,
        sequence_number: u64,
        script_hash: Vec<u8>,
    },
```

**File:** aptos-move/aptos-vm/src/move_vm_ext/session/session_id.rs (L91-105)
```rust
    pub fn txn_meta(txn_metadata: &TransactionMetadata) -> Self {
        match txn_metadata.replay_protector() {
            ReplayProtector::SequenceNumber(sequence_number) => Self::Txn {
                sender: txn_metadata.sender,
                sequence_number,
                script_hash: txn_metadata.script_hash.clone(),
            },
            ReplayProtector::Nonce(nonce) => Self::OrderlessTxn {
                sender: txn_metadata.sender,
                nonce,
                expiration_time: txn_metadata.expiration_timestamp_secs,
                script_hash: txn_metadata.script_hash.clone(),
            },
        }
    }
```

**File:** aptos-move/framework/src/natives/transaction_context.rs (L118-129)
```rust
fn native_get_txn_hash(
    context: &mut SafeNativeContext,
    _ty_args: &[Type],
    _args: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    context.charge(TRANSACTION_CONTEXT_GET_TXN_HASH_BASE)?;
    let transaction_context = context.extensions().get::<NativeTransactionContext>();

    Ok(smallvec![Value::vector_u8(
        transaction_context.session_hash.clone()
    )])
}
```

**File:** aptos-move/framework/src/natives/transaction_context.rs (L137-155)
```rust
fn native_generate_unique_address(
    context: &mut SafeNativeContext,
    _ty_args: &[Type],
    _args: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    context.charge(TRANSACTION_CONTEXT_GENERATE_UNIQUE_ADDRESS_BASE)?;

    let transaction_context = context
        .extensions_mut()
        .get_mut::<NativeTransactionContext>();
    transaction_context.auid_counter += 1;

    let auid = AuthenticationKey::auid(
        transaction_context.session_hash.clone(),
        transaction_context.auid_counter,
    )
    .account_address();
    Ok(smallvec![Value::address(auid)])
}
```

**File:** aptos-move/framework/aptos-framework/sources/object.move (L264-271)
```text
    /// Create a new object by generating a random unique address based on transaction hash.
    /// The unique address is computed sha3_256([transaction hash | auid counter | 0xFB]).
    /// The created object is deletable as we can guarantee the same unique address can
    /// never be regenerated with future txs.
    public fun create_object(owner_address: address): ConstructorRef {
        let unique_address = transaction_context::generate_auid_address();
        create_object_internal(owner_address, unique_address, true)
    }
```

**File:** aptos-move/framework/aptos-framework/sources/transaction_validation.move (L143-143)
```text
        assert!(chain_id::get() == chain_id, error::invalid_argument(PROLOGUE_EBAD_CHAIN_ID));
```

**File:** types/src/transaction/authenticator.rs (L890-893)
```rust
    pub fn auid(mut txn_hash: Vec<u8>, auid_counter: u64) -> Self {
        txn_hash.extend(auid_counter.to_le_bytes().to_vec());
        Self::from_preimage(txn_hash, Scheme::DeriveAuid)
    }
```
