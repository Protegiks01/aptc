# Audit Report

## Title
Indexer-GRPC-Manager Process Crash via Malformed FullnodeInfo Timestamp Causing Complete Service Denial of Service

## Summary
The `render_fullnode_tab()` function in the status page contains multiple `.unwrap()` calls on optional `timestamp` fields that can cause the entire indexer-grpc-manager process to crash when rendering fullnode information. Since the protobuf schema defines `timestamp` as optional, any malicious or buggy fullnode can send a `FullnodeInfo` message without a timestamp, triggering a panic that kills the entire service due to the configured panic handler. [1](#0-0) 

## Finding Description

The vulnerability exists at five locations in `status_page.rs` where `.unwrap()` is called on `timestamp` fields (lines 73, 118, 170, 247, 269). The most critical instance is in `render_fullnode_tab()`: [2](#0-1) 

The `FullnodeInfo` protobuf message defines `timestamp` as an optional field: [3](#0-2) 

Which translates to `Option<Timestamp>` in the Rust generated code: [4](#0-3) 

**Attack Flow:**

1. A malicious or buggy fullnode sends a `PingFullnodeResponse` with `FullnodeInfo` where `timestamp = None`
2. The `MetadataManager` receives and stores this info without validation: [5](#0-4) 

3. An operator or monitoring system accesses the status page at the root endpoint (`/`)
4. The status page attempts to render fullnode information and calls `.unwrap()` on the None timestamp
5. A panic occurs, triggering the global panic handler: [6](#0-5) 

6. The panic handler logs the crash and calls `process::exit(12)`, **killing the entire indexer-grpc-manager process**

This breaks the availability guarantee: the indexer-grpc-manager is a critical coordination service that handles transaction streaming, service discovery, and metadata management for the entire indexer infrastructure.

## Impact Explanation

This is **HIGH severity** according to Aptos bug bounty criteria:

- **API crashes**: The status page endpoint causes complete process termination
- **Service disruption**: The entire indexer-grpc-manager crashes, not just the status page
- **Transaction streaming failure**: All clients lose access to transaction data
- **Service discovery breakdown**: Coordination between fullnodes and data services stops
- **No recovery without restart**: Requires manual intervention to restart the service

While the initial security question categorized this as "Medium" for monitoring DoS, the actual impact is much worse because:
1. The panic handler terminates the entire process, not just the HTTP request
2. The indexer-grpc-manager is critical infrastructure for transaction streaming
3. All connected clients are affected simultaneously

Similar `.unwrap()` calls exist in other rendering functions for `LiveDataServiceInfo` and `HistoricalDataServiceInfo`: [7](#0-6) [8](#0-7) 

## Likelihood Explanation

**HIGH likelihood:**

- **Easy exploitation**: Any fullnode can send a protobuf message with optional fields omitted
- **No authentication required**: Any connected fullnode is trusted to send valid messages
- **Accidental trigger**: Even non-malicious bugs in fullnode implementations could trigger this
- **Common access pattern**: Status pages are frequently accessed by monitoring systems and operators

The metadata manager code already demonstrates awareness of this risk by using `.unwrap_or_default()` in its own timestamp checks: [9](#0-8) 

However, the status page code uses unsafe `.unwrap()` instead.

## Recommendation

Replace all `.unwrap()` calls on optional timestamp fields with `.unwrap_or_default()` or proper Option handling:

**For `render_fullnode_tab()` at line 73:**
```rust
let (timestamp, known_latest_version) = if let Some(last_sample) = last_sample {
    (
        format!("{:?}", last_sample.timestamp.unwrap_or_default()), // FIX: Use unwrap_or_default
        format!("{}", last_sample.known_latest_version()),
    )
} else {
    ("No data point.".to_string(), "No data point.".to_string())
};
```

**For `render_live_data_service_tab()` at line 118:**
```rust
(
    format!("{:?}", last_sample.timestamp.unwrap_or_default()), // FIX
    format!("{}", last_sample.known_latest_version()),
    // ... rest of the tuple
)
```

**For `render_historical_data_service_tab()` at line 170:**
```rust
(
    format!("{:?}", last_sample.timestamp.unwrap_or_default()), // FIX
    format!("{}", last_sample.known_latest_version()),
    // ... rest of the tuple
)
```

**For stream rendering functions at lines 247 and 269:**
```rust
entry.1.back().cloned().and_then(|sample| {
    sample.stream_info.and_then(|stream_info| {
        sample.timestamp.map(|ts| {  // FIX: Use map instead of unwrap
            let data_service_instance = entry.0.clone();
            (data_service_instance, ts, stream_info)
        })
    })
})
```

Alternatively, add validation in `handle_fullnode_info()` to reject messages with None timestamps:

```rust
fn handle_fullnode_info(&self, address: GrpcAddress, info: FullnodeInfo) -> Result<()> {
    // Validate timestamp exists
    if info.timestamp.is_none() {
        bail!("FullnodeInfo missing required timestamp field");
    }
    
    let mut entry = self
        .fullnodes
        .entry(address.clone())
        .or_insert(Fullnode::new(address.clone()));
    entry.value_mut().recent_states.push_back(info);
    // ... rest of function
}
```

## Proof of Concept

**Rust Integration Test:**

```rust
#[tokio::test]
async fn test_status_page_crash_with_none_timestamp() {
    use aptos_protos::indexer::v1::FullnodeInfo;
    use std::collections::{HashMap, VecDeque};
    
    // Create FullnodeInfo with None timestamp (simulating malicious fullnode)
    let malicious_info = FullnodeInfo {
        chain_id: 1,
        timestamp: None,  // Missing timestamp triggers the bug
        known_latest_version: Some(1000),
    };
    
    // Create the data structure that status page receives
    let mut fullnodes_info = HashMap::new();
    let mut recent_states = VecDeque::new();
    recent_states.push_back(malicious_info);
    fullnodes_info.insert("malicious-fullnode:50051".to_string(), recent_states);
    
    // This call will panic at line 73 when rendering
    // In production, this panic kills the entire process
    let result = std::panic::catch_unwind(|| {
        render_fullnode_tab(fullnodes_info)
    });
    
    assert!(result.is_err(), "Status page should panic with None timestamp");
}
```

**Manual Exploitation:**

1. Deploy a modified fullnode that sends `PingFullnodeResponse` with `FullnodeInfo.timestamp = None`
2. Connect this fullnode to the indexer-grpc-manager
3. Wait for the manager to ping the fullnode (happens every ~1 second)
4. Access the status page at `http://<manager-host>:<port>/`
5. The entire indexer-grpc-manager process crashes with exit code 12

**Expected behavior:** Status page should display "No timestamp" or use a default value, not crash the entire service.

## Notes

This vulnerability demonstrates a common anti-pattern: using `.unwrap()` on protobuf optional fields without validation. The metadata manager correctly uses `.unwrap_or_default()` for the same timestamp fields in its staleness checks, but the status page uses the unsafe `.unwrap()` pattern. This inconsistency suggests the vulnerability was introduced during status page development without considering that external services could send incomplete protobuf messages.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/status_page.rs (L70-78)
```rust
                    let last_sample = fullnode_info.1.back();
                    let (timestamp, known_latest_version) = if let Some(last_sample) = last_sample {
                        (
                            format!("{:?}", last_sample.timestamp.unwrap()),
                            format!("{}", last_sample.known_latest_version()),
                        )
                    } else {
                        ("No data point.".to_string(), "No data point.".to_string())
                    };
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/status_page.rs (L115-120)
```rust
            let (timestamp, known_latest_version, min_servable_version, num_connected_streams) =
                if let Some(last_sample) = last_sample {
                    (
                        format!("{:?}", last_sample.timestamp.unwrap()),
                        format!("{}", last_sample.known_latest_version()),
                        format!("{:?}", last_sample.min_servable_version),
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/status_page.rs (L167-172)
```rust
            let (timestamp, known_latest_version, num_connected_streams) =
                if let Some(last_sample) = last_sample {
                    (
                        format!("{:?}", last_sample.timestamp.unwrap()),
                        format!("{}", last_sample.known_latest_version()),
                        format!(
```

**File:** protos/proto/aptos/indexer/v1/grpc.proto (L51-55)
```text
message FullnodeInfo {
  uint64 chain_id = 1;
  optional aptos.util.timestamp.Timestamp timestamp = 2;
  optional uint64 known_latest_version = 3;
}
```

**File:** protos/rust/src/pb/aptos.indexer.v1.rs (L223-230)
```rust
pub struct FullnodeInfo {
    #[prost(uint64, tag="1")]
    pub chain_id: u64,
    #[prost(message, optional, tag="2")]
    pub timestamp: ::core::option::Option<super::super::util::timestamp::Timestamp>,
    #[prost(uint64, optional, tag="3")]
    pub known_latest_version: ::core::option::Option<u64>,
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L198-203)
```rust
                    let need_ping = fullnode.recent_states.back().is_none_or(|s| {
                        Self::is_stale_timestamp(
                            s.timestamp.unwrap_or_default(),
                            Duration::from_secs(1),
                        )
                    });
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L533-550)
```rust
    fn handle_fullnode_info(&self, address: GrpcAddress, info: FullnodeInfo) -> Result<()> {
        let mut entry = self
            .fullnodes
            .entry(address.clone())
            .or_insert(Fullnode::new(address.clone()));
        entry.value_mut().recent_states.push_back(info);
        if let Some(known_latest_version) = info.known_latest_version {
            trace!(
                "Received known_latest_version ({known_latest_version}) from fullnode {address}."
            );
            self.update_known_latest_version(known_latest_version);
        }
        if entry.value().recent_states.len() > MAX_NUM_OF_STATES_TO_KEEP {
            entry.value_mut().recent_states.pop_front();
        }

        Ok(())
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-server-framework/src/lib.rs (L149-168)
```rust
pub fn setup_panic_handler() {
    std::panic::set_hook(Box::new(move |pi: &PanicHookInfo<'_>| {
        handle_panic(pi);
    }));
}

// Formats and logs panic information
fn handle_panic(panic_info: &PanicHookInfo<'_>) {
    // The Display formatter for a PanicHookInfo contains the message, payload and location.
    let details = format!("{}", panic_info);
    let backtrace = format!("{:#?}", Backtrace::new());
    let info = CrashInfo { details, backtrace };
    let crash_info = toml::to_string_pretty(&info).unwrap();
    error!("{}", crash_info);
    // TODO / HACK ALARM: Write crash info synchronously via eprintln! to ensure it is written before the process exits which error! doesn't guarantee.
    // This is a workaround until https://github.com/aptos-labs/aptos-core/issues/2038 is resolved.
    eprintln!("{}", crash_info);
    // Kill the process
    process::exit(12);
}
```
