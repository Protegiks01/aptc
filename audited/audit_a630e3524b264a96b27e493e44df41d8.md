# Audit Report

## Title
ApprovedExecutionHashes Lacks Version Compatibility Causing Governance Liveness Failure During Protocol Rollbacks

## Summary
The `ApprovedExecutionHashes` on-chain configuration lacks version compatibility mechanisms present in other critical configs, creating a silent failure mode during protocol rollbacks that blocks large governance transactions from executing, including emergency rollback proposals themselves.

## Finding Description

The `ApprovedExecutionHashes` struct is used to bypass mempool transaction size limits for approved governance proposals. However, unlike other critical on-chain configurations (`ConsensusConfig`, `ExecutionConfig`), it lacks any version compatibility mechanisms. [1](#0-0) 

In contrast, other configs use versioned enums with fallback mechanisms: [2](#0-1) [3](#0-2) 

**The Critical Path:**

When a transaction is validated, the VM checks if it's an approved governance script: [4](#0-3) 

The `fetch_config` method silently converts deserialization errors to `None`: [5](#0-4) 

If the config cannot be deserialized (e.g., due to struct format mismatch after rollback), `is_approved_gov_script` returns `false`, and the transaction is subjected to regular size limits: [6](#0-5) 

**Failure Scenario:**

1. Protocol upgrade modifies `ApprovedExecutionHashes` structure (adds fields, changes types)
2. Upgraded network operates; governance proposals approved and stored in new format
3. Critical bug discovered; emergency rollback initiated
4. Rollback requires large governance transaction (framework downgrade)
5. Old code cannot deserialize new format data
6. `fetch_config()` silently returns `None` (line 191, .ok()? swallows error)
7. `is_approved_gov_script()` returns `false`
8. Large rollback transaction rejected: `EXCEEDED_MAX_TRANSACTION_SIZE`
9. **Cannot execute emergency governance to complete rollback**

The Move-side resource stores data using `SimpleMap`: [7](#0-6) 

This is critical infrastructure for governance operations: [8](#0-7) 

## Impact Explanation

**High Severity** per Aptos bug bounty criteria: "Significant protocol violations"

This vulnerability creates a **self-perpetuating governance liveness failure**:

- During protocol rollbacks, the mechanism designed to enable large governance transactions (emergency fixes, rollback completions) becomes non-functional
- All validators simultaneously affected (deterministic deserialization failure)
- Blocks the recovery mechanism itself - cannot use governance to fix governance
- Requires hard fork or manual database intervention to resolve
- Violates the **Governance Integrity** invariant

Could escalate to **Critical Severity**: "Total loss of liveness/network availability" if governance is completely stuck and cannot execute critical fixes.

## Likelihood Explanation

**Medium Likelihood:**

**Prerequisites:**
1. Protocol upgrade that modifies `ApprovedExecutionHashes` structure
2. Governance proposals executed in new format
3. Rollback scenario triggered (rare but critical)

While protocol rollbacks are uncommon, they are **necessary for emergency responses** to critical bugs. The Aptos codebase shows rollback testing exists:

The codebase demonstrates that config structure evolution is common (ExecutionConfig has 7 versions, ConsensusConfig has multiple variants), making future changes to `ApprovedExecutionHashes` plausible.

When this failure occurs, the impact is catastrophic because it prevents the exact governance operations needed for recovery.

## Recommendation

Implement version compatibility mechanisms matching other critical configs:

```rust
// types/src/on_chain_config/approved_execution_hashes.rs

#[derive(Clone, Debug, Deserialize, PartialEq, Eq, Serialize)]
pub enum ApprovedExecutionHashes {
    V1(ApprovedExecutionHashesV1),
    // Maintain backwards compatibility on replay
    Missing,
}

#[derive(Clone, Debug, Deserialize, PartialEq, Eq, Serialize)]
pub struct ApprovedExecutionHashesV1 {
    pub entries: Vec<(u64, Vec<u8>)>,
}

impl ApprovedExecutionHashes {
    pub fn default_if_missing() -> Self {
        Self::Missing
    }
    
    pub fn entries(&self) -> Vec<(u64, Vec<u8>)> {
        match self {
            Self::V1(v1) => v1.entries.clone(),
            Self::Missing => vec![],
        }
    }
    
    pub fn to_btree_map(self) -> BTreeMap<u64, Vec<u8>> {
        self.entries().into_iter().collect()
    }
}

impl Default for ApprovedExecutionHashes {
    fn default() -> Self {
        Self::Missing
    }
}
```

Update the VM to handle missing config gracefully:

```rust
// aptos-move/aptos-vm/src/aptos_vm.rs
fn is_approved_gov_script(
    resolver: &impl ConfigStorage,
    txn: &SignedTransaction,
    txn_metadata: &TransactionMetadata,
) -> bool {
    if let Ok(TransactionExecutableRef::Script(_script)) = txn.payload().executable_ref() {
        let approved_hashes = ApprovedExecutionHashes::fetch_config(resolver)
            .unwrap_or_else(|| ApprovedExecutionHashes::default_if_missing());
        approved_hashes.entries()
            .iter()
            .any(|(_, hash)| hash == &txn_metadata.script_hash)
    } else {
        false
    }
}
```

Add logging for deserialization failures to detect issues early.

## Proof of Concept

```rust
// Test demonstrating deserialization failure with incompatible formats
#[test]
fn test_approved_execution_hashes_rollback_incompatibility() {
    use bcs;
    use types::on_chain_config::approved_execution_hashes::ApprovedExecutionHashes;
    
    // Simulate "new" format with additional field
    #[derive(serde::Serialize, serde::Deserialize)]
    struct ApprovedExecutionHashesV2 {
        entries: Vec<(u64, Vec<u8>)>,
        timestamps: Vec<(u64, u64)>,  // NEW FIELD
    }
    
    // Create data in new format
    let new_format = ApprovedExecutionHashesV2 {
        entries: vec![(1, vec![0xAB, 0xCD])],
        timestamps: vec![(1, 1234567890)],
    };
    
    let serialized = bcs::to_bytes(&new_format).unwrap();
    
    // Try to deserialize with old format (current ApprovedExecutionHashes)
    let result = bcs::from_bytes::<ApprovedExecutionHashes>(&serialized);
    
    // This FAILS silently in production code
    assert!(result.is_err(), "Deserialization should fail with incompatible format");
    
    // In production, fetch_config() converts this to None with .ok()?
    // causing is_approved_gov_script() to return false
    // and large governance transactions to be rejected
}
```

**Notes:**
- This is an architectural vulnerability, not an active attack
- The silent failure mode is the critical issue - no error logging or alerting
- Other OnChainConfigs have proper versioning precisely to prevent this scenario
- The impact is amplified because it affects the recovery mechanism itself during emergency situations

### Citations

**File:** types/src/on_chain_config/approved_execution_hashes.rs (L8-11)
```rust
#[derive(Clone, Debug, Deserialize, PartialEq, Eq, Serialize)]
pub struct ApprovedExecutionHashes {
    pub entries: Vec<(u64, Vec<u8>)>,
}
```

**File:** types/src/on_chain_config/execution_config.rs (L11-24)
```rust
#[derive(Clone, Debug, Deserialize, PartialEq, Eq, Serialize)]
pub enum OnChainExecutionConfig {
    V1(ExecutionConfigV1),
    V2(ExecutionConfigV2),
    V3(ExecutionConfigV3),
    /// To maintain backwards compatibility on replay, we must ensure that any new features resolve
    /// to previous behavior (before OnChainExecutionConfig was registered) in case of Missing.
    Missing,
    // Reminder: Add V4 and future versions here, after Missing (order matters for enums).
    V4(ExecutionConfigV4),
    V5(ExecutionConfigV5),
    V6(ExecutionConfigV6),
    V7(ExecutionConfigV7),
}
```

**File:** types/src/on_chain_config/consensus_config.rs (L46-52)
```rust
    pub fn default_if_missing() -> Self {
        Self::JolteonV2 {
            main: ConsensusConfigV1::default(),
            quorum_store_enabled: true,
            order_vote_enabled: false,
        }
    }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L286-302)
```rust
fn is_approved_gov_script(
    resolver: &impl ConfigStorage,
    txn: &SignedTransaction,
    txn_metadata: &TransactionMetadata,
) -> bool {
    if let Ok(TransactionExecutableRef::Script(_script)) = txn.payload().executable_ref() {
        match ApprovedExecutionHashes::fetch_config(resolver) {
            Some(approved_execution_hashes) => approved_execution_hashes
                .entries
                .iter()
                .any(|(_, hash)| hash == &txn_metadata.script_hash),
            None => false,
        }
    } else {
        false
    }
}
```

**File:** types/src/on_chain_config/mod.rs (L185-193)
```rust
    fn fetch_config_and_bytes<T>(storage: &T) -> Option<(Self, Bytes)>
    where
        T: ConfigStorage + ?Sized,
    {
        let state_key = StateKey::on_chain_config::<Self>().ok()?;
        let bytes = storage.fetch_config_bytes(&state_key)?;
        let config = Self::deserialize_into_config(&bytes).ok()?;
        Some((config, bytes))
    }
```

**File:** aptos-move/aptos-vm/src/gas.rs (L109-121)
```rust
    } else if txn_metadata.transaction_size > txn_gas_params.max_transaction_size_in_bytes {
        speculative_warn!(
            log_context,
            format!(
                "[VM] Transaction size too big {} (max {})",
                txn_metadata.transaction_size, txn_gas_params.max_transaction_size_in_bytes
            ),
        );
        return Err(VMStatus::error(
            StatusCode::EXCEEDED_MAX_TRANSACTION_SIZE,
            None,
        ));
    }
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L108-112)
```text
    /// Used to track which execution script hashes have been approved by governance.
    /// This is required to bypass cases where the execution scripts exceed the size limit imposed by mempool.
    struct ApprovedExecutionHashes has key {
        hashes: SimpleMap<u64, vector<u8>>,
    }
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L610-630)
```text
    /// Add the execution script hash of a successful governance proposal to the approved list.
    /// This is needed to bypass the mempool transaction size limit for approved governance proposal transactions that
    /// are too large (e.g. module upgrades).
    public fun add_approved_script_hash(proposal_id: u64) acquires ApprovedExecutionHashes {
        let approved_hashes = borrow_global_mut<ApprovedExecutionHashes>(@aptos_framework);

        // Ensure the proposal can be resolved.
        let proposal_state = voting::get_proposal_state<GovernanceProposal>(@aptos_framework, proposal_id);
        assert!(proposal_state == PROPOSAL_STATE_SUCCEEDED, error::invalid_argument(EPROPOSAL_NOT_RESOLVABLE_YET));

        let execution_hash = voting::get_execution_hash<GovernanceProposal>(@aptos_framework, proposal_id);

        // If this is a multi-step proposal, the proposal id will already exist in the ApprovedExecutionHashes map.
        // We will update execution hash in ApprovedExecutionHashes to be the next_execution_hash.
        if (simple_map::contains_key(&approved_hashes.hashes, &proposal_id)) {
            let current_execution_hash = simple_map::borrow_mut(&mut approved_hashes.hashes, &proposal_id);
            *current_execution_hash = execution_hash;
        } else {
            simple_map::add(&mut approved_hashes.hashes, proposal_id, execution_hash);
        }
    }
```
