# Audit Report

## Title
Panic in Indexer-gRPC Service Due to Unchecked Optional IndexerReader

## Summary
The `bootstrap()` function in `indexer-grpc-fullnode/src/runtime.rs` accepts an optional `indexer_reader` parameter that is passed downstream to create a `Context`. When the indexer-gRPC service is enabled but both table info and internal indexer DB are disabled, the `indexer_reader` is `None`. However, the `IndexerStreamCoordinator::set_highest_known_version()` method unconditionally expects the reader to be present, causing a panic when clients connect to the stream. [1](#0-0) 

## Finding Description
The vulnerability exists in the optional handling of `indexer_reader` across multiple components:

1. **Bootstrap accepts optional reader**: The `bootstrap()` function accepts `indexer_reader: Option<Arc<dyn IndexerReader>>` and passes it to `Context::new()` without validation. [2](#0-1) 

2. **Context stores optional reader**: The `Context` struct stores this as an optional field `indexer_reader: Option<Arc<dyn IndexerReader>>`. [3](#0-2) 

3. **Service initialization proceeds**: The `FullnodeDataService` is created regardless of whether `indexer_reader` is `None`. [4](#0-3) 

4. **Stream coordinator created**: When clients connect, an `IndexerStreamCoordinator` is instantiated with the context containing the potentially `None` reader. [5](#0-4) 

5. **Panic on None value**: During stream processing, `set_highest_known_version()` is called which unconditionally expects the reader to be present using `.expect("Table info reader not set")`, causing a panic if it's `None`. [6](#0-5) 

6. **Triggered during processing**: This method is called from `ensure_highest_known_version()` which is invoked during batch processing when clients request transactions. [7](#0-6) 

The misconfiguration occurs when:
- `config.indexer_grpc.enabled = true` (indexer-grpc service is enabled)
- `config.indexer_table_info.table_info_service_mode.is_enabled() = false` (table info service disabled)
- `config.indexer_db_config.is_internal_indexer_db_enabled() = false` OR `internal_indexer_db = None` (internal indexer DB disabled)

This results in `indexer_reader = None` being passed to the context. [8](#0-7) 

## Impact Explanation
This vulnerability causes **denial of service** for the indexer-gRPC service, classified as **Medium Severity** under the Aptos bug bounty program:

- **Service Unavailability**: Each client connection that attempts to stream transactions will trigger a panic in the stream handler, causing that connection to fail immediately
- **Repeated Crashes**: Multiple client connections will cause repeated panics, filling logs and potentially affecting node stability
- **No Consensus Impact**: The panic is isolated to the indexer-gRPC service and does not affect consensus, execution, mempool, or other critical blockchain components
- **Configuration-Triggered**: Requires a specific misconfiguration rather than malicious input, but is a realistic scenario during partial deployments or testing

The severity fits the Medium category: "State inconsistencies requiring intervention" - the service crashes and requires either configuration changes or code fixes to restore functionality.

## Likelihood Explanation
**Medium Likelihood**: 

The vulnerability requires a specific but plausible configuration state:
- Node operators may enable indexer-gRPC for transaction streaming without enabling the optional table info or internal indexer DB services
- This scenario is particularly likely during:
  - Initial node setup or testing phases
  - Partial feature rollouts where not all indexing services are enabled
  - Resource-constrained environments where operators disable optional services
  
Once the misconfiguration exists, **every client connection** attempting to stream transactions will trigger the panic deterministically. No special permissions or malicious actions are required - any legitimate client connecting to the service will cause the crash.

## Recommendation
Add validation in the `bootstrap()` function to either:

**Option 1: Fail fast during bootstrap**
```rust
pub fn bootstrap(
    config: &NodeConfig,
    chain_id: ChainId,
    db: Arc<dyn DbReader>,
    mp_sender: MempoolClientSender,
    indexer_reader: Option<Arc<dyn IndexerReader>>,
    port_tx: Option<oneshot::Sender<u16>>,
) -> Option<Runtime> {
    if !config.indexer_grpc.enabled {
        return None;
    }

    // Validate indexer_reader is present if required
    if indexer_reader.is_none() {
        error!("Indexer gRPC service requires indexer_reader to be configured. Please enable either table_info_service_mode or internal_indexer_db.");
        return None;
    }

    // ... rest of implementation
}
```

**Option 2: Handle None gracefully in set_highest_known_version**
```rust
pub fn set_highest_known_version(&mut self) -> anyhow::Result<()> {
    let info = self.context.get_latest_ledger_info_wrapped()?;
    
    let latest_table_info_version = if let Some(indexer_reader) = self.context.indexer_reader.as_ref() {
        indexer_reader
            .get_latest_table_info_ledger_version()?
            .unwrap_or(info.ledger_version.0)
    } else {
        // Fall back to storage ledger version if no indexer reader
        info.ledger_version.0
    };

    self.highest_known_version =
        std::cmp::min(info.ledger_version.0, latest_table_info_version);

    Ok(())
}
```

**Recommended approach**: Option 1 is preferred as it provides clear error messaging during node startup and prevents the service from entering an invalid state. This follows the fail-fast principle and makes the dependency explicit.

## Proof of Concept

**Configuration Setup**:
```toml
# In node config
[indexer_grpc]
enabled = true
address = "0.0.0.0:50051"

[indexer_table_info]
# Disabled - no table_info_service_mode set

[indexer_db_config]
# Disabled or not configured
```

**Reproduction Steps**:
1. Start an Aptos node with the above configuration (indexer-grpc enabled, but both table info and internal indexer DB disabled)
2. Use any gRPC client to connect to the indexer-grpc service:
   ```bash
   grpcurl -plaintext localhost:50051 aptos.internal.fullnode.v1.FullnodeData/GetTransactionsFromNode
   ```
3. Send a `GetTransactionsFromNode` request with any valid starting version
4. Observe the panic in node logs: `thread 'tokio-runtime-worker' panicked at 'Table info reader not set'`
5. The stream connection fails immediately, and the error is logged

**Expected Behavior**: Service should either refuse to start during bootstrap with a clear error message, or handle the None case gracefully during stream processing.

**Actual Behavior**: Service starts successfully but panics when clients attempt to stream transactions, causing repeated crashes for each connection attempt.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/runtime.rs (L36-46)
```rust
pub fn bootstrap(
    config: &NodeConfig,
    chain_id: ChainId,
    db: Arc<dyn DbReader>,
    mp_sender: MempoolClientSender,
    indexer_reader: Option<Arc<dyn IndexerReader>>,
    port_tx: Option<oneshot::Sender<u16>>,
) -> Option<Runtime> {
    if !config.indexer_grpc.enabled {
        return None;
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/runtime.rs (L64-71)
```rust
    runtime.spawn(async move {
        let context = Arc::new(Context::new(
            chain_id,
            db,
            mp_sender,
            node_config,
            indexer_reader,
        ));
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/runtime.rs (L80-85)
```rust
        // If we are here, we know indexer grpc is enabled.
        let server = FullnodeDataService {
            service_context: service_context.clone(),
            abort_handle: Arc::new(AtomicBool::new(false)),
        };
        let localnet_data_server = LocalnetDataService { service_context };
```

**File:** api/src/context.rs (L73-85)
```rust
pub struct Context {
    chain_id: ChainId,
    pub db: Arc<dyn DbReader>,
    mp_sender: MempoolClientSender,
    pub node_config: Arc<NodeConfig>,
    gas_schedule_cache: Arc<RwLock<GasScheduleCache>>,
    gas_estimation_cache: Arc<RwLock<GasEstimationCache>>,
    gas_limit_cache: Arc<RwLock<GasLimitCache>>,
    view_function_stats: Arc<FunctionStats>,
    simulate_txn_stats: Arc<FunctionStats>,
    pub indexer_reader: Option<Arc<dyn IndexerReader>>,
    pub wait_for_hash_active_connections: Arc<AtomicUsize>,
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/fullnode_data_service.rs (L103-117)
```rust
            let mut coordinator = IndexerStreamCoordinator::new(
                context,
                starting_version,
                ending_version,
                processor_task_count,
                processor_batch_size,
                output_batch_size,
                tx.clone(),
                // For now the request for this interface doesn't include a txn filter
                // because it is only used for the txn stream filestore worker, which
                // needs every transaction. Later we may add support for txn filtering
                // to this interface too.
                None,
                Some(abort_handle.clone()),
            );
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/stream_coordinator.rs (L532-546)
```rust
    pub fn set_highest_known_version(&mut self) -> anyhow::Result<()> {
        let info = self.context.get_latest_ledger_info_wrapped()?;
        let latest_table_info_version = self
            .context
            .indexer_reader
            .as_ref()
            .expect("Table info reader not set")
            .get_latest_table_info_ledger_version()?
            .expect("Table info ledger version not set");

        self.highest_known_version =
            std::cmp::min(info.ledger_version.0, latest_table_info_version);

        Ok(())
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/stream_coordinator.rs (L550-579)
```rust
    async fn ensure_highest_known_version(&mut self) -> bool {
        let mut empty_loops = 0;
        while self.highest_known_version == 0 || self.current_version > self.highest_known_version {
            if let Some(abort_handle) = self.abort_handle.as_ref() {
                if abort_handle.load(Ordering::SeqCst) {
                    return false;
                }
            }
            if empty_loops > 0 {
                tokio::time::sleep(Duration::from_millis(RETRY_TIME_MILLIS)).await;
            }
            empty_loops += 1;
            if let Err(err) = self.set_highest_known_version() {
                error!(
                    error = format!("{:?}", err),
                    "[Indexer Fullnode] Failed to set highest known version"
                );
                continue;
            } else {
                sample!(
                    SampleRate::Frequency(10),
                    info!(
                        highest_known_version = self.highest_known_version,
                        "[Indexer Fullnode] Found new highest known version",
                    )
                );
            }
        }
        true
    }
```

**File:** aptos-node/src/services.rs (L72-98)
```rust
    let (indexer_table_info_runtime, indexer_async_v2) = match bootstrap_indexer_table_info(
        node_config,
        chain_id,
        db_rw.clone(),
        mempool_client_sender.clone(),
    ) {
        Some((runtime, indexer_v2)) => (Some(runtime), Some(indexer_v2)),
        None => (None, None),
    };

    let (db_indexer_runtime, txn_event_reader) = match bootstrap_internal_indexer_db(
        node_config,
        db_rw.clone(),
        internal_indexer_db,
        update_receiver,
    ) {
        Some((runtime, db_indexer)) => (Some(runtime), Some(db_indexer)),
        None => (None, None),
    };

    let indexer_readers = IndexerReaders::new(indexer_async_v2, txn_event_reader);

    // Create the API runtime
    let indexer_reader: Option<Arc<dyn IndexerReader>> = indexer_readers.map(|readers| {
        let trait_object: Arc<dyn IndexerReader> = Arc::new(readers);
        trait_object
    });
```
