# Audit Report

## Title
Waypoint Verification Bypass via Unverified Peer-Advertised Ledger Info

## Summary

The `verify_waypoint_is_satisfiable` function in the state sync bootstrapper relies on peer-advertised `synced_ledger_info` data without cryptographic verification of signatures. This allows malicious peers to bypass waypoint checks by advertising fake high-version ledger infos, or conversely, can cause incorrect rejection of valid waypoints during startup race conditions when no peer data is available yet. [1](#0-0) 

## Finding Description

Waypoints are critical trust anchors in Aptos that represent cryptographically-verified blockchain states. During node bootstrapping, the system must verify that the configured waypoint can be satisfied by data available in the network. However, this verification process has a critical flaw.

**Root Cause:**

When peers advertise their storage summaries containing `synced_ledger_info`, these ledger infos are stored without signature verification: [2](#0-1) [3](#0-2) [4](#0-3) 

The waypoint satisfiability check then uses this unverified data: [5](#0-4) 

**Attack Vector 1: Malicious Bypass**

A malicious peer can advertise a `StorageServerSummary` with a fake `synced_ledger_info` containing:
- A version higher than the node's waypoint version
- Invalid or fabricated BLS signatures (never checked)

This bypasses the version comparison check, making the node believe the waypoint is satisfiable when it may not be in reality.

**Attack Vector 2: Incorrect Rejection**

If the global data summary is empty (no peers polled yet, or all peers ignored due to low scores), the function incorrectly returns `UnsatisfiableWaypoint`: [6](#0-5) 

This creates a race condition where legitimate nodes fail to bootstrap during startup. [7](#0-6) 

**Broken Invariant:**

This violates the "Cryptographic Correctness" invariant - BLS signatures must be verified before trusting ledger info data. It also breaks the trust anchor guarantee that waypoints provide, as the verification can be bypassed or incorrectly rejected based on unverified peer data.

## Impact Explanation

**High Severity** - This vulnerability can cause:

1. **Denial of Service**: Nodes may fail to bootstrap correctly due to:
   - Race conditions causing incorrect waypoint rejection
   - Malicious peers causing nodes to panic later when they can't actually verify the waypoint after bypassing the initial check

2. **Trust Anchor Compromise**: Waypoints are designed as off-chain trust anchors to prevent long-range attacks and ensure nodes sync to the correct chain. Bypassing these checks undermines this critical security mechanism.

3. **Validator Node Impact**: If validator nodes fail to bootstrap or get stuck in a panic loop, this affects network availability and could lead to liveness issues.

4. **Network Partition Risk**: If honest and malicious nodes make different decisions about waypoint satisfiability, it could lead to network inconsistencies.

While this doesn't directly cause fund loss, it significantly impacts network availability and violates critical security guarantees, qualifying as High Severity per Aptos bug bounty criteria.

## Likelihood Explanation

**High Likelihood** - This vulnerability is highly likely to be exploited because:

1. **Easy to Exploit**: Any peer can connect and advertise fake storage summaries - no special privileges required
2. **No Authentication**: Storage summaries are not authenticated or verified before use
3. **Race Condition**: The legitimate incorrect rejection scenario can occur naturally during normal node startup
4. **Network Exposure**: Any bootstrapping node is vulnerable when connecting to the network
5. **Low Attacker Cost**: Malicious peer only needs to advertise fake data, no computational work required

The attack is practical and requires minimal resources to execute.

## Recommendation

**Immediate Fix:**

1. **Verify Signatures**: Before using `synced_ledger_info` from peer advertisements, verify the BLS aggregate signatures against a known validator set:

```rust
// In poller.rs, before updating peer storage summary
let storage_summary = match result {
    Ok(storage_summary) => {
        // Verify synced_ledger_info signatures if present
        if let Some(synced_ledger_info) = &storage_summary.data_summary.synced_ledger_info {
            // Need to verify against current epoch state or known validator set
            // This requires passing epoch state context to the poller
            if let Err(e) = verify_ledger_info_signatures(synced_ledger_info) {
                warn!("Invalid synced_ledger_info signatures from peer: {:?}", e);
                return;
            }
        }
        storage_summary
    },
    Err(error) => { /* ... */ },
};
```

2. **Defensive Check**: In `verify_waypoint_is_satisfiable`, add a more defensive check:

```rust
fn verify_waypoint_is_satisfiable(
    &mut self,
    global_data_summary: &GlobalDataSummary,
) -> Result<(), Error> {
    // ... existing local storage check ...
    
    // Get the highest advertised synced ledger info version
    let highest_advertised_ledger_info = global_data_summary
        .advertised_data
        .highest_synced_ledger_info()
        .ok_or_else(|| {
            // More informative error - this might be temporary
            Error::AdvertisedDataError(
                "Unable to verify waypoint satisfiability yet - no peer data available. Will retry.".into()
            )
        })?;
    
    // ... rest of function ...
}
```

3. **Delay Initial Check**: Don't check waypoint satisfiability immediately on startup - wait for at least one peer polling round to complete to avoid race conditions.

**Long-term Fix:**

Implement a proper trust establishment protocol where:
- Nodes only accept storage summaries from peers after verifying they're on the correct chain
- Use secure peer reputation and attestation mechanisms
- Implement gradual trust buildup rather than immediately trusting peer advertisements

## Proof of Concept

```rust
// Integration test demonstrating the vulnerability
#[tokio::test]
async fn test_waypoint_bypass_via_fake_peer_advertisement() {
    // Setup: Create a bootstrapping node with waypoint at version 1000
    let waypoint = Waypoint::new_any(&create_ledger_info_at_version(1000));
    let mut bootstrapper = create_test_bootstrapper(waypoint);
    
    // Attack: Malicious peer advertises fake high-version ledger info
    let fake_ledger_info = LedgerInfoWithSignatures::new(
        LedgerInfo::new(
            BlockInfo::new(/* epoch */ 100, /* version */ 10000, /* ... */),
            HashValue::zero(),
        ),
        BTreeMap::new(), // Empty signatures map - invalid!
    );
    
    let fake_summary = StorageServerSummary {
        data_summary: DataSummary {
            synced_ledger_info: Some(fake_ledger_info),
            // ... other fields ...
        },
        // ... other fields ...
    };
    
    // Simulate peer advertising this fake summary
    data_client.update_peer_storage_summary(malicious_peer_id, fake_summary);
    data_client.update_global_summary_cache().unwrap();
    
    let global_summary = data_client.get_global_data_summary();
    
    // Vulnerability: This should fail but passes!
    let result = bootstrapper.verify_waypoint_is_satisfiable(&global_summary);
    assert!(result.is_ok()); // ❌ Fake data bypasses the check
    
    // The actual version advertised is 10000, higher than waypoint 1000,
    // so the check passes even though the ledger info has no valid signatures
}

#[tokio::test]
async fn test_waypoint_incorrect_rejection_race_condition() {
    // Setup: Create a bootstrapping node with valid waypoint
    let waypoint = Waypoint::new_any(&create_valid_ledger_info());
    let mut bootstrapper = create_test_bootstrapper(waypoint);
    
    // Scenario: Node starts before any peers are polled
    let empty_global_summary = GlobalDataSummary::empty();
    
    // Vulnerability: Valid waypoint gets rejected!
    let result = bootstrapper.verify_waypoint_is_satisfiable(&empty_global_summary);
    assert!(matches!(result, Err(Error::UnsatisfiableWaypoint(_)))); // ❌ False rejection
}
```

## Notes

This vulnerability affects the core trust model of the Aptos blockchain's state synchronization. Waypoints are specifically designed to prevent long-range attacks and ensure nodes sync to the correct chain after restarts. The lack of signature verification on peer-advertised ledger infos undermines this critical security mechanism.

The issue is particularly concerning because:
1. It can affect both new nodes joining the network and existing nodes restarting
2. The attack requires no special resources or privileges
3. The race condition variant can occur in normal operation
4. It could potentially be used as part of a larger eclipse attack strategy

The fix requires careful consideration of when and how to verify signatures, as the node may not yet have the validator set information needed for verification during early bootstrapping phases.

### Citations

**File:** state-sync/state-sync-driver/src/error.rs (L51-53)
```rust
    #[error("Failed to verify waypoint satisfiability: {0}")]
    UnsatisfiableWaypoint(String),
}
```

**File:** state-sync/aptos-data-client/src/poller.rs (L436-439)
```rust
        // Update the summary for the peer
        data_summary_poller
            .data_client
            .update_peer_storage_summary(peer, storage_summary);
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L177-179)
```rust
    fn update_storage_summary(&mut self, storage_summary: StorageServerSummary) {
        self.storage_summary = Some(storage_summary);
    }
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L325-330)
```rust
    pub fn update_summary(&self, peer: PeerNetworkId, storage_summary: StorageServerSummary) {
        self.peer_to_state
            .entry(peer)
            .or_insert(PeerState::new(self.data_client_config.clone()))
            .update_storage_summary(storage_summary);
    }
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L352-355)
```rust
        // If we have no peers, return an empty global summary
        if storage_summaries.is_empty() {
            return GlobalDataSummary::empty();
        }
```

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L880-915)
```rust
    fn verify_waypoint_is_satisfiable(
        &mut self,
        global_data_summary: &GlobalDataSummary,
    ) -> Result<(), Error> {
        // If our storage has already synced beyond our waypoint, nothing needs to be checked
        let latest_ledger_info = utils::fetch_latest_synced_ledger_info(self.storage.clone())?;
        let waypoint_version = self.driver_configuration.waypoint.version();
        if latest_ledger_info.ledger_info().version() >= waypoint_version {
            self.verified_epoch_states
                .set_verified_waypoint(waypoint_version);
            return Ok(());
        }

        // Get the highest advertised synced ledger info version
        let highest_advertised_ledger_info = global_data_summary
            .advertised_data
            .highest_synced_ledger_info()
            .ok_or_else(|| {
                Error::UnsatisfiableWaypoint(
                    "Unable to check waypoint satisfiability! No highest advertised ledger info found in the network!".into(),
                )
            })?;
        let highest_advertised_version = highest_advertised_ledger_info.ledger_info().version();

        // Compare the highest advertised version with our waypoint
        if highest_advertised_version < waypoint_version {
            Err(Error::UnsatisfiableWaypoint(
                format!(
                    "The waypoint is not satisfiable! No advertised version higher than our waypoint! Highest version: {:?}, waypoint version: {:?}.",
                    highest_advertised_version, waypoint_version
                )
            ))
        } else {
            Ok(())
        }
    }
```
