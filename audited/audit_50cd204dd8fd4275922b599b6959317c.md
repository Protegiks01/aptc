# Audit Report

## Title
Silent Validator Network Address Deserialization Failures Enable Validator Isolation and Network Liveness Attacks

## Summary
BCS deserialization errors in validator network addresses are silently suppressed in the network discovery layer, allowing validators with invalid configurations to remain in the active set while being unreachable. This creates a divergence between the consensus validator set (which includes their voting power) and the actual reachable validators, potentially causing network liveness failures.

## Finding Description

The vulnerability exists in the error handling chain when validators' network addresses are processed:

**1. Valid Error Propagation at Type Level**

The `validator_network_addresses()` function correctly returns a Result type: [1](#0-0) 

**2. Error Silencing in Network Discovery**

However, in the network discovery layer, when this function is called, errors are caught and silently converted to empty address lists: [2](#0-1) 

The critical line is `.unwrap_or_default()` which converts any deserialization error into an empty vector, only logging a warning. This means validators with corrupted or invalid network addresses are added to the peer set with zero addresses.

**3. Validator Becomes Unreachable**

When the connectivity manager processes these validators, they are marked as ineligible to dial because they have no addresses: [3](#0-2) [4](#0-3) 

**4. Voting Power Still Counted**

Meanwhile, the validator's voting power is still included in consensus quorum calculations because the ValidatorSet â†’ ValidatorVerifier conversion does NOT validate network addresses: [5](#0-4) 

The quorum calculation includes all validators' voting power: [6](#0-5) 

**5. No Validation During Address Updates**

The on-chain function that updates validator addresses accepts raw bytes without validation: [7](#0-6) 

## Impact Explanation

This vulnerability meets **High Severity** criteria per Aptos bug bounty:

1. **Network Liveness Degradation**: If validators controlling significant voting power have invalid addresses, the effective reachable voting power drops below the BFT threshold (2f+1), preventing consensus progress while the network appears operational.

2. **Validator Node Isolation**: Legitimate validators become silently isolated from the network, unable to participate in consensus, causing "significant protocol violations" (High severity category).

3. **Difficult Debugging**: Errors are only logged as warnings, making it extremely difficult for operators to diagnose why validators cannot participate.

4. **Persistent State Corruption**: Invalid addresses remain on-chain until manually corrected, creating a "state inconsistency requiring intervention" (Medium severity category).

## Likelihood Explanation

**Moderate to High Likelihood:**

1. **Accidental Triggering**: Validator operators using buggy CLI tools or client libraries could accidentally submit malformed BCS data.

2. **State Corruption**: Other bugs in state synchronization or VM execution could corrupt the on-chain address data.

3. **Operational Impact**: Even one validator with invalid addresses faces isolation, and multiple validators with this issue could cause network-wide liveness failures.

4. **No Detection Mechanism**: The silent failure pattern means this issue could persist undetected until consensus progress stops.

## Recommendation

**Immediate Fix**: Implement proper error propagation and fail-fast behavior:

```rust
// In network/discovery/src/validator_set.rs, line 121-140
let addrs = if is_validator {
    config.validator_network_addresses()
} else {
    config.fullnode_network_addresses()
}
.map_err(|err| {
    error!(  // Upgrade from warn! to error!
        NetworkSchema::new(&network_context),
        "CRITICAL: Failed to deserialize network addresses for peer {}: {}. \
         This validator will be EXCLUDED from the active set.",
        peer_id,
        err
    );
    
    inc_by_with_context(&DISCOVERY_COUNTS, &network_context, "critical_parse_failure", 1);
    err
})?;  // Propagate the error instead of unwrap_or_default()

// Then handle the Result at a higher level to:
// 1. Emit alerts to monitoring systems
// 2. Consider excluding the validator from the active set
// 3. Trigger operator notifications
```

**Long-term Fixes**:

1. **On-Chain Validation**: Add BCS deserialization validation in the Move contract:
```move
// In stake.move, update_network_and_fullnode_addresses:
assert!(
    are_valid_network_addresses(new_network_addresses),
    error::invalid_argument(EINVALID_NETWORK_ADDRESSES)
);
```

2. **Epoch Transition Validation**: During epoch changes, validate that all validators in the active set have valid, deserializable network addresses before committing to the new epoch.

3. **Health Checks**: Implement periodic health checks that verify validator connectivity and alert when validators become unreachable.

## Proof of Concept

```rust
// Rust test demonstrating the vulnerability
#[test]
fn test_invalid_network_addresses_silent_failure() {
    use aptos_types::validator_config::ValidatorConfig;
    use aptos_crypto::bls12381;
    
    // Create a ValidatorConfig with INVALID BCS data
    let consensus_key = bls12381::PrivateKey::generate_for_testing().public_key();
    let invalid_bcs_data = vec![0xFF, 0xFF, 0xFF]; // Invalid BCS
    
    let config = ValidatorConfig::new(
        consensus_key,
        invalid_bcs_data.clone(), // Invalid validator addresses
        vec![],
        0,
    );
    
    // Attempt to deserialize - this SHOULD fail
    let result = config.validator_network_addresses();
    assert!(result.is_err(), "Expected deserialization to fail");
    
    // In extract_validator_set_updates, this error is silently converted to empty vec
    // Simulating the vulnerable code path:
    let addrs = result.unwrap_or_default();
    assert_eq!(addrs.len(), 0, "Silent failure: error became empty addresses");
    
    // The validator is now in the peer set but unreachable
    // Yet their voting power still counts in consensus quorum calculation
    println!("VULNERABILITY: Validator has invalid addresses but remains in active set");
}
```

**Notes:**

This vulnerability violates multiple critical invariants:
- **Consensus Safety**: The effective voting power available for consensus diverges from the calculated quorum threshold
- **Deterministic Execution**: Different nodes may have different views of which validators are reachable
- **Defensive Programming**: Errors should be propagated and handled explicitly, not silenced

The root cause is a dangerous error-handling anti-pattern where recoverable errors are silently converted to default values, allowing the system to proceed in an invalid state instead of failing fast and alerting operators.

### Citations

**File:** types/src/validator_config.rs (L64-66)
```rust
    pub fn validator_network_addresses(&self) -> Result<Vec<NetworkAddress>, bcs::Error> {
        bcs::from_bytes(&self.validator_network_addresses)
    }
```

**File:** network/discovery/src/validator_set.rs (L121-140)
```rust
            let addrs = if is_validator {
                config
                    .validator_network_addresses()
                    .map_err(anyhow::Error::from)
            } else {
                config
                    .fullnode_network_addresses()
                    .map_err(anyhow::Error::from)
            }
            .map_err(|err| {
                inc_by_with_context(&DISCOVERY_COUNTS, &network_context, "read_failure", 1);

                warn!(
                    NetworkSchema::new(&network_context),
                    "OnChainDiscovery: Failed to parse any network address: peer: {}, err: {}",
                    peer_id,
                    err
                )
            })
            .unwrap_or_default();
```

**File:** network/framework/src/connectivity_manager/mod.rs (L259-262)
```rust
    /// Peers without addresses can't be dialed to
    pub fn is_eligible_to_be_dialed(&self) -> bool {
        self.is_eligible() && !self.addrs.is_empty()
    }
```

**File:** network/framework/src/connectivity_manager/mod.rs (L580-585)
```rust
            .filter(|(peer_id, peer)| {
                peer.is_eligible_to_be_dialed() // The node is eligible to dial
                    && !self.connected.contains_key(peer_id) // The node is not already connected
                    && !self.dial_queue.contains_key(peer_id) // There is no pending dial to this node
                    && roles_to_dial.contains(&peer.role) // We can dial this role
            })
```

**File:** types/src/validator_verifier.rs (L206-214)
```rust
    pub fn new(validator_infos: Vec<ValidatorConsensusInfo>) -> Self {
        let total_voting_power = sum_voting_power(&validator_infos);
        let quorum_voting_power = if validator_infos.is_empty() {
            0
        } else {
            total_voting_power * 2 / 3 + 1
        };
        Self::build_index(validator_infos, quorum_voting_power, total_voting_power)
    }
```

**File:** types/src/validator_verifier.rs (L563-585)
```rust
impl From<&ValidatorSet> for ValidatorVerifier {
    fn from(validator_set: &ValidatorSet) -> Self {
        let sorted_validator_infos: BTreeMap<u64, ValidatorConsensusInfo> = validator_set
            .payload()
            .map(|info| {
                (
                    info.config().validator_index,
                    ValidatorConsensusInfo::new(
                        info.account_address,
                        info.consensus_public_key().clone(),
                        info.consensus_voting_power(),
                    ),
                )
            })
            .collect();
        let validator_infos: Vec<_> = sorted_validator_infos.values().cloned().collect();
        for info in validator_set.payload() {
            assert_eq!(
                validator_infos[info.config().validator_index as usize].address,
                info.account_address
            );
        }
        ValidatorVerifier::new(validator_infos)
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L955-971)
```text
    public entry fun update_network_and_fullnode_addresses(
        operator: &signer,
        pool_address: address,
        new_network_addresses: vector<u8>,
        new_fullnode_addresses: vector<u8>,
    ) acquires StakePool, ValidatorConfig {
        check_stake_permission(operator);
        assert_reconfig_not_in_progress();
        assert_stake_pool_exists(pool_address);
        let stake_pool = borrow_global_mut<StakePool>(pool_address);
        assert!(signer::address_of(operator) == stake_pool.operator_address, error::unauthenticated(ENOT_OPERATOR));
        assert!(exists<ValidatorConfig>(pool_address), error::not_found(EVALIDATOR_CONFIG));
        let validator_info = borrow_global_mut<ValidatorConfig>(pool_address);
        let old_network_addresses = validator_info.network_addresses;
        validator_info.network_addresses = new_network_addresses;
        let old_fullnode_addresses = validator_info.fullnode_addresses;
        validator_info.fullnode_addresses = new_fullnode_addresses;
```
