# Audit Report

## Title
Mass Censorship Attack via Coordinated Validator Transaction Filtering

## Summary
A coordinated group of validators controlling >1/3 of voting power can deploy identical restrictive transaction filters to permanently censor entire classes of transactions, effectively disabling critical protocol features including governance and staking operations.

## Finding Description

The Aptos consensus system allows each validator to configure custom transaction filters that determine which transactions they will include in proposed blocks and which blocks they will vote for. This creates a critical vulnerability where coordinated validators can enforce mass censorship.

**Attack Mechanism:**

1. **Filter Configuration**: Each validator configures their transaction filter via `node_config.transaction_filters.consensus_filter`. [1](#0-0) 

2. **Block Proposal Filtering**: When proposing a block, validators apply their configured filter to remove transactions matching Deny rules. [2](#0-1) 

3. **Block Validation Filtering**: When receiving a block proposal from another validator, each validator checks if the block contains ANY transactions their filter would deny. [3](#0-2) 

4. **Vote Withholding**: If denied transactions are found, the validator drops the proposal and does NOT vote for it. [4](#0-3) 

5. **Quorum Failure**: Since quorum requires >2/3 voting power, if >1/3 of validators withhold votes, the block cannot achieve quorum. [5](#0-4) 

**Transaction Filter Capabilities:**

The `TransactionMatcher` enum supports powerful filtering criteria including:
- Specific entry functions: `EntryFunction(address, module, function)` 
- Module addresses: `ModuleAddress(address)`
- Sender addresses: `Sender(address)`
- All transactions: `All` [6](#0-5) 

**Attack Scenario:**

Validators controlling >1/3 voting power coordinate to deploy identical filters denying:
- All governance transactions: `Deny(EntryFunction(0x1, "aptos_governance", "*"))`
- All staking transactions: `Deny(EntryFunction(0x1, "stake", "*"))`  
- Any protocol feature by module address

When honest validators propose blocks containing these transactions, the coordinated validators refuse to vote, preventing quorum. Only blocks without the censored transactions achieve consensus and commit.

## Impact Explanation

**Severity: Critical** - This vulnerability meets multiple Critical severity criteria from the Aptos bug bounty:

1. **Total loss of liveness** for specific transaction classes: Governance transactions, staking transactions, or any targeted protocol feature become permanently unprocessable.

2. **Non-recoverable network partition**: If governance transactions are censored, on-chain governance cannot execute proposals to fix the issue, requiring a hard fork.

3. **Permanent freezing of protocol functionality**: Critical features like validator set updates, protocol upgrades, and governance voting can be completely disabled.

This breaks the fundamental **Consensus Safety invariant** that "AptosBFT must prevent chain splits under < 1/3 Byzantine" by allowing >1/3 validators to halt liveness for transaction subsets without requiring >2/3 Byzantine behavior.

## Likelihood Explanation

**Likelihood: Medium-to-High**

**Requirements for attack:**
- Coordination of validators controlling >1/3 voting power
- Each validator configures identical filter rules in their node config
- No code changes or exploits needed - uses designed features

**Why this is realistic:**
1. Filter configuration is straightforward through config files
2. No cryptographic attacks or complex exploits required  
3. Validators may claim "regulatory compliance" as justification
4. Attack is deniable - validators can claim network issues
5. No on-chain evidence of coordination
6. Once governance is censored, no on-chain remedy exists

The attack requires validator coordination, which is a form of collusion. However, unlike >2/3 Byzantine attacks, this only requires >1/3 validators, making it more feasible. The filters are designed features that can be legitimately configured, making detection difficult.

## Recommendation

**Immediate Fix:** Disable the `check_denied_inline_transactions` validation check that allows validators to reject blocks based on their local filter configuration.

**Correct Design:** Transaction filtering should only apply to:
1. **Block proposal stage**: Validators filter what they propose
2. **NOT block validation stage**: Validators must vote on ALL valid blocks regardless of their filter preferences

**Implementation:**

Remove the filter check from the proposal validation path: [3](#0-2) 

This code should be removed or modified to only log warnings rather than rejecting proposals.

**Alternative approach:** Implement consensus-level filter rules that ALL validators must follow (configured via on-chain governance), rather than per-validator filters that create inconsistent validation behavior.

## Proof of Concept

```rust
// PoC Configuration for Coordinated Validators
// File: validator_node_config.yaml (for each coordinating validator)

transaction_filters:
  consensus_filter:
    filter_enabled: true
    block_transaction_filter:
      block_transaction_rules:
        # Deny all governance transactions
        - Deny:
          - Transaction:
              ModuleAddress: "0x1"  # aptos_framework
          - Transaction:
              EntryFunction: ["0x1", "aptos_governance", "*"]
        
        # Deny all staking transactions  
        - Deny:
          - Transaction:
              EntryFunction: ["0x1", "stake", "*"]
```

**Execution Steps:**

1. Deploy 3+ validators with combined >1/3 voting power
2. Configure identical filters as shown above
3. Submit a governance proposal transaction
4. Observe that honest validators propose blocks with the transaction
5. Coordinated validators reject these blocks (no votes)
6. Blocks without governance transactions achieve quorum
7. Governance is permanently disabled

**Observable Effects:**
- Governance transactions remain in mempool indefinitely
- Blocks containing governance transactions do not achieve QC
- Only "clean" blocks without filtered transactions commit
- `REJECTED_PROPOSAL_DENY_TXN_COUNT` metric increases for rejected proposals

## Notes

This vulnerability exploits the asymmetry between block proposal and block validation. While validators should be free to choose which transactions to include in their own proposals, allowing them to reject OTHER validators' proposals based on transaction content creates a censorship vector.

The key insight is that the filter check happens at line 1204-1214 in `round_manager.rs` BEFORE voting, allowing validators to refuse voting on otherwise valid proposals. This gives validators veto power over transaction inclusion beyond their own proposals.

The fix must preserve validators' ability to filter their OWN proposals while preventing them from rejecting others' valid proposals. The current design conflates these two distinct concerns.

### Citations

**File:** consensus/src/epoch_manager.rs (L211-211)
```rust
        let consensus_txn_filter_config = node_config.transaction_filters.consensus_filter.clone();
```

**File:** consensus/src/block_preparer.rs (L91-98)
```rust
            let filtered_txns = filter_block_transactions(
                txn_filter_config,
                block_id,
                block_author,
                block_epoch,
                block_timestamp_usecs,
                txns,
            );
```

**File:** consensus/src/round_manager.rs (L1202-1214)
```rust
        // If the proposal contains any inline transactions that need to be denied
        // (e.g., due to filtering) drop the message and do not vote for the block.
        if let Err(error) = self
            .block_store
            .check_denied_inline_transactions(&proposal, &self.block_txn_filter_config)
        {
            counters::REJECTED_PROPOSAL_DENY_TXN_COUNT.inc();
            bail!(
                "[RoundManager] Proposal for block {} contains denied inline transactions: {}. Dropping proposal!",
                proposal.id(),
                error
            );
        }
```

**File:** types/src/validator_verifier.rs (L211-211)
```rust
            total_voting_power * 2 / 3 + 1
```

**File:** crates/aptos-transaction-filters/src/transaction_filter.rs (L171-180)
```rust
pub enum TransactionMatcher {
    All,                                           // Matches any transaction
    TransactionId(HashValue),                      // Matches a specific transaction by its ID
    Sender(AccountAddress), // Matches any transaction sent by a specific account address
    ModuleAddress(AccountAddress), // Matches any transaction that calls a module at a specific address
    EntryFunction(AccountAddress, String, String), // Matches any transaction that calls a specific entry function in a module
    AccountAddress(AccountAddress), // Matches any transaction that involves a specific account address
    PublicKey(AnyPublicKey),        // Matches any transaction that involves a specific public key
    EncryptedTransaction,           // Matches any encrypted transaction
}
```
