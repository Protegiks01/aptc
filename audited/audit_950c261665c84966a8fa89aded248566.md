# Audit Report

## Title
Insufficient Validation in Faucet Amount Allows Unbounded Token Minting on Misconfigured Test Networks

## Summary
The `fund_account()` function in `crates/aptos/src/common/utils.rs` does not validate the `num_octas` parameter before passing it to the faucet. When combined with a faucet configured without a `maximum_amount` limit, this allows requesting and minting up to `u64::MAX` tokens on test/devnet environments, potentially inflating token supply and wasting gas resources.

## Finding Description
The vulnerability exists across three layers:

1. **CLI Layer**: The `fund_account()` function accepts `num_octas: u64` without validation: [1](#0-0) 

2. **Faucet Client Layer**: The `FaucetClient::fund()` method formats the amount directly into a URL query without validation: [2](#0-1) 

3. **Faucet Server Layer**: The `MintFunder::get_amount()` method only enforces a maximum if `maximum_amount` is configured. When `maximum_amount` is `None`, it returns the requested amount without bounds: [3](#0-2) 

The `maximum_amount` field in `TransactionSubmissionConfig` is `Option<u64>` with no default value: [4](#0-3) 

**Attack Flow:**
1. Attacker identifies a faucet deployed without `maximum_amount` configured
2. Attacker calls the faucet API with `amount=18446744073709551615` (u64::MAX)
3. The faucet mints u64::MAX tokens using `aptos_coin::mint()`: [5](#0-4) 

4. The tokens are deposited via the fungible asset system: [6](#0-5) 

5. For a new account (balance = 0), the full amount is successfully deposited
6. For an existing account, the deposit aborts due to Move's checked arithmetic overflow protection at `store.balance += amount`

## Impact Explanation
This is a **Medium severity** issue based on the Aptos bug bounty criteria ("Limited funds loss or manipulation"):

- **Not Critical/High** because:
  - Only affects test/devnet faucets (no mainnet impact)
  - Requires faucet misconfiguration (operator failure to set `maximum_amount`)
  - Move's checked arithmetic prevents actual balance overflow (transactions abort)
  - Does not break consensus or enable fund theft from other accounts

- **Medium** because:
  - Allows inflation of testnet token supply to astronomical levels
  - Wastes gas fees on failed deposit attempts
  - Can DOS the faucet through repeated failed transactions
  - Requires operator intervention to mitigate

## Likelihood Explanation
**Moderate likelihood** in misconfigured deployments:

- **Requirements**: 
  - Faucet deployed on testnet/devnet without `maximum_amount` configured
  - Attacker identifies the misconfiguration
  - No additional authentication or rate limiting prevents abuse

- **Barriers**:
  - Most production faucet deployments likely configure `maximum_amount`
  - Only affects non-production environments
  - Testnet tokens have no real economic value

## Recommendation
Implement validation at multiple layers:

1. **Add validation in `fund_account()`**:
```rust
pub async fn fund_account(
    rest_client: Client,
    faucet_url: Url,
    faucet_auth_token: Option<&str>,
    address: AccountAddress,
    num_octas: u64,
) -> CliTypedResult<()> {
    // Add reasonable upper bound (e.g., 1000 APT = 100_000_000_000 octas)
    const MAX_FAUCET_AMOUNT: u64 = 100_000_000_000;
    if num_octas > MAX_FAUCET_AMOUNT {
        return Err(CliError::CommandArgumentError(
            format!("Requested amount {} exceeds maximum {}", num_octas, MAX_FAUCET_AMOUNT)
        ));
    }
    
    let mut client = FaucetClient::new_from_rest_client(faucet_url, rest_client);
    // ... rest of function
}
```

2. **Make `maximum_amount` required or provide sensible default**:
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct TransactionSubmissionConfig {
    /// Maximum amount of OCTA to give an account.
    #[serde(default = "TransactionSubmissionConfig::default_maximum_amount")]
    maximum_amount: u64,
    // ...
}

impl TransactionSubmissionConfig {
    fn default_maximum_amount() -> u64 {
        100_000_000_000 // 1000 APT
    }
}
```

3. **Add server-side validation in faucet endpoint**:
```rust
async fn fund_inner(...) -> poem::Result<Vec<SignedTransaction>, AptosTapError> {
    // Validate amount even if maximum_amount is not configured
    const ABSOLUTE_MAX: u64 = 1_000_000_000_000; // 10,000 APT
    if let Some(requested) = fund_request.amount {
        if requested > ABSOLUTE_MAX {
            return Err(AptosTapError::new(
                format!("Requested amount {} exceeds absolute maximum {}", requested, ABSOLUTE_MAX),
                AptosTapErrorCode::InvalidRequest,
            ));
        }
    }
    // ...
}
```

## Proof of Concept
**Scenario**: Faucet deployed without `maximum_amount` configured

**Attack Steps**:
```bash
# 1. Set up connection to testnet faucet (hypothetically misconfigured)
export FAUCET_URL="https://faucet.testnet.aptoslabs.com"
export NODE_URL="https://fullnode.testnet.aptoslabs.com"

# 2. Create a new account
aptos init --network custom --rest-url $NODE_URL --faucet-url $FAUCET_URL

# 3. Request maximum u64 value (18446744073709551615 octas)
# This would normally be prevented by CLI limits, but demonstrates the issue
curl -X POST "$FAUCET_URL/mint?address=0xABCD&amount=18446744073709551615&return_txns=true"

# 4. For a new account, this successfully mints and deposits u64::MAX tokens
# For an existing account, the transaction aborts on deposit overflow
```

**Expected Behavior**: Request should be rejected with "amount exceeds maximum"

**Actual Behavior** (in misconfigured faucet): Request proceeds, minting u64::MAX tokens

**Notes**:
- This PoC requires a faucet actually deployed without `maximum_amount` configured
- The vulnerability is limited to test/devnet environments
- The security impact is configuration-dependent rather than an inherent code flaw

### Citations

**File:** crates/aptos/src/common/utils.rs (L455-470)
```rust
pub async fn fund_account(
    rest_client: Client,
    faucet_url: Url,
    faucet_auth_token: Option<&str>,
    address: AccountAddress,
    num_octas: u64,
) -> CliTypedResult<()> {
    let mut client = FaucetClient::new_from_rest_client(faucet_url, rest_client);
    if let Some(token) = faucet_auth_token {
        client = client.with_auth_token(token.to_string());
    }
    client
        .fund(address, num_octas)
        .await
        .map_err(|err| CliError::ApiError(format!("Faucet issue: {:#}", err)))
}
```

**File:** crates/aptos-rest-client/src/faucet.rs (L84-109)
```rust
    pub async fn fund(&self, address: AccountAddress, amount: u64) -> Result<()> {
        let mut url = self.faucet_url.clone();
        url.set_path("mint");
        let query = format!("auth_key={}&amount={}&return_txns=true", address, amount);
        url.set_query(Some(&query));

        // Faucet returns the transaction that creates the account and needs to be waited on before
        // returning.
        let response = self.build_and_submit_request(url).await?;
        let status_code = response.status();
        let body = response.text().await.map_err(FaucetClientError::decode)?;
        if !status_code.is_success() {
            return Err(FaucetClientError::status(status_code.as_u16()).into());
        }

        let bytes = hex::decode(body).map_err(FaucetClientError::decode)?;
        let txns: Vec<SignedTransaction> =
            bcs::from_bytes(&bytes).map_err(FaucetClientError::decode)?;

        self.rest_client
            .wait_for_signed_transaction(&txns[0])
            .await
            .map_err(FaucetClientError::unknown)?;

        Ok(())
    }
```

**File:** crates/aptos-faucet/core/src/funder/mint.rs (L540-550)
```rust
    fn get_amount(&self, amount: Option<u64>, did_bypass_checkers: bool) -> u64 {
        match (
            amount,
            self.txn_config.get_maximum_amount(did_bypass_checkers),
        ) {
            (Some(amount), Some(maximum_amount)) => std::cmp::min(amount, maximum_amount),
            (Some(amount), None) => amount,
            (None, Some(maximum_amount)) => std::cmp::min(self.amount_to_fund, maximum_amount),
            (None, None) => self.amount_to_fund,
        }
    }
```

**File:** crates/aptos-faucet/core/src/funder/common.rs (L93-128)
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct TransactionSubmissionConfig {
    /// Maximum amount of OCTA to give an account.
    maximum_amount: Option<u64>,

    /// With this it is possible to set a different maximum amount for requests that
    /// were allowed to skip the Checkers by a Bypasser. This can be helpful for CI,
    /// where we might need to mint a greater amount than is normally required in the
    /// standard case. If not given, maximum_amount is used whether the request
    /// bypassed the checks or not.
    maximum_amount_with_bypass: Option<u64>,

    /// How long to wait between fetching updated gas unit prices.
    #[serde(default = "TransactionSubmissionConfig::default_gas_unit_price_ttl_secs")]
    gas_unit_price_ttl_secs: u16,

    /// If given, we'll use this value for the gas unit price. If not, we'll use
    /// the gas unit price estimation API periodically.
    pub gas_unit_price_override: Option<u64>,

    /// The maximum amount of gas to spend on a single transfer.
    #[serde(default = "TransactionSubmissionConfig::default_max_gas_amount")]
    pub max_gas_amount: u64,

    /// Expiration time we'll allow for transactions.
    #[serde(default = "TransactionSubmissionConfig::default_transaction_expiration_secs")]
    pub transaction_expiration_secs: u64,

    /// Amount of time we'll wait for the seqnum to catch up before resetting it.
    #[serde(default = "TransactionSubmissionConfig::default_wait_for_outstanding_txns_secs")]
    pub wait_for_outstanding_txns_secs: u64,

    /// Whether to wait for the transaction before returning.
    #[serde(default)]
    pub wait_for_transactions: bool,
}
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_coin.move (L93-108)
```text
    public entry fun mint(
        account: &signer,
        dst_addr: address,
        amount: u64,
    ) acquires MintCapStore {
        let account_addr = signer::address_of(account);

        assert!(
            exists<MintCapStore>(account_addr),
            error::not_found(ENO_CAPABILITIES),
        );

        let mint_cap = &borrow_global<MintCapStore>(account_addr).mint_cap;
        let coins_minted = coin::mint<AptosCoin>(amount, mint_cap);
        coin::deposit<AptosCoin>(dst_addr, coins_minted);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/fungible_asset.move (L1244-1269)
```text
    inline fun unchecked_deposit_with_no_events_inline(
        store_addr: address, fa: FungibleAsset
    ): u64 {
        let FungibleAsset { metadata, amount } = fa;
        assert!(
            exists<FungibleStore>(store_addr),
            error::not_found(EFUNGIBLE_STORE_EXISTENCE)
        );
        let store = borrow_global_mut<FungibleStore>(store_addr);
        assert!(
            metadata == store.metadata,
            error::invalid_argument(EFUNGIBLE_ASSET_AND_STORE_MISMATCH)
        );

        if (amount != 0) {
            if (store.balance == 0
                && concurrent_fungible_balance_exists_inline(store_addr)) {
                let balance_resource =
                    borrow_global_mut<ConcurrentFungibleBalance>(store_addr);
                balance_resource.balance.add(amount);
            } else {
                store.balance += amount;
            };
        };
        amount
    }
```
