# Audit Report

## Title
Private Key Exposure via Insecure File Permissions in Indexer Transaction Generator

## Summary
The `save_as_profile_file()` method in the indexer transaction generator writes private keys to disk without setting restrictive file permissions, allowing other processes and users on the same system to read sensitive account credentials during the window between file creation and deletion.

## Finding Description

The `save_as_profile_file()` method creates a configuration file containing plaintext private keys without setting proper Unix file permissions. [1](#0-0) 

The method uses `tokio::fs::create_dir_all()` and `tokio::fs::write()` which create directories and files with default permissions on Unix systems (typically 0755 for directories and 0644 for files after umask application). This means the configuration file containing the private key is readable by all users on the system.

The file is created when `prepare_script_transaction()` calls `save_as_profile_file()` [2](#0-1) , and while it is eventually deleted [3](#0-2) , there is a significant time window during script compilation and execution where the file exists with insecure permissions.

In contrast, the Aptos codebase provides a secure pattern for writing sensitive files with restricted permissions using `write_to_user_only_file()` which sets mode 0o600 (owner-only read/write) on Unix systems. [4](#0-3) 

**Attack Path:**
1. Developer or CI system runs the indexer-transaction-generator tool on a multi-user system or shared CI/CD environment
2. The tool creates `.aptos/config.yaml` in the script directory with the private key in plaintext
3. File is created with default permissions (0644), making it world-readable
4. Another user, compromised process, or malicious actor on the same system reads the file during the execution window (several seconds while scripts compile and run)
5. If the process crashes or is interrupted, the file may never be deleted, leaving credentials permanently exposed
6. Attacker gains the private key and can sign arbitrary transactions, drain funds, or compromise the account

## Impact Explanation

This vulnerability allows exposure of private keys that grant complete control over blockchain accounts. According to Aptos bug bounty criteria, this qualifies as **Critical Severity** because:

- **Credential Exposure**: Private keys are the most sensitive cryptographic material, providing full account control
- **Loss of Funds**: An attacker with the private key can sign transactions to transfer all funds from the compromised account
- **Account Takeover**: Complete control over account operations, including smart contract interactions

While this affects a testing tool rather than core protocol components, the tool handles real credentials that could be used in development, staging, or testing environments connected to live networks. The file permission issue represents a fundamental security flaw in credential handling.

## Likelihood Explanation

**Likelihood: Medium-High**

This vulnerability is likely to be exploited in realistic scenarios:

1. **CI/CD Environments**: Testing tools are commonly run in CI/CD pipelines that may use shared runners or multi-tenant container environments where multiple processes have access to the filesystem

2. **Development Systems**: Multi-user development servers or shared workstations where multiple developers have access

3. **Container Environments**: Docker containers or Kubernetes pods where multiple processes may run with different privilege levels

4. **Exposure Window**: The file exists for several seconds during compilation and execution, providing ample time for monitoring processes to detect and read it

5. **Crash Scenarios**: If the process terminates unexpectedly (OOM, SIGKILL, panic), the cleanup code may not execute, leaving credentials permanently on disk

6. **Backup Systems**: Files may be captured by backup systems, file synchronization tools, or monitoring agents before deletion

## Recommendation

Replace the insecure `tokio::fs::write()` calls with the existing secure pattern from the Aptos codebase. The fix should:

1. Use `tokio::fs::OpenOptions` with `.mode(0o600)` on Unix systems to restrict file permissions to owner-only
2. Apply the same restriction to directory creation
3. Follow the pattern established in `write_to_user_only_file()` 

**Fixed Implementation:**

```rust
pub async fn save_as_profile_file(&self, profile_file_path: &Path) -> anyhow::Result<()> {
    use tokio::fs::OpenOptions;
    #[cfg(unix)]
    use std::os::unix::fs::OpenOptionsExt;
    
    let content = format!(
        "---\nprofiles:\n  default:\n    public_key: {}\n    private_key: {}\n    account: {}\n    rest_url: {REST_URL}\n    faucet_url: {FAUCET_URL}",
        self.public_key, self.private_key, self.account
    );
    
    let account_folder = profile_file_path.join(".aptos");
    
    // Create directory with restrictive permissions
    #[cfg(unix)]
    {
        use std::fs::DirBuilder;
        use std::os::unix::fs::DirBuilderExt;
        let mut builder = DirBuilder::new();
        builder.mode(0o700).recursive(true);
        builder.create(&account_folder).await?;
    }
    #[cfg(not(unix))]
    {
        tokio::fs::create_dir_all(&account_folder).await?;
    }
    
    let config_path = account_folder.join("config.yaml");
    
    // Write file with restrictive permissions
    let mut opts = OpenOptions::new();
    opts.write(true).create(true).truncate(true);
    #[cfg(unix)]
    opts.mode(0o600);
    
    let mut file = opts.open(&config_path).await.context(format!(
        "[Account] Failed to create account profile at path: {:?}",
        config_path
    ))?;
    
    use tokio::io::AsyncWriteExt;
    file.write_all(content.as_bytes()).await.context(format!(
        "[Account] Failed to write account profile to path: {:?}",
        config_path
    ))?;
    
    Ok(())
}
```

## Proof of Concept

```rust
// PoC demonstrating insecure file permissions
use std::path::Path;
use tokio::fs;

#[tokio::test]
async fn test_insecure_file_permissions() {
    // Create a temporary directory for testing
    let temp_dir = std::env::temp_dir().join("aptos_security_test");
    fs::create_dir_all(&temp_dir).await.unwrap();
    
    // Simulate current insecure behavior
    let test_file = temp_dir.join("insecure_key.txt");
    fs::write(&test_file, "private_key_content").await.unwrap();
    
    // Check file permissions on Unix
    #[cfg(unix)]
    {
        use std::os::unix::fs::PermissionsExt;
        let metadata = std::fs::metadata(&test_file).unwrap();
        let permissions = metadata.permissions();
        let mode = permissions.mode();
        
        // Verify file is world-readable (0644 or similar)
        assert!(mode & 0o044 != 0, "File should be world-readable with default permissions");
        println!("Insecure file mode: {:o}", mode & 0o777);
    }
    
    // Create secure file
    #[cfg(unix)]
    {
        use std::os::unix::fs::OpenOptionsExt;
        use tokio::fs::OpenOptions;
        use tokio::io::AsyncWriteExt;
        
        let secure_file = temp_dir.join("secure_key.txt");
        let mut opts = OpenOptions::new();
        opts.write(true).create(true).mode(0o600);
        let mut file = opts.open(&secure_file).await.unwrap();
        file.write_all(b"private_key_content").await.unwrap();
        
        let metadata = std::fs::metadata(&secure_file).unwrap();
        let permissions = metadata.permissions();
        let mode = permissions.mode();
        
        // Verify file is owner-only (0600)
        assert_eq!(mode & 0o777, 0o600, "File should be owner-only");
        println!("Secure file mode: {:o}", mode & 0o777);
    }
    
    // Cleanup
    fs::remove_dir_all(&temp_dir).await.ok();
}
```

## Notes

This vulnerability represents a violation of the principle of least privilege and the secure-by-default security model. While the affected component is a testing tool rather than a core protocol component, it handles real cryptographic credentials that provide complete account control. The Aptos codebase already implements the correct pattern for handling sensitive files, but this pattern was not applied consistently across all credential-handling code paths.

### Citations

**File:** ecosystem/indexer-grpc/indexer-transaction-generator/src/accont_manager.rs (L24-45)
```rust
    pub async fn save_as_profile_file(&self, profile_file_path: &Path) -> anyhow::Result<()> {
        // TODO: refactor this to use serde to write the file.
        let content = format!(
            "---\nprofiles:\n  default:\n    public_key: {}\n    private_key: {}\n    account: {}\n    rest_url: {REST_URL}\n    faucet_url: {FAUCET_URL}",
            self.public_key, self.private_key, self.account
        );
        // create the folder.
        let account_folder = profile_file_path.join(".aptos");
        tokio::fs::create_dir_all(account_folder.clone())
            .await
            .context(format!(
                "[Account] Failed to create account profile folder at path: {:?}",
                profile_file_path
            ))?;
        tokio::fs::write(account_folder.join("config.yaml"), content)
            .await
            .context(format!(
                "[Account] Failed to save account profile to path: {:?}",
                profile_file_path
            ))?;
        Ok(())
    }
```

**File:** ecosystem/indexer-grpc/indexer-transaction-generator/src/script_transaction_generator.rs (L70-73)
```rust
        sender_account
            .save_as_profile_file(&script_path)
            .await
            .context("Failed to save the account profile.")?;
```

**File:** ecosystem/indexer-grpc/indexer-transaction-generator/src/script_transaction_generator.rs (L111-114)
```rust
        sender_account
            .delete_profile_file(&script_path)
            .await
            .context("Failed to delete the account profile.")?;
```

**File:** crates/aptos/src/common/utils.rs (L224-229)
```rust
pub fn write_to_user_only_file(path: &Path, name: &str, bytes: &[u8]) -> CliTypedResult<()> {
    let mut opts = OpenOptions::new();
    #[cfg(unix)]
    opts.mode(0o600);
    write_to_file_with_opts(path, name, bytes, &mut opts)
}
```
