# Audit Report

## Title
Mempool Peer Prioritization Deprioritizes New Peers Below Maximally Distant Peers During Metadata Population Window

## Summary
The `compare_validator_distance()` function in mempool peer prioritization unconditionally prioritizes peers with ANY validator distance metadata over peers without metadata. This causes newly connected peers to be deprioritized below even maximally distant peers (distance=100) for 45-60 seconds while their network information is being populated, enabling transaction propagation manipulation.

## Finding Description

The vulnerability exists in the validator distance comparison logic used for mempool peer prioritization: [1](#0-0) 

The match statement treats ANY distance value (including `MAX_DISTANCE_FROM_VALIDATORS` = 100) as superior to no distance value (None). This creates an exploitable timing window based on peer monitoring metadata population intervals: [2](#0-1) [3](#0-2) 

When a new peer connects, metadata is populated asynchronously:
- **0-15 seconds**: No metadata → considered unhealthy → deprioritized by health check
- **15-60 seconds**: Has `latest_node_info_response` (healthy) but no `latest_network_info_response` (distance=None) → **deprioritized by distance check**

The `get_distance_from_validators()` server function can return `MAX_DISTANCE_FROM_VALIDATORS` (100) for poorly connected peers: [4](#0-3) 

During the 15-60 second window after connection, peer prioritization logic processes as follows: [5](#0-4) 

**Attack Scenario:**
1. Attacker maintains multiple connected peers with `distance_from_validators` = 90-100 (poorly connected, but metadata populated)
2. A new well-connected peer (e.g., VFN with actual distance=1) connects to the target node
3. For 45 seconds, the comparison returns:
   - Old peer: `Some(100)` vs New peer: `None` → `Ordering::Greater` (old peer prioritized)
4. Mempool preferentially broadcasts transactions to the attacker's maximally distant peers instead of the new well-connected peer
5. Attacker can selectively drop/delay transactions during this window

The test suite confirms this behavior is intentional but problematic: [6](#0-5) 

## Impact Explanation

**Medium Severity** per Aptos bug bounty criteria:

**Network Degradation:** Newly connected peers are systematically deprioritized for 45 seconds, degrading transaction propagation efficiency across the network. This directly impacts network performance without requiring validator compromise.

**Temporary Transaction Censorship:** An attacker controlling multiple poorly-connected peers can effectively delay transaction propagation to well-connected new peers during the metadata population window. While time-limited, this enables:
- Selective transaction visibility delays
- Front-running opportunities through controlled propagation
- Network partition simulation by isolating new peers

**Repeated Exploitation:** The vulnerability can be exploited repeatedly by cycling peer connections, creating sustained network degradation.

**Not Critical/High because:**
- Does not violate consensus safety
- Does not cause fund loss or theft
- Does not cause permanent network partition
- Limited to 45-second windows per new peer connection

## Likelihood Explanation

**HIGH likelihood of occurrence:**

1. **Automatic Trigger:** Every new peer connection triggers the vulnerability naturally - no special attacker setup required
2. **Configuration Default:** The 60-second network info interval is the default configuration, affecting all standard deployments
3. **Network Churn:** Normal network operations involve frequent peer connections/disconnections, providing regular exploitation opportunities
4. **Low Attacker Bar:** Attacker only needs to maintain connected peers with high distance values - trivial to achieve by running nodes without good validator connectivity

The vulnerability is triggered in production environments during normal operations, making it a persistent issue rather than a theoretical edge case.

## Recommendation

Modify `compare_validator_distance()` to treat peers without distance metadata as potentially well-connected rather than poorly connected. Prioritize peers without metadata over peers with high distances until metadata is populated:

```rust
fn compare_validator_distance(
    monitoring_metadata_a: &Option<&PeerMonitoringMetadata>,
    monitoring_metadata_b: &Option<&PeerMonitoringMetadata>,
) -> Ordering {
    let validator_distance_a = get_distance_from_validators(monitoring_metadata_a);
    let validator_distance_b = get_distance_from_validators(monitoring_metadata_b);

    // Define a threshold for "far" peers (e.g., distance > 50)
    const FAR_PEER_THRESHOLD: u64 = 50;

    match (validator_distance_a, validator_distance_b) {
        (Some(distance_a), Some(distance_b)) => {
            distance_a.cmp(&distance_b).reverse()
        },
        (Some(distance_a), None) => {
            // If peer A is very far, give new peer (None) the benefit of the doubt
            if distance_a > FAR_PEER_THRESHOLD {
                Ordering::Less  // Prioritize the new peer without metadata
            } else {
                Ordering::Greater  // Prioritize peer with known good distance
            }
        },
        (None, Some(distance_b)) => {
            // Symmetric logic
            if distance_b > FAR_PEER_THRESHOLD {
                Ordering::Greater  // Prioritize the new peer without metadata
            } else {
                Ordering::Less  // Prioritize peer with known good distance
            }
        },
        (None, None) => Ordering::Equal,
    }
}
```

**Alternative approach:** Reduce `network_info_request_interval_ms` to match `node_info_request_interval_ms` (15 seconds) to minimize the vulnerability window, though this increases network overhead.

## Proof of Concept

```rust
#[cfg(test)]
mod vulnerability_test {
    use super::*;
    use aptos_peer_monitoring_service_types::PeerMonitoringMetadata;
    
    #[test]
    fn test_new_peer_deprioritized_below_far_peer() {
        // Create metadata for a peer at maximum distance (worst case)
        let far_peer_metadata = create_metadata_with_distance(Some(100));
        
        // Create metadata for a new peer without distance info yet
        let new_peer_metadata = create_metadata_with_distance(None);
        
        // Compare: Far peer (distance=100) vs New peer (distance=None)
        let ordering = compare_validator_distance(
            &Some(&far_peer_metadata),
            &Some(&new_peer_metadata)
        );
        
        // VULNERABILITY: Far peer is prioritized over new peer
        assert_eq!(ordering, Ordering::Greater);
        
        // This means transactions will be sent to the maximally distant peer
        // BEFORE the new peer, even though the new peer might be at distance 1
        // once its metadata populates in 45 seconds.
        
        // An attacker exploits this by:
        // 1. Maintaining peers with distance=100 
        // 2. When new peers connect, they're deprioritized for 45 seconds
        // 3. Attacker receives transactions first and can censor/delay them
    }
    
    #[test]
    fn test_exploitation_window() {
        // Simulate the timeline of a new peer connection:
        
        // T=0s: Peer connects, no metadata
        let no_metadata: Option<&PeerMonitoringMetadata> = None;
        let far_peer = create_metadata_with_distance(Some(95));
        
        // T=0-15s: No metadata -> considered unhealthy -> deprioritized
        // (health check handles this, not shown here)
        
        // T=15-60s: Has node_info but no network_info
        let partial_metadata = PeerMonitoringMetadata::new(
            None,  // No ping latency yet
            None,
            None,  // No network_info_response (distance missing)
            Some(Default::default()),  // Has node_info_response (healthy)
            None,
        );
        
        // During 15-60s window: New peer is healthy but has no distance
        let ordering = compare_validator_distance(
            &Some(&far_peer),
            &Some(&partial_metadata)
        );
        
        // VULNERABLE: Far peer prioritized during 45-second window
        assert_eq!(ordering, Ordering::Greater);
        
        // T=60s+: Network info populates, peer gets proper priority
        // (but damage is done - 45 seconds of deprioritization)
    }
}
```

**Notes**

This vulnerability represents a design flaw in the peer prioritization fallback logic. While the intent is to prefer peers with known metrics over unknown peers, the implementation fails to account for the semantic difference between "proven to be far" (distance=100) and "not yet measured" (distance=None). The 45-second exploitation window per connection, combined with normal network churn, makes this a persistent issue affecting transaction propagation efficiency and enabling censorship attacks. The fix requires updating the comparison logic to treat unmeasured peers as potentially well-connected rather than assuming they are poorly connected.

### Citations

**File:** mempool/src/shared_mempool/priority.rs (L74-120)
```rust
    fn compare_intelligent(
        &self,
        peer_a: &(PeerNetworkId, Option<&PeerMonitoringMetadata>),
        peer_b: &(PeerNetworkId, Option<&PeerMonitoringMetadata>),
    ) -> Ordering {
        // Deconstruct the peer tuples
        let (peer_network_id_a, monitoring_metadata_a) = peer_a;
        let (peer_network_id_b, monitoring_metadata_b) = peer_b;

        // First, compare the peers by health (e.g., sync lag)
        let unhealthy_ordering = compare_peer_health(
            &self.mempool_config,
            &self.time_service,
            monitoring_metadata_a,
            monitoring_metadata_b,
        );
        if !unhealthy_ordering.is_eq() {
            return unhealthy_ordering; // Only return if it's not equal
        }

        // Next, compare by network ID (i.e., Validator > VFN > Public)
        let network_ordering = compare_network_id(
            &peer_network_id_a.network_id(),
            &peer_network_id_b.network_id(),
        );
        if !network_ordering.is_eq() {
            return network_ordering; // Only return if it's not equal
        }

        // Otherwise, compare by peer distance from the validators.
        // This avoids badly configured/connected peers (e.g., broken VN-VFN connections).
        let distance_ordering =
            compare_validator_distance(monitoring_metadata_a, monitoring_metadata_b);
        if !distance_ordering.is_eq() {
            return distance_ordering; // Only return if it's not equal
        }

        // Otherwise, compare by peer ping latency (the lower the better)
        let latency_ordering = compare_ping_latency(monitoring_metadata_a, monitoring_metadata_b);
        if !latency_ordering.is_eq() {
            return latency_ordering; // Only return if it's not equal
        }

        // Otherwise, simply hash the peer IDs and compare the hashes.
        // In practice, this should be relatively rare.
        self.compare_hash(peer_network_id_a, peer_network_id_b)
    }
```

**File:** mempool/src/shared_mempool/priority.rs (L615-639)
```rust
fn compare_validator_distance(
    monitoring_metadata_a: &Option<&PeerMonitoringMetadata>,
    monitoring_metadata_b: &Option<&PeerMonitoringMetadata>,
) -> Ordering {
    // Get the validator distance from the monitoring metadata
    let validator_distance_a = get_distance_from_validators(monitoring_metadata_a);
    let validator_distance_b = get_distance_from_validators(monitoring_metadata_b);

    // Compare the distances
    match (validator_distance_a, validator_distance_b) {
        (Some(validator_distance_a), Some(validator_distance_b)) => {
            // Prioritize the peer with the lowest validator distance
            validator_distance_a.cmp(&validator_distance_b).reverse()
        },
        (Some(_), None) => {
            Ordering::Greater // Prioritize the peer with a validator distance
        },
        (None, Some(_)) => {
            Ordering::Less // Prioritize the peer with a validator distance
        },
        (None, None) => {
            Ordering::Equal // Neither peer has a validator distance
        },
    }
}
```

**File:** mempool/src/shared_mempool/priority.rs (L1218-1243)
```rust
        // Create a list of peers with the same network ID, but different validator distances
        let peer_metadata_1 = create_metadata_with_distance(Some(1));
        let public_peer_1 = (create_public_peer(), Some(&peer_metadata_1));

        let peer_metadata_2 = create_metadata_with_distance(None);
        let public_peer_2 = (
            create_public_peer(),
            Some(&peer_metadata_2), // No validator distance
        );

        let peer_metadata_3 = create_metadata_with_distance(Some(0));
        let public_peer_3 = (create_public_peer(), Some(&peer_metadata_3));

        let peer_metadata_4 = create_metadata_with_distance(Some(2));
        let public_peer_4 = (create_public_peer(), Some(&peer_metadata_4));

        // Verify that peers on the same network ID are prioritized by validator distance
        let all_peers = vec![public_peer_1, public_peer_2, public_peer_3, public_peer_4];
        let prioritized_peers = prioritized_peers_state.sort_peers_by_priority(&all_peers);
        let expected_peers = vec![
            public_peer_3.0,
            public_peer_1.0,
            public_peer_4.0,
            public_peer_2.0,
        ];
        assert_eq!(prioritized_peers, expected_peers);
```

**File:** config/src/config/peer_monitoring_config.rs (L60-72)
```rust
pub struct NetworkMonitoringConfig {
    pub network_info_request_interval_ms: u64, // The interval (ms) between network info requests
    pub network_info_request_timeout_ms: u64,  // The timeout (ms) for each network info request
}

impl Default for NetworkMonitoringConfig {
    fn default() -> Self {
        Self {
            network_info_request_interval_ms: 60_000, // 1 minute
            network_info_request_timeout_ms: 10_000,  // 10 seconds
        }
    }
}
```

**File:** config/src/config/peer_monitoring_config.rs (L74-88)
```rust
#[derive(Clone, Copy, Debug, Deserialize, PartialEq, Eq, Serialize)]
#[serde(default, deny_unknown_fields)]
pub struct NodeMonitoringConfig {
    pub node_info_request_interval_ms: u64, // The interval (ms) between node info requests
    pub node_info_request_timeout_ms: u64,  // The timeout (ms) for each node info request
}

impl Default for NodeMonitoringConfig {
    fn default() -> Self {
        Self {
            node_info_request_interval_ms: 15_000, // 15 seconds
            node_info_request_timeout_ms: 10_000,  // 10 seconds
        }
    }
}
```

**File:** peer-monitoring-service/server/src/lib.rs (L296-340)
```rust
/// Returns the distance from the validators using the given base config
/// and the peers and metadata information.
fn get_distance_from_validators(
    base_config: &BaseConfig,
    peers_and_metadata: Arc<PeersAndMetadata>,
) -> u64 {
    // Get the connected peers and metadata
    let connected_peers_and_metadata = match peers_and_metadata.get_connected_peers_and_metadata() {
        Ok(connected_peers_and_metadata) => connected_peers_and_metadata,
        Err(error) => {
            warn!(LogSchema::new(LogEntry::PeerMonitoringServiceError).error(&error.into()));
            return MAX_DISTANCE_FROM_VALIDATORS;
        },
    };

    // If we're a validator and we have active validator peers, we're in the validator set.
    // TODO: figure out if we need to deal with validator set forks here.
    if base_config.role.is_validator() {
        for peer_metadata in connected_peers_and_metadata.values() {
            if peer_metadata.get_connection_metadata().role.is_validator() {
                return 0;
            }
        }
    }

    // Otherwise, go through our peers, find the min, and return a distance relative to the min
    let mut min_peer_distance_from_validators = MAX_DISTANCE_FROM_VALIDATORS;
    for peer_metadata in connected_peers_and_metadata.values() {
        if let Some(ref latest_network_info_response) = peer_metadata
            .get_peer_monitoring_metadata()
            .latest_network_info_response
        {
            min_peer_distance_from_validators = min(
                min_peer_distance_from_validators,
                latest_network_info_response.distance_from_validators,
            );
        }
    }

    // We're one hop away from the peer
    min(
        MAX_DISTANCE_FROM_VALIDATORS,
        min_peer_distance_from_validators + 1,
    )
}
```
