# Audit Report

## Title
Indexer Cache Worker Crashes on Unknown StatusType Enum Values During Protocol Upgrades

## Summary
The indexer-grpc-cache-worker will panic and crash when receiving StreamStatus messages containing new StatusType enum variants that were added in protocol upgrades, breaking backward compatibility and causing indexer service outages.

## Finding Description
The `StatusType` enum is defined in the protobuf schema with three variants: `Unspecified=0`, `Init=1`, and `BatchEnd=2`. [1](#0-0) 

The enum values are stored in protobuf messages as `i32` fields, which means the wire format can accept any integer value. [2](#0-1) 

The cache worker processes incoming messages and attempts to convert the `i32` value to the `StatusType` enum using `try_from().expect()`: [3](#0-2) 

This pattern is also used in the initialization path: [4](#0-3) 

When a protocol upgrade adds a new `StatusType` variant (e.g., `StatusType::BatchError = 3`), the prost-generated `TryFrom<i32>` implementation returns an `Err` for the unknown value. The `.expect()` call converts this error into an unrecoverable panic, crashing the entire cache worker process.

The serde implementation demonstrates that `from_i32()` returns `None` for unknown values: [5](#0-4) 

## Impact Explanation
This is a **Low Severity** issue affecting the indexer-grpc infrastructure:

- **Availability Impact**: The cache worker crashes and stops serving indexed transaction data to applications
- **Service Disruption**: During rolling upgrades, older cache workers will crash when newer fullnodes send messages with new enum variants
- **Not Consensus-Critical**: This component is in the `ecosystem/` directory and doesn't affect blockchain consensus, validator operations, or core protocol safety
- **Recovery**: Simple restart or upgrade of the cache worker restores service

Per the Aptos bug bounty program, this falls under **Low Severity**: "Non-critical implementation bugs" affecting auxiliary infrastructure rather than core protocol components.

## Likelihood Explanation
**Likelihood: High** during protocol upgrades that extend the `StatusType` enum.

The issue will occur whenever:
1. A protocol upgrade adds new `StatusType` variants to the protobuf definition
2. Fullnodes are upgraded to the new version and begin sending the new enum values
3. Cache workers running older code versions receive these messages
4. The automatic `.expect()` panic terminates the worker process

This is a **guaranteed crash** scenario during any rolling upgrade that modifies the enum, making it highly likely to occur in practice.

## Recommendation
Replace the `.expect()` pattern with proper error handling that treats unknown enum values as `Unspecified`:

```rust
// In process_transactions_from_node_response (line 191)
match StatusType::try_from(status.r#type).unwrap_or(StatusType::Unspecified) {
    StatusType::Init => Ok(GrpcDataStatus::StreamInit(status.start_version)),
    StatusType::BatchEnd => { /* ... */ },
    StatusType::Unspecified => {
        // Log warning about unknown status type for monitoring
        warn!("[Indexer Cache] Received unknown status type: {}, treating as Unspecified", status.r#type);
        Ok(GrpcDataStatus::StreamInit(status.start_version))
    }
}

// In verify_fullnode_init_signal (line 296)
match StatusType::try_from(status_frame.r#type).unwrap_or(StatusType::Unspecified) {
    StatusType::Init => (init_signal.chain_id, status_frame.start_version),
    _ => {
        bail!("[Indexer Cache] Streaming error: first frame is not INIT signal.");
    }
}
```

This ensures forward compatibility: older cache workers can continue operating when receiving new enum variants by treating them as `Unspecified` and logging the occurrence for monitoring.

## Proof of Concept
```rust
// Simulation of the crash scenario
use aptos_protos::internal::fullnode::v1::stream_status::StatusType;

#[test]
fn test_unknown_status_type_crash() {
    // Simulate receiving a new enum value (3) that doesn't exist in older code
    let unknown_value: i32 = 3;
    
    // This is what the current code does - it will panic
    let result = std::panic::catch_unwind(|| {
        StatusType::try_from(unknown_value).expect("Invalid status type")
    });
    
    assert!(result.is_err(), "Code panics on unknown enum value");
    
    // Recommended approach - handle gracefully
    let handled = StatusType::try_from(unknown_value).unwrap_or(StatusType::Unspecified);
    assert_eq!(handled, StatusType::Unspecified, "Unknown values should map to Unspecified");
}
```

## Notes
This vulnerability specifically affects the indexer-grpc ecosystem components during protocol upgrades. While it causes service disruption, it does not compromise blockchain safety, consensus, or validator operations. The issue represents a forward-compatibility bug that violates the principle of graceful degradation in distributed systems during version transitions.

### Citations

**File:** protos/rust/src/pb/aptos.internal.fullnode.v1.rs (L21-23)
```rust
pub struct StreamStatus {
    #[prost(enumeration="stream_status::StatusType", tag="1")]
    pub r#type: i32,
```

**File:** protos/rust/src/pb/aptos.internal.fullnode.v1.rs (L35-41)
```rust
    pub enum StatusType {
        Unspecified = 0,
        /// Signal for the start of the stream.
        Init = 1,
        /// Signal for the end of the batch.
        BatchEnd = 2,
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-cache-worker/src/worker.rs (L191-207)
```rust
            match StatusType::try_from(status.r#type).expect("[Indexer Cache] Invalid status type.")
            {
                StatusType::Init => Ok(GrpcDataStatus::StreamInit(status.start_version)),
                StatusType::BatchEnd => {
                    let start_version = status.start_version;
                    let num_of_transactions = status
                        .end_version
                        .expect("TransactionsFromNodeResponse status end_version is None")
                        - start_version
                        + 1;
                    Ok(GrpcDataStatus::BatchEnd {
                        start_version,
                        num_of_transactions,
                    })
                },
                StatusType::Unspecified => unreachable!("Unspecified status type."),
            }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-cache-worker/src/worker.rs (L296-299)
```rust
            match StatusType::try_from(status_frame.r#type)
                .expect("[Indexer Cache] Invalid status type.")
            {
                StatusType::Init => (init_signal.chain_id, status_frame.start_version),
```

**File:** protos/rust/src/pb/aptos.internal.fullnode.v1.serde.rs (L449-460)
```rust
            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                use std::convert::TryFrom;
                i32::try_from(v)
                    .ok()
                    .and_then(stream_status::StatusType::from_i32)
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }
```
