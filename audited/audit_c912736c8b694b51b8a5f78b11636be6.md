# Audit Report

## Title
Validator Transaction Reordering Enables Denial-of-Service on JWK Updates via Epoch Transition Manipulation

## Summary
A malicious block leader can reorder DKG and JWK validator transactions within a block proposal to cause legitimate JWK updates to fail verification. When a DKG transaction executes before a JWK transaction in the same block, the DKG triggers an immediate epoch transition that updates the validator set, causing the subsequent JWK transaction to verify against the wrong validator set and be discarded.

## Finding Description

The vulnerability stems from the lack of ordering validation for validator transactions in block proposals, combined with the immediate state changes caused by DKG transactions during epoch transitions.

**Root Cause 1: No Ordering Validation**

The validator transaction pool maintains FIFO ordering [1](#0-0) , but there is no enforcement of this ordering when validators process proposals. The `process_proposal` function verifies each validator transaction individually [2](#0-1)  but performs no checks to ensure transactions appear in the correct order.

**Root Cause 2: Immediate Epoch Transition**

When a DKG transaction executes, it calls `finish_with_dkg_result` [3](#0-2) , which triggers `reconfigure()`. This immediately increments the epoch number [4](#0-3)  and updates the validator set [5](#0-4)  within the same block execution.

**Root Cause 3: Index-Based Multi-Signature Verification**

JWK transactions verify multi-signatures using validator indices from the bitvec [6](#0-5) . These indices are epoch-specific - when the validator set changes during an epoch transition, the same index may map to a different validator with a different public key.

**Attack Flow:**

1. In epoch N, both DKG and JWK consensus complete, adding transactions to the pool
2. A malicious block leader is elected and pulls both transactions from the pool
3. Leader creates a proposal with DKG transaction **before** JWK transaction (reordered)
4. Other validators receive and process the proposal:
   - DKG transaction executes successfully (epoch N check passes) [7](#0-6) 
   - Epoch increments from N to N+1 immediately [4](#0-3) 
   - Validator set updates to epoch N+1 configuration [8](#0-7) 
   - JWK transaction attempts to execute but fetches the **new** epoch N+1 validator set [9](#0-8) 
   - Multi-signature verification fails because the signature was created by epoch N validators but is being verified against epoch N+1 validator public keys [10](#0-9) 
   - JWK transaction is discarded [11](#0-10) 
5. The legitimate, quorum-certified JWK update is not applied to on-chain state

Notably, the JWK transaction has no epoch field or epoch check in its structure [12](#0-11) , making it vulnerable to epoch transition timing issues.

## Impact Explanation

**Severity: High** - Significant Protocol Violation

This vulnerability represents a significant protocol violation with security implications:

1. **Denial of Service on JWK Updates**: JWK updates are critical for keyless account security. If they can be systematically blocked, compromised or rotated-out JWKs cannot be updated, directly impacting the security model of keyless accounts.

2. **Consensus Safety Degradation**: Aptos BFT is designed to tolerate < 1/3 Byzantine validators. However, this attack requires only a **single** Byzantine leader (< 1/3 threshold) to cause legitimate validator transactions to fail, effectively allowing one malicious validator to disrupt critical protocol operations that achieved quorum consensus.

3. **State Inconsistency**: The attack creates a state where quorum-certified updates (JWK changes that validators agreed upon) fail to be applied, creating inconsistency between off-chain consensus and on-chain state.

4. **Deterministic But Manipulable**: While all honest validators will reach the same state for a given block (preserving deterministic execution), the malicious leader can manipulate which state is reached by reordering transactions, violating the expectation that validator transactions should be processed in a deterministic order based on consensus completion time.

## Likelihood Explanation

**Likelihood: Medium to High**

The attack is feasible with moderate frequency:

1. **Opportunity Window**: The attack can only occur when both DKG and JWK transactions are simultaneously in the validator transaction pool, which happens during overlapping consensus processes across different validator transaction types.

2. **Leader Election**: The attacker must be elected as block leader, which occurs with probability 1/N for N validators in a round-robin scheme, or varies based on the specific proposer election mechanism.

3. **No Detection**: There is no mechanism to detect this reordering attack since the reordered block appears valid to all validators - it passes all existing validation checks.

4. **Repeatability**: A sophisticated attacker who controls a validator can wait for the opportunity window and execute the attack whenever they are elected leader during that window.

5. **No Coordination Required**: Unlike attacks requiring >1/3 collusion, this requires only a single malicious validator to be leader, making it significantly more practical.

## Recommendation

**Implement Validator Transaction Ordering Validation**

The protocol should enforce that validator transactions in a block must follow a deterministic ordering. Recommend adding validation in `process_proposal`:

```rust
// In consensus/src/round_manager.rs, add after line 1137:

// Validate validator transaction ordering
if let Some(vtxns) = proposal.validator_txns() {
    ensure!(
        self.validate_vtxn_ordering(vtxns),
        "Validator transactions are not in valid order"
    );
}

// Add method to RoundManager:
fn validate_vtxn_ordering(&self, vtxns: &[ValidatorTransaction]) -> bool {
    // Enforce that DKG transactions must come AFTER JWK transactions
    // to prevent epoch transition from invalidating subsequent JWK verifications
    let mut seen_dkg = false;
    for vtxn in vtxns {
        match vtxn {
            ValidatorTransaction::DKGResult(_) => {
                seen_dkg = true;
            },
            ValidatorTransaction::ObservedJWKUpdate(_) => {
                if seen_dkg {
                    return false; // JWK after DKG is invalid
                }
            }
        }
    }
    true
}
```

**Alternative Solution: Add Epoch Field to JWK Updates**

Add an epoch field to `QuorumCertifiedUpdate` and validate it during JWK transaction processing to ensure the transaction is processed in the correct epoch context.

## Proof of Concept

The following demonstrates the vulnerability at the consensus level:

```rust
// Consensus-level test (pseudo-code showing the attack flow)
#[test]
fn test_validator_txn_reordering_attack() {
    // Setup: Epoch N with validator set V1
    let mut test_env = TestEnvironment::new();
    test_env.initialize_epoch(/* epoch */ 0, /* validators */ &validator_set_1);
    
    // Step 1: DKG and JWK consensus complete in epoch N
    let dkg_txn = ValidatorTransaction::DKGResult(create_dkg_transcript(/* epoch */ 0));
    let jwk_txn = ValidatorTransaction::ObservedJWKUpdate(
        create_jwk_update_with_quorum_cert(/* epoch */ 0, &validator_set_1)
    );
    
    // Step 2: Add both to pool (JWK added first - should execute first in FIFO)
    test_env.vtxn_pool.put(Topic::JWK_CONSENSUS(issuer), Arc::new(jwk_txn.clone()), None);
    test_env.vtxn_pool.put(Topic::DKG, Arc::new(dkg_txn.clone()), None);
    
    // Step 3: Malicious leader reorders - DKG before JWK
    let mut malicious_proposal_txns = vec![dkg_txn, jwk_txn];
    let proposal = test_env.create_proposal(malicious_proposal_txns);
    
    // Step 4: Process proposal
    let result = test_env.execute_proposal(proposal);
    
    // Step 5: Verify attack succeeded
    // - DKG transaction should succeed and increment epoch
    assert_eq!(test_env.current_epoch(), 1);
    
    // - JWK transaction should fail verification and be discarded
    let jwk_state = test_env.get_observed_jwks();
    assert!(!jwk_state.contains_update_from_epoch_0()); // JWK update was not applied!
    
    // Step 6: Demonstrate the JWK update would succeed with correct ordering
    test_env.reset_to_epoch(0);
    let correct_proposal_txns = vec![jwk_txn, dkg_txn]; // Correct FIFO order
    let correct_proposal = test_env.create_proposal(correct_proposal_txns);
    let result = test_env.execute_proposal(correct_proposal);
    
    // Both transactions should succeed
    let jwk_state = test_env.get_observed_jwks();
    assert!(jwk_state.contains_update_from_epoch_0()); // JWK update applied successfully
}
```

## Notes

This vulnerability demonstrates a subtle interaction between validator transaction ordering, epoch transitions, and cryptographic verification. While individual components work correctly in isolation, their composition creates an exploitable attack surface. The fix requires either enforcing transaction ordering at the protocol level or redesigning validator transactions to be epoch-agnostic. The impact is significant because it affects the integrity of critical protocol operations (JWK updates for keyless accounts) and can be executed by a single Byzantine validator without requiring collusion.

### Citations

**File:** crates/validator-transaction-pool/src/lib.rs (L84-94)
```rust
    pub fn pull(
        &self,
        deadline: Instant,
        max_items: u64,
        max_bytes: u64,
        filter: TransactionFilter,
    ) -> Vec<ValidatorTransaction> {
        self.inner
            .lock()
            .pull(deadline, max_items, max_bytes, filter)
    }
```

**File:** consensus/src/round_manager.rs (L1126-1137)
```rust
        if let Some(vtxns) = proposal.validator_txns() {
            for vtxn in vtxns {
                let vtxn_type_name = vtxn.type_name();
                ensure!(
                    is_vtxn_expected(&self.randomness_config, &self.jwk_consensus_config, vtxn),
                    "unexpected validator txn: {:?}",
                    vtxn_type_name
                );
                vtxn.verify(self.epoch_state.verifier.as_ref())
                    .context(format!("{} verify failed", vtxn_type_name))?;
            }
        }
```

**File:** aptos-move/framework/aptos-framework/sources/reconfiguration_with_dkg.move (L65-68)
```text
    fun finish_with_dkg_result(account: &signer, dkg_result: vector<u8>) {
        dkg::finish(dkg_result);
        finish(account);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/reconfiguration.move (L142-142)
```text
        config_ref.epoch = config_ref.epoch + 1;
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1344-1402)
```text
    public(friend) fun on_new_epoch(
    ) acquires AptosCoinCapabilities, PendingTransactionFee, StakePool, TransactionFeeConfig, ValidatorConfig, ValidatorPerformance, ValidatorSet {
        let validator_set = borrow_global_mut<ValidatorSet>(@aptos_framework);
        let config = staking_config::get();
        let validator_perf = borrow_global_mut<ValidatorPerformance>(@aptos_framework);

        // Process pending stake and distribute transaction fees and rewards for each currently active validator.
        vector::for_each_ref(&validator_set.active_validators, |validator| {
            let validator: &ValidatorInfo = validator;
            update_stake_pool(validator_perf, validator.addr, &config);
        });

        // Process pending stake and distribute transaction fees and rewards for each currently pending_inactive validator
        // (requested to leave but not removed yet).
        vector::for_each_ref(&validator_set.pending_inactive, |validator| {
            let validator: &ValidatorInfo = validator;
            update_stake_pool(validator_perf, validator.addr, &config);
        });

        // Activate currently pending_active validators.
        append(&mut validator_set.active_validators, &mut validator_set.pending_active);

        // Officially deactivate all pending_inactive validators. They will now no longer receive rewards.
        validator_set.pending_inactive = vector::empty();

        // Update active validator set so that network address/public key change takes effect.
        // Moreover, recalculate the total voting power, and deactivate the validator whose
        // voting power is less than the minimum required stake.
        let next_epoch_validators = vector::empty();
        let (minimum_stake, _) = staking_config::get_required_stake(&config);
        let vlen = vector::length(&validator_set.active_validators);
        let total_voting_power = 0;
        let i = 0;
        while ({
            spec {
                invariant spec_validators_are_initialized(next_epoch_validators);
                invariant i <= vlen;
            };
            i < vlen
        }) {
            let old_validator_info = vector::borrow_mut(&mut validator_set.active_validators, i);
            let pool_address = old_validator_info.addr;
            let validator_config = borrow_global<ValidatorConfig>(pool_address);
            let stake_pool = borrow_global<StakePool>(pool_address);
            let new_validator_info = generate_validator_info(pool_address, stake_pool, *validator_config);

            // A validator needs at least the min stake required to join the validator set.
            if (new_validator_info.voting_power >= minimum_stake) {
                spec {
                    assume total_voting_power + new_validator_info.voting_power <= MAX_U128;
                };
                total_voting_power = total_voting_power + (new_validator_info.voting_power as u128);
                vector::push_back(&mut next_epoch_validators, new_validator_info);
            };
            i = i + 1;
        };

        validator_set.active_validators = next_epoch_validators;
        validator_set.total_voting_power = total_voting_power;
```

**File:** types/src/validator_verifier.rs (L354-361)
```rust
        for index in multi_signature.get_signers_bitvec().iter_ones() {
            let validator = self
                .validator_infos
                .get(index)
                .ok_or(VerifyError::UnknownAuthor)?;
            authors.push(validator.address);
            pub_keys.push(validator.public_key());
        }
```

**File:** aptos-move/aptos-vm/src/validator_txns/dkg.rs (L99-102)
```rust
        // Check epoch number.
        if dkg_node.metadata.epoch != config_resource.epoch() {
            return Err(Expected(EpochNotCurrent));
        }
```

**File:** aptos-move/aptos-vm/src/validator_txns/jwk.rs (L78-88)
```rust
            Err(Expected(failure)) => {
                // Pretend we are inside Move, and expected failures are like Move aborts.
                debug!("Processing dkg transaction expected failure: {:?}", failure);
                Ok((
                    VMStatus::MoveAbort {
                        location: AbortLocation::Script,
                        code: failure as u64,
                        message: None,
                    },
                    VMOutput::empty_with_status(TransactionStatus::Discard(StatusCode::ABORTED)),
                ))
```

**File:** aptos-move/aptos-vm/src/validator_txns/jwk.rs (L109-120)
```rust
        let validator_set =
            ValidatorSet::fetch_config(resolver).ok_or(Expected(MissingResourceValidatorSet))?;
        let observed_jwks =
            ObservedJWKs::fetch_config(resolver).ok_or(Expected(MissingResourceObservedJWKs))?;

        let mut jwks_by_issuer: HashMap<Issuer, ProviderJWKs> =
            observed_jwks.into_providers_jwks().into();
        let issuer = update.update.issuer.clone();
        let on_chain = jwks_by_issuer
            .entry(issuer.clone())
            .or_insert_with(|| ProviderJWKs::new(issuer));
        let verifier = ValidatorVerifier::from(&validator_set);
```

**File:** aptos-move/aptos-vm/src/validator_txns/jwk.rs (L140-142)
```rust
        verifier
            .verify_multi_signatures(&observed, &multi_sig)
            .map_err(|_| Expected(MultiSigVerificationFailed))?;
```

**File:** types/src/jwks/mod.rs (L1-50)
```rust
// Copyright (c) Aptos Foundation
// Licensed pursuant to the Innovation-Enabling Source Code License, available at https://github.com/aptos-labs/aptos-core/blob/main/LICENSE

use self::{
    jwk::JWK,
    rsa::{INSECURE_TEST_RSA_JWK, RSA_JWK, SECURE_TEST_RSA_JWK},
};
#[cfg(test)]
use crate::move_any;
use crate::{
    aggregate_signature::AggregateSignature, jwks::unsupported::UnsupportedJWK,
    move_utils::as_move_value::AsMoveValue, on_chain_config::OnChainConfig,
};
use anyhow::{bail, ensure, Context};
use aptos_crypto_derive::{BCSCryptoHash, CryptoHasher};
use jwk::JWKMoveStruct;
use move_core_types::{
    ident_str,
    identifier::IdentStr,
    language_storage::TypeTag,
    move_resource::MoveStructType,
    value::{MoveStruct, MoveValue},
};
use once_cell::sync::Lazy;
use serde::{Deserialize, Serialize};
use std::{
    collections::HashMap,
    fmt::{Debug, Formatter},
};

pub mod jwk;
pub mod patch;
pub mod rsa;
pub mod unsupported;

pub type Issuer = Vec<u8>;
/// Type for JWK Key ID.
pub type KID = Vec<u8>;

pub fn secure_test_rsa_jwk() -> RSA_JWK {
    SECURE_TEST_RSA_JWK.clone()
}

pub fn insecure_test_rsa_jwk() -> RSA_JWK {
    INSECURE_TEST_RSA_JWK.clone()
}

pub fn issuer_from_str(s: &str) -> Issuer {
    s.as_bytes().to_vec()
}
```
