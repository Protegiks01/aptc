# Audit Report

## Title
Silent Transaction Loss in Reconfiguration Suffix Block Handling

## Summary
The executor's `execute_and_update_state()` function silently drops all transactions from blocks when `parent_output.has_reconfiguration()` returns true, without error reporting or mempool notification, potentially causing permanent transaction loss if consensus validation fails.

## Finding Description

When the executor processes a block whose parent contains a reconfiguration, it checks the condition at line 218 and if true, calls `reconfig_suffix()` at line 224 to create an empty execution output: [1](#0-0) 

The `reconfig_suffix()` method creates an execution output with empty transaction lists: [2](#0-1) 

The input transactions from the `ExecutableBlock` are destructured at line 198 but never used when the reconfiguration suffix path is taken: [3](#0-2) 

The critical issue occurs in the consensus pipeline's `post_ledger_update` function, which is responsible for notifying mempool about failed transactions. When a block has transactions but produces an empty compute_status (from `reconfig_suffix()`), the logic fails to notify mempool: [4](#0-3) 

**The vulnerability flow:**
1. Consensus layer should enforce empty blocks after reconfiguration via `verify_well_formed()`: [5](#0-4) 

2. However, if this check fails or is bypassed, the executor silently drops transactions
3. The `post_ledger_update` condition `user_txns.len() >= compute_status.len()` evaluates to TRUE
4. Since `compute_status.is_empty()` is also TRUE, no error is logged (line 942)
5. Mempool notification (lines 950-972) is skipped
6. Transactions are permanently lost without recovery mechanism

## Impact Explanation

**Severity: High**

This qualifies as **High Severity** per Aptos bug bounty criteria due to significant protocol violation and potential transaction loss. While not directly causing validator slowdowns or API crashes, the silent loss of user transactions represents a critical failure of the transaction processing guarantee.

The impact includes:
- **Silent Transaction Loss**: User transactions are permanently dropped without notification
- **No Error Reporting**: The system continues operating without logging the issue
- **No Recovery Path**: Transactions are not returned to mempool for retry
- **State Inconsistency**: Users believe transactions were processed when they were actually dropped
- **Protocol Violation**: Breaks the invariant that all valid transactions are either executed or explicitly rejected

## Likelihood Explanation

**Likelihood: Low** 

This vulnerability requires one of the following conditions:
1. **Consensus Validation Bug**: A bug in `verify_well_formed()` allowing non-empty reconfiguration suffix blocks
2. **Byzantine Validator Attack**: Malicious validators bypassing consensus checks (requires >1/3 Byzantine power)
3. **State Corruption**: Database inconsistency causing incorrect `has_reconfiguration()` results

The consensus layer properly implements validation: [6](#0-5) 

And the proposal generator automatically creates empty blocks after reconfiguration: [7](#0-6) 

However, the explicit comment "ignore reconfiguration suffix, even if the block is non-empty" indicates developers anticipated this scenario, suggesting awareness of potential edge cases.

## Recommendation

Implement defense-in-depth by adding explicit validation in the executor:

```rust
let execution_output =
    if parent_block_id != committed_block_id && parent_output.has_reconfiguration() {
        // Verify the block is actually empty as required by consensus rules
        if !transactions.is_empty() {
            return Err(ExecutorError::InternalError {
                error: format!(
                    "Block {} contains {} transactions but parent has reconfiguration. \
                    Reconfiguration suffix blocks must be empty.",
                    block_id,
                    transactions.len()
                ).into(),
            });
        }
        
        info!(
            LogSchema::new(LogEntry::BlockExecutor).block_id(block_id),
            "reconfig_descendant_block_received"
        );
        parent_output.execution_output.reconfig_suffix()
    } else {
        // ... normal execution path
    }
```

Additionally, fix the `post_ledger_update` logic to detect and report this condition:

```rust
if user_txns.len() > 0 && compute_status.is_empty() {
    error!(
        "CRITICAL: Block {} had {} transactions but produced empty compute_status. \
        This indicates a consensus validation failure. Transactions were dropped!",
        block.id(),
        user_txns.len()
    );
    // Could also panic here to prevent silent transaction loss
}
```

## Proof of Concept

This vulnerability cannot be demonstrated with a standard test as it requires bypassing consensus validation. However, the problematic code path can be traced:

**Step 1**: Consensus validation check (should prevent this)
- File: `consensus/consensus-types/src/block.rs` lines 483-488
- Check: Blocks after reconfiguration must be empty

**Step 2**: If validation fails, executor processes block
- File: `execution/executor/src/block_executor/mod.rs` lines 217-224
- Result: Transactions silently dropped via `reconfig_suffix()`

**Step 3**: Post-processing fails to notify mempool
- File: `consensus/src/pipeline/pipeline_builder.rs` lines 936-972  
- Logic flaw: Condition at line 939 combined with line 942 allows silent failure

A test would require mocking a Byzantine validator that bypasses `verify_well_formed()`, which represents a separate vulnerability in the consensus layer.

## Notes

This finding represents a **defense-in-depth failure** rather than a directly exploitable vulnerability by unprivileged attackers. The primary protection (consensus validation) is properly implemented, but the executor lacks secondary validation. If consensus validation ever fails due to a bug or under Byzantine conditions, user transactions would be silently and permanently lost without error reporting or recovery mechanisms.

The severity is rated High because the consequence (transaction loss) is severe, even though the likelihood requires a separate consensus failure to trigger.

### Citations

**File:** execution/executor/src/block_executor/mod.rs (L198-202)
```rust
        let ExecutableBlock {
            block_id,
            transactions,
            auxiliary_info,
        } = block;
```

**File:** execution/executor/src/block_executor/mod.rs (L217-224)
```rust
        let execution_output =
            if parent_block_id != committed_block_id && parent_output.has_reconfiguration() {
                // ignore reconfiguration suffix, even if the block is non-empty
                info!(
                    LogSchema::new(LogEntry::BlockExecutor).block_id(block_id),
                    "reconfig_descendant_block_received"
                );
                parent_output.execution_output.reconfig_suffix()
```

**File:** execution/executor-types/src/execution_output.rs (L113-128)
```rust
    pub fn reconfig_suffix(&self) -> Self {
        Self::new_impl(Inner {
            is_block: false,
            first_version: self.next_version(),
            statuses_for_input_txns: vec![],
            to_commit: TransactionsToKeep::new_empty(),
            to_discard: TransactionsWithOutput::new_empty(),
            to_retry: TransactionsWithOutput::new_empty(),
            result_state: self.result_state.clone(),
            state_reads: ShardedStateCache::new_empty(self.next_version().checked_sub(1)),
            hot_state_updates: HotStateUpdates::new_empty(),
            block_end_info: None,
            next_epoch_state: self.next_epoch_state.clone(),
            subscribable_events: Planned::ready(vec![]),
        })
    }
```

**File:** consensus/src/pipeline/pipeline_builder.rs (L936-972)
```rust
        tracker.start_working();
        let compute_status = compute_result.compute_status_for_input_txns();
        // the length of compute_status is user_txns.len() + num_vtxns + 1 due to having blockmetadata
        if user_txns.len() >= compute_status.len() {
            // reconfiguration suffix blocks don't have any transactions
            // otherwise, this is an error
            if !compute_status.is_empty() {
                error!(
                        "Expected compute_status length and actual compute_status length mismatch! user_txns len: {}, compute_status len: {}, has_reconfiguration: {}",
                        user_txns.len(),
                        compute_status.len(),
                        compute_result.has_reconfiguration(),
                    );
            }
        } else {
            let user_txn_status = &compute_status[compute_status.len() - user_txns.len()..];
            // todo: avoid clone
            let txns: Vec<SignedTransaction> = user_txns
                .iter()
                .map(|txn| {
                    txn.borrow_into_inner()
                        .try_as_signed_user_txn()
                        .expect("must be a user txn")
                })
                .cloned()
                .collect();

            // notify mempool about failed transaction
            if let Err(e) = mempool_notifier
                .notify_failed_txn(&txns, user_txn_status)
                .await
            {
                error!(
                    error = ?e, "Failed to notify mempool of rejected txns",
                );
            }
        }
```

**File:** consensus/consensus-types/src/block.rs (L483-488)
```rust
        if parent.has_reconfiguration() {
            ensure!(
                self.payload().is_none_or(|p| p.is_empty()),
                "Reconfiguration suffix should not carry payload"
            );
        }
```

**File:** consensus/consensus-types/src/proposal_msg.rs (L33-41)
```rust
    pub fn verify_well_formed(&self) -> Result<()> {
        ensure!(
            !self.proposal.is_nil_block(),
            "Proposal {} for a NIL block",
            self.proposal
        );
        self.proposal
            .verify_well_formed()
            .context("Fail to verify ProposalMsg's block")?;
```

**File:** consensus/src/liveness/proposal_generator.rs (L505-515)
```rust
        let (validator_txns, payload, timestamp) = if hqc.certified_block().has_reconfiguration() {
            // Reconfiguration rule - we propose empty blocks with parents' timestamp
            // after reconfiguration until it's committed
            (
                vec![],
                Payload::empty(
                    self.quorum_store_enabled,
                    self.allow_batches_without_pos_in_proposal,
                ),
                hqc.certified_block().timestamp_usecs(),
            )
```
