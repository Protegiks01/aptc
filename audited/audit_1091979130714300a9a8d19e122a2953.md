# Audit Report

## Title
Unexecutable Governance Proposals Due to Excessive OIDC Provider Lists Exceeding Transaction Size Limits

## Summary
The JWK consensus configuration update mechanism can generate Move scripts that exceed the 1 MB governance transaction size limit when the OIDC provider list is sufficiently large (approximately 2,000-5,000 providers depending on string lengths). This results in governance proposals that can be approved through voting but become permanently unexecutable, wasting governance resources and potentially blocking legitimate configuration updates. [1](#0-0) 

## Finding Description

The `generate_jwk_consensus_config_update_proposal` function generates a Move script that includes ALL OIDC providers in a single vector initialization. The script size grows linearly with the number of providers. [2](#0-1) 

Each OIDC provider generates one line of code with the provider name and config URL. The governance transaction size limit is 1 MB: [3](#0-2) 

The size validation occurs during transaction execution: [4](#0-3) 

**Attack Path:**

1. **Proposal Creation**: An entity with sufficient stake creates a governance proposal with a large OIDC provider list (2,000-5,000 providers). The proposal creation only submits the execution hash, not the full script. [5](#0-4) 

2. **Voting & Approval**: The proposal passes governance voting and gets added to approved execution hashes. [6](#0-5) 

3. **Execution Attempt**: When attempting to execute the approved proposal, the transaction containing the full script is rejected because `transaction_size > max_transaction_size_in_bytes_gov` (1 MB).

4. **Result**: The proposal remains in an approved-but-unexecutable state permanently.

**Key Issue**: There is NO validation during proposal creation to verify that the corresponding execution script will be within size limits. Additionally, there are NO incremental update functions for JWKConsensusConfig - every update requires replacing the entire configuration: [7](#0-6) 

This contrasts with the individual provider operations that exist for the deprecated SupportedOIDCProviders system but not for the current JWKConsensusConfig. [8](#0-7) 

## Impact Explanation

This vulnerability qualifies as **Medium Severity** under the Aptos Bug Bounty criteria for the following reasons:

1. **State Inconsistencies Requiring Intervention**: Approved governance proposals that cannot be executed represent a state inconsistency in the governance system.

2. **Governance Resource Waste**: The voting period, stake lockup, and community attention are wasted on proposals that can never execute.

3. **Operational Blocking**: If the OIDC provider list legitimately grows over time, eventually even routine updates will generate scripts exceeding 1 MB, blocking all future JWK consensus configuration changes.

4. **Limited Direct Impact**: This does not directly affect funds, consensus safety, or network liveness. The impact is constrained to the governance process and JWK configuration updates specifically.

## Likelihood Explanation

**Malicious Attack Scenario - LOW likelihood:**
- Requires significant stake to meet `required_proposer_stake` threshold
- Requires proposal to pass governance voting (>50% voting power)
- Validators reviewing the proposal would likely notice and reject a configuration with thousands of providers
- High barrier to execution

**Operational Risk Scenario - MEDIUM likelihood:**
- As OIDC providers are added over time through legitimate governance, the list grows
- Each update generates a script including ALL current providers
- Eventually crosses the 1 MB threshold
- No early warning system exists
- More realistic concern than malicious attack

The likelihood increases over time as the provider list grows organically.

## Recommendation

**Immediate Mitigations:**

1. **Add Pre-Execution Validation**: During proposal creation, validate that the execution script size will not exceed limits:

```rust
pub fn generate_jwk_consensus_config_update_proposal(
    config: &OnChainJWKConsensusConfig,
    is_testnet: bool,
    next_execution_hash: Option<HashValue>,
    is_multi_step: bool,
) -> anyhow::Result<Vec<(String, String)>> {
    // ... existing code ...
    
    let proposal = generate_governance_proposal(/* ... */);
    
    // Validate script size
    let script_size = proposal.len();
    let max_size = 1_000_000; // 1 MB minus overhead
    anyhow::ensure!(
        script_size < max_size,
        "Generated script size ({} bytes) exceeds maximum allowed ({} bytes). Consider reducing OIDC provider count.",
        script_size,
        max_size
    );
    
    result.push(("jwk-consensus-config".to_string(), proposal));
    Ok(result)
}
```

2. **Implement Incremental Updates**: Add functions to JWKConsensusConfig for individual provider operations:

```move
// In jwk_consensus_config.move
public fun upsert_oidc_provider_for_next_epoch(
    framework: &signer,
    name: String,
    config_url: String
) acquires JWKConsensusConfig {
    system_addresses::assert_aptos_framework(framework);
    
    let config = if (config_buffer::does_exist<JWKConsensusConfig>()) {
        config_buffer::extract_v2<JWKConsensusConfig>()
    } else {
        *borrow_global<JWKConsensusConfig>(@aptos_framework)
    };
    
    // Extract providers, modify, and re-pack
    // ... implementation details ...
    
    config_buffer::upsert(config);
}
```

3. **Add Hard Limit on Provider Count**: Enforce a maximum number of OIDC providers (e.g., 1000) in the Move contract:

```move
const MAX_OIDC_PROVIDERS: u64 = 1000;

public fun new_v1(oidc_providers: vector<OIDCProvider>): JWKConsensusConfig {
    assert!(
        vector::length(&oidc_providers) <= MAX_OIDC_PROVIDERS,
        error::invalid_argument(ETOO_MANY_PROVIDERS)
    );
    // ... existing validation ...
}
```

## Proof of Concept

```rust
// Test demonstrating the vulnerability
#[test]
fn test_jwk_config_script_exceeds_size_limit() {
    use aptos_types::on_chain_config::{OnChainJWKConsensusConfig, ConfigV1, OIDCProvider};
    
    // Create a large provider list
    let mut providers = vec![];
    for i in 0..3500 {
        providers.push(OIDCProvider {
            name: format!("https://provider{}.example.com", i),
            config_url: format!(
                "https://provider{}.example.com/.well-known/openid-configuration",
                i
            ),
        });
    }
    
    let config = OnChainJWKConsensusConfig::V1(ConfigV1 {
        oidc_providers: providers,
    });
    
    // Generate the proposal script
    let result = generate_jwk_consensus_config_update_proposal(
        &config,
        false, // not testnet
        None,  // no next execution hash
        false, // not multi-step
    );
    
    assert!(result.is_ok());
    let scripts = result.unwrap();
    let script = &scripts[0].1;
    
    // Check script size
    let script_size = script.len();
    println!("Generated script size: {} bytes", script_size);
    
    // Demonstrate it exceeds 1 MB
    const MAX_GOV_TXN_SIZE: usize = 1_048_576;
    assert!(
        script_size > MAX_GOV_TXN_SIZE,
        "Script size {} should exceed governance limit {}",
        script_size,
        MAX_GOV_TXN_SIZE
    );
    
    // This script would fail execution with EXCEEDED_MAX_TRANSACTION_SIZE
    // even though the proposal could be created and approved
}
```

**Notes:**

The vulnerability exists but has LIMITED EXPLOITABILITY due to governance requirements. The more realistic concern is operational risk rather than malicious attack. The issue violates the "Governance Integrity" invariant that approved proposals should be executable. Mitigation requires both validation during proposal generation and alternative incremental update mechanisms.

### Citations

**File:** aptos-move/aptos-release-builder/src/components/jwk_consensus_config.rs (L20-46)
```rust
    let proposal = generate_governance_proposal(
        &writer,
        is_testnet,
        next_execution_hash,
        is_multi_step,
        &["aptos_framework::jwk_consensus_config", "std::string::utf8"],
        |writer| {
            match config {
                OnChainJWKConsensusConfig::Off => {
                    emitln!(writer, "jwk_consensus_config::set_for_next_epoch({}, jwk_consensus_config::new_off());", signer_arg);
                },
                OnChainJWKConsensusConfig::V1(v1) => {
                    emitln!(writer, "let config = jwk_consensus_config::new_v1(vector[");
                    for p in v1.oidc_providers.iter() {
                        emitln!(writer, "jwk_consensus_config::new_oidc_provider(utf8(b\"{}\"), utf8(b\"{}\")),", p.name, p.config_url);
                    }
                    emitln!(writer, "]);");
                    emitln!(
                        writer,
                        "jwk_consensus_config::set_for_next_epoch({}, config);",
                        signer_arg
                    );
                },
            }
            emitln!(writer, "aptos_governance::reconfigure({});", signer_arg);
        },
    );
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L78-81)
```rust
            max_transaction_size_in_bytes_gov: NumBytes,
            { RELEASE_V1_13.. => "max_transaction_size_in_bytes.gov" },
            1024 * 1024
        ],
```

**File:** aptos-move/aptos-vm/src/gas.rs (L83-108)
```rust
    if is_approved_gov_script {
        let max_txn_size_gov = if gas_feature_version >= RELEASE_V1_13 {
            gas_params.vm.txn.max_transaction_size_in_bytes_gov
        } else {
            MAXIMUM_APPROVED_TRANSACTION_SIZE_LEGACY.into()
        };

        if txn_metadata.transaction_size > max_txn_size_gov
            // Ensure that it is only the approved payload that exceeds the
            // maximum. The (unknown) user input should be restricted to the original
            // maximum transaction size.
            || txn_metadata.transaction_size
                > txn_metadata.script_size + txn_gas_params.max_transaction_size_in_bytes
        {
            speculative_warn!(
                log_context,
                format!(
                    "[VM] Governance transaction size too big {} payload size {}",
                    txn_metadata.transaction_size, txn_metadata.script_size,
                ),
            );
            return Err(VMStatus::error(
                StatusCode::EXCEEDED_MAX_TRANSACTION_SIZE,
                None,
            ));
        }
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L405-412)
```text
    public fun create_proposal_v2_impl(
        proposer: &signer,
        stake_pool: address,
        execution_hash: vector<u8>,
        metadata_location: vector<u8>,
        metadata_hash: vector<u8>,
        is_multi_step_proposal: bool,
    ): u64 acquires GovernanceConfig, GovernanceEvents {
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L613-630)
```text
    public fun add_approved_script_hash(proposal_id: u64) acquires ApprovedExecutionHashes {
        let approved_hashes = borrow_global_mut<ApprovedExecutionHashes>(@aptos_framework);

        // Ensure the proposal can be resolved.
        let proposal_state = voting::get_proposal_state<GovernanceProposal>(@aptos_framework, proposal_id);
        assert!(proposal_state == PROPOSAL_STATE_SUCCEEDED, error::invalid_argument(EPROPOSAL_NOT_RESOLVABLE_YET));

        let execution_hash = voting::get_execution_hash<GovernanceProposal>(@aptos_framework, proposal_id);

        // If this is a multi-step proposal, the proposal id will already exist in the ApprovedExecutionHashes map.
        // We will update execution hash in ApprovedExecutionHashes to be the next_execution_hash.
        if (simple_map::contains_key(&approved_hashes.hashes, &proposal_id)) {
            let current_execution_hash = simple_map::borrow_mut(&mut approved_hashes.hashes, &proposal_id);
            *current_execution_hash = execution_hash;
        } else {
            simple_map::add(&mut approved_hashes.hashes, proposal_id, execution_hash);
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/jwk_consensus_config.move (L62-65)
```text
    public fun set_for_next_epoch(framework: &signer, config: JWKConsensusConfig) {
        system_addresses::assert_aptos_framework(framework);
        config_buffer::upsert(config);
    }
```

**File:** aptos-move/aptos-release-builder/src/components/oidc_providers.rs (L21-48)
```rust
pub fn generate_oidc_provider_ops_proposal(
    ops: &[OidcProviderOp],
    is_testnet: bool,
    next_execution_hash: Option<HashValue>,
    is_multi_step: bool,
) -> anyhow::Result<Vec<(String, String)>> {
    let signer_arg = get_signer_arg(is_testnet, &next_execution_hash);
    let mut result = vec![];

    let writer = CodeWriter::new(Loc::default());

    let proposal = generate_governance_proposal(
        &writer,
        is_testnet,
        next_execution_hash,
        is_multi_step,
        &["aptos_framework::jwks"],
        |writer| {
            for op in ops {
                write_op(writer, signer_arg, op);
            }
            emitln!(writer, "aptos_governance::reconfigure({});", signer_arg);
        },
    );

    result.push(("oidc-provider-ops".to_string(), proposal));
    Ok(result)
}
```
