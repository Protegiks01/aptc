# Audit Report

## Title
Named Address Validation Bypass Allows Test-Compiled Modules to Evade Poison Check Protection

## Summary
The `check_has_unit_test_module` function validates the presence of the UnitTest module only by checking the named address string "std" rather than its resolved numerical value (0x1). This allows attackers to define `std` as any arbitrary address in their Move.toml configuration, provide a fake `unit_test` module at that address, and bypass the test-mode poison check designed to prevent test-compiled modules from executing on production networks.

## Finding Description

The Move compiler implements a "test poison" mechanism to prevent modules compiled in test mode from being deployed to production blockchains. When compiling with the `--test` flag, the compiler injects a function that calls `std::unit_test::create_signers_for_testing`, a native function that only exists in test-enabled VMs. On production VMs, this native function is absent, causing module linking to fail. [1](#0-0) 

The validation function `check_has_unit_test_module` checks for the presence of a module named "unit_test" at address "std": [2](#0-1) 

The critical vulnerability is at lines 125-133: the function only validates that the address **name** is the string "std", not that this named address resolves to the canonical value `0x1` (CORE_CODE_ADDRESS). The poison function generation similarly uses only the address name: [3](#0-2) 

Named addresses are resolved from user-provided configurations stored as mappings: [4](#0-3) 

**Attack Path:**

1. Attacker creates a malicious `Move.toml` defining: `std = "0xAttacker"` (where 0xAttacker is the attacker's controlled address)
2. Attacker creates a fake module: `module std::unit_test { public fun create_signers_for_testing(num: u64): vector<signer> { vector::empty() } }`
3. Attacker compiles their module in test mode with `--test` flag
4. The `check_has_unit_test_module` validation passes because a module named "unit_test" exists at address name "std" âœ“
5. The poison function is injected calling `std::unit_test::create_signers_for_testing(0)`, which resolves to `0xAttacker::unit_test::create_signers_for_testing(0)` in bytecode
6. Attacker publishes both their main module AND the fake unit_test module to address `0xAttacker`
7. On production blockchain, the module links successfully because both modules exist at the attacker's address
8. Test-compiled module executes on production, bypassing all intended protections

## Impact Explanation

This is a **HIGH severity** vulnerability per Aptos bug bounty criteria as it constitutes a "Significant protocol violation." The test poison mechanism is a critical security boundary designed to enforce separation between test and production environments.

**Security Guarantees Broken:**
- **Move VM Safety invariant**: Test-compiled code may contain unsafe operations, debugging hooks, or relaxed gas accounting that should never execute on production
- **Deterministic Execution invariant**: Test-compiled modules may behave differently than production-compiled modules, potentially causing consensus splits if validators process them differently
- **Access Control invariant**: Test frameworks often provide privileged capabilities (e.g., arbitrary signer creation) that must not be available in production

**Concrete Harms:**
- Attackers can deploy modules compiled with test-mode features to production networks
- Test-only code paths with reduced safety checks become executable in production
- Potential for introducing non-deterministic behavior if test and production code diverge
- Undermines the security model that assumes test-compiled code never reaches production

## Likelihood Explanation

**Likelihood: HIGH**

This vulnerability is highly likely to be exploited because:

1. **Trivial to execute**: Requires only modifying Move.toml configuration file
2. **No special privileges needed**: Any user can compile Move modules with custom configurations
3. **Clear attacker motivation**: Enables deployment of privileged test code or bypassing safety checks
4. **Difficult to detect**: The malicious configuration looks legitimate and validators cannot easily distinguish test-compiled bytecode
5. **No runtime protections**: Once the modules are published, they function normally on-chain

The only barrier is that attackers must deploy their fake `unit_test` module alongside their main module, which is easily accomplished.

## Recommendation

Add explicit validation that the "std" named address resolves to the canonical value `0x1` (CORE_CODE_ADDRESS). Modify the `check_has_unit_test_module` function:

```rust
fn check_has_unit_test_module(compilation_env: &mut CompilationEnv, prog: &P::Program) -> bool {
    let has_unit_test_module = prog
        .lib_definitions
        .iter()
        .chain(prog.source_definitions.iter())
        .any(|pkg| match &pkg.def {
            P::Definition::Module(mdef) => {
                mdef.name.0.value.as_str() == UNIT_TEST_MODULE_NAME
                    && mdef.address.is_some()
                    && match &mdef.address.as_ref().unwrap().value {
                        P::LeadingNameAccess_::Name(name) => {
                            // Check the name matches "std"
                            if name.value.as_str() != STDLIB_ADDRESS_NAME {
                                return false;
                            }
                            // NEW: Validate that "std" resolves to 0x1
                            if let Some(addr_map) = compilation_env.current_named_address_map() {
                                if let Some(resolved_addr) = addr_map.get(&name.value) {
                                    return resolved_addr.into_inner() == AccountAddress::ONE;
                                }
                            }
                            false
                        },
                        P::LeadingNameAccess_::AnonymousAddress(addr) => {
                            // Also accept anonymous 0x1
                            addr == &NumericalAddress::new(AccountAddress::ONE.into_bytes(), NumberFormat::Hex)
                        },
                    }
            },
            _ => false,
        });

    // ... rest of function unchanged
}
```

This ensures the poison check only accepts the legitimate stdlib at address 0x1, preventing named address manipulation attacks.

## Proof of Concept

**Step 1: Create malicious Move.toml**
```toml
[package]
name = "TestBypass"
version = "1.0.0"

[addresses]
std = "0x42"  # Attacker's address instead of 0x1
```

**Step 2: Create fake unit_test module (fake_stdlib/sources/unit_test.move)**
```move
module std::unit_test {
    use std::vector;
    
    // Fake non-native implementation
    public fun create_signers_for_testing(_num: u64): vector<signer> {
        vector::empty<signer>()
    }
}
```

**Step 3: Create attacker's module (sources/attack.move)**
```move
module std::attack {
    // This module is compiled in test mode but will work in production
    #[test_only]
    use std::signer;
    
    public fun exploit() {
        // Test-only code that should never run in production
        // but will successfully deploy and execute
    }
}
```

**Step 4: Compile with test flag**
```bash
move compile --test
```

**Expected Result**: Compilation succeeds with poison function injected, but the poison references `0x42::unit_test::create_signers_for_testing` instead of `0x1::unit_test::create_signers_for_testing`.

**Step 5: Publish to production**
```bash
aptos move publish --named-addresses std=0x42
```

**Actual Result**: Both modules publish successfully to address 0x42 on production blockchain, bypassing the test-mode protection entirely.

**Notes**

The vulnerability exists because the compiler treats named addresses as opaque identifiers during validation, deferring resolution to later compilation stages. The `NamedAddressMap` structure allows arbitrary mappings without enforcing that critical system addresses like "std" maintain their canonical values. [5](#0-4) 

On production VMs, the legitimate `unit_test` native module is excluded via feature flags, but this protection is circumvented when attackers provide their own non-native implementation at a different address.

### Citations

**File:** third_party/move/move-compiler-v2/legacy-move-compiler/src/unit_test/filter_test_members.rs (L118-136)
```rust
fn check_has_unit_test_module(compilation_env: &mut CompilationEnv, prog: &P::Program) -> bool {
    let has_unit_test_module = prog
        .lib_definitions
        .iter()
        .chain(prog.source_definitions.iter())
        .any(|pkg| match &pkg.def {
            P::Definition::Module(mdef) => {
                mdef.name.0.value.as_str() == UNIT_TEST_MODULE_NAME
                    && mdef.address.is_some()
                    && match &mdef.address.as_ref().unwrap().value {
                        // TODO: remove once named addresses have landed in the stdlib
                        P::LeadingNameAccess_::Name(name) => {
                            name.value.as_str() == STDLIB_ADDRESS_NAME
                        },
                        P::LeadingNameAccess_::AnonymousAddress(_) => false,
                    }
            },
            _ => false,
        });
```

**File:** third_party/move/move-compiler-v2/legacy-move-compiler/src/unit_test/filter_test_members.rs (L165-169)
```rust
/// If a module is being compiled in test mode, create a dummy function that calls a native
/// function `0x1::UnitTest::create_signers_for_testing` that only exists if the VM is being run
/// with the "unit_test" feature flag set. This will then cause the module to fail to link if
/// an attempt is made to publish a module that has been compiled in test mode on a VM that is not
/// running in test mode.
```

**File:** third_party/move/move-compiler-v2/legacy-move-compiler/src/unit_test/filter_test_members.rs (L177-183)
```rust
    let leading_name_access = sp(
        mloc,
        P::LeadingNameAccess_::Name(sp(mloc, STDLIB_ADDRESS_NAME.into())),
    );

    let mod_name = sp(mloc, UNIT_TEST_MODULE_NAME.into());
    let mod_addr_name = sp(mloc, (leading_name_access, mod_name));
```

**File:** third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/mod.rs (L131-131)
```rust
pub type NamedAddressMap = BTreeMap<Symbol, NumericalAddress>;
```

**File:** aptos-move/framework/move-stdlib/src/natives/mod.rs (L47-50)
```rust
        #[cfg(feature = "testing")]
        {
            add_natives!("unit_test", unit_test::make_all(builder));
        }
```
