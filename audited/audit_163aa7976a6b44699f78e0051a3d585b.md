# Audit Report

## Title
Type Safety Violation in GenericWeighting PVSS Wrapper Enables Semantic Security Breaks with Inappropriate Transcript Types

## Summary
The `GenericWeighting<T>` wrapper can be instantiated with transcript types that reuse encryption randomness (such as `das::Transcript`), which breaks ElGamal semantic security by encrypting multiple shares under the same key with the same randomness. While the production DKG correctly uses `das::WeightedTranscript`, the public API lacks type-level constraints to prevent unsafe instantiations.

## Finding Description

The `GenericWeighting<T>` struct implements a generic transformation from unweighted to weighted PVSS by duplicating encryption keys proportional to player weights. [1](#0-0) 

The core mechanism duplicates encryption keys: [2](#0-1) 

When instantiated with `das::Transcript`, which uses a single randomness value `r` for all ciphertexts: [3](#0-2) 

A player with weight `w` receives `w` ciphertexts encrypted under **the same encryption key with the same randomness**: `C[i] = h^{f(ω^i)} * ek^r`. This violates IND-CPA security of ElGamal encryption.

**Required Properties for Security:**
The transcript type `T` must satisfy:
1. **Independent Randomness**: Each ciphertext must use fresh, independent randomness
2. **No Randomness Optimization**: The dealing algorithm must not reuse randomness across encryptions
3. **Semantic Security Preservation**: Key reuse must not break semantic security when combined with the weighting transformation

**Unsafe Instantiations:**
- `GenericWeighting<das::Transcript>` - explicitly marked unsafe in tests [4](#0-3) 

**Safe Instantiations:**
The production DKG uses `das::WeightedTranscript` which generates independent randomness for each share: [5](#0-4) 

## Impact Explanation

**Potential Impact if Deployed:** Critical Severity

If `GenericWeighting<das::Transcript>` were deployed in the DKG:
- Complete loss of semantic security for PVSS dealings
- Ciphertext ratios leak share relationships: `C[i]/C[j] = h^{f(ω^i) - f(ω^j)}`
- Partial information leakage could enable full secret reconstruction
- Violates fundamental threshold cryptography security properties

**Actual Impact:** Low Severity (API Design Issue)

The production DKG correctly uses `das::WeightedTranscript` as confirmed here: [6](#0-5) 

However, `GenericWeighting` remains publicly exported: [7](#0-6) 

This creates an API surface where developers could mistakenly instantiate unsafe configurations.

## Likelihood Explanation

**Current System:** Very Low
- Production code uses the correct secure implementation
- Test files contain explicit warnings against unsafe usage
- No evidence of unsafe instantiation in production paths

**Future Risk:** Medium
- Public API lacks type-level safety constraints
- Only runtime warnings (comments) prevent misuse
- Developers unfamiliar with the codebase could make mistakes
- Type system permits compilation of unsafe instantiations

## Recommendation

**Option 1: Add Type-Level Constraints (Preferred)**
```rust
// Add a marker trait for PVSS schemes safe for generic weighting
pub trait SafeForGenericWeighting: Transcript {}

// Only implement for safe transcript types
impl SafeForGenericWeighting for chunky::Transcript { }

// Constrain GenericWeighting to only accept safe types
impl<T: SafeForGenericWeighting> Transcript for GenericWeighting<T> { ... }
```

**Option 2: Remove Public Export**
If `GenericWeighting` is only intended for testing/benchmarking, make it `pub(crate)` or feature-gate it behind `#[cfg(test)]`.

**Option 3: Deprecate and Document**
Add `#[deprecated]` annotations with clear warnings about security requirements for transcript types.

## Proof of Concept

The vulnerability is demonstrated in existing test code showing the semantic security break: [8](#0-7) 

A concrete attack demonstration would involve:
1. Instantiate `GenericWeighting<das::Transcript>` with weighted configuration
2. Deal shares to a player with weight ≥ 2
3. Observe multiple ciphertexts encrypted under same key with same randomness
4. Compute ciphertext ratios to extract share relationships
5. Use relationships to break confidentiality if any share value leaks

---

**Final Assessment:** While the theoretical vulnerability is valid and the API design is problematic, the **current production deployment is secure** because it uses `das::WeightedTranscript` rather than `GenericWeighting<das::Transcript>`. This represents a **code quality and API safety issue** rather than an immediately exploitable vulnerability. The lack of type-level enforcement creates future risk that should be addressed through stronger type constraints or API restrictions.

### Citations

**File:** crates/aptos-dkg/src/pvss/weighted/generic_weighting.rs (L6-7)
```rust
/// WARNING: This will **NOT** necessarily be secure for any PVSS scheme, since it will reuse encryption
/// keys, which might not be safe depending on the PVSS scheme.
```

**File:** crates/aptos-dkg/src/pvss/weighted/generic_weighting.rs (L49-66)
```rust
    fn to_weighted_encryption_keys(
        sc: &WeightedConfigBlstrs,
        eks: &[T::EncryptPubKey],
    ) -> Vec<T::EncryptPubKey> {
        // Re-organize the encryption key vector so that we deal multiple shares to each player,
        // proportional to their weight.
        let mut duplicated_eks = Vec::with_capacity(sc.get_total_weight());

        for (player_id, ek) in eks.iter().enumerate() {
            let player = sc.get_player(player_id);
            let num_shares = sc.get_player_weight(&player);
            for _ in 0..num_shares {
                duplicated_eks.push(ek.clone());
            }
        }

        duplicated_eks
    }
```

**File:** crates/aptos-dkg/src/pvss/das/unweighted_protocol.rs (L120-138)
```rust
        // Pick ElGamal randomness
        let r = random_scalar(&mut rng);
        let g_1 = pp.get_encryption_public_params().pubkey_base();
        let g_2 = pp.get_commitment_base();
        let h_1 = *pp.get_encryption_public_params().message_base();

        let V = (0..sc.n)
            .map(|i| g_2.mul(f_evals[i]))
            .chain([g_2.mul(f[0])])
            .collect::<Vec<G2Projective>>();

        let C = (0..sc.n)
            .map(|i| {
                g1_multi_exp(
                    [h_1, Into::<G1Projective>::into(&eks[i])].as_slice(),
                    [f_evals[i], r].as_slice(),
                )
            })
            .collect::<Vec<G1Projective>>();
```

**File:** crates/aptos-dkg/tests/pvss.rs (L74-80)
```rust
        // Generically-weighted Das
        // WARNING: Insecure, due to encrypting different shares with the same randomness, do not use!
        // TODO: Remove?
        pvss_deal_verify_and_reconstruct::<GenericWeighting<das::Transcript>>(
            &wc,
            seed.to_bytes_le(),
        );
```

**File:** crates/aptos-dkg/src/pvss/das/weighted_protocol.rs (L134-136)
```rust
        // Pick ElGamal randomness r_j, \forall j \in [W]
        // r[j] = r_{j+1}, \forall j \in [0, W-1]
        let r = random_scalars(W, &mut rng);
```

**File:** types/src/dkg/real_dkg/mod.rs (L38-38)
```rust
pub type WTrx = pvss::das::WeightedTranscript;
```

**File:** crates/aptos-dkg/src/pvss/mod.rs (L27-27)
```rust
pub use weighted::{GenericWeighting, WeightedConfigBlstrs};
```
