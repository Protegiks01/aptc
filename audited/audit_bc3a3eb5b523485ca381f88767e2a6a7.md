# Audit Report

## Title
Unauthorized Non-Validator Peers Can Act as Consensus Publishers and Inject Malicious Message Flows to Observers

## Summary
Non-validator peers can enable publisher mode and accept subscription requests from consensus observers without any authorization check. While cryptographic signatures on message content are validated, unauthorized publishers can selectively relay, delay, or withhold valid consensus messages, causing observers to maintain an incorrect view of consensus state.

## Finding Description

The consensus observer system allows nodes to receive consensus updates without participating in consensus directly. However, there is a critical authorization gap in the subscription establishment flow:

**Vulnerability 1: Publisher Side - No Subscriber Authorization**

When a peer sends a `Subscribe` request, the consensus publisher accepts it unconditionally without verifying if the subscriber is authorized: [1](#0-0) 

Any peer can send a subscribe request and be added to `active_subscribers`, receiving all consensus messages published by that node.

**Vulnerability 2: Observer Side - No Publisher Authorization**

When an observer creates subscriptions, it selects peers based on protocol support and network metrics, but never validates that the peer is actually a validator or authorized to publish consensus information: [2](#0-1) 

The subscription creation only verifies that the peer responds with `SubscribeAck`, but doesn't check if the peer is in the validator set.

**Attack Scenario:**

1. Attacker runs a malicious node (not a validator)
2. Attacker sets `publisher_enabled = true` in their configuration: [3](#0-2) 

3. Attacker's node advertises support for ConsensusObserver protocols
4. When an honest observer node connects and subscribes, the malicious publisher accepts the subscription
5. The message verification only checks if messages come from active subscriptions: [4](#0-3) 

6. The verification in subscription_manager only checks the peer is in the active subscriptions map: [5](#0-4) 

**Root Cause:**

The system assumes that any peer with `publisher_enabled=true` is trustworthy. The configuration shows publishers should only be validators and VFNs: [6](#0-5) 

However, this is merely a configuration default - any node operator can enable publisher mode. There is no runtime enforcement that publishers must be in the validator set.

**Exploitation Impact:**

While the attacker cannot forge cryptographic signatures (which are validated against the epoch state), they can:
- **Selectively relay messages**: Withhold certain blocks or commit decisions
- **Delay messages**: Send valid but stale information
- **Cause state divergence**: Observers subscribed to malicious publishers may have incomplete views of consensus
- **Prevent consensus progress**: Observers may fail to advance if critical messages are withheld

Network metadata includes peer roles that could be checked: [7](#0-6) 

But the consensus observer system never validates `connection_metadata.role` when establishing subscriptions.

## Impact Explanation

**Critical Severity** - This vulnerability meets the Aptos bug bounty Critical severity criteria:

1. **Consensus/Safety violations**: Observers may report incorrect consensus state if they only receive partial information from malicious publishers
2. **State inconsistencies**: Observers may diverge from actual consensus, leading to incorrect state synchronization
3. **Protocol violation**: Breaks the invariant that only validators should publish authoritative consensus information

The impact is amplified because:
- Observers are intended to be lightweight clients that trust the consensus messages they receive
- While observers typically subscribe to multiple peers (default 2), even one malicious subscription can cause confusion
- The attack requires no validator credentials or insider access
- The attack is undetectable without detailed message flow analysis

## Likelihood Explanation

**High Likelihood**:

1. **Low attack complexity**: Attacker only needs to run a node with `publisher_enabled=true`
2. **No special credentials required**: Any network participant can attempt this attack
3. **Easy to execute**: Simple configuration change enables publisher mode
4. **Widespread exposure**: Any observer node is vulnerable when connecting to untrusted peers
5. **Difficult to detect**: Malicious behavior (selective message relay) is hard to distinguish from network latency

## Recommendation

Implement authorization checks at both the publisher and observer sides:

**Fix 1: Publisher-side authorization**

In `consensus_publisher.rs`, validate that subscribers are from trusted networks before accepting subscriptions:

```rust
ConsensusObserverRequest::Subscribe => {
    // Get peer metadata and verify the peer is from an authorized network
    let peers_and_metadata = self.consensus_observer_client.get_peers_and_metadata();
    let peer_metadata = peers_and_metadata
        .get_metadata_for_peer(peer_network_id)
        .ok_or_else(|| Error::UnexpectedError("Peer metadata not found".to_string()))?;
    
    // Only accept subscriptions from known peer roles (not arbitrary public peers)
    let connection_metadata = peer_metadata.get_connection_metadata();
    if !connection_metadata.role.is_validator() && !connection_metadata.role.is_vfn() {
        warn!("Rejecting subscription from unauthorized peer role: {:?}", connection_metadata.role);
        response_sender.send(ConsensusObserverResponse::UnsubscribeAck);
        return;
    }
    
    // Add the peer to the set of active subscribers
    self.add_active_subscriber(peer_network_id);
    // ... rest of the logic
}
```

**Fix 2: Observer-side authorization**

In `subscription_utils.rs`, filter peers to only include validators/VFNs:

```rust
fn sort_peers_for_subscriptions(
    mut connected_peers_and_metadata: HashMap<PeerNetworkId, PeerMetadata>,
    // ... other params
) -> Option<Vec<PeerNetworkId>> {
    // Filter to only include validators and VFNs
    connected_peers_and_metadata.retain(|peer_network_id, peer_metadata| {
        let connection_metadata = peer_metadata.get_connection_metadata();
        connection_metadata.role.is_validator() || connection_metadata.role.is_vfn()
    });
    
    // ... rest of the logic
}
```

**Fix 3: Runtime configuration enforcement**

In the node configuration, enforce that public fullnodes cannot enable publisher mode:

```rust
impl ConfigOptimizer for ConsensusObserverConfig {
    fn optimize(/* params */) -> Result<bool, Error> {
        match node_type {
            NodeType::PublicFullnode => {
                // Explicitly prevent public nodes from being publishers
                if consensus_observer_config.publisher_enabled {
                    return Err(Error::ConfigError(
                        "Public fullnodes cannot act as consensus publishers".to_string()
                    ));
                }
            },
            // ... rest of the logic
        }
    }
}
```

## Proof of Concept

**Setup:**
1. Run a malicious node with `publisher_enabled = true` (not a validator)
2. Connect to an honest observer node
3. Accept the observer's subscription request
4. Selectively withhold `CommitDecision` messages

**Expected Result:**
The observer accepts the subscription and processes messages from the malicious publisher, even though it's not a validator. The observer's consensus state becomes stale or incorrect due to missing commit decisions.

**Verification Steps:**
```rust
// In subscription_utils.rs, add logging to verify peer role:
info!("Attempting to subscribe to peer: {:?}, role: {:?}", 
      potential_peer, 
      peer_metadata.get_connection_metadata().role);

// In consensus_publisher.rs, add logging:
info!("Accepting subscription from peer: {:?}, role: {:?}",
      peer_network_id,
      self.consensus_observer_client
          .get_peers_and_metadata()
          .get_metadata_for_peer(peer_network_id)
          .map(|m| m.get_connection_metadata().role));
```

This will demonstrate that non-validator peers are accepted as both publishers and subscription targets without any role validation.

**Notes**

The vulnerability stems from the implicit trust assumption that only validators/VFNs would enable publisher mode. However, there is no cryptographic or protocol-level enforcement of this assumption. The peer role information is available in the connection metadata but is never checked during subscription establishment.

This is particularly dangerous because:
1. The consensus observer system is designed for lightweight clients that trust the consensus information they receive
2. Signature validation on message content prevents forgery but not selective relay attacks
3. Multi-peer subscriptions mitigate but don't eliminate the risk
4. The attack is entirely network-level and requires no consensus protocol participation

### Citations

**File:** consensus/src/consensus_observer/publisher/consensus_publisher.rs (L181-192)
```rust
            ConsensusObserverRequest::Subscribe => {
                // Add the peer to the set of active subscribers
                self.add_active_subscriber(peer_network_id);
                info!(LogSchema::new(LogEntry::ConsensusPublisher)
                    .event(LogEvent::Subscription)
                    .message(&format!(
                        "New peer subscribed to consensus updates! Peer: {:?}",
                        peer_network_id
                    )));

                // Send a simple subscription ACK
                response_sender.send(ConsensusObserverResponse::SubscribeAck);
```

**File:** consensus/src/consensus_observer/observer/subscription_utils.rs (L116-162)
```rust
async fn create_single_subscription(
    consensus_observer_config: ConsensusObserverConfig,
    consensus_observer_client: Arc<
        ConsensusObserverClient<NetworkClient<ConsensusObserverMessage>>,
    >,
    db_reader: Arc<dyn DbReader>,
    sorted_potential_peers: Vec<PeerNetworkId>,
    time_service: TimeService,
) -> (Option<ConsensusObserverSubscription>, Vec<PeerNetworkId>) {
    let mut peers_with_failed_attempts = vec![];
    for potential_peer in sorted_potential_peers {
        // Log the subscription attempt
        info!(
            LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                "Attempting to subscribe to potential peer: {}!",
                potential_peer
            ))
        );

        // Send a subscription request to the peer and wait for the response
        let subscription_request = ConsensusObserverRequest::Subscribe;
        let request_timeout_ms = consensus_observer_config.network_request_timeout_ms;
        let response = consensus_observer_client
            .send_rpc_request_to_peer(&potential_peer, subscription_request, request_timeout_ms)
            .await;

        // Process the response and update the active subscription
        match response {
            Ok(ConsensusObserverResponse::SubscribeAck) => {
                // Log the successful subscription
                info!(
                    LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                        "Successfully subscribed to peer: {}!",
                        potential_peer
                    ))
                );

                // Create the new subscription
                let subscription = ConsensusObserverSubscription::new(
                    consensus_observer_config,
                    db_reader.clone(),
                    potential_peer,
                    time_service.clone(),
                );

                // Return the successful subscription
                return (Some(subscription), peers_with_failed_attempts);
```

**File:** config/src/config/consensus_observer_config.rs (L24-25)
```rust
    /// Whether the consensus publisher is enabled
    pub publisher_enabled: bool,
```

**File:** config/src/config/consensus_observer_config.rs (L112-127)
```rust
            NodeType::Validator => {
                if ENABLE_ON_VALIDATORS && !publisher_manually_set {
                    // Only enable the publisher for validators
                    consensus_observer_config.publisher_enabled = true;
                    modified_config = true;
                }
            },
            NodeType::ValidatorFullnode => {
                if ENABLE_ON_VALIDATOR_FULLNODES
                    && !observer_manually_set
                    && !publisher_manually_set
                {
                    // Enable both the observer and the publisher for VFNs
                    consensus_observer_config.observer_enabled = true;
                    consensus_observer_config.publisher_enabled = true;
                    modified_config = true;
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L578-594)
```rust
        // Verify the message is from the peers we've subscribed to
        if let Err(error) = self
            .subscription_manager
            .verify_message_for_subscription(peer_network_id)
        {
            // Update the rejected message counter
            increment_rejected_message_counter(&peer_network_id, &message);

            // Log the error and return
            warn!(
                LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                    "Received message that was not from an active subscription! Error: {:?}",
                    error,
                ))
            );
            return;
        }
```

**File:** consensus/src/consensus_observer/observer/subscription_manager.rs (L363-385)
```rust
    pub fn verify_message_for_subscription(
        &mut self,
        message_sender: PeerNetworkId,
    ) -> Result<(), Error> {
        // Check if the message is from an active subscription
        if let Some(active_subscription) = self
            .active_observer_subscriptions
            .lock()
            .get_mut(&message_sender)
        {
            // Update the last message receive time and return early
            active_subscription.update_last_message_receive_time();
            return Ok(());
        }

        // Otherwise, the message is not from an active subscription.
        // Send another unsubscribe request, and return an error.
        self.unsubscribe_from_peer(message_sender);
        Err(Error::InvalidMessageError(format!(
            "Received message from unexpected peer, and not an active subscription: {}!",
            message_sender
        )))
    }
```

**File:** network/framework/src/application/metadata.rs (L20-35)
```rust
/// A container holding all relevant metadata for the peer.
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
pub struct PeerMetadata {
    pub(crate) connection_state: ConnectionState,
    pub(crate) connection_metadata: ConnectionMetadata,
    pub(crate) peer_monitoring_metadata: PeerMonitoringMetadata,
}

impl PeerMetadata {
    pub fn new(connection_metadata: ConnectionMetadata) -> Self {
        PeerMetadata {
            connection_state: ConnectionState::Connected,
            connection_metadata,
            peer_monitoring_metadata: PeerMonitoringMetadata::default(),
        }
    }
```
