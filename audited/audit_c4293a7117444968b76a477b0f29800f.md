# Audit Report

## Title
Gas Feature Version Skew Between Verifier and Runtime Type Limits Enables Module DOS via Governance Misconfiguration

## Summary
The verifier's type size limits (`max_type_nodes`, `max_type_depth`) and the runtime TypeBuilder's limits (`max_ty_size`, `max_ty_depth`) are controlled by different mechanisms that can diverge. The verifier limits are hardcoded based on feature flags, while TypeBuilder limits come from governance-updatable gas parameters. This allows governance to create a mismatch where modules pass verification but fail at runtime, breaking deterministic execution and enabling denial-of-service attacks on published modules.

## Finding Description
The `aptos_prod_verifier_config()` and `aptos_prod_ty_builder()` functions create security boundaries for type complexity using different configuration sources: [1](#0-0) 

The verifier's `max_type_nodes` and `max_type_depth` are **hardcoded** based on the `ENABLE_FUNCTION_VALUES` feature flag (128/20 if enabled, 256/None if disabled). [2](#0-1) 

The TypeBuilder's `max_ty_size` and `max_ty_depth` are sourced from **governance-updatable gas parameters** when `gas_feature_version >= RELEASE_V1_15`. [3](#0-2) 

These gas parameters can be updated through governance without any validation that they remain consistent with verifier limits: [4](#0-3) 

The TODO comments confirm that consistency validation is missing: [5](#0-4) 

**Attack Path:**

1. **Initial State:** ENABLE_FUNCTION_VALUES=true, gas_params.max_ty_size=128, max_ty_depth=20 (all aligned)

2. **Governance Update:** Malicious or buggy proposal updates gas parameters to max_ty_size=50, max_ty_depth=10

3. **Divergence Created:** 
   - Verifier still allows max_type_nodes=128, max_type_depth=20 (based on feature flag)
   - TypeBuilder now enforces max_ty_size=50, max_ty_depth=10 (based on gas params)

4. **Module Publishing:** Attacker publishes module with types having 80 nodes and depth 15

5. **Verification Succeeds:** 80 < 128 and 15 < 20, so bytecode verifier passes [6](#0-5) 

6. **Runtime Failure:** When transactions try to instantiate these types, TypeBuilder checks fail [7](#0-6) 

7. **Transaction Validation:** The failure occurs during transaction argument validation [8](#0-7) 

This breaks the critical invariant that **verified on-chain code should execute deterministically**. Modules that were successfully published become unusable.

## Impact Explanation
This vulnerability qualifies as **High Severity** ($50,000 range) with potential for **Critical Severity** depending on exploitation:

**Immediate Impact:**
- **Significant Protocol Violation:** Breaks deterministic execution invariant - verified modules can fail at runtime
- **Denial of Service:** Published modules become non-functional when gas params are tightened
- **System Instability:** Critical framework modules could become unusable, requiring emergency intervention

**Critical Escalation Potential:**
- If system-critical modules (governance, staking, coin transfer) are affected, this could cause **total loss of liveness** (Critical severity - up to $1,000,000)
- Governance lock-out: If governance modules fail, the chain cannot recover without a hard fork (**non-recoverable network partition**)

The vulnerability enables unprivileged attackers to publish "time-bomb" modules that appear valid but become DOS vectors when governance adjusts gas parameters.

## Likelihood Explanation
**Likelihood: Medium-High**

**Factors Increasing Likelihood:**
1. **No Validation:** Gas schedule updates have TODO comments for consistency checks that were never implemented
2. **Independent Update Paths:** Feature flags and gas parameters are updated through separate governance proposals
3. **Legitimate Use Case:** Governance may tighten limits for security reasons without realizing the impact on existing modules
4. **No Safeguards:** The codebase has no assertions or runtime checks preventing this mismatch

**Factors Decreasing Likelihood:**
1. Requires governance action (but governance proposals can be buggy or malicious)
2. Core developers likely monitor gas parameter changes (but not foolproof)

The vulnerability is **exploitable today** - governance could accidentally trigger it through well-intentioned security tightening.

## Recommendation
**Immediate Fix:** Add validation in gas schedule updates to ensure runtime type limits are never stricter than verifier limits:

```rust
// In aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move
public fun set_for_next_epoch(aptos_framework: &signer, gas_schedule_blob: vector<u8>) acquires GasScheduleV2 {
    system_addresses::assert_aptos_framework(aptos_framework);
    assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));
    let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
    
    // NEW: Validate type limits consistency
    validate_type_limits_consistency(&new_gas_schedule);
    
    if (exists<GasScheduleV2>(@aptos_framework)) {
        let cur_gas_schedule = borrow_global<GasScheduleV2>(@aptos_framework);
        assert!(
            new_gas_schedule.feature_version >= cur_gas_schedule.feature_version,
            error::invalid_argument(EINVALID_GAS_FEATURE_VERSION)
        );
    };
    config_buffer::upsert(new_gas_schedule);
}

// NEW: Validation function
fun validate_type_limits_consistency(gas_schedule: &GasScheduleV2) {
    // Extract max_ty_size and max_ty_depth from gas schedule
    // Check against current feature flags and verifier limits
    // Abort with EINVALID_GAS_SCHEDULE if runtime limits would be stricter than verifier
}
```

**Structural Fix:** Unify the configuration source - make both verifier and TypeBuilder use the same gas parameters:

```rust
// In aptos-move/aptos-vm-environment/src/prod_configs.rs
pub fn aptos_prod_verifier_config(gas_feature_version: u64, features: &Features, gas_params: &AptosGasParameters) -> VerifierConfig {
    // ...
    let max_type_nodes = if gas_feature_version >= RELEASE_V1_15 {
        Some(gas_params.vm.txn.max_ty_size.into())  // Use gas params, not hardcoded!
    } else if enable_function_values {
        Some(128)
    } else {
        Some(256)
    };
    // ... similar for max_type_depth
}
```

**Long-term Fix:** Add runtime assertions in `aptos_prod_vm_config()` to detect mismatches:

```rust
pub fn aptos_prod_vm_config(...) -> VMConfig {
    let vm_config = VMConfig { ... };
    
    // Assert type limits are consistent
    if let Some(verifier_max) = vm_config.verifier_config.max_type_nodes {
        assert!(vm_config.ty_builder.max_ty_size >= verifier_max as u64,
                "Runtime type limits must not be stricter than verifier limits");
    }
    
    vm_config
}
```

## Proof of Concept

```move
// Test demonstrating the vulnerability
// Save as: aptos-move/aptos-vm/tests/gas_limit_mismatch_test.move

#[test_only]
module test_addr::type_limit_mismatch {
    use std::vector;
    
    // Struct with deeply nested types (approaching limit)
    struct DeepNesting has drop {
        level1: vector<vector<vector<vector<vector<
            vector<vector<vector<vector<vector<u64>>>>>>>>>>
    }
    
    // This function will pass verification with max_type_nodes=128
    // but fail at runtime if max_ty_size is reduced to 50
    public fun create_deep_structure(): DeepNesting {
        DeepNesting {
            level1: vector::empty()
        }
    }
    
    #[test]
    #[expected_failure(abort_code = TOO_MANY_TYPE_NODES)]
    fun test_type_instantiation_failure_after_gas_param_reduction() {
        // This test simulates:
        // 1. Module published when limits are aligned (max_ty_size=128)
        // 2. Governance reduces max_ty_size to 50
        // 3. Existing module's types can no longer be instantiated
        let _ = create_deep_structure();
    }
}
```

**Rust Reproduction Steps:**

1. Set initial state: `ENABLE_FUNCTION_VALUES=true`, `max_ty_size=128`
2. Publish module with 100-node types (passes verification)
3. Update gas params: `max_ty_size=64` via governance
4. Execute transaction calling the module
5. Observe: Transaction fails with `TOO_MANY_TYPE_NODES` despite module being verified

The vulnerability is confirmed by the lack of validation in gas schedule updates and the independent control of verifier vs. runtime limits.

## Notes

This vulnerability exists because the codebase evolved to add gas parameters for type limits (V1.15+) without updating the verifier config to use those same parameters. The hardcoded verifier limits based on feature flags create a permanent divergence risk. The TODO comments in gas_schedule.move explicitly acknowledge missing consistency validation, confirming this is a known gap in the implementation.

### Citations

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L116-127)
```rust
pub fn aptos_prod_ty_builder(
    gas_feature_version: u64,
    gas_params: &AptosGasParameters,
) -> TypeBuilder {
    if gas_feature_version >= RELEASE_V1_15 {
        let max_ty_size = gas_params.vm.txn.max_ty_size;
        let max_ty_depth = gas_params.vm.txn.max_ty_depth;
        TypeBuilder::with_limits(max_ty_size.into(), max_ty_depth.into())
    } else {
        aptos_default_ty_builder()
    }
}
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L145-194)
```rust
pub fn aptos_prod_verifier_config(gas_feature_version: u64, features: &Features) -> VerifierConfig {
    let sig_checker_v2_fix_script_ty_param_count =
        features.is_enabled(FeatureFlag::SIGNATURE_CHECKER_V2_SCRIPT_FIX);
    let sig_checker_v2_fix_function_signatures = gas_feature_version >= RELEASE_V1_34;
    let enable_enum_types = features.is_enabled(FeatureFlag::ENABLE_ENUM_TYPES);
    let enable_resource_access_control =
        features.is_enabled(FeatureFlag::ENABLE_RESOURCE_ACCESS_CONTROL);
    let enable_function_values = features.is_enabled(FeatureFlag::ENABLE_FUNCTION_VALUES);
    // Note: we reuse the `enable_function_values` flag to set various stricter limits on types.

    VerifierConfig {
        scope: VerificationScope::Everything,
        max_loop_depth: Some(5),
        max_generic_instantiation_length: Some(32),
        max_function_parameters: Some(128),
        max_basic_blocks: Some(1024),
        max_value_stack_size: 1024,
        max_type_nodes: if enable_function_values {
            Some(128)
        } else {
            Some(256)
        },
        max_push_size: Some(10000),
        max_struct_definitions: None,
        max_struct_variants: None,
        max_fields_in_struct: None,
        max_function_definitions: None,
        max_back_edges_per_function: None,
        max_back_edges_per_module: None,
        max_basic_blocks_in_script: None,
        max_per_fun_meter_units: Some(1000 * 80000),
        max_per_mod_meter_units: Some(1000 * 80000),
        _use_signature_checker_v2: true,
        sig_checker_v2_fix_script_ty_param_count,
        sig_checker_v2_fix_function_signatures,
        enable_enum_types,
        enable_resource_access_control,
        enable_function_values,
        max_function_return_values: if enable_function_values {
            Some(128)
        } else {
            None
        },
        max_type_depth: if enable_function_values {
            Some(20)
        } else {
            None
        },
    }
}
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L266-274)
```rust
            max_ty_size: NumTypeNodes,
            { RELEASE_V1_15.. => "max_ty_size" },
            128,
        ],
        [
            max_ty_depth: NumTypeNodes,
            { RELEASE_V1_15.. => "max_ty_depth" },
            20,
        ],
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L43-50)
```text
    public(friend) fun initialize(aptos_framework: &signer, gas_schedule_blob: vector<u8>) {
        system_addresses::assert_aptos_framework(aptos_framework);
        assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));

        // TODO(Gas): check if gas schedule is consistent
        let gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
        move_to<GasScheduleV2>(aptos_framework, gas_schedule);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L91-103)
```text
    public fun set_for_next_epoch(aptos_framework: &signer, gas_schedule_blob: vector<u8>) acquires GasScheduleV2 {
        system_addresses::assert_aptos_framework(aptos_framework);
        assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));
        let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
        if (exists<GasScheduleV2>(@aptos_framework)) {
            let cur_gas_schedule = borrow_global<GasScheduleV2>(@aptos_framework);
            assert!(
                new_gas_schedule.feature_version >= cur_gas_schedule.feature_version,
                error::invalid_argument(EINVALID_GAS_FEATURE_VERSION)
            );
        };
        config_buffer::upsert(new_gas_schedule);
    }
```

**File:** third_party/move/move-vm/runtime/src/storage/environment.rs (L192-195)
```rust
            move_bytecode_verifier::verify_module_with_config(
                &self.vm_config().verifier_config,
                compiled_module.as_ref(),
            )?;
```

**File:** third_party/move/move-vm/types/src/loaded_data/runtime_types.rs (L1194-1223)
```rust
    #[inline]
    fn check(&self, count: &mut u64, depth: u64) -> PartialVMResult<()> {
        if *count >= self.max_ty_size {
            return self.too_many_nodes_error();
        }
        if depth > self.max_ty_depth {
            return self.too_large_depth_error();
        }
        Ok(())
    }

    #[cold]
    fn too_many_nodes_error(&self) -> PartialVMResult<()> {
        Err(
            PartialVMError::new(StatusCode::TOO_MANY_TYPE_NODES).with_message(format!(
                "Type size is larger than maximum {}",
                self.max_ty_size
            )),
        )
    }

    #[cold]
    fn too_large_depth_error(&self) -> PartialVMResult<()> {
        Err(
            PartialVMError::new(StatusCode::VM_MAX_TYPE_DEPTH_REACHED).with_message(format!(
                "Type depth is larger than maximum {}",
                self.max_ty_depth
            )),
        )
    }
```

**File:** aptos-move/aptos-vm/src/verifier/transaction_arg_validation.rs (L136-149)
```rust
    let ty_builder = &loader.runtime_environment().vm_config().ty_builder;

    // Need to keep this here to ensure we return the historic correct error code for replay
    for ty in func.param_tys()[signer_param_cnt..].iter() {
        let subst_res = ty_builder.create_ty_with_subst(ty, func.ty_args());
        let ty = subst_res.map_err(|e| e.finish(Location::Undefined).into_vm_status())?;
        let valid = is_valid_txn_arg(loader.runtime_environment(), &ty, allowed_structs);
        if !valid {
            return Err(VMStatus::error(
                StatusCode::INVALID_MAIN_FUNCTION_SIGNATURE,
                None,
            ));
        }
    }
```
