# Audit Report

## Title
Resource Exhaustion via Missing Field Length Validation Before Expensive Operations in Keyless Authentication

## Summary
The `ZeroKnowledgeSig` validation performs expensive operations (on-chain state reads, cryptographic deserialization, JWT parsing) before validating that the `extra_field` and `override_aud_val` strings comply with their maximum size limits (350 bytes and 120 bytes respectively). This allows attackers to submit transactions with oversized fields that force validators to waste computational resources before detecting the invalid input. Since signature validation failures result in transaction discard without gas charges, attackers pay nothing for the wasted validator resources.

## Finding Description

The validation flow for keyless transactions with `ZeroKnowledgeSig` follows this order: [1](#0-0) 

Within `validate_authenticators`, the following expensive operations occur **before** field length validation:

1. **Line 220**: `get_jwks_onchain(resolver)` - Expensive on-chain state read with deserialization
2. **Lines 222-233**: Training wheels public key retrieval and Ed25519 deserialization - State read plus cryptographic deserialization
3. **Lines 235-260**: JWK lookup including JWT header parsing and potential federated JWK state reads

Only after these operations, in `verify_keyless_signature_without_ephemeral_signature_check`: [2](#0-1) 

The field length validation occurs indirectly at **line 307-316** when `get_public_inputs_hash` is called, which eventually calls: [3](#0-2) 

The actual length check happens deep inside the Poseidon hashing functions: [4](#0-3) 

**Attack Path:**
1. Attacker creates a `SignedTransaction` with a `KeylessSignature` containing a `ZeroKnowledgeSig`
2. The `ZeroKnowledgeSig` includes an oversized `extra_field` (e.g., 10 KB instead of max 350 bytes) or oversized `override_aud_val` (e.g., 10 KB instead of max 120 bytes)
3. During transaction validation, expensive state reads and deserialization occur
4. Only when computing the public inputs hash does the validation fail with "Byte array length of X is NOT <= max length of Y bytes"
5. Transaction is discarded via the `unwrap_or_discard` macro: [5](#0-4) [6](#0-5) 

6. Attacker pays no gas, but validators wasted CPU cycles and I/O operations

The maximum field sizes are defined as circuit constants: [7](#0-6) 

## Impact Explanation

This is a **Low Severity** resource exhaustion vulnerability per Aptos bug bounty criteria. The impact includes:

- **Resource Waste**: Attackers can force validators to perform expensive operations (state reads from AptosDB, cryptographic deserializations, JWT parsing) before cheap validation catches the error
- **No Gas Cost**: Transaction discard means the attacker pays no gas for wasted validator resources
- **Bounded Impact**: The attack is limited by network-level protections (maximum transaction size, mempool rate limiting, peer reputation)
- **No Consensus Risk**: Does not break consensus safety, liveness, or deterministic execution
- **No Fund Loss**: Cannot steal, mint, or freeze funds

This qualifies as Low Severity under "Non-critical implementation bugs" that waste resources but do not threaten core protocol security.

## Likelihood Explanation

**High Likelihood** - The vulnerability is:
- **Trivial to Exploit**: Any user can submit a transaction with oversized string fields
- **Zero Cost**: Attacker pays no gas since transactions are discarded
- **No Special Access**: Requires no validator privileges, insider knowledge, or special keys
- **Currently Exploitable**: The vulnerability exists in production code with no mitigations

The only limiting factors are network-level transaction size limits and mempool protections, which may not effectively prevent this specific attack pattern since the fields are within BCS serialization limits but exceed the circuit constants.

## Recommendation

Add early length validation in `verify_keyless_signature_without_ephemeral_signature_check` **before** calling `get_public_inputs_hash` at line 307:

```rust
// After line 303 (override_aud_val allowlist check), add:

// Validate extra_field length before expensive operations
if let Some(ref extra_field) = zksig.extra_field {
    if extra_field.len() > config.max_extra_field_bytes as usize {
        return Err(invalid_signature!(format!(
            "extra_field length {} exceeds maximum {} bytes",
            extra_field.len(),
            config.max_extra_field_bytes
        )));
    }
}

// Validate override_aud_val length before expensive operations
if let Some(ref override_aud) = zksig.override_aud_val {
    if override_aud.len() > MAX_AUD_VAL_BYTES {
        return Err(invalid_signature!(format!(
            "override_aud_val length {} exceeds maximum {} bytes",
            override_aud.len(),
            MAX_AUD_VAL_BYTES
        )));
    }
}

// Then proceed with public_inputs_hash computation (line 307)
```

This ensures cheap validation occurs before expensive cryptographic operations and state reads.

## Proof of Concept

```rust
// This PoC demonstrates the attack pattern (conceptual Rust code)
use aptos_types::{
    keyless::{ZeroKnowledgeSig, ZKP, Groth16Proof},
    transaction::authenticator::EphemeralSignature,
};

fn create_malicious_zkp_sig() -> ZeroKnowledgeSig {
    // Create an oversized extra_field (10 KB instead of 350 bytes max)
    let oversized_extra_field = "x".repeat(10_000);
    
    ZeroKnowledgeSig {
        proof: ZKP::Groth16(Groth16Proof::dummy_proof()),
        exp_horizon_secs: 3600, // Valid value
        extra_field: Some(oversized_extra_field), // INVALID: > 350 bytes
        override_aud_val: None,
        training_wheels_signature: None,
    }
}

// When this signature is used in a transaction:
// 1. Validators read JWKs from state (expensive)
// 2. Validators deserialize training wheels key (expensive)  
// 3. Validators parse JWT header and lookup JWK (expensive)
// 4. ONLY THEN does validation fail when hashing the oversized field
// 5. Transaction discarded, attacker pays no gas
// 6. Validator resources wasted
```

**Notes**

This vulnerability demonstrates a violation of the "fail-fast" principle in security-critical validation code. Cheap checks (string length validation) should always precede expensive operations (state reads, cryptographic operations) to prevent resource exhaustion attacks. While the impact is bounded by network-level protections, the issue represents a clear inefficiency that attackers can exploit at no cost to themselves while imposing costs on validators.

### Citations

**File:** aptos-move/aptos-vm/src/keyless_validation.rs (L153-273)
```rust
pub(crate) fn validate_authenticators(
    pvk: Option<&PreparedVerifyingKey<Bn254>>,
    configuration: Option<&Configuration>,
    authenticators: &Vec<(AnyKeylessPublicKey, KeylessSignature)>,
    features: &Features,
    resolver: &impl AptosMoveResolver,
    module_storage: &impl ModuleStorage,
) -> Result<(), VMStatus> {
    let mut with_zk = false;
    for (pk, sig) in authenticators {
        // Feature-gating for keyless TXNs (whether ZK or ZKless, whether passkey-based or not)
        if matches!(sig.cert, EphemeralCertificate::ZeroKnowledgeSig { .. }) {
            if !features.is_zk_keyless_enabled() {
                return Err(VMStatus::error(StatusCode::FEATURE_UNDER_GATING, None));
            }

            with_zk = true;
        }
        if matches!(sig.cert, EphemeralCertificate::OpenIdSig { .. })
            && !features.is_zkless_keyless_enabled()
        {
            return Err(VMStatus::error(StatusCode::FEATURE_UNDER_GATING, None));
        }
        if matches!(sig.ephemeral_signature, EphemeralSignature::WebAuthn { .. })
            && !features.is_keyless_with_passkeys_enabled()
        {
            return Err(VMStatus::error(StatusCode::FEATURE_UNDER_GATING, None));
        }
        if matches!(pk, AnyKeylessPublicKey::Federated { .. })
            && !features.is_federated_keyless_enabled()
        {
            return Err(VMStatus::error(StatusCode::FEATURE_UNDER_GATING, None));
        }
    }

    // If there are ZK authenticators, the Groth16 VK must have been set on-chain.
    if with_zk && pvk.is_none() {
        return Err(invalid_signature!("Groth16 VK has not been set on-chain"));
    }

    let config = configuration.ok_or_else(|| {
        // Preserve error code for compatibility.
        value_deserialization_error!(format!(
            "get_resource failed on {}::{}::{}",
            CORE_CODE_ADDRESS.to_hex_literal(),
            Configuration::struct_tag().module,
            Configuration::struct_tag().name
        ))
    })?;
    if authenticators.len() > config.max_signatures_per_txn as usize {
        // println!("[aptos-vm][groth16] Too many keyless authenticators");
        return Err(invalid_signature!("Too many keyless authenticators"));
    }

    let onchain_timestamp_obj = get_current_time_onchain(resolver)?;
    // Check the expiry timestamp on all authenticators first to fail fast
    // This is a redundant check to quickly dismiss expired signatures early and save compute on more computationally costly checks.
    // The actual check is performed in `verify_keyless_signature_without_ephemeral_signature_check`.
    for (_, sig) in authenticators {
        sig.verify_expiry(onchain_timestamp_obj.microseconds)
            .map_err(|_| {
                // println!("[aptos-vm][groth16] ZKP expired");

                invalid_signature!("The ephemeral keypair has expired")
            })?;
    }

    let patched_jwks = get_jwks_onchain(resolver)?;

    let training_wheels_pk = match &config.training_wheels_pubkey {
        None => None,
        // This takes ~4.4 microseconds, so we are not too concerned about speed here.
        // (Run `cargo bench -- ed25519/pk_deserialize` in `crates/aptos-crypto`.)
        Some(bytes) => Some(EphemeralPublicKey::ed25519(
            Ed25519PublicKey::try_from(bytes.as_slice()).map_err(|_| {
                // println!("[aptos-vm][groth16] On chain TW PK is invalid");

                invalid_signature!("The training wheels PK set on chain is not a valid PK")
            })?,
        )),
    };

    for (pk, sig) in authenticators {
        // Try looking up the jwk in 0x1.
        let jwk = match get_jwk_for_authenticator(&patched_jwks.jwks, pk.inner_keyless_pk(), sig) {
            // 1: If found in 0x1, then we consider that the ground truth & we are done.
            Ok(jwk) => jwk,
            // 2: If not found in 0x1, we check the Keyless PK type.
            Err(e) => {
                match pk {
                    // 2.a: If this is a federated keyless account; look in `jwk_addr` for JWKs
                    AnyKeylessPublicKey::Federated(fed_pk) => {
                        let federated_jwks =
                            get_federated_jwks_onchain(resolver, &fed_pk.jwk_addr, module_storage)
                                .map_err(|_| {
                                    invalid_signature!(format!(
                                        "Could not fetch federated PatchedJWKs at {}",
                                        fed_pk.jwk_addr
                                    ))
                                })?;
                        // 2.a.i If not found in jwk_addr either, then we fail the validation.
                        get_jwk_for_authenticator(&federated_jwks.jwks, pk.inner_keyless_pk(), sig)?
                    },
                    // 2.b: If this is not a federated keyless account, then we fail the validation.
                    AnyKeylessPublicKey::Normal(_) => return Err(e),
                }
            },
        };
        verify_keyless_signature_without_ephemeral_signature_check(
            pk,
            sig,
            &jwk,
            onchain_timestamp_obj.microseconds,
            &training_wheels_pk,
            config,
            pvk,
        )?;
    }

    Ok(())
}
```

**File:** aptos-move/aptos-vm/src/keyless_validation.rs (L275-363)
```rust
pub fn verify_keyless_signature_without_ephemeral_signature_check(
    public_key: &AnyKeylessPublicKey,
    signature: &KeylessSignature,
    jwk: &JWK,
    onchain_timestamp_microseconds: u64,
    training_wheels_pk: &Option<EphemeralPublicKey>,
    config: &Configuration,
    pvk: Option<&PreparedVerifyingKey<Bn254>>,
) -> Result<(), VMStatus> {
    signature
        .verify_expiry(onchain_timestamp_microseconds)
        .map_err(|_| {
            // println!("[aptos-vm][groth16] ZKP expired");

            invalid_signature!("The ephemeral keypair has expired")
        })?;
    match &signature.cert {
        EphemeralCertificate::ZeroKnowledgeSig(zksig) => match jwk {
            JWK::RSA(rsa_jwk) => {
                if zksig.exp_horizon_secs > config.max_exp_horizon_secs {
                    // println!("[aptos-vm][groth16] Expiration horizon is too long");
                    return Err(invalid_signature!("The expiration horizon is too long"));
                }

                // If an `aud` override was set for account recovery purposes, check that it is
                // in the allow-list on-chain.
                if zksig.override_aud_val.is_some() {
                    config.is_allowed_override_aud(zksig.override_aud_val.as_ref().unwrap())?;
                }
                match &zksig.proof {
                    ZKP::Groth16(groth16proof) => {
                        // let start = std::time::Instant::now();
                        let public_inputs_hash = get_public_inputs_hash(
                            signature,
                            public_key.inner_keyless_pk(),
                            rsa_jwk,
                            config,
                        )
                        .map_err(|_| {
                            // println!("[aptos-vm][groth16] PIH computation failed");
                            invalid_signature!("Could not compute public inputs hash")
                        })?;
                        // println!("Public inputs hash time: {:?}", start.elapsed());

                        let groth16_and_stmt =
                            Groth16ProofAndStatement::new(*groth16proof, public_inputs_hash);

                        // The training wheels signature is only checked if a training wheels PK is set on chain
                        if training_wheels_pk.is_some() {
                            match &zksig.training_wheels_signature {
                                Some(training_wheels_sig) => {
                                    training_wheels_sig
                                        .verify(
                                            &groth16_and_stmt,
                                            training_wheels_pk.as_ref().unwrap(),
                                        )
                                        .map_err(|_| {
                                            // println!("[aptos-vm][groth16] TW sig verification failed");
                                            invalid_signature!(
                                                "Could not verify training wheels signature"
                                            )
                                        })?;
                                },
                                None => {
                                    // println!("[aptos-vm][groth16] Expected TW sig to be set");
                                    return Err(invalid_signature!(
                                        "Training wheels signature expected but it is missing"
                                    ));
                                },
                            }
                        }

                        let result = zksig.verify_groth16_proof(public_inputs_hash, pvk.unwrap());

                        result.map_err(|_| {
                            // println!("[aptos-vm][groth16] ZKP verification failed");
                            // println!("[aptos-vm][groth16] PIH: {}", public_inputs_hash);
                            // match zksig.proof {
                            //     ZKP::Groth16(proof) => {
                            //         println!("[aptos-vm][groth16] ZKP: {}", proof.hash());
                            //     },
                            // }
                            // println!(
                            //     "[aptos-vm][groth16] PVK: {}",
                            //     Groth16VerificationKey::from(pvk).hash()
                            // );
                            invalid_signature!("Proof verification failed")
                        })?;
                    },
```

**File:** types/src/keyless/bn254_circom.rs (L291-308)
```rust
    let (has_extra_field, extra_field_hash) = match extra_field {
        None => (Fr::zero(), *EMPTY_EXTRA_FIELD_HASH),
        Some(extra_field) => (
            Fr::one(),
            poseidon_bn254::keyless::pad_and_hash_string(
                extra_field,
                config.max_extra_field_bytes as usize,
            )?,
        ),
    };

    let (override_aud_val_hash, use_override_aud) = match override_aud_val {
        Some(override_aud_val) => (
            cached_pad_and_hash_string(override_aud_val, IdCommitment::MAX_AUD_VAL_BYTES)?,
            ark_bn254::Fr::from(1),
        ),
        None => (*EMPTY_OVERRIDE_AUD_FIELD_HASH, ark_bn254::Fr::from(0)),
    };
```

**File:** crates/aptos-crypto/src/poseidon_bn254/keyless.rs (L85-103)
```rust
pub fn pad_and_pack_bytes_to_scalars_with_len(
    bytes: &[u8],
    max_bytes: usize,
) -> anyhow::Result<Vec<ark_bn254::Fr>> {
    let len = bytes.len();
    if max_bytes > MAX_NUM_INPUT_BYTES {
        bail!(
            "Cannot hash more than {} bytes. Was given {} bytes.",
            MAX_NUM_INPUT_BYTES,
            len
        );
    }
    if len > max_bytes {
        bail!(
            "Byte array length of {} is NOT <= max length of {} bytes.",
            bytes.len(),
            max_bytes
        );
    }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L176-185)
```rust
macro_rules! unwrap_or_discard {
    ($res:expr) => {
        match $res {
            Ok(s) => s,
            Err(e) => {
                // covers both VMStatus itself and VMError which can convert to VMStatus
                let s: VMStatus = e.into();

                let o = discarded_output(s.status_code());
                return (s, o);
```

**File:** aptos-move/aptos-vm/src/errors.rs (L307-309)
```rust
pub(crate) fn discarded_output(status_code: StatusCode) -> VMOutput {
    VMOutput::empty_with_status(TransactionStatus::Discard(status_code))
}
```

**File:** types/src/keyless/circuit_constants.rs (L16-21)
```rust
pub(crate) const MAX_AUD_VAL_BYTES: usize = 120;
pub(crate) const MAX_UID_KEY_BYTES: usize = 30;
pub(crate) const MAX_UID_VAL_BYTES: usize = 330;
pub(crate) const MAX_ISS_VAL_BYTES: u16 = 120;
pub(crate) const MAX_EXTRA_FIELD_BYTES: u16 = 350;
pub(crate) const MAX_JWT_HEADER_B64_BYTES: u32 = 300;
```
