# Audit Report

## Title
Security Event Sampling Enables Attack Volume Obfuscation for Noise Handshake Replay Attacks

## Summary
The `SecurityEvent::NoiseHandshake` logging for replay attack detection uses 15-second duration-based sampling, allowing attackers to perform multiple replay attacks within sampling windows while only having the first attempt logged. This reduces visibility into attack patterns and enables more effective reconnaissance and DoS probing.

## Finding Description

The Aptos network layer implements anti-replay protection for Noise protocol handshakes to prevent attackers from replaying captured handshake messages to force validators into expensive Diffie-Hellman computations. [1](#0-0) 

When a replay attack is detected, the server returns a `NoiseHandshakeError::ServerReplayDetected` error. [2](#0-1) 

This error is marked as requiring security logging via the `should_security_log()` method. [3](#0-2) 

However, the security event logging is wrapped in a sampling macro with a 15-second duration window for both inbound and outbound connections. [4](#0-3) 

The sampling implementation only executes the logging statement once per time window. [5](#0-4) 

**Attack Scenario:**
1. Attacker captures a valid handshake message from network traffic
2. Attacker replays the message to a validator at time T=0 → **LOGGED**
3. Attacker replays 50 more times between T=1 and T=14 seconds → **NOT LOGGED**
4. Attacker replays again at T=16 seconds → **LOGGED**
5. Attacker performs 100 replays between T=17 and T=30 seconds → **NOT LOGGED**

Result: Only 2 out of 152 replay attacks are logged, giving security teams no visibility into the attack's true scale and intensity.

## Impact Explanation

This vulnerability does NOT break core security mechanisms - replay attacks are still correctly detected and rejected. However, it creates a **security monitoring blind spot** that enables:

1. **Reconnaissance Evasion**: Attackers can probe anti-replay mechanisms extensively while appearing to perform minimal attacks in logs
2. **DoS Attack Obfuscation**: Distributed replay attacks from multiple sources can force validators to perform handshake parsing and validation work without comprehensive logging of attack volume
3. **Incident Response Degradation**: Security teams cannot accurately assess attack severity, source diversity, or temporal patterns

Critically, no metrics or counters exist to track replay attempts - the sampled logs are the only visibility mechanism into these security-critical events. All other security events (`ConsensusEquivocatingVote`, `InvalidConsensusProposal`, `InvalidSyncInfoMsg`, etc.) are logged without sampling.

**Severity Assessment**: This falls into **Low Severity** per bug bounty criteria ("Minor information leaks" / "Non-critical implementation bugs"). While it reduces security monitoring effectiveness, the actual security control (replay protection) functions correctly. It does not cause validator slowdowns (attacks are rejected before expensive crypto operations), state inconsistencies, or protocol violations.

## Likelihood Explanation

**High Likelihood**: Any external attacker can:
- Capture handshake messages from network traffic (they're encrypted but can be replayed)
- Attempt connections to any validator node  
- Perform replay attacks at arbitrary frequencies
- Observe that only sporadic attempts appear in logs (if they have log access)

No special access, validator collusion, or sophisticated tooling is required. The sampling behavior is deterministic and exploitable by design.

## Recommendation

**Option 1 - Remove Sampling for Security Events (Recommended)**:
Security-critical events should never be sampled. Remove the `sample!` wrapper for `SecurityEvent::NoiseHandshake`:

```rust
// In network/framework/src/transport/mod.rs
if err.should_security_log() {
    warn!(
        SecurityEvent::NoiseHandshake,
        NetworkSchema::new(&ctxt.noise.network_context)
            .network_address(&addr)
            .connection_origin(&origin),
        error = %err,
    );
}
```

**Option 2 - Add Metrics Counter**:
Even if sampling remains for log volume management, add a counter that tracks ALL replay attempts:

```rust
// In network/framework/src/counters.rs
pub static NOISE_REPLAY_ATTACKS_DETECTED: Lazy<IntCounterVec> = Lazy::new(|| {
    register_int_counter_vec!(
        "aptos_noise_replay_attacks_detected",
        "Number of noise handshake replay attacks detected",
        &["role_type", "network_id", "peer_id", "direction"]
    ).unwrap()
});

// In handshake validation code
if anti_replay_timestamps.is_replay(remote_public_key, client_timestamp) {
    counters::noise_replay_attacks_detected(&network_context, origin).inc();
    return Err(NoiseHandshakeError::ServerReplayDetected(/*...*/));
}
```

**Option 3 - Use Frequency-Based Sampling**:
If logs must be sampled, use frequency-based sampling (e.g., 1-in-10) instead of duration-based to ensure attack patterns are preserved:

```rust
sample!(
    SampleRate::Frequency(10),  // Log every 10th replay
    warn!(SecurityEvent::NoiseHandshake, /*...*/)
);
```

## Proof of Concept

```rust
// File: network/framework/src/transport/test_replay_sampling.rs
#[tokio::test]
async fn test_replay_attack_sampling_obfuscation() {
    use std::time::Duration;
    use tokio::time::sleep;
    
    // Simulated validator node with replay detection
    let validator = setup_test_validator();
    let captured_handshake = capture_valid_handshake();
    
    let mut logged_events = Vec::new();
    let mut rejected_count = 0;
    
    // Perform 100 replay attacks over 10 seconds
    for i in 0..100 {
        let result = validator.attempt_connection(captured_handshake.clone()).await;
        
        // All replays are rejected
        assert!(result.is_err());
        rejected_count += 1;
        
        // Check if logged (only first in each 15s window)
        if validator.last_log_contains("SecurityEvent::NoiseHandshake") {
            logged_events.push(i);
        }
        
        sleep(Duration::from_millis(100)).await; // 100 attacks in 10 seconds
    }
    
    // Verification
    assert_eq!(rejected_count, 100); // All replays were rejected
    assert!(logged_events.len() <= 2); // But only ~1-2 were logged (due to 15s sampling)
    
    println!("Replays rejected: {}", rejected_count);
    println!("Replays logged: {}", logged_events.len());
    println!("Attack visibility: {:.1}%", (logged_events.len() as f64 / rejected_count as f64) * 100.0);
    // Expected output: Attack visibility: 1-2% (massive underreporting)
}
```

## Notes

- This issue is specific to `SecurityEvent::NoiseHandshake` - all other security events are logged without sampling
- The sampling was likely added to reduce log volume from high-frequency connection attempts, but inadvertently created a security monitoring gap
- The 15-second window is particularly problematic as it's long enough to hide burst attacks but short enough that persistent attackers still get some log entries
- The replay protection mechanism itself is correctly implemented and secure - this is purely a visibility/monitoring issue

### Citations

**File:** network/framework/src/noise/handshake.rs (L30-39)
```rust
/// In a mutually authenticated network, a client message is accompanied with a timestamp.
/// This is in order to prevent replay attacks, where the attacker does not know the client's static key,
/// but can still replay a handshake message in order to force a peer into performing a few Diffie-Hellman key exchange operations.
///
/// Thus, to prevent replay attacks a responder will always check if the timestamp is strictly increasing,
/// effectively considering it as a stateful counter.
///
/// If the client timestamp has been seen before, or is not strictly increasing,
/// we can abort the handshake early and avoid heavy Diffie-Hellman computations.
/// If the client timestamp is valid, we store it.
```

**File:** network/framework/src/noise/handshake.rs (L443-450)
```rust
            // check the timestamp is not a replay
            let mut anti_replay_timestamps = anti_replay_timestamps.write();
            if anti_replay_timestamps.is_replay(remote_public_key, client_timestamp) {
                return Err(NoiseHandshakeError::ServerReplayDetected(
                    remote_peer_short,
                    client_timestamp,
                ));
            }
```

**File:** network/framework/src/noise/error.rs (L87-93)
```rust
impl NoiseHandshakeError {
    /// Errors that are either clear bugs or indicate some security issue. Should
    /// immediately alert an engineer if we hit one of these errors.
    pub fn should_security_log(&self) -> bool {
        use NoiseHandshakeError::*;
        matches!(self, ServerReplayDetected(_, _))
    }
```

**File:** network/framework/src/transport/mod.rs (L279-289)
```rust
            if err.should_security_log() {
                sample!(
                    SampleRate::Duration(Duration::from_secs(15)),
                    warn!(
                        SecurityEvent::NoiseHandshake,
                        NetworkSchema::new(&ctxt.noise.network_context)
                            .network_address(&addr)
                            .connection_origin(&origin),
                        error = %err,
                    )
                );
```

**File:** crates/aptos-logger/src/sample.rs (L62-79)
```rust
    fn sample_duration(rate: &Duration, last_sample: &AtomicU64) -> bool {
        let rate = rate.as_secs();
        // Seconds since Unix Epoch
        let now = SystemTime::now()
            .duration_since(SystemTime::UNIX_EPOCH)
            .expect("SystemTime before UNIX EPOCH!")
            .as_secs();

        last_sample
            .fetch_update(Ordering::SeqCst, Ordering::SeqCst, |last_sample| {
                if now.saturating_sub(last_sample) >= rate {
                    Some(now)
                } else {
                    None
                }
            })
            .is_ok()
    }
```
