# Audit Report

## Title
Token V1 Missing Description Length Validation Enables Collection Spam Attack on Indexers

## Summary
The Token V1 `create_collection` function in `aptos-token/sources/token.move` does not validate the length of the `description` parameter, unlike Token V2 which enforces a 2048 character limit. This allows attackers to create collections with arbitrarily large descriptions or spam indexers with minimal-data collections at low cost, causing off-chain infrastructure degradation.

## Finding Description

The `create_collection` function in Token V1 performs validation on collection name and URI length, but completely omits description length validation: [1](#0-0) 

Constants define maximum lengths for name and URI: [2](#0-1) 

However, the `description` parameter is accepted without any length check and directly stored in `CollectionData`: [3](#0-2) 

The formal specification confirms this omission: [4](#0-3) 

In contrast, Token V2 properly validates description length: [5](#0-4) 

**Attack Vectors:**

1. **Large Description Attack**: Create collections with megabyte-sized descriptions, causing indexer database bloat and UI rendering issues
2. **Mass Spam Attack**: Create thousands of minimal collections (1-char name, empty URI/description) cheaply to flood indexers with garbage data

**Cost Analysis:**

Storage gas costs are defined as: [6](#0-5) 

For minimal collections (~50 bytes): ~300k (item) + 250k (bytes) = ~550k gas units â‰ˆ 0.00055 APT per collection. An attacker could create 1 million collections for ~550 APT (~$5,500 at current prices).

## Impact Explanation

While the core Aptos protocol remains unaffected (consensus, validator operations, and state consistency are not compromised), this vulnerability creates **Medium severity** impact through:

1. **Indexer Infrastructure Degradation**: Off-chain indexers must process and store all collection events, including arbitrarily large descriptions. This leads to:
   - Database bloat requiring expensive storage expansion
   - Increased query latency affecting user experience
   - Potential need for manual intervention to clean spam data

2. **Explorer UI/UX Issues**: Blockchain explorers attempting to display large descriptions may experience:
   - Rendering failures or crashes
   - Page load timeouts
   - Degraded user experience

3. **Economic Attack Surface**: The relatively low cost (0.00055 APT per minimal collection) enables economically feasible spam attacks compared to the operational cost of indexer infrastructure.

This qualifies as **Medium severity** under "State inconsistencies requiring intervention" - while not protocol state, indexer state inconsistencies (bloat, corruption) may require intervention to maintain ecosystem functionality.

## Likelihood Explanation

**Likelihood: High**

The attack is trivially executable by any user:
- No special permissions required
- Simple transaction call to `create_collection` 
- Low economic barrier (~550 APT for 1M spam collections)
- No rate limiting beyond gas costs
- Multiple attack vectors (large descriptions or mass spam)

The inconsistency between Token V1 and V2 suggests this was identified as an issue but not backported to V1 for compatibility reasons, indicating known exposure.

## Recommendation

Add description length validation to Token V1's `create_collection` function to match Token V2's security posture:

```move
// Add constant
const MAX_DESCRIPTION_LENGTH: u64 = 2048;

// Add validation in create_collection function after line 1170:
public fun create_collection(
    creator: &signer,
    name: String,
    description: String,
    uri: String,
    maximum: u64,
    mutate_setting: vector<bool>
) acquires Collections {
    assert!(name.length() <= MAX_COLLECTION_NAME_LENGTH, error::invalid_argument(ECOLLECTION_NAME_TOO_LONG));
    assert!(uri.length() <= MAX_URI_LENGTH, error::invalid_argument(EURI_TOO_LONG));
    assert!(description.length() <= MAX_DESCRIPTION_LENGTH, error::invalid_argument(EDESCRIPTION_TOO_LONG)); // ADD THIS
    // ... rest of function
}
```

Add corresponding error constant:

```move
const EDESCRIPTION_TOO_LONG: u64 = 41;
```

**Note**: This is a breaking change for Token V1. Consider:
- Governance proposal to activate the change
- Grace period for existing applications
- Documentation of the new limit

## Proof of Concept

```move
#[test(creator = @0xCAFE)]
fun test_spam_collection_attack(creator: &signer) {
    use std::string;
    use aptos_token::token;
    
    // Setup: Initialize token framework for creator
    token::initialize_token_store(creator);
    
    // Attack 1: Create collection with massive description (1 MB)
    let massive_desc = string::utf8(vector::empty<u8>());
    let i = 0;
    while (i < 1000000) {
        string::append_utf8(&mut massive_desc, b"A");
        i = i + 1;
    };
    
    token::create_collection(
        creator,
        string::utf8(b"Spam1"),
        massive_desc, // 1 MB description - NO VALIDATION!
        string::utf8(b""),
        0,
        vector[false, false, false]
    );
    
    // Attack 2: Mass spam with minimal collections
    let j = 0;
    while (j < 1000) {
        let name = string::utf8(b"S");
        string::append_utf8(&mut name, &vector[(j % 256) as u8]);
        
        token::create_collection(
            creator,
            name,
            string::utf8(b""), // Empty description
            string::utf8(b""), // Empty URI  
            0,
            vector[false, false, false]
        );
        j = j + 1;
    };
    
    // Result: 1001 garbage collections created
    // - 1 with 1MB description bloating indexer DB
    // - 1000 minimal spam collections
    // Total cost: ~550 APT for mass spam + ~5 APT for large description
}
```

## Notes

- This vulnerability specifically affects **Token V1** (`0x3::token`) only; Token V2 (`0x4::collection`) has proper validation
- The primary victims are off-chain indexers and explorers, not the core protocol
- Storage gas costs provide economic rate limiting but do not prevent the attack
- The inconsistency between V1 and V2 suggests this was a known design improvement
- Events (including `CreateCollectionEvent`) are processed by indexers but not stored in on-chain state, limiting protocol-level impact

### Citations

**File:** aptos-move/framework/aptos-token/sources/token.move (L32-34)
```text
    const MAX_COLLECTION_NAME_LENGTH: u64 = 128;
    const MAX_NFT_NAME_LENGTH: u64 = 128;
    const MAX_URI_LENGTH: u64 = 512;
```

**File:** aptos-move/framework/aptos-token/sources/token.move (L1169-1170)
```text
        assert!(name.length() <= MAX_COLLECTION_NAME_LENGTH, error::invalid_argument(ECOLLECTION_NAME_TOO_LONG));
        assert!(uri.length() <= MAX_URI_LENGTH, error::invalid_argument(EURI_TOO_LONG));
```

**File:** aptos-move/framework/aptos-token/sources/token.move (L1193-1200)
```text
        let collection = CollectionData {
            description,
            name,
            uri,
            supply: 0,
            maximum,
            mutability_config
        };
```

**File:** aptos-move/framework/aptos-token/sources/token.spec.move (L516-533)
```text
    /// The length of the name is up to MAX_COLLECTION_NAME_LENGTH;
    /// The length of the uri is up to MAX_URI_LENGTH;
    /// The collection_data should not exist before you create it.
    spec create_collection(
        creator: &signer,
        name: String,
        description: String,
        uri: String,
        maximum: u64,
        mutate_setting: vector<bool>
    ) {
        // TODO: Complex abort condition.
        pragma aborts_if_is_partial;
        let account_addr = signer::address_of(creator);
        aborts_if len(name.bytes) > 128;
        aborts_if len(uri.bytes) > 512;
        include CreateCollectionAbortsIf;
    }
```

**File:** aptos-move/framework/aptos-token-objects/sources/collection.move (L56-58)
```text
    const MAX_COLLECTION_NAME_LENGTH: u64 = 128;
    const MAX_URI_LENGTH: u64 = 512;
    const MAX_DESCRIPTION_LENGTH: u64 = 2048;
```

**File:** aptos-move/framework/aptos-framework/sources/storage_gas.move (L420-427)
```text
        move_to(aptos_framework, StorageGas {
            per_item_read: 300 * k,
            per_item_create: 5 * m,
            per_item_write: 300 * k,
            per_byte_read: 300,
            per_byte_create: 5 * k,
            per_byte_write: 5 * k,
        });
```
