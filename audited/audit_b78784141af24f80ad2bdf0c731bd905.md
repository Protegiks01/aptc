# Audit Report

## Title
Non-Deterministic Indexer Behavior Due to Inconsistent BCS Deserialization in Token Property Maps

## Summary
The `convert_bcs_hex()` function in the indexer handles BCS deserialization failures inconsistently across type branches. Known types attempt BCS decoding and return formatted values, while unknown types bypass BCS validation entirely and return raw hex strings. This creates non-deterministic indexing behavior when the same blockchain data is processed by nodes with different type recognition capabilities or when users specify non-standard type strings.

## Finding Description
The vulnerability exists in the `convert_bcs_hex()` function which processes Token v1 property map values. [1](#0-0) 

The function maintains a hardcoded match statement for recognized types (u8, u64, u128, bool, address, string, and signed integers). For these types, it:
1. Hex decodes the value
2. BCS deserializes to the specific type
3. Converts to string representation
4. Returns `None` if BCS deserialization fails

However, for unrecognized types (the default `_` branch), it returns `Ok(value)` directly, bypassing BCS validation and returning the original hex string unchanged.

Token v1 property maps allow users to specify arbitrary type strings. [2](#0-1) 

The on-chain Move code only validates a limited set of types in `create_property_value<T>()`, but users can call `create_property_value_raw()` to specify any type string. [3](#0-2) 

When properties are indexed, the type string from blockchain data is used directly to determine decoding behavior. [4](#0-3) 

**Attack Scenario:**
1. User creates a Token v1 property with type="u64" and BCS-encoded value representing `1` (0x0100000000000000)
2. Indexer Node A (with standard type recognition) processes this: decodes to "1"
3. User creates another property with type="custom_integer" (typo or custom type) and the same BCS value
4. Indexer Node A processes this: returns "0x0100000000000000" (raw hex)
5. Result: **Same BCS data produces different indexed values** depending on type string recognition

Worse: If Indexer Node B runs an older version without signed integer support (i8, i16, etc.), and a property uses type="i64":
- Node B treats "i64" as unknown → stores hex value
- Node A recognizes "i64" → stores decoded numeric value
- Result: **Database inconsistency across indexer nodes**

## Impact Explanation
This is **Medium Severity** under the Aptos bug bounty criteria: "State inconsistencies requiring intervention."

The vulnerability causes:
1. **Non-deterministic indexer databases**: Different indexer nodes produce different property values for identical blockchain data
2. **Version-dependent behavior**: Older indexers vs. newer indexers process the same properties differently
3. **User-controllable divergence**: Users can intentionally cause indexer inconsistency by using non-standard type strings

While this doesn't directly affect consensus (validators process the same blockchain data), it breaks a critical invariant: indexers should produce deterministic, consistent views of blockchain state. Applications querying different indexer nodes would receive conflicting data, undermining trust in the indexer infrastructure.

## Likelihood Explanation
**Likelihood: Medium to High**

This will occur whenever:
- Users create Token v1 properties with custom/non-standard type strings (already seen in test code with "integer" type)
- Indexer software is upgraded with new type support (e.g., when signed integers were added)
- Type strings contain typos or case variations
- New Move framework types are introduced but not yet in the indexer's match statement

The issue is not theoretical - the Move test code itself uses non-standard types. [5](#0-4) 

## Recommendation
**Fix 1: Consistent fallback behavior**
Modify the default case to attempt generic BCS validation rather than returning raw hex:

```rust
pub fn convert_bcs_hex(typ: String, value: String) -> Option<String> {
    let decoded = hex::decode(value.strip_prefix("0x").unwrap_or(&*value)).ok()?;

    match typ.as_str() {
        "0x1::string::String" => bcs::from_bytes::<String>(decoded.as_slice()),
        "u8" => bcs::from_bytes::<u8>(decoded.as_slice()).map(|e| e.to_string()),
        // ... existing known types ...
        _ => {
            // For unknown types, validate BCS format but return hex
            // This ensures the data is at least valid BCS
            bcs::from_bytes::<Vec<u8>>(decoded.as_slice())
                .map(|_| format!("0x{}", hex::encode(decoded)))
        }
    }
    .ok()
}
```

**Fix 2: Normalize hex output**
Ensure all branches return consistently formatted hex strings (lowercase with 0x prefix) when falling back.

**Fix 3: Add comprehensive testing**
Add tests for:
- Invalid BCS data with known types
- Valid BCS data with unknown types  
- Hex format variations (uppercase, no prefix, etc.)

## Proof of Concept

```rust
#[cfg(test)]
mod test_convert_bcs_hex_inconsistency {
    use super::*;

    #[test]
    fn test_known_type_vs_unknown_type_same_bcs() {
        // BCS encoding of u64 value 1
        let bcs_value = "0x0100000000000000".to_string();
        
        // Known type: decodes and formats
        let known_result = convert_bcs_hex("u64".to_string(), bcs_value.clone());
        assert_eq!(known_result, Some("1".to_string()));
        
        // Unknown type: returns raw hex
        let unknown_result = convert_bcs_hex("custom_u64".to_string(), bcs_value.clone());
        assert_eq!(unknown_result, Some("0x0100000000000000".to_string()));
        
        // INCONSISTENCY DEMONSTRATED: Same BCS data, different outputs!
        assert_ne!(known_result, unknown_result);
    }

    #[test]
    fn test_typo_in_type_causes_different_output() {
        let bcs_value = "0x0100000000000000".to_string();
        
        let correct = convert_bcs_hex("u64".to_string(), bcs_value.clone());
        let typo = convert_bcs_hex("u644".to_string(), bcs_value.clone()); // typo
        
        assert_eq!(correct, Some("1".to_string()));
        assert_eq!(typo, Some("0x0100000000000000".to_string()));
        
        // A simple typo causes completely different indexed values!
        assert_ne!(correct, typo);
    }

    #[test]
    fn test_case_sensitivity_inconsistency() {
        let bcs_bool_true = "0x01".to_string();
        
        let lowercase = convert_bcs_hex("bool".to_string(), bcs_bool_true.clone());
        let uppercase = convert_bcs_hex("Bool".to_string(), bcs_bool_true.clone());
        
        assert_eq!(lowercase, Some("true".to_string()));
        assert_eq!(uppercase, Some("0x01".to_string())); // Treated as unknown
        
        // Case variation causes different outputs
        assert_ne!(lowercase, uppercase);
    }
}
```

**Notes**

This vulnerability specifically affects the indexer subsystem, not core consensus. However, it violates the deterministic execution invariant that all nodes processing identical blockchain data should produce identical results. The indexer is a critical infrastructure component that applications rely on for querying blockchain state.

The issue is exacerbated by Token v1's design allowing arbitrary type strings without on-chain validation, combined with the indexer's incomplete type recognition. Token v2 addresses this partially by using numeric type identifiers, but Token v1 properties remain vulnerable.

### Citations

**File:** crates/indexer/src/util.rs (L136-158)
```rust
pub fn convert_bcs_hex(typ: String, value: String) -> Option<String> {
    let decoded = hex::decode(value.strip_prefix("0x").unwrap_or(&*value)).ok()?;

    match typ.as_str() {
        "0x1::string::String" => bcs::from_bytes::<String>(decoded.as_slice()),
        "u8" => bcs::from_bytes::<u8>(decoded.as_slice()).map(|e| e.to_string()),
        "u16" => bcs::from_bytes::<u16>(decoded.as_slice()).map(|e| e.to_string()),
        "u32" => bcs::from_bytes::<u32>(decoded.as_slice()).map(|e| e.to_string()),
        "u64" => bcs::from_bytes::<u64>(decoded.as_slice()).map(|e| e.to_string()),
        "u128" => bcs::from_bytes::<u128>(decoded.as_slice()).map(|e| e.to_string()),
        "u256" => bcs::from_bytes::<BigDecimal>(decoded.as_slice()).map(|e| e.to_string()),
        "i8" => bcs::from_bytes::<i8>(decoded.as_slice()).map(|e| e.to_string()),
        "i16" => bcs::from_bytes::<i16>(decoded.as_slice()).map(|e| e.to_string()),
        "i32" => bcs::from_bytes::<i32>(decoded.as_slice()).map(|e| e.to_string()),
        "i64" => bcs::from_bytes::<i64>(decoded.as_slice()).map(|e| e.to_string()),
        "i128" => bcs::from_bytes::<i128>(decoded.as_slice()).map(|e| e.to_string()),
        "i256" => bcs::from_bytes::<BigDecimal>(decoded.as_slice()).map(|e| e.to_string()),
        "bool" => bcs::from_bytes::<bool>(decoded.as_slice()).map(|e| e.to_string()),
        "address" => bcs::from_bytes::<Address>(decoded.as_slice()).map(|e| e.to_string()),
        _ => Ok(value),
    }
    .ok()
}
```

**File:** aptos-move/framework/aptos-token/sources/property_map.move (L54-57)
```text
    struct PropertyValue has store, copy, drop {
        value: vector<u8>,
        type: String,
    }
```

**File:** aptos-move/framework/aptos-token/sources/property_map.move (L237-245)
```text
    public fun create_property_value_raw(
        value: vector<u8>,
        type: String
    ): PropertyValue {
        PropertyValue {
            value,
            type,
        }
    }
```

**File:** aptos-move/framework/aptos-token/sources/property_map.move (L278-279)
```text
    fun test_types(): vector<String> {
        vector[ utf8(b"integer"), utf8(b"integer"), utf8(b"String") ]
```

**File:** crates/indexer/src/models/property_map.rs (L15-20)
```rust
pub fn create_property_value(typ: String, value: String) -> Result<PropertyValue> {
    Ok(PropertyValue {
        value: util::convert_bcs_hex(typ.clone(), value.clone()).unwrap_or(value),
        typ,
    })
}
```
