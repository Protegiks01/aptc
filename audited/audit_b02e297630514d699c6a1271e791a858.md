# Audit Report

## Title
Memory Exhaustion in `bcs::to_bytes()` Native Function Due to Missing Memory Tracking Before Serialization

## Summary
The `bcs::to_bytes()` native function performs BCS serialization and allocates memory for the output **before** charging gas or tracking memory usage. An attacker can exploit this by creating large vectors and calling `bcs::to_bytes()` on them concurrently, causing memory exhaustion on validator nodes before any resource limits are enforced.

## Finding Description

The vulnerability exists in both implementations of the `native_to_bytes()` function:

**In the Move stdlib native implementation:** [1](#0-0) 

**In the Aptos framework native implementation:** [2](#0-1) 

The critical flaw is that serialization occurs and allocates memory for the `serialized_value` Vec<u8> **before** any resource accounting:

1. **Serialization happens first** - The `ValueSerDeContext::serialize()` call allocates a Vec<u8> proportional to the serialized output size
2. **Gas charged after** - Gas is only charged after serialization completes based on the output size
3. **No memory tracking** - The function never calls `context.use_heap_memory()` to track the allocated memory against the 10MB memory quota [3](#0-2) 

The Aptos memory tracking system exists and enforces a memory quota: [4](#0-3) 

However, `bcs::to_bytes()` never invokes this protection mechanism. Additionally, the pre-execution gas check is a no-op: [5](#0-4) 

**Attack Scenario:**

1. Attacker stores resources containing vectors with ~1MB of data (within storage limits) [6](#0-5) 

2. Attacker submits multiple transactions concurrently that:
   - Load these large resources from storage (pays gas for loading)
   - Call `bcs::to_bytes()` on the loaded values
   - Each serialization allocates ~1MB+ before gas is checked

3. With sufficient concurrent transactions (e.g., 1000 txns), this creates a ~1GB+ memory spike across the validator node before any limits are enforced

4. This violates the **Move VM Safety** invariant: "Bytecode execution must respect gas limits and memory constraints"

## Impact Explanation

This qualifies as **High Severity** per the Aptos bug bounty program criteria for the following reasons:

- **Validator node slowdowns**: Memory exhaustion leads to increased GC pressure, swap thrashing, and degraded performance
- **Potential crashes**: Out-of-memory conditions can crash validator processes, disrupting consensus participation
- **DoS potential**: Attackers can repeatedly trigger this condition with relatively low cost (since gas is charged after the memory spike)

The attack does not result in:
- Loss of funds (no theft or minting)
- Consensus safety violations (no chain splits or double-spending)
- Permanent network partition

Therefore, it does not meet Critical severity criteria, but clearly meets High severity as a validator availability attack.

## Likelihood Explanation

This vulnerability is **highly likely** to be exploitable:

- **Low attacker cost**: Creating 1MB resources and calling `bcs::to_bytes()` is inexpensive since storage costs are paid once and serialization gas is charged after the memory spike
- **No special privileges required**: Any transaction sender can exploit this
- **Parallelization amplifies impact**: Block executors process multiple transactions concurrently, multiplying the memory consumption
- **Realistic parameters**: The 1MB storage limit per write operation provides sufficient size for effective exploitation
- **No existing mitigations**: The vulnerability exists in production code with no compensating controls

## Recommendation

Add memory tracking to the `bcs::to_bytes()` native function **before** performing serialization. The fix should:

1. **Estimate serialization size** using `ValueSerDeContext::serialized_size()` before actual serialization
2. **Track memory** via `context.use_heap_memory()` with the estimated size
3. **Perform serialization** only after memory tracking succeeds
4. **Charge gas** as currently done

**Fixed code structure for Aptos framework version:**

```rust
fn native_to_bytes(
    context: &mut SafeNativeContext,
    ty_args: &[Type],
    mut args: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    // ... existing setup code ...
    
    let val = ref_to_val.read_ref()?;
    
    // STEP 1: Estimate serialization size first
    let function_value_extension = context.function_value_extension();
    let max_value_nest_depth = context.max_value_nest_depth();
    let estimated_size = ValueSerDeContext::new(max_value_nest_depth)
        .with_legacy_signer()
        .with_func_args_deserialization(&function_value_extension)
        .serialized_size(&val, &layout)?;
    
    // STEP 2: Track memory BEFORE serialization
    context.use_heap_memory(estimated_size as u64)?;
    
    // STEP 3: Now perform serialization
    let serialized_value = match ValueSerDeContext::new(max_value_nest_depth)
        .with_legacy_signer()
        .with_func_args_deserialization(&function_value_extension)
        .serialize(&val, &layout)?
    {
        Some(serialized_value) => serialized_value,
        None => {
            context.charge(BCS_TO_BYTES_FAILURE)?;
            return Err(SafeNativeError::Abort {
                abort_code: NFE_BCS_SERIALIZATION_FAILURE,
            });
        },
    };
    
    // STEP 4: Charge gas as before
    context.charge(BCS_TO_BYTES_PER_BYTE_SERIALIZED * NumBytes::new(serialized_value.len() as u64))?;
    
    Ok(smallvec![Value::vector_u8(serialized_value)])
}
```

The same fix should be applied to the Move stdlib version in `third_party/move/move-stdlib/src/natives/bcs.rs`.

## Proof of Concept

```move
module attacker::memory_exhaustion {
    use std::bcs;
    use std::vector;
    
    /// Resource containing a large vector
    struct LargeData has key {
        data: vector<u128>
    }
    
    /// Store a large vector (approaching 1MB limit)
    /// 1MB / 16 bytes per u128 = ~65,536 elements
    public entry fun store_large_vector(account: &signer) {
        let large_vec = vector::empty<u128>();
        let i = 0;
        while (i < 65000) {
            vector::push_back(&mut large_vec, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);
            i = i + 1;
        };
        
        move_to(account, LargeData { data: large_vec });
    }
    
    /// Trigger serialization - causes memory spike BEFORE gas check
    public entry fun trigger_serialization(addr: address) acquires LargeData {
        let data = borrow_global<LargeData>(addr);
        // This line allocates ~1MB+ in memory BEFORE charging gas
        let _serialized = bcs::to_bytes(&data.data);
    }
}
```

**Exploitation steps:**

1. Deploy the module above
2. Call `store_large_vector()` once to create a 1MB resource
3. Submit 1000+ concurrent transactions calling `trigger_serialization()`
4. Each transaction allocates ~1MB during serialization before gas limits are checked
5. Validator experiences memory exhaustion, degraded performance, or crash

The vulnerability is confirmed through code analysis showing memory allocation occurs before resource accounting in both native implementations.

## Notes

This vulnerability represents a fundamental violation of the Move VM's resource safety guarantees. The memory quota system ( [7](#0-6) ) exists specifically to prevent such exhaustion attacks, but the `bcs::to_bytes()` function bypasses this protection entirely by performing allocations before invoking memory tracking mechanisms.

### Citations

**File:** third_party/move/move-stdlib/src/natives/bcs.rs (L69-79)
```rust
    let serialized_value = match ValueSerDeContext::new(max_value_nest_depth)
        .with_legacy_signer()
        .with_func_args_deserialization(&function_value_extension)
        .serialize(&val, &layout)?
    {
        Some(serialized_value) => serialized_value,
        None => {
            cost += gas_params.failure;
            return Ok(NativeResult::err(cost, NFE_BCS_SERIALIZATION_FAILURE));
        },
    };
```

**File:** aptos-move/framework/move-stdlib/src/natives/bcs.rs (L97-109)
```rust
    let serialized_value = match ValueSerDeContext::new(max_value_nest_depth)
        .with_legacy_signer()
        .with_func_args_deserialization(&function_value_extension)
        .serialize(&val, &layout)?
    {
        Some(serialized_value) => serialized_value,
        None => {
            context.charge(BCS_TO_BYTES_FAILURE)?;
            return Err(SafeNativeError::Abort {
                abort_code: NFE_BCS_SERIALIZATION_FAILURE,
            });
        },
    };
```

**File:** aptos-move/framework/move-stdlib/src/natives/bcs.rs (L110-111)
```rust
    context
        .charge(BCS_TO_BYTES_PER_BYTE_SERIALIZED * NumBytes::new(serialized_value.len() as u64))?;
```

**File:** aptos-move/aptos-native-interface/src/context.rs (L205-217)
```rust
    pub fn use_heap_memory(&mut self, amount: u64) -> SafeNativeResult<()> {
        if self.timed_feature_enabled(TimedFeatureFlag::FixMemoryUsageTracking) {
            if self.has_direct_gas_meter_access_in_native_context() {
                self.gas_meter()
                    .use_heap_memory_in_native_context(amount)
                    .map_err(LimitExceededError::from_err)?;
            } else {
                self.legacy_heap_memory_usage =
                    self.legacy_heap_memory_usage.saturating_add(amount);
            }
        }
        Ok(())
    }
```

**File:** aptos-move/aptos-gas-meter/src/meter.rs (L208-214)
```rust
    fn charge_native_function_before_execution(
        &mut self,
        _ty_args: impl ExactSizeIterator<Item = impl TypeView>,
        _args: impl ExactSizeIterator<Item = impl ValueView>,
    ) -> PartialVMResult<()> {
        Ok(())
    }
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L142-142)
```rust
        [memory_quota: AbstractValueSize, { 1.. => "memory_quota" }, 10_000_000],
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L154-156)
```rust
            max_bytes_per_write_op: NumBytes,
            { 5.. => "max_bytes_per_write_op" },
            1 << 20, // a single state item is 1MB max
```
