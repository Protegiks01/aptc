# Audit Report

## Title
Critical Lock Poisoning Vulnerability in Sharded Block Executor Causes Permanent Loss of Liveness

## Summary
The `SHARDED_BLOCK_EXECUTOR` global mutex can become permanently poisoned if any panic occurs during sharded block execution, causing all subsequent block execution attempts to fail and resulting in total loss of validator liveness. The root cause is the use of `aptos_infallible::Mutex` which converts poison errors into panics, creating a cascading failure mode with no recovery path.

## Finding Description

The vulnerability exists in the interaction between three components:

1. **The Infallible Mutex Wrapper**: [1](#0-0) 

The `aptos_infallible::Mutex` wrapper calls `.expect()` on lock attempts, which will panic if the underlying `std::sync::Mutex` is poisoned.

2. **Global Executor State**: [2](#0-1) 

The `SHARDED_BLOCK_EXECUTOR` is a global static wrapped in this infallible mutex.

3. **Lock Acquisition During Execution**: [3](#0-2) 

The lock is held throughout the entire block execution process, which contains multiple panic paths.

**Panic Paths While Holding Lock:**

- **Assert on shard count mismatch**: [4](#0-3) 

- **Unsupported global transactions panic**: [5](#0-4) 

- **Channel communication failures**: [6](#0-5) 

- **Multiple unwrap calls on channel sends**: [7](#0-6) 

- **Indexing without bounds checking**: [8](#0-7) 

**Attack Scenario:**
1. Attacker crafts a block with partitioned transactions where the number of shards doesn't match expectations, or includes global transactions in remote execution mode
2. During execution, one of the panic paths is triggered while `SHARDED_BLOCK_EXECUTOR.lock()` is held
3. The panic causes the `std::sync::Mutex` to become poisoned
4. The next call to `SHARDED_BLOCK_EXECUTOR.lock()` receives a `PoisonError`
5. The `.expect()` in the infallible mutex wrapper panics with "Cannot currently handle a poisoned lock"
6. All future block execution attempts fail permanently, requiring validator restart at minimum

## Impact Explanation

This is a **CRITICAL** severity vulnerability under the Aptos Bug Bounty program criteria, specifically matching:
- **"Total loss of liveness/network availability"** - Once triggered, the validator node cannot execute any blocks
- **"Non-recoverable network partition (requires hardfork)"** - If enough validators are affected simultaneously, the network cannot progress

The vulnerability breaks the fundamental liveness guarantee of the blockchain. A single panic during block execution creates a permanent denial of service condition for that validator node. If an attacker can trigger this across multiple validators (by including malicious transaction patterns in proposed blocks), it could halt the entire network.

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH**

The vulnerability can be triggered through multiple attack vectors:

1. **Shard count mismatch**: An attacker with the ability to influence transaction partitioning could cause the assertion to fail
2. **Global transactions in remote mode**: If the system is configured for remote execution and global transactions are included
3. **Executor shard failures**: Any thread panic or channel communication failure in the executor shards will poison the mutex
4. **Index out of bounds**: If `sharded_output` is empty (due to shard execution failures), the indexing will panic

The vulnerability is especially dangerous because:
- It requires no special permissions - any transaction pattern that triggers the panic paths suffices
- The failure mode is permanent - no automatic recovery mechanism exists
- Multiple independent panic paths increase the attack surface

## Recommendation

**Immediate Fix**: Replace `aptos_infallible::Mutex` with proper error handling that can recover from poisoned mutexes:

```rust
// In execution/executor-service/src/local_executor_helper.rs
pub static SHARDED_BLOCK_EXECUTOR: Lazy<
    Arc<Mutex<ShardedBlockExecutor<CachedStateView, LocalExecutorClient<CachedStateView>>>>,
> = Lazy::new(|| {
    info!("LOCAL_SHARDED_BLOCK_EXECUTOR created");
    Arc::new(Mutex::new(
        LocalExecutorClient::create_local_sharded_block_executor(AptosVM::get_num_shards(), None),
    ))
});

// In do_get_execution_output.rs, handle poison errors:
fn execute_block_sharded<V: VMBlockExecutor>(
    partitioned_txns: PartitionedTransactions,
    state_view: Arc<CachedStateView>,
    onchain_config: BlockExecutorConfigFromOnchain,
) -> Result<Vec<TransactionOutput>> {
    let executor = if !get_remote_addresses().is_empty() {
        REMOTE_SHARDED_BLOCK_EXECUTOR
            .lock()
            .unwrap_or_else(|poisoned| {
                error!("REMOTE_SHARDED_BLOCK_EXECUTOR was poisoned, recovering");
                poisoned.into_inner()
            })
    } else {
        SHARDED_BLOCK_EXECUTOR
            .lock()
            .unwrap_or_else(|poisoned| {
                error!("SHARDED_BLOCK_EXECUTOR was poisoned, recovering");
                poisoned.into_inner()
            })
    };
    
    Ok(V::execute_block_sharded(
        &executor,
        partitioned_txns,
        state_view,
        onchain_config,
    )?)
}
```

**Additional Hardening**:
1. Replace all `assert!`, `panic!`, and `.unwrap()` calls in the execution path with proper `Result`-based error handling
2. Add recovery mechanisms for shard communication failures
3. Implement graceful degradation when shards fail (e.g., fall back to unsharded execution)
4. Add monitoring/alerting for mutex poison events

## Proof of Concept

```rust
#[cfg(test)]
mod poison_test {
    use super::*;
    use std::sync::Arc;
    use std::panic;
    
    #[test]
    fn test_mutex_poisoning_causes_permanent_failure() {
        // Simulate a panic while holding the SHARDED_BLOCK_EXECUTOR lock
        let result = panic::catch_unwind(|| {
            let _guard = SHARDED_BLOCK_EXECUTOR.lock();
            // Simulate a panic that could occur during execution
            panic!("Simulated panic during sharded execution");
        });
        
        assert!(result.is_err(), "First panic should occur");
        
        // Now try to acquire the lock again - this should panic due to poison
        let result2 = panic::catch_unwind(|| {
            let _guard = SHARDED_BLOCK_EXECUTOR.lock();
        });
        
        assert!(result2.is_err(), "Second lock attempt should panic due to poison");
        
        // Demonstrate that all future attempts fail
        for i in 0..5 {
            let result = panic::catch_unwind(|| {
                let _guard = SHARDED_BLOCK_EXECUTOR.lock();
            });
            assert!(result.is_err(), "Lock attempt {} should fail due to persistent poison", i);
        }
    }
    
    #[test]
    fn test_shard_count_mismatch_triggers_panic() {
        // Create partitioned transactions with wrong number of shards
        let wrong_shard_count = PartitionedTransactions::with_wrong_shard_count();
        
        let result = panic::catch_unwind(|| {
            execute_block_sharded::<AptosVM>(
                wrong_shard_count,
                Arc::new(mock_state_view()),
                mock_onchain_config(),
            )
        });
        
        assert!(result.is_err(), "Shard count mismatch should trigger panic");
    }
}
```

## Notes

This vulnerability represents a systemic design flaw in the error handling strategy for the block executor. The use of "infallible" mutexes that convert errors into panics creates unrecoverable failure modes that are fundamentally incompatible with the high-availability requirements of a blockchain validator. The fix requires both immediate patching of the mutex handling and a broader review of panic-based error handling throughout the execution pipeline.

### Citations

**File:** crates/aptos-infallible/src/mutex.rs (L19-23)
```rust
    pub fn lock(&self) -> MutexGuard<'_, T> {
        self.0
            .lock()
            .expect("Cannot currently handle a poisoned lock")
    }
```

**File:** execution/executor-service/src/local_executor_helper.rs (L14-21)
```rust
pub static SHARDED_BLOCK_EXECUTOR: Lazy<
    Arc<Mutex<ShardedBlockExecutor<CachedStateView, LocalExecutorClient<CachedStateView>>>>,
> = Lazy::new(|| {
    info!("LOCAL_SHARDED_BLOCK_EXECUTOR created");
    Arc::new(Mutex::new(
        LocalExecutorClient::create_local_sharded_block_executor(AptosVM::get_num_shards(), None),
    ))
});
```

**File:** execution/executor/src/workflow/do_get_execution_output.rs (L269-274)
```rust
            Ok(V::execute_block_sharded(
                &SHARDED_BLOCK_EXECUTOR.lock(),
                partitioned_txns,
                state_view,
                onchain_config,
            )?)
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/mod.rs (L80-85)
```rust
        assert_eq!(
            num_executor_shards,
            transactions.num_shards(),
            "Block must be partitioned into {} sub-blocks",
            num_executor_shards
        );
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/mod.rs (L98-98)
```rust
        let num_rounds = sharded_output[0].len();
```

**File:** execution/executor-service/src/remote_executor_client.rs (L190-192)
```rust
        if !global_txns.is_empty() {
            panic!("Global transactions are not supported yet");
        }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/local_executor_shard.rs (L169-172)
```rust
            results.push(
                rx.recv()
                    .unwrap_or_else(|_| panic!("Did not receive output from shard {}", i))?,
            );
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/local_executor_shard.rs (L193-200)
```rust
            self.command_txs[i]
                .send(ExecutorShardCommand::ExecuteSubBlocks(
                    state_view.clone(),
                    sub_blocks_for_shard,
                    concurrency_level_per_shard,
                    onchain_config.clone(),
                ))
                .unwrap();
```
