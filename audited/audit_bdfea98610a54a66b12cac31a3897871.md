# Audit Report

## Title
Validator Transaction Pool Permanent Starvation Due to Size-Based Filtering Logic Flaw

## Summary
The `pull()` function in the validator transaction pool uses a size-based filter that permanently excludes transactions exceeding the available `max_bytes` quota, causing critical validator transactions (such as DKG results) to never be included in blocks if their serialized size consistently exceeds the quota available during block formation. This can lead to consensus liveness failure and network halt.

## Finding Description

The validator transaction pool's `pull()` method implements a filtering mechanism that only selects transactions where `size_in_bytes() <= max_bytes`. [1](#0-0) 

The critical flaw is in the iteration logic: transactions that fail the size check are **skipped** by the filter but remain in the pool indefinitely. [2](#0-1) 

**Attack Scenario:**

1. A DKG transcript transaction is added to the pool with a size of 1.5 MB (realistic for ~10,000 validators based on the size formula: `96 + (n+1) * 144 bytes`). [3](#0-2) 

2. During block formation, consensus calls `pull()` with `max_bytes = 1,048,576` (1 MB) due to block space constraints or configuration. [4](#0-3) 

3. The DKG transcript (1.5 MB) fails the filter condition `1,572,864 <= 1,048,576` and is excluded from the result set.

4. On subsequent `pull()` calls, `seq_num_lower_bound` resets to 0, and the same transaction is checked again and filtered out again.

5. The DKG transcript **never** gets included in any block, preventing the network from completing the DKG ceremony needed for epoch transitions. [5](#0-4) 

This breaks the consensus liveness invariant because DKG results are **required** for epoch transitions, and without them, the network cannot proceed to the next epoch, resulting in a complete halt.

## Impact Explanation

**Critical Severity** - This vulnerability can cause:

1. **Total loss of liveness/network availability**: If DKG transcripts cannot be included in blocks, the network cannot transition to the next epoch, resulting in permanent liveness failure. [6](#0-5) 

2. **Non-recoverable network partition**: Once the starvation condition occurs, manual intervention or a hard fork would be required to resolve it.

3. **Consensus Safety Violation**: The inability to process validator transactions breaks the fundamental assumption that all valid protocol messages can eventually be processed.

The default per-block limit for validator transactions is 2 MB. [7](#0-6)  A DKG transcript for 10,000 validators would be approximately 1.44 MB, and for 14,562+ validators would exceed 2 MB, triggering permanent starvation.

## Likelihood Explanation

**Current State**: Low likelihood on existing networks with <1,000 validators where DKG transcripts are <200 KB.

**Future Risk**: High likelihood as the network scales:
- With 10,000 validators: DKG transcripts ~1.44 MB (approaching the 2 MB limit)
- With 15,000+ validators: DKG transcripts >2 MB (guaranteed starvation)
- Any scenario where `max_bytes` quota is reduced below transaction size during `pull()` calls

The vulnerability can manifest naturally **without malicious actors** as validator sets grow, or if block formation logic allocates insufficient quota for validator transactions.

## Recommendation

Implement a multi-stage pull mechanism that guarantees progress for oversized transactions:

```rust
pub fn pull(
    &mut self,
    deadline: Instant,
    mut max_items: u64,
    mut max_bytes: u64,
    filter: TransactionFilter,
) -> Vec<ValidatorTransaction> {
    let mut ret = vec![];
    let mut seq_num_lower_bound = 0;
    let mut found_oversized = false;

    while max_items >= 1 && max_bytes >= 1 {
        if let Some(seq_num) = self
            .txn_queue
            .range(seq_num_lower_bound..)
            .filter(|(_, item)| {
                item.txn.size_in_bytes() as u64 <= max_bytes
                    && !filter.should_exclude(&item.txn)
            })
            .map(|(seq_num, _)| *seq_num)
            .next()
        {
            // ... existing logic ...
        } else {
            // If no transaction fits, check if there's an oversized one
            if !found_oversized {
                if let Some((seq_num, item)) = self
                    .txn_queue
                    .range(seq_num_lower_bound..)
                    .filter(|(_, item)| !filter.should_exclude(&item.txn))
                    .next()
                {
                    // Found an oversized transaction that should be pulled alone
                    ret.push(item.txn.as_ref().clone());
                    warn!(
                        "Pulling oversized validator transaction (size: {} bytes, limit: {} bytes)",
                        item.txn.size_in_bytes(),
                        max_bytes
                    );
                    found_oversized = true;
                }
            }
            break;
        }
    }

    ret
}
```

Additionally, add validation when creating DKG transcripts to ensure they don't exceed the per-block limit. [8](#0-7) 

## Proof of Concept

```rust
#[test]
fn test_oversized_transaction_starvation() {
    use crate::{TransactionFilter, VTxnPoolState};
    use aptos_types::validator_txn::{Topic, ValidatorTransaction};
    use std::sync::Arc;
    use std::time::{Duration, Instant};

    let pool = VTxnPoolState::default();
    
    // Create an oversized transaction (simulating large DKG transcript)
    let large_payload = vec![0xFF; 2_000_000]; // 2MB transaction
    let large_txn = ValidatorTransaction::dummy(large_payload);
    
    // Add to pool
    let _guard = pool.put(
        Topic::DKG,
        Arc::new(large_txn.clone()),
        None,
    );
    
    // Try to pull with 1MB limit (simulating limited block space)
    let pulled = pool.pull(
        Instant::now() + Duration::from_secs(10),
        99,
        1_048_576, // 1 MB max_bytes
        TransactionFilter::default(),
    );
    
    // Transaction is NOT pulled due to size constraint
    assert_eq!(pulled.len(), 0, "Oversized transaction should not be pulled");
    
    // Multiple subsequent pulls also fail
    for _ in 0..10 {
        let pulled = pool.pull(
            Instant::now() + Duration::from_secs(10),
            99,
            1_048_576,
            TransactionFilter::default(),
        );
        assert_eq!(pulled.len(), 0, "Transaction remains starved");
    }
    
    // This demonstrates permanent starvation - the transaction
    // can NEVER be included in a block with the current logic
}
```

**Notes**

The vulnerability stems from the unconditional filtering logic that excludes transactions based solely on current quota availability, without any fallback mechanism for critical protocol transactions. While validator transaction sizes are typically bounded by cryptographic parameters [9](#0-8) , the pool implementation makes no guarantees about eventual inclusion of oversized but valid transactions. This is particularly critical for DKG transcripts [10](#0-9)  which are essential for epoch transitions and network liveness.

### Citations

**File:** crates/validator-transaction-pool/src/lib.rs (L152-199)
```rust
    pub fn pull(
        &mut self,
        deadline: Instant,
        mut max_items: u64,
        mut max_bytes: u64,
        filter: TransactionFilter,
    ) -> Vec<ValidatorTransaction> {
        let mut ret = vec![];
        let mut seq_num_lower_bound = 0;

        // Check deadline at the end of every iteration to ensure validator txns get a chance no matter what current proposal delay is.
        while max_items >= 1 && max_bytes >= 1 {
            // Find the seq_num of the first txn that satisfies the quota.
            if let Some(seq_num) = self
                .txn_queue
                .range(seq_num_lower_bound..)
                .filter(|(_, item)| {
                    item.txn.size_in_bytes() as u64 <= max_bytes
                        && !filter.should_exclude(&item.txn)
                })
                .map(|(seq_num, _)| *seq_num)
                .next()
            {
                // Update the quota usage.
                // Send the pull notification if requested.
                let PoolItem {
                    txn,
                    pull_notification_tx,
                    ..
                } = self.txn_queue.get(&seq_num).unwrap();
                if let Some(tx) = pull_notification_tx {
                    let _ = tx.push((), txn.clone());
                }
                max_items -= 1;
                max_bytes -= txn.size_in_bytes() as u64;
                seq_num_lower_bound = seq_num + 1;
                ret.push(txn.as_ref().clone());

                if Instant::now() >= deadline {
                    break;
                }
            } else {
                break;
            }
        }

        ret
    }
```

**File:** crates/aptos-dkg/tests/pvss.rs (L405-413)
```rust
fn expected_transcript_size<T: Transcript<SecretSharingConfig = ThresholdConfigBlstrs>>(
    sc: &ThresholdConfigBlstrs,
) -> usize {
    if T::scheme_name() == unweighted_protocol::DAS_SK_IN_G1 {
        G2_PROJ_NUM_BYTES
            + (sc.get_total_num_players() + 1) * (G2_PROJ_NUM_BYTES + G1_PROJ_NUM_BYTES)
    } else {
        panic!("Did not implement support for '{}' yet", T::scheme_name())
    }
```

**File:** consensus/src/payload_client/mixed.rs (L67-79)
```rust
            .pull(
                params.max_poll_time,
                min(
                    params.max_txns.count(),
                    self.validator_txn_config.per_block_limit_txn_count(),
                ),
                min(
                    params.max_txns.size_in_bytes(),
                    self.validator_txn_config.per_block_limit_total_bytes(),
                ),
                validator_txn_filter,
            )
            .await;
```

**File:** dkg/src/dkg_manager/mod.rs (L397-409)
```rust
                let txn = ValidatorTransaction::DKGResult(DKGTranscript {
                    metadata: DKGTranscriptMetadata {
                        epoch: self.epoch_state.epoch,
                        author: self.my_addr,
                    },
                    transcript_bytes: bcs::to_bytes(&agg_trx)
                        .map_err(|e| anyhow!("transcript serialization error: {e}"))?,
                });
                let vtxn_guard = self.vtxn_pool.put(
                    Topic::DKG,
                    Arc::new(txn),
                    Some(self.pull_notification_tx.clone()),
                );
```

**File:** types/src/on_chain_config/consensus_config.rs (L125-127)
```rust
const VTXN_CONFIG_PER_BLOCK_LIMIT_TXN_COUNT_DEFAULT: u64 = 2;
const VTXN_CONFIG_PER_BLOCK_LIMIT_TOTAL_BYTES_DEFAULT: u64 = 2097152; //2MB

```

**File:** types/src/validator_txn.rs (L32-34)
```rust
    pub fn size_in_bytes(&self) -> usize {
        bcs::serialized_size(self).unwrap()
    }
```

**File:** crates/aptos-crypto/src/blstrs/mod.rs (L28-31)
```rust
pub const G1_PROJ_NUM_BYTES: usize = 48;

/// The size in bytes of a compressed G2 point (efficiently deserializable into projective coordinates)
pub const G2_PROJ_NUM_BYTES: usize = 96;
```

**File:** types/src/dkg/mod.rs (L49-54)
```rust
#[derive(Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct DKGTranscript {
    pub metadata: DKGTranscriptMetadata,
    #[serde(with = "serde_bytes")]
    pub transcript_bytes: Vec<u8>,
}
```
