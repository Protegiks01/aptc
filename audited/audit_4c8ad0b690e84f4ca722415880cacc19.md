# Audit Report

## Title
Missing File Permission Validation for Sensitive Authentication Token Files

## Summary
The `Token::FromDisk` function reads GitHub API tokens and Vault authentication tokens from disk without validating that the files have restrictive permissions (e.g., 0600). This allows any local user on the system to read these sensitive credentials if the files were created with permissive permissions.

## Finding Description

The `read_file` function in `config/src/config/secure_backend_config.rs` reads token files without checking their permissions: [1](#0-0) 

This function is called when loading tokens via `Token::FromDisk`: [2](#0-1) 

These tokens are used in two critical security contexts:

1. **GitHub API Access**: Used for genesis setup with full repository permissions (`repo:*`): [3](#0-2) [4](#0-3) 

2. **Vault Authentication**: Used to access HashiCorp Vault storing validator cryptographic keys and consensus safety rules: [5](#0-4) 

The codebase establishes patterns for **writing** files with restrictive permissions (0600): [6](#0-5) 

However, there is **no validation** when **reading** these sensitive token files to ensure they have restrictive permissions. If an operator creates the token file with default umask (e.g., 0644 on many Linux systems), any local user can read the token.

## Impact Explanation

**High Severity** per bug bounty criteria - this qualifies as a "Significant protocol violation" because:

- **GitHub Token Compromise**: Unauthorized access to genesis configuration repositories could allow modification of blockchain initial state, validator sets, and framework code
- **Vault Token Compromise**: Unauthorized access to validator cryptographic keys and consensus safety rules stored in Vault could compromise validator security
- **Violation of Cryptographic Material Management**: The Aptos secure coding guidelines mandate that cryptographic keys be "stored in protected environments": [7](#0-6) 

However, this requires local system access and operator misconfiguration as prerequisites.

## Likelihood Explanation

**Medium Likelihood**:
- Requires local user access to the validator or genesis setup system
- Depends on operator creating token files with permissive permissions (common with default umask 0022)
- No warnings or checks in the code prevent this misconfiguration
- The code provides functions to write files securely but doesn't enforce reading them securely

## Recommendation

Add file permission validation before reading sensitive token files. Fail or warn if permissions are more permissive than 0600:

```rust
#[cfg(unix)]
fn validate_file_permissions(path: &Path) -> Result<(), Error> {
    use std::os::unix::fs::PermissionsExt;
    let metadata = std::fs::metadata(path)
        .map_err(|e| Error::IO(path.to_str().unwrap().to_string(), e))?;
    let mode = metadata.permissions().mode() & 0o777;
    
    if mode & 0o077 != 0 {
        return Err(Error::UnexpectedError(format!(
            "Token file {} has overly permissive permissions {:o}. Should be 0600 or stricter.",
            path.display(), mode
        )));
    }
    Ok(())
}

fn read_file(path: &Path) -> Result<String, Error> {
    #[cfg(unix)]
    validate_file_permissions(path)?;
    
    let mut file = File::open(path)
        .map_err(|e| Error::IO(path.to_str().unwrap().to_string(), e))?;
    let mut contents = String::new();
    file.read_to_string(&mut contents)
        .map_err(|e| Error::IO(path.to_str().unwrap().to_string(), e))?;
    Ok(contents)
}
```

## Proof of Concept

```rust
#[cfg(test)]
mod permission_test {
    use super::*;
    use std::fs::File;
    use std::io::Write;
    use std::os::unix::fs::PermissionsExt;
    
    #[test]
    fn test_permissive_token_file_vulnerability() {
        let temppath = aptos_temppath::TempPath::new();
        temppath.create_as_file().unwrap();
        
        // Simulate operator creating file with world-readable permissions
        let mut file = File::create(temppath.path()).unwrap();
        file.write_all(b"secret_token_12345").unwrap();
        
        // Set permissions to 0644 (world-readable)
        let mut perms = std::fs::metadata(temppath.path()).unwrap().permissions();
        perms.set_mode(0o644);
        std::fs::set_permissions(temppath.path(), perms).unwrap();
        
        // Current code reads the file successfully without validation
        let token = Token::FromDisk(temppath.path().to_path_buf());
        assert_eq!("secret_token_12345", token.read_token().unwrap());
        
        // This demonstrates any local user can read the token
        // Expected behavior: should fail with permission error
    }
}
```

## Notes

This vulnerability represents a defense-in-depth failure where the code trusts operator-created files without validation. While the primary responsibility lies with operators to create files with correct permissions, the codebase should defensively validate these permissions to prevent accidental exposure of credentials.

### Citations

**File:** config/src/config/secure_backend_config.rs (L108-115)
```rust
impl Token {
    pub fn read_token(&self) -> Result<String, Error> {
        match self {
            Token::FromDisk(path) => read_file(path),
            Token::FromConfig(token) => Ok(token.clone()),
        }
    }
}
```

**File:** config/src/config/secure_backend_config.rs (L153-160)
```rust
fn read_file(path: &Path) -> Result<String, Error> {
    let mut file =
        File::open(path).map_err(|e| Error::IO(path.to_str().unwrap().to_string(), e))?;
    let mut contents = String::new();
    file.read_to_string(&mut contents)
        .map_err(|e| Error::IO(path.to_str().unwrap().to_string(), e))?;
    Ok(contents)
}
```

**File:** config/src/config/secure_backend_config.rs (L174-177)
```rust
            SecureBackend::Vault(config) => {
                let storage = Storage::from(VaultStorage::new(
                    config.server.clone(),
                    config.token.read_token().expect("Unable to read token"),
```

**File:** crates/aptos/src/genesis/git.rs (L98-100)
```rust
    /// Path to Github API token.  Token must have repo:* permissions
    #[clap(long, value_parser)]
    pub(crate) github_token_file: Option<PathBuf>,
```

**File:** crates/aptos/src/genesis/git.rs (L144-156)
```rust
    pub fn github(
        repository: GithubRepo,
        branch: String,
        token_path: PathBuf,
    ) -> CliTypedResult<Client> {
        let token = Token::FromDisk(token_path).read_token()?;
        Ok(Client::Github(GithubClient::new(
            repository.owner,
            repository.repository,
            branch,
            token,
        )))
    }
```

**File:** crates/aptos/src/common/utils.rs (L224-229)
```rust
pub fn write_to_user_only_file(path: &Path, name: &str, bytes: &[u8]) -> CliTypedResult<()> {
    let mut opts = OpenOptions::new();
    #[cfg(unix)]
    opts.mode(0o600);
    write_to_file_with_opts(path, name, bytes, &mut opts)
}
```

**File:** RUST_SECURE_CODING.md (L139-141)
```markdown
### Cryptographic Material Management

Adhere strictly to established protocols for generating, storing, and managing cryptographic keys. This includes using secure random sources for key generation, ensuring keys are stored in protected environments, and implementing robust management practices to handle key lifecycle events like rotation and revocation [Key Management Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Key_Management_Cheat_Sheet.html).
```
