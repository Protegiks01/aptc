# Audit Report

## Title
Race Condition in state_view() Causes Panic and Potential Consensus Divergence Due to Stale State View

## Summary
The `state_view()` function in `BlockExecutor` contains a critical TOCTOU (Time-of-Check-Time-of-Use) race condition where a block's state can become incompatible with the persisted database state between block retrieval and `CachedStateView` creation, causing assertion failures and potential consensus violations.

## Finding Description

The vulnerability exists in the two-step process within `state_view()`: [1](#0-0) 

**The Race Window:**

Between retrieving the block (line 398) and creating the `CachedStateView` (lines 403-407), another thread can commit a different block to the database, updating the persisted state to a version that is incompatible with the retrieved block's state.

**The Root Cause:**

When `CachedStateView::new()` is called, it internally retrieves the persisted state from the database: [2](#0-1) 

This persisted state is then used to create a `StateDelta` with an assertion that requires the block's state to be a descendant of the persisted state: [3](#0-2) 

**Attack Scenario - Fork Commit Race:**

1. BlockTree has two branches from root at V10:
   - Branch A: Block_A (V11) → Block_B (V12)  
   - Branch B: Block_C (V11') → Block_D (V12')

2. Thread 1 calls `state_view(Block_B)`
   - Retrieves Block_B with state V12 (built on layers: V12 → V11 → V10)

3. Thread 2 concurrently calls `commit_ledger(Block_D)` on Branch B:
   - Commits Block_D to database
   - Updates persisted state to V12' (asynchronously via `state_merkle_batch_committer`)
   - Calls `block_tree.prune()` to update root to Block_D [4](#0-3) 

4. Thread 1 continues in `state_view(Block_B)`:
   - Calls `CachedStateView::new()` with Block_B's state V12
   - Retrieves persisted state V12' from database
   - Attempts `StateDelta::new(base=V12', current=V12)`
   - **V12 is NOT a descendant of V12'** (different branches!)
   - Assertion fails → **PANIC**

**No Synchronization Protection:**

The `state_view()` method only acquires a read lock on the `inner` RwLock: [5](#0-4) 

Similarly, `commit_ledger()` also uses a read lock: [6](#0-5) 

This allows both operations to execute concurrently without mutual exclusion.

**Invariant Violations:**

1. **State Consistency**: The `StateDelta` created represents an invalid relationship between speculative and persisted state
2. **Deterministic Execution**: Different validators could see different states if the race occurs at different times, leading to non-deterministic execution results

## Impact Explanation

**High Severity** - This vulnerability causes multiple critical issues:

1. **Node Crashes (Denial of Service)**: The assertion failure causes validator nodes to panic and crash, reducing network availability. If multiple validators experience this simultaneously during fork resolution, network liveness is compromised.

2. **Potential Consensus Divergence**: If the assertion were removed or failed silently, the invalid `StateDelta` could cause:
   - Incorrect state reads during block execution
   - Different validators computing different state roots for the same block
   - Consensus safety violations where validators commit incompatible blocks

3. **API Availability**: The `state_view()` function is used to provide read-only views of blockchain state. Crashes affect API reliability for dApps and users.

This meets **High Severity** criteria per the Aptos bug bounty program:
- Validator node crashes/slowdowns
- API crashes  
- Significant protocol violations

If the issue led to actual consensus splits (state root mismatches), it could escalate to **Critical Severity**.

## Likelihood Explanation

**High Likelihood** in environments with:

1. **Active Forks**: During network partitions or malicious equivocation attempts, multiple block branches exist simultaneously
2. **Concurrent Operations**: High-throughput validators frequently execute `state_view()` calls while committing blocks
3. **State Sync Operations**: Nodes catching up may call `state_view()` on historical blocks while commits are ongoing

The race window exists between database commit (line 390) and BlockTree pruning (line 392), which can span multiple milliseconds depending on system load. During this window, the persisted state is updated but the BlockTree still contains old blocks.

The vulnerability requires no attacker capabilities - it occurs naturally during normal concurrent blockchain operations, especially during fork resolution in consensus.

## Recommendation

**Solution: Acquire exclusive lock or ensure version consistency**

**Option 1 - Add Version Check (Recommended):**

```rust
fn state_view(&self, block_id: HashValue) -> ExecutorResult<CachedStateView> {
    // Get the committed version before retrieving the block
    let committed_version = self.db.reader.get_latest_version()?;
    
    let mut block_vec = self.block_tree.get_blocks_opt(&[block_id])?;
    let block = block_vec
        .pop()
        .expect("Must exist.")
        .ok_or(ExecutorError::BlockNotFound(block_id))?;
    
    // Verify block is still valid against current committed state
    let block_version = block.output.result_state().version();
    if let Some(block_ver) = block_version {
        if block_ver > committed_version {
            // Block is still speculative, safe to use
            Ok(CachedStateView::new(
                StateViewId::BlockExecution { block_id },
                Arc::clone(&self.db.reader),
                block.output.result_state().latest().clone(),
            )?)
        } else {
            // Block may have been invalidated by a commit, reject
            Err(ExecutorError::InternalError {
                error: format!("Block {} may be stale", block_id),
            }.into())
        }
    } else {
        // Pre-genesis block, safe
        Ok(CachedStateView::new(
            StateViewId::BlockExecution { block_id },
            Arc::clone(&self.db.reader),
            block.output.result_state().latest().clone(),
        )?)
    }
}
```

**Option 2 - Cache Persisted State Snapshot:**

Modify `CachedStateView::new()` to accept an optional persisted state parameter, allowing `state_view()` to retrieve it once before getting the block, ensuring consistency.

**Option 3 - Use Execution Lock:**

Extend the `execution_lock` scope to cover state view creation, preventing commits during state view operations (may impact performance).

## Proof of Concept

```rust
use std::sync::{Arc, Barrier};
use std::thread;

// Reproduction scenario (pseudocode - requires test harness):
fn test_state_view_race() {
    let executor = /* initialize BlockExecutor */;
    let barrier = Arc::new(Barrier::new(2));
    
    // Thread 1: Call state_view on a block from branch A
    let executor_clone = executor.clone();
    let barrier_clone = barrier.clone();
    let handle1 = thread::spawn(move || {
        barrier_clone.wait();
        // This should panic when persisted state is updated
        let result = executor_clone.state_view(block_b_id);
        assert!(result.is_err() || result.unwrap().is_ok());
    });
    
    // Thread 2: Commit a block from branch B (different fork)
    let executor_clone = executor.clone();
    let barrier_clone = barrier.clone();
    let handle2 = thread::spawn(move || {
        barrier_clone.wait();
        // Commit branch B, updating persisted state
        executor_clone.commit_ledger(ledger_info_branch_b).unwrap();
    });
    
    // One thread will likely panic due to assertion failure
    handle1.join().unwrap();
    handle2.join().unwrap();
}
```

**Expected Result**: Thread 1 panics with assertion failure `current.is_descendant_of(&base)` when the persisted state is updated to a fork that Block_B is not descended from.

## Notes

The vulnerability is exacerbated by the asynchronous nature of persisted state updates via `state_merkle_batch_committer`: [7](#0-6) 

The comment in `PersistedState` acknowledges version consistency concerns: [8](#0-7) 

This confirms that the codebase is aware of version synchronization challenges between execution and storage layers, but the `state_view()` function lacks proper protection against this race condition.

### Citations

**File:** execution/executor/src/block_executor/mod.rs (L141-148)
```rust
    fn commit_ledger(&self, ledger_info_with_sigs: LedgerInfoWithSignatures) -> ExecutorResult<()> {
        let _guard = CONCURRENCY_GAUGE.concurrency_with(&["block", "commit_ledger"]);

        self.inner
            .read()
            .as_ref()
            .expect("BlockExecutor is not reset")
            .commit_ledger(ledger_info_with_sigs)
```

**File:** execution/executor/src/block_executor/mod.rs (L157-160)
```rust
    fn state_view(&self, block_id: HashValue) -> ExecutorResult<CachedStateView> {
        self.maybe_initialize()?;
        self.inner.read().as_ref().unwrap().state_view(block_id)
    }
```

**File:** execution/executor/src/block_executor/mod.rs (L387-392)
```rust
        let target_version = ledger_info_with_sigs.ledger_info().version();
        self.db
            .writer
            .commit_ledger(target_version, Some(&ledger_info_with_sigs), None)?;

        self.block_tree.prune(ledger_info_with_sigs.ledger_info())?;
```

**File:** execution/executor/src/block_executor/mod.rs (L397-408)
```rust
    fn state_view(&self, block_id: HashValue) -> ExecutorResult<CachedStateView> {
        let mut block_vec = self.block_tree.get_blocks_opt(&[block_id])?;
        let block = block_vec
            .pop()
            .expect("Must exist.")
            .ok_or(ExecutorError::BlockNotFound(block_id))?;
        Ok(CachedStateView::new(
            StateViewId::BlockExecution { block_id },
            Arc::clone(&self.db.reader),
            block.output.result_state().latest().clone(),
        )?)
    }
```

**File:** storage/storage-interface/src/state_store/state_view/cached_state_view.rs (L126-135)
```rust
    pub fn new(id: StateViewId, reader: Arc<dyn DbReader>, state: State) -> StateViewResult<Self> {
        let (hot_state, persisted_state) = reader.get_persisted_state()?;
        Ok(Self::new_impl(
            id,
            reader,
            hot_state,
            persisted_state,
            state,
        ))
    }
```

**File:** storage/storage-interface/src/state_store/state_delta.rs (L27-38)
```rust
    pub fn new(base: State, current: State) -> Self {
        assert!(current.is_descendant_of(&base));

        let shards = Arc::new(std::array::from_fn(|shard_id| {
            current.shards()[shard_id].view_layers_after(&base.shards()[shard_id])
        }));

        Self {
            base,
            current,
            shards,
        }
```

**File:** storage/aptosdb/src/state_store/state_merkle_batch_committer.rs (L106-106)
```rust
                    self.persisted_state.set(snapshot);
```

**File:** storage/aptosdb/src/state_store/persisted_state.rs (L53-58)
```rust
        // n.b. Summary must be updated before committing the hot state, otherwise in the execution
        // pipeline we risk having a state generated based on a persisted version (v2) that's newer
        // than that of the summary (v1). That causes issue down the line where we commit the diffs
        // between a later snapshot (v3) and a persisted snapshot (v1) to the JMT, at which point
        // we will not be able to calculate the difference (v1 - v3) because the state links only
        // to as far as v2 (code will panic)
```
