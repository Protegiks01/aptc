# Audit Report

## Title
Indexer Metadata Version Inconsistency Leading to Incomplete Query Results

## Summary
The internal indexer's `ensure_cover_ledger_version()` validation function only checks `LatestVersion` metadata, not feature-specific versions (`TransactionVersion`, `EventVersion`, `StateVersion`). When indexer features are partially enabled, `LatestVersion` advances while disabled feature versions lag behind, allowing clients to query at ledger versions beyond the actual indexed data range and receive incomplete results without error.

## Finding Description
In `DBIndexer::process_a_batch()`, metadata updates are conditionally performed based on feature flags: [1](#0-0) 

However, `LatestVersion` is always updated regardless of which features are enabled: [2](#0-1) 

The critical flaw lies in the `ensure_cover_ledger_version()` function, which validates client queries by only checking `LatestVersion`: [3](#0-2) 

This validation is used before serving all client queries: [4](#0-3) [5](#0-4) 

**Exploitation Scenario:**

1. Node indexes versions 0-1000 with `transaction_enabled=true`, `event_enabled=true`, `statekeys_enabled=true`
   - `LatestVersion = 1000`, `TransactionVersion = 1000`, `EventVersion = 1000`, `StateVersion = 1000`

2. Node operator reconfigures with `transaction_enabled=false`, `event_enabled=true`, `statekeys_enabled=true` (as seen in production configs: [6](#0-5) )

3. Node processes versions 1001-2000:
   - Transaction indexing is skipped ( [7](#0-6) )
   - `LatestVersion = 2000`, `TransactionVersion = 1000`, `EventVersion = 2000`, `StateVersion = 2000`

4. Client queries: `get_account_ordered_transactions(address, start_seq=0, limit=100, ledger_version=1500)`
   - Version check passes: `LatestVersion (2000) >= 1500` ✓
   - Query proceeds but `OrderedTransactionByAccountSchema` only contains data up to version 1000
   - **Returns incomplete transaction list without error**

The iterator ( [8](#0-7) ) will simply stop when it runs out of indexed data, providing no indication that transactions from versions 1001-1500 exist but were not indexed.

## Impact Explanation
**Medium Severity** - This qualifies as "State inconsistencies requiring intervention" per the bug bounty program. 

Clients relying on indexer data will:
- Receive incomplete transaction histories for accounts
- Miss events that occurred during gaps in indexing
- See partial state key information
- Have no indication that data is incomplete (no error returned)

This breaks the **State Consistency** invariant: clients expect that if a query succeeds for a ledger version within the indexed range, all data at that version is available. This can lead to:
- Incorrect balance calculations in wallets/explorers
- Missing transaction notifications
- Incomplete audit trails
- Potential financial miscalculations by dependent services

However, this does NOT directly cause:
- Consensus violations (validators are unaffected)
- Fund loss (blockchain state remains correct)
- Network disruption (only indexer API is affected)

## Likelihood Explanation
**Medium Likelihood** - This requires specific conditions:

1. Node operator must change indexer feature flags after initial deployment (configuration change)
2. Partial feature enablement must occur (evidence shows this is used in production: [9](#0-8) )
3. Clients must query during the period when version gaps exist

The `get_start_version()` function attempts to detect version mismatches when features are re-enabled ( [10](#0-9) ), but this only prevents restart, not the initial inconsistency while a feature is disabled.

## Recommendation

Modify `ensure_cover_ledger_version()` to check feature-specific versions based on the query type:

```rust
// Add feature-specific version checks
pub fn ensure_cover_ledger_version_for_transactions(&self, ledger_version: Version) -> Result<()> {
    if !self.transaction_enabled() {
        bail!("Transaction indexing is not enabled")
    }
    let txn_version = self.get_transaction_version()?;
    if let Some(txn_version) = txn_version {
        if txn_version >= ledger_version {
            return Ok(());
        }
    }
    bail!("ledger version too new for transaction indexer")
}

pub fn ensure_cover_ledger_version_for_events(&self, ledger_version: Version) -> Result<()> {
    if !self.event_enabled() {
        bail!("Event indexing is not enabled")
    }
    let event_version = self.get_event_version()?;
    if let Some(event_version) = event_version {
        if event_version >= ledger_version {
            return Ok(());
        }
    }
    bail!("ledger version too new for event indexer")
}

pub fn ensure_cover_ledger_version_for_state(&self, ledger_version: Version) -> Result<()> {
    if !self.statekeys_enabled() {
        bail!("State key indexing is not enabled")
    }
    let state_version = self.get_state_version()?;
    if let Some(state_version) = state_version {
        if state_version >= ledger_version {
            return Ok(());
        }
    }
    bail!("ledger version too new for state indexer")
}
```

Then update query functions to use the appropriate check:
- `get_account_ordered_transactions` → `ensure_cover_ledger_version_for_transactions`
- `get_events` → `ensure_cover_ledger_version_for_events`
- `get_prefixed_state_value_iterator` → `ensure_cover_ledger_version_for_state`

## Proof of Concept

```rust
#[cfg(test)]
mod version_mismatch_test {
    use super::*;
    use aptos_temppath::TempPath;
    use aptos_types::account_address::AccountAddress;
    
    #[test]
    fn test_partial_indexing_inconsistency() {
        // Setup: Create indexer DB with all features enabled
        let tmpdir = TempPath::new();
        let mut config = InternalIndexerDBConfig::default();
        config.enable_transaction = true;
        config.enable_event = true;
        config.enable_statekeys = true;
        
        let db = create_test_db(&tmpdir);
        let indexer_db = InternalIndexerDB::new(db.clone(), config);
        let main_db = create_mock_main_db();
        let indexer = DBIndexer::new(indexer_db.clone(), main_db.clone());
        
        // Index versions 0-100 with all features
        indexer.process(0, 100).unwrap();
        
        // Verify all versions are at 100
        assert_eq!(indexer_db.get_persisted_version().unwrap(), Some(100));
        assert_eq!(indexer_db.get_transaction_version().unwrap(), Some(100));
        assert_eq!(indexer_db.get_event_version().unwrap(), Some(100));
        
        // Reconfigure: Disable transaction indexing
        let mut new_config = InternalIndexerDBConfig::default();
        new_config.enable_transaction = false;  // DISABLED
        new_config.enable_event = true;
        new_config.enable_statekeys = true;
        
        let indexer_db2 = InternalIndexerDB::new(db.clone(), new_config);
        let indexer2 = DBIndexer::new(indexer_db2.clone(), main_db.clone());
        
        // Process versions 101-200 (transactions NOT indexed)
        indexer2.process(101, 200).unwrap();
        
        // BUG: LatestVersion advances but TransactionVersion does not
        assert_eq!(indexer_db2.get_persisted_version().unwrap(), Some(200)); // Advanced!
        assert_eq!(indexer_db2.get_transaction_version().unwrap(), Some(100)); // Lagged!
        
        // VULNERABILITY: Query at version 150 passes validation
        let address = AccountAddress::random();
        let result = indexer2.get_account_ordered_transactions(
            address,
            0,
            100,
            false,
            150  // Within LatestVersion but beyond TransactionVersion
        );
        
        // Query succeeds but returns incomplete data (missing txns 101-150)
        assert!(result.is_ok()); // Should have failed with "ledger version too new"
        
        // Transactions from versions 101-150 are missing in the result
        // but client has no way to know this
    }
}
```

## Notes

This vulnerability exists in the production codebase and can occur when node operators use partial indexer feature configurations. While the `get_start_version()` function provides some protection by panicking when trying to re-enable a disabled feature, it does not prevent the core issue: clients querying during periods when features are disabled receive incomplete data without error indication.

The fix should ensure that feature-specific version checks are performed based on the type of query being executed, providing clear error messages when requested data is not available due to indexing gaps.

### Citations

**File:** storage/indexer/src/db_indexer.rs (L163-172)
```rust
    pub fn ensure_cover_ledger_version(&self, ledger_version: Version) -> Result<()> {
        let indexer_latest_version = self.get_persisted_version()?;
        if let Some(indexer_latest_version) = indexer_latest_version {
            if indexer_latest_version >= ledger_version {
                return Ok(());
            }
        }

        bail!("ledger version too new")
    }
```

**File:** storage/indexer/src/db_indexer.rs (L421-429)
```rust
                if self.indexer_db.transaction_enabled() {
                    if let ReplayProtector::SequenceNumber(seq_num) = signed_txn.replay_protector()
                    {
                        batch.put::<OrderedTransactionByAccountSchema>(
                            &(signed_txn.sender(), seq_num),
                            &version,
                        )?;
                    }
                }
```

**File:** storage/indexer/src/db_indexer.rs (L524-541)
```rust
        if self.indexer_db.transaction_enabled() {
            batch.put::<InternalIndexerMetadataSchema>(
                &MetadataKey::TransactionVersion,
                &MetadataValue::Version(version - 1),
            )?;
        }
        if self.indexer_db.event_enabled() {
            batch.put::<InternalIndexerMetadataSchema>(
                &MetadataKey::EventVersion,
                &MetadataValue::Version(version - 1),
            )?;
        }
        if self.indexer_db.statekeys_enabled() {
            batch.put::<InternalIndexerMetadataSchema>(
                &MetadataKey::StateVersion,
                &MetadataValue::Version(version - 1),
            )?;
        }
```

**File:** storage/indexer/src/db_indexer.rs (L542-545)
```rust
        batch.put::<InternalIndexerMetadataSchema>(
            &MetadataKey::LatestVersion,
            &MetadataValue::Version(version - 1),
        )?;
```

**File:** storage/indexer/src/db_indexer.rs (L594-595)
```rust
        self.indexer_db
            .ensure_cover_ledger_version(ledger_version)?;
```

**File:** storage/indexer/src/db_indexer.rs (L639-640)
```rust
        self.indexer_db
            .ensure_cover_ledger_version(ledger_version)?;
```

**File:** testsuite/forge/src/backend/k8s/helm-values/aptos-node-default-values.yaml (L12-13)
```yaml
    indexer_db_config:
      enable_event: true
```

**File:** testsuite/forge/src/backend/k8s/helm-values/aptos-node-default-values.yaml (L31-32)
```yaml
    indexer_db_config:
      enable_event: true
```

**File:** storage/indexer_schemas/src/utils.rs (L73-117)
```rust
    fn next_impl(&mut self) -> Result<Option<(u64, Version)>> {
        Ok(match self.inner.next().transpose()? {
            Some(((address, seq_num), version)) => {
                // No more transactions sent by this account.
                if address != self.address {
                    return Ok(None);
                }
                if seq_num >= self.end_seq_num {
                    return Ok(None);
                }

                // Ensure seq_num_{i+1} == seq_num_{i} + 1
                if let Some(expected_seq_num) = self.expected_next_seq_num {
                    ensure!(
                        seq_num == expected_seq_num,
                        "DB corruption: account transactions sequence numbers are not contiguous: \
                     actual: {}, expected: {}",
                        seq_num,
                        expected_seq_num,
                    );
                };

                // Ensure version_{i+1} > version_{i}
                if let Some(prev_version) = self.prev_version {
                    ensure!(
                        prev_version < version,
                        "DB corruption: account transaction versions are not strictly increasing: \
                         previous version: {}, current version: {}",
                        prev_version,
                        version,
                    );
                }

                // No more transactions (in this view of the ledger).
                if version > self.ledger_version {
                    return Ok(None);
                }

                self.expected_next_seq_num = Some(seq_num + 1);
                self.prev_version = Some(version);
                Some((seq_num, version))
            },
            None => None,
        })
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-table-info/src/internal_indexer_db_service.rs (L108-139)
```rust
        if node_config.indexer_db_config.enable_statekeys() {
            let state_start_version = self
                .db_indexer
                .indexer_db
                .get_state_version()?
                .map_or(0, |v| v + 1);
            if start_version != state_start_version {
                panic!("Cannot start state indexer because the progress doesn't match.");
            }
        }

        if node_config.indexer_db_config.enable_transaction() {
            let transaction_start_version = self
                .db_indexer
                .indexer_db
                .get_transaction_version()?
                .map_or(0, |v| v + 1);
            if start_version != transaction_start_version {
                panic!("Cannot start transaction indexer because the progress doesn't match.");
            }
        }

        if node_config.indexer_db_config.enable_event() {
            let event_start_version = self
                .db_indexer
                .indexer_db
                .get_event_version()?
                .map_or(0, |v| v + 1);
            if start_version != event_start_version {
                panic!("Cannot start event indexer because the progress doesn't match.");
            }
        }
```
