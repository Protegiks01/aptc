# Audit Report

## Title
Missing Share Verification in Decryption Key Reconstruction API - Defense-in-Depth Failure

## Summary
The `reconstruct_decryption_key()` function and `SecretShare::aggregate()` do not verify shares against verification keys before performing Shamir secret sharing reconstruction. While the current consensus implementation verifies shares at network entry points, the API design lacks enforcement of this critical security invariant at the reconstruction layer, creating a fragile security boundary.

## Finding Description

The batch encryption module implements threshold decryption using Shamir secret sharing, where a decryption key must be reconstructed from `t` shares. The security of this scheme requires that shares be verified against their corresponding verification keys before reconstruction.

**Three-Layer Verification Bypass:**

1. **`FPTXSuccinct::reconstruct_decryption_key()`** directly calls reconstruction without verification: [1](#0-0) 

2. **`BIBEDecryptionKey::reconstruct()`** performs raw Shamir reconstruction without checking shares: [2](#0-1) 

3. **`SecretShare::aggregate()`** extracts and reconstructs shares without calling `verify()`: [3](#0-2) 

**Verification Functions Exist But Are Not Called:**

The codebase provides verification methods that should be used: [4](#0-3) [5](#0-4) 

**Current Protection Mechanisms:**

The consensus implementation DOES verify shares at network entry points: [6](#0-5) [7](#0-6) 

## Impact Explanation

**Current Impact: No Immediate Exploit** - The current consensus implementation verifies all incoming shares before storage, preventing direct exploitation. However, this creates **Critical Technical Debt** because:

1. **API Surface Risk**: Future code modifications could mistakenly call `aggregate()` or `reconstruct_decryption_key()` without ensuring prior verification
2. **Defense-in-Depth Violation**: If a bug exists in the network-layer verification logic, unverified shares could flow through to reconstruction
3. **Cryptographic Invariant Violation**: Threshold cryptography security fundamentally requires that only valid shares participate in reconstruction

If exploited (through future modifications or verification bypass), this would be **Critical Severity** as it could:
- Produce incorrect decryption keys
- Allow attackers to influence reconstructed secrets
- Break the threshold decryption security guarantees
- Potentially affect consensus randomness if decryption keys are used in that context

## Likelihood Explanation

**Current Likelihood: Low** - All identified code paths verify shares before storage. No immediate exploit vector exists for external attackers without validator privileges.

**Future Likelihood: Medium-High** - This is a latent vulnerability waiting for:
- Code refactoring that bypasses verification
- New features using the unsafe API directly
- Bugs in the verification layer that this API doesn't catch

The unsafe API design makes vulnerabilities more likely in future development.

## Recommendation

**Enforce verification at the reconstruction layer:**

1. Modify `reconstruct_decryption_key()` to require verification keys and perform verification before reconstruction
2. Update `SecretShare::aggregate()` to verify all shares before extraction
3. Add verification checks in `BIBEDecryptionKey::reconstruct()`

The test cases already demonstrate the correct pattern: [8](#0-7) 

This verification loop should be moved INTO the reconstruction functions rather than relying on callers to remember it.

## Proof of Concept

While no immediate exploit exists, the following demonstrates the API accepts unverified shares:

```rust
// Hypothetical unsafe usage that the API permits:
let unverified_shares: Vec<BIBEDecryptionKeyShare> = /* forged or corrupted shares */;
let config = ShamirThresholdConfig::new(5, 8);

// This succeeds even with unverified/forged shares - NO verification performed
let decryption_key = FPTXSuccinct::reconstruct_decryption_key(
    &unverified_shares,
    &config
).unwrap();

// The key is now reconstructed from potentially invalid shares
// If verification were enforced here, this would fail
```

The correct usage pattern from tests shows verification SHOULD happen but isn't enforced by the API.

---

**Notes:**

This finding represents a **defense-in-depth failure** rather than an immediately exploitable vulnerability. The current consensus code does verify shares at entry points, but the unsafe API design creates unnecessary risk. The cryptographic security invariant (verify before reconstruct) should be enforced at the lowest level possible, not relied upon at higher layers. This is critical infrastructure for threshold cryptography - the API should be impossible to use incorrectly.

### Citations

**File:** crates/aptos-batch-encryption/src/schemes/fptx_succinct.rs (L149-154)
```rust
    fn reconstruct_decryption_key(
        shares: &[Self::DecryptionKeyShare],
        config: &Self::ThresholdConfig,
    ) -> anyhow::Result<Self::DecryptionKey> {
        BIBEDecryptionKey::reconstruct(config, shares)
    }
```

**File:** crates/aptos-batch-encryption/src/schemes/fptx_succinct.rs (L178-184)
```rust
    fn verify_decryption_key_share(
        verification_key_share: &Self::VerificationKey,
        digest: &Self::Digest,
        decryption_key_share: &Self::DecryptionKeyShare,
    ) -> anyhow::Result<()> {
        verification_key_share.verify_decryption_key_share(digest, decryption_key_share)
    }
```

**File:** crates/aptos-batch-encryption/src/shared/key_derivation.rs (L166-184)
```rust
impl Reconstructable<ShamirThresholdConfig<Fr>> for BIBEDecryptionKey {
    type ShareValue = BIBEDecryptionKeyShareValue;

    fn reconstruct(
        threshold_config: &ShamirThresholdConfig<Fr>,
        shares: &[BIBEDecryptionKeyShare],
    ) -> Result<Self> {
        let signature_g1 = G1Affine::reconstruct(
            threshold_config,
            &shares
                .iter()
                .map(|share| (share.0, share.1.signature_share_eval))
                .collect::<Vec<ShamirGroupShare<G1Affine>>>(),
        )?;

        // sanity check
        Ok(Self { signature_g1 })
    }
}
```

**File:** types/src/secret_sharing.rs (L75-82)
```rust
    pub fn verify(&self, config: &SecretShareConfig) -> anyhow::Result<()> {
        let index = config.get_id(self.author());
        let decryption_key_share = self.share().clone();
        // TODO(ibalajiarun): Check index out of bounds
        config.verification_keys[index]
            .verify_decryption_key_share(&self.metadata.digest, &decryption_key_share)?;
        Ok(())
    }
```

**File:** types/src/secret_sharing.rs (L84-99)
```rust
    pub fn aggregate<'a>(
        dec_shares: impl Iterator<Item = &'a SecretShare>,
        config: &SecretShareConfig,
    ) -> anyhow::Result<DecryptionKey> {
        let threshold = config.threshold();
        let shares: Vec<SecretKeyShare> = dec_shares
            .map(|dec_share| dec_share.share.clone())
            .take(threshold as usize)
            .collect();
        let decryption_key =
            <FPTXWeighted as BatchThresholdEncryption>::reconstruct_decryption_key(
                &shares,
                &config.config,
            )?;
        Ok(decryption_key)
    }
```

**File:** consensus/src/rand/secret_sharing/secret_share_manager.rs (L218-226)
```rust
                    match bcs::from_bytes::<SecretShareMessage>(dec_msg.req.data()) {
                        Ok(msg) => {
                            if msg.verify(&epoch_state_clone, &config_clone).is_ok() {
                                let _ = tx.unbounded_send(SecretShareRpc {
                                    msg,
                                    protocol: dec_msg.protocol,
                                    response_sender: dec_msg.response_sender,
                                });
                            }
```

**File:** consensus/src/rand/secret_sharing/reliable_broadcast_state.rs (L44-60)
```rust
    fn add(&self, peer: Author, share: Self::Response) -> anyhow::Result<Option<()>> {
        ensure!(share.author() == &peer, "Author does not match");
        ensure!(
            share.metadata() == &self.secret_share_metadata,
            "Metadata does not match: local {:?}, received {:?}",
            self.secret_share_metadata,
            share.metadata()
        );
        share.verify(&self.secret_share_config)?;
        info!(LogSchema::new(LogEvent::ReceiveReactiveSecretShare)
            .epoch(share.epoch())
            .round(share.metadata().round)
            .remote_peer(*share.author()));
        let mut store = self.secret_share_store.lock();
        let aggregated = store.add_share(share)?.then_some(());
        Ok(aggregated)
    }
```

**File:** crates/aptos-batch-encryption/src/tests/fptx_succinct_smoke.rs (L33-38)
```rust
    dk_shares
        .iter()
        .zip(&vks)
        .map(|(dk_share, vk)| FPTXSuccinct::verify_decryption_key_share(vk, &d, dk_share))
        .collect::<Result<Vec<()>>>()
        .unwrap();
```
