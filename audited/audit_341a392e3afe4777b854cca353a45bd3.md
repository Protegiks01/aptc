# Audit Report

## Title
Race Condition in Block Epilogue Abort Protocol Causes Incorrect Incarnation State

## Summary
The `prepare_for_block_epilogue()` function violates the documented two-step abort protocol by calling `start_abort()` without a corresponding `finish_abort()` call. This creates a race condition where concurrent worker threads attempting to abort the block epilogue transaction will fail with a `PanicError` when they try to complete their abort operations, potentially disrupting block finalization.

## Finding Description

The `prepare_for_block_epilogue()` function in `scheduler_status.rs` violates a critical invariant documented in the same file. [1](#0-0) 

The documentation clearly states that "A successful [ExecutionStatuses::start_abort] must be followed by a [ExecutionStatuses::finish_abort] call on the status."

However, the `prepare_for_block_epilogue()` implementation violates this protocol: [2](#0-1) 

At line 479, the function calls `start_abort()` but then directly manipulates the transaction status by calling `to_pending_scheduling()` at lines 480-485, completely bypassing the required `finish_abort()` call.

**Race Condition Scenario:**

During parallel execution in BlockSTMv2, the block epilogue transaction can be speculatively executed. When dependencies change:

1. **Worker Thread A** (processing transaction dependency changes):
   - Detects that block epilogue transaction at index N needs to be aborted
   - Successfully calls `start_abort(N, incarnation=0)`, setting `next_incarnation_to_abort = 1`
   - Is about to call `finish_abort(N, 0, false)` to complete the two-step protocol

2. **Main Thread** (after scheduler halts, in `finalize_parallel_execution`):
   - Calls `prepare_for_block_epilogue(N)`
   - Acquires status lock, reads `incarnation=0, status=Executed`
   - Calls `start_abort(N, 0)` - returns `Ok(false)` (already aborted by Worker A)
   - Calls `to_pending_scheduling(N, incarnation=1)` - directly modifies status
   - Calls `to_executing()` - sets status to `Executing(incarnation=1)`
   - Returns `incarnation=1`

3. **Worker Thread A** (continues):
   - Calls `finish_abort(N, 0, false)`
   - Checks `next_incarnation_to_abort == 1` âœ“
   - Acquires lock, reads `incarnation=1, status=Executing`
   - Checks `never_started_execution(0)`: [3](#0-2) 

   - Returns **true** because `incarnation(1) > aborted_incarnation(0)`
   - Returns `PanicError`: "Finish abort of incarnation 0, but inner status Executing(incarnation=1)" [4](#0-3) 

The `finish_abort()` validation fails because `prepare_for_block_epilogue()` violated the abort protocol by manipulating the incarnation state without properly completing the abort sequence.

## Impact Explanation

This qualifies as **High Severity** under the Aptos Bug Bounty criteria:

- **Validator node slowdowns**: The `PanicError` in worker threads can cause parallel execution to fail, forcing fallback to sequential execution or requiring block re-execution
- **Protocol violations**: The violation of the documented two-step abort protocol breaks a fundamental invariant of the transaction status state machine
- **Block finalization disruption**: If the error propagates, it can prevent proper block epilogue execution, which is responsible for fee distribution to validators

The race condition affects the **Deterministic Execution** invariant - while all validators would experience the same race condition (maintaining consensus), the unpredictable failure breaks the reliability guarantee that blocks should finalize consistently.

## Likelihood Explanation

**Moderate to High Likelihood:**

- The race condition window exists whenever:
  1. Block epilogue transaction is speculatively executed during parallel processing
  2. A dependency changes requiring the epilogue to be aborted
  3. The abort sequence overlaps with the finalization phase

- This is more likely to occur under:
  - High transaction throughput (more parallel workers active)
  - Blocks with complex dependencies involving the epilogue
  - Blocks that are cut short (early halt due to gas limits)

- The condition is **not exploitable** by malicious actors (timing is unpredictable), but can occur naturally during normal operation as the system scales.

## Recommendation

Fix the `prepare_for_block_epilogue()` function to properly complete the two-step abort protocol:

```rust
pub(crate) fn prepare_for_block_epilogue(
    &self,
    block_epilogue_idx: TxnIndex,
) -> Result<Incarnation, PanicError> {
    let status = &self.statuses[block_epilogue_idx as usize];
    let status_guard = &mut *status.status_with_incarnation.lock();
    let incarnation = status_guard.incarnation();

    match status_guard.status {
        SchedulingStatus::Executing(_) => {
            return Err(code_invariant_error(
                "Block epilogue txn must not be executing",
            ));
        },
        SchedulingStatus::Aborted | SchedulingStatus::Executed => {
            // Properly complete the two-step abort protocol
            if self.start_abort(block_epilogue_idx, incarnation)? {
                // Only if start_abort succeeded, call finish_abort
                drop(status_guard); // Release lock before finish_abort
                self.finish_abort(block_epilogue_idx, incarnation, false)?;
                // Re-acquire lock for to_executing
                let status_guard = &mut *status.status_with_incarnation.lock();
                return self.to_executing(block_epilogue_idx, status_guard)?
                    .ok_or_else(|| {
                        code_invariant_error(format!(
                            "Expected PendingScheduling Status for block epilogue idx {}",
                            block_epilogue_idx
                        ))
                    });
            }
            // If start_abort returned false, status was already modified by another thread
            // Check if it's now in PendingScheduling state
        },
        SchedulingStatus::PendingScheduling => {},
    }

    self.to_executing(block_epilogue_idx, status_guard)?
        .ok_or_else(|| {
            code_invariant_error(format!(
                "Expected PendingScheduling Status for block epilogue idx {}",
                block_epilogue_idx
            ))
        })
}
```

Alternatively, add synchronization to ensure all worker threads complete their abort sequences before `prepare_for_block_epilogue()` is called.

## Proof of Concept

```rust
#[test]
fn test_block_epilogue_abort_race_condition() {
    use std::sync::{Arc, Barrier};
    use std::thread;
    
    let statuses = ExecutionStatuses::new(2); // One regular txn + epilogue
    let block_epilogue_idx = 1;
    
    // Set up: epilogue was speculatively executed
    let status = statuses.get_status_mut(block_epilogue_idx);
    *status.status_with_incarnation.lock() = 
        StatusWithIncarnation::new_for_test(SchedulingStatus::Executed, 0);
    
    let statuses = Arc::new(statuses);
    let barrier = Arc::new(Barrier::new(2));
    
    // Worker thread simulating abort from dependency change
    let statuses_clone = Arc::clone(&statuses);
    let barrier_clone = Arc::clone(&barrier);
    let worker = thread::spawn(move || {
        // Step 1: Successfully start abort
        assert!(statuses_clone.start_abort(block_epilogue_idx, 0).unwrap());
        
        // Wait for main thread to interfere
        barrier_clone.wait();
        
        // Step 3: Try to finish abort - this should fail with race condition
        let result = statuses_clone.finish_abort(block_epilogue_idx, 0, false);
        assert!(result.is_err(), "Expected PanicError due to race condition");
        result
    });
    
    // Main thread simulating prepare_for_block_epilogue
    barrier.wait(); // Wait for worker to start abort
    
    // Step 2: prepare_for_block_epilogue violates protocol
    let result = statuses.prepare_for_block_epilogue(block_epilogue_idx);
    assert!(result.is_ok());
    assert_eq!(result.unwrap(), 1); // Returns incarnation 1
    
    // Verify race condition occurred
    let worker_result = worker.join().unwrap();
    assert!(worker_result.is_err(), 
        "Worker's finish_abort should fail due to protocol violation");
}
```

This test demonstrates that `prepare_for_block_epilogue()`'s violation of the abort protocol causes concurrent `finish_abort()` calls to fail with invariant errors, which could disrupt block finalization in production.

## Notes

The security question's premise that the function "may call start_abort and finish_abort" is incorrect - the function only calls `start_abort()` without the corresponding `finish_abort()`, which is precisely the vulnerability. The correct incarnation number is still returned, but the abort state machine is left in an inconsistent state that causes failures in concurrent threads attempting to properly complete their abort sequences.

### Citations

**File:** aptos-move/block-executor/src/scheduler_status.rs (L45-47)
```rust
   b) Finish Abort Phase:
      - A successful [ExecutionStatuses::start_abort] must be followed by a
        [ExecutionStatuses::finish_abort] call on the status.
```

**File:** aptos-move/block-executor/src/scheduler_status.rs (L180-184)
```rust
    fn never_started_execution(&self, incarnation: Incarnation) -> bool {
        self.incarnation < incarnation
            || (self.incarnation == incarnation
                && self.status == SchedulingStatus::PendingScheduling)
    }
```

**File:** aptos-move/block-executor/src/scheduler_status.rs (L463-497)
```rust
    pub(crate) fn prepare_for_block_epilogue(
        &self,
        block_epilogue_idx: TxnIndex,
    ) -> Result<Incarnation, PanicError> {
        let status = &self.statuses[block_epilogue_idx as usize];
        let status_guard = &mut *status.status_with_incarnation.lock();
        let incarnation = status_guard.incarnation();

        match status_guard.status {
            SchedulingStatus::Executing(_) => {
                return Err(code_invariant_error(
                    "Block epilogue txn must not be executing",
                ));
            },
            SchedulingStatus::Aborted | SchedulingStatus::Executed => {
                // Start abort is idempotent for the same incarnation.
                self.start_abort(block_epilogue_idx, incarnation)?;
                self.to_pending_scheduling(
                    block_epilogue_idx,
                    status_guard,
                    incarnation + 1,
                    false,
                );
            },
            SchedulingStatus::PendingScheduling => {},
        }

        self.to_executing(block_epilogue_idx, status_guard)?
            .ok_or_else(|| {
                code_invariant_error(format!(
                    "Expected PendingScheduling Status for block epilogue idx {}",
                    block_epilogue_idx
                ))
            })
    }
```

**File:** aptos-move/block-executor/src/scheduler_status.rs (L667-673)
```rust
            if status_guard.already_aborted(aborted_incarnation)
                || status_guard.never_started_execution(aborted_incarnation)
            {
                return Err(code_invariant_error(format!(
                    "Finish abort of incarnation {}, but inner status {:?}",
                    aborted_incarnation, status_guard
                )));
```
