# Audit Report

## Title
Missing Cryptographic Validation in SecretSharedKey Constructor Enables Consensus Divergence

## Summary
The `SecretSharedKey::new()` constructor does not validate that the provided `DecryptionKey` cryptographically corresponds to the `Digest` in the metadata, allowing mismatched key-metadata pairs to be created. While individual secret shares are verified upon receipt, the reconstructed decryption key is never validated against the digest before use, creating a critical gap that could cause consensus divergence if triggered by logic bugs in the aggregation or metadata management code.

## Finding Description
The vulnerability exists in the secret sharing system used for encrypted transaction decryption in Aptos consensus. The system works as follows:

1. Each validator computes a digest from encrypted transactions and derives a secret share [1](#0-0) 

2. Shares are broadcast to other validators and verified individually [2](#0-1) 

3. Once sufficient shares are collected, they are aggregated into a full `DecryptionKey` [3](#0-2) 

4. A `SecretSharedKey` is created with metadata and the key **without any validation** [4](#0-3) 

5. The key is then used to decrypt transactions [5](#0-4) 

The critical flaw is that while the batch encryption library provides a `verify_decryption_key` method [6](#0-5) , which validates a `DecryptionKey` against a `Digest` using BLS pairing checks [7](#0-6) , this validation is **never invoked** in the `SecretSharedKey` constructor.

This breaks the **Deterministic Execution** invariant and creates multiple attack vectors:

**Attack Vector 1: Metadata Confusion**
If the `SecretSharedKey` is routed to the wrong block (e.g., round N key sent to round M block), the constructor won't detect this. The code accepts a `round` parameter but doesn't validate it matches the metadata [8](#0-7) 

**Attack Vector 2: Logic Bug Amplification**  
Any bug in share aggregation, metadata management, or key routing that causes a mismatch will go undetected. The decryption will either fail silently or produce incorrect plaintexts, causing different validators to execute different transactions and commit different state roots.

**Attack Vector 3: Digest Non-Determinism**
If there's any source of non-determinism in digest computation (transaction ordering bugs, race conditions, etc.), validators would compute different digests, aggregate keys valid for different digests, and diverge during decryption.

## Impact Explanation
This is a **Critical Severity** vulnerability under the Aptos bug bounty criteria because it can cause **Consensus/Safety violations**. If triggered, it would cause:

1. Different validators to successfully decrypt different sets of transactions
2. Different execution results and state roots for the same block
3. Permanent chain split requiring a hard fork to resolve

The lack of cryptographic validation means there's no safety net to catch mismatched key-metadata pairs, relying entirely on perfect correctness of all upstream logic. This violates defense-in-depth principles for consensus-critical code.

## Likelihood Explanation
While individual secret shares are verified cryptographically, the aggregated key is not. The likelihood depends on:

- **Current probability**: LOW - The existing code appears to handle metadata correctly in normal operation
- **Future probability**: MEDIUM - Any refactoring, optimization, or bug in the share aggregation, block queue management, or metadata handling could trigger this latent vulnerability
- **Severity when triggered**: CRITICAL - Consensus divergence

The fact that the cryptographic validation function exists but isn't used suggests this was an oversight rather than an intentional design decision.

## Recommendation
Add cryptographic validation to the `SecretSharedKey::new()` constructor:

```rust
impl SecretSharedKey {
    pub fn new(metadata: SecretShareMetadata, key: DecryptionKey, encryption_key: &EncryptionKey) -> anyhow::Result<Self> {
        // Validate that the decryption key matches the digest in metadata
        encryption_key.verify_decryption_key(&metadata.digest, &key)?;
        Ok(Self { metadata, key })
    }
}
```

This requires passing the `EncryptionKey` as a parameter, which is available in the `SecretShareConfig`. Update all call sites to provide this validation parameter.

Alternatively, store the `EncryptionKey` in the metadata or config to enable validation without changing the function signature extensively.

## Proof of Concept
```rust
// This PoC demonstrates that mismatched key-metadata pairs can be created
// and would go undetected in the current implementation

use aptos_types::secret_sharing::{SecretShareMetadata, SecretSharedKey, DecryptionKey, Digest};
use aptos_crypto::hash::HashValue;

fn exploit_missing_validation() {
    // Create metadata for block A with digest_A
    let metadata_a = SecretShareMetadata::new(
        1, // epoch
        100, // round  
        123456, // timestamp
        HashValue::random(),
        digest_a, // correct digest for block A
    );
    
    // Create metadata for block B with digest_B  
    let metadata_b = SecretShareMetadata::new(
        1, // epoch
        101, // round
        123457, // timestamp
        HashValue::random(),
        digest_b, // correct digest for block B
    );
    
    // Attacker (or buggy code) creates SecretSharedKey with:
    // - metadata from block B (digest_B)
    // - key reconstructed from shares valid for block A (digest_A)
    let mismatched_key = SecretSharedKey::new(
        metadata_b, // metadata with digest_B
        key_valid_for_digest_a, // key that only works with digest_A
    );
    
    // NO VALIDATION OCCURS - mismatched pair is created successfully!
    // When used for decryption:
    // - Block A would decrypt successfully (key matches digest_A)
    // - Block B would fail (key doesn't match digest_B)
    // Result: CONSENSUS DIVERGENCE
}
```

## Notes
While this vulnerability requires a trigger (a bug in upstream code), the complete absence of cryptographic validation for such a consensus-critical component is a severe security weakness. The validation mechanism exists in the codebase but is not used at the point where it matters most - creating the `SecretSharedKey` that will be used for decryption.

The current code relies on perfect correctness of:
- Share collection and filtering logic
- Metadata consistency across all code paths  
- Block-to-key routing logic
- Digest computation determinism

Any bug in these areas would cause undetected consensus divergence. Defense-in-depth for consensus code demands cryptographic validation at trust boundaries, which the constructor represents.

### Citations

**File:** consensus/src/pipeline/decryption_pipeline_builder.rs (L92-109)
```rust
        let (digest, proofs_promise) =
            FPTXWeighted::digest(&digest_key, &txn_ciphertexts, encryption_round)?;

        let metadata = SecretShareMetadata::new(
            block.epoch(),
            block.round(),
            block.timestamp_usecs(),
            block.id(),
            digest.clone(),
        );

        let derived_key_share = FPTXWeighted::derive_decryption_key_share(&msk_share, &digest)?;
        derived_self_key_share_tx
            .send(Some(SecretShare::new(
                author,
                metadata.clone(),
                derived_key_share,
            )))
```

**File:** consensus/src/pipeline/decryption_pipeline_builder.rs (L126-131)
```rust
                if let Ok(payload) = FPTXWeighted::decrypt_individual::<DecryptedPayload>(
                    &decryption_key.key,
                    &ciphertext,
                    &digest,
                    &eval_proof,
                ) {
```

**File:** consensus/src/rand/secret_sharing/network_messages.rs (L28-38)
```rust
    pub fn verify(
        &self,
        epoch_state: &EpochState,
        config: &SecretShareConfig,
    ) -> anyhow::Result<()> {
        ensure!(self.epoch() == epoch_state.epoch);
        match self {
            SecretShareMessage::RequestShare(_) => Ok(()),
            SecretShareMessage::Share(share) => share.verify(config),
        }
    }
```

**File:** consensus/src/rand/secret_sharing/secret_share_store.rs (L56-61)
```rust
            let maybe_key = SecretShare::aggregate(self.shares.values(), &dec_config);
            match maybe_key {
                Ok(key) => {
                    let dec_key = SecretSharedKey::new(metadata, key);
                    let _ = decision_tx.unbounded_send(dec_key);
                },
```

**File:** types/src/secret_sharing.rs (L128-132)
```rust
impl SecretSharedKey {
    pub fn new(metadata: SecretShareMetadata, key: DecryptionKey) -> Self {
        Self { metadata, key }
    }
}
```

**File:** crates/aptos-batch-encryption/src/shared/encryption_key.rs (L27-33)
```rust
    pub fn verify_decryption_key(
        &self,
        digest: &Digest,
        decryption_key: &BIBEDecryptionKey,
    ) -> Result<()> {
        BIBEMasterPublicKey(self.sig_mpk_g2).verify_decryption_key(digest, decryption_key)
    }
```

**File:** crates/aptos-batch-encryption/src/shared/key_derivation.rs (L154-163)
```rust
    pub fn verify_decryption_key(
        &self,
        digest: &Digest,
        decryption_key: &BIBEDecryptionKey,
    ) -> Result<()> {
        verify_bls(self.0, digest, self.0, decryption_key.signature_g1)
            .map_err(|_| BatchEncryptionError::DecryptionKeyVerifyError)?;

        Ok(())
    }
```

**File:** consensus/src/rand/secret_sharing/block_queue.rs (L64-77)
```rust
    pub fn set_secret_shared_key(&mut self, round: Round, key: SecretSharedKey) {
        let offset = self.offset(round);
        if self.pending_secret_key_rounds.contains(&round) {
            observe_block(
                self.blocks()[offset].timestamp_usecs(),
                BlockStage::SECRET_SHARING_ADD_DECISION,
            );
            let block = &self.blocks_mut()[offset];
            if let Some(tx) = block.pipeline_tx().lock().as_mut() {
                tx.secret_shared_key_tx.take().map(|tx| tx.send(Some(key)));
            }
            self.pending_secret_key_rounds.remove(&round);
        }
    }
```
