# Audit Report

## Title
Peer Monitoring Service: Missing Validation on Connected Peers Count Enables Resource Exhaustion

## Summary
The `NetworkInformationResponse` struct in the peer monitoring service does not validate the size of the `connected_peers` BTreeMap field, allowing malicious peers to send responses containing hundreds of thousands of fake peer entries (limited only by the 64 MiB network message size). While this does not directly inflate network importance (as the field is unused in peer prioritization), it can cause memory exhaustion and CPU overhead through deserialization and storage.

## Finding Description
The `NetworkInformationResponse` struct contains a `connected_peers` field defined as `BTreeMap<PeerNetworkId, ConnectionMetadata>`: [1](#0-0) 

When the peer monitoring service server receives a `GetNetworkInformation` request, it constructs this response with the node's actual connected peers: [2](#0-1) 

However, when the client receives this response from remote peers, the validation in `handle_monitoring_service_response` only checks the `distance_from_validators` field but completely omits validation of the `connected_peers` map size: [3](#0-2) 

The response is stored in `PeerMonitoringMetadata.latest_network_info_response`: [4](#0-3) 

The only usage of this field is extracting the count for metrics: [5](#0-4) 

Notably, the metrics code includes a comment indicating expected limits: [6](#0-5) 

**Attack Scenario:**
1. Malicious peer connects to victim node
2. Victim's peer monitoring client requests network information
3. Malicious peer responds with a `NetworkInformationResponse` containing ~300,000-600,000 fake entries in `connected_peers` (approaching the 64 MiB network message limit)
4. Victim deserializes and stores this large map in memory
5. Multiple malicious peers amplify the attack
6. Memory and CPU resources are exhausted

**Critical Finding:** Despite the claim in the security question, the `connected_peers` field is **NOT** used for peer prioritization or determining "network importance." All peer prioritization logic uses only the `distance_from_validators` field: [7](#0-6) [8](#0-7) [9](#0-8) 

## Impact Explanation
**Assessment: Does NOT meet bug bounty severity criteria**

While this is a legitimate missing validation, the security impact is limited:

1. **Not Consensus/Safety Impact:** The `connected_peers` field is never used in any consensus, validation, or security-critical decision-making
2. **Resource Exhaustion Only:** The impact is limited to memory consumption and CPU overhead during deserialization
3. **Network Layer Mitigation:** The maximum message size is already bounded by the network layer at 64 MiB
4. **Scope Exclusion:** The prompt explicitly states "Network-level DoS attacks are out of scope per bug bounty rules" - this resource exhaustion attack falls into this category

The finding does not meet:
- **Critical** criteria (no fund loss, no consensus violation, no network partition)
- **High** criteria (unlikely to cause significant validator slowdowns given bounded message size)
- **Medium** criteria (no fund loss, no state inconsistencies requiring intervention)

## Likelihood Explanation
**High likelihood of occurrence** but **low severity impact**:
- Any network peer can trivially craft this attack
- No special permissions required
- Simple to execute
- However, impact is bounded by network message limits and unused field status

## Recommendation
Add validation in the response handler to enforce reasonable limits on `connected_peers` size consistent with the documented expectation of 1000 peers maximum:

```rust
// In handle_monitoring_service_response, after line 114:
const MAX_CONNECTED_PEERS: usize = 1000;

// Validate the connected peers count
if network_info_response.connected_peers.len() > MAX_CONNECTED_PEERS {
    warn!(LogSchema::new(LogEntry::NetworkInfoRequest)
        .event(LogEvent::InvalidResponse)
        .peer(peer_network_id)
        .message(&format!(
            "Peer returned excessive connected peers count: {}",
            network_info_response.connected_peers.len()
        )));
    self.handle_request_failure();
    return;
}
```

## Proof of Concept
**Not Provided** - While technically feasible, this vulnerability does not meet the bug bounty program's severity criteria and appears to fall under the explicitly excluded category of "Network-level DoS attacks."

---

# Notes
After thorough investigation, while there is indeed missing validation on the `connected_peers` field size, this finding does **not** meet the "EXTREMELY high bar" required for a valid security vulnerability under the Aptos Bug Bounty program because:

1. The field is not used for peer prioritization or any security decisions (contradicting the question's premise about "inflating network importance")
2. The impact is purely resource exhaustion, which falls under the excluded "Network-level DoS attacks" category
3. The impact does not clearly fit Critical, High, or Medium severity criteria
4. The network layer already bounds message size at 64 MiB

This is a **defense-in-depth improvement** rather than an exploitable security vulnerability.

### Citations

**File:** peer-monitoring-service/types/src/response.rs (L51-55)
```rust
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
pub struct NetworkInformationResponse {
    pub connected_peers: BTreeMap<PeerNetworkId, ConnectionMetadata>, // Connected peers
    pub distance_from_validators: u64, // The distance of the peer from the validator set
}
```

**File:** peer-monitoring-service/server/src/lib.rs (L217-248)
```rust
    fn get_network_information(&self) -> Result<PeerMonitoringServiceResponse, Error> {
        // Get the connected peers
        let connected_peers_and_metadata =
            self.peers_and_metadata.get_connected_peers_and_metadata()?;
        let connected_peers = connected_peers_and_metadata
            .into_iter()
            .map(|(peer, metadata)| {
                let connection_metadata = metadata.get_connection_metadata();
                (
                    peer,
                    ConnectionMetadata::new(
                        connection_metadata.addr,
                        connection_metadata.remote_peer_id,
                        connection_metadata.role,
                    ),
                )
            })
            .collect();

        // Get the distance from the validators
        let distance_from_validators =
            get_distance_from_validators(&self.base_config, self.peers_and_metadata.clone());

        // Create and return the response
        let network_information_response = NetworkInformationResponse {
            connected_peers,
            distance_from_validators,
        };
        Ok(PeerMonitoringServiceResponse::NetworkInformation(
            network_information_response,
        ))
    }
```

**File:** peer-monitoring-service/client/src/peer_states/network_info.rs (L91-158)
```rust
    fn handle_monitoring_service_response(
        &mut self,
        peer_network_id: &PeerNetworkId,
        peer_metadata: PeerMetadata,
        _monitoring_service_request: PeerMonitoringServiceRequest,
        monitoring_service_response: PeerMonitoringServiceResponse,
        _response_time_secs: f64,
    ) {
        // Verify the response type is valid
        let network_info_response = match monitoring_service_response {
            PeerMonitoringServiceResponse::NetworkInformation(network_information_response) => {
                network_information_response
            },
            _ => {
                warn!(LogSchema::new(LogEntry::NetworkInfoRequest)
                    .event(LogEvent::ResponseError)
                    .peer(peer_network_id)
                    .message(
                        "An unexpected response was received instead of a network info response!"
                    ));
                self.handle_request_failure();
                return;
            },
        };

        // Sanity check the response depth from the peer metadata
        let network_id = peer_network_id.network_id();
        let is_valid_depth = match network_info_response.distance_from_validators {
            0 => {
                // Verify the peer is a validator and has the correct network id
                let peer_is_validator = peer_metadata.get_connection_metadata().role.is_validator();
                let peer_has_correct_network = match self.base_config.role {
                    RoleType::Validator => network_id.is_validator_network(), // We're a validator
                    RoleType::FullNode => network_id.is_vfn_network(),        // We're a VFN
                };
                peer_is_validator && peer_has_correct_network
            },
            1 => {
                // Verify the peer is a VFN and has the correct network id
                let peer_is_vfn = peer_metadata.get_connection_metadata().role.is_vfn();
                let peer_has_correct_network = match self.base_config.role {
                    RoleType::Validator => network_id.is_vfn_network(), // We're a validator
                    RoleType::FullNode => network_id.is_public_network(), // We're a VFN or PFN
                };
                peer_is_vfn && peer_has_correct_network
            },
            distance_from_validators => {
                // The distance must be less than or equal to the max
                distance_from_validators <= MAX_DISTANCE_FROM_VALIDATORS
            },
        };

        // If the depth did not pass our sanity checks, handle a failure
        if !is_valid_depth {
            warn!(LogSchema::new(LogEntry::NetworkInfoRequest)
                .event(LogEvent::InvalidResponse)
                .peer(peer_network_id)
                .message(&format!(
                    "Peer returned invalid depth from validators: {}",
                    network_info_response.distance_from_validators
                )));
            self.handle_request_failure();
            return;
        }

        // Store the new latency ping result
        self.record_network_info_response(network_info_response);
    }
```

**File:** peer-monitoring-service/client/src/peer_states/network_info.rs (L186-193)
```rust
            // Update the number of connected peers metric
            let num_connected_peers = network_info_response.connected_peers.len();
            metrics::observe_value(
                &metrics::NUM_CONNECTED_PEERS,
                peer_network_id,
                num_connected_peers as f64,
            );
        }
```

**File:** peer-monitoring-service/types/src/lib.rs (L43-51)
```rust
/// The peer monitoring metadata for a peer
#[derive(Clone, Default, Deserialize, PartialEq, Serialize)]
pub struct PeerMonitoringMetadata {
    pub average_ping_latency_secs: Option<f64>, // The average latency ping for the peer
    pub latest_ping_latency_secs: Option<f64>,  // The latest latency ping for the peer
    pub latest_network_info_response: Option<NetworkInformationResponse>, // The latest network info response
    pub latest_node_info_response: Option<NodeInformationResponse>, // The latest node info response
    pub internal_client_state: Option<String>, // A detailed client state string for debugging and logging
}
```

**File:** peer-monitoring-service/client/src/metrics.rs (L56-60)
```rust
// Histogram buckets for tracking the number of connected peers
const NUM_CONNECTED_PEERS_BUCKETS: &[f64] = &[
    0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 20.0, 30.0, 50.0, 100.0, 200.0, 400.0,
    1000.0, // Max number of connected peers should never be more than 1000
];
```

**File:** mempool/src/shared_mempool/priority.rs (L507-516)
```rust
fn get_distance_from_validators(
    monitoring_metadata: &Option<&PeerMonitoringMetadata>,
) -> Option<u64> {
    monitoring_metadata.and_then(|metadata| {
        metadata
            .latest_network_info_response
            .as_ref()
            .map(|network_info_response| network_info_response.distance_from_validators)
    })
}
```

**File:** state-sync/aptos-data-client/src/utils.rs (L238-241)
```rust
        let distance = peer_monitoring_metadata
            .latest_network_info_response
            .as_ref()
            .map(|response| response.distance_from_validators);
```

**File:** consensus/src/consensus_observer/observer/subscription_utils.rs (L202-205)
```rust
    let distance = peer_monitoring_metadata
        .latest_network_info_response
        .as_ref()
        .map(|response| response.distance_from_validators);
```
