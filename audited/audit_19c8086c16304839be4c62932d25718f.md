# Audit Report

## Title
Insufficient Gas Headroom Formula Causes Transaction Failures During Epoch Transitions with Dynamic Storage Gas Changes

## Summary
The fixed 1.5x gas headroom multiplier in `adjust_gas_headroom()` is mathematically inadequate to handle edge cases where Aptos' dynamic storage gas parameters increase significantly between transaction simulation and execution. This can cause properly-simulated transactions to fail with OUT_OF_GAS errors, particularly during epoch transitions or governance-initiated storage gas configuration changes.

## Finding Description

The `adjust_gas_headroom()` function applies a constant 1.5x multiplier to simulated gas usage: [1](#0-0) 

This function is used in two critical paths:

1. **Rosetta API** - When estimating gas for transaction construction: [2](#0-1) 

2. **Aptos CLI** - When submitting transactions with gas estimation: [3](#0-2) 

The vulnerability arises from Aptos' **dynamic storage gas pricing mechanism**. Storage gas parameters are reconfigured every epoch based on utilization: [4](#0-3) 

The exponential gas curve can cause dramatic price increases: [5](#0-4) 

At 99% utilization, gas costs reach **91.38%** of the delta between minimum and maximum. Since initialization sets a **100x** multiplier between min and max gas: [6](#0-5) 

Governance can trigger immediate storage gas reconfigurations: [7](#0-6) 

Epoch transitions occur when time threshold is exceeded: [8](#0-7) 

**Attack Scenario:**
1. User simulates transaction at 10% storage utilization: `gas_used = g_min ≈ 300K` (per-item read)
2. Headroom applied: `max_gas = 1.5 × 300K = 450K`
3. Epoch changes, utilization increases to 70%
4. New gas cost: `g_min + 6.69% × (30M - 300K) ≈ 2.29M`
5. Actual execution requires `2.29M > 450K` → **OUT_OF_GAS failure**

Even a utilization change from 50% → 70% causes gas to increase from `g_min + 1.09% × Δg` to `g_min + 6.69% × Δg`, a **6.13x increase** in the variable portion, far exceeding the 1.5x headroom.

## Impact Explanation

**Medium Severity** - This meets the "Limited funds loss or manipulation" and "State inconsistencies requiring intervention" criteria:

1. **Direct Financial Loss**: Users lose transaction fees when their properly-simulated transactions fail due to insufficient gas
2. **User Experience Degradation**: Legitimate transactions that passed simulation fail unexpectedly at execution time
3. **State Consistency Issues**: Multi-step protocols relying on transaction sequencing may break when intermediate transactions fail
4. **Governance Attack Vector**: Malicious governance proposals could intentionally increase storage gas costs to cause widespread transaction failures

The vulnerability does NOT constitute Critical/High severity because:
- No direct theft or minting of funds
- No consensus safety violations
- No permanent network issues
- Affected users can resubmit with higher gas limits

However, it represents a systematic failure of the gas estimation mechanism that affects all users relying on simulation for gas planning.

## Likelihood Explanation

**High Likelihood** - This vulnerability can manifest through multiple realistic scenarios:

1. **Natural Utilization Growth**: As Aptos adoption increases, storage utilization naturally rises, causing periodic gas spikes during epoch transitions
2. **Governance Gas Config Changes**: The `set_storage_gas_config()` function can be called via governance proposals to adjust gas parameters, causing immediate reconfiguration
3. **Epoch Boundary Effects**: Transactions simulated near epoch boundaries are most vulnerable as they may execute in the next epoch with different gas parameters
4. **Temporal Separation**: Users often simulate transactions and submit them later (especially in automated systems), increasing the chance of epoch changes

The vulnerability is particularly likely because:
- The 1.5x multiplier is **arbitrary** with no formal verification (note the `TODO(Gas): double check if this right` comment)
- Storage gas can theoretically increase by **100x** but headroom only provides **1.5x** protection
- Epoch transitions are **frequent and unpredictable** from the user's perspective

## Recommendation

**Immediate Mitigation:**
1. Increase the gas headroom multiplier from 1.5x to a more conservative value (e.g., 3x or 5x) to account for potential storage gas increases
2. Add epoch-awareness to gas estimation - if simulation happens near an epoch boundary, apply additional safety margin
3. Document the dynamic nature of storage gas costs prominently in API/CLI documentation

**Robust Solution:**
Implement dynamic headroom calculation based on current storage utilization:

```rust
pub fn adjust_gas_headroom_dynamic(
    gas_used: u64, 
    max_possible_gas: u64,
    current_utilization_bps: u64,  // basis points (0-10000)
    target_utilization_bps: u64
) -> u64 {
    // Calculate utilization ratio
    let utilization_ratio = current_utilization_bps.saturating_mul(10000) 
        .saturating_div(target_utilization_bps.max(1));
    
    // Apply higher headroom at higher utilization levels
    let headroom_multiplier = if utilization_ratio >= 9000 {
        10  // 10x headroom at 90%+ utilization
    } else if utilization_ratio >= 7000 {
        5   // 5x headroom at 70%+ utilization
    } else if utilization_ratio >= 5000 {
        3   // 3x headroom at 50%+ utilization
    } else {
        2   // 2x minimum headroom
    };
    
    std::cmp::min(
        max_possible_gas,
        gas_used.saturating_mul(headroom_multiplier)
    )
}
```

**Additional Safeguards:**
1. Add simulation metadata indicating the epoch number and storage utilization at simulation time
2. Implement client-side warnings when submitting transactions simulated in a previous epoch
3. Consider adding on-chain transaction retries with automatic gas adjustment for OUT_OF_GAS failures

## Proof of Concept

```move
#[test_only]
module aptos_framework::gas_headroom_vulnerability_test {
    use aptos_framework::storage_gas;
    use aptos_framework::state_storage;
    use aptos_framework::reconfiguration;
    
    #[test(framework = @aptos_framework)]
    fun test_insufficient_headroom_on_utilization_spike(framework: signer) {
        // Initialize storage and gas systems
        state_storage::initialize(&framework);
        storage_gas::initialize(&framework);
        
        // Simulate at 10% utilization
        state_storage::set_for_test(0, 200_000_000, 100_000_000); // 10% of 2B items, 10% of 1TB
        storage_gas::on_reconfig();
        let gas_at_10_pct = borrow_global<storage_gas::StorageGas>(@aptos_framework).per_item_read;
        
        // Apply 1.5x headroom (simulating adjust_gas_headroom behavior)
        let estimated_max_gas = gas_at_10_pct * 3 / 2;  // 1.5x
        
        // Epoch changes, utilization spikes to 70%
        state_storage::set_for_test(0, 1_400_000_000, 700_000_000); // 70% utilization
        reconfiguration::reconfigure();
        let gas_at_70_pct = borrow_global<storage_gas::StorageGas>(@aptos_framework).per_item_read;
        
        // Verify that actual gas exceeds estimated max gas
        assert!(gas_at_70_pct > estimated_max_gas, 0);
        
        // Calculate how much the gas increased
        let gas_increase_factor = (gas_at_70_pct * 100) / gas_at_10_pct;
        // This will show gas increased by ~7-8x, far exceeding 1.5x headroom
        assert!(gas_increase_factor > 150, 1); // More than 1.5x increase
    }
}
```

## Notes

The vulnerability stems from a fundamental mismatch between:
1. **Static headroom assumption** (1.5x is always sufficient)
2. **Dynamic gas reality** (storage gas can increase dramatically)

The code comment "Gas costs are dynamic based on storage" acknowledges this, but the 1.5x multiplier doesn't adequately address the mathematical implications of exponential gas curves with 100x min-max ranges. The `TODO(Gas): double check if this right` comment in the constants file further suggests this value was never formally verified for correctness across all scenarios.

This is a **design-level vulnerability** rather than an implementation bug - the logic works as intended, but the mathematical assumptions underlying the 1.5x constant are insufficient for the dynamic gas pricing model Aptos employs.

### Citations

**File:** config/global-constants/src/lib.rs (L40-45)
```rust
pub fn adjust_gas_headroom(gas_used: u64, max_possible_gas: u64) -> u64 {
    std::cmp::min(
        max_possible_gas,
        (gas_used.saturating_mul(GAS_HEADROOM_NUMERATOR)).saturating_div(GAS_HEADROOM_DENOMINATOR),
    )
}
```

**File:** crates/aptos-rosetta/src/construction.rs (L424-429)
```rust
        let max_gas_amount = if let Some(max_gas_amount) = options.max_gas_amount.as_ref() {
            max_gas_amount.0
        } else {
            // If estimating, we want to give headroom to ensure the transaction succeeds
            adjust_gas_headroom(simulated_txn.info.gas_used(), user_txn.max_gas_amount())
        };
```

**File:** crates/aptos/src/common/types.rs (L2025-2030)
```rust
            // Take the gas used and use a headroom factor on it
            let gas_used = simulated_txn.info.gas_used.0;
            // TODO: remove the hardcoded 530 as it's the minumum gas units required for the transaction that will
            // automatically create an account for stateless account.
            let adjusted_max_gas =
                adjust_gas_headroom(gas_used, max(simulated_txn.request.max_gas_amount.0, 530));
```

**File:** aptos-move/framework/aptos-framework/sources/storage_gas.move (L286-299)
```text
    ///
    /// | $u_r$ | $u_m$ (approximate) |
    /// |-------|---------------------|
    /// | 10%   | 0.02%               |
    /// | 20%   | 0.06%               |
    /// | 30%   | 0.17%               |
    /// | 40%   | 0.44%               |
    /// | 50%   | 1.09%               |
    /// | 60%   | 2.71%               |
    /// | 70%   | 6.69%               |
    /// | 80%   | 16.48%              |
    /// | 90%   | 40.61%              |
    /// | 95%   | 63.72%              |
    /// | 99%   | 91.38%              |
```

**File:** aptos-move/framework/aptos-framework/sources/storage_gas.move (L376-410)
```text
    /// | Per item   | Read      | 300K        | 300K * 100  |
    /// | Per item   | Create    | 300k        | 300k * 100    |
    /// | Per item   | Write     | 300K        | 300K * 100  |
    /// | Per byte   | Read      | 300         | 300 * 100   |
    /// | Per byte   | Create    | 5K          | 5K * 100    |
    /// | Per byte   | Write     | 5K          | 5K * 100    |
    ///
    /// `StorageGas` values are additionally initialized, but per
    /// `on_reconfig()`, they will be reconfigured for each subsequent
    /// epoch after initialization.
    ///
    /// See `base_8192_exponential_curve()` fore more information on
    /// target utilization.
    public fun initialize(aptos_framework: &signer) {
        system_addresses::assert_aptos_framework(aptos_framework);
        assert!(
            !exists<StorageGasConfig>(@aptos_framework),
            error::already_exists(ESTORAGE_GAS_CONFIG)
        );

        let k: u64 = 1000;
        let m: u64 = 1000 * 1000;

        let item_config = UsageGasConfig {
            target_usage: 2 * k * m, // 2 billion
            read_curve: base_8192_exponential_curve(300 * k, 300 * k * 100),
            create_curve: base_8192_exponential_curve(300 * k, 300 * k * 100),
            write_curve: base_8192_exponential_curve(300 * k, 300 * k * 100),
        };
        let byte_config = UsageGasConfig {
            target_usage: 1 * m * m, // 1TB
            read_curve: base_8192_exponential_curve(300, 300 * 100),
            create_curve: base_8192_exponential_curve(5 * k,  5 * k * 100),
            write_curve: base_8192_exponential_curve(5 * k,  5 * k * 100),
        };
```

**File:** aptos-move/framework/aptos-framework/sources/storage_gas.move (L515-533)
```text
    public(friend) fun on_reconfig() acquires StorageGas, StorageGasConfig {
        assert!(
            exists<StorageGasConfig>(@aptos_framework),
            error::not_found(ESTORAGE_GAS_CONFIG)
        );
        assert!(
            exists<StorageGas>(@aptos_framework),
            error::not_found(ESTORAGE_GAS)
        );
        let (items, bytes) = state_storage::current_items_and_bytes();
        let gas_config = borrow_global<StorageGasConfig>(@aptos_framework);
        let gas = borrow_global_mut<StorageGas>(@aptos_framework);
        gas.per_item_read = calculate_read_gas(&gas_config.item_config, items);
        gas.per_item_create = calculate_create_gas(&gas_config.item_config, items);
        gas.per_item_write = calculate_write_gas(&gas_config.item_config, items);
        gas.per_byte_read = calculate_read_gas(&gas_config.byte_config, bytes);
        gas.per_byte_create = calculate_create_gas(&gas_config.byte_config, bytes);
        gas.per_byte_write = calculate_write_gas(&gas_config.byte_config, bytes);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L147-152)
```text
    public fun set_storage_gas_config(aptos_framework: &signer, config: StorageGasConfig) {
        storage_gas::set_config(aptos_framework, config);
        // Need to trigger reconfiguration so the VM is guaranteed to load the new gas fee starting from the next
        // transaction.
        reconfiguration::reconfigure();
    }
```

**File:** aptos-move/framework/aptos-framework/sources/block.move (L215-217)
```text
        if (timestamp - reconfiguration::last_reconfiguration_time() >= epoch_interval) {
            reconfiguration::reconfigure();
        };
```
