Audit Report

## Title
Unbounded Execution Result Size in Sharded Block Executor Allows Coordinator Memory Exhaustion

## Summary
A malicious or compromised executor shard can send execution results (as `Vec<Vec<TransactionOutput>>`) of excessive size to the sharded block executor coordinator, which deserializes and aggregates the output without validation or enforcement of expected transaction-to-output cardinality. This can result in memory exhaustion (OOM) on the coordinator node, leading to a denial of service.

## Finding Description
The coordinator interface for sharded execution (`CoordinatorClient::send_execution_result`) allows each shard to return an arbitrarily large `Vec<Vec<TransactionOutput>>` as the result of executing its sub-blocks. When operating in remote mode, these results are serialized and transmitted over the network (with a single-message size limit of 80MiB), but there is **no validation** on result dimensionality or on the match between the number of output records and the number of transactions submitted to the shard. 

On the receiving end, the coordinator will:
1. Deserialize the entire shard result, thereby allocating memory for potentially vast structures. [1](#0-0) [2](#0-1) 
2. Aggregate results from all shards by flattening all output, in proportion to the number and size of output messages received, again without any sanity checks or validations. [3](#0-2) 
3. Attempt to process and commit results, with excess output simply increasing memory/disk footprint or being ignored, but never explicitly detected or reported.

Although the 80MiB per-message network limit may throttle the attack, a distributed attack from multiple compromised shards or repeated oversize results could destabilize the coordinator due to cumulative memory pressure. There is no invariant enforcement (such as a check that the number of transaction outputs matches transactions submitted), so output size manipulation is feasible.

## Impact Explanation
- **Category**: Medium (DoS by OOM, not a consensus or ledger break)
- **Scope**: Affects any coordinator node that receives output from untrusted, buggy, or compromised executor shards in sharded mode.
- **Potential Damage**: Coordinator OOM triggers a crash and restart, temporarily halting progress, reducing availability, and risking liveness if repeated or coordinated across nodes. This is within "Validator node slowdowns / API crashes" in the bounty program.

## Likelihood Explanation
Attack requires either a compromised or intentionally malicious executor shard. Buggy or outright malicious code in external/executor-service pods could trigger it. Given sharded execution modes may be used in shared or horizontally scalable environments, this is feasible under certain threat models (particularly cloud/remote-based execution).

## Recommendation
- Add a **strict validation** when receiving execution results: enforce that the number of outputs exactly matches the number of input transactions, and that no individual output dimension exceeds a safe threshold.
- Additionally, reject or drop incoming messages that breach the expected result pattern, and record an anomaly or security log event.
- Defensive coding: Always apply a memory/size guard (e.g., through checked deserialization APIs) before allocating potentially large structures received over the network.

## Proof of Concept
A malicious executor shard can be simulated by sending a properly signed network packet containing a `RemoteExecutionResult` struct whose `inner` is a `Vec<Vec<TransactionOutput>>` with excessive memory footprint (e.g., containing thousands of vectors and outputs). The coordinator, upon deserialization and aggregation, will crash due to OOM.

---

### Supporting Evidence [1](#0-0) [2](#0-1) [3](#0-2) 

---

Notes:
- The network message limit (80 MiB) somewhat limits the scale, but multiple shards or repeated invocations can reliably destabilize the coordinator.
- No consensus or chain-safety invariant is directly violated, so this is not a Critical impact, but presents a persistent availability/DoS risk in deployments using remote executor shards.
- This is not exploitable by a simple malicious transaction sender; attacker must control or compromise an executor shard. Nevertheless, defensive programming is recommended in distributed systems of this kind.

### Citations

**File:** execution/executor-service/src/remote_cordinator_client.rs (L115-120)
```rust
    fn send_execution_result(&self, result: Result<Vec<Vec<TransactionOutput>>, VMStatus>) {
        let remote_execution_result = RemoteExecutionResult::new(result);
        let output_message = bcs::to_bytes(&remote_execution_result).unwrap();
        self.result_tx.send(Message::new(output_message)).unwrap();
    }
}
```

**File:** execution/executor-service/src/remote_executor_client.rs (L163-172)
```rust
    fn get_output_from_shards(&self) -> Result<Vec<Vec<Vec<TransactionOutput>>>, VMStatus> {
        trace!("RemoteExecutorClient Waiting for results");
        let mut results = vec![];
        for rx in self.result_rxs.iter() {
            let received_bytes = rx.recv().unwrap().to_bytes();
            let result: RemoteExecutionResult = bcs::from_bytes(&received_bytes).unwrap();
            results.push(result.inner?);
        }
        Ok(results)
    }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/mod.rs (L98-110)
```rust
        let num_rounds = sharded_output[0].len();
        let mut aggregated_results = vec![];
        let mut ordered_results = vec![vec![]; num_executor_shards * num_rounds];
        // Append the output from individual shards in the round order
        for (shard_id, results_from_shard) in sharded_output.into_iter().enumerate() {
            for (round, result) in results_from_shard.into_iter().enumerate() {
                ordered_results[round * num_executor_shards + shard_id] = result;
            }
        }

        for result in ordered_results.into_iter() {
            aggregated_results.extend(result);
        }
```
