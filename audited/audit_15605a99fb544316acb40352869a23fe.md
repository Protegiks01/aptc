# Audit Report

## Title
Weak RSA Keys Accepted for OpenIdSig Keyless Authentication Enabling Account Takeover

## Summary
The keyless validation system fails to enforce minimum RSA key sizes for OpenIdSig (zkless keyless) authentication. While ZeroKnowledgeSig validates that RSA modulus is exactly 2048 bits, the OpenIdSig verification path accepts RSA keys of any size, including cryptographically weak 512-bit or 1024-bit keys. This allows attackers to factor weak private keys and forge JWT signatures, gaining unauthorized access to keyless accounts.

## Finding Description

The Aptos keyless authentication system supports two certificate types: `ZeroKnowledgeSig` (with ZK proofs) and `OpenIdSig` (zkless). Both use RSA JWKs for JWT signature verification, but only the ZK path validates key strength.

**Vulnerable Path (OpenIdSig):**

When validating OpenIdSig certificates, the code path branches to OpenIdSig-specific verification: [1](#0-0) 

The OpenIdSig verification calls `verify_jwt_signature()`: [2](#0-1) 

Which delegates to the RSA_JWK verification using the `jsonwebtoken` crate: [3](#0-2) 

The underlying implementation uses `DecodingKey::from_rsa_components()` which accepts RSA keys of **any size** without validation: [4](#0-3) 

**Protected Path (ZeroKnowledgeSig):**

In contrast, ZK signatures require computing a Poseidon hash of the JWK: [5](#0-4) 

This calls `to_poseidon_scalar()` which enforces exactly 256 bytes (2048 bits): [6](#0-5) 

The constant `RSA_MODULUS_BYTES` is defined as 256 bytes: [7](#0-6) 

**On-Chain Storage (No Validation):**

JWKs can be registered via `update_federated_jwk_set` without size validation: [8](#0-7) 

The function only validates that input vectors have matching lengths and are non-empty, but performs no cryptographic strength validation: [9](#0-8) 

**Attack Scenario:**

1. **Malicious Dapp Owner**: Registers a federated keyless provider with 512-bit RSA keys via `update_federated_jwk_set()` - any address can call this entry function
2. **User Onboarding**: Users create federated keyless accounts, binding their identity to the weak JWK
3. **Key Factorization**: Attacker factors the 512-bit RSA private key (feasible in hours with modern computing)
4. **JWT Forgery**: Attacker crafts valid JWT tokens with forged signatures
5. **Account Takeover**: Attacker submits transactions with OpenIdSig, passing all validation checks in the vulnerable path
6. **Fund Theft**: Attacker drains all funds from affected accounts

## Impact Explanation

**Critical Severity** - This vulnerability enables:

- **Loss of Funds**: Direct theft from all keyless accounts using weak JWKs
- **Unauthorized Access**: Complete account takeover for affected users  
- **Cryptographic Failure**: Violates the fundamental security guarantee that RSA signatures require computationally infeasible key recovery

512-bit RSA keys can be factored in hours with commodity hardware. 1024-bit RSA has been deprecated since 2013 and is considered cryptographically weak. NIST SP 800-57 requires minimum 2048-bit RSA keys for security. The ZK circuit correctly enforces 2048-bit keys, but the OpenIdSig path bypasses this critical security control entirely.

This qualifies as **Loss of Funds (Critical)** under the Aptos bug bounty program, as it enables direct theft of APT and other tokens through account takeover.

## Likelihood Explanation

**High Likelihood** because:

1. **Federated Keyless Design**: Any dapp owner (untrusted actor) can register JWKs without cryptographic validation
2. **No Runtime Protection**: OpenIdSig verification path accepts weak keys without error or warning
3. **Factorization Feasibility**: 512-bit RSA factorization is trivial with modern tools; 1024-bit is achievable by well-resourced attackers
4. **Accidental Misconfiguration**: Dapp owners might unknowingly deploy test keys with weak parameters to production
5. **Persistent Vulnerability**: Once weak keys are registered on-chain, all historical and future OpenIdSig signatures are compromised until keys are rotated

The asymmetric validation between ZeroKnowledgeSig (enforced) and OpenIdSig (unenforced) paths creates a security gap that attackers can exploit.

## Recommendation

Enforce RSA key size validation in all code paths:

1. **Add validation to `update_federated_jwk_set`**: Check that the RSA modulus `n` decodes to exactly 256 bytes (2048 bits) before allowing registration
2. **Add runtime validation to OpenIdSig path**: Validate RSA modulus size in `RSA_JWK::verify_signature_without_exp_check()` before calling `jsonwebtoken`
3. **Consistent validation**: Reuse the same validation logic from `to_poseidon_scalar()` in all verification paths

Suggested fix for `RSA_JWK::verify_signature_without_exp_check()`:

```rust
pub fn verify_signature_without_exp_check(&self, jwt_token: &str) -> Result<TokenData<Claims>> {
    // Validate key size before verification
    let modulus = base64::decode_config(&self.n, URL_SAFE_NO_PAD)?;
    if modulus.len() != Self::RSA_MODULUS_BYTES {
        bail!("RSA modulus must be exactly {} bytes (2048 bits)", Self::RSA_MODULUS_BYTES);
    }
    
    let mut validation = Validation::new(Algorithm::RS256);
    validation.validate_exp = false;
    let key = &DecodingKey::from_rsa_components(&self.n, &self.e)?;
    let claims = jsonwebtoken::decode::<Claims>(jwt_token, key, &validation)?;
    Ok(claims)
}
```

## Proof of Concept

A complete PoC would require:

1. Generating a 512-bit RSA key pair
2. Creating a federated JWK with the weak key via `update_federated_jwk_set`
3. Creating a federated keyless account bound to that JWK
4. Factoring the weak RSA private key
5. Forging a JWT signature
6. Submitting a transaction with OpenIdSig certificate
7. Demonstrating successful validation and execution

The vulnerability logic is validated through code analysis showing the asymmetric enforcement between ZeroKnowledgeSig (validated) and OpenIdSig (not validated) paths.

## Notes

This vulnerability represents a critical security gap where the ZK proof path correctly enforces cryptographic strength requirements (2048-bit RSA) but the zkless OpenIdSig path does not. The federated keyless design allows untrusted dapp owners to register JWKs, making this a realistic attack vector. The fix should align both code paths to enforce the same cryptographic minimum standards defined by `RSA_MODULUS_BYTES`.

### Citations

**File:** aptos-move/aptos-vm/src/keyless_validation.rs (L307-316)
```rust
                        let public_inputs_hash = get_public_inputs_hash(
                            signature,
                            public_key.inner_keyless_pk(),
                            rsa_jwk,
                            config,
                        )
                        .map_err(|_| {
                            // println!("[aptos-vm][groth16] PIH computation failed");
                            invalid_signature!("Could not compute public inputs hash")
                        })?;
```

**File:** aptos-move/aptos-vm/src/keyless_validation.rs (L368-399)
```rust
        EphemeralCertificate::OpenIdSig(openid_sig) => {
            match jwk {
                JWK::RSA(rsa_jwk) => {
                    openid_sig
                        .verify_jwt_claims(
                            signature.exp_date_secs,
                            &signature.ephemeral_pubkey,
                            public_key.inner_keyless_pk(),
                            config,
                        )
                        .map_err(|_| invalid_signature!("OpenID claim verification failed"))?;

                    // TODO(OpenIdSig): Implement batch verification for all RSA signatures in
                    //  one TXN.
                    // Note: Individual OpenID RSA signature verification will be fast when the
                    // RSA public exponent is small (e.g., 65537). For the same TXN, batch
                    // verification of all RSA signatures will be even faster even when the
                    // exponent is the same. Across different TXNs, batch verification will be
                    // (1) more difficult to implement and (2) not very beneficial since, when
                    // it fails, bad signature identification will require re-verifying all
                    // signatures assuming an adversarial batch.
                    //
                    // We are now ready to verify the RSA signature
                    openid_sig
                        .verify_jwt_signature(rsa_jwk, &signature.jwt_header_json)
                        .map_err(|_| {
                            invalid_signature!("RSA signature verification failed for OpenIdSig")
                        })?;
                },
                JWK::Unsupported(_) => return Err(invalid_signature!("JWK is not supported")),
            }
        },
```

**File:** types/src/keyless/openid_sig.rs (L126-139)
```rust
    pub fn verify_jwt_signature(
        &self,
        rsa_jwk: &RSA_JWK,
        jwt_header_json: &str,
    ) -> anyhow::Result<()> {
        let jwt_b64 = format!(
            "{}.{}.{}",
            base64url_encode_str(jwt_header_json),
            base64url_encode_str(&self.jwt_payload_json),
            base64url_encode_bytes(&self.jwt_sig)
        );
        rsa_jwk.verify_signature_without_exp_check(&jwt_b64)?;
        Ok(())
    }
```

**File:** types/src/jwks/rsa/mod.rs (L52-54)
```rust
impl RSA_JWK {
    /// The circuit-supported RSA modulus size.
    pub const RSA_MODULUS_BYTES: usize = 256;
```

**File:** types/src/jwks/rsa/mod.rs (L89-95)
```rust
    pub fn verify_signature_without_exp_check(&self, jwt_token: &str) -> Result<TokenData<Claims>> {
        let mut validation = Validation::new(Algorithm::RS256);
        validation.validate_exp = false;
        let key = &DecodingKey::from_rsa_components(&self.n, &self.e)?;
        let claims = jsonwebtoken::decode::<Claims>(jwt_token, key, &validation)?;
        Ok(claims)
    }
```

**File:** types/src/jwks/rsa/mod.rs (L102-110)
```rust
    pub fn to_poseidon_scalar(&self) -> Result<ark_bn254::Fr> {
        let mut modulus = base64::decode_config(&self.n, URL_SAFE_NO_PAD)?;
        // The circuit only supports RSA256
        if modulus.len() != Self::RSA_MODULUS_BYTES {
            bail!(
                "Wrong modulus size, must be {} bytes",
                Self::RSA_MODULUS_BYTES
            );
        }
```

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L258-277)
```text
    public entry fun update_federated_jwk_set(jwk_owner: &signer, iss: vector<u8>, kid_vec: vector<String>, alg_vec: vector<String>, e_vec: vector<String>, n_vec: vector<String>) acquires FederatedJWKs {
        assert!(!vector::is_empty(&kid_vec), error::invalid_argument(EINVALID_FEDERATED_JWK_SET));
        let num_jwk = vector::length<String>(&kid_vec);
        assert!(vector::length(&alg_vec) == num_jwk , error::invalid_argument(EINVALID_FEDERATED_JWK_SET));
        assert!(vector::length(&e_vec) == num_jwk, error::invalid_argument(EINVALID_FEDERATED_JWK_SET));
        assert!(vector::length(&n_vec) == num_jwk, error::invalid_argument(EINVALID_FEDERATED_JWK_SET));

        let remove_all_patch = new_patch_remove_all();
        let patches = vector[remove_all_patch];
        while (!vector::is_empty(&kid_vec)) {
            let kid = vector::pop_back(&mut kid_vec);
            let alg = vector::pop_back(&mut alg_vec);
            let e = vector::pop_back(&mut e_vec);
            let n = vector::pop_back(&mut n_vec);
            let jwk = new_rsa_jwk(kid, alg, e, n);
            let patch = new_patch_upsert_jwk(iss, jwk);
            vector::push_back(&mut patches, patch)
        };
        patch_federated_jwks(jwk_owner, patches);
    }
```
