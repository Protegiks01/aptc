# Audit Report

## Title
Missing Configuration Validation Allows Transaction Propagation Liveness Degradation

## Summary
The `sanitize()` function in `mempool_config.rs` lacks validation to ensure `shared_mempool_ack_timeout_ms < shared_mempool_backoff_interval_ms`, allowing misconfigurations that degrade transaction propagation when combined with network packet loss.

## Finding Description

The mempool configuration validation function is currently empty and performs no checks on the relationship between ACK timeout and backoff interval parameters. [1](#0-0) 

The default configuration maintains the correct relationship (ack_timeout=2000ms < backoff_interval=30000ms): [2](#0-1) 

However, if an operator misconfigures a node with inverted values (e.g., ack_timeout=60000ms, backoff_interval=1000ms), the retry logic breaks down when ACKs are lost:

1. **Normal Flow**: When broadcasts are sent, they're tracked in `sent_messages` and expire after `ack_timeout_ms` if no ACK is received: [3](#0-2) 

2. **Misconfiguration Impact**: With ack_timeout > backoff_interval and ACK packet loss:
   - Messages accumulate in `sent_messages` without expiring quickly
   - Eventually hit `max_broadcasts_per_peer` limit (default 20)
   - Node cannot send new broadcasts until messages expire at the much longer ack_timeout
   - Transaction propagation is blocked for extended periods [4](#0-3) 

3. **Backoff Scheduling**: The backoff interval is used when scheduling retries in backoff mode: [5](#0-4) 

## Impact Explanation

This issue falls under **Low to Medium severity** rather than the suggested Medium severity, for these reasons:

**Why Not Medium Severity:**
- Does NOT cause "state inconsistencies requiring intervention" in the blockchain state sense
- Does NOT cause fund loss or manipulation
- Only affects transaction propagation speed, not correctness
- Requires operator misconfiguration as a precondition
- Default configuration is correct

**Actual Impact:**
- **Operational Issue**: Degrades network health and transaction dissemination speed
- **Requires Multiple Preconditions**: Operator error + network packet loss
- **Temporary Effect**: Resolved when messages eventually expire or network recovers
- **No Safety Violation**: Does not break consensus, deterministic execution, or state consistency invariants

Per Aptos bug bounty criteria, this is closer to **Low Severity** ("Non-critical implementation bugs") as it's a defensive validation gap rather than an exploitable vulnerability.

## Likelihood Explanation

**Low Likelihood** due to multiple required preconditions:

1. **Operator Misconfiguration Required**: Default values are correct (2s < 30s). An operator must explicitly override with inverted values
2. **Network Unreliability Required**: ACK packet loss must occur to trigger the issue
3. **Limited Scope**: Only affects misconfigured nodes, not the entire network
4. **Not Directly Exploitable**: An attacker cannot force this configuration on victim nodes

The issue is more of a configuration footgun than an exploitable security vulnerability.

## Recommendation

Add validation in the `sanitize()` function to ensure proper parameter relationships: [1](#0-0) 

**Recommended Fix:**
```rust
impl ConfigSanitizer for MempoolConfig {
    fn sanitize(
        node_config: &NodeConfig,
        _node_type: NodeType,
        _chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let mempool = &node_config.mempool;
        
        // Validate ACK timeout is less than backoff interval for proper retry logic
        if mempool.shared_mempool_ack_timeout_ms >= mempool.shared_mempool_backoff_interval_ms {
            return Err(Error::ConfigSanitizerFailed(
                "mempool".to_string(),
                format!(
                    "shared_mempool_ack_timeout_ms ({}) must be less than shared_mempool_backoff_interval_ms ({}) to ensure proper retry logic",
                    mempool.shared_mempool_ack_timeout_ms,
                    mempool.shared_mempool_backoff_interval_ms
                )
            ));
        }
        
        Ok(())
    }
}
```

## Proof of Concept

The following test demonstrates the configuration issue:

```rust
#[test]
fn test_invalid_ack_timeout_backoff_relationship() {
    use aptos_config::config::{NodeConfig, NodeType};
    use aptos_types::chain_id::ChainId;
    
    // Create a node config with inverted values
    let mut node_config = NodeConfig::default();
    node_config.mempool.shared_mempool_ack_timeout_ms = 60_000; // 60 seconds
    node_config.mempool.shared_mempool_backoff_interval_ms = 1_000; // 1 second
    
    // This should fail validation but currently passes
    let result = MempoolConfig::sanitize(
        &node_config,
        NodeType::Validator,
        Some(ChainId::test())
    );
    
    // Currently passes (bug) - should fail with validation error
    assert!(result.is_ok()); // This assertion shows the bug exists
    
    // After fix, this should fail:
    // assert!(result.is_err());
    // assert!(result.unwrap_err().to_string().contains("ack_timeout_ms"));
}
```

**Note:** This PoC demonstrates the missing validation but does not demonstrate an exploitable attack path, as the issue requires operator misconfiguration and network unreliability to manifest in operational impact.

---

**Notes:**

While this is a valid code quality issue (missing defensive validation), it does **not** meet the extremely high bar for an exploitable security vulnerability because:

1. **Requires Operator Error**: Not directly exploitable by attackers
2. **No Invariant Violation**: Doesn't break consensus, safety, or state consistency
3. **Operational Impact Only**: Affects network health, not correctness or security
4. **Default Configuration Correct**: Only affects nodes with explicit misconfigurations

This should be tracked as a **configuration validation improvement** rather than a critical security vulnerability.

### Citations

**File:** config/src/config/mempool_config.rs (L108-116)
```rust
impl Default for MempoolConfig {
    fn default() -> MempoolConfig {
        MempoolConfig {
            shared_mempool_tick_interval_ms: 10,
            shared_mempool_backoff_interval_ms: 30_000,
            shared_mempool_batch_size: 300,
            shared_mempool_max_batch_bytes: MAX_APPLICATION_MESSAGE_SIZE as u64,
            shared_mempool_ack_timeout_ms: 2_000,
            shared_mempool_max_concurrent_inbound_syncs: 4,
```

**File:** config/src/config/mempool_config.rs (L176-184)
```rust
impl ConfigSanitizer for MempoolConfig {
    fn sanitize(
        _node_config: &NodeConfig,
        _node_type: NodeType,
        _chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        Ok(()) // TODO: add reasonable verifications
    }
}
```

**File:** mempool/src/shared_mempool/network.rs (L429-439)
```rust
        // Find earliest message in timeline index that expired.
        // Note that state.broadcast_info.sent_messages is ordered in decreasing order in the timeline index
        for (message, sent_time) in state.broadcast_info.sent_messages.iter() {
            let deadline = sent_time.add(Duration::from_millis(
                self.mempool_config.shared_mempool_ack_timeout_ms,
            ));
            if SystemTime::now().duration_since(deadline).is_ok() {
                expired_message_id = Some(message);
            } else {
                pending_broadcasts += 1;
            }
```

**File:** mempool/src/shared_mempool/network.rs (L441-448)
```rust
            // The maximum number of broadcasts sent to a single peer that are pending a response ACK at any point.
            // If the number of un-ACK'ed un-expired broadcasts reaches this threshold, we do not broadcast anymore
            // and wait until an ACK is received or a sent broadcast expires.
            // This helps rate-limit egress network bandwidth and not overload a remote peer or this
            // node's network sender.
            if pending_broadcasts >= self.mempool_config.max_broadcasts_per_peer {
                return Err(BroadcastError::TooManyPendingBroadcasts(peer));
            }
```

**File:** mempool/src/shared_mempool/tasks.rs (L108-114)
```rust
    let schedule_backoff = network_interface.is_backoff_mode(&peer);

    let interval_ms = if schedule_backoff {
        smp.config.shared_mempool_backoff_interval_ms
    } else {
        smp.config.shared_mempool_tick_interval_ms
    };
```
