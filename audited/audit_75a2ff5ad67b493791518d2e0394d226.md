# Audit Report

## Title
Missing Epoch and Round Validation in Commit Vote Signing Enables Potential Consensus Safety Violations

## Summary
The `guarded_sign_commit_vote()` function in SafetyRules lacks critical validation checks for epoch verification and monotonic round/version progression (the "extension check" mentioned in TODO comments). This defense-in-depth failure could allow validators to sign commit votes for incorrect epochs or regressed rounds if triggered by bugs in the consensus pipeline. [1](#0-0) 

## Finding Description

The `guarded_sign_commit_vote()` function is responsible for signing commit votes after block execution. Unlike the similar `guarded_construct_and_sign_vote_two_chain()` function, it lacks several critical safety checks:

**Missing Validations:**

1. **No Epoch Verification**: The function doesn't call `verify_epoch()` on the `new_ledger_info` parameter. The old ledger info's epoch is implicitly validated through signature verification, but the new execution result's epoch is never checked. [2](#0-1) 

2. **No Extension Check** (TODO line 413): The function doesn't verify that the commit extends from previously committed blocks. There's no check that round numbers or version numbers increase monotonically.

3. **No Safety Data Persistence**: Unlike voting functions, this doesn't update or persist safety data, providing no record of what was signed.

**Comparison with Similar Functions:**

The `guarded_construct_and_sign_vote_two_chain()` function performs comprehensive checks: [3](#0-2) 

It calls `verify_proposal()` which includes epoch verification: [4](#0-3) 

And persists updated safety data: [5](#0-4) 

**Attack Scenario:**

If a bug in the consensus pipeline (buffer manager, state sync, or epoch transition) causes it to send a `SigningRequest` with:
- A valid `ordered_ledger_info` (from round R, epoch E) with 2f+1 signatures
- A `commit_ledger_info` for a different epoch or regressed round

The safety rules would sign it because:
- `is_ordered_only()` check passes (ordered info has dummy execution values) [6](#0-5) 

- `match_ordered_only()` check passes (if same block ID/round) [7](#0-6) 

- Signature verification passes (it's a legitimate QC)
- **But epoch of commit_ledger_info is never validated**
- **And round progression is never checked**

## Impact Explanation

**Severity: Medium**

While this represents a defense-in-depth failure, direct exploitation requires a separate bug in the consensus pipeline to send invalid inputs. However, the potential impact is severe:

1. **Consensus Safety Violation**: If validators sign commit votes for regressed rounds or wrong epochs, it could lead to different committed states for the same round
2. **Chain Split Risk**: If enough validators (2f+1) sign invalid commit decisions, it could cause a network partition requiring intervention
3. **State Inconsistency**: Could violate the fundamental invariant that committed state only progresses forward

The impact aligns with **Medium Severity** per bug bounty criteria: "State inconsistencies requiring intervention"

However, this is **NOT directly exploitable** by an external attacker without validator access or a separate consensus bug.

## Likelihood Explanation

**Likelihood: Low-Medium**

The vulnerability cannot be directly triggered by external attackers. Exploitation requires:

1. A software bug in the consensus pipeline (buffer manager, state sync, epoch transitions)
2. Or malicious validator behavior (violates trust model)
3. The bug must cause invalid `SigningRequest` creation with mismatched epochs or regressed rounds
4. Multiple validators would need to experience the same issue to create a valid commit decision (2f+1 signatures)

**Why this matters despite low likelihood:**
- Safety rules should be defense-in-depth, validating ALL inputs
- The TODO comments explicitly acknowledge these checks are missing
- Similar functions DO perform these validations
- Complex state sync and epoch transition code is error-prone
- Crash recovery scenarios could trigger edge cases

## Recommendation

Add the missing validation checks to `guarded_sign_commit_vote()`:

```rust
fn guarded_sign_commit_vote(
    &mut self,
    ledger_info: LedgerInfoWithSignatures,
    new_ledger_info: LedgerInfo,
) -> Result<bls12381::Signature, Error> {
    self.signer()?;
    
    let old_ledger_info = ledger_info.ledger_info();
    
    // Get safety data for validation
    let mut safety_data = self.persistent_storage.safety_data()?;
    
    // ADD: Verify epoch on new_ledger_info
    self.verify_epoch(new_ledger_info.epoch(), &safety_data)?;
    
    if !old_ledger_info.commit_info().is_ordered_only()
        && old_ledger_info.commit_info() != new_ledger_info.commit_info()
    {
        return Err(Error::InvalidOrderedLedgerInfo(old_ledger_info.to_string()));
    }

    if !old_ledger_info
        .commit_info()
        .match_ordered_only(new_ledger_info.commit_info())
    {
        return Err(Error::InconsistentExecutionResult(
            old_ledger_info.commit_info().to_string(),
            new_ledger_info.commit_info().to_string(),
        ));
    }

    if !self.skip_sig_verify {
        ledger_info
            .verify_signatures(&self.epoch_state()?.verifier)
            .map_err(|error| Error::InvalidQuorumCertificate(error.to_string()))?;
    }

    // ADD: Extension check - verify round progression
    let commit_round = new_ledger_info.round();
    if let Some(last_vote) = &safety_data.last_vote {
        let last_commit_round = last_vote.ledger_info().round();
        if commit_round < last_commit_round {
            return Err(Error::IncorrectLastVotedRound(
                commit_round,
                last_commit_round,
            ));
        }
    }
    
    // ADD: Verify version progression if not empty
    if !new_ledger_info.commit_info().is_empty() {
        let commit_version = new_ledger_info.version();
        if let Some(last_vote) = &safety_data.last_vote {
            let last_version = last_vote.ledger_info().version();
            if commit_version < last_version {
                return Err(Error::InternalError(format!(
                    "Commit version {} is less than last voted version {}",
                    commit_version, last_version
                )));
            }
        }
    }

    let signature = self.sign(&new_ledger_info)?;
    
    // ADD: Consider persisting safety data about this commit vote
    // (This may need careful consideration to avoid impacting performance)

    Ok(signature)
}
```

## Proof of Concept

```rust
#[test]
fn test_sign_commit_vote_wrong_epoch() {
    use crate::tests::test_utils;
    
    let (mut safety_rules, signer) = test_utils::make_safety_rules();
    let (proof, genesis_qc) = test_utils::make_genesis(&signer);
    
    safety_rules.initialize(&proof).unwrap();
    
    // Create valid ordered ledger info for epoch 1
    let round = genesis_qc.certified_block().round();
    let block = test_utils::make_proposal_with_qc(round + 1, genesis_qc, &signer);
    let ordered_li = block.block().quorum_cert().ledger_info().clone();
    
    // Create commit ledger info with WRONG EPOCH (epoch 2)
    let wrong_epoch_commit_info = BlockInfo::new(
        2, // Wrong epoch!
        round + 1,
        block.block().id(),
        HashValue::random(),
        100,
        block.block().timestamp_usecs(),
        None,
    );
    let wrong_epoch_li = LedgerInfo::new(
        wrong_epoch_commit_info,
        ordered_li.ledger_info().consensus_data_hash(),
    );
    
    // Currently this SUCCEEDS but should FAIL
    let result = safety_rules.sign_commit_vote(
        ordered_li,
        wrong_epoch_li,
    );
    
    // With proper validation, this should return Error::IncorrectEpoch
    assert!(result.is_err()); // This will FAIL with current code
}

#[test]
fn test_sign_commit_vote_regressed_round() {
    use crate::tests::test_utils;
    
    let (mut safety_rules, signer) = test_utils::make_safety_rules();
    let (proof, genesis_qc) = test_utils::make_genesis(&signer);
    
    safety_rules.initialize(&proof).unwrap();
    
    // Sign a vote for round 10
    let block10 = test_utils::make_proposal_with_qc(10, genesis_qc.clone(), &signer);
    let ordered_li_10 = block10.block().quorum_cert().ledger_info().clone();
    let commit_li_10 = ordered_li_10.ledger_info().clone();
    
    safety_rules.sign_commit_vote(ordered_li_10.clone(), commit_li_10).unwrap();
    
    // Now try to sign for round 5 (regressed)
    let block5 = test_utils::make_proposal_with_qc(5, genesis_qc, &signer);
    let ordered_li_5 = block5.block().quorum_cert().ledger_info().clone();
    let commit_li_5 = ordered_li_5.ledger_info().clone();
    
    let result = safety_rules.sign_commit_vote(ordered_li_5, commit_li_5);
    
    // With proper extension check, this should fail
    assert!(result.is_err()); // This will FAIL with current code
}
```

## Notes

This vulnerability represents a **defense-in-depth failure** rather than a directly exploitable bug. The missing checks violate the principle that safety rules should validate ALL inputs, even from trusted consensus components. The TODO comments explicitly acknowledge these validations are needed but not implemented.

While direct exploitation requires a separate bug in the consensus pipeline, the severity of potential impact (consensus safety violations, chain splits) justifies fixing these missing validations to harden the system against future bugs or edge cases in state sync, crash recovery, and epoch transitions.

### Citations

**File:** consensus/safety-rules/src/safety_rules.rs (L63-85)
```rust
    pub(crate) fn verify_proposal(
        &mut self,
        vote_proposal: &VoteProposal,
    ) -> Result<VoteData, Error> {
        let proposed_block = vote_proposal.block();
        let safety_data = self.persistent_storage.safety_data()?;

        self.verify_epoch(proposed_block.epoch(), &safety_data)?;

        self.verify_qc(proposed_block.quorum_cert())?;
        if !self.skip_sig_verify {
            proposed_block
                .validate_signature(&self.epoch_state()?.verifier)
                .map_err(|error| Error::InvalidProposal(error.to_string()))?;
        }
        proposed_block
            .verify_well_formed()
            .map_err(|error| Error::InvalidProposal(error.to_string()))?;

        vote_proposal
            .gen_vote_data()
            .map_err(|error| Error::InvalidAccumulatorExtension(error.to_string()))
    }
```

**File:** consensus/safety-rules/src/safety_rules.rs (L372-418)
```rust
    fn guarded_sign_commit_vote(
        &mut self,
        ledger_info: LedgerInfoWithSignatures,
        new_ledger_info: LedgerInfo,
    ) -> Result<bls12381::Signature, Error> {
        self.signer()?;

        let old_ledger_info = ledger_info.ledger_info();

        if !old_ledger_info.commit_info().is_ordered_only()
            // When doing fast forward sync, we pull the latest blocks and quorum certs from peers
            // and store them in storage. We then compute the root ordered cert and root commit cert
            // from storage and start the consensus from there. But given that we are not storing the
            // ordered cert obtained from order votes in storage, instead of obtaining the root ordered cert
            // from storage, we set root ordered cert to commit certificate.
            // This means, the root ordered cert will not have a dummy executed_state_id in this case.
            // To handle this, we do not raise error if the old_ledger_info.commit_info() matches with
            // new_ledger_info.commit_info().
            && old_ledger_info.commit_info() != new_ledger_info.commit_info()
        {
            return Err(Error::InvalidOrderedLedgerInfo(old_ledger_info.to_string()));
        }

        if !old_ledger_info
            .commit_info()
            .match_ordered_only(new_ledger_info.commit_info())
        {
            return Err(Error::InconsistentExecutionResult(
                old_ledger_info.commit_info().to_string(),
                new_ledger_info.commit_info().to_string(),
            ));
        }

        // Verify that ledger_info contains at least 2f + 1 dostinct signatures
        if !self.skip_sig_verify {
            ledger_info
                .verify_signatures(&self.epoch_state()?.verifier)
                .map_err(|error| Error::InvalidQuorumCertificate(error.to_string()))?;
        }

        // TODO: add guarding rules in unhappy path
        // TODO: add extension check

        let signature = self.sign(&new_ledger_info)?;

        Ok(signature)
    }
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L53-95)
```rust
    pub(crate) fn guarded_construct_and_sign_vote_two_chain(
        &mut self,
        vote_proposal: &VoteProposal,
        timeout_cert: Option<&TwoChainTimeoutCertificate>,
    ) -> Result<Vote, Error> {
        // Exit early if we cannot sign
        self.signer()?;

        let vote_data = self.verify_proposal(vote_proposal)?;
        if let Some(tc) = timeout_cert {
            self.verify_tc(tc)?;
        }
        let proposed_block = vote_proposal.block();
        let mut safety_data = self.persistent_storage.safety_data()?;

        // if already voted on this round, send back the previous vote
        // note: this needs to happen after verifying the epoch as we just check the round here
        if let Some(vote) = safety_data.last_vote.clone() {
            if vote.vote_data().proposed().round() == proposed_block.round() {
                return Ok(vote);
            }
        }

        // Two voting rules
        self.verify_and_update_last_vote_round(
            proposed_block.block_data().round(),
            &mut safety_data,
        )?;
        self.safe_to_vote(proposed_block, timeout_cert)?;

        // Record 1-chain data
        self.observe_qc(proposed_block.quorum_cert(), &mut safety_data);
        // Construct and sign vote
        let author = self.signer()?.author();
        let ledger_info = self.construct_ledger_info_2chain(proposed_block, vote_data.hash())?;
        let signature = self.sign(&ledger_info)?;
        let vote = Vote::new_with_signature(vote_data, author, ledger_info, signature);

        safety_data.last_vote = Some(vote.clone());
        self.persistent_storage.set_safety_data(safety_data)?;

        Ok(vote)
    }
```

**File:** types/src/block_info.rs (L196-204)
```rust
    pub fn match_ordered_only(&self, executed_block_info: &BlockInfo) -> bool {
        self.epoch == executed_block_info.epoch
            && self.round == executed_block_info.round
            && self.id == executed_block_info.id
            && (self.timestamp_usecs == executed_block_info.timestamp_usecs
            // executed block info has changed its timestamp because it's a reconfiguration suffix
                || (self.timestamp_usecs > executed_block_info.timestamp_usecs
                    && executed_block_info.has_reconfiguration()))
    }
```

**File:** types/src/block_info.rs (L209-214)
```rust
    pub fn is_ordered_only(&self) -> bool {
        *self != BlockInfo::empty()
            && self.next_epoch_state.is_none()
            && self.executed_state_id == *ACCUMULATOR_PLACEHOLDER_HASH
            && self.version == 0
    }
```
