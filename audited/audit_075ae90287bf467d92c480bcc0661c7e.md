# Audit Report

## Title
Critical Epoch Boundary Validation Bypass During Backup Restore Allows Malicious Validator Set Injection

## Summary
The epoch ending restore process fails to cryptographically validate the first epoch ending ledger info when no trusted waypoints are provided, allowing an attacker to inject arbitrary validator sets that bypass all signature verification and compromise consensus safety.

## Finding Description

The `EPOCH_ENDING_VERSION` metric is a monitoring gauge that tracks restore progress. [1](#0-0) 

However, the critical vulnerability exists in the epoch ending restore validation logic. During the restoration of epoch ending backups, the system performs validation in the `preheat_impl` function. [2](#0-1) 

The validation logic for each ledger info follows this pattern: first check the waypoint matches the manifest, then either verify against a trusted waypoint OR verify signatures using the previous epoch's validator set. [3](#0-2) 

**The Critical Flaw**: When restoring the very first epoch ending ledger info where:
1. `previous_li` is `None` (first iteration)
2. No trusted waypoint exists for that version
3. The only validation is that the manifest waypoint matches the computed waypoint (both attacker-controlled)

This results in **zero cryptographic validation** of the first ledger info's signatures or validator set.

The trusted waypoints are optional via the `--trust-waypoint` CLI parameter. [4](#0-3) 

Once the malicious first ledger info is accepted, its `next_epoch_state` field (containing the attacker's validator set) is used to verify all subsequent epoch ending ledger infos, creating a chain of false validation.

The malicious data is then persisted to the database. [5](#0-4) 

**No Post-Restore Validation**: When the node starts, the `maybe_bootstrap` function skips genesis validation if the database already contains data. [6](#0-5) 

The database simply loads the malicious validator sets without re-validation. [7](#0-6) 

## Impact Explanation

This vulnerability achieves **Critical Severity** under the Aptos bug bounty criteria:

- **Consensus/Safety Violation**: Breaks the fundamental AptosBFT safety invariant that requires cryptographically verified validator sets for consensus participation
- **Validator Set Manipulation**: Allows attacker to inject arbitrary validator public keys, completely compromising the BFT consensus mechanism
- **Chain Fork Potential**: An operator restoring from malicious backup will run a divergent chain with attacker-controlled validators
- **Fund Theft Vector**: If combined with social engineering to get users to interact with the forked chain, enables theft of assets

## Likelihood Explanation

**Likelihood: Medium to High**

- **Attack Complexity**: Low - attacker only needs to host malicious backup files
- **Operator Error**: Requires operator to omit `--trust-waypoint` flag during restore, which is documented but not enforced
- **Common Scenario**: New validator operators setting up nodes from backup are likely targets
- **No Warning**: System provides no warning about missing trusted waypoints for genesis/first epochs

The attack is particularly concerning for:
- Testnets where operators may be less security-conscious
- New operators following incomplete documentation
- Disaster recovery scenarios under time pressure

## Recommendation

**Immediate Fix**: Require at least one trusted waypoint (preferably genesis) when restoring epoch ending backups.

**Implementation**:
1. Modify `EpochEndingRestoreController::new()` to validate that `trusted_waypoints` contains at minimum the genesis waypoint (version 0)
2. Add validation in `preheat_impl` to ensure the first ledger info either has a trusted waypoint or is being verified against a provided `previous_epoch_ending_ledger_info`
3. Enhance the CLI to make `--trust-waypoint` mandatory for epoch ending restores
4. Add explicit error message: "Epoch ending restore requires at least genesis waypoint for security"

**Code Fix** (conceptual):
```rust
// In EpochEndingRestoreController::new()
ensure!(
    !global_opt.trusted_waypoints.is_empty() || 
    /* future: allow previous_epoch_ending_ledger_info */,
    "Epoch ending restore requires trusted waypoints for security. \
    At minimum, provide genesis waypoint with --trust-waypoint"
);
```

## Proof of Concept

**Attack Steps**:

1. **Create Malicious Backup**:
   - Generate fake epoch ending ledger info with attacker-controlled validator keys in `next_epoch_state`
   - Create manifest with waypoint matching the fake ledger info
   - Host files at attacker-controlled URL

2. **Victim Restore** (operator runs):
   ```bash
   aptos-db restore epoch-ending \
     --epoch-ending-manifest https://attacker.com/fake-backup/manifest.json \
     --target-db-dir /path/to/db
   # Note: No --trust-waypoint flag used
   ```

3. **Validation Bypass**:
   - `preheat_impl` executes validation loop
   - First ledger info: `previous_li` = `None`, `trusted_waypoints.get()` = `None`
   - Only check: `manifest_waypoint == computed_waypoint` (both attacker-controlled)
   - **No signature verification occurs**
   - Malicious validator set accepted

4. **Persistence**:
   - `save_ledger_infos` commits malicious data to database
   - Node starts, `maybe_bootstrap` skips validation (DB not empty)
   - Node runs with attacker's validator set

5. **Impact Verification**:
   - Query `get_epoch_state(1)` returns attacker's validators
   - Node diverges from canonical Aptos chain
   - Consensus controlled by attacker's keys

**Expected Result**: Node accepts and persists malicious validator set without any signature verification, compromising consensus safety.

## Notes

While the `EPOCH_ENDING_VERSION` metric itself is just observability instrumentation, this investigation revealed a critical vulnerability in the epoch boundary validation logic during restore operations. The metric is set only after validation completes, so it cannot directly cause the vulnerability, but the broader restore validation logic where this metric is used contains the exploitable flaw. The vulnerability allows bypassing the cryptographic verification that is essential for maintaining consensus safety and validator set integrity.

### Citations

**File:** storage/backup/backup-cli/src/metrics/restore.rs (L23-29)
```rust
pub static EPOCH_ENDING_VERSION: Lazy<IntGauge> = Lazy::new(|| {
    register_int_gauge!(
        "aptos_db_restore_epoch_ending_version",
        "Last version of the current epoch ending being restored."
    )
    .unwrap()
});
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L80-158)
```rust
    async fn preheat_impl(&self) -> Result<EpochEndingRestorePreheatData> {
        let manifest: EpochEndingBackup =
            self.storage.load_json_file(&self.manifest_handle).await?;
        manifest.verify()?;

        let mut next_epoch = manifest.first_epoch;
        let mut waypoint_iter = manifest.waypoints.iter();

        let mut previous_li: Option<&LedgerInfoWithSignatures> = None;
        let mut ledger_infos = Vec::new();

        let mut past_target = false;
        for chunk in &manifest.chunks {
            if past_target {
                break;
            }

            let lis = self.read_chunk(&chunk.ledger_infos).await?;
            ensure!(
                chunk.first_epoch + lis.len() as u64 == chunk.last_epoch + 1,
                "Number of items in chunks doesn't match that in manifest. \
                first_epoch: {}, last_epoch: {}, items in chunk: {}",
                chunk.first_epoch,
                chunk.last_epoch,
                lis.len(),
            );

            for li in lis {
                if li.ledger_info().version() > self.target_version {
                    past_target = true;
                    break;
                }

                ensure!(
                    li.ledger_info().epoch() == next_epoch,
                    "LedgerInfo epoch not expected. Expected: {}, actual: {}.",
                    li.ledger_info().epoch(),
                    next_epoch,
                );
                let wp_manifest = waypoint_iter.next().ok_or_else(|| {
                    anyhow!("More LedgerInfo's found than waypoints in manifest.")
                })?;
                let wp_li = Waypoint::new_epoch_boundary(li.ledger_info())?;
                ensure!(
                    *wp_manifest == wp_li,
                    "Waypoints don't match. In manifest: {}, In chunk: {}",
                    wp_manifest,
                    wp_li,
                );
                if let Some(wp_trusted) = self.trusted_waypoints.get(&wp_li.version()) {
                    ensure!(
                        *wp_trusted == wp_li,
                        "Waypoints don't match. In backup: {}, trusted: {}",
                        wp_li,
                        wp_trusted,
                    );
                } else if let Some(pre_li) = previous_li {
                    pre_li
                        .ledger_info()
                        .next_epoch_state()
                        .ok_or_else(|| {
                            anyhow!(
                                "Next epoch state not found from LI at epoch {}.",
                                pre_li.ledger_info().epoch()
                            )
                        })?
                        .verify(&li)?;
                }
                ledger_infos.push(li);
                previous_li = ledger_infos.last();
                next_epoch += 1;
            }
        }

        Ok(EpochEndingRestorePreheatData {
            manifest,
            ledger_infos,
        })
    }
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L248-253)
```rust
            RestoreRunMode::Restore { restore_handler } => {
                restore_handler.save_ledger_infos(&preheat_data.ledger_infos)?;

                EPOCH_ENDING_EPOCH.set(last_li.epoch() as i64);
                EPOCH_ENDING_VERSION.set(last_li.version() as i64);
            },
```

**File:** storage/backup/backup-cli/src/utils/mod.rs (L332-346)
```rust
pub struct TrustedWaypointOpt {
    #[clap(
        long,
        help = "(multiple) When provided, an epoch ending LedgerInfo at the waypoint version will be \
        checked against the hash in the waypoint, but signatures on it are NOT checked. \
        Use this for two purposes: \
        1. set the genesis or the latest waypoint to confirm the backup is compatible. \
        2. set waypoints at versions where writeset transactions were used to overwrite the \
        validator set, so that the signature check is skipped. \
        N.B. LedgerInfos are verified only when restoring / verifying the epoch ending backups, \
        i.e. they are NOT checked at all when doing one-shot restoring of the transaction \
        and state backups."
    )]
    pub trust_waypoint: Vec<Waypoint>,
}
```

**File:** execution/executor/src/db_bootstrapper/mod.rs (L56-59)
```rust
    if ledger_summary.version().map_or(0, |v| v + 1) != waypoint.version() {
        info!(waypoint = %waypoint, "Skip genesis txn.");
        return Ok(None);
    }
```

**File:** storage/aptosdb/src/ledger_db/ledger_metadata_db.rs (L135-154)
```rust
    pub(crate) fn get_epoch_state(&self, epoch: u64) -> Result<EpochState> {
        ensure!(epoch > 0, "EpochState only queryable for epoch >= 1.",);

        let ledger_info_with_sigs =
            self.db
                .get::<LedgerInfoSchema>(&(epoch - 1))?
                .ok_or_else(|| {
                    AptosDbError::NotFound(format!("Last LedgerInfo of epoch {}", epoch - 1))
                })?;
        let latest_epoch_state = ledger_info_with_sigs
            .ledger_info()
            .next_epoch_state()
            .ok_or_else(|| {
                AptosDbError::Other(
                    "Last LedgerInfo in epoch must carry next_epoch_state.".to_string(),
                )
            })?;

        Ok(latest_epoch_state.clone())
    }
```
