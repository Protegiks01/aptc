# Audit Report

## Title
Integer Overflow Leading to Complete State Merkle Database Corruption via Unchecked Addition in Truncation Path

## Summary
The `delete_nodes_and_stale_indices_at_or_after_version()` function lacks input validation and contains an integer overflow vulnerability in its caller `truncate_state_merkle_db_single_shard()`. When `target_version = u64::MAX`, the unchecked addition `target_version + 1` wraps to 0 in release builds, causing all state merkle tree nodes (including genesis) and progress metadata to be deleted, rendering the database completely unusable. [1](#0-0) 

## Finding Description

The vulnerability exists in a two-stage failure:

**Stage 1: Integer Overflow in Caller** [2](#0-1) 

The function performs unchecked addition `target_version + 1` which wraps to 0 when `target_version = u64::MAX` in release builds (debug builds panic).

**Stage 2: Catastrophic Deletion with version = 0** [3](#0-2) 

When `version = 0` is passed:
1. `version.checked_sub(1)` returns `None`
2. `StateMerkleDb::put_progress(None, ...)` **deletes** the progress metadata instead of updating it [4](#0-3) 

3. All JellyfishMerkleNode entries at version â‰¥ 0 are deleted (lines 614-619), **including genesis**

**Trigger Conditions:**
The overflow can occur when `truncate_state_merkle_db_shards` is called with `target_version = u64::MAX` during database initialization: [5](#0-4) 

If the `StateMerkleCommitProgress` metadata becomes corrupted and contains `u64::MAX`, the initialization path triggers the overflow.

**Invariant Violation:**
Breaks the **State Consistency** invariant - the database should always maintain genesis (version 0) and valid progress tracking. The code also violates defensive programming principles found elsewhere in the codebase: [6](#0-5) 

## Impact Explanation

**Severity: High** (per Aptos bug bounty criteria)

**Impact if triggered:**
- Complete deletion of all state merkle tree nodes including genesis
- Progress metadata deletion leaving database in untrackable state
- Validator node becomes completely non-functional, cannot sync or process blocks
- Requires full database wipe and resynchronization from genesis
- In a validator context: Total node failure causing missed attestations and potential slashing

This meets **High Severity** criteria: "Validator node slowdowns" and "Significant protocol violations" - though the impact is actually closer to a complete node crash.

## Likelihood Explanation

**Likelihood: Low to Medium**

The vulnerability requires specific conditions to trigger:

1. **Database corruption** causing `StateMerkleCommitProgress` to contain `u64::MAX` 
2. **Another bug** in progress tracking code that writes `u64::MAX`
3. **Malformed database recovery** after crash during certain operations

While direct external exploitation is not feasible, the conditions could occur through:
- Storage layer bugs or race conditions
- Improper error handling in crash recovery
- Database migration issues
- File system corruption affecting RocksDB

The lack of input validation means any corruption propagates to catastrophic failure rather than being caught early.

## Recommendation

Add defensive input validation to prevent both the overflow and version = 0 scenarios:

```rust
fn delete_nodes_and_stale_indices_at_or_after_version(
    db: &DB,
    version: Version,
    shard_id: Option<usize>,
    batch: &mut SchemaBatch,
) -> Result<()> {
    // Add validation to prevent deletion of genesis
    ensure!(
        version > 0,
        "Cannot delete nodes at genesis (version 0). This would corrupt the database."
    );
    
    delete_stale_node_index_at_or_after_version::<StaleNodeIndexSchema>(db, version, batch)?;
    delete_stale_node_index_at_or_after_version::<StaleNodeIndexCrossEpochSchema>(
        db, version, batch,
    )?;

    let mut iter = db.iter::<JellyfishMerkleNodeSchema>()?;
    iter.seek(&NodeKey::new_empty_path(version))?;
    for item in iter {
        let (key, _) = item?;
        batch.delete::<JellyfishMerkleNodeSchema>(&key)?;
    }

    // Safe to subtract 1 since version > 0
    StateMerkleDb::put_progress(Some(version - 1), shard_id, batch)
}
```

Additionally, fix the overflow in the caller:

```rust
pub(crate) fn truncate_state_merkle_db_single_shard(
    state_merkle_db: &StateMerkleDb,
    shard_id: usize,
    target_version: Version,
) -> Result<()> {
    let mut batch = SchemaBatch::new();
    
    // Use checked_add to prevent overflow
    let delete_from_version = target_version.checked_add(1)
        .ok_or_else(|| anyhow!("Target version too large, would overflow"))?;
    
    delete_nodes_and_stale_indices_at_or_after_version(
        state_merkle_db.db_shard(shard_id),
        delete_from_version,
        Some(shard_id),
        &mut batch,
    )?;
    state_merkle_db.db_shard(shard_id).write_schemas(batch)
}
```

## Proof of Concept

```rust
#[test]
#[should_panic(expected = "Cannot delete nodes at genesis")]
fn test_delete_nodes_at_genesis_prevented() {
    use tempfile::tempdir;
    let tmpdir = tempdir().unwrap();
    let db = DB::open(tmpdir.path(), "test_db", &[]).unwrap();
    
    // Simulate corrupted metadata containing u64::MAX
    let mut metadata_batch = SchemaBatch::new();
    metadata_batch.put::<DbMetadataSchema>(
        &DbMetadataKey::StateMerkleCommitProgress,
        &DbMetadataValue::Version(u64::MAX),
    ).unwrap();
    db.write_schemas(metadata_batch).unwrap();
    
    // This should trigger the overflow: u64::MAX + 1 = 0 in release mode
    let mut batch = SchemaBatch::new();
    
    // In release build, this would call with version = 0
    // The fix should catch this and panic with proper error message
    delete_nodes_and_stale_indices_at_or_after_version(
        &db,
        0, // Simulating the wrapped value
        None,
        &mut batch,
    ).unwrap(); // Should fail with proper validation
}
```

**Notes**

While this vulnerability has low exploitability by external attackers (requires database corruption or another bug to trigger), it represents a critical defensive programming failure. The codebase demonstrates awareness of version 0 being special (genesis) in other functions but fails to protect against it here. The lack of input validation means that any corruption or bug propagates to catastrophic database failure rather than being caught early with a clear error message. This should be fixed to improve system robustness and fail-safe behavior.

### Citations

**File:** storage/aptosdb/src/utils/truncation_helper.rs (L193-206)
```rust
pub(crate) fn truncate_state_merkle_db_single_shard(
    state_merkle_db: &StateMerkleDb,
    shard_id: usize,
    target_version: Version,
) -> Result<()> {
    let mut batch = SchemaBatch::new();
    delete_nodes_and_stale_indices_at_or_after_version(
        state_merkle_db.db_shard(shard_id),
        target_version + 1,
        Some(shard_id),
        &mut batch,
    )?;
    state_merkle_db.db_shard(shard_id).write_schemas(batch)
}
```

**File:** storage/aptosdb/src/utils/truncation_helper.rs (L603-622)
```rust
fn delete_nodes_and_stale_indices_at_or_after_version(
    db: &DB,
    version: Version,
    shard_id: Option<usize>,
    batch: &mut SchemaBatch,
) -> Result<()> {
    delete_stale_node_index_at_or_after_version::<StaleNodeIndexSchema>(db, version, batch)?;
    delete_stale_node_index_at_or_after_version::<StaleNodeIndexCrossEpochSchema>(
        db, version, batch,
    )?;

    let mut iter = db.iter::<JellyfishMerkleNodeSchema>()?;
    iter.seek(&NodeKey::new_empty_path(version))?;
    for item in iter {
        let (key, _) = item?;
        batch.delete::<JellyfishMerkleNodeSchema>(&key)?;
    }

    StateMerkleDb::put_progress(version.checked_sub(1), shard_id, batch)
}
```

**File:** storage/aptosdb/src/state_merkle_db.rs (L323-347)
```rust
    pub fn get_state_snapshot_version_before(
        &self,
        next_version: Version,
    ) -> Result<Option<Version>> {
        if next_version > 0 {
            let max_possible_version = next_version - 1;
            let mut iter = self.metadata_db().rev_iter::<JellyfishMerkleNodeSchema>()?;
            iter.seek_for_prev(&NodeKey::new_empty_path(max_possible_version))?;
            if let Some((key, _node)) = iter.next().transpose()? {
                let version = key.version();
                if self
                    .metadata_db()
                    .get::<JellyfishMerkleNodeSchema>(&NodeKey::new_empty_path(version))?
                    .is_some()
                {
                    return Ok(Some(version));
                }
                // Since we split state merkle commit into multiple batches, it's possible that
                // the root is not committed yet. In this case we need to look at the previous
                // root.
                return self.get_state_snapshot_version_before(version);
            }
        }
        // No version before genesis.
        Ok(None)
```

**File:** storage/aptosdb/src/state_merkle_db.rs (L393-409)
```rust
    pub(crate) fn put_progress(
        version: Option<Version>,
        shard_id: Option<usize>,
        batch: &mut impl WriteBatch,
    ) -> Result<()> {
        let key = if let Some(shard_id) = shard_id {
            DbMetadataKey::StateMerkleShardCommitProgress(shard_id)
        } else {
            DbMetadataKey::StateMerkleCommitProgress
        };

        if let Some(version) = version {
            batch.put::<DbMetadataSchema>(&key, &DbMetadataValue::Version(version))
        } else {
            batch.delete::<DbMetadataSchema>(&key)
        }
    }
```

**File:** storage/aptosdb/src/state_merkle_db.rs (L668-676)
```rust
        if !readonly {
            if let Some(overall_state_merkle_commit_progress) =
                get_state_merkle_commit_progress(&state_merkle_db)?
            {
                truncate_state_merkle_db_shards(
                    &state_merkle_db,
                    overall_state_merkle_commit_progress,
                )?;
            }
```
