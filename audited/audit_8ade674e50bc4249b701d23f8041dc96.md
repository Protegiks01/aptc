# Audit Report

## Title
Critical Private Key Exposure Through Command-Line Arguments in Aptos CLI Key Tool

## Summary
The Aptos CLI Key tool accepts private cryptographic keys directly as command-line arguments via `--private-key` and `--private-network-key` options. This design flaw exposes sensitive key material through process listings, shell history, system logs, and audit trails, enabling unauthorized key theft by any user with system access or log visibility.

## Finding Description
The vulnerability exists in two distinct locations where private keys can be provided as command-line arguments:

**1. NetworkKeyInputOptions in the Key tool:** [1](#0-0) 

The `--private-network-key` option accepts x25519 private keys directly on the command line for the `extract-peer` command.

**2. PrivateKeyInputOptions used across multiple commands:** [2](#0-1) 

The `--private-key` option accepts Ed25519 private keys directly on the command line and is used by multiple commands including `extract-public-key`.

When users invoke commands like:
```bash
aptos key extract-peer --private-network-key 404acc8ec6a0f18df7359a6ee7823f19dd95616b10fed8bdb0de030e891b945a --host example.com:6180
```

The private key becomes visible through:
- **Process listings**: Any user running `ps aux`, `top`, or reading `/proc/<pid>/cmdline` can view the complete command including the private key
- **Shell history**: The command persists in `~/.bash_history`, `~/.zsh_history`, etc., often indefinitely
- **System audit logs**: Tools like auditd on Linux record all commands executed
- **Centralized logging**: Many organizations log all commands to centralized SIEM systems
- **Parent process inspection**: Any parent process can read child process arguments

The key extraction logic processes these arguments: [3](#0-2) 

While the codebase properly protects keys in other areas (using SilentDebug/SilentDisplay traits [4](#0-3)  and restricted file permissions [5](#0-4) ), accepting keys as command-line arguments completely bypasses these protections.

This breaks the **Cryptographic Correctness** invariant which mandates that cryptographic operations and key material must be secure.

## Impact Explanation
This vulnerability qualifies as **Critical Severity** under the Aptos Bug Bounty program criteria for the following reasons:

1. **Loss of Funds**: If a user's account private key is exposed, attackers can steal all funds from that account by signing unauthorized transactions.

2. **Consensus/Safety Violations**: If validator network keys (x25519) or validator operator keys are exposed through this mechanism, attackers can:
   - Impersonate validators in the network layer
   - Potentially disrupt consensus by injecting malicious messages
   - Compromise the validator's ability to participate in consensus

3. **Validator Node Compromise**: Exposed validator operator keys enable attackers to:
   - Submit malicious transactions on behalf of validators
   - Manipulate staking operations
   - Potentially take control of validator accounts

The vulnerability affects all users of the Aptos CLI who utilize the command-line key input options, including validator operators during initial setup or key rotation procedures.

## Likelihood Explanation
This vulnerability has **HIGH likelihood** of exploitation:

**Attack Complexity**: Trivial - no special tools or privileges required
- Attacker only needs read access to `/proc` filesystem (standard on Linux)
- Or access to shell history files (often world-readable or accessible via backups)
- Or access to system logs (common in shared environments or compromised systems)

**Real-World Scenarios**:
1. **Shared/Multi-tenant Systems**: On systems with multiple users, any user can view processes of others
2. **Compromised Systems**: Attackers gaining initial access immediately see command history
3. **Backup/Log Aggregation**: Keys may be extracted from archived logs months later
4. **Cloud Environments**: Instance metadata or logging services may capture commands
5. **CI/CD Pipelines**: Build logs often capture full command invocations

**User Error**: Users may not realize the security implications of command-line arguments versus file-based inputs, especially since:
- The documentation doesn't warn against using `--private-key` directly
- The option is provided as a convenience feature
- Users may copy-paste examples that use this insecure pattern

## Recommendation
**Immediate Fix**: Remove or deprecate the `--private-key` and `--private-network-key` command-line options entirely. Force users to use secure alternatives:

1. **File-based input** (already supported): `--private-key-file` and `--private-network-key-file`
2. **Standard input**: Add support for reading keys from stdin
3. **Interactive prompt**: Add support for prompting users with hidden input (terminal echo disabled)

**Code Changes Required**:

For `NetworkKeyInputOptions`: [1](#0-0) 
Remove the `private_network_key: Option<String>` field and associated logic.

For `PrivateKeyInputOptions`: [2](#0-1) 
Remove the `private_key: Option<String>` field and associated logic.

**Documentation**: Add prominent security warnings in CLI documentation and error messages explaining why direct command-line key input is dangerous.

**Migration Path**: 
- Add deprecation warnings when these options are used
- Provide clear migration guidance to file-based or stdin-based alternatives
- Remove the options in a future major version

## Proof of Concept

**Step 1**: Generate a private key using the CLI:
```bash
aptos key generate --output-file test-key
```

**Step 2**: Extract the private key from the file:
```bash
PRIVATE_KEY=$(cat test-key)
```

**Step 3**: In one terminal, run the vulnerable command:
```bash
aptos key extract-public-key --private-key "$PRIVATE_KEY" --output-file test-public-key --assume-yes
```

**Step 4**: In another terminal (as any user on the system), capture the private key:
```bash
# Immediate exposure via process listing
ps aux | grep "aptos key extract-public-key"

# Persistent exposure in shell history
cat ~/.bash_history | grep "private-key"

# Exposure via /proc filesystem (if process still running)
cat /proc/$(pgrep -f "aptos key")/cmdline | tr '\0' ' '
```

**Expected Result**: The private key `$PRIVATE_KEY` is visible in plaintext in all three locations, demonstrating complete key exposure.

**Impact Demonstration**: An attacker with access to any of these data sources can:
1. Copy the exposed private key
2. Use it to sign transactions and steal funds from the associated account
3. If the key is a validator key, compromise consensus participation

**Notes**
The vulnerability is present across multiple Aptos CLI commands that accept the `--private-key` option through `PrivateKeyInputOptions`, not just the Key tool. This includes transaction signing operations and other sensitive operations throughout the CLI. While the codebase demonstrates security awareness in other areas (protected Debug implementations, restricted file permissions), this fundamental design flaw in command-line argument handling creates a critical exposure vector that undermines those protections.

### Citations

**File:** crates/aptos/src/op/key.rs (L119-136)
```rust
#[derive(Debug, Default, Parser)]
pub struct NetworkKeyInputOptions {
    /// x25519 Private key input file name
    #[clap(long, group = "network_key_input", value_parser)]
    private_network_key_file: Option<PathBuf>,

    /// x25519 Private key encoded in a type as shown in `encoding`
    #[clap(long, group = "network_key_input")]
    private_network_key: Option<String>,

    /// x25519 Public key input file name
    #[clap(long, group = "network_key_input", value_parser)]
    public_network_key_file: Option<PathBuf>,

    /// x25519 Public key encoded in a type as shown in `encoding`
    #[clap(long, group = "network_key_input")]
    public_network_key: Option<String>,
}
```

**File:** crates/aptos/src/op/key.rs (L148-166)
```rust
    pub fn extract_public_network_key(
        self,
        encoding: EncodingType,
    ) -> CliTypedResult<x25519::PublicKey> {
        // The grouping above prevents there from being more than one, but just in case
        match (self.public_network_key, self.public_network_key_file, self.private_network_key, self.private_network_key_file) {
            (Some(public_network_key), None, None, None) => Ok(encoding.decode_key("--public-network-key", public_network_key.as_bytes().to_vec())?),
            (None, Some(public_network_key_file), None, None) => Ok(encoding.load_key("--public-network-key-file", public_network_key_file.as_path())?),
            (None, None, Some(private_network_key), None) => {
                let private_network_key: x25519::PrivateKey = encoding.decode_key("--private-network-key", private_network_key.as_bytes().to_vec())?;
                Ok(private_network_key.public_key())
            }
            (None, None, None, Some(private_network_key_file)) => {
                let private_network_key: x25519::PrivateKey = encoding.load_key("--private-network-key-file", private_network_key_file.as_path())?;
                Ok(private_network_key.public_key())
            }
            _ => Err(CliError::CommandArgumentError("Must provide exactly one of [--public-network-key, --public-network-key-file, --private-network-key, --private-network-key-file]".to_string()))
        }
    }
```

**File:** crates/aptos/src/common/types.rs (L780-794)
```rust
#[derive(Debug, Default, Parser)]
pub struct PrivateKeyInputOptions {
    /// Signing Ed25519 private key file path
    ///
    /// Encoded with type from `--encoding`
    /// Mutually exclusive with `--private-key`
    #[clap(long, group = "private_key_input", value_parser)]
    private_key_file: Option<PathBuf>,
    /// Signing Ed25519 private key
    ///
    /// Encoded with type from `--encoding`
    /// Mutually exclusive with `--private-key-file`
    #[clap(long, group = "private_key_input")]
    private_key: Option<String>,
}
```

**File:** crates/aptos/src/common/types.rs (L1083-1089)
```rust
    /// Save to the `output_file` with restricted permissions (mode 0600)
    pub fn save_to_file_confidential(&self, name: &str, bytes: &[u8]) -> CliTypedResult<()> {
        let mut opts = OpenOptions::new();
        #[cfg(unix)]
        opts.mode(0o600);
        write_to_file_with_opts(self.output_file.as_path(), name, bytes, &mut opts)
    }
```

**File:** crates/aptos-crypto/src/ed25519/ed25519_keys.rs (L22-24)
```rust
/// An Ed25519 private key
#[derive(DeserializeKey, SerializeKey, SilentDebug, SilentDisplay)]
pub struct Ed25519PrivateKey(pub(crate) ed25519_dalek::SecretKey);
```
