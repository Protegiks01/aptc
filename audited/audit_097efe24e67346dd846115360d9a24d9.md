# Audit Report

## Title
StateKeysSchema Index Bloat Causes API Performance Degradation and Resource Exhaustion

## Summary
The `StateKeysSchema` indexer accumulates deleted state keys indefinitely without cleanup, causing progressive performance degradation for API queries. While query results remain correct, the system suffers from increased database read amplification and potential API timeouts as deleted keys accumulate over time.

## Finding Description

The internal indexer's `StateKeysSchema` maintains an index of state keys to enable efficient prefix-based queries when database sharding is enabled. However, the indexing logic contains a critical asymmetry:

**Indexing Path (Transaction Processing):**
When transactions execute, the `DBIndexer::process_a_batch` method only indexes creation and modification operations: [1](#0-0) 

Deletion operations (`write_op.is_deletion()`) are explicitly **not indexed**, meaning deleted keys are never removed from `StateKeysSchema`.

**Query Path (API Requests):**
When API endpoints query resources or modules by prefix (used in `get_resources_by_pagination`, `get_modules_by_pagination`), the `PrefixedStateValueIterator` iterates over all keys in `StateKeysSchema` and fetches corresponding values from the main database: [2](#0-1) 

For each deleted key still present in `StateKeysSchema`, the iterator:
1. Reads the key from `StateKeysSchema` (DB read)
2. Queries `state_kv_db` for the value (DB read)
3. Receives `None` (key was deleted)
4. Continues to next key

**Attack Scenario:**
An attacker can exploit this by:

1. Creating many table items under an account (e.g., 100,000 items via Move table operations)
2. Deleting all table items using `table::remove` operations
3. The deleted keys remain in `StateKeysSchema` indefinitely
4. Subsequent API queries for that account's resources iterate through all 100,000 deleted keys, performing 200,000 unnecessary database reads before returning results

**Validation Gap:**
The `verify_state_kvs` function only validates that keys in `state_kv_db` exist in `StateKeysSchema` (one direction), but never checks for orphaned keys in `StateKeysSchema`: [3](#0-2) 

No cleanup mechanism exists anywhere in the codebase to remove deleted keys from `StateKeysSchema`: [4](#0-3) 

## Impact Explanation

This qualifies as **High Severity** per Aptos bug bounty criteria:
- **"Validator node slowdowns"**: Progressive degradation affects all nodes running API services with sharding enabled
- **"API crashes"**: Queries can timeout when iterating through excessive deleted keys, causing service unavailability

The attack causes:
- **Read amplification**: Each deleted key causes 2 unnecessary DB reads (index + main DB lookup)
- **Unbounded growth**: `StateKeysSchema` size grows monotonically with no pruning
- **Service degradation**: API response times increase linearly with deleted key count
- **Resource exhaustion**: Excessive DB I/O can exhaust node resources

This does NOT affect consensus or state correctness (results are accurate when returned), but significantly impacts API availability and node performance.

## Likelihood Explanation

**High Likelihood:**
- Deletions occur naturally in normal Aptos operations (Move's `move_from`, `table::remove`, object deletions)
- No special privileges required - any user can create and delete table items
- The problem compounds over network lifetime as more deletions accumulate
- Production deployments with sharding enabled are directly affected

**Attack Complexity: Low**
- Simple Move transactions to create/delete table items
- No timing requirements or race conditions
- Deterministic and reproducible impact

## Recommendation

Implement deletion tracking in `StateKeysSchema` by modifying the indexing logic:

**Option 1: Index Deletions** (Recommended)
Modify `DBIndexer::process_a_batch` to remove deleted keys:

```rust
if self.indexer_db.statekeys_enabled() {
    writeset.write_op_iter().for_each(|(state_key, write_op)| {
        if write_op.is_creation() || write_op.is_modification() {
            batch
                .put::<StateKeysSchema>(state_key, &())
                .expect("Failed to put state keys to a batch");
        } else if write_op.is_deletion() {
            batch
                .delete::<StateKeysSchema>(state_key)
                .expect("Failed to delete state key from batch");
        }
    });
}
```

**Option 2: Periodic Pruning**
Implement a background pruner that:
1. Iterates through `StateKeysSchema`
2. Queries `state_kv_db` for current state
3. Removes keys that no longer exist in the main database

**Option 3: Bidirectional Validation**
Extend `verify_state_kvs` to also detect orphaned keys and trigger cleanup.

## Proof of Concept

```rust
// Rust test demonstrating the vulnerability
#[test]
fn test_state_keys_schema_bloat() {
    // Setup test environment with indexer enabled
    let (db, indexer) = setup_test_db_with_indexer();
    
    // Step 1: Create 10,000 table items via transactions
    let account = AccountAddress::random();
    for i in 0..10000 {
        let table_key = StateKey::table_item(&table_handle, &serialize(&i));
        let write_set = WriteSet::new(vec![
            (table_key.clone(), WriteOp::creation(b"value".to_vec(), metadata))
        ]);
        process_transaction(&indexer, write_set);
    }
    
    // Measure StateKeysSchema size
    let keys_before_delete = count_state_keys(&indexer);
    assert_eq!(keys_before_delete, 10000);
    
    // Step 2: Delete all 10,000 table items
    for i in 0..10000 {
        let table_key = StateKey::table_item(&table_handle, &serialize(&i));
        let write_set = WriteSet::new(vec![
            (table_key.clone(), WriteOp::deletion(metadata))
        ]);
        process_transaction(&indexer, write_set);
    }
    
    // Step 3: Verify orphaned keys remain in StateKeysSchema
    let keys_after_delete = count_state_keys(&indexer);
    assert_eq!(keys_after_delete, 10000); // BUG: Should be 0
    
    // Step 4: Measure query performance degradation
    let start = Instant::now();
    let result = indexer.get_prefixed_state_value_iterator(
        &StateKeyPrefix::from(account), 
        None, 
        version
    ).collect::<Vec<_>>();
    let elapsed = start.elapsed();
    
    // Query returns correct (empty) results but takes excessive time
    assert!(result.is_empty());
    assert!(elapsed > Duration::from_secs(5)); // Timeout in production
}
```

## Notes

This vulnerability creates an **index-state divergence** where `StateKeysSchema` contains keys that no longer exist in `state_kv_db`. While this doesn't produce incorrect query results (the iterator correctly filters deleted keys), it causes severe performance degradation through read amplification. The issue is exacerbated in production deployments with database sharding enabled, as these rely exclusively on the indexer-based iterator path for prefix queries.

### Citations

**File:** storage/indexer/src/db_indexer.rs (L90-108)
```rust
    pub fn write_keys_to_indexer_db(
        &self,
        keys: &Vec<StateKey>,
        snapshot_version: Version,
        progress: StateSnapshotProgress,
    ) -> Result<()> {
        // add state value to internal indexer
        let mut batch = SchemaBatch::new();
        for state_key in keys {
            batch.put::<StateKeysSchema>(state_key, &())?;
        }

        batch.put::<InternalIndexerMetadataSchema>(
            &MetadataKey::StateSnapshotRestoreProgress(snapshot_version),
            &MetadataValue::StateSnapshotProgress(progress),
        )?;
        self.db.write_schemas(batch)?;
        Ok(())
    }
```

**File:** storage/indexer/src/db_indexer.rs (L489-497)
```rust
            if self.indexer_db.statekeys_enabled() {
                writeset.write_op_iter().for_each(|(state_key, write_op)| {
                    if write_op.is_creation() || write_op.is_modification() {
                        batch
                            .put::<StateKeysSchema>(state_key, &())
                            .expect("Failed to put state keys to a batch");
                    }
                });
            }
```

**File:** storage/indexer/src/utils.rs (L49-74)
```rust
    pub fn next_impl(&mut self) -> anyhow::Result<Option<(StateKey, StateValue)>> {
        let iter = &mut self.state_keys_iter;
        if self.is_finished {
            return Ok(None);
        }
        while let Some((state_key, _)) = iter.next().transpose()? {
            if !self.key_prefix.is_prefix(&state_key)? {
                self.is_finished = true;
                return Ok(None);
            }

            match self
                .main_db
                .get_state_value_by_version(&state_key, self.desired_version)?
            {
                Some(state_value) => {
                    return Ok(Some((state_key, state_value)));
                },
                None => {
                    // state key doesn't have value before the desired version, continue to next state key
                    continue;
                },
            }
        }
        Ok(None)
    }
```

**File:** storage/aptosdb/src/db_debugger/validation.rs (L114-146)
```rust
pub fn verify_state_kvs(
    db_root_path: &Path,
    internal_db: &DB,
    target_ledger_version: u64,
) -> Result<()> {
    println!("Validating db statekeys");
    let storage_dir = StorageDirPaths::from_path(db_root_path);
    let state_kv_db =
        StateKvDb::open_sharded(&storage_dir, RocksdbConfig::default(), None, None, false)?;

    //read all statekeys from internal db and store them in mem
    let mut all_internal_keys = HashSet::new();
    let mut iter = internal_db.iter::<StateKeysSchema>()?;
    iter.seek_to_first();
    for (key_ind, state_key_res) in iter.enumerate() {
        let state_key = state_key_res?.0;
        let state_key_hash = state_key.hash();
        all_internal_keys.insert(state_key_hash);
        if key_ind % 10_000_000 == 0 {
            println!("Processed {} keys", key_ind);
        }
    }
    println!(
        "Number of state keys in internal db: {}",
        all_internal_keys.len()
    );
    for shard_id in 0..16 {
        let shard = state_kv_db.db_shard(shard_id);
        println!("Validating state_kv for shard {}", shard_id);
        verify_state_kv(shard, &all_internal_keys, target_ledger_version)?;
    }
    Ok(())
}
```
