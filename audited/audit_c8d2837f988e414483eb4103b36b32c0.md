# Audit Report

## Title
IP Blocklist Configuration Silently Accepts Empty Files, Bypassing IP Filtering Protection

## Summary
When the Aptos faucet's IP blocklist is configured but the IP range file exists as empty (or contains only comments/whitespace), the faucet starts successfully and operates without blocking any IPs. This violates the operator's security intent and could enable abuse of the faucet service in error conditions such as file corruption, deployment errors, or configuration management failures.

## Finding Description

The `IpRangeManager` class in the faucet loads IP ranges from a file without validating that at least one valid IP range was successfully parsed. [1](#0-0) 

When the IP range file exists but is empty (or contains only comments), the function:
1. Successfully opens the file (no error)
2. Creates empty `ipv4_list` and `ipv6_list` collections
3. Returns `Ok(Self)` with empty lists
4. No validation checks if any IP ranges were loaded

The `IpBlocklistChecker` then uses this manager to check incoming requests: [2](#0-1) 

With empty lists, `contains()` always returns `false`, so no IPs are ever blocked. The checker returns an empty rejection list, allowing all requests to proceed.

The faucet server builds these checkers during startup: [3](#0-2) 

Since empty files don't cause errors, the server starts successfully and processes requests without IP filtering: [4](#0-3) 

**Error Conditions Leading to Empty Files:**
- File corruption during deployment
- Configuration management system deploys wrong/truncated file
- Storage system errors causing data loss
- Deployment scripts that create placeholder files
- Accidental file overwrites

## Impact Explanation

This issue represents a **Medium severity** operational security vulnerability under the Aptos bug bounty categories:

While the faucet is an auxiliary service (not core consensus/execution), it still handles controlled resource distribution. The vulnerability enables:

1. **Service Abuse**: Malicious actors can bypass IP blocking to repeatedly drain faucet resources
2. **Resource Exhaustion**: Attackers previously blocked can resume attacks, potentially exhausting the faucet account balance
3. **Silent Security Degradation**: Operators believe IP filtering is active when it's completely bypassed

However, this does not qualify as Critical or High severity because:
- No consensus/validator impact
- No direct loss of mainnet funds
- Faucet distributes test tokens in controlled amounts
- The faucet is not part of core blockchain infrastructure

The issue fits **Medium** severity as it causes "State inconsistencies requiring intervention" - the faucet operates in an unintended security state that requires manual detection and remediation.

## Likelihood Explanation

**Likelihood: Medium to High**

This vulnerability can manifest through common operational scenarios:

1. **Configuration Management Errors** (Common): Automated deployment systems may create empty placeholder files if the actual configuration is missing
2. **File Corruption** (Uncommon): Storage or network issues during deployment
3. **Human Error** (Common): Operators accidentally overwriting files or deploying wrong files
4. **Version Control Issues** (Common): Empty template files committed to repositories instead of actual configurations

The vulnerability is particularly dangerous because:
- It fails silently without errors or warnings
- Monitoring systems won't detect the issue unless specifically checking for empty blocklists
- Operators may not notice until abuse occurs
- The faucet continues operating normally in all other respects

## Recommendation

Add validation in `IpRangeManager::new()` to ensure at least one IP range was successfully loaded when the configuration context requires it:

```rust
impl IpRangeManager {
    pub fn new(config: IpRangeManagerConfig) -> Result<Self> {
        let file = File::open(&config.file)
            .with_context(|| format!("Failed to open {}", config.file.to_string_lossy()))?;

        let mut ipv4_list = IpRange::<Ipv4Net>::new();
        let mut ipv6_list = IpRange::<Ipv6Net>::new();
        let mut valid_range_count = 0;
        
        for line in std::io::BufReader::new(file).lines() {
            let line = line?;
            if line.starts_with('#') || line.starts_with("//") || line.is_empty() {
                continue;
            }
            match line.parse::<Ipv4Net>() {
                Ok(ipv4_net) => {
                    ipv4_list.add(ipv4_net);
                    valid_range_count += 1;
                },
                Err(_) => match line.parse::<Ipv6Net>() {
                    Ok(ipv6_net) => {
                        ipv6_list.add(ipv6_net);
                        valid_range_count += 1;
                    },
                    Err(_) => {
                        bail!("Failed to parse line as IPv4 or IPv6 range: {}", line);
                    },
                },
            }
        }
        
        // Add validation for blocklist usage (requires at least one range)
        if valid_range_count == 0 {
            bail!("IP range file {} contains no valid IP ranges. At least one IP range must be specified.", 
                  config.file.to_string_lossy());
        }
        
        Ok(Self {
            ipv4_list,
            ipv6_list,
        })
    }
}
```

**Alternative approach**: Add a configuration flag to `IpRangeManagerConfig` indicating whether empty files should be rejected:

```rust
pub struct IpRangeManagerConfig {
    pub file: PathBuf,
    pub require_non_empty: bool,  // Reject if file contains no valid ranges
}
```

## Proof of Concept

Create a test demonstrating the vulnerability:

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use std::io::Write;
    use tempfile::NamedTempFile;

    #[test]
    fn test_empty_blocklist_allows_all_ips() {
        // Create an empty IP blocklist file
        let mut temp_file = NamedTempFile::new().unwrap();
        writeln!(temp_file, "# Empty blocklist").unwrap();
        writeln!(temp_file, "").unwrap();
        
        let config = IpRangeManagerConfig {
            file: temp_file.path().to_path_buf(),
        };
        
        // This should fail but currently succeeds
        let manager = IpRangeManager::new(config).unwrap();
        
        // Verify that no IPs are blocked (vulnerability)
        let test_ip = "1.2.3.4".parse::<IpAddr>().unwrap();
        assert_eq!(manager.contains_ip(&test_ip), false); // No IPs blocked!
        
        let malicious_ip = "192.168.1.1".parse::<IpAddr>().unwrap();
        assert_eq!(manager.contains_ip(&malicious_ip), false); // Even known bad IPs pass!
    }
    
    #[test]
    #[should_panic(expected = "contains no valid IP ranges")]
    fn test_empty_blocklist_should_fail() {
        // With the fix, empty blocklist files should be rejected
        let mut temp_file = NamedTempFile::new().unwrap();
        writeln!(temp_file, "# Only comments").unwrap();
        
        let config = IpRangeManagerConfig {
            file: temp_file.path().to_path_buf(),
        };
        
        // After fix, this should panic/error
        IpRangeManager::new(config).unwrap();
    }
}
```

**Notes**

The vulnerability specifically affects IP blocklists, not allowlists. An empty IP allowlist causes all requests to go through normal checkers (more restrictive, safer behavior). The issue only manifests when:

1. An IP blocklist is explicitly configured in the faucet settings
2. The file exists and is readable
3. But contains no valid IP ranges (empty, comments only, or all invalid entries)

This is distinct from the file being missing/inaccessible, which causes startup failure (safe behavior).

### Citations

**File:** crates/aptos-faucet/core/src/common/ip_range_manager.rs (L24-53)
```rust
    pub fn new(config: IpRangeManagerConfig) -> Result<Self> {
        let file = File::open(&config.file)
            .with_context(|| format!("Failed to open {}", config.file.to_string_lossy()))?;

        let mut ipv4_list = IpRange::<Ipv4Net>::new();
        let mut ipv6_list = IpRange::<Ipv6Net>::new();
        for line in std::io::BufReader::new(file).lines() {
            let line = line?;
            if line.starts_with('#') || line.starts_with("//") || line.is_empty() {
                continue;
            }
            match line.parse::<Ipv4Net>() {
                Ok(ipv4_net) => {
                    ipv4_list.add(ipv4_net);
                },
                Err(_) => match line.parse::<Ipv6Net>() {
                    Ok(ipv6_net) => {
                        ipv6_list.add(ipv6_net);
                    },
                    Err(_) => {
                        bail!("Failed to parse line as IPv4 or IPv6 range: {}", line);
                    },
                },
            }
        }
        Ok(Self {
            ipv4_list,
            ipv6_list,
        })
    }
```

**File:** crates/aptos-faucet/core/src/checkers/ip_blocklist.rs (L27-51)
```rust
    async fn check(
        &self,
        data: CheckerData,
        _dry_run: bool,
    ) -> Result<Vec<RejectionReason>, AptosTapError> {
        match &data.source_ip {
            IpAddr::V4(source_ip) => {
                if self.manager.ipv4_list.contains(source_ip) {
                    return Ok(vec![RejectionReason::new(
                        format!("IP {} is in blocklist", source_ip),
                        RejectionReasonCode::IpInBlocklist,
                    )]);
                }
            },
            IpAddr::V6(source_ip) => {
                if self.manager.ipv6_list.contains(source_ip) {
                    return Ok(vec![RejectionReason::new(
                        format!("IP {} is in blocklist", source_ip),
                        RejectionReasonCode::IpInBlocklist,
                    )]);
                }
            },
        }
        Ok(vec![])
    }
```

**File:** crates/aptos-faucet/core/src/server/run.rs (L128-139)
```rust
        let mut checkers: Vec<Checker> = Vec::new();
        for checker_config in &self.checker_configs {
            let checker = checker_config
                .clone()
                .build(captcha_manager.clone())
                .await
                .with_context(|| {
                    format!("Failed to build Checker with args: {:?}", checker_config)
                })?;
            checker.spawn_periodic_tasks(&mut join_set);
            checkers.push(checker);
        }
```

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L262-278)
```rust
        let mut rejection_reasons = Vec::new();
        for checker in &self.checkers {
            rejection_reasons.extend(checker.check(checker_data.clone(), dry_run).await.map_err(
                |e| AptosTapError::new_with_error_code(e, AptosTapErrorCode::CheckerError),
            )?);
            if !rejection_reasons.is_empty() && self.return_rejections_early {
                break;
            }
        }

        if !rejection_reasons.is_empty() {
            return Err(AptosTapError::new(
                format!("Request rejected by {} checkers", rejection_reasons.len()),
                AptosTapErrorCode::Rejected,
            )
            .rejection_reasons(rejection_reasons));
        }
```
