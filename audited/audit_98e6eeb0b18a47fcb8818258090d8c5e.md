# Audit Report

## Title
Byzantine Validators Can Force Premature Timeouts via EchoTimeout Mechanism Without Time-Based Validation

## Summary
The EchoTimeout mechanism in AptosBFT consensus allows Byzantine validators to force honest nodes to timeout prematurely by sending valid timeout messages immediately at round start. The code lacks time-based validation, enabling f+1 Byzantine validators to disrupt consensus liveness systematically.

## Finding Description

The vulnerability exists in the EchoTimeout handling logic where honest nodes echo timeouts after receiving f+1 timeout messages without verifying that sufficient time has elapsed in the current round. [1](#0-0) 

When `VoteReceptionResult::EchoTimeout` is returned, the only guard is `!self.round_state.is_timeout_sent()`. There is no validation that:
- The local round timeout has actually expired
- Sufficient time has elapsed in the round
- A valid proposal is being processed or has been received

The EchoTimeout is triggered when f+1 timeout votes are received: [2](#0-1) 

Byzantine validators can send cryptographically valid timeout messages immediately at round start. The timeout message verification only checks signature validity and epoch/round consistency, with no time-based constraints: [3](#0-2) 

When `process_local_timeout()` is called via EchoTimeout, honest nodes are forced to send their own timeout. If `enable_round_timeout_msg` is disabled, nodes vote for NIL and cannot subsequently vote for legitimate proposals: [4](#0-3) 

The guard in `vote_block()` prevents voting after a timeout vote has been sent: [5](#0-4) 

**Attack Scenario:**
1. Round R starts with legitimate proposer ready to send a valid proposal
2. f+1 Byzantine validators immediately send cryptographically valid timeout messages for round R
3. Honest nodes receive these f+1 timeout messages within milliseconds of round start
4. EchoTimeout is triggered on honest nodes
5. Honest nodes call `process_local_timeout()` even though their local timeout hasn't expired
6. If `enable_round_timeout_msg` is false, honest nodes vote for NIL and cannot vote for legitimate proposals
7. Valid proposal arrives but cannot achieve quorum as honest nodes already committed to timeout
8. Network forced to next round unnecessarily

## Impact Explanation

This is a **High Severity** vulnerability per Aptos bug bounty criteria:

- **Validator node slowdowns**: Byzantine validators can systematically force premature timeouts in every round, significantly slowing consensus progress
- **Significant protocol violations**: Violates the liveness guarantee that honest proposals should be processed within the round timeout period
- **Liveness degradation**: Legitimate proposals are rejected due to premature timeouts, requiring additional rounds to finalize blocks
- **Resource waste**: Unnecessary timeout messages and round transitions consume bandwidth and computational resources

The attack can be executed repeatedly in every round, causing sustained liveness degradation. While it doesn't break consensus safety (no chain splits or double-spends), it significantly impacts network performance and finality time.

## Likelihood Explanation

**Likelihood: HIGH**

The attack is highly likely because:

1. **Low attack threshold**: Requires only f+1 Byzantine validators (less than 1/3 of voting power)
2. **No special privileges**: Byzantine validators only need standard validator capabilities to sign and send timeout messages
3. **No detection mechanism**: Honest nodes cannot distinguish between legitimate and premature timeout messages as there's no time-based validation
4. **Repeatable**: Can be executed in every round without limitation
5. **Simple execution**: Attackers simply send timeout messages at round start instead of waiting for actual timeout

The only requirement is controlling f+1 validators, which is within the standard Byzantine fault tolerance assumption of the system.

## Recommendation

Add time-based validation to prevent premature timeout echoing:

**Option 1: Enforce minimum elapsed time before echoing**
```rust
VoteReceptionResult::EchoTimeout(_) if !self.round_state.is_timeout_sent() => {
    // Only echo if minimum time has elapsed in the round
    let elapsed = self.time_service.get_current_timestamp()
        .duration_since(self.round_state.round_start_time());
    let min_echo_time = self.round_state.current_round_timeout() / 2;
    
    if elapsed >= min_echo_time {
        self.process_local_timeout(round).await
    } else {
        // Too early to echo, wait for local timeout
        Ok(())
    }
},
```

**Option 2: Only echo after receiving a valid proposal**
Check if a proposal has been received and processed before echoing timeout:

```rust
VoteReceptionResult::EchoTimeout(_) if !self.round_state.is_timeout_sent() => {
    // Only echo if no valid proposal received or proposal processing failed
    if self.round_state.has_received_proposal() {
        Ok(())
    } else {
        self.process_local_timeout(round).await
    }
},
```

**Option 3: Increase echo threshold**
Require more than f+1 timeouts before echoing (e.g., 2f+1 for stronger consensus): [6](#0-5) 

Change threshold calculation from `f+1` to a higher value.

## Proof of Concept

The following Rust test demonstrates the vulnerability:

```rust
#[test]
fn byzantine_premature_timeout_attack() {
    let runtime = consensus_runtime();
    let mut playground = NetworkPlayground::new(runtime.handle().clone());
    let mut nodes = NodeSetup::create_nodes(
        &mut playground,
        runtime.handle().clone(),
        4, // 4 nodes: f=1, need f+1=2 Byzantine nodes
        None, None, None,
        Some(config_with_round_timeout_msg_disabled()),
        None, None, false,
    );
    runtime.spawn(playground.start());
    
    timed_block_on(&runtime, async {
        // Clear message queue
        for node in &mut nodes {
            node.next_proposal().await;
        }
        
        // Honest node 0 hasn't timed out
        let node_0 = &mut nodes[0];
        let round_start = Instant::now();
        
        // Byzantine nodes 1 and 2 immediately send timeout at round start
        // (without waiting for actual timeout period)
        for node in &mut nodes[1..=2] {
            node.round_manager.process_local_timeout(1).await.unwrap_err();
        }
        
        // Node 0 receives Byzantine timeout messages
        let timeout_1 = node_0.next_vote().await;
        node_0.round_manager.process_vote_msg(timeout_1).await.unwrap();
        
        // After receiving 2nd timeout (f+1), node 0 is forced to echo
        let timeout_2 = node_0.next_vote().await;
        let result = node_0.round_manager.process_vote_msg(timeout_2).await;
        
        // Verify node 0 timed out prematurely (before its local timeout)
        let elapsed = round_start.elapsed();
        let expected_timeout = Duration::from_millis(
            node_0.round_manager.local_config.round_initial_timeout_ms
        );
        
        assert!(result.is_err()); // Timeout occurred
        assert!(elapsed < expected_timeout); // But local timeout hasn't expired!
        
        // Now a valid proposal arrives, but node 0 already voted for NIL
        // and cannot vote for the legitimate proposal
    });
}
```

This test demonstrates that honest node 0 is forced to timeout after receiving f+1 Byzantine timeout messages, even though its local timeout period hasn't expired. The node has voted for NIL and cannot subsequently vote for legitimate proposals that arrive later in the round.

### Citations

**File:** consensus/src/round_manager.rs (L1045-1062)
```rust
            let (is_nil_vote, mut timeout_vote) = match self.round_state.vote_sent() {
                Some(vote) if vote.vote_data().proposed().round() == round => {
                    (vote.vote_data().is_for_nil(), vote)
                },
                _ => {
                    // Didn't vote in this round yet, generate a backup vote
                    let nil_block = self
                        .proposal_generator
                        .generate_nil_block(round, self.proposer_election.clone())?;
                    info!(
                        self.new_log(LogEvent::VoteNIL),
                        "Planning to vote for a NIL block {}", nil_block
                    );
                    counters::VOTE_NIL_COUNT.inc();
                    let nil_vote = self.vote_block(nil_block).await?;
                    (true, nil_vote)
                },
            };
```

**File:** consensus/src/round_manager.rs (L1508-1512)
```rust
        ensure!(
            self.round_state.vote_sent().is_none(),
            "[RoundManager] Already vote on this round {}",
            self.round_state.current_round()
        );
```

**File:** consensus/src/round_manager.rs (L1821-1823)
```rust
            VoteReceptionResult::EchoTimeout(_) if !self.round_state.is_timeout_sent() => {
                self.process_local_timeout(round).await
            },
```

**File:** consensus/src/pending_votes.rs (L255-263)
```rust
        // Echo timeout if receive f+1 timeout message.
        if !self.echo_timeout {
            let f_plus_one = validator_verifier.total_voting_power()
                - validator_verifier.quorum_voting_power()
                + 1;
            if tc_voting_power >= f_plus_one {
                self.echo_timeout = true;
                return VoteReceptionResult::EchoTimeout(tc_voting_power);
            }
```

**File:** consensus/consensus-types/src/round_timeout.rs (L153-171)
```rust
    pub fn verify(&self, validator: &ValidatorVerifier) -> anyhow::Result<()> {
        ensure!(
            self.round_timeout.epoch() == self.sync_info.epoch(),
            "RoundTimeoutV2Msg has different epoch"
        );
        ensure!(
            self.round_timeout.round() > self.sync_info.highest_round(),
            "Timeout Round should be higher than SyncInfo"
        );
        ensure!(
            self.round_timeout.two_chain_timeout().hqc_round()
                <= self.sync_info.highest_certified_round(),
            "2-chain Timeout hqc should be less or equal than the sync info hqc"
        );
        // We're not verifying SyncInfo here yet: we are going to verify it only in case we need
        // it. This way we avoid verifying O(n) SyncInfo messages while aggregating the votes
        // (O(n^2) signature verifications).
        self.round_timeout.verify(validator)
    }
```
