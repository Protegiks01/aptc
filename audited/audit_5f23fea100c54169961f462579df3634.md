# Audit Report

## Title
Signature Verifier Cache Bypass During RELEASE_V1_34 Upgrade

## Summary
The VERIFIED_MODULES_CACHE uses only module hash as the cache key without including verifier configuration. During the RELEASE_V1_34 upgrade when `sig_checker_v2_fix_function_signatures` activates, modules verified with the old configuration can be loaded from cache without re-verification, bypassing the new stricter signature checks. This creates a window where invalid modules remain accessible until the cache is flushed.

## Finding Description
The vulnerability exists in the interaction between three components:

1. **Verifier Cache Implementation**: [1](#0-0) 

The cache uses only the module hash as the key, not a composite of (module_hash, verifier_config).

2. **Signature Verification Change at V1_34**: [2](#0-1) 

At RELEASE_V1_34, `sig_checker_v2_fix_function_signatures` becomes true, changing verification behavior.

3. **Conditional Cache Flush Logic**: [3](#0-2) 

The cache flush only occurs when `gas_feature_version >= RELEASE_V1_34` AND is only triggered in the block executor path via `check_ready()`.

4. **Function Signature Recursive Checking**: [4](#0-3) 

When `sig_checker_v2_fix_function_signatures` is false, the verifier does NOT recurse into function signature types. When true, it recursively validates all nested types within function signatures.

**Attack Scenario:**

1. Pre-V1_34: Attacker deploys a module with invalid nested types inside function signatures (e.g., function types with unsatisfied ability constraints or malformed type parameters)
2. The module passes verification because nested function signature types are not checked
3. Module is loaded and cached in VERIFIED_MODULES_CACHE
4. On-chain upgrade to V1_34 occurs (gas_feature_version increases)
5. Before the first block execution (which would trigger `check_ready()` and flush the cache), the attacker triggers module loading via:
   - View function execution: [5](#0-4) 
   - Transaction simulation
   - Direct module queries

6. Module loading checks the cache: [6](#0-5) 

If the module hash is in cache, verification is SKIPPED entirely, regardless of the current verifier configuration.

This creates a window where modules that should fail the new stricter verification can continue to be loaded and executed.

## Impact Explanation
This qualifies as **High Severity** based on the following impacts:

1. **Significant Protocol Violations**: Modules that violate current bytecode verification standards can execute, breaking the invariant that "all executed code must pass current bytecode verification standards"

2. **API Node Crashes**: If invalid function signature types are actually used during view function execution, they could cause:
   - Type system violations leading to VM panics
   - Undefined behavior in the Move VM
   - Memory safety issues if type constraints are violated

3. **Potential Consensus Issues**: If different validator nodes have different cache states during the upgrade window (some flushed, some not), they could make different decisions about module validity, though in practice the block execution path should synchronize cache flushes.

4. **State Inconsistency**: The system temporarily allows execution of code that does not meet current verification standards, requiring manual intervention to identify and address affected modules.

## Likelihood Explanation
**Medium-High Likelihood:**

- **Requires Specific Timing**: The exploit window exists between the on-chain V1_34 upgrade and the first block execution that flushes the cache
- **Common Scenario**: API nodes and view function endpoints are frequently accessed, making it likely that module loading occurs during this window
- **No Restart Required**: Validators and API nodes may not restart immediately after an on-chain parameter upgrade, leaving cached verification results in memory
- **Attacker Control**: An attacker who deployed malicious modules pre-V1_34 can monitor the upgrade and immediately trigger view functions to exploit the stale cache

The attack is realistic because:
1. The attacker can deploy modules pre-V1_34 with invalid function signatures
2. The V1_34 upgrade is a public on-chain event that can be monitored
3. View functions and simulations are accessible to any network participant
4. The cache is global and shared across all execution contexts

## Recommendation
Implement a cache invalidation strategy that includes the verifier configuration in the cache key or version:

```rust
// Option 1: Include verifier config in cache key
pub(crate) struct VerifiedModuleCache(
    Mutex<lru::LruCache<([u8; 32], Vec<u8>), ()>>
);

// Where the key is (module_hash, verifier_config_bytes)

// Option 2: Add cache generation/version
pub(crate) struct VerifiedModuleCache {
    cache: Mutex<lru::LruCache<[u8; 32], ()>>,
    verifier_config_hash: Mutex<Option<[u8; 32]>>,
}

// Flush cache when config changes:
pub(crate) fn check_and_flush_if_config_changed(&self, new_config_hash: [u8; 32]) {
    let mut config = self.verifier_config_hash.lock();
    if config.as_ref() != Some(&new_config_hash) {
        self.cache.lock().clear();
        *config = Some(new_config_hash);
    }
}
```

Additionally, ensure cache flush logic is called in ALL module loading paths, not just block execution:

```rust
// In AptosEnvironment::new() or module loading initialization
impl RuntimeEnvironment {
    pub fn check_and_flush_cache_if_config_changed(&self) {
        let config_bytes = bcs::to_bytes(&self.vm_config.verifier_config)
            .expect("Verifier config is serializable");
        let config_hash = sha3_256(&config_bytes);
        VERIFIED_MODULES_CACHE.check_and_flush_if_config_changed(config_hash);
    }
}
```

## Proof of Concept
```rust
// Rust test demonstrating the vulnerability

#[test]
fn test_verifier_cache_bypass_during_upgrade() {
    use move_binary_format::file_format::*;
    use move_bytecode_verifier::verify_module_with_config;
    use aptos_vm_environment::prod_configs::*;
    
    // 1. Create a module with invalid nested types in function signatures
    let module_with_invalid_func_sig = create_module_with_complex_function_type();
    let module_hash = sha3_256(&module_bytes);
    
    // 2. Verify with old config (sig_checker_v2_fix_function_signatures = false)
    let old_verifier_config = aptos_prod_verifier_config(
        RELEASE_V1_33, // Before V1_34
        &Features::default()
    );
    
    // Should pass with old config
    assert!(verify_module_with_config(&old_verifier_config, &module).is_ok());
    
    // 3. Add to cache
    VERIFIED_MODULES_CACHE.put(module_hash);
    
    // 4. Simulate upgrade to V1_34 (config changes)
    let new_verifier_config = aptos_prod_verifier_config(
        RELEASE_V1_34, // At V1_34
        &Features::default()
    );
    
    // Should fail with new config (if verified from scratch)
    assert!(verify_module_with_config(&new_verifier_config, &module).is_err());
    
    // 5. But cache lookup succeeds!
    assert!(VERIFIED_MODULES_CACHE.contains(&module_hash));
    
    // 6. Module loading skips verification due to cache hit
    // This allows the invalid module to be loaded post-V1_34
}

fn create_module_with_complex_function_type() -> CompiledModule {
    // Create a module with a function that has complex nested types
    // in its signature that violate new verification rules
    // Example: function with type |(T)| -> U where T lacks required abilities
    // ...implementation...
}
```

## Notes
The vulnerability is particularly concerning because:

1. **Silent Failure**: The cache bypass happens silently without any indication that verification was skipped
2. **Global Scope**: The VERIFIED_MODULES_CACHE is a global singleton affecting all execution paths
3. **Upgrade-Specific**: The issue specifically manifests during major version upgrades when verification rules change
4. **Window of Vulnerability**: Even if cache flush eventually happens, there's a window where invalid modules can be loaded

The fix should ensure that verification cache invalidation is synchronous with configuration changes and applies to all module loading paths, not just block execution.

### Citations

**File:** third_party/move/move-vm/runtime/src/storage/verified_module_cache.rs (L13-49)
```rust
pub(crate) struct VerifiedModuleCache(Mutex<lru::LruCache<[u8; 32], ()>>);

impl VerifiedModuleCache {
    /// Maximum size of the cache. When modules are cached, they can skip re-verification.
    const VERIFIED_CACHE_SIZE: NonZeroUsize = NonZeroUsize::new(100_000).unwrap();

    /// Returns new empty verified module cache.
    pub(crate) fn empty() -> Self {
        Self(Mutex::new(lru::LruCache::new(Self::VERIFIED_CACHE_SIZE)))
    }

    /// Returns true if the module hash is contained in the cache. For tests, the cache is treated
    /// as empty at all times.
    pub(crate) fn contains(&self, module_hash: &[u8; 32]) -> bool {
        // Note: need to use get to update LRU queue.
        verifier_cache_enabled() && self.0.lock().get(module_hash).is_some()
    }

    /// Inserts the hash into the cache, marking the corresponding as locally verified. For tests,
    /// entries are not added to the cache.
    pub(crate) fn put(&self, module_hash: [u8; 32]) {
        if verifier_cache_enabled() {
            let mut cache = self.0.lock();
            cache.put(module_hash, ());
        }
    }

    /// Flushes the verified modules cache.
    pub(crate) fn flush(&self) {
        self.0.lock().clear();
    }

    /// Returns the number of verified modules in the cache.
    pub(crate) fn size(&self) -> usize {
        self.0.lock().len()
    }
}
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L145-149)
```rust
pub fn aptos_prod_verifier_config(gas_feature_version: u64, features: &Features) -> VerifierConfig {
    let sig_checker_v2_fix_script_ty_param_count =
        features.is_enabled(FeatureFlag::SIGNATURE_CHECKER_V2_SCRIPT_FIX);
    let sig_checker_v2_fix_function_signatures = gas_feature_version >= RELEASE_V1_34;
    let enable_enum_types = features.is_enabled(FeatureFlag::ENABLE_ENUM_TYPES);
```

**File:** aptos-move/block-executor/src/code_cache_global_manager.rs (L117-126)
```rust
            if storage_environment.gas_feature_version() >= RELEASE_V1_34 {
                let flush_verifier_cache = self.environment.as_ref().is_none_or(|e| {
                    e.verifier_config_bytes() != storage_environment.verifier_config_bytes()
                });
                if flush_verifier_cache {
                    // Additionally, if the verifier config changes, we flush static verifier cache
                    // as well.
                    RuntimeEnvironment::flush_verified_module_cache();
                }
            }
```

**File:** third_party/move/move-bytecode-verifier/src/signature_v2.rs (L172-187)
```rust
            Function(params, results, abilities) => {
                assert_abilities(*abilities, required_abilities)?;
                if self.sig_checker_v2_fix_function_signatures {
                    for ty in params.iter().chain(results) {
                        self.check_ty(
                            ty,
                            // Immediate params and returns can be references.
                            true,
                            // Note we do not need to check abilities of argument or result types,
                            // they do not matter for the `required_abilities`.
                            AbilitySet::EMPTY,
                            param_constraints,
                        )?
                    }
                }
            },
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L2628-2637)
```rust
    pub fn execute_view_function(
        state_view: &impl StateView,
        module_id: ModuleId,
        func_name: Identifier,
        type_args: Vec<TypeTag>,
        arguments: Vec<Vec<u8>>,
        max_gas_amount: u64,
    ) -> ViewFunctionOutput {
        let env = AptosEnvironment::new(state_view);
        let vm = AptosVM::new(&env);
```

**File:** third_party/move/move-vm/runtime/src/storage/environment.rs (L184-197)
```rust
        if !VERIFIED_MODULES_CACHE.contains(module_hash) {
            let _timer =
                VM_TIMER.timer_with_label("move_bytecode_verifier::verify_module_with_config");

            // For regular execution, we cache already verified modules. Note that this even caches
            // verification for the published modules. This should be ok because as long as the
            // hash is the same, the deployed bytecode and any dependencies are the same, and so
            // the cached verification result can be used.
            move_bytecode_verifier::verify_module_with_config(
                &self.vm_config().verifier_config,
                compiled_module.as_ref(),
            )?;
            check_natives(compiled_module.as_ref())?;
            VERIFIED_MODULES_CACHE.put(*module_hash);
```
