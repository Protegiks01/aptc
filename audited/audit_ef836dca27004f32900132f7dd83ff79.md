# Audit Report

## Title
Commit Queue Draining After Scheduler Halt in BlockSTMv1 Worker Loop

## Summary
The `drain_commit_queue()` closure in the `worker_loop()` function does not check if the scheduler has been halted before processing transactions from the commit queue. This allows transactions to be materialized and their commit hooks to be executed even after an error has caused the scheduler to halt, potentially causing irrecoverable side effects and wasting computation resources.

## Finding Description
In the BlockSTMv1 implementation, the `worker_loop()` function defines a `drain_commit_queue()` closure that processes all transactions from the commit queue without checking whether the scheduler has been halted: [1](#0-0) 

This closure blindly drains all transactions from the commit queue, calling `materialize_txn_commit()` and `record_finalized_output()` for each transaction. During materialization, the transaction commit hook is invoked: [2](#0-1) 

The vulnerability manifests in the following scenario:

1. Worker A validates and commits transaction T1, adding it to the commit queue [3](#0-2) 

2. Worker B encounters a code invariant error, module r/w intersection, or gas limit exceeded error and halts the scheduler [4](#0-3) 

3. Worker C drains the commit queue and processes T1 without checking if the scheduler is halted [5](#0-4) 

4. T1's transaction commit hook executes, potentially causing side effects (e.g., sending cross-shard messages in sharded execution) [6](#0-5) 

5. The parallel execution later fails and falls back to sequential execution, but the side effects from the commit hook cannot be rolled back [7](#0-6) 

This breaks the **State Consistency** invariant that state transitions must be atomic - commit hooks execute even though their transactions are ultimately discarded.

Notably, BlockSTMv2's implementation correctly handles this by checking `is_halted()` before processing post-commit tasks: [8](#0-7) 

## Impact Explanation
**Severity: Medium**

The impact varies by execution context:

1. **Sharded Execution (Higher Impact):** Transaction commit hooks send cross-shard messages for transactions that are later discarded. This could cause shards to have inconsistent views of transaction status, violating the deterministic execution invariant. While all shards should eventually fall back to sequential execution, the intermediate inconsistency could cause coordination issues.

2. **Non-Sharded Execution (Lower Impact):** With `NoOpTransactionCommitHook`, there are no side effects, but computational resources are wasted materializing transactions that will be discarded.

The vulnerability qualifies as **Medium Severity** per the Aptos bug bounty criteria as it represents a state inconsistency that could require intervention in sharded environments, though it does not directly cause fund loss or consensus failure.

## Likelihood Explanation
**Likelihood: High**

This vulnerability has high likelihood because:

1. Multiple error conditions trigger scheduler halts: code invariant errors, module r/w intersections, gas limit exceeded, and high incarnation counts [9](#0-8) 

2. The race condition naturally occurs in concurrent execution: one worker encounters an error while another worker drains the commit queue

3. The commit queue is populated before halt checks occur [10](#0-9) 

4. Multiple workers operate concurrently, making the race window significant

## Recommendation
Add a halt check in the `drain_commit_queue` closure before processing each transaction, consistent with SchedulerV2's implementation: [1](#0-0) 

**Fixed implementation:**
```rust
let drain_commit_queue = || -> Result<(), PanicError> {
    while let Ok(txn_idx) = scheduler.pop_from_commit_queue() {
        // Check if scheduler has been halted before processing
        if scheduler.has_halted() {
            break;
        }
        self.materialize_txn_commit(
            txn_idx,
            scheduler_wrapper,
            environment,
            shared_sync_params,
        )?;
        self.record_finalized_output(txn_idx, txn_idx, shared_sync_params)?;
    }
    Ok(())
};
```

This ensures consistency with the V2 scheduler implementation and prevents wasted work and side effects after errors.

## Proof of Concept
A full PoC requires complex multi-threaded test infrastructure, but the vulnerability can be demonstrated conceptually:

```rust
// Thread 1: Commits transaction to queue
prepare_and_queue_commit_ready_txn(txn_idx, incarnation, ...)?;
// Transaction is now in commit queue

// Thread 2: Encounters error and halts scheduler  
let err = code_invariant_error("Module r/w intersection detected");
scheduler.halt();
shared_maybe_error.store(true, Ordering::SeqCst);

// Thread 3: Drains commit queue WITHOUT checking halt status
drain_commit_queue()?;
// BUG: Transaction is materialized and commit hook is called
// even though scheduler is halted due to error in Thread 2

// Verification: Check that transaction commit hook was invoked
// despite parallel execution being discarded
assert!(commit_hook_was_called);
assert!(parallel_execution_failed);
```

The key evidence is the contrast between V1 and V2 implementations, where V2 explicitly checks halt status before processing post-commit tasks, demonstrating this is a recognized issue that was fixed in the V2 design.

## Notes
This vulnerability specifically affects BlockSTMv1's `worker_loop()` implementation. The BlockSTMv2's `worker_loop_v2()` correctly checks `is_halted()` when processing post-commit tasks, indicating this issue was identified and addressed in the V2 redesign. The inconsistency between implementations suggests this is a genuine bug rather than intentional behavior.

### Citations

**File:** aptos-move/block-executor/src/executor.rs (L1277-1279)
```rust
        if let Some(txn_commit_listener) = &self.transaction_commit_hook {
            last_input_output.notify_listener(txn_idx, txn_commit_listener)?;
        }
```

**File:** aptos-move/block-executor/src/executor.rs (L1311-1322)
```rust
        let drain_commit_queue = || -> Result<(), PanicError> {
            while let Ok(txn_idx) = scheduler.pop_from_commit_queue() {
                self.materialize_txn_commit(
                    txn_idx,
                    scheduler_wrapper,
                    environment,
                    shared_sync_params,
                )?;
                self.record_finalized_output(txn_idx, txn_idx, shared_sync_params)?;
            }
            Ok(())
        };
```

**File:** aptos-move/block-executor/src/executor.rs (L1326-1331)
```rust
                if *incarnation as usize > num_workers.pow(2) + num_txns + 30 {
                    // Something is wrong if we observe high incarnations (e.g. a bug
                    // might manifest as an execution-invalidation cycle). Break out
                    // to fallback to sequential execution.
                    error!("Observed incarnation {} of txn {txn_idx}", *incarnation);
                    return Err(PanicOr::Or(ParallelBlockExecutionError::IncarnationTooHigh));
```

**File:** aptos-move/block-executor/src/executor.rs (L1363-1363)
```rust
            drain_commit_queue()?;
```

**File:** aptos-move/block-executor/src/executor.rs (L1952-1953)
```rust
                        // Make sure to halt the scheduler if it hasn't already been halted.
                        scheduler.halt();
```

**File:** aptos-move/block-executor/src/executor.rs (L1964-1996)
```rust
        let (has_error, maybe_block_epilogue_txn) = if shared_maybe_error.load(Ordering::SeqCst) {
            (true, None)
        } else {
            match self.finalize_parallel_execution(
                maybe_executor.into_inner(),
                signature_verified_block,
                scheduler.pop_from_commit_queue().is_ok(),
                transaction_slice_metadata,
                SchedulerWrapper::V1(&scheduler, &skip_module_reads_validation),
                module_cache_manager_guard.environment(),
                &shared_sync_params,
            ) {
                Ok(maybe_block_epilogue_txn) => {
                    // Update state counters & insert verified modules into cache (safe after error check).
                    counters::update_state_counters(versioned_cache.stats(), true);
                    (
                        module_cache_manager_guard
                            .module_cache_mut()
                            .insert_verified(versioned_cache.take_modules_iter())
                            .is_err(),
                        maybe_block_epilogue_txn,
                    )
                },
                Err(_) => (true, None),
            }
        };

        // Explicit async drops even when there is an error.
        DEFAULT_DROPPER.schedule_drop((last_input_output, scheduler, versioned_cache));

        if has_error {
            return Err(());
        }
```

**File:** aptos-move/block-executor/src/txn_last_input_output.rs (L374-387)
```rust
        // Add before halt, so SchedulerV2 can organically observe and process post commit
        // processing tasks even after it has halted.
        scheduler.add_to_post_commit(txn_idx)?;

        // !!! CAUTION !!! after the txn_idx is added to the post commit queue, it is no longer
        // safe to expect an output be stored for txn_idx: post-commit materialization takes
        // the output (instead of cloning for efficiency) for parallel post-processing.

        // While panic errors can lead to halting parallel execution (and fallback),
        // below we may halt the execution by design (no errors) in cases when:
        // a) all transactions are scheduled for committing, or
        // b) we skip_rest after a transaction
        // Either all txn committed, or a committed txn caused an early halt.
        if (txn_idx + 1 == num_txns || skips_rest) && scheduler.halt() {
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/cross_shard_client.rs (L137-147)
```rust
impl TransactionCommitHook for CrossShardCommitSender {
    fn on_transaction_committed(
        &self,
        txn_idx: TxnIndex,
        txn_output: &OnceCell<TransactionOutput>,
    ) {
        let global_txn_idx = txn_idx + self.index_offset;
        if self.dependent_edges.contains_key(&global_txn_idx) {
            self.send_remote_update_for_success(global_txn_idx, txn_output);
        }
    }
```

**File:** aptos-move/block-executor/src/scheduler_v2.rs (L807-816)
```rust
        match self.pop_post_commit_task()? {
            Some(txn_idx) => {
                return Ok(TaskKind::PostCommitProcessing(txn_idx));
            },
            None => {
                if self.is_halted() {
                    return Ok(TaskKind::Done);
                }
            },
        }
```
