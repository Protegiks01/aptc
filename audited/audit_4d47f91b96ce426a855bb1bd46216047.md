# Audit Report

## Title
Unauthenticated Metrics and Status Endpoint Exposure in Indexer GRPC Data Service V2

## Summary
The indexer-grpc-data-service-v2 exposes metrics and status endpoints without any authentication mechanism on all network interfaces (`0.0.0.0`), allowing any network attacker to gather sensitive operational intelligence about transaction processing patterns, connected clients, cache state, and system performance metrics.

## Finding Description

The vulnerability exists in the startup sequence of the indexer-grpc-data-service-v2. When the service starts, it spawns two concurrent tasks: one for the metrics/health endpoints and one for the main gRPC service. The metrics handler task immediately starts serving HTTP endpoints on all network interfaces without any authentication checks. [1](#0-0) [2](#0-1) 

The `register_probes_and_metrics_handler` function creates three unauthenticated HTTP endpoints:

1. **`/metrics` endpoint** - Exposes ALL Prometheus metrics via `aptos_metrics_core::gather()`: [3](#0-2) 

2. **`/` (status page) endpoint** - Exposes detailed operational state: [4](#0-3) 

3. **`/readiness` endpoint** - Health check

These endpoints are served on `0.0.0.0:health_check_port`, binding to all network interfaces: [5](#0-4) 

**Sensitive Information Exposed:**

The metrics include: [6](#0-5) 

The status page exposes: [7](#0-6) 

This reveals:
- Known latest transaction version being processed
- All active stream IDs and their current processing state
- Transaction throughput patterns (10s, 60s, 10min windows)
- Cache size and memory usage
- System latency metrics
- Number of connected clients

**No Authentication in V2:**

Unlike potential authentication mechanisms, the v2 service has NO authentication checks in either the gRPC service or the metrics endpoints: [8](#0-7) 

## Impact Explanation

This vulnerability allows an unprivileged network attacker to:

1. **Profile Transaction Processing**: Monitor which transaction versions are being processed, revealing timing patterns for transaction indexing
2. **Track Connected Clients**: Enumerate active streams and monitor client connection patterns
3. **Gather System Intelligence**: Learn system capacity, memory usage, and performance characteristics
4. **Plan Coordinated Attacks**: Use operational metrics to identify optimal timing for resource exhaustion or targeted attacks on specific transaction ranges
5. **Privacy Violation**: Track which clients are querying which transaction ranges by correlating stream activity

While this is an **indexer service** (not a consensus node), the exposed information provides valuable reconnaissance data for attackers planning larger ecosystem attacks. The indexer is critical infrastructure for dApps and wallets, and operational intelligence about its state can enable:
- Timing attacks coordinated with transaction submission
- Targeted DoS planning (though DoS itself is out of scope)
- Understanding of system bottlenecks and resource constraints

Per the Aptos bug bounty criteria, this qualifies as **Medium severity** due to the operational security implications and the comprehensive nature of the information disclosure, which exceeds "minor information leaks" (Low severity) by exposing detailed transaction processing patterns and client connection data.

## Likelihood Explanation

**Likelihood: High**

This vulnerability is trivially exploitable:
- No authentication required
- Simple HTTP GET requests to publicly accessible endpoints
- Works immediately upon service startup
- No special timing or race conditions required
- Attacker needs only network connectivity to the health_check_port

The attack can be automated with simple scripts:
```bash
# Get all metrics
curl http://<indexer-host>:<health_check_port>/metrics

# Get detailed status page
curl http://<indexer-host>:<health_check_port>/
```

## Recommendation

Implement authentication for the metrics and status endpoints. Options include:

1. **Add Bearer Token Authentication**:
```rust
async fn register_probes_and_metrics_handler<C>(
    config: GenericConfig<C>, 
    port: u16,
    auth_token: Option<String>,
) where C: RunnableConfig {
    
    let auth_check = warp::header::optional::<String>("authorization")
        .and_then(move |auth: Option<String>| {
            let token = auth_token.clone();
            async move {
                if let Some(expected_token) = token {
                    match auth {
                        Some(bearer) if bearer == format!("Bearer {}", expected_token) => {
                            Ok(())
                        }
                        _ => Err(warp::reject::custom(Unauthorized))
                    }
                } else {
                    Ok(()) // Auth disabled if no token configured
                }
            }
        });
    
    let metrics_endpoint = warp::path("metrics")
        .and(auth_check.clone())
        .map(|| {
            let metrics = aptos_metrics_core::gather();
            // ... encode metrics ...
        });
    
    // Apply auth_check to status_endpoint as well
}
```

2. **Bind to localhost only** for production deployments behind a secure proxy:
```rust
.run(([127, 0, 0, 1], port)) // localhost only
```

3. **Add IP whitelisting** to restrict access to monitoring systems only

4. **Use mTLS** for metrics scraping by Prometheus/monitoring tools

## Proof of Concept

```rust
// PoC: Demonstrate unauthenticated access to sensitive metrics
// This can be run against any running indexer-grpc-data-service-v2 instance

use reqwest;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let indexer_host = "localhost"; // or actual indexer IP
    let health_port = 8084; // default health_check_port
    
    // 1. Access metrics endpoint without auth
    let metrics_url = format!("http://{}:{}/metrics", indexer_host, health_port);
    let metrics_resp = reqwest::get(&metrics_url).await?;
    println!("Metrics Status: {}", metrics_resp.status());
    let metrics_body = metrics_resp.text().await?;
    
    // Parse sensitive info
    for line in metrics_body.lines() {
        if line.contains("aptos_indexer_grpc_v2") {
            println!("Exposed metric: {}", line);
        }
    }
    
    // 2. Access status page without auth
    let status_url = format!("http://{}:{}/", indexer_host, health_port);
    let status_resp = reqwest::get(&status_url).await?;
    println!("\nStatus Page: {}", status_resp.status());
    let status_body = status_resp.text().await?;
    
    // Extract sensitive operational data
    println!("Status page reveals:");
    println!("{}", status_body);
    
    // 3. Monitor transaction processing patterns
    println!("\n[*] Monitoring transaction processing...");
    for _ in 0..10 {
        let resp = reqwest::get(&metrics_url).await?;
        let body = resp.text().await?;
        
        // Extract version metrics
        for line in body.lines() {
            if line.contains("cache_start_version") || 
               line.contains("cache_end_version") ||
               line.contains("num_connected_streams") {
                println!("{}", line);
            }
        }
        tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;
    }
    
    Ok(())
}
```

**Notes**

This vulnerability is specific to the **indexer-grpc-data-service-v2** component, which is infrastructure (not consensus-critical). However, it exposes significant operational intelligence that violates operational security best practices. The older v1 service had deprecated authentication support, but v2 removed it entirely, creating this exposure. Production deployments should implement proper authentication or network isolation for these monitoring endpoints.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/main.rs (L14-16)
```rust
async fn main() -> Result<()> {
    let args = ServerArgs::parse();
    args.run::<IndexerGrpcDataServiceConfig>().await
```

**File:** ecosystem/indexer-grpc/indexer-grpc-server-framework/src/lib.rs (L46-56)
```rust
pub async fn run_server_with_config<C>(config: GenericConfig<C>) -> Result<()>
where
    C: RunnableConfig,
{
    let health_port = config.health_check_port;
    // Start liveness and readiness probes.
    let config_clone = config.clone();
    let task_handler = tokio::spawn(async move {
        register_probes_and_metrics_handler(config_clone, health_port).await;
        anyhow::Ok(())
    });
```

**File:** ecosystem/indexer-grpc/indexer-grpc-server-framework/src/lib.rs (L203-217)
```rust
    let metrics_endpoint = warp::path("metrics").map(|| {
        // Metrics encoding.
        let metrics = aptos_metrics_core::gather();
        let mut encode_buffer = vec![];
        let encoder = TextEncoder::new();
        // If metrics encoding fails, we want to panic and crash the process.
        encoder
            .encode(&metrics, &mut encode_buffer)
            .context("Failed to encode metrics")
            .unwrap();

        Response::builder()
            .header("Content-Type", "text/plain")
            .body(encode_buffer)
    });
```

**File:** ecosystem/indexer-grpc/indexer-grpc-server-framework/src/lib.rs (L219-222)
```rust
    let status_endpoint = warp::path::end().and_then(move || {
        let config = config.clone();
        async move { config.status_page().await }
    });
```

**File:** ecosystem/indexer-grpc/indexer-grpc-server-framework/src/lib.rs (L260-262)
```rust
        warp::serve(readiness.or(metrics_endpoint).or(status_endpoint))
            .run(([0, 0, 0, 0], port))
            .await;
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/metrics.rs (L10-76)
```rust
pub static NUM_CONNECTED_STREAMS: Lazy<IntGaugeVec> = Lazy::new(|| {
    register_int_gauge_vec!(
        "aptos_indexer_grpc_v2_num_connected_streams",
        "# of connected streams.",
        &["data_service_type"]
    )
    .unwrap()
});

pub static CACHE_START_VERSION: Lazy<IntGauge> = Lazy::new(|| {
    register_int_gauge!(
        "aptos_indexer_grpc_v2_live_data_service_cache_start_version",
        "The cache_start_version of the live data service instance."
    )
    .unwrap()
});

pub static CACHE_END_VERSION: Lazy<IntGauge> = Lazy::new(|| {
    register_int_gauge!(
        "aptos_indexer_grpc_v2_live_data_service_cache_end_version",
        "The cache_end_version (exclusive) of the live data service instance."
    )
    .unwrap()
});

pub static CACHE_SIZE_BYTES: Lazy<IntGauge> = Lazy::new(|| {
    register_int_gauge!(
        "aptos_indexer_grpc_v2_live_data_service_cache_size_bytes",
        "Cache size in bytes."
    )
    .unwrap()
});

pub static CACHE_SIZE_LIMIT_BYTES: Lazy<IntGauge> = Lazy::new(|| {
    register_int_gauge!(
        "aptos_indexer_grpc_v2_live_data_service_cache_size_limit_bytes",
        "Limit of cache size in bytes."
    )
    .unwrap()
});

pub static LATENCY_MS: Lazy<IntGauge> = Lazy::new(|| {
    register_int_gauge!(
        "aptos_indexer_grpc_v2_live_data_service_latency_ms",
        "The latency of live data service (comparing with txn timestamp)."
    )
    .unwrap()
});

pub static COUNTER: Lazy<IntCounterVec> = Lazy::new(|| {
    register_int_counter_vec!(
        "aptos_indexer_grpc_v2_data_service_counter",
        "Generic counter for various things.",
        &["name"],
    )
    .unwrap()
});

pub static TIMER: Lazy<HistogramVec> = Lazy::new(|| {
    register_histogram_vec!(
        "aptos_indexer_grpc_v2_data_service_timer",
        "Generic timer for various things.",
        &["name"],
        exponential_buckets(/*start=*/ 1e-6, /*factor=*/ 2.0, /*count=*/ 30).unwrap(),
    )
    .unwrap()
});
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/status_page.rs (L46-114)
```rust
fn render_connection_manager_info(connection_manager: &ConnectionManager) -> Container {
    let known_latest_version = connection_manager.known_latest_version();
    let active_streams = connection_manager.get_active_streams();
    let active_streams_table = active_streams.into_iter().fold(
        Table::new()
            .with_attributes([("style", "width: 100%; border: 5px solid black;")])
            .with_thead_attributes([("style", "background-color: lightcoral; color: white;")])
            .with_custom_header_row(
                TableRow::new()
                    .with_cell(TableCell::new(TableCellType::Header).with_raw("Id"))
                    .with_cell(TableCell::new(TableCellType::Header).with_raw("Current Version"))
                    .with_cell(TableCell::new(TableCellType::Header).with_raw("End Version"))
                    .with_cell(
                        TableCell::new(TableCellType::Header).with_raw("Past 10s throughput"),
                    )
                    .with_cell(
                        TableCell::new(TableCellType::Header).with_raw("Past 60s throughput"),
                    )
                    .with_cell(
                        TableCell::new(TableCellType::Header).with_raw("Past 10min throughput"),
                    ),
            ),
        |table, active_stream| {
            table.with_custom_body_row(
                TableRow::new()
                    .with_cell(TableCell::new(TableCellType::Data).with_raw(&active_stream.id))
                    .with_cell(TableCell::new(TableCellType::Data).with_raw(format!(
                        "{:?}",
                        active_stream.progress.as_ref().and_then(|progress| {
                            progress.samples.last().map(|sample| sample.version)
                        })
                    )))
                    .with_cell(
                        TableCell::new(TableCellType::Data).with_raw(active_stream.end_version()),
                    )
                    .with_cell(TableCell::new(TableCellType::Data).with_raw(
                        get_throughput_from_samples(
                            active_stream.progress.as_ref(),
                            Duration::from_secs(10),
                        ),
                    ))
                    .with_cell(TableCell::new(TableCellType::Data).with_raw(
                        get_throughput_from_samples(
                            active_stream.progress.as_ref(),
                            Duration::from_secs(60),
                        ),
                    ))
                    .with_cell(TableCell::new(TableCellType::Data).with_raw(
                        get_throughput_from_samples(
                            active_stream.progress.as_ref(),
                            Duration::from_secs(600),
                        ),
                    )),
            )
        },
    );

    Container::new(ContainerType::Section)
        .with_paragraph_attr("Connection Manager", [(
            "style",
            "font-size: 24px; font-weight: bold;",
        )])
        .with_paragraph(format!("Known latest version: {known_latest_version}."))
        .with_paragraph_attr("Active Streams", [(
            "style",
            "font-size: 16px; font-weight: bold;",
        )])
        .with_table(active_streams_table)
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/service.rs (L43-72)
```rust
    async fn get_transactions(
        &self,
        req: Request<GetTransactionsRequest>,
    ) -> Result<Response<Self::GetTransactionsStream>, Status> {
        if let Some(live_data_service) = self.live_data_service.as_ref() {
            if let Some(historical_data_service) = self.historical_data_service.as_ref() {
                let request = req.into_inner();
                let mut stream = live_data_service
                    .get_transactions(Request::new(request.clone()))
                    .await?
                    .into_inner();
                let peekable = std::pin::pin!(stream.as_mut().peekable());
                if let Some(Ok(_)) = peekable.peek().await {
                    return live_data_service
                        .get_transactions(Request::new(request.clone()))
                        .await;
                }

                historical_data_service
                    .get_transactions(Request::new(request))
                    .await
            } else {
                live_data_service.get_transactions(req).await
            }
        } else if let Some(historical_data_service) = self.historical_data_service.as_ref() {
            historical_data_service.get_transactions(req).await
        } else {
            unreachable!("Must have at least one of the data services enabled.");
        }
    }
```
