# Audit Report

## Title
Integer Overflow in Block Epilogue Fee Distribution Causes Validator Node Crash

## Summary
An unchecked integer multiplication in the block epilogue fee distribution calculation can overflow u64 when processing transactions with maximum gas parameters, causing validator nodes to panic and crash during block execution. This creates a consensus availability vulnerability.

## Finding Description

The vulnerability exists in the `gen_block_epilogue` function where transaction fees are calculated for distribution to validators. [1](#0-0) 

The code performs an unchecked multiplication that can overflow u64. When a transaction uses maximum allowed gas parameters:
- `gas_unit_available_to_distribute` can reach ~2,000,000 (max gas minus storage fees)
- `gas_price` can be 10,000,000,000 (max allowed per gas schedule)
- `gas_price_to_burn` is typically 90 (configured value) [2](#0-1) [3](#0-2) [4](#0-3) 

**Overflow Calculation:**
```
fee_to_distribute = 2,000,000 × (10,000,000,000 - 90)
                  = 2,000,000 × 9,999,999,910
                  = 19,999,999,820,000,000
u64::MAX          = 18,446,744,073,709,551,615
```

The result exceeds u64::MAX. Since overflow checks are enabled in release builds: [5](#0-4) 

The multiplication will panic, crashing the validator node during block execution. This breaks the **Deterministic Execution** invariant as nodes crash rather than executing blocks consistently.

## Impact Explanation

This qualifies as **High Severity** under Aptos bug bounty criteria:
- **Validator node crashes**: The panic terminates the validator process
- **Significant protocol violation**: Blocks cannot be processed, breaking consensus execution

Could escalate to **Critical Severity** if:
- Multiple validators crash simultaneously
- Network loses liveness (less than 2/3 validators operational)
- Recovery requires network intervention or hardfork

The vulnerability affects the core consensus execution path, making it a fundamental protocol-level issue rather than an isolated edge case.

## Likelihood Explanation

**Likelihood: Medium to High**

While requiring maximum gas parameters, the attack is:
- **Easily executable**: Any user can submit such a transaction
- **No special permissions needed**: Standard transaction submission
- **Deterministic**: Same transaction parameters always trigger overflow
- **Not economically prohibitive**: Attacker only pays for gas actually used

The main constraint is that gas prices rarely reach the maximum allowed value under normal network conditions. However, during periods of high congestion or through intentional manipulation, an attacker could craft such transactions to disrupt validator operations.

## Recommendation

Replace unchecked arithmetic with overflow-safe operations:

```rust
let fee_to_distribute = gas_unit_available_to_distribute
    .checked_mul(gas_price - gas_price_to_burn)
    .unwrap_or_else(|| {
        error!("Fee calculation overflow: gas_units={}, gas_price_delta={}", 
               gas_unit_available_to_distribute, gas_price - gas_price_to_burn);
        0 // Or use saturating_mul() to cap at u64::MAX
    });

*amount.entry(proposer_index).or_insert(0) = amount
    .entry(proposer_index)
    .or_insert(0)
    .checked_add(fee_to_distribute)
    .unwrap_or_else(|| {
        error!("Fee accumulation overflow for proposer {}", proposer_index);
        u64::MAX
    });
```

Alternative: Use `saturating_mul()` and `saturating_add()` to cap at u64::MAX without panicking, though this may lead to incorrect fee accounting.

The Move-side aggregator handling should also be reviewed: [6](#0-5) 

## Proof of Concept

**Rust Test Case:**
```rust
#[test]
#[should_panic(expected = "attempt to multiply with overflow")]
fn test_fee_distribution_overflow() {
    let gas_unit_available_to_distribute: u64 = 2_000_000;
    let gas_price: u64 = 10_000_000_000; // max allowed
    let gas_price_to_burn: u64 = 90;
    
    // This will panic with overflow-checks=true
    let _fee_to_distribute = gas_unit_available_to_distribute 
        * (gas_price - gas_price_to_burn);
}
```

**Attack Transaction:**
1. Create transaction with `max_gas_amount = 2_000_000`
2. Set `gas_unit_price = 10_000_000_000` (maximum allowed)
3. Include transaction payload that consumes maximum execution gas
4. Minimize storage fees (use existing resources, avoid new allocations)
5. Submit to network
6. During block execution, `gen_block_epilogue` computes fee distribution
7. Integer overflow triggers panic
8. Validator node crashes

**Notes**
- The vulnerability exists in production code path executed for every block with fee distribution enabled
- The edge case of u64::MAX values is not properly fuzzed or tested in boundary conditions
- Empty fee distributions would result in an empty BTreeMap, which is safe
- The all-false limit flags scenario is unrelated to this specific vulnerability but other boundary conditions in the same file warrant fuzzing attention

### Citations

**File:** aptos-move/block-executor/src/executor.rs (L2071-2073)
```rust
                            let fee_to_distribute =
                                gas_unit_available_to_distribute * (gas_price - gas_price_to_burn);
                            *amount.entry(proposer_index).or_insert(0) += fee_to_distribute;
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L66-71)
```rust
        // The maximum gas unit price that a transaction can be submitted with.
        [
            max_price_per_gas_unit: FeePerGasUnit,
            "max_price_per_gas_unit",
            10_000_000_000
        ],
```

**File:** config/global-constants/src/lib.rs (L28-31)
```rust
#[cfg(any(test, feature = "testing"))]
pub const MAX_GAS_AMOUNT: u64 = 100_000_000;
#[cfg(not(any(test, feature = "testing")))]
pub const MAX_GAS_AMOUNT: u64 = 2_000_000;
```

**File:** types/src/on_chain_config/execution_config.rs (L129-131)
```rust
            transaction_deduper_type: TransactionDeduperType::TxnHashAndAuthenticatorV1,
            gas_price_to_burn: 90,
            persisted_auxiliary_info_version: 1,
```

**File:** Cargo.toml (L921-923)
```text
[profile.release]
debug = true
overflow-checks = true
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L616-635)
```text
    public(friend) fun record_fee(
        vm: &signer,
        fee_distribution_validator_indices: vector<u64>,
        fee_amounts_octa: vector<u64>,
    ) acquires PendingTransactionFee {
        // Operational constraint: can only be invoked by the VM.
        system_addresses::assert_vm(vm);

        assert!(fee_distribution_validator_indices.length() == fee_amounts_octa.length());

        let num_validators_to_distribute = fee_distribution_validator_indices.length();
        let pending_fee = borrow_global_mut<PendingTransactionFee>(@aptos_framework);
        let i = 0;
        while (i < num_validators_to_distribute) {
            let validator_index = fee_distribution_validator_indices[i];
            let fee_octa = fee_amounts_octa[i];
            pending_fee.pending_fee_by_validator.borrow_mut(&validator_index).add(fee_octa);
            i = i + 1;
        }
    }
```
