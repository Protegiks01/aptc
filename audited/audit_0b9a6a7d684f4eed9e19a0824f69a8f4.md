# Audit Report

## Title
Untracked Memory Allocation in identifier_from_ref() Bypasses Memory Quota Limits

## Summary
The `identifier_from_ref()` function in `function_info.rs` performs an untracked `.to_vec()` allocation on potentially large identifier strings, bypassing the Move VM's memory quota system. An attacker can construct `FunctionInfo` structures with extremely large identifier strings (up to ~10MB per identifier) and trigger native function calls that allocate this memory outside of quota tracking, potentially causing validator node memory exhaustion. [1](#0-0) 

## Finding Description

The vulnerability exists in the native function implementation for FunctionInfo operations. The attack flow is:

**Step 1: Identifier Size Validation Gap**
The `Identifier::is_valid()` function validates character patterns but does NOT enforce any size limits at runtime. [2](#0-1) 

While bytecode deserialization enforces IDENTIFIER_SIZE_MAX (255) or LEGACY_IDENTIFIER_SIZE_MAX (65535), these limits do NOT apply to identifiers constructed programmatically at runtime. [3](#0-2) 

**Step 2: Memory Quota Calculation**
The Move VM's memory quota is set to 10,000,000 abstract value size units. For a `vector<u8>` with N bytes, the abstract size is approximately 40 + 1*N. A `String` struct adds 40 more units (80 + N total). This allows creation of strings up to ~9.9MB within the quota. [4](#0-3) [5](#0-4) 

**Step 3: FunctionInfo Creation**
The `new_function_info_from_address()` function validates identifiers using the `is_identifier` native function, which charges gas per byte but does NOT reject large identifiers. [6](#0-5) 

The native implementation charges proportional gas but performs no size enforcement: [7](#0-6) 

**Step 4: Untracked Memory Allocation**
When `check_dispatch_type_compatibility_impl` processes the FunctionInfo, it calls `extract_function_info()` which invokes `identifier_from_ref()` twice per FunctionInfo (for module_name and function_name). Each call performs `.to_vec()` which allocates a **new** Vec<u8> copy of the identifier bytes. This allocation is a raw Rust heap allocation that is **NOT** tracked by the memory quota system. [8](#0-7) 

The memory tracking system only monitors Move VM values, not temporary native allocations: [9](#0-8) 

**Step 5: Exploitation Scenario**
With `check_dispatch_type_compatibility_impl` accepting two FunctionInfo arguments, each with two string identifiers:
- Attacker creates 4 strings of ~2.5MB each (within 10MB quota)
- Each `.to_vec()` call allocates an untracked copy
- Total untracked allocation: 4 × 2.5MB = **10MB per transaction**
- Multiple concurrent transactions amplify the effect
- Memory is freed only after function completion, not during execution

The comment in the code acknowledges missing gas charging for this operation: [10](#0-9) 

## Impact Explanation

This qualifies as **High Severity** per the Aptos bug bounty criteria:

1. **Validator Node Slowdowns**: Multiple transactions with large identifiers executing concurrently can cause memory pressure, triggering garbage collection overhead and degrading validator performance.

2. **Resource Limit Invariant Violation**: Breaks invariant #9 ("All operations must respect gas, storage, and computational limits") and invariant #3 ("Bytecode execution must respect gas limits and memory constraints"). The untracked allocations bypass the memory quota system designed to prevent resource exhaustion.

3. **Deterministic Execution Risk**: Under memory pressure, different validators might experience varying performance or OOM conditions at different times, potentially causing consensus timing issues or block proposal delays.

While modern validator nodes have sufficient RAM to prevent immediate OOM from a single transaction, the vulnerability enables:
- Sustained memory pressure attacks across multiple blocks
- Amplification through concurrent transaction execution
- Bypassing of designed memory protection mechanisms

## Likelihood Explanation

**Likelihood: Medium to High**

The attack is feasible because:
1. Fungible asset dispatch registration is accessible to users who can create custom asset types
2. The cost is bounded by gas limits but large identifiers are possible
3. No explicit size validation exists for runtime-constructed identifiers
4. The code path is actively used in production (fungible asset dispatch)

Constraints that partially mitigate but don't prevent the attack:
- Gas costs scale with identifier size (per-byte charging)
- Memory quota limits total size to ~10MB per transaction
- Temporary nature of allocations (freed after function return)

However, an attacker with sufficient APT can sustain this attack across multiple transactions, and the lack of tracking means the VM's protection mechanisms are blind to this resource consumption.

## Recommendation

**Immediate Fix: Add explicit size validation in identifier_from_ref()**

Before calling `.to_vec()`, enforce a maximum identifier size (e.g., 65535 bytes to match LEGACY_IDENTIFIER_SIZE_MAX):

```rust
fn identifier_from_ref(v: Value) -> SafeNativeResult<Identifier> {
    let bytes_ref = v
        .value_as::<StructRef>()
        .and_then(|s| s.borrow_field(0))
        .and_then(|v| v.value_as::<VectorRef>())
        .map_err(SafeNativeError::InvariantViolation)?
        .as_bytes_ref();
    
    // Enforce maximum identifier size before allocation
    const MAX_IDENTIFIER_SIZE: usize = 65535;
    if bytes_ref.as_slice().len() > MAX_IDENTIFIER_SIZE {
        return Err(SafeNativeError::Abort { abort_code: 1 });
    }
    
    let bytes = bytes_ref.to_vec();
    Identifier::from_utf8(bytes).map_err(|_| SafeNativeError::Abort { abort_code: 1 })
}
```

**Additional Hardening:**

1. Charge gas proportional to the allocation size before calling `.to_vec()`:
```rust
context.charge(FUNCTION_INFO_IDENTIFIER_EXTRACTION_PER_BYTE 
    * NumBytes::new(bytes_ref.as_slice().len() as u64))?;
```

2. Consider using `as_bytes_ref()` results directly where possible instead of allocating via `.to_vec()`, or use `use_heap_memory_in_native_context()` to track the allocation:
```rust
context.use_heap_memory_in_native_context(bytes_ref.as_slice().len() as u64)?;
```

3. Add compile-time enforcement in `Identifier::from_utf8()` to validate size limits match deserialization constraints.

## Proof of Concept

```move
module attacker::exploit {
    use std::string::{Self, String};
    use aptos_framework::function_info;
    use std::vector;
    
    /// Create a FunctionInfo with extremely large identifiers
    /// to trigger untracked memory allocations
    public entry fun exploit_memory_exhaustion(account: &signer) {
        // Create a vector with ~2.5M bytes (just under memory quota / 4)
        let large_vec = vector::empty<u8>();
        let i = 0;
        while (i < 2_500_000) {
            vector::push_back(&mut large_vec, 97); // 'a' character
            i = i + 1;
        };
        
        // Create String from large vector (passes UTF-8 and identifier validation)
        let large_string = string::utf8(large_vec);
        
        // Create FunctionInfo with large identifiers
        // This passes validation but creates large untracked allocations
        // when used in check_dispatch_type_compatibility_impl
        let function_info = function_info::new_function_info_from_address(
            @0x1,
            large_string,
            large_string, // Reuse for function name
        );
        
        // When this FunctionInfo is passed to check_dispatch_type_compatibility_impl
        // (via fungible asset dispatch registration), it triggers:
        // - 2 × 2.5MB untracked allocations per FunctionInfo
        // - 2 FunctionInfo args = 10MB total untracked allocation
        // - Multiple concurrent txns amplify the effect
    }
}
```

**Notes:**
- The PoC demonstrates FunctionInfo creation with large identifiers
- Actual exploitation requires calling functions that use `check_dispatch_type_compatibility_impl`
- The vulnerability is in the native code path, not directly testable in Move
- A full exploit would target fungible asset dispatch registration or similar entry points

### Citations

**File:** aptos-move/framework/src/natives/function_info.rs (L23-32)
```rust
fn identifier_from_ref(v: Value) -> SafeNativeResult<Identifier> {
    let bytes = v
        .value_as::<StructRef>()
        .and_then(|s| s.borrow_field(0))
        .and_then(|v| v.value_as::<VectorRef>())
        .map_err(SafeNativeError::InvariantViolation)?
        .as_bytes_ref()
        .to_vec();
    Identifier::from_utf8(bytes).map_err(|_| SafeNativeError::Abort { abort_code: 1 })
}
```

**File:** aptos-move/framework/src/natives/function_info.rs (L73-86)
```rust
fn native_check_dispatch_type_compatibility_impl(
    context: &mut SafeNativeContext,
    _ty_args: &[Type],
    mut arguments: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    debug_assert!(arguments.len() == 2);

    // TODO: Figure out the correct gas charging schema here.
    //
    // We need to load the modules from lhs and rhs, and cloning the bytes for module id and function name.
    context.charge(FUNCTION_INFO_CHECK_DISPATCH_TYPE_COMPATIBILITY_IMPL_BASE)?;

    let (rhs, rhs_id) = {
        let (module, func) = extract_function_info(&mut arguments)?;
```

**File:** aptos-move/framework/src/natives/function_info.rs (L143-166)
```rust
fn native_is_identifier(
    context: &mut SafeNativeContext,
    _ty_args: &[Type],
    mut arguments: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    debug_assert!(arguments.len() == 1);

    let s_arg = safely_pop_arg!(arguments, VectorRef);
    let s_ref = s_arg.as_bytes_ref();

    context.charge(
        FUNCTION_INFO_CHECK_IS_IDENTIFIER_BASE
            + FUNCTION_INFO_CHECK_IS_IDENTIFIER_PER_BYTE
                * NumBytes::new(s_ref.as_slice().len() as u64),
    )?;

    let result = if let Ok(str) = std::str::from_utf8(&s_ref) {
        Identifier::is_valid(str)
    } else {
        false
    };

    Ok(smallvec![Value::bool(result)])
}
```

**File:** third_party/move/move-core/types/src/identifier.rs (L82-94)
```rust
pub const fn is_valid(s: &str) -> bool {
    // Rust const fn's don't currently support slicing or indexing &str's, so we
    // have to operate on the underlying byte slice. This is not a problem as
    // valid identifiers are (currently) ASCII-only.
    let b = s.as_bytes();
    match b {
        b"<SELF>" => true,
        [b'<', b'S', b'E', b'L', b'F', b'>', b'_', ..] if b.len() > 7 => all_bytes_numeric(b, 7),
        [b'a'..=b'z', ..] | [b'A'..=b'Z', ..] => all_bytes_valid(b, 1),
        [b'_', ..] | [b'$', ..] if b.len() > 1 => all_bytes_valid(b, 1),
        _ => false,
    }
}
```

**File:** third_party/move/move-binary-format/src/file_format_common.rs (L20-27)
```rust
};

/// Constant values for the binary format header.
///
/// The binary header is magic + version info + table count.
pub enum BinaryConstants {}
impl BinaryConstants {
    /// The `DIEM_MAGIC` size, 4 byte for major version and 1 byte for table count.
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L142-142)
```rust
        [memory_quota: AbstractValueSize, { 1.. => "memory_quota" }, 10_000_000],
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/misc.rs (L335-343)
```rust
    fn visit_vec_u8(&mut self, depth: u64, vals: &[u8]) -> PartialVMResult<()> {
        self.check_depth(depth)?;
        let mut size = self.params.per_u8_packed * NumArgs::new(vals.len() as u64);
        if self.feature_version >= 3 {
            size += self.params.vector;
        }
        self.size += size;
        Ok(())
    }
```

**File:** aptos-move/framework/aptos-framework/sources/function_info.move (L35-53)
```text
    public fun new_function_info_from_address(
        module_address: address,
        module_name: String,
        function_name: String,
    ): FunctionInfo {
        assert!(
            is_identifier(string::bytes(&module_name)),
            EINVALID_IDENTIFIER
        );
        assert!(
            is_identifier(string::bytes(&function_name)),
            EINVALID_IDENTIFIER
        );
        FunctionInfo {
            module_address,
            module_name,
            function_name,
        }
    }
```

**File:** aptos-move/aptos-memory-usage-tracker/src/lib.rs (L322-343)
```rust
    fn charge_native_function_before_execution(
        &mut self,
        ty_args: impl ExactSizeIterator<Item = impl TypeView> + Clone,
        args: impl ExactSizeIterator<Item = impl ValueView> + Clone,
    ) -> PartialVMResult<()> {
        // TODO(Gas): https://github.com/aptos-labs/aptos-core/issues/5485
        if !self.should_leak_memory_for_native {
            self.release_heap_memory(args.clone().try_fold(
                AbstractValueSize::zero(),
                |acc, val| {
                    let heap_size = self
                        .vm_gas_params()
                        .misc
                        .abs_val
                        .abstract_heap_size(val, self.feature_version())?;
                    Ok::<_, PartialVMError>(acc + heap_size)
                },
            )?);
        }

        self.base
            .charge_native_function_before_execution(ty_args, args)
```
