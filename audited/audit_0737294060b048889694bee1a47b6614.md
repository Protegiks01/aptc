# Audit Report

## Title
Mutex Poisoning via Panic-on-Send Leading to Complete Network Message Service Denial of Service

## Summary
The `GRPCNetworkMessageServiceServerWrapper::simple_msg_exchange` implementation holds a mutex lock during a potentially panicking channel send operation. If a message handler's receiver is dropped (during component shutdown or crash) while the gRPC service remains active, any incoming message for that handler type triggers a panic while holding the mutex lock, permanently poisoning the mutex and causing all subsequent network messages to fail with panic.

## Finding Description

The vulnerability exists in the implementation of the `NetworkMessageService` trait for the gRPC-based remote executor network communication system. [1](#0-0) 

The generated gRPC service code wraps implementors in an `Arc` and allows concurrent calls to `simple_msg_exchange`. The actual implementation stores message handlers in a mutex-protected HashMap. [2](#0-1) 

The critical code path exhibits a race condition between message handling and component lifecycle: [3](#0-2) 

Due to Rust's temporary lifetime extension rules, the `MutexGuard` from `lock().unwrap()` remains alive through the `if let` block body, meaning the mutex lock is held during the `handler.send(msg).unwrap()` call. If the channel receiver has been dropped (which occurs when service components shut down or crash), the `send()` operation fails and `.unwrap()` panics **while holding the mutex lock**.

This causes permanent mutex poisoning - all subsequent calls to `simple_msg_exchange` panic on `lock().unwrap()`, completely disabling the network message service for ALL message types, not just the one whose receiver was dropped.

**Attack Path:**
1. Remote executor service components register handlers via `create_inbound_channel` [4](#0-3) 
2. A component crashes, is reconfigured, or shuts down, dropping its `Receiver<Message>` [5](#0-4) 
3. GRPCNetworkMessageServiceServerWrapper remains active with stale handler
4. Any gRPC client sends a message matching the dropped handler's type
5. The send operation fails, panic occurs while holding lock, mutex becomes poisoned
6. All future network messages across ALL types fail permanently

## Impact Explanation

**Severity: HIGH** (per Aptos Bug Bounty categories: "API crashes" and "Validator node slowdowns")

This vulnerability causes **complete denial of service** of the remote executor network communication system. Once triggered:
- ALL message types stop being processed (not just the one whose handler failed)
- The service requires a full restart to recover
- Remote state view queries fail, impacting distributed execution
- Cross-shard communication becomes impossible

While this doesn't directly compromise consensus safety or cause fund loss, it severely degrades validator node operation by:
- Preventing remote execution coordination
- Blocking distributed state queries
- Forcing service restarts and potential data loss
- Creating a single point of failure from ANY component crash

The vulnerability affects the **Resource Limits** invariant - the system fails to gracefully handle resource cleanup (dropped receivers) and instead cascades into complete service failure.

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH**

This vulnerability is likely to trigger in production because:

1. **Component lifecycle is independent**: Service components like `RemoteStateViewService` can crash, restart, or reconfigure independently of the gRPC server
2. **No cleanup mechanism**: Dropped receivers leave stale handlers in the HashMap with no automatic cleanup
3. **No panic boundaries**: The gRPC handler has no `catch_unwind` or error recovery
4. **Common operations**: Component restarts, reconfigurations, and crashes are normal operational events

An attacker doesn't need special access - they simply need to send a network message after ANY service component has dropped its receiver, which can occur through:
- Normal component shutdowns during reconfigurations
- Component crashes due to other bugs
- Intentional DoS by causing components to crash first

## Recommendation

**Fix 1: Release lock before send operation**
```rust
async fn simple_msg_exchange(
    &self,
    request: Request<NetworkMessage>,
) -> Result<Response<Empty>, Status> {
    let _timer = NETWORK_HANDLER_TIMER
        .with_label_values(&[&self.self_addr.to_string(), "inbound_msgs"])
        .start_timer();
    let remote_addr = request.remote_addr();
    let network_message = request.into_inner();
    let msg = Message::new(network_message.message);
    let message_type = MessageType::new(network_message.message_type);

    // Clone the handler to release lock before send
    let handler = {
        let handlers = self.inbound_handlers.lock().unwrap();
        handlers.get(&message_type).cloned()
    };

    if let Some(handler) = handler {
        // Send without holding lock, handle errors gracefully
        if let Err(e) = handler.send(msg) {
            error!(
                "Failed to send message from {:?} for type {:?}: {}",
                remote_addr, message_type, e
            );
            return Err(Status::internal("Handler unavailable"));
        }
    } else {
        error!(
            "No handler registered for sender: {:?} and msg type {:?}",
            remote_addr, message_type
        );
        return Err(Status::not_found("No handler registered"));
    }
    Ok(Response::new(Empty {}))
}
```

**Fix 2: Add handler cleanup on receiver drop**
Implement a mechanism to remove handlers from the HashMap when their receivers are dropped, preventing stale handlers.

**Fix 3: Use try_lock or expect instead of unwrap**
Replace `.unwrap()` with `.expect("message")` to provide better error context, or handle `PoisonError` explicitly to recover from poisoning.

## Proof of Concept

```rust
#[cfg(test)]
mod race_condition_poc {
    use super::*;
    use std::time::Duration;
    use std::thread;

    #[test]
    fn test_mutex_poisoning_via_dropped_receiver() {
        let server_addr = SocketAddr::new(
            IpAddr::V4(Ipv4Addr::LOCALHOST), 
            utils::get_available_port()
        );
        
        let server_handlers: Arc<Mutex<HashMap<MessageType, Sender<Message>>>> =
            Arc::new(Mutex::new(HashMap::new()));

        let message_type = "test_crash".to_string();
        
        // Create channel and register handler
        let (msg_tx, msg_rx) = crossbeam_channel::unbounded();
        server_handlers
            .lock()
            .unwrap()
            .insert(MessageType::new(message_type.clone()), msg_tx);
        
        let server = GRPCNetworkMessageServiceServerWrapper::new(
            server_handlers.clone(), 
            server_addr
        );

        let rt = Runtime::new().unwrap();
        let (shutdown_tx, shutdown_rx) = oneshot::channel();
        server.start(&rt, "test".to_string(), server_addr, 1000, shutdown_rx);

        // Wait for server to start
        thread::sleep(Duration::from_millis(100));

        // Simulate component crash: drop receiver
        drop(msg_rx);

        // Create client
        let mut client = GRPCNetworkMessageServiceClientWrapper::new(&rt, server_addr);
        let client_addr = SocketAddr::new(
            IpAddr::V4(Ipv4Addr::LOCALHOST), 
            utils::get_available_port()
        );

        // First message triggers panic and mutex poisoning
        let result1 = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            rt.block_on(async {
                client.send_message(
                    client_addr,
                    Message::new(vec![1, 2, 3]),
                    &MessageType::new(message_type.clone()),
                ).await;
            });
        }));
        
        assert!(result1.is_err(), "First message should panic on send");

        // Wait a bit
        thread::sleep(Duration::from_millis(50));

        // Second message should fail due to poisoned mutex
        // Even with a DIFFERENT message type
        let (other_tx, other_rx) = crossbeam_channel::unbounded();
        server_handlers
            .lock()
            .unwrap()
            .insert(MessageType::new("other_type".to_string()), other_tx);

        let result2 = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            rt.block_on(async {
                client.send_message(
                    client_addr,
                    Message::new(vec![4, 5, 6]),
                    &MessageType::new("other_type".to_string()),
                ).await;
            });
        }));

        // This demonstrates the DoS: ALL subsequent messages fail
        assert!(result2.is_err(), "Subsequent messages fail due to poisoned mutex");
        
        shutdown_tx.send(()).unwrap();
    }
}
```

This PoC demonstrates that dropping a receiver while the service is active causes a panic that poisons the mutex, making ALL subsequent network messages (even of different types) fail permanently.

### Citations

**File:** protos/rust/src/pb/aptos.remote_executor.v1.tonic.rs (L224-237)
```rust
                        fn call(
                            &mut self,
                            request: tonic::Request<super::NetworkMessage>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as NetworkMessageService>::simple_msg_exchange(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
```

**File:** secure/net/src/grpc_network_service/mod.rs (L25-28)
```rust
pub struct GRPCNetworkMessageServiceServerWrapper {
    inbound_handlers: Arc<Mutex<HashMap<MessageType, Sender<Message>>>>,
    self_addr: SocketAddr,
}
```

**File:** secure/net/src/grpc_network_service/mod.rs (L105-107)
```rust
        if let Some(handler) = self.inbound_handlers.lock().unwrap().get(&message_type) {
            // Send the message to the registered handler
            handler.send(msg).unwrap();
```

**File:** secure/net/src/network_controller/mod.rs (L128-137)
```rust
    pub fn create_inbound_channel(&mut self, message_type: String) -> Receiver<Message> {
        let (inbound_sender, inbound_receiver) = unbounded();

        self.inbound_handler
            .lock()
            .unwrap()
            .register_handler(message_type, inbound_sender);

        inbound_receiver
    }
```

**File:** execution/executor-service/src/remote_state_view_service.rs (L17-22)
```rust
pub struct RemoteStateViewService<S: StateView + Sync + Send + 'static> {
    kv_rx: Receiver<Message>,
    kv_tx: Arc<Vec<Sender<Message>>>,
    thread_pool: Arc<rayon::ThreadPool>,
    state_view: Arc<RwLock<Option<Arc<S>>>>,
}
```
