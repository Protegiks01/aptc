# Audit Report

## Title
Bytecode Stability Check Bypass via Missing Compilation Metadata Allows Unstable Bytecode on Mainnet

## Summary
The `UNSTABLE_BYTECODE_REJECTED` check can be bypassed by publishing Move modules without compilation metadata, allowing unstable bytecode with experimental features to be deployed on mainnet. This creates a bytecode version confusion vulnerability that violates deterministic execution guarantees.

## Finding Description

The unstable bytecode rejection mechanism is implemented in two functions that check whether bytecode compiled with unstable compiler or language versions can be deployed on mainnet: [1](#0-0) [2](#0-1) 

The critical vulnerability lies in how these functions handle missing compilation metadata. When `get_compilation_metadata()` returns `None`, the check is **silently skipped** and returns `Ok(())`, allowing the bytecode to be published without validation: [3](#0-2) 

This creates a version confusion scenario where:

1. **Bytecode can be compiled with unstable features** (LanguageVersion V2_4 or V2_5) which are marked as unstable: [4](#0-3) 

2. **The compilation metadata can be stripped** from the compiled module before publishing, causing `get_compilation_metadata()` to return `None`

3. **The validation is bypassed** because the check only examines metadata, not the actual bytecode version field in the `CompiledModule` structure

4. **No enforcement of metadata presence** - The metadata format check only validates format when metadata exists, but does not require it: [5](#0-4) 

**Attack Path:**
1. Attacker compiles Move code using unstable language version (V2_4 or V2_5) with experimental features
2. Attacker deserializes the compiled bytecode and removes the `COMPILATION_METADATA_KEY` entry from the metadata vector
3. Attacker re-serializes and publishes this modified bytecode on mainnet
4. The `reject_unstable_bytecode` check passes because `get_compilation_metadata()` returns `None`
5. Unstable bytecode with experimental features is now deployed on mainnet

**Invariant Violation:**
This breaks the **Deterministic Execution** invariant. Different validator nodes may have different implementations of unstable bytecode features, leading to divergent execution results for the same input, potentially causing consensus splits.

## Impact Explanation

**Severity: Medium to High**

This vulnerability creates several risks:

1. **Consensus Split Risk**: If unstable bytecode contains experimental features that are interpreted differently by validators (due to implementation variations or bugs in unstable features), different validators could produce different execution results for identical transactions, violating consensus safety.

2. **Deterministic Execution Violation**: The Aptos blockchain relies on all validators producing identical state roots for identical blocks. Unstable bytecode features may have incomplete implementations or bugs that break this guarantee.

3. **Testnet-to-Mainnet Replay**: Bytecode compiled and tested on testnet with unstable features can be deployed on mainnet by simply stripping the metadata, bypassing the intended safety mechanism.

While this doesn't directly result in fund loss, it threatens the **consensus safety** of the network, which qualifies as High severity under Aptos bug bounty criteria. However, exploitation requires the unstable features to actually cause divergent behavior, which may not occur in all cases, potentially reducing this to Medium severity.

## Likelihood Explanation

**Likelihood: Medium**

The attack requires:
- Knowledge of the compilation metadata structure and how to manipulate it
- Access to compile Move code with unstable language versions
- Understanding that the metadata check can be bypassed

However:
- The attack is technically straightforward for someone familiar with Move bytecode
- No privileged access is required - any user can publish modules
- The vulnerability is in production code that is active on mainnet
- The feature flags preventing unstable bytecode are already enabled, indicating this is an intended security control

The main limiting factor is that the attacker would need unstable bytecode that actually causes consensus issues, which may not happen with all unstable features.

## Recommendation

**Fix 1: Reject modules without compilation metadata on mainnet**

Modify the rejection functions to explicitly check for missing metadata on mainnet:

```rust
fn reject_unstable_bytecode(&self, modules: &[CompiledModule]) -> VMResult<()> {
    if self.chain_id().is_mainnet() {
        for module in modules {
            let metadata = get_compilation_metadata(module);
            
            // Reject modules without compilation metadata on mainnet
            if metadata.is_none() {
                return Err(PartialVMError::new(StatusCode::UNSTABLE_BYTECODE_REJECTED)
                    .with_message(
                        "modules without compilation metadata cannot be published on mainnet".to_string(),
                    )
                    .finish(Location::Undefined));
            }
            
            if metadata.unwrap().unstable {
                return Err(PartialVMError::new(StatusCode::UNSTABLE_BYTECODE_REJECTED)
                    .with_message(
                        "code marked unstable is not published on mainnet".to_string(),
                    )
                    .finish(Location::Undefined));
            }
        }
    }
    Ok(())
}
```

Apply the same fix to `reject_unstable_bytecode_for_script`.

**Fix 2: Validate bytecode version field**

Additionally, validate that the bytecode version in `CompiledModule.version` matches stable bytecode format versions to prevent version confusion at a deeper level.

**Fix 3: Enable SAFER_METADATA by default**

Ensure the `SAFER_METADATA` feature flag is enabled on mainnet to enforce metadata validation through `check_metadata_format`.

## Proof of Concept

```rust
// Rust test demonstrating the bypass
#[test]
fn test_unstable_bytecode_bypass_via_missing_metadata() {
    let mut harness = MoveHarness::new();
    let account = harness.new_account_at(AccountAddress::from_hex_literal("0xf00d").unwrap());
    
    // Compile module with unstable language version
    let mut builder = PackageBuilder::new("TestPackage");
    builder.add_source(
        "test.move",
        r#"
        module 0xf00d::Test {
            public fun unstable_feature() { }
        }
        "#,
    );
    let path = builder.write_to_temp().unwrap();
    
    let package = BuiltPackage::build(
        path.path().to_path_buf(),
        BuildOptions {
            compiler_version: Some(CompilerVersion::latest()), // V2_1 - unstable
            language_version: Some(LanguageVersion::V2_4),     // unstable
            ..BuildOptions::default()
        }
    ).expect("build should succeed");
    
    let code = package.extract_code();
    let mut module = CompiledModule::deserialize(&code[0]).unwrap();
    
    // Strip compilation metadata
    module.metadata.retain(|m| m.key != *COMPILATION_METADATA_KEY);
    
    let mut stripped_code = vec![];
    module.serialize(&mut stripped_code).unwrap();
    
    // Set chain to mainnet
    harness.set_resource(
        CORE_CODE_ADDRESS,
        ChainId::struct_tag(),
        &ChainId::mainnet().id(),
    );
    
    // Attempt to publish on mainnet - should fail but currently succeeds
    let result = harness.run_transaction_payload_mainnet(
        &account,
        aptos_stdlib::code_publish_package_txn(
            bcs::to_bytes(&package.extract_metadata().unwrap()).unwrap(),
            vec![stripped_code],
        ),
    );
    
    // This demonstrates the vulnerability - the transaction succeeds
    // when it should have failed with UNSTABLE_BYTECODE_REJECTED
    assert!(result.status().is_success()); // Currently passes - this is the bug!
}
```

## Notes

The vulnerability exists because the security check makes an incorrect assumption that the absence of compilation metadata is safe. This violates the security principle that missing security-critical data should fail closed, not open. The fix must require compilation metadata for all modules published on mainnet going forward, while potentially grandfathering existing modules that lack this metadata.

### Citations

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1742-1757)
```rust
    fn reject_unstable_bytecode(&self, modules: &[CompiledModule]) -> VMResult<()> {
        if self.chain_id().is_mainnet() {
            for module in modules {
                if let Some(metadata) = get_compilation_metadata(module) {
                    if metadata.unstable {
                        return Err(PartialVMError::new(StatusCode::UNSTABLE_BYTECODE_REJECTED)
                            .with_message(
                                "code marked unstable is not published on mainnet".to_string(),
                            )
                            .finish(Location::Undefined));
                    }
                }
            }
        }
        Ok(())
    }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1760-1771)
```rust
    pub fn reject_unstable_bytecode_for_script(&self, script: &CompiledScript) -> VMResult<()> {
        if self.chain_id().is_mainnet() {
            if let Some(metadata) = get_compilation_metadata(script) {
                if metadata.unstable {
                    return Err(PartialVMError::new(StatusCode::UNSTABLE_BYTECODE_REJECTED)
                        .with_message("script marked unstable cannot be run on mainnet".to_string())
                        .finish(Location::Script));
                }
            }
        }
        Ok(())
    }
```

**File:** types/src/vm/module_metadata.rs (L253-283)
```rust
fn check_metadata_format(module: &CompiledModule) -> Result<(), MalformedError> {
    let mut exist = false;
    let mut compilation_key_exist = false;
    for data in module.metadata.iter() {
        if data.key == *APTOS_METADATA_KEY || data.key == *APTOS_METADATA_KEY_V1 {
            if exist {
                return Err(MalformedError::DuplicateKey);
            }
            exist = true;

            if data.key == *APTOS_METADATA_KEY {
                bcs::from_bytes::<RuntimeModuleMetadata>(&data.value)
                    .map_err(|e| MalformedError::DeserializedError(data.key.clone(), e))?;
            } else if data.key == *APTOS_METADATA_KEY_V1 {
                bcs::from_bytes::<RuntimeModuleMetadataV1>(&data.value)
                    .map_err(|e| MalformedError::DeserializedError(data.key.clone(), e))?;
            }
        } else if data.key == *COMPILATION_METADATA_KEY {
            if compilation_key_exist {
                return Err(MalformedError::DuplicateKey);
            }
            compilation_key_exist = true;
            bcs::from_bytes::<CompilationMetadata>(&data.value)
                .map_err(|e| MalformedError::DeserializedError(data.key.clone(), e))?;
        } else {
            return Err(MalformedError::UnknownKey(data.key.clone()));
        }
    }

    Ok(())
}
```

**File:** types/src/vm/module_metadata.rs (L311-317)
```rust
pub fn get_compilation_metadata(code: &impl CompiledCodeMetadata) -> Option<CompilationMetadata> {
    if let Some(data) = find_metadata(code.metadata(), COMPILATION_METADATA_KEY) {
        bcs::from_bytes::<CompilationMetadata>(&data.value).ok()
    } else {
        None
    }
}
```

**File:** third_party/move/move-model/src/metadata.rs (L286-294)
```rust
    /// Whether the language version is unstable. An unstable version
    /// should not be allowed on production networks.
    pub const fn unstable(self) -> bool {
        use LanguageVersion::*;
        match self {
            V1 | V2_0 | V2_1 | V2_2 | V2_3 => false,
            V2_4 | V2_5 => true,
        }
    }
```
