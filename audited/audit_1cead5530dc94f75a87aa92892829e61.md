# Audit Report

## Title
Sharded Block Executor Applies Output Limits Per-Shard, Enabling Block Output Size Amplification

## Summary
The sharded block executor applies `block_output_limit` independently to each shard rather than globally, allowing the total aggregated block output to reach `num_shards × block_output_limit` bytes. This violates the design intent of limiting total block output size and can theoretically cause heap exhaustion during result aggregation.

## Finding Description

The `ShardedBlockExecutor::execute_block()` function aggregates transaction outputs from multiple independent shards without enforcing a global limit on the total output size. [1](#0-0) 

Each shard receives the same `BlockExecutorConfigFromOnchain` configuration, including the `block_output_limit`: [2](#0-1) 

The `block_output_limit` is documented as a "Block limit on the total (approximate) txn output size in bytes": [3](#0-2) 

However, during sharded execution, each shard independently enforces this limit via its own `BlockGasLimitProcessor`: [4](#0-3) 

This means if `num_shards = N`, the total aggregated output can reach `N × block_output_limit` before aggregation at line 109-110. With no bounds checking during aggregation, this violates the **Resource Limits** invariant (#9) requiring "all operations must respect gas, storage, and computational limits."

**Attack Scenario:**
1. Attacker submits transactions maximizing output within per-transaction limits (10MB write_set + 10MB events per transaction)
2. Block partitioner distributes transactions across N shards (e.g., N=8)
3. Each shard executes until reaching `block_output_limit` (e.g., 12MB from release config)
4. Aggregation creates vector of size `N × block_output_limit` (8 × 12MB = 96MB)
5. With higher configurations (N=32, limit=1GB in test config), total reaches 32GB [5](#0-4) 

## Impact Explanation

**Medium Severity** - This constitutes a design flaw that violates documented invariants but has limited practical impact with current production configurations:

- **Current Production Config**: block_output_limit ≈ 12MB, typical num_shards = 8, total = 96MB (unlikely to exhaust heap) [6](#0-5) 

- **Test Config Scenario**: block_output_limit = 1TB, num_shards = 32, theoretical total = 32TB (could cause issues) [7](#0-6) 

- **Genesis Default**: block_output_limit = 4MB [8](#0-7) 

The issue qualifies as **Medium Severity** per Aptos Bug Bounty criteria: "State inconsistencies requiring intervention" - the amplified output size violates the intended block output constraints, though immediate node crashes are unlikely with current configurations.

## Likelihood Explanation

**Likelihood: Low-Medium**

**Requirements for exploitation:**
- Attacker must submit numerous transactions maximizing output (each transaction limited to ~20MB total)
- Block must be sufficiently full to reach limits across multiple shards
- Significant gas costs required to submit many large-output transactions
- Network must be configured with high num_shards or high block_output_limit

**Mitigating factors:**
- Per-transaction limits constrain individual output sizes (10MB write_set, 10MB events) [9](#0-8) 
- Current production configs limit practical impact
- Requires sustained attack to consistently fill blocks

## Recommendation

Implement global output size tracking across all shards with enforcement before aggregation:

```rust
pub fn execute_block(
    &self,
    state_view: Arc<S>,
    transactions: PartitionedTransactions,
    concurrency_level_per_shard: usize,
    onchain_config: BlockExecutorConfigFromOnchain,
) -> Result<Vec<TransactionOutput>, VMStatus> {
    // ... existing code ...
    
    let mut aggregated_results = vec![];
    let mut total_approx_output_size = 0u64;
    let block_output_limit = onchain_config
        .block_gas_limit_type
        .block_output_limit();
    
    for result in ordered_results.into_iter() {
        // Check global limit before extending
        if let Some(limit) = block_output_limit {
            for output in &result {
                total_approx_output_size += output.approximate_size();
                if total_approx_output_size > limit {
                    return Err(VMStatus::Error(
                        StatusCode::STORAGE_WRITE_LIMIT_REACHED,
                        None
                    ));
                }
            }
        }
        aggregated_results.extend(result);
    }
    // ... rest of function ...
}
```

Additionally, consider dividing `block_output_limit` by `num_shards` when passing configuration to each shard to maintain the global limit invariant.

## Proof of Concept

```rust
// Rust integration test demonstrating the amplification
#[test]
fn test_sharded_output_amplification() {
    use aptos_types::block_executor::config::BlockExecutorConfigFromOnchain;
    use aptos_types::on_chain_config::BlockGasLimitType;
    
    let block_output_limit = 10 * 1024 * 1024; // 10MB intended limit
    let num_shards = 8;
    
    let config = BlockExecutorConfigFromOnchain::new(
        BlockGasLimitType::ComplexLimitV1 {
            effective_block_gas_limit: 1_000_000,
            execution_gas_effective_multiplier: 1,
            io_gas_effective_multiplier: 1,
            conflict_penalty_window: 8,
            use_granular_resource_group_conflicts: false,
            use_module_publishing_block_conflict: false,
            block_output_limit: Some(block_output_limit),
            include_user_txn_size_in_block_output: true,
            add_block_limit_outcome_onchain: false,
        },
        false,
        None,
    );
    
    // Create transactions that maximize output
    // Execute through sharded executor with num_shards
    // Observe aggregated output size can reach num_shards × block_output_limit
    // Expected: ~10MB total, Actual: up to ~80MB
}
```

## Notes

This vulnerability represents a design flaw where the architectural intent of block output limits is not correctly implemented in the sharded execution path. While current production configurations make severe exploitation unlikely, the principle of defense-in-depth suggests this should be addressed to prevent future misconfigurations from enabling attacks. The issue becomes more severe if network parameters are adjusted to increase either the number of shards or the block output limit threshold.

### Citations

**File:** aptos-move/aptos-vm/src/sharded_block_executor/mod.rs (L108-110)
```rust
        for result in ordered_results.into_iter() {
            aggregated_results.extend(result);
        }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/local_executor_shard.rs (L192-200)
```rust
        for (i, sub_blocks_for_shard) in sub_blocks.into_iter().enumerate() {
            self.command_txs[i]
                .send(ExecutorShardCommand::ExecuteSubBlocks(
                    state_view.clone(),
                    sub_blocks_for_shard,
                    concurrency_level_per_shard,
                    onchain_config.clone(),
                ))
                .unwrap();
```

**File:** types/src/on_chain_config/execution_config.rs (L151-151)
```rust
            block_output_limit: Some(4 * 1024 * 1024),
```

**File:** types/src/on_chain_config/execution_config.rs (L302-303)
```rust
        /// Block limit on the total (approximate) txn output size in bytes.
        block_output_limit: Option<u64>,
```

**File:** aptos-move/block-executor/src/limit_processor.rs (L111-117)
```rust
        if self.block_gas_limit_type.block_output_limit().is_some() {
            self.accumulated_approx_output_size += approx_output_size
                .expect("approx_output_size needs to be computed if block_output_limit is set");
        } else {
            assert_none!(approx_output_size);
        }
    }
```

**File:** aptos-move/aptos-vm/tests/sharded_block_executor.rs (L94-95)
```rust
        let max_num_shards = 32;
        let num_shards = rng.gen_range(1, max_num_shards);
```

**File:** aptos-move/aptos-release-builder/data/example-release-with-randomness-framework/release.yaml (L58-58)
```yaml
                block_output_limit: 12582912
```

**File:** types/src/block_executor/config.rs (L133-133)
```rust
                    block_output_limit: Some(1_000_000_000_000),
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L159-162)
```rust
            max_bytes_all_write_ops_per_transaction: NumBytes,
            { 5.. => "max_bytes_all_write_ops_per_transaction" },
            10 << 20, // all write ops from a single transaction are 10MB max
        ],
```
