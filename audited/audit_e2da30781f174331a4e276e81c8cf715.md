# Audit Report

## Title
Unmetered Storage Lookups for Friend Modules at Special Addresses Enable DoS Attack

## Summary
In the non-lazy loading module publishing path, friend modules declared at special addresses (0x0-0xf) bypass gas metering during dependency charging, then undergo unmetered storage existence checks in `create_with_compat_config()`. This allows attackers to force validators to perform expensive storage lookups without paying gas, enabling denial-of-service attacks against validator nodes.

## Finding Description

The vulnerability exists in the interaction between three components during module publishing when lazy loading is disabled:

**1. Gas Charging Phase** - Friends at special addresses are skipped: [1](#0-0) 

The `check_dependencies_and_charge_gas` function is called with all immediate friends. However, within this function: [2](#0-1) 

Friends are added to the traversal stack via `push_next_ids_to_visit`, which skips special addresses: [3](#0-2) 

The `visit_if_not_special_address` function returns `false` for special addresses (0x0-0xf): [4](#0-3) 

**2. Unmetered Validation Phase** - Storage lookups performed without gas charging: [5](#0-4) 

The `unmetered_check_module_exists` function performs storage lookups: [6](#0-5) 

This calls `get_module_or_build_with`, which invokes the builder's `build` method to fetch from storage: [7](#0-6) 

**3. No Negative Result Caching** - Failed lookups are NOT cached: [8](#0-7) 

When `builder.build(key)?` returns `None` (module doesn't exist), the `Vacant` entry is NOT inserted into the cache. This means repeated lookups for the same non-existent module will hit storage every time.

**Attack Scenario:**
1. Attacker creates a Move module declaring 500 friends at address 0x1 with non-existent names (e.g., `0x1::Fake1`, `0x1::Fake2`, ..., `0x1::Fake500`)
2. Attacker publishes this module when lazy loading is disabled
3. In `charge_package_dependencies`, all 500 friends are passed to `check_dependencies_and_charge_gas`
4. `push_next_ids_to_visit` skips all 500 friends because address 0x1 is special - no gas charged
5. Later, `create_with_compat_config` calls `unmetered_check_module_exists` for each friend
6. Each call performs an uncached storage lookup via `fetch_module_bytes`
7. The transaction fails (friends don't exist), but 500 unmetered storage lookups were performed
8. Attacker can spam such transactions to overwhelm validators with unpaid storage access

**Invariant Violated:**
This breaks Critical Invariant #9: "Resource Limits: All operations must respect gas, storage, and computational limits." The code comment explicitly states the invariant: [9](#0-8) 

## Impact Explanation

**High Severity** according to Aptos Bug Bounty criteria:

1. **Validator Node Slowdowns**: Validators must perform hundreds of unmetered storage lookups per malicious transaction, consuming CPU and I/O resources without compensation. A sustained attack could significantly degrade validator performance.

2. **Significant Protocol Violations**: This breaks the fundamental gas metering invariant that all storage accesses must be paid for. The protocol design assumes friends are "metered at the caller side" for special addresses, but they are not.

3. **Resource Exhaustion**: Attackers can exploit this to perform expensive operations (storage lookups) at minimal cost, violating the economic security model where computational work must be paid for.

4. **DoS Potential**: By spamming transactions with many non-existent friends at special addresses, attackers can force validators to waste resources processing transactions that will inevitably fail, reducing overall network throughput.

## Likelihood Explanation

**High Likelihood** - The attack is practical and easy to execute:

1. **No Special Privileges Required**: Any user can publish modules with friend declarations
2. **Simple Exploit**: The attacker only needs to craft a Move module with many friends at special addresses
3. **Deterministic Outcome**: The vulnerability triggers reliably when lazy loading is disabled
4. **Low Attack Cost**: The attacker pays minimal gas (only for the module bytes and failed publishing attempt) but forces expensive storage lookups
5. **Current Relevance**: While lazy loading may be enabled on mainnet, the non-lazy loading code path remains in production and could be used in specific scenarios or network configurations

The attack becomes more severe when:
- Network is under load (amplifies slowdown effect)
- Multiple attackers coordinate (distributed DoS)
- Move bytecode allows large friend lists (amplifies unmetered lookups per transaction)

## Recommendation

**Fix 1: Charge gas for friends at special addresses before validation**

In `charge_package_dependencies`, explicitly charge for friends at special addresses before they reach the validation phase:

```rust
// In aptos-move/aptos-vm/src/aptos_vm.rs, after line 1629:
// For non-lazy loading, charge gas for friends at special addresses
for (friend_addr, friend_name) in modules
    .iter()
    .flat_map(|module| module.immediate_friends_iter())
    .filter(|addr_and_name| !module_ids_in_bundle.contains(addr_and_name))
{
    if friend_addr.is_special() {
        // Special addresses were skipped in check_dependencies_and_charge_gas,
        // so charge for them explicitly here
        let size = module_storage
            .unmetered_get_module_size(friend_addr, friend_name)?
            .unwrap_or(0); // Charge for lookup even if module doesn't exist
        gas_meter
            .charge_dependency(
                DependencyKind::Existing,
                friend_addr,
                friend_name,
                NumBytes::new(size as u64),
            )
            .map_err(|err| err.finish(Location::Undefined))?;
    }
}
```

**Fix 2: Cache negative lookup results**

Modify the module cache to remember that a module doesn't exist, preventing repeated storage lookups for the same non-existent module within a transaction.

**Fix 3: Limit friend declarations**

Add a reasonable upper bound on the number of friends a module can declare (e.g., 50 friends) and enforce this during deserialization.

## Proof of Concept

```move
// malicious_module.move
module 0xcafe::exploit {
    // Declare many friends at special address 0x1 that don't exist
    friend 0x1::fake_friend_001;
    friend 0x1::fake_friend_002;
    friend 0x1::fake_friend_003;
    // ... repeat for 500 friends ...
    friend 0x1::fake_friend_500;
    
    public fun dummy() {}
}
```

```rust
// Rust test demonstrating the attack
#[test]
fn test_unmetered_friend_lookup_dos() {
    // 1. Setup test harness with lazy loading DISABLED
    let mut harness = MoveHarness::new();
    harness.set_feature_flag(FeatureFlag::LazyLoading, false);
    
    // 2. Create module with 500 non-existent friends at address 0x1
    let module_code = create_module_with_many_fake_friends(500);
    
    // 3. Attempt to publish - this should perform 500 unmetered storage lookups
    let result = harness.publish_module(
        account_addr,
        module_code
    );
    
    // 4. Transaction fails (friends don't exist) but validators performed
    //    500 storage lookups without charging gas for them
    assert!(result.is_err());
    
    // 5. Verify that gas was NOT charged for the 500 friend lookups
    let gas_used = result.gas_used();
    // Gas should only cover module bytes, not the 500 storage lookups
    assert!(gas_used < expected_gas_with_friend_lookups);
}
```

The PoC demonstrates that an attacker can force validators to perform hundreds of storage lookups without paying the corresponding gas, breaking the resource limits invariant and enabling DoS attacks.

## Notes

This vulnerability specifically affects the **non-lazy loading code path**. When lazy loading is enabled, all friends must be in the same bundle, which prevents this attack but introduces different usability constraints. The core issue is the inconsistency between the gas charging phase (which skips special addresses) and the validation phase (which expects them to be metered), creating an exploitable gap in the resource accounting system.

### Citations

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1616-1630)
```rust
        if !self.features().is_lazy_loading_enabled() {
            check_dependencies_and_charge_gas(
                module_storage,
                gas_meter,
                traversal_context,
                modules
                    .iter()
                    .flat_map(|module| {
                        module
                            .immediate_dependencies_iter()
                            .chain(module.immediate_friends_iter())
                    })
                    .filter(|addr_and_name| !module_ids_in_bundle.contains(addr_and_name)),
            )?;
            return Ok(());
```

**File:** third_party/move/move-vm/runtime/src/storage/dependencies_gas_charging.rs (L62-108)
```rust
pub fn check_dependencies_and_charge_gas<'a, I>(
    module_storage: &impl ModuleStorage,
    gas_meter: &mut impl DependencyGasMeter,
    traversal_context: &mut TraversalContext<'a>,
    ids: I,
) -> VMResult<()>
where
    I: IntoIterator<Item = (&'a AccountAddress, &'a IdentStr)>,
    I::IntoIter: DoubleEndedIterator,
{
    let _timer = VM_TIMER.timer_with_label("check_dependencies_and_charge_gas");

    // Initialize the work list (stack) and the map of visited modules.
    //
    // TODO: Determine the reserved capacity based on the max number of dependencies allowed.
    let mut stack = Vec::with_capacity(512);
    traversal_context.push_next_ids_to_visit(&mut stack, ids);

    while let Some((addr, name)) = stack.pop() {
        let size = module_storage.unmetered_get_existing_module_size(addr, name)?;
        gas_meter
            .charge_dependency(
                DependencyKind::Existing,
                addr,
                name,
                NumBytes::new(size as u64),
            )
            .map_err(|err| err.finish(Location::Module(ModuleId::new(*addr, name.to_owned()))))?;

        // Extend the lifetime of the module to the remainder of the function body
        // by storing it in an arena.
        //
        // This is needed because we need to store references derived from it in the
        // work list.
        let compiled_module =
            module_storage.unmetered_get_existing_deserialized_module(addr, name)?;
        let compiled_module = traversal_context.referenced_modules.alloc(compiled_module);

        // Explore all dependencies and friends that have been visited yet.
        let imm_deps_and_friends = compiled_module
            .immediate_dependencies_iter()
            .chain(compiled_module.immediate_friends_iter());
        traversal_context.push_next_ids_to_visit(&mut stack, imm_deps_and_friends);
    }

    Ok(())
}
```

**File:** third_party/move/move-vm/runtime/src/module_traversal.rs (L59-65)
```rust
    pub fn visit_if_not_special_address(
        &mut self,
        addr: &'a AccountAddress,
        name: &'a IdentStr,
    ) -> bool {
        !addr.is_special() && self.visited.insert((addr, name), ()).is_none()
    }
```

**File:** third_party/move/move-vm/runtime/src/module_traversal.rs (L124-137)
```rust
    pub(crate) fn push_next_ids_to_visit<I>(
        &mut self,
        stack: &mut Vec<(&'a AccountAddress, &'a IdentStr)>,
        ids: I,
    ) where
        I: IntoIterator<Item = (&'a AccountAddress, &'a IdentStr)>,
        I::IntoIter: DoubleEndedIterator,
    {
        for (addr, name) in ids.into_iter().rev() {
            if self.visit_if_not_special_address(addr, name) {
                stack.push((addr, name));
            }
        }
    }
```

**File:** third_party/move/move-vm/runtime/src/storage/publishing.rs (L291-300)
```rust
            // Also verify that all friends exist.
            for (friend_addr, friend_name) in compiled_module.immediate_friends_iter() {
                // INVARIANT:
                //   Friends of the module in a bundle must be metered at the caller side. For lazy
                //   loading, friends must be in the same bundle (which implies that the access is
                //   already metered).
                if !staged_module_storage.unmetered_check_module_exists(friend_addr, friend_name)? {
                    return Err(module_linker_error!(friend_addr, friend_name));
                }
            }
```

**File:** third_party/move/move-vm/runtime/src/storage/module_storage.rs (L191-198)
```rust
    fn unmetered_check_module_exists(
        &self,
        address: &AccountAddress,
        module_name: &IdentStr,
    ) -> VMResult<bool> {
        let id = ModuleId::new(*address, module_name.to_owned());
        Ok(self.get_module_or_build_with(&id, self)?.is_some())
    }
```

**File:** third_party/move/move-vm/runtime/src/storage/implementations/unsync_module_storage.rs (L136-160)
```rust
    fn build(
        &self,
        key: &Self::Key,
    ) -> VMResult<Option<ModuleCode<Self::Deserialized, Self::Verified, Self::Extension>>> {
        let mut bytes = match self.ctx.fetch_module_bytes(key.address(), key.name())? {
            Some(bytes) => bytes,
            None => return Ok(None),
        };
        // TODO: remove this once framework on mainnet is using the new option module
        if let Some(replaced_bytes) = self
            .ctx
            .runtime_environment()
            .get_module_bytes_override(key.address(), key.name())
        {
            bytes = replaced_bytes;
        }
        let compiled_module = self
            .ctx
            .runtime_environment()
            .deserialize_into_compiled_module(&bytes)?;
        let hash = sha3_256(&bytes);
        let extension = Arc::new(BytesWithHash::new(bytes, hash));
        let module = ModuleCode::from_deserialized(compiled_module, extension);
        Ok(Some(module))
    }
```

**File:** third_party/move/move-vm/types/src/code/cache/module_cache.rs (L333-358)
```rust
    fn get_module_or_build_with(
        &self,
        key: &Self::Key,
        builder: &dyn ModuleCodeBuilder<
            Key = Self::Key,
            Deserialized = Self::Deserialized,
            Verified = Self::Verified,
            Extension = Self::Extension,
        >,
    ) -> VMResult<
        Option<(
            Arc<ModuleCode<Self::Deserialized, Self::Verified, Self::Extension>>,
            Self::Version,
        )>,
    > {
        use hashbrown::hash_map::Entry::*;

        Ok(match self.module_cache.borrow_mut().entry(key.clone()) {
            Occupied(entry) => Some(entry.get().as_module_code_and_version()),
            Vacant(entry) => builder.build(key)?.map(|module| {
                entry
                    .insert(VersionedModuleCode::new_with_default_version(module))
                    .as_module_code_and_version()
            }),
        })
    }
```
