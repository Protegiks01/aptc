# Audit Report

## Title
Thread Pool Exhaustion via Blocking REST Calls in Network Discovery Causing Loss of Liveness

## Summary
The `RestStream::poll_next()` function in the network discovery module uses `futures::executor::block_on()` to make synchronous blocking REST API calls from within an async context, directly blocking tokio worker threads. This can exhaust the async executor's thread pool, causing critical network tasks (consensus messaging, peer management, state sync) to stall and resulting in loss of liveness.

## Finding Description

The network discovery subsystem provides multiple mechanisms for discovering peers, including REST-based discovery. The `RestStream` implementation polls a REST endpoint at regular intervals to fetch the current validator set. However, the implementation contains a critical flaw in how it handles async operations. [1](#0-0) 

The `poll_next()` function uses `futures::executor::block_on()` to convert an async REST API call into a blocking operation. This is explicitly acknowledged as problematic by the developers through the TODO comment. When this function is called from within the async runtime (which happens when the discovery task is polled), it blocks the current tokio worker thread for the duration of the REST call (up to 10 seconds timeout). [2](#0-1) 

The discovery listeners are spawned on the network runtime and share the same thread pool as critical network operations: [3](#0-2) 

Each network gets its own dedicated tokio runtime: [4](#0-3) 

Critical network services including consensus messaging run on the same runtime: [5](#0-4) 

**Attack Scenario:**

1. An attacker configures or controls a REST endpoint used for network discovery
2. The endpoint becomes slow or unresponsive (but not completely unreachable, causing timeouts rather than immediate failures)
3. The discovery task blocks a worker thread for up to 10 seconds per poll
4. In constrained configurations (test environments with `runtime_threads = Some(1)`), this blocks the entire network runtime
5. In production configurations, repeated blocking calls during high load can exhaust available worker threads
6. Critical async tasks (consensus message handling, peer connections, state synchronization) cannot execute
7. The node experiences loss of liveness and cannot participate in consensus [6](#0-5) 

Test configurations explicitly set network runtimes to use only 1 thread, making this vulnerability deterministic.

## Impact Explanation

**High Severity** - This vulnerability qualifies as "Validator node slowdowns" under the Aptos bug bounty program's High Severity category.

**In Test/Development Environments (Critical Impact):**
- Networks configured with `runtime_threads = Some(1)` experience complete thread pool exhaustion
- All async tasks on the network runtime are blocked for up to 10 seconds per REST poll
- Consensus messages cannot be processed, causing the node to fall out of sync
- Complete loss of liveness for the affected network during blocking periods

**In Production Environments (High Impact):**
- Default configuration uses one thread per CPU core, providing more resilience
- However, under load or with multiple concurrent blocking calls, worker threads can still be exhausted
- Causes significant latency spikes in consensus message processing
- Degrades network performance and validator effectiveness
- Can cause validators to miss consensus rounds or appear unresponsive

**Broken Invariants:**
1. **Resource Limits**: The async executor's thread pool should not be blocked by I/O operations
2. **Liveness Guarantee**: Network tasks must remain responsive to process critical messages
3. **Async Execution Model**: Async tasks should use non-blocking operations or delegate to blocking thread pools

## Likelihood Explanation

**Likelihood: Medium to High**

**Favorable Conditions for Exploitation:**
1. REST discovery is a documented and supported feature
2. The feature is actively tested and used in the codebase
3. Configuration is straightforward - operators can easily enable REST discovery
4. An attacker only needs to control or influence a REST endpoint (via network conditions, compromise, or misconfiguration)
5. No special privileges or validator access required [7](#0-6) 

**Attack Complexity:**
- **Low**: Simply configure a slow or intermittently responsive REST endpoint
- Network latency, rate limiting, or service degradation achieves the same effect
- Can occur accidentally due to infrastructure issues (misconfigured load balancers, network issues)

**Mitigating Factors:**
- REST discovery may not be widely used in production (on-chain discovery is more common)
- Production servers typically have sufficient CPU cores to tolerate some thread blocking
- Operators may not enable REST discovery on validator networks

However, the explicit acknowledgment in the code confirms this is a known architectural problem awaiting resolution. [8](#0-7) 

## Recommendation

**Immediate Fix:**
Replace the blocking `block_on()` call with proper async handling. The REST client already provides async methods - use them directly.

**Corrected Implementation:**
```rust
fn poll_next(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<Self::Item>> {
    // Wait for delay, or add the delay for next call
    futures::ready!(self.interval.as_mut().poll_next(cx));

    // Poll the async REST call directly without blocking
    let response_fut = self.rest_client.get_account_resource_bcs::<ValidatorSet>(
        AccountAddress::ONE,
        "0x1::stake::ValidatorSet",
    );
    
    // Box and pin the future if needed, or restructure to store the future in RestStream
    // This requires refactoring RestStream to hold the in-progress future
}
```

**Better Architectural Approach:**
Store the REST call future as state in `RestStream` and poll it properly, or use `tokio::spawn()` to execute the REST call on the async runtime without blocking.

**Alternative Using spawn_blocking() (if blocking is necessary):**
```rust
// If blocking is truly required, use tokio's blocking thread pool
let response = tokio::task::spawn_blocking(move || {
    futures::executor::block_on(rest_client.get_account_resource_bcs::<ValidatorSet>(
        AccountAddress::ONE,
        "0x1::stake::ValidatorSet",
    ))
}).await;
```

However, since the `aptos_rest_client` already provides async APIs, the proper fix is to use them directly in an async manner.

## Proof of Concept

**Reproduction Steps:**

1. Create a test network with REST discovery enabled and `runtime_threads = Some(1)`
2. Configure the REST endpoint to respond slowly (5-10 seconds delay)
3. Observe that during the blocking REST call, no other network tasks can execute
4. Measure consensus message latency - it will spike to 10+ seconds
5. Verify thread pool exhaustion via tokio runtime metrics

**Test Code:**
```rust
#[tokio::test]
async fn test_rest_discovery_thread_pool_exhaustion() {
    // Create a slow REST server that takes 5 seconds to respond
    let slow_server = spawn_slow_rest_server(Duration::from_secs(5));
    
    // Configure network with single thread and REST discovery
    let mut network_config = NetworkConfig::network_with_id(NetworkId::Public);
    network_config.runtime_threads = Some(1);  // Single thread - guaranteed blocking
    network_config.discovery_method = DiscoveryMethod::Rest(RestDiscovery {
        url: slow_server.url(),
        interval_secs: 1,  // Poll every second
    });
    
    // Create runtime and spawn discovery + a test task
    let runtime = create_network_runtime(&network_config);
    let start = Instant::now();
    
    runtime.spawn(async {
        // This task should complete quickly, but will be blocked
        tokio::time::sleep(Duration::from_millis(100)).await;
        println!("Task completed in {:?}", start.elapsed());
        // Expected: ~100ms, Actual: ~5+ seconds due to blocking
    });
    
    // Start discovery - this will block the single worker thread
    // The test task above won't execute until after the blocking call completes
    
    // Assert that task completion is delayed beyond 5 seconds
    tokio::time::sleep(Duration::from_secs(6)).await;
    // Verify via metrics or logging that thread was blocked
}
```

**Notes**

This vulnerability represents a clear violation of async runtime best practices. The use of `futures::executor::block_on()` from within an already-async context defeats the purpose of async execution and creates the exact thread starvation scenario that async runtimes are designed to prevent.

The developers are aware of this issue (as evidenced by the TODO comment), but it remains unresolved in the current codebase. The impact ranges from severe performance degradation to complete loss of liveness depending on the runtime configuration and deployment environment.

The vulnerability is especially concerning because:
1. It affects network discovery, a fundamental component for node operation
2. The same runtime handles consensus messages, making consensus vulnerable to disruption
3. Test configurations with single-threaded runtimes experience deterministic failures
4. The issue can be triggered accidentally through infrastructure problems, not just malicious attacks

### Citations

**File:** network/discovery/src/rest.rs (L42-68)
```rust
    fn poll_next(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<Self::Item>> {
        // Wait for delay, or add the delay for next call
        futures::ready!(self.interval.as_mut().poll_next(cx));

        // Retrieve the onchain resource at the interval
        // TODO there should be a better way than converting this to a blocking call
        let response = block_on(self.rest_client.get_account_resource_bcs::<ValidatorSet>(
            AccountAddress::ONE,
            "0x1::stake::ValidatorSet",
        ));
        Poll::Ready(match response {
            Ok(inner) => {
                let validator_set = inner.into_inner();
                Some(Ok(extract_validator_set_updates(
                    self.network_context,
                    validator_set,
                )))
            },
            Err(err) => {
                info!(
                    "Failed to retrieve validator set by REST discovery {:?}",
                    err
                );
                Some(Err(DiscoveryError::Rest(err)))
            },
        })
    }
```

**File:** crates/aptos-rest-client/src/client_builder.rs (L54-54)
```rust
            timeout: Duration::from_secs(10), // Default to 10 seconds
```

**File:** network/discovery/src/lib.rs (L127-129)
```rust
    pub fn start(self, executor: &Handle) {
        spawn_named!("DiscoveryChangeListener", executor, Box::pin(self).run());
    }
```

**File:** aptos-node/src/network.rs (L294-307)
```rust
        if network_id.is_validator_network() {
            // A validator node must have only a single consensus network handle
            if consensus_network_handle.is_some() {
                panic!("There can be at most one validator network!");
            } else {
                let network_handle = register_client_and_service_with_network(
                    &mut network_builder,
                    network_id,
                    &network_config,
                    consensus_network_configuration(node_config),
                    true,
                );
                consensus_network_handle = Some(network_handle);
            }
```

**File:** aptos-node/src/network.rs (L459-469)
```rust
fn create_network_runtime(network_config: &NetworkConfig) -> Runtime {
    let network_id = network_config.network_id;
    debug!("Creating runtime for network ID: {}", network_id);

    // Create the runtime
    let thread_name = format!(
        "network-{}",
        network_id.as_str().chars().take(3).collect::<String>()
    );
    aptos_runtimes::spawn_named_runtime(thread_name, network_config.runtime_threads)
}
```

**File:** aptos-node/src/lib.rs (L548-548)
```rust
    validator_network.runtime_threads = Some(1);
```

**File:** testsuite/smoke-test/src/network.rs (L146-159)
```rust
async fn test_rest_discovery() {
    let mut swarm = SwarmBuilder::new_local(1).with_aptos().build().await;

    // Point to an already existing node
    let (version, rest_endpoint) = {
        let validator = swarm.validators().next().unwrap();
        (validator.version(), validator.rest_api_endpoint())
    };
    let mut full_node_config = NodeConfig::get_default_pfn_config();
    let network_config = full_node_config.full_node_networks.first_mut().unwrap();
    network_config.discovery_method = DiscoveryMethod::Rest(RestDiscovery {
        url: rest_endpoint,
        interval_secs: 1,
    });
```
