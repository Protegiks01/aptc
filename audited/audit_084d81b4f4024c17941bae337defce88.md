# Audit Report

## Title
Database Inconsistency Due to Non-Atomic Truncate Operation with Panic-Based Error Handling

## Summary
The `aptos-debugger` truncate command performs a non-atomic multi-step database modification where metadata is updated first, then followed by a call to `StateStore::sync_commit_progress()` that uses panic-based error handling (`.expect()` calls). If database corruption, read failures, or data inconsistencies cause a panic during the synchronization phase, the database is left in an inconsistent state with updated metadata but un-truncated or partially-truncated data, requiring manual recovery.

## Finding Description
The vulnerability exists in the database truncation workflow executed by the `aptos-debugger` tool. The execution flow is:

1. Entry point at [1](#0-0) 

2. Command delegation through [2](#0-1) 

3. The truncate command first writes metadata atomically at [3](#0-2) 

4. Then calls `sync_commit_progress` without error handling at [4](#0-3) 

5. Inside `sync_commit_progress`, multiple `.expect()` calls will panic on errors: [5](#0-4) , [6](#0-5) , [7](#0-6) , [8](#0-7) , [9](#0-8) , and [10](#0-9) 

The issue breaks the **State Consistency** invariant: "State transitions must be atomic and verifiable via Merkle proofs." When a panic occurs:
- `OverallCommitProgress` metadata has been committed to `target_version`
- But `ledger_db`, `state_kv_db`, and `state_merkle_db` may not be truncated or only partially truncated
- The database believes it's at `target_version` but contains data beyond that version
- This creates an unrecoverable inconsistency requiring restoration from backup

## Impact Explanation
This vulnerability meets **Medium Severity** criteria per the Aptos bug bounty program: "State inconsistencies requiring intervention."

Specifically:
- The database is left in an inconsistent state where metadata and actual data disagree on the current version
- Manual intervention is required to restore from the backup checkpoint created before truncation
- Automated recovery is not possible as the database state is corrupted
- This affects operators performing database maintenance, potentially causing validator downtime during recovery

While the truncate command does create a backup beforehand [11](#0-10) , the panic leaves the operator uncertain about the exact database state, complicating recovery procedures.

## Likelihood Explanation
This vulnerability has **moderate likelihood** of occurring:

- Database corruption or I/O errors during truncation operations are realistic scenarios in production environments
- The truncate command is specifically designed for database maintenance and recovery scenarios where corruption may already exist
- The `.expect()` calls will trigger on any database read failures, write failures, or data consistency violations
- Operators running truncate on already-corrupted databases are highly likely to encounter this issue
- The issue is deterministic once error conditions are met (database corruption, disk failures, inconsistent state)

## Recommendation
Replace panic-based error handling with proper `Result<()>` return types throughout the call chain:

1. Change `StateStore::sync_commit_progress()` signature from returning `void` to `Result<()>`
2. Replace all `.expect()` calls with `?` operators to propagate errors gracefully
3. In the truncate command, handle the error from `sync_commit_progress` and provide rollback or clear error messaging
4. Consider wrapping the entire operation (metadata write + sync_commit_progress) in a transaction-like mechanism or implement a rollback strategy if sync fails

Example fix for the truncate command:

```rust
// Write metadata
let mut batch = SchemaBatch::new();
batch.put::<DbMetadataSchema>(
    &DbMetadataKey::OverallCommitProgress,
    &DbMetadataValue::Version(target_version),
)?;
ledger_db.metadata_db().write_schemas(batch)?;

// Try to sync commit progress - if it fails, rollback metadata
if let Err(e) = StateStore::sync_commit_progress_safe(
    Arc::clone(&ledger_db),
    Arc::clone(&state_kv_db),
    Arc::clone(&state_merkle_db),
    false,
) {
    // Rollback: restore previous OverallCommitProgress
    eprintln!("Failed to sync commit progress: {:?}", e);
    eprintln!("Database may be in inconsistent state. Please restore from backup.");
    return Err(e);
}
```

## Proof of Concept

**Setup**: Create a database with intentional corruption or inconsistency

**Steps to reproduce**:
1. Set up an AptosDB instance with data up to version 1000
2. Manually corrupt one of the state databases (e.g., delete some state_kv entries)
3. Run the truncate command:
   ```bash
   aptos-debugger aptos-db truncate \
     --db-dir /path/to/db \
     --target-version 500 \
     --backup-checkpoint-dir /path/to/backup \
     --enable-storage-sharding
   ```
4. Observe that the command panics during `sync_commit_progress` when it tries to read corrupted data
5. Check the database state:
   - `OverallCommitProgress` metadata = 500 (updated)
   - Actual ledger data still exists beyond version 500
   - Database cannot be used without restoration from backup

**Expected behavior**: The command should return an error gracefully without modifying metadata if sync will fail

**Actual behavior**: Command panics after metadata write, leaving database in inconsistent state

## Notes
While the tool creates a backup before truncation, the panic-based error handling obscures the exact failure point and database state, making recovery procedures more complex and error-prone than necessary. Proper error propagation would allow operators to make informed decisions about recovery strategies.

### Citations

**File:** crates/aptos-debugger/src/main.rs (L19-19)
```rust
    Cmd::parse().run().await
```

**File:** crates/aptos-debugger/src/lib.rs (L20-28)
```rust
impl Cmd {
    pub async fn run(self) -> Result<()> {
        match self {
            Cmd::AptosDb(cmd) => cmd.run().await,
            Cmd::Decode(cmd) => cmd.run().await,
            Cmd::DumpPendingTxns(cmd) => cmd.run().await,
            Cmd::Move(cmd) => cmd.run().await,
        }
    }
```

**File:** storage/aptosdb/src/db_debugger/truncate/mod.rs (L49-62)
```rust
        if !self.opt_out_backup_checkpoint {
            let backup_checkpoint_dir = self.backup_checkpoint_dir.unwrap();
            ensure!(
                !backup_checkpoint_dir.exists(),
                "Backup dir already exists."
            );
            println!("Creating backup at: {:?}", &backup_checkpoint_dir);
            fs::create_dir_all(&backup_checkpoint_dir)?;
            AptosDB::create_checkpoint(
                &self.db_dir,
                backup_checkpoint_dir,
                self.sharding_config.enable_storage_sharding,
            )?;
            println!("Done!");
```

**File:** storage/aptosdb/src/db_debugger/truncate/mod.rs (L130-135)
```rust
        let mut batch = SchemaBatch::new();
        batch.put::<DbMetadataSchema>(
            &DbMetadataKey::OverallCommitProgress,
            &DbMetadataValue::Version(target_version),
        )?;
        ledger_db.metadata_db().write_schemas(batch)?;
```

**File:** storage/aptosdb/src/db_debugger/truncate/mod.rs (L137-142)
```rust
        StateStore::sync_commit_progress(
            Arc::clone(&ledger_db),
            Arc::clone(&state_kv_db),
            Arc::clone(&state_merkle_db),
            /*crash_if_difference_is_too_large=*/ false,
        );
```

**File:** storage/aptosdb/src/state_store/mod.rs (L417-420)
```rust
        if let Some(overall_commit_progress) = ledger_metadata_db
            .get_synced_version()
            .expect("DB read failed.")
        {
```

**File:** storage/aptosdb/src/state_store/mod.rs (L425-428)
```rust
            let ledger_commit_progress = ledger_metadata_db
                .get_ledger_commit_progress()
                .expect("Failed to read ledger commit progress.");
            assert_ge!(ledger_commit_progress, overall_commit_progress);
```

**File:** storage/aptosdb/src/state_store/mod.rs (L430-436)
```rust
            let state_kv_commit_progress = state_kv_db
                .metadata_db()
                .get::<DbMetadataSchema>(&DbMetadataKey::StateKvCommitProgress)
                .expect("Failed to read state K/V commit progress.")
                .expect("State K/V commit progress cannot be None.")
                .expect_version();
            assert_ge!(state_kv_commit_progress, overall_commit_progress);
```

**File:** storage/aptosdb/src/state_store/mod.rs (L448-449)
```rust
            truncate_ledger_db(ledger_db.clone(), overall_commit_progress)
                .expect("Failed to truncate ledger db.");
```

**File:** storage/aptosdb/src/state_store/mod.rs (L461-467)
```rust
            truncate_state_kv_db(
                &state_kv_db,
                state_kv_commit_progress,
                overall_commit_progress,
                std::cmp::max(difference as usize, 1), /* batch_size */
            )
            .expect("Failed to truncate state K/V db.");
```

**File:** storage/aptosdb/src/state_store/mod.rs (L496-497)
```rust
                truncate_state_merkle_db(&state_merkle_db, state_merkle_target_version)
                    .expect("Failed to truncate state merkle db.");
```
