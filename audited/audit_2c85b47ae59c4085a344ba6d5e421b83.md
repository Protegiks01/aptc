# Audit Report

## Title
Malformed JWKs Can Be Signed and Committed On-Chain Without Validation, Breaking Keyless Authentication

## Summary
The JWK consensus system signs and commits JWK observations from external OIDC providers without validating cryptographic parameters (base64 encoding, modulus size, RSA component validity). When malformed JWKs reach consensus and are stored on-chain, all keyless authentication attempts for the affected provider/key fail, requiring emergency governance intervention.

## Finding Description

The vulnerability exists in the JWK observation-to-commitment pipeline where validators process JWKs from external OIDC providers without cryptographic validation.

**Validation Gap in JWK Parsing:**

When JWKs are parsed from JSON, the `RSA_JWK::try_from` implementation only validates that required fields (`kid`, `kty`, `alg`, `e`, `n`) exist as strings and that `kty == "RSA"`. It does NOT validate whether `n` and `e` contain valid base64-encoded data or form valid RSA components. [1](#0-0) 

**Signing Without Validation:**

In `process_new_observation()`, when validators observe new JWKs from OIDC providers, they immediately sign these JWKs with their consensus keys and initiate consensus without any cryptographic validation of the RSA parameters. [2](#0-1) 

**On-Chain Commitment Without Parameter Validation:**

The validator transaction processor validates multi-signatures and version numbers but never validates the cryptographic correctness of JWK parameters before committing them on-chain. [3](#0-2) 

**Authentication Failure at Runtime:**

When these malformed on-chain JWKs are later used for keyless authentication, the `verify_jwt_signature()` call attempts to create an RSA decoding key via `DecodingKey::from_rsa_components(&self.n, &self.e)`, which fails if the base64 encoding is invalid or the components are malformed. [4](#0-3) [5](#0-4) 

**Attack Flow:**

1. Compromised or misconfigured OIDC provider serves JWKs with invalid base64 in `n` or `e` fields
2. Multiple validators independently fetch these malformed JWKs via `JWKObserver`
3. Each validator signs the observation without validation
4. Consensus is reached as validators observe identical malformed data
5. Malformed JWKs are committed on-chain via validator transaction
6. All subsequent keyless authentication attempts fail with signature verification errors

This breaks the **Input Validation** security guarantee by allowing untrusted external data to be consensus-certified and stored without cryptographic correctness validation.

## Impact Explanation

**HIGH Severity** per Aptos bug bounty criteria:

**Availability Impact:** All users with keyless accounts using the affected OIDC provider and key ID cannot authenticate or submit transactions. The authentication path fails at RSA signature verification, returning `invalid_signature!("RSA signature verification failed for OpenIdSig")`.

**Scope:** Major providers (Google, Apple, Facebook) could be affected during key rotation misconfigurations. Thousands of keyless accounts could become simultaneously inaccessible.

**Recovery Complexity:** Requires emergency governance action to patch on-chain JWKs using the `Patches` mechanism, involving validator coordination and governance approval delays.

This qualifies as **"Significant protocol violations"** under High Severity classification, as it completely breaks a critical authentication mechanism for an entire user population segment.

## Likelihood Explanation

**Medium to High Likelihood:**

- OIDC providers occasionally misconfigure JWK endpoints during key rotations or infrastructure changes
- External dependencies on third-party OIDC providers introduce inherent risk
- No validation exists to prevent malformed data from reaching consensus
- Attack requires no special privileges - only a compromised/misconfigured OIDC provider
- Multiple independent validators naturally reach consensus on the same malformed data from the provider
- The vulnerability is deterministic: malformed JWKs will always break authentication

## Recommendation

Add cryptographic validation before signing JWK observations:

```rust
pub fn process_new_observation(
    &mut self,
    issuer: Issuer,
    jwks: Vec<JWKMoveStruct>,
) -> Result<()> {
    // Validate JWK cryptographic parameters before signing
    for jwk in &jwks {
        if let Ok(JWK::RSA(rsa_jwk)) = JWK::try_from(jwk) {
            // Validate base64 encoding
            base64::decode_config(&rsa_jwk.n, URL_SAFE_NO_PAD)
                .context("Invalid base64 in modulus")?;
            base64::decode_config(&rsa_jwk.e, URL_SAFE_NO_PAD)
                .context("Invalid base64 in exponent")?;
            
            // Validate RSA components can form a valid decoding key
            DecodingKey::from_rsa_components(&rsa_jwk.n, &rsa_jwk.e)
                .context("Invalid RSA components")?;
            
            // Optionally validate modulus size for ZK circuit compatibility
            let modulus = base64::decode_config(&rsa_jwk.n, URL_SAFE_NO_PAD)?;
            ensure!(
                modulus.len() == RSA_JWK::RSA_MODULUS_BYTES,
                "Modulus size must be {} bytes", RSA_JWK::RSA_MODULUS_BYTES
            );
        }
    }
    
    // Existing signing logic...
    let state = self.states_by_issuer.entry(issuer.clone()).or_default();
    state.observed = Some(jwks.clone());
    // ... rest of function
}
```

## Proof of Concept

```rust
#[test]
fn test_malformed_jwk_consensus() {
    // Create a malformed JWK with invalid base64 in modulus
    let malformed_jwk = serde_json::json!({
        "kid": "test-key",
        "kty": "RSA",
        "alg": "RS256",
        "e": "AQAB",
        "n": "invalid-base64-!!!!" // Invalid base64
    });
    
    // This will successfully parse (no validation)
    let rsa_jwk = RSA_JWK::try_from(&malformed_jwk).unwrap();
    assert_eq!(rsa_jwk.n, "invalid-base64-!!!!");
    
    // But will fail at authentication time
    let result = DecodingKey::from_rsa_components(&rsa_jwk.n, &rsa_jwk.e);
    assert!(result.is_err(), "Should fail with invalid base64");
    
    // Simulating the process_new_observation flow:
    // 1. Malformed JWK parses successfully
    // 2. Gets signed by validator (no validation)
    // 3. Reaches consensus among validators
    // 4. Gets committed on-chain
    // 5. Breaks all authentication attempts
}
```

## Notes

This vulnerability demonstrates a classic input validation failure where external untrusted data (OIDC provider JWKs) is consensus-signed and committed without verifying cryptographic correctness. The root cause is the separation between parsing validation (field presence) and cryptographic validation (parameter correctness), with only the former being performed before consensus.

The pepper service in `keyless/pepper/service/src/external_resources/jwk_fetcher.rs` does perform additional validation (filtering for `e == "AQAB"`), but this is separate from the validator consensus path and does not prevent malformed JWKs from being committed on-chain by validators.

### Citations

**File:** types/src/jwks/rsa/mod.rs (L89-95)
```rust
    pub fn verify_signature_without_exp_check(&self, jwt_token: &str) -> Result<TokenData<Claims>> {
        let mut validation = Validation::new(Algorithm::RS256);
        validation.validate_exp = false;
        let key = &DecodingKey::from_rsa_components(&self.n, &self.e)?;
        let claims = jsonwebtoken::decode::<Claims>(jwt_token, key, &validation)?;
        Ok(claims)
    }
```

**File:** types/src/jwks/rsa/mod.rs (L132-178)
```rust
impl TryFrom<&serde_json::Value> for RSA_JWK {
    type Error = anyhow::Error;

    fn try_from(json_value: &serde_json::Value) -> Result<Self, Self::Error> {
        let kty = json_value
            .get("kty")
            .ok_or_else(|| anyhow!("Field `kty` not found"))?
            .as_str()
            .ok_or_else(|| anyhow!("Field `kty` is not a string"))?
            .to_string();

        ensure!(
            kty.as_str() == "RSA",
            "json to rsa jwk conversion failed with incorrect kty"
        );

        let ret = Self {
            kty,
            kid: json_value
                .get("kid")
                .ok_or_else(|| anyhow!("Field `kid` not found"))?
                .as_str()
                .ok_or_else(|| anyhow!("Field `kid` is not a string"))?
                .to_string(),
            alg: json_value
                .get("alg")
                .ok_or_else(|| anyhow!("Field `alg` not found"))?
                .as_str()
                .ok_or_else(|| anyhow!("Field `alg` is not a string"))?
                .to_string(),
            e: json_value
                .get("e")
                .ok_or_else(|| anyhow!("Field `e` not found"))?
                .as_str()
                .ok_or_else(|| anyhow!("Field `e` is not a string"))?
                .to_string(),
            n: json_value
                .get("n")
                .ok_or_else(|| anyhow!("Field `n` not found"))?
                .as_str()
                .ok_or_else(|| anyhow!("Field `n` is not a string"))?
                .to_string(),
        };

        Ok(ret)
    }
}
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager/mod.rs (L184-228)
```rust
    pub fn process_new_observation(
        &mut self,
        issuer: Issuer,
        jwks: Vec<JWKMoveStruct>,
    ) -> Result<()> {
        debug!(
            epoch = self.epoch_state.epoch,
            issuer = String::from_utf8(issuer.clone()).ok(),
            "Processing new observation."
        );
        let state = self.states_by_issuer.entry(issuer.clone()).or_default();
        state.observed = Some(jwks.clone());
        if state.observed.as_ref() != state.on_chain.as_ref().map(ProviderJWKs::jwks) {
            let observed = ProviderJWKs {
                issuer: issuer.clone(),
                version: state.on_chain_version() + 1,
                jwks,
            };
            let signature = self
                .consensus_key
                .sign(&observed)
                .context("process_new_observation failed with signing error")?;
            let abort_handle = self
                .update_certifier
                .start_produce(
                    self.epoch_state.clone(),
                    observed.clone(),
                    self.qc_update_tx.clone(),
                )
                .context(
                    "process_new_observation failed with update_certifier.start_produce failure",
                )?;
            state.consensus_state = ConsensusState::InProgress {
                my_proposal: ObservedUpdate {
                    author: self.my_addr,
                    observed: observed.clone(),
                    signature,
                },
                abort_handle_wrapper: QuorumCertProcessGuard::new(abort_handle),
            };
            info!("[JWK] update observed, update={:?}", observed);
        }

        Ok(())
    }
```

**File:** aptos-move/aptos-vm/src/validator_txns/jwk.rs (L100-179)
```rust
    fn process_jwk_update_inner(
        &self,
        resolver: &impl AptosMoveResolver,
        module_storage: &impl AptosModuleStorage,
        log_context: &AdapterLogSchema,
        session_id: SessionId,
        update: jwks::QuorumCertifiedUpdate,
    ) -> Result<(VMStatus, VMOutput), ExecutionFailure> {
        // Load resources.
        let validator_set =
            ValidatorSet::fetch_config(resolver).ok_or(Expected(MissingResourceValidatorSet))?;
        let observed_jwks =
            ObservedJWKs::fetch_config(resolver).ok_or(Expected(MissingResourceObservedJWKs))?;

        let mut jwks_by_issuer: HashMap<Issuer, ProviderJWKs> =
            observed_jwks.into_providers_jwks().into();
        let issuer = update.update.issuer.clone();
        let on_chain = jwks_by_issuer
            .entry(issuer.clone())
            .or_insert_with(|| ProviderJWKs::new(issuer));
        let verifier = ValidatorVerifier::from(&validator_set);

        let QuorumCertifiedUpdate {
            update: observed,
            multi_sig,
        } = update;

        // Check version.
        if on_chain.version + 1 != observed.version {
            return Err(Expected(IncorrectVersion));
        }

        let authors = multi_sig.get_signers_addresses(&verifier.get_ordered_account_addresses());

        // Check voting power.
        verifier
            .check_voting_power(authors.iter(), true)
            .map_err(|_| Expected(NotEnoughVotingPower))?;

        // Verify multi-sig.
        verifier
            .verify_multi_signatures(&observed, &multi_sig)
            .map_err(|_| Expected(MultiSigVerificationFailed))?;

        // All verification passed. Apply the `observed`.
        let mut gas_meter = UnmeteredGasMeter;
        let mut session = self.new_session(resolver, session_id, None);
        let args = vec![
            MoveValue::Signer(AccountAddress::ONE),
            vec![observed].as_move_value(),
        ];

        let traversal_storage = TraversalStorage::new();
        session
            .execute_function_bypass_visibility(
                &JWKS_MODULE,
                UPSERT_INTO_OBSERVED_JWKS,
                vec![],
                serialize_values(&args),
                &mut gas_meter,
                &mut TraversalContext::new(&traversal_storage),
                module_storage,
            )
            .map_err(|e| {
                expect_only_successful_execution(e, UPSERT_INTO_OBSERVED_JWKS.as_str(), log_context)
            })
            .map_err(|r| Unexpected(r.unwrap_err()))?;

        let output = get_system_transaction_output(
            session,
            module_storage,
            &self
                .storage_gas_params(log_context)
                .map_err(Unexpected)?
                .change_set_configs,
        )
        .map_err(Unexpected)?;

        Ok((VMStatus::Executed, output))
    }
```

**File:** aptos-move/aptos-vm/src/keyless_validation.rs (L368-399)
```rust
        EphemeralCertificate::OpenIdSig(openid_sig) => {
            match jwk {
                JWK::RSA(rsa_jwk) => {
                    openid_sig
                        .verify_jwt_claims(
                            signature.exp_date_secs,
                            &signature.ephemeral_pubkey,
                            public_key.inner_keyless_pk(),
                            config,
                        )
                        .map_err(|_| invalid_signature!("OpenID claim verification failed"))?;

                    // TODO(OpenIdSig): Implement batch verification for all RSA signatures in
                    //  one TXN.
                    // Note: Individual OpenID RSA signature verification will be fast when the
                    // RSA public exponent is small (e.g., 65537). For the same TXN, batch
                    // verification of all RSA signatures will be even faster even when the
                    // exponent is the same. Across different TXNs, batch verification will be
                    // (1) more difficult to implement and (2) not very beneficial since, when
                    // it fails, bad signature identification will require re-verifying all
                    // signatures assuming an adversarial batch.
                    //
                    // We are now ready to verify the RSA signature
                    openid_sig
                        .verify_jwt_signature(rsa_jwk, &signature.jwt_header_json)
                        .map_err(|_| {
                            invalid_signature!("RSA signature verification failed for OpenIdSig")
                        })?;
                },
                JWK::Unsupported(_) => return Err(invalid_signature!("JWK is not supported")),
            }
        },
```
