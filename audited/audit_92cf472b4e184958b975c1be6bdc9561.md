# Audit Report

## Title
Symlink Attack Vulnerability in Move Package Dependency Resolution Allows Malicious Code Inclusion

## Summary
The `add_local_dep()` function and the Move.toml dependency parser do not validate whether local dependency paths are symbolic links. This allows attackers to include arbitrary code from outside the intended project directory during compilation, potentially leading to the deployment of backdoored Move modules that could steal user funds.

## Finding Description

The vulnerability exists in two related locations in the Aptos Move package system:

**Location 1:** The `add_local_dep()` function accepts a path parameter without any symlink validation: [1](#0-0) 

The path is stored directly and later written to Move.toml without validation: [2](#0-1) 

**Location 2:** When parsing Move.toml dependencies, the local path is converted to a PathBuf without symlink validation: [3](#0-2) 

**Location 3:** During dependency resolution, the path is used directly to read the package manifest and source files: [4](#0-3) 

The path is then used to locate source files for compilation: [5](#0-4) 

**Attack Scenario:**

1. Attacker creates a malicious Move project repository
2. Creates a symbolic link named `malicious_dep` pointing to either:
   - A directory containing backdoored Move code (also in the repo)
   - A sensitive directory on the victim's system (e.g., `~/.move/packages/private_modules`)
3. In Move.toml, declares: `MaliciousDep = { local = "malicious_dep" }`
4. Commits the repository with the symlink (Git preserves symlinks)
5. Victim clones the repository and runs `aptos move compile` or `aptos move build`
6. The compiler follows the symlink and includes code from outside the intended project
7. If deployed to the blockchain, the malicious code executes with the deployer's authority

This breaks the **Access Control** invariant by allowing inclusion of code from outside the intended package boundaries, and the **Deterministic Execution** invariant as different systems with different symlink targets would compile different bytecode from the same source repository.

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos bug bounty program for the following reasons:

1. **Significant Protocol Violation**: Allows circumvention of package isolation and access controls in the Move build system
2. **Potential for Fund Loss**: Malicious Move modules compiled via this attack could be deployed to the blockchain and steal user funds through backdoored logic
3. **Supply Chain Attack Vector**: Enables sophisticated attacks where seemingly legitimate Move libraries contain hidden malicious dependencies via symlinks

While this is primarily a build-time vulnerability rather than a runtime blockchain protocol issue, it directly impacts the security of Move module deployment, which is a critical part of the Aptos ecosystem. A compromised module deployed through this attack vector would execute on-chain with full authority, potentially leading to **Critical** severity impacts (fund theft).

## Likelihood Explanation

The likelihood is **Medium to High**:

**Factors increasing likelihood:**
- Git repositories preserve symbolic links by default
- Developers routinely add third-party Move libraries as dependencies
- The attack is silent and difficult to detect without manual inspection
- Automated CI/CD pipelines may not flag suspicious symlinks
- No warnings or validation errors occur during compilation

**Factors decreasing likelihood:**
- Requires victim to clone and compile a malicious repository
- Developers may notice unusual symlinks during code review
- Modern development tools may show symlinks in diff views
- Requires attacker to successfully distribute malicious package

## Recommendation

Implement symlink validation in the Move package dependency resolution system:

```rust
// In manifest_parser.rs, modify parse_dependency():
(Some(local), None, None) => {
    let local_str = local
        .as_str()
        .ok_or_else(|| format_err!("Local source path not a string"))?;
    let local_path = PathBuf::from(local_str);
    
    // Validate that the path is not a symbolic link
    if local_path.is_symlink() {
        bail!(
            "Local dependency path '{}' is a symbolic link. \
            Symbolic links are not allowed for security reasons. \
            Please use a direct path instead.",
            local_str
        );
    }
    
    Ok(PM::Dependency {
        subst,
        version,
        digest,
        local: local_path,
        git_info,
        node_info,
    })
},
```

Similarly, add validation in `PackageBuilder::add_local_dep()`:

```rust
pub fn add_local_dep(&mut self, name: &str, path: &str) -> Result<()> {
    let path_buf = PathBuf::from(path);
    
    // Validate that the path is not a symbolic link
    if path_buf.exists() && path_buf.is_symlink() {
        bail!(
            "Dependency path '{}' is a symbolic link. \
            Symbolic links are not allowed for security reasons.",
            path
        );
    }
    
    self.deps.push((name.to_string(), path.to_string()));
    Ok(())
}
```

Additionally, consider validating the canonical path to ensure it doesn't escape expected boundaries.

## Proof of Concept

```rust
// Create a test that demonstrates the symlink vulnerability
#[test]
fn test_symlink_dependency_attack() {
    use std::fs;
    use std::os::unix::fs::symlink;
    use tempfile::tempdir;
    
    // Create victim's private package
    let private_dir = tempdir().unwrap();
    let private_pkg_path = private_dir.path().join("private_package");
    fs::create_dir_all(&private_pkg_path).unwrap();
    
    // Create Move.toml for private package
    fs::write(
        private_pkg_path.join("Move.toml"),
        r#"
[package]
name = "PrivatePackage"
version = "0.0.0"
        "#
    ).unwrap();
    
    // Create private source directory with sensitive code
    let private_sources = private_pkg_path.join("sources");
    fs::create_dir_all(&private_sources).unwrap();
    fs::write(
        private_sources.join("sensitive.move"),
        "module 0x1::sensitive { public fun steal_funds() {} }"
    ).unwrap();
    
    // Create attacker's malicious package
    let malicious_dir = tempdir().unwrap();
    let malicious_pkg_path = malicious_dir.path();
    
    // Create symlink to victim's private package
    let symlink_path = malicious_pkg_path.join("evil_dep");
    symlink(&private_pkg_path, &symlink_path).unwrap();
    
    // Create malicious package using PackageBuilder
    let mut builder = PackageBuilder::new("MaliciousPackage");
    
    // This should fail with symlink validation, but currently succeeds
    builder.add_local_dep("PrivatePackage", symlink_path.to_str().unwrap());
    builder.add_source("main.move", "script { fun main() {} }");
    
    // Write to disk - the symlink is followed without validation
    let result = builder.write_to_disk(malicious_pkg_path);
    
    // Currently this succeeds - it should fail with symlink validation error
    assert!(result.is_ok()); // This demonstrates the vulnerability
    
    // Verify the Move.toml contains the symlink reference
    let move_toml = fs::read_to_string(malicious_pkg_path.join("Move.toml")).unwrap();
    assert!(move_toml.contains("PrivatePackage"));
    
    // When this package is compiled, it will include code from the private package
    // without the developer's knowledge or consent
}
```

## Notes

This vulnerability affects both the `PackageBuilder` API and the general Move.toml dependency parsing system. While `PackageBuilder` is described as a testing helper, the same vulnerability exists in the production dependency resolution code used for all Move package compilation. The attack is particularly dangerous because:

1. Git repositories preserve symlinks, making this a viable supply chain attack vector
2. The compilation process provides no warnings about following symlinks
3. The included code becomes part of the compiled package and would execute on-chain if deployed

The vulnerability should be fixed in both locations to ensure complete protection.

### Citations

**File:** aptos-move/package-builder/src/lib.rs (L36-38)
```rust
    pub fn add_local_dep(&mut self, name: &str, path: &str) {
        self.deps.push((name.to_string(), path.to_string()))
    }
```

**File:** aptos-move/package-builder/src/lib.rs (L71-74)
```rust
                self.deps
                    .into_iter()
                    .map(|(name, dep_path)| format!("{} = {{ local = \"{}\" }}", name, dep_path))
                    .join("\n")
```

**File:** third_party/move/tools/move-package/src/source_package/manifest_parser.rs (L342-355)
```rust
                (Some(local), None, None) => {
                    let local_str = local
                        .as_str()
                        .ok_or_else(|| format_err!("Local source path not a string"))?;
                    let local_path = PathBuf::from(local_str);
                    Ok(PM::Dependency {
                        subst,
                        version,
                        digest,
                        local: local_path,
                        git_info,
                        node_info,
                    })
                },
```

**File:** third_party/move/tools/move-package/src/resolution/resolution_graph.rs (L499-517)
```rust
    fn parse_package_manifest(
        dep: &Dependency,
        dep_name: &PackageName,
        mut root_path: PathBuf,
    ) -> Result<(SourceManifest, PathBuf)> {
        root_path.push(&dep.local);
        match fs::read_to_string(root_path.join(SourcePackageLayout::Manifest.path())) {
            Ok(contents) => {
                let source_package: SourceManifest =
                    parse_move_manifest_string(contents).and_then(parse_source_manifest)?;
                Ok((source_package, root_path))
            },
            Err(_) => Err(anyhow::format_err!(
                "Unable to find package manifest for '{}' at {:?}",
                dep_name,
                SourcePackageLayout::Manifest.path().join(root_path),
            )),
        }
    }
```

**File:** third_party/move/tools/move-package/src/resolution/resolution_graph.rs (L758-768)
```rust
    pub fn get_sources(&self, config: &BuildConfig) -> Result<Vec<FileName>> {
        let places_to_look =
            ResolvingPackage::get_source_paths_for_config(&self.package_path, config)?
                .into_iter()
                .map(|p| p.to_string_lossy().to_string())
                .collect::<Vec<_>>();
        Ok(find_move_filenames(&places_to_look, false)?
            .into_iter()
            .map(Symbol::from)
            .collect())
    }
```
