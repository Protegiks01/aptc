# Audit Report

## Title
Chain ID Spoofing in Indexer-GRPC-Data-Service-V2: Missing Chain ID Validation Allows Serving Wrong-Chain Data

## Summary
The indexer-grpc-data-service-v2 does not validate the `chain_id` field from upstream data sources (GrpcManager responses and file store) against its configured `chain_id`. This allows misconfigured or malicious services to fetch data from one blockchain (e.g., testnet) while claiming to serve data from another (e.g., mainnet), corrupting all downstream indexers and applications.

## Finding Description

The vulnerability exists in two critical data paths:

**Path 1: LiveDataService (Critical)**

The `LiveDataService` fetches blockchain transactions from a GrpcManager through the `DataClient`. When the GrpcManager returns a `TransactionsResponse`, this response includes a `chain_id` field as defined in the protobuf schema: [1](#0-0) 

However, the `DataClient.fetch_transactions()` method completely ignores this `chain_id` field and only extracts the transactions: [2](#0-1) 

The `LiveDataService` then constructs its own `TransactionsResponse` using the configured `chain_id` from its config, completely overwriting any chain information from the actual data source: [3](#0-2) 

**Path 2: HistoricalDataService (Same Pattern)**

The `HistoricalDataService` exhibits the same vulnerability pattern, constructing responses with the configured `chain_id` without validating the actual chain of the source data: [4](#0-3) 

**Root Cause in Configuration**

The `chain_id` is read from the configuration file and passed directly to services without any validation against blockchain state: [5](#0-4) 

The `ConnectionManager` stores this `chain_id` and includes it in heartbeat messages, but never validates it against the actual blockchain: [6](#0-5) 

**Attack Scenario:**

1. Service operator configures `indexer-grpc-data-service-v2` with `chain_id: 1` (mainnet) in config
2. Operator mistakenly or maliciously configures `grpc_manager_addresses` to point to a testnet GrpcManager
3. Service fetches testnet transactions (chain_id=2) from GrpcManager
4. Service ignores the `chain_id: 2` in the response and overwrites it with configured `chain_id: 1`
5. All clients consuming this service receive testnet data labeled as mainnet data
6. Downstream indexers store incorrect chain data, breaking all applications

**Comparison with V1 (Regression)**

The older `indexer-grpc-data-service` (v1) properly validates chain_id by comparing file store metadata against Redis cache: [7](#0-6) 

This validation was removed in v2, introducing a security regression.

## Impact Explanation

This vulnerability qualifies as **Medium to High severity** under the Aptos bug bounty program:

**Medium Severity Impacts:**
- **State inconsistencies requiring intervention**: All indexers consuming misconfigured services will have corrupted data requiring full re-indexing
- **Data integrity violation**: Applications relying on this data for balance queries, NFT ownership, transaction history will have incorrect information

**Potential High Severity Escalation:**
- If widely-used indexer infrastructure is misconfigured, it could affect major DeFi protocols, wallets, and exchanges
- Financial losses for applications making decisions based on corrupted data (e.g., wrong token balances, fake transaction confirmations)
- Ecosystem reputation damage if mainnet services inadvertently serve testnet data

**Not Critical Severity because:**
- Does not directly affect consensus nodes or validator operations
- Does not enable on-chain fund theft or manipulation
- Does not compromise blockchain state itself
- Can be detected and remediated by re-deploying with correct configuration

## Likelihood Explanation

**Likelihood: Medium-High**

**Factors Increasing Likelihood:**
1. **Easy Misconfiguration**: Simple environment variable mistake or copy-paste error in deployment scripts
2. **Silent Failure**: No runtime validation means the issue persists undetected until data inconsistencies are noticed
3. **Regression from V1**: The removal of validation in v2 suggests this protection was not considered critical
4. **Multiple Deployment Environments**: Services often have mainnet, testnet, devnet configurations that can be accidentally mixed

**Factors Decreasing Likelihood:**
1. **Requires Deployment Access**: Attacker needs ability to deploy/configure the service
2. **Eventually Detectable**: Data inconsistencies would be noticed by applications comparing multiple indexer sources
3. **Not Exploitable Remotely**: Requires configuration file access or deployment privileges

**Real-World Scenarios:**
- DevOps engineer copies mainnet config but forgets to update GrpcManager endpoint
- Staging environment accidentally pointed to production service with wrong chain config
- Malicious infrastructure provider deploys fake data service to deceive applications

## Recommendation

**Immediate Fix: Add Chain ID Validation**

Add validation in `DataClient.fetch_transactions()` to verify the response chain_id matches the expected chain_id:

```rust
pub(super) async fn fetch_transactions(&self, starting_version: u64) -> Vec<Transaction> {
    let expected_chain_id = self.connection_manager.chain_id();
    
    loop {
        let mut client = self.connection_manager.get_grpc_manager_client_for_request();
        let response = client.get_transactions(request.clone()).await;
        
        if let Ok(response) = response {
            let response_inner = response.into_inner();
            
            // VALIDATION: Verify chain_id matches
            if let Some(chain_id) = response_inner.chain_id {
                if chain_id != expected_chain_id {
                    error!(
                        "Chain ID mismatch: expected {}, got {}. Refusing to serve data.",
                        expected_chain_id, chain_id
                    );
                    // Continue loop to retry or implement exponential backoff
                    tokio::time::sleep(Duration::from_secs(5)).await;
                    continue;
                }
            } else {
                warn!("Response missing chain_id field");
            }
            
            let transactions = response_inner.transactions;
            if transactions.is_empty() {
                return vec![];
            }
            if transactions.first().unwrap().version == starting_version {
                return transactions;
            }
        }
    }
}
```

**Additional Hardening:**

1. **Add startup validation** in `ConnectionManager::new()` to verify chain_id from first heartbeat response
2. **Add periodic validation** in `ConnectionManager.heartbeat()` to continuously verify chain_id
3. **Add configuration validation** to prevent obviously wrong combinations (e.g., mainnet chain_id with testnet endpoint)
4. **Add metrics/alerts** when chain_id mismatches are detected

## Proof of Concept

**Integration Test (Rust):**

```rust
#[tokio::test]
async fn test_chain_id_mismatch_detection() {
    // Setup: Create mock GrpcManager returning testnet data (chain_id=2)
    let mock_grpc_manager = create_mock_grpc_manager_with_chain_id(2);
    
    // Configure data service v2 claiming to serve mainnet (chain_id=1)
    let config = IndexerGrpcDataServiceConfig {
        chain_id: 1, // Mainnet
        grpc_manager_addresses: vec![mock_grpc_manager.address()],
        // ... other config
    };
    
    // Start the service
    let service = create_live_data_service(config).await;
    
    // Client requests transactions
    let request = GetTransactionsRequest {
        starting_version: Some(0),
        transactions_count: Some(10),
        ..Default::default()
    };
    
    // Expected behavior: Service should detect chain_id mismatch
    // Current behavior: Service serves testnet data labeled as mainnet
    let mut stream = service.get_transactions(request).await.unwrap();
    
    if let Some(Ok(response)) = stream.next().await {
        // BUG: Response will have chain_id=1 (mainnet) but contain testnet data
        assert_eq!(response.chain_id, Some(1)); // Passes incorrectly
        
        // Verify the actual transaction data is from testnet
        // (would require access to known testnet transaction data)
        // This demonstrates the spoofing vulnerability
    }
}
```

**Configuration Demonstration:**

```yaml
# Vulnerable configuration file
# config.yaml
chain_id: 1  # Claiming mainnet
service_config:
  listen_address: "0.0.0.0:50051"
live_data_service_config:
  enabled: true
grpc_manager_addresses:
  - "https://testnet-grpc-manager.example.com"  # WRONG! Points to testnet
self_advertised_address: "mainnet-indexer.example.com"  # Claims mainnet
```

The service will start successfully and serve testnet data with mainnet chain_id, with no validation error.

**Notes**

While this vulnerability affects the indexer infrastructure rather than core consensus, it represents a critical data integrity issue for the Aptos ecosystem. The removal of chain_id validation from v1 to v2 is a security regression that must be addressed. Applications and indexers relying on these data services have no way to detect they are receiving wrong-chain data, as the chain_id field is forged to match expectations.

This issue is particularly concerning because:
1. It's a silent failure mode with no error logs
2. The v1 service had proper validation that was removed
3. The proto schema includes chain_id specifically for validation purposes, but v2 ignores it
4. Downstream corruption affects the entire application ecosystem

### Citations

**File:** protos/proto/aptos/indexer/v1/raw_data.proto (L40-49)
```text
// TransactionsResponse is a batch of transactions.
message TransactionsResponse {
  // Required; transactions data.
  repeated aptos.transaction.v1.Transaction transactions = 1;

  // Required; chain id.
  optional uint64 chain_id = 2 [jstype = JS_STRING];

  optional ProcessedRange processed_range = 3;
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/data_client.rs (L31-39)
```rust
            let response = client.get_transactions(request.clone()).await;
            if let Ok(response) = response {
                let transactions = response.into_inner().transactions;
                if transactions.is_empty() {
                    return vec![];
                }
                if transactions.first().unwrap().version == starting_version {
                    return transactions;
                }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/mod.rs (L199-206)
```rust
                let response = TransactionsResponse {
                    transactions,
                    chain_id: Some(self.chain_id),
                    processed_range: Some(ProcessedRange {
                        first_version: next_version,
                        last_version: last_processed_version,
                    }),
                };
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/historical_data_service.rs (L210-217)
```rust
                            TransactionsResponse {
                                transactions: chunk.to_vec(),
                                chain_id: Some(self.chain_id),
                                processed_range: Some(ProcessedRange {
                                    first_version,
                                    last_version,
                                }),
                            }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/config.rs (L114-122)
```rust
        let connection_manager = Arc::new(
            ConnectionManager::new(
                self.chain_id,
                self.grpc_manager_addresses.clone(),
                self.self_advertised_address.clone(),
                /*is_live_data_service=*/ true,
            )
            .await,
        );
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/connection_manager.rs (L111-129)
```rust
    pub(crate) async fn new(
        chain_id: u64,
        grpc_manager_addresses: Vec<String>,
        self_advertised_address: String,
        is_live_data_service: bool,
    ) -> Self {
        let grpc_manager_connections = DashMap::new();
        grpc_manager_addresses.into_iter().for_each(|address| {
            grpc_manager_connections
                .insert(address.clone(), Self::create_client_from_address(&address));
        });
        let res = Self {
            chain_id,
            grpc_manager_connections,
            self_advertised_address,
            known_latest_version: AtomicU64::new(0),
            active_streams: DashMap::new(),
            is_live_data_service,
        };
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service/src/service.rs (L414-463)
```rust
    // Validate chain id
    let mut metadata = file_store_operator.get_file_store_metadata().await;
    while metadata.is_none() {
        metadata = file_store_operator.get_file_store_metadata().await;
        tracing::warn!(
            "[File worker] File store metadata not found. Waiting for {} ms.",
            FILE_STORE_METADATA_WAIT_MS
        );
        tokio::time::sleep(std::time::Duration::from_millis(
            FILE_STORE_METADATA_WAIT_MS,
        ))
        .await;
    }

    let metadata_chain_id = metadata.unwrap().chain_id;

    // Validate redis chain id. Must be present by the time it gets here
    let chain_id = match cache_operator.get_chain_id().await {
        Ok(chain_id) => chain_id.unwrap(),
        Err(e) => {
            ERROR_COUNT
                .with_label_values(&["redis_get_chain_id_failed"])
                .inc();
            // Connection will be dropped anyway, so we ignore the error here.
            let _result = tx
                .send_timeout(
                    Err(Status::unavailable(
                        "[Data Service] Cannot get the chain id from redis; please retry.",
                    )),
                    RESPONSE_CHANNEL_SEND_TIMEOUT,
                )
                .await;
            error!(
                error = e.to_string(),
                "[Data Service] Failed to get chain id from redis."
            );
            return;
        },
    };

    if metadata_chain_id != chain_id {
        let _result = tx
            .send_timeout(
                Err(Status::unavailable("[Data Service] Chain ID mismatch.")),
                RESPONSE_CHANNEL_SEND_TIMEOUT,
            )
            .await;
        error!("[Data Service] Chain ID mismatch.",);
        return;
    }
```
