# Audit Report

## Title
Private Key Exposure via Non-Atomic Write and Permission Race Condition in save_to_file_confidential()

## Summary
The `SaveFile::save_to_file_confidential()` function in the Aptos CLI contains multiple critical flaws that can expose private key material in a world-readable state. The function fails to implement atomic writes, does not update permissions on existing files, and provides no permission protection on Windows platforms.

## Finding Description

The vulnerability exists in the implementation of confidential file saving used for private key storage. [1](#0-0) 

This function calls `write_to_file_with_opts()` which performs a non-atomic write operation: [2](#0-1) 

**Vulnerability #1: Permission Race Condition on Existing Files**

The `.mode(0o600)` setting in `OpenOptions` only applies when a file is **created**, not when it is opened for writing. According to POSIX semantics, if a file already exists, `open()` with `O_CREAT` preserves the existing file permissions and ignores the mode parameter. This means:

1. If `private.key` already exists with permissions `0o644` (world-readable)
2. User runs `aptos key generate --output-file private.key --assume-yes`
3. The file is opened with existing `0o644` permissions (mode setting ignored)
4. File is truncated to 0 bytes via `.truncate(true)`
5. `write_all()` begins writing the private key
6. If write fails (disk full, I/O error, process killed), partial private key bytes remain on disk
7. The partial data is **world-readable** due to the preserved `0o644` permissions

The function is used to save Ed25519 and BLS12381 private keys: [3](#0-2) 

**Vulnerability #2: No Permission Protection on Windows**

The `#[cfg(unix)]` conditional compilation means the `.mode(0o600)` line does not exist on Windows builds. On Windows, all private key files are created with default permissions, which may allow other local users to read them.

**Vulnerability #3: Non-Atomic Write Operation**

The implementation uses direct file writes instead of the atomic write pattern (write to temporary file → sync → atomic rename). If `write_all()` is interrupted at any point, partial private key data remains on disk with no recovery mechanism.

**Vulnerability #4: Truncate-Before-Write Pattern**

The `.truncate(true)` option truncates the file to 0 bytes before writing begins. This ensures that if the write fails, there is no way to recover the previous key, and partial new key data is left exposed.

## Impact Explanation

This qualifies as **Medium Severity** under the Aptos bug bounty criteria:

- **Limited funds loss or manipulation**: Compromised private keys enable account takeover and theft of funds from the affected account
- **State inconsistencies requiring intervention**: Exposed validator keys could require emergency key rotation and network intervention
- **Information disclosure**: Private key material (cryptographic secrets) exposed to unauthorized local users

While this doesn't directly affect consensus or on-chain state, it breaks the fundamental security guarantee that private keys remain confidential. An attacker who obtains even partial private key data may be able to:
- Perform cryptanalytic attacks to recover the full key
- Gain information about the key generation entropy
- In worst case with sufficient bytes written, directly reconstruct the private key

This breaks the **Cryptographic Correctness** invariant: "BLS signatures, VRF, and hash operations must be secure" - the security of these operations depends on private key confidentiality.

## Likelihood Explanation

This vulnerability has **HIGH likelihood** of occurrence in real-world deployments:

**Common Scenario 1: File Created by User First**
```bash
# User accidentally creates file before running CLI
touch private.key  # Created with umask, may be 0o644
aptos key generate --output-file private.key --assume-yes
# Process killed (Ctrl+C, disk full, etc.)
# Result: Partial key data world-readable
```

**Common Scenario 2: Previous Buggy Version**
If a previous version of the CLI or another tool created the file with incorrect permissions, regenerating the key preserves the insecure permissions.

**Common Scenario 3: Windows Deployment**
On Windows, ALL private keys are created with potentially insecure default permissions since there is no permission protection.

**Common Scenario 4: Disk Space Issues**
If the disk fills during key generation (common on validator nodes with limited storage), `write_all()` fails mid-write, leaving partial key data.

The check performed before writing only prompts for overwrite, it does not verify or fix file permissions: [4](#0-3) 

## Recommendation

Implement atomic writes with proper permission handling:

```rust
pub fn save_to_file_confidential(&self, name: &str, bytes: &[u8]) -> CliTypedResult<()> {
    use std::fs;
    
    // Create temporary file in same directory as target (ensures same filesystem)
    let temp_path = self.output_file.with_extension("tmp");
    
    // Set restrictive permissions BEFORE writing any data
    let mut opts = OpenOptions::new();
    opts.write(true).create_new(true);  // Fail if temp file exists
    
    #[cfg(unix)]
    opts.mode(0o600);
    
    // Open temp file with secure permissions
    let mut temp_file = opts
        .open(&temp_path)
        .map_err(|e| CliError::IO(name.to_string(), e))?;
    
    // Write all data to temp file
    temp_file.write_all(bytes)
        .map_err(|e| {
            // Clean up temp file on write failure
            let _ = fs::remove_file(&temp_path);
            CliError::IO(name.to_string(), e)
        })?;
    
    // Sync to ensure data is on disk
    temp_file.sync_all()
        .map_err(|e| {
            let _ = fs::remove_file(&temp_path);
            CliError::IO(name.to_string(), e)
        })?;
    
    drop(temp_file);
    
    // Fix permissions on Windows (requires platform-specific code)
    #[cfg(windows)]
    {
        // Use Windows ACLs to restrict access
        // Implementation needed for Windows security
    }
    
    // Atomic rename (overwrites target if exists)
    fs::rename(&temp_path, &self.output_file)
        .map_err(|e| {
            let _ = fs::remove_file(&temp_path);
            CliError::IO(name.to_string(), e)
        })?;
    
    Ok(())
}
```

Additionally, add a permission verification step in `check_key_file()`:

```rust
pub fn check_key_file(&self) -> CliTypedResult<()> {
    self.file_options.check_file()?;
    
    #[cfg(unix)]
    if self.file_options.output_file.exists() {
        use std::os::unix::fs::PermissionsExt;
        let metadata = fs::metadata(&self.file_options.output_file)
            .map_err(|e| CliError::IO("output_file", e))?;
        let mode = metadata.permissions().mode() & 0o777;
        
        if mode != 0o600 {
            eprintln!("Warning: {} has insecure permissions {:o}, will be fixed to 0600", 
                     self.file_options.output_file.display(), mode);
        }
    }
    
    check_if_file_exists(&self.public_key_file()?, self.file_options.prompt_options)
}
```

## Proof of Concept

```rust
// PoC demonstrating the vulnerability
use std::fs::{self, OpenOptions};
use std::io::Write;
use std::os::unix::fs::PermissionsExt;

fn main() {
    let filename = "test_private.key";
    
    // Scenario: File exists with world-readable permissions
    {
        let mut file = OpenOptions::new()
            .write(true)
            .create(true)
            .mode(0o644)  // World-readable
            .open(filename)
            .unwrap();
        file.write_all(b"old key data").unwrap();
    }
    
    println!("Created file with 0o644 permissions");
    let meta = fs::metadata(filename).unwrap();
    println!("Initial permissions: {:o}", meta.permissions().mode() & 0o777);
    
    // Simulate save_to_file_confidential() behavior
    {
        let mut opts = OpenOptions::new();
        #[cfg(unix)]
        opts.mode(0o600);  // This will be IGNORED because file exists!
        
        let mut file = opts
            .write(true)
            .create(true)
            .truncate(true)  // Truncate existing file
            .open(filename)
            .unwrap();
        
        // Simulate partial write (write only some bytes)
        let private_key_bytes = b"super_secret_ed25519_private_key_0123456789abcdef";
        let partial = &private_key_bytes[0..20];  // Only write 20 bytes
        file.write_all(partial).unwrap();
        // Simulate crash/interruption - don't write remaining bytes
    }
    
    // Check: File still has 0o644 permissions with partial key data!
    let meta = fs::metadata(filename).unwrap();
    let perms = meta.permissions().mode() & 0o777;
    println!("After 'confidential' save permissions: {:o}", perms);
    
    let content = fs::read_to_string(filename).unwrap();
    println!("Partial key data (length {}): {}", content.len(), content);
    
    assert_eq!(perms, 0o644, "VULNERABILITY: File retained world-readable permissions!");
    assert!(content.len() < 50, "VULNERABILITY: Partial key data left on disk!");
    
    // Cleanup
    fs::remove_file(filename).unwrap();
    
    println!("\n[VULNERABILITY CONFIRMED]");
    println!("Partial private key data was written to disk with world-readable (0o644) permissions!");
}
```

**Expected Output:**
```
Created file with 0o644 permissions
Initial permissions: 644
After 'confidential' save permissions: 644
Partial key data (length 20): super_secret_ed25519
[VULNERABILITY CONFIRMED]
Partial private key data was written to disk with world-readable (0o644) permissions!
```

## Notes

This vulnerability affects all CLI operations that save private keys, including:
- `aptos key generate` - Ed25519 and BLS12381 key generation
- `aptos init` - Initial account setup with private key creation
- Any validator setup operations that write private keys to disk

The vulnerability is particularly critical for validator operators, as compromised validator keys could enable:
- Unauthorized validator operations
- Stake pool manipulation
- Consensus participation by unauthorized parties

While the bug is in the CLI tool (not core blockchain protocol), it directly impacts the security of validator nodes and user wallets, making it a legitimate Medium severity finding under the Aptos bug bounty program.

### Citations

**File:** crates/aptos/src/common/types.rs (L1084-1089)
```rust
    pub fn save_to_file_confidential(&self, name: &str, bytes: &[u8]) -> CliTypedResult<()> {
        let mut opts = OpenOptions::new();
        #[cfg(unix)]
        opts.mode(0o600);
        write_to_file_with_opts(self.output_file.as_path(), name, bytes, &mut opts)
    }
```

**File:** crates/aptos/src/common/utils.rs (L178-191)
```rust
/// Checks if a file exists, being overridden by `PromptOptions`
pub fn check_if_file_exists(file: &Path, prompt_options: PromptOptions) -> CliTypedResult<()> {
    if file.exists() {
        prompt_yes_with_override(
            &format!(
                "{:?} already exists, are you sure you want to overwrite it?",
                file.as_os_str(),
            ),
            prompt_options,
        )?
    }

    Ok(())
}
```

**File:** crates/aptos/src/common/utils.rs (L232-246)
```rust
pub fn write_to_file_with_opts(
    path: &Path,
    name: &str,
    bytes: &[u8],
    opts: &mut OpenOptions,
) -> CliTypedResult<()> {
    let mut file = opts
        .write(true)
        .create(true)
        .truncate(true)
        .open(path)
        .map_err(|e| CliError::IO(name.to_string(), e))?;
    file.write_all(bytes)
        .map_err(|e| CliError::IO(name.to_string(), e))
}
```

**File:** crates/aptos/src/op/key.rs (L437-441)
```rust
        // Write private and public keys to files
        let public_key_file = self.public_key_file()?;
        self.file_options
            .save_to_file_confidential(key_name, &encoded_private_key)?;
        write_to_file(&public_key_file, key_name, &encoded_public_key)?;
```
