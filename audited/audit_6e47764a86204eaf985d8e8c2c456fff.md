# Audit Report

## Title
Secp256k1 Signature Malleability Vulnerability in Move Native ecdsa_recover Function

## Summary
While the primary Rust transaction authenticator path correctly rejects high-s secp256k1 signatures, the Move native `ecdsa_recover` function used in Ethereum derivable account authentication does not validate against high-s values. This allows signature malleability attacks that can bypass consensus-level transaction deduplication and waste network resources.

## Finding Description

The Aptos codebase implements Secp256k1 ECDSA signature verification through two distinct code paths:

**Path 1: Rust Transaction Authenticator (PROTECTED)**

The primary transaction authentication flow correctly implements high-s rejection: [1](#0-0) 

This verification explicitly checks for high-s values and rejects them with `CanonicalRepresentationError`, as confirmed by the malleability test: [2](#0-1) 

**Path 2: Move Native ecdsa_recover (VULNERABLE)**

However, the Move native function for secp256k1 signature recovery does NOT implement this protection: [3](#0-2) 

This function uses `libsecp256k1::Signature::parse_standard_slice` and `libsecp256k1::recover`, which accept high-s signatures without canonicalization checks. The `libsecp256k1` library version 0.7.0 does not enforce low-s canonicalization - applications must explicitly validate this.

**Attack Scenario:**

The vulnerable path is exploited through Ethereum derivable accounts: [4](#0-3) 

An attacker can:

1. Observe a valid Ethereum derivable account transaction with signature (r, s)
2. Create a malleable variant (r, -s mod n) where the new s value is high (> curve_order/2)
3. Both signatures recover to the same Ethereum address and pass authentication: [5](#0-4) 

4. The consensus deduplication system treats these as distinct transactions because they have different authenticators: [6](#0-5) 

The deduplication uses `(txn.committed_hash(), txn.authenticator())` as the unique key. Since malleable signatures have different authenticator bytes but identical transaction content, both variants pass through consensus processing.

## Impact Explanation

**Severity: High**

This violates the **Cryptographic Correctness** invariant and creates multiple security concerns:

1. **Consensus Resource Exhaustion**: Attackers can submit multiple malleable variants of valid transactions, forcing validators to process duplicate work. While only one variant executes (sequence number prevents double execution), all variants consume:
   - Network bandwidth for propagation
   - Consensus computation cycles
   - Mempool storage
   - Transaction verification resources

2. **Signature Uniqueness Violation**: Systems relying on signature uniqueness for indexing, logging, or analytics would incorrectly treat malleable variants as distinct transactions.

3. **MEV/Transaction Ordering Attacks**: Submitting multiple variants with different gas prices could manipulate transaction ordering or priority in ways not intended by the original signer.

While this does not directly cause fund loss or consensus safety violations, it represents a significant protocol violation that enables denial-of-service attacks against validator resources, meeting the **High Severity** criteria for "Significant protocol violations" and "Validator node slowdowns."

## Likelihood Explanation

**Likelihood: High**

- Ethereum derivable accounts are an active feature in production
- No special privileges required - any user can exploit this
- Attack is trivial to execute: simple ECDSA math to flip s values
- Detection difficulty: malleable transactions appear legitimate to most monitoring
- Known attack vector: signature malleability is well-documented in blockchain security

## Recommendation

Add high-s validation to the Move native `ecdsa_recover` function:

```rust
fn native_ecdsa_recover(
    context: &mut SafeNativeContext,
    _ty_args: &[Type],
    mut arguments: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    // ... existing code ...
    
    let sig = match libsecp256k1::Signature::parse_standard_slice(&signature) {
        Ok(sig) => sig,
        Err(_) => {
            return Err(SafeNativeError::Abort {
                abort_code: abort_codes::NFE_DESERIALIZE,
            });
        },
    };
    
    // ADD THIS CHECK:
    if sig.s.is_high() {
        return Err(SafeNativeError::Abort {
            abort_code: abort_codes::NFE_DESERIALIZE,
        });
    }
    
    context.charge(SECP256K1_ECDSA_RECOVER * NumArgs::one())?;
    
    // ... rest of function ...
}
```

Alternatively, normalize signatures during parsing to always use low-s form, similar to how signing is handled.

## Proof of Concept

```rust
#[test]
fn test_secp256k1_malleability_in_move_native() {
    use libsecp256k1::{Message, SecretKey, sign, recover};
    
    // Create a valid signature with low-s
    let secret_key = SecretKey::parse(&[0x01; 32]).unwrap();
    let message = Message::parse(&[0x42; 32]);
    let (sig, recovery_id) = sign(&message, &secret_key);
    
    // Verify low-s signature recovers correctly
    let pk1 = recover(&message, &sig, &recovery_id).unwrap();
    assert!(!sig.s.is_high());
    
    // Create malleable high-s variant
    let mut high_sig = sig.clone();
    high_sig.s = -high_sig.s;
    assert!(high_sig.s.is_high());
    
    // Both signatures recover to the SAME public key
    let pk2 = recover(&message, &high_sig, &recovery_id).unwrap();
    assert_eq!(pk1.serialize(), pk2.serialize());
    
    // This demonstrates that libsecp256k1::recover accepts high-s
    // The Move native function would accept both variants
    println!("VULNERABILITY: Both low-s and high-s recover to same pubkey");
    println!("Low-s sig: {:?}", sig.serialize());
    println!("High-s sig: {:?}", high_sig.serialize());
}
```

## Notes

The primary transaction authentication path through `types/src/transaction/authenticator.rs` is **correctly protected** against this vulnerability. The issue is isolated to the Move native `ecdsa_recover` function used specifically for Ethereum derivable account authentication. This creates an inconsistency in security posture across the codebase where the same cryptographic primitive is validated differently depending on the execution path.

### Citations

**File:** crates/aptos-crypto/src/secp256k1_ecdsa.rs (L209-223)
```rust
    fn verify(
        &self,
        message: &libsecp256k1::Message,
        public_key: &libsecp256k1::PublicKey,
    ) -> Result<()> {
        // Prevent malleability attacks, low order only. The library only signs in low
        // order, so this was done intentionally.
        if self.0.s.is_high() {
            Err(anyhow!(CryptoMaterialError::CanonicalRepresentationError))
        } else if libsecp256k1::verify(message, &self.0, public_key) {
            Ok(())
        } else {
            Err(anyhow!("Unable to verify signature."))
        }
    }
```

**File:** crates/aptos-crypto/src/unit_tests/secp256k1_ecdsa_test.rs (L82-112)
```rust
#[test]
fn malleability() {
    let mut rng = OsRng;
    let message = b"Hello world";
    let key_pair = KeyPair::<PrivateKey, PublicKey>::generate(&mut rng);

    let signature = key_pair.private_key.sign_arbitrary_message(message);
    assert!(signature
        .verify_arbitrary_msg(message, &key_pair.public_key)
        .is_ok());

    let signature_bytes = signature.to_bytes();
    let signature_deserialized =
        secp256k1_ecdsa::Signature::try_from(&signature_bytes[..]).unwrap();
    assert_eq!(signature, signature_deserialized);

    let mut high_signature = signature.clone();
    high_signature.0.s = -high_signature.0.s;
    let high_signature_bytes = high_signature.to_bytes();

    // We can load
    secp256k1_ecdsa::Signature::try_from(&high_signature_bytes[..]).unwrap();

    // Ensure this is now high.
    assert!(!signature.0.s.is_high());
    assert!(high_signature.0.s.is_high());
    assert!(high_signature.0.s != signature.0.s);
    high_signature
        .verify_arbitrary_msg(message, &key_pair.public_key)
        .unwrap_err();
}
```

**File:** aptos-move/framework/src/natives/cryptography/secp256k1.rs (L63-77)
```rust
    // NOTE(Gas): O(1) deserialization cost
    // which seems to be 64 bytes, so O(1) cost for all intents and purposes.
    let sig = match libsecp256k1::Signature::parse_standard_slice(&signature) {
        Ok(sig) => sig,
        Err(_) => {
            return Err(SafeNativeError::Abort {
                abort_code: abort_codes::NFE_DESERIALIZE,
            });
        },
    };

    context.charge(SECP256K1_ECDSA_RECOVER * NumArgs::one())?;

    // NOTE(Gas): O(1) cost: a size-2 multi-scalar multiplication
    match libsecp256k1::recover(&msg, &sig, &rid) {
```

**File:** aptos-move/framework/aptos-framework/sources/account/common_account_abstractions/ethereum_derivable_account.move (L152-176)
```text
    fun recover_public_key(signature_bytes: &vector<u8>, message: &vector<u8>): vector<u8> {
        let rs = signature_bytes.slice(0, 64);
        let v = signature_bytes[64];
        assert!(v == 27 || v == 28, EUNEXPECTED_V);
        let signature = secp256k1::ecdsa_signature_from_bytes(rs);

        let maybe_recovered = secp256k1::ecdsa_recover(*message, v - 27, &signature);

        assert!(
            maybe_recovered.is_some(),
            EINVALID_SIGNATURE
        );

        let pubkey = maybe_recovered.borrow();

        let pubkey_bytes = secp256k1::ecdsa_raw_public_key_to_bytes(pubkey);

        // Add 0x04 prefix to the public key, to match the
        // full uncompressed format from ethers.js
        let full_pubkey = &mut vector[];
        full_pubkey.push_back(4u8);
        full_pubkey.append(pubkey_bytes);

        *full_pubkey
    }
```

**File:** aptos-move/framework/aptos-framework/sources/account/common_account_abstractions/ethereum_derivable_account.move (L179-205)
```text
    fun authenticate_auth_data(
        aa_auth_data: AbstractionAuthData,
        entry_function_name: &vector<u8>
    ) {
        let derivable_abstract_public_key = aa_auth_data.derivable_abstract_public_key();
        let abstract_public_key = deserialize_abstract_public_key(derivable_abstract_public_key);
        let digest_utf8 = string_utils::to_string(aa_auth_data.digest()).bytes();
        let abstract_signature = deserialize_abstract_signature(aa_auth_data.derivable_abstract_signature());
        let issued_at = abstract_signature.issued_at.bytes();
        let scheme = abstract_signature.scheme.bytes();
        let message = construct_message(&abstract_public_key.ethereum_address, &abstract_public_key.domain, entry_function_name, digest_utf8, issued_at, scheme);
        let hashed_message = aptos_hash::keccak256(message);
        let public_key_bytes = recover_public_key(&abstract_signature.signature, &hashed_message);

        // 1. Skip the 0x04 prefix (take the bytes after the first byte)
        let public_key_without_prefix = public_key_bytes.slice(1, public_key_bytes.length());
        // 2. Run Keccak256 on the public key (without the 0x04 prefix)
        let kexHash = aptos_hash::keccak256(public_key_without_prefix);
        // 3. Slice the last 20 bytes (this is the Ethereum address)
        let recovered_addr = kexHash.slice(12, 32);
        // 4. Remove the 0x prefix from the utf8 account address
        let ethereum_address_without_prefix = abstract_public_key.ethereum_address.slice(2, abstract_public_key.ethereum_address.length());

        let account_address_vec = base16_utf8_to_vec_u8(ethereum_address_without_prefix);
        // Verify that the recovered address matches the domain account identity
        assert!(recovered_addr == account_address_vec, EADDR_MISMATCH);
    }
```

**File:** consensus/src/txn_hash_and_authenticator_deduper.rs (L63-84)
```rust
        let hash_and_authenticators: Vec<_> = possible_duplicates
            .into_par_iter()
            .zip(&transactions)
            .with_min_len(optimal_min_len(num_txns, 48))
            .map(|(need_hash, txn)| match need_hash {
                true => Some((txn.committed_hash(), txn.authenticator())),
                false => None,
            })
            .collect();

        // TODO: Possibly parallelize. See struct comment.
        let mut seen_hashes = HashSet::new();
        let mut num_duplicates: usize = 0;
        let filtered: Vec<_> = hash_and_authenticators
            .into_iter()
            .zip(transactions)
            .filter_map(|(maybe_hash, txn)| match maybe_hash {
                None => Some(txn),
                Some(hash_and_authenticator) => {
                    if seen_hashes.insert(hash_and_authenticator) {
                        Some(txn)
                    } else {
```
