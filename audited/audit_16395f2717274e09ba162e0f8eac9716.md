# Audit Report

## Title
State KV Pruner Bootstrap Inconsistency: Missing Validation Allows Node Dysfunction from Corrupted Metadata

## Summary
The `StateKvPrunerManager::new()` function initializes the pruner's `min_readable_version` from persisted metadata without validating that this value does not exceed the actual ledger version. If the metadata contains a `min_readable_version` ahead of the current ledger, the node will incorrectly reject all state reads below that version as "pruned," even though the data exists, causing complete node dysfunction.

## Finding Description
During node bootstrap, `StateKvPrunerManager::new()` retrieves the pruner progress from database metadata and stores it as the minimum readable version without any consistency check against the actual ledger version. [1](#0-0) 

The `get_state_kv_pruner_progress()` function reads the persisted metadata value, defaulting to 0 if not found: [2](#0-1) 

Later during initialization, `maybe_set_pruner_target_db_version()` is called with the synced version, but this only updates the target if certain conditions are met and does NOT validate the initial `min_readable_version`: [3](#0-2) 

When any state read occurs, `error_if_state_kv_pruned()` checks if the requested version is below `min_readable_version` and rejects it as pruned: [4](#0-3) 

**Attack Scenario:**
1. Database metadata contains `StateKvPrunerProgress = 1000` (from corruption, mismatched backup restore, or prior bug)
2. Actual ledger is only at version 500
3. Node bootstraps, sets `min_readable_version = 1000`
4. Any state read for version â‰¤ 999 is rejected as "pruned" even though data exists
5. API calls fail, state sync fails, consensus may be impacted if validator cannot read state

**How This Can Occur:**
- **Mismatched database restoration**: Restoring `state_kv_db` from a newer backup than `ledger_db`
- **Database corruption**: Metadata corruption causing incorrect values
- **Partial write failures**: System crash after metadata write but before ledger commit completes
- **Bug in pruner logic**: Future bug that incorrectly updates metadata

This breaks the **State Consistency** invariant - the node cannot serve valid state queries despite having the data.

## Impact Explanation
**Medium Severity** per Aptos bug bounty criteria: This causes state inconsistencies requiring operator intervention. The node becomes dysfunctional and cannot:
- Serve state queries via API (all calls return "pruned" errors)
- Participate in consensus if it's a validator (cannot read current state)
- Perform state synchronization
- Execute transactions that require state reads

While not directly exploitable by an unprivileged attacker for immediate gain, this represents a critical robustness gap that violates defensive programming principles. In production:
- Operational errors during backup/restore could trigger this
- Database corruption events could cause this
- Future bugs in pruning logic could manifest this way

The impact is node-level availability loss requiring manual intervention to detect and fix the metadata inconsistency.

## Likelihood Explanation
**Medium Likelihood** in operational scenarios:
- Database restoration is a common operational procedure
- Backup/restore workflows may not guarantee atomic consistency across all database components
- Disaster recovery scenarios often involve restoring from different backup points
- Database corruption, while rare, does occur in production systems

The likelihood is NOT high for direct attacker exploitation, as it requires privileged access to database files or exploiting another vulnerability first. However, for operational causes (the primary concern for this defensive gap), the likelihood is medium.

## Recommendation
Add validation during `StateKvPrunerManager::new()` to ensure `min_readable_version` does not exceed the ledger's synced version. If inconsistency is detected, either:

1. **Conservative approach**: Reset `min_readable_version` to 0 and log a warning
2. **Strict approach**: Fail bootstrap with a clear error message requiring operator intervention

Example fix for conservative approach:

```rust
pub fn new(state_kv_db: Arc<StateKvDb>, state_kv_pruner_config: LedgerPrunerConfig) -> Self {
    let pruner_worker = if state_kv_pruner_config.enable {
        Some(Self::init_pruner(
            Arc::clone(&state_kv_db),
            state_kv_pruner_config,
        ))
    } else {
        None
    };

    let mut min_readable_version =
        pruner_utils::get_state_kv_pruner_progress(&state_kv_db).expect("Must succeed.");
    
    // VALIDATION: Check against commit progress
    if let Ok(Some(commit_progress)) = state_kv_db.get_progress() {
        if min_readable_version > commit_progress {
            warn!(
                min_readable_version = min_readable_version,
                commit_progress = commit_progress,
                "Detected inconsistent state_kv_pruner progress ahead of commit progress. \
                 Resetting to 0 to prevent invalid 'pruned' errors."
            );
            min_readable_version = 0;
            // Persist the corrected value
            state_kv_db.write_pruner_progress(0).expect("Failed to reset pruner progress");
        }
    }

    PRUNER_VERSIONS
        .with_label_values(&["state_kv_pruner", "min_readable"])
        .set(min_readable_version as i64);

    Self {
        state_kv_db,
        prune_window: state_kv_pruner_config.prune_window,
        pruner_worker,
        pruning_batch_size: state_kv_pruner_config.batch_size,
        min_readable_version: AtomicVersion::new(min_readable_version),
    }
}
```

Additionally, consider adding similar validation in `AptosDB::open_internal()` after all components are initialized to perform a cross-component consistency check.

## Proof of Concept

```rust
// Test demonstrating the vulnerability
#[test]
fn test_state_kv_pruner_bootstrap_inconsistency() {
    use aptos_temppath::TempPath;
    use aptos_config::config::RocksdbConfigs;
    
    let tmpdir = TempPath::new();
    
    // Create a database and commit some transactions
    let mut db = AptosDB::new_for_test(&tmpdir);
    let genesis = aptos_vm_genesis::test_genesis_transaction();
    db.save_transactions(&[genesis], 0, None, true).unwrap();
    
    // Simulate 100 more transactions
    for i in 1..100 {
        // ... commit transactions ...
    }
    
    let synced_version = db.get_synced_version().unwrap().unwrap();
    assert_eq!(synced_version, 100);
    
    // Manually corrupt the metadata by writing a future pruner progress
    let corrupted_progress = synced_version + 1000; // version 1100
    db.state_kv_db().write_pruner_progress(corrupted_progress).unwrap();
    
    // Close and reopen the database (simulating node restart)
    drop(db);
    
    let db = AptosDB::new_for_test(&tmpdir);
    
    // The min_readable_version is now ahead of actual ledger
    let min_readable = db.state_store.state_kv_pruner.get_min_readable_version();
    assert_eq!(min_readable, corrupted_progress); // 1100
    
    // Try to read state at current ledger version (100)
    let state_key = StateKey::access_path(AccessPath::new(
        AccountAddress::ONE,
        vec![0x01],
    ));
    
    let result = db.get_state_value_by_version(&state_key, synced_version);
    
    // This should succeed but will fail with "pruned" error
    // even though version 100 is the current ledger version
    match result {
        Err(e) => {
            assert!(e.to_string().contains("is pruned"));
            assert!(e.to_string().contains(&format!("min available version is {}", corrupted_progress)));
            println!("BUG CONFIRMED: State at current ledger version {} rejected as pruned. Min readable: {}", 
                     synced_version, corrupted_progress);
        }
        Ok(_) => panic!("Expected error but read succeeded"),
    }
}
```

## Notes
While this issue requires privileged access or operational errors to trigger (not directly exploitable by remote attackers), it represents a critical defensive programming gap. Production systems must be resilient to operational errors, partial failures, and cascading bugs. The lack of validation here means that database inconsistencies (from any source) will manifest as silent node dysfunction rather than failing fast with clear diagnostic information.

The security impact is availability loss rather than confidentiality or integrity breach, but availability is a core security property for blockchain validators.

### Citations

**File:** storage/aptosdb/src/pruner/state_kv_pruner/state_kv_pruner_manager.rs (L84-108)
```rust
    pub fn new(state_kv_db: Arc<StateKvDb>, state_kv_pruner_config: LedgerPrunerConfig) -> Self {
        let pruner_worker = if state_kv_pruner_config.enable {
            Some(Self::init_pruner(
                Arc::clone(&state_kv_db),
                state_kv_pruner_config,
            ))
        } else {
            None
        };

        let min_readable_version =
            pruner_utils::get_state_kv_pruner_progress(&state_kv_db).expect("Must succeed.");

        PRUNER_VERSIONS
            .with_label_values(&["state_kv_pruner", "min_readable"])
            .set(min_readable_version as i64);

        Self {
            state_kv_db,
            prune_window: state_kv_pruner_config.prune_window,
            pruner_worker,
            pruning_batch_size: state_kv_pruner_config.batch_size,
            min_readable_version: AtomicVersion::new(min_readable_version),
        }
    }
```

**File:** storage/aptosdb/src/pruner/pruner_utils.rs (L23-29)
```rust
pub(crate) fn get_state_kv_pruner_progress(state_kv_db: &StateKvDb) -> Result<Version> {
    Ok(get_progress(
        state_kv_db.metadata_db(),
        &DbMetadataKey::StateKvPrunerProgress,
    )?
    .unwrap_or(0))
}
```

**File:** storage/aptosdb/src/db/aptosdb_internal.rs (L162-171)
```rust
        if !readonly {
            if let Some(version) = myself.get_synced_version()? {
                myself
                    .ledger_pruner
                    .maybe_set_pruner_target_db_version(version);
                myself
                    .state_store
                    .state_kv_pruner
                    .maybe_set_pruner_target_db_version(version);
            }
```

**File:** storage/aptosdb/src/db/aptosdb_internal.rs (L305-315)
```rust
    pub(super) fn error_if_state_kv_pruned(&self, data_type: &str, version: Version) -> Result<()> {
        let min_readable_version = self.state_store.state_kv_pruner.get_min_readable_version();
        ensure!(
            version >= min_readable_version,
            "{} at version {} is pruned, min available version is {}.",
            data_type,
            version,
            min_readable_version
        );
        Ok(())
    }
```
