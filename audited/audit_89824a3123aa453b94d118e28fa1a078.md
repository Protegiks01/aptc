# Audit Report

## Title
Missing Version Monotonicity Check in Commit Vote Signing Allows Potential Consensus Safety Violation

## Summary
The `guarded_sign_commit_vote()` function in SafetyRules does not validate that the version in `new_ledger_info` is greater than the last committed version, creating a gap in defense-in-depth protections against state rollbacks. While storage layer checks exist, SafetyRules should independently enforce version monotonicity as a critical consensus safety invariant.

## Finding Description

The `guarded_sign_commit_vote()` function in `consensus/safety-rules/src/safety_rules.rs` is responsible for signing commit votes after block execution in Aptos's decoupled execution model. This function performs several validation checks but **critically omits verification of version monotonicity**. [1](#0-0) 

The function validates:
1. That the ordered ledger info is ordered-only (lines 381-393)
2. That commit data consistency via `match_ordered_only()` (lines 395-403)
3. That signatures have 2f+1 voting power (lines 405-410)

However, SafetyData struct does not track the last committed version: [2](#0-1) 

The struct only tracks rounds (last_voted_round, preferred_round, one_chain_round) but no version information. The `match_ordered_only()` method explicitly does NOT check version: [3](#0-2) 

This creates a scenario where in decoupled execution mode, blocks are ordered with dummy versions (0), then executed to get real versions. The TODO comments acknowledge this gap: [4](#0-3) 

**Attack Path (requires additional preconditions):**
1. A validator's execution layer produces a block with version V_old (where V_old â‰¤ last_committed_version)
2. This could occur through: database corruption, state sync issues, executor bugs, or validator restart from old backup
3. The SigningRequest is created with ordered_proof (version 0) and commit_ledger_info (version V_old)
4. SafetyRules signs the commit vote without checking V_old > last_committed_version
5. If 2f+1 validators are affected, a commit proof forms for V_old
6. This violates consensus safety by creating a valid commitment to a state rollback

## Impact Explanation

While a storage layer check exists that would eventually reject the commit, the consensus safety violation occurs at the protocol level when validators sign commit votes for rollback versions: [5](#0-4) 

**However**, this is primarily a **defense-in-depth issue** rather than a standalone exploitable vulnerability because:

1. **Unprivileged attacker cannot directly cause this**: An external attacker cannot force validators to execute blocks with old versions without exploiting separate vulnerabilities in the executor or state sync
2. **Requires additional failure conditions**: Exploitation requires validator state corruption, executor bugs, or other system failures affecting 2f+1 validators
3. **Storage layer provides backstop**: The storage check would prevent actual commit even if signatures are collected

**Impact Assessment: HIGH severity** (not Critical) because:
- Requires additional preconditions to exploit
- Storage layer provides secondary defense
- Represents incomplete safety rule rather than direct exploitable path
- Could enable network inconsistency if combined with other failures

## Likelihood Explanation

**Likelihood: LOW-MEDIUM**

The vulnerability cannot be directly exploited by an unprivileged attacker. It requires:

1. **Validator State Issues** (2f+1 validators): Database corruption, failed state sync, rollback from backup, or execution bugs
2. **Timing**: Blocks must be executed and signed before storage commit detection
3. **Coordination**: Multiple validators must independently experience the same issue

The vulnerability becomes more relevant in:
- Mass validator failures or correlated bugs
- State sync protocol issues affecting multiple validators
- Executor implementation bugs producing incorrect versions
- Network partitions with inconsistent state recovery

## Recommendation

Add version tracking to SafetyData and implement monotonicity check in `guarded_sign_commit_vote()`:

**Step 1**: Extend SafetyData to track last committed version: [6](#0-5) 

Add field: `last_committed_version: u64`

**Step 2**: Update SafetyRules to check version monotonicity: [1](#0-0) 

Add check before signing (after line 410):
```rust
// Verify version monotonicity
let safety_data = self.persistent_storage.safety_data()?;
if new_ledger_info.version() > 0 && 
   new_ledger_info.version() <= safety_data.last_committed_version {
    return Err(Error::VersionTooOld(
        new_ledger_info.version(),
        safety_data.last_committed_version,
    ));
}
```

**Step 3**: Update last_committed_version when commit proofs are received

This implements the missing "extension check" referenced in the TODO comment.

## Proof of Concept

**Note**: A complete PoC requires creating conditions where the executor produces old versions, which would require mocking or exploiting separate bugs. This is demonstrating the missing check, not a full end-to-end exploit.

```rust
#[test]
fn test_sign_commit_vote_version_rollback() {
    // Setup: Create SafetyRules with committed version 1000
    let (mut safety_rules, signer) = test_setup();
    
    // Simulate: Network has committed up to version 1000
    // (In real scenario, this would be tracked in SafetyData)
    
    // Create ordered ledger info (version 0 - ordered only)
    let ordered_block_info = BlockInfo::new(
        1, // epoch
        100, // round
        HashValue::random(),
        *ACCUMULATOR_PLACEHOLDER_HASH, // ordered-only marker
        0, // version (dummy)
        1000000,
        None,
    );
    let ordered_ledger_info = LedgerInfo::new(
        ordered_block_info,
        HashValue::random(),
    );
    let ordered_proof = LedgerInfoWithSignatures::new(
        ordered_ledger_info,
        AggregateSignature::empty(), // Would have 2f+1 sigs in real scenario
    );
    
    // Create commit ledger info with OLD version 900
    let commit_block_info = BlockInfo::new(
        1, // epoch
        100, // round (matches)
        ordered_block_info.id(), // id (matches)
        HashValue::random(), // real executed state
        900, // version - ROLLBACK TO 900 (should fail but doesn't!)
        1000000, // timestamp (matches)
        None,
    );
    let commit_ledger_info = LedgerInfo::new(
        commit_block_info,
        ordered_ledger_info.consensus_data_hash(),
    );
    
    // BUG: This should fail but will succeed because 
    // SafetyRules doesn't check version monotonicity
    let result = safety_rules.sign_commit_vote(
        ordered_proof,
        commit_ledger_info,
    );
    
    // Currently passes (vulnerability)
    // Should fail with Error::VersionTooOld(900, 1000)
    assert!(result.is_ok()); // This demonstrates the bug
}
```

## Notes

This vulnerability represents **incomplete safety rules** rather than a direct attack vector. The storage layer provides defense, but SafetyRules should independently enforce all consensus safety invariants including version monotonicity. The TODO comments in the code acknowledge this gap. While not immediately exploitable by unprivileged attackers, it weakens the system's defense-in-depth and could contribute to consensus safety violations when combined with other failures or bugs.

### Citations

**File:** consensus/safety-rules/src/safety_rules.rs (L372-418)
```rust
    fn guarded_sign_commit_vote(
        &mut self,
        ledger_info: LedgerInfoWithSignatures,
        new_ledger_info: LedgerInfo,
    ) -> Result<bls12381::Signature, Error> {
        self.signer()?;

        let old_ledger_info = ledger_info.ledger_info();

        if !old_ledger_info.commit_info().is_ordered_only()
            // When doing fast forward sync, we pull the latest blocks and quorum certs from peers
            // and store them in storage. We then compute the root ordered cert and root commit cert
            // from storage and start the consensus from there. But given that we are not storing the
            // ordered cert obtained from order votes in storage, instead of obtaining the root ordered cert
            // from storage, we set root ordered cert to commit certificate.
            // This means, the root ordered cert will not have a dummy executed_state_id in this case.
            // To handle this, we do not raise error if the old_ledger_info.commit_info() matches with
            // new_ledger_info.commit_info().
            && old_ledger_info.commit_info() != new_ledger_info.commit_info()
        {
            return Err(Error::InvalidOrderedLedgerInfo(old_ledger_info.to_string()));
        }

        if !old_ledger_info
            .commit_info()
            .match_ordered_only(new_ledger_info.commit_info())
        {
            return Err(Error::InconsistentExecutionResult(
                old_ledger_info.commit_info().to_string(),
                new_ledger_info.commit_info().to_string(),
            ));
        }

        // Verify that ledger_info contains at least 2f + 1 dostinct signatures
        if !self.skip_sig_verify {
            ledger_info
                .verify_signatures(&self.epoch_state()?.verifier)
                .map_err(|error| Error::InvalidQuorumCertificate(error.to_string()))?;
        }

        // TODO: add guarding rules in unhappy path
        // TODO: add extension check

        let signature = self.sign(&new_ledger_info)?;

        Ok(signature)
    }
```

**File:** consensus/consensus-types/src/safety_data.rs (L8-21)
```rust
/// Data structure for safety rules to ensure consensus safety.
#[derive(Debug, Deserialize, Eq, PartialEq, Serialize, Clone, Default)]
pub struct SafetyData {
    pub epoch: u64,
    pub last_voted_round: u64,
    // highest 2-chain round, used for 3-chain
    pub preferred_round: u64,
    // highest 1-chain round, used for 2-chain
    #[serde(default)]
    pub one_chain_round: u64,
    pub last_vote: Option<Vote>,
    #[serde(default)]
    pub highest_timeout_round: u64,
}
```

**File:** types/src/block_info.rs (L196-204)
```rust
    pub fn match_ordered_only(&self, executed_block_info: &BlockInfo) -> bool {
        self.epoch == executed_block_info.epoch
            && self.round == executed_block_info.round
            && self.id == executed_block_info.id
            && (self.timestamp_usecs == executed_block_info.timestamp_usecs
            // executed block info has changed its timestamp because it's a reconfiguration suffix
                || (self.timestamp_usecs > executed_block_info.timestamp_usecs
                    && executed_block_info.has_reconfiguration()))
    }
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L522-538)
```rust
    fn get_and_check_commit_range(&self, version_to_commit: Version) -> Result<Option<Version>> {
        let old_committed_ver = self.ledger_db.metadata_db().get_synced_version()?;
        let pre_committed_ver = self.state_store.current_state_locked().version();
        ensure!(
            old_committed_ver.is_none() || version_to_commit >= old_committed_ver.unwrap(),
            "Version too old to commit. Committed: {:?}; Trying to commit with LI: {}",
            old_committed_ver,
            version_to_commit,
        );
        ensure!(
            pre_committed_ver.is_some() && version_to_commit <= pre_committed_ver.unwrap(),
            "Version too new to commit. Pre-committed: {:?}, Trying to commit with LI: {}",
            pre_committed_ver,
            version_to_commit,
        );
        Ok(old_committed_ver)
    }
```
