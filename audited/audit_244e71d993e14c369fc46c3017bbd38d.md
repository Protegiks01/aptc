# Audit Report

## Title
Premature Transaction Expiration Due to Block Timestamp Skew in Mempool Garbage Collection

## Summary
The mempool's `gc_by_expiration_time` function removes transactions based on block timestamps which can be up to 5 minutes ahead of real time per consensus rules. This allows malicious validators to prematurely censor valid transactions by proposing blocks with timestamps near the maximum allowed future bound (5 minutes ahead), causing transactions that should remain valid for several more minutes to be immediately garbage collected from the mempool. [1](#0-0) 

## Finding Description
The vulnerability exists in the interaction between three components:

1. **Block Timestamp Bounds**: Consensus allows block timestamps to be up to 5 minutes (300 seconds) ahead of current real time. [2](#0-1) 

2. **Expiration Time Index**: The mempool maintains an expiration time index using transaction's user-specified `expiration_timestamp_secs`. [3](#0-2) 

3. **GC by Expiration Time**: When blocks are committed, `gc_by_expiration_time` is called with the block's timestamp to remove expired transactions. [4](#0-3) 

The garbage collection logic removes all transactions where `expiration_time < block_timestamp - 1 microsecond`: [5](#0-4) 

**Attack Scenario:**
1. Current real time: T (e.g., 2024-01-01 12:00:00 = T microseconds since epoch)
2. User submits transaction with `expiration_timestamp_secs` = T/1,000,000 + 180 seconds (expires 3 minutes from now)
3. Malicious validator proposes block with `timestamp_usecs` = T + 300,000,000 microseconds (5 minutes in the future, which is valid)
4. Block is committed and `process_committed_transactions` is called with `block_timestamp_usecs` = T + 300,000,000
5. `gc_by_expiration_time` converts this to `Duration::from_micros(T + 300,000,000)`
6. `TTLIndex::gc` calculates `max_expiration_time = (T + 300,000,000) - 1` microsecond
7. Transaction with `expiration_time = Duration::from_secs((T/1,000,000) + 180)` = `Duration::from_micros(T + 180,000,000)` is garbage collected because T + 180,000,000 < T + 300,000,000
8. Transaction is removed from mempool even though it should be valid for 3 more minutes in real time [6](#0-5) 

## Impact Explanation
This vulnerability allows transaction censorship and breaks transaction liveness guarantees:

- **Transaction Censorship**: Malicious validators can selectively censor transactions by timing their proposals to coincide with transactions entering mempool. By proposing blocks with timestamps near the 5-minute upper bound, they can force premature removal of transactions that users expect to remain valid.

- **Broken User Expectations**: Users set expiration timestamps expecting their transactions to be eligible for inclusion until that time. Premature removal violates this expectation without any indication to the user.

- **State Inconsistency**: The mempool state becomes inconsistent with user intent, requiring manual resubmission of transactions.

This qualifies as **Medium Severity** per Aptos bug bounty criteria: "State inconsistencies requiring intervention" and limited transaction censorship that doesn't require validator collusion.

## Likelihood Explanation
The attack is highly likely to occur because:

1. **Single Validator Attack**: A single malicious validator acting as block leader can execute this attack. Honest validators will accept and vote for the block because timestamps up to 5 minutes in the future are consensus-valid.

2. **No Special Conditions Required**: The attack works on any transaction with expiration less than 5 minutes from the current time, which is common for user transactions.

3. **Natural Occurrence**: Even without malicious intent, clock skew or network delays could cause blocks to have timestamps significantly ahead of some nodes' local time, triggering this issue.

4. **Repeated Exploitation**: A malicious validator can repeatedly exploit this whenever they are elected as leader.

## Recommendation
Implement a constraint on `gc_by_expiration_time` to prevent using block timestamps that are too far ahead of real time:

```rust
pub(crate) fn gc_by_expiration_time(&mut self, block_time: Duration) {
    // Clamp block_time to not exceed real time by more than a reasonable threshold
    let current_time = aptos_infallible::duration_since_epoch();
    let max_allowed_block_time = current_time.saturating_add(Duration::from_secs(60)); // 1 minute buffer
    let clamped_block_time = std::cmp::min(block_time, max_allowed_block_time);
    
    self.gc(self.eager_expire_time(clamped_block_time), false);
}
```

This ensures that even if block timestamps are far in the future, the garbage collection will not prematurely remove transactions that are still valid in real time. The 1-minute buffer allows for reasonable clock skew while preventing the 5-minute exploit window.

Alternatively, only use `gc_by_system_ttl` (which uses real time) and remove `gc_by_expiration_time` entirely, or call it only when block timestamp is within a reasonable bound of real time.

## Proof of Concept
```rust
// Test case demonstrating premature expiration
#[test]
fn test_premature_expiration_with_future_block_timestamp() {
    use std::time::{Duration, SystemTime};
    use aptos_infallible::duration_since_epoch;
    
    // Setup mempool
    let mut config = MempoolConfig::default();
    config.system_transaction_timeout_secs = 60; // 60 second system TTL
    let mut mempool = Mempool::new(&node_config_with_mempool(config));
    
    // Current real time
    let current_time = duration_since_epoch();
    let current_time_secs = current_time.as_secs();
    
    // Create transaction expiring in 3 minutes
    let expiration_secs = current_time_secs + 180; // 3 minutes from now
    let txn = create_signed_transaction_with_expiration(expiration_secs);
    
    // Add transaction to mempool
    let status = mempool.add_txn(
        txn.clone(),
        100, // ranking_score
        Some(0), // account_sequence_number
        TimelineState::NotReady,
        true, // client_submitted
        None,
        None,
    );
    assert_eq!(status.code, MempoolStatusCode::Accepted);
    
    // Simulate block committed with timestamp 5 minutes in the future
    let block_timestamp_usecs = (current_time.as_micros() as u64) + 300_000_000; // 5 minutes ahead
    
    // Trigger GC with future block timestamp
    mempool.gc_by_expiration_time(Duration::from_micros(block_timestamp_usecs));
    
    // Transaction should be prematurely removed even though it hasn't expired in real time
    assert!(mempool.get_by_hash(txn.committed_hash()).is_none());
    // Transaction was valid for 3 more minutes but was removed immediately
}
```

## Notes
The issue is exacerbated by the fact that the 5-minute future timestamp bound in consensus (`TIMEBOUND` = 300 seconds) is quite large. While this allows for clock skew tolerance, it creates a significant window for premature transaction expiration. The system TTL based on real time provides partial mitigation, but doesn't prevent the premature removal issue when block timestamps are significantly ahead of real time.

### Citations

**File:** mempool/src/core_mempool/transaction.rs (L24-24)
```rust
    pub expiration_time: Duration,
```

**File:** consensus/consensus-types/src/opt_block_data.rs (L110-114)
```rust
        const TIMEBOUND: u64 = 300_000_000;
        ensure!(
            self.timestamp_usecs() <= (current_ts.as_micros() as u64).saturating_add(TIMEBOUND),
            "Blocks must not be too far in the future"
        );
```

**File:** mempool/src/core_mempool/transaction_store.rs (L119-121)
```rust
            expiration_time_index: TTLIndex::new(Box::new(|t: &MempoolTransaction| {
                Duration::from_secs(t.txn.expiration_timestamp_secs())
            })),
```

**File:** mempool/src/shared_mempool/tasks.rs (L740-742)
```rust
    if block_timestamp_usecs > 0 {
        pool.gc_by_expiration_time(block_timestamp);
    }
```

**File:** mempool/src/core_mempool/index.rs (L247-260)
```rust
    pub(crate) fn gc(&mut self, now: Duration) -> Vec<TTLOrderingKey> {
        // Ideally, we should garbage collect all transactions with expiration time < now.
        let max_expiration_time = now.saturating_sub(Duration::from_micros(1));
        let ttl_key = TTLOrderingKey {
            expiration_time: max_expiration_time,
            address: AccountAddress::ZERO,
            replay_protector: ReplayProtector::Nonce(0),
        };

        let mut active = self.data.split_off(&ttl_key);
        let ttl_transactions = self.data.iter().cloned().collect();
        self.data.clear();
        self.data.append(&mut active);
        ttl_transactions
```

**File:** state-sync/inter-component/mempool-notifications/src/lib.rs (L149-152)
```rust
pub struct MempoolCommitNotification {
    pub transactions: Vec<CommittedTransaction>,
    pub block_timestamp_usecs: u64, // The timestamp of the committed block.
}
```
