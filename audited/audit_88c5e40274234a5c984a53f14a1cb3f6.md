# Audit Report

## Title
Feature Flag Bypass: Nested Function Types in Struct Fields Evade enable_function_values Check

## Summary
The Move bytecode verifier fails to recursively check nested signature tokens in struct field definitions when the `enable_function_values` feature is disabled. While `verify_signatures()` correctly uses `preorder_traversal()` to detect all nested Function types in the signature table, the `verify_field_definition()` method only checks the top-level type token, allowing attackers to bypass the feature flag by embedding Function types within Vector, Reference, or StructInstantiation types in struct fields.

## Finding Description
The security question asks whether `preorder_traversal()` visits all nested signature tokens. The answer is **yes** for the signature table verification path, but **no** for struct field verification, creating an exploitable bypass. [1](#0-0) 

In the signature table verification path, `verify_signatures()` correctly uses `preorder_traversal()` to iterate through all nested tokens: [2](#0-1) 

The `preorder_traversal()` implementation properly pushes all children of Function types onto the stack, ensuring complete traversal of nested structures.

However, the struct field verification path has a critical flaw: [3](#0-2) 

The `verify_field_definition()` method calls `verify_signature_token()` directly on the field's type token without using `preorder_traversal()`. The verification function only checks if the token itself is a Function type: [4](#0-3) 

This means a struct field declared as `Vector<Function<[U8], [U64], abilities>>` would pass verification because:
1. The top-level token is `Vector`, not `Function`
2. No recursive traversal occurs
3. The nested Function type is never checked

The signature_v2 verifier does perform recursive checking via `check_ty()`, but it only enforces ability constraints, not the `enable_function_values` feature flag: [5](#0-4) 

## Impact Explanation
**Severity: Medium to High**

This vulnerability breaks the **Move VM Safety** invariant by allowing feature-gated functionality to be used when explicitly disabled. When blockchain operators disable `enable_function_values` to prevent function value usage (for security, compatibility, or upgrade reasons), attackers can bypass this restriction by:

1. Deploying modules with struct definitions containing `Vector<Function<...>>`, `&Function<...>`, or `SomeStruct<Function<...>>` fields
2. These modules pass verification despite function values being disabled
3. Subsequent code using these types may execute undefined behavior or break VM assumptions

This violates **Deterministic Execution** because different nodes with different security assumptions about feature availability may process modules differently. It also enables potential exploitation of unpatched function value vulnerabilities even after the feature is intentionally disabled.

While this doesn't directly cause loss of funds, it represents a significant protocol violation that undermines the feature flag security model and could enable chain of exploitation attacks.

## Likelihood Explanation
**Likelihood: Medium**

Exploitation requires:
- Network configuration where `enable_function_values` is set to `false` (non-default but possible in restricted environments)
- Attacker ability to deploy Move modules
- Knowledge of the verification gap

The default configuration has `enable_function_values` set to `true`, reducing immediate risk: [6](#0-5) 

However, the vulnerability becomes critical in environments where operators intentionally disable function values for security hardening or during feature rollout periods.

## Recommendation
Modify `verify_field_definition()` to use `preorder_traversal()` for complete nested type checking, matching the approach used in `verify_signatures()`:

```rust
fn verify_field_definition(
    &self,
    struct_idx: usize,
    field: &FieldDefinition,
) -> PartialVMResult<()> {
    // Check all nested tokens, not just the top-level type
    for t in field.signature.0.preorder_traversal() {
        self.verify_signature_token(t)
            .map_err(|e| e.at_index(IndexKind::StructDefinition, struct_idx as u16))?;
    }
    Ok(())
}
```

Additionally, consider adding explicit Function type rejection in the signature_v2 verifier when `enable_function_values` is disabled, providing defense-in-depth.

## Proof of Concept
```move
// Compile with enable_function_values = false
module 0xCAFE::Exploit {
    struct Wrapper has copy, drop {
        // This should be rejected but isn't
        nested_func: vector<|u8| u64>  // Function type nested in Vector
    }

    public fun create(): Wrapper {
        // This module will pass verification incorrectly
        Wrapper { nested_func: vector[] }
    }
}
```

Rust test demonstrating the vulnerability:

```rust
#[test]
fn test_nested_function_bypass() {
    use move_binary_format::file_format::*;
    use move_bytecode_verifier::VerifierConfig;
    
    // Create a module with Vector<Function> in struct field
    let mut module = CompiledModule::default();
    // ... (construct module with struct field type = Vector<Function<...>>)
    
    let mut config = VerifierConfig::default();
    config.enable_function_values = false;  // Feature disabled
    
    // This should fail but doesn't
    let result = verify_module_with_config(&config, &module);
    assert!(result.is_err());  // Expected: error, Actual: passes
}
```

## Notes
The `preorder_traversal()` method itself is correctly implemented and visits all nested tokens as designed. The vulnerability lies in the inconsistent application of this traversal method across different verification code paths. The signature table verification uses it correctly, while struct field verification does not.

### Citations

**File:** third_party/move/move-bytecode-verifier/src/features.rs (L99-106)
```rust
    fn verify_field_definition(
        &self,
        struct_idx: usize,
        field: &FieldDefinition,
    ) -> PartialVMResult<()> {
        self.verify_signature_token(&field.signature.0)
            .map_err(|e| e.at_index(IndexKind::StructDefinition, struct_idx as u16))
    }
```

**File:** third_party/move/move-bytecode-verifier/src/features.rs (L159-171)
```rust
    fn verify_signatures(&self) -> PartialVMResult<()> {
        if !self.config.enable_function_values {
            for (idx, sig) in self.code.signatures().iter().enumerate() {
                for tok in &sig.0 {
                    for t in tok.preorder_traversal() {
                        self.verify_signature_token(t)
                            .map_err(|e| e.at_index(IndexKind::Signature, idx as u16))?
                    }
                }
            }
        }
        Ok(())
    }
```

**File:** third_party/move/move-bytecode-verifier/src/features.rs (L173-180)
```rust
    fn verify_signature_token(&self, tok: &SignatureToken) -> PartialVMResult<()> {
        if !self.config.enable_function_values && matches!(tok, SignatureToken::Function(..)) {
            Err(PartialVMError::new(StatusCode::FEATURE_NOT_ENABLED)
                .with_message("function value feature not enabled".to_string()))
        } else {
            Ok(())
        }
    }
```

**File:** third_party/move/move-binary-format/src/file_format.rs (L998-1001)
```rust
                    Function(args, result, _) => {
                        self.stack.extend(result.iter().rev());
                        self.stack.extend(args.iter().rev());
                    },
```

**File:** third_party/move/move-bytecode-verifier/src/signature_v2.rs (L172-187)
```rust
            Function(params, results, abilities) => {
                assert_abilities(*abilities, required_abilities)?;
                if self.sig_checker_v2_fix_function_signatures {
                    for ty in params.iter().chain(results) {
                        self.check_ty(
                            ty,
                            // Immediate params and returns can be references.
                            true,
                            // Note we do not need to check abilities of argument or result types,
                            // they do not matter for the `required_abilities`.
                            AbilitySet::EMPTY,
                            param_constraints,
                        )?
                    }
                }
            },
```

**File:** third_party/move/move-bytecode-verifier/src/verifier.rs (L267-267)
```rust
            enable_function_values: true,
```
