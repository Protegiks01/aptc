# Audit Report

## Title
Case-Sensitive Address Standardization Causes Indexer State Inconsistency

## Summary
The `standardize_address()` function in the indexer-grpc transaction filter incorrectly preserves the case of uppercase hexadecimal characters (A-F) for special addresses, violating the AIP-40 standard requirement for canonical lowercase representation. This causes different indexer nodes to produce inconsistent standardized addresses, leading to divergent filtering behavior and database state across the indexer network.

## Finding Description

The security question's premise is partially incorrect—uppercase characters DO pass the validation check, not fail it. However, this reveals the actual vulnerability: the function improperly accepts and preserves uppercase hex characters. [1](#0-0) 

The validation logic at lines 16-21 checks if an address is "special" (0x0 to 0xf) by verifying:
1. All characters before the last are '0'
2. The last character is a hexadecimal digit (`is_ascii_hexdigit()`)
3. The last character is <= 'f' (ASCII 102)

The bug occurs because uppercase 'A'-'F' (ASCII 65-70) satisfy `last_char <= 'f'` since they are numerically less than lowercase 'f'. The function then preserves the original case at line 25, returning "0xA" for input "0xA" instead of normalizing to "0xa".

The canonical implementation in `AccountAddress` always produces lowercase: [2](#0-1) [3](#0-2) 

The canonical version uses `hex::encode()` which always produces lowercase, while the indexer filter version preserves input case.

**Attack Scenario:**

1. Indexer Node A receives a filter configuration with sender address "0xA"
2. Indexer Node B receives the same filter with sender address "0xa" 
3. Both nodes cache their respective standardized values: "0xA" vs "0xa" [4](#0-3) 

4. A transaction with sender "0xa" arrives at both nodes
5. Node A compares: `standardize_address("0xa")` = "0xa" != "0xA" → NO MATCH (transaction passes through)
6. Node B compares: `standardize_address("0xa")` = "0xa" == "0xa" → MATCH (transaction filtered) [5](#0-4) 

The nodes produce different filtering results, causing indexer state divergence.

## Impact Explanation

This is **Medium Severity** per Aptos bug bounty criteria:
- **State inconsistencies requiring intervention**: Different indexer nodes will have inconsistent database states when filtering transactions by special addresses with mixed case
- Does not affect consensus or validator operations (indexers are off-chain infrastructure)
- Violates the deterministic execution invariant for indexer operations
- Could cause data integrity issues requiring database reconciliation or rebuilding

The impact is limited to indexer infrastructure, not the core blockchain, which prevents this from being High or Critical severity.

## Likelihood Explanation

**High Likelihood**:
- Trivial to exploit—simply use uppercase hex characters in address representations
- No special privileges required
- Could occur accidentally through normal API usage if clients don't normalize addresses
- Multiple codepaths accept addresses (protobuf filters, API endpoints)
- No existing tests validate case sensitivity handling [6](#0-5) 

Notice all test cases use lowercase hex characters—the case sensitivity issue is completely untested.

## Recommendation

Normalize the last character to lowercase before returning it for special addresses:

```rust
pub fn standardize_address(address: &str) -> String {
    let trimmed = address.strip_prefix("0x").unwrap_or(address);

    if let Some(last_char) = trimmed.chars().last() {
        if trimmed[..trimmed.len().saturating_sub(1)]
            .chars()
            .all(|c| c == '0')
            && last_char.is_ascii_hexdigit()
            && last_char <= 'f'
        {
            let mut result = String::with_capacity(3);
            result.push_str("0x");
            result.push(last_char.to_ascii_lowercase()); // FIX: Normalize to lowercase
            return result;
        }
    }

    let mut result = String::with_capacity(66);
    result.push_str("0x");
    result.push_str(&ZEROS[..64 - trimmed.len()]);
    result.push_str(&trimmed.to_ascii_lowercase()); // ALSO: Normalize long form
    result
}
```

Additionally, add test coverage for uppercase inputs to prevent regression.

## Proof of Concept

```rust
#[test]
fn test_uppercase_special_address_inconsistency() {
    // Demonstrates the vulnerability: uppercase and lowercase produce different results
    let uppercase_result = standardize_address("0xA");
    let lowercase_result = standardize_address("0xa");
    
    // BUG: These should be equal but they're not
    assert_ne!(uppercase_result, lowercase_result);
    assert_eq!(uppercase_result, "0xA");  // Preserves uppercase
    assert_eq!(lowercase_result, "0xa");  // Preserves lowercase
    
    // This causes filter comparison failures
    let filter_with_uppercase = "0xA";
    let transaction_sender = "0xa";
    
    assert_ne!(
        standardize_address(filter_with_uppercase),
        standardize_address(transaction_sender)
    );
    // Different nodes would produce different filtering results!
}

#[test]
fn test_all_uppercase_special_addresses() {
    // All uppercase A-F should be normalized to lowercase per AIP-40
    assert_eq!(standardize_address("0xA"), "0xa"); // Should normalize (currently fails)
    assert_eq!(standardize_address("0xB"), "0xb"); // Should normalize (currently fails)
    assert_eq!(standardize_address("0xC"), "0xc"); // Should normalize (currently fails)
    assert_eq!(standardize_address("0xD"), "0xd"); // Should normalize (currently fails)
    assert_eq!(standardize_address("0xE"), "0xe"); // Should normalize (currently fails)
    assert_eq!(standardize_address("0xF"), "0xf"); // Should normalize (currently fails)
}
```

**Notes:**

The security question's technical premise was incorrect (claimed uppercase would fail `last_char <= 'f'` check), but the broader concern about inconsistent address representation is valid. The actual bug is that uppercase characters PASS the check when they shouldn't, causing case-preserving behavior that violates AIP-40 canonical address representation standards and creates indexer state inconsistency.

### Citations

**File:** ecosystem/indexer-grpc/transaction-filter/src/utils.rs (L10-36)
```rust
pub fn standardize_address(address: &str) -> String {
    // Remove "0x" prefix if it exists
    let trimmed = address.strip_prefix("0x").unwrap_or(address);

    // Check if the address is a special address by seeing if the first 31 bytes are zero and the last byte is smaller than 0b10000
    if let Some(last_char) = trimmed.chars().last() {
        if trimmed[..trimmed.len().saturating_sub(1)]
            .chars()
            .all(|c| c == '0')
            && last_char.is_ascii_hexdigit()
            && last_char <= 'f'
        {
            // Return special addresses in short format
            let mut result = String::with_capacity(3);
            result.push_str("0x");
            result.push(last_char);
            return result;
        }
    }

    // Return non-special addresses in long format
    let mut result = String::with_capacity(66);
    result.push_str("0x");
    result.push_str(&ZEROS[..64 - trimmed.len()]);
    result.push_str(trimmed);
    result
}
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/utils.rs (L42-62)
```rust
    #[test]
    fn test_standardize_special_address() {
        assert_eq!(standardize_address("0x1"), "0x1");
        assert_eq!(standardize_address("0x01"), "0x1");
        assert_eq!(standardize_address("0x001"), "0x1");
        assert_eq!(standardize_address("0x000000001"), "0x1");
        assert_eq!(standardize_address("0xf"), "0xf");
        assert_eq!(standardize_address("0x0f"), "0xf");
        assert_eq!(
            standardize_address(
                "0x0000000000000000000000000000000000000000000000000000000000000001"
            ),
            "0x1"
        );

        assert_eq!(standardize_address("1"), "0x1");
        assert_eq!(
            standardize_address("0000000000000000000000000000000000000000000000000000000000000001"),
            "0x1"
        );
    }
```

**File:** third_party/move/move-core/types/src/account_address.rs (L101-108)
```rust
    pub fn to_standard_string(&self) -> String {
        let suffix = if self.is_special() {
            self.short_str_lossless()
        } else {
            self.to_canonical_string()
        };
        format!("0x{}", suffix)
    }
```

**File:** third_party/move/move-core/types/src/account_address.rs (L132-145)
```rust
    pub fn to_canonical_string(&self) -> String {
        hex::encode(self.0)
    }

    /// NOTE: For the purposes of displaying an address, using it in a response, or
    /// storing it at rest as a string, use `to_standard_string`.
    pub fn short_str_lossless(&self) -> String {
        let hex_str = hex::encode(self.0).trim_start_matches('0').to_string();
        if hex_str.is_empty() {
            "0".to_string()
        } else {
            hex_str
        }
    }
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/filters/user_transaction.rs (L38-45)
```rust
impl UserTransactionFilter {
    fn get_standardized_sender(&self) -> &Option<String> {
        self.standardized_sender.get_or_init(|| {
            self.sender
                .clone()
                .map(|address| standardize_address(&address))
        })
    }
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/filters/user_transaction.rs (L83-98)
```rust
    fn matches(&self, txn: &Transaction) -> bool {
        let user_request = if let Some(TxnData::User(u)) = txn.txn_data.as_ref() {
            if let Some(user_request) = u.request.as_ref() {
                user_request
            } else {
                return false;
            }
        } else {
            return false;
        };

        if let Some(sender_filter) = self.get_standardized_sender() {
            if &standardize_address(&user_request.sender) != sender_filter {
                return false;
            }
        }
```
