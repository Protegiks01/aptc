# Audit Report

## Title
Race Condition in Round Advancement Causes Stale Vote Transmission and State Inconsistency

## Summary
A race condition exists in the consensus layer where `current_round` advances and clears `vote_sent` during an async operation, but the ongoing vote creation process completes and broadcasts a vote for the previous round. This results in the node sending a stale vote to the network while `vote_sent()` incorrectly returns `None`, creating state inconsistency between `RoundState` and actual network behavior.

## Finding Description

The vulnerability occurs in the interaction between `RoundState.process_certificates()` and `RoundManager.vote_block()` during asynchronous block execution.

**The Attack Sequence:**

1. Node is in round N and receives a proposal for round N
2. `process_verified_proposal()` calls `create_vote()` which calls `vote_block()`
3. `vote_block()` calls `insert_block().await` to execute the block [1](#0-0) 
4. During this await, the async runtime processes another event (e.g., sync message with QC for round N)
5. That event triggers `process_certificates()` which calls `round_state.process_certificates()` [2](#0-1) 
6. `round_state.process_certificates()` advances `current_round` to N+1 and immediately clears `vote_sent = None` [3](#0-2) 
7. Control returns to `vote_block()`, which checks if `vote_sent().is_none()` [4](#0-3) 
8. The check **passes** because `vote_sent` was just cleared, so `vote_block()` proceeds to create a vote for the round N block
9. The vote is successfully created and returned to `process_verified_proposal()`
10. `record_vote()` is called, but it checks if `vote.round() == current_round` (N == N+1) [5](#0-4) 
11. The check **fails**, so `vote_sent` remains `None` and the vote is NOT recorded
12. Despite this failure, the vote is broadcast to the network [6](#0-5) 

**Result:** The node broadcasts a vote for round N to the network, but locally:
- `round_state.current_round = N+1`
- `round_state.vote_sent = None`
- `vote_sent()` returns `None` despite having sent a vote

This violates the **State Consistency** invariant that requires internal state to accurately reflect network actions.

## Impact Explanation

This is a **Medium Severity** vulnerability that causes "State inconsistencies requiring intervention" as defined in the Aptos bug bounty program.

**Specific Impacts:**

1. **State Inconsistency:** `RoundState` believes no vote was sent (`vote_sent = None`), but a vote was broadcast to the network
2. **Vote Tracking Failure:** The `vote_sent()` function incorrectly returns `None`, misleading any code that relies on this to determine voting status
3. **Timeout Handling Issues:** When `process_local_timeout()` calls `vote_sent()` to check if a vote was already sent, it will incorrectly conclude no vote was sent and may generate duplicate timeout votes [7](#0-6) 
4. **Audit Trail Corruption:** The node's understanding of its own voting behavior is incorrect, complicating debugging and monitoring

While SafetyRules prevents actual double-voting in the same round (maintaining consensus safety), the state inconsistency can cause:
- Confusion in network protocol handling
- Incorrect timeout behavior
- Difficulty diagnosing consensus issues
- Potential for escalation if combined with other bugs

## Likelihood Explanation

**Likelihood: Medium to High**

This race condition can occur naturally during normal network operation:

1. **Trigger Frequency:** Happens when a QC or sync message arrives during the block execution phase (between starting `insert_block()` and checking `vote_sent()`)
2. **Block Execution Duration:** Block execution involves state computation and can take significant time, creating a wide window for the race
3. **Network Timing:** High network activity increases the probability of receiving certificates during block execution
4. **No Special Privileges Required:** Any validator node can experience this during normal consensus operation
5. **Deterministic Once Triggered:** Once the timing conditions align, the vulnerability deterministically produces the inconsistent state

The vulnerability is not intentionally exploitable by an attacker (it's a timing-dependent race), but it can occur frequently enough in production to cause operational issues.

## Recommendation

**Fix: Check round consistency after async operations and before voting**

Add a round consistency check after `insert_block()` returns to ensure the round hasn't advanced:

```rust
async fn vote_block(&mut self, proposed_block: Block) -> anyhow::Result<Vote> {
    let block_round = proposed_block.round();
    let block_arc = self
        .block_store
        .insert_block(proposed_block)
        .await
        .context("[RoundManager] Failed to execute_and_insert the block")?;

    // NEW CHECK: Ensure round hasn't advanced during block execution
    ensure!(
        block_round == self.round_state.current_round(),
        "[RoundManager] Round advanced during block execution from {} to {}",
        block_round,
        self.round_state.current_round()
    );

    // Short circuit if already voted.
    ensure!(
        self.round_state.vote_sent().is_none(),
        "[RoundManager] Already vote on this round {}",
        self.round_state.current_round()
    );

    // ... rest of the function
}
```

**Alternative Fix: Improve `record_vote()` to handle round mismatches more explicitly:**

Modify `record_vote()` to return a Result indicating whether the vote was recorded, and abort the broadcast if recording fails:

```rust
pub fn record_vote(&mut self, vote: Vote) -> Result<(), String> {
    if vote.vote_data().proposed().round() == self.current_round {
        self.vote_sent = Some(vote);
        Ok(())
    } else {
        Err(format!(
            "Vote round {} does not match current round {}",
            vote.vote_data().proposed().round(),
            self.current_round
        ))
    }
}
```

Then in `process_verified_proposal()`, check the result before broadcasting.

## Proof of Concept

```rust
// Conceptual PoC demonstrating the race condition
// This would be added to consensus/src/round_manager_tests/mod.rs

#[tokio::test]
async fn test_stale_vote_race_condition() {
    // Setup: Create RoundManager in round N
    let mut round_manager = create_test_round_manager().await;
    assert_eq!(round_manager.round_state().current_round(), 1);
    
    // Step 1: Receive proposal for round 1
    let proposal_round_1 = create_test_proposal(1);
    
    // Step 2: Start processing proposal (vote_block begins)
    let vote_future = round_manager.vote_block(proposal_round_1);
    
    // Step 3: Simulate concurrent QC arrival during block execution
    // This would advance the round to 2 and clear vote_sent
    let qc_round_1 = create_test_qc(1);
    round_manager.process_qc(qc_round_1).await;
    
    // Verify round advanced and vote_sent was cleared
    assert_eq!(round_manager.round_state().current_round(), 2);
    assert!(round_manager.round_state().vote_sent().is_none());
    
    // Step 4: vote_block completes (this is where the bug occurs)
    let vote = vote_future.await.unwrap();
    
    // BUG: Vote was created for round 1, but current_round is 2
    assert_eq!(vote.vote_data().proposed().round(), 1);
    assert_eq!(round_manager.round_state().current_round(), 2);
    
    // BUG: vote_sent() still returns None even though vote was created
    assert!(round_manager.round_state().vote_sent().is_none());
    
    // The vote would be broadcast at this point, creating the inconsistency
}
```

**Notes:**
- The actual PoC would require careful setup of the async test infrastructure to properly simulate the race condition
- Key is demonstrating that `insert_block().await` can yield control, allowing `process_certificates()` to run mid-execution
- The inconsistency is observable: vote for round N sent to network, but `vote_sent()` returns `None` and `current_round = N+1`

### Citations

**File:** consensus/src/round_manager.rs (L1045-1047)
```rust
            let (is_nil_vote, mut timeout_vote) = match self.round_state.vote_sent() {
                Some(vote) if vote.vote_data().proposed().round() == round => {
                    (vote.vote_data().is_for_nil(), vote)
```

**File:** consensus/src/round_manager.rs (L1096-1099)
```rust
        if let Some(new_round_event) = self
            .round_state
            .process_certificates(sync_info, &epoch_state.verifier)
        {
```

**File:** consensus/src/round_manager.rs (L1406-1418)
```rust
        if self.local_config.broadcast_vote {
            info!(self.new_log(LogEvent::Vote), "{}", vote);
            PROPOSAL_VOTE_BROADCASTED.inc();
            self.network.broadcast_vote(vote_msg).await;
        } else {
            let recipient = self
                .proposer_election
                .get_valid_proposer(proposal_round + 1);
            info!(
                self.new_log(LogEvent::Vote).remote_peer(recipient),
                "{}", vote
            );
            self.network.send_vote(vote_msg, vec![recipient]).await;
```

**File:** consensus/src/round_manager.rs (L1501-1505)
```rust
        let block_arc = self
            .block_store
            .insert_block(proposed_block)
            .await
            .context("[RoundManager] Failed to execute_and_insert the block")?;
```

**File:** consensus/src/round_manager.rs (L1508-1512)
```rust
        ensure!(
            self.round_state.vote_sent().is_none(),
            "[RoundManager] Already vote on this round {}",
            self.round_state.current_round()
        );
```

**File:** consensus/src/liveness/round_state.rs (L258-260)
```rust
            self.current_round = new_round;
            self.pending_votes = PendingVotes::new();
            self.vote_sent = None;
```

**File:** consensus/src/liveness/round_state.rs (L318-322)
```rust
    pub fn record_vote(&mut self, vote: Vote) {
        if vote.vote_data().proposed().round() == self.current_round {
            self.vote_sent = Some(vote);
        }
    }
```
