# Audit Report

## Title
DNS Rebinding SSRF Vulnerability in Node Checker Full Node Client

## Summary
The `extract_network_address()` function in the node-checker fn-check-client performs DNS resolution without validating the resolved IP addresses, allowing malicious validator operators to register domains that resolve to internal addresses, leading to Server-Side Request Forgery (SSRF) attacks against the node-checker infrastructure.

## Finding Description

The vulnerability exists in the network address extraction flow where validator fullnode addresses are processed:

**Attack Flow:**

1. **Malicious Address Registration**: A validator operator registers a fullnode address containing a malicious domain via the on-chain `update_network_and_fullnode_addresses()` function. [1](#0-0) 

   The Move function accepts raw bytes for network addresses with no validation of the actual address content - only authentication checks ensure the caller is the stake pool operator.

2. **DNS Resolution Without Validation**: When fn-check-client reads these addresses from on-chain, it calls `extract_network_address()` which invokes `to_socket_addrs()`: [2](#0-1) 

   This performs DNS resolution at check-time (not registration-time), with **no validation** that the resolved IP is not:
   - Loopback addresses (127.0.0.1, ::1)
   - Private IP ranges (10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16)
   - Link-local addresses (169.254.0.0/16) - including cloud metadata services
   - Internal network addresses

3. **Internal IP Exposure**: The resolved IP is extracted and used to construct a URL: [3](#0-2) 

4. **SSRF Execution**: This URL is passed to the Node Health Checker (NHC) as a query parameter: [4](#0-3) 

5. **Malicious Request**: NHC creates an HTTP client and makes actual requests to the internal address: [5](#0-4) 

   The API provider then executes HTTP requests to whatever URL is provided: [6](#0-5) 

**DNS Rebinding Technique:**
1. Attacker registers domain `evil.com` initially resolving to a public IP
2. Registers this domain in their validator's fullnode addresses on-chain
3. Later changes DNS records to resolve to internal targets (127.0.0.1, 192.168.x.x, 169.254.169.254, etc.)
4. When node-checker runs, DNS resolution occurs at that moment, returning the internal address
5. NHC makes HTTP requests to the internal target

## Impact Explanation

**Severity: High to Critical** (depending on deployment environment)

The impact includes:
- **Cloud Metadata Access**: Access to 169.254.169.254 can expose AWS/GCP credentials, potentially compromising cloud infrastructure
- **Internal Network Scanning**: Map internal services and identify vulnerable targets
- **Internal Service Exploitation**: Access internal APIs, databases, or admin panels not exposed to the internet
- **Data Exfiltration**: Retrieve sensitive information from internal services
- **Lateral Movement**: Use as a pivot point to attack other internal systems

While this doesn't directly violate blockchain consensus or cause loss of funds, if the node-checker infrastructure has access to:
- Blockchain deployment credentials
- Validator management systems
- Internal blockchain monitoring/control systems

Then this could escalate to **Critical** severity by enabling attacks on core blockchain infrastructure.

## Likelihood Explanation

**Likelihood: Medium to High**

Requirements for exploitation:
- Attacker must be a validator operator (requires staking and validator setup)
- Attacker must control a domain and its DNS records
- Node-checker must be actively running checks against validator fullnodes

While becoming a validator operator has some barriers, it's an intended feature of the permissionless network. DNS control is trivial for attackers. The main uncertainty is the deployment context of the node-checker and what internal resources it can access.

## Recommendation

Implement IP address validation after DNS resolution to block private and internal addresses:

```rust
pub fn extract_network_address(network_address: &NetworkAddress) -> Result<(Url, u16)> {
    let mut socket_addrs = network_address
        .to_socket_addrs()
        .with_context(|| format!("Failed to parse network address..."))?;
    let socket_addr = socket_addrs
        .next()
        .ok_or_else(|| anyhow::anyhow!("No socket address found"))?;
    
    match socket_addr {
        SocketAddr::V4(addr) => {
            let ip = addr.ip();
            
            // Validate IP is not private/internal
            if ip.is_loopback() || ip.is_private() || ip.is_link_local() {
                return Err(anyhow::anyhow!(
                    "Network address resolves to private/internal IP: {}", ip
                ));
            }
            
            Ok((
                Url::parse(&format!("http://{}", ip))
                    .context("Failed to parse address as URL")?,
                addr.port(),
            ))
        },
        SocketAddr::V6(addr) => {
            // Add similar validation for IPv6 if supported in future
            Err(anyhow::anyhow!("We do not support IPv6 addresses: {}", addr))
        },
    }
}
```

Additionally, consider implementing allow-lists for validator fullnode addresses or requiring IP addresses instead of domains.

## Proof of Concept

**Setup:**
1. Become a validator operator on the network
2. Register domain `malicious.example.com` initially resolving to a public IP (e.g., 1.2.3.4)
3. Update validator fullnode address on-chain:

```rust
// Move transaction calling stake::update_network_and_fullnode_addresses
// with fullnode address containing /dns/malicious.example.com/...
```

4. Wait for address to be committed on-chain
5. Change DNS record for `malicious.example.com` to resolve to internal target:
   - `127.0.0.1` (localhost)
   - `169.254.169.254` (AWS metadata service)
   - `192.168.1.1` (internal router/service)

6. When fn-check-client runs its checks, observe that:
   - DNS resolution returns the internal IP
   - NHC makes HTTP requests to the internal address
   - Attacker can access internal services, metadata endpoints, or exfiltrate data

**Expected Result:** NHC makes HTTP requests to internal addresses, allowing the attacker to probe and access internal infrastructure.

## Notes

This vulnerability requires validator operator privileges (a semi-trusted role), but validator operators should not be able to attack the infrastructure running node health checks. The actual severity depends heavily on the deployment environment of the node-checker and what internal resources it can access. In the worst case where it has access to sensitive blockchain infrastructure or cloud credentials, this becomes a Critical issue.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L955-995)
```text
    public entry fun update_network_and_fullnode_addresses(
        operator: &signer,
        pool_address: address,
        new_network_addresses: vector<u8>,
        new_fullnode_addresses: vector<u8>,
    ) acquires StakePool, ValidatorConfig {
        check_stake_permission(operator);
        assert_reconfig_not_in_progress();
        assert_stake_pool_exists(pool_address);
        let stake_pool = borrow_global_mut<StakePool>(pool_address);
        assert!(signer::address_of(operator) == stake_pool.operator_address, error::unauthenticated(ENOT_OPERATOR));
        assert!(exists<ValidatorConfig>(pool_address), error::not_found(EVALIDATOR_CONFIG));
        let validator_info = borrow_global_mut<ValidatorConfig>(pool_address);
        let old_network_addresses = validator_info.network_addresses;
        validator_info.network_addresses = new_network_addresses;
        let old_fullnode_addresses = validator_info.fullnode_addresses;
        validator_info.fullnode_addresses = new_fullnode_addresses;

        if (std::features::module_event_migration_enabled()) {
            event::emit(
                UpdateNetworkAndFullnodeAddresses {
                    pool_address,
                    old_network_addresses,
                    new_network_addresses,
                    old_fullnode_addresses,
                    new_fullnode_addresses,
                },
            );
        } else {
            event::emit_event(
                &mut stake_pool.update_network_and_fullnode_addresses_events,
                UpdateNetworkAndFullnodeAddressesEvent {
                    pool_address,
                    old_network_addresses,
                    new_network_addresses,
                    old_fullnode_addresses,
                    new_fullnode_addresses,
                },
            );
        };
    }
```

**File:** ecosystem/node-checker/fn-check-client/src/helpers.rs (L13-15)
```rust
    let mut socket_addrs = network_address
        .to_socket_addrs()
        .with_context(|| format!("Failed to parse network address as SocketAddr, this might imply that the domain name doesn't resolve to an IP: {}", network_address))?;
```

**File:** ecosystem/node-checker/fn-check-client/src/helpers.rs (L19-24)
```rust
    match socket_addr {
        SocketAddr::V4(addr) => Ok((
            Url::parse(&format!("http://{}", addr.ip()))
                .context("Failed to parse address as URL")?,
            addr.port(),
        )),
```

**File:** ecosystem/node-checker/fn-check-client/src/check.rs (L198-209)
```rust
        // Build up query params.
        let mut params = HashMap::new();
        params.insert("node_url", node_url.to_string());
        params.insert("api_port", api_port.to_string());
        params.insert("noise_port", noise_port.to_string());
        params.insert(
            "baseline_configuration_name",
            self.nhc_baseline_config_name.clone(),
        );
        if let Some(public_key) = public_key {
            params.insert("public_key", public_key.to_encoded_string().unwrap());
        }
```

**File:** ecosystem/node-checker/src/configuration/node_address.rs (L107-115)
```rust
    pub fn get_api_client(&self, timeout: Duration) -> Result<AptosRestClient> {
        let client = reqwest::ClientBuilder::new()
            .timeout(timeout)
            .cookie_provider(self.cookie_store.clone())
            .build()
            .unwrap();

        Ok(AptosRestClient::from((client, self.get_api_url()?)))
    }
```

**File:** ecosystem/node-checker/src/provider/api_index.rs (L55-64)
```rust
    async fn provide(&self) -> Result<Self::Output, ProviderError> {
        self.output_cache
            .get(
                self.client
                    .get_index()
                    .map_ok(|r| r.into_inner())
                    .map_err(|e| ProviderError::RetryableEndpointError("/", e.into())),
            )
            .await
    }
```
