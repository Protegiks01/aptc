# Audit Report

## Title
Integer Underflow in Cache Worker Causes Denial of Service via Malicious Fullnode

## Summary
The indexer cache worker lacks validation of batch end versions, allowing a malicious fullnode to trigger integer underflow that crashes the worker due to Aptos's overflow-checks=true configuration. The type aliases ChainID and StartingVersion provide no type safety or overflow protection.

## Finding Description

The cache worker defines type aliases without type safety guarantees: [1](#0-0) 

These aliases provide no protection against integer overflow/underflow. When processing batch end signals, the code performs unchecked arithmetic: [2](#0-1) 

If a malicious fullnode sends a BATCH_END message with `end_version < start_version`, the subtraction at line 199 causes integer underflow. Critically, Aptos Core builds with overflow checking enabled in production: [3](#0-2) 

This means integer underflow causes a **panic in production builds**, crashing the cache worker.

**Attack Flow:**
1. Attacker runs a malicious fullnode or compromises an existing one
2. Indexer cache worker connects to the malicious fullnode via gRPC
3. Malicious fullnode sends valid INIT signal and DATA chunks
4. Malicious fullnode sends BATCH_END with `start_version=1000, end_version=500`
5. Worker attempts calculation: `500 - 1000 + 1` → integer underflow
6. Due to `overflow-checks=true`, the worker panics and crashes
7. Indexer becomes unavailable until manual restart
8. Attack can be repeated to cause persistent DoS

The validation check at line 433 cannot prevent this because the panic occurs before that validation executes. [4](#0-3) 

## Impact Explanation

This vulnerability meets **Medium Severity** criteria per the Aptos bug bounty program:
- **API crashes**: The cache worker crashes, causing the indexer API to become unavailable
- **State inconsistencies requiring intervention**: Requires manual restart and investigation
- **Significant protocol violation**: Violates the expected streaming protocol invariants

The impact is limited to indexer availability (no consensus or fund loss), but indexers are critical infrastructure for blockchain data access. Repeated attacks could make the indexer service unreliable.

## Likelihood Explanation

**Likelihood: Medium**

**Attacker Requirements:**
- Run a fullnode (no special privileges needed)
- Convince an indexer operator to connect to it (social engineering or DNS/network attacks)

**Feasibility:**
- Anyone can run a fullnode without validator stake
- Many indexer operators connect to third-party fullnodes
- Attack is trivial to execute once connected (single malformed message)
- Can be automated for persistent DoS

**Mitigating Factors:**
- Requires indexer to connect to attacker's fullnode
- Most production indexers connect to trusted fullnodes
- Easy to detect and blacklist malicious fullnode after first crash

## Recommendation

**Immediate Fix:** Add validation before arithmetic operations to prevent underflow:

```rust
StatusType::BatchEnd => {
    let start_version = status.start_version;
    let end_version = status
        .end_version
        .expect("TransactionsFromNodeResponse status end_version is None");
    
    // Validate end_version >= start_version
    if end_version < start_version {
        bail!(
            "[Indexer Cache] Invalid batch end signal: end_version ({}) < start_version ({})",
            end_version,
            start_version
        );
    }
    
    let num_of_transactions = end_version - start_version + 1;
    Ok(GrpcDataStatus::BatchEnd {
        start_version,
        num_of_transactions,
    })
}
```

**Long-term Improvements:**
1. Use checked arithmetic operations (`checked_sub`, `checked_add`) throughout
2. Replace type aliases with newtype wrappers for compile-time type safety
3. Add comprehensive input validation for all gRPC streaming messages
4. Implement rate limiting and anomaly detection for fullnode connections
5. Add fuzzing tests for gRPC message handling

## Proof of Concept

**Rust PoC (add to worker.rs tests):**

```rust
#[tokio::test]
async fn test_batch_end_underflow_panic() {
    // Create mock response with invalid batch end
    let invalid_response = TransactionsFromNodeResponse {
        response: Some(transactions_from_node_response::Response::Status(
            StreamStatus {
                r#type: StatusType::BatchEnd as i32,
                start_version: 1000,
                end_version: Some(500), // end < start
            },
        )),
        chain_id: 1,
    };
    
    let mut cache_operator = /* setup mock cache operator */;
    let result = process_transactions_from_node_response(
        invalid_response,
        &mut cache_operator,
        std::time::Instant::now(),
    )
    .await;
    
    // With overflow-checks=true, this panics instead of returning Err
    // In production, this crashes the entire worker process
    assert!(result.is_err() || /* panicked */);
}
```

**Attack Simulation Steps:**
1. Set up malicious fullnode with modified `fullnode_data_service.rs`
2. Send INIT with valid starting_version
3. Send DATA chunks with valid transactions
4. Send BATCH_END with `end_version < start_version`
5. Observe cache worker panic and crash

## Notes

This vulnerability exists because the type aliases `ChainID = u32` and `StartingVersion = u64` provide no actual type safety—they are merely documentation. The real issue is the lack of defensive validation combined with Aptos's production overflow checking configuration. While the validation at line 433 would catch logical inconsistencies, it never executes because the panic happens first during the underflow calculation.

The chain_id type confusion (u8 → u32 → u64) does not cause exploitable issues in practice because valid chain IDs are in the range 1-255, but it demonstrates the lack of type safety throughout the codebase.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-cache-worker/src/worker.rs (L26-27)
```rust
type ChainID = u32;
type StartingVersion = u64;
```

**File:** ecosystem/indexer-grpc/indexer-grpc-cache-worker/src/worker.rs (L194-204)
```rust
                StatusType::BatchEnd => {
                    let start_version = status.start_version;
                    let num_of_transactions = status
                        .end_version
                        .expect("TransactionsFromNodeResponse status end_version is None")
                        - start_version
                        + 1;
                    Ok(GrpcDataStatus::BatchEnd {
                        start_version,
                        num_of_transactions,
                    })
```

**File:** ecosystem/indexer-grpc/indexer-grpc-cache-worker/src/worker.rs (L433-443)
```rust
                    if current_version != start_version + num_of_transactions {
                        error!(
                            current_version = current_version,
                            actual_current_version = start_version + num_of_transactions,
                            "[Indexer Cache] End signal received with wrong version."
                        );
                        ERROR_COUNT
                            .with_label_values(&["data_end_wrong_version"])
                            .inc();
                        break;
                    }
```

**File:** Cargo.toml (L921-923)
```text
[profile.release]
debug = true
overflow-checks = true
```
