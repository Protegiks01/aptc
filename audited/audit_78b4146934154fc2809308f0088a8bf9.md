# Audit Report

## Title
Insufficient Cryptographic Validation in DKGResult Consensus-Time Verification Allows Malicious Validators to Waste Block Space

## Summary
The `verify()` method for `DKGResult` validator transactions at consensus-time does not perform cryptographic validation of DKG transcript proofs. It only validates metadata (dealer indices, voting power), allowing malicious validators to include cryptographically invalid transcripts in their proposed blocks. While these fail during VM execution, this enables block space wastage and potential denial-of-service attacks on the randomness beacon.

## Finding Description

The vulnerability exists in the two-phase validation architecture for DKG transcripts:

**Consensus-Time Validation (Insufficient):** [1](#0-0) 

This delegates to `DKGTranscript::verify()`: [2](#0-1) 

Which only calls `verify_transcript_extra()`: [3](#0-2) 

This method **only** validates:
- Dealer indices are valid validator indices
- Voting power threshold is met
- Fast path consistency

It does **NOT** perform cryptographic validation of:
- BLS signature verification on dealer contributions
- Low-degree test on the committed polynomial
- Multi-pairing checks for encryption correctness

**VM-Time Validation (Comprehensive):** [4](#0-3) 

This calls the full cryptographic verification: [5](#0-4) 

Which includes the actual cryptographic PVSS verification: [6](#0-5) 

**Attack Scenario:**

1. Malicious validator creates a `DKGTranscript` with:
   - Valid BCS serialization
   - Valid metadata (correct dealer indices, sufficient voting power representation)
   - **Corrupted cryptographic proofs** (invalid BLS signatures, incorrect polynomial commitments, or malformed ciphertexts)

2. When selected as proposer, includes this in their block proposal

3. During consensus validation: [7](#0-6) 

4. The transcript passes consensus validation (only metadata checked)

5. Block is accepted and ordered by consensus

6. During VM execution, full cryptographic validation fails: [8](#0-7) 

7. Transaction is discarded, DKG session remains incomplete, but validators can retry with valid transcripts in subsequent blocks

## Impact Explanation

**Severity: Medium to High**

This violates critical security invariants:

1. **Consensus Safety Principle**: Consensus should only accept valid data. By accepting cryptographically invalid transcripts, it breaks the defense-in-depth principle where consensus acts as first-line validation.

2. **Block Space Wastage**: Malicious validator can repeatedly include invalid DKG transcripts in their proposals, wasting validator resources and block space.

3. **Randomness Beacon DoS**: While not permanent, repeated invalid proposals can delay DKG completion, temporarily preventing randomness generation for applications depending on on-chain randomness.

4. **Protocol Deviation**: The two-phase validation creates an inconsistency where consensus accepts what VM later rejects, violating the deterministic execution invariant expectations.

However, impact is mitigated by:
- Honest validators perform full verification during aggregation and only submit valid transcripts
- DKG can still complete with valid transcripts in subsequent blocks
- No permanent network damage (recoverable)

This constitutes a **High Severity** issue per Aptos bug bounty criteria as it enables "significant protocol violations" and validator-level attacks on the randomness system.

## Likelihood Explanation

**Likelihood: LOW to MEDIUM**

**Requirements:**
- Attacker must be an active validator in the validator set
- Must be selected as block proposer
- Requires insider access (trusted validator acting maliciously)

**Mitigating Factors:**
- Honest validators verify transcripts cryptographically during aggregation
- Social/economic disincentives for validators to act maliciously
- Can only delay, not permanently break DKG

**However**, this represents a **design flaw** where consensus-time validation is insufficient, violating security best practices regardless of likelihood.

## Recommendation

**Fix: Add Cryptographic Validation at Consensus Time**

Modify `DKGTranscript::verify()` to perform full cryptographic validation:

```rust
// In types/src/dkg/mod.rs
pub(crate) fn verify(&self, verifier: &ValidatorVerifier) -> Result<()> {
    let transcripts: Transcripts = bcs::from_bytes(&self.transcript_bytes)
        .context("Transcripts deserialization failed")?;
    
    // Add full cryptographic verification
    let pub_params = RealDKG::new_public_params_for_verification(
        self.metadata.epoch, 
        verifier
    );
    RealDKG::verify_transcript(&pub_params, &transcripts)
        .context("Transcript cryptographic verification failed")?;
    
    RealDKG::verify_transcript_extra(&transcripts, verifier, true, None)
        .context("Transcript metadata verification failed")?;
    
    Ok(())
}
```

**Alternative (Performance-Conscious):**

If full verification is too expensive at consensus time, add a cryptographic "sanity check" that validates BLS signatures on dealer contributions without the expensive multi-pairing checks:

```rust
pub(crate) fn verify(&self, verifier: &ValidatorVerifier) -> Result<()> {
    let transcripts: Transcripts = bcs::from_bytes(&self.transcript_bytes)
        .context("Transcripts deserialization failed")?;
    
    // Quick cryptographic sanity check (BLS signatures only)
    RealDKG::verify_transcript_signatures(&transcripts, verifier)
        .context("Transcript signature verification failed")?;
    
    RealDKG::verify_transcript_extra(&transcripts, verifier, true, None)
}
```

This provides defense-in-depth while maintaining acceptable consensus performance.

## Proof of Concept

**Note:** This vulnerability requires validator privileges and cannot be demonstrated by an unprivileged attacker. The PoC would require:

1. Setting up a local testnet with malicious validator
2. Modifying validator code to create corrupted DKG transcripts
3. Observing that consensus accepts the proposal but VM rejects it

**Conceptual PoC Steps:**

```rust
// Pseudo-code for malicious validator behavior

// 1. Create valid transcript structure but corrupt cryptographic proofs
let mut valid_transcript = generate_valid_dkg_transcript();
valid_transcript.main.soks[0].signature = corrupt_signature();  // Invalid BLS sig

let dkg_txn = ValidatorTransaction::DKGResult(DKGTranscript {
    metadata: DKGTranscriptMetadata {
        epoch: current_epoch,
        author: validator_address,
    },
    transcript_bytes: bcs::to_bytes(&valid_transcript).unwrap(),
});

// 2. Include in block proposal when selected as proposer
// Passes: consensus validation (only checks metadata)
// Fails: VM execution (cryptographic validation)
// Result: Transaction discarded, block space wasted
```

## Notes

**Critical Observation:** While honest validators perform full cryptographic verification during transcript aggregation [9](#0-8) , a malicious validator can bypass this by directly creating proposals with invalid transcripts.

The vulnerability fundamentally stems from the architectural decision to defer cryptographic validation to the VM layer, creating a window where consensus accepts invalid data. This violates the principle that consensus should be the authoritative validator of all block content.

### Citations

**File:** types/src/validator_txn.rs (L45-52)
```rust
    pub fn verify(&self, verifier: &ValidatorVerifier) -> anyhow::Result<()> {
        match self {
            ValidatorTransaction::DKGResult(dkg_result) => dkg_result
                .verify(verifier)
                .context("DKGResult verification failed"),
            ValidatorTransaction::ObservedJWKUpdate(_) => Ok(()),
        }
    }
```

**File:** types/src/dkg/mod.rs (L83-88)
```rust
    pub(crate) fn verify(&self, verifier: &ValidatorVerifier) -> Result<()> {
        let transcripts: Transcripts = bcs::from_bytes(&self.transcript_bytes)
            .context("Transcripts deserialization failed")?;
        RealDKG::verify_transcript_extra(&transcripts, verifier, true, None)
    }
}
```

**File:** types/src/dkg/real_dkg/mod.rs (L295-329)
```rust
    fn verify_transcript_extra(
        trx: &Self::Transcript,
        verifier: &ValidatorVerifier,
        checks_voting_power: bool,
        ensures_single_dealer: Option<AccountAddress>,
    ) -> anyhow::Result<()> {
        let all_validator_addrs = verifier.get_ordered_account_addresses();
        let main_trx_dealers = trx.main.get_dealers();
        let mut dealer_set = HashSet::with_capacity(main_trx_dealers.len());
        for dealer in main_trx_dealers.iter() {
            if let Some(dealer_addr) = all_validator_addrs.get(dealer.id) {
                dealer_set.insert(*dealer_addr);
            } else {
                bail!("invalid dealer idx");
            }
        }
        ensure!(main_trx_dealers.len() == dealer_set.len());
        if ensures_single_dealer.is_some() {
            let expected_dealer_set: HashSet<AccountAddress> =
                ensures_single_dealer.into_iter().collect();
            ensure!(expected_dealer_set == dealer_set);
        }

        if checks_voting_power {
            verifier
                .check_voting_power(dealer_set.iter(), true)
                .context("not enough power")?;
        }

        if let Some(fast_trx) = &trx.fast {
            ensure!(fast_trx.get_dealers() == main_trx_dealers);
            ensure!(trx.main.get_dealt_public_key() == fast_trx.get_dealt_public_key());
        }
        Ok(())
    }
```

**File:** types/src/dkg/real_dkg/mod.rs (L332-401)
```rust
    fn verify_transcript(
        params: &Self::PublicParams,
        trx: &Self::Transcript,
    ) -> anyhow::Result<()> {
        // Verify dealer indices are valid.
        let dealers = trx
            .main
            .get_dealers()
            .iter()
            .map(|player| player.id)
            .collect::<Vec<usize>>();
        let num_validators = params.session_metadata.dealer_validator_set.len();
        ensure!(
            dealers.iter().all(|id| *id < num_validators),
            "real_dkg::verify_transcript failed with invalid dealer index."
        );

        let all_eks = params.pvss_config.eks.clone();

        let addresses = params.verifier.get_ordered_account_addresses();
        let dealers_addresses = dealers
            .iter()
            .filter_map(|&pos| addresses.get(pos))
            .cloned()
            .collect::<Vec<_>>();

        let spks = dealers_addresses
            .iter()
            .filter_map(|author| params.verifier.get_public_key(author))
            .collect::<Vec<_>>();

        let aux = dealers_addresses
            .iter()
            .map(|address| (params.pvss_config.epoch, address))
            .collect::<Vec<_>>();

        trx.main.verify(
            &params.pvss_config.wconfig,
            &params.pvss_config.pp,
            &spks,
            &all_eks,
            &aux,
        )?;

        // Verify fast path is present if and only if fast_wconfig is present.
        ensure!(
            trx.fast.is_some() == params.pvss_config.fast_wconfig.is_some(),
            "real_dkg::verify_transcript failed with mismatched fast path flag in trx and params."
        );

        if let Some(fast_trx) = trx.fast.as_ref() {
            let fast_dealers = fast_trx
                .get_dealers()
                .iter()
                .map(|player| player.id)
                .collect::<Vec<usize>>();
            ensure!(
                dealers == fast_dealers,
                "real_dkg::verify_transcript failed with inconsistent dealer index."
            );
        }

        if let (Some(fast_trx), Some(fast_wconfig)) =
            (trx.fast.as_ref(), params.pvss_config.fast_wconfig.as_ref())
        {
            fast_trx.verify(fast_wconfig, &params.pvss_config.pp, &spks, &all_eks, &aux)?;
        }

        Ok(())
    }
```

**File:** aptos-move/aptos-vm/src/validator_txns/dkg.rs (L68-77)
```rust
            Err(Expected(failure)) => {
                // Pretend we are inside Move, and expected failures are like Move aborts.
                Ok((
                    VMStatus::MoveAbort {
                        location: AbortLocation::Script,
                        code: failure as u64,
                        message: None,
                    },
                    VMOutput::empty_with_status(TransactionStatus::Discard(StatusCode::ABORTED)),
                ))
```

**File:** aptos-move/aptos-vm/src/validator_txns/dkg.rs (L111-112)
```rust
        DefaultDKG::verify_transcript(&pub_params, &transcript)
            .map_err(|_| Expected(TranscriptVerificationFailed))?;
```

**File:** crates/aptos-dkg/src/pvss/das/weighted_protocol.rs (L280-377)
```rust
    fn verify<A: Serialize + Clone>(
        &self,
        sc: &<Self as traits::Transcript>::SecretSharingConfig,
        pp: &Self::PublicParameters,
        spks: &[Self::SigningPubKey],
        eks: &[Self::EncryptPubKey],
        auxs: &[A],
    ) -> anyhow::Result<()> {
        self.check_sizes(sc)?;
        let n = sc.get_total_num_players();
        if eks.len() != n {
            bail!("Expected {} encryption keys, but got {}", n, eks.len());
        }
        let W = sc.get_total_weight();

        // Deriving challenges by flipping coins: less complex to implement & less likely to get wrong. Creates bad RNG risks but we deem that acceptable.
        let mut rng = rand::thread_rng();
        let extra = random_scalars(2 + W * 3, &mut rng);

        let sok_vrfy_challenge = &extra[W * 3 + 1];
        let g_2 = pp.get_commitment_base();
        let g_1 = pp.get_encryption_public_params().pubkey_base();
        batch_verify_soks::<G1Projective, A>(
            self.soks.as_slice(),
            g_1,
            &self.V[W],
            spks,
            auxs,
            sok_vrfy_challenge,
        )?;

        let ldt = LowDegreeTest::random(
            &mut rng,
            sc.get_threshold_weight(),
            W + 1,
            true,
            sc.get_batch_evaluation_domain(),
        );
        ldt.low_degree_test_on_g1(&self.V)?;

        //
        // Correctness of encryptions check
        //

        let alphas_betas_and_gammas = &extra[0..W * 3 + 1];
        let (alphas_and_betas, gammas) = alphas_betas_and_gammas.split_at(2 * W + 1);
        let (alphas, betas) = alphas_and_betas.split_at(W + 1);
        assert_eq!(alphas.len(), W + 1);
        assert_eq!(betas.len(), W);
        assert_eq!(gammas.len(), W);

        let lc_VR_hat = G2Projective::multi_exp_iter(
            self.V_hat.iter().chain(self.R_hat.iter()),
            alphas_and_betas.iter(),
        );
        let lc_VRC = G1Projective::multi_exp_iter(
            self.V.iter().chain(self.R.iter()).chain(self.C.iter()),
            alphas_betas_and_gammas.iter(),
        );
        let lc_V_hat = G2Projective::multi_exp_iter(self.V_hat.iter().take(W), gammas.iter());
        let mut lc_R_hat = Vec::with_capacity(n);

        for i in 0..n {
            let p = sc.get_player(i);
            let weight = sc.get_player_weight(&p);
            let s_i = sc.get_player_starting_index(&p);

            lc_R_hat.push(g2_multi_exp(
                &self.R_hat[s_i..s_i + weight],
                &gammas[s_i..s_i + weight],
            ));
        }

        let h = pp.get_encryption_public_params().message_base();
        let g_2_neg = g_2.neg();
        let eks = eks
            .iter()
            .map(Into::<G1Projective>::into)
            .collect::<Vec<G1Projective>>();
        // The vector of left-hand-side ($\mathbb{G}_2$) inputs to each pairing in the multi-pairing.
        let lhs = [g_1, &lc_VRC, h].into_iter().chain(&eks);
        // The vector of right-hand-side ($\mathbb{G}_2$) inputs to each pairing in the multi-pairing.
        let rhs = [&lc_VR_hat, &g_2_neg, &lc_V_hat]
            .into_iter()
            .chain(&lc_R_hat);

        let res = multi_pairing(lhs, rhs);
        if res != Gt::identity() {
            bail!(
                "Expected zero during multi-pairing check for {} {}, but got {}",
                sc,
                <Self as traits::Transcript>::scheme_name(),
                res
            );
        }

        return Ok(());
    }
```

**File:** consensus/src/round_manager.rs (L1126-1137)
```rust
        if let Some(vtxns) = proposal.validator_txns() {
            for vtxn in vtxns {
                let vtxn_type_name = vtxn.type_name();
                ensure!(
                    is_vtxn_expected(&self.randomness_config, &self.jwk_consensus_config, vtxn),
                    "unexpected validator txn: {:?}",
                    vtxn_type_name
                );
                vtxn.verify(self.epoch_state.verifier.as_ref())
                    .context(format!("{} verify failed", vtxn_type_name))?;
            }
        }
```

**File:** dkg/src/transcript_aggregation/mod.rs (L96-101)
```rust
        S::verify_transcript_extra(&transcript, &self.epoch_state.verifier, false, Some(sender))
            .context("extra verification failed")?;

        S::verify_transcript(&self.dkg_pub_params, &transcript).map_err(|e| {
            anyhow!("[DKG] adding peer transcript failed with trx verification failure: {e}")
        })?;
```
