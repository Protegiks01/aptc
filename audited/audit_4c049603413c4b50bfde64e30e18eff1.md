# Audit Report

## Title
Incomplete Type Argument Validation in View Function Argument Checking Allows Capability Types in Phantom Parameters

## Summary
The `is_valid_txn_arg` function in `transaction_arg_validation.rs` does not recursively validate type arguments of instantiated structs, allowing disallowed types like `signer`, references, and other capabilities to be passed as phantom type parameters to view functions, bypassing the intended type safety restrictions.

## Finding Description

The validation function `is_valid_txn_arg` is designed to ensure only safe types can be passed as transaction arguments. It explicitly disallows `Signer`, `Reference`, `MutableReference`, `TyParam`, and `Function` types. [1](#0-0) 

However, when validating `Struct` and `StructInstantiation` types, the function only checks if the struct name exists in the `allowed_structs` whitelist, without recursively validating the type arguments: [2](#0-1) 

In contrast, `Vector` types are properly validated recursively: [3](#0-2) 

The `Object` struct is defined with a phantom type parameter that has no ability constraints: [4](#0-3) 

`Object` is included in the allowed structs list for view functions: [5](#0-4) 

**Attack Path:**
1. Attacker calls a view function accepting `Object<T>` where `T` has no ability constraints
2. Attacker provides `Object<signer>` or `Object<&mut SomeResource>` as the type argument
3. `is_valid_txn_arg(Object<signer>)` checks only if "Object" is in `allowed_structs` â†’ passes
4. The validation does not recursively check if `signer` itself is a valid transaction argument type
5. Type passes validation despite containing a normally-disallowed capability type

The validation occurs in `validate_view_function` which calls `construct_args`: [6](#0-5) 

Phantom type parameters are explicitly filtered out when computing polymorphic abilities, meaning they don't affect the runtime representation: [7](#0-6) 

## Impact Explanation

**Severity: Medium**

While this is a clear validation bypass, the actual security impact is limited because:

1. **No Direct Exploitation Path**: Phantom type parameters are compile-time constructs that don't exist at runtime. Move lacks runtime type reflection, so the phantom type cannot be extracted or used to gain actual capabilities.

2. **Ability Constraints Still Enforced**: When `LoadedFunction` is instantiated, type arguments are validated against the function's type parameter ability constraints via `verify_ty_arg_abilities`. [8](#0-7) 

3. **Defense-in-Depth Violation**: This represents an inconsistency in the security model where types explicitly marked as invalid transaction arguments can bypass validation through phantom parameters.

4. **Potential for Future Exploits**: If Move framework code makes assumptions about valid type arguments being restricted to safe types, this could enable future vulnerabilities.

This qualifies as **Medium severity** under "State inconsistencies requiring intervention" as it violates the intended type safety invariants but doesn't directly lead to funds loss or consensus violations.

## Likelihood Explanation

**Likelihood: High**

- **Ease of Exploitation**: Trivial - any user can call a view function with `Object<signer>` as a type argument
- **No Special Privileges Required**: No validator access or special permissions needed
- **Currently Exploitable**: The vulnerability exists in current code and can be triggered immediately
- **Limited Impact**: While easy to trigger, actual security harm is constrained by Move's design

## Recommendation

Modify `is_valid_txn_arg` to recursively validate type arguments of instantiated structs, similar to how `Vector` types are validated:

```rust
Struct { .. } => {
    // Check struct is allowed (existing logic)
    runtime_environment.get_struct_name(ty)...
},
StructInstantiation { def, ty_args } => {
    // Check struct is allowed
    if !runtime_environment.get_struct_name(ty)... {
        return false;
    }
    // NEW: Recursively validate type arguments
    ty_args.iter().all(|ty_arg| {
        is_valid_txn_arg(runtime_environment, ty_arg, allowed_structs)
    })
},
```

Note: This requires distinguishing `Struct` from `StructInstantiation` in the match pattern rather than treating them identically.

## Proof of Concept

```move
#[test_only]
module test::phantom_bypass {
    use aptos_framework::object::Object;
    use std::signer;

    #[view]
    public fun vulnerable_view<T>(obj: Object<T>): address {
        // Function accepts any Object<T> with no constraints on T
        object::object_address(&obj)
    }
    
    #[test]
    fun test_signer_phantom_bypass() {
        // This should fail validation but currently passes
        // Call view function with Object<signer> as type argument
        // The validation checks only "Object" is allowed, not "signer"
        
        // In practice, the call would be:
        // AptosVM::execute_view_function(..., type_args: vec![TypeTag::Signer], ...)
        // This bypasses the normal restriction that Signer cannot be a transaction argument
    }
}
```

## Notes

The fundamental issue is that the validation treats all struct instantiations uniformly without distinguishing between phantom and non-phantom type parameters. While non-phantom parameters are implicitly validated during BCS deserialization (as their values must be constructed), phantom parameters are never validated because they don't exist in the serialization format. This creates an asymmetry where the type system allows types that the validation explicitly prohibits.

### Citations

**File:** aptos-move/aptos-vm/src/verifier/transaction_arg_validation.rs (L63-66)
```rust
        ("0x1::object::Object", FunctionId {
            module_id: ModuleId::new(AccountAddress::ONE, Identifier::from(ident_str!("object"))),
            func_name: ident_str!("address_to_object"),
        }),
```

**File:** aptos-move/aptos-vm/src/verifier/transaction_arg_validation.rs (L208-208)
```rust
        Vector(inner) => is_valid_txn_arg(runtime_environment, inner, allowed_structs),
```

**File:** aptos-move/aptos-vm/src/verifier/transaction_arg_validation.rs (L209-223)
```rust
        Struct { .. } | StructInstantiation { .. } => {
            // Note: Original behavior was to return false even if the module loading fails (e.g.,
            //       if struct does not exist. This preserves it.
            runtime_environment
                .get_struct_name(ty)
                .ok()
                .flatten()
                .is_some_and(|(module_id, identifier)| {
                    allowed_structs.contains_key(&format!(
                        "{}::{}",
                        module_id.short_str_lossless(),
                        identifier
                    ))
                })
        },
```

**File:** aptos-move/aptos-vm/src/verifier/transaction_arg_validation.rs (L224-224)
```rust
        Signer | Reference(_) | MutableReference(_) | TyParam(_) | Function { .. } => false,
```

**File:** aptos-move/framework/aptos-framework/sources/object.move (L129-131)
```text
    struct Object<phantom T> has copy, drop, store {
        inner: address,
    }
```

**File:** aptos-move/aptos-vm/src/verifier/view_function.rs (L64-91)
```rust
    let result = if loader.is_lazy_loading_enabled() {
        transaction_arg_validation::construct_args(
            session,
            loader,
            gas_meter,
            traversal_context,
            func.param_tys(),
            args,
            func.ty_args(),
            allowed_structs,
            true,
        )
    } else {
        let traversal_storage = TraversalStorage::new();
        transaction_arg_validation::construct_args(
            session,
            loader,
            // No metering with eager loading.
            &mut UnmeteredGasMeter,
            &mut TraversalContext::new(&traversal_storage),
            func.param_tys(),
            args,
            func.ty_args(),
            allowed_structs,
            true,
        )
    };
    result.map_err(|e| PartialVMError::new(e.status_code()))
```

**File:** third_party/move/move-core/types/src/ability.rs (L235-238)
```rust
        let abs = type_arguments
            .zip(declared_phantom_parameters)
            .filter(|(_, is_phantom)| !is_phantom)
            .map(|(ty_arg_abilities, _)| {
```

**File:** third_party/move/move-vm/runtime/src/storage/loader/traits.rs (L159-160)
```rust
        Type::verify_ty_arg_abilities(function.ty_param_abilities(), &ty_args)
            .map_err(|e| e.finish(Location::Module(module.self_id().clone())))?;
```
