# Audit Report

## Title
Indexer Panic Due to Missing Table Data When Table Indexer is Disabled

## Summary
The stake processor indexer panics and crashes completely when processing delegation pool transactions on nodes where the table indexer is disabled. This occurs because the code unconditionally unwraps an optional `data` field from `WriteTableItem` that is only populated when the table indexer is enabled.

## Finding Description
The stake processor's delegation balance tracking code assumes that `WriteTableItem.data` is always present, but this field is explicitly optional and only populated when the table indexer is enabled on the node. [1](#0-0) 

The table indexer is disabled by default: [2](#0-1) 

When processing delegation pool transactions, the code path is:

1. `StakeTransactionProcessor::process_transactions()` calls `CurrentDelegatorBalance::from_transaction()` with `.unwrap()`: [3](#0-2) 

2. `CurrentDelegatorBalance::from_transaction()` calls `get_inactive_share_to_pool_mapping()` with `.unwrap()`: [4](#0-3) 

3. `get_inactive_share_to_pool_mapping()` calls `get_inactive_pool_metadata_from_write_table_item()`: [5](#0-4) 

4. `get_inactive_pool_metadata_from_write_table_item()` unconditionally unwraps the optional `data` field: [6](#0-5) 

When `write_table_item.data` is `None` (because table indexer is disabled), the unwrap on line 152 causes a panic. This panic propagates through the processor and crashes the entire indexer: [7](#0-6) 

The indexer completely stops processing transactions and becomes unavailable until manually restarted with correct configuration.

## Impact Explanation
This qualifies as **Medium Severity** according to the Aptos bug bounty criteria:
- Causes complete loss of indexer availability, requiring manual intervention
- Results in state inconsistencies as the indexer stops tracking delegation balances
- Does not affect consensus, validators, or on-chain state (only off-chain indexer)
- Affects critical infrastructure that dApps and explorers depend on for delegation pool data

The issue could potentially qualify as **High Severity** under "API crashes" since the indexer provides APIs that become completely unavailable. However, since it only affects optional infrastructure and not core blockchain operations, Medium severity is more appropriate.

## Likelihood Explanation
**High likelihood** of occurrence:
- The table indexer is disabled by default in node configurations
- No validation exists to prevent running the stake processor without table indexer enabled
- Any delegation pool transaction (add stake, unlock stake, etc.) triggers the code path
- No privileged access required - normal user transactions cause the crash
- No attacker action needed - happens during routine operation with default configuration

## Recommendation
Implement defensive checks for the optional `data` field and provide clear error messages about configuration requirements:

```rust
pub fn get_inactive_pool_metadata_from_write_table_item(
    write_table_item: &WriteTableItem,
    txn_version: i64,
) -> anyhow::Result<Option<PoolBalanceMetadata>> {
    let table_item_data = write_table_item.data.as_ref()
        .context(format!(
            "WriteTableItem.data is None at version {}. The table indexer must be enabled \
             (set indexer_table_info.table_info_service_mode to IndexingOnly or Backup/Restore) \
             to run the stake processor.",
            txn_version
        ))?;

    if let Some(StakeTableItem::Pool(inner)) = StakeTableItem::from_table_item_type(
        table_item_data.value_type.as_str(),
        &table_item_data.value,
        txn_version,
    )? {
        // ... rest of implementation
    }
}
```

Additionally, add startup validation in the stake processor to verify table indexer is enabled before processing begins.

## Proof of Concept

**Configuration Setup:**
1. Configure a fullnode with the stake processor indexer enabled
2. Ensure table indexer is disabled (default configuration): `indexer_table_info.table_info_service_mode = Disabled`
3. Start the indexer

**Trigger the Panic:**
1. Submit any delegation pool transaction (e.g., `delegation_pool::add_stake()`)
2. The transaction gets included in a block
3. The indexer attempts to process it
4. Panic occurs at `delegator_pools.rs:152` when unwrapping `None`
5. Entire indexer crashes and stops processing

**Verification:**
Check indexer logs - you will see a panic message indicating unwrap failed on a None value, followed by indexer termination. The indexer will not resume processing until manually restarted with corrected configuration.

## Notes
- Similar vulnerable patterns exist in `move_tables.rs` at lines 66, 67, 74, 75 which should also be fixed
- The issue affects all nodes running the stake processor with default configuration
- Workaround: Enable table indexer by setting `table_info_service_mode` to `IndexingOnly` in node configuration

### Citations

**File:** api/types/src/transaction.rs (L1183-1186)
```rust
    // This is optional, and only possible to populate if the table indexer is enabled for this node
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub data: Option<DecodedTableData>,
```

**File:** config/src/config/indexer_table_info_config.rs (L41-48)
```rust
impl Default for IndexerTableInfoConfig {
    fn default() -> Self {
        Self {
            parser_task_count: DEFAULT_PARSER_TASK_COUNT,
            parser_batch_size: DEFAULT_PARSER_BATCH_SIZE,
            table_info_service_mode: TableInfoServiceMode::Disabled,
        }
    }
```

**File:** crates/indexer/src/processors/stake_processor.rs (L346-349)
```rust
            // Add delegator balances
            let delegator_balances =
                CurrentDelegatorBalance::from_transaction(txn, &mut conn).unwrap();
            all_delegator_balances.extend(delegator_balances);
```

**File:** crates/indexer/src/models/stake_models/delegator_balances.rs (L281-296)
```rust
    pub fn get_inactive_share_to_pool_mapping(
        write_table_item: &APIWriteTableItem,
        txn_version: i64,
    ) -> anyhow::Result<Option<ShareToPoolMapping>> {
        if let Some(balance) = DelegatorPool::get_inactive_pool_metadata_from_write_table_item(
            write_table_item,
            txn_version,
        )? {
            Ok(Some(HashMap::from([(
                balance.shares_table_handle.clone(),
                balance,
            )])))
        } else {
            Ok(None)
        }
    }
```

**File:** crates/indexer/src/models/stake_models/delegator_balances.rs (L344-348)
```rust
                    if let Some(map) =
                        Self::get_inactive_share_to_pool_mapping(table_item, txn_version).unwrap()
                    {
                        inactive_share_to_pool.extend(map);
                    }
```

**File:** crates/indexer/src/models/stake_models/delegator_pools.rs (L148-172)
```rust
    pub fn get_inactive_pool_metadata_from_write_table_item(
        write_table_item: &WriteTableItem,
        txn_version: i64,
    ) -> anyhow::Result<Option<PoolBalanceMetadata>> {
        let table_item_data = write_table_item.data.as_ref().unwrap();

        if let Some(StakeTableItem::Pool(inner)) = StakeTableItem::from_table_item_type(
            table_item_data.value_type.as_str(),
            &table_item_data.value,
            txn_version,
        )? {
            let total_coins = inner.total_coins;
            let total_shares = &inner.total_shares / &inner.scaling_factor;
            Ok(Some(PoolBalanceMetadata {
                transaction_version: txn_version,
                total_coins,
                total_shares,
                scaling_factor: inner.scaling_factor,
                shares_table_handle: inner.shares.inner.get_handle(),
                parent_table_handle: standardize_address(&write_table_item.handle.to_string()),
            }))
        } else {
            Ok(None)
        }
    }
```

**File:** crates/indexer/src/runtime.rs (L216-243)
```rust
        let batches = match futures::future::try_join_all(tasks).await {
            Ok(res) => res,
            Err(err) => panic!("Error processing transaction batches: {:?}", err),
        };

        let mut batch_start_version = u64::MAX;
        let mut batch_end_version = 0;
        let mut num_res = 0;

        for (num_txn, res) in batches {
            let processed_result: ProcessingResult = match res {
                // When the batch is empty b/c we're caught up, continue to next batch
                None => continue,
                Some(Ok(res)) => res,
                Some(Err(tpe)) => {
                    let (err, start_version, end_version, _) = tpe.inner();
                    error!(
                        processor_name = processor_name,
                        start_version = start_version,
                        end_version = end_version,
                        error =? err,
                        "Error processing batch!"
                    );
                    panic!(
                        "Error in '{}' while processing batch: {:?}",
                        processor_name, err
                    );
                },
```
