# Audit Report

## Title
Missing TLS/mTLS Enforcement in Remote Executor Network Communication Exposes Transaction Data to Eavesdropping

## Summary
The `NetworkMessageServiceClient` in Aptos Core's remote executor system establishes unencrypted gRPC connections using plaintext HTTP, allowing network-level attackers to intercept sensitive transaction data during distributed block execution. This affects the execution layer's confidentiality guarantees and could enable front-running attacks.

## Finding Description

The Aptos Core remote executor system supports distributed block execution across multiple executor shards for performance optimization. Communication between the coordinator and remote executor shards uses gRPC via the `NetworkMessageServiceClient`, but **no transport layer security (TLS/mTLS) is enforced**. [1](#0-0) 

The client wrapper explicitly constructs connections using the `http://` scheme (plaintext), and the underlying `tonic::transport::Endpoint` does not configure any TLS certificates or encryption. [2](#0-1) 

The server side similarly lacks TLS configuration, using a plain `Server::builder()` without certificate or key setup.

**Attack Path:**

1. A validator deploys remote executor shards across multiple machines (intended production use case per command-line flags in `executor-service/src/main.rs`) [3](#0-2) 

2. The coordinator sends `ExecuteBlockCommand` messages containing full transaction data via the plaintext gRPC channel [4](#0-3) 

3. These messages contain `SubBlocksForShard<AnalyzedTransaction>`, where each `AnalyzedTransaction` wraps a `SignatureVerifiedTransaction` with complete transaction payloads [5](#0-4) [6](#0-5) 

4. An attacker with network access (compromised router, ISP-level interception, or machine compromise in the same network) captures these plaintext gRPC messages using standard packet sniffing tools

5. The attacker extracts:
   - Sender and recipient addresses
   - Transaction amounts and asset types
   - Smart contract function calls and arguments
   - Gas prices and limits
   - Transaction signatures (though already public after commit)
   - Execution results and state changes (sent back as `RemoteExecutionResult`)

## Impact Explanation

**Critical Severity** per Aptos Bug Bounty criteria:

1. **Information Disclosure**: Exposes complete transaction data before blockchain commitment, violating confidentiality guarantees during the execution phase

2. **Front-Running Opportunities**: An attacker seeing transactions before execution completion could front-run them by:
   - Observing high-value DEX trades and placing competing orders
   - Front-running governance proposals with advance knowledge
   - Extracting MEV (Miner Extractable Value) opportunities

3. **Privacy Violations**: Transactions meant to be private until committed are exposed to network observers

4. **Consensus Security Impact**: While not directly breaking consensus safety, the information asymmetry could be weaponized to manipulate transaction ordering or validator behavior

This qualifies as **Critical** because:
- It enables potential financial loss through front-running attacks (Loss of Funds criterion)
- It violates security properties of the execution layer (Significant protocol violation)
- It affects validator node security when remote executors are deployed

## Likelihood Explanation

**HIGH Likelihood** when:
- Remote executor shards are deployed across different physical machines or cloud regions (the intended use case for performance scaling)
- Network traffic traverses untrusted networks (internet, shared cloud infrastructure)
- An attacker has network access through compromised infrastructure

**MEDIUM Likelihood** when:
- Deployed on isolated private networks with strong perimeter security
- Network segmentation prevents unauthorized packet capture

The feature is **production-ready** with command-line flags in both `executor-service` and `executor-benchmark` binaries, indicating it's designed for real deployment scenarios. [7](#0-6) [8](#0-7) 

## Recommendation

Implement mandatory TLS/mTLS for all remote executor communications:

1. **Add TLS Configuration to GRPCNetworkMessageServiceClientWrapper:**
   - Modify `get_channel()` to accept TLS configuration (certificates, keys)
   - Use `tonic::transport::ClientTlsConfig` with certificate validation
   - Change connection scheme from `http://` to `https://`
   - Implement certificate pinning for mutual authentication

2. **Add TLS Configuration to GRPCNetworkMessageServiceServerWrapper:**
   - Accept TLS certificate and key paths in configuration
   - Use `tonic::transport::ServerTlsConfig` in `Server::builder()`
   - Enforce client certificate validation (mTLS)

3. **Reference Implementation Pattern:**
   The codebase already has TLS implementation examples in the indexer-grpc services that should be followed: [9](#0-8) 

4. **Configuration Updates:**
   - Add certificate/key path parameters to `NetworkController::new()`
   - Update CLI arguments in `main.rs` to require TLS certificates
   - Make TLS mandatory (no opt-out option for production deployments)

5. **Deployment Guidance:**
   - Document certificate generation and rotation procedures
   - Enforce certificate validation in production configurations
   - Consider using a proper PKI or certificate authority

## Proof of Concept

**Network Traffic Capture PoC:**

1. Deploy remote executor shards using the current implementation:
```bash
# Start executor shard 0
./executor-service --shard-id 0 --num-shards 2 \
  --remote-executor-addresses 127.0.0.1:50001 127.0.0.1:50002 \
  --coordinator-address 127.0.0.1:52200

# Start executor shard 1
./executor-service --shard-id 1 --num-shards 2 \
  --remote-executor-addresses 127.0.0.1:50001 127.0.0.1:50002 \
  --coordinator-address 127.0.0.1:52200
```

2. Run executor benchmark with remote executors:
```bash
./executor-benchmark --remote-executor-addresses 127.0.0.1:50001 127.0.0.1:50002 \
  --coordinator-address 127.0.0.1:52200 \
  --num-executor-shards 2
```

3. Capture network traffic with tcpdump/Wireshark:
```bash
sudo tcpdump -i lo -w remote_executor.pcap 'port 50001 or port 50002 or port 52200'
```

4. Analyze captured packets:
   - Filter for gRPC traffic (HTTP/2)
   - Observe plaintext protobuf messages containing transaction data
   - Extract `ExecuteBlockCommand` messages showing full transaction payloads
   - Verify no TLS handshake occurs

**Expected Result:** Complete transaction data including sender addresses, amounts, function arguments, and execution results are visible in plaintext in the packet capture, confirming the vulnerability.

---

## Notes

This vulnerability is particularly concerning because:

1. The remote executor feature appears to be production-ready with comprehensive CLI support, not just experimental code
2. No warnings or TODOs indicate this is a known limitation
3. Other parts of the codebase (indexer-grpc services) correctly implement TLS, showing the pattern exists but wasn't applied here
4. The performance benefits of remote executors incentivize their use in production, increasing exposure
5. The lack of authentication also means any network peer could potentially connect to remote executor shards if network access is obtained

The fix should be mandatory (not optional) as there's no legitimate use case for plaintext transmission of transaction data across network boundaries.

### Citations

**File:** secure/net/src/grpc_network_service/mod.rs (L75-86)
```rust
        Server::builder()
            .timeout(std::time::Duration::from_millis(rpc_timeout_ms))
            .add_service(
                NetworkMessageServiceServer::new(self).max_decoding_message_size(MAX_MESSAGE_SIZE),
            )
            .add_service(reflection_service)
            .serve_with_shutdown(server_addr, async {
                server_shutdown_rx.await.ok();
                info!("Received signal to shutdown server at {:?}", server_addr);
            })
            .await
            .unwrap();
```

**File:** secure/net/src/grpc_network_service/mod.rs (L124-138)
```rust
    pub fn new(rt: &Runtime, remote_addr: SocketAddr) -> Self {
        Self {
            remote_addr: remote_addr.to_string(),
            remote_channel: rt
                .block_on(async { Self::get_channel(format!("http://{}", remote_addr)).await }),
        }
    }

    async fn get_channel(remote_addr: String) -> NetworkMessageServiceClient<Channel> {
        info!("Trying to connect to remote server at {:?}", remote_addr);
        let conn = tonic::transport::Endpoint::new(remote_addr)
            .unwrap()
            .connect_lazy();
        NetworkMessageServiceClient::new(conn).max_decoding_message_size(MAX_MESSAGE_SIZE)
    }
```

**File:** execution/executor-service/src/main.rs (L20-24)
```rust
    #[clap(long, num_args = 1..)]
    pub remote_executor_addresses: Vec<SocketAddr>,

    #[clap(long)]
    pub coordinator_address: SocketAddr,
```

**File:** execution/executor-service/src/remote_executor_client.rs (L195-205)
```rust
            let execution_request = RemoteExecutionRequest::ExecuteBlock(ExecuteBlockCommand {
                sub_blocks,
                concurrency_level: concurrency_level_per_shard,
                onchain_config: onchain_config.clone(),
            });

            senders[shard_id]
                .lock()
                .unwrap()
                .send(Message::new(bcs::to_bytes(&execution_request).unwrap()))
                .unwrap();
```

**File:** execution/executor-service/src/lib.rs (L48-53)
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct ExecuteBlockCommand {
    pub(crate) sub_blocks: SubBlocksForShard<AnalyzedTransaction>,
    pub(crate) concurrency_level: usize,
    pub(crate) onchain_config: BlockExecutorConfigFromOnchain,
}
```

**File:** types/src/transaction/analyzed_transaction.rs (L23-37)
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct AnalyzedTransaction {
    transaction: SignatureVerifiedTransaction,
    /// Set of storage locations that are read by the transaction - this doesn't include location
    /// that are written by the transactions to avoid duplication of locations across read and write sets
    /// This can be accurate or strictly overestimated.
    pub read_hints: Vec<StorageLocation>,
    /// Set of storage locations that are written by the transaction. This can be accurate or strictly
    /// overestimated.
    pub write_hints: Vec<StorageLocation>,
    /// A transaction is predictable if neither the read_hint or the write_hint have wildcards.
    predictable_transaction: bool,
    /// The hash of the transaction - this is cached for performance reasons.
    hash: HashValue,
}
```

**File:** execution/executor-benchmark/src/main.rs (L209-215)
```rust
    /// Gives an option to specify remote shard addresses. If specified, then we expect the number
    /// of remote addresses to be equal to 'num_executor_shards', and one coordinator address
    /// Address is specified as <IP>:<PORT>
    #[clap(long, num_args = 1..)]
    remote_executor_addresses: Option<Vec<SocketAddr>>,
    #[clap(long)]
    coordinator_address: Option<SocketAddr>,
```

**File:** execution/executor-benchmark/src/main.rs (L632-647)
```rust
        remote_executor_client::set_remote_addresses(
            opt.pipeline_opt
                .sharding_opt
                .remote_executor_addresses
                .clone()
                .unwrap(),
        );
        assert_eq!(
            execution_shards,
            remote_executor_client::get_remote_addresses().len(),
            "Number of execution shards ({}) must be equal to the number of remote addresses ({}).",
            execution_shards,
            remote_executor_client::get_remote_addresses().len()
        );
        remote_executor_client::set_coordinator_address(
            opt.pipeline_opt.sharding_opt.coordinator_address.unwrap(),
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service/src/config.rs (L33-39)
```rust
#[serde(deny_unknown_fields)]
pub struct TlsConfig {
    /// The address for the TLS GRPC server to listen on.
    pub data_service_grpc_listen_address: SocketAddr,
    pub cert_path: String,
    pub key_path: String,
}
```
