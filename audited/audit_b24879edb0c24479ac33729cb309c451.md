# Audit Report

## Title
Optimistic Proposals Fail to Track Failed Authors, Undermining Validator Reputation System

## Summary
OptimisticProposal blocks do not track `failed_authors`, causing validator failures to be hidden from the leader reputation system. This allows poorly performing validators to maintain artificially high reputation scores and continue being selected as leaders, degrading network performance and liveness.

## Finding Description

The Aptos consensus protocol uses a reputation-based leader election system where validators who fail to propose blocks receive lower reputation weights, reducing their chances of being selected as future leaders. This accountability mechanism depends on each committed block recording which validators failed to propose in previous rounds via the `failed_authors` field.

However, OptimisticProposal blocks—a performance optimization enabled by default—completely bypass this tracking mechanism: [1](#0-0) 

When optimistic proposals are converted to BlockMetadata for execution, they return an empty `failed_proposer_indices` array: [2](#0-1) 

The validation logic explicitly skips failed_authors checking for optimistic proposals: [3](#0-2) 

Notably, the code comment at line 403 of block_data.rs claims to add "failed_authors" but the implementation doesn't: [4](#0-3) 

**Attack Flow:**

1. Validator A is scheduled to propose in round N but fails (network issue, crash, or malicious behavior)
2. Round N times out, moving to round N+1
3. Validator B proposes an optimistic proposal for round N+1
4. The optimistic proposal is committed with empty `failed_proposer_indices`
5. The NewBlockEvent emitted has no record of Validator A's failure
6. The leader reputation system counts proposals/failures from these events: [5](#0-4) 

7. Validator A's failure is never counted, maintaining their artificially high reputation
8. Validator A continues to be selected as a leader at rates higher than deserved

The reputation heuristic applies penalties based on failure rates: [6](#0-5) 

Without accurate failure tracking, validators exceeding the `failure_threshold_percent` (default 10%) are not properly downweighted, violating the protocol's accountability guarantees.

Optimistic proposals are enabled by default: [7](#0-6) 

## Impact Explanation

This vulnerability constitutes **Medium Severity** per Aptos bug bounty criteria:

- **State inconsistencies requiring intervention**: The leader reputation state becomes inconsistent with actual validator performance, systematically underreporting failures
- **Network performance degradation**: Failed validators continue being selected as leaders, causing additional timeout rounds and reduced throughput
- **Validator accountability failure**: The reputation system's core purpose—penalizing poor performers—is undermined

While this doesn't directly violate consensus safety (Byzantine fault tolerance remains intact), it degrades network liveness and allows suboptimal validators to persist in leadership roles. In a production network with frequent optimistic proposals (the happy path), a significant percentage of validator failures would go unrecorded, systematically biasing leader selection.

## Likelihood Explanation

**High likelihood** of occurrence:

1. **Default configuration**: Optimistic proposals are enabled by default in production configurations
2. **Happy path optimization**: Optimistic proposals are used in consecutive successful rounds, the most common case
3. **Failure scenarios**: Any validator failure followed by an optimistic proposal loses the failure record
4. **No mitigation**: There is no mechanism to retroactively recover failed_authors for committed optimistic proposals

The test suite demonstrates optimistic proposals being used for rounds 2-10 consecutively: [8](#0-7) 

This pattern means that any failure in this sequence would not be tracked.

## Recommendation

**Fix 1: Add failed_authors to OptimisticProposal BlockType**

Modify the `BlockType::OptimisticProposal` to include `failed_authors`:

```rust
// In block_data.rs BlockType enum
OptimisticProposal {
    body: OptBlockBody,
    failed_authors: Vec<(Round, Author)>,
}
```

**Fix 2: Compute failed_authors when processing optimistic proposals**

In `round_manager.rs`, compute failed_authors when converting OptBlockData to Block:

```rust
async fn process_opt_proposal(&mut self, opt_block_data: OptBlockData) -> anyhow::Result<()> {
    // ... existing validation ...
    let hqc = self.block_store.highest_quorum_cert().as_ref().clone();
    
    // Compute failed authors for the gap between HQC and opt proposal
    let failed_authors = self.proposal_generator.compute_failed_authors(
        opt_block_data.round(),
        hqc.certified_block().round(),
        false,
        self.proposer_election.clone(),
    );
    
    let proposal = Block::new_from_opt_with_failed_authors(
        opt_block_data, 
        hqc, 
        failed_authors
    );
    // ... continue processing ...
}
```

**Fix 3: Update new_from_opt implementation**

Ensure `BlockData::new_from_opt` properly stores and returns failed_authors matching the comment at line 403.

## Proof of Concept

The following Rust test demonstrates the vulnerability:

```rust
#[test]
fn test_optimistic_proposal_missing_failed_authors() {
    use aptos_consensus_types::{
        block::Block,
        block_data::{BlockData, BlockType},
        opt_block_data::OptBlockData,
        quorum_cert::QuorumCert,
        common::Payload,
    };
    use aptos_crypto::HashValue;
    use aptos_types::{
        account_address::AccountAddress,
        block_info::BlockInfo,
    };
    
    // Create an optimistic proposal
    let opt_block_data = OptBlockData::new(
        vec![],
        Payload::empty(false, false),
        AccountAddress::random(),
        1,
        5,
        1000,
        BlockInfo::random(3), // parent at round 3
        QuorumCert::dummy_certificate_for_genesis(), // grandparent at round 2
    );
    
    // Convert to Block
    let hqc = QuorumCert::dummy_certificate_for_genesis();
    let block_data = BlockData::new_from_opt(opt_block_data, hqc);
    let block = Block::new_from_opt(opt_block_data_clone, hqc_clone);
    
    // VULNERABILITY: failed_authors should contain entries for rounds 4 (gap)
    // but returns None instead
    assert!(block.block_data().failed_authors().is_none());
    
    // When creating BlockMetadata, failed_proposer_indices will be empty
    let validators = vec![AccountAddress::random(); 10];
    let metadata = block.new_block_metadata(&validators);
    
    // VULNERABILITY: Validator failures in round 4 are lost
    assert_eq!(metadata.failed_proposer_indices().len(), 0);
    
    // Compare with normal proposal which would track failures
    let normal_block_data = BlockData::new_proposal(
        Payload::empty(false, false),
        AccountAddress::random(),
        vec![(4, AccountAddress::random())], // failed author tracked
        5,
        1000,
        hqc_for_normal,
    );
    
    assert!(normal_block_data.failed_authors().is_some());
    assert_eq!(normal_block_data.failed_authors().unwrap().len(), 1);
}
```

This test shows that:
1. OptimisticProposal blocks return `None` for `failed_authors()`
2. Normal proposals track failed_authors correctly
3. The gap in rounds between parent QC and optimistic proposal loses validator failure information
4. BlockMetadata created from optimistic proposals has empty `failed_proposer_indices`

## Notes

This vulnerability represents a design oversight where the optimization for faster block propagation (optimistic proposals) inadvertently disabled a critical accountability mechanism. The comment mismatch at line 403 suggests this was unintentional. The issue is exacerbated by optimistic proposals being enabled by default and used in the common case, meaning a significant fraction of validator failures go untracked in production networks.

### Citations

**File:** consensus/consensus-types/src/block_data.rs (L225-233)
```rust
    pub fn failed_authors(&self) -> Option<&Vec<(Round, Author)>> {
        match &self.block_type {
            BlockType::Proposal { failed_authors, .. }
            | BlockType::NilBlock { failed_authors, .. }
            | BlockType::DAGBlock { failed_authors, .. } => Some(failed_authors),
            BlockType::ProposalExt(p) => Some(p.failed_authors()),
            BlockType::OptimisticProposal(_) | BlockType::Genesis => None,
        }
    }
```

**File:** consensus/consensus-types/src/block_data.rs (L402-419)
```rust
    /// Returns an instance of BlockData by converting the OptBlockData to BlockData
    /// and adding QC and failed_authors
    pub fn new_from_opt(opt_block_data: OptBlockData, quorum_cert: QuorumCert) -> Self {
        let OptBlockData {
            epoch,
            round,
            timestamp_usecs,
            block_body: proposal_body,
            ..
        } = opt_block_data;
        Self {
            epoch,
            round,
            timestamp_usecs,
            quorum_cert,
            block_type: BlockType::OptimisticProposal(proposal_body),
        }
    }
```

**File:** consensus/consensus-types/src/block.rs (L580-594)
```rust
    pub fn new_block_metadata(&self, validators: &[AccountAddress]) -> BlockMetadata {
        BlockMetadata::new(
            self.id(),
            self.epoch(),
            self.round(),
            self.author().unwrap_or(AccountAddress::ZERO),
            self.previous_bitvec().into(),
            // For nil block, we use 0x0 which is convention for nil address in move.
            self.block_data()
                .failed_authors()
                .map_or(vec![], |failed_authors| {
                    Self::failed_authors_to_indices(validators, failed_authors)
                }),
            self.timestamp_usecs(),
        )
```

**File:** consensus/src/round_manager.rs (L1216-1231)
```rust
        if !proposal.is_opt_block() {
            // Validate that failed_authors list is correctly specified in the block.
            let expected_failed_authors = self.proposal_generator.compute_failed_authors(
                proposal.round(),
                proposal.quorum_cert().certified_block().round(),
                false,
                self.proposer_election.clone(),
            );
            ensure!(
                proposal.block_data().failed_authors().is_some_and(|failed_authors| *failed_authors == expected_failed_authors),
                "[RoundManager] Proposal for block {} has invalid failed_authors list {:?}, expected {:?}",
                proposal.round(),
                proposal.block_data().failed_authors(),
                expected_failed_authors,
            );
        }
```

**File:** consensus/src/liveness/leader_reputation.rs (L428-461)
```rust
    pub fn count_failed_proposals(
        &self,
        epoch_to_candidates: &HashMap<u64, Vec<Author>>,
        history: &[NewBlockEvent],
    ) -> HashMap<Author, u32> {
        Self::history_iter(
            history,
            epoch_to_candidates,
            self.proposer_window_size,
            self.reputation_window_from_stale_end,
        )
        .fold(HashMap::new(), |mut map, meta| {
            match Self::indices_to_validators(
                &epoch_to_candidates[&meta.epoch()],
                meta.failed_proposer_indices(),
            ) {
                Ok(failed_proposers) => {
                    for &failed_proposer in failed_proposers {
                        let count = map.entry(failed_proposer).or_insert(0);
                        *count += 1;
                    }
                },
                Err(msg) => {
                    error!(
                        "Failed proposer conversion from indices failed at epoch {}, round {}: {}",
                        meta.epoch(),
                        meta.round(),
                        msg
                    )
                },
            }
            map
        })
    }
```

**File:** consensus/src/liveness/leader_reputation.rs (L521-552)
```rust
impl ReputationHeuristic for ProposerAndVoterHeuristic {
    fn get_weights(
        &self,
        epoch: u64,
        epoch_to_candidates: &HashMap<u64, Vec<Author>>,
        history: &[NewBlockEvent],
    ) -> Vec<u64> {
        assert!(epoch_to_candidates.contains_key(&epoch));

        let (votes, proposals, failed_proposals) =
            self.aggregation
                .get_aggregated_metrics(epoch_to_candidates, history, &self.author);

        epoch_to_candidates[&epoch]
            .iter()
            .map(|author| {
                let cur_votes = *votes.get(author).unwrap_or(&0);
                let cur_proposals = *proposals.get(author).unwrap_or(&0);
                let cur_failed_proposals = *failed_proposals.get(author).unwrap_or(&0);

                if cur_failed_proposals * 100
                    > (cur_proposals + cur_failed_proposals) * self.failure_threshold_percent
                {
                    self.failed_weight
                } else if cur_proposals > 0 || cur_votes > 0 {
                    self.active_weight
                } else {
                    self.inactive_weight
                }
            })
            .collect()
    }
```

**File:** config/src/config/consensus_config.rs (L380-386)
```rust
            enable_pre_commit: true,
            max_pending_rounds_in_commit_vote_cache: 100,
            optimistic_sig_verification: true,
            enable_round_timeout_msg: true,
            enable_optimistic_proposal_rx: true,
            enable_optimistic_proposal_tx: true,
        }
```

**File:** consensus/src/round_manager_tests/opt_proposal_test.rs (L33-84)
```rust
#[test]
fn test_opt_proposal_proposed_no_failures() {
    let runtime = consensus_runtime();
    let mut playground = NetworkPlayground::new(runtime.handle().clone());
    let mut nodes = NodeSetup::create_nodes(
        &mut playground,
        runtime.handle().clone(),
        1,
        None,
        None,
        None,
        Some(config_with_opt_proposal_enabled()),
        None,
        None,
        false,
    );
    let genesis = nodes[0].block_store.ordered_root();

    // Process and vote on a normal proposal for round 1
    process_and_vote_on_proposal(&runtime, &mut nodes, 0, &[], true, Some(0), true, 1, 0, 0);

    let node = &mut nodes[0];
    let mut expected_grandparent_qc = genesis.id();
    for round in 2..10 {
        let opt_proposal_msg = timed_block_on(&runtime, async { node.next_opt_proposal().await });
        assert_eq!(opt_proposal_msg.round(), round);
        assert_eq!(
            opt_proposal_msg
                .block_data()
                .grandparent_qc()
                .certified_block()
                .id(),
            expected_grandparent_qc
        );
        expected_grandparent_qc = opt_proposal_msg.block_data().parent_id();
        // process and vote on the optimistic proposal only
        process_and_vote_opt_proposal(
            &runtime,
            node,
            opt_proposal_msg,
            round,
            round.saturating_sub(2),
            0,
        );
        // process vote to gather QC and enter the next round
        timed_block_on(&runtime, async {
            let vote_msg = node.next_vote().await;
            // Adding vote to form a QC
            node.round_manager.process_vote_msg(vote_msg).await.unwrap();
        });
    }
}
```
