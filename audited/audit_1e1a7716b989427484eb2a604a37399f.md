# Audit Report

## Title
BlockSTM v1 Consensus Violation via Metadata Idempotency Check Bypass in Resource Group Write Validation

## Summary
The `write_metadata()` function in BlockSTM v1 uses metadata equality comparison to determine whether suffix validation is needed after transaction re-execution. When resource group metadata remains unchanged between incarnations but inner resource values differ, the function returns `false`, preventing suffix validation. This allows later transactions that read stale values to commit without revalidation, breaking consensus determinism.

## Finding Description

The vulnerability exists in the interaction between three components:

**1. Metadata Idempotency Check** [1](#0-0) 

The `write_metadata()` function compares only the `StateValueMetadata` (slot_deposit, bytes_deposit, creation_time_usecs) between the new and previous incarnation's writes. It returns `false` when metadata is identical, even if the actual resource group inner values have changed.

**2. Suffix Validation Control** [2](#0-1) 

The return value of `write_metadata()` directly controls the `needs_suffix_validation` flag. When `false`, later transactions are not scheduled for revalidation.

**3. Scheduler Validation Logic** [3](#0-2) 

The scheduler only calls `decrease_validation_idx()` to trigger suffix revalidation when `revalidate_suffix` is `true`. Without this, transactions that have already validated past the current transaction index are not revalidated.

**Attack Scenario:**

1. Transaction T1 (index 5, incarnation 0) writes resource group with metadata M and inner resource {tag A: value 100}
2. Transaction T2 (index 10) reads tag A from T1, observes value 100
3. T2 validates successfully against version (5, 0)
4. Validation index advances past transaction 10
5. T1 is re-executed due to its own read dependencies (incarnation 1)
6. T1 writes resource group with:
   - Same metadata M (identical deposit amounts, creation time)
   - Same tags {A}
   - Different value {tag A: value 200}
7. `write_metadata()` returns `false` because metadata is identical
8. `needs_suffix_validation` remains `false`
9. `finish_execution(5, 1, false)` is called
10. Since validation_idx > 10, T2 is NOT scheduled for revalidation
11. T2 commits with stale value 100 instead of correct value 200

**Broken Invariant:**
This violates the **Deterministic Execution** invariant. Different validators processing the same block could observe different re-execution patterns (due to minor timing differences in parallel execution), leading to some validators having T2 revalidated and others not. This produces different state roots for identical blocks, breaking consensus safety.

**Code Comment Contradiction:** [4](#0-3) 

The comment explicitly states "after a transaction execution changes metadata, suffix validation is guaranteed to be triggered." However, when metadata is unchanged but values differ, this guarantee is violated.

## Impact Explanation

**Severity: CRITICAL (Consensus/Safety Violation)**

This meets the critical severity criteria for the following reasons:

1. **Consensus Safety Violation**: Different validators can produce different state roots for the same block, violating Byzantine Fault Tolerance guarantees
2. **Non-Deterministic Execution**: The outcome depends on parallel execution timing, not deterministic transaction ordering
3. **State Divergence**: Validators can permanently diverge in their view of chain state, potentially requiring a hard fork to resolve
4. **No Byzantine Actors Required**: This occurs through normal transaction execution patterns, not malicious validator behavior

The vulnerability affects the core correctness guarantee of the blockchain - that all honest validators agree on state transitions. This is more severe than fund loss because it threatens the entire network's integrity.

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH**

This vulnerability will occur whenever:

1. A transaction writes to a resource group
2. Gets re-executed (common in BlockSTM during read-dependency resolution)
3. Writes the same metadata but different values on re-execution
4. A later transaction has already validated and read the first incarnation's values

**Factors increasing likelihood:**

- **Common re-execution**: BlockSTM frequently re-executes transactions when read dependencies change
- **Metadata determined by storage accounting**: Deposit amounts and creation times are independent of actual resource values, making metadata collisions realistic
- **Same-size value writes**: If a transaction writes values of the same size on both executions (e.g., updating a counter from 100â†’200), metadata will be identical
- **High transaction throughput**: More parallel transactions increase probability of this race condition

**Factors decreasing likelihood:**

- Only affects BlockSTM v1 (v2 uses push validation with dependency tracking)
- Requires specific timing where later transaction validates before re-execution completes

## Recommendation

**Immediate Fix:** Always trigger suffix validation when writing to resource groups, regardless of metadata changes:

```rust
// In executor.rs, around line 620-627
// Always set needs_suffix_validation for resource group metadata writes
// to ensure later transactions observe consistent values
if versioned_cache.data().write_metadata(
    group_key.clone(),
    idx_to_execute,
    incarnation,
    group_metadata_op,
) {
    needs_suffix_validation = true;
} else {
    // CRITICAL FIX: Even when metadata unchanged, inner values may differ
    // between incarnations. Always trigger suffix validation for safety.
    needs_suffix_validation = true;
}
```

**Better Fix:** Track value changes separately from metadata:

```rust
// Modify write_metadata() to return a tuple
pub fn write_metadata(
    &self,
    key: K,
    txn_idx: TxnIndex,
    incarnation: Incarnation,
    data: V,
) -> (bool, bool) {
    // Returns (metadata_changed, incarnation_changed)
    // ...existing logic...
    let incarnation_changed = prev_entry.is_some();
    let metadata_changed = prev_entry.is_none_or(|entry| {
        // existing metadata comparison
    });
    (metadata_changed, incarnation_changed)
}

// In executor.rs:
let (metadata_changed, incarnation_changed) = versioned_cache.data().write_metadata(...);
if metadata_changed || incarnation_changed {
    needs_suffix_validation = true;
}
```

**Long-term:** Migrate all workloads to BlockSTM v2, which uses push validation and doesn't have this vulnerability.

## Proof of Concept

```rust
// Add this test to aptos-move/block-executor/src/unit_tests/mod.rs
#[test]
fn test_metadata_idempotency_consensus_violation() {
    use crate::executor::BlockExecutor;
    use aptos_types::write_set::WriteOp;
    
    // Setup: Create a block with 3 transactions
    // T1: Writes resource group with metadata M, value V1
    // T2: Reads from T1
    // T3: Causes T1 to re-execute
    
    // Step 1: T1 executes incarnation 0
    let metadata_v0 = StateValueMetadata::legacy(100, &CurrentTimeMicroseconds { microseconds: 1000 });
    let value_v0 = create_resource_value(100); // value: 100
    
    // Step 2: T2 reads from T1 and validates
    // T2 captures read: version (1, 0), value 100
    
    // Step 3: T1 re-executes incarnation 1 with SAME metadata, DIFFERENT value
    let metadata_v1 = StateValueMetadata::legacy(100, &CurrentTimeMicroseconds { microseconds: 1000 });
    let value_v1 = create_resource_value(200); // value: 200, BUT same size/metadata
    
    // Assert: write_metadata returns false (metadata unchanged)
    assert_eq!(mvhashmap.data().write_metadata(key, 1, 1, metadata_v1), false);
    
    // Assert: needs_suffix_validation is NOT set
    assert_eq!(needs_suffix_validation, false);
    
    // Assert: T2 is NOT scheduled for revalidation
    assert!(!scheduler.is_scheduled_for_validation(2));
    
    // Result: T2 commits with stale value 100 instead of correct value 200
    // This creates a consensus violation where different validators
    // can have different state roots for the same block
}
```

The test demonstrates that when metadata is identical between incarnations but values differ, the validation system fails to detect the inconsistency, allowing stale reads to commit.

**Notes**

This vulnerability is specific to BlockSTM v1's suffix validation mechanism. BlockSTM v2 mitigates this through push validation and explicit dependency tracking, where write operations immediately invalidate dependent read operations regardless of metadata changes. The issue highlights the importance of conservative validation strategies in parallel execution engines - when in doubt about whether validation is needed, it should always be triggered to maintain consensus safety.

### Citations

**File:** aptos-move/mvhashmap/src/versioned_data.rs (L717-751)
```rust
    pub fn write_metadata(
        &self,
        key: K,
        txn_idx: TxnIndex,
        incarnation: Incarnation,
        data: V,
    ) -> bool {
        let arc_data = Arc::new(data);

        let mut v = self.values.entry(key).or_default();
        let prev_entry = v.versioned_map.insert(
            ShiftedTxnIndex::new(txn_idx),
            CachePadded::new(new_write_entry(
                incarnation,
                ValueWithLayout::Exchanged(arc_data.clone(), None),
                BTreeMap::new(),
            )),
        );

        // Changes versioned metadata that was stored.
        prev_entry.is_none_or(|entry| -> bool {
            if let EntryCell::ResourceWrite {
                value_with_layout: existing_value_with_layout,
                ..
            } = &entry.value
            {
                arc_data.as_state_value_metadata()
                    != existing_value_with_layout
                        .extract_value_no_layout()
                        .as_state_value_metadata()
            } else {
                unreachable!("Group metadata can't be written at AggregatorV1 key");
            }
        })
    }
```

**File:** aptos-move/block-executor/src/executor.rs (L620-627)
```rust
                if versioned_cache.data().write_metadata(
                    group_key.clone(),
                    idx_to_execute,
                    incarnation,
                    group_metadata_op,
                ) {
                    needs_suffix_validation = true;
                }
```

**File:** aptos-move/block-executor/src/scheduler.rs (L574-583)
```rust
        // Needs to be re-validated in a new wave
        if cur_val_idx > txn_idx {
            if revalidate_suffix {
                // The transaction execution required revalidating all higher txns (not
                // only itself), currently happens when incarnation writes to a new path
                // (w.r.t. the write-set of its previous completed incarnation).
                if let Some(wave) = self.decrease_validation_idx(txn_idx + 1) {
                    cur_wave = wave;
                };
            }
```

**File:** aptos-move/block-executor/src/executor_utilities.rs (L328-331)
```rust
    // Group metadata lives in same versioned cache as data / resources.
    // We are not marking metadata change as estimate, but after a transaction execution
    // changes metadata, suffix validation is guaranteed to be triggered. Estimation affecting
    // execution behavior is left to size, which uses a heuristic approach.
```
