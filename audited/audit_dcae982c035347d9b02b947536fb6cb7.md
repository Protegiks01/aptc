# Audit Report

## Title
OnChainConsensusConfig Lacks Variant Validation Leading to Governance Bypass via Deserialization Failures

## Summary
The `consensus_config::set_for_next_epoch()` Move function accepts arbitrary bytes without validating that they represent a valid OnChainConsensusConfig variant (V1-V5). This allows an attacker to submit a governance proposal with malformed config bytes that cause deserialization failures during epoch transitions, forcing all validators to fall back to a hardcoded default configuration and bypassing governance intent.

## Finding Description

The vulnerability exists in the consensus configuration update path through multiple layers:

**Layer 1: Rust Release Builder** [1](#0-0) 

The `generate_consensus_upgrade_proposal()` function accepts an `&OnChainConsensusConfig` reference and serializes it via BCS without explicit variant validation (the Rust type system ensures validity here). However, this function is NOT the only way to create consensus config proposals.

**Layer 2: Move On-Chain Validation (Critical Gap)** [2](#0-1) 

The `set_for_next_epoch()` function performs ONLY a length check (`vector::length(&config) > 0`) and no content validation. It accepts any arbitrary bytes, regardless of whether they represent a valid OnChainConsensusConfig variant.

**Layer 3: Deserialization at Epoch Transition** [3](#0-2) 

The deserialization performs double BCS decoding. If bytes contain an unknown variant (e.g., variant index 6 when only V1-V5 exist), BCS deserialization fails with an error. [4](#0-3) 

When deserialization fails, validators log a warning and fall back to `OnChainConsensusConfig::default()`, which is hardcoded as V4 with specific settings. [5](#0-4) 

**Attack Scenario:**

1. Attacker crafts a governance proposal with a custom Move script:
```move
script {
    use aptos_framework::consensus_config;
    use aptos_framework::aptos_governance;
    
    fun main(framework_signer: &signer) {
        // Malicious bytes: double-BCS-encoded unknown variant
        // Inner: [6, 0, 0, 0] (variant index 6 as u32 little-endian)
        // Outer: [4, 6, 0, 0, 0] (BCS Vec<u8> with length 4)
        let malicious_config: vector<u8> = vector[4, 6, 0, 0, 0];
        
        consensus_config::set_for_next_epoch(framework_signer, malicious_config);
        aptos_governance::reconfigure(framework_signer);
    }
}
```

2. The Move function accepts the bytes (passes length > 0 check)
3. Invalid bytes are stored on-chain in the config buffer
4. On the next epoch transition, all validators attempt to deserialize
5. Deserialization fails due to unknown variant index
6. All validators fall back to the hardcoded default V4 configuration
7. Network runs with default config despite governance having "set" a different config
8. On-chain state shows invalid config bytes, but runtime uses default

**Example Legitimate Proposal Format:** [6](#0-5) 

This shows that governance proposals directly pass raw `vector<u8>` bytes to `set_for_next_epoch()`, making it trivial to substitute malicious bytes.

## Impact Explanation

**Medium Severity** - This vulnerability creates state inconsistencies requiring intervention:

1. **State Inconsistency**: On-chain ConsensusConfig resource contains invalid bytes that cannot be deserialized, while validators operate using a hardcoded fallback. This violates the "State Consistency" invariant.

2. **Governance Bypass**: Attackers can prevent legitimate consensus configuration upgrades from taking effect by poisoning the on-chain config with invalid bytes, forcing the network to use default settings regardless of governance decisions. This violates the "Governance Integrity" invariant.

3. **Operational Confusion**: Operators see config on-chain that differs from actual runtime behavior, making debugging and validation difficult.

4. **Requires Intervention**: Once invalid bytes are stored, a new governance proposal with valid bytes must be submitted to restore proper configuration.

The impact does NOT include:
- Consensus safety violations (all validators use same default consistently)
- Loss of funds or value
- Network liveness failures (network continues with default config)
- Permanent damage (fixable with new proposal)

This aligns with the Medium severity category: "State inconsistencies requiring intervention."

## Likelihood Explanation

**Moderate Likelihood:**

**Prerequisites:**
- Attacker must have sufficient stake to create a governance proposal
- Proposal must receive enough votes to pass
- Attacker must craft Move script with malicious bytes

**Feasibility:**
- Move supports raw `vector<u8>` construction with arbitrary bytes
- No technical barriers to creating malicious proposal script
- Governance approval is the main barrier

**Motivation:**
- Could be used to prevent DAG consensus activation
- Could force network to specific default configuration
- Could be used as griefing attack against governance
- Could prevent security-critical config updates

While requiring governance approval raises the bar, wealthy attackers or malicious validator coalitions could exploit this. The technical attack is straightforward once governance access is obtained.

## Recommendation

**Add variant validation in the Move layer** before accepting config bytes:

```move
// In consensus_config.move
native fun validate_consensus_config_bytes(config_bytes: vector<u8>): bool;

public fun set_for_next_epoch(account: &signer, config: vector<u8>) {
    system_addresses::assert_aptos_framework(account);
    assert!(vector::length(&config) > 0, error::invalid_argument(EINVALID_CONFIG));
    
    // NEW: Validate that bytes represent valid OnChainConsensusConfig
    assert!(
        validate_consensus_config_bytes(config),
        error::invalid_argument(EINVALID_CONFIG)
    );
    
    std::config_buffer::upsert<ConsensusConfig>(ConsensusConfig {config});
}
```

**Implement native validation function in Rust** (in `aptos-move/framework/src/natives/consensus_config.rs`):

```rust
pub fn validate_consensus_config_bytes(
    _context: &mut SafeNativeContext,
    _ty_args: &[Type],
    mut args: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    let config_bytes = safely_pop_arg!(args, Vec<u8>);
    
    // Attempt deserialization and check if it succeeds
    let is_valid = bcs::from_bytes::<OnChainConsensusConfig>(&config_bytes).is_ok();
    
    Ok(smallvec![Value::bool(is_valid)])
}
```

This ensures only valid, deserializable OnChainConsensusConfig bytes can be stored on-chain.

## Proof of Concept

**Malicious Move Script:**

```move
script {
    use aptos_framework::consensus_config;
    use aptos_framework::aptos_governance;
    
    fun main(core_resources: &signer) {
        let framework_signer = aptos_governance::get_signer_testnet_only(
            core_resources, 
            @0x1
        );
        
        // Construct invalid OnChainConsensusConfig bytes
        // Represents variant index 6 (non-existent) double-BCS-encoded
        // First BCS layer: Vec<u8> of length 4
        // Second BCS layer: u32 variant index 6 in little-endian
        let invalid_config: vector<u8> = vector[
            4,           // ULEB128 length = 4
            6, 0, 0, 0   // Variant index 6 (u32 little-endian)
        ];
        
        // This call succeeds (only checks length > 0)
        consensus_config::set_for_next_epoch(framework_signer, invalid_config);
        
        // Trigger reconfiguration
        aptos_governance::reconfigure(framework_signer);
    }
}
```

**Expected Behavior After Execution:**

1. Script executes successfully (passes Move validation)
2. Invalid bytes stored in config buffer
3. On next epoch, validators log warnings: "Failed to read on-chain consensus config"
4. All validators fall back to V4 default configuration
5. Network runs with default config despite on-chain config being "set"
6. Subsequent queries show corrupted config bytes on-chain

**Rust Test to Demonstrate Deserialization Failure:**

```rust
#[test]
fn test_invalid_variant_deserialization() {
    // Construct bytes representing variant index 6 (doesn't exist)
    let invalid_inner = vec![6u8, 0, 0, 0]; // u32 = 6
    let invalid_outer = bcs::to_bytes(&invalid_inner).unwrap();
    
    // Attempt to deserialize as OnChainConsensusConfig
    let result = OnChainConsensusConfig::deserialize_into_config(&invalid_outer);
    
    // Should fail with deserialization error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to deserialize"));
}
```

## Notes

The vulnerability stems from the architectural decision to accept opaque `vector<u8>` in the Move layer without content validation. While the Rust release builder ensures type safety, alternative governance proposal creation paths bypass this protection. The validators' fallback behavior prevents consensus divergence but creates a governance bypass vector and state inconsistency that requires manual intervention to resolve.

### Citations

**File:** aptos-move/aptos-release-builder/src/components/consensus_config.rs (L11-51)
```rust
pub fn generate_consensus_upgrade_proposal(
    consensus_config: &OnChainConsensusConfig,
    is_testnet: bool,
    next_execution_hash: Option<HashValue>,
    is_multi_step: bool,
) -> Result<Vec<(String, String)>> {
    let signer_arg = get_signer_arg(is_testnet, &next_execution_hash);
    let mut result = vec![];

    let writer = CodeWriter::new(Loc::default());

    emitln!(writer, "// Consensus config upgrade proposal\n");
    let config_comment = format!("// config: {:#?}", consensus_config).replace('\n', "\n// ");
    emitln!(writer, "{}\n", config_comment);

    let proposal = generate_governance_proposal(
        &writer,
        is_testnet,
        next_execution_hash,
        is_multi_step,
        &["aptos_framework::consensus_config"],
        |writer| {
            let consensus_config_blob = bcs::to_bytes(consensus_config).unwrap();
            assert!(consensus_config_blob.len() < 65536);

            emit!(writer, "let consensus_blob: vector<u8> = ");
            generate_blob_as_hex_string(writer, &consensus_config_blob);
            emitln!(writer, ";\n");

            emitln!(
                writer,
                "consensus_config::set_for_next_epoch({}, consensus_blob);",
                signer_arg
            );
            emitln!(writer, "aptos_governance::reconfigure({});", signer_arg);
        },
    );

    result.push(("consensus-config".to_string(), proposal));
    Ok(result)
}
```

**File:** aptos-move/framework/aptos-framework/sources/configs/consensus_config.move (L52-56)
```text
    public fun set_for_next_epoch(account: &signer, config: vector<u8>) {
        system_addresses::assert_aptos_framework(account);
        assert!(vector::length(&config) > 0, error::invalid_argument(EINVALID_CONFIG));
        std::config_buffer::upsert<ConsensusConfig>(ConsensusConfig {config});
    }
```

**File:** types/src/on_chain_config/consensus_config.rs (L443-450)
```rust
impl Default for OnChainConsensusConfig {
    fn default() -> Self {
        OnChainConsensusConfig::V4 {
            alg: ConsensusAlgorithmConfig::default_if_missing(),
            vtxn: ValidatorTxnConfig::default_if_missing(),
            window_size: DEFAULT_WINDOW_SIZE,
        }
    }
```

**File:** types/src/on_chain_config/consensus_config.rs (L464-468)
```rust
    fn deserialize_into_config(bytes: &[u8]) -> Result<Self> {
        let raw_bytes: Vec<u8> = bcs::from_bytes(bytes)?;
        bcs::from_bytes(&raw_bytes)
            .map_err(|e| format_err!("[on-chain config] Failed to deserialize into config: {}", e))
    }
```

**File:** consensus/src/epoch_manager.rs (L1178-1201)
```rust
        let onchain_consensus_config: anyhow::Result<OnChainConsensusConfig> = payload.get();
        let onchain_execution_config: anyhow::Result<OnChainExecutionConfig> = payload.get();
        let onchain_randomness_config_seq_num: anyhow::Result<RandomnessConfigSeqNum> =
            payload.get();
        let randomness_config_move_struct: anyhow::Result<RandomnessConfigMoveStruct> =
            payload.get();
        let onchain_jwk_consensus_config: anyhow::Result<OnChainJWKConsensusConfig> = payload.get();
        let dkg_state = payload.get::<DKGState>();

        if let Err(error) = &onchain_consensus_config {
            warn!("Failed to read on-chain consensus config {}", error);
        }

        if let Err(error) = &onchain_execution_config {
            warn!("Failed to read on-chain execution config {}", error);
        }

        if let Err(error) = &randomness_config_move_struct {
            warn!("Failed to read on-chain randomness config {}", error);
        }

        self.epoch_state = Some(epoch_state.clone());

        let consensus_config = onchain_consensus_config.unwrap_or_default();
```

**File:** aptos-move/aptos-release-builder/data/example-release-with-randomness-framework/output/1-consensus-config.move (L43-52)
```text
        let consensus_blob: vector<u8> = vector[
            2, 0, 1, 10, 0, 0, 0, 0, 0, 0, 0, 40, 0, 0, 0, 0, 0, 0, 0, 2,
            1, 232, 3, 0, 0, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
            0, 0, 0, 0, 0, 10, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
            0, 0, 0, 0, 0, 1, 5, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 1, 1,
            3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 32, 0, 0, 0, 0, 0,
        ];

        consensus_config::set_for_next_epoch(framework_signer, consensus_blob);
        aptos_governance::reconfigure(framework_signer);
```
