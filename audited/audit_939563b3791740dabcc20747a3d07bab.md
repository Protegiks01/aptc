# Audit Report

## Title
Out-of-Bounds Array Access in Cross-Shard Message Routing Due to Missing Configuration Validation

## Summary
The sharded block execution system can crash validator nodes due to missing validation between `max_partitioning_rounds` configuration and the fixed-size message channel arrays bounded by `MAX_ALLOWED_PARTITIONING_ROUNDS`. When `max_partitioning_rounds` is configured to be ≥ `MAX_ALLOWED_PARTITIONING_ROUNDS`, transactions in later rounds trigger out-of-bounds array access during cross-shard message routing, causing validator node panics. [1](#0-0) 

## Finding Description

The vulnerability stems from a mismatch between dynamic partitioning configuration and statically-sized communication infrastructure:

**1. Sentinel Index Creation (The Questioned Line):**
At line 329, when no next writer exists, a sentinel value is created with `round_id = num_rounds()` and `shard_id = num_executor_shards`. While this sentinel is intentionally invalid (designed as an exclusive upper bound for range queries), it exposes a deeper issue with round boundary validation. [2](#0-1) 

**2. Unconstrained Configuration:**
The `max_partitioning_rounds` parameter can be set to any value without validation against `MAX_ALLOWED_PARTITIONING_ROUNDS` (defined as 8): [3](#0-2) [4](#0-3) 

**3. Transaction Round Assignment:**
During partitioning, transactions are assigned to rounds based on `max_partitioning_rounds`: [5](#0-4) [6](#0-5) 

If `max_partitioning_rounds = 9`, transactions can have `round_id = 8`.

**4. Dependent Edge Propagation:**
These round_ids propagate through dependent edges: [7](#0-6) 

**5. Cross-Shard Message Routing:**
During execution, the `CrossShardCommitSender` extracts these indices and routes messages: [8](#0-7) 

The critical check only handles `GLOBAL_ROUND_ID` (value 9), but not `round_id = 8`.

**6. Out-of-Bounds Access:**
Both local and remote implementations directly index without bounds checking: [9](#0-8) [10](#0-9) 

The message channel arrays are sized to `MAX_ALLOWED_PARTITIONING_ROUNDS = 8`: [11](#0-10) [12](#0-11) 

Accessing `message_txs[shard_id][8]` when the array only has indices `[0, 8)` causes a panic.

## Impact Explanation

**Severity: High** - Validator node crashes and API failures.

This violates the **Deterministic Execution** invariant as misconfigured nodes will crash while correctly configured nodes continue, creating a liveness failure for affected validators. When validators crash during block execution, they cannot participate in consensus, potentially reducing network availability if enough validators are misconfigured.

The impact qualifies as **High Severity** per Aptos bug bounty criteria:
- Validator node crashes (immediate termination during block execution)
- API crashes (execution service failures)
- Significant protocol violation (deterministic execution failure across nodes with different configurations)

## Likelihood Explanation

**Likelihood: Low to Medium**

While the default configuration (4 rounds) is safe, the likelihood increases if:
1. Operators manually configure `max_partitioning_rounds ≥ 8` for performance tuning
2. Configuration templates or documentation suggest values near the limit
3. Automated configuration management systems use unsafe values

The vulnerability is deterministic once triggered - any block with cross-shard dependencies in round 8+ will crash the node.

## Recommendation

Add validation in the configuration builder to enforce the constraint:

```rust
// In execution/block-partitioner/src/v2/config.rs
impl PartitionerV2Config {
    pub fn max_partitioning_rounds(mut self, val: usize) -> Self {
        assert!(
            val <= MAX_ALLOWED_PARTITIONING_ROUNDS,
            "max_partitioning_rounds ({}) cannot exceed MAX_ALLOWED_PARTITIONING_ROUNDS ({})",
            val,
            MAX_ALLOWED_PARTITIONING_ROUNDS
        );
        self.max_partitioning_rounds = val;
        self
    }
}

// In execution/block-partitioner/src/v2/mod.rs
impl PartitionerV2 {
    pub fn new(
        num_threads: usize,
        num_rounds_limit: usize,
        // ...
    ) -> Self {
        assert!(
            num_rounds_limit <= MAX_ALLOWED_PARTITIONING_ROUNDS,
            "num_rounds_limit ({}) cannot exceed MAX_ALLOWED_PARTITIONING_ROUNDS ({})",
            num_rounds_limit,
            MAX_ALLOWED_PARTITIONING_ROUNDS
        );
        // ...
    }
}
```

## Proof of Concept

```rust
// Rust reproduction demonstrating the crash
#[test]
#[should_panic(expected = "index out of bounds")]
fn test_invalid_round_config() {
    // Set max_partitioning_rounds = 9 (> MAX_ALLOWED_PARTITIONING_ROUNDS = 8)
    let config = PartitionerV2Config {
        num_threads: 8,
        max_partitioning_rounds: 9, // INVALID
        cross_shard_dep_avoid_threshold: 0.9,
        dashmap_num_shards: 64,
        partition_last_round: false,
        pre_partitioner_config: Box::<ConnectedComponentPartitionerConfig>::default(),
    };
    
    // Create partitioner and executor with conflicting configuration
    let partitioner = config.build();
    let executor = LocalExecutorService::setup_local_executor_shards(4, Some(8));
    
    // Create transactions with cross-shard dependencies
    let txns = create_txns_with_conflicts(100);
    let partitioned = partitioner.partition(txns, 4);
    
    // This will crash when trying to send cross-shard message for round 8
    // message_txs[shard_id][8] accesses out of bounds
    executor.execute_block(
        Arc::new(FakeStateView::new()),
        partitioned,
        8,
        BlockExecutorConfigFromOnchain::default(),
    ).unwrap(); // PANIC HERE
}
```

**Notes:**
- The vulnerability requires validator operator misconfiguration, not remote exploitation by unprivileged attackers
- The fix is straightforward: add assertion checks in configuration constructors
- This represents a defense-in-depth failure where configuration validation is missing

### Citations

**File:** execution/block-partitioner/src/v2/state.rs (L326-331)
```rust
                let start_of_next_sub_block = ShardedTxnIndexV2::new(round_id, shard_id + 1, 0);
                let next_writer = self.first_writer(key_idx, start_of_next_sub_block);
                let end_follower = match next_writer {
                    None => ShardedTxnIndexV2::new(self.num_rounds(), self.num_executor_shards, 0), // Guaranteed to be greater than any invalid idx...
                    Some(idx) => ShardedTxnIndexV2::new(idx.round_id(), idx.shard_id() + 1, 0),
                };
```

**File:** execution/block-partitioner/src/v2/state.rs (L337-345)
```rust
                    let dst_txn_idx = ShardedTxnIndex {
                        txn_index: *self.final_idxs_by_pre_partitioned
                            [follower_txn_idx.pre_partitioned_txn_idx]
                            .read()
                            .unwrap(),
                        shard_id: final_sub_blk_idx.shard_id,
                        round_id: final_sub_blk_idx.round_id,
                    };
                    deps.add_dependent_edge(dst_txn_idx, vec![self.storage_location(key_idx)]);
```

**File:** execution/executor-benchmark/src/main.rs (L216-217)
```rust
    #[clap(long, default_value = "4")]
    max_partitioning_rounds: usize,
```

**File:** types/src/block_executor/partitioner.rs (L20-22)
```rust
pub static MAX_ALLOWED_PARTITIONING_ROUNDS: usize = 8;
pub static GLOBAL_ROUND_ID: usize = MAX_ALLOWED_PARTITIONING_ROUNDS + 1;
pub static GLOBAL_SHARD_ID: usize = usize::MAX;
```

**File:** execution/block-partitioner/src/v2/partition_to_matrix.rs (L37-39)
```rust
        for round_id in 0..(state.num_rounds_limit - 1) {
            let (accepted, discarded) = Self::discarding_round(state, round_id, remaining_txns);
            state.finalized_txn_matrix.push(accepted);
```

**File:** execution/block-partitioner/src/v2/partition_to_matrix.rs (L60-66)
```rust
        let last_round_id = state.finalized_txn_matrix.len();
        state.thread_pool.install(|| {
            (0..state.num_executor_shards)
                .into_par_iter()
                .for_each(|shard_id| {
                    remaining_txns[shard_id].par_iter().for_each(|&txn_idx| {
                        state.update_trackers_on_accepting(txn_idx, last_round_id, shard_id);
```

**File:** aptos-move/aptos-vm/src/sharded-block-executor/cross_shard_client.rs (L116-130)
```rust

```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/local_executor_shard.rs (L95-104)
```rust
        let (cross_shard_msg_txs, cross_shard_msg_rxs): (
            Vec<Vec<Sender<CrossShardMsg>>>,
            Vec<Vec<Receiver<CrossShardMsg>>>,
        ) = (0..num_shards)
            .map(|_| {
                (0..MAX_ALLOWED_PARTITIONING_ROUNDS)
                    .map(|_| unbounded())
                    .unzip()
            })
            .unzip();
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/local_executor_shard.rs (L331-333)
```rust
    fn send_cross_shard_msg(&self, shard_id: ShardId, round: RoundId, msg: CrossShardMsg) {
        self.message_txs[shard_id][round].send(msg).unwrap()
    }
```

**File:** execution/executor-service/src/remote_cross_shard_client.rs (L26-34)
```rust
        for remote_address in shard_addresses.iter() {
            let mut txs = vec![];
            for round in 0..MAX_ALLOWED_PARTITIONING_ROUNDS {
                let message_type = format!("cross_shard_{}", round);
                let tx = controller.create_outbound_channel(*remote_address, message_type);
                txs.push(Mutex::new(tx));
            }
            message_txs.push(txs);
        }
```

**File:** execution/executor-service/src/remote_cross_shard_client.rs (L55-58)
```rust
    fn send_cross_shard_msg(&self, shard_id: ShardId, round: RoundId, msg: CrossShardMsg) {
        let input_message = bcs::to_bytes(&msg).unwrap();
        let tx = self.message_txs[shard_id][round].lock().unwrap();
        tx.send(Message::new(input_message)).unwrap();
```
