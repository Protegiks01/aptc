# Audit Report

## Title
Supply Chain Attack: Move Package Resolver Fails to Detect Git Repository Takeover

## Summary
The Move package resolver does not verify repository ownership or detect when a git repository has been transferred to a malicious owner. This allows attackers to inject malicious code into Move packages through repository takeover attacks, potentially compromising smart contracts deployed on the Aptos blockchain.

## Finding Description

The Move package resolver identifies git dependencies solely by their URL through the `CanonicalGitIdentity` mechanism. [1](#0-0) 

When resolving git dependencies, the system creates a canonical identity by normalizing the URL (lowercasing, removing `.git` suffix, etc.) but performs **no verification** of repository ownership, identity, or transfer events. [2](#0-1) 

The `PackageLock` stores mappings of `"repo_url@branch"` to commit IDs for reproducibility, but this protection only works if the lock file exists and is not bypassed. [3](#0-2) 

**Attack Scenario:**

1. Developer creates Move package depending on `https://github.com/victim/move-lib` in their `Move.toml` manifest
2. Package resolver clones the repository and creates a lock file with the commit hash
3. Original repository owner deletes their GitHub repository or transfers it to another account
4. Attacker creates a new repository at the same URL `https://github.com/victim/move-lib` with malicious code
5. When any of these events occur:
   - New developer clones the project without the `Move.lock` file
   - Developer deletes lock file and rebuilds
   - Developer updates dependencies with new branch
   - Cache is cleared
6. The resolver fetches from the attacker's repository with **no warning** that ownership has changed
7. Malicious code is compiled into Move bytecode and potentially deployed on-chain

The package manifest structure contains no security fields to prevent this: [4](#0-3) 

When the package cache clones or updates repositories, it performs no verification beyond standard git operations: [5](#0-4) 

## Impact Explanation

This is a **High Severity** vulnerability per Aptos bug bounty criteria because:

1. **Validator Node Impact**: If validators use compromised dependencies in their node software or framework modules, this could lead to consensus divergence or node compromise
2. **Smart Contract Compromise**: Developers deploying Move contracts with malicious dependencies could lose funds or have their contracts exploited
3. **Ecosystem-Wide Risk**: This affects all developers building on Aptos, creating systemic supply chain risk
4. **No Warning Mechanism**: The complete absence of detection/warning makes this attack completely silent

While not directly causing consensus violations, this vulnerability can **lead to** consensus issues if different validators compile different versions of core framework code, or if malicious contracts manipulate on-chain state in unexpected ways.

## Likelihood Explanation

**Likelihood: Medium-High**

Factors increasing likelihood:
- GitHub allows repository deletion and recreation at the same URL
- GitHub allows repository transfers between accounts  
- Developers commonly delete `Move.lock` files or update dependencies
- No cryptographic verification of repository identity
- Attack has proven successful in other ecosystems (npm, PyPI, RubyGems)

Factors decreasing likelihood:
- Requires attacker to obtain a previously-used repository URL
- Lock files provide protection when present and committed
- Requires developer action (building/updating) to trigger

This attack is **technically feasible** and has **real-world precedent** in other package ecosystems, making it a credible threat.

## Recommendation

Implement multiple layers of defense:

1. **Add Repository Identity Verification**:
   - Store repository metadata (creation date, owner ID) in lock file
   - Warn when repository metadata changes between builds
   - Consider cryptographic commit signing verification

2. **Implement Subresource Integrity**:
   - Add optional checksum/hash fields to `PackageLocation::Git` in the manifest
   - Verify repository content hash matches expected value
   - Fail builds when checksums don't match

3. **Add Transfer Detection**:
   - Query GitHub/GitLab API for repository transfer events
   - Warn users when repository ownership has changed
   - Require explicit acknowledgment to proceed

4. **Strengthen Lock File Usage**:
   - Make lock files mandatory for production builds
   - Add warnings when building without lock file
   - Include repository metadata in lock file format

**Example fix for manifest structure:**

Add security fields to `PackageLocation::Git`:
```rust
Git {
    url: Url,
    rev: Option<String>,
    subdir: Option<String>,
    // Add security fields
    expected_owner: Option<String>,  // Repository owner verification
    content_hash: Option<String>,     // Subresource integrity check
}
```

## Proof of Concept

**Reproduction Steps:**

1. Create a Move package with git dependency:
```toml
[package]
name = "VulnerablePackage"
version = "1.0.0"

[dependencies]
ExternalLib = { git = "https://github.com/victim/move-lib", rev = "main" }
```

2. Build the package (creates `Move.lock` with commit hash)

3. Simulate repository takeover:
   - Original owner deletes repository at `github.com/victim/move-lib`
   - Attacker creates new repository at same URL with malicious code

4. Delete `Move.lock` file (simulating new developer or dependency update)

5. Rebuild the package:
```bash
cargo run --bin move-package-resolver -- resolve
```

6. **Expected behavior**: System should detect ownership change and warn user

7. **Actual behavior**: System silently fetches from attacker's repository with no warning, no error, no indication that the repository has changed hands

The resolver will fetch and compile the malicious code without any security checks, as evidenced by the code flow in `resolve_dependency` which only validates the URL format, not repository ownership or identity.

**Notes**

This is a supply chain security vulnerability affecting the Move package ecosystem on Aptos. While the direct impact is at build/compile time rather than runtime, the downstream consequences can be severe: malicious code compiled into Move modules can steal funds, manipulate governance, or compromise validator operations when deployed on-chain. The complete absence of repository ownership verification or transfer detection represents a significant security gap in the Move toolchain that should be addressed to protect the Aptos ecosystem from supply chain attacks.

### Citations

**File:** third_party/move/tools/move-package-cache/src/canonical.rs (L11-38)
```rust
/// Canonicalized identity of a git repository, derived from a [`Url`].
/// - Ignores the scheme
/// - Converts host & path to lowercase
/// - Keeps port, but only if it is non-default
/// - Trims trailing slashes and `.git` suffix
#[derive(Debug, Clone, Eq, PartialEq, Ord, PartialOrd)]
pub struct CanonicalGitIdentity(String);

impl CanonicalGitIdentity {
    pub fn new(git_url: &Url) -> Result<Self> {
        let host = git_url
            .host_str()
            .ok_or_else(|| anyhow!("invalid git URL, unable to extract host: {}", git_url))?
            .to_ascii_lowercase();

        let port = match git_url.port() {
            Some(port) => match (git_url.scheme(), port) {
                ("http", 80) | ("https", 443) | ("ssh", 22) => "".to_string(),
                _ => format!(":{}", port),
            },
            None => "".to_string(),
        };

        let path = git_url.path().to_ascii_lowercase();
        let path = path.trim_end_matches("/").trim_end_matches(".git");

        Ok(Self(format!("{}{}{}", host, port, path)))
    }
```

**File:** third_party/move/tools/move-package-resolver/src/resolver.rs (L387-411)
```rust
        PackageLocation::Git { url, rev, subdir } => {
            let commit_id = package_lock
                .resolve_git_revision(package_cache, &url, &rev.unwrap())
                .await?;

            let subdir = PathBuf::from_str(&subdir.unwrap_or(String::new()))?;
            if subdir.is_absolute() {
                bail!("subdir cannot be an absolute path: {}", subdir.display());
            }
            let normalized_subdir = NormalizedPath::new(&subdir);
            if let Some(std::path::Component::ParentDir) = normalized_subdir.components().next() {
                bail!("subdir outside of repo root: {}", subdir.display());
            }

            let identity = PackageIdentity {
                name: dep_name.to_string(),
                location: SourceLocation::Git {
                    repo: CanonicalGitIdentity::new(&url)?,
                    commit_id,
                    subdir: normalized_subdir,
                },
            };

            remote_url = url;
            (identity, Some(&remote_url))
```

**File:** third_party/move/tools/move-package-resolver/src/lock.rs (L56-84)
```rust
    /// Resolves and pins a git revision.
    ///
    /// - If the given git URL and branch/rev combo is already recorded in the lock,
    /// returns the pinned commit hash.
    /// - Otherwise, queries the remote, records the result,
    /// and returns the resolved commit hash.
    pub async fn resolve_git_revision<L>(
        &mut self,
        package_cache: &PackageCache<L>,
        git_url: &Url,
        rev: &str,
    ) -> Result<Oid>
    where
        L: PackageCacheListener,
    {
        let git_identity = CanonicalGitIdentity::new(git_url)?;

        let repo_loc_and_rev = format!("{}@{}", git_identity, rev);

        let res = match self.git.entry(repo_loc_and_rev) {
            btree_map::Entry::Occupied(entry) => entry.get().clone(),
            btree_map::Entry::Vacant(entry) => {
                let oid = package_cache.resolve_git_revision(git_url, rev).await?;
                entry.insert(oid.to_string()).clone()
            },
        };

        Ok(Oid::from_str(&res)?)
    }
```

**File:** third_party/move/tools/move-package-manifest/src/manifest.rs (L125-156)
```rust
/// Location of a package dependency.
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum PackageLocation {
    /// Refers to a package stored in the local file system.
    Local { path: PathBuf },

    /// Refers to a package stored in a git repository.
    Git {
        /// URL to the Git repository.
        url: Url,
        /// Optional Git revision to pin the dependency to.
        /// This can be a commit hash, a branch name or a tag name.
        rev: Option<String>,
        /// Optional subdirectory within the Git repository.
        subdir: Option<String>,
    },

    /// Refers to a package published on-chain.
    ///
    // TODO: The current design is tentative. There are issues we plan to resolve later:
    //       - Leaky abstraction -- can we still want to maintain clear Move/Aptos separation?
    //       - Replacing `String` w/ more specific data structures
    //         - `node_url`: Should accept both URL and known network names (e.g. "mainnet")
    //         - `package_addr`: May accept both numerical and named addresses
    Aptos {
        /// URL to the Aptos full-node connected to the network where the package is published.
        node_url: String,

        /// Address of the published package.
        package_addr: AccountAddress,
    },
}
```

**File:** third_party/move/tools/move-package-cache/src/package_cache.rs (L89-178)
```rust
    /// Clones or updates a Git repository, ensuring it is available locally with up-to-date data.
    ///
    /// Returns an `ActiveRepository` object. This can be used to access the contents of the repo, and while
    /// is still alive, a lock is held to prevent other package cache instances to access the repo.
    async fn clone_or_update_git_repo(&self, git_url: &Url) -> Result<ActiveRepository>
    where
        L: PackageCacheListener,
    {
        let repo_dir_name = percent_encode_for_filename(&CanonicalGitIdentity::new(git_url)?);
        let repos_path = self.root.join("git").join("repos");
        let repo_path = repos_path.join(&repo_dir_name);

        println!("{}", repo_path.display());

        // First, acquire a file lock to ensure exclusive write access to the cached repo.
        let lock_path = repo_path.with_extension("lock");

        fs::create_dir_all(&repos_path)?;
        let file_lock =
            FileLock::lock_with_alert_on_wait(&lock_path, Duration::from_millis(1000), || {
                self.listener.on_file_lock_wait(&lock_path);
            })
            .await?;

        // Next, ensure that we have an up-to-date clone of the repo locally.
        //
        // Before performing the actual operation, we need to configure the fetch options
        // (shared by both clone and update).
        let mut cbs = RemoteCallbacks::new();
        let mut received = 0;
        cbs.transfer_progress(move |stats| {
            let received_new = stats.received_objects();

            if received_new != received {
                received = received_new;

                self.listener.on_repo_receive_object(
                    git_url.as_str(),
                    stats.received_objects(),
                    stats.total_objects(),
                );
            }

            true
        });
        let mut fetch_options = FetchOptions::new();
        fetch_options.remote_callbacks(cbs);

        let repo = if repo_path.exists() {
            // If the repo already exists, update it.
            self.listener.on_repo_update_start(git_url.as_str());

            let repo = Repository::open_bare(&repo_path)?;
            {
                let mut remote = repo.find_remote("origin")?;
                // Fetch all remote branches and map them to local remote-tracking branches
                // - refs/heads/*: fetch all remote branches
                // - refs/remotes/origin/*: store them as local remote-tracking branches under origin/
                remote
                    .fetch(
                        &["refs/heads/*:refs/remotes/origin/*"],
                        Some(&mut fetch_options),
                        None,
                    )
                    .map_err(|err| anyhow!("Failed to update git repo at {}: {}", git_url, err))?;
            }

            self.listener.on_repo_update_complete(git_url.as_str());

            repo
        } else {
            // If the repo does not exist, clone it.
            let mut repo_builder = RepoBuilder::new();
            repo_builder.fetch_options(fetch_options);
            repo_builder.bare(true);

            self.listener.on_repo_clone_start(git_url.as_str());
            let repo = repo_builder
                .clone(git_url.as_str(), &repo_path)
                .map_err(|err| anyhow!("Failed to clone git repo at {}: {}", git_url, err))?;
            self.listener.on_repo_clone_complete(git_url.as_str());

            repo
        };

        Ok(ActiveRepository {
            repo,
            lock: file_lock,
        })
    }
```
