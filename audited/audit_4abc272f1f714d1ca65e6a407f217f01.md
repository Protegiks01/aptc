# Audit Report

## Title
Resource Group Metadata WriteOp Kind Change Bypass via ONLY_COMPARE_METADATA Validation

## Summary
When `ONLY_COMPARE_METADATA` is true in `write_v2()`, the validation logic only compares `StateValueMetadata` fields (slot_deposit, bytes_deposit, creation_time_usecs) but ignores the `WriteOpKind` (Creation vs Modification). This allows a transaction to change its resource group metadata operation type between incarnations without invalidating dependent readers, potentially breaking resource group semantic invariants during parallel execution.

## Finding Description

The vulnerability exists in the metadata validation logic for resource group operations. When BlockSTMv2 writes resource group metadata using `write_v2::<true>()`, it uses the `compare_values_and_layouts` function with `ONLY_COMPARE_METADATA = true`. [1](#0-0) 

This comparison only checks metadata equality via `as_state_value_metadata()`, which for `WriteOp` types returns:
- `Creation(StateValue)` → `Some(metadata)`  
- `Modification(StateValue)` → `Some(metadata)`
- `Deletion(StateValueMetadata)` → `None` [2](#0-1) 

The critical issue is that `Creation` and `Modification` operations with identical metadata (same deposits and timestamps) will pass validation as equal, even though they represent semantically different operations.

Resource group metadata operations are written to the versioned cache here: [3](#0-2) 

**Attack Scenario:**

1. Storage state: Resource group G exists
2. Transaction T5 (incarnation 1) modifies G → `metadata_op = Modification(M1)`
3. Transaction T10 reads G's metadata, records dependency on T5
4. Transaction T5 (incarnation 2) creates G → `metadata_op = Creation(M1)` (same metadata)
5. `write_v2::<true>` validates: `Some(M1) == Some(M1)` → **PASS**
6. T10's dependency is NOT invalidated despite operation type change
7. T10 commits believing it saw Modification, but cache shows Creation

During finalization, the system validates that operation types match resource existence: [4](#0-3) 

However, the cached metadata_op can have a different operation type than what dependent transactions observed, leading to potential validation failures or state inconsistencies when multiple validators execute the same block with different dependency invalidation patterns.

## Impact Explanation

This vulnerability has **High** severity impact because it can cause:

1. **Non-deterministic execution**: Different validators may invalidate dependencies differently based on timing, leading to consensus splits where validators compute different state roots for the same block
2. **State inconsistency**: Transactions may commit based on incorrect assumptions about whether a resource group was created vs modified
3. **Validation bypass**: The semantic meaning of Creation (resource didn't exist) vs Modification (resource existed) is lost during dependency validation

This breaks the **Deterministic Execution** invariant: "All validators must produce identical state roots for identical blocks."

## Likelihood Explanation

**Medium likelihood** - Requires specific conditions:
- Parallel transaction execution (BlockSTMv2)
- Transaction re-execution with different metadata_op kind but same metadata values  
- Dependent transactions that read the resource group metadata
- Metadata fields (deposits, timestamp) remain identical across incarnations

The attack is feasible because metadata values can be deterministic across incarnations while the operation type changes based on speculative reads of earlier transactions.

## Recommendation

Modify `compare_values_and_layouts` to include `WriteOpKind` comparison when validating metadata operations:

```rust
fn compare_values_and_layouts<
    const ONLY_COMPARE_METADATA: bool,
    V: TransactionWrite + PartialEq,
>(
    prev_value: &V,
    new_value: &V,
    prev_maybe_layout: Option<&Arc<MoveTypeLayout>>,
    new_maybe_layout: Option<&Arc<MoveTypeLayout>>,
) -> bool {
    if ONLY_COMPARE_METADATA {
        // For resource group metadata, also compare operation kind
        prev_value.write_op_kind() == new_value.write_op_kind() &&
        prev_value.as_state_value_metadata() == new_value.as_state_value_metadata()
    } else {
        prev_maybe_layout.is_none() && new_maybe_layout.is_none() && prev_value == new_value
    }
}
```

## Proof of Concept

```rust
#[test]
fn test_metadata_op_kind_validation_bypass() {
    use aptos_types::write_set::WriteOp;
    use aptos_types::state_store::state_value::{StateValue, StateValueMetadata};
    
    // Create metadata with same values
    let metadata = StateValueMetadata::new(100, 50, &CurrentTimeMicroseconds { microseconds: 1000 });
    
    // Create two WriteOps with different kinds but same metadata
    let creation_op = WriteOp::creation(Bytes::new(), metadata.clone());
    let modification_op = WriteOp::modification(Bytes::new(), metadata.clone());
    
    // Both return Some(metadata) for as_state_value_metadata()
    assert_eq!(
        creation_op.as_state_value_metadata(),
        modification_op.as_state_value_metadata()
    );
    
    // But they have different operation kinds
    assert_ne!(
        creation_op.write_op_kind(),
        modification_op.write_op_kind()
    );
    
    // This demonstrates that ONLY_COMPARE_METADATA validation
    // would incorrectly pass for these semantically different operations
}
```

**Notes:**
- The vulnerability requires access to BlockSTMv2 parallel execution paths
- Impact is amplified in high-throughput scenarios with frequent re-executions
- Fix should maintain backward compatibility while adding operation kind validation

### Citations

**File:** aptos-move/mvhashmap/src/versioned_data.rs (L382-404)
```rust
fn compare_values_and_layouts<
    const ONLY_COMPARE_METADATA: bool,
    V: TransactionWrite + PartialEq,
>(
    prev_value: &V,
    new_value: &V,
    prev_maybe_layout: Option<&Arc<MoveTypeLayout>>,
    new_maybe_layout: Option<&Arc<MoveTypeLayout>>,
) -> bool {
    // ONLY_COMPARE_METADATA is a const static flag that indicates that these entries are
    // versioning metadata only, and not the actual value (Currently, only used for versioning
    // resource group metadata). Hence, validation is only performed on the metadata.
    if ONLY_COMPARE_METADATA {
        prev_value.as_state_value_metadata() == new_value.as_state_value_metadata()
    } else {
        // Layouts pass validation only if they are both None. Otherwise, validation pessimistically
        // fails. This is a simple logic that avoids potentially costly layout comparisons.
        prev_maybe_layout.is_none() && new_maybe_layout.is_none() && prev_value == new_value
    }
    // TODO(BlockSTMv2): optimize layout validation (potentially based on size, or by having
    // a more efficient representation. Optimizing value validation by having a configurable
    // size threshold above which validation can automatically pessimistically fail.
}
```

**File:** types/src/write_set.rs (L429-442)
```rust
impl TransactionWrite for WriteOp {
    fn bytes(&self) -> Option<&Bytes> {
        self.bytes()
    }

    fn as_state_value(&self) -> Option<StateValue> {
        self.as_state_value_opt().cloned()
    }

    // Note that even if WriteOp is DeletionWithMetadata, the method returns None, as a later
    // read would not read the metadata of the deletion op.
    fn as_state_value_metadata(&self) -> Option<StateValueMetadata> {
        self.as_state_value_opt().map(StateValue::metadata).cloned()
    }
```

**File:** aptos-move/block-executor/src/executor.rs (L257-266)
```rust
                        abort_manager.invalidate_dependencies(
                            // Invalidate the readers of group metadata.
                            versioned_cache.data().write_v2::<true>(
                                group_key.clone(),
                                idx_to_execute,
                                incarnation,
                                TriompheArc::new(group_metadata_op),
                                None,
                            )?,
                        )?;
```

**File:** aptos-move/block-executor/src/executor_utilities.rs (L102-119)
```rust
    let metadata_is_deletion = metadata_op.is_deletion();

    if is_read_needing_exchange && metadata_is_deletion {
        // Value needed exchange but was not written / modified during the txn
        // execution: may not be empty.
        Err(code_invariant_error(
            "Value only read and exchanged, but metadata op is Deletion".to_string(),
        ))
    } else if finalized_group.is_empty() != metadata_is_deletion {
        // finalize_group already applies the deletions.
        Err(code_invariant_error(format!(
            "Group is empty = {} but op is deletion = {} in parallel execution",
            finalized_group.is_empty(),
            metadata_is_deletion
        )))
    } else {
        Ok((group_key, metadata_op, finalized_group, group_size))
    }
```
