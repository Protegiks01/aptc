# Audit Report

## Title
Missing X25519 Public Key Validation Enables Low-Order Point Attack on Validator Network Communication

## Summary

The `x25519::PublicKey::from()` function accepts arbitrary 32-byte values without validating that they represent valid curve points. [1](#0-0)  This allows malicious validators to register with low-order X25519 public keys in their network addresses, forcing other validators to derive predictable shared secrets during Noise protocol handshakes, breaking the confidentiality and authenticity of validator network communications.

## Finding Description

**Vulnerability Chain:**

1. **No validation during PublicKey construction:** The `from()` implementation directly wraps input bytes without checking if they represent a valid curve point or detecting low-order points. [1](#0-0)  Similarly, `try_from()` only validates length. [2](#0-1) 

2. **No validation during validator registration:** When validators register via `initialize_validator()`, network addresses (containing X25519 public keys) are stored as raw bytes without cryptographic validation. [3](#0-2)  Note that consensus keys receive BLS proof-of-possession validation (line 679-683), but network addresses do not.

3. **Direct usage in Noise protocol:** During the Noise IK handshake, remote public keys are constructed directly from received bytes using `PublicKey::from()` [4](#0-3)  and used immediately in Diffie-Hellman operations. [5](#0-4) 

4. **Predictable shared secrets:** When Diffie-Hellman is performed with a low-order point (such as the all-zero point or one of seven other small-subgroup points on Curve25519), the resulting shared secret becomes one of at most 8 predictable values. The Noise protocol then derives session keys from this predictable shared secret. [6](#0-5) 

**Attack Scenario:**

1. Attacker stakes tokens and registers as validator with network address containing a low-order X25519 public key (e.g., 32 zero bytes: `0x0000...0000`)
2. Honest validator attempts to establish Noise connection with attacker's node
3. Honest validator performs DH with the low-order point, producing predictable shared secret
4. Session keys derived from this shared secret become predictable to attacker
5. Attacker can decrypt validator messages and forge authenticated messages
6. This compromises consensus communication, potentially enabling message manipulation or network partitioning

## Impact Explanation

**Severity: High**

This vulnerability breaks **Critical Invariant #10 (Cryptographic Correctness)** by allowing predictable shared secrets in the validator network's cryptographic protocol.

The impact includes:
- **Confidentiality breach:** Attacker can decrypt messages between validators
- **Authentication bypass:** Attacker can forge authenticated messages in Noise sessions
- **Consensus manipulation risk:** If consensus messages are intercepted/modified, this threatens consensus safety
- **Network availability:** Attacker could cause connection failures for targeted validators

While this doesn't directly allow fund theft, it compromises the security of the validator network communication layer, which is critical for consensus operation. Per the Aptos bug bounty criteria, this qualifies as **High Severity** due to "Significant protocol violations" affecting validator network security.

## Likelihood Explanation

**Likelihood: Medium-High**

The attack requires:
- Attacker must stake tokens to become a validator (economic barrier, but stake is returned)
- Technical knowledge to craft low-order points
- Other validators must attempt to connect to the malicious validator

However:
- No privileged access required beyond standard validator registration
- Network addresses are not validated during registration (unlike consensus keys)
- The vulnerability is deterministic once the malicious key is registered
- Discovery mechanisms will propagate the malicious network address to all validators

## Recommendation

**Solution:** Implement point validation for X25519 public keys before use in cryptographic operations.

**Fix 1 - Validate during construction:**
Add validation to `PublicKey::try_from()` to reject low-order points:

```rust
// In crates/aptos-crypto/src/x25519.rs
impl std::convert::TryFrom<&[u8]> for PublicKey {
    type Error = traits::CryptoMaterialError;

    fn try_from(public_key_bytes: &[u8]) -> Result<Self, Self::Error> {
        let public_key_bytes: [u8; PUBLIC_KEY_SIZE] = public_key_bytes
            .try_into()
            .map_err(|_| traits::CryptoMaterialError::WrongLengthError)?;
        
        // Reject known low-order points
        if is_low_order_point(&public_key_bytes) {
            return Err(traits::CryptoMaterialError::ValidationError);
        }
        
        Ok(Self(public_key_bytes))
    }
}

fn is_low_order_point(bytes: &[u8; 32]) -> bool {
    // Check for known low-order points (zero point and 7 others)
    const LOW_ORDER_POINTS: [[u8; 32]; 8] = [
        [0u8; 32], // Identity
        // Add other 7 known low-order points
        // Reference: RFC 7748 Section 6.1
    ];
    LOW_ORDER_POINTS.iter().any(|lop| lop == bytes)
}
```

**Fix 2 - Validate in Noise protocol:**
Check for zero shared secret after DH operations:

```rust
// In crates/aptos-crypto/src/noise.rs
let dh_output = e.diffie_hellman(&rs);
if dh_output == [0u8; 32] {
    return Err(NoiseError::WeakPublicKey);
}
```

## Proof of Concept

```rust
// Test demonstrating the vulnerability
#[test]
fn test_low_order_point_attack() {
    use aptos_crypto::{x25519, traits::Uniform};
    use rand::SeedableRng;
    
    // Attacker creates a low-order point (all zeros)
    let malicious_pubkey = x25519::PublicKey::from([0u8; 32]);
    
    // Honest validator performs DH with this key
    let mut rng = rand::rngs::StdRng::from_seed([1u8; 32]);
    let honest_private = x25519::PrivateKey::generate(&mut rng);
    
    let shared_secret = honest_private.diffie_hellman(&malicious_pubkey);
    
    // The shared secret becomes zero (predictable!)
    assert_eq!(shared_secret, [0u8; 32], 
        "DH with low-order point produces predictable zero shared secret");
    
    // This means Noise session keys derived from this are predictable
    // Attacker can decrypt/forge messages
}
```

**Notes:**

The validation gap exists because X25519 public key validation was not implemented, unlike Ed25519 where the codebase explicitly acknowledges small-subgroup concerns. [7](#0-6)  This inconsistency suggests the security risk was not fully considered for the network layer cryptography.

### Citations

**File:** crates/aptos-crypto/src/x25519.rs (L222-226)
```rust
impl std::convert::From<[u8; PUBLIC_KEY_SIZE]> for PublicKey {
    fn from(public_key_bytes: [u8; PUBLIC_KEY_SIZE]) -> Self {
        Self(public_key_bytes)
    }
}
```

**File:** crates/aptos-crypto/src/x25519.rs (L228-237)
```rust
impl std::convert::TryFrom<&[u8]> for PublicKey {
    type Error = traits::CryptoMaterialError;

    fn try_from(public_key_bytes: &[u8]) -> Result<Self, Self::Error> {
        let public_key_bytes: [u8; PUBLIC_KEY_SIZE] = public_key_bytes
            .try_into()
            .map_err(|_| traits::CryptoMaterialError::WrongLengthError)?;
        Ok(Self(public_key_bytes))
    }
}
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L670-692)
```text
    public entry fun initialize_validator(
        account: &signer,
        consensus_pubkey: vector<u8>,
        proof_of_possession: vector<u8>,
        network_addresses: vector<u8>,
        fullnode_addresses: vector<u8>,
    ) acquires AllowedValidators {
        check_stake_permission(account);
        // Checks the public key has a valid proof-of-possession to prevent rogue-key attacks.
        let pubkey_from_pop = &bls12381::public_key_from_bytes_with_pop(
            consensus_pubkey,
            &proof_of_possession_from_bytes(proof_of_possession)
        );
        assert!(option::is_some(pubkey_from_pop), error::invalid_argument(EINVALID_PUBLIC_KEY));

        initialize_owner(account);
        move_to(account, ValidatorConfig {
            consensus_pubkey,
            network_addresses,
            fullnode_addresses,
            validator_index: 0,
        });
    }
```

**File:** crates/aptos-crypto/src/noise.rs (L374-374)
```rust
        let re = x25519::PublicKey::from(re);
```

**File:** crates/aptos-crypto/src/noise.rs (L377-378)
```rust
        let dh_output = e.diffie_hellman(&re);
        mix_key(&mut ck, &dh_output)?;
```

**File:** crates/aptos-crypto/src/noise.rs (L394-396)
```rust
        // split
        let (k1, k2) = hkdf(&ck, None)?;
        let session = NoiseSession::new(k1, k2, rs);
```

**File:** crates/aptos-crypto/src/ed25519/ed25519_keys.rs (L100-111)
```rust
    /// Deserialize an Ed25519PublicKey without any validation checks apart from expected key size
    /// and valid curve point, although not necessarily in the prime-order subgroup.
    ///
    /// This function does NOT check the public key for membership in a small subgroup.
    pub(crate) fn from_bytes_unchecked(
        bytes: &[u8],
    ) -> std::result::Result<Ed25519PublicKey, CryptoMaterialError> {
        match ed25519_dalek::PublicKey::from_bytes(bytes) {
            Ok(dalek_public_key) => Ok(Ed25519PublicKey(dalek_public_key)),
            Err(_) => Err(CryptoMaterialError::DeserializationError),
        }
    }
```
