# Audit Report

## Title
Native Function Gas Charging Timing Vulnerability Allows Resource Exhaustion Before Out-of-Gas Detection

## Summary
Table native functions in Aptos perform expensive operations (key serialization and storage I/O) before charging the corresponding gas costs. Even with modern gas metering (gas_feature_version >= 36), attackers can trigger these expensive operations with insufficient gas, causing validator resource exhaustion before the out-of-gas condition is detected.

## Finding Description

The Aptos Move VM uses a two-phase gas charging approach for native functions: [1](#0-0) [2](#0-1) [3](#0-2) 

The `charge_native_function_before_execution` is a no-op in StandardGasMeter: [4](#0-3) 

Table native functions have `incremental_gas_charging` disabled: [5](#0-4) 

In `native_add_box`, expensive operations occur before their gas costs are charged: [6](#0-5) [7](#0-6) [8](#0-7) 

The TODO comments explicitly acknowledge this timing issue exists in multiple table operations: [9](#0-8) [10](#0-9) [11](#0-10) 

**Attack Flow:**
1. Attacker submits transaction calling `table::add()` with a large serializable key
2. Transaction has precisely calculated gas: enough for `ADD_BOX_BASE` but insufficient for full execution
3. Native function charges base cost (succeeds)
4. `serialize_key()` performs expensive CPU work serializing the large key
5. `get_or_create_global_value()` performs expensive storage I/O
6. Native attempts to charge `key_cost` and load costs
7. Out-of-gas error occurs, transaction aborts
8. **BUT**: Validator already consumed CPU cycles and performed I/O operations

The same pattern exists in `native_borrow_box`, `native_contains_box`, and `native_remove_box`.

## Impact Explanation

This vulnerability enables a **resource exhaustion attack** against validator nodes:

- **Validator CPU Exhaustion**: Attacker can force validators to perform expensive serialization operations (potentially with arbitrarily large inputs up to transaction size limits) before detecting insufficient gas.

- **Validator I/O Exhaustion**: Attacker can trigger expensive storage lookups that complete before gas charges are applied.

- **Deterministic Execution Violation**: While the transaction ultimately fails with out-of-gas, all validators waste identical resources processing it, causing synchronized slowdowns.

This qualifies as **High Severity** per Aptos bug bounty criteria:
- Causes "Validator node slowdowns" 
- Represents a "Significant protocol violation" (gas metering bypass)
- Breaks the critical invariant: "All operations must respect gas, storage, and computational limits"

The impact is bounded but significant - an attacker with modest funds can submit many such transactions to create sustained validator resource consumption.

## Likelihood Explanation

**Likelihood: HIGH**

Attack requirements:
- No special privileges needed - any user can submit transactions
- Transaction structure is straightforward (standard table operations)
- Gas calculation is deterministic - attacker can precisely compute required gas
- Exploitable on all networks running affected code

Attack complexity:
- **LOW**: Simple to execute, reproducible
- Can be automated to submit many transactions
- Affects all validators processing transactions from mempool
- No timing dependencies or race conditions

The vulnerability is currently present in production code, as evidenced by the TODO comments acknowledging the issue but not yet fixing it.

## Recommendation

**Immediate Fix**: Restructure table native functions to charge gas BEFORE performing expensive operations.

For `native_add_box`, the corrected flow should be:

```rust
fn native_add_box(
    context: &mut SafeNativeContext,
    ty_args: &[Type],
    mut args: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    context.charge(ADD_BOX_BASE)?;
    
    // Extract args first
    let val = args.pop_back().unwrap();
    let key = args.pop_back().unwrap();
    let handle = get_table_handle(&safely_pop_arg!(args, StructRef))?;
    
    // Charge MAXIMUM possible cost upfront before any work
    let max_key_size = estimate_max_serialized_size(&key)?;
    context.charge(ADD_BOX_PER_BYTE_SERIALIZED * NumBytes::new(max_key_size))?;
    context.charge(COMMON_LOAD_BASE_NEW)?; // Assume worst case load
    
    // NOW perform expensive operations
    let (extensions, mut loader_context, abs_val_gas_params, gas_feature_version) =
        context.extensions_with_loader_context_and_gas_params();
    let table_context = extensions.get::<NativeTableContext>();
    let mut table_data = table_context.table_data.borrow_mut();
    
    let table = table_data.get_or_create_table(&mut loader_context, handle, &ty_args[0], &ty_args[2])?;
    let function_value_extension = loader_context.function_value_extension();
    let key_bytes = serialize_key(&function_value_extension, &table.key_layout, &key)?;
    let (gv, loaded) = table.get_or_create_global_value(&function_value_extension, table_context, key_bytes)?;
    
    // Work is done, refund any over-charge if needed
    let actual_key_cost = ADD_BOX_PER_BYTE_SERIALIZED * NumBytes::new(key_bytes.len() as u64);
    if actual_key_cost < max_key_size { 
        // Optionally refund difference
    }
    
    // Continue with rest of function...
}
```

**Alternative Approach**: Implement a two-pass system where native functions estimate costs before execution, charge conservatively, then refund excess if actual cost is lower.

**Long-term Solution**: Remove the `with_incremental_gas_charging(false, ...)` wrapper and ensure all native functions follow the pattern: "Always remember: first charge gas, then execute!" [12](#0-11) 

## Proof of Concept

```rust
#[test]
fn test_table_gas_timing_exploit() {
    use aptos_types::transaction::TransactionPayload;
    use move_core_types::language_storage::ModuleId;
    
    // Setup: Create table and prepare large key
    let mut executor = TestExecutor::new();
    
    // Create a table
    let table_creation = create_table_transaction();
    executor.execute_and_apply(table_creation);
    
    // Craft attack transaction:
    // 1. Create very large key (e.g., 1MB vector)
    // 2. Calculate gas needed for ADD_BOX_BASE only
    // 3. Submit transaction with precisely that amount
    
    let large_key = vec![0u8; 1_000_000]; // 1MB key
    let attack_tx = transaction_builder()
        .sender(attacker_account)
        .payload(table_add_entry(table_handle, large_key, small_value))
        .max_gas_amount(calculate_base_gas_only()) // Only enough for base charge
        .build();
    
    // Execute attack
    let output = executor.execute_transaction(attack_tx);
    
    // Verify: Transaction should fail with OUT_OF_GAS
    assert!(output.status().is_discarded());
    assert_eq!(output.status().status_code(), StatusCode::OUT_OF_GAS);
    
    // Observe: Despite failure, validator performed:
    // - 1MB key serialization (expensive CPU)
    // - Storage lookup (expensive I/O)
    // These operations completed BEFORE out-of-gas detection
    
    // Attack can be repeated many times to exhaust validator resources
}
```

To demonstrate in a real environment, submit multiple transactions calling `0x1::table::add<K,V>()` with large keys and insufficient gas. Monitor validator CPU and I/O metrics to observe resource consumption despite transaction failures.

---

**Notes:**

This vulnerability exists in production code as evidenced by multiple TODO comments acknowledging the issue. While modern gas metering (version >= 36) provides better protections than legacy paths, the fundamental timing issue remains: expensive operations execute before their gas costs are fully charged. The attack is practical, requires no special privileges, and can cause measurable validator performance degradation.

### Citations

**File:** third_party/move/move-vm/runtime/src/interpreter.rs (L1090-1096)
```rust
        gas_meter.charge_native_function_before_execution(
            ty_args.iter().map(|ty| TypeWithRuntimeEnvironment {
                ty,
                runtime_environment: self.loader.runtime_environment(),
            }),
            args.iter(),
        )?;
```

**File:** third_party/move/move-vm/runtime/src/interpreter.rs (L1106-1106)
```rust
        let result = native_function(&mut native_context, ty_args, args)?;
```

**File:** third_party/move/move-vm/runtime/src/interpreter.rs (L1115-1115)
```rust
                gas_meter.charge_native_function(cost, Some(return_values.iter()))?;
```

**File:** aptos-move/aptos-gas-meter/src/meter.rs (L208-214)
```rust
    fn charge_native_function_before_execution(
        &mut self,
        _ty_args: impl ExactSizeIterator<Item = impl TypeView>,
        _args: impl ExactSizeIterator<Item = impl ValueView>,
    ) -> PartialVMResult<()> {
        Ok(())
    }
```

**File:** aptos-move/framework/table-natives/src/lib.rs (L301-301)
```rust
    builder.with_incremental_gas_charging(false, |builder| {
```

**File:** aptos-move/framework/table-natives/src/lib.rs (L394-394)
```rust
    context.charge(ADD_BOX_BASE)?;
```

**File:** aptos-move/framework/table-natives/src/lib.rs (L411-415)
```rust
    let key_bytes = serialize_key(&function_value_extension, &table.key_layout, &key)?;
    let key_cost = ADD_BOX_PER_BYTE_SERIALIZED * NumBytes::new(key_bytes.len() as u64);

    let (gv, loaded) =
        table.get_or_create_global_value(&function_value_extension, table_context, key_bytes)?;
```

**File:** aptos-move/framework/table-natives/src/lib.rs (L437-442)
```rust
    // TODO(Gas): Figure out a way to charge this earlier.
    context.charge(key_cost)?;
    if let Some(amount) = mem_usage {
        context.use_heap_memory(amount)?;
    }
    charge_load_cost(context, loaded)?;
```

**File:** aptos-move/framework/table-natives/src/lib.rs (L497-497)
```rust
    // TODO(Gas): Figure out a way to charge this earlier.
```

**File:** aptos-move/framework/table-natives/src/lib.rs (L551-551)
```rust
    // TODO(Gas): Figure out a way to charge this earlier.
```

**File:** aptos-move/framework/table-natives/src/lib.rs (L611-611)
```rust
    // TODO(Gas): Figure out a way to charge this earlier.
```

**File:** aptos-move/aptos-native-interface/src/context.rs (L69-72)
```rust
    /// Always remember: first charge gas, then execute!
    ///
    /// In other words, this function **MUST** always be called **BEFORE** executing **any**
    /// gas-metered operation or library call within a native function.
```
