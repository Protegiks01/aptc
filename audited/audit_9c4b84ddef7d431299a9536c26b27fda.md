# Audit Report

## Title
Unverified Signature Propagation via Backup Handler During Epoch History Gap

## Summary
The backup handler's `get_state_root_proof()` function returns `LedgerInfoWithSignatures` from the database without cryptographically verifying BLS aggregate signatures. Combined with a verification bypass during backup restoration when the epoch exceeds available epoch history, invalid signatures can enter the database and propagate to other nodes through the backup API, violating cryptographic correctness guarantees.

## Finding Description

This vulnerability comprises three interconnected components that collectively break the **Cryptographic Correctness** invariant:

**1. No Signature Verification in Backup Handler**

The `get_state_root_proof()` function retrieves `LedgerInfoWithSignatures` from the database and returns it directly without verifying signatures. [1](#0-0) 

The function only ensures the ledger info is from the correct epoch but never validates that the aggregated BLS signatures are cryptographically valid for that epoch's validator set.

**2. Storage Layer Bypasses Signature Verification**

When storing ledger infos during restoration, the system writes directly to the database without signature verification. [2](#0-1) 

The storage layer trusts that signatures were verified earlier in the pipeline, creating a vulnerability if earlier verification is bypassed.

**3. Critical Verification Gap During Epoch History Overflow**

During backup restoration, if the epoch being restored exceeds the available epoch history length, signature verification is completely skipped: [3](#0-2) 

The code returns `Ok(())` with only a warning, claiming "node won't be able to start if this data is malicious." However, this claim is incorrect because waypoint verification only checks content hash, not signatures: [4](#0-3) 

Waypoint verification validates version and hash (computed from ledger info content) but does NOT verify BLS signatures. Invalid signatures with correct ledger info content will pass waypoint checks.

**Normal Verification Path (bypassed by the vulnerability):** [5](#0-4) 

In the normal path, signatures ARE verified using the previous epoch's validator set via `next_epoch_state().verify()`, which calls: [6](#0-5) 

**Attack Propagation Chain:**

1. Attacker creates malicious backup with `LedgerInfoWithSignatures` containing:
   - CORRECT ledger info content (epoch, version, root_hash, timestamp, next_epoch_state)
   - INVALID/FORGED BLS aggregate signatures

2. During restoration with epoch > epoch_history.len():
   - Verification at line 287 bypassed (returns `Ok()` immediately)
   - No call to `verify_signatures()` occurs

3. Invalid signatures stored via `save_ledger_infos()` (no verification)

4. Compromised node's backup service exposes this data: [7](#0-6) 

5. Other nodes download from this compromised backup source and repeat the cycle

6. Invalid signatures propagate through the backup infrastructure

## Impact Explanation

**Severity: High**

This vulnerability breaks fundamental cryptographic guarantees in the Aptos backup infrastructure:

1. **Cryptographic Correctness Violation**: The system stores and serves `LedgerInfoWithSignatures` that were never validated by a quorum (2f+1) of validators, directly violating BFT consensus assumptions.

2. **Trust Chain Compromise**: Once invalid signatures enter one node's database, they propagate through backup/restore mechanisms. Nodes serving backup data don't re-verify signatures, creating a cascading trust violation across the network.

3. **Backup Infrastructure as Attack Vector**: The backup API becomes exploitable for distributing cryptographically invalid state commitments, undermining the integrity of the entire backup system.

4. **State Inconsistency**: Nodes operate with databases containing cryptographically incorrect data that shouldn't exist according to protocol specifications.

While this doesn't directly cause fund loss or network halts, it represents a **significant protocol violation affecting multiple nodes and backup infrastructure integrity**. Per Aptos bug bounty criteria, this qualifies as **High Severity** due to the systemic impact on backup infrastructure and potential for widespread propagation.

The vulnerability is particularly concerning because:
- The incorrect comment at line 280-285 provides false assurance
- Waypoint verification is insufficient to catch this attack
- No re-verification occurs when serving backup data
- Propagation is automatic through normal backup/restore operations

## Likelihood Explanation

**Likelihood: Medium**

The attack requires specific but realistic conditions:

**Attack Prerequisites:**
1. **Attacker Control of Backup Data**: Achievable via:
   - Compromised backup storage service
   - Man-in-the-middle during backup downloads
   - Social engineering to distribute malicious backups
   - Malicious backups in shared/public storage

2. **Victim Restoring at Epoch Boundary**: Common during:
   - New validator onboarding
   - Node recovery from corruption/extended downtime
   - Fast sync operations
   - Network upgrades with state sync

3. **Epoch History Gap**: Victim must restore epochs beyond current epoch history (realistic for new nodes joining the network)

**Why This Is Realistic:**

- New validators frequently join requiring full state restoration
- Fast sync scenarios commonly involve epoch gaps
- Network upgrades may trigger mass backup/restore operations
- Backup sources are often semi-trusted infrastructure (not fully verified)
- Attack leaves no immediate traces (node functions normally)

The attack becomes more likely during network upgrades or epoch reconfigurations when multiple nodes restore from backups simultaneously.

## Recommendation

**Fix 1: Add Signature Verification to Epoch History Gap Case**

Modify `EpochHistory::verify_ledger_info()` to require trusted waypoints for epochs beyond epoch history:

```rust
if epoch > self.epoch_endings.len() as u64 {
    // Require trusted waypoint for epochs beyond history
    let wp_li = Waypoint::new_any(li_with_sigs.ledger_info());
    let wp_trusted = self.trusted_waypoints.get(&wp_li.version())
        .ok_or_else(|| anyhow!(
            "Epoch {} is beyond epoch history (until epoch {}) and no trusted waypoint provided. \
            Cannot verify signatures without epoch history or trusted waypoint.",
            epoch,
            self.epoch_endings.len()
        ))?;
    ensure!(
        *wp_trusted == wp_li,
        "Waypoints don't match for epoch beyond history. In backup: {}, trusted: {}",
        wp_li,
        wp_trusted,
    );
    return Ok(());
}
```

**Fix 2: Add Signature Verification Before Serving Backup Data**

Add verification in `get_state_root_proof()` before returning:

```rust
// Verify signatures if validator verifier is available for this epoch
if let Ok(epoch_state) = ledger_metadata_db.get_epoch_state(epoch) {
    ledger_info.verify_signatures(&epoch_state.verifier)?;
}
```

**Fix 3: Add Signature Verification to Storage Layer**

Add optional signature verification to `save_ledger_infos()` when epoch state is available.

## Proof of Concept

**Attack Scenario:**

1. Set up malicious backup storage serving modified `StateSnapshotBackup` with:
   - Correct `TransactionInfoWithProof`
   - Correct `LedgerInfo` content (to pass waypoint hash check)
   - Invalid `AggregateSignature` (forged or empty)

2. New node joins network and initiates restore:
   - Fetches epoch history up to epoch N
   - Restores state snapshot at epoch N+5
   
3. During state snapshot restore:
   - `EpochHistory::verify_ledger_info()` called with epoch N+5
   - Epoch N+5 > N (epoch history length)
   - Line 287 returns `Ok()` without verification
   
4. Invalid signatures stored in database

5. Node's backup service now serves invalid signatures via `get_state_root_proof()` endpoint

6. Other nodes downloading from this source get infected

**Verification:**
- Check database after restore: `LedgerInfoWithSignatures` present with invalid signatures
- Query backup API: Returns unverified signatures
- Node starts successfully: Waypoint verification only checks hash, passes

## Notes

The vulnerability is confirmed by code analysis across multiple components. The TODO comment at line 280 acknowledges this as a known limitation but incorrectly claims protection via node startup verification. Waypoint verification is insufficient as it only validates content hash, not cryptographic signatures. The attack is realistic for scenarios involving new node onboarding, fast sync operations, or network recovery, making this a valid security concern requiring remediation.

### Citations

**File:** storage/aptosdb/src/backup/backup_handler.rs (L188-205)
```rust
    pub fn get_state_root_proof(
        &self,
        version: Version,
    ) -> Result<(TransactionInfoWithProof, LedgerInfoWithSignatures)> {
        let ledger_metadata_db = self.ledger_db.metadata_db();
        let epoch = ledger_metadata_db.get_epoch(version)?;
        let ledger_info = ledger_metadata_db.get_latest_ledger_info_in_epoch(epoch)?;
        let txn_info = self
            .ledger_db
            .transaction_info_db()
            .get_transaction_info_with_proof(
                version,
                ledger_info.ledger_info().version(),
                self.ledger_db.transaction_accumulator_db(),
            )?;

        Ok((txn_info, ledger_info))
    }
```

**File:** storage/aptosdb/src/backup/restore_utils.rs (L41-58)
```rust
pub(crate) fn save_ledger_infos(
    ledger_metadata_db: &LedgerMetadataDb,
    ledger_infos: &[LedgerInfoWithSignatures],
    existing_batch: Option<&mut SchemaBatch>,
) -> Result<()> {
    ensure!(!ledger_infos.is_empty(), "No LedgerInfos to save.");

    if let Some(existing_batch) = existing_batch {
        save_ledger_infos_impl(ledger_metadata_db, ledger_infos, existing_batch)?;
    } else {
        let mut batch = SchemaBatch::new();
        save_ledger_infos_impl(ledger_metadata_db, ledger_infos, &mut batch)?;
        ledger_metadata_db.write_schemas(batch)?;
        update_latest_ledger_info(ledger_metadata_db, ledger_infos)?;
    }

    Ok(())
}
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L136-147)
```rust
                } else if let Some(pre_li) = previous_li {
                    pre_li
                        .ledger_info()
                        .next_epoch_state()
                        .ok_or_else(|| {
                            anyhow!(
                                "Next epoch state not found from LI at epoch {}.",
                                pre_li.ledger_info().epoch()
                            )
                        })?
                        .verify(&li)?;
                }
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L279-287)
```rust
        if epoch > self.epoch_endings.len() as u64 {
            // TODO(aldenhu): fix this from upper level
            warn!(
                epoch = epoch,
                epoch_history_until = self.epoch_endings.len(),
                "Epoch is too new and can't be verified. Previous chunks are verified and node \
                won't be able to start if this data is malicious."
            );
            return Ok(());
```

**File:** types/src/waypoint.rs (L62-79)
```rust
    pub fn verify(&self, ledger_info: &LedgerInfo) -> Result<()> {
        ensure!(
            ledger_info.version() == self.version(),
            "Waypoint version mismatch: waypoint version = {}, given version = {}",
            self.version(),
            ledger_info.version()
        );
        let converter = Ledger2WaypointConverter::new(ledger_info);
        ensure!(
            converter.hash() == self.value(),
            format!(
                "Waypoint value mismatch: waypoint value = {}, given value = {}",
                self.value().to_hex(),
                converter.hash().to_hex()
            )
        );
        Ok(())
    }
```

**File:** types/src/epoch_state.rs (L41-49)
```rust
    fn verify(&self, ledger_info: &LedgerInfoWithSignatures) -> anyhow::Result<()> {
        ensure!(
            self.epoch == ledger_info.ledger_info().epoch(),
            "LedgerInfo has unexpected epoch {}, expected {}",
            ledger_info.ledger_info().epoch(),
            self.epoch
        );
        ledger_info.verify_signatures(&self.verifier)?;
        Ok(())
```

**File:** storage/backup/backup-service/src/handlers/mod.rs (L83-88)
```rust
    let state_root_proof = warp::path!(Version)
        .map(move |version| {
            reply_with_bcs_bytes(STATE_ROOT_PROOF, &bh.get_state_root_proof(version)?)
        })
        .map(unwrap_or_500)
        .recover(handle_rejection);
```
