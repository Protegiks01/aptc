# Audit Report

## Title
Script Type Parameter Count Underestimation Leads to Validator Node Crash (Assertion Panic in Bytecode Verifier)

## Summary
The `max_num_of_ty_params_or_args()` function in the Move bytecode verifier fails to account for script-level type parameter declarations, causing it to underestimate the required bitset size for `BitsetTypeParameterConstraints`. When the `SIGNATURE_CHECKER_V2_SCRIPT_FIX` feature flag is disabled, an attacker can submit a malicious script with more type parameters than the verifier expects, triggering a runtime assertion panic that crashes validator nodes. [1](#0-0) 

## Finding Description
The vulnerability exists in the type parameter counting logic for script verification. The `max_num_of_ty_params_or_args()` function calculates the maximum number of type parameters needed to size the `BitsetTypeParameterConstraints` bitset, but it only checks:
- Function handle type parameter lengths
- Struct handle type parameter lengths  
- Type parameter indices referenced in signatures and field definitions

**Critical Omission**: For scripts, it does NOT check `script.type_parameters.len()` - the script's own type parameter count. [2](#0-1) 

When `verify_script()` is called without the fix flag enabled, it uses the underestimated value to choose an insufficient bitset size (N=1, N=2, or N=16 words). Later, when `verify_script_impl()` constructs `BitsetTypeParameterConstraints::from(script.type_parameters.as_slice())`, the `FromIterator` implementation attempts to insert type parameter indices that exceed the bitset's capacity, triggering the assertion at line 71. [3](#0-2) 

**Attack Path:**
1. Attacker creates a `CompiledScript` with `type_parameters: Vec<AbilitySet>` of length 17 (exceeding NUM_PARAMS_PER_WORD = 16)
2. The script contains no actual references to these type parameters in signatures or code
3. `max_num_of_ty_params_or_args()` returns 0 (no usage detected)
4. Without the fix flag, `max_num = 0`
5. Since `0 <= 16`, `verify_script_impl::<1>` is called with N=1 (bitset can hold max 16 type params)
6. At line 1191, `BitsetTypeParameterConstraints::from()` iterates through all 17 type parameters
7. When inserting index 16: assertion `16 < 1 * 16` evaluates to FALSE
8. **PANIC: Validator node crashes** [4](#0-3) 

**Current Mitigation Status:**
The vulnerability is mitigated by the `sig_checker_v2_fix_script_ty_param_count` flag which adds the missing check. This flag is enabled by default in production. [5](#0-4) [6](#0-5) 

However, the vulnerability remains exploitable if:
- The feature flag is disabled through on-chain governance
- Custom Aptos deployments don't enable the flag
- Testnet or development environments lack the fix

## Impact Explanation
**Severity: HIGH** (per Aptos Bug Bounty criteria)

This vulnerability enables a **Denial of Service attack against validator nodes**, fitting the HIGH severity category:
- **Validator node crashes**: The assertion panic causes immediate termination of the verifier process
- **Network availability impact**: If multiple validators verify the malicious script simultaneously, it can cause widespread node failures
- **Consensus disruption**: Loss of validators can impact block production and finalization

The attack requires only the ability to submit a transaction script to the network - no special privileges needed. The malicious script can be crafted to pass initial validation checks while carrying the payload that crashes the verifier.

This breaks the **Move VM Safety** invariant: "Bytecode execution must respect gas limits and memory constraints" - the verifier should reject invalid bytecode gracefully, not crash.

## Likelihood Explanation
**Likelihood: MEDIUM to LOW**

The attack is straightforward to execute (crafting a malicious script requires only modifying type parameter counts in the binary format), but exploitation requires:

1. **Feature flag disabled**: The fix must be turned off, which currently requires governance action
2. **Network access**: Attacker must be able to submit scripts to the network
3. **Timing window**: The attack only works while the flag is disabled

Given that the fix is enabled by default in production, the current likelihood is LOW for mainnet. However, the likelihood increases to MEDIUM for:
- Testnets or development networks
- Custom Aptos forks or deployments
- Scenarios where governance disables the flag for compatibility reasons

The vulnerability is deterministic - once conditions are met, the attack succeeds 100% of the time.

## Recommendation
The existing fix is correct but should be made permanent and unconditional:

**Recommended Fix:** Remove the feature flag dependency and always check script type parameter count:

```rust
pub fn verify_script(config: &VerifierConfig, script: &CompiledScript) -> VMResult<()> {
    let mut max_num = max_num_of_ty_params_or_args(BinaryIndexedView::Script(script));
    // ALWAYS check script's own type parameter count
    max_num = max_num.max(script.type_parameters.len());
    
    // ... rest of function
}
```

**Additional Hardening:**
1. Convert the assertion at line 71 to return a proper error instead of panicking:
```rust
fn insert(&mut self, ty_param_idx: TypeParameterIndex, required_abilities: AbilitySet) -> PartialVMResult<()> {
    if (ty_param_idx as usize) >= N * NUM_PARAMS_PER_WORD {
        return Err(PartialVMError::new(StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR)
            .with_message(format!("Type parameter index {} exceeds maximum {}", 
                ty_param_idx, N * NUM_PARAMS_PER_WORD)));
    }
    // ... rest of function
}
```

2. Mark the `SIGNATURE_CHECKER_V2_SCRIPT_FIX` feature flag as non-disableable in production environments

## Proof of Concept

```rust
#[test]
#[should_panic(expected = "Type parameter index out of bounds")]
fn test_script_type_param_underestimation_panic() {
    use move_binary_format::file_format::*;
    use move_bytecode_verifier::{verify_script, VerifierConfig};
    use move_core_types::{ability::AbilitySet, account_address::AccountAddress, identifier::Identifier};

    // Create a script with 17 type parameters (exceeds NUM_PARAMS_PER_WORD = 16)
    let script = CompiledScript {
        version: move_binary_format::file_format_common::VERSION_MAX,
        module_handles: vec![ModuleHandle {
            address: AddressIdentifierIndex(0),
            name: IdentifierIndex(0),
        }],
        struct_handles: vec![],
        function_handles: vec![],
        function_instantiations: vec![],
        signatures: vec![Signature(vec![])],
        identifiers: vec![Identifier::new("test").unwrap()],
        address_identifiers: vec![AccountAddress::ZERO],
        constant_pool: vec![],
        metadata: vec![],
        
        // Critical: 17 type parameters declared but never used
        type_parameters: vec![AbilitySet::EMPTY; 17],
        
        parameters: SignatureIndex(0),
        code: CodeUnit {
            locals: SignatureIndex(0),
            code: vec![Bytecode::Ret],
        },
        access_specifiers: None,
    };

    // Configure verifier with the fix DISABLED
    let mut config = VerifierConfig::default();
    config.sig_checker_v2_fix_script_ty_param_count = false;

    // This should panic with "Type parameter index out of bounds"
    // when it tries to create BitsetTypeParameterConstraints with N=1
    // but script has 17 type parameters
    verify_script(&config, &script).unwrap();
}
```

## Notes
- This is a **known and patched vulnerability** in the Aptos codebase, confirmed by the existence of the `SIGNATURE_CHECKER_V2_SCRIPT_FIX` feature flag
- The fix is enabled by default in production environments as of the current codebase version
- Similar logic exists for module verification but is NOT vulnerable - module verification correctly checks function handle and struct handle type parameter counts
- The vulnerability specifically affects **scripts only**, not compiled modules
- The root cause is the architectural decision to have script-level type parameters separate from handle type parameters, which wasn't accounted for in the original implementation of `max_num_of_ty_params_or_args()`

### Citations

**File:** third_party/move/move-bytecode-verifier/src/signature_v2.rs (L37-56)
```rust
impl<const N: usize> FromIterator<(TypeParameterIndex, AbilitySet)>
    for BitsetTypeParameterConstraints<N>
{
    fn from_iter<T: IntoIterator<Item = (TypeParameterIndex, AbilitySet)>>(iter: T) -> Self {
        let mut constraints = Self::new();
        for (idx, abilities) in iter.into_iter() {
            constraints.insert(idx, abilities);
        }
        constraints
    }
}

impl<'a, const N: usize> From<&'a [AbilitySet]> for BitsetTypeParameterConstraints<N> {
    fn from(abilities: &'a [AbilitySet]) -> Self {
        abilities
            .iter()
            .enumerate()
            .map(|(idx, abilities)| (idx as TypeParameterIndex, *abilities))
            .collect()
    }
```

**File:** third_party/move/move-bytecode-verifier/src/signature_v2.rs (L71-77)
```rust
        assert!(
            (ty_param_idx as usize) < N * NUM_PARAMS_PER_WORD,
            "Type parameter index out of bounds. \
             The current Bitset implementation is only configured to handle \
             {} type parameters at max.",
            N * NUM_PARAMS_PER_WORD
        );
```

**File:** third_party/move/move-bytecode-verifier/src/signature_v2.rs (L1201-1251)
```rust
fn max_num_of_ty_params_or_args(resolver: BinaryIndexedView) -> usize {
    let mut n = 0;

    for fh in resolver.function_handles() {
        n = n.max(fh.type_parameters.len())
    }

    for sh in resolver.struct_handles() {
        n = n.max(sh.type_parameters.len())
    }

    for sig in resolver.signatures() {
        for ty in &sig.0 {
            for ty in ty.preorder_traversal() {
                if let SignatureToken::TypeParameter(ty_param_idx) = ty {
                    n = n.max(*ty_param_idx as usize + 1)
                }
            }
        }
    }

    if let Some(struct_defs) = resolver.struct_defs() {
        for struct_def in struct_defs {
            match &struct_def.field_information {
                StructFieldInformation::Native => {},
                StructFieldInformation::Declared(fields) => {
                    for field in fields {
                        for ty in field.signature.0.preorder_traversal() {
                            if let SignatureToken::TypeParameter(ty_param_idx) = ty {
                                n = n.max(*ty_param_idx as usize + 1)
                            }
                        }
                    }
                },
                StructFieldInformation::DeclaredVariants(variants) => {
                    for variant in variants {
                        for field in &variant.fields {
                            for ty in field.signature.0.preorder_traversal() {
                                if let SignatureToken::TypeParameter(ty_param_idx) = ty {
                                    n = n.max(*ty_param_idx as usize + 1)
                                }
                            }
                        }
                    }
                },
            }
        }
    }

    n
}
```

**File:** third_party/move/move-bytecode-verifier/src/signature_v2.rs (L1273-1291)
```rust
pub fn verify_script(config: &VerifierConfig, script: &CompiledScript) -> VMResult<()> {
    let mut max_num = max_num_of_ty_params_or_args(BinaryIndexedView::Script(script));
    if config.sig_checker_v2_fix_script_ty_param_count {
        max_num = max_num.max(script.type_parameters.len());
    }

    let res = if max_num <= NUM_PARAMS_PER_WORD {
        verify_script_impl::<1>(config, script)
    } else if max_num <= NUM_PARAMS_PER_WORD * 2 {
        verify_script_impl::<2>(config, script)
    } else if max_num <= NUM_PARAMS_PER_WORD * 16 {
        verify_script_impl::<16>(config, script)
    } else {
        return Err(
            PartialVMError::new(StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR)
                .with_message("too many type parameters/arguments in the program".to_string())
                .finish(Location::Undefined),
        );
    };
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L145-148)
```rust
pub fn aptos_prod_verifier_config(gas_feature_version: u64, features: &Features) -> VerifierConfig {
    let sig_checker_v2_fix_script_ty_param_count =
        features.is_enabled(FeatureFlag::SIGNATURE_CHECKER_V2_SCRIPT_FIX);
    let sig_checker_v2_fix_function_signatures = gas_feature_version >= RELEASE_V1_34;
```

**File:** types/src/on_chain_config/aptos_features.rs (L203-203)
```rust
            FeatureFlag::SIGNATURE_CHECKER_V2_SCRIPT_FIX,
```
