# Audit Report

## Title
FederatedKeyless JWK Address Manipulation Enables Transaction Filter Bypass

## Summary
The `jwk_addr` field in `FederatedKeylessPublicKey` is user-controlled and can be set to any arbitrary address. The transaction filtering system incorrectly treats this field as an address association marker, allowing attackers to bypass address-based filters by manipulating `jwk_addr` to match whitelisted addresses or avoid blocklisted addresses. [1](#0-0) 

## Finding Description

The vulnerability stems from a semantic confusion in how `jwk_addr` is interpreted. This field was designed to indicate **where** JWKs (JSON Web Keys) should be looked up during signature validation, but the transaction filter treats it as an **identity/association** marker.

The attack flow works as follows:

1. **Transaction Filter Setup**: Node operators configure filters using `TransactionMatcher::AccountAddress(target_address)` to allow/deny transactions involving specific addresses.

2. **Filter Matching Logic**: When checking if a transaction matches an address filter, the system calls `matches_transaction_authenticator_address()`, which for SingleKey/MultiKey authenticators calls `matches_any_public_key_address()`. [2](#0-1) 

3. **Vulnerable Comparison**: For FederatedKeyless public keys, this function simply compares `public_key.jwk_addr == *address` without validating that the user has any legitimate relationship to that address.

4. **User-Controlled Field**: The `jwk_addr` field is completely user-controlled during account creation, with no validation of ownership or authority over that address. [3](#0-2) [4](#0-3) 

5. **Filter Application Points**: These filters are applied at multiple critical points:
   - Mempool transaction admission
   - Consensus batch processing  
   - QuorumStore transaction filtering [5](#0-4) 

### Attack Scenarios

**Scenario 1: Whitelist Bypass**
- Operator configures: `Allow([AccountAddress(TRUSTED_ADDR)])`
- Attacker creates FederatedKeyless account with `jwk_addr = TRUSTED_ADDR`
- Transaction passes filter because `jwk_addr == TRUSTED_ADDR`
- Transaction later fails signature validation (if JWKs not installed), but filter decision already made

**Scenario 2: Blacklist Evasion**
- Operator configures: `Deny([AccountAddress(BLOCKED_ADDR)])`
- Attacker's actual identity would be blocked
- Attacker sets `jwk_addr = SOME_OTHER_ADDR`
- Transaction passes filter because `jwk_addr != BLOCKED_ADDR`
- Transaction proceeds through mempool/consensus before eventual validation

### Why This is a Problem

The `jwk_addr` field serves a **validation purpose** (where to find JWKs) but is being used for an **authorization purpose** (address association). During signature validation, the system correctly fetches JWKs from the specified address: [6](#0-5) 

However, by the time validation occurs, the filtering decision has already been made based on the fake address association. While invalid transactions eventually fail, they've already consumed resources and violated policy intent.

## Impact Explanation

This vulnerability qualifies as **Medium Severity** per Aptos bug bounty criteria:

**Why Not Critical:**
- No funds loss or theft (transactions with invalid JWKs fail signature verification)
- No consensus safety violation (validators still reject invalid signatures)
- No permanent state corruption or network partition

**Why Medium:**
- **Policy Violation**: Subverts the intended purpose of transaction filters, which are meant to enforce node operator policies
- **Resource Waste**: Validators expend computational resources processing transactions that will eventually fail validation
- **DoS Potential**: Attackers could flood mempool with filter-bypassing transactions that consume resources before being rejected
- **Operational Impact**: Creates inconsistent filtering behavior where transactions appear to be from trusted addresses but aren't

The impact aligns with "State inconsistencies requiring intervention" - while not corrupting on-chain state, it creates operational inconsistencies in how transactions are filtered vs. validated.

## Likelihood Explanation

**High Likelihood:**

1. **Easy to Exploit**: Creating a FederatedKeyless account with arbitrary `jwk_addr` is straightforward using the SDK - requires no special privileges or complex setup.

2. **No Validation Barriers**: There are no checks preventing users from setting `jwk_addr` to any address they choose.

3. **Common Use Case**: Transaction filters are commonly used by node operators to enforce policies, making the attack surface broad.

4. **Immediate Impact**: The bypass occurs at the first filtering checkpoint (mempool admission), providing immediate benefit to attackers.

5. **Low Detection Risk**: The manipulation is subtle - transactions appear legitimate until signature validation fails deep in the processing pipeline.

## Recommendation

**Fix the Semantic Confusion:**

The `jwk_addr` field should NOT be used for address association in filters. Instead, the filter should skip FederatedKeyless public keys when matching addresses, or use a different field that actually represents the account's identity.

**Option 1: Exclude FederatedKeyless from Address Matching (Recommended)**

Modify `matches_any_public_key_address()` to return `false` for FederatedKeyless keys:

```rust
fn matches_any_public_key_address(any_public_key: &AnyPublicKey, address: &AccountAddress) -> bool {
    match any_public_key {
        AnyPublicKey::Ed25519 { .. }
        | AnyPublicKey::Secp256k1Ecdsa { .. }
        | AnyPublicKey::Secp256r1Ecdsa { .. }
        | AnyPublicKey::SlhDsa_Sha2_128s { .. }
        | AnyPublicKey::Keyless { .. }
        | AnyPublicKey::FederatedKeyless { .. } => false,  // Don't use jwk_addr for matching
    }
}
```

**Option 2: Use Authentication Key or Account Address**

If address-based filtering for FederatedKeyless accounts is needed, derive it from the account's actual authentication key, not the JWK storage location.

**Additional Safeguards:**

1. Add validation in `patch_federated_jwks()` to verify that only the address owner can install JWKs (already partially implemented but could be strengthened). [7](#0-6) 

2. Document clearly that `jwk_addr` is for JWK lookup only and should not be used for authorization decisions.

3. Add warnings in SDK documentation about the security implications of `jwk_addr` values.

## Proof of Concept

```rust
#[test]
fn test_federated_keyless_filter_bypass() {
    use aptos_types::{
        keyless::{FederatedKeylessPublicKey, KeylessPublicKey, IdCommitment, Pepper},
        transaction::authenticator::AnyPublicKey,
    };
    use move_core_types::account_address::AccountAddress;
    use aptos_transaction_filters::{
        transaction_filter::{TransactionFilter, TransactionMatcher},
    };

    // Simulate a trusted address that should be allowed through filters
    let trusted_address = AccountAddress::from_hex_literal("0xcafe").unwrap();
    
    // Attacker creates a FederatedKeyless public key with jwk_addr = trusted_address
    let attacker_pk = KeylessPublicKey {
        iss_val: "https://attacker.com".to_string(),
        idc: IdCommitment(vec![0u8; 32]),
    };
    
    let attacker_fed_pk = FederatedKeylessPublicKey {
        jwk_addr: trusted_address,  // Attacker sets this to trusted address!
        pk: attacker_pk,
    };
    
    let any_pk = AnyPublicKey::FederatedKeyless { 
        public_key: attacker_fed_pk 
    };
    
    // Create a whitelist filter that only allows the trusted address
    let filter = TransactionFilter::empty()
        .add_account_address_filter(true, trusted_address)
        .add_all_filter(false);
    
    // Create a transaction signed with the attacker's FederatedKeyless key
    // (Transaction creation details omitted for brevity - would use SingleKey authenticator)
    
    // The filter will INCORRECTLY match this transaction because:
    // matches_any_public_key_address(&any_pk, &trusted_address) returns TRUE
    // even though the attacker has no legitimate relationship to trusted_address
    
    assert!(crate::transaction_filter::matches_any_public_key_address(
        &any_pk, 
        &trusted_address
    )); // This should NOT be true for security!
}
```

**Notes:**
- The transaction would eventually fail signature validation when JWKs aren't found at `trusted_address`
- However, the filter bypass has already occurred, allowing the transaction into mempool/consensus
- This wastes validator resources and violates the operator's intended security policy
- The semantic confusion between "JWK storage location" and "address association" is the root cause

### Citations

**File:** crates/aptos-transaction-filters/src/transaction_filter.rs (L258-280)
```rust
/// Returns true iff the account authenticator contains the given account address
fn matches_account_authenticator_address(
    account_authenticator: &AccountAuthenticator,
    address: &AccountAddress,
) -> bool {
    // Match all variants explicitly to ensure future enum changes are caught during compilation
    match account_authenticator {
        AccountAuthenticator::Ed25519 { .. }
        | AccountAuthenticator::MultiEd25519 { .. }
        | AccountAuthenticator::NoAccountAuthenticator => false,
        AccountAuthenticator::SingleKey { authenticator } => {
            matches_any_public_key_address(authenticator.public_key(), address)
        },
        AccountAuthenticator::MultiKey { authenticator } => authenticator
            .public_keys()
            .public_keys()
            .iter()
            .any(|any_public_key| matches_any_public_key_address(any_public_key, address)),
        AccountAuthenticator::Abstract { authenticator } => {
            authenticator.function_info().module_address == *address
        },
    }
}
```

**File:** crates/aptos-transaction-filters/src/transaction_filter.rs (L312-325)
```rust
fn matches_any_public_key_address(any_public_key: &AnyPublicKey, address: &AccountAddress) -> bool {
    // Match all variants explicitly to ensure future enum changes are caught during compilation
    match any_public_key {
        AnyPublicKey::Ed25519 { .. }
        | AnyPublicKey::Secp256k1Ecdsa { .. }
        | AnyPublicKey::Secp256r1Ecdsa { .. }
        | AnyPublicKey::SlhDsa_Sha2_128s { .. }
        | AnyPublicKey::Keyless { .. } => false,
        AnyPublicKey::FederatedKeyless { public_key } => {
            // Check if the public key's JWK address matches the given address
            public_key.jwk_addr == *address
        },
    }
}
```

**File:** types/src/keyless/mod.rs (L374-379)
```rust
#[derive(Clone, Debug, Eq, PartialEq, Hash, Serialize, Deserialize)]
#[cfg_attr(feature = "fuzzing", derive(arbitrary::Arbitrary))]
pub struct FederatedKeylessPublicKey {
    pub jwk_addr: AccountAddress,
    pub pk: KeylessPublicKey,
}
```

**File:** sdk/src/types.rs (L1067-1074)
```rust
            let federated_account = FederatedKeylessAccount::new_from_jwt(
                jwt,
                ephemeral_key_pair,
                jwk_addr,
                Some("sub"),
                pepper.clone(),
                zksig,
            )?;
```

**File:** mempool/src/shared_mempool/tasks.rs (L408-466)
```rust
fn filter_transactions(
    transaction_filter_config: &TransactionFilterConfig,
    transactions: Vec<(
        SignedTransaction,
        Option<u64>,
        Option<BroadcastPeerPriority>,
    )>,
    statuses: &mut Vec<(SignedTransaction, (MempoolStatus, Option<StatusCode>))>,
) -> Vec<(
    SignedTransaction,
    Option<u64>,
    Option<BroadcastPeerPriority>,
)> {
    // If the filter is not enabled, return early
    if !transaction_filter_config.is_enabled() {
        return transactions;
    }

    // Start the filter processing timer
    let transaction_filter_timer = counters::PROCESS_TXN_BREAKDOWN_LATENCY
        .with_label_values(&[counters::FILTER_TRANSACTIONS_LABEL])
        .start_timer();

    // Filter the transactions and update the statuses accordingly
    let transactions = transactions
        .into_iter()
        .filter_map(|(transaction, account_sequence_number, priority)| {
            if transaction_filter_config
                .transaction_filter()
                .allows_transaction(&transaction)
            {
                Some((transaction, account_sequence_number, priority))
            } else {
                info!(LogSchema::event_log(
                    LogEntry::TransactionFilter,
                    LogEvent::TransactionRejected
                )
                .message(&format!(
                    "Transaction {} rejected by filter",
                    transaction.committed_hash()
                )));

                statuses.push((
                    transaction.clone(),
                    (
                        MempoolStatus::new(MempoolStatusCode::RejectedByFilter),
                        None,
                    ),
                ));
                None
            }
        })
        .collect();

    // Update the filter processing latency metrics
    transaction_filter_timer.stop_and_record();

    transactions
}
```

**File:** aptos-move/aptos-vm/src/keyless_validation.rs (L236-260)
```rust
        // Try looking up the jwk in 0x1.
        let jwk = match get_jwk_for_authenticator(&patched_jwks.jwks, pk.inner_keyless_pk(), sig) {
            // 1: If found in 0x1, then we consider that the ground truth & we are done.
            Ok(jwk) => jwk,
            // 2: If not found in 0x1, we check the Keyless PK type.
            Err(e) => {
                match pk {
                    // 2.a: If this is a federated keyless account; look in `jwk_addr` for JWKs
                    AnyKeylessPublicKey::Federated(fed_pk) => {
                        let federated_jwks =
                            get_federated_jwks_onchain(resolver, &fed_pk.jwk_addr, module_storage)
                                .map_err(|_| {
                                    invalid_signature!(format!(
                                        "Could not fetch federated PatchedJWKs at {}",
                                        fed_pk.jwk_addr
                                    ))
                                })?;
                        // 2.a.i If not found in jwk_addr either, then we fail the validation.
                        get_jwk_for_authenticator(&federated_jwks.jwks, pk.inner_keyless_pk(), sig)?
                    },
                    // 2.b: If this is not a federated keyless account, then we fail the validation.
                    AnyKeylessPublicKey::Normal(_) => return Err(e),
                }
            },
        };
```

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L183-203)
```text
    public fun patch_federated_jwks(jwk_owner: &signer, patches: vector<Patch>) acquires FederatedJWKs {
        // Prevents accidental calls in 0x1::jwks that install federated JWKs at the Aptos framework address.
        assert!(!system_addresses::is_aptos_framework_address(signer::address_of(jwk_owner)),
            error::invalid_argument(EINSTALL_FEDERATED_JWKS_AT_APTOS_FRAMEWORK)
        );

        let jwk_addr = signer::address_of(jwk_owner);
        if (!exists<FederatedJWKs>(jwk_addr)) {
            move_to(jwk_owner, FederatedJWKs { jwks: AllProvidersJWKs { entries: vector[] } });
        };

        let fed_jwks = borrow_global_mut<FederatedJWKs>(jwk_addr);
        vector::for_each_ref(&patches, |obj|{
            let patch: &Patch = obj;
            apply_patch(&mut fed_jwks.jwks, *patch);
        });

        // TODO: Can we check the size more efficiently instead of serializing it via BCS?
        let num_bytes = vector::length(&bcs::to_bytes(fed_jwks));
        assert!(num_bytes < MAX_FEDERATED_JWKS_SIZE_BYTES, error::invalid_argument(EFEDERATED_JWKS_TOO_LARGE));
    }
```
