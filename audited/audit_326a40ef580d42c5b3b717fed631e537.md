# Audit Report

## Title
OptQS Parameter Attack: Malicious Leader Can Censor Validators Through Misplaced Blame in Availability Checking

## Summary
A malicious block proposer can exploit the OptQuorumStore (OptQS) batch availability checking mechanism to systematically censor specific validators by including their batches when those batches are not widely replicated, causing other validators to incorrectly blame the batch authors rather than the proposer, resulting in those validators being excluded from future OptQS proposals.

## Finding Description

The OptQuorumStore feature allows proposers to include batches without proof-of-store quorum signatures (`opt_batches`) for improved throughput. However, the system contains a critical design flaw in how batch availability is checked and how blame is assigned for unavailable batches.

**The Attack Flow:**

1. **Batch Inclusion**: The proposer pulls opt_batches from their local proof queue using `pull_batches()` with `exclude_authors` parameter that filters specific validators. [1](#0-0) 

2. **Lack of Availability Guarantee**: OptQS batches require only author validation, not quorum availability verification. [2](#0-1) 

3. **Misplaced Blame Mechanism**: When validators receive a proposal, they check if opt_batches exist locally. If a batch is missing, they mark the **batch author** (not the proposer) as unavailable. [3](#0-2) 

4. **Blame Propagation**: Missing authors are reported in timeout votes, which feeds into the failure tracker. [4](#0-3) 

5. **Persistent Censorship**: The failure tracker extracts `missing_authors` from past timeouts and adds them to `exclude_authors` for future OptQS proposals, creating a censorship feedback loop. [5](#0-4) 

**The Vulnerability:**

A malicious proposer can:
- Include batches from victim validators that are fresh (not widely replicated)
- Include batches that only exist in the proposer's local queue
- Cause honest validators to mark victim validators as having "unavailable" batches
- Over multiple rounds, get victim validators persistently excluded via the exponential window failure tracker

The `exclude_authors` HashSet is used to filter out entire validators from batch selection: [6](#0-5) 

This allows the malicious proposer to exclude all other validators' batches or include only specific validators' batches by manipulating which batches appear unavailable to honest nodes.

## Impact Explanation

**Severity: High**

This vulnerability constitutes a significant protocol violation that enables:

1. **Censorship Attack**: A malicious proposer can systematically exclude specific validators' transactions from blocks by causing them to be added to `exclude_authors`

2. **Consensus Fairness Violation**: The OptQS mechanism is designed to include batches from all validators fairly, but this attack allows selective censorship

3. **Liveness Degradation**: If multiple validators are excluded, the effective transaction throughput decreases as fewer batches are included

4. **Persistent Effect**: The exponential window failure tracker (with configurable max_window) means exclusion can persist for many rounds, potentially indefinitely if the attacker is frequently selected as proposer

The attack does not directly cause consensus safety violations (forks) but significantly impacts consensus liveness and fairness, meeting the **High Severity** criteria of "Significant protocol violations" per the Aptos bug bounty program.

## Likelihood Explanation

**Likelihood: Medium to High**

The attack is feasible because:

1. **Regular Opportunity**: Any validator becomes proposer in rotation based on proposer election, giving regular opportunities for exploitation

2. **No Additional Privileges Required**: The attacker only needs to be a validator and wait for their turn as proposer

3. **Difficult to Detect**: The blame is misplaced on batch authors, making it appear as though those validators are experiencing availability issues rather than being attacked

4. **No Cryptographic Barriers**: The attack exploits logic flaws, not cryptographic weaknesses

5. **Existing Infrastructure**: The attack uses the existing OptQS mechanism without modification

The main limiting factors are:
- The attacker can only act when they are the proposer (frequency depends on validator count)
- Other validators must not have the targeted batches for the attack to succeed
- The failure tracker has built-in recovery (resets window after consecutive successes)

## Recommendation

**Fix 1: Include Proposer in Blame Assignment**

When checking payload availability, also track which proposer included unavailable batches and exclude proposers (not just batch authors) from OptQS if they repeatedly include unavailable batches.

**Fix 2: Add Quorum Availability Requirement**

Before including batches in `opt_batches`, require evidence that they are available to at least a quorum of validators. This could be done via:
- Requiring minimum batch age (already partially implemented with `minimum_batch_age_usecs`)
- Gossiping batch availability information
- Only including batches that have been gossiped for sufficient time

**Fix 3: Separate Timeout Reasons**

Distinguish between "batch unavailable due to author" vs "batch unavailable due to proposer selection" in timeout reasons, so the failure tracker can correctly identify malicious proposers.

**Example Fix for payload availability check:**

```rust
// In check_payload_availability
Payload::OptQuorumStore(OptQuorumStorePayload::V1(p)) => {
    let mut missing_authors = BitVec::with_num_bits(self.ordered_authors.len() as u16);
    let mut unavailable_count = 0;
    for batch in p.opt_batches().deref() {
        if self.batch_reader.exists(batch.digest()).is_none() {
            let index = *self.address_to_validator_index
                .get(&batch.author())
                .expect("Payload author should have been verified");
            missing_authors.set(index as u16);
            unavailable_count += 1;
        }
    }
    
    // If too many batches are unavailable, blame the proposer instead
    if unavailable_count > p.opt_batches().len() / 2 {
        // Return proposer-specific error
        Err(ProposerIncludedUnavailableBatches { 
            proposer: block.author(),
            missing_authors 
        })
    } else if missing_authors.all_zeros() {
        Ok(())
    } else {
        Err(missing_authors)
    }
}
```

## Proof of Concept

While a full end-to-end PoC would require a multi-node testnet setup, the vulnerability can be demonstrated conceptually:

```rust
// Conceptual PoC showing the attack flow
// This would be run as a Rust integration test with multiple nodes

#[test]
fn test_optqs_censorship_attack() {
    // Setup: 4 validators, validator_0 is malicious
    let (nodes, mut runtime) = setup_test_network(4);
    let malicious_node = &nodes[0];
    let victim_node = &nodes[1];
    
    // Step 1: Victim creates fresh batches
    victim_node.create_fresh_batches(batch_count = 10);
    // Don't gossip them widely yet
    
    // Step 2: Malicious node becomes proposer
    runtime.advance_to_proposer(malicious_node.author());
    
    // Step 3: Malicious node pulls victim's fresh batches into opt_batches
    // These batches exist in malicious node's queue but not in other nodes
    let proposal = malicious_node.create_optqs_proposal(
        include_batches_from: vec![victim_node.author()],
        minimum_age: 0, // Include very fresh batches
    );
    
    // Step 4: Broadcast proposal to network
    malicious_node.broadcast_proposal(proposal);
    
    // Step 5: Honest nodes check availability
    for node in nodes[2..].iter() {
        let result = node.check_payload_availability(&proposal);
        // Honest nodes don't have victim's fresh batches
        assert!(result.is_err());
        let missing = result.unwrap_err();
        // They blame the victim, not the malicious proposer!
        assert!(missing.get(victim_node.validator_index()));
    }
    
    // Step 6: Timeout occurs, victim is blamed
    runtime.advance_until_timeout();
    
    // Step 7: Next round, victim is excluded from OptQS
    runtime.advance_to_next_round();
    let next_proposal = nodes[2].create_optqs_proposal_as_leader();
    let excluded = next_proposal.get_excluded_authors();
    assert!(excluded.contains(&victim_node.author()));
    
    // Attack succeeded: victim is now censored from OptQS
}
```

The attack succeeds because the availability check blames batch authors rather than the proposer who chose to include unavailable batches, creating a systematic censorship mechanism.

## Notes

This vulnerability exploits a fundamental design flaw in the OptQS availability checking and blame assignment mechanism. The system assumes that batch unavailability indicates problems with the batch author, when in reality it may indicate that the proposer included batches that were not sufficiently replicated. The `maybe_optqs_payload_pull_params` can indirectly be manipulated through this attack by poisoning the failure tracker with false blame against victim validators.

### Citations

**File:** consensus/src/quorum_store/proof_manager.rs (L131-152)
```rust
            if let Some(ref params) = request.maybe_optqs_payload_pull_params {
                let max_opt_batch_txns_size = request.max_txns - txns_with_proof_size;
                let max_opt_batch_txns_after_filtering = request.max_txns_after_filtering - cur_unique_txns;
                let (opt_batches, opt_payload_size, _) =
                    self.batch_proof_queue.pull_batches(
                        &excluded_batches
                            .iter()
                            .cloned()
                            .chain(proof_block.iter().map(|proof| proof.info().clone()))
                            .collect(),
                        &params.exclude_authors,
                        max_opt_batch_txns_size,
                        max_opt_batch_txns_after_filtering,
                        request.soft_max_txns_after_filtering,
                        request.return_non_full,
                        request.block_timestamp,
                        Some(params.minimum_batch_age_usecs),
                    );
                (opt_batches, opt_payload_size)
            } else {
                (Vec::new(), PayloadTxnsSize::zero())
            };
```

**File:** consensus/consensus-types/src/common.rs (L558-570)
```rust
    pub fn verify_opt_batches<T: TBatchInfo>(
        verifier: &ValidatorVerifier,
        opt_batches: &OptBatches<T>,
    ) -> anyhow::Result<()> {
        let authors = verifier.address_to_validator_index();
        for batch in &opt_batches.batch_summary {
            ensure!(
                authors.contains_key(&batch.author()),
                "Invalid author {} for batch {}",
                batch.author(),
                batch.digest()
            );
        }
```

**File:** consensus/src/payload_manager/quorum_store_payload_manager.rs (L409-424)
```rust
            Payload::OptQuorumStore(OptQuorumStorePayload::V1(p)) => {
                let mut missing_authors = BitVec::with_num_bits(self.ordered_authors.len() as u16);
                for batch in p.opt_batches().deref() {
                    if self.batch_reader.exists(batch.digest()).is_none() {
                        let index = *self
                            .address_to_validator_index
                            .get(&batch.author())
                            .expect("Payload author should have been verified");
                        missing_authors.set(index as u16);
                    }
                }
                if missing_authors.all_zeros() {
                    Ok(())
                } else {
                    Err(missing_authors)
                }
```

**File:** consensus/src/round_manager.rs (L968-983)
```rust
    fn compute_timeout_reason(&self, round: Round) -> RoundTimeoutReason {
        if self.round_state().vote_sent().is_some() {
            return RoundTimeoutReason::NoQC;
        }

        match self.block_store.get_block_for_round(round) {
            None => RoundTimeoutReason::ProposalNotReceived,
            Some(block) => {
                if let Err(missing_authors) = self.block_store.check_payload(block.block()) {
                    RoundTimeoutReason::PayloadUnavailable { missing_authors }
                } else {
                    RoundTimeoutReason::Unknown
                }
            },
        }
    }
```

**File:** consensus/src/liveness/proposal_status_tracker.rs (L80-98)
```rust
    fn get_exclude_authors(&self) -> HashSet<Author> {
        let mut exclude_authors = HashSet::new();

        let limit = self.window;
        for round_reason in self.past_round_statuses.iter().rev().take(limit) {
            if let NewRoundReason::Timeout(RoundTimeoutReason::PayloadUnavailable {
                missing_authors,
            }) = round_reason
            {
                for author_idx in missing_authors.iter_ones() {
                    if let Some(author) = self.ordered_authors.get(author_idx) {
                        exclude_authors.insert(*author);
                    }
                }
            }
        }

        exclude_authors
    }
```

**File:** consensus/src/quorum_store/batch_proof_queue.rs (L596-600)
```rust
        for (_, batches) in self
            .author_to_batches
            .iter()
            .filter(|(author, _)| !exclude_authors.contains(author))
        {
```
