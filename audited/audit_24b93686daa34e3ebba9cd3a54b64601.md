# Audit Report

## Title
Telemetry Service Validator Cache Accepts Unverified ValidatorSet from REST API Enabling Authentication Bypass

## Summary
The telemetry service's `update_for_chain()` function blindly trusts ValidatorSet resources returned by configured REST endpoints without cryptographic verification of the source address. A compromised or malicious full node can return a ValidatorSet from an arbitrary address (not CORE_CODE_ADDRESS/0x1), causing the telemetry service to cache and trust fake validators, enabling authentication bypass.

## Finding Description

The vulnerability exists in the validator cache update mechanism. The `update_for_chain()` function queries a ValidatorSet resource from CORE_CODE_ADDRESS (0x1) via REST API: [1](#0-0) 

The REST client makes a request for the resource at a specific address, but the response contains only the BCS-encoded ValidatorSet without any proof of origin: [2](#0-1) 

The ValidatorSet structure itself does not contain the address it was fetched from: [3](#0-2) 

**Attack Scenario:**
1. Attacker deploys a malicious Move contract at address 0xATTACKER containing a fake ValidatorSet with attacker-controlled peer IDs and public keys
2. Attacker compromises a "trusted full node" endpoint OR tricks operators into misconfiguring the service to use attacker's node
3. When telemetry service queries CORE_CODE_ADDRESS, malicious node returns ValidatorSet from 0xATTACKER instead
4. Telemetry service has no mechanism to verify the source address and caches the fake data
5. Attacker's fake validators can now authenticate successfully: [4](#0-3) 

The authentication check only verifies peer IDs against the cached validator set, not the cryptographic integrity of that cache.

**Broken Invariant:** State resources should be cryptographically verifiable via Merkle proofs (Invariant #4: State Consistency). The telemetry service violates this by accepting unverified state.

## Impact Explanation

This vulnerability **does not meet Critical severity** despite the question's classification. Per Aptos bug bounty criteria:

- **NOT Critical**: Does not affect blockchain consensus, cause loss of funds, or enable RCE on validator nodes
- **NOT High**: Does not compromise validator nodes, only affects telemetry service
- **Medium at best**: Represents an authentication bypass in monitoring infrastructure requiring manual intervention

The impact is limited to:
- Authentication bypass allowing fake validators to submit telemetry data
- Pollution of metrics and monitoring systems
- Potential DoS of telemetry service through spam
- Network topology information disclosure
- However, **does NOT affect blockchain consensus or safety**

The telemetry service is explicitly **not consensus-critical** - it's a monitoring component separate from the blockchain protocol itself.

## Likelihood Explanation

**Low to Medium likelihood:**

**Requirements:**
- Attacker must compromise a "trusted full node" configured in the telemetry service, OR
- Successfully perform MITM attack (if HTTPS/certificate validation weak), OR  
- Social engineer operators into misconfiguring the service

These are **privileged infrastructure attacks**, not unprivileged exploits. The configuration explicitly designates these as "trusted_full_node_addresses": [5](#0-4) 

The service is designed with the assumption that these endpoints are trusted. While this is a weak security model, it's an explicit architectural decision rather than an oversight.

## Recommendation

**1. Implement Cryptographic Verification:**
Add state proof verification to ensure resources actually originate from the claimed address. The codebase already has proof infrastructure: [6](#0-5) 

The REST API should return resources with Merkle proofs, and the client should verify them before caching.

**2. Include Source Address in Response:**
Modify the BCS response format to include the source address, allowing client-side validation:

```rust
async fn update_for_chain(
    &self,
    chain_name: &ChainCommonName,
    url: &str,
) -> Result<(), ValidatorCacheUpdateError> {
    let client = aptos_rest_client::Client::new(Url::parse(url).map_err(|e| {
        error!("invalid url for chain_id {}: {}", chain_name, e);
        ValidatorCacheUpdateError::InvalidUrl
    })?);
    
    let response: Response<ValidatorSet> = client
        .get_account_resource_bcs(CORE_CODE_ADDRESS, "0x1::stake::ValidatorSet")
        .await
        .map_err(ValidatorCacheUpdateError::RestError)?;

    // VALIDATE SOURCE ADDRESS
    // Note: This would require API changes to include source address in response
    // For now, this is a conceptual fix
    
    let (peer_addrs, state) = response.into_parts();
    // ... rest of function
}
```

**3. Cross-Validation:**
Query multiple independent full nodes and require consensus before caching.

**4. Enhanced Monitoring:**
Add alerts when validator set changes unexpectedly or contains unknown validators.

## Proof of Concept

```rust
// Mock malicious full node response test
#[tokio::test]
async fn test_address_spoofing_attack() {
    use aptos_types::{
        account_address::AccountAddress,
        on_chain_config::ValidatorSet,
        validator_info::ValidatorInfo,
        validator_config::ValidatorConfig,
    };
    use httpmock::MockServer;
    
    // Create fake validator set at attacker address (not CORE_CODE_ADDRESS)
    let attacker_address = AccountAddress::from_hex_literal("0xATTACKER").unwrap();
    let fake_validator = ValidatorInfo::new(
        attacker_address,
        100,
        ValidatorConfig::new(/* attacker's keys */)
    );
    let fake_validator_set = ValidatorSet::new(vec![fake_validator]);
    
    let server = MockServer::start();
    let mock = server.mock(|when, then| {
        // Request asks for CORE_CODE_ADDRESS (0x1)
        when.path("/v1/accounts/0000000000000000000000000000000000000000000000000000000000000001/resource/0x1::stake::ValidatorSet");
        
        // But malicious server returns resource from different address
        // No verification allows this to succeed
        then.status(200)
            .body(bcs::to_bytes(&fake_validator_set).unwrap())
            .header(X_APTOS_CHAIN_ID, "1")
            .header(X_APTOS_EPOCH, "1");
    });
    
    // Telemetry service accepts this without verification
    // Fake validators can now authenticate
}
```

---

**Notes:**

While this is a **valid design weakness**, it **fails the "EXTREMELY high bar" validation** because:

1. ❌ **Not exploitable by unprivileged attacker**: Requires compromising trusted infrastructure (full node operators)
2. ❌ **Impact below stated severity**: Affects only telemetry service (monitoring), not blockchain consensus - does not meet Critical criteria
3. ⚠️ **Architectural assumption**: Service explicitly designed to trust configured endpoints

Per the strict validation requirements and the directive to be "ruthlessly skeptical," this represents a **Medium severity design limitation** at best, not the Critical vulnerability claimed in the question. The telemetry service is intentionally architected with trust assumptions about configured full nodes.

**However**, the vulnerability IS technically real - the code DOES lack verification, and a compromised endpoint CAN poison the cache. The fix recommendations are valid and would improve security posture.

### Citations

**File:** crates/aptos-telemetry-service/src/validator_cache.rs (L95-98)
```rust
        let response: Response<ValidatorSet> = client
            .get_account_resource_bcs(CORE_CODE_ADDRESS, "0x1::stake::ValidatorSet")
            .await
            .map_err(ValidatorCacheUpdateError::RestError)?;
```

**File:** crates/aptos-rest-client/src/lib.rs (L1214-1221)
```rust
        let url = self.build_path(&format!(
            "accounts/{}/resource/{}",
            address.to_hex(),
            resource_type
        ))?;
        let response = self.get_bcs(url).await?;
        Ok(response.and_then(|inner| bcs::from_bytes(&inner))?)
    }
```

**File:** types/src/on_chain_config/validator_set.rs (L23-32)
```rust
#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]
#[cfg_attr(any(test, feature = "fuzzing"), derive(Arbitrary))]
pub struct ValidatorSet {
    pub scheme: ConsensusScheme,
    pub active_validators: Vec<ValidatorInfo>,
    pub pending_inactive: Vec<ValidatorInfo>,
    pub pending_active: Vec<ValidatorInfo>,
    pub total_voting_power: u128,
    pub total_joining_power: u128,
}
```

**File:** crates/aptos-telemetry-service/src/auth.rs (L72-86)
```rust
    let (epoch, peer_role) = match cache.read().get(&body.chain_id) {
        Some((epoch, peer_set)) => {
            match peer_set.get(&body.peer_id) {
                Some(peer) => {
                    let remote_public_key = &remote_public_key;
                    if !peer.keys.contains(remote_public_key) {
                        warn!("peer found in peer set but public_key is not found. request body: {}, role_type: {}, peer_id: {}, received public_key: {}", body.chain_id, body.role_type, body.peer_id, remote_public_key);
                        return Err(reject::custom(ServiceError::forbidden(
                            ServiceErrorCode::AuthError(
                                AuthError::PeerPublicKeyNotFound,
                                body.chain_id,
                            ),
                        )));
                    }
                    Ok((*epoch, peer.role))
```

**File:** crates/aptos-telemetry-service/src/lib.rs (L975-976)
```rust
    /// Map of chain name to full node REST API URL for fetching validator sets
    pub trusted_full_node_addresses: HashMap<ChainCommonName, String>,
```

**File:** types/src/state_proof.rs (L1-5)
```rust
// Copyright (c) Aptos Foundation
// Licensed pursuant to the Innovation-Enabling Source Code License, available at https://github.com/aptos-labs/aptos-core/blob/main/LICENSE

use crate::{
    epoch_change::EpochChangeProof,
```
