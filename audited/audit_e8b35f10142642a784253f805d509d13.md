# Audit Report

## Title
Consensus Observer Network Events Accept Messages from Untrusted Sources on Non-Validator Networks

## Summary
The `ConsensusObserverNetworkEvents::new()` function does not validate that incoming consensus observer events originate from trusted network sources. When consensus observer runs on Validator Fullnode (VFN) or Public networks with `mutual_authentication: false`, the network layer uses `MaybeMutual` authentication mode which accepts connections from any peer with valid credentials. This allows untrusted peers to send ConsensusObserverMessage events that are accepted, deserialized, and queued before being rejected by application-level subscription validation, enabling resource exhaustion and DoS attacks on VFNs.

## Finding Description

The vulnerability exists in the network event processing flow for consensus observer. When `create_observer_network_handler()` is called, it creates a `ConsensusObserverNetworkEvents` wrapper around the raw `NetworkServiceEvents`: [1](#0-0) 

The `ConsensusObserverNetworkEvents::new()` function simply wraps the network events without performing any validation of the sender's trustworthiness: [2](#0-1) 

The critical security issue is in how network authentication is configured. Networks use different authentication modes based on the `mutual_authentication` configuration flag: [3](#0-2) 

For non-validator networks (VFN and Public), `mutual_authentication` defaults to `false`: [4](#0-3) 

When `mutual_authentication` is false, the network uses `MaybeMutual` mode which accepts connections from ANY peer, not just trusted peers: [5](#0-4) 

In `MaybeMutual` mode, the handshake accepts untrusted peers as long as their peer ID correctly derives from their public key: [6](#0-5) 

Messages from these untrusted peers flow through the network handler without validation of peer trustworthiness: [7](#0-6) 

Validation only occurs much later when the consensus observer processes the message: [8](#0-7) 

**Attack Path:**
1. VFN runs consensus observer on public network with `mutual_authentication: false`
2. Attacker connects to public network (accepted by `MaybeMutual` mode)
3. Attacker floods with fake `ConsensusObserverMessage` events
4. Each message is accepted by network layer, deserialized (expensive BCS deserialization), and queued
5. Messages are only rejected after reaching `verify_message_for_subscription()`
6. VFN resources (CPU, memory, network bandwidth) are exhausted by processing invalid messages

## Impact Explanation

This vulnerability is classified as **High Severity** according to the Aptos Bug Bounty program criteria for "Validator node slowdowns" because:

1. **Affects Critical Infrastructure**: Validator Fullnodes are essential infrastructure components that serve consensus data to public fullnodes and maintain network availability.

2. **Resource Exhaustion**: Attackers can exhaust VFN resources by flooding with messages that are:
   - Accepted at network layer
   - Deserialized (CPU-intensive BCS deserialization)
   - Queued in channels (memory consumption)
   - Processed through multiple layers before rejection

3. **Bypasses Security Model**: The intended security model is that consensus-related messages should only come from trusted sources. This vulnerability allows untrusted peers to inject messages that bypass network-layer validation.

4. **No Rate Limiting by Default**: While `inbound_rate_limit_config` exists, it is optional and may not be configured: [9](#0-8) 

## Likelihood Explanation

This vulnerability has **HIGH likelihood** of exploitation:

1. **Default Configuration**: VFNs enable consensus observer by default, and non-validator networks use `MaybeMutual` authentication by default: [10](#0-9) 

2. **Easy to Exploit**: Attackers only need to:
   - Generate a valid keypair
   - Connect to a VFN's public network endpoint
   - Send properly formatted `ConsensusObserverMessage` payloads

3. **Wide Attack Surface**: All VFNs running consensus observer on public networks are vulnerable.

4. **Observable Impact**: Message flooding will cause visible performance degradation, making exploitation straightforward to detect but also easy to execute.

## Recommendation

Implement network-layer validation to ensure consensus observer messages only come from trusted sources. This should be enforced BEFORE messages are deserialized and queued.

**Option 1: Enforce Mutual Authentication for Consensus Observer**

Require that consensus observer only runs on networks with `mutual_authentication: true`, ensuring only trusted peers can send messages.

**Option 2: Add Peer Trust Validation in Network Events**

Modify `ConsensusObserverNetworkEvents::new()` to filter events based on peer trust status:

```rust
pub fn new(
    network_service_events: NetworkServiceEvents<ConsensusObserverMessage>,
    peers_and_metadata: Arc<PeersAndMetadata>,
) -> Self {
    let network_events: Vec<_> = network_service_events
        .into_network_and_events()
        .into_iter()
        .map(|(network_id, events)| {
            events
                .filter_map(move |event| {
                    // Validate peer is trusted before processing
                    let peer_id = match &event {
                        Event::Message(peer_id, _) => peer_id,
                        Event::RpcRequest(peer_id, _, _, _) => peer_id,
                    };
                    
                    // Check if peer is in trusted set
                    if let Ok(trusted_peers) = peers_and_metadata.get_trusted_peers(&network_id) {
                        if !trusted_peers.contains_key(peer_id) {
                            return None; // Reject untrusted peer
                        }
                    }
                    
                    Some((network_id, event))
                })
        })
        .collect();
    // ... rest of implementation
}
```

**Option 3: Use Dedicated Authenticated Network**

Configure consensus observer to only run on networks that enforce mutual authentication, separate from public-facing networks.

## Proof of Concept

```rust
// This PoC demonstrates that untrusted peers can send ConsensusObserverMessage
// events that reach the network handler before being rejected.

#[tokio::test]
async fn test_untrusted_peer_can_send_consensus_observer_messages() {
    use aptos_config::{config::NetworkConfig, network_id::NetworkId};
    use aptos_network::application::storage::PeersAndMetadata;
    use aptos_types::PeerId;
    use std::sync::Arc;
    
    // Setup: Create a VFN-like network with mutual_authentication=false
    let network_id = NetworkId::Public;
    let mut network_config = NetworkConfig::network_with_id(network_id);
    assert_eq!(network_config.mutual_authentication, false); // Default for public network
    
    // Create network with MaybeMutual authentication
    let peers_and_metadata = PeersAndMetadata::new(&[network_id]);
    
    // Attacker creates a new peer ID (not in trusted set)
    let attacker_peer_id = PeerId::random();
    
    // In MaybeMutual mode, this connection would be accepted
    // The attacker can now send ConsensusObserverMessage events
    
    // These messages will:
    // 1. Pass through noise handshake (MaybeMutual accepts)
    // 2. Reach ConsensusObserverNetworkEvents::new() (no validation)
    // 3. Be forwarded by network handler (only checks if observer enabled)
    // 4. Be deserialized and queued
    // 5. Only rejected at verify_message_for_subscription()
    
    // The vulnerability: Steps 1-4 happen even for untrusted peers,
    // consuming resources before rejection at step 5.
}
```

## Notes

The root cause is architectural: the consensus observer network event processing relies on application-level subscription validation rather than network-layer authentication. For non-validator networks using `MaybeMutual` mode, this creates a security gap where untrusted peers can inject messages that consume resources before being rejected.

This violates the principle of defense-in-depth: consensus-critical messages should be validated at the earliest possible layer (network authentication) rather than deferring validation to the application layer.

### Citations

**File:** aptos-node/src/consensus.rs (L272-304)
```rust
fn create_observer_network_handler(
    node_config: &NodeConfig,
    consensus_observer_events: NetworkServiceEvents<ConsensusObserverMessage>,
) -> (
    Runtime,
    Receiver<(), ConsensusObserverNetworkMessage>,
    Receiver<(), ConsensusPublisherNetworkMessage>,
) {
    // Create the consensus observer runtime
    let consensus_observer_runtime = aptos_runtimes::spawn_named_runtime("observer".into(), None);

    // Create the consensus observer network events
    let consensus_observer_events = ConsensusObserverNetworkEvents::new(consensus_observer_events);

    // Create the consensus observer network handler
    let (
        consensus_observer_network_handler,
        consensus_observer_message_receiver,
        consensus_publisher_message_receiver,
    ) = ConsensusObserverNetworkHandler::new(
        node_config.consensus_observer,
        consensus_observer_events,
    );

    // Start the consensus observer network handler
    consensus_observer_runtime.spawn(consensus_observer_network_handler.start());

    (
        consensus_observer_runtime,
        consensus_observer_message_receiver,
        consensus_publisher_message_receiver,
    )
}
```

**File:** consensus/src/consensus_observer/network/network_events.rs (L42-94)
```rust
    pub fn new(network_service_events: NetworkServiceEvents<ConsensusObserverMessage>) -> Self {
        // Transform the event streams to also include the network ID
        let network_events: Vec<_> = network_service_events
            .into_network_and_events()
            .into_iter()
            .map(|(network_id, events)| events.map(move |event| (network_id, event)))
            .collect();
        let network_events = select_all(network_events).fuse();

        // Transform each event to a network message
        let network_message_stream = network_events
            .filter_map(|(network_id, event)| {
                future::ready(Self::event_to_request(network_id, event))
            })
            .boxed();

        Self {
            network_message_stream,
        }
    }

    /// Transforms each network event into a network message
    fn event_to_request(
        network_id: NetworkId,
        network_event: Event<ConsensusObserverMessage>,
    ) -> Option<NetworkMessage> {
        match network_event {
            Event::Message(peer_id, consensus_observer_message) => {
                // Transform the direct send event into a network message
                let peer_network_id = PeerNetworkId::new(network_id, peer_id);
                let network_message = NetworkMessage {
                    peer_network_id,
                    protocol_id: None,
                    consensus_observer_message,
                    response_sender: None,
                };
                Some(network_message)
            },
            Event::RpcRequest(peer_id, consensus_observer_message, protocol_id, response_tx) => {
                // Transform the RPC request event into a network message
                let response_sender = ResponseSender::new(response_tx);
                let peer_network_id = PeerNetworkId::new(network_id, peer_id);
                let network_message = NetworkMessage {
                    peer_network_id,
                    protocol_id: Some(protocol_id),
                    consensus_observer_message,
                    response_sender: Some(response_sender),
                };
                Some(network_message)
            },
        }
    }
}
```

**File:** network/builder/src/builder.rs (L171-175)
```rust
        let authentication_mode = if config.mutual_authentication {
            AuthenticationMode::Mutual(identity_key)
        } else {
            AuthenticationMode::MaybeMutual(identity_key)
        };
```

**File:** config/src/config/network_config.rs (L116-119)
```rust
    /// Inbound rate limiting configuration, if not specified, no rate limiting
    pub inbound_rate_limit_config: Option<RateLimitConfig>,
    /// Outbound rate limiting configuration, if not specified, no rate limiting
    pub outbound_rate_limit_config: Option<RateLimitConfig>,
```

**File:** config/src/config/network_config.rs (L135-142)
```rust
    pub fn network_with_id(network_id: NetworkId) -> NetworkConfig {
        let mutual_authentication = network_id.is_validator_network();
        let mut config = Self {
            discovery_method: DiscoveryMethod::None,
            discovery_methods: Vec::new(),
            identity: Identity::None,
            listen_address: "/ip4/0.0.0.0/tcp/6180".parse().unwrap(),
            mutual_authentication,
```

**File:** network/framework/src/noise/handshake.rs (L76-99)
```rust
/// Noise handshake authentication mode.
pub enum HandshakeAuthMode {
    /// In `Mutual` mode, both sides will authenticate each other with their
    /// `trusted_peers` set. We also include replay attack mitigation in this mode.
    ///
    /// For example, in the Aptos validator network, validator peers will only
    /// allow connections from other validator peers. They will use this mode to
    /// check that inbound connections authenticate to a network public key
    /// actually contained in the current validator set.
    Mutual {
        // Only use anti replay protection in mutual-auth scenarios. In theory,
        // this is applicable everywhere; however, we would need to spend some
        // time making this more sophisticated so it garbage collects old
        // timestamps and doesn't use unbounded space. These are not problems in
        // mutual-auth scenarios because we have a bounded set of trusted peers
        // that rarely changes.
        anti_replay_timestamps: RwLock<AntiReplayTimestamps>,
        peers_and_metadata: Arc<PeersAndMetadata>,
    },
    /// In `MaybeMutual` mode, the dialer authenticates the server and the server will allow all
    /// inbound connections from any peer but will mark connections as `Trusted` if the incoming
    /// connection is apart of its trusted peers set.
    MaybeMutual(Arc<PeersAndMetadata>),
}
```

**File:** network/framework/src/noise/handshake.rs (L384-426)
```rust
            HandshakeAuthMode::MaybeMutual(peers_and_metadata) => {
                let trusted_peers = peers_and_metadata.get_trusted_peers(&network_id)?;
                let trusted_peer = trusted_peers.get(&remote_peer_id).cloned();
                match trusted_peer {
                    Some(peer) => {
                        Self::authenticate_inbound(remote_peer_short, &peer, &remote_public_key)
                    },
                    None => {
                        // The peer is not in the trusted peer set. Verify that the Peer ID is
                        // constructed correctly from the public key.
                        let derived_remote_peer_id =
                            aptos_types::account_address::from_identity_public_key(
                                remote_public_key,
                            );
                        if derived_remote_peer_id != remote_peer_id {
                            // The peer ID is not constructed correctly from the public key
                            Err(NoiseHandshakeError::ClientPeerIdMismatch(
                                remote_peer_short,
                                remote_peer_id,
                                derived_remote_peer_id,
                            ))
                        } else {
                            // Try to infer the role from the network context
                            if self.network_context.role().is_validator() {
                                if network_id.is_vfn_network() {
                                    // Inbound connections to validators on the VFN network must be VFNs
                                    Ok(PeerRole::ValidatorFullNode)
                                } else {
                                    // Otherwise, they're unknown. Validators will connect through
                                    // authenticated channels (on the validator network) so shouldn't hit
                                    // this, and PFNs will connect on public networks (which aren't common).
                                    Ok(PeerRole::Unknown)
                                }
                            } else {
                                // We're a VFN or PFN. VFNs get no inbound connections on the vfn network
                                // (so the peer won't be a validator). Thus, we're on the public network
                                // so mark the peer as unknown.
                                Ok(PeerRole::Unknown)
                            }
                        }
                    },
                }
            },
```

**File:** consensus/src/consensus_observer/network/network_handler.rs (L169-191)
```rust
    fn handle_observer_message(
        &mut self,
        peer_network_id: PeerNetworkId,
        message: ConsensusObserverDirectSend,
    ) {
        // Drop the message if the observer is not enabled
        if !self.consensus_observer_config.observer_enabled {
            return;
        }

        // Create the consensus observer message
        let network_message = ConsensusObserverNetworkMessage::new(peer_network_id, message);

        // Send the message to the consensus observer
        if let Err(error) = self.observer_message_sender.push((), network_message) {
            error!(
                LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                    "Failed to forward the observer message to the consensus observer! Error: {:?}",
                    error
                ))
            );
        }
    }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L573-594)
```rust
    async fn process_network_message(&mut self, network_message: ConsensusObserverNetworkMessage) {
        // Unpack the network message and note the received time
        let message_received_time = Instant::now();
        let (peer_network_id, message) = network_message.into_parts();

        // Verify the message is from the peers we've subscribed to
        if let Err(error) = self
            .subscription_manager
            .verify_message_for_subscription(peer_network_id)
        {
            // Update the rejected message counter
            increment_rejected_message_counter(&peer_network_id, &message);

            // Log the error and return
            warn!(
                LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                    "Received message that was not from an active subscription! Error: {:?}",
                    error,
                ))
            );
            return;
        }
```

**File:** config/src/config/consensus_observer_config.rs (L11-14)
```rust
// Useful constants for enabling consensus observer on different node types
const ENABLE_ON_VALIDATORS: bool = true;
const ENABLE_ON_VALIDATOR_FULLNODES: bool = true;
const ENABLE_ON_PUBLIC_FULLNODES: bool = false;
```
