# Audit Report

## Title
Missing Input Validation in Randomness Config Governance Proposals Allows On-Chain Storage of Invalid DKG Thresholds

## Summary
The `randomness_config::new_v1()` Move function does not validate that threshold percentage values satisfy DKG security constraints (secrecy > 33.33%, secrecy < reconstruction, reconstruction ≤ 66.67%). Invalid values can be committed to on-chain storage via governance proposals, causing validator node failures, consensus issues, or randomness generation disruption during epoch transitions when DKG initialization attempts to use these invalid thresholds.

## Finding Description

The vulnerability exists in a multi-layer validation gap across the randomness configuration update flow:

**Layer 1 - Rust Proposal Generation:** [1](#0-0) 

The Rust code generates Move script code that calls `randomness_config::new_v1()` with `fixed_point64::create_from_rational(percentage, 100)`. No validation of percentage values occurs at this layer.

**Layer 2 - Move FixedPoint64 Creation:** [2](#0-1) 

The `create_from_rational()` function only validates basic arithmetic constraints (denominator ≠ 0, ratio not too small/large), but does NOT enforce that percentages are in valid range [0, 100] or that they satisfy DKG security requirements.

**Layer 3 - Move Config Creation:** [3](#0-2) 

The `new_v1()` function simply packs the FixedPoint64 values into a ConfigV1 struct with **zero validation**.

**Layer 4 - On-Chain Storage:** [4](#0-3) 

The `set_for_next_epoch()` function only validates the signer is @aptos_framework but performs **no value validation**.

**Layer 5 - DKG Usage (Too Late):** [5](#0-4) 

The actual DKG security constraints are validated in `DKGRoundingProfile::new()`, but this occurs **after** the invalid config is already committed to on-chain storage. The validation checks require:
- `secrecy_threshold * 3 > 1` (>33.33%)
- `secrecy_threshold < reconstruct_threshold`
- `reconstruct_threshold * 3 <= 2` (≤66.67%)

**Attack Scenario:**

An attacker submits a governance proposal with invalid thresholds:
- `secrecy_threshold_in_percentage = 0` (0%)
- `reconstruct_threshold_in_percentage = 0` (0%)

These values propagate through all layers:
1. `create_from_rational(0, 100)` = 0.0 (valid, no arithmetic errors)
2. `new_v1()` packs them (no validation)
3. `set_for_next_epoch()` stores them (signer check only)
4. Config committed to on-chain state

During the next epoch transition: [6](#0-5) 

When `build_dkg_pvss_config()` is called: [7](#0-6) 

The `total_weight_upper_bound()` function calculates:
```
(n/2 + 2) / (reconstruct_threshold - secrecy_threshold)
```

With both thresholds = 0, the denominator becomes `U64F64::DELTA` (smallest positive value), resulting in an astronomically large weight value that can cause:
- Integer overflow panics
- Memory allocation failures  
- Determinism violations if validators handle errors differently

The fallback "infallible" method: [8](#0-7) 

This clamps values to [0, 1] but does **not** enforce the lower bound constraints, allowing zero or near-zero thresholds to proceed, breaking DKG security assumptions.

## Impact Explanation

**High Severity** per Aptos bug bounty criteria:

1. **Validator Node Slowdowns**: Extreme weight calculations can cause computational exhaustion during epoch transitions
2. **Consensus Issues**: If validators handle DKG initialization failures differently, this breaks the Deterministic Execution invariant, potentially causing chain splits
3. **Randomness Generation Failures**: Invalid thresholds break the cryptographic security guarantees of the DKG protocol, making randomness either unavailable or insecure
4. **Epoch Transition Disruption**: Failed DKG initialization prevents proper epoch transitions, degrading network liveness

This violates critical invariants:
- **Invariant #1 (Deterministic Execution)**: Different error handling across validators
- **Invariant #9 (Resource Limits)**: Unbounded computation from extreme weight values

## Likelihood Explanation

**High Likelihood:**

1. **Low Attack Complexity**: Requires only a governance proposal with invalid numeric parameters (no cryptographic attacks or race conditions)
2. **No Insider Access Required**: Any entity capable of submitting governance proposals can trigger this
3. **Silent Propagation**: Invalid values pass through all layers without any warning until epoch transition
4. **Existing Code Path**: Uses legitimate governance mechanisms, not an edge case
5. **Real-World Scenario**: Accidental misconfigurations (e.g., percentage values > 100, or reversed secrecy/reconstruction values) could trigger this even without malicious intent

## Recommendation

Add validation in the Move `new_v1()` function to enforce DKG constraints before config creation:

```move
public fun new_v1(secrecy_threshold: FixedPoint64, reconstruction_threshold: FixedPoint64): RandomnessConfig {
    // Validate DKG security constraints
    let one_third = fixed_point64::create_from_rational(1, 3);
    let two_thirds = fixed_point64::create_from_rational(2, 3);
    
    assert!(
        fixed_point64::greater(secrecy_threshold, one_third),
        EINVALID_SECRECY_THRESHOLD  // secrecy must be > 1/3
    );
    assert!(
        fixed_point64::less(secrecy_threshold, reconstruction_threshold),
        EINVALID_THRESHOLD_ORDER  // secrecy must be < reconstruction
    );
    assert!(
        fixed_point64::less_or_equal(reconstruction_threshold, two_thirds),
        EINVALID_RECONSTRUCTION_THRESHOLD  // reconstruction must be <= 2/3
    );
    
    RandomnessConfig {
        variant: copyable_any::pack( ConfigV1 {
            secrecy_threshold,
            reconstruction_threshold
        } )
    }
}
```

Additionally, add similar validation in the Rust `OnChainRandomnessConfig::new_v1()` function: [9](#0-8) 

Add checks before creating the config:
```rust
pub fn new_v1(
    secrecy_threshold_in_percentage: u64,
    reconstruct_threshold_in_percentage: u64,
) -> Self {
    // Validate DKG constraints
    assert!(secrecy_threshold_in_percentage > 33, "secrecy threshold must be > 33%");
    assert!(secrecy_threshold_in_percentage < reconstruct_threshold_in_percentage, 
            "secrecy must be < reconstruction");
    assert!(reconstruct_threshold_in_percentage <= 67, "reconstruction threshold must be <= 67%");
    
    // existing code...
}
```

## Proof of Concept

**Move Test (add to `randomness_config.move`):**

```move
#[test]
#[expected_failure(abort_code = EINVALID_SECRECY_THRESHOLD)]
public entry fun test_new_v1_rejects_zero_secrecy(framework: signer) {
    // This should abort with zero secrecy threshold
    let invalid_config = new_v1(
        fixed_point64::create_from_rational(0, 100),  // 0% secrecy
        fixed_point64::create_from_rational(67, 100)  // 67% reconstruction
    );
}

#[test]
#[expected_failure(abort_code = EINVALID_THRESHOLD_ORDER)]
public entry fun test_new_v1_rejects_inverted_thresholds(framework: signer) {
    // This should abort when secrecy > reconstruction
    let invalid_config = new_v1(
        fixed_point64::create_from_rational(80, 100),  // 80% secrecy
        fixed_point64::create_from_rational(20, 100)   // 20% reconstruction
    );
}
```

**Rust Reproduction:**

```rust
#[test]
#[should_panic(expected = "secrecy threshold must be > 33%")]
fn test_new_v1_validation() {
    // This demonstrates the missing validation
    let config = OnChainRandomnessConfig::new_v1(0, 0);  // Should panic but currently doesn't
}
```

## Notes

The current code relies on "defense in depth" with validation only at DKG initialization time, but this is insufficient because:

1. Invalid configs can persist on-chain between epochs
2. Error handling in the DKG "infallible" fallback is inadequate for extreme values
3. The governance layer has no mechanism to prevent invalid proposals from being committed

The fix should implement validation at the **earliest possible point** (Move function entry) to provide fail-fast behavior and prevent invalid state from ever being stored on-chain.

### Citations

**File:** aptos-move/aptos-release-builder/src/components/randomness_config.rs (L77-92)
```rust
                ReleaseFriendlyRandomnessConfig::V1 {
                    secrecy_threshold_in_percentage,
                    reconstruct_threshold_in_percentage,
                } => {
                    emitln!(writer, "let v1 = randomness_config::new_v1(");
                    emitln!(
                        writer,
                        "    fixed_point64::create_from_rational({}, 100),",
                        secrecy_threshold_in_percentage
                    );
                    emitln!(
                        writer,
                        "    fixed_point64::create_from_rational({}, 100),",
                        reconstruct_threshold_in_percentage
                    );
                    emitln!(writer, ");");
```

**File:** aptos-move/framework/aptos-stdlib/sources/fixed_point64.move (L129-141)
```text
    public fun create_from_rational(numerator: u128, denominator: u128): FixedPoint64 {
        // If the denominator is zero, this will abort.
        // Scale the numerator to have 64 fractional bits, so that the quotient will have 64
        // fractional bits.
        let scaled_numerator = (numerator as u256) << 64;
        assert!(denominator != 0, EDENOMINATOR);
        let quotient = scaled_numerator / (denominator as u256);
        assert!(quotient != 0 || numerator == 0, ERATIO_OUT_OF_RANGE);
        // Return the quotient as a fixed-point number. We first need to check whether the cast
        // can succeed.
        assert!(quotient <= MAX_U128, ERATIO_OUT_OF_RANGE);
        FixedPoint64 { value: (quotient as u128) }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/randomness_config.move (L52-56)
```text
    /// This can be called by on-chain governance to update on-chain consensus configs for the next epoch.
    public fun set_for_next_epoch(framework: &signer, new_config: RandomnessConfig) {
        system_addresses::assert_aptos_framework(framework);
        config_buffer::upsert(new_config);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/randomness_config.move (L93-100)
```text
    public fun new_v1(secrecy_threshold: FixedPoint64, reconstruction_threshold: FixedPoint64): RandomnessConfig {
        RandomnessConfig {
            variant: copyable_any::pack( ConfigV1 {
                secrecy_threshold,
                reconstruction_threshold
            } )
        }
    }
```

**File:** types/src/dkg/real_dkg/rounding/mod.rs (L34-48)
```rust
pub fn total_weight_upper_bound(
    validator_stakes: &[u64],
    mut reconstruct_threshold_in_stake_ratio: U64F64,
    secrecy_threshold_in_stake_ratio: U64F64,
) -> usize {
    reconstruct_threshold_in_stake_ratio = max(
        reconstruct_threshold_in_stake_ratio,
        secrecy_threshold_in_stake_ratio + U64F64::DELTA,
    );
    let two = U64F64::from_num(2);
    let n = U64F64::from_num(validator_stakes.len());
    ((n / two + two) / (reconstruct_threshold_in_stake_ratio - secrecy_threshold_in_stake_ratio))
        .ceil()
        .to_num::<usize>()
}
```

**File:** types/src/dkg/real_dkg/rounding/mod.rs (L187-199)
```rust
    pub fn new(
        validator_stakes: &Vec<u64>,
        total_weight_min: usize,
        total_weight_max: usize,
        secrecy_threshold_in_stake_ratio: U64F64,
        reconstruct_threshold_in_stake_ratio: U64F64,
        fast_secrecy_threshold_in_stake_ratio: Option<U64F64>,
    ) -> anyhow::Result<Self> {
        ensure!(total_weight_min >= validator_stakes.len());
        ensure!(total_weight_max >= total_weight_min);
        ensure!(secrecy_threshold_in_stake_ratio * U64F64::from_num(3) > U64F64::from_num(1));
        ensure!(secrecy_threshold_in_stake_ratio < reconstruct_threshold_in_stake_ratio);
        ensure!(reconstruct_threshold_in_stake_ratio * U64F64::from_num(3) <= U64F64::from_num(2));
```

**File:** types/src/dkg/real_dkg/rounding/mod.rs (L254-282)
```rust
    pub fn infallible(
        validator_stakes: &Vec<u64>,
        mut secrecy_threshold_in_stake_ratio: U64F64,
        mut reconstruct_threshold_in_stake_ratio: U64F64,
        fast_secrecy_threshold_in_stake_ratio: Option<U64F64>,
    ) -> Self {
        let one = U64F64::from_num(1);
        secrecy_threshold_in_stake_ratio = min(one, secrecy_threshold_in_stake_ratio);
        reconstruct_threshold_in_stake_ratio = min(one, reconstruct_threshold_in_stake_ratio);
        reconstruct_threshold_in_stake_ratio = max(
            secrecy_threshold_in_stake_ratio,
            reconstruct_threshold_in_stake_ratio,
        );

        let stake_total = U64F64::from_num(validator_stakes.clone().into_iter().sum::<u64>());

        let estimated_weight_total = total_weight_upper_bound(
            validator_stakes,
            reconstruct_threshold_in_stake_ratio,
            secrecy_threshold_in_stake_ratio,
        );
        let stake_per_weight = stake_total / U64F64::from_num(estimated_weight_total);
        compute_profile_fixed_point(
            validator_stakes,
            stake_per_weight,
            secrecy_threshold_in_stake_ratio,
            fast_secrecy_threshold_in_stake_ratio,
        )
    }
```

**File:** types/src/dkg/real_dkg/mod.rs (L199-217)
```rust
    fn new_public_params(dkg_session_metadata: &DKGSessionMetadata) -> RealDKGPublicParams {
        let randomness_config = dkg_session_metadata
            .randomness_config_derived()
            .unwrap_or_else(OnChainRandomnessConfig::default_enabled);
        let secrecy_threshold = randomness_config
            .secrecy_threshold()
            .unwrap_or_else(|| *rounding::DEFAULT_SECRECY_THRESHOLD);
        let reconstruct_threshold = randomness_config
            .reconstruct_threshold()
            .unwrap_or_else(|| *rounding::DEFAULT_RECONSTRUCT_THRESHOLD);
        let maybe_fast_path_secrecy_threshold = randomness_config.fast_path_secrecy_threshold();

        let pvss_config = build_dkg_pvss_config(
            dkg_session_metadata.dealer_epoch,
            secrecy_threshold,
            reconstruct_threshold,
            maybe_fast_path_secrecy_threshold,
            &dkg_session_metadata.target_validator_consensus_infos_cloned(),
        );
```

**File:** types/src/on_chain_config/randomness_config.rs (L101-115)
```rust
    pub fn new_v1(
        secrecy_threshold_in_percentage: u64,
        reconstruct_threshold_in_percentage: u64,
    ) -> Self {
        let secrecy_threshold = FixedPoint64MoveStruct::from_u64f64(
            U64F64::from_num(secrecy_threshold_in_percentage) / U64F64::from_num(100),
        );
        let reconstruction_threshold = FixedPoint64MoveStruct::from_u64f64(
            U64F64::from_num(reconstruct_threshold_in_percentage) / U64F64::from_num(100),
        );
        Self::V1(ConfigV1 {
            secrecy_threshold,
            reconstruction_threshold,
        })
    }
```
