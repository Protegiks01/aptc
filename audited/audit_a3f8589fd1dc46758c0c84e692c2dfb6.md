# Audit Report

## Title
RoundProposer Default Fallback Creates Permanent Leader Centralization Risk

## Summary
The `RoundProposer` implementation uses a static, non-rotating default proposer that always falls back to the first validator in the set for any unmapped rounds. This creates a consensus centralization vulnerability where a single validator can become the de facto permanent leader once explicitly mapped rounds are exhausted.

## Finding Description

The `RoundProposer` election mechanism allows on-chain governance to specify proposers for specific rounds via a `HashMap<Round, AccountAddress>`. However, the implementation has a critical flaw in its fallback behavior: [1](#0-0) 

The default proposer is hardcoded to the first validator in the ordered list and never rotates: [2](#0-1) 

**Attack Scenario:**

1. On-chain governance configures `ProposerElectionType::RoundProposer` with a finite HashMap mapping (e.g., rounds 1-100)
2. The epoch begins and the proposer election is created once: [3](#0-2) 

3. Consensus progresses through rounds within the epoch (epochs are time-based, not round-limited): [4](#0-3) 

4. Once rounds exceed the mapped values (e.g., round 101+), ALL subsequent rounds fall back to the same default proposer (first validator)
5. This validator now has permanent control over block proposals until epoch reconfiguration
6. The validator can:
   - Censor specific transactions
   - Extract MEV by reordering transactions
   - Cause liveness issues by refusing to propose
   - Centralize block production power

**Evidence from test demonstrating the behavior:** [5](#0-4) 

This violates the consensus fairness invariant where leader election should distribute proposal rights across validators to prevent centralization.

## Impact Explanation

**Severity: Medium**

This qualifies as Medium severity per the Aptos bug bounty criteria because it creates:

1. **Consensus Centralization**: A single validator gains disproportionate control over block production, violating the decentralization guarantee of BFT consensus
2. **Liveness Risk**: If the permanent leader validator becomes unavailable or malicious, consensus liveness degrades as timeouts occur on every round
3. **Transaction Censorship**: The permanent leader can selectively exclude transactions, affecting network utility
4. **MEV Extraction**: Concentrated proposal power enables systematic MEV extraction

While this doesn't break consensus safety (Byzantine fault tolerance <1/3 is maintained), it creates state inconsistencies requiring intervention if governance misconfigures the system without understanding the permanent fallback behavior.

## Likelihood Explanation

**Likelihood: Medium-High**

This vulnerability is likely to manifest because:

1. **Finite Round Mappings**: It's impractical for governance to map all future rounds in a HashMap since rounds are unbounded within time-based epochs
2. **Epoch Duration**: Epochs last until `epoch_interval` time expires (configurable, potentially hours/days), during which hundreds or thousands of rounds can occur
3. **Governance Unawareness**: The hardcoded fallback behavior is not prominently documented in the on-chain config, so governance may configure RoundProposer expecting rotation without realizing the centralization risk
4. **No Runtime Updates**: The proposer election is created once per epoch and never updated, so there's no mechanism to correct the issue mid-epoch

## Recommendation

**Fix: Implement round-robin rotation for the default proposer**

Modify the `RoundProposer` implementation to rotate through all validators when a round is not explicitly mapped, rather than always falling back to a single validator:

```rust
// In consensus/src/liveness/round_proposer_election.rs
pub struct RoundProposer {
    proposers: HashMap<Round, Author>,
    // Store all validators for rotation instead of single default
    all_proposers: Vec<Author>,
}

impl RoundProposer {
    pub fn new(proposers: HashMap<Round, Author>, all_proposers: Vec<Author>) -> Self {
        Self {
            proposers,
            all_proposers,
        }
    }
}

impl ProposerElection for RoundProposer {
    fn get_valid_proposer(&self, round: Round) -> Author {
        match self.proposers.get(&round) {
            Some(round_proposer) => *round_proposer,
            // Rotate through all proposers instead of fixed default
            None => {
                let index = (round as usize) % self.all_proposers.len();
                self.all_proposers[index]
            }
        }
    }
}
```

And update the initialization in `epoch_manager.rs`:

```rust
ProposerElectionType::RoundProposer(round_proposers) => {
    Arc::new(RoundProposer::new(
        round_proposers.clone(),
        proposers, // Pass all proposers for rotation
    ))
},
```

This ensures that unmapped rounds distribute fairly across all validators rather than centralizing on one.

## Proof of Concept

```rust
#[test]
fn test_round_proposer_permanent_leader_vulnerability() {
    use crate::liveness::{
        proposer_election::ProposerElection, 
        round_proposer_election::RoundProposer,
    };
    use aptos_types::account_address::AccountAddress;
    use std::collections::HashMap;

    // Create 4 validators
    let validator_0 = AccountAddress::from_hex_literal("0x1").unwrap();
    let validator_1 = AccountAddress::from_hex_literal("0x2").unwrap();
    let validator_2 = AccountAddress::from_hex_literal("0x3").unwrap();
    let validator_3 = AccountAddress::from_hex_literal("0x4").unwrap();

    // Governance configures only first 10 rounds
    let mut round_proposers = HashMap::new();
    round_proposers.insert(1, validator_0);
    round_proposers.insert(2, validator_1);
    round_proposers.insert(3, validator_2);
    round_proposers.insert(4, validator_3);
    round_proposers.insert(5, validator_0);
    round_proposers.insert(6, validator_1);
    round_proposers.insert(7, validator_2);
    round_proposers.insert(8, validator_3);
    round_proposers.insert(9, validator_0);
    round_proposers.insert(10, validator_1);

    let pe = RoundProposer::new(round_proposers, validator_0);

    // First 10 rounds work as expected
    assert_eq!(pe.get_valid_proposer(1), validator_0);
    assert_eq!(pe.get_valid_proposer(2), validator_1);
    assert_eq!(pe.get_valid_proposer(10), validator_1);

    // BUG: All subsequent rounds permanently use validator_0
    assert_eq!(pe.get_valid_proposer(11), validator_0); // CENTRALIZATION!
    assert_eq!(pe.get_valid_proposer(100), validator_0); // STILL validator_0
    assert_eq!(pe.get_valid_proposer(1000), validator_0); // PERMANENT LEADER
    
    // validator_0 now controls all proposals for rounds 11+
    // This violates consensus fairness and creates centralization risk
}
```

## Notes

The vulnerability exists because the `RoundProposer` implementation was designed with the assumption that governance would map all relevant rounds, but epochs are time-based (not round-based), making it impossible to predict how many rounds will occur. The hardcoded comment acknowledges this is intentional [6](#0-5) , but this design choice creates a security risk when combined with unbounded round progression within time-based epochs.

### Citations

**File:** consensus/src/epoch_manager.rs (L396-405)
```rust
            ProposerElectionType::RoundProposer(round_proposers) => {
                // Hardcoded to the first proposer
                let default_proposer = proposers
                    .first()
                    .expect("INVARIANT VIOLATION: proposers is empty");
                Arc::new(RoundProposer::new(
                    round_proposers.clone(),
                    *default_proposer,
                ))
            },
```

**File:** consensus/src/epoch_manager.rs (L852-854)
```rust
        info!(epoch = epoch, "Create ProposerElection");
        let proposer_election =
            self.create_proposer_election(&epoch_state, &onchain_consensus_config);
```

**File:** consensus/src/liveness/round_proposer_election.rs (L12-14)
```rust
    // Default proposer to use if proposer for a round is unspecified.
    // We hardcode this to the first proposer
    default_proposer: Author,
```

**File:** consensus/src/liveness/round_proposer_election.rs (L27-32)
```rust
    fn get_valid_proposer(&self, round: Round) -> Author {
        match self.proposers.get(&round) {
            None => self.default_proposer,
            Some(round_proposer) => *round_proposer,
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/block.move (L215-217)
```text
        if (timestamp - reconfiguration::last_reconfiguration_time() >= epoch_interval) {
            reconfiguration::reconfigure();
        };
```

**File:** consensus/src/liveness/round_proposer_test.rs (L27-39)
```rust
    // In round 3, send a proposal from chosen_author_round1 (which is also the default proposer).
    // The proposal should win because the map doesn't specify proposer for round 3 hence
    // falling back on the default proposer

    assert!(pe.is_valid_proposer(chosen_author_round1, 1),);
    assert!(!pe.is_valid_proposer(another_author, 1));
    assert!(pe.is_valid_proposer(chosen_author_round2, 2));
    assert!(!pe.is_valid_proposer(another_author, 2));
    assert!(pe.is_valid_proposer(chosen_author_round1, 3));
    assert!(!pe.is_valid_proposer(another_author, 3));
    assert_eq!(pe.get_valid_proposer(1), chosen_author_round1);
    assert_eq!(pe.get_valid_proposer(2), chosen_author_round2);
    assert_eq!(pe.get_valid_proposer(3), chosen_author_round1);
```
