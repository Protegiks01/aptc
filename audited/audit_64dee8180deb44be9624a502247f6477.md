# Audit Report

## Title
Transaction Size Validation After Expensive Signature Verification Enables Resource Exhaustion DoS

## Summary
The VM validator performs expensive signature verification operations (including multiple memory clones of transaction payloads) before validating transaction size limits. This allows attackers to submit oversized transactions that bypass API-level size limits but fail VM size checks, forcing validators to waste resources on transactions that should be rejected immediately.

## Finding Description

The transaction validation flow has a critical ordering vulnerability where expensive operations occur before basic size validation:

**Vulnerability Chain:**

1. **API Layer Size Check (8 MB limit)**: The API middleware checks Content-Length against 8 MB [1](#0-0) 

2. **Mempool Clones Transaction**: Transaction is cloned before validation [2](#0-1) 

3. **VM Validation Order in `AptosVM::validate_transaction`**: Signature verification happens BEFORE size check
   - Signature verification occurs at line 3232 [3](#0-2) 
   
   - Size check only happens much later in `check_gas` called from `run_prologue_with_payload` [4](#0-3) 

4. **Expensive Signature Verification for FeePayer/MultiAgent**: For these transaction types, the `RawTransaction` (including payload) is cloned 2-3 times during signature verification [5](#0-4) 

**Attack Scenario:**
An attacker can craft FeePayer or MultiAgent transactions with payloads between 64 KB and 8 MB (e.g., 4 MB). These transactions:
- Pass the API Content-Length check (< 8 MB)
- Get cloned for validation (4 MB)
- Undergo signature verification which clones the RawTransaction 2-3 more times (8-12 MB additional allocations)
- Are THEN rejected for exceeding the VM's 64 KB limit [6](#0-5) 

This violates the **Resource Limits** invariant: "All operations must respect gas, storage, and computational limits" by performing expensive operations on transactions that exceed size limits before checking those limits.

## Impact Explanation

**Medium Severity** - This meets the Medium severity criteria for "State inconsistencies requiring intervention" in the form of validator resource exhaustion:

- **Memory Exhaustion**: Each oversized FeePayer/MultiAgent transaction causes 16+ MB of allocations (original + validation clone + 2-3 signature verification clones) before being rejected
- **CPU Waste**: Cryptographic signature verification operations are performed on invalid transactions
- **Amplification Attack**: Attacker bandwidth cost (sending 4 MB transaction) << Validator resource cost (allocating 16+ MB, performing cryptographic operations)
- **No Rate Limiting**: No mention of per-IP or per-account rate limiting on invalid transaction submissions
- **Concurrent Amplification**: If 100 such transactions are submitted concurrently, validators allocate 1.6+ GB temporarily

While the panic handler prevents crashes, sustained attacks could degrade validator performance and block processing capacity. [7](#0-6) 

## Likelihood Explanation

**High Likelihood:**
- **No Authentication Required**: Anyone can submit transactions via public API endpoints
- **Low Attack Cost**: Attacker only needs network bandwidth to send oversized transactions
- **Easy to Execute**: Simple script can generate and submit malformed transactions
- **No Early Detection**: Size validation happens after expensive operations, so attack succeeds in wasting resources
- **Gap Exists by Design**: 8 MB API limit vs 64 KB VM limit creates exploitable gap

## Recommendation

Move transaction size validation to occur BEFORE signature verification:

```rust
// In aptos-move/aptos-vm/src/aptos_vm.rs, validate_transaction method
fn validate_transaction(
    &self,
    transaction: SignedTransaction,
    state_view: &impl StateView,
    module_storage: &impl ModuleStorage,
) -> VMValidatorResult {
    let _timer = TXN_VALIDATION_SECONDS.start_timer();
    let log_context = AdapterLogSchema::new(state_view.id(), 0);

    // ADD EARLY SIZE CHECK HERE - before any expensive operations
    let txn_size = transaction.txn_bytes_len();
    let max_size = self.gas_params(&log_context)
        .map(|params| params.vm.txn.max_transaction_size_in_bytes)
        .unwrap_or(64 * 1024);
    
    if txn_size > max_size {
        return VMValidatorResult::error(StatusCode::EXCEEDED_MAX_TRANSACTION_SIZE);
    }

    // Continue with existing validation...
    // Feature flag checks
    // Signature verification
    // etc.
}
```

Additionally, lower the API Content-Length limit to match the VM limit plus reasonable overhead (e.g., 128 KB) to prevent the gap.

## Proof of Concept

```rust
// PoC: Submit oversized FeePayer transaction to demonstrate resource waste

use aptos_types::transaction::*;
use aptos_crypto::{ed25519::*, PrivateKey, Uniform};

fn create_oversized_fee_payer_transaction() -> SignedTransaction {
    let mut rng = rand::thread_rng();
    let sender_key = Ed25519PrivateKey::generate(&mut rng);
    let fee_payer_key = Ed25519PrivateKey::generate(&mut rng);
    
    // Create a large payload (2 MB of script bytecode)
    let large_code = vec![0u8; 2 * 1024 * 1024];
    let script = Script::new(large_code, vec![], vec![]);
    
    let raw_txn = RawTransaction::new_script(
        AccountAddress::random(),
        0, // sequence number
        script,
        1_000_000, // max gas
        1, // gas price
        u64::MAX, // expiration
        ChainId::test(),
    );
    
    // Create FeePayer authenticator (will cause multiple clones during validation)
    let sender_sig = sender_key.sign(&raw_txn).unwrap();
    let fee_payer_sig = fee_payer_key.sign(&raw_txn).unwrap();
    
    let authenticator = TransactionAuthenticator::FeePayer {
        sender: AccountAuthenticator::Ed25519 {
            public_key: sender_key.public_key(),
            signature: sender_sig,
        },
        secondary_signer_addresses: vec![],
        secondary_signers: vec![],
        fee_payer_address: AccountAddress::random(),
        fee_payer_signer: AccountAuthenticator::Ed25519 {
            public_key: fee_payer_key.public_key(),
            signature: fee_payer_sig,
        },
    };
    
    SignedTransaction::new(raw_txn, authenticator)
}

// Submit this transaction via API - it will:
// 1. Pass 8 MB Content-Length check
// 2. Get cloned for validation (2 MB)
// 3. Undergo signature verification with 2-3 clones (4-6 MB more)
// 4. Be rejected for exceeding 64 KB limit
// Total wasted allocations: ~8-10 MB per transaction
```

**Notes**

This vulnerability exploits the architectural gap between API-level and VM-level size validation. The issue is exacerbated for FeePayer and MultiAgent transactions due to the multiple `RawTransaction` clones during signature verification. While individual transaction processing remains bounded, concurrent submission of many such transactions can significantly impact validator resource availability, potentially affecting network liveness during sustained attacks.

The fix should implement defense-in-depth: early size validation before expensive operations AND tighter API limits to match VM constraints.

### Citations

**File:** config/src/config/api_config.rs (L97-97)
```rust
const DEFAULT_REQUEST_CONTENT_LENGTH_LIMIT: u64 = 8 * 1024 * 1024; // 8 MB
```

**File:** mempool/src/shared_mempool/tasks.rs (L494-494)
```rust
                let result = smp.validator.read().validate_transaction(t.0.clone());
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L3232-3236)
```rust
        let txn = match transaction.check_signature() {
            Ok(t) => t,
            _ => {
                return VMValidatorResult::error(StatusCode::INVALID_SIGNATURE);
            },
```

**File:** aptos-move/aptos-vm/src/gas.rs (L109-121)
```rust
    } else if txn_metadata.transaction_size > txn_gas_params.max_transaction_size_in_bytes {
        speculative_warn!(
            log_context,
            format!(
                "[VM] Transaction size too big {} (max {})",
                txn_metadata.transaction_size, txn_gas_params.max_transaction_size_in_bytes
            ),
        );
        return Err(VMStatus::error(
            StatusCode::EXCEEDED_MAX_TRANSACTION_SIZE,
            None,
        ));
    }
```

**File:** types/src/transaction/authenticator.rs (L196-213)
```rust
                let no_fee_payer_address_message = RawTransactionWithData::new_fee_payer(
                    raw_txn.clone(),
                    secondary_signer_addresses.clone(),
                    AccountAddress::ZERO,
                );

                let mut remaining = to_verify
                    .iter()
                    .filter(|verifier| verifier.verify(&no_fee_payer_address_message).is_err())
                    .collect::<Vec<_>>();

                remaining.push(&fee_payer_signer);

                let fee_payer_address_message = RawTransactionWithData::new_fee_payer(
                    raw_txn.clone(),
                    secondary_signer_addresses.clone(),
                    *fee_payer_address,
                );
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L73-76)
```rust
            max_transaction_size_in_bytes: NumBytes,
            "max_transaction_size_in_bytes",
            64 * 1024
        ],
```

**File:** vm-validator/src/vm_validator.rs (L155-169)
```rust
        let result = std::panic::catch_unwind(move || {
            let vm_validator_locked = vm_validator.lock().unwrap();

            use aptos_vm::VMValidator;
            let vm = AptosVM::new(&vm_validator_locked.state.environment);
            vm.validate_transaction(
                txn,
                &vm_validator_locked.state.state_view,
                &vm_validator_locked.state,
            )
        });
        if let Err(err) = &result {
            error!("VMValidator panicked: {:?}", err);
        }
        result.map_err(|_| anyhow::anyhow!("panic validating transaction"))
```
