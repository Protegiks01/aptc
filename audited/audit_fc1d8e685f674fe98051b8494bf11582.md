# Audit Report

## Title
Unbounded Memory Allocation in NetworkStream::read() Enables Denial of Service

## Summary
The `NetworkStream::read()` function in `secure/net/src/lib.rs` lacks maximum message size validation on the read path, allowing an attacker to specify arbitrarily large message sizes (up to u32::MAX â‰ˆ 4GB) in the length prefix, causing unbounded memory allocation and potential memory exhaustion.

## Finding Description

The network protocol in `secure/net/src/lib.rs` uses a length-prefixed message format where a 4-byte u32 value indicates the message size. While the `write()` function validates that outgoing messages are smaller than u32::MAX, the `read_buffer()` function performs **no validation** on the size read from the network. [1](#0-0) 

The message size is read directly from the network and converted to `usize` without any bounds checking. The code then accumulates data in `self.buffer` until it has the specified amount: [2](#0-1) 

Once enough data is accumulated, it allocates a new Vec of that size: [3](#0-2) 

In contrast, the GRPC-based network implementation enforces a reasonable 80 MB limit: [4](#0-3) 

**Attack Path:**
1. Attacker connects to a NetworkServer instance (e.g., safety-rules remote service)
2. Sends a 4-byte length prefix containing a large value (e.g., 1 GB = 1,073,741,824 bytes)
3. Sends actual data to fill the buffer
4. Server allocates 1 GB in `self.buffer` plus another 1 GB in the return Vec (line 493)
5. Multiple concurrent requests can exhaust all available memory
6. Server process crashes due to OOM

The service is used in the safety-rules remote mode: [5](#0-4) 

## Impact Explanation

**Severity: Low** (despite potential DoS impact)

The impact is limited because:

1. **Mainnet validators are protected**: The configuration sanitizer explicitly prevents remote safety-rules services on mainnet, requiring `SafetyRulesService::Local`: [6](#0-5) 

2. **Scope limitation**: Per bug bounty rules, "Network-level DoS attacks are out of scope"

3. **Limited deployment**: This code path is only used in testnet/development environments where `SafetyRulesService::Process` mode might be enabled

4. **No funds at risk**: This is a pure availability issue with no consensus safety violation or funds loss

While a successful attack could crash safety-rules services in test environments, the explicit mainnet protection and DoS scope exclusion limit the severity to Low.

## Likelihood Explanation

**Likelihood: Low** in production, **Medium** in test environments

- **Production**: Near-zero likelihood since mainnet config sanitizer prevents this code path
- **Test environments**: Medium likelihood if:
  - Attacker has network access to the safety-rules service port
  - Service is running in Process mode
  - No additional network-level rate limiting exists

The attack itself is trivial to execute (just send malformed length prefix), but access to the vulnerable service is limited.

## Recommendation

Add maximum message size validation in `read_buffer()` consistent with the GRPC implementation:

```rust
fn read_buffer(&mut self) -> Vec<u8> {
    const MAX_MESSAGE_SIZE: usize = 80 * 1024 * 1024; // 80 MB
    
    if self.buffer.len() < 4 {
        return Vec::new();
    }

    let mut u32_bytes = [0; 4];
    u32_bytes.copy_from_slice(&self.buffer[..4]);
    let data_size = u32::from_le_bytes(u32_bytes) as usize;
    
    // Validate message size before allocating
    if data_size > MAX_MESSAGE_SIZE {
        // Clear buffer and return error through parent read() function
        self.buffer.clear();
        return Vec::new(); // Could also return Err(Error::DataTooLarge(data_size))
    }

    let remaining_data = &self.buffer[4..];
    if remaining_data.len() < data_size {
        return Vec::new();
    }

    let returnable_data = remaining_data[..data_size].to_vec();
    self.buffer = remaining_data[data_size..].to_vec();
    returnable_data
}
```

Additionally, consider adding periodic buffer size checks in the `read()` loop to prevent unbounded accumulation.

## Proof of Concept

```rust
#[cfg(test)]
mod exploit_test {
    use super::*;
    use std::io::Write;
    use std::net::{TcpListener, TcpStream};
    use std::thread;
    
    #[test]
    fn test_unbounded_read_allocation() {
        let listener = TcpListener::bind("127.0.0.1:0").unwrap();
        let addr = listener.local_addr().unwrap();
        
        // Spawn attacker thread
        thread::spawn(move || {
            let (mut stream, _) = listener.accept().unwrap();
            
            // Send malicious length prefix: 1 GB
            let malicious_size: u32 = 1_000_000_000;
            stream.write_all(&malicious_size.to_le_bytes()).unwrap();
            
            // Send some data to keep connection alive
            let data = vec![0u8; 10_000];
            stream.write_all(&data).unwrap();
            
            // Server will now allocate and try to read 1GB
            thread::sleep(std::time::Duration::from_secs(5));
        });
        
        thread::sleep(std::time::Duration::from_millis(100));
        
        // Server attempts to read - will allocate large buffer
        let mut client = NetworkClient::new(
            "exploit_test".to_string(),
            addr,
            5000
        );
        
        // This will cause large memory allocation attempting to read 1GB
        // In a real attack, this would be repeated to exhaust memory
        let result = client.read();
        
        // The read will timeout or fail, but memory has been allocated
        assert!(result.is_err());
    }
}
```

---

**Note:** While this is a valid implementation bug that violates the Resource Limits invariant (#9: "All operations must respect gas, storage, and computational limits"), it does not meet the reporting criteria due to:
1. Low severity classification
2. DoS attacks being out of scope
3. Not exploitable on mainnet production deployments

The issue should be fixed for defense-in-depth, but does not constitute a Critical/High/Medium severity vulnerability per the bug bounty program criteria.

### Citations

**File:** secure/net/src/lib.rs (L438-443)
```rust
            let read = self.stream.read(&mut self.temp_buffer)?;
            trace!("Read {} bytes from stream", read);
            if read == 0 {
                return Err(Error::RemoteStreamClosed);
            }
            self.buffer.extend(self.temp_buffer[..read].to_vec());
```

**File:** secure/net/src/lib.rs (L486-486)
```rust
        let data_size = u32::from_le_bytes(u32_bytes) as usize;
```

**File:** secure/net/src/lib.rs (L493-493)
```rust
        let returnable_data = remaining_data[..data_size].to_vec();
```

**File:** secure/net/src/grpc_network_service/mod.rs (L23-23)
```rust
const MAX_MESSAGE_SIZE: usize = 1024 * 1024 * 80;
```

**File:** consensus/safety-rules/src/remote_service.rs (L51-51)
```rust
    let request = network_server.read()?;
```

**File:** config/src/config/safety_rules_config.rs (L99-103)
```rust
            if chain_id.is_mainnet() && !safety_rules_config.service.is_local() {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    format!("The safety rules service should be set to local in mainnet for optimal performance! Given config: {:?}", &safety_rules_config.service)
                ));
```
