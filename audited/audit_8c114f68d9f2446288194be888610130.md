# Audit Report

## Title
Incorrect Meter Limit Applied to Module-Level Verification Causing Potential Module Rejection

## Summary
The bytecode verifier's `BoundMeter` incorrectly initializes the module-level meter bounds with `max_per_fun_meter_units` instead of `max_per_mod_meter_units`, causing the module meter to be limited by the per-function limit rather than the per-module limit. This causes verification of earlier functions to affect the meter budget for subsequent functions when the accumulated module cost is checked against the incorrect limit. [1](#0-0) 

## Finding Description
The Move bytecode verifier uses a metering system to limit verification complexity. The `VerifierConfig` provides two separate configuration fields for controlling verification costs:
- `max_per_fun_meter_units`: limit for individual function verification
- `max_per_mod_meter_units`: limit for cumulative module verification [2](#0-1) 

During module verification, a single `BoundMeter` is created and reused across all functions in the module. The meter has two separate bounds: `fun_bounds` for function-level tracking and `mod_bounds` for module-level tracking. [3](#0-2) 

For each function verification:
1. `enter_scope(Scope::Function)` properly resets `fun_bounds.units` to 0
2. Verification accumulates costs in `fun_bounds`
3. `transfer(Scope::Function, Scope::Module, 1.0)` adds function costs to `mod_bounds`
4. The transfer operation checks if `mod_bounds.units` exceeds `mod_bounds.max` [4](#0-3) 

The bug is at line 115 of `meter.rs`, where `mod_bounds.max` is incorrectly set to `config.max_per_fun_meter_units` instead of `config.max_per_mod_meter_units`. This causes the module meter to be limited by the per-function limit, not the per-module limit. [5](#0-4) 

When a module has multiple functions, even if each function individually passes the per-function limit, the accumulated module cost could exceed the incorrectly-applied per-function limit and cause verification to fail.

## Impact Explanation
**Current Production Impact:** In the current Aptos production configuration, both limits are set to the same value (80,000,000), so this bug does not manifest in practice. [6](#0-5) 

**Potential Future Impact:** If the configuration is changed to set different values (e.g., `max_per_fun_meter_units = 10,000,000` and `max_per_mod_meter_units = 100,000,000`), this bug would cause:

1. **Denial of Service**: Valid modules with many functions would be incorrectly rejected, even if each function is individually within limits
2. **Configuration System Violation**: The intended separation between per-function and per-module limits would be broken
3. **Developer Impact**: Legitimate module developers would be unable to deploy valid code

This qualifies as **Medium Severity** under Aptos bug bounty criteria as it could cause "state inconsistencies requiring intervention" if the configuration system is used as intended.

## Likelihood Explanation
**Current Likelihood:** Low - the bug does not manifest in production because both limits are set equally.

**Future Likelihood:** Medium-High if configuration is changed to use different per-function and per-module limits, which appears to be the intended use case given the existence of two separate configuration fields.

The bug is deterministic and would affect all modules with sufficient cumulative verification cost once configuration is changed.

## Recommendation
Fix the `BoundMeter::new()` function to use the correct configuration field for module bounds:

```rust
impl BoundMeter {
    pub fn new(config: &VerifierConfig) -> Self {
        Self {
            mod_bounds: Bounds {
                name: "<unknown>".to_string(),
                units: 0,
                max: config.max_per_mod_meter_units,  // FIX: use correct field
            },
            fun_bounds: Bounds {
                name: "<unknown>".to_string(),
                units: 0,
                max: config.max_per_fun_meter_units,
            },
        }
    }
}
```

## Proof of Concept
```rust
use move_bytecode_verifier::{CodeUnitVerifier, VerifierConfig};
use move_binary_format::file_format::{
    empty_module, Bytecode, CodeUnit, FunctionDefinition, 
    FunctionHandle, IdentifierIndex, ModuleHandleIndex, SignatureIndex,
};

#[test]
fn test_module_meter_uses_wrong_limit() {
    // Create a module with 15 small functions
    let mut module = empty_module();
    
    for i in 0..15 {
        // Each function has a simple loop to consume meter units
        let code = vec![
            Bytecode::LdU64(0),
            Bytecode::LdU64(10),
            Bytecode::Lt,
            Bytecode::BrFalse(5),
            Bytecode::LdU64(1),
            Bytecode::Add,
            Bytecode::Branch(1),
            Bytecode::Ret,
        ];
        
        let code_unit = CodeUnit {
            code,
            ..Default::default()
        };
        
        let fun_def = FunctionDefinition {
            code: Some(code_unit),
            ..Default::default()
        };
        
        let fun_handle = FunctionHandle {
            module: ModuleHandleIndex(0),
            name: IdentifierIndex(i),
            parameters: SignatureIndex(0),
            return_: SignatureIndex(0),
            type_parameters: vec![],
            access_specifiers: None,
            attributes: vec![],
        };
        
        module.function_handles.push(fun_handle);
        module.function_defs.push(fun_def);
    }
    
    // Configure with different per-function and per-module limits
    let config = VerifierConfig {
        max_per_fun_meter_units: Some(100_000),    // 100K per function
        max_per_mod_meter_units: Some(10_000_000), // 10M per module
        ..Default::default()
    };
    
    // This should pass (15 functions * ~80K each = ~1.2M < 10M module limit)
    // But will fail because module meter incorrectly uses 100K limit
    let result = CodeUnitVerifier::verify_module(&config, &module);
    
    // Due to the bug, this will fail even though it should pass
    // The module accumulated cost (~1.2M) exceeds the incorrectly applied 
    // per-function limit (100K) instead of being checked against the 
    // correct per-module limit (10M)
    assert!(result.is_err(), "Bug manifests: module rejected incorrectly");
}
```

## Notes
- This bug directly answers the security question: verification of one function DOES affect the meter budget for subsequent functions through the module-level accumulation, and the module meter is checked against the incorrect limit.
- While the function-level meter IS properly reset via `enter_scope`, the module-level meter accumulates and uses the wrong configuration value for its limit.
- The impact is currently mitigated in production by setting both limits to the same value, but this breaks the intended configuration system design.
- The fix is trivial (one-line change) but important for maintaining correct verifier behavior if configuration is adjusted in the future.

### Citations

**File:** third_party/move/move-bytecode-verifier/src/meter.rs (L80-87)
```rust
    fn transfer(&mut self, from: Scope, to: Scope, factor: f32) -> PartialVMResult<()> {
        let units = (self.get_bounds(from).units as f32 * factor) as u128;
        self.add(to, units)
    }

    fn add(&mut self, scope: Scope, units: u128) -> PartialVMResult<()> {
        self.get_bounds(scope).add(units)
    }
```

**File:** third_party/move/move-bytecode-verifier/src/meter.rs (L109-123)
```rust
impl BoundMeter {
    pub fn new(config: &VerifierConfig) -> Self {
        Self {
            mod_bounds: Bounds {
                name: "<unknown>".to_string(),
                units: 0,
                max: config.max_per_fun_meter_units,
            },
            fun_bounds: Bounds {
                name: "<unknown>".to_string(),
                units: 0,
                max: config.max_per_fun_meter_units,
            },
        }
    }
```

**File:** third_party/move/move-bytecode-verifier/src/verifier.rs (L52-53)
```rust
    pub max_per_fun_meter_units: Option<u128>,
    pub max_per_mod_meter_units: Option<u128>,
```

**File:** third_party/move/move-bytecode-verifier/src/code_unit_verifier.rs (L46-76)
```rust
    fn verify_module_impl(
        verifier_config: &VerifierConfig,
        module: &CompiledModule,
    ) -> PartialVMResult<()> {
        let mut meter = BoundMeter::new(verifier_config);
        let mut name_def_map = HashMap::new();
        for (idx, func_def) in module.function_defs().iter().enumerate() {
            let fh = module.function_handle_at(func_def.function);
            name_def_map.insert(fh.name, FunctionDefinitionIndex(idx as u16));
        }
        let mut total_back_edges = 0;
        for (idx, function_definition) in module.function_defs().iter().enumerate() {
            let index = FunctionDefinitionIndex(idx as TableIndex);
            let num_back_edges = Self::verify_function(
                verifier_config,
                index,
                function_definition,
                module,
                &name_def_map,
                &mut meter,
            )
            .map_err(|err| err.at_index(IndexKind::FunctionDefinition, index.0))?;
            total_back_edges += num_back_edges;
        }
        if let Some(limit) = verifier_config.max_back_edges_per_module {
            if total_back_edges > limit {
                return Err(PartialVMError::new(StatusCode::TOO_MANY_BACK_EDGES));
            }
        }
        Ok(())
    }
```

**File:** third_party/move/move-bytecode-verifier/src/code_unit_verifier.rs (L117-177)
```rust
    fn verify_function(
        verifier_config: &VerifierConfig,
        index: FunctionDefinitionIndex,
        function_definition: &FunctionDefinition,
        module: &CompiledModule,
        name_def_map: &HashMap<IdentifierIndex, FunctionDefinitionIndex>,
        meter: &mut impl Meter,
    ) -> PartialVMResult<usize> {
        meter.enter_scope(
            module
                .identifier_at(module.function_handle_at(function_definition.function).name)
                .as_str(),
            Scope::Function,
        );
        // nothing to verify for native function
        let code = match &function_definition.code {
            Some(code) => code,
            None => return Ok(0),
        };

        // create `FunctionView` and `BinaryIndexedView`
        let function_view = control_flow::verify_function(
            verifier_config,
            module,
            index,
            function_definition,
            code,
            meter,
        )?;

        if let Some(limit) = verifier_config.max_basic_blocks {
            if function_view.cfg().blocks().len() > limit {
                return Err(
                    PartialVMError::new(StatusCode::TOO_MANY_BASIC_BLOCKS).at_code_offset(index, 0)
                );
            }
        }

        let num_back_edges = function_view.cfg().num_back_edges();
        if let Some(limit) = verifier_config.max_back_edges_per_function {
            if num_back_edges > limit {
                return Err(
                    PartialVMError::new(StatusCode::TOO_MANY_BACK_EDGES).at_code_offset(index, 0)
                );
            }
        }

        let resolver = BinaryIndexedView::Module(module);
        // verify
        let code_unit_verifier = CodeUnitVerifier {
            resolver,
            function_view,
            name_def_map,
        };
        code_unit_verifier.verify_common(verifier_config, meter)?;
        AcquiresVerifier::verify(module, index, function_definition, meter)?;

        meter.transfer(Scope::Function, Scope::Module, 1.0)?;

        Ok(num_back_edges)
    }
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L175-176)
```rust
        max_per_fun_meter_units: Some(1000 * 80000),
        max_per_mod_meter_units: Some(1000 * 80000),
```
