# Audit Report

## Title
Authentication Key Rotation Without Event Emission Bypasses Audit Logs

## Summary
The `rotate_authentication_key_call()` entry function in the Aptos Framework allows users to rotate their authentication keys without emitting `KeyRotation` or `KeyRotationEvent` events, bypassing audit trail requirements and making it impossible for off-chain systems to track key rotation activities.

## Finding Description

The Aptos Framework's account module provides multiple pathways for authentication key rotation. While `rotate_authentication_key()` and `rotate_authentication_key_with_rotation_capability()` properly emit events through the `update_auth_key_and_originating_address_table()` function, the `rotate_authentication_key_call()` entry function bypasses this mechanism entirely. [1](#0-0) 

This function calls `rotate_authentication_key_internal()` which only updates the authentication key without any event emission: [2](#0-1) 

In contrast, the proper key rotation flow calls `update_auth_key_and_originating_address_table()` which emits events: [3](#0-2) 

The vulnerability exists because `rotate_authentication_key_call()` is a public entry function callable by any account holder, allowing them to rotate keys while evading audit mechanisms that rely on event emission. This is confirmed by the test infrastructure which accurately models this behavior: [4](#0-3) 

The test executor even acknowledges this limitation: [5](#0-4) 

## Impact Explanation

This vulnerability falls under **Medium Severity** per the Aptos Bug Bounty criteria as it creates state inconsistencies requiring intervention and compromises audit trail integrity. While it doesn't directly result in fund loss or consensus violations, it:

1. **Breaks Audit Trail Integrity**: Off-chain indexers and monitoring systems that rely on `key_rotation_events` EventHandle or `KeyRotation` events will miss rotations performed via `rotate_authentication_key_call()`, creating blind spots in security monitoring.

2. **Compliance Violations**: Enterprises and regulated entities using Aptos may be unable to meet audit requirements that mandate complete logging of authentication changes.

3. **Forensic Investigation Gaps**: Post-incident investigations cannot reconstruct the complete history of key rotations, potentially obscuring evidence of account compromise or unauthorized access.

4. **Inconsistent Event Emission**: The existence of multiple key rotation methods with different event emission behaviors creates inconsistent behavior that violates the principle of complete audit logging.

## Likelihood Explanation

**Likelihood: High**

The vulnerability is highly likely to be exploited because:

1. **No Special Privileges Required**: Any account holder can call `rotate_authentication_key_call()` as it is a public entry function.

2. **Already in Production Use**: Evidence from mainnet transactions shows this function is actively being used: [6](#0-5) 

3. **Intentional Design for Passkeys**: The function was explicitly designed to support non-standard key algorithms (passkeys, WebAuthn) that cannot produce proof-of-knowledge signatures, making it a necessary feature that cannot be easily removed.

4. **Multiple Call Paths**: The function is called by other entry functions like `rotate_authentication_key_from_public_key()` and `upsert_ed25519_backup_key_on_keyless_account()`, amplifying the audit gap: [7](#0-6) [8](#0-7) 

## Recommendation

**Solution 1: Emit Events in rotate_authentication_key_internal()**

Modify `rotate_authentication_key_internal()` to emit at minimum a `KeyRotation` event even when the `OriginatingAddress` table is not updated:

```move
public(friend) fun rotate_authentication_key_internal(account: &signer, new_auth_key: vector<u8>) acquires Account {
    let addr = signer::address_of(account);
    ensure_resource_exists(addr);
    assert!(
        new_auth_key.length() == 32,
        error::invalid_argument(EMALFORMED_AUTHENTICATION_KEY)
    );
    check_rotation_permission(account);
    let account_resource = &mut Account[addr];
    let old_auth_key = account_resource.authentication_key;
    account_resource.authentication_key = new_auth_key;
    
    // Emit event for audit trail even without OriginatingAddress update
    if (std::features::module_event_migration_enabled()) {
        event::emit(KeyRotation {
            account: addr,
            old_authentication_key: old_auth_key,
            new_authentication_key: new_auth_key,
        });
    } else {
        event::emit_event<KeyRotationEvent>(
            &mut account_resource.key_rotation_events,
            KeyRotationEvent {
                old_authentication_key: old_auth_key,
                new_authentication_key: new_auth_key,
            }
        );
    };
}
```

**Solution 2: Add Separate Unverified Key Rotation Event**

Create a distinct event type for unverified rotations to maintain semantic clarity:

```move
#[event]
struct UnverifiedKeyRotation has drop, store {
    account: address,
    old_authentication_key: vector<u8>,
    new_authentication_key: vector<u8>,
}
```

This allows audit systems to distinguish between verified rotations (with proof-of-knowledge) and unverified rotations (for passkeys).

## Proof of Concept

```move
#[test_only]
module test_audit_bypass {
    use aptos_framework::account;
    use aptos_framework::event;
    use std::signer;
    use std::vector;
    
    #[test(account = @0xCAFE)]
    fun test_key_rotation_without_events(account: &signer) {
        let addr = signer::address_of(account);
        
        // Create account
        account::create_account_for_test(addr);
        
        // Get initial event count
        let account_resource = borrow_global<account::Account>(addr);
        let initial_event_count = event::counter(&account_resource.key_rotation_events);
        
        // Rotate key using rotate_authentication_key_call
        let new_auth_key = vector::empty<u8>();
        let i = 0;
        while (i < 32) {
            vector::push_back(&mut new_auth_key, (i as u8));
            i = i + 1;
        };
        
        account::rotate_authentication_key_call(account, new_auth_key);
        
        // Verify key was rotated but no event was emitted
        let account_resource = borrow_global<account::Account>(addr);
        assert!(account_resource.authentication_key == new_auth_key, 1);
        
        let final_event_count = event::counter(&account_resource.key_rotation_events);
        assert!(initial_event_count == final_event_count, 2); // Event counter unchanged!
    }
}
```

**Expected behavior**: The test demonstrates that authentication keys can be rotated without incrementing the `key_rotation_events` counter, confirming the audit log bypass.

## Notes

The test infrastructure file `AccountData::rotate_key()` accurately simulates this production behavior by not updating the `key_rotation_events` EventHandle counter, which is why it was flagged in the security question. The real vulnerability exists in the production Move framework code where audit trail completeness is a critical security requirement for enterprise adoption and compliance.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L440-450)
```text
    public(friend) fun rotate_authentication_key_internal(account: &signer, new_auth_key: vector<u8>) acquires Account {
        let addr = signer::address_of(account);
        ensure_resource_exists(addr);
        assert!(
            new_auth_key.length() == 32,
            error::invalid_argument(EMALFORMED_AUTHENTICATION_KEY)
        );
        check_rotation_permission(account);
        let account_resource = &mut Account[addr];
        account_resource.authentication_key = new_auth_key;
    }
```

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L460-462)
```text
    entry fun rotate_authentication_key_call(account: &signer, new_auth_key: vector<u8>) acquires Account {
        rotate_authentication_key_internal(account, new_auth_key);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L486-486)
```text
        rotate_authentication_key_call(account, new_auth_key);
```

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L560-560)
```text
        rotate_authentication_key_call(account, new_auth_key);
```

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L1083-1097)
```text
        if (std::features::module_event_migration_enabled()) {
            event::emit(KeyRotation {
                account: originating_addr,
                old_authentication_key: account_resource.authentication_key,
                new_authentication_key: new_auth_key_vector,
            });
        } else {
            event::emit_event<KeyRotationEvent>(
                &mut account_resource.key_rotation_events,
                KeyRotationEvent {
                    old_authentication_key: account_resource.authentication_key,
                    new_authentication_key: new_auth_key_vector,
                }
            );
        };
```

**File:** aptos-move/aptos-transaction-simulation/src/account.rs (L649-651)
```rust
    pub fn rotate_key(&mut self, privkey: Ed25519PrivateKey, pubkey: Ed25519PublicKey) {
        self.account.rotate_key(privkey, pubkey)
    }
```

**File:** aptos-move/e2e-tests/src/executor.rs (L1705-1706)
```rust
        // Note: This does not update the mapping of originating addresses but it is probably fine
        //       for testing purposes.
```

**File:** ecosystem/indexer-grpc/indexer-test-transactions/src/json_transactions/imported_mainnet_txns/2200077673_account_restoration_unverified_key_rotation_to_multi_key_txn.json (L1-1)
```json
{
```
