# Audit Report

## Title
IP Allowlist Bypass Enables Unlimited Faucet Drain Without Rate Limiting

## Summary
The `IpAllowlistBypasser` allows requests from allowlisted IP ranges to completely bypass all checkers, including rate limit controls. An attacker with access to allowlisted IP addresses can make unlimited funding requests to exhaust the faucet's resources, preventing legitimate users from accessing the service.

## Finding Description
The faucet's IP allowlist feature is implemented through `IpAllowlistBypasser`, which checks if a request's source IP falls within configured CIDR ranges. [1](#0-0) 

When a bypasser returns `true`, the request completely bypasses all checkers and no tracking occurs. [2](#0-1) 

Critically, bypassed requests skip the `complete()` phase where rate limit counters would normally be updated: [3](#0-2) 

This means rate limit checkers like `MemoryRatelimitChecker` never track bypassed requests. [4](#0-3) 

**Attack Scenario:**
1. Attacker gains access to an IP address in the allowlisted range (e.g., corporate network, cloud provider IP block, shared NAT)
2. Attacker sends unlimited funding requests to different receiver addresses from the allowlisted IP
3. Each request bypasses all rate limiting and checkers
4. For `TransferFunder`, the faucet account balance is drained: [5](#0-4) 
5. For `MintFunder`, unlimited coins are minted, spamming the network
6. Legitimate users (including those with allowlisted IPs) cannot obtain funds due to exhaustion

The security guarantee broken is that bypassed requests can optionally receive higher amounts via `maximum_amount_with_bypass`: [6](#0-5) 

## Impact Explanation
**Medium Severity** per Aptos bug bounty criteria - this constitutes resource exhaustion and denial of service:

- **For TransferFunder**: Attacker drains the faucet account balance, requiring manual intervention to refill
- **For MintFunder**: Unlimited minting creates blockchain spam and degrades network performance
- **Availability Impact**: Legitimate developers and users cannot access testnet funds
- **No Consensus Impact**: This is a faucet service issue, not a blockchain consensus vulnerability

This qualifies as "Limited funds loss or manipulation" and "State inconsistencies requiring intervention" under Medium severity.

## Likelihood Explanation
**Medium-High Likelihood:**

- **Attacker Requirements**: Access to an IP in the allowlisted range (corporate networks, cloud providers, shared infrastructure)
- **Complexity**: Low - simple HTTP requests, no cryptographic operations needed
- **Detection**: Difficult - bypassed requests generate no rate limit alerts or tracking
- **Common Scenario**: Organizations often allowlist entire IP ranges (e.g., `/24` or `/16` CIDR blocks) rather than individual IPs, expanding attack surface

The vulnerability is particularly exploitable in scenarios where:
- Allowlists include broad cloud provider ranges
- Multiple users share the same public IP (NAT)
- Internal networks have malicious actors

## Recommendation
Implement defense-in-depth by adding rate limiting specifically for bypassed requests:

**Option 1**: Add per-receiver-address rate limiting that applies even to bypassed requests
```rust
// In FundApiComponents::fund_inner, after line 296:
if bypass {
    // Even bypassed requests should have per-account limits
    self.check_receiver_rate_limit(&checker_data.receiver).await?;
}
```

**Option 2**: Add configuration for per-IP rate limits on bypassed requests
```rust
pub struct IpAllowlistBypasserConfig {
    pub ip_range_config: IpRangeManagerConfig,
    pub max_bypassed_requests_per_day: Option<u32>,  // New field
}
```

**Option 3**: Remove the bypass skip of `complete()` phase to maintain tracking:
```rust
// Always call complete() for audit trail, even if bypassed
for checker in &self.checkers {
    checker.complete(complete_data.clone()).await?;
}
```

**Recommended Fix**: Implement Option 1 + Option 3 for defense-in-depth.

## Proof of Concept
```rust
#[tokio::test]
async fn test_ip_allowlist_exhaustion() {
    // Setup faucet with IP allowlist containing 10.0.0.0/8
    let config = create_test_config_with_allowlist("10.0.0.0/8");
    let faucet = build_faucet(config).await;
    
    // Simulate attacker from allowlisted IP
    let allowlisted_ip = "10.0.0.100".parse().unwrap();
    
    // Make 1000 requests rapidly without any rate limiting
    for i in 0..1000 {
        let receiver = AccountAddress::random();
        let result = faucet.fund(
            FundRequest {
                address: Some(receiver.to_hex_literal()),
                amount: Some(100_000_000),
                ..Default::default()
            },
            RealIp(Some(allowlisted_ip)),
            &HeaderMap::new(),
        ).await;
        
        // All requests succeed - no rate limiting applied
        assert!(result.is_ok(), "Request {} should succeed", i);
    }
    
    // Verify faucet is drained or overloaded
    let health = faucet.funder.is_healthy().await;
    assert!(!health.can_process_requests, "Faucet should be unhealthy");
    
    // Legitimate user from same allowlist cannot get funds
    let legitimate_user = AccountAddress::random();
    let result = faucet.fund(
        FundRequest {
            address: Some(legitimate_user.to_hex_literal()),
            amount: Some(100_000_000),
            ..Default::default()
        },
        RealIp(Some(allowlisted_ip)),
        &HeaderMap::new(),
    ).await;
    
    assert!(result.is_err(), "Legitimate user should fail due to exhaustion");
}
```

## Notes
The vulnerability exists because the allowlist design assumes trusted users, but in practice:
- IP addresses can be shared by multiple users (NAT, proxies)
- Compromised machines on allowlisted networks can abuse the bypass
- Broad CIDR ranges expose large attack surfaces

The faucet is not part of the core blockchain consensus, so this does not affect consensus safety or validator operations. However, it prevents legitimate testnet usage and constitutes a Medium severity resource exhaustion vulnerability.

### Citations

**File:** crates/aptos-faucet/core/src/bypasser/ip_allowlist.rs (L24-29)
```rust
#[async_trait]
impl BypasserTrait for IpAllowlistBypasser {
    async fn request_can_bypass(&self, data: CheckerData) -> Result<bool> {
        Ok(self.manager.contains_ip(&data.source_ip))
    }
}
```

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L245-259)
```rust
        for bypasser in &self.bypassers {
            if bypasser
                .request_can_bypass(checker_data.clone())
                .await
                .map_err(|e| {
                    AptosTapError::new_with_error_code(e, AptosTapErrorCode::BypasserError)
                })?
            {
                info!(
                    "Allowing request from {} to bypass checks / storage",
                    source_ip
                );
                return Ok((checker_data, true, permit));
            }
        }
```

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L332-347)
```rust
        if !bypass {
            let response_is_500 = match &fund_result {
                Ok(_) => false,
                Err(e) => e.error_code.status().is_server_error(),
            };
            let complete_data = CompleteData {
                checker_data,
                txn_hashes: txn_hashes.clone(),
                response_is_500,
            };
            for checker in &self.checkers {
                checker.complete(complete_data.clone()).await.map_err(|e| {
                    AptosTapError::new_with_error_code(e, AptosTapErrorCode::CheckerError)
                })?;
            }
        }
```

**File:** crates/aptos-faucet/core/src/checkers/memory_ratelimit.rs (L67-91)
```rust
impl CheckerTrait for MemoryRatelimitChecker {
    async fn check(
        &self,
        data: CheckerData,
        dry_run: bool,
    ) -> Result<Vec<RejectionReason>, AptosTapError> {
        self.clear_if_new_day().await;

        let mut ip_to_requests_today = self.ip_to_requests_today.lock().await;

        let requests_today = ip_to_requests_today.get_or_insert_mut(data.source_ip, || 1);
        if *requests_today >= self.max_requests_per_day {
            return Ok(vec![RejectionReason::new(
                format!(
                    "IP {} has exceeded the daily limit of {} requests",
                    data.source_ip, self.max_requests_per_day
                ),
                RejectionReasonCode::UsageLimitExhausted,
            )]);
        } else if !dry_run {
            *requests_today += 1;
        }

        Ok(vec![])
    }
```

**File:** crates/aptos-faucet/core/src/funder/transfer.rs (L263-331)
```rust
    async fn fund(
        &self,
        amount: Option<u64>,
        receiver_address: AccountAddress,
        _asset: Option<String>,
        check_only: bool,
        did_bypass_checkers: bool,
    ) -> Result<Vec<SignedTransaction>, AptosTapError> {
        // Confirm the funder has sufficient balance, return a 500 if not. This
        // will only happen briefly, soon after we get into this state the LB
        // will deregister this instance based on the health check responses
        // being returned from `/`.
        self.is_healthy_as_result().await?;

        let client = self.get_api_client();

        // Determine amount to fund.
        let amount = self.get_amount(amount, did_bypass_checkers);

        // Update the sequence numbers of the accounts.
        // TransferFunder always uses DEFAULT_ASSET_NAME since it only handles a single asset.
        let (_funder_seq_num, receiver_seq_num) = update_sequence_numbers(
            &client,
            &self.faucet_account,
            &self.outstanding_requests,
            receiver_address,
            amount,
            self.wait_for_outstanding_txns_secs,
            DEFAULT_ASSET_NAME,
        )
        .await?;

        // When updating the sequence numbers, we expect that the receiver sequence
        // number should be None, because the account should not exist yet.
        if receiver_seq_num.is_some() {
            return Err(AptosTapError::new(
                "Account ineligible".to_string(),
                AptosTapErrorCode::Rejected,
            )
            .rejection_reasons(vec![RejectionReason::new(
                format!("Account {} already exists", receiver_address),
                RejectionReasonCode::AccountAlreadyExists,
            )]));
        }

        // This Move function checks if the account exists, and if it does,
        // returns an error. If not, it creates the account and transfers the
        // requested amount of coins to it.
        let transactions = if check_only {
            vec![]
        } else {
            let txn = self
                .execute_transaction(
                    &client,
                    aptos_stdlib::aptos_account_transfer(receiver_address, amount),
                    &receiver_address,
                )
                .await?;
            info!(
                hash = txn.committed_hash().to_hex_literal(),
                address = receiver_address,
                amount = amount,
                event = "transaction_submitted"
            );
            vec![txn]
        };

        Ok(transactions)
    }
```

**File:** crates/aptos-faucet/core/src/funder/mint.rs (L540-550)
```rust
    fn get_amount(&self, amount: Option<u64>, did_bypass_checkers: bool) -> u64 {
        match (
            amount,
            self.txn_config.get_maximum_amount(did_bypass_checkers),
        ) {
            (Some(amount), Some(maximum_amount)) => std::cmp::min(amount, maximum_amount),
            (Some(amount), None) => amount,
            (None, Some(maximum_amount)) => std::cmp::min(self.amount_to_fund, maximum_amount),
            (None, None) => self.amount_to_fund,
        }
    }
```
