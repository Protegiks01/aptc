# Audit Report

## Title
Validator Node Crash via Unhandled Panic in DKG Public Parameter Construction

## Summary
The DKG result processing function in `aptos-vm` contains unsafe `.unwrap()` operations that can cause validator nodes to panic and crash when processing DKG session metadata containing invalid BLS12-381 public key bytes, potentially leading to network-wide validator outages.

## Finding Description

The `process_dkg_result_inner()` function fetches `DKGState` from on-chain storage and processes it to verify and publish DKG results. While the `ok_or` operations at lines 91-97 properly convert `Option` to `Result`, a critical vulnerability exists in the downstream call chain. [1](#0-0) 

When `DefaultDKG::new_public_params()` is invoked at line 105, it internally calls methods that perform unsafe conversions: [2](#0-1) 

The `new_public_params` function calls `target_validator_consensus_infos_cloned()` and `dealer_consensus_infos_cloned()`: [3](#0-2) 

These methods contain unsafe `.unwrap()` calls on fallible type conversions: [4](#0-3) 

The conversion from `ValidatorConsensusInfoMoveStruct` to `ValidatorConsensusInfo` can fail when BLS12-381 public key bytes are invalid: [5](#0-4) 

The `PublicKey::try_from` validates that bytes represent a valid curve point, and returns an error for invalid input: [6](#0-5) 

**Attack Path:**
If corrupted or malicious state exists in `DKGState` storage (via storage corruption, a Move VM bug allowing arbitrary writes, or validation bypass), when any validator processes a DKG result transaction:
1. `DKGState` is fetched containing invalid `pk_bytes` in validator consensus info
2. Line 105 calls `new_public_params()` 
3. The `.unwrap()` panics on failed conversion
4. The validator node crashes

This violates the **Deterministic Execution** invariant - validators should handle errors gracefully rather than panicking, as panics are non-recoverable and cause node crashes.

## Impact Explanation

**High Severity** - This meets the Aptos bug bounty criteria for "Validator node slowdowns" and potentially "API crashes." If multiple validators attempt to process a DKG result containing invalid data simultaneously, it could cause network-wide validator crashes, approaching Critical severity ("Total loss of liveness/network availability").

The vulnerability breaks the defense-in-depth principle: even if Move-side validation is correct, the Rust execution layer should handle invalid storage data gracefully rather than panicking. Panics in validator transaction processing are consensus-critical failures.

## Likelihood Explanation

**Medium-Low Likelihood** under normal conditions, as validator consensus keys are validated during registration and rotation: [7](#0-6) [8](#0-7) 

However, likelihood increases in scenarios involving:
- Storage layer corruption or bugs
- Future Move VM vulnerabilities enabling validation bypass
- Genesis misconfiguration
- Unforeseen serialization/deserialization edge cases

The impact severity warrants fixing regardless of likelihood.

## Recommendation

Replace unsafe `.unwrap()` calls with proper error handling that returns `Result` types. The conversion failures should propagate as expected `ExecutionFailure` errors rather than causing panics.

**Fix for `types/src/dkg/mod.rs`:**
```rust
// Change return type to Result
pub fn target_validator_consensus_infos_cloned(&self) -> Result<Vec<ValidatorConsensusInfo>> {
    self.target_validator_set
        .clone()
        .into_iter()
        .map(|obj| obj.try_into())
        .collect()
}

pub fn dealer_consensus_infos_cloned(&self) -> Result<Vec<ValidatorConsensusInfo>> {
    self.dealer_validator_set
        .clone()
        .into_iter()
        .map(|obj| obj.try_into())
        .collect()
}
```

**Fix for `types/src/dkg/real_dkg/mod.rs`:**
```rust
fn new_public_params(dkg_session_metadata: &DKGSessionMetadata) -> Result<RealDKGPublicParams> {
    // ... existing code ...
    
    let target_infos = dkg_session_metadata
        .target_validator_consensus_infos_cloned()
        .context("Invalid target validator consensus info")?;
    let pvss_config = build_dkg_pvss_config(/* ... */, &target_infos);
    
    let dealer_infos = dkg_session_metadata
        .dealer_consensus_infos_cloned()
        .context("Invalid dealer consensus info")?;
    let verifier = ValidatorVerifier::new(dealer_infos);
    
    Ok(RealDKGPublicParams { /* ... */ })
}
```

Then propagate errors in `aptos-move/aptos-vm/src/validator_txns/dkg.rs` line 105 as `Expected` failures.

## Proof of Concept

```rust
#[test]
fn test_dkg_invalid_pubkey_crash() {
    use aptos_types::dkg::{DKGSessionMetadata, ValidatorConsensusInfoMoveStruct};
    use aptos_types::validator_verifier::ValidatorConsensusInfo;
    
    // Create metadata with invalid BLS key bytes (wrong length)
    let invalid_metadata = DKGSessionMetadata {
        dealer_epoch: 1,
        randomness_config: RandomnessConfigMoveStruct::default(),
        dealer_validator_set: vec![ValidatorConsensusInfoMoveStruct {
            addr: AccountAddress::ONE,
            pk_bytes: vec![0xFF; 32], // Invalid: BLS keys are 48 bytes, wrong format
            voting_power: 100,
        }],
        target_validator_set: vec![],
    };
    
    // This will panic with .unwrap() instead of returning Err
    let result = std::panic::catch_unwind(|| {
        invalid_metadata.dealer_consensus_infos_cloned()
    });
    
    assert!(result.is_err(), "Should panic on invalid key bytes");
}
```

This test demonstrates that invalid public key bytes cause a panic rather than returning a proper error, violating defensive programming principles for consensus-critical code.

### Citations

**File:** aptos-move/aptos-vm/src/validator_txns/dkg.rs (L91-97)
```rust
        let dkg_state =
            OnChainConfig::fetch_config(resolver).ok_or(Expected(MissingResourceDKGState))?;
        let config_resource = ConfigurationResource::fetch_config(resolver)
            .ok_or(Expected(MissingResourceConfiguration))?;
        let DKGState { in_progress, .. } = dkg_state;
        let in_progress_session_state =
            in_progress.ok_or(Expected(MissingResourceInprogressDKGSession))?;
```

**File:** aptos-move/aptos-vm/src/validator_txns/dkg.rs (L105-105)
```rust
        let pub_params = DefaultDKG::new_public_params(&in_progress_session_state.metadata);
```

**File:** types/src/dkg/real_dkg/mod.rs (L216-218)
```rust
            &dkg_session_metadata.target_validator_consensus_infos_cloned(),
        );
        let verifier = ValidatorVerifier::new(dkg_session_metadata.dealer_consensus_infos_cloned());
```

**File:** types/src/dkg/mod.rs (L100-114)
```rust
    pub fn target_validator_consensus_infos_cloned(&self) -> Vec<ValidatorConsensusInfo> {
        self.target_validator_set
            .clone()
            .into_iter()
            .map(|obj| obj.try_into().unwrap())
            .collect()
    }

    pub fn dealer_consensus_infos_cloned(&self) -> Vec<ValidatorConsensusInfo> {
        self.dealer_validator_set
            .clone()
            .into_iter()
            .map(|obj| obj.try_into().unwrap())
            .collect()
    }
```

**File:** types/src/validator_verifier.rs (L118-126)
```rust
    fn try_from(value: ValidatorConsensusInfoMoveStruct) -> Result<Self, Self::Error> {
        let ValidatorConsensusInfoMoveStruct {
            addr,
            pk_bytes,
            voting_power,
        } = value;
        let public_key = bls12381_keys::PublicKey::try_from(pk_bytes.as_slice())?;
        Ok(Self::new(addr, public_key, voting_power))
    }
```

**File:** crates/aptos-crypto/src/bls12381/bls12381_keys.rs (L242-246)
```rust
    fn try_from(bytes: &[u8]) -> std::result::Result<Self, CryptoMaterialError> {
        Ok(Self {
            pubkey: blst::min_pk::PublicKey::from_bytes(bytes)
                .map_err(|_| CryptoMaterialError::DeserializationError)?,
        })
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L679-683)
```text
        let pubkey_from_pop = &bls12381::public_key_from_bytes_with_pop(
            consensus_pubkey,
            &proof_of_possession_from_bytes(proof_of_possession)
        );
        assert!(option::is_some(pubkey_from_pop), error::invalid_argument(EINVALID_PUBLIC_KEY));
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L927-931)
```text
        let pubkey_from_pop = &bls12381::public_key_from_bytes_with_pop(
            new_consensus_pubkey,
            &proof_of_possession_from_bytes(proof_of_possession)
        );
        assert!(option::is_some(pubkey_from_pop), error::invalid_argument(EINVALID_PUBLIC_KEY));
```
