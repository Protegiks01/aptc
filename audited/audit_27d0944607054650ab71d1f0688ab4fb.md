# Audit Report

## Title
Missing Signature Verification for Resumed State Sync Target Ledger Info

## Summary
When a node resumes state synchronization after a crash or reboot, it retrieves the `target_ledger_info` from persistent metadata storage without verifying that the signatures are valid or from the correct epoch's validator set. This violates the cryptographic correctness invariant and could allow state sync to proceed with an invalid or manipulated target.

## Finding Description

The state sync driver stores `target_ledger_info` (a `LedgerInfoWithSignatures`) in persistent metadata storage during snapshot synchronization. When a node crashes and restarts, the bootstrapper retrieves this target from storage and uses it to resume syncing without signature verification. [1](#0-0) 

The `target` retrieved from `metadata_storage.previous_snapshot_sync_target()` is directly passed to `fetch_missing_state_values()` without any signature verification against the appropriate epoch's validator set. This breaks the security assumption documented in the storage synchronizer interface: [2](#0-1) 

The metadata storage itself performs no signature validation when storing or retrieving the target ledger info: [3](#0-2) 

While the continuous syncer has explicit signature verification: [4](#0-3) 

The bootstrapper lacks equivalent verification when resuming from metadata storage. The signature verification method exists in `LedgerInfoWithV0`: [5](#0-4) 

But it is never called on the resumed target before use.

## Impact Explanation

**Critical Severity**: This vulnerability could lead to consensus safety violations and state inconsistencies. An attacker who can manipulate the metadata storage (through filesystem access during node downtime or through exploitation of another vulnerability) could inject a malicious `target_ledger_info` with:

1. Invalid signatures that don't form a valid quorum
2. Signatures from validators no longer in the current validator set (after an epoch change)
3. A ledger info pointing to an invalid state root

When the node resumes, it would sync to this invalid target, potentially diverging from the correct chain state. This breaks the "Cryptographic Correctness" invariant requiring that "BLS signatures, VRF, and hash operations must be secure."

## Likelihood Explanation

**Medium-High Likelihood**: The vulnerability triggers automatically when:
1. A node performs state sync and stores a target in metadata
2. The node crashes or restarts before sync completes  
3. Upon restart, the unverified target is loaded and used

While requiring filesystem access reduces likelihood, the automatic nature of the bug and the critical window during node restarts make exploitation feasible. Additionally, if an epoch change occurs between storage and resume, old validator signatures could be replayed.

## Recommendation

Add signature verification when loading a resumed target from metadata storage. The target ledger info's signatures should be verified against the validator set for the epoch indicated in the ledger info:

```rust
// In fetch_missing_state_snapshot_data, after line 522:
if let Some(target) = self.metadata_storage.previous_snapshot_sync_target()? {
    // NEW: Verify the target ledger info signatures
    let target_epoch = target.ledger_info().epoch();
    let epoch_state = self.get_epoch_state_for_epoch(target_epoch)?;
    epoch_state.verify(&target).map_err(|error| {
        Error::VerificationError(format!(
            "Failed to verify resumed target ledger info signatures: {:?}", error
        ))
    })?;
    
    if self.metadata_storage.is_snapshot_sync_complete(&target)? {
        // ... existing logic
    }
}
```

The node should maintain or be able to retrieve historical epoch states to verify ledger infos from past epochs.

## Proof of Concept

**Reproduction Steps:**

1. Start a full node in fast sync mode to sync to a recent ledger version
2. Allow state sync to begin and store the target in metadata (check `STATE_SYNC_DB_NAME` database)
3. Kill the node process during active state sync
4. Manually modify the metadata storage to inject a `target_ledger_info` with invalid signatures or from wrong epoch validators
5. Restart the node
6. Observe that the node resumes state sync using the manipulated target without signature verification errors
7. The node will attempt to sync to an invalid state, potentially causing consensus divergence

**Expected Behavior:** Node should verify signatures on the resumed target and reject invalid ones.

**Actual Behavior:** Node uses the resumed target without signature verification.

This demonstrates that signature verification is not performed on resumed state sync targets from persistent storage, violating the cryptographic correctness invariant.

### Citations

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L520-543)
```rust
        if highest_synced_version == GENESIS_TRANSACTION_VERSION {
            // We're syncing a new node. Check the progress and fetch any missing data
            if let Some(target) = self.metadata_storage.previous_snapshot_sync_target()? {
                if self.metadata_storage.is_snapshot_sync_complete(&target)? {
                    // Fast syncing to the target is complete. Verify that the
                    // highest synced version matches the target.
                    if target.ledger_info().version() == GENESIS_TRANSACTION_VERSION {
                        info!(LogSchema::new(LogEntry::Bootstrapper).message(&format!(
                            "The fast sync to genesis is complete! Target: {:?}",
                            target
                        )));
                        self.bootstrapping_complete().await
                    } else {
                        Err(Error::UnexpectedError(format!(
                            "The snapshot sync for the target was marked as complete but \
                        the highest synced version is genesis! Something has gone wrong! \
                        Target snapshot sync: {:?}",
                            target
                        )))
                    }
                } else {
                    // Continue snapshot syncing to the target
                    self.fetch_missing_state_values(target, true).await
                }
```

**File:** state-sync/state-sync-driver/src/storage_synchronizer.rs (L81-82)
```rust
    /// Note: this assumes that `epoch_change_proofs`, `target_ledger_info`,
    /// and `target_output_with_proof` have already been verified.
```

**File:** state-sync/state-sync-driver/src/metadata_storage.rs (L201-227)
```rust
    fn update_last_persisted_state_value_index(
        &self,
        target_ledger_info: &LedgerInfoWithSignatures,
        last_persisted_state_value_index: u64,
        snapshot_sync_completed: bool,
    ) -> Result<(), Error> {
        // Ensure that if any previous snapshot progress exists, it has the same target
        if let Some(snapshot_progress) = self.get_snapshot_progress()? {
            if target_ledger_info != &snapshot_progress.target_ledger_info {
                return Err(Error::StorageError(format!("Failed to update the last persisted state value index! \
                The given target does not match the previously stored target. Given target: {:?}, stored target: {:?}",
                    target_ledger_info, snapshot_progress.target_ledger_info
                )));
            }
        }

        // Create the key/value pair
        let metadata_key = MetadataKey::StateSnapshotSync;
        let metadata_value = MetadataValue::StateSnapshotSync(StateSnapshotProgress {
            last_persisted_state_value_index,
            snapshot_sync_completed,
            target_ledger_info: target_ledger_info.clone(),
        });

        // Insert the new key/value pair
        self.commit_key_value(metadata_key, metadata_value)
    }
```

**File:** state-sync/state-sync-driver/src/continuous_syncer.rs (L452-466)
```rust
        // Verify the ledger info state and signatures
        if let Err(error) = self
            .get_speculative_stream_state()?
            .verify_ledger_info_with_signatures(ledger_info_with_signatures)
        {
            self.reset_active_stream(Some(NotificationAndFeedback::new(
                notification_id,
                NotificationFeedback::PayloadProofFailed,
            )))
            .await?;
            Err(error)
        } else {
            Ok(())
        }
    }
```

**File:** types/src/ledger_info.rs (L303-308)
```rust
    pub fn verify_signatures(
        &self,
        validator: &ValidatorVerifier,
    ) -> ::std::result::Result<(), VerifyError> {
        validator.verify_multi_signatures(self.ledger_info(), &self.signatures)
    }
```
