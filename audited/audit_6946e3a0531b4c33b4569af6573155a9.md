# Audit Report

## Title
Critical Consensus Race Condition: OrderVote Creation Uses Inconsistent State Compute Results Across Validators

## Summary
A critical race condition exists in the consensus protocol where validators create `OrderVote` messages with different `BlockInfo` data depending on whether block execution has completed when they broadcast their order vote. This prevents vote aggregation and causes liveness failures.

## Finding Description

The vulnerability occurs because blocks are created with dummy execution state that gets updated asynchronously, but order votes are created by reading the **current** state without waiting for execution to complete.

**Vulnerable Flow:**

1. Blocks are created with dummy state using `PipelinedBlock::new_ordered()` which calls `StateComputeResult::new_dummy()`: [1](#0-0) 

2. This dummy state uses `ACCUMULATOR_PLACEHOLDER_HASH` as the root hash: [2](#0-1) 

3. Execution happens asynchronously and updates state via `set_compute_result()`: [3](#0-2) 

4. When a QC forms, `broadcast_order_vote()` immediately calls `create_order_vote()` which reads the block's **current** state: [4](#0-3) 

5. The `order_vote_proposal()` generates `BlockInfo` from the current compute result: [5](#0-4) 

6. `block_info()` uses the current state's root hash and version: [6](#0-5) 

7. The OrderVote's LedgerInfo is created with this BlockInfo: [7](#0-6) 

**Race Condition Impact:**

Order votes are aggregated by LedgerInfo hash in `PendingOrderVotes`: [8](#0-7) 

Since `LedgerInfo` contains `BlockInfo` (which includes `executed_state_id` and `version`), votes with different execution states have different hashes and are stored in separate HashMap entries, preventing aggregation.

**Why This is NOT Intentional:**

Unlike commit votes which explicitly wait for execution to complete: [9](#0-8) 

Order votes have NO such synchronization and read whatever state is currently available.

## Impact Explanation

**Critical Severity - Consensus Safety Violation**

This meets the **Consensus/Safety Violations (Critical)** category from the Aptos bug bounty:

1. **Different validators vote on different state transitions**: Validators creating order votes at different times vote on different `BlockInfo` data (dummy vs. actual execution results) for the same block, violating consensus safety.

2. **Liveness Failure**: If voting power splits between validators with dummy state and actual state, neither group can aggregate the required 2f+1 signatures to form an order certificate, permanently blocking consensus progress.

3. **Non-Deterministic Protocol Behavior**: The outcome depends on network timing rather than deterministic protocol rules, making the system unreliable.

## Likelihood Explanation

**Likelihood: HIGH**

This vulnerability triggers naturally during normal operation:

1. **No attack required**: The race condition is inherent in the pipelined consensus design where order votes can be created before execution completes.

2. **Network timing variability**: Different validators receive votes and form QCs at different times due to normal network latency.

3. **Variable execution duration**: Block execution time is non-deterministic, depending on transaction complexity and system load.

4. **Expected to occur regularly**: Given the asynchronous pipeline design, any block where execution takes longer than QC formation time will trigger this race condition.

## Recommendation

Ensure order votes wait for execution to complete before creation, similar to commit votes. Modify `broadcast_order_vote()` to await the block's `ledger_update_fut` before reading the compute result:

```rust
async fn broadcast_order_vote(&mut self, vote: &Vote, qc: Arc<QuorumCert>) -> anyhow::Result<()> {
    if let Some(proposed_block) = self.block_store.get_block(vote.vote_data().proposed().id()) {
        // Wait for execution to complete
        proposed_block.wait_for_compute_result().await?;
        
        // Now create order vote with actual execution results
        let order_vote = self.create_order_vote(proposed_block.clone(), qc.clone()).await?;
        // ... rest of broadcast logic
    }
    Ok(())
}
```

Alternatively, enforce that all order votes use dummy state consistently by creating `BlockInfo` with placeholder values explicitly, independent of the block's current execution state.

## Proof of Concept

This can be demonstrated by instrumenting the code to log the `executed_state_id` values in order votes. Under normal network conditions with varying execution times, different validators will produce order votes with different `BlockInfo` values (some with `ACCUMULATOR_PLACEHOLDER_HASH`, others with actual state roots), preventing aggregation when voting power splits between the two groups.

### Citations

**File:** consensus/consensus-types/src/pipelined_block.rs (L277-330)
```rust
    pub fn set_compute_result(
        &self,
        state_compute_result: StateComputeResult,
        execution_time: Duration,
    ) {
        let mut to_commit = 0;
        let mut to_retry = 0;
        for txn in state_compute_result.compute_status_for_input_txns() {
            match txn {
                TransactionStatus::Keep(_) => to_commit += 1,
                TransactionStatus::Retry => to_retry += 1,
                _ => {},
            }
        }

        let execution_summary = ExecutionSummary {
            payload_len: self
                .block
                .payload()
                .map_or(0, |payload| payload.len_for_execution()),
            to_commit,
            to_retry,
            execution_time,
            root_hash: state_compute_result.root_hash(),
            gas_used: state_compute_result
                .execution_output
                .block_end_info
                .as_ref()
                .map(|info| info.block_effective_gas_units()),
        };
        *self.state_compute_result.lock() = state_compute_result;

        // We might be retrying execution, so it might have already been set.
        // Because we use this for statistics, it's ok that we drop the newer value.
        if let Some(previous) = self.execution_summary.get() {
            if previous.root_hash == execution_summary.root_hash
                || previous.root_hash == *ACCUMULATOR_PLACEHOLDER_HASH
            {
                warn!(
                    "Skipping re-inserting execution result, from {:?} to {:?}",
                    previous, execution_summary
                );
            } else {
                error!(
                    "Re-inserting execution result with different root hash: from {:?} to {:?}",
                    previous, execution_summary
                );
            }
        } else {
            self.execution_summary
                .set(execution_summary)
                .expect("inserting into empty execution summary");
        }
    }
```

**File:** consensus/consensus-types/src/pipelined_block.rs (L394-398)
```rust
    pub fn new_ordered(block: Block, window: OrderedBlockWindow) -> Self {
        let input_transactions = Vec::new();
        let state_compute_result = StateComputeResult::new_dummy();
        Self::new(block, input_transactions, state_compute_result).with_block_window(window)
    }
```

**File:** consensus/consensus-types/src/pipelined_block.rs (L452-459)
```rust
    pub fn block_info(&self) -> BlockInfo {
        let compute_result = self.compute_result();
        self.block().gen_block_info(
            compute_result.root_hash(),
            compute_result.last_version_or_0(),
            compute_result.epoch_state().clone(),
        )
    }
```

**File:** consensus/consensus-types/src/pipelined_block.rs (L471-473)
```rust
    pub fn order_vote_proposal(&self, quorum_cert: Arc<QuorumCert>) -> OrderVoteProposal {
        OrderVoteProposal::new(self.block.clone(), self.block_info(), quorum_cert)
    }
```

**File:** execution/executor-types/src/state_compute_result.rs (L70-76)
```rust
    /// generate a new dummy state compute result with ACCUMULATOR_PLACEHOLDER_HASH as the root hash.
    /// this function is used in ordering_state_computer as a dummy state compute result,
    /// where the real compute result is generated after ordering_state_computer.commit pushes
    /// the blocks and the finality proof to the execution phase.
    pub fn new_dummy() -> Self {
        Self::new_dummy_with_root_hash(*ACCUMULATOR_PLACEHOLDER_HASH)
    }
```

**File:** consensus/src/round_manager.rs (L1626-1650)
```rust
    async fn create_order_vote(
        &mut self,
        block: Arc<PipelinedBlock>,
        qc: Arc<QuorumCert>,
    ) -> anyhow::Result<OrderVote> {
        let order_vote_proposal = block.order_vote_proposal(qc);
        let order_vote_result = self
            .safety_rules
            .lock()
            .construct_and_sign_order_vote(&order_vote_proposal);
        let order_vote = order_vote_result.context(format!(
            "[RoundManager] SafetyRules Rejected {} for order vote",
            block.block()
        ))?;

        fail_point!("consensus::create_invalid_order_vote", |_| {
            use aptos_crypto::bls12381;
            let faulty_order_vote = OrderVote::new_with_signature(
                order_vote.author(),
                order_vote.ledger_info().clone(),
                bls12381::Signature::dummy_signature(),
            );
            Ok(faulty_order_vote)
        });
        Ok(order_vote)
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L113-114)
```rust
        let ledger_info =
            LedgerInfo::new(order_vote_proposal.block_info().clone(), HashValue::zero());
```

**File:** consensus/src/pending_order_votes.rs (L67-81)
```rust
        // derive data from order vote
        let li_digest = order_vote.ledger_info().hash();

        // obtain the ledger info with signatures associated to the order vote's ledger info
        let (quorum_cert, status) = self.li_digest_to_votes.entry(li_digest).or_insert_with(|| {
            // if the ledger info with signatures doesn't exist yet, create it
            (
                verified_quorum_cert.expect(
                    "Quorum Cert is expected when creating a new entry in pending order votes",
                ),
                OrderVoteStatus::NotEnoughVotes(SignatureAggregator::new(
                    order_vote.ledger_info().clone(),
                )),
            )
        });
```

**File:** consensus/src/pipeline/pipeline_builder.rs (L989-1013)
```rust
        let (compute_result, _, epoch_end_timestamp) = ledger_update_fut.await?;
        let mut consensus_data_hash = select! {
            Ok(_) = order_vote_rx => {
                HashValue::zero()
            }
            Ok(li) = order_proof_fut => {
                li.ledger_info().ledger_info().consensus_data_hash()
            }
            Ok(li) = commit_proof_fut => {
                li.ledger_info().consensus_data_hash()
            }
            else => {
                return Err(anyhow!("all receivers dropped"))?;
            }
        };
        if order_vote_enabled {
            consensus_data_hash = HashValue::zero();
        }
        tracker.start_working();

        let mut block_info = block.gen_block_info(
            compute_result.root_hash(),
            compute_result.last_version_or_0(),
            compute_result.epoch_state().clone(),
        );
```
