# Audit Report

## Title
Chain ID Spoofing Through Genesis File Manipulation Bypasses Identity Information Protection on Mainnet Validators

## Summary
The ConfigOptimizer automatically enables `expose_identity_information` for non-mainnet chains by reading the chain_id from the genesis transaction file. An attacker with filesystem access can replace the genesis file with one containing a testnet chain_id, causing the optimizer to incorrectly enable identity exposure on mainnet validators while the node continues operating normally using the actual mainnet chain_id from the database. [1](#0-0) 

## Finding Description
The vulnerability exists due to a trust mismatch in how chain_id is determined during different phases of node initialization:

**During Config Loading:** [2](#0-1) 

The `get_chain_id()` function extracts the chain_id from the genesis transaction file by deserializing the genesis blob and reading the chain_id from the write set. This chain_id is then used by the ConfigOptimizer. [3](#0-2) 

The ConfigOptimizer checks if the chain_id from the genesis file is mainnet. If not, it automatically enables all inspection endpoints including `expose_identity_information`.

**During Node Runtime:** [4](#0-3) 

The actual chain_id used by the running node is fetched from the database (on-chain resources), not from the genesis file.

**The Attack Path:**

1. Attacker gains filesystem write access to the validator's genesis.blob file
2. Attacker replaces the mainnet genesis.blob with a testnet genesis.blob (containing testnet chain_id)
3. Validator restarts and loads configuration
4. ConfigOptimizer reads the fake testnet chain_id from the modified genesis file
5. ConfigOptimizer enables `expose_identity_information = true` (lines 90-93)
6. Database initialization succeeds because it's already bootstrapped: [5](#0-4) 

When the database already contains data, `maybe_bootstrap()` skips genesis application and returns `Ok(None)` without error.

7. The inspection service starts with identity exposure enabled: [6](#0-5) 

8. The `/identity_information` endpoint now exposes validator peer IDs
9. The node continues operating normally using the real mainnet chain_id from the database

**Critical Gap:** The ConfigSanitizer only checks `expose_configuration`, not `expose_identity_information`: [7](#0-6) 

## Impact Explanation
This vulnerability falls under **High Severity** per the Aptos bug bounty criteria for "Significant protocol violations" because it bypasses the intended security protection that prevents mainnet validators from exposing identity information. While the immediate impact is information disclosure (validator peer IDs), this information could enable:

- Targeted network-level attacks against specific validators
- Eclipse attacks where attackers isolate validators
- More sophisticated attacks using validator network topology information

The peer ID exposure violates the security invariant that mainnet validators should not expose debugging/identity endpoints.

## Likelihood Explanation
**Medium Likelihood** - While this requires filesystem write access, several realistic scenarios make this exploitable:

1. **Misconfigured file permissions**: The genesis.blob file may have overly permissive permissions
2. **Supply chain attacks**: Malicious genesis files could be shipped in deployment packages
3. **Compromised deployment automation**: CI/CD pipelines with write access could be exploited
4. **Container escape vulnerabilities**: In containerized deployments, container escapes could provide filesystem access
5. **Shared hosting environments**: Where multiple services share filesystem access

The attack is persistent (survives until manually corrected) and leaves the node functioning normally, making detection difficult.

## Recommendation
Implement chain_id verification that compares the genesis file chain_id against the database chain_id:

1. **Add runtime verification** in `setup_environment_and_start_node()`:
```rust
// After database initialization (line 704-705)
let db_chain_id = utils::fetch_chain_id(&db_rw)?;
let genesis_chain_id = extract_node_type_and_chain_id(&node_config).1;

if let (Some(genesis_cid), Some(db_cid)) = (genesis_chain_id, Some(db_chain_id)) {
    if genesis_cid != db_cid {
        return Err(anyhow!(
            "Chain ID mismatch! Genesis file contains {:?} but database contains {:?}. \
             This may indicate genesis file tampering.",
            genesis_cid, db_cid
        ));
    }
}
```

2. **Add sanitizer check** for `expose_identity_information` in `InspectionServiceConfig::sanitize()`:
```rust
// In inspection_service_config.rs, lines 54-65
if node_type.is_validator() && chain_id.is_mainnet() {
    if inspection_service_config.expose_configuration {
        return Err(Error::ConfigSanitizerFailed(
            sanitizer_name,
            "Mainnet validators should not expose the node configuration!".to_string(),
        ));
    }
    // ADD THIS CHECK:
    if inspection_service_config.expose_identity_information {
        return Err(Error::ConfigSanitizerFailed(
            sanitizer_name,
            "Mainnet validators should not expose identity information!".to_string(),
        ));
    }
}
```

3. **Add integrity checking**: Implement cryptographic verification of the genesis file against a hardcoded hash or signature for mainnet/testnet deployments.

## Proof of Concept
```rust
// Test demonstrating the vulnerability
#[test]
fn test_chain_id_spoofing_vulnerability() {
    use aptos_types::chain_id::ChainId;
    use tempfile::TempDir;
    
    // Create a mainnet validator config
    let test_dir = TempDir::new().unwrap();
    let mut node_config = NodeConfig::default();
    node_config.base.role = RoleType::Validator;
    
    // Create a TESTNET genesis transaction
    let testnet_genesis = create_genesis_with_chain_id(ChainId::testnet());
    
    // Save it to the genesis file location
    let genesis_path = test_dir.path().join("genesis.blob");
    node_config.execution.genesis_file_location = genesis_path.clone();
    std::fs::write(&genesis_path, bcs::to_bytes(&testnet_genesis).unwrap()).unwrap();
    
    // Load the config (this triggers the optimizer)
    node_config.execution.load_from_path(&RootPath::new_path(test_dir.path())).unwrap();
    
    // Run the optimizer with empty local config
    let local_config = serde_yaml::from_str("{}").unwrap();
    InspectionServiceConfig::optimize(
        &mut node_config,
        &local_config,
        NodeType::Validator,
        Some(ChainId::testnet()), // ConfigOptimizer reads this from the fake genesis
    ).unwrap();
    
    // VULNERABILITY: expose_identity_information is now TRUE
    // even though this should be a mainnet validator
    assert!(node_config.inspection_service.expose_identity_information);
    
    // When the node runs, it would use mainnet chain_id from DB,
    // but inspection service already has identity exposure enabled!
}
```

## Notes
- The vulnerability relies on the separation between config-time chain_id (from genesis file) and runtime chain_id (from database)
- The issue is exacerbated by the lack of sanitizer protection for `expose_identity_information` on mainnet validators
- This could be considered a configuration integrity vulnerability that violates defense-in-depth principles
- While filesystem access is required, the attack surface is broader than it appears due to deployment complexity in production environments

### Citations

**File:** config/src/config/inspection_service_config.rs (L54-65)
```rust
        // Verify that mainnet validators do not expose the configuration
        if let Some(chain_id) = chain_id {
            if node_type.is_validator()
                && chain_id.is_mainnet()
                && inspection_service_config.expose_configuration
            {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "Mainnet validators should not expose the node configuration!".to_string(),
                ));
            }
        }
```

**File:** config/src/config/inspection_service_config.rs (L71-108)
```rust
impl ConfigOptimizer for InspectionServiceConfig {
    fn optimize(
        node_config: &mut NodeConfig,
        local_config_yaml: &Value,
        _node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<bool, Error> {
        let inspection_service_config = &mut node_config.inspection_service;
        let local_inspection_config_yaml = &local_config_yaml["inspection_service"];

        // Enable all endpoints for non-mainnet nodes (to aid debugging)
        let mut modified_config = false;
        if let Some(chain_id) = chain_id {
            if !chain_id.is_mainnet() {
                if local_inspection_config_yaml["expose_configuration"].is_null() {
                    inspection_service_config.expose_configuration = true;
                    modified_config = true;
                }

                if local_inspection_config_yaml["expose_identity_information"].is_null() {
                    inspection_service_config.expose_identity_information = true;
                    modified_config = true;
                }

                if local_inspection_config_yaml["expose_peer_information"].is_null() {
                    inspection_service_config.expose_peer_information = true;
                    modified_config = true;
                }

                if local_inspection_config_yaml["expose_system_information"].is_null() {
                    inspection_service_config.expose_system_information = true;
                    modified_config = true;
                }
            }
        }

        Ok(modified_config)
    }
```

**File:** config/src/config/node_config_loader.rs (L156-198)
```rust
/// Get the chain ID for the node from the genesis transaction.
/// If the chain ID cannot be extracted, an error is returned.
fn get_chain_id(node_config: &NodeConfig) -> Result<ChainId, Error> {
    // TODO: can we make this less hacky?

    // Load the genesis transaction from disk
    let genesis_txn = get_genesis_txn(node_config).ok_or_else(|| {
        Error::InvariantViolation("The genesis transaction was not found!".to_string())
    })?;

    // Extract the chain ID from the genesis transaction
    match genesis_txn {
        Transaction::GenesisTransaction(WriteSetPayload::Direct(change_set)) => {
            let chain_id_state_key = StateKey::on_chain_config::<ChainId>()?;

            // Get the write op from the write set
            let write_set_mut = change_set.clone().write_set().clone().into_mut();
            let write_op = write_set_mut.get(&chain_id_state_key).ok_or_else(|| {
                Error::InvariantViolation(
                    "The genesis transaction does not contain the write op for the chain id!"
                        .into(),
                )
            })?;

            // Extract the chain ID from the write op
            let write_op_bytes = write_op.bytes().ok_or_else(|| Error::InvariantViolation(
                "The genesis transaction does not contain the correct write op for the chain ID!".into(),
            ))?;
            let chain_id = ChainId::deserialize_into_config(write_op_bytes).map_err(|error| {
                Error::InvariantViolation(format!(
                    "Failed to deserialize the chain ID: {:?}",
                    error
                ))
            })?;

            Ok(chain_id)
        },
        _ => Err(Error::InvariantViolation(format!(
            "The genesis transaction has the incorrect type: {:?}!",
            genesis_txn
        ))),
    }
}
```

**File:** aptos-node/src/utils.rs (L41-50)
```rust
/// Fetches the chain ID from on-chain resources
pub fn fetch_chain_id(db: &DbReaderWriter) -> anyhow::Result<ChainId> {
    let db_state_view = db
        .reader
        .latest_state_checkpoint_view()
        .map_err(|err| anyhow!("[aptos-node] failed to create db state view {}", err))?;
    Ok(ChainIdResource::fetch_config(&db_state_view)
        .expect("[aptos-node] missing chain ID resource")
        .chain_id())
}
```

**File:** execution/executor/src/db_bootstrapper/mod.rs (L48-59)
```rust
pub fn maybe_bootstrap<V: VMBlockExecutor>(
    db: &DbReaderWriter,
    genesis_txn: &Transaction,
    waypoint: Waypoint,
) -> Result<Option<LedgerInfoWithSignatures>> {
    let ledger_summary = db.reader.get_pre_committed_ledger_summary()?;
    // if the waypoint is not targeted with the genesis txn, it may be either already bootstrapped, or
    // aiming for state sync to catch up.
    if ledger_summary.version().map_or(0, |v| v + 1) != waypoint.version() {
        info!(waypoint = %waypoint, "Skip genesis txn.");
        return Ok(None);
    }
```

**File:** crates/aptos-inspection-service/src/server/identity_information.rs (L13-26)
```rust
pub fn handle_identity_information_request(node_config: &NodeConfig) -> (StatusCode, Body, String) {
    // Only return identity information if the endpoint is enabled
    let (status_code, body) = if node_config.inspection_service.expose_identity_information {
        let identity_information = get_identity_information(node_config);
        (StatusCode::OK, Body::from(identity_information))
    } else {
        (
            StatusCode::FORBIDDEN,
            Body::from(IDENTITY_INFO_DISABLED_MESSAGE),
        )
    };

    (status_code, body, CONTENT_TYPE_TEXT.into())
}
```
