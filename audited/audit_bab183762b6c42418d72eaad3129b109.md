# Audit Report

## Title
Consensus Configuration Allows Stake-Independent Validator Selection Enabling Sybil Attacks

## Summary
The `weight_by_voting_power` configuration parameter in `ProposerAndVoterConfig` can be set to `false` via governance without any validation, fundamentally breaking the stake-weighted consensus security model. When disabled, all validators receive equal proposer selection probability regardless of stake amount, enabling Sybil attacks where an attacker benefits from splitting stake across multiple minimal-stake validators rather than consolidating into a single validator.

## Finding Description
The Aptos consensus protocol uses leader reputation to select block proposers, with selection probability designed to be proportional to validator stake when `weight_by_voting_power=true` (the default). However, this critical security parameter can be modified through on-chain governance to `false` without any validation or safety checks. [1](#0-0) 

When `weight_by_voting_power=false`, the epoch manager creates a uniform voting power vector where all validators get weight 1, regardless of their actual stake: [2](#0-1) 

This uniform weighting is then used in proposer selection where stake weights are calculated by multiplying reputation weights by voting power: [3](#0-2) 

**Attack Scenario:**
1. Governance proposal sets `weight_by_voting_power=false` (no validation prevents this)
2. Attacker with N × minimum_stake creates N validators each with minimum_stake instead of 1 validator with N × minimum_stake
3. Each validator receives voting_power=1 in proposer selection
4. Attacker's total selection probability = N × (reputation_weight × 1)
5. Honest validator with N × minimum_stake receives selection probability = 1 × (reputation_weight × 1)
6. Attacker gains N× more proposer selections despite identical total stake

This violates the fundamental Proof-of-Stake security property where voting power should be proportional to stake. The minimum stake requirement provides no protection: [4](#0-3) 

The governance configuration update mechanism has no validation for this parameter beyond checking the config is non-empty: [5](#0-4) 

## Impact Explanation
**Severity: HIGH to CRITICAL**

This breaks Critical Invariant #5 ("Governance Integrity: Voting power must be correctly calculated from stake") and enables:

1. **Consensus Centralization**: Attackers can dominate proposer selection by creating many low-stake validators, potentially leading to >50% of blocks being proposed by a single entity despite having minority stake
2. **Sybil Attack Vector**: The cost of attack becomes proportional to validator count × minimum_stake rather than total stake required for equivalent influence
3. **MEV Extraction Amplification**: Disproportionate proposer selection enables higher MEV extraction than stake would justify
4. **Liveness Risk**: If attacker validators are poorly operated, network liveness degrades disproportionately to their actual stake

While the voting_power_increase_limit (50% per epoch) rate-limits the attack, it only delays rather than prevents exploitation over multiple epochs. With MAX_VALIDATOR_SET_SIZE of 65,536, an attacker could gradually build a dominant validator set. [6](#0-5) 

This qualifies as either:
- **Critical**: "Consensus/Safety violations" if exploitation leads to >33% Byzantine validators
- **High**: "Significant protocol violations" as it fundamentally breaks stake-weighted consensus

## Likelihood Explanation
**Likelihood: MEDIUM**

While requiring governance approval makes this less likely than a direct exploit, several factors increase the risk:

1. **No Validation**: Absence of validation or warnings means governance could set this without understanding security implications
2. **Configuration Flexibility**: The parameter appears designed for flexibility without clear security documentation
3. **Economic Incentive**: Attackers have strong financial incentives to lobby for this change or exploit if accidentally enabled
4. **Gradual Exploitation**: The attack can be executed slowly over multiple epochs, making detection difficult

The default value of `true` provides protection, but governance changes are routine and this could be modified accidentally or through social engineering. [7](#0-6) 

## Recommendation
Implement multiple layers of defense:

1. **Remove Configuration Option**: If equal weighting is never intended for production, remove `weight_by_voting_power` as a configurable parameter and hardcode it to `true`

2. **Add Validation**: If configurability is required, add validation in `consensus_config.move`:

```move
public fun set_for_next_epoch(account: &signer, config: vector<u8>) {
    system_addresses::assert_aptos_framework(account);
    assert!(vector::length(&config) > 0, error::invalid_argument(EINVALID_CONFIG));
    
    // Validate weight_by_voting_power is true
    let parsed_config = deserialize_config(config);
    assert!(weight_by_voting_power_enabled(&parsed_config), 
            error::invalid_argument(EWEIGHT_BY_VOTING_POWER_REQUIRED));
    
    std::config_buffer::upsert<ConsensusConfig>(ConsensusConfig {config});
}
```

3. **Add Warning Documentation**: Document in `ProposerAndVoterConfig` that setting `weight_by_voting_power=false` breaks security guarantees

4. **Governance Alert**: Implement on-chain governance warnings for security-critical parameter changes

## Proof of Concept

```rust
// Rust test demonstrating Sybil attack advantage
#[test]
fn test_sybil_attack_with_equal_weights() {
    let minimum_stake = 1_000_000u64;
    let attacker_total_stake = 100_000_000u64;
    let num_attacker_validators = (attacker_total_stake / minimum_stake) as usize; // 100
    
    // Scenario 1: weight_by_voting_power = true (secure)
    let voting_powers_weighted: Vec<u64> = vec![attacker_total_stake]; // Single validator
    let reputation_weight = 1000u64;
    let stake_weight_weighted = reputation_weight as u128 * attacker_total_stake as u128;
    
    // Scenario 2: weight_by_voting_power = false (vulnerable)
    let voting_powers_equal: Vec<u64> = vec![1; num_attacker_validators]; // 100 validators
    let stake_weights_equal: Vec<u128> = voting_powers_equal
        .iter()
        .map(|vp| reputation_weight as u128 * (*vp as u128))
        .collect();
    let total_stake_weight_equal: u128 = stake_weights_equal.iter().sum();
    
    // With equal weighting, attacker gets 100x more selection probability
    assert_eq!(total_stake_weight_equal, num_attacker_validators as u128 * reputation_weight as u128);
    assert_eq!(total_stake_weight_equal / stake_weight_weighted, num_attacker_validators as u128);
    
    println!("Weighted: {} selection weight", stake_weight_weighted);
    println!("Equal: {} selection weight ({}x advantage)", 
             total_stake_weight_equal, num_attacker_validators);
}
```

## Notes

The vulnerability exists in the lack of validation for a security-critical configuration parameter. While governance is considered trusted, the absence of safeguards means:

1. Accidental misconfiguration is possible
2. Social engineering attacks on governance are feasible  
3. No defense-in-depth protections exist
4. The security implications are not documented in the code

The default configuration is secure (`weight_by_voting_power=true`), but the ability to disable this without validation represents a dangerous governance attack surface that violates secure-by-default principles.

### Citations

**File:** types/src/on_chain_config/consensus_config.rs (L481-505)
```rust
impl Default for ConsensusConfigV1 {
    fn default() -> Self {
        Self {
            decoupled_execution: true,
            back_pressure_limit: 10,
            exclude_round: 40,
            max_failed_authors_to_store: 10,
            proposer_election_type: ProposerElectionType::LeaderReputation(
                LeaderReputationType::ProposerAndVoterV2(ProposerAndVoterConfig {
                    active_weight: 1000,
                    inactive_weight: 10,
                    failed_weight: 1,
                    failure_threshold_percent: 10, // = 10%
                    // In each round we get stastics for the single proposer
                    // and large number of validators. So the window for
                    // the proposers needs to be significantly larger
                    // to have enough useful statistics.
                    proposer_window_num_validators_multiplier: 10,
                    voter_window_num_validators_multiplier: 1,
                    weight_by_voting_power: true,
                    use_history_from_previous_epoch_max_count: 5,
                }),
            ),
        }
    }
```

**File:** types/src/on_chain_config/consensus_config.rs (L552-575)
```rust
#[derive(Clone, Copy, Debug, Deserialize, Eq, PartialEq, Serialize)]
pub struct ProposerAndVoterConfig {
    // Selection weight for active validators with proposer failures below threshold
    pub active_weight: u64,
    // Selection weight for inactive validators with proposer failures below threshold
    pub inactive_weight: u64,
    // Selection weight for validators with proposer failures above threshold
    pub failed_weight: u64,
    // Thresholed of failures in the rounds validator was selected to be proposer
    // integer values representing percentages, i.e. 12 is 12%.
    pub failure_threshold_percent: u32,
    // Window into history considered for proposer statistics, multiplier
    // on top of number of validators
    pub proposer_window_num_validators_multiplier: usize,
    // Window into history considered for votre statistics, multiplier
    // on top of number of validators
    pub voter_window_num_validators_multiplier: usize,
    // Flag whether to use voting power as multiplier to the weights
    pub weight_by_voting_power: bool,
    // Flag whether to use history from previous epoch (0 if not),
    // representing a number of historical epochs (beyond the current one)
    // to consider.
    pub use_history_from_previous_epoch_max_count: u32,
}
```

**File:** consensus/src/epoch_manager.rs (L347-359)
```rust
                let voting_powers: Vec<_> = if weight_by_voting_power {
                    proposers
                        .iter()
                        .map(|p| {
                            epoch_state
                                .verifier
                                .get_voting_power(p)
                                .expect("INVARIANT VIOLATION: proposer not in verifier set")
                        })
                        .collect()
                } else {
                    vec![1; proposers.len()]
                };
```

**File:** consensus/src/liveness/leader_reputation.rs (L710-715)
```rust
        // Multiply weights by voting power:
        let stake_weights: Vec<u128> = weights
            .iter_mut()
            .enumerate()
            .map(|(i, w)| *w as u128 * self.voting_powers[i] as u128)
            .collect();
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L98-100)
```text
    /// Limit the maximum size to u16::max, it's the current limit of the bitvec
    /// https://github.com/aptos-labs/aptos-core/blob/main/crates/aptos-bitvec/src/lib.rs#L20
    const MAX_VALIDATOR_SET_SIZE: u64 = 65536;
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1072-1076)
```text
        let config = staking_config::get();
        let (minimum_stake, maximum_stake) = staking_config::get_required_stake(&config);
        let voting_power = get_next_epoch_voting_power(stake_pool);
        assert!(voting_power >= minimum_stake, error::invalid_argument(ESTAKE_TOO_LOW));
        assert!(voting_power <= maximum_stake, error::invalid_argument(ESTAKE_TOO_HIGH));
```

**File:** aptos-move/framework/aptos-framework/sources/configs/consensus_config.move (L52-56)
```text
    public fun set_for_next_epoch(account: &signer, config: vector<u8>) {
        system_addresses::assert_aptos_framework(account);
        assert!(vector::length(&config) > 0, error::invalid_argument(EINVALID_CONFIG));
        std::config_buffer::upsert<ConsensusConfig>(ConsensusConfig {config});
    }
```
