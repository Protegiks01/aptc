# Audit Report

## Title
Unmetered Control Flow Verification Enables Validator DoS via Complex CFG Modules

## Summary
The Move bytecode verifier's control flow verification pass does not implement gas metering despite accepting a meter parameter, allowing attackers to submit module publishing transactions with maximally complex control flow graphs (up to 1024 basic blocks) that consume excessive CPU time during unmetered graph traversal operations, causing validator node slowdowns.

## Finding Description
The vulnerability exists in the control flow verification pass invoked during module publishing. When a validator processes a module publishing transaction, the bytecode must be verified before acceptance. This verification includes control flow analysis performed by `verify_function()`. [1](#0-0) 

The meter parameter is explicitly marked as unused with a TODO comment, meaning no metering units are charged during the CPU-intensive operations that follow.

The verification performs TWO unmetered graph traversals:

**First traversal** - CFG construction when creating the FunctionView: [2](#0-1) 

**Second traversal** - Loop analysis in verify_reducibility: [3](#0-2) 

The `verify_reducibility()` function performs Tarjan's reducibility algorithm with nested graph traversal operations. It creates a LoopSummary via depth-first search, then iterates through all nodes processing loop bodies: [4](#0-3) 

The critical issue is that `max_basic_blocks` limit is enforced AFTER this unmetered work completes: [5](#0-4) 

The production configuration sets metering limits, but they are not enforced during control flow verification: [6](#0-5) 

This verification occurs in the critical transaction processing path: [7](#0-6) 

**Attack Path**:
1. Attacker crafts a Move module with complex control flow (1024 basic blocks, 5 loop depth, many edges)
2. Submits module publishing transaction to network
3. Transaction enters mempool and is included in a block proposal
4. All validators execute the transaction during block execution
5. Each validator performs unmetered CFG construction and loop analysis
6. CPU time is consumed without metering enforcement
7. Validators experience slowdowns processing the block
8. Attacker can repeatedly submit such transactions to sustain the attack

## Impact Explanation
**Severity: High** (up to $50,000 per Aptos Bug Bounty)

This vulnerability meets the High severity criterion of "Validator node slowdowns". The impact includes:

- **Consensus Degradation**: All validators processing blocks with malicious module publishing transactions experience CPU slowdowns during unmetered verification work
- **Resource Exhaustion**: With 1024 basic blocks and complex control flow, the O(V + E) graph traversals can consume significant CPU cycles
- **Amplification**: Every validator in the network processes the same transaction, amplifying the impact
- **Sustained Attack**: Attacker can submit multiple transactions or modules with multiple functions to extend the attack duration
- **Breaks Invariant #9**: "Resource Limits: All operations must respect gas, storage, and computational limits" - the metering bypass violates this invariant

While not critical severity (no funds loss or consensus safety violation), this represents a significant protocol violation enabling targeted validator DoS attacks.

## Likelihood Explanation
**Likelihood: High**

The attack is highly feasible:

- **Low Barrier**: Any account with sufficient gas can submit module publishing transactions
- **No Special Access**: Does not require validator privileges or insider access
- **Deterministic**: The unmetered work reliably occurs for crafted modules
- **Within Limits**: Attacker stays within configured limits (1024 blocks, 5 loop depth) that are only checked after the unmetered work
- **Easy to Craft**: Generating Move bytecode with complex but valid control flow is straightforward using compiler or manual bytecode construction

The TODO comment indicates this was a known limitation but remained unaddressed, increasing likelihood of oversight.

## Recommendation
Implement metering in the control flow verification pass by charging units proportional to the work performed:

```rust
pub fn verify_function<'a>(
    verifier_config: &'a VerifierConfig,
    module: &'a CompiledModule,
    index: FunctionDefinitionIndex,
    function_definition: &'a FunctionDefinition,
    code: &'a CodeUnit,
    meter: &mut impl Meter,  // Remove underscore, use the meter
) -> PartialVMResult<FunctionView<'a>> {
    let function_handle = module.function_handle_at(function_definition.function);

    if module.version() <= 5 {
        control_flow_v5::verify(verifier_config, Some(index), code)?;
        Ok(FunctionView::function(module, index, code, function_handle))
    } else {
        verify_fallthrough(Some(index), code)?;
        
        // Charge for CFG construction based on bytecode size
        meter.add(Scope::Function, code.code.len() as u128)?;
        
        let function_view = FunctionView::function(module, index, code, function_handle);
        
        // Charge for reducibility verification based on CFG complexity
        let num_blocks = function_view.cfg().num_blocks() as u128;
        let num_edges = function_view.cfg().blocks()
            .iter()
            .map(|b| function_view.cfg().successors(*b).len())
            .sum::<usize>() as u128;
        meter.add(Scope::Function, num_blocks * 10 + num_edges * 5)?;
        
        verify_reducibility(verifier_config, &function_view)?;
        Ok(function_view)
    }
}
```

Alternatively, enforce basic block limits BEFORE performing the expensive graph operations by checking `code.code.len()` against bytecode instruction limits upfront.

## Proof of Concept
```rust
// Create a Move module with maximum complexity within limits
module 0xCAFE::ComplexCFG {
    public fun attack() {
        let i = 0;
        // Generate 1024 basic blocks with complex branching
        // Each loop creates multiple blocks with back edges
        loop {
            if (i == 0) { i = 1; }
            else if (i == 1) { i = 2; }
            else if (i == 2) { i = 3; }
            // ... repeat pattern to maximize blocks ...
            else if (i == 1000) { i = 1001; }
            else { break; };
            // Nested loops (up to depth 5)
            loop {
                loop {
                    loop {
                        loop {
                            if (i > 500) { break; };
                            i = i + 1;
                        };
                        if (i > 500) { break; };
                    };
                    if (i > 500) { break; };
                };
                if (i > 500) { break; };
            };
        };
    }
}

// Compile to bytecode and submit via transaction:
// let compiled = compile_module(source);
// let txn = create_publish_module_txn(sender, compiled);
// client.submit_transaction(txn);
// All validators will perform unmetered CFG analysis
```

**Notes**
This vulnerability specifically affects the control flow verification pass. While subsequent verification passes (type safety, reference safety) do implement metering, the unmetered work occurs first and cannot be aborted until limits are hit in later passes. The production configuration's metering limits of `1000 * 80000` units per function are meant to prevent excessive verification work, but the control flow pass bypasses this protection entirely. The max_loop_depth limit of 5 provides some constraint but does not prevent exploitation via maximally complex graphs within that depth bound.

### Citations

**File:** third_party/move/move-bytecode-verifier/src/control_flow.rs (L35-54)
```rust
pub fn verify_function<'a>(
    verifier_config: &'a VerifierConfig,
    module: &'a CompiledModule,
    index: FunctionDefinitionIndex,
    function_definition: &'a FunctionDefinition,
    code: &'a CodeUnit,
    _meter: &mut impl Meter, // TODO: metering
) -> PartialVMResult<FunctionView<'a>> {
    let function_handle = module.function_handle_at(function_definition.function);

    if module.version() <= 5 {
        control_flow_v5::verify(verifier_config, Some(index), code)?;
        Ok(FunctionView::function(module, index, code, function_handle))
    } else {
        verify_fallthrough(Some(index), code)?;
        let function_view = FunctionView::function(module, index, code, function_handle);
        verify_reducibility(verifier_config, &function_view)?;
        Ok(function_view)
    }
}
```

**File:** third_party/move/move-bytecode-verifier/src/control_flow.rs (L117-182)
```rust
fn verify_reducibility<'a>(
    verifier_config: &VerifierConfig,
    function_view: &'a FunctionView<'a>,
) -> PartialVMResult<()> {
    let current_function = function_view.index().unwrap_or(FunctionDefinitionIndex(0));
    let err = move |code: StatusCode, offset: CodeOffset| {
        Err(PartialVMError::new(code).at_code_offset(current_function, offset))
    };

    let summary = LoopSummary::new(function_view.cfg());
    let mut partition = LoopPartition::new(&summary);

    // Iterate through nodes in reverse pre-order so more deeply nested loops (which would appear
    // later in the pre-order) are processed first.
    for head in summary.preorder().rev() {
        // If a node has no back edges, it is not a loop head, so doesn't need to be processed.
        let back = summary.back_edges(head);
        if back.is_empty() {
            continue;
        }

        // Collect the rest of the nodes in `head`'s loop, in `body`.  Start with the nodes that
        // jump back to the head, and grow `body` by repeatedly following predecessor edges until
        // `head` is found again.

        let mut body = BTreeSet::new();
        for node in back {
            let node = partition.containing_loop(*node);

            if node != head {
                body.insert(node);
            }
        }

        let mut frontier: Vec<_> = body.iter().copied().collect();
        while let Some(node) = frontier.pop() {
            for pred in summary.pred_edges(node) {
                let pred = partition.containing_loop(*pred);

                // `pred` can eventually jump back to `head`, so is part of its body.  If it is not
                // a descendant of `head`, it implies that `head` does not dominate a node in its
                // loop, therefore the CFG is not reducible, according to Property 1 (see doc
                // comment).
                if !summary.is_descendant(/* ancestor */ head, /* descendant */ pred) {
                    return err(StatusCode::INVALID_LOOP_SPLIT, summary.block(pred));
                }

                let body_extended = pred != head && body.insert(pred);
                if body_extended {
                    frontier.push(pred);
                }
            }
        }

        // Collapse all the nodes in `body` into `head`, so it appears as one node when processing
        // outer loops (this performs a sequence of Operation 4(b), followed by a 4(a)).
        let depth = partition.collapse_loop(head, &body);
        if let Some(max_depth) = verifier_config.max_loop_depth {
            if depth as usize > max_depth {
                return err(StatusCode::LOOP_MAX_DEPTH_REACHED, summary.block(head));
            }
        }
    }

    Ok(())
}
```

**File:** third_party/move/move-binary-format/src/binary_views.rs (L436-451)
```rust
    pub fn function(
        module: &'a CompiledModule,
        index: FunctionDefinitionIndex,
        code: &'a CodeUnit,
        function_handle: &'a FunctionHandle,
    ) -> Self {
        Self {
            index: Some(index),
            code,
            parameters: module.signature_at(function_handle.parameters),
            return_: module.signature_at(function_handle.return_),
            locals: module.signature_at(code.locals),
            type_parameters: &function_handle.type_parameters,
            cfg: VMControlFlowGraph::new(&code.code),
        }
    }
```

**File:** third_party/move/move-bytecode-verifier/src/loop_summary.rs (L53-154)
```rust
    pub fn new(cfg: &VMControlFlowGraph) -> Self {
        use Exploration::*;
        use Frontier::*;

        enum Exploration {
            InProgress(NodeId),
            Done(NodeId),
        }

        enum Frontier {
            Visit {
                from_node: NodeId,
                to_block: BlockId,
            },
            Finish {
                block: BlockId,
                node_id: NodeId,
                parent: NodeId,
            },
        }

        let num_blocks = cfg.num_blocks() as usize;

        // Fields in LoopSummary that are filled via a depth-first traversal of `cfg`.
        let mut blocks = vec![0; num_blocks];
        let mut descs = vec![0; num_blocks];
        let mut backs = vec![vec![]; num_blocks];
        let mut preds = vec![vec![]; num_blocks];

        let mut next_node = NodeId(0);

        let root_block = cfg.entry_block_id();
        let root_node = next_node.bump();

        let mut exploration = BTreeMap::new();
        blocks[usize::from(root_node)] = root_block;
        exploration.insert(root_block, InProgress(root_node));

        let mut stack: Vec<Frontier> = cfg
            .successors(root_block)
            .iter()
            .map(|succ| Visit {
                from_node: root_node,
                to_block: *succ,
            })
            .collect();

        while let Some(action) = stack.pop() {
            match action {
                Finish {
                    block,
                    node_id,
                    parent,
                } => {
                    descs[usize::from(parent)] += 1 + descs[usize::from(node_id)];
                    *exploration.get_mut(&block).unwrap() = Done(node_id);
                },

                Visit {
                    from_node,
                    to_block,
                } => match exploration.entry(to_block) {
                    Entry::Occupied(entry) => match entry.get() {
                        // Cyclic back edge detected by re-visiting `to` while still processing its
                        // children.
                        InProgress(to_node) => backs[usize::from(*to_node)].push(from_node),

                        // Cross edge detected by re-visiting `to` after it and its children have
                        // been processed.
                        Done(to_node) => preds[usize::from(*to_node)].push(from_node),
                    },

                    // Visiting `to` for the first time: `from` must be its parent in the depth-
                    // -first spanning tree, and we should continue exploring its successors.
                    Entry::Vacant(entry) => {
                        let to_node = next_node.bump();
                        entry.insert(InProgress(to_node));
                        blocks[usize::from(to_node)] = to_block;
                        preds[usize::from(to_node)].push(from_node);

                        stack.push(Finish {
                            block: to_block,
                            node_id: to_node,
                            parent: from_node,
                        });

                        stack.extend(cfg.successors(to_block).iter().map(|succ| Visit {
                            from_node: to_node,
                            to_block: *succ,
                        }));
                    },
                },
            }
        }

        LoopSummary {
            blocks,
            descs,
            backs,
            preds,
        }
    }
```

**File:** third_party/move/move-bytecode-verifier/src/code_unit_verifier.rs (L137-153)
```rust
        // create `FunctionView` and `BinaryIndexedView`
        let function_view = control_flow::verify_function(
            verifier_config,
            module,
            index,
            function_definition,
            code,
            meter,
        )?;

        if let Some(limit) = verifier_config.max_basic_blocks {
            if function_view.cfg().blocks().len() > limit {
                return Err(
                    PartialVMError::new(StatusCode::TOO_MANY_BASIC_BLOCKS).at_code_offset(index, 0)
                );
            }
        }
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L175-176)
```rust
        max_per_fun_meter_units: Some(1000 * 80000),
        max_per_mod_meter_units: Some(1000 * 80000),
```

**File:** third_party/move/move-vm/runtime/src/storage/environment.rs (L183-201)
```rust
    ) -> VMResult<LocallyVerifiedModule> {
        if !VERIFIED_MODULES_CACHE.contains(module_hash) {
            let _timer =
                VM_TIMER.timer_with_label("move_bytecode_verifier::verify_module_with_config");

            // For regular execution, we cache already verified modules. Note that this even caches
            // verification for the published modules. This should be ok because as long as the
            // hash is the same, the deployed bytecode and any dependencies are the same, and so
            // the cached verification result can be used.
            move_bytecode_verifier::verify_module_with_config(
                &self.vm_config().verifier_config,
                compiled_module.as_ref(),
            )?;
            check_natives(compiled_module.as_ref())?;
            VERIFIED_MODULES_CACHE.put(*module_hash);
        }

        Ok(LocallyVerifiedModule(compiled_module, module_size))
    }
```
