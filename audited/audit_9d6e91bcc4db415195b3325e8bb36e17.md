# Audit Report

## Title
Integer Overflow Panic in `standardize_address()` Enables Denial of Service of Indexer gRPC Service

## Summary
The `standardize_address()` function in the transaction filter utility lacks input length validation, causing a panic when processing addresses longer than 64 hexadecimal characters. This vulnerability can be exploited via the indexer gRPC endpoint to crash the service, resulting in a denial of service for blockchain data indexing and querying capabilities.

## Finding Description
The `standardize_address()` function contains an integer underflow vulnerability that causes a runtime panic when handling addresses longer than 64 characters. [1](#0-0) 

When an attacker sends a gRPC `GetTransactionsRequest` with a transaction filter containing an address field longer than 64 characters (e.g., in `UserTransactionFilter.sender`, `EntryFunctionFilter.address`, or `MoveStructTagFilter.address`), the following execution path occurs:

1. The gRPC endpoint receives the request and calls `parse_transaction_filter()` [2](#0-1) 

2. This invokes `BooleanTransactionFilter::new_from_proto()` which converts the protobuf filter to Rust types [3](#0-2) 

3. During conversion, the `From` trait implementation for `UserTransactionFilter` calls `standardize_address()` on the sender field [4](#0-3) 

4. Similar patterns exist for `EntryFunctionFilter` [5](#0-4)  and `MoveStructTagFilter` [6](#0-5) 

When the address string exceeds 64 characters, the calculation `64 - trimmed.len()` on line 33 of `utils.rs` causes integer underflow in debug mode or wrapping in release mode. In release mode, this produces a very large number that causes an out-of-bounds panic when attempting to slice the `ZEROS` constant (which is only 64 characters long).

**Note on Empty String**: The question mentions empty strings, but empty strings are handled correctly and return `"0x0000000000000000000000000000000000000000000000000000000000000000"` without issues.

## Impact Explanation
This vulnerability enables a **High Severity** denial of service attack against the Aptos indexer gRPC service. Per the Aptos bug bounty criteria, this qualifies as "API crashes" under High Severity (up to $50,000).

While this does not affect consensus safety, transaction execution, or validator operations, it impacts the availability of critical blockchain data querying infrastructure. The indexer gRPC service is used by applications, wallets, and developers to query blockchain state and transaction history. A prolonged outage would disrupt the ecosystem's ability to:
- Query historical transaction data
- Monitor on-chain events
- Build user-facing applications
- Analyze blockchain activity

## Likelihood Explanation
This vulnerability is **highly likely** to be exploited because:

1. **Low attack complexity**: An attacker only needs to send a single malformed gRPC request with an address string exceeding 64 characters
2. **No authentication required**: The gRPC endpoint is publicly accessible
3. **Immediate impact**: The panic occurs during filter parsing, crashing the service instantly
4. **Easily discoverable**: The lack of input validation is evident from code inspection
5. **Repeatable**: The attacker can continuously crash the service by sending requests whenever it restarts

## Recommendation
Implement input length validation before processing the address string. Add a bounds check to ensure the trimmed address does not exceed 64 characters:

```rust
pub fn standardize_address(address: &str) -> Result<String, String> {
    let trimmed = address.strip_prefix("0x").unwrap_or(address);
    
    // Validate address length (Aptos addresses are 32 bytes = 64 hex chars max)
    if trimmed.len() > 64 {
        return Err(format!("Address too long: {} characters (max 64)", trimmed.len()));
    }
    
    // ... rest of function logic
}
```

Additionally, change the `From` implementations to `TryFrom` to properly propagate errors:

```rust
impl TryFrom<aptos_protos::indexer::v1::UserTransactionFilter> for UserTransactionFilter {
    type Error = anyhow::Error;
    
    fn try_from(proto_filter: aptos_protos::indexer::v1::UserTransactionFilter) -> Result<Self> {
        Ok(Self {
            standardized_sender: OnceCell::with_value(
                proto_filter
                    .sender
                    .as_ref()
                    .map(|address| standardize_address(address))
                    .transpose()?,
            ),
            sender: proto_filter.sender,
            payload: proto_filter.payload_filter.map(|f| f.try_into()).transpose()?,
        })
    }
}
```

## Proof of Concept

```rust
#[test]
#[should_panic]
fn test_standardize_address_overflow_panic() {
    use aptos_transaction_filter::utils::standardize_address;
    
    // Create an address longer than 64 characters
    let long_address = "0x".to_string() + &"1".repeat(70);
    
    // This will panic due to integer overflow when calculating slice bounds
    standardize_address(&long_address);
}

#[test]
fn test_empty_address_handling() {
    use aptos_transaction_filter::utils::standardize_address;
    
    // Empty string should be handled correctly
    let result = standardize_address("");
    assert_eq!(result, "0x0000000000000000000000000000000000000000000000000000000000000000");
}
```

To demonstrate the full gRPC attack:

```rust
#[tokio::test]
async fn test_grpc_dos_via_long_address() {
    use aptos_protos::indexer::v1::{
        BooleanTransactionFilter, ApiFilter, UserTransactionFilter,
        boolean_transaction_filter, api_filter,
    };
    
    // Create malicious filter with 70-character address
    let malicious_filter = BooleanTransactionFilter {
        filter: Some(boolean_transaction_filter::Filter::ApiFilter(
            ApiFilter {
                filter: Some(api_filter::Filter::UserTransactionFilter(
                    UserTransactionFilter {
                        sender: Some("1".repeat(70)),
                        payload_filter: None,
                    }
                ))
            }
        ))
    };
    
    // Attempting to parse this filter will panic and crash the service
    let result = aptos_transaction_filter::BooleanTransactionFilter::new_from_proto(
        malicious_filter,
        Some(1024)
    );
    
    // Service crashes before returning an error
}
```

---

**Notes**

This vulnerability affects only the indexer-grpc auxiliary service and does not impact core blockchain consensus, execution, or state management. The empty string case mentioned in the security question is handled correctly and returns the zero address. The actual vulnerability is triggered by addresses **longer** than 64 characters.

### Citations

**File:** ecosystem/indexer-grpc/transaction-filter/src/utils.rs (L10-36)
```rust
pub fn standardize_address(address: &str) -> String {
    // Remove "0x" prefix if it exists
    let trimmed = address.strip_prefix("0x").unwrap_or(address);

    // Check if the address is a special address by seeing if the first 31 bytes are zero and the last byte is smaller than 0b10000
    if let Some(last_char) = trimmed.chars().last() {
        if trimmed[..trimmed.len().saturating_sub(1)]
            .chars()
            .all(|c| c == '0')
            && last_char.is_ascii_hexdigit()
            && last_char <= 'f'
        {
            // Return special addresses in short format
            let mut result = String::with_capacity(3);
            result.push_str("0x");
            result.push(last_char);
            return result;
        }
    }

    // Return non-special addresses in long format
    let mut result = String::with_capacity(66);
    result.push_str("0x");
    result.push_str(&ZEROS[..64 - trimmed.len()]);
    result.push_str(trimmed);
    result
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/localnet_data_service.rs (L64-71)
```rust
        let filter = if let Some(proto_filter) = r.transaction_filter {
            Some(parse_transaction_filter(
                proto_filter,
                self.service_context.max_transaction_filter_size_bytes,
            )?)
        } else {
            None
        };
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/boolean_transaction_filter.rs (L94-127)
```rust
    pub fn new_from_proto(
        proto_filter: aptos_protos::indexer::v1::BooleanTransactionFilter,
        max_filter_size: Option<usize>,
    ) -> Result<Self> {
        if let Some(max_filter_size) = max_filter_size {
            ensure!(
                proto_filter.encoded_len() <= max_filter_size,
                format!(
                    "Filter is too complicated. Max size: {} bytes, Actual size: {} bytes",
                    max_filter_size,
                    proto_filter.encoded_len()
                )
            );
        }
        Ok(
            match proto_filter
                .filter
                .ok_or(anyhow!("Oneof is not set in BooleanTransactionFilter."))?
            {
                aptos_protos::indexer::v1::boolean_transaction_filter::Filter::ApiFilter(
                    api_filter,
                ) => TryInto::<APIFilter>::try_into(api_filter)?.into(),
                aptos_protos::indexer::v1::boolean_transaction_filter::Filter::LogicalAnd(
                    logical_and,
                ) => BooleanTransactionFilter::And(logical_and.try_into()?),
                aptos_protos::indexer::v1::boolean_transaction_filter::Filter::LogicalOr(
                    logical_or,
                ) => BooleanTransactionFilter::Or(logical_or.try_into()?),
                aptos_protos::indexer::v1::boolean_transaction_filter::Filter::LogicalNot(
                    logical_not,
                ) => BooleanTransactionFilter::Not(logical_not.try_into()?),
            },
        )
    }
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/filters/user_transaction.rs (L48-60)
```rust
impl From<aptos_protos::indexer::v1::UserTransactionFilter> for UserTransactionFilter {
    fn from(proto_filter: aptos_protos::indexer::v1::UserTransactionFilter) -> Self {
        Self {
            standardized_sender: OnceCell::with_value(
                proto_filter
                    .sender
                    .as_ref()
                    .map(|address| standardize_address(address)),
            ),
            sender: proto_filter.sender,
            payload: proto_filter.payload_filter.map(|f| f.into()),
        }
    }
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/filters/user_transaction.rs (L155-168)
```rust
impl From<aptos_protos::indexer::v1::EntryFunctionFilter> for EntryFunctionFilter {
    fn from(proto_filter: aptos_protos::indexer::v1::EntryFunctionFilter) -> Self {
        Self {
            standardized_address: OnceCell::with_value(
                proto_filter
                    .address
                    .as_ref()
                    .map(|address| standardize_address(address)),
            ),
            address: proto_filter.address,
            module: proto_filter.module_name,
            function: proto_filter.function,
        }
    }
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/filters/move_module.rs (L48-62)
```rust
impl From<aptos_protos::indexer::v1::MoveStructTagFilter> for MoveStructTagFilter {
    fn from(proto_filter: aptos_protos::indexer::v1::MoveStructTagFilter) -> Self {
        Self {
            standardized_address: OnceCell::with_value(
                proto_filter
                    .address
                    .as_ref()
                    .map(|address| standardize_address(address)),
            ),
            address: proto_filter.address,
            module: proto_filter.module,
            name: proto_filter.name,
        }
    }
}
```
