# Audit Report

## Title
Validator Node Crash During Seed Configuration Migration Due to Inverted Logic in Peer::extend()

## Summary
A logic inversion bug in `Peer::extend()` combined with an unwrapped error in `merge_seeds()` causes validator nodes to panic during startup when the same peer exists in both the deprecated `seed_addrs` and new `seeds` configuration fields with matching roles. This prevents affected validators from starting until manual configuration intervention.

## Finding Description

The vulnerability exists in the seed peer configuration migration path where the legacy `seed_addrs` field is being deprecated in favor of the new `seeds` field. [1](#0-0) 

The `Peer::extend()` method contains inverted logic: it returns an error when roles **DO** match (line 487), but the error message claims "Roles don't match" (line 489). The comment on line 485 even hints at the confusion with "TODO: Instead of rejecting, maybe pick one of the roles?" [2](#0-1) 

When `merge_seeds()` processes configurations, it converts legacy `seed_addrs` entries to `Peer` objects with `PeerRole::ValidatorFullNode` (line 485), then attempts to merge them with existing `seeds` entries using `.unwrap()` on the extend result (line 492).

**Exploitation Path:**
1. Validator operator maintains both `seed_addrs` and `seeds` in their configuration during migration (common cautious practice)
2. Same `peer_id` exists in both configurations 
3. Both entries have matching roles (e.g., `ValidatorFullNode`)
4. During node startup, `merge_seeds()` is called
5. The `extend()` method returns an error because roles match (inverted logic)
6. The `.unwrap()` panics
7. Validator node crashes and cannot start [3](#0-2) 

The `verify_seeds()` validation does not check for duplicate peer IDs across both fields, allowing this scenario to pass validation.

## Impact Explanation

This is a **High Severity** vulnerability per the Aptos bug bounty criteria:

- **Validator node crashes**: Affected nodes panic at startup and cannot participate in consensus
- **Loss of availability**: Nodes remain down until operators manually fix configurations
- **Network partition risk**: During coordinated upgrades, multiple validators hitting this simultaneously could cause network partitions or liveness issues
- **Operational disruption**: Requires immediate manual intervention to restore service

This matches the "Validator node slowdowns" and "API crashes" categories under High Severity ($50,000 tier).

## Likelihood Explanation

**HIGH likelihood during migration period:**

- Migration from `seed_addrs` to `seeds` is an ongoing process (comment explicitly says "TODO: Once fully migrated, remove seed_addrs")
- Operators following best practices for cautious migration will maintain entries in both fields
- Same peer IDs with matching roles is the **expected** migration pattern
- No validation prevents this scenario
- Affects any validator performing config updates during the migration window

The vulnerability is not theoretical - it will reliably trigger during normal operational procedures.

## Recommendation

**Fix 1: Correct the inverted logic in Peer::extend():**

```rust
pub fn extend(&mut self, other: Peer) -> Result<(), Error> {
    if self.role != other.role {  // Changed == to !=
        return Err(Error::InvariantViolation(format!(
            "Roles don't match self {:?} vs other {:?}",
            self.role, other.role
        )));
    }
    self.addresses.extend(other.addresses);
    self.keys.extend(other.keys);
    Ok(())
}
```

**Fix 2: Add duplicate detection in verify_seeds():**

```rust
pub fn verify_seeds(&self) -> Result<(), Error> {
    // ... existing validation ...
    
    // Check for duplicate peer_ids between seed_addrs and seeds
    for peer_id in self.seed_addrs.keys() {
        if self.seeds.contains_key(peer_id) {
            return Err(Error::InvariantViolation(format!(
                "Peer {} exists in both seed_addrs and seeds. Remove from seed_addrs.",
                peer_id.short_str(),
            )));
        }
    }
    Ok(())
}
```

**Fix 3: Handle merge errors gracefully instead of panicking:**

```rust
.and_modify(|seed| {
    if let Err(e) = seed.extend(peer.clone()) {
        warn!("Failed to extend seed for peer {}: {}. Using existing seed configuration.", peer_id, e);
    }
})
```

## Proof of Concept

```rust
#[cfg(test)]
mod test {
    use super::*;
    use aptos_types::PeerId;
    use aptos_crypto::{x25519, Uniform};
    
    #[test]
    #[should_panic(expected = "Roles don't match")]
    fn test_seed_migration_panic() {
        // Create a peer ID and addresses
        let peer_id = PeerId::random();
        let private_key = x25519::PrivateKey::generate_for_testing();
        let public_key = private_key.public_key();
        let addr = NetworkAddress::from_str(&format!(
            "/ip4/127.0.0.1/tcp/6180/noise-ik/{}/handshake/0",
            public_key
        )).unwrap();
        
        // Create NetworkConfig with duplicate peer in both configs
        let mut config = NetworkConfig::default();
        
        // Add to old seed_addrs
        config.seed_addrs.insert(peer_id, vec![addr.clone()]);
        
        // Add to new seeds with same role
        let peer = Peer::from_addrs(PeerRole::ValidatorFullNode, vec![addr]);
        config.seeds.insert(peer_id, peer);
        
        // This will panic when merge_seeds is called
        let _merged = merge_seeds(&config);
    }
}
```

## Notes

The vulnerability demonstrates a critical operational risk during the ongoing migration from `seed_addrs` to `seeds` format. The backwards logic in `Peer::extend()` combined with aggressive error handling via `.unwrap()` creates a denial-of-service condition for validators during routine configuration updates. This affects network availability and could cascade during coordinated upgrade scenarios.

### Citations

**File:** config/src/config/network_config.rs (L319-340)
```rust
    pub fn verify_seeds(&self) -> Result<(), Error> {
        for (peer_id, addrs) in self.seed_addrs.iter() {
            for addr in addrs {
                Self::verify_address(peer_id, addr)?;
            }
        }

        for (peer_id, seed) in self.seeds.iter() {
            for addr in seed.addresses.iter() {
                Self::verify_address(peer_id, addr)?;
            }

            // Require there to be a pubkey somewhere, either in the address (assumed by `is_aptosnet_addr`)
            if seed.keys.is_empty() && seed.addresses.is_empty() {
                return Err(Error::InvariantViolation(format!(
                    "Seed peer {} has no pubkeys",
                    peer_id.short_str(),
                )));
            }
        }
        Ok(())
    }
```

**File:** config/src/config/network_config.rs (L486-496)
```rust
    pub fn extend(&mut self, other: Peer) -> Result<(), Error> {
        if self.role == other.role {
            return Err(Error::InvariantViolation(format!(
                "Roles don't match self {:?} vs other {:?}",
                self.role, other.role
            )));
        }
        self.addresses.extend(other.addresses);
        self.keys.extend(other.keys);
        Ok(())
    }
```

**File:** network/builder/src/builder.rs (L477-494)
```rust
    // Merge old seed configuration with new seed configuration
    // TODO(gnazario): Once fully migrated, remove `seed_addrs`
    config
        .seed_addrs
        .iter()
        .map(|(peer_id, addrs)| {
            (
                peer_id,
                Peer::from_addrs(PeerRole::ValidatorFullNode, addrs.clone()),
            )
        })
        .for_each(|(peer_id, peer)| {
            seeds
                .entry(*peer_id)
                // Sad clone due to Rust not realizing these are two distinct paths
                .and_modify(|seed| seed.extend(peer.clone()).unwrap())
                .or_insert(peer);
        });
```
