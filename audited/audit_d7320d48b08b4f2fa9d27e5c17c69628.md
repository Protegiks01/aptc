# Audit Report

## Title
Move IR Compiler Panic on Version-Incompatible Dependencies with Function Types or Signed Integers

## Summary
The Move IR compiler's `compile_script()` function accepts dependencies without validating their bytecode versions. When dependencies contain VERSION_8+ function types or VERSION_9+ signed integer types in signatures, the compiler panics with `unimplemented!()` during type reindexing, causing a denial-of-service crash during compilation.

## Finding Description

The vulnerability exists in the Move IR compiler's dependency processing logic. When `compile_script()` is invoked with dependencies: [1](#0-0) 

It calls `add_compiled_dependency()` which performs **no bytecode version validation**: [2](#0-1) 

When the script references functions from these dependencies, the compiler must reindex their signatures through `reindex_signature_token()`: [3](#0-2) 

This function explicitly **panics** when encountering:
- **Function types** (VERSION_8+): `unimplemented!("function types not supported by MoveIR")` at lines 773-775
- **Signed integer types** (VERSION_9+): `unimplemented!("signed integer types not supported by MoveIR")` at lines 776-783

The call chain triggering the panic:
1. Script calls dependency function → `compile_bytecode()` at line 1554
2. Resolves function handle → `context.function_handle()`
3. Ensures declaration → `ensure_function_declared()` at line 868
4. Fetches signature → `dep_function_signature()` at line 860  
5. Reindexes types → `reindex_function_signature()` → `reindex_signature_token()`
6. **PANIC** on unsupported type [4](#0-3) 

## Impact Explanation

This is classified as **Low Severity** under Aptos bug bounty criteria ("Non-critical implementation bugs"). 

The Move IR compiler is a **development tool** for compiling legacy IR text format, not a production blockchain component. It is NOT used by:
- Validators during block execution
- The AptosVM runtime
- Transaction processing
- Consensus mechanisms
- State management

The impact is limited to:
- Developers using the IR compiler crashing their build process
- CI/CD pipelines using IR compilation failing
- No effect on deployed contracts, blockchain state, or validator operations

## Likelihood Explanation

**Likelihood: Low**

This requires:
1. A developer using the legacy Move IR compiler (most use the modern Move language compiler)
2. Dependencies compiled with VERSION_8+ (function types) or VERSION_9+ (signed integers)
3. The script actually calling functions from those dependencies with incompatible types

Modern Move development uses the Move language compiler, not the IR compiler. The IR compiler is primarily for testing, debugging, and historical compatibility.

## Recommendation

Add bytecode version validation in `add_compiled_dependency()`:

```rust
pub fn add_compiled_dependency(&mut self, compiled_dep: &'a CompiledModule) -> Result<()> {
    // Validate bytecode version compatibility
    if compiled_dep.version >= VERSION_8 {
        bail!(
            "Module {} uses bytecode version {}, but Move IR compiler only supports up to VERSION_7. \
             Function types (VERSION_8+) and signed integers (VERSION_9+) are not supported.",
            compiled_dep.self_id(),
            compiled_dep.version
        );
    }
    
    let ident = ModuleIdent {
        address: *compiled_dep.address(),
        name: ModuleName(compiled_dep.name().as_str().into()),
    };
    match self.dependencies.get(&ident) {
        None => self
            .dependencies
            .insert(ident, CompiledDependency::borrowed(compiled_dep)?),
        Some(_previous) => bail!("Duplicate dependency module for {}", ident),
    };
    Ok(())
}
```

## Proof of Concept

```rust
// Create a module with signed integers (VERSION_9 feature)
let module_code = r#"
module 0x1::SignedIntModule {
    public fun process_signed(x: i64): i64 {
        x
    }
}
"#;

// Compile with Move compiler to get VERSION_9 bytecode
let compiled_module = compile_move_module(module_code, VERSION_9);

// Attempt to compile IR script using this dependency
let script_ir = r#"
import 0x1.SignedIntModule;
main() {
    let x: i64;
    x = SignedIntModule.process_signed(42i64);
    return;
}
"#;

// This will PANIC with "unimplemented: signed integer types not supported by MoveIR"
let result = Compiler::new(vec![&compiled_module])
    .into_compiled_script_and_source_map(script_ir);

// Expected: Err with clear version incompatibility message
// Actual: PANIC
```

**Note**: This vulnerability does not meet the critical security impact requirements as it only affects a development tool, not the blockchain runtime or consensus.

### Citations

**File:** third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs (L322-398)
```rust
pub fn compile_script<'a>(
    script: Script,
    dependencies: impl IntoIterator<Item = &'a CompiledModule>,
) -> Result<(CompiledScript, SourceMap)> {
    verify_script(&script)?;

    let mut context = Context::new(script.loc, HashMap::new(), None)?;
    for dep in dependencies {
        context.add_compiled_dependency(dep)?;
    }

    compile_imports(&mut context, script.imports.clone())?;
    // Add explicit handles/dependency declarations to `dependencies`
    compile_explicit_dependency_declarations(
        &mut context,
        script.imports,
        script.explicit_dependency_declarations,
    )?;

    for ir_constant in script.constants {
        let constant = compile_constant(&mut context, ir_constant.signature, ir_constant.value)?;
        context.declare_constant(ir_constant.name.clone(), constant.clone())?;
        let const_idx = context.constant_index(constant)?;
        record_src_loc!(const_decl: context, const_idx, ir_constant.name);
    }

    let function = script.main;

    let sig = function_signature(&mut context, &function.value.signature)?;
    let parameters_sig_idx = context.signature_index(Signature(sig.parameters))?;

    record_src_loc!(
        function_decl: context,
        function.loc,
        0,
        matches!(function.value.body, FunctionBody::Native)
    );
    record_src_loc!(
        function_type_formals: context,
        &function.value.signature.type_formals
    );
    let code = compile_function_body_impl(&mut context, function.value)?.unwrap();

    let (
        MaterializedPools {
            module_handles,
            struct_handles,
            function_handles,
            signatures,
            identifiers,
            address_identifiers,
            constant_pool,
            function_instantiations,
            ..
        },
        _compiled_deps,
        source_map,
    ) = context.materialize_pools();
    let script = CompiledScript {
        version: VERSION_DEFAULT,
        module_handles,
        struct_handles,
        function_handles,
        function_instantiations,
        signatures,
        identifiers,
        address_identifiers,
        constant_pool,
        metadata: vec![],

        type_parameters: sig.type_parameters,
        parameters: parameters_sig_idx,
        access_specifiers: None,
        code,
    };
    Ok((script, source_map))
}
```

**File:** third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs (L1550-1568)
```rust
            let ty_arg_tokens =
                compile_types(context, function_frame.type_parameters(), &type_actuals)?;
            let tokens = Signature(ty_arg_tokens);
            let type_actuals_id = context.signature_index(tokens)?;
            let fh_idx = context.function_handle(module, name)?.1;
            let fcall = if type_actuals.is_empty() {
                Bytecode::Call(fh_idx)
            } else {
                let fi_idx = context.function_instantiation_index(fh_idx, type_actuals_id)?;
                Bytecode::CallGeneric(fi_idx)
            };
            push_instr!(call.loc, fcall);
            for _ in 0..type_actuals.len() {
                function_frame.pop()?;
            }
            // Return value of current function is pushed onto the stack.
            function_frame.push()?;
        },
    })
```

**File:** third_party/move/move-ir-compiler/move-ir-to-bytecode/src/context.rs (L323-335)
```rust
    pub fn add_compiled_dependency(&mut self, compiled_dep: &'a CompiledModule) -> Result<()> {
        let ident = ModuleIdent {
            address: *compiled_dep.address(),
            name: ModuleName(compiled_dep.name().as_str().into()),
        };
        match self.dependencies.get(&ident) {
            None => self
                .dependencies
                .insert(ident, CompiledDependency::borrowed(compiled_dep)?),
            Some(_previous) => bail!("Duplicate dependency module for {}", ident),
        };
        Ok(())
    }
```

**File:** third_party/move/move-ir-compiler/move-ir-to-bytecode/src/context.rs (L753-823)
```rust
    fn reindex_signature_token(
        &mut self,
        dep: &ModuleIdent,
        orig: SignatureToken,
    ) -> Result<SignatureToken> {
        Ok(match orig {
            x @ SignatureToken::Bool
            | x @ SignatureToken::U8
            | x @ SignatureToken::U16
            | x @ SignatureToken::U32
            | x @ SignatureToken::U64
            | x @ SignatureToken::U128
            | x @ SignatureToken::U256
            | x @ SignatureToken::Address
            | x @ SignatureToken::Signer
            | x @ SignatureToken::TypeParameter(_) => x,
            SignatureToken::Vector(inner) => {
                let correct_inner = self.reindex_signature_token(dep, *inner)?;
                SignatureToken::Vector(Box::new(correct_inner))
            },
            SignatureToken::Function(..) => {
                unimplemented!("function types not supported by MoveIR")
            },
            SignatureToken::I8
            | SignatureToken::I16
            | SignatureToken::I32
            | SignatureToken::I64
            | SignatureToken::I128
            | SignatureToken::I256 => {
                unimplemented!("signed integer types not supported by MoveIR")
            },
            SignatureToken::Reference(inner) => {
                let correct_inner = self.reindex_signature_token(dep, *inner)?;
                SignatureToken::Reference(Box::new(correct_inner))
            },
            SignatureToken::MutableReference(inner) => {
                let correct_inner = self.reindex_signature_token(dep, *inner)?;
                SignatureToken::MutableReference(Box::new(correct_inner))
            },
            SignatureToken::Struct(orig_sh_idx) => {
                let dep_info = self.dependency(dep)?;
                let (mident, sname) = dep_info
                    .source_struct_info(orig_sh_idx)
                    .ok_or_else(|| format_err!("Malformed dependency"))?;
                let module_name = *self.module_alias(&mident)?;
                let sident = QualifiedStructIdent {
                    module: module_name,
                    name: sname,
                };
                let correct_sh_idx = self.struct_handle_index(sident)?;
                SignatureToken::Struct(correct_sh_idx)
            },
            SignatureToken::StructInstantiation(orig_sh_idx, inners) => {
                let dep_info = self.dependency(dep)?;
                let (mident, sname) = dep_info
                    .source_struct_info(orig_sh_idx)
                    .ok_or_else(|| format_err!("Malformed dependency"))?;
                let module_name = *self.module_alias(&mident)?;
                let sident = QualifiedStructIdent {
                    module: module_name,
                    name: sname,
                };
                let correct_sh_idx = self.struct_handle_index(sident)?;
                let correct_inners = inners
                    .into_iter()
                    .map(|t| self.reindex_signature_token(dep, t))
                    .collect::<Result<_>>()?;
                SignatureToken::StructInstantiation(correct_sh_idx, correct_inners)
            },
        })
    }
```
