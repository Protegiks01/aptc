# Audit Report

## Title
Cyclic Dependency Bypass in Lazy Module Verification Allows Partially Verified Module Graphs

## Summary
When lazy loading is enabled, the Move VM allows cyclic dependencies to bypass verification during module publishing. These modules are cached with the same `Code::Verified` status as eagerly verified modules, but lack transitive verification guarantees including cycle detection. This creates a semantic gap where "verified" modules may contain undetected cycles, violating the acyclic dependency invariant.

## Finding Description

The Move VM's module verification system has two modes controlled by the `ENABLE_LAZY_LOADING` feature flag:
- **Eager verification**: Verifies the full transitive closure of dependencies and detects cycles
- **Lazy verification**: Performs only local verification and immediate dependency linking, explicitly skipping cycle detection

The critical flaw is that both verification modes mark modules with the same `Code::Verified` state, creating no distinction between:
1. Modules verified with full transitive checks (including cycle detection)
2. Modules verified with only local checks (no cycle detection) [1](#0-0) 

During module publishing with lazy loading enabled, the code explicitly skips cyclic dependency checks: [2](#0-1) 

In contrast, eager verification detects cycles during the transitive dependency walk: [3](#0-2) 

When `unmetered_get_eagerly_verified_module` is called on a lazily-verified module, it returns immediately without performing transitive verification: [4](#0-3) 

This violates the documented guarantee that eager verification performs "verification of transitive dependencies": [5](#0-4) 

**Attack Scenario:**
1. Attacker waits for lazy loading to be enabled (default state) or enables it via governance
2. Publishes a module bundle containing cyclic dependencies: A → B → C → A
3. Publishing succeeds because cycle detection is skipped with lazy loading
4. Modules A, B, C are all marked as `Code::Verified` in the module cache
5. Later execution attempts to load these modules for function calls
6. Depending on the loader implementation and execution path:
   - Infinite recursion during dependency resolution
   - Stack overflow from unbounded recursive calls
   - Runtime errors that differ across validators
   - Undefined behavior in cycle handling

## Impact Explanation

This is a **HIGH severity** vulnerability under the Aptos bug bounty "Significant protocol violations" category:

1. **Consensus Determinism Risk**: Different validators may handle cyclic modules differently during execution, leading to state divergence and consensus failures.

2. **VM Safety Violation**: The acyclic dependency invariant is fundamental to the Move VM's type system and execution model. Cyclic dependencies can cause:
   - Stack overflow from unbounded recursion
   - Infinite loops during module resolution
   - Memory exhaustion from circular references

3. **Semantic Contract Breach**: Code calling `unmetered_get_eagerly_verified_module` expects the guarantee documented in the function - that transitive dependencies are verified. This contract is violated when returning lazily-verified modules.

4. **Availability Impact**: Successful exploitation could cause validator nodes to crash or hang when attempting to execute functions from cyclic modules.

## Likelihood Explanation

**MEDIUM-HIGH likelihood:**

1. **Lazy loading is enabled by default**: The `ENABLE_LAZY_LOADING` feature flag is included in default features, making this attack surface immediately available. [6](#0-5) 

2. **Module publishing is permissionless**: Any account can publish Move modules to their address without special privileges.

3. **No runtime protection**: The vulnerability lies in the verification logic itself - there's no additional runtime protection against cyclic modules once they're published.

4. **Exploitation complexity is low**: Creating cyclic dependencies in Move modules is straightforward - just import each other in a cycle.

The main limiting factor is that in practice, most code paths use the `dispatch_loader!` macro which correctly selects the loader based on the flag. However, the semantic gap remains: modules cached as "Verified" may not have been fully verified.

## Recommendation

Implement verification state metadata in the module cache to distinguish between verification levels:

```rust
pub enum VerificationLevel {
    Local,      // Only local bytecode verification
    Eager,      // Full transitive verification with cycle detection
}

pub enum Code<D, V> {
    Deserialized(Arc<D>),
    Verified(Arc<V>, VerificationLevel),  // Track verification level
}
```

Modify `unmetered_get_eagerly_verified_module` to check verification level:

```rust
fn unmetered_get_eagerly_verified_module(
    &self,
    address: &AccountAddress,
    module_name: &IdentStr,
) -> VMResult<Option<Arc<Module>>> {
    let id = ModuleId::new(*address, module_name.to_owned());
    let (module, version) = match self.get_module_or_build_with(&id, self)? {
        Some(module_and_version) => module_and_version,
        None => return Ok(None),
    };

    if let Code::Verified(_, VerificationLevel::Eager) = module.code() {
        return Ok(Some(module.code().verified().clone()));
    }

    // If not eagerly verified, perform full transitive verification
    let mut visited = HashSet::new();
    visited.insert(id.clone());
    Ok(Some(visit_dependencies_and_verify(
        id, module, version, &mut visited, self
    )?))
}
```

Alternatively, enforce cycle detection even with lazy loading by adding a separate cycle detection pass during publishing that doesn't require full transitive verification.

## Proof of Concept

```move
// Module A in bundle
address 0xCAFE {
module A {
    use 0xCAFE::B;
    public fun call_b() {
        B::call_c();
    }
}

// Module B in bundle
module B {
    use 0xCAFE::C;
    public fun call_c() {
        C::call_a();
    }
}

// Module C in bundle (creates cycle)
module C {
    use 0xCAFE::A;
    public fun call_a() {
        A::call_b();  // Cycle: A -> B -> C -> A
    }
}
}
```

**Reproduction steps:**
1. Ensure `ENABLE_LAZY_LOADING` feature flag is enabled
2. Publish the module bundle above using `aptos move publish`
3. Publishing succeeds despite cyclic dependencies
4. Modules are cached as `Code::Verified` without cycle detection
5. Attempt to call `A::call_b()` via a transaction
6. Observe runtime behavior: infinite recursion, stack overflow, or execution error

The vulnerability is confirmed by the explicit comment in the publishing code that cycle detection is skipped with lazy loading, combined with the semantic guarantee violation in `unmetered_get_eagerly_verified_module`.

## Notes

This vulnerability represents a fundamental design issue where the verification state (`Code::Verified`) is ambiguous about which verification guarantees it provides. While current code paths correctly use flag-specific APIs, the semantic contract of "eagerly verified" is broken, and future code changes could inadvertently rely on verification guarantees that don't exist for lazily-verified modules. The explicit bypassing of cycle detection during lazy loading creates a window for protocol-level attacks against the Move VM's safety invariants.

### Citations

**File:** third_party/move/move-vm/types/src/code/cache/types.rs (L48-54)
```rust
/// An entry for the code cache that can have multiple different representations.
pub enum Code<D, V> {
    /// Deserialized code, not yet verified with bytecode verifier.
    Deserialized(Arc<D>),
    /// Fully-verified code.
    Verified(Arc<V>),
}
```

**File:** third_party/move/move-vm/runtime/src/storage/publishing.rs (L259-260)
```rust
                // Linking checks to immediate dependencies. Note that we do not check cyclic
                // dependencies here.
```

**File:** third_party/move/move-vm/runtime/src/storage/module_storage.rs (L105-109)
```rust
    /// Returns the verified module if it exists, or [None] otherwise. The existing module can be
    /// either in a cached state (it is then returned) or newly constructed. The error is returned
    /// if the storage fails to fetch the deserialized module and verify it. The verification is
    /// eager: i.e., it addition to local module verification there are also linking checks and
    /// verification of transitive dependencies.
```

**File:** third_party/move/move-vm/runtime/src/storage/module_storage.rs (L247-249)
```rust
        if module.code().is_verified() {
            return Ok(Some(module.code().verified().clone()));
        }
```

**File:** third_party/move/move-vm/runtime/src/storage/module_storage.rs (L409-415)
```rust
        } else {
            // We must have found a cycle otherwise.
            return Err(module_cyclic_dependency_error!(
                dependency_id.address(),
                dependency_id.name()
            ));
        }
```

**File:** third_party/move/move-vm/runtime/src/config.rs (L38-38)
```rust
    pub enable_lazy_loading: bool,
```
