# Audit Report

## Title
Missing HTTPS Validation in Faucet Configuration Allows Potential Man-in-the-Middle Attacks

## Summary
The `validate_config()` function in the Aptos faucet does not validate that the `node_url` uses HTTPS, allowing operators to accidentally or intentionally configure HTTP URLs. This exposes faucet-to-node communication to man-in-the-middle attacks, potentially leaking API keys and allowing manipulation of node responses.

## Finding Description

The faucet's configuration validation function performs only syntactic YAML parsing without validating the security properties of the `node_url` field. [1](#0-0) 

The `node_url` is defined in `ApiConnectionConfig` with a default HTTPS value, but no enforcement mechanism exists: [2](#0-1) 

This URL is subsequently used to create API clients that communicate with blockchain nodes: [3](#0-2) 

When an HTTP URL is configured, all communication occurs in plaintext, including:
1. **API keys** sent in request headers
2. **Transaction data** being submitted to the node
3. **Account queries** and responses containing balance information
4. **Gas price estimation** requests and responses

An attacker positioned between the faucet and node could:
- **Intercept API keys** sent in plaintext, gaining unauthorized access to the node API
- **Observe transaction patterns** including amounts, recipients, and timing
- **Manipulate node responses** to cause the faucet to behave incorrectly (e.g., falsely reporting transaction success/failure)
- **Cause denial of service** by dropping or corrupting responses

While signed transactions cannot be modified without detection, response manipulation could cause operational issues such as:
- Faucet believing a transaction failed when it succeeded, leading to duplicate funding attempts
- Faucet believing a transaction succeeded when it failed, causing user confusion
- Incorrect sequence number tracking due to manipulated account state responses

## Impact Explanation

This vulnerability falls under **Medium Severity** per the Aptos bug bounty criteria:
- **Limited information exposure**: API keys and transaction metadata can be intercepted
- **State inconsistencies requiring intervention**: Manipulated responses could cause faucet state tracking issues
- **Service degradation**: The faucet service reliability can be compromised through MITM attacks

While this does not directly compromise blockchain consensus or validator operations, it creates a significant security weakness in a user-facing service that handles fund distribution.

## Likelihood Explanation

**Likelihood: Medium to Low**

This vulnerability requires:
1. An operator to explicitly configure an HTTP URL (overriding the HTTPS default)
2. A network position allowing MITM attacks (compromised network, malicious ISP, etc.)

However, the vulnerability is **realistic** because:
- Development/testing environments may use HTTP for convenience
- Misconfigurations can occur during deployment
- Internal networks may use HTTP assuming "security through isolation"
- The lack of validation means such misconfigurations go undetected

The attack complexity is low once the misconfiguration exists - standard MITM tools can intercept HTTP traffic.

## Recommendation

Add URL scheme validation to the `validate_config()` function:

```rust
// In crates/aptos-faucet/core/src/server/validate_config.rs
impl ValidateConfig {
    pub async fn validate_config(&self) -> Result<()> {
        let file = File::open(&self.config_path).with_context(|| {
            format!(
                "Failed to load config at {}",
                self.config_path.to_string_lossy()
            )
        })?;
        let reader = BufReader::new(file);
        let run_config: RunConfig = serde_yaml::from_reader(reader).with_context(|| {
            format!(
                "Failed to parse config at {}",
                self.config_path.to_string_lossy()
            )
        })?;

        // Add HTTPS validation
        let node_url_scheme = run_config.funder_config.get_node_url_scheme();
        if node_url_scheme != "https" {
            anyhow::bail!(
                "node_url must use HTTPS for secure communication, got scheme: {}",
                node_url_scheme
            );
        }

        info!("Config is valid: {:#?}", run_config);
        Ok(())
    }
}
```

Additionally, add a helper method to extract the scheme based on funder type, or validate directly in `ApiConnectionConfig`:

```rust
// In crates/aptos-faucet/core/src/funder/common.rs
impl ApiConnectionConfig {
    pub fn validate_https(&self) -> Result<()> {
        if self.node_url.scheme() != "https" {
            anyhow::bail!(
                "node_url must use HTTPS for secure communication. Got: {}. \
                HTTP URLs expose API keys and transaction data to interception.",
                self.node_url.scheme()
            );
        }
        Ok(())
    }
}
```

Then call this validation in the config building process.

## Proof of Concept

**Demonstrating the vulnerability:**

1. Create a malicious config file with HTTP URL:
```yaml
# malicious_config.yaml
server_config:
  listen_address: "0.0.0.0"
  listen_port: 8081
  api_path_base: ""

funder_config:
  type: mint_funder
  api_connection_config:
    node_url: "http://malicious-node.attacker.com/"  # HTTP instead of HTTPS
    chain_id: 2
  # ... rest of config
```

2. The `validate_config` command accepts this without error:
```bash
cargo run -p aptos-faucet-cli -- validate-config -c malicious_config.yaml
# Expected: ERROR - Config validation failed: node_url must use HTTPS
# Actual: Config is valid (vulnerability confirmed)
```

3. When the faucet runs with this config, all API communication occurs over HTTP:
   - API keys sent in plaintext headers
   - Transaction submissions interceptable
   - Node responses manipulable

**Attack demonstration:**
```bash
# Attacker runs MITM proxy
mitmproxy -p 80 --mode transparent

# Faucet makes request with HTTP node_url
# Attacker intercepts and extracts:
# - API-KEY: <secret_key_in_plaintext>
# - Transaction payloads
# - Can inject fake responses
```

The vulnerability is confirmed by the absence of any scheme validation in the codebase.

### Citations

**File:** crates/aptos-faucet/core/src/server/validate_config.rs (L17-35)
```rust
    pub async fn validate_config(&self) -> Result<()> {
        let file = File::open(&self.config_path).with_context(|| {
            format!(
                "Failed to load config at {}",
                self.config_path.to_string_lossy()
            )
        })?;
        let reader = BufReader::new(file);
        let run_config: RunConfig = serde_yaml::from_reader(reader).with_context(|| {
            format!(
                "Failed to parse config at {}",
                self.config_path.to_string_lossy()
            )
        })?;

        info!("Config is valid: {:#?}", run_config);

        Ok(())
    }
```

**File:** crates/aptos-faucet/core/src/funder/common.rs (L55-75)
```rust
pub struct ApiConnectionConfig {
    /// Aptos node (any node type with an open API) server URL.
    /// Include the port in this if not using the default for the scheme.
    #[clap(long, default_value = "https://fullnode.testnet.aptoslabs.com/")]
    pub node_url: Url,

    /// API key for talking to the node API.
    #[clap(long)]
    pub api_key: Option<String>,

    /// Any additional headers to send with the request. We don't accept this on the
    /// CLI.
    #[clap(skip)]
    pub additional_headers: Option<HashMap<String, String>>,

    /// Chain ID of the network this client is connecting to. For example, for mainnet:
    /// "MAINNET" or 1, testnet: "TESTNET" or 2. If there is no predefined string
    /// alias (e.g. "MAINNET"), just use the number. Note: Chain ID of 0 is not allowed.
    #[clap(long, default_value_t = ChainId::testnet())]
    pub chain_id: ChainId,
}
```

**File:** crates/aptos-faucet/core/src/funder/mint.rs (L339-353)
```rust
    pub fn get_api_client(&self) -> Client {
        let mut builder = Client::builder(AptosBaseUrl::Custom(self.node_url.clone()));

        if let Some(api_key) = self.node_api_key.clone() {
            builder = builder.api_key(&api_key).expect("Failed to set API key");
        }

        if let Some(additional_headers) = &self.node_additional_headers {
            for (key, value) in additional_headers {
                builder = builder.header(key, value).expect("Failed to set header");
            }
        }

        builder.build()
    }
```
