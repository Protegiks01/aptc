# Audit Report

## Title
Mainnet Validator Config Sanitization Bypass via Missing Genesis File Allows Unsafe Configurations

## Summary
A critical vulnerability exists in the node configuration loading process that allows mainnet validators to start with unsafe configurations (including in-memory storage for consensus keys) when the genesis file is missing or misconfigured. The sanitizer bypasses all mainnet-specific security checks when it cannot extract the chain ID from the genesis transaction.

## Finding Description

The vulnerability exists in the configuration loading and sanitization flow. When a validator node starts, it loads its configuration and runs sanitizers to enforce security requirements. However, the sanitizers rely on extracting the `chain_id` from the genesis transaction to determine if mainnet-specific checks should be enforced. [1](#0-0) 

The `extract_node_type_and_chain_id()` function attempts to load the chain ID from the genesis transaction. If this fails (due to missing genesis file, incorrect path, or corrupt genesis data), the error is caught and the function continues with `chain_id = None`: [2](#0-1) 

The `get_chain_id()` function returns an error when the genesis transaction cannot be loaded, which is caught and logged but allows execution to continue.

When the sanitizer runs with `chain_id = None`, all mainnet-specific checks are bypassed. The most critical bypassed check is in `SafetyRulesConfig::sanitize()`: [3](#0-2) 

This check prevents mainnet validators from using `InMemoryStorage` for their SafetyRules backend. However, if `chain_id` is `None`, the entire `if let Some(chain_id) = chain_id` block is skipped, and the dangerous configuration is allowed.

The default `SafetyRulesConfig` uses in-memory storage: [4](#0-3) 

**Attack Scenario:**
1. A mainnet validator operator deploys a node with a valid YAML configuration
2. The genesis.blob file is missing, has incorrect permissions, or the path in the config is wrong
3. The node starts and attempts to load the config
4. `get_genesis_txn()` returns `None` because genesis cannot be loaded
5. `get_chain_id()` fails with an error but execution continues
6. The sanitizer is called with `chain_id = None`
7. All mainnet-specific security checks are bypassed, including the check for in-memory storage
8. If the YAML config doesn't explicitly specify the SafetyRules backend, it defaults to `InMemoryStorage`
9. The validator starts and participates in consensus with consensus keys stored only in memory
10. On node restart, the validator loses its consensus state and keys, potentially causing equivocation

## Impact Explanation

This vulnerability has **CRITICAL** severity impact per the Aptos Bug Bounty criteria for the following reasons:

**Consensus/Safety Violations**: SafetyRules is the core consensus safety component that prevents validators from equivocation (double-signing). It maintains critical state including the last voted round and block. When this state is stored in memory and lost on restart:
- The validator may vote for conflicting blocks in the same round
- This violates BFT consensus safety guarantees
- With multiple affected validators, the network could experience chain splits or safety violations

**Additional Bypassed Checks**: The vulnerability also bypasses other mainnet-specific checks: [5](#0-4) 

While the default values for these are safe, an operator could explicitly disable them in the YAML and the sanitizer wouldn't catch it on mainnet if chain_id is None.

**Non-recoverable Network Impact**: If multiple validators experience this issue simultaneously, the network could require manual intervention or even a hardfork to recover consensus integrity.

## Likelihood Explanation

The likelihood is **MEDIUM to HIGH** because:

1. **Common Misconfiguration**: Missing or misconfigured genesis files are a common operational error during node deployment, especially when:
   - Copying configurations between environments
   - Updating node software versions
   - Deploying via automated infrastructure (Kubernetes, Terraform)
   - File permission issues in containerized deployments

2. **Silent Failure**: The error is logged to stdout but doesn't cause the node to fail startup: [6](#0-5) 
   
   Operators may miss this warning message among other startup logs.

3. **Default Configuration Risk**: The default SafetyRulesConfig uses in-memory storage, so any YAML config that doesn't explicitly specify the backend will use the unsafe default if validation is bypassed.

4. **No Fail-Safe**: There's no secondary validation that catches this condition before the validator starts participating in consensus.

## Recommendation

**Fix 1: Make chain_id extraction mandatory for validators**

Modify the `extract_node_type_and_chain_id()` function to fail hard when genesis cannot be loaded for validator nodes:

```rust
fn extract_node_type_and_chain_id(node_config: &NodeConfig) -> Result<(NodeType, ChainId), Error> {
    let node_type = NodeType::extract_from_config(node_config);
    
    // For validators, chain_id is mandatory
    let chain_id = get_chain_id(node_config)?;
    
    if node_type.is_validator() && chain_id.is_none() {
        return Err(Error::InvariantViolation(
            "Chain ID must be available for validator nodes. Ensure genesis file is properly configured.".to_string()
        ));
    }
    
    Ok((node_type, chain_id))
}
```

**Fix 2: Enforce critical checks even when chain_id is None**

Update the SafetyRulesConfig sanitizer to enforce the in-memory storage check regardless of chain_id for validators:

```rust
impl ConfigSanitizer for SafetyRulesConfig {
    fn sanitize(
        node_config: &NodeConfig,
        node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();
        let safety_rules_config = &node_config.consensus.safety_rules;

        if !node_type.is_validator() {
            return Ok(());
        }

        // CRITICAL: Always check backend for validators, regardless of chain_id
        if safety_rules_config.backend.is_in_memory() {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "The secure backend must not be set to in-memory storage for validators! This would cause loss of consensus state on restart.".to_string(),
            ));
        }

        if let Some(chain_id) = chain_id {
            // Additional mainnet-specific checks...
            if chain_id.is_mainnet() && !safety_rules_config.service.is_local() {
                // existing check
            }
            // ... other checks
        }

        Ok(())
    }
}
```

**Fix 3: Add explicit validation before node startup**

Add a final validation check in the node startup path that ensures critical invariants are met before allowing consensus participation.

## Proof of Concept

```rust
#[cfg(test)]
mod test {
    use super::*;
    use crate::config::{NodeConfig, SafetyRulesConfig, SecureBackend, ConsensusConfig};
    use aptos_temppath::TempPath;
    
    #[test]
    fn test_mainnet_validator_bypass_via_missing_genesis() {
        // Create a validator config with in-memory storage for SafetyRules
        let mut node_config = NodeConfig::get_default_validator_config();
        
        // Set unsafe configuration (in-memory storage)
        node_config.consensus.safety_rules.backend = SecureBackend::InMemoryStorage;
        
        // Set genesis_file_location to a non-existent path
        let temp_path = TempPath::new();
        node_config.execution.genesis_file_location = 
            temp_path.path().join("nonexistent_genesis.blob");
        
        // Try to extract chain_id - this will fail and return None
        let (node_type, chain_id) = extract_node_type_and_chain_id(&node_config);
        
        assert_eq!(node_type, NodeType::Validator);
        assert!(chain_id.is_none(), "chain_id should be None when genesis is missing");
        
        // Run sanitizer with chain_id = None
        // This should fail but currently succeeds, demonstrating the vulnerability
        let result = NodeConfig::sanitize(&node_config, node_type, chain_id);
        
        // VULNERABILITY: This passes when it should fail!
        // On a real mainnet validator, this would allow unsafe in-memory storage
        assert!(result.is_ok(), "Sanitizer bypassed - VULNERABILITY DEMONSTRATED");
        
        // The validator would now start with in-memory consensus keys
        // On restart, it loses all consensus state and may equivocate
    }
    
    #[test]
    fn test_proper_rejection_with_chain_id() {
        let mut node_config = NodeConfig::get_default_validator_config();
        node_config.consensus.safety_rules.backend = SecureBackend::InMemoryStorage;
        
        // With mainnet chain_id, sanitizer should reject in-memory storage
        let result = NodeConfig::sanitize(
            &node_config, 
            NodeType::Validator, 
            Some(ChainId::mainnet())
        );
        
        assert!(result.is_err(), "Should reject in-memory storage for mainnet");
    }
}
```

**Notes**

This vulnerability demonstrates a critical failure in defense-in-depth. While the sanitizers are well-designed to enforce mainnet security requirements, they silently fail when a prerequisite (chain_id extraction) fails. The fix requires either making chain_id mandatory for validators or enforcing critical security checks unconditionally regardless of chain_id availability.

### Citations

**File:** config/src/config/node_config_loader.rs (L112-124)
```rust
fn extract_node_type_and_chain_id(node_config: &NodeConfig) -> (NodeType, Option<ChainId>) {
    // Get the node type from the node config
    let node_type = NodeType::extract_from_config(node_config);

    // Get the chain ID from the genesis transaction
    match get_chain_id(node_config) {
        Ok(chain_id) => (node_type, Some(chain_id)),
        Err(error) => {
            println!("Failed to extract the chain ID from the genesis transaction: {:?}! Continuing with None.", error);
            (node_type, None)
        },
    }
}
```

**File:** config/src/config/node_config_loader.rs (L158-198)
```rust
fn get_chain_id(node_config: &NodeConfig) -> Result<ChainId, Error> {
    // TODO: can we make this less hacky?

    // Load the genesis transaction from disk
    let genesis_txn = get_genesis_txn(node_config).ok_or_else(|| {
        Error::InvariantViolation("The genesis transaction was not found!".to_string())
    })?;

    // Extract the chain ID from the genesis transaction
    match genesis_txn {
        Transaction::GenesisTransaction(WriteSetPayload::Direct(change_set)) => {
            let chain_id_state_key = StateKey::on_chain_config::<ChainId>()?;

            // Get the write op from the write set
            let write_set_mut = change_set.clone().write_set().clone().into_mut();
            let write_op = write_set_mut.get(&chain_id_state_key).ok_or_else(|| {
                Error::InvariantViolation(
                    "The genesis transaction does not contain the write op for the chain id!"
                        .into(),
                )
            })?;

            // Extract the chain ID from the write op
            let write_op_bytes = write_op.bytes().ok_or_else(|| Error::InvariantViolation(
                "The genesis transaction does not contain the correct write op for the chain ID!".into(),
            ))?;
            let chain_id = ChainId::deserialize_into_config(write_op_bytes).map_err(|error| {
                Error::InvariantViolation(format!(
                    "Failed to deserialize the chain ID: {:?}",
                    error
                ))
            })?;

            Ok(chain_id)
        },
        _ => Err(Error::InvariantViolation(format!(
            "The genesis transaction has the incorrect type: {:?}!",
            genesis_txn
        ))),
    }
}
```

**File:** config/src/config/safety_rules_config.rs (L36-48)
```rust
impl Default for SafetyRulesConfig {
    fn default() -> Self {
        Self {
            backend: SecureBackend::InMemoryStorage,
            logger: LoggerConfig::default(),
            service: SafetyRulesService::Local,
            test: None,
            // Default value of 30 seconds for a timeout
            network_timeout_ms: 30_000,
            enable_cached_safety_data: true,
            initial_safety_rules_config: InitialSafetyRulesConfig::None,
        }
    }
```

**File:** config/src/config/safety_rules_config.rs (L85-96)
```rust
        if let Some(chain_id) = chain_id {
            // Verify that the secure backend is appropriate for mainnet validators
            if chain_id.is_mainnet()
                && node_type.is_validator()
                && safety_rules_config.backend.is_in_memory()
            {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "The secure backend should not be set to in memory storage in mainnet!"
                        .to_string(),
                ));
            }
```

**File:** config/src/config/execution_config.rs (L167-183)
```rust
        if let Some(chain_id) = chain_id {
            if chain_id.is_mainnet() {
                if !execution_config.paranoid_hot_potato_verification {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "paranoid_hot_potato_verification must be enabled for mainnet nodes!"
                            .into(),
                    ));
                }
                if !execution_config.paranoid_type_verification {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "paranoid_type_verification must be enabled for mainnet nodes!".into(),
                    ));
                }
            }
        }
```
