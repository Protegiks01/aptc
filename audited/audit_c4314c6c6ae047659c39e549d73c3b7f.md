# Audit Report

## Title
Malicious Full Node Can Cause Client Transaction Expiration Logic to Fail via Timestamp Overflow

## Summary
The REST client's `State::from_headers()` function parses `X_APTOS_LEDGER_TIMESTAMP` without validation, accepting u64::MAX or other extreme values. When this timestamp is used in transaction expiration checks, the arithmetic causes all transactions to be incorrectly rejected as expired, creating a denial-of-service condition for clients connected to malicious full nodes.

## Finding Description
The vulnerability exists in the interaction between two components:

1. **Header Parsing (No Validation)**: [1](#0-0) 

The `from_headers()` function blindly parses the timestamp header as a u64 without any bounds checking or validation. This allows malicious values like u64::MAX (18,446,744,073,709,551,615 microseconds) to be accepted.

2. **Expiration Check (Broken by Overflow)**: [2](#0-1) 

When waiting for transaction confirmation, the code checks if a transaction has expired by dividing the timestamp by 1,000,000 to convert microseconds to seconds. If the timestamp is u64::MAX:
- `u64::MAX / 1_000_000 = 18,446,744,073,709` seconds
- This represents approximately 584 million years from epoch
- Any realistic transaction expiration timestamp (typically current_time + 30-60 seconds) will be far less than this value
- The condition `expiration_timestamp_secs <= state.timestamp_usecs / 1_000_000` will always evaluate to true
- Result: The client incorrectly believes the transaction has expired

**Attack Path:**
1. Attacker operates or compromises a full node
2. Client connects to this malicious full node's REST API
3. When client submits a transaction and waits for confirmation, it polls the transaction status
4. Malicious node returns valid responses but includes `X-Aptos-Ledger-TimestampUsec: 18446744073709551615` in headers
5. Client's `State::from_headers()` accepts this value without validation
6. Client's expiration check incorrectly determines transaction has expired
7. Client returns error to user even if transaction was successfully committed to blockchain

This breaks the **Transaction Validation** invariant - the client's transaction lifecycle tracking becomes unreliable, potentially causing users to believe their transactions failed when they succeeded.

## Impact Explanation
**Medium Severity** - This qualifies as "State inconsistencies requiring intervention" per the bug bounty criteria.

**Direct Impact:**
- Client-side denial of service: Users cannot reliably submit transactions through the malicious full node
- Transaction tracking failure: Committed transactions are incorrectly reported as expired
- Potential double-spend attempts: Users may retry "failed" transactions that were actually committed

**Affected Components:**
- All Aptos REST clients (SDK, CLI tools, wallets) connecting to compromised full nodes
- Does not affect validator consensus or the blockchain itself
- Impact limited to clients, but could affect many users if a popular public full node is compromised

**Why Not Higher Severity:**
- Requires client to connect to malicious full node (attacker-controlled infrastructure)
- Does not affect consensus, validator operations, or blockchain state
- Can be mitigated by connecting to trusted full nodes
- No direct fund loss or consensus violation

## Likelihood Explanation
**Medium Likelihood**

**Factors Increasing Likelihood:**
- Many users connect to public full node endpoints for convenience
- Compromising or operating a malicious full node is feasible for attackers
- No client-side validation exists to detect this attack
- Attack is trivial to execute once attacker controls a full node

**Factors Decreasing Likelihood:**
- Most users connect to well-maintained, trusted full node infrastructure (e.g., official Aptos endpoints)
- Validators and honest full nodes serve correct timestamps
- Attack requires user to specifically connect to attacker's infrastructure

The vulnerability is realistic and exploitable, though impact is limited to clients trusting malicious infrastructure.

## Recommendation
Add timestamp validation in `State::from_headers()` to reject unreasonable values:

```rust
pub fn from_headers(headers: &reqwest::header::HeaderMap) -> anyhow::Result<Self> {
    // ... existing parsing code ...
    
    let maybe_timestamp = headers
        .get(X_APTOS_LEDGER_TIMESTAMP)
        .and_then(|h| h.to_str().ok())
        .and_then(|s| s.parse().ok())
        .and_then(|timestamp_usecs: u64| {
            // Validate timestamp is within reasonable bounds
            // Current time in microseconds should be around 1.7e15
            // Reject timestamps more than 100 years in the future (3.15e15 usecs)
            const MAX_REASONABLE_TIMESTAMP_USECS: u64 = 3_150_000_000_000_000;
            if timestamp_usecs <= MAX_REASONABLE_TIMESTAMP_USECS {
                Some(timestamp_usecs)
            } else {
                None
            }
        });
    
    // ... rest of function ...
}
```

Additionally, consider using saturating arithmetic in the expiration check to prevent unexpected behavior:

```rust
if expiration_timestamp_secs <= state.timestamp_usecs.saturating_div(1_000_000) {
    return Err(anyhow!("Transaction expired...").into());
}
```

## Proof of Concept

```rust
#[cfg(test)]
mod test {
    use super::*;
    use reqwest::header::HeaderMap;
    
    #[test]
    fn test_timestamp_overflow_causes_expiration_failure() {
        // Create headers with u64::MAX timestamp
        let mut headers = HeaderMap::new();
        headers.insert("X-Aptos-Chain-Id", "1".parse().unwrap());
        headers.insert("X-Aptos-Epoch", "100".parse().unwrap());
        headers.insert("X-Aptos-Ledger-Version", "1000000".parse().unwrap());
        headers.insert("X-Aptos-Ledger-TimestampUsec", "18446744073709551615".parse().unwrap()); // u64::MAX
        headers.insert("X-Aptos-Ledger-Oldest-Version", "0".parse().unwrap());
        headers.insert("X-Aptos-Block-Height", "10000".parse().unwrap());
        headers.insert("X-Aptos-Oldest-Block-Height", "0".parse().unwrap());
        
        // Parse state from malicious headers
        let state = State::from_headers(&headers).unwrap();
        
        // Verify the malicious timestamp was accepted
        assert_eq!(state.timestamp_usecs, u64::MAX);
        
        // Simulate expiration check (typical transaction expires 30 seconds from now)
        let current_time_secs = 1700000000u64; // Realistic current time
        let expiration_timestamp_secs = current_time_secs + 30;
        
        // This check will incorrectly indicate expiration
        // because u64::MAX / 1_000_000 = 18446744073709 >> expiration_timestamp_secs
        let timestamp_secs = state.timestamp_usecs / 1_000_000;
        assert!(expiration_timestamp_secs <= timestamp_secs, 
            "Transaction incorrectly marked as expired due to timestamp overflow");
        
        println!("Expiration check: {} <= {} = true (INCORRECT)", 
            expiration_timestamp_secs, timestamp_secs);
        println!("Transaction would be rejected as expired even though it's valid");
    }
}
```

## Notes
The same parsing function is used throughout the REST client, so this vulnerability affects all transaction submission and status checking operations. The issue is particularly concerning because:

1. The error message "Transaction expired. It is guaranteed it will not be committed on chain" is definitive, leading users to believe their transaction definitively failed
2. Users may attempt to resubmit transactions, potentially causing unintended double operations
3. The vulnerability is silent - there's no indication to the user that they're connected to a malicious node

Similar timestamp validation should be added wherever external timestamp values are parsed from network sources.

### Citations

**File:** crates/aptos-rest-client/src/state.rs (L32-35)
```rust
        let maybe_timestamp = headers
            .get(X_APTOS_LEDGER_TIMESTAMP)
            .and_then(|h| h.to_str().ok())
            .and_then(|s| s.parse().ok());
```

**File:** crates/aptos-rest-client/src/lib.rs (L781-783)
```rust
                    if expiration_timestamp_secs <= state.timestamp_usecs / 1_000_000 {
                        return Err(anyhow!("Transaction expired. It is guaranteed it will not be committed on chain.").into());
                    }
```
