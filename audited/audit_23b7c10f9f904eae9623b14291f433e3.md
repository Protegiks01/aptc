# Audit Report

## Title
Insufficient JWT `iat` (Issued-At) Timestamp Validation in Keyless Authentication Allows Bypass of Ephemeral Key Expiration Horizon

## Summary
The keyless authentication system uses the JWT's `iat` (issued-at) claim to validate ephemeral public key (EPK) expiration horizons, but does not validate that `iat` itself is reasonable (i.e., not in the future, within acceptable bounds of current time). This allows an attacker with access to a JWT containing a manipulated `iat` value to bypass the intended security control limiting EPK lifespans.

## Finding Description

The test code in question contains backwards timestamps (exp=now, iat=now+3600), which is indeed incorrect: [1](#0-0) 

However, the production JWT creation code in the telemetry service is correct: [2](#0-1) 

The **actual vulnerability** exists in the keyless authentication system. When validating ephemeral public key expiration dates, the code uses the JWT's `iat` claim without validating its reasonableness: [3](#0-2) 

The vulnerability also exists in the pepper service: [4](#0-3) 

The issue is that neither validation path checks whether `iat` is:
- In the past (not future)
- Within a reasonable tolerance of current time

An attacker who can obtain a JWT with `iat` set far in the future can bypass the `max_exp_horizon_secs` check and create ephemeral keys that remain valid much longer than intended.

## Impact Explanation

**Severity: Medium**

This vulnerability allows bypassing the ephemeral key expiration horizon security control, which could enable:
1. **Extended credential validity**: Attackers can create ephemeral keys that remain valid far longer than the intended `max_exp_horizon_secs` limit
2. **Weakened security posture**: The purpose of `max_exp_horizon_secs` is to limit credential lifetime; bypassing this reduces security

However, exploitation requires:
- A JWT signed by an OIDC provider whose JWK is registered on-chain
- Either: (a) an OIDC provider with significant clock skew, (b) a malicious OIDC provider registered via governance, or (c) abuse of federated keyless with unrestricted JWK registration

This does not directly lead to:
- Funds theft or minting
- Consensus violations
- Network partition or liveness failures

Therefore, it meets **Medium Severity** criteria per Aptos bug bounty guidelines: "State inconsistencies requiring intervention" and "Limited funds loss or manipulation" through extended credential access.

## Likelihood Explanation

**Likelihood: Low to Medium**

The vulnerability exists in production code and the logic flaw is clear, but exploitation faces significant barriers:

1. **OIDC Provider Clock Skew** (Most realistic): If a legitimate registered OIDC provider (Google, Apple, etc.) experiences significant clock skew and sets their system clock years in the future, they would naturally issue JWTs with future `iat` values. Users of that provider could then exploit this. This is unlikely but not impossible.

2. **Malicious OIDC Provider** (Difficult): Requires governance approval to register a malicious provider's JWK on-chain. Aptos governance would likely reject obviously malicious providers.

3. **Federated Keyless Abuse** (Unknown): Depends on restrictions around federated JWK registration, which would require further investigation.

## Recommendation

Add validation to ensure the `iat` claim is reasonable before using it for security decisions:

```rust
// In OpenIdSig::verify_jwt_claims
pub fn verify_jwt_claims(
    &self,
    exp_timestamp_secs: u64,
    epk: &EphemeralPublicKey,
    pk: &KeylessPublicKey,
    config: &Configuration,
) -> anyhow::Result<()> {
    let claims: Claims = serde_json::from_str(&self.jwt_payload_json)?;
    
    // NEW: Validate that iat is in the past and not too old
    let current_time_secs = seconds_from_epoch(
        SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .context("Failed to get current time")?
            .as_secs()
    )?;
    
    let iat_time = seconds_from_epoch(claims.oidc_claims.iat)?;
    
    // iat must be in the past
    ensure!(
        iat_time <= current_time_secs,
        "JWT iat claim is in the future"
    );
    
    // iat must not be too old (e.g., within 1 hour of current time)
    // This prevents using very old JWTs with past iat values
    const MAX_IAT_AGE_SECS: u64 = 3600; // 1 hour
    ensure!(
        current_time_secs.saturating_sub(iat_time.as_secs()) <= MAX_IAT_AGE_SECS,
        "JWT iat claim is too old"
    );
    
    // Continue with existing validation...
    let max_expiration_date = seconds_from_epoch(
        claims.oidc_claims.iat
            .checked_add(config.max_exp_horizon_secs)
            .ok_or_else(|| {
                anyhow::anyhow!("Overflow when adding iat and max_exp_horizon_secs")
            })?,
    )?;
    // ... rest of function
}
```

Apply similar validation in the pepper service's `verify_public_key_expiry_date_secs` function.

## Proof of Concept

**Note:** This PoC is conceptual as it requires external OIDC provider manipulation, which cannot be fully demonstrated within the Aptos codebase alone.

```rust
// Conceptual PoC showing the vulnerability
#[test]
fn test_iat_manipulation_vulnerability() {
    // Assume attacker obtains JWT from OIDC provider with clock set to year 2100
    let malicious_jwt_claims = OidcClaims {
        iss: "https://malicious-or-skewed-provider.com".to_string(),
        aud: "valid_audience".to_string(),
        sub: "user123".to_string(),
        nonce: "valid_nonce".to_string(),
        iat: 4102444800, // Jan 1, 2100 in seconds since epoch
        exp: 4102448400, // 1 hour later
        email: Some("user@example.com".to_string()),
        email_verified: Some(serde_json::Value::Bool(true)),
    };
    
    // Attacker requests EPK with expiration far in future
    let epk_exp_timestamp_secs = 4102444800 + 365 * 24 * 3600; // 1 year from "now"
    
    // With max_exp_horizon_secs = 30 days (2,592,000 seconds)
    let max_exp_horizon_secs = 2_592_000u64;
    
    // Calculate max allowed expiration: iat + max_exp_horizon_secs
    let max_expiration = malicious_jwt_claims.iat + max_exp_horizon_secs;
    // = 4102444800 + 2,592,000 = 4105036800 (30 days from year 2100)
    
    // Attacker's EPK expiration (1 year from 2100) would be:
    // 4102444800 + 31,536,000 = 4133980800
    
    // VULNERABILITY: The check only validates exp < (iat + max_horizon)
    // If current time is 2024, but iat is 2100, the validation passes
    // because it doesn't check that iat itself is reasonable!
    
    // The attacker can create an EPK valid until year 2101
    // even though we're in year 2024!
    assert!(epk_exp_timestamp_secs < max_expiration); // This would PASS incorrectly
}
```

To fully exploit this in practice, an attacker would need to:
1. Identify an OIDC provider registered in Aptos with significant clock skew, OR
2. Register their own malicious provider via governance (unlikely to succeed), OR
3. Exploit federated keyless with unrestricted JWK registration

**Notes:**
- The test code timestamp confusion (exp=now, iat=now+3600) is in test-only code and does not affect production
- The telemetry service production code correctly implements JWT timestamp handling
- The vulnerability is specific to keyless authentication's use of `iat` for security decisions without proper validation
- Best practices for JWT validation (RFC 8725) recommend validating `iat` is not in the future

### Citations

**File:** crates/aptos-telemetry-service/src/types/auth.rs (L47-64)
```rust
impl Claims {
    #[cfg(test)]
    pub(crate) fn test() -> Self {
        use chrono::{Duration, Utc};

        Self {
            chain_id: ChainId::test(),
            peer_id: PeerId::random(),
            node_type: NodeType::Validator,
            epoch: 10,
            exp: Utc::now().timestamp() as usize,
            iat: Utc::now()
                .checked_add_signed(Duration::seconds(3600))
                .unwrap()
                .timestamp() as usize,
            run_uuid: Uuid::default(),
        }
    }
```

**File:** crates/aptos-telemetry-service/src/jwt_auth.rs (L18-42)
```rust
pub fn create_jwt_token(
    jwt_service: &JsonWebTokenService,
    chain_id: ChainId,
    peer_id: PeerId,
    node_type: NodeType,
    epoch: u64,
    uuid: Uuid,
) -> Result<String, Error> {
    let issued = Utc::now().timestamp();
    let expiration = Utc::now()
        .checked_add_signed(chrono::Duration::minutes(60))
        .expect("valid timestamp")
        .timestamp();

    let claims = Claims {
        chain_id,
        peer_id,
        node_type,
        epoch,
        exp: expiration as usize,
        iat: issued as usize,
        run_uuid: uuid,
    };
    jwt_service.encode(claims)
}
```

**File:** types/src/keyless/openid_sig.rs (L64-78)
```rust
        let max_expiration_date = seconds_from_epoch(
            claims
                .oidc_claims
                .iat
                .checked_add(config.max_exp_horizon_secs)
                .ok_or_else(|| {
                    anyhow::anyhow!("Overflow when adding iat and max_exp_horizon_secs")
                })?,
        )?;
        let expiration_date = seconds_from_epoch(exp_timestamp_secs)?;

        ensure!(
            expiration_date < max_expiration_date,
            "The ephemeral public key's expiration date is too far into the future"
        );
```

**File:** keyless/pepper/service/src/dedicated_handlers/pepper_request.rs (L450-461)
```rust
    let (max_exp_date_secs, overflowed) = claims
        .claims
        .iat
        .overflowing_add(keyless_configuration.max_exp_horizon_secs);
    if overflowed {
        return Err(PepperServiceError::BadRequest(
            "The maximum allowed expiry date overflowed".to_string(),
        ));
    }

    // Verify that the expiry date is within the allowed horizon
    if exp_date_secs >= max_exp_date_secs {
```
