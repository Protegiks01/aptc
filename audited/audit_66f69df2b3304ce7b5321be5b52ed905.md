# Audit Report

## Title
Consensus Observer Permanent Liveness Failure Due to Uncleared State Sync Metrics on Error

## Summary
When state synchronization fails in the consensus observer, the `OBSERVER_STATE_SYNC_EXECUTING` gauge metric remains set to 1 permanently, and internal sync handles are not cleared. This causes the consensus observer to enter a permanent stuck state where it believes syncing is still in progress, preventing it from processing any new consensus messages until the node is manually restarted.

## Finding Description

The consensus observer uses two metric labels `STATE_SYNCING_FOR_FALLBACK` and `STATE_SYNCING_TO_COMMIT` with the `OBSERVER_STATE_SYNC_EXECUTING` gauge to track active state sync operations. [1](#0-0) 

When state sync is initiated, both `sync_for_fallback()` and `sync_to_commit()` set this gauge to 1. [2](#0-1) [3](#0-2) 

**The critical bug**: When state sync fails with an error, the code logs the error and returns early without resetting the gauge back to 0. [4](#0-3) [5](#0-4) 

This creates three compounding problems:

1. **Metric stays at 1 forever**: Operators monitoring the gauge see "syncing=1" when no sync is actually running, hiding the failed attempt.

2. **Handle not cleared**: The `fallback_sync_handle` or `sync_to_commit_handle` remains `Some(_)`, so `in_fallback_mode()` and `is_syncing_to_commit()` return true even though the sync task has failed. [6](#0-5) 

3. **Permanent liveness failure**: The `check_progress()` method checks these flags and returns early when they're true, causing the observer to permanently wait for a sync that has already failed. [7](#0-6) 

The consensus observer enters an infinite loop where it periodically checks progress, sees that syncing is "in progress", waits, but never actually makes progress because the sync already failed.

## Impact Explanation

This qualifies as **Medium Severity** under "State inconsistencies requiring intervention":

1. **Permanent liveness failure**: The observer node stops processing all consensus messages and cannot recover without manual restart.

2. **Hidden failures**: Failed state sync attempts are completely hidden from operators because the metric shows syncing is "in progress" when it has actually failed.

3. **State inconsistency**: The node's internal state is inconsistent - the manager believes sync is ongoing, but no sync task is running.

4. **Network-wide observability degradation**: If multiple observer nodes hit this bug, the network's observability infrastructure degrades as nodes silently get stuck.

5. **No automatic recovery**: There is no timeout mechanism or error detection to recover from this state. The only resolution is manual intervention (node restart).

While observer nodes don't participate in consensus (limiting the impact compared to validator nodes), they are critical infrastructure for monitoring, APIs, and network observability. Multiple stuck observer nodes would significantly degrade operational capabilities.

## Likelihood Explanation

**High likelihood** - This can occur naturally through:

1. **Network failures**: Temporary network issues causing `execution_client.sync_for_duration()` or `execution_client.sync_to_target()` to fail.

2. **Database errors**: Storage layer issues preventing successful synchronization.

3. **Resource exhaustion**: Memory or disk issues causing sync operations to fail.

4. **Execution client errors**: Any error from the execution client during sync operations.

No attacker action is required - this is a bug that manifests during normal operational failures, making it highly likely to occur in production environments.

## Recommendation

Add proper error handling to ensure metrics and state are always cleaned up, even on failure paths:

```rust
// In sync_for_fallback()
async move {
    // Set gauge at start
    metrics::set_gauge_with_label(
        &metrics::OBSERVER_STATE_SYNC_EXECUTING,
        metrics::STATE_SYNCING_FOR_FALLBACK,
        1,
    );

    // Ensure cleanup happens regardless of success/failure
    let _cleanup_guard = scopeguard::guard((), |_| {
        metrics::set_gauge_with_label(
            &metrics::OBSERVER_STATE_SYNC_EXECUTING,
            metrics::STATE_SYNCING_FOR_FALLBACK,
            0,
        );
    });

    // Sync logic...
    let latest_synced_ledger_info = match execution_client
        .clone()
        .sync_for_duration(fallback_duration)
        .await
    {
        Ok(ledger_info) => ledger_info,
        Err(error) => {
            error!(LogSchema::new(LogEntry::ConsensusObserver)
                .message(&format!("Failed to sync for fallback! Error: {:?}", error)));
            
            // Send failure notification so StateSyncManager can clear handle
            let _ = sync_notification_sender.send(
                StateSyncNotification::FallbackSyncFailed
            );
            return;
        },
    };

    // Send success notification...
}
```

Apply the same pattern to `sync_to_commit()`. Additionally, add new notification variants for failures and ensure `clear_active_fallback_sync()` and `clear_active_commit_sync()` are called when failure notifications are received.

## Proof of Concept

```rust
#[tokio::test]
async fn test_failed_sync_causes_permanent_stuck_state() {
    use consensus::consensus_observer::observer::state_sync_manager::*;
    use consensus::pipeline::execution_client::*;
    use std::sync::Arc;
    
    // Create a mock execution client that fails
    struct FailingExecutionClient;
    
    #[async_trait]
    impl TExecutionClient for FailingExecutionClient {
        async fn sync_for_duration(&self, _duration: Duration) 
            -> Result<LedgerInfoWithSignatures> {
            Err(anyhow::anyhow!("Sync failed!"))
        }
        
        async fn sync_to_target(&self, _target: LedgerInfoWithSignatures) 
            -> Result<()> {
            Err(anyhow::anyhow!("Sync to target failed!"))
        }
        // ... other required methods
    }
    
    let (state_sync_notification_sender, mut receiver) = 
        tokio::sync::mpsc::unbounded_channel();
    
    let mut state_sync_manager = StateSyncManager::new(
        ConsensusObserverConfig::default(),
        Arc::new(FailingExecutionClient),
        state_sync_notification_sender,
    );
    
    // Trigger fallback sync
    state_sync_manager.sync_for_fallback();
    
    // Verify the handle is set
    assert!(state_sync_manager.in_fallback_mode());
    
    // Wait for the sync task to fail
    tokio::time::sleep(Duration::from_secs(1)).await;
    
    // BUG: No notification is sent on failure
    assert!(receiver.try_recv().is_err());
    
    // BUG: Handle remains set even though sync failed
    assert!(state_sync_manager.in_fallback_mode());
    
    // BUG: Metric remains at 1
    let gauge_value = metrics::OBSERVER_STATE_SYNC_EXECUTING
        .with_label_values(&[metrics::STATE_SYNCING_FOR_FALLBACK])
        .get();
    assert_eq!(gauge_value, 1);
    
    // This demonstrates the observer would be stuck forever
    // waiting for a sync that already failed
}
```

## Notes

This vulnerability directly answers the security question: "Can STATE_SYNCING_FOR_FALLBACK and STATE_SYNCING_TO_COMMIT labels be misused to hide failed state sync attempts?" 

Yes, they are currently **unintentionally** misused because failed attempts leave the gauge at 1, making it appear that syncing is still in progress when it has actually failed. This is not malicious abuse but a critical implementation bug that has the same effect - hiding failures from operators and causing permanent node unavailability.

### Citations

**File:** consensus/src/consensus_observer/common/metrics.rs (L28-29)
```rust
pub const STATE_SYNCING_FOR_FALLBACK: &str = "sync_for_fallback";
pub const STATE_SYNCING_TO_COMMIT: &str = "sync_to_commit";
```

**File:** consensus/src/consensus_observer/observer/state_sync_manager.rs (L101-114)
```rust
    pub fn in_fallback_mode(&self) -> bool {
        self.fallback_sync_handle.is_some()
    }

    /// Returns true iff we are waiting for state sync to synchronize
    /// to a commit decision that will transition us to a new epoch
    pub fn is_syncing_through_epoch(&self) -> bool {
        matches!(self.sync_to_commit_handle, Some((_, true)))
    }

    /// Returns true iff state sync is currently syncing to a commit decision
    pub fn is_syncing_to_commit(&self) -> bool {
        self.sync_to_commit_handle.is_some()
    }
```

**File:** consensus/src/consensus_observer/observer/state_sync_manager.rs (L139-143)
```rust
                metrics::set_gauge_with_label(
                    &metrics::OBSERVER_STATE_SYNC_EXECUTING,
                    metrics::STATE_SYNCING_FOR_FALLBACK,
                    1, // We're syncing for the fallback
                );
```

**File:** consensus/src/consensus_observer/observer/state_sync_manager.rs (L156-160)
```rust
                    Err(error) => {
                        error!(LogSchema::new(LogEntry::ConsensusObserver)
                            .message(&format!("Failed to sync for fallback! Error: {:?}", error)));
                        return;
                    },
```

**File:** consensus/src/consensus_observer/observer/state_sync_manager.rs (L212-216)
```rust
                metrics::set_gauge_with_label(
                    &metrics::OBSERVER_STATE_SYNC_EXECUTING,
                    metrics::STATE_SYNCING_TO_COMMIT,
                    1, // We're syncing to a commit decision
                );
```

**File:** consensus/src/consensus_observer/observer/state_sync_manager.rs (L224-230)
```rust
                    error!(
                        LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                            "Failed to sync to commit decision: {:?}! Error: {:?}",
                            commit_decision, error
                        ))
                    );
                    return;
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L173-188)
```rust
        if self.state_sync_manager.in_fallback_mode() {
            info!(LogSchema::new(LogEntry::ConsensusObserver)
                .message("Waiting for state sync to complete fallback syncing!",));
            return;
        }

        // If state sync is syncing to a commit decision, we should wait for it to complete
        if self.state_sync_manager.is_syncing_to_commit() {
            info!(
                LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                    "Waiting for state sync to reach commit decision: {:?}!",
                    self.observer_block_data.lock().root().commit_info()
                ))
            );
            return;
        }
```
