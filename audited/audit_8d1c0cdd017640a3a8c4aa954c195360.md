# Audit Report

## Title
Type Mismatch in V1 Batch Signature Verification Causing Consensus Disagreement

## Summary
V1 batch signatures are created over `BatchInfo` objects but verified against `BatchInfoExt` objects, causing verification failures when optimistic signature verification is disabled or when validators use pessimistic verification sets. This leads to consensus disagreement between validators with different configuration settings.

## Finding Description

The vulnerability stems from a type mismatch in the signature creation and verification flow for V1 batches in the quorum store consensus mechanism.

**Signature Creation Flow:** [1](#0-0) 

When creating signatures for V1 batches, the code extracts the inner `BatchInfo` struct, signs it directly, then converts the result to `SignedBatchInfo<BatchInfoExt>`. The signature is created over the hash of `BatchInfo`.

**Signature Verification Flow:** [2](#0-1) 

When verifying signatures, the code calls `optimistic_verify` with `&self.info`, which is of type `BatchInfoExt` (not `BatchInfo`).

**Hash Computation Difference:** [3](#0-2) 

The `signing_message` function uses the type's CryptoHasher seed, which differs between `BatchInfo` and `BatchInfoExt`:
- `BatchInfo` derives its own `CryptoHasher` with seed based on "BatchInfo" [4](#0-3) 

- `BatchInfoExt` derives its own `CryptoHasher` with seed based on "BatchInfoExt" [5](#0-4) 

Additionally, the BCS serialization differs (bare struct vs enum with variant tag).

**When Verification Fails:** [6](#0-5) 

With `optimistic_sig_verification=false` or when an author is in the `pessimistic_verify_set`, signatures are immediately verified against the wrong type, causing rejection.

**Network Message Verification:** [7](#0-6) 

Failed verification causes messages to be rejected before reaching the proof coordinator, preventing V1 batches from achieving quorum.

## Impact Explanation

**Severity: High (Consensus Disagreement)**

This vulnerability breaks the **Deterministic Execution** and **Consensus Safety** invariants:

1. **Liveness Failure**: Validators with `optimistic_sig_verification=false` cannot process V1 batches, completely blocking their participation in quorum store consensus.

2. **Consensus Disagreement**: Validators with different configuration settings will disagree on which batch signatures are valid:
   - Validators with optimistic=true accept V1 batches
   - Validators with optimistic=false reject V1 batches
   - This causes network partition and consensus failure

3. **Configuration Dependency**: The consensus protocol's correctness depends on identical configuration across all validators, violating determinism requirements.

The default configuration has `optimistic_sig_verification=true`, but validators can change this setting: [8](#0-7) 

Additionally, the pessimistic verify set can be modified at runtime: [9](#0-8) 

## Likelihood Explanation

**Likelihood: Medium-High**

While the default configuration enables optimistic verification, several realistic scenarios trigger this vulnerability:

1. **Security-Hardened Deployments**: Operators concerned about signature verification attacks might disable optimistic verification for stronger security guarantees
2. **Pessimistic Verify Set**: Validators automatically add authors to the pessimistic set when detecting invalid signatures, which could inadvertently trigger this bug
3. **Configuration Drift**: During upgrades or reconfigurations, validators might temporarily have mismatched settings
4. **Debugging/Testing**: Operators testing signature verification might disable optimistic mode

The vulnerability is deterministic and will always trigger under these conditions.

## Recommendation

**Fix: Verify signatures against the same type they were created with**

For V1 batches, signatures should be verified against `BatchInfo`, not `BatchInfoExt`. Modify the signature verification to extract the inner type:

```rust
// In SignedBatchInfo::verify() for BatchInfoExt
pub fn verify(&self, ...) -> anyhow::Result<()> {
    // ... existing checks ...
    
    // For V1 batches, verify against inner BatchInfo
    if !self.info.is_v2() {
        let inner_info = self.info.info();
        Ok(validator.optimistic_verify(self.signer, inner_info, &self.signature)?)
    } else {
        Ok(validator.optimistic_verify(self.signer, &self.info, &self.signature)?)
    }
}
```

Alternatively, create V1 signatures over `BatchInfoExt::V1` instead of the inner `BatchInfo`:

```rust
// In batch_store.rs persist_inner()
if !batch_info.is_v2() {
    // Sign the full BatchInfoExt::V1, not just the inner BatchInfo
    self.generate_signed_batch_info(batch_info.clone())
        .ok()
} else {
    self.generate_signed_batch_info(batch_info).ok()
}
```

The first approach is preferred as it maintains backward compatibility with existing V1 signatures.

## Proof of Concept

Create a test that demonstrates signature verification failure with optimistic mode disabled:

```rust
#[test]
fn test_v1_batch_signature_verification_with_pessimistic_mode() {
    use aptos_crypto::bls12381;
    use aptos_types::validator_signer::ValidatorSigner;
    use consensus_types::proof_of_store::{BatchInfo, BatchInfoExt, SignedBatchInfo};
    
    // Create V1 batch
    let batch_info = BatchInfo::new(
        PeerId::random(),
        BatchId::new(1),
        0,
        100,
        HashValue::random(),
        10,
        1000,
        0,
    );
    
    // Create signer
    let signer = ValidatorSigner::random([0u8; 32]);
    
    // Sign BatchInfo (as done in batch_store.rs)
    let signed_batch_info_v1 = SignedBatchInfo::new(
        batch_info.clone(),
        &signer
    ).unwrap();
    
    // Convert to BatchInfoExt (as done in batch_store.rs)
    let signed_batch_info_ext: SignedBatchInfo<BatchInfoExt> = 
        signed_batch_info_v1.into();
    
    // Create validator verifier with optimistic=false
    let validator_verifier = ValidatorVerifier::new_single(
        signer.author(),
        signer.public_key()
    );
    validator_verifier.set_optimistic_sig_verification_flag(false);
    
    // Attempt to verify - THIS WILL FAIL
    let result = signed_batch_info_ext.verify(
        signer.author(),
        1000000,
        &validator_verifier
    );
    
    // Verification fails because signature was over BatchInfo
    // but verification is against BatchInfoExt
    assert!(result.is_err(), "V1 batch signature verification should fail with optimistic=false");
}
```

This test will fail verification even though the signature is cryptographically valid, demonstrating the type mismatch vulnerability.

### Citations

**File:** consensus/src/quorum_store/batch_store.rs (L515-521)
```rust
                if !batch_info.is_v2() {
                    self.generate_signed_batch_info(batch_info.info().clone())
                        .ok()
                        .map(|inner| inner.into())
                } else {
                    self.generate_signed_batch_info(batch_info).ok()
                }
```

**File:** consensus/consensus-types/src/proof_of_store.rs (L46-48)
```rust
#[derive(
    Clone, Debug, Deserialize, Serialize, CryptoHasher, BCSCryptoHash, PartialEq, Eq, Hash,
)]
```

**File:** consensus/consensus-types/src/proof_of_store.rs (L192-194)
```rust
#[derive(
    Clone, Debug, Deserialize, Serialize, CryptoHasher, BCSCryptoHash, PartialEq, Eq, Hash,
)]
```

**File:** consensus/consensus-types/src/proof_of_store.rs (L459-482)
```rust
    pub fn verify(
        &self,
        sender: PeerId,
        max_batch_expiry_gap_usecs: u64,
        validator: &ValidatorVerifier,
    ) -> anyhow::Result<()> {
        if sender != self.signer {
            bail!("Sender {} mismatch signer {}", sender, self.signer);
        }

        if self.expiration()
            > aptos_infallible::duration_since_epoch().as_micros() as u64
                + max_batch_expiry_gap_usecs
        {
            bail!(
                "Batch expiration too far in future: {} > {}",
                self.expiration(),
                aptos_infallible::duration_since_epoch().as_micros() as u64
                    + max_batch_expiry_gap_usecs
            );
        }

        Ok(validator.optimistic_verify(self.signer, &self.info, &self.signature)?)
    }
```

**File:** crates/aptos-crypto/src/traits/mod.rs (L170-177)
```rust
pub fn signing_message<T: CryptoHash + Serialize>(
    message: &T,
) -> Result<Vec<u8>, CryptoMaterialError> {
    let mut bytes = <T::Hasher as CryptoHasher>::seed().to_vec();
    bcs::serialize_into(&mut bytes, &message)
        .map_err(|_| CryptoMaterialError::SerializationError)?;
    Ok(bytes)
}
```

**File:** types/src/validator_verifier.rs (L236-242)
```rust
    pub fn set_optimistic_sig_verification_flag(&mut self, flag: bool) {
        self.optimistic_sig_verification = flag;
    }

    pub fn add_pessimistic_verify_set(&self, author: AccountAddress) {
        self.pessimistic_verify_set.insert(author);
    }
```

**File:** types/src/validator_verifier.rs (L269-285)
```rust
    pub fn optimistic_verify<T: Serialize + CryptoHash>(
        &self,
        author: AccountAddress,
        message: &T,
        signature_with_status: &SignatureWithStatus,
    ) -> std::result::Result<(), VerifyError> {
        if self.get_public_key(&author).is_none() {
            return Err(VerifyError::UnknownAuthor);
        }
        if (!self.optimistic_sig_verification || self.pessimistic_verify_set.contains(&author))
            && !signature_with_status.is_verified()
        {
            self.verify(author, message, signature_with_status.signature())?;
            signature_with_status.set_verified();
        }
        Ok(())
    }
```

**File:** consensus/src/round_manager.rs (L184-196)
```rust
            UnverifiedEvent::SignedBatchInfo(sd) => {
                if !self_message {
                    sd.verify(
                        peer_id,
                        max_num_batches,
                        max_batch_expiry_gap_usecs,
                        validator,
                    )?;
                    counters::VERIFY_MSG
                        .with_label_values(&["signed_batch"])
                        .observe(start_time.elapsed().as_secs_f64());
                }
                VerifiedEvent::SignedBatchInfo(Box::new((*sd).into()))
```

**File:** config/src/config/consensus_config.rs (L382-382)
```rust
            optimistic_sig_verification: true,
```
