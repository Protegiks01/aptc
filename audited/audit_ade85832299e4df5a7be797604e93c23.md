# Audit Report

## Title
Out-of-Bounds Array Access in WeightedConfig Due to Unchecked Player ID in Consensus DKG Decryption

## Summary
The `WeightedConfig` struct's methods access internal arrays using `Player.id` without bounds validation. During epoch transitions, if a validator's index in the new epoch exceeds the number of players configured in the DKG session's weighted configuration, calls to `decrypt_secret_share_from_transcript()` trigger out-of-bounds array accesses, causing validator node crashes (DoS) or undefined behavior.

## Finding Description
The `WeightedConfig` struct maintains player weights and share indices in vectors, with the invariant that all player IDs must be `< num_players`. However, several methods accept `&Player` parameters and directly index into these vectors without bounds checking: [1](#0-0) [2](#0-1) 

The `Player` struct has a public `id` field, allowing arbitrary Player instances to be created: [3](#0-2) 

This violates the design intent stated in comments: [4](#0-3) 

During epoch transitions, the consensus layer constructs Player instances using validator indices from the new epoch state without validating they're within the bounds of the DKG session's weighted configuration: [5](#0-4) [6](#0-5) [7](#0-6) 

The `wconfig` was built from the DKG session's target validator set: [8](#0-7) 

While reconfiguration locking should prevent validator set size changes, the code only validates epoch numbers match but not validator set sizes: [9](#0-8) 

If `my_index >= wconfig.num_players` (where `num_players` equals `target_validator_set.len()`), the subsequent call chain triggers out-of-bounds access when `decrypt_own_share()` calls `get_player_weight()`.

## Impact Explanation
**High Severity** - This violates the **Deterministic Execution** invariant. When a validator with an out-of-bounds index attempts to decrypt shares:
- **Debug builds**: Panic crash (instant DoS)
- **Release builds**: Undefined behavior via out-of-bounds memory access, potentially reading arbitrary memory or causing segfaults

Different validators may exhibit different behavior depending on memory layout, breaking consensus determinism. This affects validator node availability and could cause network liveness issues if multiple validators crash simultaneously during epoch transitions.

## Likelihood Explanation
**Medium-to-Low Likelihood** - Exploitation requires a validator set size mismatch between the DKG session configuration and actual epoch validator set. While reconfiguration locking should prevent this, edge cases exist:
- DKG session timeout/retry with changed validator sets
- Validator ordering differences between lists
- Race conditions in epoch transition logic
- Bugs in reconfiguration state management

The vulnerability is latent and depends on specific timing/state conditions during epoch transitions.

## Recommendation
Add bounds checking to all `WeightedConfig` methods that accept `Player` parameters:

```rust
pub fn get_player_weight(&self, player: &Player) -> anyhow::Result<usize> {
    self.weights.get(player.id)
        .copied()
        .ok_or_else(|| anyhow!("Player ID {} out of bounds (num_players: {})", 
                               player.id, self.num_players))
}

pub fn get_virtual_player(&self, player: &Player, j: usize) -> anyhow::Result<Player> {
    let weight = self.weights.get(player.id)
        .ok_or_else(|| anyhow!("Player ID {} out of bounds", player.id))?;
    anyhow::ensure!(j < *weight, "Sub-share index {} out of bounds", j);
    let id = self.get_share_index(player.id, j)?;
    Ok(Player { id })
}
```

Additionally, validate validator set size consistency in `epoch_manager.rs`:

```rust
// After line 1046
ensure!(
    new_epoch_state.verifier.len() == dkg_pub_params.pvss_config.wconfig.get_total_num_players(),
    "Validator set size mismatch: epoch has {} validators but DKG config has {} players",
    new_epoch_state.verifier.len(),
    dkg_pub_params.pvss_config.wconfig.get_total_num_players()
);
```

Make `Player.id` private and provide a safe constructor in the `SecretSharingConfig` trait.

## Proof of Concept
```rust
// This PoC demonstrates the out-of-bounds access
use aptos_crypto::weighted_config::WeightedConfigBlstrs;
use aptos_crypto::player::Player;

fn main() {
    // Create config with 3 players
    let wconfig = WeightedConfigBlstrs::new(2, vec![1, 1, 1]).unwrap();
    
    // Attacker creates player with out-of-bounds ID
    let malicious_player = Player { id: 100 };
    
    // This will panic in debug or cause UB in release
    let _weight = wconfig.get_player_weight(&malicious_player);
    // Panic: index out of bounds: the len is 3 but the index is 100
}
```

## Notes
The core issue is the mismatch between the type system's promise (Player IDs are valid) and its actual enforcement (public field allows arbitrary IDs). While reconfiguration locking reduces exploitation likelihood, defense-in-depth requires explicit bounds validation since the consequences of violation are severe (memory safety, consensus determinism).

### Citations

**File:** crates/aptos-crypto/src/weighted_config.rs (L163-165)
```rust
    pub fn get_player_weight(&self, player: &Player) -> usize {
        self.weights[player.id]
    }
```

**File:** crates/aptos-crypto/src/weighted_config.rs (L177-184)
```rust
    pub fn get_virtual_player(&self, player: &Player, j: usize) -> Player {
        // println!("WeightedConfig::get_virtual_player({player}, {i})");
        assert_lt!(j, self.weights[player.id]);

        let id = self.get_share_index(player.id, j).unwrap();

        Player { id }
    }
```

**File:** crates/aptos-crypto/src/player.rs (L21-24)
```rust
pub struct Player {
    /// A number from 0 to n-1.
    pub id: usize,
}
```

**File:** crates/aptos-crypto/src/player.rs (L26-28)
```rust
/// The point of Player is to provide type-safety: ensure nobody creates out-of-range player IDs.
/// So there is no `new()` method; only the SecretSharingConfig trait is allowed to create them.
// TODO: AFAIK the only way to really enforce this is to put both traits inside the same module (or use unsafe Rust)
```

**File:** consensus/src/epoch_manager.rs (L1043-1045)
```rust
        if dkg_session.metadata.dealer_epoch + 1 != new_epoch_state.epoch {
            return Err(NoRandomnessReason::CompletedSessionTooOld);
        }
```

**File:** consensus/src/epoch_manager.rs (L1047-1052)
```rust
        let my_index = new_epoch_state
            .verifier
            .address_to_validator_index()
            .get(&self.author)
            .copied()
            .ok_or_else(|| NoRandomnessReason::NotInValidatorSet)?;
```

**File:** consensus/src/epoch_manager.rs (L1066-1071)
```rust
        let (sk, pk) = DefaultDKG::decrypt_secret_share_from_transcript(
            &dkg_pub_params,
            &transcript,
            my_index as u64,
            &dkg_decrypt_key,
        )
```

**File:** types/src/dkg/real_dkg/mod.rs (L211-217)
```rust
        let pvss_config = build_dkg_pvss_config(
            dkg_session_metadata.dealer_epoch,
            secrecy_threshold,
            reconstruct_threshold,
            maybe_fast_path_secrecy_threshold,
            &dkg_session_metadata.target_validator_consensus_infos_cloned(),
        );
```

**File:** types/src/dkg/real_dkg/mod.rs (L428-434)
```rust
        let (sk, pk) = trx.main.decrypt_own_share(
            &pub_params.pvss_config.wconfig,
            &Player {
                id: player_idx as usize,
            },
            dk,
            &pub_params.pvss_config.pp,
```
