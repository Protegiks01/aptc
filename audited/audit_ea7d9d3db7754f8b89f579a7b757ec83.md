# Audit Report

## Title
Token V1 Missing Zero Denominator Validation Causes Transaction Aborts in Payment Distribution

## Summary
The Token V1 framework's `create_royalty` function fails to validate that the royalty denominator is non-zero, allowing creation of invalid royalty state. This causes runtime transaction aborts when marketplace contracts attempt to calculate royalty payments using division, rendering affected tokens unsellable.

## Finding Description

The vulnerability exists in the Token V1 (`aptos_token::token`) framework where the `create_royalty` function only validates that the numerator does not exceed the denominator, but does not check if the denominator is zero: [1](#0-0) 

Compare this to Token V2's implementation which properly validates the denominator: [2](#0-1) 

**Attack Path:**

1. Attacker calls `create_royalty(0, 0, payee_address)` which passes validation since `0 <= 0` evaluates to true
2. Attacker creates or mutates a token with this invalid royalty via `create_tokendata` or `mutate_tokendata_royalty`: [3](#0-2) 

3. The invalid royalty state (with zero denominator) is stored on-chain and emitted via `RoyaltyMutate` event: [4](#0-3) 

4. When a user attempts to purchase/sell the token through marketplace contracts, the payment settlement performs direct division: [5](#0-4) 

5. The division operation with zero denominator causes a Move VM abort, failing the entire transaction

The `math64::mul_div` function that would be used in safer implementations explicitly aborts on zero denominator: [6](#0-5) 

## Impact Explanation

**Severity: Medium**

This vulnerability allows an attacker to create tokens that become permanently unsellable through marketplace contracts, constituting a Denial of Service attack on token liquidity. While this does not result in direct loss of funds or consensus violations, it creates:

1. **State inconsistency** requiring manual intervention - tokens exist but cannot be traded
2. **Marketplace disruption** - affected tokens brick marketplace functionality for those specific assets
3. **User experience harm** - legitimate token holders cannot liquidate their positions

The impact is limited to Medium severity because:
- No funds are stolen or permanently locked (tokens remain transferable via direct transfer)
- No consensus safety violations occur
- The issue requires third-party marketplace code integration
- Tokens can still be transferred directly between users

## Likelihood Explanation

**Likelihood: Medium to High**

The vulnerability is easily exploitable:
- Any token creator can call `create_royalty` with zero denominator
- No special privileges or access required
- Attack succeeds with simple parameter manipulation
- Both token creation and mutation paths are vulnerable

However, actual exploitation impact depends on:
- Marketplace contracts using direct division instead of safe helper functions like `bounded_percentage`
- Token creators having incentive to intentionally create unsellable tokens (griefing attack)
- The core framework allows but doesn't encourage this behavior

## Recommendation

Add zero denominator validation to Token V1's `create_royalty` function to match Token V2's implementation:

```move
public fun create_royalty(royalty_points_numerator: u64, royalty_points_denominator: u64, payee_address: address): Royalty {
    assert!(royalty_points_denominator != 0, error::invalid_argument(EROYALTY_DENOMINATOR_IS_ZERO));
    assert!(royalty_points_numerator <= royalty_points_denominator, error::invalid_argument(EINVALID_ROYALTY_NUMERATOR_DENOMINATOR));
    Royalty {
        royalty_points_numerator,
        royalty_points_denominator,
        payee_address
    }
}
```

Define the error constant:
```move
const EROYALTY_DENOMINATOR_IS_ZERO: u64 = 41;
```

Additionally, marketplace contracts should use the defensive `bounded_percentage` helper instead of direct division, as demonstrated in `collection_offer.move`: [7](#0-6) 

## Proof of Concept

```move
#[test(creator = @0xCAFE, buyer = @0xBEEF)]
#[expected_failure(abort_code = 0x10004, location = aptos_std::math64)]
fun test_zero_denominator_royalty_causes_abort(creator: &signer, buyer: &signer) {
    // Setup accounts
    account::create_account_for_test(signer::address_of(creator));
    account::create_account_for_test(signer::address_of(buyer));
    
    // Create collection
    create_collection(
        creator,
        string::utf8(b"Test Collection"),
        string::utf8(b"Description"),
        string::utf8(b"https://test.com"),
        1000,
        vector<bool>[false, false, false]
    );
    
    // Create token with ZERO denominator royalty - THIS SHOULD FAIL BUT DOESN'T
    let token_id = create_tokendata(
        creator,
        string::utf8(b"Test Collection"),
        string::utf8(b"Token #1"),
        string::utf8(b"Description"),
        1,
        string::utf8(b"https://token.com"),
        signer::address_of(creator), // payee
        0, // royalty_denominator = 0 (INVALID!)
        0, // royalty_numerator = 0
        create_token_mutability_config(&vector<bool>[false, false, true, false, false]),
        vector<String>[],
        vector<vector<u8>>[],
        vector<String>[]
    );
    
    // Attempt to sell token - THIS WILL ABORT due to division by zero
    // Simulating token_offer.move line 384: price * royalty_numerator / royalty_denominator
    let price = 1000;
    let royalty = get_tokendata_royalty(token_id);
    let royalty_charge = price * get_royalty_numerator(&royalty) / get_royalty_denominator(&royalty);
    // ABORT HERE: division by zero with error code 0x10004
}
```

**Notes:**

This vulnerability highlights an inconsistency between Token V1 and Token V2 implementations. While Token V2 properly validates royalty parameters, Token V1 was likely developed earlier without this safeguard. The Rust event parsing code in `royalty_mutate.rs` is not the source of the vulnerabilityâ€”it merely deserializes events already emitted by Move code. The root cause is the missing validation in the Move framework, which allows invalid state creation that causes downstream failures in marketplace contracts performing royalty calculations.

### Citations

**File:** aptos-move/framework/aptos-token/sources/token.move (L831-850)
```text
    public fun mutate_tokendata_royalty(creator: &signer, token_data_id: TokenDataId, royalty: Royalty) acquires Collections {
        assert_tokendata_exists(creator, token_data_id);

        let all_token_data = &mut Collections[token_data_id.creator].token_data;
        let token_data = all_token_data.borrow_mut(token_data_id);
        assert!(token_data.mutability_config.royalty, error::permission_denied(EFIELD_NOT_MUTABLE));

        token_event_store::emit_token_royalty_mutate_event(
            creator,
            token_data_id.collection,
            token_data_id.name,
            token_data.royalty.royalty_points_numerator,
            token_data.royalty.royalty_points_denominator,
            token_data.royalty.payee_address,
            royalty.royalty_points_numerator,
            royalty.royalty_points_denominator,
            royalty.payee_address
        );
        token_data.royalty = royalty;
    }
```

**File:** aptos-move/framework/aptos-token/sources/token.move (L1001-1010)
```text
    public fun create_royalty(royalty_points_numerator: u64, royalty_points_denominator: u64, payee_address: address): Royalty {
        assert!(royalty_points_numerator <= royalty_points_denominator, error::invalid_argument(EINVALID_ROYALTY_NUMERATOR_DENOMINATOR));
        // Question[Orderless]: Is it okay to remove this check to accommodate stateless accounts?
        // assert!(account::exists_at(payee_address), error::invalid_argument(EROYALTY_PAYEE_ACCOUNT_DOES_NOT_EXIST));
        Royalty {
            royalty_points_numerator,
            royalty_points_denominator,
            payee_address
        }
    }
```

**File:** aptos-move/framework/aptos-token-objects/sources/royalty.move (L54-59)
```text
    public fun create(numerator: u64, denominator: u64, payee_address: address): Royalty {
        assert!(denominator != 0, error::out_of_range(EROYALTY_DENOMINATOR_IS_ZERO));
        assert!(numerator <= denominator, error::out_of_range(EROYALTY_EXCEEDS_MAXIMUM));

        Royalty { numerator, denominator, payee_address }
    }
```

**File:** types/src/account_config/events/royalty_mutate.rs (L30-52)
```rust
    pub fn new(
        creator: AccountAddress,
        collection: String,
        token: String,
        old_royalty_numerator: u64,
        old_royalty_denominator: u64,
        old_royalty_payee_addr: AccountAddress,
        new_royalty_numerator: u64,
        new_royalty_denominator: u64,
        new_royalty_payee_addr: AccountAddress,
    ) -> Self {
        Self {
            creator,
            collection,
            token,
            old_royalty_numerator,
            old_royalty_denominator,
            old_royalty_payee_addr,
            new_royalty_numerator,
            new_royalty_denominator,
            new_royalty_payee_addr,
        }
    }
```

**File:** aptos-move/move-examples/marketplace/sources/token_offer.move (L384-384)
```text
        let royalty_charge = price * royalty_numerator / royalty_denominator;
```

**File:** aptos-move/framework/aptos-stdlib/sources/math64.move (L50-54)
```text
    public inline fun mul_div(a: u64, b: u64, c: u64): u64 {
        // Inline functions cannot take constants, as then every module using it needs the constant
        assert!(c != 0, std::error::invalid_argument(4));
        (((a as u128) * (b as u128) / (c as u128)) as u64)
    }
```

**File:** aptos-move/move-examples/marketplace/sources/listing.move (L293-299)
```text
    public inline fun bounded_percentage(amount: u64, numerator: u64, denominator: u64): u64 {
        if (denominator == 0) {
            0
        } else {
            math64::min(amount, math64::mul_div(amount, numerator, denominator))
        }
    }
```
