# Audit Report

## Title
Array Index Out-of-Bounds Panic in Cross-Shard Message Handling with Large round_id Values

## Summary
The block partitioner can be configured with `max_partitioning_rounds` exceeding `MAX_ALLOWED_PARTITIONING_ROUNDS` (8), causing validator nodes to crash with array index out-of-bounds panics when attempting to send or receive cross-shard messages during sharded block execution.

## Finding Description

The Aptos block partitioner (PartitionerV2) allows configuration of `max_partitioning_rounds` via CLI arguments or programmatic configuration, with no validation against the hard limit of `MAX_ALLOWED_PARTITIONING_ROUNDS` (8). [1](#0-0) [2](#0-1) 

When configured with `max_partitioning_rounds > 8`, the partitioner creates transactions with `round_id >= 8` through the partitioning algorithm: [3](#0-2) 

These `round_id` values are stored in `ShardedTxnIndexV2` structures via `mark_txn_ordered()`: [4](#0-3) 

The problematic `round_id` values propagate into cross-shard dependency tracking: [5](#0-4) 

However, the executor's cross-shard client implementations pre-allocate message channels for **only 8 rounds**: [6](#0-5) [7](#0-6) 

When the executor attempts to send or receive messages with `round_id >= 8`, it directly indexes these arrays causing a panic: [8](#0-7) [9](#0-8) 

## Impact Explanation

**Severity: HIGH** (Validator node crashes)

This violates the **Total loss of liveness/network availability** criterion. When triggered:
- All validator nodes attempting to execute the block crash immediately with array bounds panic
- Network cannot make progress until configuration is corrected and nodes restarted
- Requires coordinated network recovery intervention

This breaks the **Deterministic Execution** and **Consensus Safety** invariants as crashed nodes cannot participate in consensus or execute blocks.

## Likelihood Explanation

**Likelihood: LOW** (Requires trusted operator misconfiguration)

⚠️ **CRITICAL LIMITATION**: This vulnerability requires a **trusted validator operator** to misconfigure the system by setting `--max-partitioning-rounds` > 8. This does NOT meet the standard security vulnerability criteria of being exploitable by an untrusted attacker.

The issue occurs when:
1. Validator operators configure `max_partitioning_rounds > 8` (default is 4)
2. A block contains enough transactions to require later partitioning rounds
3. The executor attempts cross-shard communication with `round_id >= 8`

## Recommendation

Add configuration validation in `PartitionerV2::new()`:

```rust
pub fn new(
    num_threads: usize,
    num_rounds_limit: usize,
    cross_shard_dep_avoid_threshold: f32,
    dashmap_num_shards: usize,
    partition_last_round: bool,
    pre_partitioner: Box<dyn PrePartitioner>,
) -> Self {
    assert!(
        num_rounds_limit <= MAX_ALLOWED_PARTITIONING_ROUNDS,
        "max_partitioning_rounds ({}) cannot exceed MAX_ALLOWED_PARTITIONING_ROUNDS ({})",
        num_rounds_limit,
        MAX_ALLOWED_PARTITIONING_ROUNDS
    );
    // ... rest of constructor
}
```

## Proof of Concept

```rust
// Run executor-benchmark with misconfiguration:
// cargo run -p aptos-executor-benchmark -- 
//   --max-partitioning-rounds 10 
//   --num-executor-shards 4
//   --block-size 1000
//
// Expected: Validator crashes with:
// thread 'executor-shard-0' panicked at 'index out of bounds: 
// the len is 8 but the index is 9'
```

---

**⚠️ VALIDATION FAILURE**: While this is a real implementation bug causing node crashes, it **FAILS** the critical validation criterion: "Exploitable by unprivileged attacker (no validator insider access required)." This requires trusted validator operator misconfiguration and is therefore a **robustness/defensive programming issue** rather than a security vulnerability exploitable by untrusted actors per the Aptos bug bounty program requirements.

### Citations

**File:** types/src/block_executor/partitioner.rs (L18-22)
```rust
pub type RoundId = usize;

pub static MAX_ALLOWED_PARTITIONING_ROUNDS: usize = 8;
pub static GLOBAL_ROUND_ID: usize = MAX_ALLOWED_PARTITIONING_ROUNDS + 1;
pub static GLOBAL_SHARD_ID: usize = usize::MAX;
```

**File:** execution/block-partitioner/src/v2/config.rs (L54-64)
```rust
impl Default for PartitionerV2Config {
    fn default() -> Self {
        Self {
            num_threads: 8,
            max_partitioning_rounds: 4,
            cross_shard_dep_avoid_threshold: 0.9,
            dashmap_num_shards: 64,
            partition_last_round: false,
            pre_partitioner_config: Box::<ConnectedComponentPartitionerConfig>::default(),
        }
    }
```

**File:** execution/block-partitioner/src/v2/partition_to_matrix.rs (L37-71)
```rust
        for round_id in 0..(state.num_rounds_limit - 1) {
            let (accepted, discarded) = Self::discarding_round(state, round_id, remaining_txns);
            state.finalized_txn_matrix.push(accepted);
            remaining_txns = discarded;
            num_remaining_txns = remaining_txns.iter().map(|ts| ts.len()).sum();

            if num_remaining_txns
                < ((1.0 - state.cross_shard_dep_avoid_threshold) * state.num_txns() as f32) as usize
            {
                break;
            }
        }

        let _timer = MISC_TIMERS_SECONDS.timer_with(&["last_round"]);

        if !state.partition_last_round {
            trace!("Merging txns after discarding stopped.");
            let last_round_txns: Vec<PrePartitionedTxnIdx> =
                remaining_txns.into_iter().flatten().collect();
            remaining_txns = vec![vec![]; state.num_executor_shards];
            remaining_txns[state.num_executor_shards - 1] = last_round_txns;
        }

        let last_round_id = state.finalized_txn_matrix.len();
        state.thread_pool.install(|| {
            (0..state.num_executor_shards)
                .into_par_iter()
                .for_each(|shard_id| {
                    remaining_txns[shard_id].par_iter().for_each(|&txn_idx| {
                        state.update_trackers_on_accepting(txn_idx, last_round_id, shard_id);
                    });
                });
        });
        state.finalized_txn_matrix.push(remaining_txns);
    }
```

**File:** execution/block-partitioner/src/v2/conflicting_txn_tracker.rs (L54-67)
```rust
    pub fn mark_txn_ordered(
        &mut self,
        txn_id: PrePartitionedTxnIdx,
        round_id: RoundId,
        shard_id: ShardId,
    ) {
        let sharded_txn_idx = ShardedTxnIndexV2::new(round_id, shard_id, txn_id);
        if self.pending_writes.remove(&txn_id) {
            self.finalized_writes.insert(sharded_txn_idx);
        } else {
            assert!(self.pending_reads.remove(&txn_id));
        }
        self.finalized.insert(sharded_txn_idx);
    }
```

**File:** execution/block-partitioner/src/v2/state.rs (L337-345)
```rust
                    let dst_txn_idx = ShardedTxnIndex {
                        txn_index: *self.final_idxs_by_pre_partitioned
                            [follower_txn_idx.pre_partitioned_txn_idx]
                            .read()
                            .unwrap(),
                        shard_id: final_sub_blk_idx.shard_id,
                        round_id: final_sub_blk_idx.round_id,
                    };
                    deps.add_dependent_edge(dst_txn_idx, vec![self.storage_location(key_idx)]);
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/local_executor_shard.rs (L95-104)
```rust
        let (cross_shard_msg_txs, cross_shard_msg_rxs): (
            Vec<Vec<Sender<CrossShardMsg>>>,
            Vec<Vec<Receiver<CrossShardMsg>>>,
        ) = (0..num_shards)
            .map(|_| {
                (0..MAX_ALLOWED_PARTITIONING_ROUNDS)
                    .map(|_| unbounded())
                    .unzip()
            })
            .unzip();
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/local_executor_shard.rs (L331-337)
```rust
    fn send_cross_shard_msg(&self, shard_id: ShardId, round: RoundId, msg: CrossShardMsg) {
        self.message_txs[shard_id][round].send(msg).unwrap()
    }

    fn receive_cross_shard_msg(&self, current_round: RoundId) -> CrossShardMsg {
        self.message_rxs[current_round].recv().unwrap()
    }
```

**File:** execution/executor-service/src/remote_cross_shard_client.rs (L26-41)
```rust
        for remote_address in shard_addresses.iter() {
            let mut txs = vec![];
            for round in 0..MAX_ALLOWED_PARTITIONING_ROUNDS {
                let message_type = format!("cross_shard_{}", round);
                let tx = controller.create_outbound_channel(*remote_address, message_type);
                txs.push(Mutex::new(tx));
            }
            message_txs.push(txs);
        }

        // Create inbound channels for each round
        for round in 0..MAX_ALLOWED_PARTITIONING_ROUNDS {
            let message_type = format!("cross_shard_{}", round);
            let rx = controller.create_inbound_channel(message_type);
            message_rxs.push(Mutex::new(rx));
        }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/cross_shard_client.rs (L122-130)
```rust
                    if *round_id == GLOBAL_ROUND_ID {
                        self.cross_shard_client.send_global_msg(message);
                    } else {
                        self.cross_shard_client.send_cross_shard_msg(
                            *dependent_shard_id,
                            *round_id,
                            message,
                        );
                    }
```
