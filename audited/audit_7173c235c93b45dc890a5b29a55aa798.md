# Audit Report

## Title
Governance Vote Direction Manipulation via Partial Voting - Stake Pools Can Vote Both YES and NO on Same Proposal

## Summary
The `partial_vote()` function in Aptos Governance allows a stake pool to vote multiple times on the same proposal in **different directions** (both YES and NO), violating the fundamental governance invariant that each stake pool should commit to a single voting position. This enables attackers to manipulate proposal outcomes by simultaneously boosting both yes and no vote counts, potentially triggering early resolution or causing proposals to resolve in unexpected ways.

## Finding Description

The vulnerability exists in how `VotingRecordsV2` tracks voting power usage in the governance system. The system only records the **total amount** of voting power used by each stake pool per proposal, but fails to track the **direction** (yes/no) of those votes. [1](#0-0) 

The `vote_internal` function calculates remaining voting power and updates the used voting power without any direction tracking: [2](#0-1) 

The underlying `voting::vote` function simply adds votes to either `yes_votes` or `no_votes` based on the `should_pass` parameter: [3](#0-2) 

**Attack Path:**
1. Attacker controls a stake pool with 100 voting power
2. Calls `partial_vote(stake_pool, proposal_id, 50, true)` → adds 50 to `yes_votes`, marks 50 power as used
3. Calls `partial_vote(stake_pool, proposal_id, 50, false)` → adds 50 to `no_votes`, marks 100 total power as used
4. Both votes are counted! The proposal now has +50 YES and +50 NO from the same stake pool

This violates the governance integrity invariant that a stake pool should vote in only one direction. The existing test suite only verifies voting multiple times in the **same** direction: [4](#0-3) 

No test exists that verifies prevention of voting in opposite directions, indicating this scenario was not considered during development.

## Impact Explanation

**Severity: HIGH** - This constitutes a significant protocol violation that undermines governance integrity.

**Attack Scenarios:**
1. **Early Resolution Manipulation**: Attacker votes both YES and NO with large voting power to artificially inflate total vote counts, potentially triggering early resolution thresholds when the proposal shouldn't resolve yet
2. **Proposal Outcome Manipulation**: Near voting deadlines, attacker votes both ways to prevent clear majority formation or to manipulate the final yes/no ratio
3. **Governance Deadlock**: Multiple attackers voting both ways can create artificial contention on critical governance proposals
4. **Vote Count Inflation**: Absolute vote counts are manipulated, making governance metrics and voting participation appear different than reality

The impact affects critical governance decisions including:
- Network parameter updates
- Framework upgrades  
- Validator set changes
- Feature flag modifications
- Staking configuration changes

This meets **High Severity** criteria as it represents a significant governance protocol violation that can affect network-wide decisions.

## Likelihood Explanation

**Likelihood: HIGH** - The attack is trivially exploitable:

**Attacker Requirements:**
- Control or be the delegated voter for any stake pool (common for validators and token holders)
- No special privileges required beyond normal governance participation
- Attack can be executed via standard transaction submission

**Complexity: LOW**
- Two simple function calls to `partial_vote()` with opposite `should_pass` values
- No sophisticated timing or state manipulation required
- Works on any active proposal during voting period

The attack has no technical barriers and requires only basic governance participation rights that many network participants already possess.

## Recommendation

**Solution:** Track the voting direction in `VotingRecordsV2` to enforce single-direction voting per stake pool.

Modify the `VotingRecordsV2` structure to store both used voting power AND direction:

```move
// In VotingRecordsV2, change from:
votes: SmartTable<RecordKey, u64>

// To:
struct VoteRecord has store, drop, copy {
    used_voting_power: u64,
    voted_yes: bool,  // Track which direction they voted
}
votes: SmartTable<RecordKey, VoteRecord>
```

Update `vote_internal` to enforce direction consistency:

```move
// Before voting, check if they already voted in opposite direction
let record_key = RecordKey { stake_pool, proposal_id };
if (smart_table::contains(&votes, record_key)) {
    let existing_record = smart_table::borrow(&votes, record_key);
    assert!(
        existing_record.voted_yes == should_pass,
        error::invalid_argument(EVOTE_DIRECTION_MISMATCH)
    );
}
```

Alternatively, maintain the existing structure but add direction validation in `get_remaining_voting_power` by querying the `voting` module for which direction has votes and enforcing consistency.

## Proof of Concept

```move
#[test(aptos_framework = @aptos_framework, proposer = @0x123, voter = @0x234, voter_2 = @0x345)]
public entry fun test_can_vote_both_yes_and_no_on_same_proposal(
    aptos_framework: signer,
    proposer: signer,
    voter: signer,
    voter_2: signer,
) acquires ApprovedExecutionHashes, GovernanceConfig, GovernanceResponsbility, VotingRecords, VotingRecordsV2, GovernanceEvents {
    setup_partial_voting(&aptos_framework, &proposer, &voter, &voter_2);
    let voter_addr = signer::address_of(&voter);
    
    create_proposal_for_test(&proposer, false);
    
    // Voter has 20 voting power total
    // Vote YES with 10 power
    partial_vote(&voter, voter_addr, 0, 10, true);
    
    // Vote NO with 10 power - THIS SHOULD FAIL but currently succeeds!
    partial_vote(&voter, voter_addr, 0, 10, false);
    
    // Check the proposal state - both votes counted
    let (yes_votes, no_votes) = voting::get_votes<GovernanceProposal>(@aptos_framework, 0);
    assert!(yes_votes == 10, 0);  // Has 10 YES votes
    assert!(no_votes == 10, 1);   // Has 10 NO votes - SAME stake pool voted both ways!
    
    // This demonstrates the vulnerability: same stake pool voted YES and NO
}
```

This test demonstrates that a single stake pool can vote in both directions on the same proposal, violating the governance integrity invariant. The test would currently pass, proving the vulnerability exists.

## Notes

While the security question specifically asks about "flipping" votes (implying cancellation and replacement), the actual vulnerability discovered is more severe: stake pools can vote in **both directions simultaneously** without canceling previous votes. This allows manipulation of absolute vote counts and can affect proposal resolution logic in ways that simple vote flipping could not achieve.

The vulnerability stems from an incomplete state tracking design where only total voting power usage is recorded without direction information, allowing the same voting power to be counted toward opposing outcomes.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L103-106)
```text
    /// Records to track the voting power usage of each stake pool on each proposal.
    struct VotingRecordsV2 has key {
        votes: SmartTable<RecordKey, u64>
    }
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L539-574)
```text
    fun vote_internal(
        voter: &signer,
        stake_pool: address,
        proposal_id: u64,
        voting_power: u64,
        should_pass: bool,
    ) acquires ApprovedExecutionHashes, VotingRecords, VotingRecordsV2, GovernanceEvents {
        permissioned_signer::assert_master_signer(voter);
        let voter_address = signer::address_of(voter);
        assert!(stake::get_delegated_voter(stake_pool) == voter_address, error::invalid_argument(ENOT_DELEGATED_VOTER));

        assert_proposal_expiration(stake_pool, proposal_id);

        // If a stake pool has already voted on a proposal before partial governance voting is enabled,
        // `get_remaining_voting_power` returns 0.
        let staking_pool_voting_power = get_remaining_voting_power(stake_pool, proposal_id);
        voting_power = min(voting_power, staking_pool_voting_power);

        // Short-circuit if the voter has no voting power.
        assert!(voting_power > 0, error::invalid_argument(ENO_VOTING_POWER));

        voting::vote<GovernanceProposal>(
            &governance_proposal::create_empty_proposal(),
            @aptos_framework,
            proposal_id,
            voting_power,
            should_pass,
        );

        let record_key = RecordKey {
            stake_pool,
            proposal_id,
        };
        let used_voting_power = VotingRecordsV2[@aptos_framework].votes.borrow_mut_with_default(record_key, 0);
        // This calculation should never overflow because the used voting cannot exceed the total voting power of this stake pool.
        *used_voting_power += voting_power;
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L1074-1097)
```text
    public entry fun test_stake_pool_can_vote_on_partial_voting_proposal_many_times(
        aptos_framework: signer,
        proposer: signer,
        voter_1: signer,
        voter_2: signer,
    ) acquires ApprovedExecutionHashes, GovernanceConfig, GovernanceResponsbility, VotingRecords, VotingRecordsV2, GovernanceEvents {
        setup_partial_voting(&aptos_framework, &proposer, &voter_1, &voter_2);
        let execution_hash = vector[1];
        let proposer_addr = signer::address_of(&proposer);
        let voter_1_addr = signer::address_of(&voter_1);
        let voter_2_addr = signer::address_of(&voter_2);

        create_proposal_for_test(&proposer, true);

        partial_vote(&voter_1, voter_1_addr, 0, 5, true);
        partial_vote(&voter_1, voter_1_addr, 0, 3, true);
        partial_vote(&voter_1, voter_1_addr, 0, 2, true);

        assert!(get_remaining_voting_power(proposer_addr, 0) == 100, 0);
        assert!(get_remaining_voting_power(voter_1_addr, 0) == 10, 1);
        assert!(get_remaining_voting_power(voter_2_addr, 0) == 10, 2);

        test_resolving_proposal_generic(aptos_framework, true, execution_hash);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/voting.move (L405-409)
```text
        if (should_pass) {
            proposal.yes_votes = proposal.yes_votes + (num_votes as u128);
        } else {
            proposal.no_votes = proposal.no_votes + (num_votes as u128);
        };
```
