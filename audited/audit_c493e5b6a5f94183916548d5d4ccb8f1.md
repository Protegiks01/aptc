# Audit Report

## Title
Missing Configuration Validation Allows Indexer Service Panic on Legitimate Requests

## Summary
The `IndexerGrpcDataServiceConfig` lacks validation to ensure at least one data service (live or historical) is enabled, allowing the service to start successfully but panic when clients make legitimate `get_transactions` requests.

## Finding Description
The indexer-grpc-data-service-v2 has a critical gap in its configuration validation logic. Unlike the v1 service which implements proper validation, the v2 service does not override the `validate()` method in its `RunnableConfig` implementation. [1](#0-0) 

The `LiveDataServiceConfig` and `HistoricalDataServiceConfig` each have an `enabled` boolean field that determines whether the service is created: [2](#0-1) [3](#0-2) 

Both services can return `None` if disabled, and a `DataServiceWrapperWrapper` is constructed with potentially both services as `None`: [4](#0-3) 

When a client calls `get_transactions`, if both services are `None`, the code hits an `unreachable!()` macro which panics: [5](#0-4) 

Additionally, there's an unsafe `.unwrap()` in the `DataServiceWrapper` that could panic if the background handler task crashes: [6](#0-5) 

## Impact Explanation
This issue qualifies as **Medium Severity** per the bounty criteria ("API crashes"). However, it's important to note that this affects the indexer service, which is **auxiliary infrastructure** separate from core blockchain consensus, execution, or state management. 

The impact is limited to:
- Denial of service for indexer API clients
- No impact on blockchain consensus or validator operations
- No impact on funds, transactions, or state
- Only affects misconfigured deployments

While the v1 service has proper validation to prevent this, the v2 service is missing this protection: [7](#0-6) 

## Likelihood Explanation
The likelihood is **LOW** because:
- Requires operator misconfiguration (setting both `enabled: false`)
- Service operators typically enable at least one service for functionality
- Easy to detect during deployment testing
- The panic provides clear error messaging for debugging

However, the lack of startup validation means misconfigurations pass silently until runtime.

## Recommendation
Implement a `validate()` method in the `RunnableConfig` implementation for `IndexerGrpcDataServiceConfig`:

```rust
#[async_trait::async_trait]
impl RunnableConfig for IndexerGrpcDataServiceConfig {
    fn validate(&self) -> Result<()> {
        if !self.live_data_service_config.enabled 
            && !self.historical_data_service_config.enabled 
        {
            bail!("At least one of live_data_service or historical_data_service must be enabled");
        }
        Ok(())
    }
    
    // ... existing run() method ...
}
```

Additionally, replace the `.unwrap()` with proper error handling in `DataServiceWrapper::get_transactions()`.

## Proof of Concept
```rust
// Create a config with both services disabled
let config = IndexerGrpcDataServiceConfig {
    chain_id: 1,
    live_data_service_config: LiveDataServiceConfig {
        enabled: false,
        num_slots: 5_000_000,
        size_limit_bytes: 10_000_000_000,
    },
    historical_data_service_config: HistoricalDataServiceConfig {
        enabled: false,
        file_store_config: /* ... */,
    },
    // ... other fields ...
};

// Service starts successfully (no validation error)
config.run().await.expect("Should start");

// Client makes request
let request = GetTransactionsRequest { /* ... */ };

// Service panics: "Must have at least one of the data services enabled."
// Thread panics with unreachable!() at service.rs:70
```

**Note**: This vulnerability affects an **auxiliary indexer service**, not core blockchain components (consensus, execution, storage, governance, or staking). The security impact is limited to API availability for this specific indexer instance and does not affect blockchain operation, validator consensus, or fund security.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/config.rs (L107-113)
```rust
    async fn create_live_data_service(
        &self,
        tasks: &mut Vec<JoinHandle<Result<()>>>,
    ) -> Option<DataServiceWrapper> {
        if !self.live_data_service_config.enabled {
            return None;
        }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/config.rs (L157-163)
```rust
    async fn create_historical_data_service(
        &self,
        tasks: &mut Vec<JoinHandle<Result<()>>>,
    ) -> Option<DataServiceWrapper> {
        if !self.historical_data_service_config.enabled {
            return None;
        }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/config.rs (L208-209)
```rust
#[async_trait::async_trait]
impl RunnableConfig for IndexerGrpcDataServiceConfig {
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/config.rs (L228-234)
```rust
        let live_data_service = self.create_live_data_service(&mut tasks).await;
        let historical_data_service = self.create_historical_data_service(&mut tasks).await;

        let wrapper = Arc::new(DataServiceWrapperWrapper::new(
            live_data_service,
            historical_data_service,
        ));
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/service.rs (L67-71)
```rust
        } else if let Some(historical_data_service) = self.historical_data_service.as_ref() {
            historical_data_service.get_transactions(req).await
        } else {
            unreachable!("Must have at least one of the data services enabled.");
        }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/service.rs (L142-143)
```rust
        let (tx, rx) = channel(self.data_service_response_channel_size);
        self.handler_tx.send((req, tx)).await.unwrap();
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service/src/config.rs (L130-137)
```rust
    fn validate(&self) -> Result<()> {
        if self.data_service_grpc_non_tls_config.is_none()
            && self.data_service_grpc_tls_config.is_none()
        {
            bail!("At least one of data_service_grpc_non_tls_config and data_service_grpc_tls_config must be set");
        }
        self.in_memory_cache_config.validate()?;
        Ok(())
```
