# Audit Report

## Title
Token V2 Collection Mutations Silently Dropped by Indexer Due to Missing ObjectCore Metadata

## Summary
The indexer's `CollectionV2::get_v2_from_write_resource()` function returns `Ok(None)` when processing collection resource updates that occur in transactions without an accompanying `ObjectCore` resource. This causes all Token V2 collection mutations (description, URI, name changes) to be silently skipped, resulting in permanently stale indexer data. [1](#0-0) 

## Finding Description

The vulnerability stems from a flawed assumption in the indexer's metadata aggregation logic. The token processor builds a `token_v2_metadata_helper` mapping by scanning for `ObjectCore` resources in a first pass: [2](#0-1) 

When `CollectionV2::get_v2_from_write_resource()` processes a Collection write, it requires metadata from this mapping: [3](#0-2) 

**The Critical Flaw:** When a Token V2 collection is mutated after creation (e.g., via `set_collection_description`), the WriteSetChange contains ONLY the modified `Collection` resource, not the unchanged `ObjectCore`: [4](#0-3) 

In Move, when you modify a resource with `&mut`, only that specific resource is written back to storage. Other resources at the same address that weren't touched do not appear in the WriteSet. [5](#0-4) 

**Attack Scenario:**
1. **Batch N:** Creator creates a collection → Collection + ObjectCore both written → indexed correctly
2. **Batch N+M (later):** Creator calls `0x4::aptos_token::set_collection_description` → Only Collection resource written
3. Indexer's first pass finds no ObjectCore → `token_v2_metadata_helper` has no entry for this address
4. `get_v2_from_write_resource()` checks mapping, finds nothing, returns `Ok(None)`
5. Collection update silently dropped, database remains stale [6](#0-5) 

Note that `token_v2_metadata_helper` persists only within a single batch, not across calls to `process_transactions`: [7](#0-6) 

## Impact Explanation

This qualifies as **High Severity** under "API crashes / Significant protocol violations":

1. **Data Integrity Violation:** The indexer provides stale collection metadata to all downstream consumers (NFT marketplaces, wallets, analytics platforms)
2. **Silent Failure:** No error is logged or surfaced, making the issue difficult to detect
3. **Permanent Data Loss:** Once a collection update is skipped, it never gets re-indexed unless the indexer is rebuilt from genesis
4. **Ecosystem Impact:** All Token V2 collections are affected - any application relying on indexer APIs receives incorrect metadata
5. **User-Facing Consequences:** NFT marketplaces display wrong collection descriptions/images, wallets show outdated information, potentially leading to user confusion and trust erosion

While this doesn't directly cause fund loss or consensus violations, it breaks the fundamental guarantee that the indexer accurately reflects on-chain state, which the Aptos ecosystem depends on for usability.

## Likelihood Explanation

**Likelihood: HIGH**

This occurs automatically whenever:
1. Any collection creator calls mutation functions: `set_collection_description`, `set_collection_uri`, or `set_name`
2. The mutation transaction is in a different batch than the creation transaction (nearly always true) [8](#0-7) 

These are standard, documented operations in the Token V2 framework. No special privileges or exploit techniques required - this affects normal, legitimate usage patterns.

## Recommendation

**Fix: Query database for missing ObjectCore metadata as a fallback**

When metadata is not found in the in-memory mapping, query the `current_token_v2_metadata` or `current_collections_v2` table to retrieve the ObjectCore from a previous transaction. Modify `get_v2_from_write_resource()`:

```rust
if let Some(metadata) = token_v2_metadata.get(&resource.address) {
    // ... existing logic ...
} else {
    // NEW: Fallback to database lookup for mutations
    // Query ObjectCore from previous state or use defaults
    aptos_logger::warn!(
        transaction_version = txn_version,
        collection_address = &resource.address,
        "ObjectCore not in current batch, collection mutation may be from update transaction"
    );
    // Still process the collection update with default/queried values
    // rather than silently dropping it
}
```

**Alternative Fix:** In the second pass, process ALL Collection resources regardless of whether ObjectCore exists in the mapping, using default values for missing metadata fields.

## Proof of Concept

**Move Transaction Sequence:**

```move
// Transaction 1: Create mutable collection
script {
    use aptos_token_objects::aptos_token;
    
    fun create_collection(creator: &signer) {
        aptos_token::create_collection(
            creator,
            string::utf8(b"Initial description"),
            10000,
            string::utf8(b"Test Collection"),
            string::utf8(b"https://example.com"),
            true,  // mutable_description = true
            true,  // mutable_uri = true
            true,  // mutable_token_description = true
            true,  // mutable_token_name = true
            true,  // mutable_token_properties = true
            true,  // mutable_token_uri = true
            true,  // mutable_royalty = true
            // ...
        );
    }
}

// Transaction 2 (in different batch): Update collection description
script {
    use aptos_token_objects::aptos_token;
    use aptos_framework::object;
    
    fun update_collection(creator: &signer) {
        let collection = object::address_to_object<Collection>(
            collection::create_collection_address(
                signer::address_of(creator),
                &string::utf8(b"Test Collection")
            )
        );
        
        // This write ONLY includes Collection resource, NOT ObjectCore
        aptos_token::set_collection_description(
            creator,
            collection,
            string::utf8(b"UPDATED description")  // Will be silently dropped by indexer
        );
    }
}
```

**Verification:**
1. Query indexer API for collection after Transaction 2
2. Description still shows "Initial description" instead of "UPDATED description"
3. On-chain state via fullnode API shows correct "UPDATED description"
4. Indexer database permanently out of sync

### Citations

**File:** crates/indexer/src/models/token_models/v2_collections.rs (L109-137)
```rust
            if let Some(metadata) = token_v2_metadata.get(&resource.address) {
                // Getting supply data (prefer fixed supply over unlimited supply although they should never appear at the same time anyway)
                let fixed_supply = metadata.fixed_supply.as_ref();
                let unlimited_supply = metadata.unlimited_supply.as_ref();
                if let Some(supply) = unlimited_supply {
                    (current_supply, max_supply, total_minted_v2) = (
                        supply.current_supply.clone(),
                        None,
                        Some(supply.total_minted.clone()),
                    );
                }
                if let Some(supply) = fixed_supply {
                    (current_supply, max_supply, total_minted_v2) = (
                        supply.current_supply.clone(),
                        Some(supply.max_supply.clone()),
                        Some(supply.total_minted.clone()),
                    );
                }

                // Getting collection mutability config from AptosCollection
                let collection = metadata.aptos_collection.as_ref();
                if let Some(collection) = collection {
                    mutable_description = Some(collection.mutable_description);
                    mutable_uri = Some(collection.mutable_uri);
                }
            } else {
                // ObjectCore should not be missing, returning from entire function early
                return Ok(None);
            }
```

**File:** crates/indexer/src/processors/token_processor.rs (L1069-1072)
```rust
    // Get Metadata for token v2 by object
    // We want to persist this through the entire batch so that even if a token is burned,
    // we can still get the object core metadata for it
    let mut token_v2_metadata_helper: TokenV2AggregatedDataMapping = HashMap::new();
```

**File:** crates/indexer/src/processors/token_processor.rs (L1093-1115)
```rust
            for wsc in user_txn.info.changes.iter() {
                if let WriteSetChange::WriteResource(wr) = wsc {
                    if let Some(object) =
                        ObjectWithMetadata::from_write_resource(wr, txn_version).unwrap()
                    {
                        token_v2_metadata_helper.insert(
                            standardize_address(&wr.address.to_string()),
                            TokenV2AggregatedData {
                                aptos_collection: None,
                                fixed_supply: None,
                                object,
                                unlimited_supply: None,
                                property_map: None,
                                transfer_event: None,
                                token: None,
                                fungible_asset_metadata: None,
                                fungible_asset_supply: None,
                                fungible_asset_store: None,
                            },
                        );
                    }
                }
            }
```

**File:** crates/indexer/src/processors/token_processor.rs (L1329-1344)
```rust
                        if let Some((collection, current_collection)) =
                            CollectionV2::get_v2_from_write_resource(
                                resource,
                                txn_version,
                                wsc_index,
                                txn_timestamp,
                                &token_v2_metadata_helper,
                            )
                            .unwrap()
                        {
                            collections_v2.push(collection);
                            current_collections_v2.insert(
                                current_collection.collection_id.clone(),
                                current_collection,
                            );
                        }
```

**File:** aptos-move/framework/aptos-token-objects/sources/collection.move (L648-651)
```text
    inline fun borrow_mut(mutator_ref: &MutatorRef): &mut Collection {
        check_collection_exists(mutator_ref.self);
        &mut Collection[mutator_ref.self]
    }
```

**File:** aptos-move/framework/aptos-token-objects/sources/collection.move (L671-688)
```text
    public fun set_description(mutator_ref: &MutatorRef, description: String) acquires Collection {
        assert!(description.length() <= MAX_DESCRIPTION_LENGTH, error::out_of_range(EDESCRIPTION_TOO_LONG));
        let collection = borrow_mut(mutator_ref);
        if (std::features::module_event_migration_enabled()) {
            event::emit(Mutation {
                mutated_field_name: string::utf8(b"description"),
                collection: object::address_to_object(mutator_ref.self),
                old_value: collection.description,
                new_value: description,
            });
        } else {
            event::emit_event(
                &mut collection.mutation_events,
                MutationEvent { mutated_field_name: string::utf8(b"description") },
            );
        };
        collection.description = description;
    }
```

**File:** aptos-move/framework/aptos-token-objects/sources/aptos_token.move (L620-631)
```text
    public entry fun set_collection_description<T: key>(
        creator: &signer,
        collection: Object<T>,
        description: String,
    ) acquires AptosCollection {
        let aptos_collection = authorized_borrow_collection(&collection, creator);
        assert!(
            aptos_collection.mutable_description,
            error::permission_denied(EFIELD_NOT_MUTABLE),
        );
        collection::set_description(aptos_collection.mutator_ref.borrow(), description);
    }
```
