# Audit Report

## Title
Nonce Transaction Validation State Not Persisted During Mempool Validation Leading to Multi-Instance Acceptance

## Summary
Nonce-based orderless transactions can bypass persistent replay protection during mempool validation because the VM session used for validation is never committed. This allows multiple transactions with identical (address, nonce) pairs to be accepted into different mempool instances simultaneously, though only one will execute successfully.

## Finding Description

The vulnerability exists in the transaction validation flow for `ReplayProtector::Nonce` transactions:

**Step 1: Mempool Skips Sequence Number Fetch** [1](#0-0) 

For nonce transactions, no sequence number is fetched from state, returning `Ok(None)`.

**Step 2: VM Validation Runs Prologue Without Persisting State** [2](#0-1) 

The validation session runs the prologue but never commits the session, discarding all state modifications including nonce insertions.

**Step 3: Prologue Attempts Nonce Insertion** [3](#0-2) 

The `check_for_replay_protection_orderless_txn` function calls `check_and_insert_nonce`, which modifies the nonce history. [4](#0-3) 

However, since the session is not committed during validation, this insertion is lost.

**Step 4: Mempool-Level Deduplication Only Per Instance** [5](#0-4) 

While a single mempool instance prevents duplicate replay protectors, this check is local to each node.

**Attack Path:**
1. Attacker creates transactions T1, T2, T3 with same (address, nonce) but different payloads/gas
2. Submits directly to different validator nodes (bypassing broadcast)
3. Each node's VM validation runs `check_and_insert_nonce` in isolated, uncommitted sessions
4. All transactions pass validation independently
5. All enter their respective local mempools
6. Transactions propagate through consensus
7. Only one executes successfully; others fail with `PROLOGUE_ENONCE_ALREADY_USED`

## Impact Explanation

**High Severity** - Significant protocol violation with operational impact:

1. **Mempool Resource Exhaustion**: Multiple conflicting transactions occupy mempool slots across the network
2. **Consensus Resource Waste**: Validators process duplicate transactions that will inevitably fail
3. **Network Bandwidth Waste**: Redundant transaction broadcasting across peer network
4. **Transaction Ordering Manipulation**: Attacker might cause execution of lower-fee transaction over higher-fee variant

This does NOT constitute Critical severity because:
- No funds are lost or stolen
- No consensus safety violation (deterministic execution ensures only one succeeds)
- Network can recover by clearing mempools
- No permanent state corruption

## Likelihood Explanation

**High likelihood** of occurrence:
- Trivial to execute: Attacker only needs to submit same nonce to multiple public RPC endpoints
- No special permissions required
- Can be automated easily
- Economic incentive exists (cheaper transaction might execute instead of expensive one)

The attack is constrained only by:
- Number of accessible validator nodes
- Network propagation speed
- Mempool broadcast mechanisms

## Recommendation

Implement one of the following solutions:

**Option 1: Network-Level Nonce Deduplication**
Add a distributed nonce tracking mechanism at the mempool layer that synchronizes known pending nonces across validator nodes before accepting transactions.

**Option 2: Persistent Validation Session (with rollback)**
Modify VM validation to use a persistent but rollback-capable session:
```rust
// In validate_transaction, after prologue succeeds:
if txn.replay_protector().get_nonce().is_some() {
    // For nonce txns, persist validation state to temporary storage
    // Rollback on mempool eviction/expiration
}
```

**Option 3: Strict Mempool Broadcast Nonce Checking**
Enhance the mempool broadcast protocol to reject any incoming nonce transaction that conflicts with local mempool entries, preventing propagation of duplicates.

**Recommended**: Option 3 is simplest and maintains current architecture while preventing multi-instance acceptance.

## Proof of Concept

```rust
// Exploit simulation - submit to multiple nodes concurrently

use aptos_types::transaction::{SignedTransaction, ReplayProtector};

async fn exploit_nonce_validation() {
    let sender = create_test_account();
    let nonce = 12345u64;
    
    // Create multiple transactions with same nonce, different payloads
    let txn1 = create_nonce_transaction(
        sender.clone(),
        ReplayProtector::Nonce(nonce),
        payload1, // Transfer 100 APT to address A
        gas_price: 100,
    );
    
    let txn2 = create_nonce_transaction(
        sender.clone(),
        ReplayProtector::Nonce(nonce),
        payload2, // Transfer 100 APT to address B (different!)
        gas_price: 50, // Lower gas price
    );
    
    // Submit to different nodes concurrently
    let node1_handle = tokio::spawn(async move {
        submit_to_node("validator1.aptos.network", txn1).await
    });
    
    let node2_handle = tokio::spawn(async move {
        submit_to_node("validator2.aptos.network", txn2).await
    });
    
    // Both should pass validation and enter respective mempools
    let result1 = node1_handle.await.unwrap();
    let result2 = node2_handle.await.unwrap();
    
    assert!(result1.is_ok()); // Passes validation
    assert!(result2.is_ok()); // Also passes validation!
    
    // When consensus picks transactions, only one executes
    // The other fails with PROLOGUE_ENONCE_ALREADY_USED
    // But both wasted mempool/consensus resources
}
```

**Notes:**
While this vulnerability allows mempool and consensus resource waste, it does not enable transaction replay in the traditional sense (multiple successful executions). The deterministic execution layer ensures only one transaction with a given nonce succeeds. The impact is operational inefficiency rather than fund loss or consensus corruption.

### Citations

**File:** mempool/src/shared_mempool/tasks.rs (L336-350)
```rust
        transactions
            .par_iter()
            .map(|(t, _, _)| match t.replay_protector() {
                ReplayProtector::Nonce(_) => Ok(None),
                ReplayProtector::SequenceNumber(_) => {
                    get_account_sequence_number(&state_view, t.sender())
                        .map(Some)
                        .inspect_err(|e| {
                            error!(LogSchema::new(LogEntry::DBError).error(e));
                            counters::DB_ERROR.inc();
                        })
                },
            })
            .collect::<Vec<_>>()
    });
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L3282-3305)
```rust
        let (counter_label, result) = match self.validate_signed_transaction(
            &mut session,
            module_storage,
            &txn,
            &txn_data,
            &log_context,
            is_approved_gov_script,
            &mut TraversalContext::new(&storage),
            &mut gas_meter,
        ) {
            Err(err) if err.status_code() != StatusCode::SEQUENCE_NUMBER_TOO_NEW => (
                "failure",
                VMValidatorResult::new(Some(err.status_code()), 0),
            ),
            _ => (
                "success",
                VMValidatorResult::new(None, txn.gas_unit_price()),
            ),
        };

        TRANSACTIONS_VALIDATED.inc_with(&[counter_label]);

        result
    }
```

**File:** aptos-move/framework/aptos-framework/sources/transaction_validation.move (L252-263)
```text
    fun check_for_replay_protection_orderless_txn(
        sender: address,
        nonce: u64,
        txn_expiration_time: u64,
    ) {
        // prologue_common already checks that the current_time > txn_expiration_time
        assert!(
            txn_expiration_time <= timestamp::now_seconds() + MAX_EXP_TIME_SECONDS_FOR_ORDERLESS_TXNS,
            error::invalid_argument(PROLOGUE_ETRANSACTION_EXPIRATION_TOO_FAR_IN_FUTURE),
        );
        assert!(nonce_validation::check_and_insert_nonce(sender, nonce, txn_expiration_time), error::invalid_argument(PROLOGUE_ENONCE_ALREADY_USED));
    }
```

**File:** aptos-move/framework/aptos-framework/sources/nonce_validation.move (L129-204)
```text
    public(friend) fun check_and_insert_nonce(
        sender_address: address,
        nonce: u64,
        txn_expiration_time: u64,
    ): bool acquires NonceHistory {
        assert!(exists<NonceHistory>(@aptos_framework), error::invalid_state(E_NONCE_HISTORY_DOES_NOT_EXIST));
        // Check if the transaction expiration time is too far in the future.
        assert!(txn_expiration_time <= timestamp::now_seconds() + NONCE_REPLAY_PROTECTION_OVERLAP_INTERVAL_SECONDS, error::invalid_argument(ETRANSACTION_EXPIRATION_TOO_FAR_IN_FUTURE));
        let nonce_history = &mut NonceHistory[@aptos_framework];
        let nonce_key = NonceKey {
            sender_address,
            nonce,
        };
        let bucket_index = sip_hash_from_value(&nonce_key) % NUM_BUCKETS;
        let current_time = timestamp::now_seconds();
        if (!nonce_history.nonce_table.contains(bucket_index)) {
            nonce_history.nonce_table.add(
                bucket_index,
                empty_bucket(false)
            );
        };
        let bucket = table::borrow_mut(&mut nonce_history.nonce_table, bucket_index);

        let existing_exp_time = bucket.nonce_to_exp_time_map.get(&nonce_key);
        if (existing_exp_time.is_some()) {
            let existing_exp_time = existing_exp_time.extract();

            // If the existing (address, nonce) pair has not expired, return false.
            if (existing_exp_time >= current_time) {
                return false;
            };

            // We maintain an invariant that two transaction with the same (address, nonce) pair cannot be stored
            // in the nonce history if their transaction expiration times are less than `NONCE_REPLAY_PROTECTION_OVERLAP_INTERVAL_SECONDS`
            // seconds apart.
            if (txn_expiration_time <= existing_exp_time + NONCE_REPLAY_PROTECTION_OVERLAP_INTERVAL_SECONDS) {
                return false;
            };

            // If the existing (address, nonce) pair has expired, garbage collect it.
            bucket.nonce_to_exp_time_map.remove(&nonce_key);
            bucket.nonces_ordered_by_exp_time.remove(&NonceKeyWithExpTime {
                txn_expiration_time: existing_exp_time,
                sender_address,
                nonce,
            });
        };

        // Garbage collect upto MAX_ENTRIES_GARBAGE_COLLECTED_PER_CALL expired nonces in the bucket.
        let i = 0;
        while (i < MAX_ENTRIES_GARBAGE_COLLECTED_PER_CALL && !bucket.nonces_ordered_by_exp_time.is_empty()) {
            let (front_k, _) = bucket.nonces_ordered_by_exp_time.borrow_front();
            // We garbage collect a nonce after it has expired and the NONCE_REPLAY_PROTECTION_OVERLAP_INTERVAL_SECONDS
            // seconds have passed.
            if (front_k.txn_expiration_time + NONCE_REPLAY_PROTECTION_OVERLAP_INTERVAL_SECONDS < current_time) {
                bucket.nonces_ordered_by_exp_time.pop_front();
                bucket.nonce_to_exp_time_map.remove(&NonceKey {
                    sender_address: front_k.sender_address,
                    nonce: front_k.nonce,
                });
            } else {
                break;
            };
            i = i + 1;
        };

        // Insert the (address, nonce) pair in the bucket.
        let nonce_key_with_exp_time = NonceKeyWithExpTime {
            txn_expiration_time,
            sender_address,
            nonce,
        };
        bucket.nonces_ordered_by_exp_time.add(nonce_key_with_exp_time, true);
        bucket.nonce_to_exp_time_map.add(nonce_key, txn_expiration_time);
        true
    }
```

**File:** mempool/src/core_mempool/transaction_store.rs (L256-294)
```rust
        if let Some(txns) = self.transactions.get_mut(&address) {
            if let Some(current_version) = txns.get_mut(&txn_replay_protector) {
                if current_version.txn.payload() != txn.txn.payload() {
                    return MempoolStatus::new(MempoolStatusCode::InvalidUpdate).with_message(
                        "Transaction already in mempool with a different payload".to_string(),
                    );
                } else if current_version.txn.expiration_timestamp_secs()
                    != txn.txn.expiration_timestamp_secs()
                {
                    return MempoolStatus::new(MempoolStatusCode::InvalidUpdate).with_message(
                        "Transaction already in mempool with a different expiration timestamp"
                            .to_string(),
                    );
                } else if current_version.txn.max_gas_amount() != txn.txn.max_gas_amount() {
                    return MempoolStatus::new(MempoolStatusCode::InvalidUpdate).with_message(
                        "Transaction already in mempool with a different max gas amount"
                            .to_string(),
                    );
                } else if current_version.get_gas_price() < txn.get_gas_price() {
                    // Update txn if gas unit price is a larger value than before
                    if let Some(txn) = txns.remove(&txn_replay_protector) {
                        self.index_remove(&txn);
                    };
                    counters::CORE_MEMPOOL_GAS_UPGRADED_TXNS.inc();
                } else if current_version.get_gas_price() > txn.get_gas_price() {
                    return MempoolStatus::new(MempoolStatusCode::InvalidUpdate).with_message(
                        "Transaction already in mempool with a higher gas price".to_string(),
                    );
                } else {
                    // If the transaction is the same, it's an idempotent call
                    // Updating signers is not supported, the previous submission must fail
                    counters::CORE_MEMPOOL_IDEMPOTENT_TXNS.inc();
                    if let Some(acc_seq_num) = account_sequence_number {
                        self.process_ready_seq_num_based_transactions(&address, acc_seq_num);
                    }
                    return MempoolStatus::new(MempoolStatusCode::Accepted);
                }
            }
        }
```
