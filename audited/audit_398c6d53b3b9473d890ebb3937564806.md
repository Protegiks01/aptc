# Audit Report

## Title
Unbounded Memory Allocation in Proxy Protocol Parser Enables Validator Node Resource Exhaustion

## Summary
The `read_header()` function in the proxy protocol implementation lacks upper bound validation on the `address_size` field, allowing attackers to force allocation and reading of up to 65,535 bytes per connection. This enables resource exhaustion attacks against validator nodes, causing performance degradation that impacts consensus participation. [1](#0-0) 

## Finding Description
The proxy protocol parser reads a 16-byte header containing an `address_size` field (u16) that specifies how many additional bytes to read for address information. The implementation only validates **minimum** size requirements but imposes no **maximum** limit, breaking the Resource Limits invariant (#9: "All operations must respect gas, storage, and computational limits").

When an attacker connects to a node with proxy protocol enabled:

1. The node reads 16 bytes of header data [2](#0-1) 

2. Extracts `address_size` from bytes 14-16 as a u16 (0-65,535) [3](#0-2) 

3. **Unconditionally allocates** a Vec of `address_size` bytes [4](#0-3) 

4. Attempts to read exactly `address_size` bytes from the socket [5](#0-4) 

For TCP_IPV4 and TCP_IPV6, validation only checks if the size is **at least** the minimum required (12 bytes for IPv4, 36 bytes for IPv6), but never validates maximum bounds: [6](#0-5) [7](#0-6) 

This function is invoked during inbound connection processing when proxy protocol is enabled: [8](#0-7) 

**Attack Scenario:**
An attacker opens multiple connections to a validator node and for each:
- Sends valid PPv2 signature and header
- Sets `address_size = 0xFFFF` (65,535 bytes)
- Either floods with 65KB data immediately or slowly drip-feeds bytes to keep connections open
- Forces the validator to allocate 65KB × N connections worth of memory
- Wastes CPU cycles reading and processing excessive data
- Degrades validator performance, causing slow block production, consensus timeouts, and reduced network participation

## Impact Explanation
This qualifies as **High Severity** under the Aptos Bug Bounty program criteria: "Validator node slowdowns" (up to $50,000).

While not a pure network-level DoS (which would be out of scope), this is an **application-layer vulnerability** that causes resource exhaustion within the validator process itself. The attack:

- Directly degrades validator node performance through memory and CPU waste
- Impairs the validator's ability to participate effectively in AptosBFT consensus
- Can cause timeouts in consensus rounds, missed block proposals, and voting delays
- Affects network liveness and performance when multiple validators are targeted
- Is distinct from network-level attacks because it exploits application logic, not network infrastructure

The ProxyProtocol specification expects address sections to be exactly 12 bytes (IPv4) or 36 bytes (IPv6) for TCP connections. Allowing up to 65KB per connection with no justification violates reasonable resource allocation practices and enables trivial abuse.

## Likelihood Explanation
**Likelihood: High**

Attack requirements:
- Network connectivity to validator nodes (publicly accessible on P2P networks)
- Ability to send TCP connections with crafted proxy protocol headers
- No authentication required before proxy protocol parsing occurs
- No cryptographic knowledge or stake required

The attack is trivial to execute:
- Attacker scripts can open hundreds/thousands of connections
- Each malicious header is only 16 bytes before forcing 65KB allocation
- Attack can be sustained or repeated to maintain pressure on validators
- Proxy protocol processing happens before noise handshake authentication

Detection difficulty:
- Appears as legitimate proxy protocol traffic initially
- Large address sizes might look like protocol misconfiguration rather than attack
- Memory growth may be gradual if attacker spaces out connections

## Recommendation

Add strict upper bound validation that rejects unreasonably large `address_size` values. The ProxyProtocol specification defines exact sizes for IPv4 (12 bytes) and IPv6 (36 bytes). Additionally, implement a generous maximum threshold to reject obvious abuse:

**Recommended Fix:**

After line 82 in `network/netcore/src/transport/proxy_protocol.rs`, add:

```rust
// Reject unreasonably large address sizes to prevent resource exhaustion
const MAX_REASONABLE_ADDRESS_SIZE: u16 = 1024; // Generous limit allowing future TLV extensions
if address_size > MAX_REASONABLE_ADDRESS_SIZE {
    return Err(io::Error::new(
        io::ErrorKind::InvalidInput,
        format!("ProxyProtocol: Address size {} exceeds maximum allowed {}", 
                address_size, MAX_REASONABLE_ADDRESS_SIZE),
    ));
}
```

For stricter enforcement aligned with current spec support, validate exact sizes:

```rust
let expected_size = match family_and_protocol {
    LOCAL_PROTOCOL | UDP_IPV4 | UDP_IPV6 | TCP_UNIX | UDP_UNIX => {
        // For unsupported protocols, cap at reasonable limit
        if address_size > MAX_REASONABLE_ADDRESS_SIZE {
            return Err(io::Error::new(
                io::ErrorKind::InvalidInput,
                "ProxyProtocol: Address size exceeds reasonable limit",
            ));
        }
        None
    },
    TCP_IPV4 => Some(IPV4_SIZE),
    TCP_IPV6 => Some(IPV6_SIZE),
    _ => None,
};

if let Some(expected) = expected_size {
    if address_size != expected {
        return Err(io::Error::new(
            io::ErrorKind::InvalidInput,
            format!("ProxyProtocol: Address size {} doesn't match expected {}", 
                    address_size, expected),
        ));
    }
}
```

This enforces exact size matching for supported protocols while preventing resource abuse for any protocol type.

## Proof of Concept

```rust
// Add to network/netcore/src/transport/proxy_protocol.rs test module

#[test]
fn test_reject_excessive_address_size() {
    use aptos_memsocket::MemorySocket;
    use futures::{executor::block_on, future::join, io::AsyncWriteExt};
    
    let (mut sender, mut receiver) = MemorySocket::new_pair();
    let original_addr = NetworkAddress::mock();

    let server = async move {
        // Send valid PPv2 header with malicious address_size
        sender.write_all(&PPV2_SIGNATURE).await.unwrap();
        sender.write_all(&[PPV2_PROXY]).await.unwrap();
        sender.write_all(&[TCP_IPV4]).await.unwrap();
        
        // Malicious: Set address_size to 0xFFFF (65535 bytes)
        sender.write_all(&[0xFF, 0xFF]).await.unwrap();
        
        // Send the 65535 bytes of address data (all zeros for simplicity)
        let massive_data = vec![0u8; 65535];
        sender.write_all(&massive_data).await.unwrap();
    };

    let reader = read_header(&original_addr, &mut receiver);
    
    let client = async move {
        let result = reader.await;
        
        // Currently this SUCCEEDS and wastes 65KB of memory
        // After fix, this should FAIL with InvalidInput error
        match result {
            Ok(_) => {
                panic!("VULNERABLE: Accepted excessive address_size of 65535 bytes");
            }
            Err(e) if e.kind() == io::ErrorKind::InvalidInput => {
                println!("FIXED: Correctly rejected excessive address size");
            }
            Err(e) => {
                panic!("Unexpected error: {:?}", e);
            }
        }
    };

    block_on(join(server, client));
}

#[test]
fn test_resource_exhaustion_attack_simulation() {
    // Simulate multiple malicious connections
    const NUM_MALICIOUS_CONNECTIONS: usize = 100;
    const MALICIOUS_SIZE: usize = 65535;
    
    println!("Simulating resource exhaustion attack:");
    println!("  {} connections × {} bytes = {} MB total",
             NUM_MALICIOUS_CONNECTIONS,
             MALICIOUS_SIZE,
             (NUM_MALICIOUS_CONNECTIONS * MALICIOUS_SIZE) / (1024 * 1024));
    
    // This demonstrates the memory impact an attacker can cause
    let mut allocated_vectors: Vec<Vec<u8>> = Vec::new();
    
    for _ in 0..NUM_MALICIOUS_CONNECTIONS {
        // Each malicious connection forces this allocation
        allocated_vectors.push(vec![0u8; MALICIOUS_SIZE]);
    }
    
    println!("  Attack successfully allocated ~{} MB",
             (allocated_vectors.len() * MALICIOUS_SIZE) / (1024 * 1024));
}
```

**Notes:**
- The vulnerability exists because `address_size` is treated as untrusted input from the network but lacks upper bound validation
- The ProxyProtocol V2 specification defines exact sizes (12 bytes for IPv4, 36 bytes for IPv6), so enforcing these limits is spec-compliant
- While not causing integer overflow in the traditional sense, the unbounded allocation enables practical resource exhaustion attacks
- This affects validator network performance and consensus participation, meeting HIGH severity criteria

### Citations

**File:** network/netcore/src/transport/proxy_protocol.rs (L56-57)
```rust
    let mut header = [0u8; 16];
    stream.read_exact(&mut header).await?;
```

**File:** network/netcore/src/transport/proxy_protocol.rs (L81-85)
```rust
    let address_size: [u8; 2] = header[14..16].try_into().unwrap();
    let address_size = u16::from_be_bytes(address_size);

    let mut address_bytes: Vec<u8> = vec![0; address_size as usize];
    stream.read_exact(&mut address_bytes).await?;
```

**File:** network/netcore/src/transport/proxy_protocol.rs (L96-101)
```rust
            if address_size < IPV4_SIZE {
                return Err(io::Error::new(
                    io::ErrorKind::InvalidInput,
                    "ProxyProtocol: Header size doesn't match expected address type",
                ));
            }
```

**File:** network/netcore/src/transport/proxy_protocol.rs (L110-115)
```rust
            if address_size < IPV6_SIZE {
                return Err(io::Error::new(
                    io::ErrorKind::InvalidInput,
                    "ProxyProtocol: Header size doesn't match expected address type",
                ));
            }
```

**File:** network/framework/src/transport/mod.rs (L260-271)
```rust
    let addr = if proxy_protocol_enabled {
        proxy_protocol::read_header(&addr, &mut socket)
            .await
            .map_err(|err| {
                debug!(
                    network_address = addr,
                    error = %err,
                    "ProxyProtocol: Failed to read header: {}",
                    err
                );
                err
            })?
```
