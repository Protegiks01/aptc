# Audit Report

## Title
Derived Reference Marking Lost During Control Flow Joins in Move Compiler V2 Reference Safety Analysis

## Summary
The `join` function in `LifetimeState` fails to merge the `derived_from` map when joining control flow paths, causing derived reference markings to be lost. This breaks v1 Move borrow semantics enforcement, allowing illegal borrow patterns to be accepted or legal patterns to be rejected non-deterministically.

## Finding Description

The Move compiler v2's reference safety processor maintains a `derived_from` map that tracks which temporaries were used to derive borrow graph nodes. This is critical for enforcing v1 borrow semantics, which distinguish between:
- Temporaries that directly derived a reference (allowed to coexist with exclusive borrows)
- Temporaries containing copies of references (not allowed to coexist with exclusive borrows)

The vulnerability exists in the dataflow analysis join operation: [1](#0-0) 

When `copy_ref` executes, it marks the destination as derived from the source: [2](#0-1) 

However, when control flow paths join, the `join` function only merges the graph, temp_to_label_map, and global_to_label_map, but completely ignores the `derived_from` map: [3](#0-2) 

This causes two critical issues:

1. **Lost Derived Markings**: When merging states where one branch has `derived_from[label] = {src}` and another has it empty, the join keeps only `self.derived_from`, discarding `other.derived_from` entirely.

2. **Stale Labels After Renaming**: When label renaming occurs (lines 330-334), the labels in `derived_from` are not updated, leaving stale references to non-existent labels.

The v1 semantics check relies on `derived_temps()` to determine which temporaries should be exempt from restrictions: [4](#0-3) 

When derived markings are lost, `derived_temps()` returns an incorrect set, causing the check to misfire.

## Impact Explanation

This is a **Medium severity** compiler correctness bug that causes state inconsistencies in Move code validation:

- **Incorrect Acceptance**: Move code with illegal borrow patterns may be accepted when derived markings from one control flow path are lost, bypassing v1 semantics checks that should have rejected the code.

- **Incorrect Rejection**: Legal Move code may be rejected when derived markings needed to exempt temporaries from restrictions are lost during joins.

- **Non-Deterministic Behavior**: The same Move source code may be accepted or rejected depending on which control flow path's `derived_from` map survives the join operation, breaking deterministic compilation.

While this is a compile-time bug rather than a runtime consensus violation, it represents a state inconsistency in the compiler that could lead to:
- Deployment of unsafe Move modules
- Inability to deploy safe Move modules
- Inconsistent validation results across different compilation attempts

## Likelihood Explanation

**High likelihood** of occurrence:

- Any Move function with conditional branches (`if-else`, `match`, loops) that perform reference copies will trigger the join operation
- The bug manifests whenever two control flow paths with different `derived_from` states merge
- No special conditions or rare edge cases are required
- Standard Move programming patterns naturally create this scenario

## Recommendation

The `join` function must be modified to properly merge the `derived_from` maps from both states and apply label renaming:

```rust
fn join(&mut self, other: &Self) -> JoinResult {
    // Join the graph
    let mut change = self.graph.join(&other.graph);
    self.check_graph_consistency();

    // A label renaming map resulting from joining lifetime nodes.
    let mut renaming: BTreeMap<LifetimeLabel, LifetimeLabel> = BTreeMap::new();

    let mut new_temp_to_label_map = std::mem::take(&mut self.temp_to_label_map);
    change = change.combine(self.join_label_map(
        &mut new_temp_to_label_map,
        &other.temp_to_label_map,
        &mut renaming,
    ));
    let mut new_global_to_label_map = std::mem::take(&mut self.global_to_label_map);
    change = change.combine(self.join_label_map(
        &mut new_global_to_label_map,
        &other.global_to_label_map,
        &mut renaming,
    ));
    self.temp_to_label_map = new_temp_to_label_map;
    self.global_to_label_map = new_global_to_label_map;

    // FIX: Join the derived_from maps
    for (label, temps) in &other.derived_from {
        self.derived_from.entry(*label).or_default().extend(temps);
        change = JoinResult::Changed;
    }

    if !renaming.is_empty() {
        Self::rename_labels_in_graph(&renaming, &mut self.graph);
        Self::rename_labels_in_map(&renaming, &mut self.temp_to_label_map);
        Self::rename_labels_in_map(&renaming, &mut self.global_to_label_map);
        
        // FIX: Apply renaming to derived_from map
        let mut new_derived_from = BTreeMap::new();
        for (mut label, temps) in std::mem::take(&mut self.derived_from) {
            Self::rename_label(&renaming, &mut label);
            new_derived_from.entry(label).or_default().extend(temps);
        }
        self.derived_from = new_derived_from;
        
        change = JoinResult::Changed;
    }
    self.check_graph_consistency();
    change
}
```

## Proof of Concept

```move
module 0x1::test {
    struct S has drop { f: u64 }
    
    // This function demonstrates the vulnerability
    public fun vulnerable_pattern(cond: bool): u64 {
        let s = S { f: 10 };
        let r = &mut s;
        let r1;
        
        if (cond) {
            // Branch 1: Copy reference
            // This should mark r1 as derived from r in derived_from map
            r1 = r;
        } else {
            // Branch 2: Create different reference
            r1 = &mut s.f;
        };
        
        // After join: r1's derived marking is lost
        // The following should fail v1 semantics in the true branch
        // but may not if the derived marking is lost
        let x = &mut r.f;  // Exclusive borrow
        *x = 20;
        *r1  // Use r1 - behavior depends on which derived_from survives join
    }
}
```

In this example:
1. When `cond = true`, `r1` is a copy of `r` and should be marked as derived from `r`
2. When `cond = false`, `r1` is a field borrow
3. After the join, the `derived_from` marking from the true branch may be lost
4. The v1 semantics check for the exclusive borrow `&mut r.f` will incorrectly pass or fail depending on which state's `derived_from` map survives the join

**Notes**

This vulnerability affects the correctness of Move compiler v2's reference safety analysis. The comment in the code explicitly states this is to maintain compatibility with v1 borrow semantics, which has a quirk where temporaries used to derive nodes can be reused, but copies cannot. The missing `derived_from` join logic breaks this critical invariant, potentially allowing unsafe Move code to compile or preventing safe code from compiling.

### Citations

**File:** third_party/move/move-compiler-v2/src/pipeline/reference_safety/reference_safety_processor_v2.rs (L156-177)
```rust
#[derive(Clone, Default, Debug)]
pub struct LifetimeState {
    /// Contains the borrow graph at the current program point, which consists of a set of `LifetimeNode` values
    /// which are labeled by `LifetimeLabel`. This contains exactly those nodes reachable
    /// as parents or children of the node labels used in the below maps and grows and shrinks from
    /// program point to program point.
    graph: MapDomain<LifetimeLabel, LifetimeNode>,
    /// A map from temporaries to labels, for those temporaries which have an associated node in the graph.
    /// If a local is originally borrowed, it will point from `temp` to a node with the `MemoryLocation::Local(temp)`.
    /// If a local is a reference derived from a location, it will point to a node with `MemoryLocation::Derived`.
    temp_to_label_map: BTreeMap<TempIndex, LifetimeLabel>,
    /// A map from globals to labels. Represents root states of the active graph.
    global_to_label_map: BTreeMap<QualifiedInstId<StructId>, LifetimeLabel>,
    /// A map indicating which nodes have been derived from the given set of temporaries.
    /// For example, if we have `label <- borrow_field(f)(src)`, then `label -> src` will be in
    /// this map. This map is used to deal with a quirk of v1 borrow semantics which allows
    /// a temporary which was used to derive a node to be used after the borrow again, but
    /// does not allow the same thing with a temporary which contains a copy of this reference.
    /// Once we update the v1 bytecode verifier, this should go away, because there is no safety
    /// reason to not allow the copy.
    derived_from: BTreeMap<LifetimeLabel, BTreeSet<TempIndex>>,
}
```

**File:** third_party/move/move-compiler-v2/src/pipeline/reference_safety/reference_safety_processor_v2.rs (L307-338)
```rust
    fn join(&mut self, other: &Self) -> JoinResult {
        // Join the graph
        let mut change = self.graph.join(&other.graph);
        self.check_graph_consistency();

        // A label renaming map resulting from joining lifetime nodes.
        let mut renaming: BTreeMap<LifetimeLabel, LifetimeLabel> = BTreeMap::new();

        let mut new_temp_to_label_map = std::mem::take(&mut self.temp_to_label_map);
        change = change.combine(self.join_label_map(
            &mut new_temp_to_label_map,
            &other.temp_to_label_map,
            &mut renaming,
        ));
        let mut new_global_to_label_map = std::mem::take(&mut self.global_to_label_map);
        change = change.combine(self.join_label_map(
            &mut new_global_to_label_map,
            &other.global_to_label_map,
            &mut renaming,
        ));
        self.temp_to_label_map = new_temp_to_label_map;
        self.global_to_label_map = new_global_to_label_map;

        if !renaming.is_empty() {
            Self::rename_labels_in_graph(&renaming, &mut self.graph);
            Self::rename_labels_in_map(&renaming, &mut self.temp_to_label_map);
            Self::rename_labels_in_map(&renaming, &mut self.global_to_label_map);
            change = JoinResult::Changed;
        }
        self.check_graph_consistency();
        change
    }
```

**File:** third_party/move/move-compiler-v2/src/pipeline/reference_safety/reference_safety_processor_v2.rs (L800-810)
```rust
    fn copy_ref(&mut self, dest: TempIndex, src: TempIndex) {
        if let Some(label) = self.label_for_temp(src).cloned() {
            self.temp_to_label_map.insert(dest, label);
            self.mark_derived_from(label, src)
        }
    }

    /// Marks the node with label to be derived from temporary.
    fn mark_derived_from(&mut self, label: LifetimeLabel, temp: TempIndex) {
        self.derived_from.entry(label).or_default().insert(temp);
    }
```

**File:** third_party/move/move-compiler-v2/src/pipeline/reference_safety/reference_safety_processor_v2.rs (L1260-1283)
```rust
        // Temps containing mut refs alive after this program point and referring to nodes
        // in the exclusive set are not allowed in v1 borrow semantics unless they are used to
        // derive the exclusive nodes. Consider
        // `let r = &mut s; let r1 = r; let x = &mut r.f; *x; *r1`: this is not allowed in v1.
        // In contrast, `let r = &mut s; let x = &mut r.f; *x; *r` *is* allowed. The reason
        // is that `x` is derived from `r` but not (for the first example) from `r1`.
        let derived = self.state.derived_temps();
        for mut_alive_after in self.alive.after.keys().cloned().filter(|t| {
            self.ty(*t).is_mutable_reference()
                && !exclusive_temps.contains(t)
                && !derived.contains(t)
        }) {
            if let Some(label) = self.state.label_for_temp(mut_alive_after) {
                if let Some(conflict) = filtered_leaves.keys().find(|exclusive_label| {
                    self.state.is_mut(exclusive_label)
                        && self.state.is_ancestor(label, exclusive_label)
                }) {
                    self.exclusive_access_borrow_error(
                        conflict,
                        filtered_leaves.get(conflict).unwrap(),
                    )
                }
            }
        }
```
