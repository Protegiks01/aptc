# Audit Report

## Title
Bytecode Version Downgrade Allows Bypassing Entry Function Signature Validation

## Summary
The bytecode deserializer fails to enforce the minimum supported bytecode version (VERSION_MIN = 5), allowing attackers to craft modules with versions 1-4 that bypass critical entry function signature validation checks, potentially leading to deployment of modules with invalid entry points and consensus inconsistencies.

## Finding Description

The Aptos Move VM defines `VERSION_MIN = 5` as the minimum supported bytecode version, yet the deserializer only validates the upper bound (maximum version), not the lower bound. This allows an attacker to manually craft bytecode with version 1-4 and bypass modern verification logic.

**The vulnerability chain**:

1. **No Minimum Version Check in Deserializer**: The deserializer validation only checks if `version == 0 || version > max_version`, but never validates `version >= VERSION_MIN`: [1](#0-0) 

2. **Version-Dependent Verification Bypass**: The entry function signature verifier explicitly skips all checks for modules with version < 5: [2](#0-1) 

3. **Compilation vs. Runtime Gap**: While the serializer enforces VERSION_MIN during compilation, an attacker can bypass compilation and submit raw bytecode bytes directly via `code::publish_package_txn`, which only goes through deserialization: [3](#0-2) 

4. **VERSION_MIN Definition**: The codebase explicitly defines VERSION_5 as the minimum supported version: [4](#0-3) 

**Attack Scenario**:
1. Attacker crafts a compiled module binary with version header set to `4` (or 1, 2, 3)
2. Submits transaction calling `code::publish_package_txn(metadata, malicious_bytecode)`
3. Deserializer accepts it (passes `version <= max_version` check, no VERSION_MIN check)
4. Entry function signature verification returns `Ok()` immediately (line 56-57 of script_signature.rs)
5. Module is deployed without validating entry function signatures
6. Module can have entry functions with signatures that violate modern requirements

**Breaking Invariants**:
- **Deterministic Execution**: Different bytecode versions may trigger different verification paths, potentially causing validators to disagree on module validity
- **Transaction Validation**: Entry function signature requirements exist to ensure safe transaction execution; bypassing them violates this guarantee
- **Move VM Safety**: Version-gated verification checks exist to enforce security properties; allowing unsupported versions undermines this

## Impact Explanation

This vulnerability qualifies as **High to Critical Severity** based on:

**Potential Consensus Impact**: If validators have different configurations or interpretations of version validation, this could cause consensus disagreement on whether certain modules are valid, potentially leading to chain splits or state inconsistencies.

**Verification Bypass**: Entry function signature checks serve critical security purposes. Version 5 introduced changes to script verification being "adapter specific" - bypassing this allows deploying modules that don't meet modern security requirements.

**Deployment of Invalid Modules**: Attackers can deploy modules with entry functions that have signatures incompatible with the modern transaction validation framework, potentially causing:
- Unexpected execution behavior
- Gas metering inconsistencies  
- Transaction validation failures that weren't anticipated

The severity depends on what additional safeguards exist in transaction execution, but bypassing fundamental verification checks represents a critical breakdown in defense-in-depth.

## Likelihood Explanation

**High Likelihood** for the following reasons:

1. **Simple to Exploit**: Attacker only needs to:
   - Take any valid compiled module
   - Modify the version bytes in the binary header (4 bytes after magic number)
   - Submit via standard transaction

2. **No Special Privileges Required**: Any account can call `code::publish_package_txn` with arbitrary bytecode bytes

3. **Deterministic**: The vulnerability is in the core deserialization logic, affecting all validators uniformly

4. **Already Implemented**: The code paths for publishing raw bytecode exist and are actively used: [5](#0-4) 

## Recommendation

**Immediate Fix**: Add VERSION_MIN validation to the deserializer:

```rust
// In file_format_common.rs, VersionedBinary::new(), around line 617
let version = match read_u32(&mut cursor) {
    Ok(v) => v & !APTOS_BYTECODE_VERSION_MASK,
    Err(_) => {
        return Err(PartialVMError::new(StatusCode::MALFORMED)
            .with_message("Bad binary header".to_string()));
    },
};
// ADD THIS CHECK:
if version == 0 || version < VERSION_MIN || version > u32::min(max_version, VERSION_MAX) {
    Err(PartialVMError::new(StatusCode::UNKNOWN_VERSION)
        .with_message(format!(
            "bytecode version {} unsupported (must be between {} and {})",
            version, VERSION_MIN, u32::min(max_version, VERSION_MAX)
        )))
} else {
    Ok((/* ... */))
}
```

**Additional Safeguards**:
1. Add integration tests that attempt to publish bytecode with version < VERSION_MIN and verify it's rejected
2. Review all version-dependent code paths to ensure consistent enforcement
3. Consider adding on-chain governance parameter for VERSION_MIN (similar to max_version from Features)

## Proof of Concept

```rust
// Rust test demonstrating the vulnerability
#[test]
fn test_version_downgrade_bypass() {
    use move_binary_format::{
        file_format::CompiledModule,
        file_format_common::{VERSION_4, VERSION_MIN},
    };
    
    // 1. Compile a valid module normally (gets version >= VERSION_MIN)
    let module = compile_test_module();
    let mut bytecode = vec![];
    module.serialize(&mut bytecode).unwrap();
    
    // 2. Manually modify version header to VERSION_4 (< VERSION_MIN)
    // Bytecode structure: [magic:4][version:4][table_count:1][tables...]
    // Version starts at byte offset 4
    bytecode[4] = VERSION_4 as u8;
    bytecode[5] = 0;
    bytecode[6] = 0;
    bytecode[7] = 0;
    
    // 3. Attempt to deserialize - should fail but currently succeeds
    let deserializer_config = DeserializerConfig::new(VERSION_MAX, IDENTIFIER_SIZE_MAX);
    let result = CompiledModule::deserialize_with_config(&bytecode, &deserializer_config);
    
    // This assertion SHOULD pass but currently FAILS (module is accepted)
    assert!(result.is_err(), "Module with version {} should be rejected (VERSION_MIN = {})", 
            VERSION_4, VERSION_MIN);
    
    // 4. If deserialization succeeds, verify that signature checks are bypassed
    if let Ok(downgraded_module) = result {
        assert_eq!(downgraded_module.version, VERSION_4);
        
        // Entry function signature verification will skip all checks
        // due to version < VERSION_5 early return in verify_module()
        let verify_result = verify_module_with_config(
            &downgraded_module,
            &default_verifier_config()
        );
        
        // Verification passes even though it should enforce modern requirements
        assert!(verify_result.is_ok());
    }
}
```

**Notes**:
- The vulnerability exists in production code paths used during module publishing
- All validators would accept the same malformed bytecode (deterministic), but the bypass of verification checks creates security risk
- Modern entry function requirements (enforced for version >= 5) can be circumvented entirely
- This represents a fundamental breakdown in version gating that was intended to prevent exactly this scenario

### Citations

**File:** third_party/move/move-binary-format/src/file_format_common.rs (L561-562)
```rust
/// Mark which oldest version is supported.
pub const VERSION_MIN: u32 = VERSION_5;
```

**File:** third_party/move/move-binary-format/src/file_format_common.rs (L617-620)
```rust
            if version == 0 || version > u32::min(max_version, VERSION_MAX) {
                Err(PartialVMError::new(StatusCode::UNKNOWN_VERSION)
                    .with_message(format!("bytecode version {} unsupported", version)))
            } else {
```

**File:** third_party/move/move-bytecode-verifier/src/script_signature.rs (L51-58)
```rust
pub fn verify_module(
    module: &CompiledModule,
    check_signature: FnCheckScriptSignature,
) -> VMResult<()> {
    // important for not breaking old modules
    if module.version < VERSION_5 {
        return Ok(());
    }
```

**File:** third_party/move/move-binary-format/src/serializer.rs (L261-271)
```rust
fn validate_version(version: u32) -> Result<()> {
    if !(VERSION_MIN..=VERSION_MAX).contains(&version) {
        bail!(
            "The requested bytecode version {} is not supported. Only {} to {} are.",
            version,
            VERSION_MIN,
            VERSION_MAX
        )
    } else {
        Ok(())
    }
```

**File:** third_party/move/move-vm/runtime/src/storage/publishing.rs (L143-152)
```rust
            let compiled_module =
                CompiledModule::deserialize_with_config(&module_bytes, deserializer_config)
                    .map(Arc::new)
                    .map_err(|err| {
                        err.append_message_with_separator(
                            '\n',
                            "[VM] module deserialization failed".to_string(),
                        )
                        .finish(Location::Undefined)
                    })?;
```
