# Audit Report

## Title
Byzantine Proposers Can Arbitrarily Reorder Transaction Batches to Extract MEV Due to Missing Batch Order Verification

## Summary
The consensus block validation logic does not verify that transaction batches in the payload follow the protocol-defined ordering rules (gas bucket descending order, round-robin fairness). Byzantine proposers can arbitrarily reorder batches to front-run transactions, execute sandwich attacks, or extract maximum extractable value (MEV) when transaction shuffling is disabled or minimally configured.

## Finding Description

When an honest proposer creates a block, they pull batches from the quorum store using specific ordering rules defined in the protocol: [1](#0-0) [2](#0-1) 

These batches are then included in the block payload. However, when other validators receive and validate a block proposal, the payload verification only checks cryptographic signatures, inline batch digests, and size limits - **it never verifies that the batch ordering follows protocol rules**: [3](#0-2) 

The `Payload::verify()` method validates signatures via `verify_with_cache()` and batch digests via `verify_inline_batches()`, but performs no ordering verification. Similarly, the proposal processing in consensus only checks basic properties: [4](#0-3) [5](#0-4) 

A Byzantine proposer can exploit this by:
1. Pulling batches from the quorum store normally
2. Reordering them arbitrarily (e.g., placing high-value transactions from their own accounts first)
3. Including the reordered batches in their block proposal
4. All validators accept the block because signatures and digests are valid

The reordered batches directly affect execution order when transactions are extracted: [6](#0-5) 

For `OptQuorumStore` payloads, transactions are concatenated as: proof batches, then opt batches, then inline batches, in the exact order specified by the payload.

**Mitigation Assessment:**

The system includes transaction shuffling as a defense: [7](#0-6) 

However, the effectiveness depends on configuration: [8](#0-7) 

When `OnChainExecutionConfig::Missing` (for backward compatibility) or explicitly set to `NoShuffling`, the Byzantine proposer's chosen ordering is preserved during execution. Even with `UseCaseAware` shuffling, the proposer retains influence through initial batch placement.

## Impact Explanation

**High Severity** - This represents a significant protocol violation that enables Byzantine validators to:

1. **Front-running**: Place their own transactions before victim transactions they observe in the batch queue
2. **Sandwich attacks**: Surround victim transactions with their own to extract profit
3. **MEV extraction**: Optimize transaction ordering for maximum profit extraction
4. **Selective delay**: Push competing or adversarial transactions to later in execution

The impact varies by configuration:
- **Critical** when `NoShuffling` is used: Direct control over execution order
- **High** when `UseCaseAware` is minimally configured: Partial ordering control
- **Medium** when `UseCaseAware` is aggressively configured: Reduced but non-zero influence

This violates the protocol's fairness guarantees implied by the batch ordering rules implemented in the quorum store.

## Likelihood Explanation

**Likelihood: High**

Any Byzantine validator selected as a proposer can exploit this in every round they propose. The attack requires:
- Being a validator (assumed possible per the question about "Byzantine validators")
- Being selected as proposer (happens regularly in rotation)
- Basic knowledge of the payload structure

No complex cryptographic attacks or coordination with other validators is required. The proposer simply needs to reorder batches before including them in their block proposal.

## Recommendation

Implement batch ordering verification during block validation. Add a check that validates the batch ordering follows protocol rules:

```rust
// In consensus/consensus-types/src/common.rs, within Payload::verify()

pub fn verify_ordering(&self) -> anyhow::Result<()> {
    match self {
        Payload::InQuorumStore(proof_with_data) => {
            verify_batch_order(&proof_with_data.proofs)?;
        },
        Payload::QuorumStoreInlineHybrid(inline_batches, proof_with_data, _) => {
            verify_batch_order(&proof_with_data.proofs)?;
            // Verify inline batches are also correctly ordered
        },
        // ... similar for other variants
        _ => {},
    }
    Ok(())
}

fn verify_batch_order<T: TBatchInfo>(batches: &[ProofOfStore<T>]) -> anyhow::Result<()> {
    // Verify batches are sorted by gas_bucket_start in descending order
    for window in batches.windows(2) {
        ensure!(
            window[0].info().gas_bucket_start() >= window[1].info().gas_bucket_start(),
            "Batches not sorted by gas bucket: {} < {}",
            window[0].info().gas_bucket_start(),
            window[1].info().gas_bucket_start()
        );
    }
    Ok(())
}
```

Additionally, enforce transaction shuffling (UseCaseAware with strong parameters) as mandatory to provide defense-in-depth even if ordering verification has edge cases.

## Proof of Concept

```rust
// Proof of Concept: Byzantine Proposer Reorders Batches
// Add to consensus/src/tests/batch_ordering_test.rs

#[tokio::test]
async fn test_byzantine_batch_reordering() {
    // Setup: Create batches with different gas buckets
    let high_gas_batch = create_batch(gas_bucket_start: 1000, num_txns: 10);
    let medium_gas_batch = create_batch(gas_bucket_start: 500, num_txns: 10);
    let low_gas_batch = create_batch(gas_bucket_start: 100, num_txns: 10);
    
    // Honest proposer ordering: [high, medium, low] (descending gas)
    let honest_payload = Payload::InQuorumStore(ProofWithData::new(vec![
        high_gas_batch.clone(),
        medium_gas_batch.clone(),
        low_gas_batch.clone(),
    ]));
    
    // Byzantine proposer ordering: [low, high, medium] (arbitrary)
    let byzantine_payload = Payload::InQuorumStore(ProofWithData::new(vec![
        low_gas_batch.clone(),
        high_gas_batch.clone(),
        medium_gas_batch.clone(),
    ]));
    
    // Both pass verification (no ordering check)
    assert!(honest_payload.verify(&validator_verifier, &proof_cache, true).is_ok());
    assert!(byzantine_payload.verify(&validator_verifier, &proof_cache, true).is_ok());
    
    // Extract transactions and observe order
    let honest_txns = extract_transactions(&honest_payload).await;
    let byzantine_txns = extract_transactions(&byzantine_payload).await;
    
    // With NoShuffling, orders are different
    assert_ne!(honest_txns, byzantine_txns);
    
    // Byzantine proposer can place their high-value txns first by manipulating batch order
    assert_eq!(byzantine_txns[0].sender(), BYZANTINE_ADDRESS);
}
```

## Notes

This vulnerability is particularly concerning because:

1. The protocol implements specific ordering rules when pulling batches, suggesting ordering is protocol-critical
2. No verification enforces these rules, creating an exploitable gap
3. The impact is configuration-dependent but can be severe with `NoShuffling`
4. This breaks the fairness invariant implied by the batch ordering implementation

The vulnerability exists in networks where:
- Transaction shuffling is disabled (`NoShuffling`)
- On-chain execution config is missing (defaults to `NoShuffling`)
- Shuffling is weakly configured

Even with strong shuffling, the Byzantine proposer retains some ordering influence, representing a protocol deviation from the intended fair ordering behavior.

### Citations

**File:** consensus/src/quorum_store/batch_proof_queue.rs (L626-627)
```rust
        while !iters.is_empty() {
            iters.shuffle(&mut thread_rng());
```

**File:** consensus/src/quorum_store/batch_proof_queue.rs (L707-710)
```rust
        if full || return_non_full {
            // Stable sort, so the order of proofs within an author will not change.
            result.sort_by_key(|item| Reverse(item.info.gas_bucket_start()));
            (result, cur_all_txns, cur_unique_txns, full)
```

**File:** consensus/consensus-types/src/common.rs (L574-632)
```rust
    pub fn verify(
        &self,
        verifier: &ValidatorVerifier,
        proof_cache: &ProofCache,
        quorum_store_enabled: bool,
    ) -> anyhow::Result<()> {
        match (quorum_store_enabled, self) {
            (false, Payload::DirectMempool(_)) => Ok(()),
            (true, Payload::InQuorumStore(proof_with_status)) => {
                Self::verify_with_cache(&proof_with_status.proofs, verifier, proof_cache)
            },
            (true, Payload::InQuorumStoreWithLimit(proof_with_status)) => Self::verify_with_cache(
                &proof_with_status.proof_with_data.proofs,
                verifier,
                proof_cache,
            ),
            (true, Payload::QuorumStoreInlineHybrid(inline_batches, proof_with_data, _))
            | (true, Payload::QuorumStoreInlineHybridV2(inline_batches, proof_with_data, _)) => {
                Self::verify_with_cache(&proof_with_data.proofs, verifier, proof_cache)?;
                Self::verify_inline_batches(
                    inline_batches.iter().map(|(info, txns)| (info, txns)),
                )?;
                Ok(())
            },
            (true, Payload::OptQuorumStore(OptQuorumStorePayload::V1(p))) => {
                let proof_with_data = p.proof_with_data();
                Self::verify_with_cache(&proof_with_data.batch_summary, verifier, proof_cache)?;
                Self::verify_inline_batches(
                    p.inline_batches()
                        .iter()
                        .map(|batch| (batch.info(), batch.transactions())),
                )?;
                Self::verify_opt_batches(verifier, p.opt_batches())?;
                Ok(())
            },
            (true, Payload::OptQuorumStore(OptQuorumStorePayload::V2(p))) => {
                if true {
                    bail!("OptQuorumStorePayload::V2 cannot be accepted yet");
                }
                #[allow(unreachable_code)]
                {
                    let proof_with_data = p.proof_with_data();
                    Self::verify_with_cache(&proof_with_data.batch_summary, verifier, proof_cache)?;
                    Self::verify_inline_batches(
                        p.inline_batches()
                            .iter()
                            .map(|batch| (batch.info(), batch.transactions())),
                    )?;
                    Self::verify_opt_batches(verifier, p.opt_batches())?;
                    Ok(())
                }
            },
            (_, _) => Err(anyhow::anyhow!(
                "Wrong payload type. Expected Payload::InQuorumStore {} got {} ",
                quorum_store_enabled,
                self
            )),
        }
    }
```

**File:** consensus/src/round_manager.rs (L1178-1193)
```rust
        let payload_len = proposal.payload().map_or(0, |payload| payload.len());
        let payload_size = proposal.payload().map_or(0, |payload| payload.size());
        ensure!(
            num_validator_txns + payload_len as u64 <= self.local_config.max_receiving_block_txns,
            "Payload len {} exceeds the limit {}",
            payload_len,
            self.local_config.max_receiving_block_txns,
        );

        ensure!(
            validator_txns_total_bytes + payload_size as u64
                <= self.local_config.max_receiving_block_bytes,
            "Payload size {} exceeds the limit {}",
            payload_size,
            self.local_config.max_receiving_block_bytes,
        );
```

**File:** consensus/src/round_manager.rs (L1262-1262)
```rust
        if block_store.check_payload(&proposal).is_err() {
```

**File:** consensus/src/payload_manager/quorum_store_payload_manager.rs (L529-529)
```rust
                let all_txns = [proof_batch_txns, opt_batch_txns, inline_batch_txns].concat();
```

**File:** consensus/src/block_preparer.rs (L100-104)
```rust
            let mut shuffled_txns = {
                let _timer = TXN_SHUFFLE_SECONDS.start_timer();

                txn_shuffler.shuffle(deduped_txns)
            };
```

**File:** types/src/on_chain_config/execution_config.rs (L29-39)
```rust
    pub fn transaction_shuffler_type(&self) -> TransactionShufflerType {
        match &self {
            OnChainExecutionConfig::Missing => TransactionShufflerType::NoShuffling,
            OnChainExecutionConfig::V1(config) => config.transaction_shuffler_type.clone(),
            OnChainExecutionConfig::V2(config) => config.transaction_shuffler_type.clone(),
            OnChainExecutionConfig::V3(config) => config.transaction_shuffler_type.clone(),
            OnChainExecutionConfig::V4(config) => config.transaction_shuffler_type.clone(),
            OnChainExecutionConfig::V5(config) => config.transaction_shuffler_type.clone(),
            OnChainExecutionConfig::V6(config) => config.transaction_shuffler_type.clone(),
            OnChainExecutionConfig::V7(config) => config.transaction_shuffler_type.clone(),
        }
```
