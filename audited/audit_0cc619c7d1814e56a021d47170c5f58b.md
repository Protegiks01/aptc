# Audit Report

## Title
DDoS Amplification Vulnerability in Node Health Checker Latency Checker

## Summary
The Node Health Checker's `LatencyChecker` component lacks input validation on critical configuration parameters (`num_samples` and `delay_between_samples_ms`), enabling attackers to weaponize misconfigured public node-checker instances as DDoS amplification vectors against arbitrary Aptos nodes, including validators.

## Finding Description

The `LatencyChecker` configuration allows `num_samples` to be set up to 65535 (u16 max) and `delay_between_samples_ms` to be set to 0 with no validation constraints. [1](#0-0) 

The checker's `check` function executes a loop that fires `num_samples` API requests to the target node with the specified delay between each request. [2](#0-1) 

Each request calls `get_latency_datapoint`, which invokes the target node's API endpoint. [3](#0-2) 

The Node Health Checker exposes a public `/check` API endpoint that accepts arbitrary target node URLs without authentication or rate limiting. [4](#0-3) 

**Attack Path:**
1. Operator deploys a public node-checker service with a baseline configuration containing `num_samples: 65535` and `delay_between_samples_ms: 0` (either for legitimate high-frequency testing or through misconfiguration)
2. Attacker discovers this public endpoint
3. Attacker calls `/check?baseline_configuration_id=<config>&node_url=<victim_url>` 
4. The node-checker fires 65,535 rapid API requests to the victim node
5. One attacker request results in 65,535 requests to the victim (65535:1 amplification factor)
6. Multiple attackers or repeated calls can overwhelm the victim node's API, causing slowdowns or crashes

The configuration validation function performs no bounds checking on these parameters. [5](#0-4) 

This violates the **Resource Limits** invariant: "All operations must respect gas, storage, and computational limits." While the node-checker is not a blockchain component, it can be weaponized to attack validator nodes, affecting their availability and liveness.

## Impact Explanation

This vulnerability enables **application-level DDoS amplification attacks** against Aptos nodes:

- **High Severity per Bug Bounty**: The attack directly causes "Validator node slowdowns" and potentially "API crashes", which are explicitly listed as High Severity ($50,000) in the bug bounty program
- **Amplification Factor**: Up to 65535:1 amplification (one request generates 65,535 requests)
- **No Authentication/Rate Limiting**: The `/check` endpoint has no access controls, allowing unlimited exploitation
- **Validator Impact**: Can target validator nodes, degrading consensus participation and network liveness
- **Ease of Exploitation**: Requires only HTTP GET requests to a public endpoint

While the exclusions mention "Network-level DoS attacks are out of scope," this is an **application-level vulnerability** in the node-checker service logic that can be weaponized for amplification attacks. The bug bounty explicitly includes validator slowdowns and API crashes as valid High Severity impacts.

## Likelihood Explanation

**High Likelihood** of exploitation if vulnerable conditions exist:

1. **Public Deployments**: Node-checker instances may be deployed publicly for community node monitoring
2. **Legitimate High-Value Configs**: Operators might configure high `num_samples` values for thorough testing without realizing the amplification risk
3. **Trivial Exploitation**: Attackers need only discover public endpoints and send HTTP requests
4. **No Defense in Depth**: No rate limiting, authentication, or input validation protects against abuse
5. **High-Value Targets**: Validator nodes are attractive DDoS targets for competitors or malicious actors

## Recommendation

Implement multiple layers of defense:

**1. Input Validation** - Add strict bounds checking in `LatencyCheckerConfig`:

```rust
impl LatencyCheckerConfig {
    const MAX_NUM_SAMPLES: u16 = 100;
    const MIN_DELAY_MS: u64 = 10;
    
    pub fn validate(&self) -> Result<()> {
        if self.num_samples > Self::MAX_NUM_SAMPLES {
            bail!("num_samples exceeds maximum allowed value of {}", Self::MAX_NUM_SAMPLES);
        }
        if self.delay_between_samples_ms < Self::MIN_DELAY_MS {
            bail!("delay_between_samples_ms must be at least {}ms", Self::MIN_DELAY_MS);
        }
        Ok(())
    }
}
```

**2. Configuration Validation** - Call validation during config loading in `validate_configuration()`:

```rust
pub fn validate_configuration(node_configuration: &BaselineConfiguration) -> Result<()> {
    for checker_config in &node_configuration.checkers {
        if let CheckerConfig::Latency(config) = checker_config {
            config.validate().context("Invalid LatencyChecker configuration")?;
        }
    }
    build_checkers(&node_configuration.checkers).context("Failed to build Checkers")?;
    Ok(())
}
```

**3. Rate Limiting** - Add rate limiting to the `/check` API endpoint using poem middleware or a similar solution

**4. Authentication** - Consider adding API key authentication for public deployments

**5. Monitoring** - Log suspicious patterns (same target hit repeatedly, high num_samples configs)

## Proof of Concept

**Setup:**
1. Deploy node-checker with configuration:
```yaml
type: Latency
num_samples: 65535
delay_between_samples_ms: 0
max_api_latency_ms: 1000
```

**Attack Execution:**
```bash
# Single attacker request
curl "http://node-checker-service:8080/check?baseline_configuration_id=test&node_url=http://victim-validator-node:8080"

# Result: 65,535 rapid API requests fired at victim node
```

**Expected Impact:**
- Victim node's API endpoint receives 65,535 requests within seconds
- CPU and network bandwidth exhaustion on victim node
- API latency increases dramatically
- Potential API process crashes under load
- If victim is a validator: degraded consensus participation

**Verification:**
Monitor victim node's access logs or metrics to observe the request flood. Measure API latency and error rates during the attack.

## Notes

- This vulnerability exists in the `ecosystem/node-checker` component, which is an auxiliary monitoring tool rather than a core blockchain consensus component
- The default values are reasonable (`num_samples=5`, `delay_between_samples_ms=50`), but serde deserialization accepts any values within type bounds
- The lack of validation violates defense-in-depth principles and enables weaponization of the service
- While this is DoS-related, it's an application logic vulnerability (not network-level DoS) that can cause explicitly in-scope High Severity impacts (validator slowdowns, API crashes)

### Citations

**File:** ecosystem/node-checker/src/checker/latency.rs (L22-28)
```rust
    /// The number of times to hit the node to check latency.
    #[serde(default = "LatencyCheckerConfig::default_num_samples")]
    pub num_samples: u16,

    /// The delay between each call.
    #[serde(default = "LatencyCheckerConfig::default_delay_between_samples_ms")]
    pub delay_between_samples_ms: u64,
```

**File:** ecosystem/node-checker/src/checker/latency.rs (L62-66)
```rust
    async fn get_latency_datapoint(&self, provider: &ApiIndexProvider) -> Result<Duration> {
        let start = Instant::now();
        provider.provide().await?;
        Ok(start.elapsed())
    }
```

**File:** ecosystem/node-checker/src/checker/latency.rs (L84-105)
```rust
        for _ in 0..self.config.num_samples {
            match self.get_latency_datapoint(target_api_index_provider).await {
                Ok(latency) => latencies.push(latency),
                Err(e) => errors.push(e),
            }
            if errors.len() as u16 > self.config.num_allowed_errors {
                return Ok(vec![
                    Self::build_result(
                        "Node returned too many errors while checking API latency".to_string(),
                        0,
                        format!(
                            "The node returned too many errors while checking API RTT (Round trip time), the tolerance was {} errors out of {} calls: {}. Note, this latency is not the same as standard ping latency, see the attached link.",
                            self.config.num_allowed_errors, self.config.num_samples, errors.into_iter().map(|e| e.to_string()).collect::<Vec<String>>().join(", "),
                        )
                    ).links(vec![LINK.to_string()])
                ]);
            }
            tokio::time::sleep(std::time::Duration::from_millis(
                self.config.delay_between_samples_ms,
            ))
            .await;
        }
```

**File:** ecosystem/node-checker/src/server/api.rs (L29-45)
```rust
    #[oai(path = "/check", method = "get")]
    async fn check(
        &self,
        /// The ID of the baseline node configuration to use for the evaluation, e.g. devnet_fullnode
        baseline_configuration_id: Query<String>,
        /// The URL of the node to check, e.g. http://44.238.19.217 or http://fullnode.mysite.com
        node_url: Query<Url>,
        /// If given, we will assume the metrics service is available at the given port.
        metrics_port: Query<Option<u16>>,
        /// If given, we will assume the API is available at the given port.
        api_port: Query<Option<u16>>,
        /// If given, we will assume that clients can communicate with your node via noise at the given port.
        noise_port: Query<Option<u16>>,
        /// A public key for the node, e.g. 0x44fd1324c66371b4788af0b901c9eb8088781acb29e6b8b9c791d5d9838fbe1f.
        /// This is only necessary for certain checkers, e.g. HandshakeChecker.
        public_key: Query<Option<String>>,
    ) -> poem::Result<Json<CheckSummary>> {
```

**File:** ecosystem/node-checker/src/configuration/validate.rs (L24-27)
```rust
pub fn validate_configuration(node_configuration: &BaselineConfiguration) -> Result<()> {
    build_checkers(&node_configuration.checkers).context("Failed to build Checkers")?;
    Ok(())
}
```
