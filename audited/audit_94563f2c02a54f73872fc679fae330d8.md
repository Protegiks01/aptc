# Audit Report

## Title
EventFilter Empty String Bypass Enables Universal Event Matching in Indexer GRPC

## Summary
The `EventFilter` struct in the indexer-grpc transaction filter system fails to validate empty strings in the `data_substring_filter` field. An attacker can exploit this by setting `data_substring_filter` to an empty string, which passes validation but matches all events due to the behavior of the `memchr::memmem::Finder` substring search algorithm. This allows clients to bypass intended filtering restrictions and receive all transactions with events, causing resource exhaustion and unauthorized data access within the indexer service.

## Finding Description

The vulnerability exists in the validation and matching logic of the `EventFilter` struct. The root cause involves three critical code paths:

**1. Insufficient Validation:** [1](#0-0) 

The `Filterable<String>` implementation for `Option<String>` has a `validate_state()` method that unconditionally returns `Ok(())`, performing no validation on the string content, including empty strings.

**2. Filter Validation Bypass:** [2](#0-1) 

The `EventFilter` validation only checks that at least one of `data_substring_filter` or `struct_type` is set (not None), but doesn't validate whether the string is empty. An attacker can set `data_substring_filter: Some("")` and `struct_type: None`, which passes this validation.

**3. Universal Matching with Empty String:** [3](#0-2) 

The matching logic uses `memchr::memmem::Finder::new(data_substring_filter)` for substring search. When the pattern is an empty string, the Finder matches at position 0 of any byte sequence, causing `finder.find(item.data.as_bytes())` to always return `Some(0)` instead of `None`. This means the filter never rejects any event.

**Attack Flow:**

1. Client constructs a `GetTransactionsRequest` with a malicious filter: [4](#0-3) 

2. The filter is parsed without validation: [5](#0-4) 

3. The filter is applied to stream transactions: [6](#0-5) 

4. All transactions with events pass the filter, bypassing intended restrictions.

## Impact Explanation

**Severity: Medium**

This vulnerability affects the indexer-grpc data service infrastructure, not the core blockchain consensus or execution layer. The impacts include:

1. **Resource Exhaustion**: Attackers can force the indexer service to transmit all transactions with events instead of a filtered subset, consuming excessive bandwidth, CPU, and memory on both server and client sides.

2. **Data Access Bypass**: Clients may be able to access event data that should be filtered according to their subscription parameters, potentially exposing sensitive application-level information.

3. **Service Degradation**: Multiple malicious clients exploiting this vulnerability could degrade indexer service performance for legitimate users.

This qualifies as **Medium severity** under the Aptos Bug Bounty program as it causes "state inconsistencies requiring intervention" at the indexer service level, though it does not affect blockchain consensus, validator operations, or on-chain funds.

## Likelihood Explanation

**Likelihood: High**

The vulnerability is trivially exploitable:
- No special privileges or authentication bypass required
- Simple parameter manipulation in a standard gRPC request
- No complex timing or race conditions
- Immediate effect without requiring specific blockchain state

The attack vector is straightforward: any client with access to the indexer-grpc service can send a malicious filter. The only barrier is discovering that empty strings bypass validation, which is a common vulnerability pattern.

## Recommendation

Add explicit empty string validation in the `EventFilter::validate_state()` method: [2](#0-1) 

Modify the validation to check for empty strings:

```rust
fn validate_state(&self) -> Result<(), FilterError> {
    if self.data_substring_filter.is_none() && self.struct_type.is_none() {
        return Err(Error::msg("At least one of data or struct_type must be set").into());
    }
    
    // Add empty string validation
    if let Some(filter) = &self.data_substring_filter {
        if filter.is_empty() {
            return Err(Error::msg("data_substring_filter cannot be empty").into());
        }
    }

    self.data_substring_filter.is_valid()?;
    self.struct_type.is_valid()?;
    Ok(())
}
```

Additionally, consider implementing validation in the `Filterable<String>` trait for `Option<String>` to catch similar issues system-wide: [1](#0-0) 

## Proof of Concept

```rust
#[cfg(test)]
mod test {
    use super::*;
    use aptos_protos::transaction::v1::{Event, MoveType, move_type::Content, MoveStructTag};

    #[test]
    fn test_empty_string_bypass() {
        // Create an EventFilter with empty data_substring_filter
        let filter = EventFilter {
            data_substring_filter: Some("".to_string()),
            struct_type: None,
            data_substring_finder: OnceCell::new(),
        };
        
        // Validation should fail but currently passes
        assert!(filter.validate_state().is_ok(), "Empty string bypasses validation");
        
        // Create a test event with arbitrary data
        let event = Event {
            key: None,
            sequence_number: 0,
            r#type: Some(MoveType {
                content: Some(Content::Struct(MoveStructTag {
                    address: "0x1".to_string(),
                    module: "test".to_string(),
                    name: "TestEvent".to_string(),
                    generic_type_params: vec![],
                })),
            }),
            type_str: "0x1::test::TestEvent".to_string(),
            data: "{\"field\":\"value\"}".to_string(),
        };
        
        // Empty string should NOT match, but currently does
        assert!(filter.matches(&event), "Empty string matches all events - VULNERABILITY");
        
        // Test with event that has completely different data
        let event2 = Event {
            key: None,
            sequence_number: 1,
            r#type: Some(MoveType {
                content: Some(Content::Struct(MoveStructTag {
                    address: "0x2".to_string(),
                    module: "other".to_string(),
                    name: "OtherEvent".to_string(),
                    generic_type_params: vec![],
                })),
            }),
            type_str: "0x2::other::OtherEvent".to_string(),
            data: "completely different data".to_string(),
        };
        
        assert!(filter.matches(&event2), "Empty string universally matches - CONFIRMED BYPASS");
    }
}
```

## Notes

**Scope Clarification:** This vulnerability exists in the indexer-grpc subsystem, which is an off-chain data indexing service separate from the core Aptos blockchain consensus, execution, and state management layers. While it does not directly impact blockchain security or validator operations, it represents a significant issue for the indexer infrastructure that many applications depend on for accessing blockchain data.

The indexer-grpc service is designed to optimize resource usage by allowing clients to filter transaction streams. This vulnerability undermines that design goal and can be exploited to cause resource exhaustion and unauthorized data access within the indexer service layer.

### Citations

**File:** ecosystem/indexer-grpc/transaction-filter/src/traits.rs (L108-121)
```rust
impl Filterable<String> for Option<String> {
    #[inline]
    fn validate_state(&self) -> Result<(), FilterError> {
        Ok(())
    }

    #[inline]
    fn matches(&self, item: &String) -> bool {
        match self {
            Some(filter) => filter == item,
            None => true,
        }
    }
}
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/filters/event.rs (L65-73)
```rust
    fn validate_state(&self) -> Result<(), FilterError> {
        if self.data_substring_filter.is_none() && self.struct_type.is_none() {
            return Err(Error::msg("At least one of data or struct_type must be set").into());
        };

        self.data_substring_filter.is_valid()?;
        self.struct_type.is_valid()?;
        Ok(())
    }
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/filters/event.rs (L89-96)
```rust
        if let Some(data_substring_filter) = self.data_substring_filter.as_ref() {
            let finder = self
                .data_substring_finder
                .get_or_init(|| Finder::new(data_substring_filter).into_owned());
            if finder.find(item.data.as_bytes()).is_none() {
                return false;
            }
        }
```

**File:** protos/proto/aptos/indexer/v1/raw_data.proto (L19-33)
```text
message GetTransactionsRequest {
  // Required; start version of current stream.
  optional uint64 starting_version = 1 [jstype = JS_STRING];

  // Optional; number of transactions to return in current stream.
  // If not present, return an infinite stream of transactions.
  optional uint64 transactions_count = 2 [jstype = JS_STRING];

  // Optional; number of transactions in each `TransactionsResponse` for current stream.
  // If not present, default to 1000. If larger than 1000, request will be rejected.
  optional uint64 batch_size = 3;

  // If provided, only transactions that match the filter will be included.
  optional BooleanTransactionFilter transaction_filter = 4;
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/filter_utils.rs (L9-15)
```rust
pub fn parse_transaction_filter(
    proto_filter: aptos_protos::indexer::v1::BooleanTransactionFilter,
    max_filter_size_bytes: usize,
) -> Result<BooleanTransactionFilter, Status> {
    BooleanTransactionFilter::new_from_proto(proto_filter, Some(max_filter_size_bytes))
        .map_err(|e| Status::invalid_argument(format!("Invalid transaction_filter: {e:?}.")))
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/stream_coordinator.rs (L175-182)
```rust
                let pb_txns = if let Some(ref filter) = filter {
                    pb_txns
                        .into_iter()
                        .filter(|txn| filter.matches(txn))
                        .collect::<Vec<_>>()
                } else {
                    pb_txns
                };
```
