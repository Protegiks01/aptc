# Audit Report

## Title
Complete Absence of Cryptographic Verification in Aptos REST Client: Clients Forced to Blindly Trust Server Data

## Summary
The Aptos REST client (`aptos-rest-client`) provides no mechanism for clients to cryptographically verify that data received from the REST server matches the claimed ledger state. The `Response<T>` struct contains data and metadata (`State`) extracted from HTTP headers, but lacks Merkle proofs, validator signatures, or transaction accumulator hashes necessary for trustless verification. This forces clients to completely trust the REST server operator, enabling trivial data manipulation attacks.

## Finding Description
The vulnerability exists across multiple layers of the REST API architecture:

**1. Response Structure Provides No Proof Data:**

The `Response<T>` struct only contains the inner data `T` and a `State` object with metadata. [1](#0-0) 

**2. State Contains Only Unauthenticated Metadata:**

The `State` struct extracted from HTTP headers contains ledger metadata (chain_id, epoch, version, timestamp, block_height) but no cryptographic commitments. [2](#0-1) 

**3. API's LedgerInfo Strips All Cryptographic Data:**

When the REST API constructs responses, it converts `LedgerInfoWithSignatures` (which contains validator signatures and transaction accumulator hash) into a bare `LedgerInfo` type that only preserves metadata fields. [3](#0-2) 

The conversion function extracts only metadata, discarding signatures: [4](#0-3) 

**4. Response Headers Lack Cryptographic Commitments:**

The REST API response headers only include metadata fields, not the transaction accumulator hash (Merkle root) or BLS signatures that would enable verification. [5](#0-4) 

**Attack Scenario:**

1. Attacker operates or compromises a REST API endpoint
2. Client queries account balance at `https://malicious-api.example.com/v1/accounts/0x123/resource/0x1::coin::CoinStore<0x1::aptos_coin::AptosCoin>`
3. Server returns fabricated response:
   - `"value": "999999999999"` (fake balance)
   - HTTP headers: `X-Aptos-Ledger-Version: 1234567` (arbitrary version)
4. Client receives `Response<MoveResource>` with fake data
5. Client has **no mechanism** to:
   - Verify the data is in the Merkle tree at the claimed version
   - Verify the claimed version is signed by 2f+1 validators
   - Detect any tampering

This violates **Invariant #4: State Consistency** which requires "State transitions must be atomic and verifiable via Merkle proofs." [6](#0-5) 

The blockchain's internal `LedgerInfo` struct contains `transaction_accumulator_hash()` which is the Merkle root, and `LedgerInfoWithSignatures` contains BLS signatures, but these are never exposed to REST clients. [7](#0-6) 

## Impact Explanation
**Severity: CRITICAL** (up to $1,000,000 per Aptos Bug Bounty)

This qualifies as Critical severity under multiple categories:

1. **Loss of Funds**: Clients can be tricked into believing incorrect account balances, leading to:
   - Accepting payments that never occurred
   - Trading on fake asset balances
   - Executing transactions based on false state assumptions

2. **Consensus/Safety Violation**: Different clients querying different malicious servers can have incompatible views of chain state, breaking global consensus from the client perspective.

3. **Complete Loss of Trustlessness**: The fundamental value proposition of blockchain—trustless verification—is eliminated. Clients must trust intermediaries exactly as in traditional centralized systems.

The impact extends to all REST client users including:
- Wallet applications
- DeFi protocols querying state
- Indexers and analytics tools
- Any application using the official Aptos REST client

## Likelihood Explanation
**Likelihood: HIGH**

Exploitation requires:
- Running a malicious REST endpoint (trivial)
- Modifying response data (trivial)
- Waiting for clients to connect (depends on adoption)

The attack is **trivially exploitable** with no technical barriers. Any party can:
- Run a malicious REST API node
- Advertise it as a "fast" or "reliable" endpoint
- Manipulate all responses without detection

The likelihood increases as:
- More users rely on public REST endpoints instead of running full nodes
- More applications are built on top of the REST client
- Attackers realize there is no verification mechanism

## Recommendation
Implement trustless verification in the REST API by:

**1. Extend Response Structure:**
```rust
pub struct Response<T> {
    inner: T,
    state: State,
    proof: Option<StateProof>,  // Add proof field
}

pub struct StateProof {
    ledger_info_with_sigs: LedgerInfoWithSignatures,
    state_merkle_proof: SparseMerkleProof,
}
```

**2. Add API Endpoints for Proofs:**
- `GET /accounts/{address}/resource/{type}?with_proof=true` - Return data with Merkle proof
- `GET /ledger_info` - Return full `LedgerInfoWithSignatures` including validator signatures

**3. Add Verification Methods:**
```rust
impl<T> Response<T> {
    pub fn verify(&self, validator_set: &ValidatorVerifier, expected_root: HashValue) -> Result<bool> {
        // Verify validator signatures on LedgerInfo
        // Verify Merkle proof against transaction accumulator hash
        // Return true only if both verifications pass
    }
}
```

**4. Provide Client Configuration:**
```rust
let client = Client::builder(url)
    .require_proofs(true)  // Force proof verification
    .validator_set(genesis_validator_set)
    .build();
```

**5. Document Trust Model:**
Add explicit documentation warning that without proof verification, clients must trust the REST server operator completely.

## Proof of Concept
```rust
// Demonstration of undetectable data manipulation
use aptos_rest_client::Client;
use aptos_types::account_address::AccountAddress;

#[tokio::test]
async fn test_unverifiable_response() {
    // Setup: Run malicious REST server on localhost:8080
    // that returns fake balances
    
    let malicious_url = "http://localhost:8080".parse().unwrap();
    let client = Client::new(malicious_url);
    let address = AccountAddress::from_hex_literal("0x1").unwrap();
    
    // Query balance from malicious server
    let response = client.get_account_balance(
        address,
        "0x1::aptos_coin::AptosCoin"
    ).await.unwrap();
    
    let balance = response.inner();
    let state = response.state();
    
    // Client receives data but CANNOT verify:
    // 1. That this balance is actually in the state tree
    // 2. That the state tree root is signed by validators
    // 3. That the ledger_version claim is authentic
    
    println!("Received balance: {}", balance);
    println!("Claimed version: {}", state.version);
    
    // NO VERIFICATION POSSIBLE - client must blindly trust server
    // Malicious server can return ANY balance and ANY version
    
    assert!(true); // This will pass even with fake data!
}
```

**Malicious Server PoC:**
```rust
// Attacker's fake REST server
#[get("/accounts/{address}/balance/{asset_type}")]
async fn fake_balance() -> (Json<u64>, HeaderMap) {
    let mut headers = HeaderMap::new();
    headers.insert("X-Aptos-Ledger-Version", "999999999".parse().unwrap());
    headers.insert("X-Aptos-Chain-Id", "1".parse().unwrap());
    headers.insert("X-Aptos-Epoch", "100".parse().unwrap());
    
    // Return fake balance - client cannot detect tampering
    (Json(999_999_999_999_u64), headers)
}
```

## Notes
While the Aptos codebase contains comprehensive Merkle proof mechanisms (in `types/src/proof/`, `storage/aptosdb/`, `storage/jellyfish-merkle/`), these are only used internally for state-sync between nodes and are not exposed through the public REST API. The backup service has proof endpoints (`storage/backup/backup-service/`), but these are separate from the main REST API and not documented for client use. This creates a critical trust assumption that contradicts blockchain's fundamental trustless design principle.

### Citations

**File:** crates/aptos-rest-client/src/response.rs (L6-10)
```rust
#[derive(Debug)]
pub struct Response<T> {
    inner: T,
    state: State,
}
```

**File:** crates/aptos-rest-client/src/state.rs (L11-20)
```rust
pub struct State {
    pub chain_id: u8,
    pub epoch: u64,
    pub version: u64,
    pub timestamp_usecs: u64,
    pub oldest_ledger_version: u64,
    pub oldest_block_height: u64,
    pub block_height: u64,
    pub cursor: Option<String>,
}
```

**File:** api/types/src/ledger_info.rs (L11-20)
```rust
pub struct LedgerInfo {
    /// Chain ID of the current chain
    pub chain_id: u8,
    pub epoch: U64,
    pub ledger_version: U64,
    pub oldest_ledger_version: U64,
    pub block_height: U64,
    pub oldest_block_height: U64,
    pub ledger_timestamp: U64,
}
```

**File:** api/types/src/ledger_info.rs (L22-40)
```rust
impl LedgerInfo {
    pub fn new(
        chain_id: &ChainId,
        info: &LedgerInfoWithSignatures,
        oldest_ledger_version: u64,
        oldest_block_height: u64,
        block_height: u64,
    ) -> Self {
        let ledger_info = info.ledger_info();
        Self {
            chain_id: chain_id.id(),
            epoch: U64::from(ledger_info.epoch()),
            ledger_version: ledger_info.version().into(),
            oldest_ledger_version: oldest_ledger_version.into(),
            block_height: block_height.into(),
            oldest_block_height: oldest_block_height.into(),
            ledger_timestamp: ledger_info.timestamp_usecs().into(),
        }
    }
```

**File:** api/src/response.rs (L322-349)
```rust
        pub enum $enum_name<T: poem_openapi::types::ToJSON + Send + Sync> {
            $(
            #[oai(status = $status)]
            $name(
                // We use just regular u64 here instead of U64 since all header
                // values are implicitly strings anyway.
                $crate::response::AptosResponseContent<T>,
                /// Chain ID of the current chain
                #[oai(header = "X-Aptos-Chain-Id")] u8,
                /// Current ledger version of the chain
                #[oai(header = "X-Aptos-Ledger-Version")] u64,
                /// Oldest non-pruned ledger version of the chain
                #[oai(header = "X-Aptos-Ledger-Oldest-Version")] u64,
                /// Current timestamp of the chain
                #[oai(header = "X-Aptos-Ledger-TimestampUsec")] u64,
                /// Current epoch of the chain
                #[oai(header = "X-Aptos-Epoch")] u64,
                /// Current block height of the chain
                #[oai(header = "X-Aptos-Block-Height")] u64,
                /// Oldest non-pruned block height of the chain
                #[oai(header = "X-Aptos-Oldest-Block-Height")] u64,
                /// The cost of the call in terms of gas
                #[oai(header = "X-Aptos-Gas-Used")] Option<u64>,
                /// Cursor to be used for endpoints that support cursor-based
                /// pagination. Pass this to the `start` field of the endpoint
                /// on the next call to get the next page of results.
                #[oai(header = "X-Aptos-Cursor")] Option<String>,
            ),
```

**File:** types/src/ledger_info.rs (L34-59)
```rust
/// This structure serves a dual purpose.
///
/// First, if this structure is signed by 2f+1 validators it signifies the state of the ledger at
/// version `version` -- it contains the transaction accumulator at that version which commits to
/// all historical transactions. This structure may be expanded to include other information that
/// is derived from that accumulator (e.g. the current time according to the time contract) to
/// reduce the number of proofs a client must get.
///
/// Second, the structure contains a `consensus_data_hash` value. This is the hash of an internal
/// data structure that represents a block that is voted on in Consensus. If 2f+1 signatures are
/// gathered on the same ledger info that represents a Quorum Certificate (QC) on the consensus
/// data.
///
/// Combining these two concepts, when a validator votes on a block, B it votes for a
/// LedgerInfo with the `version` being the latest version that will be committed if B gets 2f+1
/// votes. It sets `consensus_data_hash` to represent B so that if those 2f+1 votes are gathered a
/// QC is formed on B.
#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize, CryptoHasher, BCSCryptoHash)]
#[cfg_attr(any(test, feature = "fuzzing"), derive(Arbitrary))]
pub struct LedgerInfo {
    commit_info: BlockInfo,

    /// Hash of consensus specific data that is opaque to all parts of the system other than
    /// consensus.
    consensus_data_hash: HashValue,
}
```

**File:** types/src/ledger_info.rs (L235-246)
```rust
/// The validator node returns this structure which includes signatures
/// from validators that confirm the state.  The client needs to only pass back
/// the LedgerInfo element since the validator node doesn't need to know the signatures
/// again when the client performs a query, those are only there for the client
/// to be able to verify the state
#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]
pub struct LedgerInfoWithV0 {
    ledger_info: LedgerInfo,
    /// Aggregated BLS signature of all the validators that signed the message. The bitmask in the
    /// aggregated signature can be used to find out the individual validators signing the message
    signatures: AggregateSignature,
}
```
