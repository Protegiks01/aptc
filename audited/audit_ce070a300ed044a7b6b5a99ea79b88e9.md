# Audit Report

## Title
Inline Batches Bypass ProofOfStore Verification Allowing Single Validator to Include Unverified Transactions

## Summary
The `ProposalMsg::verify()` function fails to verify that inline batches in `QuorumStoreInlineHybrid` and `QuorumStoreInlineHybridV2` payloads have received quorum approval via ProofOfStore. While batches referenced by proofs undergo multi-signature verification through ProofCache, inline batches are only validated by digest matching, allowing a malicious proposer to include locally-created batches without network dissemination or quorum consensus.

## Finding Description

The Aptos quorum store implements a two-tier batch inclusion mechanism in proposals:

1. **Proof-verified batches**: Batches with `ProofOfStore` that contain multi-signatures from a quorum of validators
2. **Inline batches**: Batches included directly with transactions but without `ProofOfStore`

The vulnerability exists in how these batch types are verified: [1](#0-0) 

The `verify()` function calls `payload.verify()` for validation. For `QuorumStoreInlineHybrid` payloads: [2](#0-1) 

The verification splits into two paths:
- `verify_with_cache()` for `proof_with_data.proofs` - performs multi-signature verification
- `verify_inline_batches()` for inline batches - only checks digest matching [3](#0-2) 

The `verify_inline_batches()` function only validates that the computed digest matches the `BatchInfo` digest. It does NOT verify:
- ProofOfStore multi-signatures
- Quorum approval
- Network dissemination to other validators

The proposer creates payloads that include inline batches when `allow_batches_without_pos_in_proposal` is enabled: [4](#0-3) 

These inline batches are explicitly pulled from batches **without proofs**: [5](#0-4) 

The `pull_batches_internal()` function calls `pull_internal()` with `batches_without_proofs = true` (line 501), explicitly selecting batches that lack ProofOfStore.

**Attack Scenario:**
1. Malicious Validator A becomes proposer for round X
2. Validator A creates batches locally through `BatchGenerator` with arbitrary transactions
3. These batches are stored in local `batch_store` but NOT broadcast or approved by quorum
4. When `allow_batches_without_pos_in_proposal` is enabled and proof queue is full, Validator A includes these batches as inline batches
5. Other validators verify the proposal and only check digest matching for inline batches
6. The proposal is accepted with transactions that never received quorum approval
7. Transactions execute without the distributed validation that QuorumStore is designed to provide

This breaks the fundamental quorum store invariant that batches should be certified by multiple validators before inclusion.

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos bug bounty program as a "Significant protocol violation."

**Consensus Safety Impact:**
- Single malicious proposer can bypass the quorum approval mechanism
- Violates the QuorumStore design principle requiring distributed batch certification
- Enables censorship attacks where proposer excludes competing validators' transactions
- Allows unilateral inclusion of transactions that might be rejected by honest validators

**Byzantine Fault Tolerance Compromise:**
- The system is designed to tolerate up to 1/3 Byzantine validators
- However, when a Byzantine validator is proposer, they can unilaterally include uncertified batches
- This reduces the security guarantee from "requires quorum approval" to "requires single proposer approval"

**Potential Attack Vectors:**
1. **Censorship**: Proposer includes only their own transactions via inline batches
2. **Resource Exhaustion**: Proposer includes expensive/malicious transactions
3. **State Divergence**: If validators have different mempool states, inline batches could cause execution differences

## Likelihood Explanation

**Likelihood: High**

The attack is highly feasible because:

1. **Every validator becomes proposer**: In round-robin leader election, every validator eventually becomes proposer
2. **Feature is enabled by default**: The `allow_batches_without_pos_in_proposal` configuration flag enables this optimization
3. **Proof queue fills naturally**: Under normal load, the proof queue becomes fully utilized, triggering inline batch inclusion
4. **No additional privileges required**: Any validator can exploit this during their proposer turn
5. **Detection is difficult**: Inline batches appear valid through digest verification, making the attack subtle

The vulnerability is **always active** when the configuration flag is enabled and proof queue utilization is high, which are normal operating conditions.

## Recommendation

**Solution: Require ProofOfStore verification for all batches, including inline batches**

Option 1 - Strict Verification (Recommended):
Remove inline batch support entirely or require that inline batches also have ProofOfStore. Modify the verification:

```rust
// In common.rs verify() function for QuorumStoreInlineHybrid
(true, Payload::QuorumStoreInlineHybrid(inline_batches, proof_with_data, _))
| (true, Payload::QuorumStoreInlineHybridV2(inline_batches, proof_with_data, _)) => {
    Self::verify_with_cache(&proof_with_data.proofs, verifier, proof_cache)?;
    Self::verify_inline_batches(
        inline_batches.iter().map(|(info, txns)| (info, txns)),
    )?;
    
    // ADD THIS: Verify inline batches are also in proof_cache
    for (batch_info, _) in inline_batches {
        let batch_info_ext: BatchInfoExt = batch_info.clone().into();
        ensure!(
            proof_cache.get(&batch_info_ext).is_some(),
            "Inline batch {} must have ProofOfStore",
            batch_info.digest()
        );
    }
    
    Ok(())
},
```

Option 2 - Disable Feature:
Set `allow_batches_without_pos_in_proposal = false` in configuration to prevent inline batch inclusion until proper verification is implemented.

Option 3 - Additional Validation:
Require that inline batches were received from the network (not locally created) and add timestamp/age verification to ensure they've had time for network dissemination.

## Proof of Concept

**Reproduction Steps:**

1. Set up a test network with 4 validators
2. Configure `allow_batches_without_pos_in_proposal = true`
3. Fill the proof queue to trigger inline batch inclusion
4. As proposer, create a local batch with test transactions
5. Do NOT broadcast the batch or obtain ProofOfStore
6. Include the batch as an inline batch in a proposal
7. Observe that other validators accept the proposal with only digest verification
8. Verify that the transactions execute without quorum approval

**Rust Test Skeleton:**
```rust
#[test]
fn test_inline_batch_bypasses_proof_verification() {
    // Setup: Create validator and batch_store
    let validator = create_test_validator();
    let batch_store = Arc::new(BatchStore::new(...));
    
    // Step 1: Create a local batch without broadcasting
    let batch = create_local_batch(validator.peer_id(), test_transactions());
    batch_store.save_local(batch.clone());
    
    // Step 2: Create proposal with inline batch (no ProofOfStore)
    let inline_batches = vec![(batch.info().clone(), batch.transactions())];
    let payload = Payload::QuorumStoreInlineHybrid(
        inline_batches,
        ProofWithData::new(vec![]), // Empty proofs
        None
    );
    
    let proposal = create_proposal(payload);
    let proof_cache = ProofCache::new();
    
    // Step 3: Verify proposal - should accept despite no ProofOfStore
    let result = proposal.verify(
        validator.peer_id(),
        &validator_verifier,
        &proof_cache,
        true // quorum_store_enabled
    );
    
    // BUG: This passes even though inline batch has no ProofOfStore
    assert!(result.is_ok()); 
    
    // Verification: Check that batch is NOT in ProofCache
    assert!(proof_cache.get(&batch.info().clone().into()).is_none());
}
```

## Notes

This vulnerability specifically affects the `QuorumStoreInlineHybrid` and `QuorumStoreInlineHybridV2` payload variants when `allow_batches_without_pos_in_proposal` is enabled. The `OptQuorumStore` variant also has inline batches but follows similar verification patterns. The root cause is the asymmetric verification requirements between proof-referenced batches (require ProofOfStore) and inline batches (only require digest matching), creating a bypass mechanism for the quorum approval requirement.

### Citations

**File:** consensus/consensus-types/src/proposal_msg.rs (L82-118)
```rust
    pub fn verify(
        &self,
        sender: Author,
        validator: &ValidatorVerifier,
        proof_cache: &ProofCache,
        quorum_store_enabled: bool,
    ) -> Result<()> {
        if let Some(proposal_author) = self.proposal.author() {
            ensure!(
                proposal_author == sender,
                "Proposal author {:?} doesn't match sender {:?}",
                proposal_author,
                sender
            );
        }
        let (payload_result, sig_result) = rayon::join(
            || {
                self.proposal().payload().map_or(Ok(()), |p| {
                    p.verify(validator, proof_cache, quorum_store_enabled)
                })
            },
            || {
                self.proposal()
                    .validate_signature(validator)
                    .map_err(|e| format_err!("{:?}", e))
            },
        );
        payload_result?;
        sig_result?;

        // if there is a timeout certificate, verify its signatures
        if let Some(tc) = self.sync_info.highest_2chain_timeout_cert() {
            tc.verify(validator).map_err(|e| format_err!("{:?}", e))?;
        }
        // Note that we postpone the verification of SyncInfo until it's being used.
        self.verify_well_formed()
    }
```

**File:** consensus/consensus-types/src/common.rs (L541-556)
```rust
    pub fn verify_inline_batches<'a, T: TBatchInfo + 'a>(
        inline_batches: impl Iterator<Item = (&'a T, &'a Vec<SignedTransaction>)>,
    ) -> anyhow::Result<()> {
        for (batch, payload) in inline_batches {
            // TODO: Can cloning be avoided here?
            let computed_digest = BatchPayload::new(batch.author(), payload.clone()).hash();
            ensure!(
                computed_digest == *batch.digest(),
                "Hash of the received inline batch doesn't match the digest value for batch {:?}: {} != {}",
                batch,
                computed_digest,
                batch.digest()
            );
        }
        Ok(())
    }
```

**File:** consensus/consensus-types/src/common.rs (L590-597)
```rust
            (true, Payload::QuorumStoreInlineHybrid(inline_batches, proof_with_data, _))
            | (true, Payload::QuorumStoreInlineHybridV2(inline_batches, proof_with_data, _)) => {
                Self::verify_with_cache(&proof_with_data.proofs, verifier, proof_cache)?;
                Self::verify_inline_batches(
                    inline_batches.iter().map(|(info, txns)| (info, txns)),
                )?;
                Ok(())
            },
```

**File:** consensus/src/quorum_store/proof_manager.rs (L155-184)
```rust
        let (inline_block, inline_block_size) =
            if self.allow_batches_without_pos_in_proposal && proof_queue_fully_utilized {
                let mut max_inline_txns_to_pull = request
                    .max_txns
                    .saturating_sub(cur_txns)
                    .minimum(request.max_inline_txns);
                max_inline_txns_to_pull.set_count(min(
                    max_inline_txns_to_pull.count(),
                    request
                        .max_txns_after_filtering
                        .saturating_sub(cur_unique_txns),
                ));
                let (inline_batches, inline_payload_size, _) =
                    self.batch_proof_queue.pull_batches_with_transactions(
                        &excluded_batches
                            .iter()
                            .cloned()
                            .chain(proof_block.iter().map(|proof| proof.info().clone()))
                            .chain(opt_batches.clone())
                            .collect(),
                        max_inline_txns_to_pull,
                        request.max_txns_after_filtering,
                        request.soft_max_txns_after_filtering,
                        request.return_non_full,
                        request.block_timestamp,
                    );
                (inline_batches, inline_payload_size)
            } else {
                (Vec::new(), PayloadTxnsSize::zero())
            };
```

**File:** consensus/src/quorum_store/batch_proof_queue.rs (L489-513)
```rust
    pub fn pull_batches_internal(
        &mut self,
        excluded_batches: &HashSet<BatchInfoExt>,
        exclude_authors: &HashSet<Author>,
        max_txns: PayloadTxnsSize,
        max_txns_after_filtering: u64,
        soft_max_txns_after_filtering: u64,
        return_non_full: bool,
        block_timestamp: Duration,
        minimum_batch_age_usecs: Option<u64>,
    ) -> (Vec<BatchInfoExt>, PayloadTxnsSize, u64, bool) {
        let (result, all_txns, unique_txns, is_full) = self.pull_internal(
            true,
            excluded_batches,
            exclude_authors,
            max_txns,
            max_txns_after_filtering,
            soft_max_txns_after_filtering,
            return_non_full,
            block_timestamp,
            minimum_batch_age_usecs,
        );
        let batches = result.into_iter().map(|item| item.info.clone()).collect();
        (batches, all_txns, unique_txns, is_full)
    }
```
