# Audit Report

## Title
Inspection Service Configuration Endpoint Lacks Authentication Allowing Unauthorized Node Configuration Disclosure

## Summary
The Aptos Inspection Service exposes a `/configuration` endpoint that returns the complete `NodeConfig` structure without any authentication mechanism. Any network peer that can reach port 9101 (default) can retrieve sensitive operational information when `expose_configuration` is enabled, including network topology, peer addresses, service ports, and internal configurations.

## Finding Description
The inspection service handles HTTP requests through the `serve_requests()` function, which routes requests to various handlers based on URI path. [1](#0-0) 

When a request is made to `/configuration`, it directly calls `handle_configuration_request()` without any authentication checks. [2](#0-1) 

The function only checks if the `expose_configuration` flag is enabled, and if so, returns the entire `NodeConfig` structure serialized using debug formatting. While private keys are protected by `SilentDisplay` and `SilentDebug` traits, the configuration still exposes:

- Complete network configuration including validator and fullnode networks [3](#0-2) 
- Network seed peer addresses and topology information [4](#0-3) 
- All internal service ports, addresses, and configurations
- Consensus, storage, execution, and mempool configurations
- Node role (validator vs fullnode) and data directory paths

The service binds to `0.0.0.0:9101` by default, making it accessible from any network interface. [5](#0-4) 

In contrast, the Admin Service implements proper authentication using PasscodeSha256, requiring authentication before allowing access to sensitive endpoints. [6](#0-5) 

## Impact Explanation
This vulnerability constitutes a **High Severity** information disclosure issue according to Aptos bug bounty criteria. While the direct impact is information leakage, the exposed data enables targeted attacks that could lead to:

1. **Validator node slowdowns**: An attacker armed with complete network topology, peer addresses, and service configurations can launch precision attacks against specific services or exploit configuration weaknesses to degrade node performance.

2. **API crashes**: Knowledge of exact API configurations, ports, and internal service architecture allows attackers to craft targeted requests that could trigger API crashes or resource exhaustion.

3. **Network reconnaissance**: Exposure of seed peers, network addresses, and peer discovery configurations reveals the entire network topology, enabling sophisticated attacks against the P2P network layer.

While mainnet validators have a configuration sanitizer that prevents enabling `expose_configuration`, [7](#0-6)  this protection is configuration-based, not runtime authentication-based. Non-mainnet nodes automatically enable this endpoint, [8](#0-7)  and any misconfigured mainnet node would expose all operational data without authentication.

## Likelihood Explanation
**Likelihood: High**

1. The inspection service is enabled by default on all nodes
2. For non-mainnet nodes (testnet, devnet), `expose_configuration` is automatically enabled by the config optimizer
3. The service binds to all interfaces (0.0.0.0) by default
4. No authentication credentials are required - only network reachability to port 9101
5. Operators may be unaware their configuration is publicly accessible, as tests confirm the endpoint works without any credentials [9](#0-8) 

The attack requires only:
- Network access to the node's inspection service port (9101)
- Sending a simple HTTP GET request to `/configuration`
- The `expose_configuration` flag being enabled (automatic for non-mainnet)

## Recommendation
Implement authentication for the inspection service configuration endpoint, similar to the Admin Service authentication mechanism:

1. Add an `authentication_configs` field to `InspectionServiceConfig`
2. Implement authentication checks in `serve_requests()` before routing to sensitive endpoints
3. Return `StatusCode::NETWORK_AUTHENTICATION_REQUIRED` when authentication fails
4. Require authentication for the `/configuration` endpoint even when `expose_configuration` is enabled
5. Consider defaulting to authentication-required for all endpoints, with explicit opt-out for trusted environments

Alternative recommendations:
- Bind the inspection service to localhost (127.0.0.1) by default instead of 0.0.0.0
- Add IP allowlisting capabilities to restrict access to trusted networks
- Implement TLS with mutual authentication for the inspection service

## Proof of Concept

```rust
// PoC: Accessing configuration without authentication
use hyper::{Body, Client, Request, Uri};

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let client = Client::new();
    
    // Target any Aptos node with inspection service enabled
    let uri: Uri = "http://<target-node-ip>:9101/configuration".parse()?;
    
    let req = Request::builder()
        .method("GET")
        .uri(uri)
        .body(Body::empty())?;
    
    let resp = client.request(req).await?;
    
    println!("Status: {}", resp.status());
    
    let body_bytes = hyper::body::to_bytes(resp.into_body()).await?;
    let body_str = String::from_utf8(body_bytes.to_vec())?;
    
    // If expose_configuration is enabled, this will contain:
    // - Complete NodeConfig with all network, consensus, storage configs
    // - Network topology and seed peer addresses
    // - All service ports and internal configurations
    println!("Configuration data: {}", body_str);
    
    Ok(())
}
```

**Notes**

The vulnerability is confirmed by examining the code flow: requests arrive at `serve_requests()`, are routed based on URI path without authentication checks, and `handle_configuration_request()` only verifies a boolean flag before returning sensitive data. The inconsistency with the Admin Service's authentication model and the default binding to all network interfaces amplify the security risk. While this is designed as a debugging tool, the lack of runtime authentication controls represents a significant operational security gap that could facilitate reconnaissance and targeted attacks against Aptos nodes.

### Citations

**File:** crates/aptos-inspection-service/src/server/mod.rs (L104-116)
```rust
async fn serve_requests(
    req: Request<Body>,
    node_config: NodeConfig,
    aptos_data_client: AptosDataClient,
    peers_and_metadata: Arc<PeersAndMetadata>,
) -> Result<Response<Body>, hyper::Error> {
    // Process the request and get the response components
    let (status_code, body, content_type) = match req.uri().path() {
        CONFIGURATION_PATH => {
            // /configuration
            // Exposes the node configuration
            configuration::handle_configuration_request(&node_config)
        },
```

**File:** crates/aptos-inspection-service/src/server/configuration.rs (L13-29)
```rust
pub fn handle_configuration_request(node_config: &NodeConfig) -> (StatusCode, Body, String) {
    // Only return configuration if the endpoint is enabled
    let (status_code, body) = if node_config.inspection_service.expose_configuration {
        // We format the configuration using debug formatting. This is important to
        // prevent secret/private keys from being serialized and leaked (i.e.,
        // all secret keys are marked with SilentDisplay and SilentDebug).
        let encoded_configuration = format!("{:?}", node_config);
        (StatusCode::OK, Body::from(encoded_configuration))
    } else {
        (
            StatusCode::FORBIDDEN,
            Body::from(CONFIGURATION_DISABLED_MESSAGE),
        )
    };

    (status_code, body, CONTENT_TYPE_TEXT.into())
}
```

**File:** config/src/config/node_config.rs (L37-92)
```rust
pub struct NodeConfig {
    #[serde(default)]
    pub admin_service: AdminServiceConfig,
    #[serde(default)]
    pub api: ApiConfig,
    #[serde(default)]
    pub base: BaseConfig,
    #[serde(default)]
    pub consensus: ConsensusConfig,
    #[serde(default)]
    pub consensus_observer: ConsensusObserverConfig,
    #[serde(default)]
    pub dag_consensus: DagConsensusConfig,
    #[serde(default)]
    pub dkg: DKGConfig,
    #[serde(default)]
    pub execution: ExecutionConfig,
    #[serde(default)]
    pub failpoints: Option<HashMap<String, String>>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub full_node_networks: Vec<NetworkConfig>,
    #[serde(default)]
    pub indexer: IndexerConfig,
    #[serde(default)]
    pub indexer_grpc: IndexerGrpcConfig,
    #[serde(default)]
    pub indexer_table_info: IndexerTableInfoConfig,
    #[serde(default)]
    pub inspection_service: InspectionServiceConfig,
    #[serde(default)]
    pub jwk_consensus: JWKConsensusConfig,
    #[serde(default)]
    pub logger: LoggerConfig,
    #[serde(default)]
    pub mempool: MempoolConfig,
    #[serde(default)]
    pub netbench: Option<NetbenchConfig>,
    #[serde(default)]
    pub node_startup: NodeStartupConfig,
    #[serde(default)]
    pub peer_monitoring_service: PeerMonitoringServiceConfig,
    /// In a randomness stall, set this to be on-chain `RandomnessConfigSeqNum` + 1.
    /// Once enough nodes restarted with the new value, the chain should unblock with randomness disabled.
    #[serde(default)]
    pub randomness_override_seq_num: u64,
    #[serde(default)]
    pub state_sync: StateSyncConfig,
    #[serde(default)]
    pub storage: StorageConfig,
    #[serde(default)]
    pub transaction_filters: TransactionFiltersConfig,
    #[serde(default)]
    pub validator_network: Option<NetworkConfig>,
    #[serde(default)]
    pub indexer_db_config: InternalIndexerDBConfig,
}
```

**File:** config/src/config/network_config.rs (L96-101)
```rust
    /// Addresses of initial peers to connect to. In a mutual_authentication network,
    /// we will extract the public keys from these addresses to set our initial
    /// trusted peers set.  TODO: Replace usage in configs with `seeds` this is for backwards compatibility
    pub seed_addrs: HashMap<PeerId, Vec<NetworkAddress>>,
    /// The initial peers to connect to prior to onchain discovery
    pub seeds: PeerSet,
```

**File:** config/src/config/inspection_service_config.rs (L26-36)
```rust
impl Default for InspectionServiceConfig {
    fn default() -> InspectionServiceConfig {
        InspectionServiceConfig {
            address: "0.0.0.0".to_string(),
            port: 9101,
            expose_configuration: false,
            expose_identity_information: true,
            expose_peer_information: true,
            expose_system_information: true,
        }
    }
```

**File:** config/src/config/inspection_service_config.rs (L54-64)
```rust
        // Verify that mainnet validators do not expose the configuration
        if let Some(chain_id) = chain_id {
            if node_type.is_validator()
                && chain_id.is_mainnet()
                && inspection_service_config.expose_configuration
            {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "Mainnet validators should not expose the node configuration!".to_string(),
                ));
            }
```

**File:** config/src/config/inspection_service_config.rs (L82-88)
```rust
        let mut modified_config = false;
        if let Some(chain_id) = chain_id {
            if !chain_id.is_mainnet() {
                if local_inspection_config_yaml["expose_configuration"].is_null() {
                    inspection_service_config.expose_configuration = true;
                    modified_config = true;
                }
```

**File:** crates/aptos-admin-service/src/server/mod.rs (L154-181)
```rust
        let mut authenticated = false;
        if context.config.authentication_configs.is_empty() {
            authenticated = true;
        } else {
            for authentication_config in &context.config.authentication_configs {
                match authentication_config {
                    AuthenticationConfig::PasscodeSha256(passcode_sha256) => {
                        let query = req.uri().query().unwrap_or("");
                        let query_pairs: HashMap<_, _> =
                            url::form_urlencoded::parse(query.as_bytes()).collect();
                        let passcode: Option<String> =
                            query_pairs.get("passcode").map(|p| p.to_string());
                        if let Some(passcode) = passcode {
                            if sha256::digest(passcode) == *passcode_sha256 {
                                authenticated = true;
                            }
                        }
                    },
                }
            }
        };

        if !authenticated {
            return Ok(reply_with_status(
                StatusCode::NETWORK_AUTHENTICATION_REQUIRED,
                format!("{} endpoint requires authentication.", req.uri().path()),
            ));
        }
```

**File:** crates/aptos-inspection-service/src/server/tests.rs (L48-59)
```rust
    // Enable the configuration endpoint and ping it
    node_config.inspection_service.expose_configuration = true;
    let mut response = send_get_request_to_path(&node_config, CONFIGURATION_PATH).await;
    let response_body = body::to_bytes(response.body_mut()).await.unwrap();
    let response_body_string = read_to_string(response_body.as_ref()).unwrap();

    // Verify that the response contains the expected information
    assert_eq!(response.status(), StatusCode::OK);
    assert!(response_body_string.contains("NodeConfig"));
    assert!(response_body_string.contains("InspectionServiceConfig"));
    assert!(response_body_string.contains("expose_configuration: true"));
}
```
