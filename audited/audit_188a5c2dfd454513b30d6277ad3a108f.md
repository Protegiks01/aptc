# Audit Report

## Title
DKG Weight Calculation Memory Exhaustion Due to Insufficient Threshold Gap Validation

## Summary
The DKG (Distributed Key Generation) weighted VUF implementation can allocate excessive memory leading to validator node crashes when on-chain randomness configuration has threshold values that are too close together. The minimum gap enforcement of `U64F64::DELTA` (2^-64) is mathematically insufficient to prevent memory exhaustion.

## Finding Description

The vulnerability exists in the DKG rounding algorithm's calculation of total weight for the weighted PVSS (Publicly Verifiable Secret Sharing) scheme. When randomness configuration thresholds are set via governance with values very close to each other, the formula for `total_weight_upper_bound` produces astronomically large values. [1](#0-0) 

The upper bound formula is: `(n/2 + 2) / (reconstruct_threshold - secrecy_threshold)`. When the denominator approaches zero, the result becomes massive. The code enforces a minimum gap of `U64F64::DELTA` (approximately 5.42 × 10^-20): [2](#0-1) 

With this minimum gap and 100 validators, the upper bound would be approximately `52 * 2^64 ≈ 9.6 × 10^20`. This huge value causes two critical memory allocations:

**First allocation** in `BatchEvaluationDomain::new()`: [3](#0-2) 

**Second allocation** in `aggregate_shares()`: [4](#0-3) 

The on-chain Move code provides **no validation** on threshold values when set via governance: [5](#0-4) 

While Rust code has validation checks, they only apply to `DKGRoundingProfile::new()`. If those checks fail, the system falls back to `infallible()` which still uses the problematic formula: [6](#0-5) 

## Impact Explanation

This is **High Severity** per Aptos bug bounty criteria:

1. **Validator Node Crashes**: When validators attempt to process DKG for an epoch with malformed threshold configuration, memory allocation fails causing node crashes
2. **Network Liveness Impact**: If multiple validators crash simultaneously during epoch transition, the network could lose liveness until configurations are corrected and nodes restarted
3. **Consensus Disruption**: DKG failure prevents the randomness beacon from functioning, breaking any smart contracts dependent on on-chain randomness

This violates the **Resource Limits** invariant: "All operations must respect gas, storage, and computational limits" - there is no upper bound on memory allocation based on configuration parameters.

## Likelihood Explanation

**Likelihood: Low to Medium**

This requires governance action to set problematic threshold values, which could occur through:

1. **Configuration Error**: Governance sets both `secrecy_threshold` and `reconstruction_threshold` to similar values (e.g., both at 66% or 67%) due to typo or misunderstanding
2. **Proposal Generation Bug**: Automated proposal generation could produce invalid threshold combinations
3. **Malicious Governance**: Though out of scope per threat model, a compromised governance could intentionally trigger this

The validation checks in `DKGRoundingProfile::new()` should catch most invalid configs: [7](#0-6) 

However, the `infallible` fallback path still uses the vulnerable formula, and the minimum DELTA gap is insufficient protection.

## Recommendation

**Immediate Fix**: Add explicit upper bound validation on total weight before allocation:

```rust
pub fn new(threshold_weight: usize, weights: Vec<usize>) -> anyhow::Result<Self> {
    // Existing checks...
    
    let W: usize = weights.iter().sum();
    
    // Add upper bound check
    const MAX_TOTAL_WEIGHT: usize = 1_000_000; // Reasonable limit
    if W > MAX_TOTAL_WEIGHT {
        return Err(anyhow!(
            "Total weight {} exceeds maximum allowed {}",
            W,
            MAX_TOTAL_WEIGHT
        ));
    }
    
    // Continue with existing logic...
}
```

**Move-Side Validation**: Add threshold validation in the Move code:

```move
public fun new_v1(secrecy_threshold: FixedPoint64, reconstruction_threshold: FixedPoint64): RandomnessConfig {
    // Validate thresholds
    assert!(fixed_point64::greater(
        fixed_point64::multiply_u64(3, secrecy_threshold), 
        fixed_point64::create_from_u128(1)
    ), EINVALID_SECRECY_THRESHOLD);
    
    assert!(fixed_point64::less_or_equal(
        fixed_point64::multiply_u64(3, reconstruction_threshold),
        fixed_point64::create_from_u128(2)
    ), EINVALID_RECONSTRUCTION_THRESHOLD);
    
    assert!(fixed_point64::less(secrecy_threshold, reconstruction_threshold), ETHRESHOLDS_TOO_CLOSE);
    
    // Ensure minimum gap of at least 0.01 (1%)
    let min_gap = fixed_point64::create_from_rational(1, 100);
    assert!(fixed_point64::greater_or_equal(
        fixed_point64::sub(reconstruction_threshold, secrecy_threshold),
        min_gap
    ), ETHRESHOLDS_TOO_CLOSE);
    
    // Existing logic...
}
```

**Rust-Side Additional Check**: Enforce minimum practical gap instead of relying on DELTA:

```rust
const MIN_THRESHOLD_GAP: f64 = 0.01; // 1% minimum gap

pub fn new(
    validator_stakes: &Vec<u64>,
    secrecy_threshold_in_stake_ratio: U64F64,
    mut reconstruct_threshold_in_stake_ratio: U64F64,
    fast_secrecy_threshold_in_stake_ratio: Option<U64F64>,
) -> Self {
    let min_gap = U64F64::from_num(MIN_THRESHOLD_GAP);
    reconstruct_threshold_in_stake_ratio = max(
        reconstruct_threshold_in_stake_ratio,
        secrecy_threshold_in_stake_ratio + min_gap, // Use practical minimum instead of DELTA
    );
    // ... rest of function
}
```

## Proof of Concept

```rust
use fixed::types::U64F64;
use types::dkg::real_dkg::rounding::*;

#[test]
fn test_memory_exhaustion_with_close_thresholds() {
    // Simulate governance setting both thresholds to 67%
    let validator_stakes = vec![1_000_000_u64; 100]; // 100 validators with equal stake
    
    let secrecy = U64F64::from_num(67) / U64F64::from_num(100); // 0.67
    let reconstruct = U64F64::from_num(67) / U64F64::from_num(100); // 0.67
    
    // After DELTA enforcement, gap will be 2^-64
    // This causes total_weight_upper_bound to return massive value
    
    let dkg_rounding = DKGRounding::new(
        &validator_stakes,
        secrecy,
        reconstruct,
        None,
    );
    
    // Check if total weight is unreasonably large
    let total_weight = dkg_rounding.profile.validator_weights.iter().sum::<u64>();
    println!("Total weight calculated: {}", total_weight);
    
    // Attempting to create WeightedConfigBlstrs will trigger massive allocation in BatchEvaluationDomain
    // This would cause OOM in production
    assert!(total_weight < 1_000_000, "Total weight exceeds safe limit");
}
```

This PoC demonstrates that with threshold values set to the same percentage, the resulting total weight calculation becomes problematic. In a live network, this would cause validators to crash during epoch transition when DKG is initialized.

### Citations

**File:** types/src/dkg/real_dkg/rounding/mod.rs (L34-48)
```rust
pub fn total_weight_upper_bound(
    validator_stakes: &[u64],
    mut reconstruct_threshold_in_stake_ratio: U64F64,
    secrecy_threshold_in_stake_ratio: U64F64,
) -> usize {
    reconstruct_threshold_in_stake_ratio = max(
        reconstruct_threshold_in_stake_ratio,
        secrecy_threshold_in_stake_ratio + U64F64::DELTA,
    );
    let two = U64F64::from_num(2);
    let n = U64F64::from_num(validator_stakes.len());
    ((n / two + two) / (reconstruct_threshold_in_stake_ratio - secrecy_threshold_in_stake_ratio))
        .ceil()
        .to_num::<usize>()
}
```

**File:** types/src/dkg/real_dkg/rounding/mod.rs (L67-70)
```rust
        reconstruct_threshold_in_stake_ratio = max(
            reconstruct_threshold_in_stake_ratio,
            secrecy_threshold_in_stake_ratio + U64F64::DELTA,
        );
```

**File:** types/src/dkg/real_dkg/rounding/mod.rs (L197-199)
```rust
        ensure!(secrecy_threshold_in_stake_ratio * U64F64::from_num(3) > U64F64::from_num(1));
        ensure!(secrecy_threshold_in_stake_ratio < reconstruct_threshold_in_stake_ratio);
        ensure!(reconstruct_threshold_in_stake_ratio * U64F64::from_num(3) <= U64F64::from_num(2));
```

**File:** types/src/dkg/real_dkg/rounding/mod.rs (L254-275)
```rust
    pub fn infallible(
        validator_stakes: &Vec<u64>,
        mut secrecy_threshold_in_stake_ratio: U64F64,
        mut reconstruct_threshold_in_stake_ratio: U64F64,
        fast_secrecy_threshold_in_stake_ratio: Option<U64F64>,
    ) -> Self {
        let one = U64F64::from_num(1);
        secrecy_threshold_in_stake_ratio = min(one, secrecy_threshold_in_stake_ratio);
        reconstruct_threshold_in_stake_ratio = min(one, reconstruct_threshold_in_stake_ratio);
        reconstruct_threshold_in_stake_ratio = max(
            secrecy_threshold_in_stake_ratio,
            reconstruct_threshold_in_stake_ratio,
        );

        let stake_total = U64F64::from_num(validator_stakes.clone().into_iter().sum::<u64>());

        let estimated_weight_total = total_weight_upper_bound(
            validator_stakes,
            reconstruct_threshold_in_stake_ratio,
            secrecy_threshold_in_stake_ratio,
        );
        let stake_per_weight = stake_total / U64F64::from_num(estimated_weight_total);
```

**File:** crates/aptos-crypto/src/blstrs/evaluation_domain.rs (L120-131)
```rust
    pub fn new(n: usize) -> Self {
        let (N, log_N) = smallest_power_of_2_greater_than_or_eq(n);
        let omega = EvaluationDomain::get_Nth_root_of_unity(log_N);

        let mut omegas = Vec::with_capacity(N);
        omegas.push(Scalar::ONE);

        let mut acc = omega;
        for _ in 1..N {
            omegas.push(acc);
            acc *= omega; // $\omega^i$
        }
```

**File:** crates/aptos-dkg/src/weighted_vuf/bls/mod.rs (L108-119)
```rust
    fn aggregate_shares(
        wc: &WeightedConfigBlstrs,
        apks_and_proofs: &[(Player, Self::AugmentedPubKeyShare, Self::ProofShare)],
    ) -> Self::Proof {
        // Collect all the evaluation points associated with each player
        let mut sub_player_ids = Vec::with_capacity(wc.get_total_weight());

        for (player, _, _) in apks_and_proofs {
            for j in 0..wc.get_player_weight(player) {
                sub_player_ids.push(wc.get_virtual_player(player, j).id);
            }
        }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/randomness_config.move (L93-100)
```text
    public fun new_v1(secrecy_threshold: FixedPoint64, reconstruction_threshold: FixedPoint64): RandomnessConfig {
        RandomnessConfig {
            variant: copyable_any::pack( ConfigV1 {
                secrecy_threshold,
                reconstruction_threshold
            } )
        }
    }
```
