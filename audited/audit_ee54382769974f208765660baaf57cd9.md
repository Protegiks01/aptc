# Audit Report

## Title
Private Key Memory Duplication Through Clone Implementation Without Zeroization

## Summary
When the `cloneable-private-keys` feature is enabled, the `Clone` implementation for all private key types (Secp256r1, Ed25519, BLS12381, etc.) creates unzeroed intermediate copies of private key material in memory through serialization/deserialization. This violates Aptos's documented secure coding guidelines and creates a defense-in-depth weakness.

## Finding Description

The Clone implementation serializes private keys to byte arrays and then deserializes them to create clones: [1](#0-0) 

This pattern is consistent across all private key types: [2](#0-1) [3](#0-2) 

The security issue is that the intermediate `serialized` byte array containing the raw private key material is not zeroized after use. This directly violates Aptos's secure coding standards: [4](#0-3) [5](#0-4) 

Furthermore, the `aptos-crypto` crate does not include `zeroize` as a dependency: [6](#0-5) 

**Attack Scenario:**
When this feature is enabled (during testing, fuzzing, or if accidentally enabled in production), each clone operation leaves unzeroed copies of private key bytes on the stack. An attacker with memory access through:
- Memory dumps
- Debugging/profiling tools
- Cold boot attacks
- Memory disclosure vulnerabilities (Spectre-class, buffer overflows)
- Core dumps after crashes

Could potentially extract these private key fragments from memory.

## Impact Explanation

**Severity Assessment: Medium (with caveats)**

This issue does NOT meet Critical or High severity because:
1. The `cloneable-private-keys` feature is only enabled for testing/fuzzing, not production
2. Requires attacker to have memory access (elevated privilege or separate vulnerability)
3. No direct path to consensus violations or fund theft without additional exploits

However, it represents a **defense-in-depth failure** because:
- Validator consensus keys (BLS12381) use the same vulnerable pattern [7](#0-6) 

- It explicitly violates documented security requirements
- Increases attack surface in development/testing environments
- Could be exploited if the feature is mistakenly enabled in production

**Per bug bounty criteria:** This would fall under "Medium Severity - Non-critical implementation bugs" if the feature could be enabled in production, but since it's test-only, it's actually a **code quality/compliance issue** rather than an exploitable vulnerability.

## Likelihood Explanation

**Likelihood: Low in production, High in test environments**

The feature is explicitly controlled by conditional compilation: [8](#0-7) 

In production deployments:
- Feature is not enabled (assert-private-keys-not-cloneable would be used instead)
- Private keys wrapped in `Arc` to avoid cloning
- Makes exploitation highly unlikely

In test/fuzzing environments:
- Feature is enabled
- Memory dumps or debugging could expose keys
- More likely but lower security criticality

## Recommendation

**Immediate Actions:**
1. Add `zeroize` crate as a dependency to `aptos-crypto`
2. Implement `Drop` trait for private key types using `Zeroize`
3. Zeroize intermediate serialization buffers in `Clone` implementations

**Code Fix:**

```rust
// In Cargo.toml
[dependencies]
zeroize = { version = "1.7", features = ["derive"] }

// In secp256r1_ecdsa_keys.rs
use zeroize::Zeroize;

#[cfg(any(test, feature = "cloneable-private-keys"))]
impl Clone for PrivateKey {
    fn clone(&self) -> Self {
        let mut serialized = self.to_bytes();
        let result = PrivateKey::try_from(serialized.as_ref()).unwrap();
        serialized.zeroize(); // Explicitly zero the intermediate copy
        result
    }
}

// Implement Drop for defense-in-depth
impl Drop for PrivateKey {
    fn drop(&mut self) {
        // Note: Relies on underlying p256::ecdsa::SigningKey Drop implementation
        // which should handle zeroization, but we document this expectation
    }
}
```

Apply this pattern to all private key types (Ed25519, BLS12381, Secp256k1, SLH-DSA).

## Proof of Concept

```rust
#[cfg(test)]
mod memory_leak_test {
    use super::*;
    use aptos_crypto::Uniform;
    
    #[test]
    fn test_clone_leaves_unzeroed_memory() {
        // Generate a private key
        let mut rng = rand::thread_rng();
        let original_key = PrivateKey::generate(&mut rng);
        let key_bytes = original_key.to_bytes();
        
        // Clone the key - this creates unzeroed intermediate copies
        let cloned_key = original_key.clone();
        
        // Verify keys are equal
        assert_eq!(original_key, cloned_key);
        
        // The intermediate serialized bytes are NOT zeroized
        // In a real attack, memory scanning could find these bytes
        // This is a demonstration - actual memory scanning would require
        // unsafe code and platform-specific memory access
        
        println!("WARNING: Unzeroed key material may remain in memory");
        println!("Original key bytes: {:?}", &key_bytes[..4]); // Only show first 4 bytes
    }
}
```

**Notes:**

This report documents a **code quality and compliance issue** rather than a directly exploitable vulnerability. While the technical finding is valid (unzeroed memory copies), the practical exploitability is limited by:
1. Feature flag only enabled in test/fuzzing
2. Requirement for memory access
3. No direct consensus/protocol impact

The issue should be fixed to maintain compliance with secure coding standards and defense-in-depth principles, but it does not represent an immediate critical security risk to the production Aptos network.

### Citations

**File:** crates/aptos-crypto/src/secp256r1_ecdsa/secp256r1_ecdsa_keys.rs (L28-29)
```rust
#[cfg(feature = "assert-private-keys-not-cloneable")]
static_assertions::assert_not_impl_any!(PrivateKey: Clone);
```

**File:** crates/aptos-crypto/src/secp256r1_ecdsa/secp256r1_ecdsa_keys.rs (L31-37)
```rust
#[cfg(any(test, feature = "cloneable-private-keys"))]
impl Clone for PrivateKey {
    fn clone(&self) -> Self {
        let serialized: &[u8] = &(self.to_bytes());
        PrivateKey::try_from(serialized).unwrap()
    }
}
```

**File:** crates/aptos-crypto/src/ed25519/ed25519_keys.rs (L29-35)
```rust
#[cfg(any(test, feature = "cloneable-private-keys"))]
impl Clone for Ed25519PrivateKey {
    fn clone(&self) -> Self {
        let serialized: &[u8] = &(self.to_bytes());
        Ed25519PrivateKey::try_from(serialized).unwrap()
    }
}
```

**File:** crates/aptos-crypto/src/bls12381/bls12381_keys.rs (L184-190)
```rust
#[cfg(any(test, feature = "cloneable-private-keys"))]
impl Clone for PrivateKey {
    fn clone(&self) -> Self {
        let serialized: &[u8] = &(self.to_bytes());
        PrivateKey::try_from(serialized).unwrap()
    }
}
```

**File:** RUST_SECURE_CODING.md (L96-96)
```markdown
Do not rely on `Drop` trait in security material treatment after the use, use [zeroize](https://docs.rs/zeroize/latest/zeroize/#) to explicit destroy security material, e.g. private keys.
```

**File:** RUST_SECURE_CODING.md (L143-145)
```markdown
### Zeroing Sensitive Data

Use [zeroize](https://docs.rs/zeroize/latest/zeroize/#) for zeroing memory containing sensitive data.
```

**File:** crates/aptos-crypto/Cargo.toml (L15-75)
```text
[dependencies]
aes-gcm = { workspace = true }
anyhow = { workspace = true }
aptos-crypto-derive = { workspace = true }
arbitrary = { workspace = true, features = ["derive"], optional = true }
ark-bls12-381 = { workspace = true }
ark-bn254 = { workspace = true }
ark-ec = { workspace = true }
ark-ff = { workspace = true }
ark-groth16 = { workspace = true }
ark-poly = { workspace = true }
ark-relations = { workspace = true }
ark-serialize = { workspace = true }
ark-snark = { workspace = true }
ark-std = { workspace = true }
base64 = { workspace = true }
bcs = { workspace = true }
bls12_381 = { workspace = true }
blst = { workspace = true }
blstrs = { workspace = true }
bulletproofs = { workspace = true }
bytes = { workspace = true }
curve25519-dalek = { workspace = true }
curve25519-dalek-ng = { workspace = true }
digest = { workspace = true }
dudect-bencher = { workspace = true }
ed25519-dalek = { workspace = true }
ff = { workspace = true }
group = { workspace = true }
hex = { workspace = true }
hkdf = { workspace = true }
itertools = { workspace = true }
libsecp256k1 = { workspace = true }
merlin = { workspace = true }
more-asserts = { workspace = true }
neptune = { workspace = true }
num-bigint = { workspace = true }
num-integer = { workspace = true }
num-traits = { workspace = true }
once_cell = { workspace = true }
p256 = { workspace = true }
pairing = { workspace = true }
proptest = { workspace = true, optional = true }
proptest-derive = { workspace = true, optional = true }
rand = { workspace = true }
rand_core = { workspace = true }
rayon = { workspace = true }
ring = { workspace = true }
serde = { workspace = true }
serde-name = { workspace = true }
serde_bytes = { workspace = true }
sha2 = { workspace = true }
sha2_0_10_6 = { workspace = true }
sha3 = { workspace = true }
signature = { workspace = true }
slh-dsa = { workspace = true }
static_assertions = { workspace = true }
thiserror = { workspace = true }
tiny-keccak = { workspace = true }
typenum = { workspace = true }
x25519-dalek = { workspace = true }
```

**File:** types/src/validator_signer.rs (L16-21)
```rust
#[derive(Debug)]
#[cfg_attr(any(test, feature = "fuzzing"), derive(Clone))]
pub struct ValidatorSigner {
    author: AccountAddress,
    private_key: Arc<bls12381::PrivateKey>,
}
```
