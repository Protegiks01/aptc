# Audit Report

## Title
Stale Safety Data Can Bypass Order Vote Safety Check Due to Non-Durable Storage

## Summary
If `safety_data.highest_timeout_round` is corrupted or becomes stale due to storage durability failures, the `safe_for_order_vote` safety check can incorrectly allow order votes for rounds that have already been timed out, violating the 2-chain consensus safety invariant.

## Finding Description

The `guarded_construct_and_sign_order_vote` function retrieves safety data from persistent storage and uses it to enforce a critical safety invariant: once a validator signs a timeout for round R, they cannot sign order votes for rounds ≤ R. [1](#0-0) 

The safety check is implemented in `safe_for_order_vote`: [2](#0-1) 

**The Vulnerability:**

The `highest_timeout_round` field in `SafetyData` tracks the highest round for which a timeout has been signed: [3](#0-2) 

When a timeout is signed, this field is updated: [4](#0-3) 

However, if the underlying storage returns stale or corrupted data where `highest_timeout_round` is lower than its actual value, the check `round > safety_data.highest_timeout_round` can incorrectly pass.

**Root Cause - OnDiskStorage Lacks Durability:**

The OnDiskStorage implementation used for persistent safety storage does not call fsync() after writes: [5](#0-4) 

Without fsync(), written data remains in the OS page cache and is not guaranteed to persist to disk. A crash or power failure before the OS flushes the cache results in data loss.

While OnDiskStorage is documented as "should not be used in production": [6](#0-5) 

The configuration sanitizer only prohibits InMemoryStorage for mainnet validators, not OnDiskStorage: [7](#0-6) 

**Attack Scenario:**

1. Validator is configured with OnDiskStorage backend
2. Validator signs timeout for round 10, updating `highest_timeout_round = 10`
3. Write to OnDiskStorage succeeds (data in OS page cache, not on disk)
4. Power failure or crash occurs before OS flushes cache
5. Validator restarts, loads safety_data from disk with stale `highest_timeout_round = 0`
6. OrderVoteProposal for round 5 arrives
7. Check: `5 > 0` passes ✓
8. Validator signs order vote for round 5

**Result:** The validator has signed both a timeout for round 10 AND an order vote for round 5 (≤ 10), violating the consensus safety invariant and creating an equivocation.

This is confirmed by the test suite's expected behavior: [8](#0-7) 

## Impact Explanation

**Severity: HIGH**

This violates **Consensus Safety** - a Critical invariant. When a validator equivocates by signing both a timeout and an order vote for overlapping rounds, it sends contradictory messages to the network. While AptosBFT is designed to tolerate up to 1/3 Byzantine validators, this creates an attack surface where:

- Multiple validators experiencing simultaneous crashes could violate safety if all lose their timeout records
- The validator's contradictory messages could contribute to consensus confusion
- In extreme cases with multiple affected validators, could lead to chain safety violations

However, the impact is somewhat mitigated because:
- Only affects validators using OnDiskStorage (discouraged but not prohibited)
- Requires operational failure (crash/power loss), not pure attacker control
- Other validators with correct state can still maintain consensus

This qualifies as **High Severity** per bug bounty criteria: "Significant protocol violations"

## Likelihood Explanation

**Likelihood: LOW to MEDIUM**

Factors reducing likelihood:
- OnDiskStorage is explicitly marked "not for production use"
- Production validators are expected to use VaultStorage
- Requires validator misconfiguration

Factors increasing likelihood:
- Config sanitizer doesn't prohibit OnDiskStorage for mainnet
- Power failures and crashes are common operational events  
- No secondary validation mechanism exists
- Issue persists silently until an order vote is attempted

A validator using OnDiskStorage despite recommendations, experiencing a crash during the narrow window after a timeout signature, would trigger this vulnerability.

## Recommendation

**Primary Fix: Add fsync() to OnDiskStorage**

Modify `OnDiskStorage::write()` to ensure durability:

```rust
fn write(&self, data: &HashMap<String, Value>) -> Result<(), Error> {
    let contents = serde_json::to_vec(data)?;
    let mut file = File::create(self.temp_path.path())?;
    file.write_all(&contents)?;
    file.sync_all()?; // ADD THIS LINE
    fs::rename(&self.temp_path, &self.file_path)?;
    Ok(())
}
```

**Secondary Fix: Add Config Validation**

Prohibit OnDiskStorage for mainnet validators in the sanitizer: [7](#0-6) 

Add additional check:
```rust
if chain_id.is_mainnet()
    && node_type.is_validator()
    && matches!(safety_rules_config.backend, SecureBackend::OnDiskStorage(_))
{
    return Err(Error::ConfigSanitizerFailed(
        sanitizer_name,
        "OnDiskStorage should not be used in mainnet!".to_string(),
    ));
}
```

**Tertiary Fix: Add Defensive Validation**

Consider adding monotonicity checks when loading safety_data to detect rollback scenarios.

## Proof of Concept

```rust
#[cfg(test)]
mod test_storage_durability {
    use super::*;
    use aptos_secure_storage::{OnDiskStorage, Storage};
    use aptos_temppath::TempPath;
    
    #[test]
    fn test_ondisk_storage_lacks_fsync_durability() {
        let temp_path = TempPath::new();
        temp_path.create_as_file().unwrap();
        
        // Create storage and write initial safety data
        let mut storage = PersistentSafetyStorage::initialize(
            Storage::from(OnDiskStorage::new(temp_path.path().to_path_buf())),
            Author::random(),
            bls12381::PrivateKey::generate_for_testing(),
            Waypoint::default(),
            false, // disable cache to force disk reads
        );
        
        // Sign timeout for round 10
        let mut safety_data = storage.safety_data().unwrap();
        safety_data.highest_timeout_round = 10;
        storage.set_safety_data(safety_data).unwrap();
        
        // Simulate crash - without fsync, data may not persist
        // In real scenario, kill -9 or power loss here
        drop(storage);
        
        // Restart - if OS cache wasn't flushed, we load stale data
        let mut storage = PersistentSafetyStorage::new(
            Storage::from(OnDiskStorage::new(temp_path.path().to_path_buf())),
            false,
        );
        
        let loaded_data = storage.safety_data().unwrap();
        
        // This test documents the issue - in a real crash scenario,
        // highest_timeout_round could revert to 0
        // Making it impossible to enforce the safety rule
        println!("Loaded highest_timeout_round: {}", loaded_data.highest_timeout_round);
        
        // If this is 0 instead of 10, order vote for round 5 would incorrectly pass
    }
}
```

## Notes

While this vulnerability has a clear technical path, it falls into a gray area regarding the bug bounty criteria of "exploitable by unprivileged attacker." The issue requires:

1. Validator misconfiguration (using discouraged OnDiskStorage)
2. Operational failure (crash/power loss) - not directly attacker-controllable

However, the vulnerability is **real** in that corrupted/stale `safety_data` definitively can cause `safe_for_order_vote` to make incorrect decisions. The lack of fsync() in OnDiskStorage combined with the absence of sanitizer checks creates a concrete defense-in-depth weakness where consensus safety invariants can be violated through operational failures.

The recommended fixes strengthen the system against both misconfiguration and storage durability issues, improving overall consensus safety guarantees.

### Citations

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L97-119)
```rust
    pub(crate) fn guarded_construct_and_sign_order_vote(
        &mut self,
        order_vote_proposal: &OrderVoteProposal,
    ) -> Result<OrderVote, Error> {
        // Exit early if we cannot sign
        self.signer()?;
        self.verify_order_vote_proposal(order_vote_proposal)?;
        let proposed_block = order_vote_proposal.block();
        let mut safety_data = self.persistent_storage.safety_data()?;

        // Record 1-chain data
        self.observe_qc(order_vote_proposal.quorum_cert(), &mut safety_data);

        self.safe_for_order_vote(proposed_block, &safety_data)?;
        // Construct and sign order vote
        let author = self.signer()?.author();
        let ledger_info =
            LedgerInfo::new(order_vote_proposal.block_info().clone(), HashValue::zero());
        let signature = self.sign(&ledger_info)?;
        let order_vote = OrderVote::new_with_signature(author, ledger_info.clone(), signature);
        self.persistent_storage.set_safety_data(safety_data)?;
        Ok(order_vote)
    }
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L168-178)
```rust
    fn safe_for_order_vote(&self, block: &Block, safety_data: &SafetyData) -> Result<(), Error> {
        let round = block.round();
        if round > safety_data.highest_timeout_round {
            Ok(())
        } else {
            Err(Error::NotSafeForOrderVote(
                round,
                safety_data.highest_timeout_round,
            ))
        }
    }
```

**File:** consensus/consensus-types/src/safety_data.rs (L8-21)
```rust
/// Data structure for safety rules to ensure consensus safety.
#[derive(Debug, Deserialize, Eq, PartialEq, Serialize, Clone, Default)]
pub struct SafetyData {
    pub epoch: u64,
    pub last_voted_round: u64,
    // highest 2-chain round, used for 3-chain
    pub preferred_round: u64,
    // highest 1-chain round, used for 2-chain
    #[serde(default)]
    pub one_chain_round: u64,
    pub last_vote: Option<Vote>,
    #[serde(default)]
    pub highest_timeout_round: u64,
}
```

**File:** consensus/safety-rules/src/safety_rules.rs (L158-170)
```rust
    pub(crate) fn update_highest_timeout_round(
        &self,
        timeout: &TwoChainTimeout,
        safety_data: &mut SafetyData,
    ) {
        if timeout.round() > safety_data.highest_timeout_round {
            safety_data.highest_timeout_round = timeout.round();
            trace!(
                SafetyLogSchema::new(LogEntry::HighestTimeoutRound, LogEvent::Update)
                    .highest_timeout_round(safety_data.highest_timeout_round)
            );
        }
    }
```

**File:** secure/storage/src/on_disk.rs (L16-22)
```rust
/// OnDiskStorage represents a key value store that is persisted to the local filesystem and is
/// intended for single threads (or must be wrapped by a Arc<RwLock<>>). This provides no permission
/// checks and simply offers a proof of concept to unblock building of applications without more
/// complex data stores. Internally, it reads and writes all data to a file, which means that it
/// must make copies of all key material which violates the code base. It violates it because
/// the anticipation is that data stores would securely handle key material. This should not be used
/// in production.
```

**File:** secure/storage/src/on_disk.rs (L64-70)
```rust
    fn write(&self, data: &HashMap<String, Value>) -> Result<(), Error> {
        let contents = serde_json::to_vec(data)?;
        let mut file = File::create(self.temp_path.path())?;
        file.write_all(&contents)?;
        fs::rename(&self.temp_path, &self.file_path)?;
        Ok(())
    }
```

**File:** config/src/config/safety_rules_config.rs (L86-96)
```rust
            // Verify that the secure backend is appropriate for mainnet validators
            if chain_id.is_mainnet()
                && node_type.is_validator()
                && safety_rules_config.backend.is_in_memory()
            {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "The secure backend should not be set to in memory storage in mainnet!"
                        .to_string(),
                ));
            }
```

**File:** consensus/safety-rules/src/tests/suite.rs (L306-314)
```rust
    safety_rules
        .sign_timeout_with_qc(
            &TwoChainTimeout::new(epoch, round + 4, p3.block().quorum_cert().clone()),
            Some(&tc3),
        )
        .unwrap();

    // Cannot sign order vote for round 3 after signing timeout for round 4
    assert_err!(safety_rules.construct_and_sign_order_vote(&ov3));
```
