# Audit Report

## Title
Bytecode Verification DoS: Verification Time Not Counted Against Transaction Gas Limits

## Summary
Move bytecode verification during module publishing uses a separate metering system (VerifierConfig meter units) that is independent from transaction gas limits. Verification operations can consume significant validator CPU time without proportional gas costs, and some verification passes are not fully metered. This creates a DoS vector where attackers can submit transactions that cause expensive verification work while paying minimal gas.

## Finding Description

When a user publishes a Move module, the transaction follows this flow:

1. **Gas Charging Phase**: Gas is charged based on module sizes (old modules, new modules, dependencies) in `resolve_pending_code_publish_and_finish_user_session`: [1](#0-0) 

2. **Verification Phase**: Bytecode verification occurs in `StagingModuleStorage::create_with_compat_config`, which calls `build_locally_verified_module`: [2](#0-1) 

3. **Verification Uses Separate Meter**: The verification calls `verify_module_with_config` which uses VerifierConfig's meter system: [3](#0-2) 

The critical issue is that **verification is unmetered from the transaction gas perspective**. The VerifierConfig meter has limits of 80,000,000 units per function/module in production: [4](#0-3) 

However, this meter charges **fixed costs** that may not reflect actual CPU time: [5](#0-4) [6](#0-5) 

**Critical Gap**: Some verification passes are **not metered at all**: [7](#0-6) [8](#0-7) 

The meter implementation shows that verification only fails when meter units are exceeded, returning `CONSTRAINT_NOT_SATISFIED`: [9](#0-8) 

**There is no wall-clock timeout mechanism** - only complexity-based meter limits.

## Impact Explanation

This vulnerability allows an attacker to cause **validator node slowdowns** (High Severity per Aptos bug bounty criteria, up to $50,000) through the following attack:

1. Craft bytecode with maximum allowed complexity within meter limits (e.g., 1024 basic blocks, complex type hierarchies, intricate reference patterns)
2. Submit multiple transactions publishing such modules
3. Each validator must verify each module before accepting/rejecting transactions
4. Verification consumes significant CPU time but doesn't count toward transaction gas
5. Attacker pays minimal gas (only for module sizes ~100KB each)
6. Network throughput degrades as validators spend excessive time on verification

This breaks the **Resource Limits** invariant: "All operations must respect gas, storage, and computational limits" - verification CPU time is not properly bounded by transaction gas.

## Likelihood Explanation

**Likelihood: HIGH**

- Module publishing is available to any user on the network
- No special privileges required beyond normal transaction submission
- The attack vector is straightforward: craft complex-but-valid bytecode
- Multiple verification passes lack metering (control_flow, stack_usage)
- Fixed meter costs (30 units per type node) may not reflect actual CPU cost for pathological cases
- Attacker can submit many such transactions simultaneously
- All validators must perform verification, amplifying the impact

## Recommendation

Implement verification gas metering that counts toward transaction gas limits:

1. **Charge gas for verification work**: Modify `build_locally_verified_module` to accept a gas meter parameter and charge gas proportional to verification CPU time
2. **Implement wall-clock timeouts**: Add timeout enforcement for verification operations to prevent unbounded CPU consumption
3. **Complete metering coverage**: Implement metering for all verification passes (control_flow, stack_usage)
4. **Calibrate meter costs**: Audit meter unit costs to ensure they accurately reflect worst-case CPU time
5. **Consider verification caching**: The existing `VERIFIED_MODULES_CACHE` helps, but ensure it's effective across the network

Example fix structure:
```rust
pub fn build_locally_verified_module(
    &self,
    compiled_module: Arc<CompiledModule>,
    module_size: usize,
    module_hash: &[u8; 32],
    gas_meter: &mut impl AptosGasMeter,  // ADD GAS METER
) -> VMResult<LocallyVerifiedModule> {
    if !VERIFIED_MODULES_CACHE.contains(module_hash) {
        // CHARGE GAS FOR VERIFICATION
        gas_meter.charge_verification_work(module_size)?;
        
        move_bytecode_verifier::verify_module_with_config(
            &self.vm_config().verifier_config,
            compiled_module.as_ref(),
        )?;
        // ...
    }
    Ok(LocallyVerifiedModule(compiled_module, module_size))
}
```

## Proof of Concept

A complete PoC requires crafting pathological Move bytecode. The attack would follow these steps:

```rust
// Simplified demonstration structure
// 1. Create module with maximum allowed complexity
module 0xAttacker::PathologicalModule {
    // 1024 basic blocks (max_basic_blocks limit)
    // Complex generic type hierarchies (max 128/256 type nodes each)
    // Intricate reference borrowing patterns
    // Deep control flow nesting (max_loop_depth: 5)
    
    struct ComplexType<T1, T2, T3, T4, T5> {
        // Nested generic fields to maximize type checking cost
        field1: vector<T1>,
        field2: vector<vector<T2>>,
        field3: vector<vector<vector<T3>>>,
        // ... continue nesting
    }
    
    public fun pathological_function() {
        // Control flow designed to maximize reducibility check cost
        // 1024 basic blocks with complex jump patterns
        // Reference safety analysis requiring many borrow graph operations
    }
}

// 2. Submit transaction publishing this module
// 3. Verification takes >>1 second CPU time per validator
// 4. Transaction gas charged: ~500,000 (module size only)
// 5. Actual CPU cost: Equivalent to >>50M gas at normal execution rates
// 6. Submit 100 such transactions â†’ validators spend excessive time verifying
```

The concrete PoC would require Move compiler tooling to generate bytecode that maximizes verification cost within the structural limits while staying under the 80M meter unit threshold.

## Notes

This vulnerability demonstrates a **design flaw** where verification work is inadequately metered. While the VerifierConfig meter provides some protection, it operates independently from transaction gas limits and uses fixed costs that may not reflect actual CPU time. The TODO comments in unmetered verification passes indicate this is a known incomplete area. The fix requires integrating verification costs into the transaction gas accounting system.

### Citations

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1498-1552)
```rust
        if self.gas_feature_version() >= RELEASE_V1_10 {
            // Charge old versions of existing modules, in case of upgrades.
            for module in modules.iter() {
                let addr = module.self_addr();
                let name = module.self_name();

                if !traversal_context.visit_if_not_special_address(addr, name) {
                    continue;
                }

                let size_if_old_module_exists = module_storage
                    .unmetered_get_module_size(addr, name)?
                    .map(|v| v as u64);
                if let Some(old_size) = size_if_old_module_exists {
                    gas_meter
                        .charge_dependency(
                            DependencyKind::Existing,
                            addr,
                            name,
                            NumBytes::new(old_size),
                        )
                        .map_err(|err| {
                            err.finish(Location::Module(ModuleId::new(*addr, name.to_owned())))
                        })?;
                }
            }

            // Charge all modules in the bundle that is about to be published.
            for (module, blob) in modules.iter().zip(bundle.iter()) {
                let addr = module.self_addr();
                let name = module.self_name();
                gas_meter
                    .charge_dependency(
                        DependencyKind::New,
                        addr,
                        name,
                        NumBytes::new(blob.code().len() as u64),
                    )
                    .map_err(|err| err.finish(Location::Undefined))?;

                // In case of lazy loading: add all modules in a bundle as visited to avoid double
                // charging during module initialization.
                if self.features().is_lazy_loading_enabled() {
                    traversal_context.visit_if_not_special_address(addr, name);
                }
            }

            // Charge all immediate dependencies of a published package.
            self.charge_package_dependencies(
                module_storage,
                gas_meter,
                traversal_context,
                modules,
            )?;
        }
```

**File:** third_party/move/move-vm/runtime/src/storage/publishing.rs (L245-275)
```rust
            if is_lazy_loading_enabled {
                // Local bytecode verification.
                staged_runtime_environment.paranoid_check_module_address_and_name(
                    compiled_module,
                    compiled_module.self_addr(),
                    compiled_module.self_name(),
                )?;
                let locally_verified_code = staged_runtime_environment
                    .build_locally_verified_module(
                        compiled_module.clone(),
                        bytes.len(),
                        &sha3_256(bytes),
                    )?;

                // Linking checks to immediate dependencies. Note that we do not check cyclic
                // dependencies here.
                let mut verified_dependencies = vec![];
                for (dep_addr, dep_name) in locally_verified_code.immediate_dependencies_iter() {
                    // INVARIANT:
                    //   Immediate dependency of the module in a bundle must be metered at the
                    //   caller side.
                    let dependency =
                        staged_module_storage.unmetered_get_existing_lazily_verified_module(
                            &ModuleId::new(*dep_addr, dep_name.to_owned()),
                        )?;
                    verified_dependencies.push(dependency);
                }
                staged_runtime_environment.build_verified_module_with_linking_checks(
                    locally_verified_code,
                    &verified_dependencies,
                )?;
```

**File:** third_party/move/move-vm/runtime/src/storage/environment.rs (L178-201)
```rust
    pub fn build_locally_verified_module(
        &self,
        compiled_module: Arc<CompiledModule>,
        module_size: usize,
        module_hash: &[u8; 32],
    ) -> VMResult<LocallyVerifiedModule> {
        if !VERIFIED_MODULES_CACHE.contains(module_hash) {
            let _timer =
                VM_TIMER.timer_with_label("move_bytecode_verifier::verify_module_with_config");

            // For regular execution, we cache already verified modules. Note that this even caches
            // verification for the published modules. This should be ok because as long as the
            // hash is the same, the deployed bytecode and any dependencies are the same, and so
            // the cached verification result can be used.
            move_bytecode_verifier::verify_module_with_config(
                &self.vm_config().verifier_config,
                compiled_module.as_ref(),
            )?;
            check_natives(compiled_module.as_ref())?;
            VERIFIED_MODULES_CACHE.put(*module_hash);
        }

        Ok(LocallyVerifiedModule(compiled_module, module_size))
    }
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L175-176)
```rust
        max_per_fun_meter_units: Some(1000 * 80000),
        max_per_mod_meter_units: Some(1000 * 80000),
```

**File:** third_party/move/move-bytecode-verifier/src/type_safety.rs (L87-99)
```rust
    fn push(&mut self, meter: &mut impl Meter, ty: SignatureToken) -> PartialVMResult<()> {
        self.charge_ty(meter, &ty)?;
        self.stack.push(ty);
        Ok(())
    }

    fn charge_ty(&mut self, meter: &mut impl Meter, ty: &SignatureToken) -> PartialVMResult<()> {
        meter.add_items(
            Scope::Function,
            TYPE_NODE_COST,
            ty.preorder_traversal().count(),
        )
    }
```

**File:** third_party/move/move-bytecode-verifier/src/reference_safety/abstract_state.rs (L75-87)
```rust
pub(crate) const STEP_BASE_COST: u128 = 10;
pub(crate) const STEP_PER_LOCAL_COST: u128 = 20;
pub(crate) const STEP_PER_GRAPH_ITEM_COST: u128 = 50;
pub(crate) const JOIN_BASE_COST: u128 = 100;
pub(crate) const JOIN_PER_LOCAL_COST: u128 = 10;
pub(crate) const JOIN_PER_GRAPH_ITEM_COST: u128 = 50;

// The cost for an edge from an input reference parameter to output reference.
pub(crate) const REF_PARAM_EDGE_COST: u128 = 100;
pub(crate) const REF_PARAM_EDGE_COST_GROWTH: f32 = 1.5;

// The cost of an acquires in a call.
pub(crate) const CALL_PER_ACQUIRES_COST: u128 = 100;
```

**File:** third_party/move/move-bytecode-verifier/src/control_flow.rs (L35-42)
```rust
pub fn verify_function<'a>(
    verifier_config: &'a VerifierConfig,
    module: &'a CompiledModule,
    index: FunctionDefinitionIndex,
    function_definition: &'a FunctionDefinition,
    code: &'a CodeUnit,
    _meter: &mut impl Meter, // TODO: metering
) -> PartialVMResult<FunctionView<'a>> {
```

**File:** third_party/move/move-bytecode-verifier/src/stack_usage_verifier.rs (L29-34)
```rust
    pub(crate) fn verify(
        config: &VerifierConfig,
        resolver: &'a BinaryIndexedView<'a>,
        function_view: &'a FunctionView,
        _meter: &mut impl Meter, // TODO: metering
    ) -> PartialVMResult<()> {
```

**File:** third_party/move/move-bytecode-verifier/src/meter.rs (L90-106)
```rust
impl Bounds {
    fn add(&mut self, units: u128) -> PartialVMResult<()> {
        if let Some(max) = self.max {
            let new_units = self.units.saturating_add(units);
            if new_units > max {
                // TODO: change to a new status PROGRAM_TOO_COMPLEX once this is rolled out. For
                // now we use an existing code to avoid breaking changes on potential rollback.
                return Err(PartialVMError::new(StatusCode::CONSTRAINT_NOT_SATISFIED)
                    .with_message(format!(
                        "program too complex (in `{}` with `{} current + {} new > {} max`)",
                        self.name, self.units, units, max
                    )));
            }
            self.units = new_units;
        }
        Ok(())
    }
```
