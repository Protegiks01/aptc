# Audit Report

## Title
Consensus Sync Manager Bypass Leading to Resource Exhaustion via Crafted SyncInfo Gap

## Summary

An attacker can send a carefully crafted `SyncInfo` message where the `highest_commit_cert` is just within the sync threshold (30 rounds by default) but the `highest_quorum_cert` is thousands of rounds ahead. This bypasses the efficient state synchronization mechanism and forces the victim node into an unbounded block-by-block fetch loop, causing severe resource exhaustion and node slowdown.

## Finding Description

The vulnerability exists in the `sync_to_highest_quorum_cert()` function which uses `need_sync_for_ledger_info()` to determine whether to perform a full state sync. However, this check only examines the `highest_commit_cert`, not the `highest_quorum_cert`. [1](#0-0) 

The `need_sync_for_ledger_info()` function calculates a `max_commit_gap` (default 30 rounds) and returns `false` if the commit cert is within this threshold: [2](#0-1) 

**Attack Scenario:**

1. Victim node is at commit round R (e.g., round 100)
2. Attacker sends a `SyncInfo` with:
   - `highest_commit_cert` at round R+29 (e.g., 129) - just within the 30-round gap
   - `highest_quorum_cert` at round R+10000 (e.g., 10100) - far ahead

3. The `SyncInfo.verify()` method only checks that rounds are monotonically increasing, with NO maximum gap validation: [3](#0-2) 

4. In `sync_to_highest_quorum_cert()`, the function returns early without performing state sync because the commit cert is only 29 rounds ahead.

5. Control returns to `add_certs()` which then calls `insert_quorum_cert()` with the quorum cert at round 10100: [4](#0-3) 

6. Since the quorum cert's block doesn't exist locally, `fetch_quorum_cert()` is invoked, which contains an **unbounded loop** that fetches blocks one at a time: [5](#0-4) 

7. This loop will execute approximately 10,000 times (from round 10100 back to round 100), with each iteration making a network RPC call that includes retry logic and peer selection.

**Broken Invariants:**
- **Resource Limits**: The system fails to bound network operations and memory allocation
- **Consensus Liveness**: Affected nodes become severely degraded, unable to participate effectively in consensus
- **Efficient State Sync**: The design assumes large gaps trigger `fast_forward_sync()`, but this is bypassed

## Impact Explanation

This vulnerability qualifies as **HIGH severity** under the Aptos bug bounty criteria: "Validator node slowdowns".

**Resource Exhaustion Impact:**
- **Network Bandwidth**: Each block fetch involves multiple RPC attempts with retry logic, potentially requesting from multiple peers
- **CPU**: Processing thousands of blocks sequentially with signature verification
- **Memory**: All fetched blocks are stored in the `pending` vector before insertion
- **Time**: The node is stuck in this loop for an extended duration, unable to participate in consensus

**Consensus Impact:**
- Validators running affected versions become slow or unresponsive
- Reduced network throughput as validators spend resources on inefficient sync
- Potential cascade effects if multiple nodes are targeted simultaneously
- Degraded user experience and transaction processing

The attack does NOT require the attacker to be a validator or have any privileged access - any network peer can send a `SyncInfo` message.

## Likelihood Explanation

**Likelihood: HIGH**

**Attacker Requirements:**
1. Ability to send network messages to consensus nodes (available to any peer)
2. Valid cryptographic signatures on the certificates (obtainable through):
   - Participating in consensus as a validator (< 1/3 Byzantine assumption)
   - Observing certificates from other legitimate peers who are ahead
   - Exploiting a separate vulnerability to obtain valid certificates

**Ease of Exploitation:**
- The attack requires only crafting a single `SyncInfo` message with appropriately chosen rounds
- No timing requirements or race conditions
- Can be repeated to continuously degrade target nodes
- Works against any node that is behind the network

**Natural Occurrence:**
This scenario could even occur naturally when a node that is significantly behind receives a `SyncInfo` from a legitimate peer that is only moderately ahead on commits but far ahead on quorum certs (e.g., during network partitions or slow nodes rejoining).

## Recommendation

Add validation in `sync_to_highest_quorum_cert()` to check the gap between the local state and the `highest_quorum_cert`, not just the `highest_commit_cert`. If the quorum cert gap is large, force state sync regardless of the commit cert gap.

**Recommended Fix:**

```rust
async fn sync_to_highest_quorum_cert(
    &self,
    highest_quorum_cert: QuorumCert,
    highest_commit_cert: WrappedLedgerInfo,
    retriever: &mut BlockRetriever,
) -> anyhow::Result<()> {
    // Check both commit cert and quorum cert gaps
    let need_sync_for_commit = self.need_sync_for_ledger_info(highest_commit_cert.ledger_info());
    
    // Also check if the quorum cert is too far ahead
    let max_commit_gap = 30.max(2 * self.vote_back_pressure_limit);
    let qc_round = highest_quorum_cert.certified_block().round();
    let local_ordered_round = self.ordered_root().round();
    let need_sync_for_qc = qc_round > local_ordered_round + max_commit_gap;
    
    if !need_sync_for_commit && !need_sync_for_qc {
        return Ok(());
    }
    
    // ... rest of the function
}
```

**Alternative Fix:**

Add a maximum iteration limit to `fetch_quorum_cert()` and fall back to state sync if exceeded:

```rust
async fn fetch_quorum_cert(
    &self,
    qc: QuorumCert,
    retriever: &mut BlockRetriever,
) -> anyhow::Result<()> {
    let mut pending = vec![];
    let mut retrieve_qc = qc.clone();
    let max_iterations = 30; // or use max_commit_gap
    let mut iteration_count = 0;
    
    loop {
        if self.block_exists(retrieve_qc.certified_block().id()) {
            break;
        }
        
        iteration_count += 1;
        if iteration_count > max_iterations {
            // Gap too large, should have used state sync
            bail!("fetch_quorum_cert exceeded maximum iterations, gap too large");
        }
        
        // ... rest of the loop
    }
    // ... rest of the function
}
```

## Proof of Concept

```rust
#[tokio::test]
async fn test_sync_manager_gap_exploit() {
    use aptos_consensus_types::{
        block::Block,
        quorum_cert::QuorumCert,
        sync_info::SyncInfo,
        wrapped_ledger_info::WrappedLedgerInfo,
    };
    use aptos_types::ledger_info::{LedgerInfo, LedgerInfoWithSignatures};
    
    // Setup: Create a victim node at round 100
    let victim_commit_round = 100;
    
    // Attacker crafts SyncInfo with:
    // - highest_commit_cert at round 129 (just within 30-round gap)
    // - highest_quorum_cert at round 10100 (far ahead)
    
    let commit_round = 129; // victim_commit_round + 29
    let quorum_round = 10100; // victim_commit_round + 10000
    
    // Create commit cert at round 129
    let commit_ledger_info = LedgerInfo::new(
        BlockInfo::new(
            /* epoch */ 1,
            commit_round,
            HashValue::random(),
            HashValue::random(),
            /* version */ commit_round,
            /* timestamp */ 0,
            None,
        ),
        HashValue::zero(),
    );
    
    // Create mock signatures (in real attack, attacker needs valid signatures)
    let commit_cert = WrappedLedgerInfo::new(
        /* commit_info */ commit_ledger_info.commit_info().clone(),
        LedgerInfoWithSignatures::new(commit_ledger_info, BTreeMap::new()),
    );
    
    // Create quorum cert at round 10100
    let qc_block = Block::new_proposal(
        /* payload */ vec![],
        quorum_round,
        /* timestamp */ 0,
        /* quorum_cert */ QuorumCert::certificate_for_genesis(),
        /* validator_signer */ &validator_signer,
    );
    
    let malicious_qc = QuorumCert::new(
        VoteData::new(qc_block.gen_block_info(), qc_block.quorum_cert().certified_block().clone()),
        /* ledger_info */ commit_cert.ledger_info().clone(),
    );
    
    let malicious_sync_info = SyncInfo::new_decoupled(
        malicious_qc,
        commit_cert.clone(),
        commit_cert.clone(),
        None,
    );
    
    // When victim processes this SyncInfo:
    // 1. need_sync_for_ledger_info(commit_cert) returns false (129 - 100 = 29 < 30)
    // 2. sync_to_highest_quorum_cert() exits early
    // 3. insert_quorum_cert() is called with QC at round 10100
    // 4. fetch_quorum_cert() attempts to fetch ~10000 blocks one at a time
    
    // Verify that the gap check incorrectly allows this:
    let max_commit_gap = 30;
    let min_commit_round = commit_round.saturating_sub(max_commit_gap);
    assert!(victim_commit_round >= min_commit_round); // Passes check!
    
    // But the QC gap is enormous:
    let qc_gap = quorum_round - victim_commit_round;
    assert_eq!(qc_gap, 10000); // This should trigger state sync but doesn't!
    
    println!("Exploit successful: bypassed sync check with {} round gap", qc_gap);
}
```

**Test Execution Steps:**

1. Deploy the PoC test in `consensus/src/block_storage/sync_manager_test.rs`
2. Run with: `cargo test test_sync_manager_gap_exploit`
3. Observe that the victim node would incorrectly skip state sync despite the 10,000 round gap
4. In a live network scenario, monitor network traffic showing thousands of individual block retrieval RPCs
5. Measure victim node CPU/memory usage during the attack showing resource exhaustion

### Citations

**File:** consensus/src/block_storage/sync_manager.rs (L65-92)
```rust
    pub fn need_sync_for_ledger_info(&self, li: &LedgerInfoWithSignatures) -> bool {
        const MAX_PRECOMMIT_GAP: u64 = 200;
        let block_not_exist = self.ordered_root().round() < li.commit_info().round()
            && !self.block_exists(li.commit_info().id());
        // TODO move min gap to fallback (30) to config, and if configurable make sure the value is
        // larger than buffer manager MAX_BACKLOG (20)
        let max_commit_gap = 30.max(2 * self.vote_back_pressure_limit);
        let min_commit_round = li.commit_info().round().saturating_sub(max_commit_gap);
        let current_commit_round = self.commit_root().round();

        if let Some(pre_commit_status) = self.pre_commit_status() {
            let mut status_guard = pre_commit_status.lock();
            if block_not_exist || status_guard.round() < min_commit_round {
                // pause the pre_commit so that pre_commit task doesn't over-commit
                // it can still commit if it receives the LI previously forwarded,
                // but it won't exceed the LI here
                // it'll resume after state sync is done
                status_guard.pause();
                true
            } else {
                if current_commit_round + MAX_PRECOMMIT_GAP < status_guard.round() {
                    status_guard.pause();
                }
                false
            }
        } else {
            block_not_exist || current_commit_round < min_commit_round
        }
```

**File:** consensus/src/block_storage/sync_manager.rs (L144-145)
```rust
        self.insert_quorum_cert(sync_info.highest_quorum_cert(), &mut retriever)
            .await?;
```

**File:** consensus/src/block_storage/sync_manager.rs (L240-262)
```rust
        loop {
            if self.block_exists(retrieve_qc.certified_block().id()) {
                break;
            }
            BLOCKS_FETCHED_FROM_NETWORK_WHILE_INSERTING_QUORUM_CERT.inc_by(1);
            let target_block_retrieval_payload = match &self.window_size {
                None => TargetBlockRetrieval::TargetBlockId(retrieve_qc.certified_block().id()),
                Some(_) => TargetBlockRetrieval::TargetRound(retrieve_qc.certified_block().round()),
            };
            let mut blocks = retriever
                .retrieve_blocks_in_range(
                    retrieve_qc.certified_block().id(),
                    1,
                    target_block_retrieval_payload,
                    qc.ledger_info()
                        .get_voters(&retriever.validator_addresses()),
                )
                .await?;
            // retrieve_blocks_in_range guarantees that blocks has exactly 1 element
            let block = blocks.remove(0);
            retrieve_qc = block.quorum_cert().clone();
            pending.push(block);
        }
```

**File:** consensus/src/block_storage/sync_manager.rs (L285-286)
```rust
        if !self.need_sync_for_ledger_info(highest_commit_cert.ledger_info()) {
            return Ok(());
```

**File:** consensus/consensus-types/src/sync_info.rs (L152-165)
```rust
        ensure!(
            self.highest_quorum_cert.certified_block().round()
                >= self.highest_ordered_cert().commit_info().round(),
            "HQC has lower round than HOC"
        );

        ensure!(
            self.highest_ordered_round() >= self.highest_commit_round(),
            format!(
                "HOC {} has lower round than HLI {}",
                self.highest_ordered_cert(),
                self.highest_commit_cert()
            )
        );
```
