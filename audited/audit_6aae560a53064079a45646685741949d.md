# Audit Report

## Title
Governance Bypass via Stale Feature Flags in Transaction Validation - VMValidator Environment Not Updated After Feature Changes

## Summary
The `VMValidator` in the mempool validation pipeline fails to update its cached `AptosEnvironment` when `notify_commit()` is called after governance-driven feature flag changes. This creates a critical window where transactions using disabled features can pass validation and enter the mempool, bypassing governance security controls.

## Finding Description

The vulnerability exists in the state update mechanism of `VMValidator` at the intersection of three components:

**Root Cause**: The `notify_commit()` function conditionally updates the validator's state based on version compatibility [1](#0-0) . When `old_version <= new_version`, it calls `reset_state_view()` instead of `reset_all()` [2](#0-1) .

The `reset_state_view()` function only updates the underlying state view snapshot [3](#0-2) , but does NOT update the `environment` field which contains the cached `Features` configuration [4](#0-3) .

In contrast, `reset_all()` creates a fresh environment from the new state view [5](#0-4) .

**Attack Scenario**:

1. **Initial State (Version N)**: A feature flag (e.g., `WEBAUTHN_SIGNATURE`) is enabled. VMValidator has an environment with this feature enabled.

2. **Governance Action (Version N+1)**: A critical security vulnerability is discovered in WebAuthn signature handling. Governance executes a proposal to disable `WEBAUTHN_SIGNATURE` via `change_feature_flags_for_next_epoch()` [6](#0-5) , which allows disabling features.

3. **Stale Environment Window**: When `notify_commit()` is called after the governance change:
   - The condition `old_version (N) <= new_version (N+1)` evaluates to true
   - Only `reset_state_view()` is called, updating the state view to point at version N+1
   - The `environment` field retains features from version N where `WEBAUTHN_SIGNATURE` is still enabled

4. **Validation Bypass**: When a transaction with WebAuthn signature arrives:
   - `validate_transaction()` checks feature flags using `self.features()` [7](#0-6) 
   - `self.features()` delegates to the stale environment [8](#0-7) 
   - The feature appears enabled (stale data from version N)
   - The transaction bypasses the early rejection and enters mempool
   - **But it should have been rejected** because `WEBAUTHN_SIGNATURE` is now disabled at version N+1

The same vulnerability affects all feature-gated validation checks performed in Rust before Move prologue execution, including `SINGLE_SENDER_AUTHENTICATOR` [9](#0-8) , `SLH_DSA_SHA2_128S_SIGNATURE` [10](#0-9) , and `ALLOW_SERIALIZED_SCRIPT_ARGS` [11](#0-10) .

## Impact Explanation

**Severity: High** (potentially Critical depending on the disabled feature)

This vulnerability constitutes a **significant protocol violation** qualifying for High severity under the Aptos bug bounty criteria:

1. **Governance Bypass**: The core security guarantee of on-chain governance—that feature flag changes immediately affect validation—is violated. Governance cannot effectively disable features for security reasons.

2. **Security Control Circumvention**: When a feature is disabled due to a discovered vulnerability, the stale environment allows exploitation during the window before the environment is refreshed.

3. **Mempool Pollution**: Invalid transactions that should be rejected can enter the mempool, potentially causing:
   - Consensus disagreements if different validators have different environment freshness
   - Wasted resources processing invalid transactions
   - DoS vectors if attackers flood with transactions using disabled features

4. **Window Duration**: The vulnerable window persists until either:
   - A transaction validation that triggers a different code path causes `reset_all()` to be called
   - The validator restarts and reinitializes
   - This could span multiple blocks, especially in low-traffic periods

The impact escalates to **Critical** severity if the disabled feature has an actively exploitable vulnerability (e.g., signature forgery, gas calculation error, or consensus-breaking behavior).

## Likelihood Explanation

**Likelihood: High**

1. **Governance Feature Changes Are Common**: Feature flags are regularly toggled via governance proposals as the protocol evolves [12](#0-11) .

2. **Security-Motivated Disables Are Rare But Critical**: While less frequent than feature enables, security-critical feature disables do occur when vulnerabilities are discovered.

3. **Attack Complexity Is Low**: 
   - No validator access required
   - Attacker only needs to observe governance proposals (public on-chain)
   - Can send transactions immediately after epoch change
   - No special privileges needed

4. **Detection Is Difficult**: The vulnerability window may go unnoticed as transactions appear to validate normally from the attacker's perspective.

5. **Every Validator Is Affected**: The bug exists in the core validation logic, affecting all nodes running the standard implementation.

## Recommendation

**Fix**: Always update the environment when the state view version changes. Replace the conditional logic in `notify_commit()`:

In `vm-validator/src/vm_validator.rs`, modify the `notify_commit()` function:

```rust
fn notify_commit(&mut self) {
    let db_state_view = self.db_state_view();
    
    // Always refresh environment when version changes
    let base_view_id = self.state.state_view_id();
    let new_view_id = db_state_view.id();
    
    match (base_view_id, new_view_id) {
        (
            StateViewId::TransactionValidation {
                base_version: old_version,
            },
            StateViewId::TransactionValidation {
                base_version: new_version,
            },
        ) => {
            // If version changed, fully reset to ensure environment is fresh
            if old_version != new_version {
                self.state.reset_all(db_state_view.into());
            }
            // If version unchanged, no update needed
        },
        // If incompatible view types, fully reset
        _ => self.state.reset_all(db_state_view.into()),
    }
}
```

**Alternative Fix**: Modify `reset_state_view()` to also update the environment:

In `aptos-move/aptos-resource-viewer/src/module_view.rs`:

```rust
pub fn reset_state_view(&mut self, state_view: S) {
    self.state_view = state_view;
    // Also refresh environment to pick up feature flag changes
    self.environment = AptosEnvironment::new(&self.state_view);
}
```

**Additional Safeguards**:
1. Add monitoring/metrics to detect environment staleness
2. Add an assertion that environment version matches state view version during validation
3. Consider making environment update mandatory on every `notify_commit()` to eliminate the optimization

## Proof of Concept

```rust
#[test]
fn test_governance_bypass_via_stale_environment() {
    // 1. Setup: Create validator with WEBAUTHN_SIGNATURE enabled
    let db = create_test_db_with_feature_enabled(FeatureFlag::WEBAUTHN_SIGNATURE);
    let mut validator = PooledVMValidator::new(Arc::new(db.clone()), 1);
    
    // 2. Governance disables the feature at version N+1
    let governance_txn = create_governance_proposal_to_disable_feature(
        FeatureFlag::WEBAUTHN_SIGNATURE
    );
    db.commit_transaction(governance_txn);
    
    // 3. Trigger notify_commit - this should refresh environment but doesn't
    validator.notify_commit();
    
    // 4. Create transaction using WebAuthn signature
    let txn_with_webauthn = create_test_txn_with_webauthn_signature();
    
    // 5. Validate - should FAIL but PASSES due to stale environment
    let result = validator.validate_transaction(txn_with_webauthn);
    
    // BUG: Transaction is accepted when it should be rejected
    assert!(result.is_ok(), "Transaction should be rejected but passes validation");
    
    // 6. Verify environment is stale
    let current_features = db.latest_state_checkpoint_view()
        .unwrap()
        .get_features()
        .unwrap();
    assert!(!current_features.is_enabled(FeatureFlag::WEBAUTHN_SIGNATURE));
    
    // But validator's environment still shows it enabled
    let validator_env = validator.vm_validators[0].lock().unwrap();
    assert!(validator_env.state.environment.features()
        .is_enabled(FeatureFlag::WEBAUTHN_SIGNATURE));
}
```

## Notes

**Additional Context**:

1. The vulnerability is **not** present in block execution paths, only in mempool validation, because block execution creates fresh environments for each block [13](#0-12) .

2. The original optimization (avoiding full reset when versions are compatible) was likely intended to preserve module cache performance [14](#0-13) . However, feature flags are a critical part of validation security and must be kept fresh.

3. This affects all feature flags checked in Rust validation code, not just cryptographic signature features. Any feature that gates transaction acceptance is vulnerable.

4. The issue is exacerbated during epoch transitions when governance proposals typically take effect [15](#0-14) , creating a predictable exploitation window.

### Citations

**File:** vm-validator/src/vm_validator.rs (L76-99)
```rust
    fn notify_commit(&mut self) {
        let db_state_view = self.db_state_view();

        // On commit, we need to update the state view so that we can see the latest resources.
        let base_view_id = self.state.state_view_id();
        let new_view_id = db_state_view.id();
        match (base_view_id, new_view_id) {
            (
                StateViewId::TransactionValidation {
                    base_version: old_version,
                },
                StateViewId::TransactionValidation {
                    base_version: new_version,
                },
            ) => {
                // if the state view forms a linear history, just update the state view
                if old_version <= new_version {
                    self.state.reset_state_view(db_state_view.into());
                }
            },
            // if the version is incompatible, we flush the cache
            _ => self.state.reset_all(db_state_view.into()),
        }
    }
```

**File:** aptos-move/aptos-resource-viewer/src/module_view.rs (L96-97)
```rust
    /// Stores configs needed for execution.
    pub environment: AptosEnvironment,
```

**File:** aptos-move/aptos-resource-viewer/src/module_view.rs (L101-102)
```rust
    pub module_cache:
        UnsyncModuleCache<ModuleId, CompiledModule, Module, AptosModuleExtension, usize>,
```

**File:** aptos-move/aptos-resource-viewer/src/module_view.rs (L123-125)
```rust
    pub fn reset_state_view(&mut self, state_view: S) {
        self.state_view = state_view;
    }
```

**File:** aptos-move/aptos-resource-viewer/src/module_view.rs (L134-138)
```rust
    pub fn reset_all(&mut self, state_view: S) {
        self.state_view = state_view;
        self.environment = AptosEnvironment::new(&self.state_view);
        self.module_cache = UnsyncModuleCache::empty();
    }
```

**File:** aptos-move/framework/move-stdlib/sources/configs/features.move (L790-800)
```text
    fun change_feature_flags_internal(framework: &signer, enable: vector<u64>, disable: vector<u64>) acquires Features {
        assert!(signer::address_of(framework) == @std, error::permission_denied(EFRAMEWORK_SIGNER_NEEDED));
        if (!exists<Features>(@std)) {
            move_to<Features>(framework, Features { features: vector[] })
        };
        let features = &mut Features[@std].features;
        enable.for_each_ref(|feature| {
            set(features, *feature, true);
        });
        disable.for_each_ref(|feature| {
            set(features, *feature, false);
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L3172-3178)
```rust
        if !self
            .features()
            .is_enabled(FeatureFlag::SINGLE_SENDER_AUTHENTICATOR)
        {
            if let aptos_types::transaction::authenticator::TransactionAuthenticator::SingleSender{ .. } = transaction.authenticator_ref() {
                return VMValidatorResult::error(StatusCode::FEATURE_UNDER_GATING);
            }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L3181-3194)
```rust
        if !self.features().is_enabled(FeatureFlag::WEBAUTHN_SIGNATURE) {
            if let Ok(sk_authenticators) = transaction
                .authenticator_ref()
                .to_single_key_authenticators()
            {
                for authenticator in sk_authenticators {
                    if let AnySignature::WebAuthn { .. } = authenticator.signature() {
                        return VMValidatorResult::error(StatusCode::FEATURE_UNDER_GATING);
                    }
                }
            } else {
                return VMValidatorResult::error(StatusCode::INVALID_SIGNATURE);
            }
        }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L3196-3212)
```rust
        if !self
            .features()
            .is_enabled(FeatureFlag::SLH_DSA_SHA2_128S_SIGNATURE)
        {
            if let Ok(sk_authenticators) = transaction
                .authenticator_ref()
                .to_single_key_authenticators()
            {
                for authenticator in sk_authenticators {
                    if let AnySignature::SlhDsa_Sha2_128s { .. } = authenticator.signature() {
                        return VMValidatorResult::error(StatusCode::FEATURE_UNDER_GATING);
                    }
                }
            } else {
                return VMValidatorResult::error(StatusCode::INVALID_SIGNATURE);
            }
        }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L3214-3227)
```rust
        if !self
            .features()
            .is_enabled(FeatureFlag::ALLOW_SERIALIZED_SCRIPT_ARGS)
        {
            if let Ok(TransactionExecutableRef::Script(script)) =
                transaction.payload().executable_ref()
            {
                for arg in script.args() {
                    if let TransactionArgument::Serialized(_) = arg {
                        return VMValidatorResult::error(StatusCode::FEATURE_UNDER_GATING);
                    }
                }
            }
        }
```

**File:** types/src/on_chain_config/aptos_features.rs (L76-80)
```rust
    MULTISIG_V2_ENHANCEMENT = 55,
    DELEGATION_POOL_ALLOWLISTING = 56,
    MODULE_EVENT_MIGRATION = 57,
    /// Enabled on mainnet, can never be disabled.
    _REJECT_UNSTABLE_BYTECODE = 58,
```

**File:** aptos-move/aptos-release-builder/src/components/feature_flags.rs (L614-627)
```rust
            .any(|f| !on_chain_features.is_enabled(AptosFeatureFlag::from(f.clone())))
            || self
                .disabled
                .iter()
                .any(|f| on_chain_features.is_enabled(AptosFeatureFlag::from(f.clone())))
    }
}

impl From<&AptosFeatures> for Features {
    fn from(features: &AptosFeatures) -> Features {
        let mut enabled = vec![];
        let mut disabled = vec![];
        for feature in FeatureFlag::iter() {
            if features.is_enabled(AptosFeatureFlag::from(feature.clone())) {
```

**File:** aptos-move/aptos-vm-environment/src/environment.rs (L37-41)
```rust
impl AptosEnvironment {
    /// Returns new execution environment based on the current state.
    pub fn new(state_view: &impl StateView) -> Self {
        Self(TriompheArc::new(Environment::new(state_view, false, None)))
    }
```

**File:** aptos-move/framework/aptos-framework/sources/reconfiguration_with_dkg.move (L1-50)
```text
/// Reconfiguration with DKG helper functions.
module aptos_framework::reconfiguration_with_dkg {
    use std::features;
    use std::option;
    use aptos_framework::consensus_config;
    use aptos_framework::dkg;
    use aptos_framework::execution_config;
    use aptos_framework::gas_schedule;
    use aptos_framework::jwk_consensus_config;
    use aptos_framework::jwks;
    use aptos_framework::keyless_account;
    use aptos_framework::randomness_api_v0_config;
    use aptos_framework::randomness_config;
    use aptos_framework::randomness_config_seqnum;
    use aptos_framework::reconfiguration;
    use aptos_framework::reconfiguration_state;
    use aptos_framework::stake;
    use aptos_framework::system_addresses;
    friend aptos_framework::block;
    friend aptos_framework::aptos_governance;

    /// Trigger a reconfiguration with DKG.
    /// Do nothing if one is already in progress.
    public(friend) fun try_start() {
        let incomplete_dkg_session = dkg::incomplete_session();
        if (option::is_some(&incomplete_dkg_session)) {
            let session = option::borrow(&incomplete_dkg_session);
            if (dkg::session_dealer_epoch(session) == reconfiguration::current_epoch()) {
                return
            }
        };
        reconfiguration_state::on_reconfig_start();
        let cur_epoch = reconfiguration::current_epoch();
        dkg::start(
            cur_epoch,
            randomness_config::current(),
            stake::cur_validator_consensus_infos(),
            stake::next_validator_consensus_infos(),
        );
    }

    /// Clear incomplete DKG session, if it exists.
    /// Apply buffered on-chain configs (except for ValidatorSet, which is done inside `reconfiguration::reconfigure()`).
    /// Re-enable validator set changes.
    /// Run the default reconfiguration to enter the new epoch.
    public(friend) fun finish(framework: &signer) {
        system_addresses::assert_aptos_framework(framework);
        dkg::try_clear_incomplete_session(framework);
        consensus_config::on_new_epoch(framework);
        execution_config::on_new_epoch(framework);
```
