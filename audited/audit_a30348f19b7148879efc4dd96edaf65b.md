# Audit Report

## Title
Insecure Random Coefficient Generation in DKG Schnorr Batch Verification Enables Potential Consensus Manipulation

## Summary
The PVSS Schnorr proof-of-knowledge batch verification uses `thread_rng()` instead of a Fiat-Shamir transform to derive the random linear combination coefficient `gamma`. This violates cryptographic best practices, weakens the security proof of batch verification, and potentially enables attacks if RNG state can be predicted or observed through side channels. The code explicitly acknowledges this security risk.

## Finding Description

The `pok_batch_verify()` function in the Schnorr PoK verification accepts a `gamma` parameter that should be derived cryptographically from the transcript using a Fiat-Shamir transform [1](#0-0) . However, the calling code in both unweighted and weighted DKG protocols generates this critical randomness using `thread_rng()` instead [2](#0-1)  and [3](#0-2) .

The code comment explicitly acknowledges: **"Creates bad RNG risks but we deem that acceptable"** [4](#0-3) .

**Security Guarantees Broken:**

1. **Cryptographic Correctness Invariant**: The batch verification security proof requires that random coefficients be unpredictable to the prover and cryptographically bound to the transcript. Using `thread_rng()` violates this requirement.

2. **Consensus Determinism**: By using independent `thread_rng()` calls, different validators may generate different `gamma` values when verifying the same DKG transcript, potentially leading to non-deterministic verification results across the validator set.

3. **DKG Integrity**: The distributed key generation protocol's security depends on proper verification of Schnorr proofs-of-knowledge. Weakened batch verification can allow acceptance of invalid DKG contributions.

**Attack Vector:**

An attacker who can:
- Observe or predict `thread_rng()` state through timing attacks, side channels, or environmental manipulation
- Submit multiple DKG transcripts with controlled timing
- Leverage partial knowledge of RNG state

Could potentially craft invalid Schnorr proofs that:
- Would fail individual verification
- Pass batch verification with specific predicted `gamma` values
- Result in acceptance of corrupted DKG transcripts

The codebase demonstrates knowledge of proper Fiat-Shamir implementation [5](#0-4)  and even has a domain-separator tag defined for this purpose [6](#0-5) , but deliberately chose not to use it in batch verification.

## Impact Explanation

**Critical Severity** - This vulnerability affects the DKG protocol, which is integrated into Aptos consensus for validator set randomness [7](#0-6) .

**Potential Impacts:**
1. **Consensus Safety Violation**: Acceptance of invalid DKG transcripts could compromise the distributed key generation process used for on-chain randomness
2. **Validator Set Manipulation**: Corrupted DKG outputs could affect leader election and validator selection
3. **Non-Deterministic Verification**: Different validators using different random values could disagree on transcript validity, causing consensus splits

This meets the **Critical Severity** criteria for "Consensus/Safety violations" per the Aptos bug bounty program.

## Likelihood Explanation

**Likelihood: Medium**

While exploiting this requires sophisticated attacks (RNG state prediction, timing manipulation, side-channel observation), several factors increase likelihood:

1. **Acknowledged Risk**: Code comments explicitly recognize this as a security trade-off
2. **Critical Component**: DKG is used during epoch transitions, a sensitive operation
3. **Weakened Security Model**: The lack of cryptographic binding fundamentally weakens the batch verification scheme
4. **Side Channel Potential**: Modern cryptographic research has demonstrated numerous side-channel attacks on RNG implementations
5. **Non-Determinism Risk**: Independent random generation across validators creates consensus fragility

The attack complexity is high but the potential impact on consensus justifies classification as a serious vulnerability.

## Recommendation

Replace `thread_rng()` with a proper Fiat-Shamir transform that derives the random coefficients from the transcript itself:

**Step 1**: Modify `pok_batch_verify()` to accept the transcript or compute the hash internally:

```rust
pub fn pok_batch_verify<'a, Gr>(
    poks: &Vec<(Gr, PoK<Gr>)>,
    g: &Gr,
) -> anyhow::Result<()>
where
    Gr: Serialize + Group + Mul<&'a Scalar> + HasMultiExp,
{
    // Derive gamma using Fiat-Shamir transform from the transcript
    let mut transcript_bytes = Vec::new();
    poks.serialize(&mut transcript_bytes)?;
    g.serialize(&mut transcript_bytes)?;
    
    let gamma = hash_to_scalar(&transcript_bytes, b"APTOS_DKG_BATCH_VERIFY_DST");
    
    // ... rest of verification logic unchanged
}
```

**Step 2**: Update callers to remove the `thread_rng()` generation:

In `unweighted_protocol.rs` and `weighted_protocol.rs`, replace:
```rust
let mut rng = thread_rng();
let extra = random_scalars(2, &mut rng);
batch_verify_soks::<G2Projective, A>(..., &extra[0])?;
```

With:
```rust
// Use transcript-derived randomness via Fiat-Shamir
batch_verify_soks::<G2Projective, A>(...)?;
```

This ensures:
1. Deterministic verification across all validators
2. Unpredictable-to-prover randomness
3. Compliance with cryptographic best practices
4. Maintains the security proof of batch verification

## Proof of Concept

```rust
// Conceptual PoC demonstrating the vulnerability
// File: test_batch_verify_nondeterminism.rs

use aptos_dkg::pvss::{schnorr, das::unweighted_protocol::Transcript};
use rand::thread_rng;

#[test]
fn test_batch_verification_nondeterminism() {
    // Setup: Create a valid DKG transcript
    let transcript = create_valid_dkg_transcript();
    
    // Validator A verifies with their own thread_rng()
    let mut rng_a = thread_rng();
    let gamma_a = random_scalar(&mut rng_a);
    let result_a = verify_with_gamma(&transcript, &gamma_a);
    
    // Validator B verifies with their own thread_rng()  
    let mut rng_b = thread_rng();
    let gamma_b = random_scalar(&mut rng_b);
    let result_b = verify_with_gamma(&transcript, &gamma_b);
    
    // ISSUE: gamma_a != gamma_b in general
    // For edge-case invalid transcripts near the verification boundary,
    // result_a might differ from result_b, causing consensus divergence
    
    assert_ne!(gamma_a, gamma_b);
    // In production, this could lead to:
    // - Validator A accepts the transcript
    // - Validator B rejects the transcript  
    // - Consensus failure
}

// Attack PoC: Craft invalid proofs exploiting predicted gamma
#[test]
fn test_batch_verify_attack_with_predicted_gamma() {
    // If attacker can predict gamma through timing/side-channels:
    let predicted_gamma = predict_rng_state_through_side_channel();
    
    // Craft invalid individual proofs that pass batch verification
    let invalid_poks = craft_invalid_proofs_for_gamma(predicted_gamma);
    
    // These would fail individual verification:
    for (pk, pok) in &invalid_poks {
        assert!(schnorr_verify_individual(pk, pok).is_err());
    }
    
    // But pass batch verification with predicted gamma:
    let result = pok_batch_verify(&invalid_poks, &g, &predicted_gamma);
    assert!(result.is_ok()); // VULNERABILITY: Invalid proofs accepted!
}
```

## Notes

This vulnerability represents a fundamental deviation from cryptographic best practices in batch verification schemes. The explicit code comment acknowledging "bad RNG risks" indicates conscious acceptance of this security trade-off. However, for a consensus-critical component like DKG, such trade-offs are inappropriate.

The proper Fiat-Shamir transform infrastructure already exists in the codebase [8](#0-7) , suggesting this is a fixable implementation choice rather than a fundamental limitation.

The fix is straightforward and should be prioritized given DKG's role in consensus security.

### Citations

**File:** crates/aptos-dkg/src/pvss/schnorr.rs (L69-73)
```rust
pub fn pok_batch_verify<'a, Gr>(
    poks: &Vec<(Gr, PoK<Gr>)>,
    g: &Gr,
    gamma: &Scalar,
) -> anyhow::Result<()>
```

**File:** crates/aptos-dkg/src/pvss/das/unweighted_protocol.rs (L250-263)
```rust
        // Deriving challenges by flipping coins: less complex to implement & less likely to get wrong. Creates bad RNG risks but we deem that acceptable.
        let mut rng = thread_rng();
        let extra = random_scalars(2, &mut rng);

        // Verify signature(s) on the secret commitment, player ID and `aux`
        let g_2 = *pp.get_commitment_base();
        batch_verify_soks::<G2Projective, A>(
            self.soks.as_slice(),
            &g_2,
            &self.V[sc.n],
            spks,
            auxs,
            &extra[0],
        )?;
```

**File:** crates/aptos-dkg/src/pvss/das/weighted_protocol.rs (L295-309)
```rust
        // Deriving challenges by flipping coins: less complex to implement & less likely to get wrong. Creates bad RNG risks but we deem that acceptable.
        let mut rng = rand::thread_rng();
        let extra = random_scalars(2 + W * 3, &mut rng);

        let sok_vrfy_challenge = &extra[W * 3 + 1];
        let g_2 = pp.get_commitment_base();
        let g_1 = pp.get_encryption_public_params().pubkey_base();
        batch_verify_soks::<G1Projective, A>(
            self.soks.as_slice(),
            g_1,
            &self.V[W],
            spks,
            auxs,
            sok_vrfy_challenge,
        )?;
```

**File:** crates/aptos-dkg/src/fiat_shamir.rs (L19-36)
```rust
/// Helper trait for deriving random scalars from a transcript.
///
/// Not every Fiat–Shamir call needs higher-level operations
/// (like appending PVSS information), but most do require scalar
/// derivation. This basic trait provides that functionality.
///
/// ⚠️ This trait is intentionally private: functions like `challenge_scalars`
/// should **only** be used internally to ensure properly
/// labelled scalar generation across Fiat-Shamir protocols.
trait ScalarProtocol<F: PrimeField> {
    fn challenge_full_scalars(&mut self, label: &[u8], num_scalars: usize) -> Vec<F>;

    fn challenge_full_scalar(&mut self, label: &[u8]) -> F {
        self.challenge_full_scalars(label, 1)[0]
    }

    fn challenge_128bit_scalars(&mut self, label: &[u8], num_scalars: usize) -> Vec<F>;
}
```

**File:** crates/aptos-dkg/src/pvss/traits/transcript.rs (L170-171)
```rust
    /// Domain-separator tag (DST) for the Fiat-Shamir hashing used to derive randomness from the transcript.
    fn dst() -> Vec<u8>;
```

**File:** consensus/src/epoch_manager.rs (L72-75)
```rust
use aptos_dkg::{
    pvss::{traits::Transcript, Player},
    weighted_vuf::traits::WeightedVUF,
};
```
