# Audit Report

## Title
Indexer Deletion Flag Inconsistency with Partially Deleted Objects in Resource Groups

## Summary
The Aptos indexer's `is_deleted` flag can become inconsistent with actual blockchain state when objects containing custom resources in their `ObjectGroup` have their `ObjectCore` deleted without removing all member resources. This causes the indexer to report objects as active when they are effectively dead on-chain.

## Finding Description

The vulnerability stems from how the indexer tracks object deletions in the presence of Move resource groups. In Aptos, objects use `ObjectGroup` as a resource group container, and `ObjectCore` is marked as a member of this group: [1](#0-0) 

When processing write set changes, the indexer only marks an object as deleted when it detects a `DeleteResource` operation for the entire `ObjectGroup`: [2](#0-1) 

However, the `object::delete()` function only removes `ObjectCore` and `Untransferable` from storage: [3](#0-2) 

Smart contracts commonly add custom resources to objects that are also `ObjectGroup` members, such as `Listing` and `TokenV1Container` in the marketplace example: [4](#0-3) 

**Attack Scenario:**
1. A smart contract creates an object with `ObjectCore`
2. Custom resources (e.g., `Listing`, `TokenV1Container`) are added via `move_to(&object_signer, CustomResource{...})`
3. Due to a bug or improper cleanup logic, `object::delete(delete_ref)` is called without first removing the custom resources
4. Only `ObjectCore` is deleted; custom resources remain in `ObjectGroup`
5. The resource group is not fully deleted (still has members), so no `DeleteResource` for `ObjectGroup` is generated
6. The indexer's `is_deleted` flag remains `false`: [5](#0-4) 

7. On-chain, `exists<ObjectCore>(address)` returns `false` - the object is dead
8. The indexer incorrectly shows the object as active

The code contains a TODO comment acknowledging this limitation: [6](#0-5) 

## Impact Explanation

This issue qualifies as **Medium Severity** under the Aptos bug bounty program as it causes **state inconsistencies requiring intervention**. The impact includes:

- **Data Corruption**: Applications querying the indexer receive incorrect object state information
- **User Experience Degradation**: Marketplace frontends display "ghost" objects that cannot be interacted with
- **Failed Transactions**: Users attempting operations on indexer-reported "active" objects will fail when the blockchain validates that `ObjectCore` doesn't exist
- **Ecosystem Disruption**: dApps relying on indexer data for object existence checks will malfunction

While this doesn't directly lead to fund loss or consensus violations, it breaks the fundamental invariant that **indexer state should accurately reflect blockchain state**, causing operational issues across the ecosystem.

## Likelihood Explanation

**Likelihood: Medium**

This vulnerability manifests when:
1. Smart contracts use custom resources in `ObjectGroup` (common pattern, as evidenced by 37 files using this pattern): [7](#0-6) 

2. Contract developers fail to properly clean up all resources before calling `object::delete()` (possible due to complexity or bugs)

The pattern is realistic because:
- The Aptos object model encourages adding custom resources to objects
- Cleanup logic can be complex in contracts with multiple resource types
- No compile-time enforcement ensures all resources are removed before deletion
- The issue has been acknowledged but not fixed (TODO comment)

## Recommendation

Implement proper detection of partial object deletion in the indexer by checking for `ObjectCore` existence explicitly:

**Option 1: Track ObjectCore Deletions**
Monitor `DeleteResource` events for `0x1::object::ObjectCore` in addition to `0x1::object::ObjectGroup`, and mark objects as deleted when `ObjectCore` is removed:

```rust
pub fn from_delete_resource(
    delete_resource: &DeleteResource,
    txn_version: i64,
    write_set_change_index: i64,
    object_mapping: &HashMap<CurrentObjectPK, CurrentObject>,
    conn: &mut PgPoolConnection,
) -> anyhow::Result<Option<(Self, CurrentObject)>> {
    let resource_type = delete_resource.resource.to_string();
    
    // Check for both ObjectGroup (full deletion) and ObjectCore (partial deletion)
    if resource_type == "0x1::object::ObjectGroup" || resource_type == "0x1::object::ObjectCore" {
        // ... existing deletion logic
    } else {
        Ok(None)
    }
}
```

**Option 2: Query Blockchain State**
As suggested in the TODO comment, implement KV store queries to verify `ObjectCore` existence when processing objects:

```rust
// After processing WriteResource for objects
if !blockchain_state.exists_resource<ObjectCore>(object_address) {
    current_object.is_deleted = true;
}
```

**Option 3: Framework-Level Fix**
Enhance `object::delete()` to enforce cleanup of all `ObjectGroup` member resources before deletion, or provide a function to query remaining resources.

## Proof of Concept

```move
module test_addr::partial_deletion_poc {
    use std::signer;
    use aptos_framework::object::{Self, ConstructorRef, DeleteRef, ExtendRef, ObjectCore};

    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct CustomResource has key {
        data: u64,
    }

    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct ObjectWrapper has key {
        delete_ref: DeleteRef,
        extend_ref: ExtendRef,
    }

    public entry fun create_object_with_custom_resource(creator: &signer) {
        // Create object
        let constructor_ref = object::create_object_from_account(creator);
        let object_signer = object::generate_signer(&constructor_ref);
        
        // Store wrapper with delete_ref
        let wrapper = ObjectWrapper {
            delete_ref: object::generate_delete_ref(&constructor_ref),
            extend_ref: object::generate_extend_ref(&constructor_ref),
        };
        move_to(&object_signer, wrapper);
        
        // Add custom resource
        move_to(&object_signer, CustomResource { data: 42 });
    }

    public entry fun improperly_delete_object(object_addr: address) acquires ObjectWrapper {
        // This simulates buggy cleanup logic
        let ObjectWrapper { delete_ref, extend_ref: _ } = move_from<ObjectWrapper>(object_addr);
        
        // BUG: Forgot to remove CustomResource before deleting!
        // CustomResource is still in ObjectGroup
        object::delete(delete_ref);
        
        // Result:
        // - ObjectCore is deleted (object is dead on-chain)
        // - CustomResource remains in ObjectGroup
        // - ObjectGroup is not fully deleted
        // - No DeleteResource for ObjectGroup is generated
        // - Indexer's is_deleted remains false (INCONSISTENCY!)
    }
}
```

**Test Steps:**
1. Deploy the module and call `create_object_with_custom_resource`
2. Query indexer: object shows as active (`is_deleted: false`)
3. Call `improperly_delete_object` 
4. On-chain: `exists<ObjectCore>(object_addr)` returns `false`
5. Query indexer: object still shows as active (`is_deleted: false`)
6. **Inconsistency confirmed**: Indexer state diverges from blockchain state

### Citations

**File:** aptos-move/framework/aptos-framework/sources/object.move (L166-167)
```text

    /// Permission to transfer object with permissioned signer.
```

**File:** aptos-move/framework/aptos-framework/sources/object.move (L414-428)
```text
    public fun delete(self: DeleteRef) acquires Untransferable, ObjectCore {
        let object_core = move_from<ObjectCore>(self.self);
        let ObjectCore {
            guid_creation_num: _,
            owner: _,
            allow_ungated_transfer: _,
            transfer_events,
        } = object_core;

        if (exists<Untransferable>(self.self)) {
            let Untransferable {} = move_from<Untransferable>(self.self);
        };

        event::destroy_handle(transfer_events);
    }
```

**File:** crates/indexer/src/models/v2_objects.rs (L91-100)
```rust
                    is_deleted: false,
                },
                CurrentObject {
                    object_address: resource.address,
                    owner_address: object_core.get_owner_address(),
                    state_key_hash: resource.state_key_hash,
                    allow_ungated_transfer: object_core.allow_ungated_transfer,
                    last_guid_creation_num: object_core.guid_creation_num.clone(),
                    last_transaction_version: txn_version,
                    is_deleted: false,
```

**File:** crates/indexer/src/models/v2_objects.rs (L109-110)
```rust
    /// TODO: We need to detect if an object is only partially deleted
    /// using KV store
```

**File:** crates/indexer/src/models/v2_objects.rs (L118-118)
```rust
        if delete_resource.resource.to_string() == "0x1::object::ObjectGroup" {
```

**File:** aptos-move/move-examples/marketplace/sources/listing.move (L39-56)
```text
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    /// Corner-stone for all listings, represents the core utility layer including object
    /// cleanup.
    struct Listing has key {
        /// The item owned by this listing, transferred to the new owner at the end.
        object: Object<ObjectCore>,
        /// The seller of the object
        seller: address,
        /// The fees associated with claiming this listing.
        fee_schedule: Object<FeeSchedule>,
        /// The Unix timestamp in seconds at which point bidding and purchasing can occur
        start_time: u64,
        /// Used to clean-up at the end.
        delete_ref: DeleteRef,
        /// Used to create a signer to transfer the listed item, ideally the TransferRef would
        /// support this.
        extend_ref: ExtendRef,
    }
```
