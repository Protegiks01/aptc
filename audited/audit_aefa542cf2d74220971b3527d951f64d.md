# Audit Report

## Title
Stale Pending Blocks Retained Across Epoch Transitions During Commit Sync

## Summary
The `PendingBlockStore` in the consensus observer fails to clear stale pending blocks from old epochs during commit sync epoch transitions, causing memory exhaustion and state inconsistency. This differs from fallback sync epoch transitions, which properly clear pending blocks.

## Finding Description

The consensus observer maintains a `PendingBlockStore` that holds ordered blocks awaiting their transaction payloads. When ordered block messages arrive without payloads, they are inserted into this store pending payload arrival. However, there is a critical inconsistency in how epoch transitions are handled between two different sync modes:

**Vulnerable Path - Commit Sync Epoch Transition:**

When an ordered block is received, it's inserted into `PendingBlockStore` without validating the epoch: [1](#0-0) 

The insertion happens at line 712 with NO epoch validation. The epoch check only occurs later during `process_ordered_block`: [2](#0-1) 

During commit sync epoch transitions, the code verifies payloads for the new epoch and processes ready blocks, but **never clears stale pending blocks from the old epoch**: [3](#0-2) 

**Contrast with Fallback Sync:**

Fallback sync epoch transitions properly clear pending blocks by calling `clear_pending_block_state()`: [4](#0-3) 

The `clear_block_data()` method clears all pending blocks: [5](#0-4) 

**Exploitation Scenario:**

1. Attacker sends ordered blocks without payloads during epoch N (e.g., via `process_ordered_block_message`)
2. These blocks pass the out-of-date check (line 679-680) and are inserted into `PendingBlockStore` (line 712)
3. Network transitions from epoch N to epoch N+1 via commit sync
4. The commit sync handler (lines 1026-1045) does NOT call `clear_pending_block_state()`
5. Stale epoch N blocks remain in `PendingBlockStore`
6. When payloads eventually arrive for old epoch blocks, they are rejected (verified_payload = false at line 417), so blocks are never removed
7. Process repeats across multiple epochs, accumulating stale blocks until `max_num_pending_blocks` limit is reached

The garbage collection mechanism only removes blocks based on age when the limit is exceeded, not based on epoch validity: [6](#0-5) 

## Impact Explanation

**Severity: Medium** - This qualifies as "State inconsistencies requiring intervention" under the Aptos bug bounty Medium severity category.

**Specific Impacts:**

1. **Memory Exhaustion**: Stale pending blocks accumulate across epoch transitions, consuming memory. While bounded by `max_num_pending_blocks`, this still represents unnecessary resource consumption that grows linearly with epochs.

2. **Metrics Pollution**: Pending block metrics become inaccurate, reporting blocks from multiple old epochs as "pending," confusing monitoring and debugging efforts.

3. **State Inconsistency**: The system maintains stale state from old epochs that should have been cleared, violating the state consistency invariant.

4. **Operational Impact**: When the limit is reached, legitimate new pending blocks may be rejected or oldest blocks GC'd, potentially including valid blocks from the current epoch.

## Likelihood Explanation

**Likelihood: High**

1. **Common Trigger**: Commit sync epoch transitions occur regularly during normal network operation
2. **No Special Privileges Required**: Any network peer can send ordered block messages without payloads
3. **Natural Occurrence**: Even without malicious intent, network delays can cause ordered blocks to arrive before payloads, naturally triggering this condition
4. **Accumulation Over Time**: The issue compounds across multiple epoch transitions, making it increasingly likely to manifest as the network ages

## Recommendation

Add a call to `clear_pending_block_state()` during commit sync epoch transitions to match the behavior of fallback sync epoch transitions. Modify the `process_commit_sync_notification` method:

```rust
// If the epoch has changed, end the current epoch and start the latest one.
let current_epoch_state = self.get_epoch_state();
if synced_epoch > current_epoch_state.epoch {
    // Wait for the latest epoch to start
    self.execution_client.end_epoch().await;
    self.wait_for_epoch_start().await;

    // ADD: Clear pending block state to remove stale blocks from old epoch
    self.clear_pending_block_state().await;

    // Verify the block payloads for the new epoch
    let new_epoch_state = self.get_epoch_state();
    let verified_payload_rounds = self
        .observer_block_data
        .lock()
        .verify_payload_signatures(&new_epoch_state);

    // Order all the pending blocks that are now ready (these were buffered during state sync)
    for payload_round in verified_payload_rounds {
        self.order_ready_pending_block(new_epoch_state.epoch, payload_round)
            .await;
    }
};
```

Alternatively, add epoch validation during pending block insertion to reject blocks from non-current epochs earlier in the pipeline.

## Proof of Concept

```rust
#[cfg(test)]
mod test {
    use super::*;
    
    #[tokio::test]
    async fn test_stale_pending_blocks_across_commit_sync_epoch_transition() {
        // Setup: Create consensus observer with epoch 10
        let mut observer = create_test_consensus_observer(10).await;
        
        // Step 1: Send ordered blocks WITHOUT payloads for epoch 10
        let ordered_block_epoch_10 = create_ordered_block_without_payload(10, 100);
        observer.process_ordered_block_message(
            PeerNetworkId::random(),
            Instant::now(),
            ordered_block_epoch_10.clone()
        ).await;
        
        // Verify block is in pending store
        assert!(observer.observer_block_data.lock()
            .existing_pending_block(&ordered_block_epoch_10));
        
        // Step 2: Trigger commit sync epoch transition to epoch 11
        let ledger_info_epoch_11 = create_ledger_info(11, 0);
        observer.process_commit_sync_notification(ledger_info_epoch_11).await;
        
        // Step 3: Verify stale epoch 10 block is STILL in pending store
        // BUG: This should be false but is true due to missing cleanup
        assert!(observer.observer_block_data.lock()
            .existing_pending_block(&ordered_block_epoch_10));
        
        // Step 4: Send more blocks for epoch 11, then transition to epoch 12
        let ordered_block_epoch_11 = create_ordered_block_without_payload(11, 200);
        observer.process_ordered_block_message(
            PeerNetworkId::random(),
            Instant::now(),
            ordered_block_epoch_11.clone()
        ).await;
        
        let ledger_info_epoch_12 = create_ledger_info(12, 0);
        observer.process_commit_sync_notification(ledger_info_epoch_12).await;
        
        // Step 5: Verify BOTH stale blocks (epoch 10 and 11) remain
        let pending_blocks = observer.observer_block_data.lock()
            .pending_block_store.blocks_without_payloads.len();
        assert_eq!(pending_blocks, 2); // Two stale blocks accumulated
        
        // Expected: pending_blocks should be 0 after each epoch transition
        // Actual: Stale blocks accumulate indefinitely until max_num_pending_blocks limit
    }
}
```

### Citations

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L704-713)
```rust
        // If all payloads exist, process the block. Otherwise, store it
        // in the pending block store and wait for the payloads to arrive.
        if self.all_payloads_exist(pending_block_with_metadata.ordered_block().blocks()) {
            self.process_ordered_block(pending_block_with_metadata)
                .await;
        } else {
            self.observer_block_data
                .lock()
                .insert_pending_block(pending_block_with_metadata);
        }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L728-752)
```rust
        let epoch_state = self.get_epoch_state();
        if ordered_block.proof_block_info().epoch() == epoch_state.epoch {
            if let Err(error) = ordered_block.verify_ordered_proof(&epoch_state) {
                // Log the error and update the invalid message counter
                error!(
                    LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                        "Failed to verify ordered proof! Ignoring: {:?}, from peer: {:?}. Error: {:?}",
                        ordered_block.proof_block_info(),
                        peer_network_id,
                        error
                    ))
                );
                increment_invalid_message_counter(&peer_network_id, metrics::ORDERED_BLOCK_LABEL);
                return;
            }
        } else {
            // Drop the block and log an error (the block should always be for the current epoch)
            error!(
                LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                    "Received ordered block for a different epoch! Ignoring: {:?}",
                    ordered_block.proof_block_info()
                ))
            );
            return;
        };
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L952-961)
```rust
        // If the epoch has changed, end the current epoch and start the latest one
        let current_epoch_state = self.get_epoch_state();
        if epoch > current_epoch_state.epoch {
            // Wait for the latest epoch to start
            self.execution_client.end_epoch().await;
            self.wait_for_epoch_start().await;
        };

        // Reset the pending block state
        self.clear_pending_block_state().await;
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L1026-1045)
```rust
        // If the epoch has changed, end the current epoch and start the latest one.
        let current_epoch_state = self.get_epoch_state();
        if synced_epoch > current_epoch_state.epoch {
            // Wait for the latest epoch to start
            self.execution_client.end_epoch().await;
            self.wait_for_epoch_start().await;

            // Verify the block payloads for the new epoch
            let new_epoch_state = self.get_epoch_state();
            let verified_payload_rounds = self
                .observer_block_data
                .lock()
                .verify_payload_signatures(&new_epoch_state);

            // Order all the pending blocks that are now ready (these were buffered during state sync)
            for payload_round in verified_payload_rounds {
                self.order_ready_pending_block(new_epoch_state.epoch, payload_round)
                    .await;
            }
        };
```

**File:** consensus/src/consensus_observer/observer/block_data.rs (L93-105)
```rust
    pub fn clear_block_data(&mut self) -> LedgerInfoWithSignatures {
        // Clear the payload store
        self.block_payload_store.clear_all_payloads();

        // Clear the ordered blocks
        self.ordered_block_store.clear_all_ordered_blocks();

        // Clear the pending blocks
        self.pending_block_store.clear_missing_blocks();

        // Return the root ledger info
        self.root()
    }
```

**File:** consensus/src/consensus_observer/observer/pending_blocks.rs (L156-195)
```rust
    /// Garbage collects the pending blocks store by removing
    /// the oldest blocks if the store is too large.
    fn garbage_collect_pending_blocks(&mut self) {
        // Verify that both stores have the same number of entries.
        // If not, log an error as this should never happen.
        let num_pending_blocks = self.blocks_without_payloads.len() as u64;
        let num_pending_blocks_by_hash = self.blocks_without_payloads_by_hash.len() as u64;
        if num_pending_blocks != num_pending_blocks_by_hash {
            error!(
                LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                    "The pending block stores have different numbers of entries: {} and {} (by hash)",
                    num_pending_blocks, num_pending_blocks_by_hash
                ))
            );
        }

        // Calculate the number of blocks to remove
        let max_pending_blocks = self.consensus_observer_config.max_num_pending_blocks;
        let num_blocks_to_remove = num_pending_blocks.saturating_sub(max_pending_blocks);

        // Remove the oldest blocks if the store is too large
        for _ in 0..num_blocks_to_remove {
            if let Some((oldest_epoch_round, pending_block)) =
                self.blocks_without_payloads.pop_first()
            {
                // Log a warning message for the removed block
                warn!(
                    LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                        "The pending block store is too large: {:?} blocks. Removing the block for the oldest epoch and round: {:?}",
                        num_pending_blocks, oldest_epoch_round
                    ))
                );

                // Remove the block from the hash store
                let first_block = pending_block.ordered_block().first_block();
                self.blocks_without_payloads_by_hash
                    .remove(&first_block.id());
            }
        }
    }
```
