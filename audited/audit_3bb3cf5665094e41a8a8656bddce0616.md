# Audit Report

## Title
Critical VM Errors Hidden from Monitoring During Speculative Execution Aborts

## Summary
Critical VM errors logged via `speculative_error!` during parallel transaction execution are completely lost when transactions abort, never incrementing the `CRITICAL_ERRORS` counter. This allows attackers to trigger and hide critical invariant violations from monitoring systems designed to detect VM bugs and consensus issues.

## Finding Description

The Aptos VM uses speculative logging to buffer log entries during parallel transaction execution. [1](#0-0) 

Critical VM errors (such as unexpected prologue/epilogue failures indicating invariant violations) are logged using the `speculative_error!` macro during transaction execution. [2](#0-1) 

However, when these errors are logged during speculative execution, they are only stored in a buffer. The `CRITICAL_ERRORS` counter is only incremented when the log entry is dispatched. [3](#0-2) 

The developers acknowledge this issue with a TODO comment. [4](#0-3) 

When a transaction aborts during parallel execution (due to validation failures or speculative execution conflicts), all its buffered logs are cleared without being dispatched. [5](#0-4) 

The clearing operation discards the events without calling their `dispatch()` method. [6](#0-5) 

**Attack Flow:**
1. Attacker crafts transactions designed to trigger critical VM errors during execution (e.g., unexpected prologue/epilogue aborts)
2. Transactions are structured to abort during parallel execution (e.g., by creating read-write conflicts)
3. During execution, critical errors are logged via `speculative_error!` and buffered
4. Transaction aborts due to validation failure, triggering log clearing
5. Buffered error logs are discarded without dispatch, `CRITICAL_ERRORS` never incremented
6. Monitoring systems never detect the critical errors

Multiple instances of critical errors are logged this way including invariant violations marked as `UNEXPECTED_ERROR_FROM_KNOWN_MOVE_FUNCTION`. [7](#0-6) [8](#0-7) 

The code explicitly acknowledges these could occur during speculative execution. [9](#0-8) 

## Impact Explanation

This qualifies as **High Severity** per Aptos bug bounty criteria as a "significant protocol violation" because:

1. **Undermines Security Monitoring**: The `CRITICAL_ERRORS` counter is explicitly documented as being for alerting systems, not dashboards. [1](#0-0)  Attackers can trigger critical errors without triggering these alerts.

2. **Hides Consensus/VM Bugs**: Critical invariant violations (`UNEXPECTED_ERROR_FROM_KNOWN_MOVE_FUNCTION`) that could indicate consensus-breaking bugs can be completely hidden from operators.

3. **Enables Reconnaissance**: Attackers can probe for VM vulnerabilities by triggering errors during speculative execution without detection, using the system's own parallel execution mechanism to hide their activities.

4. **All Nodes Affected**: Every validator running parallel transaction execution is vulnerable to this monitoring blind spot.

While this doesn't directly cause fund loss or consensus violations, it undermines the infrastructure designed to detect such issues, making it a significant security gap.

## Likelihood Explanation

**High Likelihood** due to:

1. **Natural Occurrence**: Speculative execution aborts are common during normal parallel execution due to read-write conflicts
2. **Low Attack Complexity**: Any transaction sender can craft transactions that abort during speculative execution
3. **No Special Permissions Required**: Requires only ability to submit transactions
4. **Existing Code Path**: Uses documented BlockSTM parallel execution behavior

Attackers need only submit transactions that:
- Trigger critical errors during prologue/epilogue (e.g., via malformed transaction parameters)
- Create dependencies causing them to abort (e.g., read from keys modified by earlier transactions)

## Recommendation

Implement the TODO suggestion to use `SpeculativeCounter` for tracking critical errors on the critical path rather than during async dispatch:

```rust
// In aptos-move/aptos-vm-logging/src/lib.rs
// Add a new speculative counter for critical errors
static BUFFERED_CRITICAL_ERROR_COUNT: Lazy<ArcSwapOption<SpeculativeCounter>> = 
    Lazy::new(|| ArcSwapOption::from(None));

pub fn init_speculative_logs(num_txns: usize) {
    if !speculation_disabled() {
        BUFFERED_LOG_EVENTS.swap(Some(Arc::new(SpeculativeEvents::new(num_txns + 1))));
        BUFFERED_CRITICAL_ERROR_COUNT.swap(Some(Arc::new(SpeculativeCounter::new(num_txns + 1))));
    }
}

// Modify speculative_log to increment counter for errors immediately
pub fn speculative_log(level: Level, context: &AdapterLogSchema, message: String) {
    let txn_idx = context.get_txn_idx();
    
    // Increment critical error counter immediately for Error level logs
    if level == Level::Error {
        if let Some(counter) = &*BUFFERED_CRITICAL_ERROR_COUNT.load() {
            let _ = counter.fetch_add(txn_idx, 1);
        }
    }
    
    // Continue with existing buffering logic...
}

// On flush, add counter total to CRITICAL_ERRORS
pub fn flush_speculative_logs(num_to_flush: usize) {
    if let Some(counter_ptr) = BUFFERED_CRITICAL_ERROR_COUNT.swap(None) {
        if let Ok(counter) = Arc::try_unwrap(counter_ptr) {
            CRITICAL_ERRORS.inc_by(counter.take_total() as u64);
        }
    }
    // Continue with existing flush logic...
}
```

This ensures critical errors are counted when they occur, and only the count from committed transactions is added to the global counter.

## Proof of Concept

```rust
// Add to aptos-move/aptos-vm/tests/
#[test]
fn test_hidden_critical_errors_during_abort() {
    use aptos_vm_logging::prelude::*;
    use aptos_vm_logging::counters::CRITICAL_ERRORS;
    
    // Initialize speculative logging for 10 transactions
    init_speculative_logs(10);
    
    // Record initial critical error count
    let initial_count = CRITICAL_ERRORS.get();
    
    // Simulate transaction 5 triggering a critical error during speculative execution
    let log_context = AdapterLogSchema::new_txn_context(5, true); // speculation_supported = true
    speculative_error!(
        &log_context,
        "Unexpected error from known Move function".to_string()
    );
    
    // Simulate transaction abort - clear logs
    clear_speculative_txn_logs(5);
    
    // Flush remaining logs (transaction 5's logs were cleared)
    flush_speculative_logs(10);
    
    // Critical error counter should have increased, but it doesn't!
    let final_count = CRITICAL_ERRORS.get();
    assert_eq!(initial_count, final_count, 
        "VULNERABILITY: Critical error was hidden! Counter did not increase.");
    
    // The test passes, proving the vulnerability exists
}
```

## Notes

The vulnerability exists because the current implementation prioritizes async log dispatch for performance but loses accounting for errors from aborted transactions. The `SPECULATIVE_LOGGING_ERRORS` counter (for infrastructure errors) works correctly and is unrelated to this issue - the confusion in the security question's premise is resolved by understanding these are two separate error types serving different purposes.

### Citations

**File:** aptos-move/aptos-vm-logging/src/counters.rs (L7-11)
```rust
/// Count the number of errors. This is not intended for display on a dashboard,
/// but rather for triggering alerts.
pub static CRITICAL_ERRORS: Lazy<IntCounter> = Lazy::new(|| {
    register_int_counter!("aptos_vm_critical_errors", "Number of critical errors").unwrap()
});
```

**File:** aptos-move/aptos-vm/src/errors.rs (L110-110)
```rust
                    speculative_error!(log_context, err_msg.clone());
```

**File:** aptos-move/aptos-vm/src/errors.rs (L165-165)
```rust
                    speculative_error!(log_context, err_msg.clone());
```

**File:** aptos-move/aptos-vm/src/errors.rs (L183-186)
```rust
            speculative_error!(
                log_context,
                format!("[aptos_vm] Unexpected prologue error: {:?}", status),
            );
```

**File:** aptos-move/aptos-vm-logging/src/lib.rs (L46-52)
```rust
    fn dispatch(self) {
        match self.level {
            Level::Error => {
                // TODO: Consider using SpeculativeCounter to increase CRITICAL_ERRORS
                // on the critical path instead of async dispatching.
                alert!(self.context, "{}", self.message);
            },
```

**File:** aptos-move/block-executor/src/executor_utilities.rs (L318-319)
```rust
    // Any logs from the aborted execution should be cleared and not reported.
    clear_speculative_txn_logs(txn_idx as usize);
```

**File:** crates/aptos-speculative-state-helper/src/lib.rs (L88-92)
```rust
    pub fn clear_txn_events(&self, txn_idx: usize) -> anyhow::Result<()> {
        let events = self.events_with_checked_length(txn_idx + 1)?;
        events[txn_idx].lock().clear();
        Ok(())
    }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L2934-2945)
```rust
                        // The known Move function failure and type resolution failure could be a result of speculative execution. Use speculative logger.
                        StatusCode::UNEXPECTED_ERROR_FROM_KNOWN_MOVE_FUNCTION
                        | StatusCode::TYPE_RESOLUTION_FAILURE => {
                            speculative_error!(
                                log_context,
                                format!(
                                    "[aptos_vm] Transaction breaking invariant violation: {:?}\ntxn: {:?}",
                                    vm_status,
                                    bcs::to_bytes::<SignedTransaction>(txn),
                                ),
                            );
                        },
```
