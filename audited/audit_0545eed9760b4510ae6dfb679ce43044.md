# Audit Report

## Title
Cache Worker Crash Loop Due to Version Gap Detection After Network Interruptions

## Summary
Network interruptions or worker restarts can cause the indexer-grpc cache worker to enter a permanent crash loop when the file store has progressed beyond the cache's `latest_version` pointer. The worker attempts to resume from the file store version without validating compatibility with the cache state, triggering false-positive gap detection that prevents recovery.

## Finding Description
The cache worker maintains a `latest_version` pointer in Redis that tracks the highest version successfully committed to the cache. When processing transaction batches, the worker follows this sequence:

1. Writes individual transactions to Redis cache via spawned async tasks [1](#0-0) 

2. At batch end, atomically updates the `latest_version` pointer using a Lua script [2](#0-1) 

The Lua script enforces strict contiguity, requiring `latest_version + num_of_versions == current_version` [3](#0-2) . If a gap is detected (line 44-45), it returns error code 2, causing the worker to crash [4](#0-3) .

**Vulnerability Scenario:**

1. Cache worker is at version 1000, processing batch 1000-1999
2. Network interruption occurs before receiving BatchEnd signal
3. Worker breaks from streaming loop and reconnects [5](#0-4) 
4. Cache `latest_version` remains at 1000 (never updated)
5. File store worker independently progresses to version 2000
6. Cache worker restarts, reads `starting_version = 2000` from file store [6](#0-5) 
7. Verification only checks file store vs fullnode init signal, NOT cache state [7](#0-6) 
8. Worker processes new batch 2000-2999, attempts to update cache with `update_cache_latest_version(1000, 3000)`
9. Lua script detects gap: `1000 + 1000 = 2000 < 3000` â†’ returns error code 2
10. Worker crashes and enters permanent crash loop

The comment at line 108 indicates this logic was not fully implemented: "TODO: Rewrite logic to actually conform to this description" [8](#0-7) .

## Impact Explanation
This qualifies as **Medium Severity** under Aptos bug bounty criteria: "State inconsistencies requiring intervention."

**Specific Impacts:**
- Cache worker becomes permanently unavailable, requiring manual intervention (reset cache or manually update `latest_version` in Redis)
- Version gap [1000-2000) is missing from cache, breaking query consistency
- Indexer clients querying missing versions receive inconsistent responses
- Requires operational intervention to restore service

This does NOT affect core blockchain consensus or validator operations, as it's purely an indexer infrastructure issue. However, it breaks the indexer's consistency guarantees.

## Likelihood Explanation
**High Likelihood** - This will occur naturally under normal operations:

- Network interruptions are common in distributed systems
- No attacker action required - occurs naturally from infrastructure issues
- File store and cache workers operate independently, making version drift inevitable
- Once triggered, creates a deterministic crash loop with no automatic recovery
- The TODO comment suggests developers were aware of incomplete logic

The vulnerability is particularly likely because:
1. gRPC streams commonly disconnect after timeouts (referenced at line 502-503) [9](#0-8) 
2. File store continues progressing during cache worker downtime
3. No safeguards exist to handle version drift between components

## Recommendation

**Immediate Fix:** Validate cache compatibility before processing new batches:

```rust
// In Worker::run(), after line 139
let cache_latest_version = CacheOperator::new(conn.clone(), self.cache_storage_format)
    .get_latest_version()
    .await?;

if let Some(cache_version) = cache_latest_version {
    if starting_version > cache_version + 1 {
        tracing::warn!(
            cache_version = cache_version,
            file_store_version = starting_version,
            "[Indexer Cache] Detected version gap. Resetting cache latest_version to align with file store."
        );
        // Option 1: Reset cache to file store version (loses some cached data)
        cache_operator.update_cache_latest_version(0, starting_version).await?;
        
        // Option 2: Fill gap by requesting missing versions from fullnode
        // Request transactions [cache_version, starting_version) and populate cache
    }
}
```

**Long-term Solution:**
1. Implement gap-filling logic to backfill missing versions from fullnode or file store
2. Store checkpoint metadata to enable safe resume points
3. Add monitoring/alerts for version drift between components
4. Consider making cache worker idempotent to handle replayed batches

## Proof of Concept

```rust
// Integration test demonstrating the crash loop
#[tokio::test]
async fn test_cache_worker_gap_detection_crash() {
    // Setup: Redis with cache at version 1000
    let redis_client = redis::Client::open("redis://127.0.0.1/").unwrap();
    let mut conn = redis_client.get_tokio_connection_manager().await.unwrap();
    let mut cache_operator = CacheOperator::new(conn.clone(), StorageFormat::Base64UncompressedProto);
    
    // Initialize cache state
    cache_operator.cache_setup_if_needed().await.unwrap();
    cache_operator.set_chain_id(4).await.unwrap();
    
    // Simulate successful processing up to version 1000
    redis::cmd("SET")
        .arg("latest_version")
        .arg("1000")
        .query_async::<_, ()>(&mut conn)
        .await
        .unwrap();
    
    // Simulate file store progressing to 2000 during network interruption
    redis::cmd("SET")
        .arg("file_store_latest_version")
        .arg("2000")
        .query_async::<_, ()>(&mut conn)
        .await
        .unwrap();
    
    // Simulate worker attempting to process batch starting at 2000
    // Processing 1000 transactions: versions 2000-2999
    let result = cache_operator
        .update_cache_latest_version(1000, 3000)
        .await;
    
    // Verify crash occurs due to gap detection
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Version is not right"));
    
    // Verify cache latest_version unchanged (crash loop state)
    let latest = cache_operator.get_latest_version().await.unwrap();
    assert_eq!(latest, Some(1000));
}
```

**Expected Behavior:** Test successfully demonstrates the crash with error message "Version is not right", confirming the permanent crash loop when version gaps exist between cache and file store.

## Notes

This vulnerability directly answers the security question about version gaps from network interruptions. The issue stems from the cache worker's incomplete restart logic that fails to validate cache state compatibility before resuming processing. The TODO comment in the code confirms this logic was recognized as incomplete but never fully implemented.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-cache-worker/src/worker.rs (L108-108)
```rust
    /// TODO: Rewrite logic to actually conform to this description
```

**File:** ecosystem/indexer-grpc/indexer-grpc-cache-worker/src/worker.rs (L123-137)
```rust
            let mut starting_version = file_store_operator.get_latest_version().await;
            while starting_version.is_none() {
                starting_version = file_store_operator.get_latest_version().await;
                tracing::warn!(
                    "[Indexer Cache] File store metadata not found. Waiting for {} ms.",
                    FILE_STORE_METADATA_WAIT_MS
                );
                tokio::time::sleep(std::time::Duration::from_millis(
                    FILE_STORE_METADATA_WAIT_MS,
                ))
                .await;
            }

            // There's a guarantee at this point that starting_version is not null
            let starting_version = starting_version.unwrap();
```

**File:** ecosystem/indexer-grpc/indexer-grpc-cache-worker/src/worker.rs (L244-247)
```rust
                    // Push to cache.
                    match cache_operator_clone
                        .update_cache_transactions(data.transactions)
                        .await
```

**File:** ecosystem/indexer-grpc/indexer-grpc-cache-worker/src/worker.rs (L316-319)
```rust
    // It's required to start the worker with the same version as file store.
    if file_store_metadata.version != starting_version {
        bail!("[Indexer Cache] Starting version mismatch between filestore metadata and fullnode init signal.");
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-cache-worker/src/worker.rs (L356-367)
```rust
    loop {
        let download_start_time = std::time::Instant::now();
        let received = match resp_stream.next().await {
            Some(r) => r,
            _ => {
                error!(
                    service_type = SERVICE_TYPE,
                    "[Indexer Cache] Streaming error: no response."
                );
                ERROR_COUNT.with_label_values(&["streaming_error"]).inc();
                break;
            },
```

**File:** ecosystem/indexer-grpc/indexer-grpc-cache-worker/src/worker.rs (L444-447)
```rust
                    cache_operator
                        .update_cache_latest_version(transaction_count, current_version)
                        .await
                        .context("Failed to update the latest version in the cache")?;
```

**File:** ecosystem/indexer-grpc/indexer-grpc-cache-worker/src/worker.rs (L502-503)
```rust
    // It is expected that we get to this point, the upstream server disconnects
    // clients after 5 minutes.
```

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/cache_operator.rs (L39-57)
```rust
const CACHE_SCRIPT_UPDATE_LATEST_VERSION: &str = r#"
    local latest_version = redis.call("GET", KEYS[1])
    local num_of_versions = tonumber(ARGV[1])
    local current_version = tonumber(ARGV[2])
    if latest_version then
        if tonumber(latest_version) + num_of_versions < current_version then
            return 2
        elseif tonumber(latest_version) + num_of_versions == current_version then
            redis.call("SET", KEYS[1], current_version)
            return 0
        else
            redis.call("SET", KEYS[1], math.max(current_version, tonumber(latest_version)))
            return 1
        end
    else
        redis.call("SET", KEYS[1], ARGV[1])
        return 0
    end
"#;
```

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/cache_operator.rs (L359-362)
```rust
            2 => {
                tracing::error!(version=version, "Redis latest version update failed. The version is beyond the next expected version.");
                Err(anyhow::anyhow!("Version is not right."))
            },
```
