# Audit Report

## Title
Stale Cross-Shard State Reads Enable Double-Spending in Sharded Block Executor Due to Incomplete Dependency Analysis

## Summary
The sharded block executor's `create_cross_shard_state_view()` function relies on `required_edges_iter()` to determine which state keys need cross-shard synchronization. If dependency analysis is incomplete (missing keys from read/write hints), transactions can read stale pre-execution state instead of waiting for cross-shard updates, violating serializability and enabling double-spending attacks.

## Finding Description

The vulnerability exists in how the sharded block executor handles cross-shard state dependencies:

**1. Dependency Collection Phase:** [1](#0-0) 

The `create_cross_shard_state_view()` function collects cross-shard state keys by iterating over `required_edges_iter()`. Only keys present in these edges are tracked in `cross_shard_data` for remote synchronization.

**2. Read/Write Hint Generation:** [2](#0-1) 

Read/write hints are generated using static analysis that only supports coin transfers and create_account transactions. All other transaction types hit a `todo!()` panic. Even for supported types, hints are hardcoded and may not capture all actual state accesses during execution.

**3. Dependency Edge Construction:** [3](#0-2) 

Required edges are built based on these incomplete hints. If a key is not in the transaction's read/write sets (because it wasn't in the hints), no dependency edge will be created for it.

**4. State Read Fallback:** [4](#0-3) 

When `get_state_value()` is called for a key NOT in `cross_shard_data`, it falls back to `base_view.get_state_value()`, returning the pre-execution state instead of blocking for cross-shard updates.

**5. Validation Limitation:** [5](#0-4) 

Validation checks reads against the local shard's versioned data. Since cross-shard writes for missing keys were never communicated to this shard, validation passes even with stale reads.

**Attack Scenario:**

1. **Setup:** Transaction T1 (Shard A, Round 0) writes to account balance K. Transaction T2 (Shard B, Round 1) reads balance K.

2. **Bug Trigger:** Due to incomplete `read_hints` in T2's `AnalyzedTransaction`, key K is not included in T2's read set.

3. **Missing Dependency:** During partitioning, no required edge from T1 to T2 is created for key K.

4. **Cross-Shard State View Creation:** When T2's shard creates `CrossShardStateView`, key K is not in `cross_shard_data` because it wasn't in `required_edges_iter()`.

5. **Stale Read:** T2 executes and reads K. Since K is not in `cross_shard_data`, the read falls back to `base_view`, returning the balance BEFORE T1's write.

6. **Validation Passes:** T2's shard validates the read against its local versioned data, which never received T1's write. Validation succeeds.

7. **Double-Spend:** T2 processes a transfer based on the old balance, enabling the account to spend funds that were already spent by T1.

## Impact Explanation

This vulnerability meets **Critical Severity** criteria per Aptos bug bounty:

- **Consensus/Safety Violations:** Different validators executing the same block with sharded execution could produce different state roots if they partition transactions differently or have race conditions in cross-shard messaging.

- **Loss of Funds:** Double-spending is directly enabled when balance reads use stale values. An attacker can craft transactions to execute in different shards such that both see old balances and allow transfers that exceed actual funds.

- **Deterministic Execution Broken:** Violates the critical invariant that "All validators must produce identical state roots for identical blocks." The execution outcome depends on whether dependency analysis was complete, not just the transaction order.

- **Non-Serializable Execution:** Transactions execute in an order that cannot be linearized to any serial execution, fundamentally breaking the serializability guarantee required for blockchain consistency.

## Likelihood Explanation

**Current State:** Low likelihood in production because:
- Sharded execution is currently limited to benchmarks
- Only coin transfers are supported (would panic for other types)
- Static analysis for coin transfers may be complete for current implementation

**Future Risk:** High likelihood if:
- Support is extended to other transaction types without comprehensive hint generation
- Coin transfer implementation changes to access additional state
- Dynamic state access patterns (tables, indirect reads) are introduced
- The `todo!()` is replaced with incomplete implementations

The vulnerability is **structurally present** in the architecture - the fallback to `base_view` without validation makes the system vulnerable to any incompleteness in dependency analysis.

## Recommendation

**Immediate Fix:**

1. **Fail Fast on Unknown Keys:** [4](#0-3) 

Replace the silent fallback with an assertion or error:

```rust
fn get_state_value(&self, state_key: &StateKey) -> Result<Option<StateValue>, StateViewError> {
    if let Some(value) = self.cross_shard_data.get(state_key) {
        return Ok(value.get_value());
    }
    // SECURITY: If a key is accessed but wasn't in cross_shard_data,
    // this indicates incomplete dependency analysis. Fail loudly.
    panic!("Cross-shard state access to key {:?} that was not in required_edges. This indicates a bug in dependency analysis.", state_key);
}
```

2. **Runtime Validation:** Add post-execution validation that all accessed keys were in the predicted read/write sets.

3. **Complete Static Analysis:** Replace the `todo!()` with comprehensive analysis or use dynamic analysis to capture actual reads/writes during execution.

**Long-term Fix:**

1. **Dynamic Dependency Tracking:** Use speculative execution with rollback - execute transactions, capture actual dependencies, then validate and potentially re-partition if predictions were wrong.

2. **Conservative Over-Approximation:** Include wildcard patterns in cross-shard dependencies to ensure all potential accesses are tracked, even if overly conservative.

3. **Formal Verification:** Prove that the dependency analysis captures all true dependencies using formal methods or extensive property testing.

## Proof of Concept

**Conceptual PoC (Rust pseudocode):**

```rust
// Transaction 1: Transfer 100 coins from Alice to Bob (Shard A, Round 0)
let t1 = create_coin_transfer(alice_addr, bob_addr, 100);
// This writes to: alice_balance, bob_balance

// Transaction 2: Transfer 100 coins from Alice to Charlie (Shard B, Round 1)
// BUG: Suppose read_hints for T2 are incomplete and don't include alice_balance
let t2_incomplete_hints = AnalyzedTransaction {
    transaction: create_coin_transfer(alice_addr, charlie_addr, 100),
    read_hints: vec![/* Missing alice_balance! */],
    write_hints: vec![account_resource_location(alice_addr), 
                      coin_store_location(charlie_addr)],
    // ...
};

// During partitioning:
// - No required edge from T1 to T2 for alice_balance (not in T2's read_hints)
// - T1 and T2 assigned to different shards

// Execution:
// - Shard A executes T1: alice_balance = initial - 100
// - Shard B creates CrossShardStateView without alice_balance in cross_shard_data
// - Shard B executes T2: reads alice_balance from base_view (stale: initial value)
// - T2 validates and commits: alice_balance = initial - 100 (overwrites T1's write)
// - Result: Alice spent 200 coins but balance only decreased by 100
```

**To Reproduce:**

1. Modify `get_read_write_hints()` to return incomplete hints for a transfer
2. Create two transfers from same account to different recipients
3. Partition them to different shards in different rounds
4. Execute with sharded executor
5. Observe that both transfers succeed despite insufficient balance

## Notes

While the current implementation limits sharded execution to benchmarks with supported transaction types, the architectural vulnerability is real. The security question specifically asks about scenarios where dependency analysis is incomplete, which this system does not defend against. The fallback to `base_view` should be considered a critical security issue that must be addressed before sharded execution is used in production.

### Citations

**File:** aptos-move/aptos-vm/src/sharded_block_executor/cross_shard_state_view.rs (L58-71)
```rust
    pub fn create_cross_shard_state_view(
        base_view: &'a S,
        transactions: &[TransactionWithDependencies<AnalyzedTransaction>],
    ) -> CrossShardStateView<'a, S> {
        let mut cross_shard_state_key = HashSet::new();
        for txn in transactions {
            for (_, storage_locations) in txn.cross_shard_dependencies.required_edges_iter() {
                for storage_location in storage_locations {
                    cross_shard_state_key.insert(storage_location.clone().into_state_key());
                }
            }
        }
        CrossShardStateView::new(cross_shard_state_key, base_view)
    }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/cross_shard_state_view.rs (L77-82)
```rust
    fn get_state_value(&self, state_key: &StateKey) -> Result<Option<StateValue>, StateViewError> {
        if let Some(value) = self.cross_shard_data.get(state_key) {
            return Ok(value.get_value());
        }
        self.base_view.get_state_value(state_key)
    }
```

**File:** types/src/transaction/analyzed_transaction.rs (L244-283)
```rust
impl AnalyzedTransactionProvider for Transaction {
    fn get_read_write_hints(&self) -> (Vec<StorageLocation>, Vec<StorageLocation>) {
        let process_entry_function = |func: &EntryFunction,
                                      sender_address: AccountAddress|
         -> (Vec<StorageLocation>, Vec<StorageLocation>) {
            match (
                *func.module().address(),
                func.module().name().as_str(),
                func.function().as_str(),
            ) {
                (AccountAddress::ONE, "coin", "transfer") => {
                    let receiver_address = bcs::from_bytes(&func.args()[0]).unwrap();
                    rw_set_for_coin_transfer(sender_address, receiver_address, true)
                },
                (AccountAddress::ONE, "aptos_account", "transfer") => {
                    let receiver_address = bcs::from_bytes(&func.args()[0]).unwrap();
                    rw_set_for_coin_transfer(sender_address, receiver_address, false)
                },
                (AccountAddress::ONE, "aptos_account", "create_account") => {
                    let receiver_address = bcs::from_bytes(&func.args()[0]).unwrap();
                    rw_set_for_create_account(sender_address, receiver_address)
                },
                _ => todo!(
                    "Only coin transfer and create account transactions are supported for now"
                ),
            }
        };
        match self {
            Transaction::UserTransaction(signed_txn) => match signed_txn.payload().executable_ref()
            {
                Ok(TransactionExecutableRef::EntryFunction(func))
                    if !signed_txn.payload().is_multisig() =>
                {
                    process_entry_function(func, signed_txn.sender())
                },
                _ => todo!("Only entry function transactions are supported for now"),
            },
            _ => empty_rw_set(),
        }
    }
```

**File:** execution/block-partitioner/src/v2/state.rs (L301-321)
```rust
        // Build required edges.
        let write_set = self.write_sets[ori_txn_idx].read().unwrap();
        let read_set = self.read_sets[ori_txn_idx].read().unwrap();
        for &key_idx in write_set.iter().chain(read_set.iter()) {
            let tracker_ref = self.trackers.get(&key_idx).unwrap();
            let tracker = tracker_ref.read().unwrap();
            if let Some(txn_idx) = tracker
                .finalized_writes
                .range(..ShardedTxnIndexV2::new(round_id, shard_id, 0))
                .last()
            {
                let src_txn_idx = ShardedTxnIndex {
                    txn_index: *self.final_idxs_by_pre_partitioned[txn_idx.pre_partitioned_txn_idx]
                        .read()
                        .unwrap(),
                    shard_id: txn_idx.shard_id(),
                    round_id: txn_idx.round_id(),
                };
                deps.add_required_edge(src_txn_idx, tracker.storage_location.clone());
            }
        }
```

**File:** aptos-move/block-executor/src/executor.rs (L808-815)
```rust
        read_set.validate_data_reads(versioned_cache.data(), idx_to_validate)
            && read_set.validate_group_reads(versioned_cache.group_data(), idx_to_validate)
            && (skip_module_reads_validation
                || read_set.validate_module_reads(
                    global_module_cache,
                    versioned_cache.module_cache(),
                    None,
                ))
```
