# Audit Report

## Title
Byzantine Validators Can Crash Consensus Nodes via Empty Weights HashMap in Secret Share Aggregation

## Summary
The `SecretShareStore` in the consensus layer contains unchecked `expect()` calls that panic when looking up validator weights in an empty HashMap. Byzantine validators can trigger these panics by sending valid secret shares before a victim node adds its own share, causing the victim's consensus node to crash and lose liveness.

## Finding Description

The vulnerability exists in the secret sharing aggregation logic used during consensus randomness generation. The root cause is an incomplete implementation where the `weights` HashMap in `SecretShareConfig` is initialized as empty but never populated. [1](#0-0) 

The `get_peer_weight()` method returns a hardcoded value of `1` for all peers: [2](#0-1) 

While `get_peer_weights()` returns a reference to the empty HashMap: [3](#0-2) 

This creates a critical inconsistency in `SecretShareStore`. When shares from other validators arrive via the network, they are successfully added using `add_share()`: [4](#0-3) 

The `add_share()` method uses `get_peer_weight()` at line 260, which returns `1`, so Byzantine shares are successfully added to the aggregator.

However, when the node processes its own block and calls `add_self_share()`, it retrieves the empty HashMap and passes it to `add_share_with_metadata()`: [5](#0-4) 

The `add_share_with_metadata()` method has two panic points. **Panic Point 1** occurs when looking up the share author's weight in the empty HashMap: [6](#0-5) 

**Panic Point 2** occurs in the `retain()` method when recalculating total weight for existing shares: [7](#0-6) 

**Attack Execution Path:**

1. Byzantine validator sends cryptographically valid share via network RPC
2. Share arrives at `verification_task()` and passes cryptographic verification: [8](#0-7) 

3. Verified share is forwarded to `handle_incoming_msg()` which calls `add_share()`: [9](#0-8) 

4. Share is added successfully to the `SecretShareAggregator` using weight of 1
5. Victim node processes its own block and calls `add_self_share()`: [10](#0-9) 

6. The `add_share_with_metadata()` method attempts to lookup in the empty HashMap and panics

Shares can arrive from any validator within a 200-round window: [11](#0-10) 

## Impact Explanation

This vulnerability qualifies as **HIGH Severity** per the Aptos bug bounty criteria: "Validator node slowdowns / API crashes."

**Specific Impacts:**
- **Consensus Participation Loss**: The crashed node cannot participate in consensus rounds until manually restarted
- **Network Liveness Degradation**: If Byzantine validators crash multiple nodes simultaneously, the network may lose liveness
- **Repeatable DoS**: Byzantine validators can continuously trigger this crash on any epoch
- **No Automatic Recovery**: The node process must be manually restarted by operators

This breaks the **Consensus Liveness** invariant - Byzantine validators (< 1/3) should not be able to prevent honest nodes from participating in consensus. While this is not a safety violation (no consensus divergence), it degrades network availability.

## Likelihood Explanation

**Likelihood: HIGH**

This vulnerability can be triggered with:
- **Low Complexity**: Byzantine validators simply send valid shares before victim processes its own block
- **No Special Timing**: Shares can be sent at any time within the 200-round window (`FUTURE_ROUNDS_TO_ACCEPT`)
- **Deterministic Outcome**: The panic is guaranteed if shares exist when `add_self_share()` is called
- **Minimal Prerequisites**: Only requires being a validator in the active set (< 1/3 can be Byzantine in BFT assumptions)

Byzantine validators are an expected threat in BFT consensus systems (up to 1/3 of stake), making this a realistic attack vector. The vulnerability can even trigger accidentally due to normal network timing variations between honest validators.

## Recommendation

**Immediate Fix**: Populate the `weights` HashMap in `SecretShareConfig::new()` with actual validator weights from the `ValidatorVerifier`, or use proper error handling instead of `expect()` calls.

**Option 1 - Populate Weights (Preferred)**:
```rust
pub fn new(
    author: Author,
    epoch: u64,
    validator: Arc<ValidatorVerifier>,
    digest_key: DigestKey,
    msk_share: MasterSecretKeyShare,
    verification_keys: Vec<VerificationKey>,
    config: <FPTXWeighted as BatchThresholdEncryption>::ThresholdConfig,
    encryption_key: EncryptionKey,
) -> Self {
    let weights = validator
        .address_to_validator_info()
        .iter()
        .map(|(addr, info)| (*addr, info.voting_power()))
        .collect();
    
    Self {
        _author: author,
        _epoch: epoch,
        validator,
        digest_key,
        msk_share,
        verification_keys,
        config,
        encryption_key,
        weights,
    }
}
```

**Option 2 - Remove Expect Calls**:
Replace `expect()` calls with proper error handling or default to `get_peer_weight()` if weight is not found in the HashMap.

## Proof of Concept

A complete PoC would require a multi-validator Aptos testnet setup. The attack can be demonstrated by:

1. Start a validator network with secret sharing enabled
2. From a Byzantine validator node, broadcast secret shares for future rounds to target victims
3. Wait for victim nodes to process their own blocks and call `add_self_share()`
4. Observe victim validator nodes crash with panic message: "Author must exist in weights"

The crash can be verified in the logs showing a panic originating from `consensus/src/rand/secret_sharing/secret_share_store.rs` at line 164 or line 79.

---

**Notes:**

This vulnerability represents an incomplete implementation where weighted shares were planned (as evidenced by the `weights` field and methods) but never fully integrated. The inconsistency between `get_peer_weight()` returning a hardcoded value and `add_share_with_metadata()` expecting a populated HashMap creates a deterministic crash path exploitable by Byzantine validators.

### Citations

**File:** types/src/secret_sharing.rs (L168-168)
```rust
            weights: HashMap::new(),
```

**File:** types/src/secret_sharing.rs (L196-197)
```rust
    pub fn get_peer_weight(&self, _peer: &Author) -> u64 {
        1
```

**File:** types/src/secret_sharing.rs (L200-202)
```rust
    pub fn get_peer_weights(&self) -> &HashMap<Author, u64> {
        &self.weights
    }
```

**File:** consensus/src/rand/secret_sharing/secret_share_store.rs (L74-81)
```rust
    fn retain(&mut self, metadata: &SecretShareMetadata, weights: &HashMap<Author, u64>) {
        self.shares.retain(|_, share| share.metadata == *metadata);
        self.total_weight = self
            .shares
            .keys()
            .map(|author| weights.get(author).expect("Author must exist for weight"))
            .sum();
    }
```

**File:** consensus/src/rand/secret_sharing/secret_share_store.rs (L162-164)
```rust
        let share_weight = *share_weights
            .get(share.author())
            .expect("Author must exist in weights");
```

**File:** consensus/src/rand/secret_sharing/secret_share_store.rs (L237-256)
```rust
    pub fn add_self_share(&mut self, share: SecretShare) -> anyhow::Result<()> {
        assert!(
            self.self_author == share.author,
            "Only self shares can be added with metadata"
        );
        let peer_weights = self.secret_share_config.get_peer_weights();
        let metadata = share.metadata();
        ensure!(metadata.epoch == self.epoch, "Share from different epoch");
        ensure!(
            metadata.round <= self.highest_known_round + FUTURE_ROUNDS_TO_ACCEPT,
            "Share from future round"
        );

        let item = self
            .secret_share_map
            .entry(metadata.round)
            .or_insert_with(|| SecretShareItem::new(self.self_author));
        item.add_share_with_metadata(share, peer_weights)?;
        item.try_aggregate(&self.secret_share_config, self.decision_tx.clone());
        Ok(())
```

**File:** consensus/src/rand/secret_sharing/secret_share_store.rs (L259-275)
```rust
    pub fn add_share(&mut self, share: SecretShare) -> anyhow::Result<bool> {
        let weight = self.secret_share_config.get_peer_weight(share.author());
        let metadata = share.metadata();
        ensure!(metadata.epoch == self.epoch, "Share from different epoch");
        ensure!(
            metadata.round <= self.highest_known_round + FUTURE_ROUNDS_TO_ACCEPT,
            "Share from future round"
        );

        let item = self
            .secret_share_map
            .entry(metadata.round)
            .or_insert_with(|| SecretShareItem::new(self.self_author));
        item.add_share(share, weight)?;
        item.try_aggregate(&self.secret_share_config, self.decision_tx.clone());
        Ok(item.has_decision())
    }
```

**File:** consensus/src/rand/secret_sharing/secret_share_manager.rs (L145-147)
```rust
            secret_share_store
                .add_self_share(self_secret_share.clone())
                .expect("Add self dec share should succeed");
```

**File:** consensus/src/rand/secret_sharing/secret_share_manager.rs (L220-220)
```rust
                            if msg.verify(&epoch_state_clone, &config_clone).is_ok() {
```

**File:** consensus/src/rand/secret_sharing/secret_share_manager.rs (L317-319)
```rust
                if let Err(e) = self.secret_share_store.lock().add_share(share) {
                    warn!("[SecretShareManager] Failed to add share: {}", e);
                }
```

**File:** consensus/src/rand/rand_gen/types.rs (L26-26)
```rust
pub const FUTURE_ROUNDS_TO_ACCEPT: u64 = 200;
```
