# Audit Report

## Title
IndexerConfig Credentials Leaked Through JSON Serialization in Logs and Telemetry

## Summary
The `IndexerConfig` struct's `postgres_uri` field containing database credentials is exposed in plaintext through two code paths that use JSON serialization instead of the custom `Debug` implementation that masks passwords: `NodeConfig.log_all_configs()` at node startup and `send_node_config()` in the telemetry service that periodically transmits configuration to remote servers.

## Finding Description

The `IndexerConfig` struct derives the `Clone` trait and implements a custom `Debug` trait that masks the password in `postgres_uri`. [1](#0-0) [2](#0-1) 

However, the struct also derives `Serialize` without any password masking, and two critical code paths bypass the secure `Debug` implementation:

**1. Local Log Leakage:** The `NodeConfig.log_all_configs()` method serializes the entire configuration to JSON and logs each field. [3](#0-2)  This method is called at node startup. [4](#0-3) 

While the `logger.rs` module has explicit password masking when logging via `Debug` formatting [5](#0-4) , the `log_all_configs()` method uses JSON serialization which exposes the plaintext password.

**2. Remote Telemetry Leakage:** The `send_node_config()` function in the telemetry service serializes the entire `NodeConfig` to JSON and sends it to remote telemetry servers every 60 minutes. [6](#0-5) [7](#0-6) 

The telemetry data is sent to `https://telemetry.aptoslabs.com` or `https://telemetry.mainnet.aptoslabs.com`. [8](#0-7) 

## Impact Explanation

**Severity: Low** (per Aptos Bug Bounty criteria for "Minor information leaks")

This is an information disclosure vulnerability that exposes database credentials, but it does NOT affect:
- Consensus safety or liveness
- Blockchain state integrity  
- Transaction execution or validation
- Fund security
- Network availability

The indexer is an auxiliary service for querying historical blockchain data and is not part of the consensus-critical path. Compromise of the indexer database does not enable attacks on the blockchain itself.

## Likelihood Explanation

**Likelihood: High** - This vulnerability occurs automatically during normal node operation:
- Credentials are logged at every node startup
- Credentials are transmitted to telemetry servers every 60 minutes

However, exploitation requires the attacker to have:
- Access to node log files (requires system-level access), OR
- Ability to intercept network traffic to telemetry endpoints, OR
- Access to telemetry service infrastructure

Node operators who can read their own logs are considered trusted actors in the threat model, making this primarily an operational security concern rather than an exploitable vulnerability by external attackers.

## Recommendation

Implement a custom `Serialize` implementation for `IndexerConfig` that masks the password in `postgres_uri`, similar to the existing `Debug` implementation:

```rust
impl Serialize for IndexerConfig {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        
        let mut state = serializer.serialize_struct("IndexerConfig", 14)?;
        state.serialize_field("enabled", &self.enabled)?;
        
        // Mask password in postgres_uri
        let masked_uri = self.postgres_uri.as_ref().map(|u| {
            url::Url::parse(u)
                .ok()
                .and_then(|mut parsed_url| {
                    if parsed_url.password().is_some() {
                        parsed_url.set_password(Some("***")).ok()?;
                    }
                    Some(parsed_url.to_string())
                })
                .unwrap_or_else(|| u.clone())
        });
        state.serialize_field("postgres_uri", &masked_uri)?;
        
        // Serialize remaining fields...
        state.serialize_field("processor", &self.processor)?;
        // ... (other fields)
        state.end()
    }
}
```

Alternatively, add a pre-processing step in both `log_all_configs()` and `send_node_config()` to mask credentials before serialization.

## Proof of Concept

Create a test demonstrating credential leakage:

```rust
#[test]
fn test_indexer_config_credential_leakage() {
    use aptos_config::config::{IndexerConfig, NodeConfig};
    
    // Create a config with sensitive postgres URI
    let mut config = NodeConfig::default();
    config.indexer.enabled = true;
    config.indexer.postgres_uri = Some(
        "postgresql://admin:secretpassword123@localhost:5432/aptos_indexer".to_string()
    );
    
    // Serialize to JSON (simulating log_all_configs behavior)
    let json_value = serde_json::to_value(&config).unwrap();
    let json_string = serde_json::to_string(&json_value).unwrap();
    
    // Verify that the password is exposed in JSON
    assert!(json_string.contains("secretpassword123"), 
            "Password should be present in JSON serialization");
    
    // Verify that Debug formatting masks the password
    let debug_string = format!("{:?}", config);
    assert!(!debug_string.contains("secretpassword123"),
            "Password should be masked in Debug output");
}
```

This test will pass, demonstrating the discrepancy between `Debug` (which masks) and `Serialize` (which exposes).

---

**Notes:** This finding represents an information disclosure vulnerability affecting operational security. While the credential leakage is real and occurs automatically, it does not directly impact blockchain consensus, state integrity, or fund security. The indexer is an auxiliary querying service, and its compromise does not provide attack vectors against core blockchain operations.

### Citations

**File:** config/src/config/indexer_config.rs (L25-25)
```rust
#[derive(Clone, Default, Deserialize, PartialEq, Eq, Serialize)]
```

**File:** config/src/config/indexer_config.rs (L92-117)
```rust
impl Debug for IndexerConfig {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        let postgres_uri = self.postgres_uri.as_ref().map(|u| {
            let mut parsed_url = url::Url::parse(u).expect("Invalid postgres uri");
            if parsed_url.password().is_some() {
                parsed_url.set_password(Some("*")).unwrap();
            }
            parsed_url.to_string()
        });
        f.debug_struct("IndexerConfig")
            .field("enabled", &self.enabled)
            .field("postgres_uri", &postgres_uri)
            .field("processor", &self.processor)
            .field("starting_version", &self.starting_version)
            .field("skip_migrations", &self.skip_migrations)
            .field("check_chain_id", &self.check_chain_id)
            .field("batch_size", &self.batch_size)
            .field("fetch_tasks", &self.fetch_tasks)
            .field("processor_tasks", &self.processor_tasks)
            .field("emit_every", &self.emit_every)
            .field("gap_lookback_versions", &self.gap_lookback_versions)
            .field("ans_contract_address", &self.ans_contract_address)
            .field("nft_points_contract", &self.nft_points_contract)
            .finish()
    }
}
```

**File:** config/src/config/node_config.rs (L97-111)
```rust
    pub fn log_all_configs(&self) {
        // Parse the node config as serde JSON
        let config_value =
            serde_json::to_value(self).expect("Failed to serialize the node config!");
        let config_map = config_value
            .as_object()
            .expect("Failed to get the config map!");

        // Log each config entry
        for (config_name, config_value) in config_map {
            let config_string =
                serde_json::to_string(config_value).expect("Failed to parse the config value!");
            info!("Using {} config: {}", config_name, config_string);
        }
    }
```

**File:** aptos-node/src/lib.rs (L698-698)
```rust
    node_config.log_all_configs();
```

**File:** aptos-node/src/logger.rs (L88-102)
```rust
    // Log the node config
    let mut config = node_config;
    let mut masked_config;
    if let Some(u) = &node_config.indexer.postgres_uri {
        let mut parsed_url = url::Url::parse(u).expect("Invalid postgres uri");
        if parsed_url.password().is_some() {
            masked_config = node_config.clone();
            parsed_url.set_password(Some("*")).unwrap();
            masked_config.indexer.postgres_uri = Some(parsed_url.to_string());
            config = &masked_config;
        }
    }

    info!("Loaded node config: {:?}", config);
}
```

**File:** crates/aptos-telemetry/src/service.rs (L372-396)
```rust
async fn send_node_config(
    peer_id: String,
    chain_id: String,
    node_config: &NodeConfig,
    telemetry_sender: Option<TelemetrySender>,
) {
    let node_config: BTreeMap<String, String> = serde_json::to_value(node_config)
        .map(|value| {
            value
                .as_object()
                .map(|obj| {
                    obj.into_iter()
                        .map(|(k, v)| (k.clone(), v.to_string()))
                        .collect::<BTreeMap<String, String>>()
                })
                .unwrap_or_default()
        })
        .unwrap_or_default();

    let telemetry_event = TelemetryEvent {
        name: APTOS_NODE_CONFIG_EVENT_NAME.into(),
        params: node_config,
    };
    prepare_and_send_telemetry_event(peer_id, chain_id, telemetry_sender, telemetry_event).await;
}
```

**File:** crates/aptos-telemetry/src/constants.rs (L31-32)
```rust
pub(crate) const TELEMETRY_SERVICE_URL: &str = "https://telemetry.aptoslabs.com";
pub(crate) const MAINNET_TELEMETRY_SERVICE_URL: &str = "https://telemetry.mainnet.aptoslabs.com";
```

**File:** crates/aptos-telemetry/src/constants.rs (L39-39)
```rust
pub(crate) const NODE_CONFIG_FREQ_SECS: u64 = 60 * 60; // 60 minutes
```
