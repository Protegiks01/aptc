# Audit Report

## Title
Silent Data Loss in TransactionOrOutputs Payload Conversion Leading to State Sync Inconsistencies

## Summary
A malicious peer can send state sync responses containing both transactions and outputs simultaneously. The conversion logic silently drops one payload type without raising an error or penalizing the malicious peer, potentially causing state sync inconsistencies.

## Finding Description
The vulnerability exists in the conversion layer between network responses and the state sync processing pipeline. The type `TransactionOrOutputListWithProofV2` is defined as a tuple allowing both transaction and output lists to be `Some` simultaneously: [1](#0-0) 

When a malicious peer sends a `DataResponse::NewTransactionsOrOutputsWithProof` with both fields populated, the deserialization succeeds because the type structure permits this invalid state. The critical flaw occurs during the conversion to `ResponsePayload`: [2](#0-1) 

This `if-else if-else` pattern prioritizes transactions over outputs. When both are present, the conversion:
1. Matches the first condition (transaction_list is Some)
2. Returns `NewTransactionsWithProof` with only the transactions
3. **Silently discards the entire output_list without any error, warning, or peer penalty**

This conversion happens in the data streaming layer when processing peer responses: [3](#0-2) 

The dropped data never reaches the continuous syncer's `process_transaction_or_output_payload()` function, so the node has no awareness that partial data was lost. The function only sees the converted `DataPayload` containing transactions: [4](#0-3) 

**Attack Scenario:**
1. Node in `ExecuteTransactionsOrApplyOutputs` mode requests data from peer
2. Malicious peer constructs response with both `transaction_list_with_proof = Some(...)` and `transaction_output_list_with_proof = Some(...)`
3. Network layer successfully deserializes this (no validation prevents both being Some)
4. Conversion at data_stream.rs:1587 silently drops outputs
5. Node processes only transactions, believing it received complete data
6. No error propagates, no negative feedback to malicious peer
7. Peer's reputation remains intact, enabling repeated attacks

This breaks the critical invariant that **all network data must be either fully processed or explicitly rejected with error feedback**.

## Impact Explanation
**Severity: High** ($50,000 category - Significant Protocol Violations)

This vulnerability causes:

1. **Silent Data Loss**: Transaction outputs containing critical state transitions are permanently lost without detection
2. **State Sync Inconsistencies**: Nodes may have incomplete state if they relied on the dropped outputs
3. **No Error Recovery**: The silent failure prevents retry logic or fallback mechanisms from engaging
4. **Peer Reputation Bypass**: Malicious peers aren't penalized, enabling sustained attacks
5. **Protocol Integrity Violation**: The state sync protocol guarantee of "complete data or explicit error" is broken

While this doesn't directly cause consensus failures (since each node's state sync is independent), it can lead to prolonged state sync delays and nodes operating with incomplete information, qualifying as a significant protocol violation.

## Likelihood Explanation
**Likelihood: Medium-High**

The attack is straightforward to execute:
- No special privileges required - any network peer can send responses
- Simple payload construction - just populate both Option fields
- No cryptographic requirements - standard serialization
- Repeatable without detection - no peer penalties applied
- Affects all nodes using `ExecuteTransactionsOrApplyOutputs` mode

The only limiting factor is that honest storage servers naturally return only one type, so this requires an actively malicious peer. However, the absence of validation means even implementation bugs could accidentally trigger this behavior.

## Recommendation
Add validation to reject responses where both fields are populated. The fix should occur at the conversion layer:

```rust
impl TryFrom<(TransactionOrOutputListWithProofV2, LedgerInfoWithSignatures)> for ResponsePayload {
    type Error = Error;

    fn try_from(
        inner: (TransactionOrOutputListWithProofV2, LedgerInfoWithSignatures),
    ) -> error::Result<Self, Error> {
        let ((transaction_list, output_list), ledger_info) = inner;
        
        // VALIDATION: Reject if both are present
        match (transaction_list.is_some(), output_list.is_some()) {
            (true, true) => {
                return Err(Error::InvalidResponse(
                    "Invalid response! Both transaction and output lists provided. Expected exactly one.".into()
                ))
            },
            (false, false) => {
                return Err(Error::InvalidResponse(
                    "Invalid response! No transaction or output list was returned!".into()
                ))
            },
            _ => {} // Valid: exactly one is Some
        }
        
        if let Some(transaction_list) = transaction_list {
            Ok(Self::NewTransactionsWithProof((transaction_list, ledger_info)))
        } else if let Some(output_list) = output_list {
            Ok(Self::NewTransactionOutputsWithProof((output_list, ledger_info)))
        } else {
            unreachable!() // Validated above
        }
    }
}
```

Apply the same validation to the other `TryFrom` implementation at lines 386-400.

Additionally, when this error occurs, ensure the peer receives negative feedback to penalize malicious behavior.

## Proof of Concept
```rust
// Test demonstrating the vulnerability
#[test]
fn test_mixed_payload_silent_drop() {
    use aptos_storage_service_types::responses::TransactionOrOutputListWithProofV2;
    use aptos_types::transaction::{TransactionListWithProofV2, TransactionOutputListWithProofV2};
    use aptos_types::ledger_info::LedgerInfoWithSignatures;
    use aptos_data_client::interface::ResponsePayload;
    
    // Create mock transaction and output lists
    let transactions = TransactionListWithProofV2::new_empty();
    let outputs = TransactionOutputListWithProofV2::new_empty();
    let ledger_info = create_mock_ledger_info(); // Mock function
    
    // Construct malicious payload with BOTH fields populated
    let malicious_payload: TransactionOrOutputListWithProofV2 = (
        Some(transactions),
        Some(outputs),  // Both are Some!
    );
    
    // Attempt conversion
    let result = ResponsePayload::try_from((malicious_payload, ledger_info));
    
    // VULNERABILITY: Conversion succeeds, silently dropping outputs
    assert!(result.is_ok());
    
    // The result contains only transactions
    match result.unwrap() {
        ResponsePayload::NewTransactionsWithProof(_) => {
            // Transactions were kept
            println!("VULNERABILITY CONFIRMED: Outputs were silently dropped!");
        },
        _ => panic!("Unexpected response type"),
    }
    
    // Expected behavior: Should return Err(InvalidResponse) when both are present
}
```

## Notes
The vulnerability manifests in the data conversion layer rather than directly in `process_transaction_or_output_payload()`. The function itself correctly handles the either-or logic, but it never receives notification of the dropped data. The security issue is the protocol's tolerance for ambiguous payload states and the silent mishandling of such states without error propagation or peer feedback mechanisms.

### Citations

**File:** state-sync/storage-service/types/src/responses.rs (L136-139)
```rust
pub type TransactionOrOutputListWithProofV2 = (
    Option<TransactionListWithProofV2>,
    Option<TransactionOutputListWithProofV2>,
);
```

**File:** state-sync/aptos-data-client/src/interface.rs (L343-365)
```rust
impl TryFrom<(TransactionOrOutputListWithProofV2, LedgerInfoWithSignatures)> for ResponsePayload {
    type Error = Error;

    fn try_from(
        inner: (TransactionOrOutputListWithProofV2, LedgerInfoWithSignatures),
    ) -> error::Result<Self, Error> {
        let ((transaction_list, output_list), ledger_info) = inner;
        if let Some(transaction_list) = transaction_list {
            Ok(Self::NewTransactionsWithProof((
                transaction_list,
                ledger_info,
            )))
        } else if let Some(output_list) = output_list {
            Ok(Self::NewTransactionOutputsWithProof((
                output_list,
                ledger_info,
            )))
        } else {
            Err(Error::InvalidResponse(
                "Invalid response! No transaction or output list was returned!".into(),
            ))
        }
    }
```

**File:** state-sync/data-streaming-service/src/data_stream.rs (L1573-1588)
```rust
async fn get_new_transactions_or_outputs_with_proof<
    T: AptosDataClientInterface + Send + Clone + 'static,
>(
    aptos_data_client: T,
    request: NewTransactionsOrOutputsWithProofRequest,
    request_timeout_ms: u64,
) -> Result<Response<ResponsePayload>, aptos_data_client::error::Error> {
    let client_response = aptos_data_client.get_new_transactions_or_outputs_with_proof(
        request.known_version,
        request.known_epoch,
        request.include_events,
        request_timeout_ms,
    );
    let (context, payload) = client_response.await?.into_parts();
    Ok(Response::new(context, ResponsePayload::try_from(payload)?))
}
```

**File:** state-sync/state-sync-driver/src/continuous_syncer.rs (L209-254)
```rust
            match data_notification.data_payload {
                DataPayload::ContinuousTransactionOutputsWithProof(
                    ledger_info_with_sigs,
                    transaction_outputs_with_proof,
                ) => {
                    let payload_start_version =
                        transaction_outputs_with_proof.get_first_output_version();
                    let notification_metadata = NotificationMetadata::new(
                        data_notification.creation_time,
                        data_notification.notification_id,
                    );
                    self.process_transaction_or_output_payload(
                        consensus_sync_request.clone(),
                        notification_metadata,
                        ledger_info_with_sigs,
                        None,
                        Some(transaction_outputs_with_proof),
                        payload_start_version,
                    )
                    .await?;
                },
                DataPayload::ContinuousTransactionsWithProof(
                    ledger_info_with_sigs,
                    transactions_with_proof,
                ) => {
                    let payload_start_version =
                        transactions_with_proof.get_first_transaction_version();
                    let notification_metadata = NotificationMetadata::new(
                        data_notification.creation_time,
                        data_notification.notification_id,
                    );
                    self.process_transaction_or_output_payload(
                        consensus_sync_request.clone(),
                        notification_metadata,
                        ledger_info_with_sigs,
                        Some(transactions_with_proof),
                        None,
                        payload_start_version,
                    )
                    .await?;
                },
                _ => {
                    return self
                        .handle_end_of_stream_or_invalid_payload(data_notification)
                        .await;
                },
```
