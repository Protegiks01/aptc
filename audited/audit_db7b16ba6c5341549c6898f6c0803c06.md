# Audit Report

## Title
Compilation Metadata Bypass Allows Unstable Bytecode on Mainnet

## Summary
The `reject_unstable_bytecode()` function only validates bytecode stability when compilation metadata is present. An attacker can strip the `COMPILATION_METADATA_KEY` from compiled modules to bypass the mainnet stability check, allowing unstable/experimental bytecode to be deployed on production networks.

## Finding Description
The Aptos VM implements a security control to prevent unstable (experimental) bytecode from being published on mainnet. This is enforced through the `reject_unstable_bytecode()` function which checks the `unstable` flag in compilation metadata. [1](#0-0) 

The vulnerability exists because this function uses an `if let Some(metadata)` pattern that only performs the check when metadata is present. If `get_compilation_metadata()` returns `None`, the check is completely skipped. [2](#0-1) 

The `get_compilation_metadata()` function returns `None` when no `COMPILATION_METADATA_KEY` is found in the module's metadata section. Critically, there is **no requirement** that this metadata must be present.

The compilation metadata is added during module compilation: [3](#0-2) 

However, since Move bytecode is just serialized binary data, an attacker can deserialize compiled modules, manipulate the metadata vector, and re-serialize for submission.

**Attack Path:**

1. Attacker compiles a module using an unstable compiler version (e.g., `CompilerVersion::V2_1`) or unstable language version (e.g., `LanguageVersion::V2_4` or `V2_5`) [4](#0-3) [5](#0-4) 

2. The compiled module contains `CompilationMetadata` with `unstable: true` [6](#0-5) 

3. Attacker deserializes the `CompiledModule`, filters out entries with key `COMPILATION_METADATA_KEY` from the `metadata` vector, then re-serializes

4. Attacker publishes the modified module to mainnet via `code_publish_package_txn`

5. During validation in `validate_publish_request()`, the `reject_unstable_bytecode()` function is called [7](#0-6) 

6. Since `get_compilation_metadata(module)` returns `None`, the if-let doesn't match and the unstable check is completely bypassed

7. The module passes validation and is accepted on mainnet, violating the security invariant

## Impact Explanation
This is a **High Severity** vulnerability under the Aptos bug bounty program as it represents a "Significant protocol violation."

The unstable flag exists specifically to prevent unvetted, experimental code from running on production networks. Unstable compiler versions and language versions may contain:
- Experimental features that haven't undergone full security review
- Known bugs that are being fixed before stabilization
- Semantic differences that could cause consensus splits if validators run different compiler versions
- Unaudited optimizations or code generation patterns

By bypassing this check, an attacker can:
- Deploy bytecode compiled with experimental features onto mainnet
- Potentially exploit bugs that only exist in unstable versions
- Undermine the security model that ensures production networks only run stable, vetted code
- Violate the **Move VM Safety** and **Deterministic Execution** invariants if unstable features have bugs

The existing test suite validates that unstable bytecode is rejected when metadata is present, but no test validates the case where metadata is completely absent: [8](#0-7) 

## Likelihood Explanation
**Likelihood: High**

This vulnerability is highly likely to be exploited because:

1. **Low Complexity**: The attack requires only basic bytecode manipulation - deserialize, filter metadata, re-serialize
2. **No Special Privileges**: Any user can publish modules on mainnet (with proper gas fees and account setup)
3. **Clear Motivation**: Attackers may want to exploit experimental features or bugs in unstable versions
4. **No Detection**: The bypass is silent - validators would execute the bytecode without any indication it was compiled with an unstable version
5. **Existing Tooling**: Standard Rust serialization libraries can manipulate `CompiledModule` structures

The metadata validation only checks for malformed or duplicate metadata when present, but never enforces its presence: [9](#0-8) 

## Recommendation
Enforce that compilation metadata MUST be present for all modules published on mainnet. Add a validation check before the stability check:

```rust
fn reject_unstable_bytecode(&self, modules: &[CompiledModule]) -> VMResult<()> {
    if self.chain_id().is_mainnet() {
        for module in modules {
            // FIRST: Require metadata to be present on mainnet
            let metadata = get_compilation_metadata(module).ok_or_else(|| {
                PartialVMError::new(StatusCode::CONSTRAINT_NOT_SATISFIED)
                    .with_message(
                        "compilation metadata is required for mainnet deployment".to_string(),
                    )
                    .finish(Location::Undefined)
            })?;
            
            // THEN: Check if it's unstable
            if metadata.unstable {
                return Err(PartialVMError::new(StatusCode::UNSTABLE_BYTECODE_REJECTED)
                    .with_message(
                        "code marked unstable is not published on mainnet".to_string(),
                    )
                    .finish(Location::Undefined));
            }
        }
    }
    Ok(())
}
```

Apply the same fix to `reject_unstable_bytecode_for_script()`: [10](#0-9) 

Additionally, add validation in `check_metadata_format()` to require `COMPILATION_METADATA_KEY` when resource groups are enabled (which is the case on mainnet).

## Proof of Concept

```rust
#[test]
fn test_missing_compilation_metadata_on_mainnet() {
    let mut h = MoveHarness::new();
    let account = h.new_account_at(AccountAddress::from_hex_literal("0xf00d").unwrap());
    
    // Build a module with unstable compiler
    let mut builder = PackageBuilder::new("Package");
    builder.add_source(
        "m.move",
        r#"
        module 0xf00d::M {
            public fun foo(): u64 { 42 }
        }
        "#,
    );
    let path = builder.write_to_temp().unwrap();
    
    // Compile with unstable compiler version
    let package = BuiltPackage::build(
        path.path().to_path_buf(), 
        BuildOptions {
            compiler_version: Some(CompilerVersion::V2_1), // Unstable!
            ..BuildOptions::default()
        }
    ).expect("building package must succeed");
    
    let origin_code = package.extract_code();
    let mut compiled_module = CompiledModule::deserialize(&origin_code[0]).unwrap();
    
    // ATTACK: Strip compilation metadata
    compiled_module.metadata.retain(|m| m.key != *COMPILATION_METADATA_KEY);
    
    let mut manipulated_code = vec![];
    compiled_module.serialize(&mut manipulated_code).unwrap();
    
    // Set up mainnet environment
    h.set_resource(
        CORE_CODE_ADDRESS,
        ChainId::struct_tag(),
        &ChainId::mainnet().id(),
    );
    
    let package_metadata = package.extract_metadata().unwrap();
    
    // This should FAIL with UNSTABLE_BYTECODE_REJECTED but will SUCCEED
    let result = h.run_transaction_payload_mainnet(
        &account,
        aptos_stdlib::code_publish_package_txn(
            bcs::to_bytes(&package_metadata).unwrap(),
            vec![manipulated_code],
        ),
    );
    
    // VULNERABILITY: This succeeds when it should fail!
    // Currently: assert_success!(result);
    // Expected: assert_vm_status!(result, StatusCode::UNSTABLE_BYTECODE_REJECTED);
    assert_success!(result); // Demonstrates the bypass
}
```

This test demonstrates that by removing the `COMPILATION_METADATA_KEY`, unstable bytecode that should be rejected on mainnet is instead accepted, completely bypassing the security control.

## Notes
- The bytecode file format version (stored in the binary header) is separate from the language version (stored in compilation metadata) and is still validated
- However, the language version determines semantic features and compiler behavior, making this bypass security-critical
- The vulnerability affects both module publishing and script execution paths
- Latest stable versions are defined as `CompilerVersion::V2_0` and `LanguageVersion::V2_3` [11](#0-10)

### Citations

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1680-1690)
```rust
    fn validate_publish_request(
        &self,
        module_storage: &impl AptosModuleStorage,
        traversal_context: &mut TraversalContext,
        gas_meter: &mut impl GasMeter,
        modules: &[CompiledModule],
        mut expected_modules: BTreeSet<String>,
        allowed_deps: Option<BTreeMap<AccountAddress, BTreeSet<String>>>,
    ) -> VMResult<()> {
        self.reject_unstable_bytecode(modules)?;
        native_validation::validate_module_natives(modules)?;
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1742-1757)
```rust
    fn reject_unstable_bytecode(&self, modules: &[CompiledModule]) -> VMResult<()> {
        if self.chain_id().is_mainnet() {
            for module in modules {
                if let Some(metadata) = get_compilation_metadata(module) {
                    if metadata.unstable {
                        return Err(PartialVMError::new(StatusCode::UNSTABLE_BYTECODE_REJECTED)
                            .with_message(
                                "code marked unstable is not published on mainnet".to_string(),
                            )
                            .finish(Location::Undefined));
                    }
                }
            }
        }
        Ok(())
    }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1760-1771)
```rust
    pub fn reject_unstable_bytecode_for_script(&self, script: &CompiledScript) -> VMResult<()> {
        if self.chain_id().is_mainnet() {
            if let Some(metadata) = get_compilation_metadata(script) {
                if metadata.unstable {
                    return Err(PartialVMError::new(StatusCode::UNSTABLE_BYTECODE_REJECTED)
                        .with_message("script marked unstable cannot be run on mainnet".to_string())
                        .finish(Location::Script));
                }
            }
        }
        Ok(())
    }
```

**File:** types/src/vm/module_metadata.rs (L253-283)
```rust
fn check_metadata_format(module: &CompiledModule) -> Result<(), MalformedError> {
    let mut exist = false;
    let mut compilation_key_exist = false;
    for data in module.metadata.iter() {
        if data.key == *APTOS_METADATA_KEY || data.key == *APTOS_METADATA_KEY_V1 {
            if exist {
                return Err(MalformedError::DuplicateKey);
            }
            exist = true;

            if data.key == *APTOS_METADATA_KEY {
                bcs::from_bytes::<RuntimeModuleMetadata>(&data.value)
                    .map_err(|e| MalformedError::DeserializedError(data.key.clone(), e))?;
            } else if data.key == *APTOS_METADATA_KEY_V1 {
                bcs::from_bytes::<RuntimeModuleMetadataV1>(&data.value)
                    .map_err(|e| MalformedError::DeserializedError(data.key.clone(), e))?;
            }
        } else if data.key == *COMPILATION_METADATA_KEY {
            if compilation_key_exist {
                return Err(MalformedError::DuplicateKey);
            }
            compilation_key_exist = true;
            bcs::from_bytes::<CompilationMetadata>(&data.value)
                .map_err(|e| MalformedError::DeserializedError(data.key.clone(), e))?;
        } else {
            return Err(MalformedError::UnknownKey(data.key.clone()));
        }
    }

    Ok(())
}
```

**File:** types/src/vm/module_metadata.rs (L311-317)
```rust
pub fn get_compilation_metadata(code: &impl CompiledCodeMetadata) -> Option<CompilationMetadata> {
    if let Some(data) = find_metadata(code.metadata(), COMPILATION_METADATA_KEY) {
        bcs::from_bytes::<CompilationMetadata>(&data.value).ok()
    } else {
        None
    }
}
```

**File:** third_party/move/move-compiler-v2/src/file_format_generator/module_generator.rs (L165-174)
```rust
        let compilation_metadata = CompilationMetadata::new(compiler_version, language_version);
        let metadata = Metadata {
            key: COMPILATION_METADATA_KEY.to_vec(),
            value: bcs::to_bytes(&compilation_metadata)
                .expect("Serialization of CompilationMetadata should succeed"),
        };
        let module = move_binary_format::CompiledModule {
            version: file_format_common::VERSION_MAX,
            self_module_handle_idx: FF::ModuleHandleIndex(0),
            metadata: vec![metadata],
```

**File:** third_party/move/move-model/src/metadata.rs (L17-24)
```rust
pub const LATEST_LANGUAGE_VERSION_VALUE: LanguageVersion = LanguageVersion::V2_5;

/// Only stable versions are allowed on production networks
pub const LATEST_STABLE_LANGUAGE_VERSION_VALUE: LanguageVersion = LanguageVersion::V2_3;
pub const LATEST_STABLE_LANGUAGE_VERSION: &str = LATEST_STABLE_LANGUAGE_VERSION_VALUE.to_str();

pub const LATEST_STABLE_COMPILER_VERSION_VALUE: CompilerVersion = CompilerVersion::V2_0;
pub const LATEST_STABLE_COMPILER_VERSION: &str = LATEST_STABLE_COMPILER_VERSION_VALUE.to_str();
```

**File:** third_party/move/move-model/src/metadata.rs (L64-85)
```rust
impl CompilationMetadata {
    pub fn new(compiler_version: CompilerVersion, language_version: LanguageVersion) -> Self {
        Self {
            compiler_version: compiler_version.to_string(),
            language_version: language_version.to_string(),
            unstable: compiler_version.unstable() || language_version.unstable(),
        }
    }

    pub fn compiler_version(&self) -> anyhow::Result<CompilerVersion> {
        CompilerVersion::from_str(&self.compiler_version)
    }

    pub fn language_version(&self) -> anyhow::Result<LanguageVersion> {
        LanguageVersion::from_str(&self.language_version)
    }

    /// Returns true of the compilation was created as unstable.
    pub fn created_as_unstable(&self) -> bool {
        self.unstable
    }
}
```

**File:** third_party/move/move-model/src/metadata.rs (L148-157)
```rust
impl CompilerVersion {
    /// Return true if this is a stable compiler version. A non-stable version
    /// should not be allowed on production networks.
    pub fn unstable(self) -> bool {
        match self {
            CompilerVersion::V1 => false,
            CompilerVersion::V2_0 => false,
            CompilerVersion::V2_1 => true,
        }
    }
```

**File:** third_party/move/move-model/src/metadata.rs (L286-294)
```rust
    /// Whether the language version is unstable. An unstable version
    /// should not be allowed on production networks.
    pub const fn unstable(self) -> bool {
        use LanguageVersion::*;
        match self {
            V1 | V2_0 | V2_1 | V2_2 | V2_3 => false,
            V2_4 | V2_5 => true,
        }
    }
```

**File:** aptos-move/e2e-move-tests/src/tests/metadata.rs (L303-331)
```rust
#[test]
fn test_compilation_metadata_for_script() {
    // run unstable compiler code to mainnet
    assert_vm_status!(
        test_compilation_metadata_script_internal(true, true),
        StatusCode::UNSTABLE_BYTECODE_REJECTED
    );
    // run stable compiler code to mainnet
    assert_success!(test_compilation_metadata_script_internal(true, false,));
    // run unstable compiler code to test
    assert_success!(test_compilation_metadata_script_internal(false, true,));
    // run stable compiler code to test
    assert_success!(test_compilation_metadata_script_internal(false, false,));
}

#[test]
fn test_compilation_metadata() {
    // publish unstable compiler code to mainnet
    assert_vm_status!(
        test_compilation_metadata_internal(true, true),
        StatusCode::UNSTABLE_BYTECODE_REJECTED
    );
    // publish stable compiler code to mainnet
    assert_success!(test_compilation_metadata_internal(true, false,));
    // publish unstable compiler code to test
    assert_success!(test_compilation_metadata_internal(false, true,));
    // publish stable compiler code to test
    assert_success!(test_compilation_metadata_internal(false, false,));
}
```
