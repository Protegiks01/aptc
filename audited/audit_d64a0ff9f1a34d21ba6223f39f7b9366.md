# Audit Report

## Title
Unencrypted Consensus Key Storage and Missing Configuration Validation for Production Validators

## Summary
The `OnDiskStorage` implementation stores consensus private keys in plaintext JSON files without encryption. While documented as unsuitable for production, the configuration sanitizer fails to prevent its use on mainnet validators (unlike `InMemoryStorage`), and production deployment templates default to using it. This creates a key exposure risk if the validator's filesystem is compromised.

## Finding Description

The `CryptoKVStorage` trait is implemented as an empty marker trait that provides cryptographic operations through a blanket implementation. [1](#0-0)  This blanket implementation delegates all key storage operations to the underlying `KVStorage` trait without adding security controls like encryption, access auditing, or rate limiting. [2](#0-1) 

For `OnDiskStorage`, consensus private keys are stored as plain JSON with no encryption at rest. [3](#0-2)  The implementation explicitly warns "This should not be used in production" and states it "violates the code base" by making unprotected copies of key material. [4](#0-3) 

However, critical security gaps exist:

1. **Missing Configuration Validation**: The config sanitizer prevents `InMemoryStorage` on mainnet validators but does NOT prevent `OnDiskStorage`. [5](#0-4) 

2. **Insecure Production Defaults**: Official production deployment templates (Terraform Helm charts) explicitly configure validators to use `on_disk_storage` for consensus keys. [6](#0-5) 

3. **No Encryption Layer**: Consensus keys including BLS12-381 private keys are written directly to disk without any encryption. [7](#0-6) 

**Attack Scenario:**
1. Validator operator deploys using default Terraform configuration
2. Consensus keys stored in `/opt/aptos/data/secure-data.json` unencrypted
3. Attacker compromises validator node (container escape, SSH breach, backup exposure, cloud provider compromise)
4. Attacker reads `secure-data.json` and extracts consensus private key
5. Attacker can now sign consensus votes and blocks as the legitimate validator
6. This enables equivocation attacks or participation in consensus safety violations

## Impact Explanation

This qualifies as **Medium Severity** under the Aptos bug bounty criteria for the following reasons:

1. **Cryptographic Correctness Invariant Violation**: The requirement that "BLS signatures, VRF, and hash operations must be secure" is violated when private keys can be stolen from unencrypted storage.

2. **Potential Consensus Impact**: While not a direct consensus bug, stolen validator keys enable an attacker to:
   - Impersonate legitimate validators
   - Sign malicious blocks or votes
   - Participate in Byzantine attacks if combined with other compromised validators
   - Violate safety if < 1/3 threshold is breached

3. **State Inconsistencies**: Requires manual intervention to rotate compromised keys and potentially remove malicious consensus participation. [8](#0-7) 

The impact is limited to validators who use the insecure configuration, but this is amplified by production templates defaulting to it.

## Likelihood Explanation

**Likelihood: Medium to High**

Factors increasing likelihood:
- Production deployment templates use `OnDiskStorage` by default
- Config sanitizer inconsistency creates false sense of security (InMemory blocked but OnDisk allowed)
- No warning displayed to operators when using OnDiskStorage
- Realistic compromise vectors exist (container escapes, SSH breaches, backup theft, insider access)
- Affects multiple validators following official deployment guides

Factors decreasing likelihood:
- Requires initial node compromise (not a remote exploit)
- Documentation does warn against production use (though easily missed)
- Vault storage option exists but requires additional setup

## Recommendation

**Immediate Fix**: Extend the configuration sanitizer to reject `OnDiskStorage` for mainnet validators, consistent with how `InMemoryStorage` is handled:

```rust
// In config/src/config/safety_rules_config.rs, update sanitize():
if chain_id.is_mainnet() && node_type.is_validator() {
    match &safety_rules_config.backend {
        SecureBackend::InMemoryStorage => {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "The secure backend should not be set to in memory storage in mainnet!"
                    .to_string(),
            ));
        },
        SecureBackend::OnDiskStorage(_) => {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "The secure backend should not be set to on disk storage in mainnet! Use Vault storage for production."
                    .to_string(),
            ));
        },
        _ => {}
    }
}
```

**Additional Mitigations**:
1. Update production Terraform templates to use Vault storage or add explicit warnings
2. Add runtime warning logs when OnDiskStorage is initialized
3. Consider adding optional filesystem-level encryption for OnDiskStorage as defense-in-depth
4. Document the security implications more prominently in deployment guides

## Proof of Concept

**Step 1**: Deploy validator using official Terraform template (uses OnDiskStorage by default)

**Step 2**: Consensus keys are stored unencrypted:
```bash
# On validator node
cat /opt/aptos/data/secure-data.json
# Output shows plaintext consensus_key and other sensitive data
```

**Step 3**: Attacker with file read access extracts key:
```rust
// Example key extraction (simplified)
use serde_json::Value;
use std::fs;

fn extract_consensus_key(path: &str) -> Result<String, Box<dyn std::error::Error>> {
    let contents = fs::read_to_string(path)?;
    let data: Value = serde_json::from_str(&contents)?;
    
    // Extract consensus_key from JSON
    if let Some(key_data) = data.get("consensus_key") {
        println!("Consensus private key extracted: {:?}", key_data);
        // Attacker can now use this key to sign consensus messages
    }
    Ok("Key extracted".to_string())
}
```

**Step 4**: Verify config sanitizer allows this:
```rust
// Test in config/src/config/safety_rules_config.rs
#[test]
fn test_ondisk_storage_allowed_on_mainnet() {
    let node_config = NodeConfig {
        consensus: ConsensusConfig {
            safety_rules: SafetyRulesConfig {
                backend: SecureBackend::OnDiskStorage(OnDiskStorageConfig::default()),
                ..Default::default()
            },
            ..Default::default()
        },
        ..Default::default()
    };
    
    // This currently PASSES but should FAIL
    SafetyRulesConfig::sanitize(
        &node_config,
        NodeType::Validator,
        Some(ChainId::mainnet()),
    ).expect("OnDiskStorage incorrectly allowed on mainnet!");
}
```

The vulnerability is confirmed by the inconsistent validation logic and insecure production defaults that expose consensus keys to theft upon filesystem compromise.

### Citations

**File:** secure/storage/src/crypto_kv_storage.rs (L16-16)
```rust
pub trait CryptoKVStorage: KVStorage {}
```

**File:** secure/storage/src/crypto_kv_storage.rs (L18-110)
```rust
impl<T: CryptoKVStorage> CryptoStorage for T {
    fn create_key(&mut self, name: &str) -> Result<Ed25519PublicKey, Error> {
        // Generate and store the new named key pair
        let (private_key, public_key) = new_ed25519_key_pair();
        self.import_private_key(name, private_key)?;
        Ok(public_key)
    }

    fn export_private_key(&self, name: &str) -> Result<Ed25519PrivateKey, Error> {
        self.get(name).map(|v| v.value)
    }

    fn export_private_key_for_version(
        &self,
        name: &str,
        version: Ed25519PublicKey,
    ) -> Result<Ed25519PrivateKey, Error> {
        let current_private_key = self.export_private_key(name)?;
        if current_private_key.public_key().eq(&version) {
            return Ok(current_private_key);
        }

        match self.export_private_key(&get_previous_version_name(name)) {
            Ok(previous_private_key) => {
                if previous_private_key.public_key().eq(&version) {
                    Ok(previous_private_key)
                } else {
                    Err(Error::KeyVersionNotFound(name.into(), version.to_string()))
                }
            },
            Err(Error::KeyNotSet(_)) => {
                Err(Error::KeyVersionNotFound(name.into(), version.to_string()))
            },
            Err(e) => Err(e),
        }
    }

    fn import_private_key(&mut self, name: &str, key: Ed25519PrivateKey) -> Result<(), Error> {
        self.set(name, key)
    }

    fn get_public_key(&self, name: &str) -> Result<PublicKeyResponse, Error> {
        let response = self.get(name)?;
        let key: Ed25519PrivateKey = response.value;

        Ok(PublicKeyResponse {
            last_update: response.last_update,
            public_key: key.public_key(),
        })
    }

    fn get_public_key_previous_version(&self, name: &str) -> Result<Ed25519PublicKey, Error> {
        match self.export_private_key(&get_previous_version_name(name)) {
            Ok(previous_private_key) => Ok(previous_private_key.public_key()),
            Err(Error::KeyNotSet(_)) => Err(Error::KeyVersionNotFound(
                name.into(),
                "previous version".into(),
            )),
            Err(e) => Err(e),
        }
    }

    fn rotate_key(&mut self, name: &str) -> Result<Ed25519PublicKey, Error> {
        let private_key: Ed25519PrivateKey = self.get(name)?.value;
        let (new_private_key, new_public_key) = new_ed25519_key_pair();
        self.set(&get_previous_version_name(name), private_key)?;
        self.set(name, new_private_key)?;
        Ok(new_public_key)
    }

    fn sign<U: CryptoHash + Serialize>(
        &self,
        name: &str,
        message: &U,
    ) -> Result<Ed25519Signature, Error> {
        let private_key = self.export_private_key(name)?;
        private_key
            .sign(message)
            .map_err(|err| Error::SerializationError(err.to_string()))
    }

    fn sign_using_version<U: CryptoHash + Serialize>(
        &self,
        name: &str,
        version: Ed25519PublicKey,
        message: &U,
    ) -> Result<Ed25519Signature, Error> {
        let private_key = self.export_private_key_for_version(name, version)?;
        private_key
            .sign(message)
            .map_err(|err| Error::SerializationError(err.to_string()))
    }
}
```

**File:** secure/storage/src/on_disk.rs (L16-22)
```rust
/// OnDiskStorage represents a key value store that is persisted to the local filesystem and is
/// intended for single threads (or must be wrapped by a Arc<RwLock<>>). This provides no permission
/// checks and simply offers a proof of concept to unblock building of applications without more
/// complex data stores. Internally, it reads and writes all data to a file, which means that it
/// must make copies of all key material which violates the code base. It violates it because
/// the anticipation is that data stores would securely handle key material. This should not be used
/// in production.
```

**File:** secure/storage/src/on_disk.rs (L64-69)
```rust
    fn write(&self, data: &HashMap<String, Value>) -> Result<(), Error> {
        let contents = serde_json::to_vec(data)?;
        let mut file = File::create(self.temp_path.path())?;
        file.write_all(&contents)?;
        fs::rename(&self.temp_path, &self.file_path)?;
        Ok(())
```

**File:** secure/storage/src/on_disk.rs (L101-101)
```rust
impl CryptoKVStorage for OnDiskStorage {}
```

**File:** config/src/config/safety_rules_config.rs (L86-96)
```rust
            // Verify that the secure backend is appropriate for mainnet validators
            if chain_id.is_mainnet()
                && node_type.is_validator()
                && safety_rules_config.backend.is_in_memory()
            {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "The secure backend should not be set to in memory storage in mainnet!"
                        .to_string(),
                ));
            }
```

**File:** terraform/helm/aptos-node/files/configs/validator-base.yaml (L14-16)
```yaml
    backend:
      type: "on_disk_storage"
      path: secure-data.json
```

**File:** consensus/safety-rules/src/persistent_safety_storage.rs (L106-132)
```rust
    pub fn consensus_sk_by_pk(
        &self,
        pk: bls12381::PublicKey,
    ) -> Result<bls12381::PrivateKey, Error> {
        let _timer = counters::start_timer("get", CONSENSUS_KEY);
        let pk_hex = hex::encode(pk.to_bytes());
        let explicit_storage_key = format!("{}_{}", CONSENSUS_KEY, pk_hex);
        let explicit_sk = self
            .internal_store
            .get::<bls12381::PrivateKey>(explicit_storage_key.as_str())
            .map(|v| v.value);
        let default_sk = self.default_consensus_sk();
        let key = match (explicit_sk, default_sk) {
            (Ok(sk_0), _) => sk_0,
            (Err(_), Ok(sk_1)) => sk_1,
            (Err(_), Err(_)) => {
                return Err(Error::ValidatorKeyNotFound("not found!".to_string()));
            },
        };
        if key.public_key() != pk {
            return Err(Error::SecureStorageMissingDataError(format!(
                "Incorrect sk saved for {:?} the expected pk",
                pk
            )));
        }
        Ok(key)
    }
```
