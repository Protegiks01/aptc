# Audit Report

## Title
Version Inconsistency Vulnerability in Consensus Certificate Merging

## Summary
The `match_ordered_only()` function used to validate BlockInfo consistency does not check the `version` field, potentially allowing ordered certificates with incorrect versions to be merged with executed states, creating version inconsistencies across the consensus layer.

## Finding Description

The `match_ordered_only()` function in BlockInfo validates that ordered and executed block information match, but explicitly excludes version validation: [1](#0-0) 

This function is used in critical consensus code paths when merging ordered proofs with executed state: [2](#0-1) [3](#0-2) [4](#0-3) 

**The Attack Vector:**

In decoupled execution mode, ordered blocks typically have `version=0` as a placeholder. However, genesis blocks for epoch transitions carry non-zero versions from the previous epoch: [5](#0-4) 

During fast-forward sync or recovery scenarios, ordered certificates can be initialized with non-zero versions: [6](#0-5) [7](#0-6) 

If an ordered certificate with version X is merged with an executed ledger info with version Y (where X ≠ Y ≠ 0), the `match_ordered_only()` check passes, creating a version mismatch that can propagate through the consensus layer: [8](#0-7) 

## Impact Explanation

This vulnerability represents a **Medium to High severity** issue:

**Consensus Invariant Violation**: Validators may accept blocks with inconsistent version information, violating the critical invariant that all validators must have identical views of block metadata. While storage-level validation provides a backstop, the consensus layer should independently ensure version consistency.

**State Inconsistency Risk**: During recovery, epoch transitions, or fast-forward sync scenarios, validators could temporarily operate with divergent version information before storage validation catches the issue, potentially causing synchronization delays or requiring manual intervention.

**Impact Category**: This falls under "Significant protocol violations" (High Severity per bug bounty) as it affects consensus metadata consistency, though it does not directly enable fund theft or total network failure.

## Likelihood Explanation

**Likelihood: Medium**

The vulnerability requires specific conditions:
- Non-standard execution paths (genesis, recovery, fast-forward sync)
- Version mismatch between ordered and executed states
- Bypassing or occurring before storage-layer validation

While not exploitable in normal operation (where ordered blocks have version=0), edge cases during network recovery, epoch boundaries, or validator restarts increase likelihood. The issue is mitigated by storage-level validation but creates a validation gap in the consensus layer.

## Recommendation

Add explicit version validation to `match_ordered_only()` for non-zero version cases:

```rust
pub fn match_ordered_only(&self, executed_block_info: &BlockInfo) -> bool {
    // Existing checks
    let basic_match = self.epoch == executed_block_info.epoch
        && self.round == executed_block_info.round
        && self.id == executed_block_info.id
        && (self.timestamp_usecs == executed_block_info.timestamp_usecs
            || (self.timestamp_usecs > executed_block_info.timestamp_usecs
                && executed_block_info.has_reconfiguration()));
    
    // If both have non-zero versions, they must match
    // Version 0 is a placeholder for ordered-only state and can differ
    if self.version != 0 && executed_block_info.version != 0 {
        return basic_match && self.version == executed_block_info.version;
    }
    
    basic_match
}
```

This preserves the intended behavior for decoupled execution (version 0 → actual version) while catching mismatches in edge cases (non-zero → different non-zero).

## Proof of Concept

Due to the complexity of the consensus system and the requirement for specific edge case conditions (epoch transitions, recovery paths), a full PoC would require:

1. Setting up a test network with epoch transition
2. Inducing a recovery scenario where ordered cert has non-zero version
3. Causing execution to produce different version
4. Demonstrating the mismatch propagates through consensus

However, the vulnerability can be demonstrated through code analysis showing the validation gap exists at the critical merge points cited above, with no version checking between non-zero values in `match_ordered_only()`.

**Notes:**
- This issue affects consensus metadata validation integrity
- Multiple defense layers (storage validation, deterministic execution) reduce but don't eliminate risk
- Most critical during non-standard execution paths (recovery, genesis, sync)
- Recommended fix maintains backward compatibility while closing the validation gap

### Citations

**File:** types/src/block_info.rs (L196-204)
```rust
    pub fn match_ordered_only(&self, executed_block_info: &BlockInfo) -> bool {
        self.epoch == executed_block_info.epoch
            && self.round == executed_block_info.round
            && self.id == executed_block_info.id
            && (self.timestamp_usecs == executed_block_info.timestamp_usecs
            // executed block info has changed its timestamp because it's a reconfiguration suffix
                || (self.timestamp_usecs > executed_block_info.timestamp_usecs
                    && executed_block_info.has_reconfiguration()))
    }
```

**File:** consensus/consensus-types/src/quorum_cert.rs (L84-99)
```rust
    pub fn certificate_for_genesis_from_ledger_info(
        ledger_info: &LedgerInfo,
        genesis_id: HashValue,
    ) -> QuorumCert {
        let ancestor = BlockInfo::new(
            ledger_info
                .epoch()
                .checked_add(1)
                .expect("Integer overflow when creating cert for genesis from ledger info"),
            0,
            genesis_id,
            ledger_info.transaction_accumulator_hash(),
            ledger_info.version(),
            ledger_info.timestamp_usecs(),
            None,
        );
```

**File:** consensus/consensus-types/src/quorum_cert.rs (L150-163)
```rust
    pub fn create_merged_with_executed_state(
        &self,
        executed_ledger_info: LedgerInfoWithSignatures,
    ) -> anyhow::Result<QuorumCert> {
        let self_commit_info = self.commit_info();
        let executed_commit_info = executed_ledger_info.ledger_info().commit_info();
        ensure!(
            self_commit_info.match_ordered_only(executed_commit_info),
            "Block info from QC and executed LI need to match, {:?} and {:?}",
            self_commit_info,
            executed_commit_info
        );
        Ok(Self::new(self.vote_data.clone(), executed_ledger_info))
    }
```

**File:** consensus/consensus-types/src/wrapped_ledger_info.rs (L110-123)
```rust
    pub fn create_merged_with_executed_state(
        &self,
        executed_ledger_info: LedgerInfoWithSignatures,
    ) -> anyhow::Result<WrappedLedgerInfo> {
        let self_commit_info = self.commit_info();
        let executed_commit_info = executed_ledger_info.ledger_info().commit_info();
        ensure!(
            self_commit_info.match_ordered_only(executed_commit_info),
            "Block info from QC and executed LI need to match, {:?} and {:?}",
            self_commit_info,
            executed_commit_info
        );
        Ok(Self::new(self.vote_data.clone(), executed_ledger_info))
    }
```

**File:** consensus/safety-rules/src/safety_rules.rs (L381-393)
```rust
        if !old_ledger_info.commit_info().is_ordered_only()
            // When doing fast forward sync, we pull the latest blocks and quorum certs from peers
            // and store them in storage. We then compute the root ordered cert and root commit cert
            // from storage and start the consensus from there. But given that we are not storing the
            // ordered cert obtained from order votes in storage, instead of obtaining the root ordered cert
            // from storage, we set root ordered cert to commit certificate.
            // This means, the root ordered cert will not have a dummy executed_state_id in this case.
            // To handle this, we do not raise error if the old_ledger_info.commit_info() matches with
            // new_ledger_info.commit_info().
            && old_ledger_info.commit_info() != new_ledger_info.commit_info()
        {
            return Err(Error::InvalidOrderedLedgerInfo(old_ledger_info.to_string()));
        }
```

**File:** consensus/safety-rules/src/safety_rules.rs (L395-403)
```rust
        if !old_ledger_info
            .commit_info()
            .match_ordered_only(new_ledger_info.commit_info())
        {
            return Err(Error::InconsistentExecutionResult(
                old_ledger_info.commit_info().to_string(),
                new_ledger_info.commit_info().to_string(),
            ));
        }
```

**File:** consensus/src/persistent_liveness_storage.rs (L145-163)
```rust
        let (root_ordered_cert, root_commit_cert) = if order_vote_enabled {
            // We are setting ordered_root same as commit_root. As every committed block is also ordered, this is fine.
            // As the block store inserts all the fetched blocks and quorum certs and execute the blocks, the block store
            // updates highest_ordered_cert accordingly.
            let root_ordered_cert =
                WrappedLedgerInfo::new(VoteData::dummy(), latest_ledger_info_sig.clone());
            (root_ordered_cert.clone(), root_ordered_cert)
        } else {
            let root_ordered_cert = quorum_certs
                .iter()
                .find(|qc| qc.commit_info().id() == commit_block.id())
                .ok_or_else(|| format_err!("No LI found for root: {}", latest_commit_id))?
                .clone()
                .into_wrapped_ledger_info();
            let root_commit_cert = root_ordered_cert
                .create_merged_with_executed_state(latest_ledger_info_sig)
                .expect("Inconsistent commit proof and evaluation decision, cannot commit block");
            (root_ordered_cert, root_commit_cert)
        };
```

**File:** consensus/src/pipeline/buffer_item.rs (L274-277)
```rust
                assert!(ordered
                    .ordered_proof
                    .commit_info()
                    .match_ordered_only(commit_proof.commit_info()));
```
