# Audit Report

## Title
Unauthenticated Remote KV Request Deserialization Enables Resource Exhaustion in Executor Service

## Summary
The `RemoteStateViewService` accepts and deserializes key-value requests from any network peer without authentication or validation, allowing attackers with network access to executor shard endpoints to cause thread pool exhaustion and consensus performance degradation through maliciously crafted BCS-encoded payloads.

## Finding Description

The executor service's `RemoteStateViewService` handles key-value requests from the coordinator during sharded block execution. However, the implementation contains multiple security issues that break the Resource Limits invariant:

**Vulnerable Code Path:** [1](#0-0) 

Messages are received and spawned on a thread pool without any validation: [2](#0-1) 

The deserialization occurs with no input validation and uses `.unwrap()` which panics on malformed input. The underlying gRPC service accepts messages from any network peer without authentication: [3](#0-2) 

**Attack Vector:**

1. Attacker identifies executor shard network addresses (configured via CLI): [4](#0-3) 

2. Attacker sends malicious gRPC messages with type "remote_kv_request" containing:
   - Maximum-sized payloads (up to 80MB limit): [5](#0-4) 
   - Extremely large `Vec<StateKey>` requiring slow deserialization
   - Malformed BCS causing thread panics

3. Each malicious message consumes a thread from the pool (default size = CPU count): [6](#0-5) 

4. Sustained attack exhausts thread pool, blocking legitimate KV requests needed for block execution

5. This executor service is used in production when remote addresses are configured: [7](#0-6) 

**Invariant Violations:**

- **Resource Limits**: No validation before expensive deserialization operations
- **Deterministic Execution**: If one shard is degraded by attack, block execution timing becomes non-deterministic across validators

## Impact Explanation

This qualifies as **High Severity** per Aptos bug bounty criteria: "Validator node slowdowns."

**Specific Impact:**
- Thread pool exhaustion blocks legitimate state value fetches during block execution
- Block execution delays cascade to consensus performance degradation  
- Sustained attack can significantly slow validator operations
- Multiple validators using remote execution could be simultaneously affected

While the service is intended for internal deployment, the lack of authentication combined with no input validation creates a critical attack surface if:
- Network isolation is misconfigured
- An attacker compromises a machine on the internal network
- A malicious coordinator or shard is present

## Likelihood Explanation

**Likelihood: Medium**

**Requirements:**
- Attacker needs network access to executor shard gRPC endpoints
- Endpoints listen on configured SocketAddr without authentication
- In properly configured deployments, these should be network-isolated
- However, misconfigurations or network compromises could enable exploitation

**Complexity: Low**
- Attack requires only sending crafted gRPC messages
- No authentication bypass needed (none exists)
- BCS encoding tools are readily available
- Impact scales with message rate and payload size

## Recommendation

Implement defense-in-depth protections:

1. **Add Authentication**: Implement mutual TLS or token-based authentication for gRPC endpoints
2. **Input Validation**: Validate message size and structure before deserialization
3. **Graceful Error Handling**: Replace `.unwrap()` with proper error handling
4. **Rate Limiting**: Implement per-peer rate limiting
5. **Bounds Checking**: Validate `Vec<StateKey>` length before processing

**Example Fix** (partial):

```rust
pub fn handle_message(
    message: Message,
    state_view: Arc<RwLock<Option<Arc<S>>>>,
    kv_tx: Arc<Vec<Sender<Message>>>,
) {
    const MAX_KEYS_PER_REQUEST: usize = 10_000;
    
    let _timer = REMOTE_EXECUTOR_TIMER
        .with_label_values(&["0", "kv_requests"])
        .start_timer();
    let bcs_deser_timer = REMOTE_EXECUTOR_TIMER
        .with_label_values(&["0", "kv_req_deser"])
        .start_timer();
    
    // Validate message size before deserialization
    if message.data.len() > 10 * 1024 * 1024 {  // 10MB limit
        warn!("Rejecting oversized KV request: {} bytes", message.data.len());
        return;
    }
    
    // Use Result instead of unwrap
    let req: RemoteKVRequest = match bcs::from_bytes(&message.data) {
        Ok(r) => r,
        Err(e) => {
            warn!("Failed to deserialize KV request: {}", e);
            return;
        }
    };
    drop(bcs_deser_timer);
    
    let (shard_id, state_keys) = req.into();
    
    // Validate reasonable bounds
    if state_keys.len() > MAX_KEYS_PER_REQUEST {
        warn!("Rejecting KV request with {} keys (max: {})", 
              state_keys.len(), MAX_KEYS_PER_REQUEST);
        return;
    }
    
    // ... rest of implementation
}
```

Additionally, add authentication at the gRPC service layer using tonic interceptors.

## Proof of Concept

```rust
// PoC: Demonstrate resource exhaustion via malicious KV requests
// This would be run against a test executor service setup

use aptos_executor_service::RemoteKVRequest;
use aptos_types::state_store::state_key::StateKey;
use aptos_secure_net::network_controller::Message;

#[test]
fn test_kv_request_resource_exhaustion() {
    // Create a malicious request with maximum allowed keys
    let mut large_keys = Vec::new();
    for i in 0..100_000 {  // Large number of state keys
        let key = StateKey::raw(&vec![i as u8; 1000]);  // Each key is 1KB
        large_keys.push(key);
    }
    
    let malicious_request = RemoteKVRequest::new(0, large_keys);
    let serialized = bcs::to_bytes(&malicious_request).unwrap();
    
    // This message is ~100MB and will take significant time to deserialize
    println!("Malicious message size: {} bytes", serialized.len());
    
    // In a real attack, send multiple such messages rapidly to
    // exhaust the thread pool (typically 8-16 threads)
    // Each thread would be blocked deserializing for extended periods
    
    // Simulate sending to executor shard
    let message = Message::new(serialized);
    // send_to_executor_shard(message); // Would exhaust thread pool
}
```

**Notes:**
- This vulnerability requires network access to executor shard endpoints, which should be restricted in production deployments through proper network segmentation
- However, the lack of authentication and input validation represents a defense-in-depth failure that should be addressed regardless of network topology
- The `kv_req_deser` metric would show elevated values during such an attack, confirming the resource exhaustion

### Citations

**File:** execution/executor-service/src/remote_state_view_service.rs (L30-36)
```rust
        let num_threads = num_threads.unwrap_or_else(num_cpus::get);
        let thread_pool = Arc::new(
            rayon::ThreadPoolBuilder::new()
                .num_threads(num_threads)
                .build()
                .unwrap(),
        );
```

**File:** execution/executor-service/src/remote_state_view_service.rs (L64-72)
```rust
    pub fn start(&self) {
        while let Ok(message) = self.kv_rx.recv() {
            let state_view = self.state_view.clone();
            let kv_txs = self.kv_tx.clone();
            self.thread_pool.spawn(move || {
                Self::handle_message(message, state_view, kv_txs);
            });
        }
    }
```

**File:** execution/executor-service/src/remote_state_view_service.rs (L74-87)
```rust
    pub fn handle_message(
        message: Message,
        state_view: Arc<RwLock<Option<Arc<S>>>>,
        kv_tx: Arc<Vec<Sender<Message>>>,
    ) {
        // we don't know the shard id until we deserialize the message, so lets default it to 0
        let _timer = REMOTE_EXECUTOR_TIMER
            .with_label_values(&["0", "kv_requests"])
            .start_timer();
        let bcs_deser_timer = REMOTE_EXECUTOR_TIMER
            .with_label_values(&["0", "kv_req_deser"])
            .start_timer();
        let req: RemoteKVRequest = bcs::from_bytes(&message.data).unwrap();
        drop(bcs_deser_timer);
```

**File:** secure/net/src/grpc_network_service/mod.rs (L23-23)
```rust
const MAX_MESSAGE_SIZE: usize = 1024 * 1024 * 80;
```

**File:** secure/net/src/grpc_network_service/mod.rs (L93-115)
```rust
    async fn simple_msg_exchange(
        &self,
        request: Request<NetworkMessage>,
    ) -> Result<Response<Empty>, Status> {
        let _timer = NETWORK_HANDLER_TIMER
            .with_label_values(&[&self.self_addr.to_string(), "inbound_msgs"])
            .start_timer();
        let remote_addr = request.remote_addr();
        let network_message = request.into_inner();
        let msg = Message::new(network_message.message);
        let message_type = MessageType::new(network_message.message_type);

        if let Some(handler) = self.inbound_handlers.lock().unwrap().get(&message_type) {
            // Send the message to the registered handler
            handler.send(msg).unwrap();
        } else {
            error!(
                "No handler registered for sender: {:?} and msg type {:?}",
                remote_addr, message_type
            );
        }
        Ok(Response::new(Empty {}))
    }
```

**File:** execution/executor-service/src/main.rs (L20-24)
```rust
    #[clap(long, num_args = 1..)]
    pub remote_executor_addresses: Vec<SocketAddr>,

    #[clap(long)]
    pub coordinator_address: SocketAddr,
```

**File:** execution/executor/src/workflow/do_get_execution_output.rs (L261-267)
```rust
        if !get_remote_addresses().is_empty() {
            Ok(V::execute_block_sharded(
                &REMOTE_SHARDED_BLOCK_EXECUTOR.lock(),
                partitioned_txns,
                state_view,
                onchain_config,
            )?)
```
