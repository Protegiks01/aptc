# Audit Report

## Title
Cross-Network Information Disclosure in Peer Monitoring Service Leaks Validator Network Topology

## Summary
The peer monitoring service's `send_request_to_peer()` function and server-side `get_network_information()` handler lack network boundary validation, allowing nodes on one network (e.g., VFN network) to probe and extract topology information about peers on a different network (e.g., validator network). This enables a VFN to discover all validators a target validator is connected to, including their IP addresses, peer IDs, and roles.

## Finding Description

The vulnerability exists at two layers:

**Client-Side (No Network Validation)**:
The `send_request_to_peer()` function accepts any `peer_network_id` parameter without validating whether the target network is appropriate for monitoring. [1](#0-0) 

The function directly passes the `peer_network_id` to the underlying network client without checking if cross-network monitoring should be allowed. The only validation performed is whether a `NetworkSender` exists for that network ID in the client's configuration. [2](#0-1) 

**Server-Side (No Response Filtering)**:
When a peer monitoring server receives a `GetNetworkInformation` request, it returns information about ALL connected peers across ALL networks, regardless of which network the request originated from. [3](#0-2) 

The `get_network_information()` method calls `get_connected_peers_and_metadata()` which returns peers from all networks without filtering: [4](#0-3) 

This method iterates through ALL network IDs and returns all connected peers regardless of the requester's network context.

**Attack Scenario**:
1. A VFN connects to a validator on the VFN network (normal operation)
2. The VFN's peer monitoring client automatically sends `GetNetworkInformation` requests to the validator
3. The validator's server responds with information about ALL its connected peers, including:
   - Validators on the validator network
   - Their IP addresses (NetworkAddress)
   - Their peer IDs
   - Their roles (PeerRole::Validator) [5](#0-4) 

4. The VFN now possesses complete validator network topology information, which should only be visible within the validator network

The peer monitoring loop automatically processes all connected peers across all networks: [6](#0-5) 

## Impact Explanation

This vulnerability qualifies as **Medium severity** per Aptos bug bounty criteria for the following reasons:

1. **Information Disclosure**: Leaks sensitive validator network topology (IP addresses, peer IDs, roles) to nodes that should not have access to this information
2. **Attack Facilitation**: The exposed information can be used to:
   - Map the complete validator network structure
   - Identify specific validators for targeted attacks
   - Understand network redundancy and connectivity patterns
   - Facilitate eclipse attacks or network partitioning attempts
3. **Network Security Boundary Violation**: Breaks the isolation between network tiers (Validator network vs VFN network vs Public network)

While this doesn't directly cause loss of funds or consensus violations, it compromises the confidentiality of critical network infrastructure information that should remain private within the validator network.

## Likelihood Explanation

**Likelihood: High**

This vulnerability occurs automatically during normal operation:
1. Peer monitoring service is enabled by default on nodes
2. The client automatically polls all connected peers for network information
3. No special configuration or malicious input is required
4. Any VFN operator can passively collect this information

The exploit requires:
- Operating a VFN (which is a normal, non-privileged role)
- Connecting to validators (which happens automatically)
- Waiting for the peer monitoring service to run its periodic requests

No special privileges, insider access, or complex attack coordination is needed.

## Recommendation

Implement network-aware filtering in the peer monitoring service:

**Option 1: Server-Side Filtering**
Modify `get_network_information()` to accept the requester's `network_id` and filter the response to only include peers on the same or less privileged networks:

```rust
fn get_network_information(
    &self,
    requester_network_id: NetworkId,
) -> Result<PeerMonitoringServiceResponse, Error> {
    let connected_peers_and_metadata =
        self.peers_and_metadata.get_connected_peers_and_metadata()?;
    
    // Filter peers based on network access policy
    let filtered_peers = connected_peers_and_metadata
        .into_iter()
        .filter(|(peer_network_id, _)| {
            is_network_visible_to_requester(
                peer_network_id.network_id(),
                requester_network_id
            )
        })
        .map(|(peer, metadata)| {
            let connection_metadata = metadata.get_connection_metadata();
            (
                peer,
                ConnectionMetadata::new(
                    connection_metadata.addr,
                    connection_metadata.remote_peer_id,
                    connection_metadata.role,
                ),
            )
        })
        .collect();
    
    // Rest of the method...
}

fn is_network_visible_to_requester(
    peer_network: NetworkId,
    requester_network: NetworkId,
) -> bool {
    match requester_network {
        NetworkId::Validator => true, // Validators can see all networks
        NetworkId::Vfn => peer_network != NetworkId::Validator, // VFNs cannot see validator network
        NetworkId::Public => peer_network == NetworkId::Public, // Public can only see public
    }
}
```

Update the `call` method to pass `network_id` to the handler: [7](#0-6) 

**Option 2: Client-Side Prevention**
Add validation in `send_request_to_peer()` or the peer monitoring loop to prevent sending requests to peers on more privileged networks.

## Proof of Concept

The vulnerability can be demonstrated with the following observation:

1. Deploy a validator node with connections to other validators on NetworkId::Validator
2. Connect a VFN to the validator on NetworkId::Vfn
3. Enable peer monitoring client on the VFN
4. Observe the peer monitoring logs or metrics

The VFN will receive `NetworkInformationResponse` containing entries with `PeerNetworkId` where `network_id() == NetworkId::Validator`, exposing the validator's connections to other validators including their IP addresses and roles.

This can be verified by:
- Checking peer monitoring metrics for peers with NetworkId::Validator visible to VFN
- Inspecting PeersAndMetadata on the VFN to see validator network peers
- Monitoring network traffic to observe NetworkInformationResponse payloads containing validator network data

The fix can be validated by ensuring that after implementing the recommendation, VFN monitoring requests only return peers on NetworkId::Vfn and NetworkId::Public, never NetworkId::Validator.

## Notes

This vulnerability represents a **network security boundary violation** where the three-tier network architecture (Validator → VFN → Public) is not properly enforced in the peer monitoring service. While Aptos correctly implements network isolation at the connection level, the peer monitoring service inadvertently leaks cross-network information through its monitoring responses.

The severity is Medium rather than Low because validator network topology is considered sensitive infrastructure information that, if exposed, could facilitate more serious attacks against the validator set.

### Citations

**File:** peer-monitoring-service/client/src/network.rs (L69-95)
```rust
pub async fn send_request_to_peer(
    peer_monitoring_client: PeerMonitoringServiceClient<
        NetworkClient<PeerMonitoringServiceMessage>,
    >,
    peer_network_id: &PeerNetworkId,
    request_id: u64,
    request: PeerMonitoringServiceRequest,
    request_timeout_ms: u64,
) -> Result<PeerMonitoringServiceResponse, Error> {
    trace!(
        (LogSchema::new(LogEntry::SendRequest)
            .event(LogEvent::SendRequest)
            .request_type(request.get_label())
            .request_id(request_id)
            .peer(peer_network_id)
            .request(&request))
    );
    metrics::increment_request_counter(
        &metrics::SENT_REQUESTS,
        request.get_label(),
        peer_network_id,
    );

    // Send the request and process the result
    let result = peer_monitoring_client
        .send_request(
            *peer_network_id,
```

**File:** network/framework/src/application/interface.rs (L260-272)
```rust
    async fn send_to_peer_rpc(
        &self,
        message: Message,
        rpc_timeout: Duration,
        peer: PeerNetworkId,
    ) -> Result<Message, Error> {
        let network_sender = self.get_sender_for_network_id(&peer.network_id())?;
        let rpc_protocol_id =
            self.get_preferred_protocol_for_peer(&peer, &self.rpc_protocols_and_preferences)?;
        Ok(network_sender
            .send_rpc(peer.peer_id(), rpc_protocol_id, message, rpc_timeout)
            .await?)
    }
```

**File:** peer-monitoring-service/server/src/lib.rs (L155-183)
```rust
    pub fn call(
        &self,
        network_id: NetworkId,
        request: PeerMonitoringServiceRequest,
    ) -> Result<PeerMonitoringServiceResponse> {
        // Update the request count
        increment_counter(
            &metrics::PEER_MONITORING_REQUESTS_RECEIVED,
            network_id,
            request.get_label(),
        );

        // Time the request processing (the timer will stop when it's dropped)
        let _timer = start_timer(
            &metrics::PEER_MONITORING_REQUEST_PROCESSING_LATENCY,
            network_id,
            request.get_label(),
        );

        // Process the request
        let response = match &request {
            PeerMonitoringServiceRequest::GetNetworkInformation => self.get_network_information(),
            PeerMonitoringServiceRequest::GetServerProtocolVersion => {
                self.get_server_protocol_version()
            },
            PeerMonitoringServiceRequest::GetNodeInformation => self.get_node_information(),
            PeerMonitoringServiceRequest::LatencyPing(request) => self.handle_latency_ping(request),
        };

```

**File:** peer-monitoring-service/server/src/lib.rs (L217-248)
```rust
    fn get_network_information(&self) -> Result<PeerMonitoringServiceResponse, Error> {
        // Get the connected peers
        let connected_peers_and_metadata =
            self.peers_and_metadata.get_connected_peers_and_metadata()?;
        let connected_peers = connected_peers_and_metadata
            .into_iter()
            .map(|(peer, metadata)| {
                let connection_metadata = metadata.get_connection_metadata();
                (
                    peer,
                    ConnectionMetadata::new(
                        connection_metadata.addr,
                        connection_metadata.remote_peer_id,
                        connection_metadata.role,
                    ),
                )
            })
            .collect();

        // Get the distance from the validators
        let distance_from_validators =
            get_distance_from_validators(&self.base_config, self.peers_and_metadata.clone());

        // Create and return the response
        let network_information_response = NetworkInformationResponse {
            connected_peers,
            distance_from_validators,
        };
        Ok(PeerMonitoringServiceResponse::NetworkInformation(
            network_information_response,
        ))
    }
```

**File:** network/framework/src/application/storage.rs (L108-125)
```rust
    pub fn get_connected_peers_and_metadata(
        &self,
    ) -> Result<HashMap<PeerNetworkId, PeerMetadata>, Error> {
        // Get the cached peers and metadata
        let cached_peers_and_metadata = self.cached_peers_and_metadata.load();

        // Collect all connected peers
        let mut connected_peers_and_metadata = HashMap::new();
        for (network_id, peers_and_metadata) in cached_peers_and_metadata.iter() {
            for (peer_id, peer_metadata) in peers_and_metadata.iter() {
                if peer_metadata.is_connected() {
                    let peer_network_id = PeerNetworkId::new(*network_id, *peer_id);
                    connected_peers_and_metadata.insert(peer_network_id, peer_metadata.clone());
                }
            }
        }
        Ok(connected_peers_and_metadata)
    }
```

**File:** peer-monitoring-service/types/src/response.rs (L50-75)
```rust
/// A response for the network information request
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
pub struct NetworkInformationResponse {
    pub connected_peers: BTreeMap<PeerNetworkId, ConnectionMetadata>, // Connected peers
    pub distance_from_validators: u64, // The distance of the peer from the validator set
}

// Display formatting provides a high-level summary of the response
impl Display for NetworkInformationResponse {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "{{ num_connected_peers: {:?}, distance_from_validators: {:?} }}",
            self.connected_peers.len(),
            self.distance_from_validators,
        )
    }
}

/// Simple connection metadata associated with each peer
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
pub struct ConnectionMetadata {
    pub network_address: NetworkAddress,
    pub peer_id: PeerId,
    pub peer_role: PeerRole,
}
```

**File:** peer-monitoring-service/client/src/peer_states/mod.rs (L29-68)
```rust
pub fn refresh_peer_states(
    monitoring_service_config: &PeerMonitoringServiceConfig,
    peer_monitor_state: PeerMonitorState,
    peer_monitoring_client: PeerMonitoringServiceClient<
        NetworkClient<PeerMonitoringServiceMessage>,
    >,
    connected_peers_and_metadata: HashMap<PeerNetworkId, PeerMetadata>,
    time_service: TimeService,
    runtime: Option<Handle>,
) -> Result<(), Error> {
    // Process all state entries (in order) and update the ones that
    // need to be refreshed for each peer.
    for peer_state_key in PeerStateKey::get_all_keys() {
        let mut num_in_flight_requests = 0;

        // Go through all connected peers and see if we should refresh the state
        for (peer_network_id, peer_metadata) in &connected_peers_and_metadata {
            // Get the peer state
            let peer_state = get_peer_state(&peer_monitor_state, peer_network_id)?;

            // If there's an-flight request, update the metrics counter
            let request_tracker = peer_state.get_request_tracker(&peer_state_key)?;
            if request_tracker.read().in_flight_request() {
                num_in_flight_requests += 1;
            }

            // Update the state if it needs to be refreshed
            let should_refresh_peer_state_key = request_tracker.read().new_request_required();
            if should_refresh_peer_state_key {
                peer_state.refresh_peer_state_key(
                    monitoring_service_config,
                    &peer_state_key,
                    peer_monitoring_client.clone(),
                    *peer_network_id,
                    peer_metadata.clone(),
                    peer_monitor_state.request_id_generator.clone(),
                    time_service.clone(),
                    runtime.clone(),
                )?;
            }
```
