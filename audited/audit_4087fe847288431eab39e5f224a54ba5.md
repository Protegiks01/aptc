# Audit Report

## Title
HashMap Collision Vulnerability in ValidatorVerifier Allows Voting Power Loss When Duplicate Validator Addresses Exist

## Summary
The `build_index()` function in `ValidatorVerifier` constructs an address-to-index mapping using HashMap collection, which silently overwrites entries when duplicate addresses exist in `validator_infos`. This causes validators with colliding addresses to become unreachable for voting power lookups and signature verification, potentially breaking quorum calculations and consensus safety. [1](#0-0) 

## Finding Description

The vulnerability exists in the validator index construction logic. When converting validator information into a lookup map, the code uses Rust's Iterator `.collect()` method to build a HashMap from `(address, index)` tuples. [2](#0-1) 

**Rust HashMap Behavior:** When collecting into a HashMap with duplicate keys, Rust silently overwrites earlier entries with later ones. If `validator_infos` contains two validators at indices 3 and 7 both with address `A`, only the mapping `(A, 7)` will exist in `address_to_validator_index`, making validator at index 3 completely unreachable.

**Impact on Critical Operations:**

1. **Voting Power Lookup:** The `get_voting_power()` method relies solely on `address_to_validator_index` to find validators. If an address collision exists, only one validator's power is accessible. [3](#0-2) 

2. **Signature Aggregation:** When aggregating signatures by address, the system uses `address_to_validator_index` to determine which validator signed, causing misattribution. [4](#0-3) 

3. **Quorum Verification:** The `sum_voting_power()` function iterates over author addresses and looks them up individually, missing overwritten validators. [5](#0-4) 

**Consensus Protocol Impact:**

During vote processing, when validators submit votes, the system checks voting power using address lookups: [6](#0-5) 

Vote signatures are aggregated in a BTreeMap keyed by address, so duplicate addresses result in only one signature being recorded: [7](#0-6) 

When checking if quorum is reached, the system iterates over collected addresses and sums voting power: [8](#0-7) 

**Breach of Invariant:** This violates the "Governance Integrity" invariant: "Voting power must be correctly calculated from stake." If duplicate addresses exist, voting power calculations become incorrect, potentially allowing:
- Quorum to appear unreached when sufficient validators have actually voted
- Incorrect validator attribution in signature verification
- Loss of validator participation despite valid votes

**Precondition Analysis:**

The Move staking code attempts to prevent duplicate addresses through state checks: [9](#0-8) 

However, the Rust code lacks defensive validation. The `From<&ValidatorSet>` conversion validates duplicate **indices** but not duplicate **addresses**: [10](#0-9) 

During epoch transitions, validators are appended without explicit duplicate checking: [11](#0-10) 

## Impact Explanation

**Severity: High**

This qualifies as High severity under "Significant protocol violations" because:

1. **Consensus Integrity Risk:** Incorrect quorum calculations could allow blocks to be committed without true supermajority consensus, or prevent valid consensus from being reached
2. **Voting Power Manipulation:** Validators' voting power becomes misrepresented, breaking the fundamental security assumption of weighted voting
3. **Partial System Failure:** Affected validators effectively lose their ability to participate in consensus despite having valid stake

While this requires the precondition of duplicate addresses existing (which SHOULD be prevented by Move code), the Rust layer's lack of defensive validation means any logic bug in the staking system would propagate directly into consensus failures. The total absence of address uniqueness validation in the critical consensus path violates defense-in-depth principles.

## Likelihood Explanation

**Likelihood: Low-Medium**

The likelihood depends on whether duplicate addresses can realistically appear:

- **Low:** The Move staking code has checks to prevent same-address validators from joining
- **Medium:** Complex epoch transition logic, lack of runtime uniqueness validation, and the append operation without duplicate checks create potential for logic errors
- **No runtime enforcement:** The formal verification invariant assumes uniqueness but doesn't enforce it [12](#0-11) 

The Rust code assumes Move code correctness without validation, creating a fragile trust boundary. Any future refactoring or logic bug in the staking system could inadvertently introduce duplicates.

## Recommendation

Add explicit validation in `build_index()` or the `From<&ValidatorSet>` conversion to detect and reject duplicate addresses:

```rust
fn build_index(
    validator_infos: Vec<ValidatorConsensusInfo>,
    quorum_voting_power: u128,
    total_voting_power: u128,
) -> Self {
    let mut address_to_validator_index = HashMap::new();
    for (index, info) in validator_infos.iter().enumerate() {
        if let Some(existing_index) = address_to_validator_index.insert(info.address, index) {
            panic!(
                "Duplicate validator address detected: {} at indices {} and {}",
                info.address, existing_index, index
            );
        }
    }
    
    // Verify the count matches to catch silent overwrites
    assert_eq!(
        address_to_validator_index.len(),
        validator_infos.len(),
        "Validator address collision detected: {} unique addresses for {} validators",
        address_to_validator_index.len(),
        validator_infos.len()
    );
    
    Self {
        validator_infos,
        quorum_voting_power,
        total_voting_power,
        address_to_validator_index,
        pessimistic_verify_set: DashSet::new(),
        optimistic_sig_verification: false,
    }
}
```

Alternatively, add validation in the `From<&ValidatorSet>` implementation after line 578 to verify address uniqueness before constructing the ValidatorVerifier.

## Proof of Concept

```rust
#[test]
fn test_duplicate_address_collision() {
    use aptos_crypto::bls12381::PrivateKey;
    use aptos_types::validator_verifier::{ValidatorConsensusInfo, ValidatorVerifier};
    use aptos_types::account_address::AccountAddress;
    
    // Create two validators with the SAME address but different public keys
    let duplicate_address = AccountAddress::random();
    let pk1 = PrivateKey::generate_for_testing().public_key();
    let pk2 = PrivateKey::generate_for_testing().public_key();
    
    let validator_infos = vec![
        ValidatorConsensusInfo::new(duplicate_address, pk1, 100),
        ValidatorConsensusInfo::new(AccountAddress::random(), PrivateKey::generate_for_testing().public_key(), 50),
        ValidatorConsensusInfo::new(duplicate_address, pk2, 200), // DUPLICATE ADDRESS
    ];
    
    let verifier = ValidatorVerifier::new(validator_infos.clone());
    
    // BUG: address_to_validator_index only has 2 entries instead of 3
    assert_eq!(verifier.address_to_validator_index().len(), 2); // Should be 3!
    
    // BUG: First validator (index 0, power 100) is unreachable
    let voting_power = verifier.get_voting_power(&duplicate_address);
    assert_eq!(voting_power, Some(200)); // Returns validator at index 2, not index 0!
    
    // BUG: Total voting power is calculated correctly (350)...
    assert_eq!(verifier.total_voting_power(), 350);
    
    // ...but when checking quorum by address, we only count 250 (missing index 0)
    let addresses = vec![duplicate_address, validator_infos[1].address];
    let summed_power = verifier.sum_voting_power(addresses.iter()).unwrap();
    assert_eq!(summed_power, 250); // Should be 350!
    
    // This breaks quorum calculations!
}
```

## Notes

This vulnerability demonstrates a defensive programming failure at the Rust/Move boundary. While the Move code attempts to maintain address uniqueness invariants, the Rust consensus layer blindly trusts this assumption without validation. The HashMap's silent overwrite behavior, combined with the lack of explicit duplicate checking, creates a fragile trust boundary that could fail catastrophically if any logic bug in the staking system allows duplicate addresses to propagate into the validator set.

### Citations

**File:** types/src/validator_verifier.rs (L184-202)
```rust
    fn build_index(
        validator_infos: Vec<ValidatorConsensusInfo>,
        quorum_voting_power: u128,
        total_voting_power: u128,
    ) -> Self {
        let address_to_validator_index = validator_infos
            .iter()
            .enumerate()
            .map(|(index, info)| (info.address, index))
            .collect();
        Self {
            validator_infos,
            quorum_voting_power,
            total_voting_power,
            address_to_validator_index,
            pessimistic_verify_set: DashSet::new(),
            optimistic_sig_verification: false,
        }
    }
```

**File:** types/src/validator_verifier.rs (L323-327)
```rust
            let index = *self
                .address_to_validator_index
                .get(addr)
                .ok_or(VerifyError::UnknownAuthor)?;
            masks.set(index as u16);
```

**File:** types/src/validator_verifier.rs (L436-448)
```rust
    pub fn sum_voting_power<'a>(
        &self,
        authors: impl Iterator<Item = &'a AccountAddress>,
    ) -> std::result::Result<u128, VerifyError> {
        let mut aggregated_voting_power = 0;
        for account_address in authors {
            match self.get_voting_power(account_address) {
                Some(voting_power) => aggregated_voting_power += voting_power as u128,
                None => return Err(VerifyError::UnknownAuthor),
            }
        }
        Ok(aggregated_voting_power)
    }
```

**File:** types/src/validator_verifier.rs (L503-507)
```rust
    pub fn get_voting_power(&self, author: &AccountAddress) -> Option<u64> {
        self.address_to_validator_index
            .get(author)
            .map(|index| self.validator_infos[*index].voting_power)
    }
```

**File:** types/src/validator_verifier.rs (L579-584)
```rust
        for info in validator_set.payload() {
            assert_eq!(
                validator_infos[info.config().validator_index as usize].address,
                info.account_address
            );
        }
```

**File:** consensus/src/pending_votes.rs (L331-336)
```rust
        let validator_voting_power = validator_verifier.get_voting_power(&vote.author());

        if validator_voting_power.is_none() {
            warn!("Received vote from an unknown author: {}", vote.author());
            return VoteReceptionResult::UnknownAuthor(vote.author());
        }
```

**File:** types/src/ledger_info.rs (L460-462)
```rust
    pub fn add_signature(&mut self, validator: AccountAddress, signature: &SignatureWithStatus) {
        self.signatures.insert(validator, signature.clone());
    }
```

**File:** types/src/ledger_info.rs (L488-495)
```rust
    pub fn check_voting_power(
        &self,
        verifier: &ValidatorVerifier,
        check_super_majority: bool,
    ) -> std::result::Result<u128, VerifyError> {
        let all_voters = self.all_voters();
        verifier.check_voting_power(all_voters, check_super_majority)
    }
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1067-1070)
```text
        assert!(
            get_validator_state(pool_address) == VALIDATOR_STATUS_INACTIVE,
            error::invalid_state(EALREADY_ACTIVE_VALIDATOR),
        );
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1364-1364)
```text
        append(&mut validator_set.active_validators, &mut validator_set.pending_active);
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1824-1826)
```text
            spec {
                invariant !(exists j in 0..i: v[j].addr == addr);
            };
```
