# Audit Report

## Title
Division-by-Zero Panic in Leader Election Causes Total Network Liveness Failure

## Summary
The `choose_index()` function in the consensus leader election mechanism performs a modulo operation that panics when all stake weights sum to zero. A malicious governance proposal can set all reputation weights (`active_weight`, `inactive_weight`, `failed_weight`) to zero, causing all consensus validators to crash simultaneously during leader election, resulting in total network liveness failure requiring a hard fork to recover.

## Finding Description

The vulnerability exists in the weighted random selection logic used for consensus leader election. The attack path involves manipulating the on-chain consensus configuration through governance to trigger a division-by-zero panic:

**Step 1: Vulnerable Code Path**

The `get_valid_proposer_and_voting_power_participation_ratio()` function computes stake weights by multiplying reputation weights with voting powers: [1](#0-0) 

These stake weights are then passed to `choose_index()`: [2](#0-1) 

**Step 2: Division-by-Zero in choose_index()**

The `choose_index()` function accumulates weights into `total_weight` and then calls `next_in_range()`: [3](#0-2) 

When `total_weight = 0`, the `next_in_range()` function performs a modulo by zero, which **panics**: [4](#0-3) 

The expression `u128::from_le_bytes(temp) % max` at line 45 will panic when `max = 0` (Rust's modulo operator panics on division by zero).

**Step 3: Attack Vector via Governance**

The reputation weights are configurable through on-chain governance in `ProposerAndVoterConfig`: [5](#0-4) 

Default values are non-zero: [6](#0-5) 

However, **there is no validation preventing all weights from being set to zero**. The weights are passed directly to `ProposerAndVoterHeuristic`: [7](#0-6) 

**Step 4: Attack Execution**

1. Attacker submits a governance proposal to modify the `ConsensusConfig`
2. Sets `active_weight = 0`, `inactive_weight = 0`, `failed_weight = 0`
3. Proposal passes with required voting power (50% of total stake)
4. Configuration takes effect in the next epoch
5. When any validator calls `get_valid_proposer_and_voting_power_participation_ratio()`:
   - All validators receive weight 0 from the heuristic
   - Even with non-zero `voting_powers`, `stake_weights = 0 × voting_power = 0`
   - `total_weight` sums to 0
   - `choose_index()` panics with division by zero
6. **All consensus validators crash simultaneously**
7. Network experiences complete liveness failure
8. Recovery requires hard fork or emergency intervention

The vulnerability breaks the **liveness invariant**: the network must maintain availability and continue producing blocks.

## Impact Explanation

This vulnerability qualifies as **Critical Severity** under the Aptos Bug Bounty program for the following reasons:

1. **Total loss of liveness/network availability**: All consensus validators crash simultaneously and deterministically when attempting leader election, causing complete network halt.

2. **Non-recoverable network partition (requires hardfork)**: Since the malicious configuration is on-chain, all validators will continue to crash upon restart until the configuration is manually corrected through a hard fork.

3. **Deterministic failure**: Unlike race conditions or timing attacks, this failure is guaranteed once the malicious configuration is activated. Every validator will crash at the same round when leader election occurs.

4. **Network-wide impact**: Affects 100% of validators, not just a subset. The entire consensus mechanism becomes inoperable.

5. **Requires emergency intervention**: The only recovery path is:
   - Hard fork to reset the configuration
   - Manual coordination among validator operators
   - Potential rollback of blockchain state

This meets the Critical severity threshold of "up to $1,000,000" as defined in the bug bounty program for total network liveness failure.

## Likelihood Explanation

**Likelihood: Medium to High**

The attack is realistic and feasible:

**Attacker Requirements:**
- Control or influence 50% of governance voting power (or coordinate with other token holders)
- Technical knowledge to craft the malicious governance proposal
- Understanding of the consensus configuration structure

**Feasibility:**
- Governance is a documented attack surface
- No technical complexity beyond standard governance proposal submission
- No need for validator access or privileged roles
- The proposal would appear as a "consensus optimization" change
- May not be immediately obvious to voters that all-zero weights cause a crash

**Barriers:**
- Requires governance proposal approval (50% voting power)
- Transparent process (voters can inspect proposal)
- Some level of coordination needed

**Why this could happen:**
1. **Social engineering**: Attacker could frame the proposal as a "performance optimization" or "equalizing validator selection"
2. **Voter apathy**: Many governance participants may not thoroughly review technical changes
3. **Insider threat**: A compromised or malicious entity with significant stake could push this through
4. **Configuration error**: Could even occur accidentally if someone mistakenly sets weights to zero during testing/development

The combination of realistic attack requirements and catastrophic impact makes this a serious vulnerability despite the governance barrier.

## Recommendation

**Immediate Fix: Add validation to prevent zero weights**

Add validation in the `ProposerAndVoterHeuristic::new()` constructor:

```rust
pub fn new(
    author: Author,
    active_weight: u64,
    inactive_weight: u64,
    failed_weight: u64,
    failure_threshold_percent: u32,
    voter_window_size: usize,
    proposer_window_size: usize,
    reputation_window_from_stale_end: bool,
) -> Self {
    // Validation: Ensure at least one weight is non-zero to prevent division by zero
    assert!(
        active_weight > 0 || inactive_weight > 0 || failed_weight > 0,
        "At least one reputation weight must be greater than zero"
    );
    
    Self {
        author,
        active_weight,
        inactive_weight,
        failed_weight,
        failure_threshold_percent,
        aggregation: NewBlockEventAggregation::new(
            voter_window_size,
            proposer_window_size,
            reputation_window_from_stale_end,
        ),
    }
}
```

**Additional Defense: Validate in choose_index()**

Add a safety check in `choose_index()` to handle empty or zero-weight vectors gracefully:

```rust
pub(crate) fn choose_index(mut weights: Vec<u128>, state: Vec<u8>) -> usize {
    assert!(!weights.is_empty(), "Weights vector cannot be empty");
    
    let mut total_weight = 0;
    for w in &mut weights {
        total_weight = total_weight
            .checked_add(w)
            .expect("Total stake shouldn't exceed u128::MAX");
        *w = total_weight;
    }
    
    assert!(total_weight > 0, "Total weight must be greater than zero");
    
    let chosen_weight = next_in_range(state, total_weight);
    weights
        .binary_search_by(|w| {
            if *w <= chosen_weight {
                Ordering::Less
            } else {
                Ordering::Greater
            }
        })
        .expect_err("Comparison never returns equals, so it's always guaranteed to be error")
}
```

**Governance-Level Fix: Add on-chain validation**

Add validation in the Move-side consensus configuration to reject configs with all-zero weights before they can be applied.

## Proof of Concept

```rust
#[cfg(test)]
mod test_zero_weight_panic {
    use super::*;
    use aptos_types::account_address::AccountAddress;
    
    #[test]
    #[should_panic(expected = "attempt to calculate the remainder with a divisor of zero")]
    fn test_choose_index_panics_with_zero_total_weight() {
        // Simulate scenario where all stake weights are zero
        let weights = vec![0u128, 0u128, 0u128, 0u128];
        let state = vec![1, 2, 3, 4];
        
        // This should panic with division by zero in next_in_range()
        let _ = choose_index(weights, state);
    }
    
    #[test]
    #[should_panic(expected = "attempt to calculate the remainder with a divisor of zero")]
    fn test_zero_weights_from_config() {
        // Simulate ProposerAndVoterHeuristic with all zero weights
        let author = AccountAddress::random();
        let active_weight = 0u64;
        let inactive_weight = 0u64;
        let failed_weight = 0u64;
        
        let heuristic = ProposerAndVoterHeuristic::new(
            author,
            active_weight,
            inactive_weight,
            failed_weight,
            10, // failure_threshold_percent
            100, // voter_window_size
            1000, // proposer_window_size
            false,
        );
        
        // Even if validators have non-zero voting power,
        // weights will all be 0 because:
        // stake_weight = heuristic_weight (0) × voting_power (>0) = 0
        let mut weights = vec![100u64, 200u64, 300u64]; // voting powers
        
        // Simulate heuristic returning all zeros
        let heuristic_weights = vec![0u64, 0u64, 0u64];
        
        let stake_weights: Vec<u128> = weights
            .iter_mut()
            .enumerate()
            .map(|(i, vp)| heuristic_weights[i] as u128 * (*vp as u128))
            .collect();
        
        // All stake_weights are 0, this will panic
        let state = vec![1, 2, 3, 4];
        let _ = choose_index(stake_weights, state);
    }
}
```

**Notes**

This vulnerability represents a critical failure in the consensus layer's leader election mechanism. The lack of input validation on reputation weights allows a malicious or compromised governance process to trigger a network-wide crash. The deterministic nature of the failure means that all validators will crash simultaneously and repeatedly, making this a severe availability attack.

The recommended fixes provide defense-in-depth:
1. Constructor-level validation prevents invalid configurations from being created
2. Runtime validation in `choose_index()` provides a safety net against any path that could produce zero weights
3. On-chain validation prevents malicious governance proposals from being enacted

Priority should be given to implementing all three layers of validation to ensure robust protection against this attack vector.

### Citations

**File:** consensus/src/liveness/leader_reputation.rs (L710-715)
```rust
        // Multiply weights by voting power:
        let stake_weights: Vec<u128> = weights
            .iter_mut()
            .enumerate()
            .map(|(i, w)| *w as u128 * self.voting_powers[i] as u128)
            .collect();
```

**File:** consensus/src/liveness/leader_reputation.rs (L732-733)
```rust
        let chosen_index = choose_index(stake_weights, state);
        (proposers[chosen_index], voting_power_participation_ratio)
```

**File:** consensus/src/liveness/proposer_election.rs (L38-46)
```rust
// next consumes seed and returns random deterministic u64 value in [0, max) range
fn next_in_range(state: Vec<u8>, max: u128) -> u128 {
    // hash = SHA-3-256(state)
    let hash = aptos_crypto::HashValue::sha3_256_of(&state).to_vec();
    let mut temp = [0u8; 16];
    copy_slice_to_vec(&hash[..16], &mut temp).expect("next failed");
    // return hash[0..16]
    u128::from_le_bytes(temp) % max
}
```

**File:** consensus/src/liveness/proposer_election.rs (L49-59)
```rust
pub(crate) fn choose_index(mut weights: Vec<u128>, state: Vec<u8>) -> usize {
    let mut total_weight = 0;
    // Create cumulative weights vector
    // Since we own the vector, we can safely modify it in place
    for w in &mut weights {
        total_weight = total_weight
            .checked_add(w)
            .expect("Total stake shouldn't exceed u128::MAX");
        *w = total_weight;
    }
    let chosen_weight = next_in_range(state, total_weight);
```

**File:** types/src/on_chain_config/consensus_config.rs (L489-493)
```rust
                LeaderReputationType::ProposerAndVoterV2(ProposerAndVoterConfig {
                    active_weight: 1000,
                    inactive_weight: 10,
                    failed_weight: 1,
                    failure_threshold_percent: 10, // = 10%
```

**File:** types/src/on_chain_config/consensus_config.rs (L552-560)
```rust
#[derive(Clone, Copy, Debug, Deserialize, Eq, PartialEq, Serialize)]
pub struct ProposerAndVoterConfig {
    // Selection weight for active validators with proposer failures below threshold
    pub active_weight: u64,
    // Selection weight for inactive validators with proposer failures below threshold
    pub inactive_weight: u64,
    // Selection weight for validators with proposer failures above threshold
    pub failed_weight: u64,
    // Thresholed of failures in the rounds validator was selected to be proposer
```

**File:** consensus/src/epoch_manager.rs (L318-328)
```rust
                        let heuristic: Box<dyn ReputationHeuristic> =
                            Box::new(ProposerAndVoterHeuristic::new(
                                self.author,
                                proposer_and_voter_config.active_weight,
                                proposer_and_voter_config.inactive_weight,
                                proposer_and_voter_config.failed_weight,
                                proposer_and_voter_config.failure_threshold_percent,
                                voter_window_size,
                                proposer_window_size,
                                leader_reputation_type.use_reputation_window_from_stale_end(),
                            ));
```
