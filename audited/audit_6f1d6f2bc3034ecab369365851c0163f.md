# Audit Report

## Title
Lack of Validation on Transaction and Gas Limits Enables Execution Engine Failures and Gas Limit Bypass

## Summary
The `get_transactions()` method in payload managers returns transaction and gas limit values that lack any validation before being used by the execution engine. These unchecked values can cause execution engine failures if set too low, bypass gas limits if set too high, or create liveness issues if set to zero.

## Finding Description

The `TPayloadManager::get_transactions()` trait method returns a tuple containing transaction limit and gas limit as `Option<u64>` values: [1](#0-0) 

These limits flow through three distinct implementations:

1. **DirectMempoolPayloadManager** always returns `None` for both limits: [2](#0-1) 

2. **QuorumStorePayloadManager** extracts limits from the payload and returns them to the execution pipeline: [3](#0-2) 

3. **ConsensusObserverPayloadManager** returns limits from stored payload data: [4](#0-3) 

The **transaction_limit** is used to truncate the transaction list without validation: [5](#0-4) 

The **gas_limit** is applied as a block gas limit override through the configuration: [6](#0-5) 

The configuration builder accepts ANY value without validation: [7](#0-6) 

When `enable_per_block_gas_limit` is true, the override is used directly by the block executor: [8](#0-7) 

The `BlockGasLimitProcessor` prioritizes the override value without any bounds checking: [9](#0-8) 

**Critical Issue**: There is a TODO comment explicitly noting that gas limit verification is missing: [10](#0-9) 

**Vulnerability Path:**

1. Proposer calculates limits via backpressure mechanism or they're embedded in the payload
2. Limits are returned by `get_transactions()` without validation
3. `transaction_limit` truncates transaction list (could be 0)
4. `gas_limit` overrides on-chain limit when `enable_per_block_gas_limit = true` (could be 0, 1, or u64::MAX)
5. Execution proceeds with invalid limits

**Broken Invariant:** Invariant #9 - "Resource Limits: All operations must respect gas, storage, and computational limits"

## Impact Explanation

**Critical Severity** - This vulnerability enables multiple attack vectors:

1. **Execution Engine Failure**: If `gas_limit = Some(0)` or `Some(1)`, the block gas limit processor will halt execution immediately after the metadata transaction, causing all validators to fail block execution and potentially creating a liveness failure.

2. **Gas Limit Bypass**: If `gas_limit = Some(u64::MAX)`, effective gas limits are bypassed, allowing unlimited computation and violating the resource limits invariant. This could enable resource exhaustion attacks.

3. **Transaction Censorship**: If `transaction_limit = Some(0)`, all user transactions are excluded from the block, causing liveness degradation and preventing transaction processing.

4. **Deterministic Execution Violation**: Extreme limit values could cause execution to halt at different points depending on system state, potentially breaking deterministic execution across validators.

Per Aptos bug bounty criteria, this qualifies as **Critical Severity** because it can cause:
- Consensus/Safety violations (different execution outcomes)
- Total loss of liveness/network availability (if limits are too restrictive)
- Significant protocol violations (bypassing gas limits)

## Likelihood Explanation

**Medium to High Likelihood:**

While this requires the proposer to include specific limit values in the payload, several scenarios make this exploitable:

1. **Implementation Bugs**: The backpressure calculation logic is complex and could produce edge-case values (0, overflow to MAX) under specific conditions.

2. **Configuration Errors**: The `enable_per_block_gas_limit` flag could be enabled without proper testing, exposing the system to unvalidated overrides.

3. **Upgrade Scenarios**: During protocol upgrades that modify limit calculation logic, bugs could introduce invalid values.

4. **No Defense in Depth**: The complete absence of validation means any bug in the proposer's limit calculation logic directly impacts all validators deterministically.

The lack of any bounds checking makes this a systemic vulnerability rather than requiring specific malicious intent.

## Recommendation

Add validation for both `transaction_limit` and `gas_limit` before using them:

```rust
// In types/src/block_executor/config.rs
pub fn with_block_gas_limit_override(self, block_gas_limit_override: Option<u64>) -> Self {
    // Validate gas limit override
    let validated_override = block_gas_limit_override.and_then(|limit| {
        // Reject unreasonably low limits (below minimum for metadata transaction)
        const MIN_BLOCK_GAS_LIMIT: u64 = 1000;
        // Reject limits exceeding the on-chain maximum
        let max_allowed = self.block_gas_limit_type.block_gas_limit()
            .unwrap_or(u64::MAX);
        
        if limit < MIN_BLOCK_GAS_LIMIT {
            warn!("Block gas limit override {} is below minimum {}, ignoring", 
                  limit, MIN_BLOCK_GAS_LIMIT);
            None
        } else if limit > max_allowed {
            warn!("Block gas limit override {} exceeds maximum {}, capping", 
                  limit, max_allowed);
            Some(max_allowed)
        } else {
            Some(limit)
        }
    });
    
    Self {
        block_gas_limit_type: self.block_gas_limit_type,
        enable_per_block_gas_limit: self.enable_per_block_gas_limit,
        per_block_gas_limit: validated_override,
        gas_price_to_burn: self.gas_price_to_burn,
    }
}
```

```rust
// In consensus/src/block_preparer.rs
pub async fn prepare_block(
    &self,
    block: &Block,
    txns: Vec<SignedTransaction>,
    max_txns_from_block_to_execute: Option<u64>,
    block_gas_limit: Option<u64>,
) -> (Vec<SignedTransaction>, Option<u64>) {
    // ... existing code ...
    
    // Validate transaction limit
    let validated_limit = max_txns_from_block_to_execute.and_then(|limit| {
        const MIN_TXNS_LIMIT: u64 = 1; // Allow at least one transaction
        if limit < MIN_TXNS_LIMIT {
            warn!("Transaction limit {} is below minimum {}, using minimum", 
                  limit, MIN_TXNS_LIMIT);
            Some(MIN_TXNS_LIMIT)
        } else {
            Some(limit)
        }
    });
    
    if let Some(limit) = validated_limit {
        shuffled_txns.truncate(limit as usize);
    }
    // ... rest of code ...
}
```

Additionally, implement the TODO to verify block gas limits in consensus observer message validation: [11](#0-10) 

## Proof of Concept

```rust
#[cfg(test)]
mod test_invalid_limits {
    use super::*;
    use aptos_types::block_executor::config::BlockExecutorConfigFromOnchain;
    use aptos_types::on_chain_config::BlockGasLimitType;
    
    #[test]
    fn test_zero_gas_limit_causes_immediate_halt() {
        // Simulate a block with gas_limit = 0
        let config = BlockExecutorConfigFromOnchain::new(
            BlockGasLimitType::Limit(10000),
            true, // enable_per_block_gas_limit
            None,
        );
        
        // Apply zero gas limit override
        let config_with_override = config.with_block_gas_limit_override(Some(0));
        
        // This returns 0, causing execution to halt immediately
        assert_eq!(config_with_override.block_gas_limit_override(), Some(0));
        
        // When BlockGasLimitProcessor is created with this config,
        // should_end_block will return true immediately, halting execution
    }
    
    #[test]
    fn test_max_gas_limit_bypasses_limits() {
        let config = BlockExecutorConfigFromOnchain::new(
            BlockGasLimitType::Limit(10000),
            true,
            None,
        );
        
        // Apply maximum gas limit override
        let config_with_override = config.with_block_gas_limit_override(Some(u64::MAX));
        
        // This returns MAX, effectively disabling gas limits
        assert_eq!(config_with_override.block_gas_limit_override(), Some(u64::MAX));
    }
    
    #[test]
    fn test_zero_transaction_limit_excludes_all_txns() {
        // Simulate transaction_limit = 0 in prepare_block
        let txns = vec![/* some transactions */];
        let max_txns = Some(0u64);
        
        let mut result = txns.clone();
        if let Some(limit) = max_txns {
            result.truncate(limit as usize);
        }
        
        // All transactions excluded
        assert_eq!(result.len(), 0);
    }
}
```

## Notes

This vulnerability exists because the system trusts limit values from the payload without validation. While the proposer is a validator (trusted role), defense-in-depth principles require validating all inputs, especially those that directly affect critical system invariants like resource limits. The complete absence of bounds checking creates a single point of failure where any bug in limit calculation logic can cause network-wide execution failures or security bypasses.

### Citations

**File:** consensus/src/payload_manager/mod.rs (L51-55)
```rust
    async fn get_transactions(
        &self,
        block: &Block,
        block_voters: Option<BitVec>,
    ) -> ExecutorResult<(Vec<SignedTransaction>, Option<u64>, Option<u64>)>;
```

**File:** consensus/src/payload_manager/direct_mempool_payload_manager.rs (L86-102)
```rust
fn get_transactions_from_block(
    block: &Block,
) -> ExecutorResult<(Vec<SignedTransaction>, Option<u64>, Option<u64>)> {
    let Some(payload) = block.payload() else {
        return Ok((Vec::new(), None, None));
    };

    match payload {
        Payload::DirectMempool(txns) => Ok((txns.clone(), None, None)),
        _ => unreachable!(
            "DirectMempoolPayloadManager: Unacceptable payload type {}. Epoch: {}, Round: {}, Block: {}",
            payload,
            block.block_data().epoch(),
            block.block_data().round(),
            block.id()
        ),
    }
```

**File:** consensus/src/payload_manager/quorum_store_payload_manager.rs (L559-563)
```rust
        Ok((
            transaction_payload.transactions(),
            transaction_payload.transaction_limit(),
            transaction_payload.gas_limit(),
        ))
```

**File:** consensus/src/payload_manager/co_payload_manager.rs (L71-75)
```rust
    Ok((
        transaction_payload.transactions(),
        transaction_payload.transaction_limit(),
        transaction_payload.gas_limit(),
    ))
```

**File:** consensus/src/block_preparer.rs (L106-108)
```rust
            if let Some(max_txns_from_block_to_execute) = max_txns_from_block_to_execute {
                shuffled_txns.truncate(max_txns_from_block_to_execute as usize);
            }
```

**File:** consensus/src/pipeline/pipeline_builder.rs (L799-801)
```rust
        let (user_txns, block_gas_limit) = prepare_fut.await?;
        let onchain_execution_config =
            onchain_execution_config.with_block_gas_limit_override(block_gas_limit);
```

**File:** types/src/block_executor/config.rs (L146-153)
```rust
    pub fn with_block_gas_limit_override(self, block_gas_limit_override: Option<u64>) -> Self {
        Self {
            block_gas_limit_type: self.block_gas_limit_type,
            enable_per_block_gas_limit: self.enable_per_block_gas_limit,
            per_block_gas_limit: block_gas_limit_override,
            gas_price_to_burn: self.gas_price_to_burn,
        }
    }
```

**File:** types/src/block_executor/config.rs (L155-161)
```rust
    pub fn block_gas_limit_override(&self) -> Option<u64> {
        if self.enable_per_block_gas_limit {
            self.per_block_gas_limit
        } else {
            None
        }
    }
```

**File:** aptos-move/block-executor/src/limit_processor.rs (L119-125)
```rust
    fn block_gas_limit(&self) -> Option<u64> {
        if self.block_gas_limit_override.is_some() {
            self.block_gas_limit_override
        } else {
            self.block_gas_limit_type.block_gas_limit()
        }
    }
```

**File:** consensus/src/consensus_observer/network/observer_message.rs (L683-697)
```rust
            Payload::QuorumStoreInlineHybridV2(
                inline_batches,
                proof_with_data,
                execution_limits,
            ) => {
                // Verify the batches in the requested block
                self.verify_batches(&proof_with_data.proofs)?;

                // Verify the inline batches
                self.verify_inline_batches(inline_batches)?;

                // Verify the transaction limit
                self.verify_transaction_limit(execution_limits.max_txns_to_execute())?;

                // TODO: verify the block gas limit?
```
