# Audit Report

## Title
Resource Exhaustion via Malformed Encrypted Transactions After Consensus

## Summary
The encrypted transaction validation process only verifies cryptographic signatures and associated data but does not validate that ciphertexts are well-formed and can be successfully decrypted. This allows attackers to submit transactions that pass all pre-consensus validation checks, consume consensus resources, but fail decryption post-consensus without charging gas, enabling a resource exhaustion attack on validator nodes.

## Finding Description

The vulnerability exists in the encrypted transaction validation and execution pipeline. The attack exploits a gap between validation (pre-consensus) and decryption (post-consensus): [1](#0-0) 

The `verify()` method delegates to the ciphertext verification: [2](#0-1) 

This validation only checks:
1. Ciphertext ID matches the hashed verification key
2. Associated data matches what was provided
3. Ed25519 signature over the ciphertext is valid

**Critical Gap:** The validation does NOT verify that the symmetric ciphertext can be successfully decrypted or that the encrypted data is well-formed.

Decryption happens AFTER consensus in the decryption pipeline: [3](#0-2) 

When decryption fails (line 140), the transaction transitions to `FailedDecryption` state but continues processing. During execution, attempting to extract the executable fails: [4](#0-3) 

This error is caught by the VM and the transaction is **discarded without charging gas**: [5](#0-4) [6](#0-5) [7](#0-6) 

**Attack Path:**
1. Attacker creates a valid Ed25519 signing key and associated verification key
2. Encrypts garbage data or crafts malformed symmetric ciphertext that will fail AES-GCM decryption
3. Creates a valid signature over the malformed ciphertext
4. Submits transaction - passes API validation (signature valid, associated data valid)
5. Transaction enters mempool and goes through consensus (all validators process it)
6. After consensus, threshold decryption is attempted with expensive cryptographic operations
7. Symmetric decryption fails due to malformed ciphertext (authentication tag mismatch or deserialization error): [8](#0-7) 

8. Transaction marked as `FailedDecryption`, but **no gas is charged** because it's discarded
9. Attacker can repeat this attack, wasting consensus bandwidth, CPU cycles, and decryption computation without cost

**Current Protection:** The vulnerability is currently mitigated by consensus-level blocking: [9](#0-8) 

And API-level configuration: [10](#0-9) [11](#0-10) 

However, when encrypted transactions are fully enabled, this protection will be removed, exposing the vulnerability.

## Impact Explanation

**Severity: Medium** (up to $10,000 per Aptos bug bounty)

This represents a resource exhaustion attack with the following impacts:
- **Consensus Bandwidth Waste:** Malformed transactions propagate across the entire validator network
- **CPU Exhaustion:** All validators perform expensive threshold decryption operations on garbage data
- **Block Space Consumption:** Malformed transactions occupy block space that could be used for legitimate transactions
- **No Gas Cost:** Attackers pay nothing because transactions are discarded before gas charging

This breaks the **Resource Limits** invariant: "All operations must respect gas, storage, and computational limits." The attack allows unbounded resource consumption without payment.

The impact is limited to Medium severity because:
- It causes validator slowdowns but not total network unavailability
- No funds are lost or stolen
- State remains consistent
- Temporary rather than permanent damage

## Likelihood Explanation

**Current Likelihood: None** - Feature is explicitly disabled at consensus layer and API config defaults to false.

**Future Likelihood: High** - Once encrypted transaction feature is enabled without fixing this validation gap:
- No specialized knowledge required beyond understanding the encryption scheme
- Simple to execute: create malformed ciphertext with valid signature
- No stake or special permissions required
- Can be automated and repeated at scale
- Low cost to attacker (no gas charged)

## Recommendation

Add well-formedness validation to the ciphertext verification process before transactions enter consensus. Specifically:

1. **Add Decryptability Check:** Validate that the ciphertext structure is well-formed and the symmetric ciphertext can be authenticated (without full decryption):
   - Verify ciphertext components are in valid ranges
   - Check that BIBECiphertext structure is properly formed
   - Validate symmetric ciphertext nonce and body are valid sizes

2. **Add Test Decryption:** Optionally, perform a lightweight test decryption during validation using the encryption key (before threshold decryption) to verify the ciphertext is not obviously malformed.

3. **Charge Minimum Gas for Failed Decryption:** Even if decryption fails, charge minimum gas to prevent free resource consumption. Modify the execution flow to charge gas in prologue before attempting decryption.

4. **Rate Limit Encrypted Transactions:** Implement per-sender rate limiting for encrypted transactions to prevent spam.

## Proof of Concept

```rust
// Proof of Concept: Create malformed encrypted transaction
use aptos_batch_encryption::shared::ciphertext::Ciphertext;
use ed25519_dalek::{SigningKey, Signature, Signer};
use ark_std::rand::thread_rng;

fn create_malformed_encrypted_transaction() {
    let mut rng = thread_rng();
    
    // Create valid signing key
    let signing_key = SigningKey::generate(&mut rng);
    let vk = signing_key.verifying_key();
    
    // Create malformed BIBE ciphertext with garbage data
    let malformed_bibe_ct = BIBECiphertext {
        id: Id::from_verifying_key(&vk),
        ct_g2: [random_g2_point(), random_g2_point(), random_g2_point()],
        padded_key: random_padded_key(),
        symmetric_ciphertext: SymmetricCiphertext {
            nonce: random_nonce(),
            ct_body: vec![0u8; 32], // Garbage data that will fail AES-GCM auth
        },
    };
    
    // Create valid associated data and signature
    let associated_data = PayloadAssociatedData::new(sender_address);
    let associated_data_bytes = bcs::to_bytes(&associated_data).unwrap();
    let to_sign = (&malformed_bibe_ct, &associated_data_bytes);
    let signature = signing_key.sign(&bcs::to_bytes(&to_sign).unwrap());
    
    // This ciphertext will pass verify() but fail decrypt()
    let ct = Ciphertext {
        vk,
        bibe_ct: malformed_bibe_ct,
        associated_data_bytes,
        signature,
    };
    
    // Verification succeeds
    assert!(ct.verify(&associated_data).is_ok());
    
    // But decryption will fail after consensus when AES-GCM authentication fails
    // Transaction consumes resources but charges no gas
}
```

**Notes**

The vulnerability represents a **latent security flaw** in the encrypted transaction design that will become exploitable when the feature is fully enabled. While currently protected by explicit blocking mechanisms, the validation gap should be closed before removing those protections to prevent resource exhaustion attacks against the validator network.

### Citations

**File:** types/src/transaction/encrypted_payload.rs (L75-80)
```rust
    pub fn executable(&self) -> Result<TransactionExecutable> {
        let Self::Decrypted { executable, .. } = self else {
            bail!("Transaction is encrypted");
        };
        Ok(executable.clone())
    }
```

**File:** types/src/transaction/encrypted_payload.rs (L147-151)
```rust
    pub fn verify(&self, sender: AccountAddress) -> anyhow::Result<()> {
        let associated_data = PayloadAssociatedData::new(sender);
        self.ciphertext().verify(&associated_data)
    }
}
```

**File:** crates/aptos-batch-encryption/src/shared/ciphertext/mod.rs (L111-132)
```rust
    pub fn verify(&self, associated_data: &impl AssociatedData) -> Result<()> {
        let hashed_id = Id::from_verifying_key(&self.vk);

        (self.bibe_ct.id() == hashed_id).then_some(()).ok_or(
            BatchEncryptionError::CTVerifyError(CTVerifyError::IdDoesNotMatchHashedVK),
        )?;
        (self.associated_data_bytes == bcs::to_bytes(associated_data)?)
            .then_some(())
            .ok_or(BatchEncryptionError::CTVerifyError(
                CTVerifyError::AssociatedDataDoesNotMatch,
            ))?;

        let to_verify = (&self.bibe_ct, &self.associated_data_bytes);

        self.vk
            .verify(&bcs::to_bytes(&to_verify)?, &self.signature)
            .map_err(|e| {
                BatchEncryptionError::CTVerifyError(CTVerifyError::SigVerificationFailed(e))
            })?;

        Ok(())
    }
```

**File:** consensus/src/pipeline/decryption_pipeline_builder.rs (L121-148)
```rust
        let decrypted_txns = encrypted_txns
            .into_par_iter()
            .zip(txn_ciphertexts)
            .map(|(mut txn, ciphertext)| {
                let eval_proof = proofs.get(&ciphertext.id()).expect("must exist");
                if let Ok(payload) = FPTXWeighted::decrypt_individual::<DecryptedPayload>(
                    &decryption_key.key,
                    &ciphertext,
                    &digest,
                    &eval_proof,
                ) {
                    let (executable, nonce) = payload.unwrap();
                    txn.payload_mut()
                        .as_encrypted_payload_mut()
                        .map(|p| {
                            p.into_decrypted(eval_proof, executable, nonce)
                                .expect("must happen")
                        })
                        .expect("must exist");
                } else {
                    txn.payload_mut()
                        .as_encrypted_payload_mut()
                        .map(|p| p.into_failed_decryption(eval_proof).expect("must happen"))
                        .expect("must exist");
                }
                txn
            })
            .collect();
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L176-189)
```rust
macro_rules! unwrap_or_discard {
    ($res:expr) => {
        match $res {
            Ok(s) => s,
            Err(e) => {
                // covers both VMStatus itself and VMError which can convert to VMStatus
                let s: VMStatus = e.into();

                let o = discarded_output(s.status_code());
                return (s, o);
            },
        }
    };
}
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L2061-2064)
```rust
        let executable = match txn.executable_ref() {
            Ok(executable) => executable,
            Err(_) => return unwrap_or_discard!(Err(deprecated_module_bundle!())),
        };
```

**File:** aptos-move/aptos-vm/src/errors.rs (L307-309)
```rust
pub(crate) fn discarded_output(status_code: StatusCode) -> VMOutput {
    VMOutput::empty_with_status(TransactionStatus::Discard(status_code))
}
```

**File:** crates/aptos-batch-encryption/src/shared/symmetric.rs (L112-123)
```rust
    pub fn decrypt<P: Plaintext>(&self, ciphertext: &SymmetricCiphertext) -> Result<P> {
        use aes_gcm::KeyInit as _; // putting this in the global scope causes Hmac<Sha256> to be
                                   // ambiguous for some reason

        let key: &Key<SymmetricCipher> = &self.0;
        let cipher = SymmetricCipher::new(key);
        let plaintext_bytes = cipher
            .decrypt(&ciphertext.nonce, ciphertext.ct_body.as_ref())
            .map_err(|_| BatchEncryptionError::SymmetricDecryptionError)?;
        Ok(bcs::from_bytes(&plaintext_bytes)
            .map_err(|_| BatchEncryptionError::DeserializationError)?)
    }
```

**File:** consensus/src/quorum_store/types.rs (L284-287)
```rust
            ensure!(
                !txn.payload().is_encrypted_variant(),
                "Encrypted transaction is not supported yet"
            );
```

**File:** config/src/config/api_config.rs (L91-92)
```rust
    /// Allow submission of encrypted transactions via the API
    pub allow_encrypted_txns_submission: bool,
```

**File:** config/src/config/api_config.rs (L145-145)
```rust
            allow_encrypted_txns_submission: false,
```
