# Audit Report

## Title
Policy Bypass Through OnDiskStorage Backend in Production Validators

## Summary
The secure storage policy system is not consistently enforced across all storage backends. While `VaultStorage` implements proper policy enforcement through `VaultPolicy`, both `InMemoryStorage` and `OnDiskStorage` explicitly provide **no permission checks**. Critical finding: `OnDiskStorage` is allowed for mainnet validators but stores consensus private keys and safety data in plaintext files without any access control enforcement, enabling local privilege escalation attacks.

## Finding Description

The Aptos secure storage system defines a `Policy` framework with `Identity`, `Permission`, and `Capability` types for access control. [1](#0-0) 

However, policy enforcement is backend-specific and inconsistent:

1. **InMemoryStorage** explicitly states: "This provides no permission checks" [2](#0-1) 

2. **OnDiskStorage** explicitly states: "This provides no permission checks" [3](#0-2) 

3. **VaultStorage** implements proper policy enforcement via `VaultPolicy` wrapper [4](#0-3) 

The production configuration sanitizer only blocks `InMemoryStorage` on mainnet validators: [5](#0-4) 

The `is_in_memory()` check only returns `true` for `InMemoryStorage`, meaning **OnDiskStorage is allowed in production**: [6](#0-5) 

The `PersistentSafetyStorage` stores consensus-critical data using the `Storage` abstraction:
- Consensus private keys [7](#0-6) 
- Safety data (epoch, last_voted_round, preferred_round) [8](#0-7) 
- Waypoints for epoch boundaries [9](#0-8) 

The test suite runs functional tests across all backends but **never tests policy enforcement** for InMemory/OnDisk backends: [10](#0-9) 

Policy enforcement tests exist only for VaultStorage: [11](#0-10) 

**Attack Scenario:**

1. Validator operator configures `OnDiskStorage` for safety rules (allowed in production)
2. The storage file is created at the configured path with default filesystem permissions
3. Malicious local process (malware, compromised service, insider threat) reads the file
4. Attacker extracts consensus private key from storage
5. Attacker can:
   - Sign conflicting votes (equivocation) → validator slashing
   - Manipulate safety data → consensus violations
   - Forge consensus messages → chain split attacks

## Impact Explanation

**CRITICAL SEVERITY** - This vulnerability meets multiple Critical impact categories:

1. **Loss of Funds**: Consensus private key theft enables validator impersonation. Attacker can cause equivocation, leading to automatic slashing of the validator's stake (potentially millions of dollars).

2. **Consensus Safety Violations**: Stolen keys allow attacker to forge consensus messages, potentially causing:
   - Double-signing of conflicting blocks
   - Safety rule violations in AptosBFT
   - Chain splits if combined with network partitioning

3. **Non-recoverable Network Impact**: If multiple validators use OnDiskStorage and keys are compromised, coordinated attack could cause consensus failure requiring emergency intervention.

The vulnerability breaks critical invariants:
- **Cryptographic Correctness**: Private keys must be securely stored
- **Access Control**: Only authorized processes should access consensus keys
- **Consensus Safety**: AptosBFT safety depends on key secrecy

## Likelihood Explanation

**HIGH LIKELIHOOD** of occurring in practice:

1. **Configuration Error**: Operators may choose OnDiskStorage for simplicity, not realizing it lacks policy enforcement
2. **Migration Path**: Operators migrating from test environments may use OnDiskStorage configs in production
3. **Documentation Gap**: No clear warning that OnDiskStorage has zero access control
4. **Local Attack Surface**: Many validators run multiple services on the same machine (monitoring, metrics, backup agents)
5. **Filesystem Defaults**: Without explicit `chmod 600`, files may be world-readable

The attacker only needs local process execution on the validator machine - no consensus participation or Byzantine behavior required.

## Recommendation

**Immediate Fixes:**

1. **Block OnDiskStorage in Production**: Extend the config sanitizer to reject OnDiskStorage on mainnet validators, similar to InMemoryStorage: [5](#0-4) 

Update to:
```rust
if chain_id.is_mainnet() && node_type.is_validator() 
    && (safety_rules_config.backend.is_in_memory() 
        || safety_rules_config.backend.is_on_disk()) {
    return Err(Error::ConfigSanitizerFailed(
        sanitizer_name,
        "Only VaultStorage with policy enforcement should be used in mainnet validators!".to_string(),
    ));
}
```

2. **Add Policy Enforcement to OnDiskStorage**: Implement OS-level access controls (file permissions, SELinux contexts) or refuse to operate without proper security.

3. **Unified Policy Testing**: Create cross-backend policy enforcement tests in the test suite to verify all backends respect policies consistently.

4. **Documentation**: Add prominent warnings that only VaultStorage provides policy enforcement.

**Long-term Fix:**

Implement a policy enforcement layer at the `Storage` trait level, not backend-specific, so all backends must enforce policies uniformly.

## Proof of Concept

```rust
// PoC: Demonstrating policy bypass with OnDiskStorage
use aptos_secure_storage::{OnDiskStorage, KVStorage, Storage};
use aptos_crypto::bls12381::PrivateKey;
use std::fs;

fn exploit_ondisk_policy_bypass() {
    // Validator configures OnDiskStorage (allowed in production)
    let storage_path = "/tmp/validator_secure_storage.json";
    let mut storage = Storage::from(OnDiskStorage::new(storage_path.into()));
    
    // Validator stores consensus private key
    let consensus_key = PrivateKey::generate_for_testing();
    storage.set("consensus_key", consensus_key.clone()).unwrap();
    
    // Malicious local process reads the file (NO POLICY CHECK!)
    let file_contents = fs::read_to_string(storage_path).unwrap();
    println!("Stolen storage contents: {}", file_contents);
    
    // Attacker extracts and uses the key
    let stolen_storage = Storage::from(OnDiskStorage::new(storage_path.into()));
    let stolen_key: PrivateKey = stolen_storage.get("consensus_key").unwrap().value;
    
    assert_eq!(consensus_key, stolen_key);
    println!("✗ VULNERABILITY CONFIRMED: Consensus key stolen without any access control!");
}
```

**Exploitation Steps:**
1. Identify validator using OnDiskStorage via leaked config or filesystem reconnaissance
2. Read storage file at configured path (e.g., `/opt/aptos/data/secure_storage.json`)
3. Parse JSON to extract consensus private key
4. Use key to sign equivocating votes or manipulate safety data
5. Cause validator slashing or consensus disruption

## Notes

This vulnerability exists because:

1. **Design Assumption Violation**: The policy system assumes enforcement at the backend level, but InMemory and OnDisk backends explicitly opt out with "no permission checks" comments.

2. **Incomplete Sanitization**: The config sanitizer blocks InMemoryStorage but not OnDiskStorage, creating a false sense of security that OnDisk is "production-ready."

3. **Test Coverage Gap**: Policy enforcement is never tested for InMemory/OnDisk backends, allowing this inconsistency to persist. [12](#0-11) [13](#0-12) 

4. **Production Reality**: OnDiskStorage backend creation shows it's meant for production use with configurable paths: [14](#0-13) 

The vulnerability is exploitable by any local attacker (malware, compromised service, insider) without requiring validator collusion or Byzantine behavior. The impact is CRITICAL as it enables consensus private key theft, leading to validator slashing (loss of funds) and potential consensus safety violations.

### Citations

**File:** secure/storage/src/policy.rs (L6-58)
```rust
/// Dictates a set of permissions
#[derive(Debug, Default, Deserialize, PartialEq, Eq, Serialize)]
pub struct Policy {
    pub permissions: Vec<Permission>,
}

impl Policy {
    pub fn new(permissions: Vec<Permission>) -> Self {
        Self { permissions }
    }

    pub fn public() -> Self {
        Self::new(vec![Permission::new(Identity::Anyone, vec![
            Capability::Read,
            Capability::Write,
        ])])
    }
}

/// Maps an identity to a set of capabilities
#[derive(Debug, Deserialize, PartialEq, Eq, Serialize)]
pub struct Permission {
    pub id: Identity,
    pub capabilities: Vec<Capability>,
}

impl Permission {
    pub fn new(id: Identity, capabilities: Vec<Capability>) -> Self {
        Self { id, capabilities }
    }
}

/// Id represents an internal identifier for a given process. For example, safety_rules or
/// key_manager. It is up to the Storage and its deployment to translate these identifiers into
/// verifiable material. For example, the process running safety_rules may have a token that is
/// intended for only safety_rules to own. The specifics are left to the implementation of the
/// storage backend interface layer.
#[derive(Debug, Deserialize, PartialEq, Eq, Serialize)]
pub enum Identity {
    User(String),
    Anyone,
    NoOne,
}

/// Represents actions
#[derive(Debug, Deserialize, PartialEq, Eq, Serialize)]
pub enum Capability {
    Export,
    Read,
    Rotate,
    Sign,
    Write,
}
```

**File:** secure/storage/src/in_memory.rs (L9-14)
```rust
/// InMemoryStorage represents a key value store that is purely in memory and intended for single
/// threads (or must be wrapped by a Arc<RwLock<>>). This provides no permission checks and simply
/// is a proof of concept to unblock building of applications without more complex data stores.
/// Internally, it retains all data, which means that it must make copies of all key material which
/// violates the code base. It violates it because the anticipation is that data stores would
/// securely handle key material. This should not be used in production.
```

**File:** secure/storage/src/on_disk.rs (L16-22)
```rust
/// OnDiskStorage represents a key value store that is persisted to the local filesystem and is
/// intended for single threads (or must be wrapped by a Arc<RwLock<>>). This provides no permission
/// checks and simply offers a proof of concept to unblock building of applications without more
/// complex data stores. Internally, it reads and writes all data to a file, which means that it
/// must make copies of all key material which violates the code base. It violates it because
/// the anticipation is that data stores would securely handle key material. This should not be used
/// in production.
```

**File:** secure/storage/src/vault.rs (L310-548)
```rust
pub mod policy {
    use super::*;
    use crate::{Capability, Identity, Policy};
    use aptos_vault_client as vault;

    const APTOS_DEFAULT: &str = "aptos_default";

    /// VaultStorage utilizes Vault for maintaining encrypted, authenticated data. This
    /// version currently matches the behavior of OnDiskStorage and InMemoryStorage. In the future,
    /// Vault will be able to create keys, sign messages, and handle permissions across different
    /// services. The specific vault service leveraged herein is called KV (Key Value) Secrets Engine -
    /// Version 2 (https://www.vaultproject.io/api/secret/kv/kv-v2.html). So while Secure Storage
    /// calls pointers to data keys, Vault has actually a secret that contains multiple key value
    /// pairs.
    pub struct VaultPolicy {
        vault: VaultStorage,
        namespace: Option<String>,
    }

    impl VaultPolicy {
        pub fn new(vault: VaultStorage, namespace: Option<String>) -> Self {
            Self { vault, namespace }
        }

        // Made into an accessor so we can get auto-renewal
        fn client(&self) -> &Client {
            self.vault.client()
        }

        fn reset_policies(&self) -> Result<(), Error> {
            let policies = match self.client().list_policies() {
                Ok(policies) => policies,
                Err(aptos_vault_client::Error::NotFound(_, _)) => return Ok(()),
                Err(e) => return Err(e.into()),
            };

            for policy in policies {
                // Never touch the default or root policy
                if policy == "default" || policy == "root" {
                    continue;
                }

                self.client().delete_policy(&policy)?;
            }
            Ok(())
        }

        /// Creates a token but uses the namespace for policies
        pub fn create_token(&self, mut policies: Vec<&str>) -> Result<String, Error> {
            policies.push(APTOS_DEFAULT);
            let result = if let Some(ns) = &self.namespace {
                let policies: Vec<_> = policies.iter().map(|p| format!("{}/{}", ns, p)).collect();
                self.client()
                    .create_token(policies.iter().map(|p| &**p).collect())?
            } else {
                self.client().create_token(policies)?
            };
            Ok(result)
        }

        /// Create a new policy in Vault, see the explanation for Policy for how the data is
        /// structured. Vault does not distingush a create and update. An update must first read the
        /// existing policy, amend the contents,  and then be applied via this API.
        pub fn set_policy(
            &self,
            policy_name: &str,
            engine: &VaultEngine,
            key: &str,
            capabilities: &[Capability],
        ) -> Result<(), Error> {
            let policy_name = self.name(policy_name, engine);

            let mut vault_policy = self.client().read_policy(&policy_name).unwrap_or_default();
            let mut core_capabilities = Vec::new();
            for capability in capabilities {
                match capability {
                    Capability::Export => {
                        let export_capability = vec![vault::Capability::Read];
                        let export_policy = format!("transit/export/signing-key/{}", key);
                        vault_policy.add_policy(&export_policy, export_capability);
                    },
                    Capability::Read => core_capabilities.push(vault::Capability::Read),
                    Capability::Rotate => {
                        let rotate_capability = vec![vault::Capability::Update];
                        let rotate_policy = format!("transit/keys/{}/rotate", key);
                        vault_policy.add_policy(&rotate_policy, rotate_capability);
                    },
                    Capability::Sign => {
                        let sign_capability = vec![vault::Capability::Update];
                        let sign_policy = format!("transit/sign/{}", key);
                        vault_policy.add_policy(&sign_policy, sign_capability);
                    },
                    Capability::Write => core_capabilities.push(vault::Capability::Update),
                }
            }

            let path = format!("{}/{}", engine.to_policy_path(), self.name(key, engine));
            vault_policy.add_policy(&path, core_capabilities);
            self.client().set_policy(&policy_name, &vault_policy)?;
            Ok(())
        }

        pub fn set_policies(
            &self,
            name: &str,
            engine: &VaultEngine,
            policy: &Policy,
        ) -> Result<(), Error> {
            for perm in &policy.permissions {
                match &perm.id {
                    Identity::User(id) => self.set_policy(id, engine, name, &perm.capabilities)?,
                    Identity::Anyone => {
                        self.set_policy(APTOS_DEFAULT, engine, name, &perm.capabilities)?
                    },
                    Identity::NoOne => (),
                };
            }
            Ok(())
        }

        fn crypto_name(&self, name: &str) -> String {
            self.name(name, &VaultEngine::Transit)
        }

        fn secret_name(&self, name: &str) -> String {
            self.name(name, &VaultEngine::KVSecrets)
        }

        fn name(&self, name: &str, engine: &VaultEngine) -> String {
            if let Some(namespace) = &self.namespace {
                format!("{}{}{}", namespace, engine.ns_seperator(), name)
            } else {
                name.into()
            }
        }
    }

    impl KVStorage for VaultPolicy {
        fn available(&self) -> Result<(), Error> {
            self.vault.available()
        }

        fn get<T: DeserializeOwned>(&self, key: &str) -> Result<GetResponse<T>, Error> {
            let secret = self.secret_name(key);
            self.vault.get(&secret)
        }

        fn set<T: Serialize>(&mut self, key: &str, value: T) -> Result<(), Error> {
            let secret = self.secret_name(key);
            self.vault.set(&secret, value)
        }

        fn reset_and_clear(&mut self) -> Result<(), Error> {
            self.vault.reset_and_clear()?;
            self.reset_policies()
        }
    }

    impl CryptoStorage for VaultPolicy {
        fn create_key(&mut self, name: &str) -> Result<Ed25519PublicKey, Error> {
            let ns_name = self.crypto_name(name);
            self.vault.create_key(&ns_name)
        }

        fn export_private_key(&self, name: &str) -> Result<Ed25519PrivateKey, Error> {
            let name = self.crypto_name(name);
            self.vault.export_private_key(&name)
        }

        fn export_private_key_for_version(
            &self,
            name: &str,
            version: Ed25519PublicKey,
        ) -> Result<Ed25519PrivateKey, Error> {
            let name = self.crypto_name(name);
            self.vault.export_private_key_for_version(&name, version)
        }

        fn import_private_key(&mut self, name: &str, key: Ed25519PrivateKey) -> Result<(), Error> {
            let ns_name = self.crypto_name(name);
            self.vault.import_private_key(&ns_name, key)
        }

        fn get_public_key(&self, name: &str) -> Result<PublicKeyResponse, Error> {
            let name = self.crypto_name(name);
            self.vault.get_public_key(&name)
        }

        fn get_public_key_previous_version(&self, name: &str) -> Result<Ed25519PublicKey, Error> {
            let name = self.crypto_name(name);
            self.vault.get_public_key_previous_version(&name)
        }

        fn rotate_key(&mut self, name: &str) -> Result<Ed25519PublicKey, Error> {
            let ns_name = self.crypto_name(name);
            self.vault.rotate_key(&ns_name)
        }

        fn sign<T: CryptoHash + Serialize>(
            &self,
            name: &str,
            message: &T,
        ) -> Result<Ed25519Signature, Error> {
            let name = self.crypto_name(name);
            self.vault.sign(&name, message)
        }

        fn sign_using_version<T: CryptoHash + Serialize>(
            &self,
            name: &str,
            version: Ed25519PublicKey,
            message: &T,
        ) -> Result<Ed25519Signature, Error> {
            let name = self.crypto_name(name);
            self.vault.sign_using_version(&name, version, message)
        }
    }

    pub enum VaultEngine {
        KVSecrets,
        Transit,
    }

    impl VaultEngine {
        fn to_policy_path(&self) -> &str {
            match self {
                VaultEngine::KVSecrets => "secret/data",
                VaultEngine::Transit => "transit/keys",
            }
        }

        fn ns_seperator(&self) -> &str {
            match self {
                VaultEngine::KVSecrets => NAMESPACE_SEPARATOR,
                VaultEngine::Transit => TRANSIT_NAMESPACE_SEPARATOR,
            }
        }
    }
}
```

**File:** config/src/config/safety_rules_config.rs (L86-96)
```rust
            // Verify that the secure backend is appropriate for mainnet validators
            if chain_id.is_mainnet()
                && node_type.is_validator()
                && safety_rules_config.backend.is_in_memory()
            {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "The secure backend should not be set to in memory storage in mainnet!"
                        .to_string(),
                ));
            }
```

**File:** config/src/config/secure_backend_config.rs (L45-48)
```rust
    /// Returns true iff the backend is in memory
    pub fn is_in_memory(&self) -> bool {
        matches!(self, SecureBackend::InMemoryStorage)
    }
```

**File:** config/src/config/secure_backend_config.rs (L162-194)
```rust
impl From<&SecureBackend> for Storage {
    fn from(backend: &SecureBackend) -> Self {
        match backend {
            SecureBackend::InMemoryStorage => Storage::from(InMemoryStorage::new()),
            SecureBackend::OnDiskStorage(config) => {
                let storage = Storage::from(OnDiskStorage::new(config.path()));
                if let Some(namespace) = &config.namespace {
                    Storage::from(Namespaced::new(namespace, Box::new(storage)))
                } else {
                    storage
                }
            },
            SecureBackend::Vault(config) => {
                let storage = Storage::from(VaultStorage::new(
                    config.server.clone(),
                    config.token.read_token().expect("Unable to read token"),
                    config
                        .ca_certificate
                        .as_ref()
                        .map(|_| config.ca_certificate().unwrap()),
                    config.renew_ttl_secs,
                    config.disable_cas.map_or_else(|| true, |disable| !disable),
                    config.connection_timeout_ms,
                    config.response_timeout_ms,
                ));
                if let Some(namespace) = &config.namespace {
                    Storage::from(Namespaced::new(namespace, Box::new(storage)))
                } else {
                    storage
                }
            },
        }
    }
```

**File:** consensus/safety-rules/src/persistent_safety_storage.rs (L98-104)
```rust
    pub fn default_consensus_sk(
        &self,
    ) -> Result<bls12381::PrivateKey, aptos_secure_storage::Error> {
        self.internal_store
            .get::<bls12381::PrivateKey>(CONSENSUS_KEY)
            .map(|v| v.value)
    }
```

**File:** consensus/safety-rules/src/persistent_safety_storage.rs (L134-148)
```rust
    pub fn safety_data(&mut self) -> Result<SafetyData, Error> {
        if !self.enable_cached_safety_data {
            let _timer = counters::start_timer("get", SAFETY_DATA);
            return self.internal_store.get(SAFETY_DATA).map(|v| v.value)?;
        }

        if let Some(cached_safety_data) = self.cached_safety_data.clone() {
            Ok(cached_safety_data)
        } else {
            let _timer = counters::start_timer("get", SAFETY_DATA);
            let safety_data: SafetyData = self.internal_store.get(SAFETY_DATA).map(|v| v.value)?;
            self.cached_safety_data = Some(safety_data.clone());
            Ok(safety_data)
        }
    }
```

**File:** consensus/safety-rules/src/persistent_safety_storage.rs (L172-175)
```rust
    pub fn waypoint(&self) -> Result<Waypoint, Error> {
        let _timer = counters::start_timer("get", WAYPOINT);
        Ok(self.internal_store.get(WAYPOINT).map(|v| v.value)?)
    }
```

**File:** secure/storage/src/tests/suite.rs (L19-34)
```rust
const STORAGE_TESTS: &[fn(&mut Storage)] = &[
    test_set_reset_get,
    test_create_and_get_non_existent_version,
    test_create_get_key_pair,
    test_create_key_pair_and_perform_rotations,
    test_create_sign_rotate_sign,
    test_ensure_storage_is_available,
    test_get_non_existent,
    test_get_public_key_previous_version,
    test_get_set,
    test_get_uncreated_key_pair,
    test_hash_value,
    test_incremental_timestamp,
    test_import_key,
    test_verify_incorrect_value_types,
];
```

**File:** secure/storage/src/tests/vault.rs (L114-229)
```rust
fn test_vault_key_value_policies() {
    let mut storage = create_vault_policy_with_namespace(None);

    let anyone = Policy::public();
    let root = Policy::new(vec![]);
    let partial = Policy::new(vec![
        Permission::new(Identity::User(READER.into()), vec![Capability::Read]),
        Permission::new(Identity::User(WRITER.into()), vec![
            Capability::Read,
            Capability::Write,
        ]),
    ]);
    let full = Policy::new(vec![
        Permission::new(Identity::User(READER.into()), vec![
            Capability::Read,
            Capability::Write,
        ]),
        Permission::new(Identity::User(WRITER.into()), vec![
            Capability::Read,
            Capability::Write,
        ]),
    ]);

    // Provide a TTL to verify that lease renews work
    let ttl = Some(3600);

    // Initialize data and policies
    storage.set(ANYONE, 1).unwrap();
    storage
        .set_policies(ANYONE, &VaultEngine::KVSecrets, &anyone)
        .unwrap();

    storage.set(ROOT, 2).unwrap();
    storage
        .set_policies(ROOT, &VaultEngine::KVSecrets, &root)
        .unwrap();

    storage.set(PARTIAL, 3).unwrap();
    storage
        .set_policies(PARTIAL, &VaultEngine::KVSecrets, &partial)
        .unwrap();

    storage.set(FULL, 4).unwrap();
    storage
        .set_policies(FULL, &VaultEngine::KVSecrets, &full)
        .unwrap();

    // Verify initial reading works correctly
    assert_eq!(storage.get::<u64>(ANYONE).unwrap().value, 1);
    assert_eq!(storage.get::<u64>(ROOT).unwrap().value, 2);
    assert_eq!(storage.get::<u64>(PARTIAL).unwrap().value, 3);
    assert_eq!(storage.get::<u64>(FULL).unwrap().value, 4);

    let writer_token = storage.create_token(vec![WRITER]).unwrap();
    let mut writer = create_vault_storage(writer_token.clone(), ttl, false);
    assert_eq!(writer.get::<u64>(ANYONE).unwrap().value, 1);
    assert_eq!(writer.get::<u64>(ROOT), Err(Error::PermissionDenied));
    assert_eq!(writer.get::<u64>(PARTIAL).unwrap().value, 3);
    assert_eq!(writer.get::<u64>(FULL).unwrap().value, 4);

    let reader_token = storage.create_token(vec![READER]).unwrap();
    let mut reader = create_vault_storage(reader_token.clone(), ttl, false);
    assert_eq!(reader.get::<u64>(ANYONE).unwrap().value, 1);
    assert_eq!(reader.get::<u64>(ROOT), Err(Error::PermissionDenied));
    assert_eq!(reader.get::<u64>(PARTIAL).unwrap().value, 3);
    assert_eq!(reader.get::<u64>(FULL).unwrap().value, 4);

    // Attempt writes followed by reads for correctness
    writer.set(ANYONE, 5).unwrap();
    assert_eq!(writer.set(ROOT, 6), Err(Error::PermissionDenied));
    writer.set(PARTIAL, 7).unwrap();
    writer.set(FULL, 8).unwrap();

    assert_eq!(storage.get::<u64>(ANYONE).unwrap().value, 5);
    assert_eq!(storage.get::<u64>(ROOT).unwrap().value, 2);
    assert_eq!(storage.get::<u64>(PARTIAL).unwrap().value, 7);
    assert_eq!(storage.get::<u64>(FULL).unwrap().value, 8);

    reader.set(ANYONE, 9).unwrap();
    assert_eq!(reader.set(ROOT, 10), Err(Error::PermissionDenied));
    assert_eq!(reader.set(PARTIAL, 11), Err(Error::PermissionDenied));
    reader.set(FULL, 12).unwrap();

    assert_eq!(storage.get::<u64>(ANYONE).unwrap().value, 9);
    assert_eq!(storage.get::<u64>(ROOT).unwrap().value, 2);
    assert_eq!(storage.get::<u64>(PARTIAL).unwrap().value, 7);
    assert_eq!(storage.get::<u64>(FULL).unwrap().value, 12);

    // Verify a reader with another namespace has no permission for the operations
    let mut reader_with_namespace = Namespaced::new(
        VAULT_NAMESPACE_1,
        create_vault_storage(reader_token, ttl, false),
    );
    assert_eq!(
        reader_with_namespace.get::<u64>(ANYONE),
        Err(Error::PermissionDenied)
    );
    assert_eq!(
        reader_with_namespace.set(ANYONE, 5),
        Err(Error::PermissionDenied)
    );

    // Verify a writer with another namespace has no permission for the operations
    let mut writer_with_namespace = Namespaced::new(
        VAULT_NAMESPACE_1,
        create_vault_storage(writer_token, ttl, false),
    );
    assert_eq!(
        writer_with_namespace.get::<u64>(ANYONE),
        Err(Error::PermissionDenied)
    );
    assert_eq!(
        writer_with_namespace.set(ANYONE, 5),
        Err(Error::PermissionDenied)
    );
}
```

**File:** secure/storage/src/tests/in_memory.rs (L6-10)
```rust
#[test]
fn in_memory() {
    let mut storage = Storage::from(InMemoryStorage::new());
    suite::execute_all_storage_tests(&mut storage);
}
```

**File:** secure/storage/src/tests/on_disk.rs (L7-12)
```rust
#[test]
fn on_disk() {
    let path_buf = TempPath::new().path().to_path_buf();
    let mut storage = Storage::from(OnDiskStorage::new(path_buf));
    suite::execute_all_storage_tests(&mut storage);
}
```
