# Audit Report

## Title
Cross-Site Scripting (XSS) Vulnerability in Indexer gRPC Manager Status Page via Unvalidated Service Addresses

## Summary
The indexer gRPC manager's status page fails to sanitize HTML output when rendering service addresses, allowing malicious services to inject JavaScript through crafted `ServiceInfo.address` fields in heartbeat requests. This enables XSS attacks against administrators viewing the status page.

## Finding Description
The vulnerability exists in the status page rendering chain where service addresses from gRPC heartbeat requests are displayed without HTML escaping.

**Attack Path:**

1. **Injection Point**: A malicious data service or fullnode sends a `HeartbeatRequest` to the gRPC manager with a crafted address: [1](#0-0) 

2. **Storage**: The unvalidated address is extracted and stored: [2](#0-1) 

3. **Display**: The address is rendered in the status page using `.with_raw()` which does not escape HTML: [3](#0-2) 

The `build_html` crate's `.with_raw()` method inserts content directly into HTML without escaping, as confirmed by the codebase search results.

**Protobuf Definition** shows no validation on the address field: [4](#0-3) 

**Similar vulnerabilities** exist for fullnode addresses and historical data service addresses displayed in the status page.

## Impact Explanation
This is a **Medium** severity issue (as indicated in the security question) because:

- **Limited Scope**: The status page is served on the `health_check_port`, typically an internal monitoring interface not exposed to the public
- **Admin Impact**: Successful exploitation could compromise administrator sessions, enabling:
  - Session hijacking
  - CSRF attacks on management operations
  - Information disclosure from admin context
  - Potential pivot to other internal systems
- **Not Direct Blockchain Impact**: This does not directly affect consensus, state consistency, or on-chain funds
- **Operator Trust Boundary**: Exploits the trust relationship between the gRPC manager and connected services

While not a blockchain protocol vulnerability, it violates security boundaries in the monitoring infrastructure.

## Likelihood Explanation
**High Likelihood** of exploitation if an attacker gains the ability to operate a malicious data service or fullnode:

- **No Authentication**: The heartbeat endpoint requires no authentication [1](#0-0) 
  
- **Network Access**: Attacker needs network connectivity to the gRPC manager service (typically restricted to internal networks)
- **Simple Payload**: XSS payload like `<script>alert(document.cookie)</script>` in the address field is sufficient
- **Persistent Storage**: The malicious address persists in the metadata manager's DashMap until service timeout

## Recommendation
Implement HTML entity encoding before inserting dynamic content into the status page. Similar to the pattern used in Move docgen:

**Option 1 - Use HTML escaping function:**
```rust
fn html_escape(s: &str) -> String {
    s.replace('&', "&amp;")
     .replace('<', "&lt;")
     .replace('>', "&gt;")
     .replace('"', "&quot;")
     .replace('\'', "&#x27;")
}
```

**Option 2 - Validate address format:**
Add validation in the heartbeat handler to ensure addresses match expected URL patterns: [5](#0-4) 

Add validation before storage:
```rust
if !is_valid_grpc_address(&address) {
    return Err(Status::invalid_argument("Invalid service address format"));
}
```

**Option 3 - Use safe HTML methods:**
Replace `.with_raw()` calls with methods that auto-escape, or wrap content: [6](#0-5) 

## Proof of Concept

```rust
// PoC: Send malicious heartbeat request
use aptos_protos::indexer::v1::{
    HeartbeatRequest, ServiceInfo, LiveDataServiceInfo,
    service_info::Info,
};

// Craft malicious address with XSS payload
let malicious_address = "<script>alert('XSS via ' + document.cookie)</script>";

let request = HeartbeatRequest {
    service_info: Some(ServiceInfo {
        address: Some(malicious_address.to_string()),
        info: Some(Info::LiveDataServiceInfo(LiveDataServiceInfo {
            chain_id: 1,
            timestamp: Some(/* current timestamp */),
            known_latest_version: Some(1000),
            stream_info: Some(/* valid stream info */),
            min_servable_version: Some(0),
        })),
    }),
};

// Send to gRPC manager endpoint
// When admin views http://<manager-host>:<health_port>/
// The script executes in their browser
```

**Verification Steps:**
1. Deploy malicious data service that sends crafted heartbeat
2. Access status page at `http://<health-check-host>:<port>/`
3. Navigate to "LiveDataServices" or "Fullnodes" tab
4. Observe JavaScript execution in browser console

## Notes

This vulnerability is specific to the monitoring/observability layer of Aptos infrastructure and does not directly compromise blockchain consensus, state integrity, or on-chain assets. However, it represents a legitimate security issue in the Aptos Core codebase that could be exploited to compromise operator access to management interfaces.

The vulnerability affects the status page implementations in:
- [7](#0-6) 
- [8](#0-7)

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/service.rs (L110-127)
```rust
    async fn heartbeat(
        &self,
        request: Request<HeartbeatRequest>,
    ) -> Result<Response<HeartbeatResponse>, Status> {
        let request = request.into_inner();
        if let Some(service_info) = request.service_info {
            if let Some(address) = service_info.address {
                if let Some(info) = service_info.info {
                    return self
                        .handle_heartbeat(address, info)
                        .await
                        .map_err(|e| Status::internal(format!("Error handling heartbeat: {e}")));
                }
            }
        }

        Err(Status::invalid_argument("Bad request."))
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L489-508)
```rust
    fn handle_live_data_service_info(
        &self,
        address: GrpcAddress,
        mut info: LiveDataServiceInfo,
    ) -> Result<()> {
        let mut entry = self
            .live_data_services
            .entry(address.clone())
            .or_insert(LiveDataService::new(address));
        if info.stream_info.is_none() {
            info.stream_info = Some(StreamInfo {
                active_streams: vec![],
            });
        }
        entry.value_mut().recent_states.push_back(info);
        if entry.value().recent_states.len() > MAX_NUM_OF_STATES_TO_KEEP {
            entry.value_mut().recent_states.pop_front();
        }

        Ok(())
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/status_page.rs (L43-97)
```rust
fn render_fullnode_tab(fullnodes_info: HashMap<String, VecDeque<FullnodeInfo>>) -> Tab {
    let overview = Container::new(ContainerType::Section)
        .with_paragraph_attr("Connected Fullnodes", [(
            "style",
            "font-size: 24px; font-weight: bold;",
        )])
        .with_table(
            fullnodes_info.into_iter().fold(
                Table::new()
                    .with_attributes([("style", "width: 100%; border: 5px solid black;")])
                    .with_thead_attributes([(
                        "style",
                        "background-color: lightcoral; color: white;",
                    )])
                    .with_custom_header_row(
                        TableRow::new()
                            .with_cell(TableCell::new(TableCellType::Header).with_raw("Id"))
                            .with_cell(
                                TableCell::new(TableCellType::Header)
                                    .with_raw("Last Ping/Heartbeat Time"),
                            )
                            .with_cell(
                                TableCell::new(TableCellType::Header)
                                    .with_raw("Known Latest Version"),
                            ),
                    ),
                |table, fullnode_info| {
                    let last_sample = fullnode_info.1.back();
                    let (timestamp, known_latest_version) = if let Some(last_sample) = last_sample {
                        (
                            format!("{:?}", last_sample.timestamp.unwrap()),
                            format!("{}", last_sample.known_latest_version()),
                        )
                    } else {
                        ("No data point.".to_string(), "No data point.".to_string())
                    };
                    table.with_custom_body_row(
                        TableRow::new()
                            .with_cell(
                                TableCell::new(TableCellType::Data).with_raw(fullnode_info.0),
                            )
                            .with_cell(TableCell::new(TableCellType::Data).with_raw(timestamp))
                            .with_cell(
                                TableCell::new(TableCellType::Data).with_raw(known_latest_version),
                            ),
                    )
                },
            ),
        );
    let content = HtmlElement::new(HtmlTag::Div)
        .with_container(overview)
        .into();

    Tab::new("Fullnodes", content)
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/status_page.rs (L196-234)
```rust
fn render_data_service_tab<const N: usize>(
    tab_name: &str,
    column_names: [&str; N],
    rows: Vec<[String; N]>,
) -> Tab {
    let overview = Container::new(ContainerType::Section)
        .with_paragraph_attr(format!("Connected {tab_name}"), [(
            "style",
            "font-size: 24px; font-weight: bold;",
        )])
        .with_table(
            rows.iter().fold(
                Table::new()
                    .with_attributes([("style", "width: 100%; border: 5px solid black;")])
                    .with_thead_attributes([(
                        "style",
                        "background-color: lightcoral; color: white;",
                    )])
                    .with_custom_header_row(column_names.into_iter().fold(
                        TableRow::new(),
                        |row, column_name| {
                            row.with_cell(
                                TableCell::new(TableCellType::Header).with_raw(column_name),
                            )
                        },
                    )),
                |table, row| {
                    table.with_custom_body_row(row.iter().fold(TableRow::new(), |r, cell| {
                        r.with_cell(TableCell::new(TableCellType::Data).with_raw(cell))
                    }))
                },
            ),
        );
    let content = HtmlElement::new(HtmlTag::Div)
        .with_container(overview)
        .into();

    Tab::new(tab_name, content)
}
```

**File:** protos/proto/aptos/indexer/v1/grpc.proto (L64-72)
```text
message ServiceInfo {
  optional string address = 1;
  oneof info {
      LiveDataServiceInfo live_data_service_info = 2;
      HistoricalDataServiceInfo historical_data_service_info = 3;
      FullnodeInfo fullnode_info = 4;
      GrpcManagerInfo grpc_manager_info = 5;
  }
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/status_page.rs (L16-44)
```rust
pub(crate) fn status_page() -> Result<Response, Rejection> {
    let mut tabs = vec![];
    // TODO(grao): Add something real.
    let overview_tab_content = HtmlElement::new(HtmlTag::Div).with_raw("Welcome!").into();
    tabs.push(Tab::new("Overview", overview_tab_content));
    if let Some(live_data_service) = LIVE_DATA_SERVICE.get() {
        let connection_manager_info =
            render_connection_manager_info(live_data_service.get_connection_manager());
        let cache_info = render_cache_info();
        let content = HtmlElement::new(HtmlTag::Div)
            .with_container(connection_manager_info)
            .with_container(cache_info)
            .into();
        tabs.push(Tab::new("LiveDataService", content));
    }

    if let Some(historical_data_service) = HISTORICAL_DATA_SERVICE.get() {
        let connection_manager_info =
            render_connection_manager_info(historical_data_service.get_connection_manager());
        let file_store_info = render_file_store_info();
        let content = HtmlElement::new(HtmlTag::Div)
            .with_container(connection_manager_info)
            .with_container(file_store_info)
            .into();
        tabs.push(Tab::new("HistoricalDataService", content));
    }

    render_status_page(tabs)
}
```
