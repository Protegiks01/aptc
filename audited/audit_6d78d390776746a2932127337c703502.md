# Audit Report

## Title
Faucet Bypass Mechanism Allows Blocked IPs to Drain Funds via Compromised Authentication Tokens

## Summary
The Aptos Faucet's bypass mechanism (used for CI/testing with auth tokens or IP allowlists) skips ALL checkers including security-critical components like `IpBlocklistChecker`. An attacker from a blocked IP who obtains a valid authentication token can bypass IP blocklist protections and access potentially unlimited faucet funds via the `maximum_amount_with_bypass` configuration.

## Finding Description
The faucet implements a two-tier validation system with Bypassers and Checkers. The critical flaw lies in how bypass evaluation occurs in the request preprocessing flow. [1](#0-0) 

When ANY bypasser returns `true` (e.g., `AuthTokenBypasser` finding a valid token or `IpAllowlistBypasser` matching an IP), the function returns immediately with `bypass = true` at line 257, completely skipping the checker validation loop that begins at line 262. [2](#0-1) 

This means security-critical checkers are never invoked when bypass is active:
- `IpBlocklistChecker` [3](#0-2)  is skipped
- `GoogleCaptchaChecker` and `TapCaptchaChecker` are skipped
- Rate limiting checkers are skipped

The `AuthTokenBypasser` validates tokens from a configured list: [4](#0-3) 

When bypass is enabled, requests can access higher funding amounts: [5](#0-4) [6](#0-5) 

**Attack Scenario:**
1. Attacker's IP (e.g., 1.2.3.4) is added to IP blocklist due to abuse
2. Attacker obtains valid auth token through:
   - Leaked CI/CD credentials
   - Compromised developer environment
   - Social engineering
3. Attacker sends funding request with `Authorization: Bearer <token>` header
4. `AuthTokenBypasser.request_can_bypass()` returns `true`
5. Request returns early, skipping IP blocklist check entirely
6. Attacker receives funds up to `maximum_amount_with_bypass` (potentially 100x normal limit)
7. Attacker repeats until faucet is drained

## Impact Explanation
This is classified as **High Severity** based on the Aptos Bug Bounty criteria for the following reasons:

**Service Availability Impact:** The faucet is a critical infrastructure component for testnet operations. A determined attacker could:
- Drain the faucet balance, denying service to legitimate developers
- Cause operational disruptions requiring manual intervention
- Force faucet operators to frequently replenish funds

**Security Control Bypass:** The IP blocklist is a security mechanism, not a convenience feature. Bypassing it violates the defense-in-depth principle where multiple independent controls should protect the system.

**Elevated Access:** The `maximum_amount_with_bypass` configuration (shown in test configuration as 100x the normal limit) amplifies the attack impact: [7](#0-6) 

While testnet tokens have no direct monetary value, faucet abuse causes:
- Developer productivity loss
- Operational overhead
- Potential testnet instability from account creation spam

## Likelihood Explanation
**Likelihood: MEDIUM-HIGH**

Auth token compromise is a realistic threat:
- CI/CD systems frequently leak credentials (GitHub Actions, GitLab CI logs)
- Developer environments may have inadequate security
- Tokens in configuration files can be committed to public repositories
- Long-lived tokens increase exposure window

The attack requires:
- Single compromised auth token (moderate difficulty)
- No technical sophistication (simple HTTP request)
- No rate limiting when bypassed (unlimited attempts)

Proof that bypass works as described exists in the test suite: [8](#0-7) 

## Recommendation
Implement **tiered bypass levels** to separate rate-limiting bypasses from security control bypasses:

```rust
// Add to BypasserTrait
pub enum BypassScope {
    RateLimitOnly,    // Skips rate limits and captcha only
    SecurityCritical, // Skips all including IP blocklist (restricted use)
}

impl BypasserTrait {
    fn bypass_scope(&self) -> BypassScope;
}

// Modify preprocess_request
async fn preprocess_request(...) {
    let mut bypass_rate_limits = false;
    let mut bypass_security = false;
    
    for bypasser in &self.bypassers {
        if bypasser.request_can_bypass(checker_data.clone()).await? {
            match bypasser.bypass_scope() {
                BypassScope::RateLimitOnly => bypass_rate_limits = true,
                BypassScope::SecurityCritical => bypass_security = true,
            }
        }
    }
    
    // Always run security-critical checkers unless explicitly bypassed
    for checker in &self.checkers {
        if checker.is_security_critical() && !bypass_security {
            rejection_reasons.extend(checker.check(...).await?);
        } else if !bypass_rate_limits {
            rejection_reasons.extend(checker.check(...).await?);
        }
    }
}
```

**Immediate mitigation:**
1. Rotate all auth tokens in production
2. Restrict `AuthTokenBypasser` usage to known-safe IPs only
3. Set `maximum_amount_with_bypass` equal to `maximum_amount`
4. Monitor for bypass usage from blocked IPs

## Proof of Concept
```rust
// Demonstrates the vulnerability
// Place in crates/aptos-faucet/core/src/server/run.rs test module

#[tokio::test]
async fn test_blocked_ip_bypasses_with_auth_token() -> Result<()> {
    // Setup: Create IP blocklist with attacker's IP
    make_ip_blocklist_file(&["192.168.1.100/32"])?;
    make_auth_tokens_file(&["leaked_token"])?;
    
    // Start faucet with both IP blocklist and auth bypass
    let config = r#"
    bypasser_configs:
      - type: "AuthToken"
        file: "/tmp/auth_tokens.txt"
    checker_configs:
      - type: "IpBlocklist"
        file: "/tmp/ip_blocklist.txt"
    funder_config:
      type: "MintFunder"
      maximum_amount: 100
      maximum_amount_with_bypass: 10000
    "#;
    
    let (port, _handle) = start_server(config).await?;
    
    // Attack: Request from blocked IP WITH auth token
    let request = FundRequest { amount: Some(5000), ... };
    let response = reqwest::Client::new()
        .post(get_fund_endpoint(port))
        .header("X-Forwarded-For", "192.168.1.100") // Blocked IP
        .header("Authorization", "Bearer leaked_token")
        .json(&request)
        .send()
        .await?;
    
    // Vulnerability: Request succeeds despite IP being blocked
    assert!(response.status().is_success());
    
    // Attacker receives elevated amount via bypass
    let balance = check_account_balance(&request.address).await?;
    assert_eq!(balance, 5000); // Got full amount, bypassed IP block
    
    // Control: Same request WITHOUT token is blocked
    let response = reqwest::Client::new()
        .post(get_fund_endpoint(port))
        .header("X-Forwarded-For", "192.168.1.100")
        .json(&request)
        .send()
        .await?;
    
    assert_eq!(response.status(), StatusCode::FORBIDDEN);
    
    Ok(())
}
```

## Notes
While the faucet is a testnet component distributing test tokens rather than a core consensus mechanism, it remains critical infrastructure. The bypass mechanism's failure to distinguish between convenience controls (rate limits, captcha) and security controls (IP blocklist) represents a design flaw exploitable by attackers with compromised credentials. The recommended tiered bypass approach maintains CI/testing convenience while preserving essential security boundaries.

### Citations

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L244-259)
```rust
        // See if this request meets the criteria to bypass checkers / storage.
        for bypasser in &self.bypassers {
            if bypasser
                .request_can_bypass(checker_data.clone())
                .await
                .map_err(|e| {
                    AptosTapError::new_with_error_code(e, AptosTapErrorCode::BypasserError)
                })?
            {
                info!(
                    "Allowing request from {} to bypass checks / storage",
                    source_ip
                );
                return Ok((checker_data, true, permit));
            }
        }
```

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L261-278)
```rust
        // Ensure request passes checkers.
        let mut rejection_reasons = Vec::new();
        for checker in &self.checkers {
            rejection_reasons.extend(checker.check(checker_data.clone(), dry_run).await.map_err(
                |e| AptosTapError::new_with_error_code(e, AptosTapErrorCode::CheckerError),
            )?);
            if !rejection_reasons.is_empty() && self.return_rejections_early {
                break;
            }
        }

        if !rejection_reasons.is_empty() {
            return Err(AptosTapError::new(
                format!("Request rejected by {} checkers", rejection_reasons.len()),
                AptosTapErrorCode::Rejected,
            )
            .rejection_reasons(rejection_reasons));
        }
```

**File:** crates/aptos-faucet/core/src/checkers/ip_blocklist.rs (L26-51)
```rust
impl CheckerTrait for IpBlocklistChecker {
    async fn check(
        &self,
        data: CheckerData,
        _dry_run: bool,
    ) -> Result<Vec<RejectionReason>, AptosTapError> {
        match &data.source_ip {
            IpAddr::V4(source_ip) => {
                if self.manager.ipv4_list.contains(source_ip) {
                    return Ok(vec![RejectionReason::new(
                        format!("IP {} is in blocklist", source_ip),
                        RejectionReasonCode::IpInBlocklist,
                    )]);
                }
            },
            IpAddr::V6(source_ip) => {
                if self.manager.ipv6_list.contains(source_ip) {
                    return Ok(vec![RejectionReason::new(
                        format!("IP {} is in blocklist", source_ip),
                        RejectionReasonCode::IpInBlocklist,
                    )]);
                }
            },
        }
        Ok(vec![])
    }
```

**File:** crates/aptos-faucet/core/src/bypasser/auth_token.rs (L31-49)
```rust
impl BypasserTrait for AuthTokenBypasser {
    async fn request_can_bypass(&self, data: CheckerData) -> Result<bool> {
        // Don't check if the request has X_IS_JWT_HEADER set.
        if data.headers.contains_key(X_IS_JWT_HEADER) {
            return Ok(false);
        }

        let auth_token = match data
            .headers
            .get(AUTHORIZATION)
            .and_then(|v| v.to_str().ok())
            .and_then(|v| v.split_whitespace().nth(1))
        {
            Some(auth_token) => auth_token,
            None => return Ok(false),
        };

        Ok(self.manager.contains(auth_token))
    }
```

**File:** crates/aptos-faucet/core/src/funder/common.rs (L176-185)
```rust
    pub fn get_maximum_amount(
        &self,
        // True if a Bypasser let the request bypass the Checkers.
        did_bypass_checkers: bool,
    ) -> Option<u64> {
        match (self.maximum_amount_with_bypass, did_bypass_checkers) {
            (Some(max), true) => Some(max),
            _ => self.maximum_amount,
        }
    }
```

**File:** crates/aptos-faucet/core/src/funder/mint.rs (L540-550)
```rust
    fn get_amount(&self, amount: Option<u64>, did_bypass_checkers: bool) -> u64 {
        match (
            amount,
            self.txn_config.get_maximum_amount(did_bypass_checkers),
        ) {
            (Some(amount), Some(maximum_amount)) => std::cmp::min(amount, maximum_amount),
            (Some(amount), None) => amount,
            (None, Some(maximum_amount)) => std::cmp::min(self.amount_to_fund, maximum_amount),
            (None, None) => self.amount_to_fund,
        }
    }
```

**File:** crates/aptos-faucet/configs/testing_mint_funder_local_wait_for_txns.yaml (L15-16)
```yaml
  maximum_amount: 100
  maximum_amount_with_bypass: 10000
```

**File:** crates/aptos-faucet/core/src/server/run.rs (L959-972)
```rust
        // Make a request for more than maximum_amount. This should be accepted as is
        // because we're including an auth token that lets us bypass the checkers,
        // meaning we're instead bound by maximum_amount_with_bypass.
        let fund_request = get_fund_request(Some(1000));
        unwrap_reqwest_result(
            reqwest::Client::new()
                .post(get_fund_endpoint(port))
                .body(fund_request.to_json_string())
                .header(CONTENT_TYPE, "application/json")
                .header(AUTHORIZATION, "Bearer test_token")
                .send()
                .await,
        )
        .await?;
```
