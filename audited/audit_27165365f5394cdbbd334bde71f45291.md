# Audit Report

## Title
Race Condition in State Sync Notification Handler Causes Out-of-Order Version Notifications

## Summary
The `handle_transaction_notification()` function can be called concurrently from two separate execution contexts without proper serialization, causing notifications to be sent to mempool, storage service, and event subscribers with non-monotonic version numbers. This occurs when the main driver task processes consensus commit notifications while the spawned commit post-processor task processes storage synchronization commits.

## Finding Description

Two independent async tasks can invoke `handle_committed_transactions()` concurrently, which breaks the notification ordering invariant:

**Execution Path 1 (Main Driver):** Consensus commit notifications processed in the main driver loop [1](#0-0) 

**Execution Path 2 (Spawned Task):** Storage sync commits processed by an independent spawned task [2](#0-1) 

Both paths call the same notification function which reads the latest version from storage and sends notifications: [3](#0-2) 

The `handle_transaction_notification()` function then sends notifications sequentially to three components without any cross-task synchronization: [4](#0-3) 

**Race Scenario:**
1. Storage sync commits transactions 101-110 → storage at version 110, queues notification
2. Consensus commits transactions 111-120 → storage at version 120
3. Task A (main driver) reads version from storage → gets 120, sends notifications
4. Task B (post-processor) reads version from storage → gets 120 (or 110 if timing differs), sends notifications
5. Notifications arrive out of order: storage service receives version 120, then version 110 (going backwards)

The storage service notification explicitly includes the version: [5](#0-4) 

Event subscribers receive EventNotification with version numbers that can arrive non-monotonically: [6](#0-5) 

## Impact Explanation

**Severity: Medium**

This issue qualifies as **Medium Severity** under the "State inconsistencies requiring intervention" category because:

1. **Event Subscriber Confusion**: Subscribers receive events with non-monotonic version numbers, potentially violating their assumptions about version ordering
2. **Duplicate/Stale Notifications**: Components may receive notifications for already-processed versions
3. **Storage Service Cache Thrashing**: Out-of-order notifications trigger unnecessary cache refreshes

While this doesn't directly cause fund loss or consensus violations, it creates state tracking inconsistencies that could require operator intervention to resolve, especially for external indexers and event processors that depend on monotonic version progression.

## Likelihood Explanation

**Likelihood: High**

This race condition occurs naturally during:
1. **Validator Bootstrap Transitions**: When a validator completes bootstrapping and transitions from state sync to consensus mode, queued post-processor notifications can race with new consensus notifications
2. **Catch-up Scenarios**: When validators lag and both sync mechanisms are active
3. **Normal Operation**: Any time the commit post-processor has a backlog while consensus is committing

The race requires no attacker intervention—it's a timing-dependent bug in normal node operation.

## Recommendation

Add a global notification sequencer to ensure version-ordered delivery. Introduce a shared mutex or atomic counter that enforces serialization:

```rust
pub struct NotificationSequencer {
    last_notified_version: Arc<Mutex<Version>>,
}

impl NotificationSequencer {
    pub async fn send_notification_if_newer(
        &self,
        version: Version,
        notification_fn: impl Future<Output = Result<(), Error>>,
    ) -> Result<(), Error> {
        let mut last_version = self.last_notified_version.lock();
        
        // Only send if this version is newer than the last notified
        if version <= *last_version {
            debug!("Skipping notification for version {} (already notified up to {})", 
                   version, *last_version);
            return Ok(());
        }
        
        notification_fn.await?;
        *last_version = version;
        Ok(())
    }
}
```

Wrap all calls to `handle_transaction_notification()` with this sequencer to guarantee monotonic version ordering.

## Proof of Concept

```rust
// Reproduction scenario in Rust
#[tokio::test]
async fn test_concurrent_notification_race() {
    let storage = create_test_storage();
    let mempool_handler = create_mock_mempool_handler();
    let event_service = Arc::new(Mutex::new(EventSubscriptionService::new(storage.clone())));
    let storage_service_handler = create_mock_storage_service_handler();
    
    // Set storage to version 100
    storage.commit_version(100);
    
    // Simulate two concurrent notification tasks
    let task1 = tokio::spawn({
        let storage = storage.clone();
        let mempool_handler = mempool_handler.clone();
        let event_service = event_service.clone();
        let storage_service_handler = storage_service_handler.clone();
        
        async move {
            // Simulate delay before reading version
            tokio::time::sleep(Duration::from_millis(10)).await;
            
            let version = fetch_pre_committed_version(storage.clone()).unwrap();
            // Reads version 110 if storage was updated
            handle_transaction_notification(
                vec![], vec![], version, ledger_info,
                mempool_handler, event_service, storage_service_handler
            ).await
        }
    });
    
    let task2 = tokio::spawn({
        async move {
            // Update storage first
            storage.commit_version(110);
            
            let version = fetch_pre_committed_version(storage.clone()).unwrap();
            // Reads version 110
            handle_transaction_notification(
                vec![], vec![], version, ledger_info,
                mempool_handler, event_service, storage_service_handler
            ).await
        }
    });
    
    // Both tasks complete, but notifications may arrive out of order
    let _ = tokio::join!(task1, task2);
    
    // Verify: storage service may have received version 110 twice
    // or version 100 after version 110 (out of order)
}
```

## Notes

The race condition is particularly problematic during validator bootstrap-to-consensus transitions where the commit post-processor task remains active with queued notifications from the bootstrap phase while consensus begins sending its own commit notifications. The lack of cross-task synchronization allows version numbers to regress in the notification stream, violating the implicit ordering contract expected by downstream consumers like indexers and event processors.

### Citations

**File:** state-sync/state-sync-driver/src/driver.rs (L316-341)
```rust
    async fn handle_consensus_commit_notification(
        &mut self,
        commit_notification: ConsensusCommitNotification,
    ) -> Result<(), Error> {
        info!(
            LogSchema::new(LogEntry::ConsensusNotification).message(&format!(
                "Received a consensus commit notification! Total transactions: {:?}, events: {:?}",
                commit_notification.get_transactions().len(),
                commit_notification.get_subscribable_events().len()
            ))
        );
        self.update_consensus_commit_metrics(&commit_notification);

        // Handle the commit notification
        let committed_transactions = CommittedTransactions {
            events: commit_notification.get_subscribable_events().clone(),
            transactions: commit_notification.get_transactions().clone(),
        };
        utils::handle_committed_transactions(
            committed_transactions,
            self.storage.clone(),
            self.mempool_notification_handler.clone(),
            self.event_subscription_service.clone(),
            self.storage_service_notification_handler.clone(),
        )
        .await;
```

**File:** state-sync/state-sync-driver/src/storage_synchronizer.rs (L796-824)
```rust
    // Create a commit post-processor
    let commit_post_processor = async move {
        while let Some(notification) = commit_post_processor_listener.next().await {
            // Start the commit post-process timer
            let _timer = metrics::start_timer(
                &metrics::STORAGE_SYNCHRONIZER_LATENCIES,
                metrics::STORAGE_SYNCHRONIZER_COMMIT_POST_PROCESS,
            );

            // Handle the committed transaction notification (e.g., notify mempool)
            let committed_transactions = CommittedTransactions {
                events: notification.subscribable_events,
                transactions: notification.committed_transactions,
            };
            utils::handle_committed_transactions(
                committed_transactions,
                storage.clone(),
                mempool_notification_handler.clone(),
                event_subscription_service.clone(),
                storage_service_notification_handler.clone(),
            )
            .await;
            decrement_pending_data_chunks(pending_data_chunks.clone());
        }
    };

    // Spawn the commit post-processor
    spawn(runtime, commit_post_processor)
}
```

**File:** state-sync/state-sync-driver/src/utils.rs (L335-370)
```rust
    // Fetch the latest synced version and ledger info from storage
    let (latest_synced_version, latest_synced_ledger_info) =
        match fetch_pre_committed_version(storage.clone()) {
            Ok(latest_synced_version) => match fetch_latest_synced_ledger_info(storage.clone()) {
                Ok(latest_synced_ledger_info) => (latest_synced_version, latest_synced_ledger_info),
                Err(error) => {
                    error!(LogSchema::new(LogEntry::SynchronizerNotification)
                        .error(&error)
                        .message("Failed to fetch latest synced ledger info!"));
                    return;
                },
            },
            Err(error) => {
                error!(LogSchema::new(LogEntry::SynchronizerNotification)
                    .error(&error)
                    .message("Failed to fetch latest synced version!"));
                return;
            },
        };

    // Handle the commit notification
    if let Err(error) = CommitNotification::handle_transaction_notification(
        committed_transactions.events,
        committed_transactions.transactions,
        latest_synced_version,
        latest_synced_ledger_info,
        mempool_notification_handler,
        event_subscription_service,
        storage_service_notification_handler,
    )
    .await
    {
        error!(LogSchema::new(LogEntry::SynchronizerNotification)
            .error(&error)
            .message("Failed to handle a transaction commit notification!"));
    }
```

**File:** state-sync/state-sync-driver/src/notification_handlers.rs (L96-110)
```rust
        // Notify the storage service of the committed transactions
        storage_service_notification_handler
            .notify_storage_service_of_committed_transactions(latest_synced_version)
            .await?;

        // Notify mempool of the committed transactions
        mempool_notification_handler
            .notify_mempool_of_committed_transactions(transactions, blockchain_timestamp_usecs)
            .await?;

        // Notify the event subscription service of the events
        event_subscription_service
            .lock()
            .notify_events(latest_synced_version, events)?;

```

**File:** state-sync/inter-component/storage-service-notifications/src/lib.rs (L76-95)
```rust
    async fn notify_new_commit(&self, highest_synced_version: u64) -> Result<(), Error> {
        // Create a new commit notification
        let commit_notification = StorageServiceCommitNotification {
            highest_synced_version,
        };

        // Send the notification to the storage service
        if let Err(error) = self
            .notification_sender
            .clone()
            .push((), commit_notification)
        {
            return Err(Error::CommitNotificationError(format!(
                "Failed to notify the storage service of committed transactions! Error: {:?}",
                error
            )));
        }

        Ok(())
    }
```

**File:** state-sync/inter-component/event-notifications/src/lib.rs (L349-358)
```rust
    fn notify_subscriber_of_events(&mut self, version: Version) -> Result<(), Error> {
        let event_notification = EventNotification {
            subscribed_events: self.event_buffer.drain(..).collect(),
            version,
        };

        self.notification_sender
            .push((), event_notification)
            .map_err(|error| Error::UnexpectedErrorEncountered(format!("{:?}", error)))
    }
```
