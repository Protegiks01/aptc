# Audit Report

## Title
Transaction Replay Failure After Feature Flag Rollback Due to Missing Feature State Preservation

## Summary
When a protocol upgrade is rolled back by disabling feature flags (such as `TRANSACTION_PAYLOAD_V2` or `ORDERLESS_TRANSACTIONS`), transactions that were successfully committed using the new features will fail during replay with `FEATURE_UNDER_GATING` status. This creates a mismatch between the stored transaction outputs (successful execution) and replay outputs (discarded transaction), breaking deterministic execution and preventing state synchronization.

## Finding Description
The Aptos VM validates transactions against currently enabled feature flags during execution. When new transaction formats are gated behind feature flags like `TRANSACTION_PAYLOAD_V2` (flag 93) or `ORDERLESS_TRANSACTIONS` (flag 94), the validation logic rejects transactions using these features when the flags are disabled. [1](#0-0) 

The vulnerability occurs in this sequence:

1. **Feature Enabled**: Governance enables `TRANSACTION_PAYLOAD_V2` flag via `change_feature_flags_for_next_epoch()` [2](#0-1) 

2. **Transactions Committed**: Users submit transactions with `TransactionPayload::Payload` variant or orderless transactions with nonce-based replay protection. These pass validation and execute successfully.

3. **Feature Rolled Back**: Governance disables the feature flag (protocol rollback scenario).

4. **Replay Failure**: During transaction replay (state sync, recovery, or verification), the VM re-executes these transactions: [3](#0-2) 

5. **Validation Rejects**: The feature flag check fails, returning `FEATURE_UNDER_GATING` error, causing the transaction to be discarded instead of executed.

6. **Mismatch Detected**: The verification logic compares outputs: [4](#0-3) 

The expected status is `Keep` (from ledger) but actual status is `Discard`, causing `ensure_match_transaction_info` to fail with "TransactionOutput does not match TransactionInfo".

The replay system only overrides `TimedFeatureFlags` (time-based features), not governance-controlled `FeatureFlags`: [5](#0-4) [6](#0-5) 

The `TimedFeatureOverride::Replay` only affects flags like `_LimitTypeTagSize` and `_ModuleComplexityCheck`, not `TRANSACTION_PAYLOAD_V2` or `ORDERLESS_TRANSACTIONS`.

## Impact Explanation
This vulnerability has **Medium severity** per the Aptos bug bounty program criteria:
- **State inconsistencies requiring intervention**: Nodes cannot replay historical transactions after feature rollback without manual intervention
- The workaround requires adding specific transaction versions to `txns_to_skip`: [7](#0-6) 

This breaks the **Deterministic Execution** invariant: validators produce different results depending on their feature flag configuration, potentially causing:
- State sync failures for nodes catching up
- Recovery/restore operations failing from backups
- Consensus issues if nodes have inconsistent feature flag states during rollback window

While not causing direct fund loss, it requires operational intervention and could lead to network availability issues.

## Likelihood Explanation
**Medium-High Likelihood:**
- Feature flag rollbacks are rare but possible (bugs discovered post-deployment, compatibility issues)
- Once a feature is enabled and transactions use it, any rollback triggers this issue
- The `replay-benchmark` tool has override capabilities but normal state sync does not: [8](#0-7) 

- No automatic safeguards prevent disabling features that have been used in committed transactions: [9](#0-8) 

## Recommendation
Implement one of these solutions:

**Option 1: Preserve Feature State in Transaction Metadata**
Store the active feature flags at execution time in `PersistedAuxiliaryInfo` and restore them during replay:

```rust
// In PersistedAuxiliaryInfo
pub struct PersistedAuxiliaryInfo {
    // ... existing fields
    pub feature_flags_at_execution: Option<Features>,
}

// During replay in chunk_executor
fn verify_execution(...) {
    let features = persisted_aux_info.feature_flags_at_execution
        .unwrap_or_else(|| get_current_features());
    // Use these features for execution
}
```

**Option 2: Extend TimedFeatureOverride for Replay**
Make `TimedFeatureOverride::Replay` also preserve governance feature flags that were enabled in historical blocks.

**Option 3: Prevent Rollback of Used Features**
Add validation in `apply_diff` to prevent disabling features that have been used in any committed transaction (track feature usage in on-chain state).

**Recommended**: Option 1 provides the most robust solution with minimal breaking changes.

## Proof of Concept

```rust
// Reproduction Steps:
// 1. Enable TRANSACTION_PAYLOAD_V2 feature flag
// 2. Submit transaction with TransactionPayload::Payload variant
// 3. Transaction executes successfully, gets committed
// 4. Disable TRANSACTION_PAYLOAD_V2 feature flag  
// 5. Attempt to replay the transaction via ChunkExecutor

#[test]
fn test_feature_rollback_replay_failure() {
    // Setup: Enable feature
    let mut features = Features::default();
    features.enable(FeatureFlag::TRANSACTION_PAYLOAD_V2);
    
    // Create transaction using new format
    let txn = create_transaction_with_payload_v2();
    
    // Execute and commit with feature enabled
    let output1 = execute_transaction(txn.clone(), &features);
    assert!(matches!(output1.status(), TransactionStatus::Keep(_)));
    let stored_info = TransactionInfo::from(&output1);
    
    // Rollback: Disable feature
    features.disable(FeatureFlag::TRANSACTION_PAYLOAD_V2);
    
    // Attempt replay with feature disabled
    let output2 = execute_transaction(txn, &features);
    assert!(matches!(output2.status(), 
        TransactionStatus::Discard(DiscardedVMStatus::FEATURE_UNDER_GATING)));
    
    // Verification fails - mismatch detected
    let result = output2.ensure_match_transaction_info(
        0, &stored_info, None, None
    );
    assert!(result.is_err()); // Status mismatch: Keep vs Discard
}
```

**Notes**
This vulnerability specifically affects the `TRANSACTION_PAYLOAD_V2` and `ORDERLESS_TRANSACTIONS` features but could apply to any feature flag that gates transaction format changes. The root cause is that feature flag state is not preserved as part of transaction execution context, making replay non-deterministic across feature flag configuration changes.

### Citations

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1911-1930)
```rust
        if matches!(transaction.payload(), TransactionPayload::Payload(_))
            && !self.features().is_transaction_payload_v2_enabled()
        {
            return Err(VMStatus::error(
                StatusCode::FEATURE_UNDER_GATING,
                Some(
                    "User transactions with TransactionPayloadInner variant are not yet supported"
                        .to_string(),
                ),
            ));
        }

        if !self.features().is_orderless_txns_enabled() {
            if let ReplayProtector::Nonce(_) = transaction.replay_protector() {
                return Err(VMStatus::error(
                    StatusCode::FEATURE_UNDER_GATING,
                    Some("Orderless transactions are not yet supported".to_string()),
                ));
            }
        }
```

**File:** aptos-move/framework/move-stdlib/sources/configs/features.move (L805-828)
```text
    public fun change_feature_flags_for_next_epoch(
        framework: &signer,
        enable: vector<u64>,
        disable: vector<u64>
    ) acquires PendingFeatures, Features {
        assert!(signer::address_of(framework) == @std, error::permission_denied(EFRAMEWORK_SIGNER_NEEDED));

        // Figure out the baseline feature vec that the diff will be applied to.
        let new_feature_vec = if (exists<PendingFeatures>(@std)) {
            // If there is a buffered feature vec, use it as the baseline.
            let PendingFeatures { features } = move_from<PendingFeatures>(@std);
            features
        } else if (exists<Features>(@std)) {
            // Otherwise, use the currently effective feature flag vec as the baseline, if it exists.
            Features[@std].features
        } else {
            // Otherwise, use an empty feature vec.
            vector[]
        };

        // Apply the diff and save it to the buffer.
        apply_diff(&mut new_feature_vec, enable, disable);
        move_to(framework, PendingFeatures { features: new_feature_vec });
    }
```

**File:** aptos-move/framework/move-stdlib/sources/configs/features.move (L874-881)
```text
    fun apply_diff(features: &mut vector<u8>, enable: vector<u64>, disable: vector<u64>) {
        enable.for_each(|feature| {
            set(features, feature, true);
        });
        disable.for_each(|feature| {
            set(features, feature, false);
        });
    }
```

**File:** execution/executor/src/chunk_executor/mod.rs (L592-627)
```rust
    fn verify_execution(
        &self,
        transactions: &[Transaction],
        persisted_aux_info: &[PersistedAuxiliaryInfo],
        transaction_infos: &[TransactionInfo],
        write_sets: &[WriteSet],
        event_vecs: &[Vec<ContractEvent>],
        begin_version: Version,
        end_version: Version,
        verify_execution_mode: &VerifyExecutionMode,
    ) -> Result<Version> {
        // Execute transactions.
        let parent_state = self.commit_queue.lock().latest_state().clone();
        let state_view = self.state_view(parent_state.latest())?;
        let txns = transactions
            .iter()
            .take((end_version - begin_version) as usize)
            .cloned()
            .map(|t| t.into())
            .collect::<Vec<SignatureVerifiedTransaction>>();

        let auxiliary_info = persisted_aux_info
            .iter()
            .take((end_version - begin_version) as usize)
            .map(|persisted_aux_info| AuxiliaryInfo::new(*persisted_aux_info, None))
            .collect::<Vec<_>>();
        // State sync executor shouldn't have block gas limit.
        let execution_output = DoGetExecutionOutput::by_transaction_execution::<V>(
            &V::new(),
            txns.into(),
            auxiliary_info,
            &parent_state,
            state_view,
            BlockExecutorConfigFromOnchain::new_no_block_limit(),
            TransactionSliceMetadata::chunk(begin_version, end_version),
        )?;
```

**File:** types/src/transaction/mod.rs (L1869-1887)
```rust
    pub fn ensure_match_transaction_info(
        &self,
        version: Version,
        txn_info: &TransactionInfo,
        expected_write_set: Option<&WriteSet>,
        expected_events: Option<&[ContractEvent]>,
    ) -> Result<()> {
        const ERR_MSG: &str = "TransactionOutput does not match TransactionInfo";

        let expected_txn_status: TransactionStatus = txn_info.status().clone().into();
        ensure!(
            self.status() == &expected_txn_status,
            "{}: version:{}, status:{:?}, auxiliary data:{:?}, expected:{:?}",
            ERR_MSG,
            version,
            self.status(),
            self.auxiliary_data(),
            expected_txn_status,
        );
```

**File:** storage/backup/backup-cli/src/coordinators/replay_verify.rs (L100-103)
```rust
    async fn run_impl(self) -> Result<(), ReplayError> {
        AptosVM::set_concurrency_level_once(self.replay_concurrency_level);
        set_timed_feature_override(TimedFeatureOverride::Replay);

```

**File:** types/src/on_chain_config/timed_features.rs (L42-65)
```rust
pub enum TimedFeatureOverride {
    Replay,
    Testing,
}

impl TimedFeatureOverride {
    #[allow(unused, clippy::match_single_binding)]
    const fn get_override(&self, flag: TimedFeatureFlag) -> Option<bool> {
        use TimedFeatureFlag::*;
        use TimedFeatureOverride::*;

        Some(match self {
            Replay => match flag {
                _LimitTypeTagSize => true,
                _ModuleComplexityCheck => true,
                // Add overrides for replay here.
                _ => return None,
            },
            Testing => match flag {
                EntryCompatibility => true,
                _ => return None, // Activate all flags
            },
        })
    }
```

**File:** execution/executor-types/src/lib.rs (L181-188)
```rust
pub enum VerifyExecutionMode {
    NoVerify,
    Verify {
        txns_to_skip: Arc<BTreeSet<Version>>,
        lazy_quit: bool,
        seen_error: Arc<AtomicBool>,
    },
}
```

**File:** aptos-move/replay-benchmark/src/overrides.rs (L91-114)
```rust
    pub fn get_state_override(&self, state_view: &impl StateView) -> HashMap<StateKey, StateValue> {
        let mut state_override = HashMap::new();

        // Enable/disable features.
        if !self.additional_enabled_features.is_empty()
            || !self.additional_disabled_features.is_empty()
        {
            let (features_state_key, features_state_value) =
                config_override::<Features, _>(state_view, |features| {
                    for feature in &self.additional_enabled_features {
                        if features.is_enabled(*feature) {
                            error!("Feature {:?} is already enabled", feature);
                        }
                        features.enable(*feature);
                    }
                    for feature in &self.additional_disabled_features {
                        if !features.is_enabled(*feature) {
                            error!("Feature {:?} is already disabled", feature);
                        }
                        features.disable(*feature);
                    }
                });
            state_override.insert(features_state_key, features_state_value);
        }
```
