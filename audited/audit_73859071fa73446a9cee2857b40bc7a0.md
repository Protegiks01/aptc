# Audit Report

## Title
CopyLoc Memory Allocation Occurs Before Memory Quota Validation Leading to Potential Temporary OOM

## Summary
The Move VM's `CopyLoc` instruction performs deep memory allocation for copying values (including closures with large captured vectors) before checking whether the memory quota would be exceeded. This creates a window where excessive memory can be temporarily allocated before the quota check fails, potentially causing out-of-memory conditions on validator nodes. [1](#0-0) 

## Finding Description

The vulnerability exists in the instruction execution order for `CopyLoc`. When a closure containing large captured vectors is copied via `CopyLoc`, the system:

1. **First** performs the deep copy via `copy_loc()`, which calls `copy_value()` to allocate memory for all captured values [2](#0-1) 

2. **Then** charges gas and checks memory quota via `charge_copy_loc()`

The deep copy implementation recursively copies all captured values in a closure: [3](#0-2) 

The memory quota check only occurs after allocation is complete: [4](#0-3) 

A developer TODO comment explicitly acknowledges this ordering issue: [5](#0-4) 

**Attack Path:**
1. Attacker creates a closure with the maximum captured arguments (64, limited by `ClosureMask::MAX_ARGS`) [6](#0-5) 

2. Each captured argument can be a large vector (limited by gas available during `pack_closure`)
3. Store the closure in a local variable
4. Repeatedly execute `CopyLoc` on that local
5. Each copy allocates memory before quota validation, creating repeated OOM risk

## Impact Explanation

**Severity: Low** (as indicated in the security question)

This qualifies as a Low severity issue under the Aptos bug bounty program criteria:
- "Non-critical implementation bugs"
- Does not lead to consensus violations (all validators fail deterministically)
- Does not cause permanent state corruption or fund loss
- Self-limiting: execution halts with `MEMORY_LIMIT_EXCEEDED` after allocation [7](#0-6) 

However, it can cause temporary resource exhaustion on validator nodes before the error is properly caught.

## Likelihood Explanation

**Likelihood: Low-Medium**

**Limiting Factors:**
- Attacker must pay gas to create large closures initially
- Maximum 64 captured arguments enforced by closure mask
- Each captured value's size limited by gas during `pack_closure`
- Memory quota check eventually fails and halts execution
- Issue is already known to developers (TODO comment exists)

**Enabling Factors:**
- Any unprivileged transaction sender can exploit
- No special permissions required
- Window exists on every `CopyLoc` operation with closures

## Recommendation

Reorder the `CopyLoc` instruction execution to charge gas and validate memory quota **before** performing the copy operation, consistent with how `ReadRef` is implemented: [8](#0-7) 

**Proposed fix for CopyLoc:**
```rust
Instruction::CopyLoc(idx) => {
    // Get a view of the local for gas charging WITHOUT copying
    let local_view = self.locals.view_loc(*idx as usize)?;
    gas_meter.charge_copy_loc(&local_view)?;
    // Now perform the actual copy after quota validation
    let local = self.locals.copy_loc(*idx as usize)?;
    interpreter.operand_stack.push(local)?;
}
```

This requires implementing a `view_loc()` method that provides a `ValueView` without copying the value.

## Proof of Concept

```move
module 0x1::closure_oom_test {
    public fun exploit() {
        // Create large vectors to capture
        let v1 = vector::empty<u128>();
        let i = 0;
        while (i < 1000) {
            vector::push_back(&mut v1, (i as u128));
            i = i + 1;
        };
        
        // Create more large vectors up to the 64 argument limit
        let v2 = copy v1;
        let v3 = copy v1;
        // ... (repeat for up to 64 captured values)
        
        // Create closure capturing all large vectors
        let closure = |x: u64| -> u64 {
            // Use captured vectors to ensure they're included
            let _ = &v1;
            let _ = &v2;
            let _ = &v3;
            x + 1
        };
        
        // Store in local
        let local_closure = closure;
        
        // Repeatedly copy the closure
        // Each copy allocates memory BEFORE quota check
        let i = 0;
        while (i < 100) {
            let copy1 = copy local_closure; // Memory allocated here
            let copy2 = copy local_closure; // Memory allocated here
            let copy3 = copy local_closure; // Memory allocated here
            // Eventually hits MEMORY_LIMIT_EXCEEDED, but after allocations
            i = i + 1;
        };
    }
}
```

**Note:** This PoC demonstrates the vulnerability conceptually. Actual exploitation depends on gas limits and memory quotas configured in the specific Aptos network deployment.

### Citations

**File:** third_party/move/move-vm/runtime/src/interpreter.rs (L2165-2169)
```rust
                    Instruction::CopyLoc(idx) => {
                        // TODO(Gas): We should charge gas before copying the value.
                        let local = self.locals.copy_loc(*idx as usize)?;
                        gas_meter.charge_copy_loc(&local)?;
                        interpreter.operand_stack.push(local)?;
```

**File:** third_party/move/move-vm/runtime/src/interpreter.rs (L2566-2571)
```rust
                    Instruction::ReadRef => {
                        let reference = interpreter.operand_stack.pop_as::<Reference>()?;
                        gas_meter.charge_read_ref(reference.value_view())?;
                        let value = reference.read_ref()?;
                        interpreter.operand_stack.push(value)?;
                    },
```

**File:** third_party/move/move-vm/types/src/values/values_impl.rs (L617-623)
```rust
            ClosureValue(Closure(fun, captured)) => {
                let captured = captured
                    .iter()
                    .map(|v| v.copy_value(depth + 1, max_depth))
                    .collect::<PartialVMResult<_>>()?;
                ClosureValue(Closure(fun.clone_dyn()?, Box::new(captured)))
            },
```

**File:** third_party/move/move-vm/types/src/values/values_impl.rs (L2352-2362)
```rust
    pub fn copy_loc(&self, idx: usize) -> PartialVMResult<Value> {
        let locals = self.0.borrow();
        match locals.get(idx) {
            Some(Value::Invalid) => Err(PartialVMError::new(
                StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR,
            )
            .with_message(format!("cannot copy invalid value at index {}", idx))),
            Some(v) => Ok(v.copy_value(1, Some(DEFAULT_MAX_VM_VALUE_NESTED_DEPTH))?),
            None => Err(Self::local_index_out_of_bounds(idx, locals.len())),
        }
    }
```

**File:** aptos-move/aptos-memory-usage-tracker/src/lib.rs (L47-59)
```rust
    #[inline]
    fn use_heap_memory(&mut self, amount: AbstractValueSize) -> PartialVMResult<()> {
        if self.feature_version >= 3 {
            match self.remaining_memory_quota.checked_sub(amount) {
                Some(remaining_quota) => {
                    self.remaining_memory_quota = remaining_quota;
                    Ok(())
                },
                None => {
                    self.remaining_memory_quota = 0.into();
                    Err(PartialVMError::new(StatusCode::MEMORY_LIMIT_EXCEEDED))
                },
            }
```

**File:** aptos-move/aptos-memory-usage-tracker/src/lib.rs (L671-679)
```rust
    fn charge_copy_loc_cached(
        &mut self,
        stack_size: AbstractValueSize,
        heap_size: AbstractValueSize,
    ) -> PartialVMResult<()> {
        self.use_heap_memory(heap_size)?;

        self.base.charge_copy_loc_cached(stack_size, heap_size)
    }
```

**File:** third_party/move/move-core/types/src/function.rs (L43-44)
```rust
    /// stack than this number.
    pub const MAX_ARGS: usize = 64;
```
