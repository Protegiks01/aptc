# Audit Report

## Title
Unicode Homoglyph and Zero-Width Character Validation Bypass in Token Collection Names

## Summary
The Aptos token frameworks (both Token V1 and Token V2) do not validate collection and token names against Unicode homoglyphs or zero-width characters. This allows attackers to create collections with names that are visually identical to legitimate collections but have different byte representations, enabling phishing attacks where users may inadvertently interact with malicious collections.

## Finding Description

The vulnerability exists in both token standards implemented in the Aptos framework:

**Token V1 (`aptos_token::token`)**: The `create_collection` function only validates the byte length of collection names but performs no content validation. [1](#0-0) 

The uniqueness check uses byte-based string comparison in the table lookup. [2](#0-1) 

**Token V2 (`aptos_token_objects::collection`)**: Similarly validates only byte length. [3](#0-2) 

The collection seed is created directly from the raw bytes without normalization. [4](#0-3) 

**Root Cause**: The Move standard library's `String::length()` function returns byte length, not character count. [5](#0-4) 

This design allows attackers to craft collection names using:
- **Unicode homoglyphs**: Characters from different scripts that look identical (e.g., Latin 'A' U+0041 vs Cyrillic 'А' U+0410)
- **Zero-width characters**: Invisible characters like zero-width space (U+200B) that affect byte representation but not visual rendering

**Attack Scenario**:
1. Legitimate collection exists: `"AptosMonkeys"` at creator address `0xabc123`
2. Attacker creates: `"АptоsМоnkeys"` using Cyrillic homoglyphs (А=U+0410, о=U+043E, М=U+041C)
3. Visually identical to users but byte-different: `0x41...` vs `0xD090...`
4. Passes validation: byte length within 128-byte limit
5. Treated as distinct collection: different table key (V1) or object address (V2)
6. Attacker mints fake tokens under the homoglyph collection
7. Users purchase "AptosMonkeys" tokens, receiving worthless fakes

## Impact Explanation

This vulnerability is correctly classified as **Medium Severity** per Aptos bug bounty criteria for the following reasons:

1. **Limited funds loss**: Users who are deceived by visually identical collection names may purchase counterfeit tokens, resulting in direct financial loss. However, the impact is bounded to individual user mistakes rather than protocol-wide compromise.

2. **No consensus violation**: The blockchain operates deterministically and correctly—different byte sequences are properly recognized as distinct collections. The vulnerability is in the lack of user protection, not protocol correctness.

3. **Social engineering component**: While the attack requires user deception, the on-chain validation failure to prevent homoglyph collections is the enabling factor. This is distinct from pure off-chain phishing—the protocol actively allows the attack surface to exist.

4. **Not Critical or High severity** because:
   - No validator node compromise
   - No consensus safety violations
   - No protocol-level invariant breakage
   - Requires per-user social engineering (not automated exploitation)

## Likelihood Explanation

**Likelihood: High**

This vulnerability is highly likely to be exploited because:

1. **Zero technical barriers**: Any user can create collections with homoglyphs by simply including Unicode characters in collection names. No special permissions or complex exploits required.

2. **Low cost**: Only requires standard transaction gas fees to create malicious collections.

3. **Well-known attack pattern**: Unicode homoglyph attacks are established in web security (domain squatting, phishing emails). Attackers will naturally attempt this vector.

4. **High value targets**: Popular NFT collections attract significant trading volume, making them lucrative phishing targets.

5. **Detection difficulty**: Users typically cannot distinguish homoglyphs in standard UI fonts without specialized tools.

6. **No current prevention**: The on-chain validation provides zero protection against this attack.

## Recommendation

Implement Unicode validation for collection and token names to prevent homoglyph and zero-width character exploitation:

**Option 1: Restrict to ASCII subset** (strictest, follows Move identifier pattern)
```move
public fun validate_name(name: &String) {
    let bytes = name.bytes();
    let i = 0;
    let len = bytes.length();
    while (i < len) {
        let byte = *vector::borrow(bytes, i);
        // Allow only printable ASCII (0x20-0x7E)
        assert!(byte >= 0x20 && byte <= 0x7E, error::invalid_argument(EINVALID_NAME_CHARACTERS));
        i = i + 1;
    };
}
```

**Option 2: Implement Unicode normalization** (more flexible)
```move
native fun normalize_nfc(s: &String): String;  // NFC normalization
native fun contains_zero_width_chars(s: &String): bool;

public fun validate_name(name: &String) {
    assert!(!contains_zero_width_chars(name), error::invalid_argument(EZERO_WIDTH_CHARS_NOT_ALLOWED));
    let normalized = normalize_nfc(name);
    // Use normalized form for uniqueness checks
}
```

**Option 3: Add confusable detection** (balanced approach)
```move
native fun is_confusable(s: &String): bool;  // Check against Unicode confusables data

public fun validate_name(name: &String) {
    assert!(!is_confusable(name), error::invalid_argument(ECONFUSABLE_CHARACTERS_DETECTED));
}
```

Apply validation in collection creation functions:
- Token V1: Add validation before line 1169 in `create_collection()`
- Token V2: Add validation before line 325 in `create_collection_internal()`
- Token names: Add similar validation in token creation functions

## Proof of Concept

```move
#[test_only]
module test_homoglyph_attack {
    use std::string;
    use aptos_token::token;
    use aptos_framework::account;
    
    #[test(creator = @0xCAFE)]
    fun test_homoglyph_collection_creation(creator: &signer) {
        account::create_account_for_test(@0xCAFE);
        
        // Create legitimate collection with Latin characters
        let latin_name = string::utf8(b"AptosMonkeys");
        token::create_collection(
            creator,
            latin_name,
            string::utf8(b"Legitimate collection"),
            string::utf8(b"https://example.com"),
            1000,
            vector[false, false, false]
        );
        
        // Create malicious collection with Cyrillic homoglyphs
        // Uses Cyrillic 'А' (U+0410) instead of Latin 'A' (U+0041)
        // Uses Cyrillic 'о' (U+043E) instead of Latin 'o' (U+006F)
        let cyrillic_name = string::utf8(b"\xD0\x90ptos\xD0\x9Conkeys"); // "АptosМonkeys"
        token::create_collection(
            creator,
            cyrillic_name,
            string::utf8(b"Fake collection"),
            string::utf8(b"https://evil.com"),
            1000,
            vector[false, false, false]
        );
        
        // Both collections exist with visually identical names
        // latin_name bytes:    [0x41, 0x70, 0x74, 0x6F, 0x73, ...]
        // cyrillic_name bytes: [0xD0, 0x90, 0x70, 0x74, 0x6F, 0x73, ...]
        // Different byte sequences pass as distinct collections
        
        // Users seeing both in a UI cannot distinguish them
        // Attacker can mint tokens under the fake collection
        // Users may purchase fake tokens believing they're legitimate
    }
    
    #[test(creator = @0xCAFE)]
    fun test_zero_width_character_attack(creator: &signer) {
        account::create_account_for_test(@0xCAFE);
        
        // Create collection with zero-width space (U+200B)
        let name_with_zwsp = string::utf8(b"Aptos\xE2\x80\x8BMonkeys"); // "Aptos​Monkeys"
        token::create_collection(
            creator,
            name_with_zwsp,
            string::utf8(b"Collection with invisible character"),
            string::utf8(b"https://example.com"),
            1000,
            vector[false, false, false]
        );
        
        // The zero-width space is invisible in most UIs
        // But changes the byte representation and thus the collection identity
        // Can be used to create multiple visually identical collections
    }
}
```

**Notes**:
- The vulnerability affects both collection names and token names through similar validation paths
- The Move identifier system explicitly avoids Unicode to prevent these attacks [6](#0-5) , but this protection doesn't extend to String values
- Frontend applications and indexers should implement additional client-side warnings, but on-chain validation is the authoritative defense layer
- Token data IDs use collection names directly as keys, making the byte-level distinction the source of the vulnerability [7](#0-6)

### Citations

**File:** aptos-move/framework/aptos-token/sources/token.move (L177-184)
```text
    struct TokenDataId has copy, drop, store {
        /// The address of the creator, eg: 0xcafe
        creator: address,
        /// The name of collection; this is unique under the same account, eg: "Aptos Animal Collection"
        collection: String,
        /// The name of the token; this is the same as the name field of TokenData
        name: String,
    }
```

**File:** aptos-move/framework/aptos-token/sources/token.move (L1169-1170)
```text
        assert!(name.length() <= MAX_COLLECTION_NAME_LENGTH, error::invalid_argument(ECOLLECTION_NAME_TOO_LONG));
        assert!(uri.length() <= MAX_URI_LENGTH, error::invalid_argument(EURI_TOO_LONG));
```

**File:** aptos-move/framework/aptos-token/sources/token.move (L1187-1190)
```text
        assert!(
            !collection_data.contains(name),
            error::already_exists(ECOLLECTION_ALREADY_EXISTS),
        );
```

**File:** aptos-move/framework/aptos-token-objects/sources/collection.move (L325-327)
```text
        assert!(name.length() <= MAX_COLLECTION_NAME_LENGTH, error::out_of_range(ECOLLECTION_NAME_TOO_LONG));
        assert!(uri.length() <= MAX_URI_LENGTH, error::out_of_range(EURI_TOO_LONG));
        assert!(description.length() <= MAX_DESCRIPTION_LENGTH, error::out_of_range(EDESCRIPTION_TOO_LONG));
```

**File:** aptos-move/framework/aptos-token-objects/sources/collection.move (L367-370)
```text
    public fun create_collection_seed(name: &String): vector<u8> {
        assert!(name.length() <= MAX_COLLECTION_NAME_LENGTH, error::out_of_range(ECOLLECTION_NAME_TOO_LONG));
        *name.bytes()
    }
```

**File:** aptos-move/framework/move-stdlib/sources/string.move (L47-50)
```text
    /// Returns the length of this string, in bytes.
    public fun length(self: &String): u64 {
        self.bytes.length()
    }
```

**File:** third_party/move/move-core/types/src/identifier.rs (L20-23)
```rust
//! Allowed identifiers are currently restricted to ASCII due to unresolved issues with Unicode
//! normalization. See [Rust issue #55467](https://github.com/rust-lang/rust/issues/55467) and the
//! associated RFC for some discussion. Unicode identifiers may eventually be supported once these
//! issues are worked out.
```
