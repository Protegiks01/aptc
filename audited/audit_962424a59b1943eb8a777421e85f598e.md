# Audit Report

## Title
Depth Check Bypass via Feature Flag Disablement Enables Stack Overflow Resource Exhaustion

## Summary
The Move VM's depth checking mechanism can be completely bypassed when the `ENABLE_FUNCTION_VALUES` feature flag is disabled on networks running gas feature version ≥ 1.38. This creates a critical gap where neither type-based nor value-based depth validation occurs during value serialization/deserialization in native functions, enabling attackers to craft deeply nested values that cause stack overflow and validator node crashes.

## Finding Description
The Aptos Move VM implements two complementary depth checking systems to prevent stack overflow from deeply nested values:

1. **Type depth checking** (TypeDepthChecker) - validates type instantiation depth
2. **Value depth checking** (runtime checks) - validates actual value nesting depth

A logic vulnerability exists in how these systems interact with feature flags: [1](#0-0) 

When `ENABLE_FUNCTION_VALUES` is disabled, `enable_depth_checks` becomes `false`. This causes the `SafeNativeContext::max_value_nest_depth()` method to return `None`: [2](#0-1) 

Simultaneously, on networks running gas feature version ≥ 1.38 (RELEASE_V1_38 = 42), `propagate_dependency_limit_error` is set to `true`: [3](#0-2) 

This disables type depth checking by setting `maybe_max_depth` to `None`: [4](#0-3) 

When type depth checking encounters `None`, it returns early without validation: [5](#0-4) 

Native functions pass the `None` value to `ValueSerDeContext` for serialization/deserialization: [6](#0-5) 

The `ValueSerDeContext::check_depth()` method bypasses validation when `max_value_nested_depth` is `None`: [7](#0-6) 

**Attack Path:**
1. Governance proposal disables `ENABLE_FUNCTION_VALUES` via the feature flag management system
2. Network continues running with gas feature version ≥ 1.38
3. Attacker crafts transaction with deeply nested Move values (e.g., recursive vector<vector<vector<...>>>)
4. Transaction invokes native function that serializes the value (e.g., `0x1::event::emit`)
5. Serialization recursively processes nested structure without depth checks
6. Stack overflow crashes validator node

Feature flags can be disabled through governance: [8](#0-7) [9](#0-8) 

## Impact Explanation
**Severity: High ($50,000)**

This vulnerability enables resource exhaustion attacks leading to validator node crashes and network availability issues:

1. **Validator Node Slowdowns/Crashes** - Deeply nested values cause stack overflow, crashing validator processes and requiring restarts
2. **Liveness Impact** - If multiple validators process the malicious transaction simultaneously, network liveness degrades
3. **Deterministic Execution Violation** - Different validators may crash at different stack depths depending on their system configuration, breaking consensus invariant #1

The vulnerability does NOT result in:
- Direct fund loss or theft
- Permanent network partition
- Consensus safety violations (double-spending)

Therefore, it qualifies as **High Severity** per Aptos bug bounty criteria: "Validator node slowdowns, API crashes, Significant protocol violations."

## Likelihood Explanation
**Likelihood: Medium-Low**

The vulnerability requires specific conditions:
1. Network must be running gas feature version ≥ 1.38 (currently at v45, so satisfied)
2. `ENABLE_FUNCTION_VALUES` must be disabled via governance
3. Attacker must craft transaction with deeply nested values

While `ENABLE_FUNCTION_VALUES` is currently enabled by default in production, it could be disabled in scenarios such as:
- Emergency rollback due to function values bug
- Governance decision to temporarily disable feature
- Accidental misconfiguration during network upgrade

The vulnerability represents a **latent logic bug** where disabling one feature unintentionally disables a critical safety mechanism. Even if unlikely to trigger in normal operation, such architectural flaws should be fixed.

## Recommendation
Implement defense-in-depth by enforcing depth limits regardless of feature flag state:

**Option 1: Always enforce value depth checks**
Modify `SafeNativeContext::max_value_nest_depth()` to always return the configured limit:

```rust
pub fn max_value_nest_depth(&self) -> Option<u64> {
    // Always return the configured depth limit regardless of enable_depth_checks
    // to prevent resource exhaustion attacks
    self.module_storage()
        .runtime_environment()
        .vm_config()
        .max_value_nest_depth
}
```

**Option 2: Keep type depth checking as fallback**
Modify TypeDepthChecker to use `max_value_nest_depth` when `propagate_dependency_limit_error` is true AND `enable_depth_checks` is false:

```rust
let maybe_max_depth = if vm_config.propagate_dependency_limit_error {
    // If value depth checks are disabled, keep type checking as fallback
    if !vm_config.enable_depth_checks {
        vm_config.max_value_nest_depth
    } else {
        None  // Value checks handle it
    }
} else {
    vm_config.max_value_nest_depth
};
```

**Option 3: Prevent feature flag combination**
Add validation in `aptos_prod_vm_config()` to prevent the unsafe configuration:

```rust
// Ensure depth checking is always active
assert!(
    enable_depth_checks || !config.propagate_dependency_limit_error,
    "Cannot disable depth checks while propagate_dependency_limit_error is enabled"
);
```

**Recommendation: Implement Option 1** (simplest and most robust).

## Proof of Concept

The following demonstrates the vulnerability path (conceptual, as actual exploitation requires governance action):

```rust
// Reproduction steps:
// 1. Start Aptos network with gas_feature_version >= 42
// 2. Submit governance proposal to disable ENABLE_FUNCTION_VALUES
// 3. Execute transaction with deeply nested value

module attacker::overflow {
    use std::vector;
    use std::event;

    struct NestedEvent has copy, drop, store {
        data: vector<vector<vector<vector<u8>>>>  // 4 levels
    }

    public entry fun trigger_overflow() {
        // Create deeply nested structure (>128 levels in practice)
        let mut outer = vector::empty();
        let mut i = 0;
        while (i < 200) {  // Exceeds DEFAULT_MAX_VM_VALUE_NESTED_DEPTH = 128
            let inner = vector::singleton(vector::singleton(
                vector::singleton(vector::singleton(i))
            ));
            vector::push_back(&mut outer, inner);
            i = i + 1;
        };
        
        // Emit event - triggers serialization without depth check
        let evt = NestedEvent { data: outer };
        event::emit(evt);  // Stack overflow here if depth checks disabled
    }
}
```

**Verification:**
1. Confirm `enable_depth_checks` is false when `ENABLE_FUNCTION_VALUES` disabled
2. Confirm `context.max_value_nest_depth()` returns `None`
3. Confirm `ValueSerDeContext::check_depth()` returns `Ok(())` without validation
4. Observe stack overflow in event serialization

## Notes
- The constant `DEFAULT_MAX_VM_VALUE_NESTED_DEPTH = 128` itself is safe and cannot be directly manipulated
- The vulnerability is in the **conditional application** of the depth limit, not the limit value itself
- Current production has both flags set correctly, but the architectural flaw creates unnecessary risk
- Fix should be applied before any scenario where `ENABLE_FUNCTION_VALUES` might be disabled

### Citations

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L221-227)
```rust
    // Value runtime depth checks have been introduced together with function values and are only
    // enabled when the function values are enabled. Previously, checks were performed over types
    // to bound the value depth (checking the size of a packed struct type bounds the value), but
    // this no longer applies once function values are enabled. With function values, types can be
    // shallow while the value can be deeply nested, thanks to captured arguments not visible in a
    // type. Hence, depth checks have been adjusted to operate on values.
    let enable_depth_checks = features.is_enabled(FeatureFlag::ENABLE_FUNCTION_VALUES);
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L262-262)
```rust
        propagate_dependency_limit_error: gas_feature_version >= RELEASE_V1_38,
```

**File:** aptos-move/aptos-native-interface/src/context.rs (L174-186)
```rust
    pub fn max_value_nest_depth(&self) -> Option<u64> {
        self.module_storage()
            .runtime_environment()
            .vm_config()
            .enable_depth_checks
            .then(|| {
                self.module_storage()
                    .runtime_environment()
                    .vm_config()
                    .max_value_nest_depth
            })
            .flatten()
    }
```

**File:** third_party/move/move-vm/runtime/src/storage/ty_depth_checker.rs (L54-67)
```rust
    pub(crate) fn new(struct_definition_loader: &'a T) -> Self {
        let vm_config = struct_definition_loader.runtime_environment().vm_config();
        // Gate by other config which will be enabled in 1.38. Will be removed after it is enabled.
        let maybe_max_depth = if vm_config.propagate_dependency_limit_error {
            None
        } else {
            vm_config.max_value_nest_depth
        };
        Self {
            struct_definition_loader,
            maybe_max_depth,
            formula_cache: RefCell::new(HashMap::new()),
        }
    }
```

**File:** third_party/move/move-vm/runtime/src/storage/ty_depth_checker.rs (L73-82)
```rust
    pub(crate) fn check_depth_of_type(
        &self,
        gas_meter: &mut impl DependencyGasMeter,
        traversal_context: &mut TraversalContext,
        ty: &Type,
    ) -> PartialVMResult<()> {
        let max_depth = match self.maybe_max_depth {
            Some(max_depth) => max_depth,
            None => return Ok(()),
        };
```

**File:** aptos-move/framework/src/natives/event.rs (L125-130)
```rust
    let function_value_extension = context.function_value_extension();
    let max_value_nest_depth = context.max_value_nest_depth();
    let blob = ValueSerDeContext::new(max_value_nest_depth)
        .with_delayed_fields_serde()
        .with_func_args_deserialization(&function_value_extension)
        .serialize(&msg, &layout)?
```

**File:** third_party/move/move-vm/types/src/value_serde.rs (L149-157)
```rust
    pub(crate) fn check_depth(&self, depth: u64) -> PartialVMResult<()> {
        if self
            .max_value_nested_depth
            .is_some_and(|max_depth| depth > max_depth)
        {
            return Err(PartialVMError::new(StatusCode::VM_MAX_VALUE_DEPTH_REACHED));
        }
        Ok(())
    }
```

**File:** aptos-move/framework/move-stdlib/sources/configs/features.move (L667-671)
```text
    /// Whether function values are enabled.
    /// Lifetime: transient
    ///
    /// We do not expect use from Move, so for now only for documentation purposes here
    const ENABLE_FUNCTION_VALUES: u64 = 89;
```

**File:** types/src/on_chain_config/aptos_features.rs (L258-258)
```rust
            FeatureFlag::ENABLE_FUNCTION_VALUES,
```
