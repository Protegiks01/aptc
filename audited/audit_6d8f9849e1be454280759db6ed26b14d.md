# Audit Report

## Title
Critical Waypoint Validation Bypass in Database Restoration Allowing Forged Blockchain State

## Summary
The `RestoreCoordinator` in the database restoration process allows complete bypass of waypoint validation when the `--skip-epoch-endings` flag is used. Combined with insufficient waypoint verification during node startup, this enables an attacker to restore a node with arbitrary forged blockchain state that is never cryptographically validated against any trusted anchor.

## Finding Description

The vulnerability exists across three interconnected validation failures:

**Failure 1: Epoch History Validation Bypass During Restore**

The `RestoreCoordinator::run_impl()` function conditionally skips epoch ending restoration based on the `skip_epoch_endings` flag: [1](#0-0) 

When `skip_epoch_endings` is true, the `epoch_history` is set to `None`. This epoch history object is responsible for validating ledger infos against trusted waypoints through `EpochHistory::verify_ledger_info()`: [2](#0-1) 

Both `StateSnapshotRestoreController` and `TransactionRestoreBatchController` only validate ledger infos when epoch_history is present: [3](#0-2) [4](#0-3) 

The flag is explicitly marked as "used for debugging" but remains exposed: [5](#0-4) 

**Failure 2: Node Startup Bypasses Waypoint Check for Non-Genesis Database**

When a node starts with a restored database, `maybe_bootstrap()` only validates the waypoint if the database version matches `waypoint.version() - 1`: [6](#0-5) 

If the database already contains data beyond genesis (e.g., restored to version 1000 with a genesis waypoint at version 0), this check evaluates to false and waypoint verification is **completely skipped**.

**Failure 3: State Sync Incorrectly Marks Waypoint as Verified Without Hash Check**

During state sync bootstrapping, `verify_waypoint_is_satisfiable()` marks the waypoint as verified if the database version is simply greater than or equal to the waypoint version, **without verifying the ledger info hash at the waypoint version**: [7](#0-6) 

The proper waypoint verification requires checking both version AND hash: [8](#0-7) 

**Complete Attack Path:**

1. Attacker creates malicious backup with forged ledger infos, transactions, and state at version 10000
2. Attacker runs: `aptos-db-tool restore bootstrap-db --skip-epoch-endings --target-db-dir /path/to/db --trust-waypoint 0:<genesis_hash> <backup_location>`
3. All state snapshots and transactions are restored **without any waypoint or signature validation**
4. Node starts with the restored database
5. `maybe_bootstrap()` sees database version 10000 != genesis waypoint version 0, skips validation
6. State sync's `verify_waypoint_is_satisfiable()` sees version 10000 >= waypoint version 0, incorrectly marks waypoint as verified
7. Node runs with completely forged blockchain state that was never validated

## Impact Explanation

**Critical Severity** - This vulnerability breaks fundamental blockchain security invariants:

- **Consensus Safety Violation**: A malicious node operates with a completely different view of the blockchain than honest nodes, violating the consensus safety guarantee that < 1/3 Byzantine validators cannot cause chain splits
- **State Integrity Bypass**: All cryptographic validation (waypoints, BLS signatures, Merkle proofs against trusted roots) is completely bypassed
- **Validator Compromise**: If deployed on a validator node, it could vote on blocks based on forged state, potentially causing consensus failures or network partitions
- **Non-Recoverable State Corruption**: The forged state appears valid to the node and would require manual intervention or hardfork to detect and correct

This meets the **Critical Severity** criteria: "Consensus/Safety violations" and potentially "Non-recoverable network partition (requires hardfork)".

## Likelihood Explanation

**High Likelihood:**
- The `--skip-epoch-endings` flag is documented and easily accessible to any operator
- The attack requires no special privileges beyond access to run the restore tool
- The vulnerability is in production code, not behind any feature flags
- No warnings or safeguards prevent using `--skip-epoch-endings` in production environments
- The exploitation steps are straightforward and don't require deep protocol knowledge

## Recommendation

**Immediate Mitigations:**

1. **Remove the `--skip-epoch-endings` flag entirely** or restrict it to test builds only
2. **Always require trusted waypoints during restore** - make waypoint validation mandatory
3. **Fix `verify_waypoint_is_satisfiable()` to actually verify the waypoint hash** when the database version exceeds the waypoint version

**Code Fix for `verify_waypoint_is_satisfiable()`:**

```rust
fn verify_waypoint_is_satisfiable(
    &mut self,
    global_data_summary: &GlobalDataSummary,
) -> Result<(), Error> {
    let waypoint = self.driver_configuration.waypoint;
    let waypoint_version = waypoint.version();
    
    // If our storage has already synced beyond our waypoint, verify the waypoint
    let latest_ledger_info = utils::fetch_latest_synced_ledger_info(self.storage.clone())?;
    if latest_ledger_info.ledger_info().version() >= waypoint_version {
        // CRITICAL FIX: Actually fetch and verify the ledger info at waypoint version
        match self.storage.get_epoch_ending_ledger_info(waypoint_version) {
            Ok(ledger_info_at_waypoint) => {
                // Verify the hash matches the trusted waypoint
                waypoint.verify(ledger_info_at_waypoint.ledger_info())?;
                self.verified_epoch_states.set_verified_waypoint(waypoint_version);
                return Ok(());
            }
            Err(_) => {
                return Err(Error::VerificationError(format!(
                    "Database is beyond waypoint version {}, but no ledger info found at that version to verify waypoint",
                    waypoint_version
                )));
            }
        }
    }
    
    // Continue with existing logic for advertised data check...
}
```

**Additional Safeguards:**

1. Add runtime check in `RestoreCoordinator` to require `trusted_waypoints` when restoring
2. Add warning logs when `skip_epoch_endings` is used
3. Validate that restored database state can be verified against at least one trusted waypoint before allowing node startup

## Proof of Concept

```bash
#!/bin/bash
# PoC: Restore database with forged state bypassing all validation

# Step 1: Create a malicious backup (details omitted for brevity)
# The backup contains forged ledger infos, state, and transactions

# Step 2: Restore with skip-epoch-endings flag
aptos-db-tool restore bootstrap-db \
    --target-db-dir /tmp/malicious_db \
    --metadata-cache-dir /tmp/backup_metadata \
    --skip-epoch-endings \
    --trust-waypoint "0:0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef" \
    local-fs \
    --dir /path/to/malicious/backup

# Step 3: Start node with the restored database
# The node will accept the forged state without any validation
aptos-node -f /path/to/node/config.yaml

# Result: Node runs with completely forged blockchain state
# - No waypoint validation during restore (skipped via --skip-epoch-endings)
# - No waypoint validation at startup (DB version check fails)
# - No waypoint validation during state sync (only version check, no hash check)
```

**Validation Steps:**
1. Create two backups: one legitimate and one with modified ledger info hashes
2. Restore both using `--skip-epoch-endings`
3. Start nodes with both databases
4. Observe that both nodes start successfully despite having different state roots
5. Verify the forged node's state differs from honest nodes by querying the same transaction version

## Notes

This vulnerability represents a complete bypass of Aptos's trusted waypoint security model. Waypoints are designed to be the fundamental trust anchor for nodes bootstrapping or recovering from backups. The ability to bypass this validation breaks the security assumption that all nodes can verify they're on the correct chain through cryptographic validation against trusted checkpoints.

The `--skip-epoch-endings` flag was likely intended only for debugging scenarios but was left in production code without adequate safeguards. This is particularly dangerous because node operators routinely perform database restorations from backups, and the flag's existence in the CLI makes it easily discoverable and usable by any operator without understanding the security implications.

### Citations

**File:** storage/backup/backup-cli/src/coordinators/restore.rs (L42-43)
```rust
    #[clap(long, help = "Skip restoring epoch ending info, used for debugging.")]
    pub skip_epoch_endings: bool,
```

**File:** storage/backup/backup-cli/src/coordinators/restore.rs (L219-231)
```rust
        let epoch_history = if !self.skip_epoch_endings {
            Some(Arc::new(
                EpochHistoryRestoreController::new(
                    epoch_handles,
                    self.global_opt.clone(),
                    self.storage.clone(),
                )
                .run()
                .await?,
            ))
        } else {
            None
        };
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L294-304)
```rust
        } else if let Some(wp_trusted) = self
            .trusted_waypoints
            .get(&li_with_sigs.ledger_info().version())
        {
            let wp_li = Waypoint::new_any(li_with_sigs.ledger_info());
            ensure!(
                *wp_trusted == wp_li,
                "Waypoints don't match. In backup: {}, trusted: {}",
                wp_li,
                wp_trusted,
            );
```

**File:** storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs (L137-139)
```rust
        if let Some(epoch_history) = self.epoch_history.as_ref() {
            epoch_history.verify_ledger_info(&li)?;
        }
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L152-154)
```rust
        if let Some(epoch_history) = epoch_history {
            epoch_history.verify_ledger_info(&ledger_info)?;
        }
```

**File:** execution/executor/src/db_bootstrapper/mod.rs (L53-59)
```rust
    let ledger_summary = db.reader.get_pre_committed_ledger_summary()?;
    // if the waypoint is not targeted with the genesis txn, it may be either already bootstrapped, or
    // aiming for state sync to catch up.
    if ledger_summary.version().map_or(0, |v| v + 1) != waypoint.version() {
        info!(waypoint = %waypoint, "Skip genesis txn.");
        return Ok(None);
    }
```

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L884-890)
```rust
        // If our storage has already synced beyond our waypoint, nothing needs to be checked
        let latest_ledger_info = utils::fetch_latest_synced_ledger_info(self.storage.clone())?;
        let waypoint_version = self.driver_configuration.waypoint.version();
        if latest_ledger_info.ledger_info().version() >= waypoint_version {
            self.verified_epoch_states
                .set_verified_waypoint(waypoint_version);
            return Ok(());
```

**File:** types/src/waypoint.rs (L62-79)
```rust
    pub fn verify(&self, ledger_info: &LedgerInfo) -> Result<()> {
        ensure!(
            ledger_info.version() == self.version(),
            "Waypoint version mismatch: waypoint version = {}, given version = {}",
            self.version(),
            ledger_info.version()
        );
        let converter = Ledger2WaypointConverter::new(ledger_info);
        ensure!(
            converter.hash() == self.value(),
            format!(
                "Waypoint value mismatch: waypoint value = {}, given value = {}",
                self.value().to_hex(),
                converter.hash().to_hex()
            )
        );
        Ok(())
    }
```
