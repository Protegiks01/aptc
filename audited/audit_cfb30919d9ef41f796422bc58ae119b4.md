# Audit Report

## Title
Malicious Governance Proposals Can Permanently Brick Aptos Network Through Unvalidated Gas Parameters

## Summary
The `gas_schedule::set_for_next_epoch()` function lacks validation of gas parameter values, allowing malicious governance proposals to set `max_bytes_per_write_op` and related parameters to zero. This causes all subsequent transactions (including recovery attempts) to fail during epilogue validation, permanently bricking the network and requiring a hard fork to recover.

## Finding Description

The vulnerability exists in the gas schedule update mechanism. When governance proposals update gas parameters via `gas_schedule::set_for_next_epoch()`, there is no validation that parameter values are within safe operational bounds. [1](#0-0) 

The function only checks that the blob is non-empty and the feature version is increasing, but explicitly notes validation is missing: [2](#0-1) 

The malicious gas parameters flow through the system:

1. **Parameter Extraction**: `ChangeSetConfigs::from_gas_params()` directly converts gas parameters without validation: [3](#0-2) 

2. **Transaction Validation**: Every transaction's epilogue creates write operations (sequence number increment, gas fee payment): [4](#0-3) 

3. **Change Set Validation**: The epilogue session validates all writes against the configured limits: [5](#0-4) 

4. **Failure Point**: When `max_bytes_per_write_op = 0`, any write operation with non-zero size fails: [6](#0-5) 

Since every transaction requires epilogue writes (Account resource for sequence number, balance updates for gas), setting these limits to zero makes ALL transactions invalid, including governance proposals that could fix the issue.

## Impact Explanation

**Critical Severity** - This vulnerability causes:

1. **Total loss of liveness/network availability**: All transaction types fail validation, making the blockchain completely non-operational
2. **Non-recoverable network partition (requires hardfork)**: No on-chain mechanism exists to recover since governance proposals themselves cannot execute
3. **Deterministic execution violation**: All validators deterministically reject all transactions based on the invalid gas parameters

The impact meets the Critical severity criteria per Aptos bug bounty:
- Total loss of liveness/network availability (✓)
- Requires hardfork to recover (✓)

## Likelihood Explanation

**Likelihood: Medium-High (given governance compromise)**

The attack requires:
- Malicious control of governance (>50% voting power)
- Knowledge of the validation gap
- Creation of a proposal with malicious gas parameters

While governance compromise is considered in the Trust Model exclusions for normal scenarios, this specific security question explicitly explores "malicious governance proposals." The missing validation represents a defense-in-depth failure - even trusted governance should not be able to accidentally or maliciously brick the network through parameter misconfiguration.

The TODO comments in the code confirm this is a known validation gap that developers intended to address.

## Recommendation

Add validation in `gas_schedule::set_for_next_epoch()` and `set_for_next_epoch_check_hash()` to enforce minimum safe values for critical gas parameters:

```move
public fun set_for_next_epoch(aptos_framework: &signer, gas_schedule_blob: vector<u8>) acquires GasScheduleV2 {
    system_addresses::assert_aptos_framework(aptos_framework);
    assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));
    let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
    
    // NEW: Validate critical parameters
    validate_gas_schedule_safety(&new_gas_schedule);
    
    if (exists<GasScheduleV2>(@aptos_framework)) {
        let cur_gas_schedule = borrow_global<GasScheduleV2>(@aptos_framework);
        assert!(
            new_gas_schedule.feature_version >= cur_gas_schedule.feature_version,
            error::invalid_argument(EINVALID_GAS_FEATURE_VERSION)
        );
    };
    config_buffer::upsert(new_gas_schedule);
}

fun validate_gas_schedule_safety(gas_schedule: &GasScheduleV2) {
    // Define minimum safe values
    const MIN_BYTES_PER_WRITE_OP: u64 = 1024; // 1KB minimum
    const MIN_BYTES_ALL_WRITE_OPS: u64 = 10240; // 10KB minimum
    const MIN_BYTES_PER_EVENT: u64 = 1024;
    const MIN_BYTES_ALL_EVENTS: u64 = 10240;
    
    // Validate each critical parameter exists and meets minimums
    let entries = &gas_schedule.entries;
    let i = 0;
    while (i < vector::length(entries)) {
        let entry = vector::borrow(entries, i);
        if (entry.key == string::utf8(b"max_bytes_per_write_op")) {
            assert!(entry.val >= MIN_BYTES_PER_WRITE_OP, error::invalid_argument(EINVALID_GAS_SCHEDULE));
        } else if (entry.key == string::utf8(b"max_bytes_all_write_ops_per_transaction")) {
            assert!(entry.val >= MIN_BYTES_ALL_WRITE_OPS, error::invalid_argument(EINVALID_GAS_SCHEDULE));
        };
        // Add similar checks for event parameters
        i = i + 1;
    };
}
```

## Proof of Concept

```move
#[test(aptos_framework = @0x1)]
#[expected_failure(abort_code = 0x..., location = aptos_framework::transaction_validation)]
fun test_malicious_gas_params_brick_network(aptos_framework: signer) {
    // 1. Create malicious gas schedule with max_bytes_per_write_op = 0
    let malicious_entries = vector::empty<GasEntry>();
    vector::push_back(&mut malicious_entries, GasEntry {
        key: string::utf8(b"max_bytes_per_write_op"),
        val: 0  // Malicious value
    });
    vector::push_back(&mut malicious_entries, GasEntry {
        key: string::utf8(b"max_bytes_all_write_ops_per_transaction"),
        val: 0  // Malicious value
    });
    
    let malicious_schedule = GasScheduleV2 {
        feature_version: 100,
        entries: malicious_entries
    };
    
    // 2. Apply malicious gas schedule (simulating governance proposal)
    gas_schedule::set_for_next_epoch(&aptos_framework, bcs::to_bytes(&malicious_schedule));
    aptos_governance::reconfigure(&aptos_framework);
    
    // 3. Try to execute ANY transaction - it will fail
    // Even a simple account creation or transfer will abort during epilogue
    // because increment_sequence_number writes to Account resource
    account::create_account_for_test(@0x999);  // This will fail with STORAGE_WRITE_LIMIT_REACHED
}
```

## Notes

This vulnerability demonstrates a critical defense-in-depth failure. While governance is generally trusted, safety-critical parameters like those controlling basic transaction validity should have validation bounds to prevent accidental or malicious misconfiguration. The TODO comments in the codebase confirm developers recognized this validation gap but it remains unaddressed, creating a single point of failure that can permanently disable the entire network.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L47-47)
```text
        // TODO(Gas): check if gas schedule is consistent
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L91-103)
```text
    public fun set_for_next_epoch(aptos_framework: &signer, gas_schedule_blob: vector<u8>) acquires GasScheduleV2 {
        system_addresses::assert_aptos_framework(aptos_framework);
        assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));
        let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
        if (exists<GasScheduleV2>(@aptos_framework)) {
            let cur_gas_schedule = borrow_global<GasScheduleV2>(@aptos_framework);
            assert!(
                new_gas_schedule.feature_version >= cur_gas_schedule.feature_version,
                error::invalid_argument(EINVALID_GAS_FEATURE_VERSION)
            );
        };
        config_buffer::upsert(new_gas_schedule);
    }
```

**File:** aptos-move/aptos-vm-types/src/storage/change_set_configs.rs (L74-84)
```rust
    fn from_gas_params(gas_feature_version: u64, gas_params: &AptosGasParameters) -> Self {
        let params = &gas_params.vm.txn;
        Self::new_impl(
            gas_feature_version,
            params.max_bytes_per_write_op.into(),
            params.max_bytes_all_write_ops_per_transaction.into(),
            params.max_bytes_per_event.into(),
            params.max_bytes_all_events_per_transaction.into(),
            params.max_write_ops_per_transaction.into(),
        )
    }
```

**File:** aptos-move/aptos-vm-types/src/storage/change_set_configs.rs (L104-107)
```rust
                let write_op_size = len + (key.size() as u64);
                if write_op_size > self.max_bytes_per_write_op {
                    return storage_write_limit_reached(None);
                }
```

**File:** aptos-move/framework/aptos-framework/sources/transaction_validation.move (L620-631)
```text
            if (transaction_fee_amount > storage_fee_refunded) {
                let burn_amount = transaction_fee_amount - storage_fee_refunded;
                transaction_fee::burn_fee(gas_payer, burn_amount);
            } else if (transaction_fee_amount < storage_fee_refunded) {
                let mint_amount = storage_fee_refunded - transaction_fee_amount;
                transaction_fee::mint_and_refund(gas_payer, mint_amount);
            };
        };

        // Increment sequence number
        let addr = signer::address_of(&account);
        account::increment_sequence_number(addr);
```

**File:** aptos-move/aptos-vm/src/move_vm_ext/session/user_transaction_sessions/epilogue.rs (L115-119)
```rust
        let change_set =
            session.finish_with_squashed_change_set(change_set_configs, module_storage, true)?;
        let epilogue_session_change_set =
            UserSessionChangeSet::new(change_set, module_write_set, change_set_configs)?;

```
