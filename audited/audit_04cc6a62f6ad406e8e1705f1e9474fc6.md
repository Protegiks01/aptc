# Audit Report

## Title
Unauthenticated Connection Replacement Attack in SafetyRules Remote Service

## Summary
The `NetworkServer::client()` function in `secure/net/src/lib.rs` accepts any TCP connection when `stream` is `None`, with no authentication or client verification. This allows a malicious client to replace a legitimate client connection and send requests to the SafetyRules service, which is responsible for critical consensus operations including signing blocks and votes.

## Finding Description

The vulnerability exists in the NetworkServer implementation used by the SafetyRules remote service. [1](#0-0) 

When `self.stream.is_none()`, the server accepts ANY incoming TCP connection via `listener.accept()` without performing authentication, authorization, or verification of the client's identity. The legitimate client connection is abandoned when read or write operations encounter errors. [2](#0-1) [3](#0-2) 

This NetworkServer is used by the SafetyRules service for critical consensus operations. [4](#0-3) 

The SafetyRules service handles sensitive operations including signing proposals, constructing and signing votes, and signing commit votes. [5](#0-4) [6](#0-5) 

**Attack Scenario:**
1. SafetyRules service runs in Process mode, listening on a network socket
2. Legitimate consensus client connects and operates normally
3. Attacker causes connection failure (timeout, TCP RST, or waits for natural error)
4. Server sets `stream = None` upon error
5. Attacker connects before legitimate client reconnects
6. Attacker can now query `ConsensusState`, send crafted `SafetyRulesInput` messages, or DoS the validator

The test suite explicitly demonstrates this behavior is by design. [7](#0-6) 

**Critical Mitigation:**
For mainnet validators, the config sanitizer enforces `SafetyRulesService::Local` mode, which does NOT use the NetworkServer. [8](#0-7) 

## Impact Explanation

**Severity Assessment: Medium to High (depending on deployment)**

**If exploitable (non-mainnet or misconfigured deployments):**
- **High Severity** - Validator liveness DoS: Attacker holds the connection, preventing legitimate consensus operations
- **Medium Severity** - Information disclosure: Query validator's internal consensus state (last_voted_round, preferred_round)
- **Medium Severity** - Potential consensus manipulation within SafetyRules constraints

**Mitigating Factors:**
- Mainnet validators are enforced to use Local mode (not vulnerable)
- Example configurations use localhost binding (127.0.0.1), limiting attack to local machine access
- SafetyRules has internal voting rule enforcement that prevents some attacks

**Remaining Attack Surface:**
- Testnet validators may use Process mode without sanitizer enforcement
- Development/testing environments
- Future non-mainnet chains
- Operator misconfiguration or sanitizer bypass

## Likelihood Explanation

**Mainnet: Very Low** - Config sanitizer prevents Process mode deployment

**Testnet/Non-mainnet: Low to Medium** - Requires:
1. SafetyRules running in Process mode
2. Service bound to externally accessible IP (not just 127.0.0.1)
3. Attacker with network access to the service
4. Ability to cause legitimate client disconnection

**Development: High** - Process mode commonly used, but lower impact environment

The vulnerability is REAL in the codebase, but practical exploitability depends heavily on deployment configuration.

## Recommendation

**Option 1: Add Authentication Layer (Recommended)**
Implement mutual authentication for NetworkServer/NetworkClient using the same NoiseIK protocol used in the main Aptos P2P network layer, or use TLS with client certificates. This would prevent unauthorized clients from connecting even if Process mode is used.

**Option 2: Strengthen Config Validation**
Extend the config sanitizer to enforce localhost binding (127.0.0.0/8) for any RemoteService server_address, preventing external exposure even in testnet/development.

**Option 3: Connection Pinning**
Modify NetworkServer to remember the first client's address and reject connections from different sources, or implement connection tokens/secrets shared between legitimate client and server.

**Recommended Fix (Option 1 - Add authentication check):**
```rust
// In NetworkServer::client(), add authentication after accept:
let (stream, stream_addr) = listener.accept()?;

// Add authentication check here
if !self.authenticate_client(&stream_addr) {
    warn!("Rejected unauthorized connection from {}", stream_addr);
    return Err(Error::UnauthorizedClient);
}
```

## Proof of Concept

```rust
// Proof of Concept: Connection Replacement Attack
use aptos_secure_net::{NetworkClient, NetworkServer};
use std::net::{IpAddr, Ipv4Addr, SocketAddr};
use std::thread;
use std::time::Duration;

#[test]
fn test_malicious_connection_replacement() {
    let server_port = aptos_config::utils::get_available_port();
    let server_addr = SocketAddr::new(IpAddr::V4(Ipv4Addr::LOCALHOST), server_port);
    
    // Victim SafetyRules server
    let mut server = NetworkServer::new("safety-rules".to_string(), server_addr, 5000);
    
    // Legitimate consensus client
    let mut legitimate_client = NetworkClient::new("consensus".to_string(), server_addr, 5000);
    
    // Normal operation
    legitimate_client.write(b"legitimate_request").unwrap();
    let response = server.read().unwrap();
    assert_eq!(response, b"legitimate_request");
    
    // Simulate connection error (timeout)
    thread::sleep(Duration::from_millis(6000)); // Exceeds 5000ms timeout
    server.read().unwrap_err(); // Connection error, stream becomes None
    
    // Attacker connects BEFORE legitimate client reconnects
    let mut attacker_client = NetworkClient::new("attacker".to_string(), server_addr, 5000);
    attacker_client.write(b"malicious_request").unwrap();
    
    // Server accepts attacker's request without authentication!
    let response = server.read().unwrap();
    assert_eq!(response, b"malicious_request"); // Attacker successfully injected data
    
    println!("Connection replacement successful - attacker is now connected!");
}
```

**Notes:**
This vulnerability exists in the codebase and connection replacement is possible by design. While mainnet deployments are protected by config enforcement requiring Local mode, the vulnerability remains exploitable in testnet, development environments, and any misconfigured deployments that use Process mode with external network binding. The lack of authentication in the NetworkServer represents a security weakness that should be addressed at the code level rather than relying solely on configuration-based mitigations.

### Citations

**File:** secure/net/src/lib.rs (L297-321)
```rust
    pub fn read(&mut self) -> Result<Vec<u8>, Error> {
        self.increment_counter(Method::Read, MethodResult::Query);

        let result = {
            let stream = self.client()?;
            stream.read().map_err(|e| (stream.remote, e))
        };

        if let Err((remote, err)) = &result {
            self.increment_counter(Method::Read, MethodResult::Failure);
            warn!(SecureNetLogSchema::new(
                &self.service,
                NetworkMode::Server,
                LogEvent::DisconnectedPeerOnRead,
            )
            .error(err)
            .remote_peer(remote));

            self.stream = None;
        } else {
            self.increment_counter(Method::Read, MethodResult::Success);
        }

        result.map_err(|err| err.1)
    }
```

**File:** secure/net/src/lib.rs (L339-363)
```rust
    pub fn write(&mut self, data: &[u8]) -> Result<(), Error> {
        self.increment_counter(Method::Write, MethodResult::Query);

        let result = {
            let stream = self.client()?;
            stream.write(data).map_err(|e| (stream.remote, e))
        };

        if let Err((remote, err)) = &result {
            self.increment_counter(Method::Write, MethodResult::Failure);
            warn!(SecureNetLogSchema::new(
                &self.service,
                NetworkMode::Server,
                LogEvent::DisconnectedPeerOnWrite,
            )
            .error(err)
            .remote_peer(remote));

            self.stream = None;
        } else {
            self.increment_counter(Method::Write, MethodResult::Success);
        }

        result.map_err(|err| err.1)
    }
```

**File:** secure/net/src/lib.rs (L365-404)
```rust
    fn client(&mut self) -> Result<&mut NetworkStream, Error> {
        if self.stream.is_none() {
            self.increment_counter(Method::Connect, MethodResult::Query);
            info!(SecureNetLogSchema::new(
                &self.service,
                NetworkMode::Server,
                LogEvent::ConnectionAttempt,
            ));

            let listener = self.listener.as_mut().ok_or(Error::AlreadyShutdown)?;

            let (stream, stream_addr) = match listener.accept() {
                Ok(ok) => ok,
                Err(err) => {
                    self.increment_counter(Method::Connect, MethodResult::Failure);
                    let err = err.into();
                    warn!(SecureNetLogSchema::new(
                        &self.service,
                        NetworkMode::Server,
                        LogEvent::ConnectionSuccessful,
                    )
                    .error(&err));
                    return Err(err);
                },
            };

            self.increment_counter(Method::Connect, MethodResult::Success);
            info!(SecureNetLogSchema::new(
                &self.service,
                NetworkMode::Server,
                LogEvent::ConnectionSuccessful,
            )
            .remote_peer(&stream_addr));

            stream.set_nodelay(true)?;
            self.stream = Some(NetworkStream::new(stream, stream_addr, self.timeout_ms));
        }

        self.stream.as_mut().ok_or(Error::NoActiveStream)
    }
```

**File:** secure/net/src/lib.rs (L606-628)
```rust
    fn test_server_timeout() {
        let server_port = utils::get_available_port();
        let server_addr = SocketAddr::new(IpAddr::V4(Ipv4Addr::LOCALHOST), server_port);
        let mut server = NetworkServer::new("test".to_string(), server_addr, TIMEOUT);
        let mut client = NetworkClient::new("test".to_string(), server_addr, TIMEOUT);
        let data1 = vec![0, 1, 2, 3];
        let data2 = vec![4, 5, 6, 7];

        // First client, success
        client.write(&data1).unwrap();
        let result1 = server.read().unwrap();
        assert_eq!(data1, result1);

        // Timedout
        server.read().unwrap_err();

        // New client, success, note the previous client connection is still active, the server is
        // actively letting it go due to lack of activity.
        let mut client2 = NetworkClient::new("test".to_string(), server_addr, TIMEOUT);
        client2.write(&data2).unwrap();
        let result2 = server.read().unwrap();
        assert_eq!(data2, result2);
    }
```

**File:** consensus/safety-rules/src/remote_service.rs (L30-55)
```rust
pub fn execute(storage: PersistentSafetyStorage, listen_addr: SocketAddr, network_timeout_ms: u64) {
    let mut safety_rules = SafetyRules::new(storage, false);
    if let Err(e) = safety_rules.consensus_state() {
        warn!("Unable to print consensus state: {}", e);
    }

    let mut serializer_service = SerializerService::new(safety_rules);
    let mut network_server =
        NetworkServer::new("safety-rules".to_string(), listen_addr, network_timeout_ms);

    loop {
        if let Err(e) = process_one_message(&mut network_server, &mut serializer_service) {
            warn!("Failed to process message: {}", e);
        }
    }
}

fn process_one_message(
    network_server: &mut NetworkServer,
    serializer_service: &mut SerializerService,
) -> Result<(), Error> {
    let request = network_server.read()?;
    let response = serializer_service.handle_message(request)?;
    network_server.write(&response)?;
    Ok(())
}
```

**File:** consensus/safety-rules/src/serializer.rs (L22-34)
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
pub enum SafetyRulesInput {
    ConsensusState,
    Initialize(Box<EpochChangeProof>),
    SignProposal(Box<BlockData>),
    SignTimeoutWithQC(
        Box<TwoChainTimeout>,
        Box<Option<TwoChainTimeoutCertificate>>,
    ),
    ConstructAndSignVoteTwoChain(Box<VoteProposal>, Box<Option<TwoChainTimeoutCertificate>>),
    ConstructAndSignOrderVote(Box<OrderVoteProposal>),
    SignCommitVote(Box<LedgerInfoWithSignatures>, Box<LedgerInfo>),
}
```

**File:** consensus/safety-rules/src/serializer.rs (L45-82)
```rust
    pub fn handle_message(&mut self, input_message: Vec<u8>) -> Result<Vec<u8>, Error> {
        let input = serde_json::from_slice(&input_message)?;

        let output = match input {
            SafetyRulesInput::ConsensusState => {
                serde_json::to_vec(&self.internal.consensus_state())
            },
            SafetyRulesInput::Initialize(li) => serde_json::to_vec(&self.internal.initialize(&li)),
            SafetyRulesInput::SignProposal(block_data) => {
                serde_json::to_vec(&self.internal.sign_proposal(&block_data))
            },
            SafetyRulesInput::SignTimeoutWithQC(timeout, maybe_tc) => serde_json::to_vec(
                &self
                    .internal
                    .sign_timeout_with_qc(&timeout, maybe_tc.as_ref().as_ref()),
            ),
            SafetyRulesInput::ConstructAndSignVoteTwoChain(vote_proposal, maybe_tc) => {
                serde_json::to_vec(
                    &self.internal.construct_and_sign_vote_two_chain(
                        &vote_proposal,
                        maybe_tc.as_ref().as_ref(),
                    ),
                )
            },
            SafetyRulesInput::ConstructAndSignOrderVote(order_vote_proposal) => serde_json::to_vec(
                &self
                    .internal
                    .construct_and_sign_order_vote(&order_vote_proposal),
            ),
            SafetyRulesInput::SignCommitVote(ledger_info, new_ledger_info) => serde_json::to_vec(
                &self
                    .internal
                    .sign_commit_vote(*ledger_info, *new_ledger_info),
            ),
        };

        Ok(output?)
    }
```

**File:** config/src/config/safety_rules_config.rs (L98-104)
```rust
            // Verify that the safety rules service is set to local for optimal performance
            if chain_id.is_mainnet() && !safety_rules_config.service.is_local() {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    format!("The safety rules service should be set to local in mainnet for optimal performance! Given config: {:?}", &safety_rules_config.service)
                ));
            }
```
