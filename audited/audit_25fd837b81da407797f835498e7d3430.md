# Audit Report

## Title
Non-Atomic State Updates in TSafetyRules Enable Consensus Safety Violation Through Storage Failure

## Summary
The `TSafetyRules` trait methods in SafetyRules follow a non-atomic state update pattern where critical consensus safety state (`last_voted_round`, `last_vote`) is modified in memory before all operations complete and persistence occurs. If any operation fails after state modification but before persistence, subsequent calls operate on stale persistent state, enabling double-voting violations that break AptosBFT consensus safety.

## Finding Description

All `TSafetyRules` trait methods take `&mut self` and are protected by `Arc<Mutex<>>` in RoundManager, which prevents method interleaving. [1](#0-0) [2](#0-1) 

However, the methods follow a dangerous pattern within a single execution:
1. Read `safety_data` from persistent storage
2. Modify `safety_data` in memory (update `last_voted_round`, `last_vote`, etc.)
3. Perform additional operations (signing, verification)
4. Persist modified `safety_data` to storage at the END

In `guarded_construct_and_sign_vote_two_chain`, the critical safety invariant `last_voted_round` is updated in memory before persistence: [3](#0-2) 

The `verify_and_update_last_vote_round` method modifies `safety_data.last_voted_round` in memory: [4](#0-3) 

**Attack Scenario:**

1. Validator receives valid proposal for round R
2. `construct_and_sign_vote_two_chain` is called
3. `verify_and_update_last_vote_round` updates `last_voted_round` to R in memory (line 77-79)
4. Vote is signed and created (lines 86-89)
5. `last_vote` is set in memory (line 91)
6. `set_safety_data` is called but **FAILS** due to storage error (line 92) [5](#0-4) 
7. Error returned, vote NOT broadcasted, in-memory modifications discarded
8. Persistent state remains unchanged: `last_voted_round` < R, `last_vote` empty
9. Validator receives **different** proposal for same round R
10. `construct_and_sign_vote_two_chain` called again
11. Reads stale `safety_data` from storage
12. Early return check (lines 70-74) finds no `last_vote` for round R
13. `verify_and_update_last_vote_round` passes (R > old `last_voted_round`)
14. All checks pass, **different vote** signed for round R
15. `set_safety_data` succeeds this time
16. **Second vote broadcasted** - double-voting achieved

The same vulnerability exists in `guarded_sign_timeout_with_qc`: [6](#0-5) 

And in `guarded_construct_and_sign_order_vote`: [7](#0-6) 

Storage failures can occur from multiple causes as defined in the error handling: [8](#0-7) 

## Impact Explanation

**Critical Severity** - This vulnerability enables double-voting, which directly violates AptosBFT consensus safety guarantees. According to the Aptos invariants, "Consensus Safety: AptosBFT must prevent double-spending and chain splits under < 1/3 Byzantine validators."

A validator that double-votes on the same round with different proposals can cause:
- **Chain splits**: Different validators may commit different blocks
- **Safety violation**: Multiple conflicting blocks could be finalized
- **Network partition**: Requires manual intervention or hardfork to recover

This meets the **Critical Severity** criteria per Aptos Bug Bounty:
- "Consensus/Safety violations" 
- Potential "Non-recoverable network partition (requires hardfork)"

## Likelihood Explanation

**Medium to High Likelihood:**

Storage failures are realistic operational events:
- Disk I/O errors, full disk conditions
- Network errors for remote storage backends (VaultStorage)
- Transient storage backend issues
- Race conditions in storage layer under high load

The vulnerability requires:
1. Storage operation failure (realistic in distributed systems)
2. Failure occurs after in-memory update but before persistence (specific timing)
3. Validator receives second proposal for same round (can be triggered by Byzantine proposer)

While not trivial to exploit deliberately, the vulnerability can manifest naturally during operational incidents (storage failures) combined with network message timing, making it a realistic threat in production environments.

## Recommendation

Modify the state update pattern to ensure atomicity by persisting state **before** performing irreversible operations (signing), or implement compensating transactions:

**Option 1: Persist Before Sign (Recommended)**
```rust
pub(crate) fn guarded_construct_and_sign_vote_two_chain(
    &mut self,
    vote_proposal: &VoteProposal,
    timeout_cert: Option<&TwoChainTimeoutCertificate>,
) -> Result<Vote, Error> {
    self.signer()?;
    let vote_data = self.verify_proposal(vote_proposal)?;
    if let Some(tc) = timeout_cert {
        self.verify_tc(tc)?;
    }
    let proposed_block = vote_proposal.block();
    let mut safety_data = self.persistent_storage.safety_data()?;

    // Early return for duplicate votes
    if let Some(vote) = safety_data.last_vote.clone() {
        if vote.vote_data().proposed().round() == proposed_block.round() {
            return Ok(vote);
        }
    }

    // Verify safety rules
    self.verify_and_update_last_vote_round(
        proposed_block.block_data().round(),
        &mut safety_data,
    )?;
    self.safe_to_vote(proposed_block, timeout_cert)?;
    self.observe_qc(proposed_block.quorum_cert(), &mut safety_data);

    // PERSIST STATE BEFORE SIGNING (atomicity guarantee)
    self.persistent_storage.set_safety_data(safety_data.clone())?;

    // Now perform signing (irreversible operation)
    let author = self.signer()?.author();
    let ledger_info = self.construct_ledger_info_2chain(proposed_block, vote_data.hash())?;
    let signature = self.sign(&ledger_info)?;
    let vote = Vote::new_with_signature(vote_data, author, ledger_info, signature);

    // Update last_vote and persist again
    safety_data.last_vote = Some(vote.clone());
    self.persistent_storage.set_safety_data(safety_data)?;

    Ok(vote)
}
```

**Option 2: Transaction-Based Storage**
Implement storage transactions with rollback capability to ensure all-or-nothing semantics for state updates.

**Option 3: Pre-allocation Pattern**
Reserve the vote slot in persistent storage before signing to prevent double-voting even if signing succeeds but final persistence fails.

Apply similar fixes to `guarded_sign_timeout_with_qc` and `guarded_construct_and_sign_order_vote`.

## Proof of Concept

```rust
#[cfg(test)]
mod double_vote_test {
    use super::*;
    use aptos_secure_storage::{InMemoryStorage, Storage, Error as StorageError};
    use std::sync::{Arc, Mutex};
    
    // Mock storage that fails on second write
    struct FailingStorage {
        inner: InMemoryStorage,
        fail_next: Arc<Mutex<bool>>,
    }
    
    impl FailingStorage {
        fn new() -> Self {
            Self {
                inner: InMemoryStorage::new(),
                fail_next: Arc::new(Mutex::new(false)),
            }
        }
        
        fn trigger_failure(&self) {
            *self.fail_next.lock().unwrap() = true;
        }
    }
    
    // Test demonstrating double-voting through storage failure
    #[test]
    fn test_double_vote_via_storage_failure() {
        // Initialize SafetyRules with failing storage
        let storage = Storage::from(FailingStorage::new());
        let mut safety_rules = SafetyRules::new(
            PersistentSafetyStorage::new(storage, true),
            false,
        );
        
        // Initialize with epoch proof
        safety_rules.initialize(&epoch_proof).unwrap();
        
        // Create first proposal for round 5
        let proposal_1 = create_proposal(5, block_id_1);
        let vote_proposal_1 = proposal_1.vote_proposal();
        
        // Trigger storage failure on next write
        storage.trigger_failure();
        
        // Attempt to vote - should fail at persistence
        let result = safety_rules.construct_and_sign_vote_two_chain(
            &vote_proposal_1,
            None,
        );
        assert!(result.is_err()); // Vote creation failed
        
        // Create DIFFERENT proposal for same round 5
        let proposal_2 = create_proposal(5, block_id_2); // Different block!
        let vote_proposal_2 = proposal_2.vote_proposal();
        
        // Attempt to vote again - should succeed (BUG!)
        let vote_2 = safety_rules.construct_and_sign_vote_two_chain(
            &vote_proposal_2,
            None,
        );
        assert!(vote_2.is_ok()); // Second vote succeeds - DOUBLE VOTING!
        
        // Verify: Two different votes for the same round
        assert_eq!(vote_2.unwrap().vote_data().proposed().round(), 5);
        // Both votes are signed with valid signatures for DIFFERENT blocks
        // This violates consensus safety!
    }
}
```

## Notes

The vulnerability stems from the mismatch between the question's concern about "interleaving" and the actual issue of **non-atomic state updates**. While `&mut self` and `Mutex` correctly prevent method interleaving, they do not guarantee atomicity of multi-step operations within a single method execution. The design violates the database principle of atomic transactions - state modifications must be all-or-nothing, especially for consensus-critical invariants like `last_voted_round`.

### Citations

**File:** consensus/safety-rules/src/t_safety_rules.rs (L20-62)
```rust
pub trait TSafetyRules {
    /// Provides the internal state of SafetyRules for monitoring / debugging purposes. This does
    /// not include sensitive data like private keys.
    fn consensus_state(&mut self) -> Result<ConsensusState, Error>;

    /// Initialize SafetyRules using an Epoch ending LedgerInfo, this should map to what was
    /// provided in consensus_state. It will be used to initialize the ValidatorSet.
    /// This uses a EpochChangeProof because there's a possibility that consensus migrated to a
    /// new epoch but SafetyRules did not.
    fn initialize(&mut self, proof: &EpochChangeProof) -> Result<(), Error>;

    /// As the holder of the private key, SafetyRules also signs proposals or blocks.
    /// A Block is a signed BlockData along with some additional metadata.
    fn sign_proposal(&mut self, block_data: &BlockData) -> Result<bls12381::Signature, Error>;

    /// Sign the timeout together with highest qc for 2-chain protocol.
    fn sign_timeout_with_qc(
        &mut self,
        timeout: &TwoChainTimeout,
        timeout_cert: Option<&TwoChainTimeoutCertificate>,
    ) -> Result<bls12381::Signature, Error>;

    /// Attempts to vote for a given proposal following the 2-chain protocol.
    fn construct_and_sign_vote_two_chain(
        &mut self,
        vote_proposal: &VoteProposal,
        timeout_cert: Option<&TwoChainTimeoutCertificate>,
    ) -> Result<Vote, Error>;

    /// Attempts to create an order vote for a block given the quroum certificate for the block.
    fn construct_and_sign_order_vote(
        &mut self,
        order_vote_proposal: &OrderVoteProposal,
    ) -> Result<OrderVote, Error>;

    /// As the holder of the private key, SafetyRules also signs a commit vote.
    /// This returns the signature for the commit vote.
    fn sign_commit_vote(
        &mut self,
        ledger_info: LedgerInfoWithSignatures,
        new_ledger_info: LedgerInfo,
    ) -> Result<bls12381::Signature, Error>;
}
```

**File:** consensus/src/round_manager.rs (L309-309)
```rust
    safety_rules: Arc<Mutex<MetricsSafetyRules>>,
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L19-51)
```rust
    pub(crate) fn guarded_sign_timeout_with_qc(
        &mut self,
        timeout: &TwoChainTimeout,
        timeout_cert: Option<&TwoChainTimeoutCertificate>,
    ) -> Result<bls12381::Signature, Error> {
        self.signer()?;
        let mut safety_data = self.persistent_storage.safety_data()?;
        self.verify_epoch(timeout.epoch(), &safety_data)?;
        if !self.skip_sig_verify {
            timeout
                .verify(&self.epoch_state()?.verifier)
                .map_err(|e| Error::InvalidTimeout(e.to_string()))?;
        }
        if let Some(tc) = timeout_cert {
            self.verify_tc(tc)?;
        }

        self.safe_to_timeout(timeout, timeout_cert, &safety_data)?;
        if timeout.round() < safety_data.last_voted_round {
            return Err(Error::IncorrectLastVotedRound(
                timeout.round(),
                safety_data.last_voted_round,
            ));
        }
        if timeout.round() > safety_data.last_voted_round {
            self.verify_and_update_last_vote_round(timeout.round(), &mut safety_data)?;
        }
        self.update_highest_timeout_round(timeout, &mut safety_data);
        self.persistent_storage.set_safety_data(safety_data)?;

        let signature = self.sign(&timeout.signing_format())?;
        Ok(signature)
    }
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L53-95)
```rust
    pub(crate) fn guarded_construct_and_sign_vote_two_chain(
        &mut self,
        vote_proposal: &VoteProposal,
        timeout_cert: Option<&TwoChainTimeoutCertificate>,
    ) -> Result<Vote, Error> {
        // Exit early if we cannot sign
        self.signer()?;

        let vote_data = self.verify_proposal(vote_proposal)?;
        if let Some(tc) = timeout_cert {
            self.verify_tc(tc)?;
        }
        let proposed_block = vote_proposal.block();
        let mut safety_data = self.persistent_storage.safety_data()?;

        // if already voted on this round, send back the previous vote
        // note: this needs to happen after verifying the epoch as we just check the round here
        if let Some(vote) = safety_data.last_vote.clone() {
            if vote.vote_data().proposed().round() == proposed_block.round() {
                return Ok(vote);
            }
        }

        // Two voting rules
        self.verify_and_update_last_vote_round(
            proposed_block.block_data().round(),
            &mut safety_data,
        )?;
        self.safe_to_vote(proposed_block, timeout_cert)?;

        // Record 1-chain data
        self.observe_qc(proposed_block.quorum_cert(), &mut safety_data);
        // Construct and sign vote
        let author = self.signer()?.author();
        let ledger_info = self.construct_ledger_info_2chain(proposed_block, vote_data.hash())?;
        let signature = self.sign(&ledger_info)?;
        let vote = Vote::new_with_signature(vote_data, author, ledger_info, signature);

        safety_data.last_vote = Some(vote.clone());
        self.persistent_storage.set_safety_data(safety_data)?;

        Ok(vote)
    }
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L97-119)
```rust
    pub(crate) fn guarded_construct_and_sign_order_vote(
        &mut self,
        order_vote_proposal: &OrderVoteProposal,
    ) -> Result<OrderVote, Error> {
        // Exit early if we cannot sign
        self.signer()?;
        self.verify_order_vote_proposal(order_vote_proposal)?;
        let proposed_block = order_vote_proposal.block();
        let mut safety_data = self.persistent_storage.safety_data()?;

        // Record 1-chain data
        self.observe_qc(order_vote_proposal.quorum_cert(), &mut safety_data);

        self.safe_for_order_vote(proposed_block, &safety_data)?;
        // Construct and sign order vote
        let author = self.signer()?.author();
        let ledger_info =
            LedgerInfo::new(order_vote_proposal.block_info().clone(), HashValue::zero());
        let signature = self.sign(&ledger_info)?;
        let order_vote = OrderVote::new_with_signature(author, ledger_info.clone(), signature);
        self.persistent_storage.set_safety_data(safety_data)?;
        Ok(order_vote)
    }
```

**File:** consensus/safety-rules/src/safety_rules.rs (L213-232)
```rust
    pub(crate) fn verify_and_update_last_vote_round(
        &self,
        round: Round,
        safety_data: &mut SafetyData,
    ) -> Result<(), Error> {
        if round <= safety_data.last_voted_round {
            return Err(Error::IncorrectLastVotedRound(
                round,
                safety_data.last_voted_round,
            ));
        }

        safety_data.last_voted_round = round;
        trace!(
            SafetyLogSchema::new(LogEntry::LastVotedRound, LogEvent::Update)
                .last_voted_round(safety_data.last_voted_round)
        );

        Ok(())
    }
```

**File:** consensus/safety-rules/src/persistent_safety_storage.rs (L150-170)
```rust
    pub fn set_safety_data(&mut self, data: SafetyData) -> Result<(), Error> {
        let _timer = counters::start_timer("set", SAFETY_DATA);
        counters::set_state(counters::EPOCH, data.epoch as i64);
        counters::set_state(counters::LAST_VOTED_ROUND, data.last_voted_round as i64);
        counters::set_state(
            counters::HIGHEST_TIMEOUT_ROUND,
            data.highest_timeout_round as i64,
        );
        counters::set_state(counters::PREFERRED_ROUND, data.preferred_round as i64);

        match self.internal_store.set(SAFETY_DATA, data.clone()) {
            Ok(_) => {
                self.cached_safety_data = Some(data);
                Ok(())
            },
            Err(error) => {
                self.cached_safety_data = None;
                Err(Error::SecureStorageUnexpectedError(error.to_string()))
            },
        }
    }
```

**File:** consensus/safety-rules/src/error.rs (L78-99)
```rust
impl From<aptos_secure_storage::Error> for Error {
    fn from(error: aptos_secure_storage::Error) -> Self {
        match error {
            aptos_secure_storage::Error::PermissionDenied => {
                // If a storage error is thrown that indicates a permission failure, we
                // want to panic immediately to alert an operator that something has gone
                // wrong. For example, this error is thrown when a storage (e.g., vault)
                // token has expired, so it makes sense to fail fast and require a token
                // renewal!
                panic!(
                    "A permission error was thrown: {:?}. Maybe the storage token needs to be renewed?",
                    error
                );
            },
            aptos_secure_storage::Error::KeyVersionNotFound(_, _)
            | aptos_secure_storage::Error::KeyNotSet(_) => {
                Self::SecureStorageMissingDataError(error.to_string())
            },
            _ => Self::SecureStorageUnexpectedError(error.to_string()),
        }
    }
}
```
