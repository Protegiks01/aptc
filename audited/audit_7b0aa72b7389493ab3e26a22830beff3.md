# Audit Report

## Title
Information Disclosure in Event API Error Responses via Debug Formatting of Move Types

## Summary
The event API's error handling at line 187 in `api/src/events.rs` can leak internal Move type structures and runtime values through verbose Debug formatting when type annotation fails during event conversion.

## Finding Description

When the Events API processes event data, it converts events from storage format to API response format. During this conversion, if there's a type mismatch between the stored event data and the expected type structure, the error includes Debug-formatted representations of both the runtime value and the type metadata. [1](#0-0) 

The conversion process calls `try_into_versioned_events()` which internally uses the Move value annotator: [2](#0-1) 

When annotation fails due to type mismatches, the error message includes full Debug output: [3](#0-2) 

This error propagates through the error handling chain where it's formatted using `{:#}` which includes the full error context: [4](#0-3) 

The resulting error message returned to API clients contains:
- Complete MoveValue Debug representation (including struct fields, closure captured values, function names, module IDs)
- Complete FatType Debug representation (including module addresses, struct names, field types, abilities, layouts) [5](#0-4) [6](#0-5) 

## Impact Explanation

This constitutes a **Low severity** information disclosure issue. While it can leak internal type metadata and some runtime values, it does NOT:
- Leak actual Move bytecode (only type metadata)
- Affect consensus, funds, or availability
- Provide actionable information for further attacks in most cases

Per the Aptos bug bounty criteria, "Minor information leaks" fall under Low severity ($1,000 range).

## Likelihood Explanation

**Likelihood: Low**

Triggering this error requires specific conditions:
1. Event data stored in database with type tag T
2. Type mismatch during deserialization (rare due to Move's type safety)
3. Possible scenarios: module upgrades with type changes, database corruption, or edge cases in VM serialization

However, Move's compatibility constraints and validation make this difficult to trigger intentionally without exploiting other bugs.

## Recommendation

Sanitize error messages before returning them to API clients. Replace verbose Debug output with generic error messages:

```rust
.map_err(|err| {
    // Log detailed error internally
    error!("Event conversion failed: {:#}", err);
    
    // Return sanitized error to client
    BasicErrorWith404::internal_with_code(
        "Failed to convert events from storage into response format",
        AptosErrorCode::InternalError,
        &latest_ledger_info,
    )
})?;
```

Also update the annotate_value error to avoid Debug formatting:

```rust
return Err(anyhow!(
    "Type mismatch during value annotation"
));
```

## Proof of Concept

```rust
// Note: This PoC is theoretical as constructing a realistic scenario
// requires triggering VM-level type mismatches, which are prevented
// by Move's type system in normal operation.

#[test]
fn test_event_conversion_error_leak() {
    // 1. Setup: Create event with specific type
    // 2. Store event in database
    // 3. Attempt to deserialize with incompatible type
    // 4. Observe error message contains Debug output
    // 5. Extract leaked type information from error
    
    // This would require either:
    // - Mocking corrupted database state
    // - Exploiting module upgrade edge cases
    // - Using VM bugs to create type mismatches
    
    // Without additional vulnerabilities, this is difficult to exploit
}
```

**Notes:**
After rigorous validation, while this code path CAN leak type metadata in error messages, the practical exploitability is limited because:
1. Triggering the error requires rare type mismatches that Move's type system prevents
2. The leaked information (type structures) is often already public in published modules
3. No bytecode is leakedâ€”only runtime type metadata
4. Impact is informational only, not actionable for further attacks

This falls under "Minor information leak" (Low severity) rather than Medium severity as originally suggested.

### Citations

**File:** api/src/events.rs (L182-194)
```rust
                let events = self
                    .context
                    .latest_state_view_poem(&latest_ledger_info)?
                    .as_converter(self.context.db.clone(), self.context.indexer_reader.clone())
                    .try_into_versioned_events(&events)
                    .context("Failed to convert events from storage into response")
                    .map_err(|err| {
                        BasicErrorWith404::internal_with_code(
                            err,
                            AptosErrorCode::InternalError,
                            &latest_ledger_info,
                        )
                    })?;
```

**File:** api/types/src/convert.rs (L612-624)
```rust
    pub fn try_into_versioned_events(
        &self,
        events: &[EventWithVersion],
    ) -> Result<Vec<VersionedEvent>> {
        let mut ret = vec![];
        for event in events {
            let data = self
                .inner
                .view_value(event.event.type_tag(), event.event.event_data())?;
            ret.push((event, MoveValue::try_from(data)?.json()?).into());
        }
        Ok(ret)
    }
```

**File:** third_party/move/tools/move-resource-viewer/src/lib.rs (L944-948)
```rust
                return Err(anyhow!(
                    "Cannot annotate value {:?} with type {:?}",
                    value,
                    ty
                ));
```

**File:** api/types/src/error.rs (L29-38)
```rust
    pub fn new_with_error_code<ErrorType: std::fmt::Display>(
        error: ErrorType,
        error_code: AptosErrorCode,
    ) -> AptosError {
        Self {
            message: format!("{:#}", error),
            error_code,
            vm_error_code: None,
        }
    }
```

**File:** third_party/move/move-core/types/src/value.rs (L117-146)
```rust
#[derive(Debug, PartialEq, Eq, Clone)]
#[cfg_attr(
    any(test, feature = "fuzzing"),
    derive(arbitrary::Arbitrary, dearbitrary::Dearbitrary)
)]
pub enum MoveValue {
    U8(u8),
    U64(u64),
    U128(u128),
    Bool(bool),
    Address(AccountAddress),
    Vector(Vec<MoveValue>),
    Struct(MoveStruct),
    // TODO: Signer is only used to construct arguments easily.
    //       Refactor the code to reflect the new permissioned signer schema.
    Signer(AccountAddress),
    // NOTE: Added in bytecode version v6, do not reorder!
    U16(u16),
    U32(u32),
    U256(int256::U256),
    // Added in bytecode version v8
    Closure(Box<MoveClosure>),
    // Added in bytecode version v9
    I8(i8),
    I16(i16),
    I32(i32),
    I64(i64),
    I128(i128),
    I256(int256::I256),
}
```

**File:** third_party/move/tools/move-resource-viewer/src/fat_type.rs (L75-106)
```rust
#[derive(Debug, Clone, Serialize, Deserialize, PartialOrd, Ord, PartialEq, Eq)]
pub(crate) enum FatType {
    Bool,
    U8,
    U64,
    U128,
    Address,
    Signer,
    Vector(Box<FatType>),
    Struct(FatStructRef),
    Reference(Box<FatType>),
    MutableReference(Box<FatType>),
    TyParam(usize),
    // NOTE: Added in bytecode version v6, do not reorder!
    U16,
    U32,
    U256,
    // NOTE: Added in bytecode version v8, do not reorder!
    Function(Box<FatFunctionType>),
    // `Runtime` and `RuntimeVariants` are used for typing
    // captured structures in closures, for which we only know
    // the raw layout (no struct name, no field names).
    Runtime(Vec<FatType>),
    RuntimeVariants(Vec<Vec<FatType>>),
    // NOTE: Added in bytecode version v9, do not reorder!
    I8,
    I16,
    I32,
    I64,
    I128,
    I256,
}
```
