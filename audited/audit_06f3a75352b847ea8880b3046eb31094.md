# Audit Report

## Title
Health Checker Nonce Validation Bypass Enables Connection Slot DoS on Public Fullnodes

## Summary
The health checker's `handle_ping_response` function fails to increment failure counters when receiving Pong responses with incorrect nonces. Malicious peers can exploit this on public fullnode networks to occupy all inbound connection slots indefinitely, preventing legitimate peers from connecting and effectively isolating the node from the network.

## Finding Description

The health checker protocol uses nonce-based challenge-response to verify peer liveness. When a node sends a Ping(nonce) request, it expects the peer to respond with Pong(nonce) containing the same nonce value. [1](#0-0) 

The vulnerability exists in the nonce validation logic. When a Pong response arrives with an **incorrect nonce**, the code logs a security warning but critically **does not increment the failure counter**. Only timeout/error responses increment failures: [2](#0-1) 

This discrepancy allows malicious peers to remain connected indefinitely by responding with wrong nonces. The health checker pings all connected peers every interval: [3](#0-2) 

**Attack Path:**

1. Attacker connects up to 100 malicious peers to a public fullnode (exploiting `max_inbound_connections = 100`) [4](#0-3) 

2. Public fullnodes use `MaybeMutual` authentication, allowing arbitrary peer connections [5](#0-4) 

3. Each malicious peer implements a modified health checker that responds with `Pong(0)` or any wrong nonce to all Ping requests

4. The victim node's health checker receives these responses, validates nonces, finds mismatches, but never increments failure counters

5. All 100 inbound slots remain occupied by malicious peers that never get disconnected

6. Legitimate peers cannot connect due to connection limit enforcement [6](#0-5) 

7. The fullnode becomes isolated from the honest network, unable to sync state, propagate transactions, or participate in consensus observation

## Impact Explanation

**Severity: HIGH** (aligns with "Validator node slowdowns" and "Significant protocol violations" categories)

- **Network Availability**: The victim fullnode is effectively partitioned from the network, unable to receive state updates or propagate transactions
- **Service Disruption**: Applications relying on the fullnode experience complete unavailability
- **Scope**: Affects all public fullnodes; validator networks with mutual authentication are protected
- **No Funds at Risk**: Does not directly cause loss of funds but severely degrades network functionality

This falls under HIGH severity as it causes significant protocol violations and effectively creates a non-recoverable network partition for the victim node without requiring complex exploitation.

## Likelihood Explanation

**Likelihood: MEDIUM**

- **Attacker Requirements**: Must run custom node software to send wrong nonces (trivial modification)
- **Network Access**: Must be able to connect to target fullnode (publicly accessible)
- **Detection**: Wrong nonce warnings logged but may go unnoticed in production
- **Cost**: Minimal - requires only network bandwidth to maintain connections
- **Skill Level**: Low - straightforward network protocol modification

The attack is technically simple but requires intentional malicious behavior, making it MEDIUM likelihood in practice.

## Recommendation

**Fix: Treat incorrect nonce responses as failures and increment the failure counter.**

Modify `handle_ping_response` to increment failures when nonce validation fails:

```rust
match ping_result {
    Ok(pong) => {
        if pong.0 == req_nonce {
            // Success: reset failures
            self.network_interface.reset_peer_round_state(peer_id, round);
        } else {
            // FIX: Treat wrong nonce as failure
            warn!(
                SecurityEvent::InvalidHealthCheckerMsg,
                NetworkSchema::new(&self.network_context).remote_peer(&peer_id),
                "{} Pong nonce doesn't match Ping nonce. Round: {}, Pong: {}, Ping: {}",
                self.network_context, round, pong.0, req_nonce
            );
            // Increment failure counter (NEW)
            self.network_interface.increment_peer_round_failure(peer_id, round);
            
            // Check if failures exceed tolerance (NEW)
            let failures = self.network_interface.get_peer_failures(peer_id).unwrap_or(0);
            if failures > self.ping_failures_tolerated {
                // Disconnect peer (NEW - reuse existing disconnect logic)
                info!(
                    NetworkSchema::new(&self.network_context).remote_peer(&peer_id),
                    "{} Disconnecting from peer due to invalid nonces: {}",
                    self.network_context, peer_id.short_str()
                );
                let peer_network_id = PeerNetworkId::new(self.network_context.network_id(), peer_id);
                if let Err(err) = timeout(
                    Duration::from_millis(50),
                    self.network_interface.disconnect_peer(
                        peer_network_id,
                        DisconnectReason::NetworkHealthCheckFailure,
                    ),
                ).await {
                    warn!("Failed to disconnect peer: {:?}", err);
                }
            }
        }
    },
    Err(err) => {
        // Existing error handling...
    }
}
```

## Proof of Concept

**Malicious Peer Implementation (Conceptual Rust):**

```rust
// Malicious health checker that always responds with wrong nonce
impl MaliciousHealthChecker {
    fn handle_ping_request(&mut self, peer_id: PeerId, ping: Ping, res_tx: oneshot::Sender<Result<Bytes, RpcError>>) {
        // Always respond with nonce 0 instead of echoing the correct nonce
        let message = protocol.to_bytes(&HealthCheckerMsg::Pong(Pong(0))).unwrap();
        let _ = res_tx.send(Ok(message.into()));
    }
}

// Attack execution:
// 1. Deploy 100 nodes running MaliciousHealthChecker
// 2. Connect all 100 to target fullnode
// 3. Target's health checker pings all 100 peers
// 4. All respond with Pong(0) regardless of ping nonce
// 5. Target logs warnings but never disconnects
// 6. All connection slots occupied indefinitely
// 7. Legitimate peers cannot connect
```

**Reproduction Steps:**
1. Deploy Aptos fullnode with default configuration (max_inbound_connections=100)
2. Modify 100 peer nodes to respond with `Pong(0)` to all health check pings
3. Connect all 100 malicious peers to target fullnode
4. Observe in target logs: repeated "Pong nonce doesn't match" warnings for all peers
5. Verify failure counters remain at 0 for all malicious peers
6. Attempt to connect legitimate peer - connection rejected due to limit
7. Target fullnode remains isolated with full connection slots occupied by malicious peers

## Notes

- The vulnerability only affects networks using `MaybeMutual` authentication (public fullnodes)
- Validator networks with `Mutual` authentication are protected as only trusted peers can connect [7](#0-6) 
- The health checker is enabled on all network types by default [8](#0-7) 
- The issue represents a logic error where nonce validation warnings have no enforcement mechanism

### Citations

**File:** network/framework/src/protocols/health_checker/mod.rs (L243-263)
```rust
                    for peer_id in connected {
                        let nonce = self.rng.r#gen::<u32>();
                        trace!(
                            NetworkSchema::new(&self.network_context),
                            round = self.round,
                            "{} Will ping: {} for round: {} nonce: {}",
                            self.network_context,
                            peer_id.short_str(),
                            self.round,
                            nonce
                        );

                        tick_handlers.push(Self::ping_peer(
                            self.network_context,
                            self.network_interface.network_client(),
                            peer_id,
                            self.round,
                            nonce,
                            self.ping_timeout,
                        ));
                    }
```

**File:** network/framework/src/protocols/health_checker/mod.rs (L315-341)
```rust
        match ping_result {
            Ok(pong) => {
                if pong.0 == req_nonce {
                    trace!(
                        NetworkSchema::new(&self.network_context).remote_peer(&peer_id),
                        rount = round,
                        "{} Ping successful for peer: {} round: {}",
                        self.network_context,
                        peer_id.short_str(),
                        round
                    );
                    // Update last successful ping to current round.
                    // If it's not in storage, don't bother updating it
                    self.network_interface
                        .reset_peer_round_state(peer_id, round);
                } else {
                    warn!(
                        SecurityEvent::InvalidHealthCheckerMsg,
                        NetworkSchema::new(&self.network_context).remote_peer(&peer_id),
                        "{} Pong nonce doesn't match Ping nonce. Round: {}, Pong: {}, Ping: {}",
                        self.network_context,
                        round,
                        pong.0,
                        req_nonce
                    );
                    debug_assert!(false, "Pong nonce doesn't match our challenge Ping nonce");
                }
```

**File:** network/framework/src/protocols/health_checker/mod.rs (L343-354)
```rust
            Err(err) => {
                warn!(
                    NetworkSchema::new(&self.network_context).remote_peer(&peer_id),
                    round = round,
                    "{} Ping failed for peer: {} round: {} with error: {:#}",
                    self.network_context,
                    peer_id.short_str(),
                    round,
                    err
                );
                self.network_interface
                    .increment_peer_round_failure(peer_id, round);
```

**File:** config/src/config/network_config.rs (L38-44)
```rust
pub const PING_INTERVAL_MS: u64 = 10_000;
pub const PING_TIMEOUT_MS: u64 = 20_000;
pub const PING_FAILURES_TOLERATED: u64 = 3;
pub const CONNECTIVITY_CHECK_INTERVAL_MS: u64 = 5000;
pub const MAX_CONNECTION_DELAY_MS: u64 = 60_000; /* 1 minute */
pub const MAX_FULLNODE_OUTBOUND_CONNECTIONS: usize = 6;
pub const MAX_INBOUND_CONNECTIONS: usize = 100;
```

**File:** network/framework/src/peer_manager/builder.rs (L171-175)
```rust
        max_message_size: usize,
        enable_proxy_protocol: bool,
        inbound_connection_limit: usize,
        tcp_buffer_cfg: TCPBufferCfg,
    ) -> Self {
```

**File:** network/framework/src/peer_manager/mod.rs (L463-475)
```rust
                    // Send a transport request to dial the peer
                    let request = TransportRequest::DialPeer(requested_peer_id, addr, response_tx);
                    self.transport_reqs_tx.send(request).await.unwrap();
                };
            },
            ConnectionRequest::DisconnectPeer(peer_id, disconnect_reason, resp_tx) => {
                // Update the connection disconnect metrics
                counters::update_network_connection_operation_metrics(
                    &self.network_context,
                    counters::DISCONNECT_LABEL.into(),
                    disconnect_reason.get_label(),
                );

```

**File:** network/framework/src/noise/handshake.rs (L1-50)
```rust
// Copyright (c) Aptos Foundation
// Licensed pursuant to the Innovation-Enabling Source Code License, available at https://github.com/aptos-labs/aptos-core/blob/main/LICENSE

//! The handshake module implements the handshake part of the protocol.
//! This module also implements additional anti-DoS mitigation,
//! by including a timestamp in each handshake initialization message.
//! Refer to the module's documentation for more information.
//! A successful handshake returns a [`NoiseStream`] which is defined in the
//! [stream] module.
//!
//! [stream]: crate::noise::stream

use crate::{
    application::storage::PeersAndMetadata,
    logging::NetworkSchema,
    noise::{error::NoiseHandshakeError, stream::NoiseStream},
};
use aptos_config::{
    config::{Peer, PeerRole},
    network_id::{NetworkContext, NetworkId},
};
use aptos_crypto::{noise, x25519};
use aptos_infallible::{duration_since_epoch, RwLock};
use aptos_logger::{error, trace};
use aptos_short_hex_str::{AsShortHexStr, ShortHexStr};
use aptos_types::PeerId;
use futures::io::{AsyncRead, AsyncReadExt, AsyncWrite, AsyncWriteExt};
use std::{collections::HashMap, convert::TryFrom as _, fmt::Debug, sync::Arc};

/// In a mutually authenticated network, a client message is accompanied with a timestamp.
/// This is in order to prevent replay attacks, where the attacker does not know the client's static key,
/// but can still replay a handshake message in order to force a peer into performing a few Diffie-Hellman key exchange operations.
///
/// Thus, to prevent replay attacks a responder will always check if the timestamp is strictly increasing,
/// effectively considering it as a stateful counter.
///
/// If the client timestamp has been seen before, or is not strictly increasing,
/// we can abort the handshake early and avoid heavy Diffie-Hellman computations.
/// If the client timestamp is valid, we store it.
#[derive(Default)]
pub struct AntiReplayTimestamps(HashMap<x25519::PublicKey, u64>);

impl AntiReplayTimestamps {
    /// The timestamp is sent as a payload, so that it is encrypted.
    /// Note that a millisecond value is a 16-byte value in rust,
    /// but as we use it to store a duration since UNIX_EPOCH we will never use more than 8 bytes.
    pub const TIMESTAMP_SIZE: usize = 8;

    /// obtain the current timestamp
    pub fn now() -> [u8; Self::TIMESTAMP_SIZE] {
```

**File:** network/builder/src/builder.rs (L199-204)
```rust
        network_builder.add_connection_monitoring(
            config.ping_interval_ms,
            config.ping_timeout_ms,
            config.ping_failures_tolerated,
            config.max_parallel_deserialization_tasks,
        );
```
