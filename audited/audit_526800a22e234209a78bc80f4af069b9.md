# Audit Report

## Title
Unvalidated BCS Deserialization in Backup Restore Leading to Potential DoS via Memory Exhaustion

## Summary
The backup restore process deserializes BCS-encoded proof files without validating vector sizes before memory allocation, allowing malformed backup files to trigger out-of-memory panics and crash nodes during disaster recovery operations.

## Finding Description

The backup restore functionality in `restore.rs` deserializes `TransactionAccumulatorRangeProof` and `LedgerInfoWithSignatures` from BCS-encoded files without pre-validation of the data format or size constraints. [1](#0-0) 

The `load_bcs_file` implementation directly calls `bcs::from_bytes` on the entire file contents without any size limits: [2](#0-1) 

The `AccumulatorRangeProof` struct contains two unbounded vectors of hash values: [3](#0-2) 

**The Critical Gap**: Validation only occurs during the `verify()` call at line 167, which checks that vector lengths don't exceed `MAX_ACCUMULATOR_PROOF_DEPTH` (63): [4](#0-3) 

However, this validation happens **AFTER** deserialization completes. Between lines 147-151 (deserialization) and line 167 (verification), a malformed BCS file can cause excessive memory allocation: [5](#0-4) 

**Attack Scenario**:
1. A corrupted or maliciously crafted BCS file claims `left_siblings` has 1 billion elements
2. Each `HashValue` is 32 bytes
3. `bcs::from_bytes` attempts to allocate ~32 GB of memory
4. Allocation fails â†’ Rust's default allocator panics on OOM
5. Node crashes during restore operation

This violates the invariant: **"Resource Limits: All operations must respect gas, storage, and computational limits"** - the code fails to enforce memory limits before allocation.

## Impact Explanation

This issue qualifies as **Medium Severity** under the Aptos bug bounty program:
- **"State inconsistencies requiring intervention"** - Failed restore operations require manual intervention
- **Node availability impact** - Crashes during disaster recovery procedures
- **Limited scope** - Only affects backup/restore operations, not consensus or production nodes

This does NOT qualify for Higher severities because:
- No consensus violation or funds at risk
- No impact on running validator nodes
- Requires access to backup storage infrastructure (not remote exploit)

## Likelihood Explanation

**Likelihood: Low to Medium**

While this requires access to backup files (typically controlled infrastructure), the scenario is realistic:
- Hardware failures can corrupt backup files
- Bugs in backup software could generate malformed data  
- Compromised backup storage could inject malicious files
- Accidental file corruption during transfer/storage

The impact is significant because disaster recovery is a critical operation - if restore fails when most needed (after catastrophic failure), it undermines the entire backup strategy.

## Recommendation

Add size validation before BCS deserialization. Implement one of these approaches:

**Option 1**: Add size check in `load_bcs_file`:
```rust
async fn load_bcs_file<T: DeserializeOwned>(&self, file_handle: &FileHandleRef) -> Result<T> {
    const MAX_BCS_FILE_SIZE: usize = 100_000_000; // 100 MB reasonable limit
    let bytes = self.read_all(file_handle).await?;
    ensure!(
        bytes.len() <= MAX_BCS_FILE_SIZE,
        "BCS file exceeds maximum size limit: {} > {}",
        bytes.len(),
        MAX_BCS_FILE_SIZE
    );
    Ok(bcs::from_bytes(&bytes)?)
}
```

**Option 2**: Use depth-limited deserialization (protects against nested structures):
```rust
async fn load_bcs_file<T: DeserializeOwned>(&self, file_handle: &FileHandleRef) -> Result<T> {
    const MAX_DEPTH: usize = 16;
    Ok(bcs::from_bytes_with_limit(&self.read_all(file_handle).await?, MAX_DEPTH)?)
}
```

**Option 3**: Add specific validation for proof vectors before constructing objects (most precise):
```rust
// After deserialization, before using the proof
ensure!(
    range_proof.left_siblings().len() <= MAX_ACCUMULATOR_PROOF_DEPTH,
    "Proof left_siblings exceeds maximum depth"
);
ensure!(
    range_proof.right_siblings().len() <= MAX_ACCUMULATOR_PROOF_DEPTH,
    "Proof right_siblings exceeds maximum depth"
);
```

The recommended approach is **Option 1** combined with **Option 3** for defense in depth.

## Proof of Concept

```rust
// PoC: Create malformed BCS file that claims huge vector size
use aptos_types::proof::TransactionAccumulatorRangeProof;
use aptos_crypto::HashValue;

// Create a valid proof first
let valid_proof = TransactionAccumulatorRangeProof::new(
    vec![HashValue::zero()],
    vec![HashValue::zero()],
);

// Serialize it
let mut bcs_bytes = bcs::to_bytes(&valid_proof).unwrap();

// Manually corrupt the BCS to claim 1 billion left_siblings
// BCS format: first byte is ULEB128 encoded length
// Replace with malicious length (requires understanding ULEB128 encoding)
// For 1 billion: 0x80, 0x94, 0xEB, 0xDC, 0x03 in ULEB128
bcs_bytes[0..5].copy_from_slice(&[0x80, 0x94, 0xEB, 0xDC, 0x03]);

// Attempt to deserialize - this will try to allocate ~32 GB
// In a real scenario, write this to a backup file
// Then run restore - it will panic on OOM
let result: Result<TransactionAccumulatorRangeProof, _> = bcs::from_bytes(&bcs_bytes);
// This will either panic (OOM) or return deserialization error if not enough bytes
```

To test in restore context:
1. Create a corrupted BCS backup file with inflated vector lengths
2. Place it in backup storage
3. Run restore operation: `aptos-db-tool restore ...`
4. Observe node panic during deserialization of proof file

**Note**: This PoC demonstrates the vulnerability concept. Actual exploitation would require crafting valid ULEB128-encoded lengths with minimal trailing data to trigger allocation before running out of bytes.

### Citations

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L147-151)
```rust
        let (range_proof, ledger_info) = storage
            .load_bcs_file::<(TransactionAccumulatorRangeProof, LedgerInfoWithSignatures)>(
                &manifest.proof,
            )
            .await?;
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L167-167)
```rust
        txn_list_with_proof.verify(ledger_info.ledger_info(), Some(manifest.first_version))?;
```

**File:** storage/backup/backup-cli/src/utils/storage_ext.rs (L31-32)
```rust
    async fn load_bcs_file<T: DeserializeOwned>(&self, file_handle: &FileHandleRef) -> Result<T> {
        Ok(bcs::from_bytes(&self.read_all(file_handle).await?)?)
```

**File:** types/src/proof/definition.rs (L575-586)
```rust
#[derive(Clone, Deserialize, Serialize)]
pub struct AccumulatorRangeProof<H> {
    /// The siblings on the left of the path from the first leaf to the root. Siblings are ordered
    /// from the bottom level to the root level.
    left_siblings: Vec<HashValue>,

    /// The sliblings on the right of the path from the last leaf to the root. Siblings are ordered
    /// from the bottom level to the root level.
    right_siblings: Vec<HashValue>,

    phantom: PhantomData<H>,
}
```

**File:** types/src/proof/definition.rs (L636-647)
```rust
        ensure!(
            self.left_siblings.len() <= MAX_ACCUMULATOR_PROOF_DEPTH,
            "Proof has more than {} ({}) left siblings.",
            MAX_ACCUMULATOR_PROOF_DEPTH,
            self.left_siblings.len(),
        );
        ensure!(
            self.right_siblings.len() <= MAX_ACCUMULATOR_PROOF_DEPTH,
            "Proof has more than {} ({}) right siblings.",
            MAX_ACCUMULATOR_PROOF_DEPTH,
            self.right_siblings.len(),
        );
```
