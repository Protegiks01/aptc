# Audit Report

## Title
Validator Node Panic via Forked Block Certificate in `send_for_execution` - Unhandled None from `path_from_ordered_root`

## Summary
The `send_for_execution` method in the consensus layer incorrectly handles the case where a block is not a descendant of the ordered root, causing validator nodes to panic when processing legitimate QuorumCerts for forked blocks. This vulnerability enables denial-of-service attacks against validators through crafted but validly-signed SyncInfo messages.

## Finding Description

The vulnerability exists in the interaction between three components:

**1. Documented Semantics of `path_from_ordered_root`:**

The `BlockReader` trait explicitly documents that `path_from_ordered_root` returns `None` when "a given block is not the successor of the root." [1](#0-0) 

**2. Implementation Confirms This Behavior:**

The `path_from_root_to_block` implementation traverses backwards from a target block to the root. If the traversal reaches a block at or below the root round but the block ID doesn't match the root ID (indicating the block is on a different fork), it correctly returns `None`: [2](#0-1) [3](#0-2) 

**3. Mishandling in `send_for_execution`:**

However, `send_for_execution` treats this `None` return value as impossible. It uses `unwrap_or_default()` to convert `None` to an empty vector, then immediately asserts the vector is non-empty, causing a panic: [4](#0-3) 

**4. Insufficient Validation in Callers:**

Both `insert_quorum_cert` and `insert_ordered_cert` call `send_for_execution` after only validating that the commit round is greater than the ordered root round—they do NOT verify that the commit block is a descendant of the ordered root: [5](#0-4) [6](#0-5) 

**Attack Path:**

1. During normal consensus operation, the BlockTree explicitly supports multiple forks through its parent-child link structure: [7](#0-6) 

2. A forked block exists in the block store on a branch that is not a descendant of the current ordered root

3. This forked block receives a valid QuorumCert with 2f+1 signatures (this occurs naturally during consensus)

4. An attacker sends a SyncInfo message containing this QuorumCert to a victim validator

5. The validator processes the SyncInfo through `process_sync_info_msg`, which verifies signatures: [8](#0-7) 

6. The flow proceeds to `add_certs` and then `insert_quorum_cert`: [9](#0-8) 

7. Since the commit block exists and has a higher round than the ordered root, `send_for_execution` is called

8. `path_from_ordered_root` correctly returns `None` because the block is on a different fork

9. The assertion fails and the validator panics

This violates the consensus liveness invariant: validators should handle valid network messages without crashing.

## Impact Explanation

**High Severity** per Aptos bug bounty criteria (up to $50,000):

This vulnerability enables **validator node crashes** through crafted but validly-signed messages:

- **Consensus Layer Impact**: The crash occurs during certificate processing in the consensus layer, not just in the API layer, making it more severe than typical API crashes

- **Liveness Disruption**: Repeated exploitation can target multiple validators, disrupting consensus rounds and delaying block finalization

- **Temporary Availability Loss**: Validators crash but can recover by restarting, distinguishing this from Critical severity issues

- **No Safety Violation**: The vulnerability affects liveness only—it doesn't enable double-spending, chain splits, fund theft, or permanent state corruption

This fits the High severity category for "API Crashes" affecting network participation, elevated by its consensus layer location and potential for coordinated attacks.

## Likelihood Explanation

**High Likelihood:**

1. **Natural Precondition**: Forks occur routinely during normal consensus when validators observe different proposals for the same round or experience transient network partitions

2. **Low Attack Barrier**: 
   - Any network participant can send SyncInfo messages to validators
   - The attack requires a valid QuorumCert with 2f+1 signatures, but these exist naturally during forking
   - No validator credentials or special permissions needed

3. **Deterministic Exploitation**: Once a valid QC for a forked block is obtained, the attack succeeds reliably against any validator processing the message

4. **Difficult Detection**: The panic appears as an assertion failure in normal consensus operation, making it hard to distinguish from implementation bugs without detailed investigation

## Recommendation

Add validation to verify that blocks are descendants of the ordered root before calling `send_for_execution`:

```rust
pub async fn insert_quorum_cert(
    &self,
    qc: &QuorumCert,
    retriever: &mut BlockRetriever,
) -> anyhow::Result<()> {
    // ... existing code ...
    
    if self.ordered_root().round() < qc.commit_info().round() {
        // NEW: Verify the commit block is a descendant of ordered root
        if self.path_from_ordered_root(qc.commit_info().id()).is_none() {
            warn!(
                "QuorumCert commit block {} is not a descendant of ordered root, skipping execution",
                qc.commit_info().id()
            );
            return Ok(());
        }
        
        SUCCESSFUL_EXECUTED_WITH_REGULAR_QC.inc();
        self.send_for_execution(qc.into_wrapped_ledger_info()).await?;
        // ... rest of code ...
    }
    Ok(())
}
```

Apply similar checks in `insert_ordered_cert` and consider replacing the `assert!` in `send_for_execution` with proper error handling.

## Proof of Concept

The vulnerability can be demonstrated by:
1. Creating a test scenario with two forked blocks at the same round
2. Setting one fork as the ordered root
3. Obtaining a valid QuorumCert for the other fork
4. Sending a SyncInfo message with this QC through `process_sync_info_msg`
5. Observing the validator panic at the assertion in `send_for_execution`

The complete execution path is traceable through the cited code locations, demonstrating the vulnerability without requiring test code modifications.

### Citations

**File:** consensus/src/block_storage/mod.rs (L39-46)
```rust
    /// Returns all the blocks between the ordered/commit root and the given block, including the given block
    /// but excluding the root.
    /// In case a given block is not the successor of the root, return None.
    /// For example if a tree is b0 <- b1 <- b2 <- b3, then
    /// path_from_root(b2) -> Some([b2, b1])
    /// path_from_root(b0) -> Some([])
    /// path_from_root(a) -> None
    fn path_from_ordered_root(&self, block_id: HashValue) -> Option<Vec<Arc<PipelinedBlock>>>;
```

**File:** consensus/src/block_storage/block_tree.rs (L519-546)
```rust
    pub(super) fn path_from_root_to_block(
        &self,
        block_id: HashValue,
        root_id: HashValue,
        root_round: u64,
    ) -> Option<Vec<Arc<PipelinedBlock>>> {
        let mut res = vec![];
        let mut cur_block_id = block_id;
        loop {
            match self.get_block(&cur_block_id) {
                Some(ref block) if block.round() <= root_round => {
                    break;
                },
                Some(block) => {
                    cur_block_id = block.parent_id();
                    res.push(block);
                },
                None => return None,
            }
        }
        // At this point cur_block.round() <= self.root.round()
        if cur_block_id != root_id {
            return None;
        }
        // Called `.reverse()` to get the chronically increased order.
        res.reverse();
        Some(res)
    }
```

**File:** consensus/src/block_storage/block_tree.rs (L548-553)
```rust
    pub(super) fn path_from_ordered_root(
        &self,
        block_id: HashValue,
    ) -> Option<Vec<Arc<PipelinedBlock>>> {
        self.path_from_root_to_block(block_id, self.ordered_root_id, self.ordered_root().round())
    }
```

**File:** consensus/src/block_storage/block_store.rs (L73-84)
```rust
/// Example tree block structure based on parent links.
///                         ╭--> A3
/// Genesis--> B0--> B1--> B2--> B3
///             ╰--> C1--> C2
///                         ╰--> D3
///
/// Example corresponding tree block structure for the QC links (must follow QC constraints).
///                         ╭--> A3
/// Genesis--> B0--> B1--> B2--> B3
///             ├--> C1
///             ├--------> C2
///             ╰--------------> D3
```

**File:** consensus/src/block_storage/block_store.rs (L327-331)
```rust
        let blocks_to_commit = self
            .path_from_ordered_root(block_id_to_commit)
            .unwrap_or_default();

        assert!(!blocks_to_commit.is_empty());
```

**File:** consensus/src/block_storage/sync_manager.rs (L116-173)
```rust
    pub async fn add_certs(
        &self,
        sync_info: &SyncInfo,
        mut retriever: BlockRetriever,
    ) -> anyhow::Result<()> {
        // When the local ordered round is very old than the received sync_info, this function will
        // (1) resets the block store with highest commit cert = sync_info.highest_quorum_cert()
        // (2) insert all the blocks between (inclusive) highest_commit_cert.commit_info().id() to
        // highest_quorum_cert.certified_block().id() into the block store and storage
        // (3) insert the quorum cert for all the above blocks into the block store and storage
        // (4) executes all the blocks that are ordered while inserting the above quorum certs
        self.sync_to_highest_quorum_cert(
            sync_info.highest_quorum_cert().clone(),
            sync_info.highest_commit_cert().clone(),
            &mut retriever,
        )
        .await?;

        self.sync_to_highest_commit_cert(
            sync_info.highest_commit_cert().ledger_info(),
            retriever.network.clone(),
        )
        .await;

        // The insert_ordered_cert(order_cert) function call expects that order_cert.commit_info().id() block
        // is already stored in block_store. So, we first call insert_quorum_cert(highest_quorum_cert).
        // This call will ensure that the highest ceritified block along with all its ancestors are inserted
        // into the block store.
        self.insert_quorum_cert(sync_info.highest_quorum_cert(), &mut retriever)
            .await?;

        // Even though we inserted the highest_quorum_cert (and its ancestors) in the above step,
        // we still need to insert ordered cert explicitly. This will send the highest ordered block
        // to execution.
        if self.order_vote_enabled {
            self.insert_ordered_cert(&sync_info.highest_ordered_cert())
                .await?;
        } else {
            // When order votes are disabled, the highest_ordered_cert().certified_block().id() need not be
            // one of the ancestors of highest_quorum_cert.certified_block().id() due to forks. So, we call
            // insert_quorum_cert instead of insert_ordered_cert as in the above case. This will ensure that
            // highest_ordered_cert().certified_block().id() is inserted the block store.
            self.insert_quorum_cert(
                &self
                    .highest_ordered_cert()
                    .as_ref()
                    .clone()
                    .into_quorum_cert(self.order_vote_enabled)?,
                &mut retriever,
            )
            .await?;
        }

        if let Some(tc) = sync_info.highest_2chain_timeout_cert() {
            self.insert_2chain_timeout_certificate(Arc::new(tc.clone()))?;
        }
        Ok(())
    }
```

**File:** consensus/src/block_storage/sync_manager.rs (L186-189)
```rust
        if self.ordered_root().round() < qc.commit_info().round() {
            SUCCESSFUL_EXECUTED_WITH_REGULAR_QC.inc();
            self.send_for_execution(qc.into_wrapped_ledger_info())
                .await?;
```

**File:** consensus/src/block_storage/sync_manager.rs (L210-219)
```rust
        if self.ordered_root().round() < ordered_cert.ledger_info().ledger_info().round() {
            if let Some(ordered_block) = self.get_block(ordered_cert.commit_info().id()) {
                if !ordered_block.block().is_nil_block() {
                    observe_block(
                        ordered_block.block().timestamp_usecs(),
                        BlockStage::OC_ADDED,
                    );
                }
                SUCCESSFUL_EXECUTED_WITH_ORDER_VOTE_QC.inc();
                self.send_for_execution(ordered_cert.clone()).await?;
```

**File:** consensus/src/round_manager.rs (L878-907)
```rust
    async fn sync_up(&mut self, sync_info: &SyncInfo, author: Author) -> anyhow::Result<()> {
        let local_sync_info = self.block_store.sync_info();
        if sync_info.has_newer_certificates(&local_sync_info) {
            info!(
                self.new_log(LogEvent::ReceiveNewCertificate)
                    .remote_peer(author),
                "Local state {},\n remote state {}", local_sync_info, sync_info
            );
            // Some information in SyncInfo is ahead of what we have locally.
            // First verify the SyncInfo (didn't verify it in the yet).
            sync_info.verify(&self.epoch_state.verifier).map_err(|e| {
                error!(
                    SecurityEvent::InvalidSyncInfoMsg,
                    sync_info = sync_info,
                    remote_peer = author,
                    error = ?e,
                );
                VerifyError::from(e)
            })?;
            SYNC_INFO_RECEIVED_WITH_NEWER_CERT.inc();
            let result = self
                .block_store
                .add_certs(sync_info, self.create_block_retriever(author))
                .await;
            self.process_certificates().await?;
            result
        } else {
            Ok(())
        }
    }
```
