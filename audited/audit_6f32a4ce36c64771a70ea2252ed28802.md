# Audit Report

## Title
Missing Security Logging for Invalid Signature Attacks in Order Vote Aggregation

## Summary
The `insert_order_vote()` function in `pending_order_votes.rs` silently handles `TooLittleVotingPower` errors that occur after invalid signatures are filtered during signature aggregation. This prevents proper detection and logging of Byzantine validator attacks and signature forgery attempts, allowing malicious validators to waste resources and mask consensus failures without triggering security alerts.

## Finding Description

In the order vote aggregation process, there is a critical asymmetry in error handling between lines 138-141 and lines 147-152 in `pending_order_votes.rs`. [1](#0-0) 

When `aggregate_and_verify()` returns `TooLittleVotingPower` after filtering invalid signatures, this is treated as a normal case at lines 138-141, returning `VoteAdded(voting_power)` without any security logging.

However, other errors are properly logged: [2](#0-1) 

The vulnerability stems from the optimistic signature verification pattern. Individual order votes pass initial verification using `optimistic_verify()`: [3](#0-2) 

With optimistic verification enabled, invalid signatures can pass initial checks and enter the aggregator. Later, when signature aggregation is attempted in `aggregate_and_verify()`: [4](#0-3) 

If the aggregated signature verification fails, invalid signatures are filtered out at line 530. After filtering, if the remaining valid signatures have insufficient voting power to meet the quorum threshold, `try_aggregate()` returns `TooLittleVotingPower`, which propagates back to `pending_order_votes.rs` line 138-141 where it's silently treated as a normal case.

**Attack Path:**
1. Byzantine validator submits order votes with invalid/forged signatures mixed with valid signatures
2. Optimistic verification allows these to pass initial checks (validator_verifier.rs:278-283)
3. Signatures are added to `SignatureAggregator` 
4. When apparent quorum is reached, `check_voting_power()` succeeds (line 113)
5. `aggregate_and_verify()` is invoked, triggering expensive cryptographic operations (line 123)
6. Signature verification fails, `filter_invalid_signatures()` is called (ledger_info.rs:530)
7. After filtering, valid signatures < quorum threshold
8. Returns `TooLittleVotingPower` → caught at line 138-141 → no security logging

This breaks the **Cryptographic Correctness** invariant by failing to log signature verification failures, preventing detection of Byzantine behavior.

## Impact Explanation

This qualifies as **Medium Severity** based on the Aptos Bug Bounty criteria:

**Resource Exhaustion (approaching High Severity - Validator node slowdowns):**
- Byzantine validators can repeatedly trigger expensive signature aggregation and verification operations
- Each attack cycle involves: signature aggregation (ledger_info.rs:507), verification (line 523), and filtering (line 530)
- This wastes validator computational resources without detection

**Security Monitoring Gap:**
The codebase has proper security logging for other consensus failures: [5](#0-4) 

But no equivalent logging exists for filtered invalid signatures in order vote aggregation. The security events are defined: [6](#0-5) 

`SecurityEvent::ConsensusInvalidMessage` should be logged when invalid signatures are detected, but this doesn't occur in the order vote path.

## Likelihood Explanation

**High Likelihood** - Byzantine validators (up to 1/3 of the validator set per AptosBFT assumptions) can trivially exploit this:
- No special conditions required
- Can be triggered at any time during normal consensus operation  
- Optimistic verification is a standard configuration
- Attack is repeatable and undetectable without external monitoring

## Recommendation

Add security logging when `TooLittleVotingPower` is returned after signature aggregation attempts, distinguishing it from the normal accumulation case:

```rust
match verification_result {
    Ok(ledger_info_with_sig) => {
        *status = OrderVoteStatus::EnoughVotes(ledger_info_with_sig.clone());
        OrderVoteReceptionResult::NewLedgerInfoWithSignatures((
            Arc::new(quorum_cert.clone()),
            ledger_info_with_sig,
        ))
    },
    Err(VerifyError::TooLittleVotingPower { voting_power, .. }) => {
        // This case indicates invalid signatures were filtered out
        error!(
            SecurityEvent::ConsensusInvalidMessage,
            "Order vote aggregation failed after signature filtering. Valid voting power: {}, Required: {}. Invalid signatures detected and removed.",
            voting_power,
            validator_verifier.quorum_voting_power()
        );
        OrderVoteReceptionResult::VoteAdded(voting_power)
    },
    Err(e) => OrderVoteReceptionResult::ErrorAggregatingSignature(e),
}
```

Additionally, track and log which validators had signatures filtered in `filter_invalid_signatures()`: [7](#0-6) 

At line 306, after adding to pessimistic_verify_set, log a security event identifying the validator with the invalid signature.

## Proof of Concept

```rust
#[cfg(test)]
mod exploit_test {
    use super::*;
    use aptos_crypto::bls12381;
    use aptos_types::validator_verifier::random_validator_verifier;

    #[test]
    fn test_undetected_invalid_signature_attack() {
        // Setup: 4 validators, quorum = 3
        let (signers, verifier) = random_validator_verifier(4, Some(2), false);
        let mut pending_order_votes = PendingOrderVotes::new();
        let li = random_ledger_info();
        let qc = QuorumCert::dummy();

        // Attacker: Byzantine validator submits valid vote
        let valid_vote = OrderVote::new_with_signature(
            signers[0].author(),
            li.clone(),
            signers[0].sign(&li).unwrap(),
        );
        assert_eq!(
            pending_order_votes.insert_order_vote(&valid_vote, &verifier, Some(qc.clone())),
            OrderVoteReceptionResult::VoteAdded(1)
        );

        // Attacker: Submits forged signatures from other validators
        let invalid_vote_1 = OrderVote::new_with_signature(
            signers[1].author(),
            li.clone(),
            bls12381::Signature::dummy_signature(), // FORGED
        );
        let invalid_vote_2 = OrderVote::new_with_signature(
            signers[2].author(),
            li.clone(),
            bls12381::Signature::dummy_signature(), // FORGED
        );

        // These pass optimistic verification and are added
        pending_order_votes.insert_order_vote(&invalid_vote_1, &verifier, None);
        pending_order_votes.insert_order_vote(&invalid_vote_2, &verifier, None);

        // Total voting power appears to be 3 (quorum met)
        // But aggregation will fail and filter invalid signatures
        // Result: VoteAdded(1) - NO SECURITY LOGGING OF FORGERY ATTEMPT
        // Expected: SecurityEvent::ConsensusInvalidMessage should be logged
    }
}
```

## Notes

This vulnerability specifically affects the order vote consensus path introduced for Aptos's ordering mechanism. The asymmetric handling between lines 138-141 (silent) and lines 147-152 (logged with "MUST_FIX") indicates this is likely an oversight rather than intentional design. Byzantine validators, which AptosBFT is designed to tolerate (up to 1/3 of the validator set), are explicitly part of the threat model, making this a valid security concern requiring proper detection and logging mechanisms.

### Citations

**File:** consensus/src/pending_order_votes.rs (L138-146)
```rust
                            Err(VerifyError::TooLittleVotingPower { voting_power, .. }) => {
                                OrderVoteReceptionResult::VoteAdded(voting_power)
                            },
                            Err(e) => OrderVoteReceptionResult::ErrorAggregatingSignature(e),
                        }
                    },
                    Err(VerifyError::TooLittleVotingPower { voting_power, .. }) => {
                        OrderVoteReceptionResult::VoteAdded(voting_power)
                    },
```

**File:** consensus/src/pending_order_votes.rs (L147-153)
```rust
                    Err(error) => {
                        error!(
                            "MUST_FIX: order vote received could not be added: {}, order vote: {}",
                            error, order_vote
                        );
                        OrderVoteReceptionResult::ErrorAddingVote(error)
                    },
```

**File:** types/src/validator_verifier.rs (L278-284)
```rust
        if (!self.optimistic_sig_verification || self.pessimistic_verify_set.contains(&author))
            && !signature_with_status.is_verified()
        {
            self.verify(author, message, signature_with_status.signature())?;
            signature_with_status.set_verified();
        }
        Ok(())
```

**File:** types/src/validator_verifier.rs (L305-308)
```rust
                } else {
                    self.add_pessimistic_verify_set(account_address);
                    None
                }
```

**File:** types/src/ledger_info.rs (L523-534)
```rust
        match verifier.verify_multi_signatures(&self.data, &aggregated_sig) {
            Ok(_) => {
                // We are not marking all the signatures as "verified" here, as two malicious
                // voters can collude and create a valid aggregated signature.
                Ok((self.data.clone(), aggregated_sig))
            },
            Err(_) => {
                self.filter_invalid_signatures(verifier);

                let aggregated_sig = self.try_aggregate(verifier)?;
                Ok((self.data.clone(), aggregated_sig))
            },
```

**File:** consensus/src/pending_votes.rs (L300-307)
```rust
                error!(
                    SecurityEvent::ConsensusEquivocatingVote,
                    remote_peer = vote.author(),
                    vote = vote,
                    previous_vote = previously_seen_vote
                );

                return VoteReceptionResult::EquivocateVote;
```

**File:** crates/aptos-logger/src/security.rs (L38-44)
```rust
    ConsensusInvalidMessage,

    /// Consensus received an equivocating vote
    ConsensusEquivocatingVote,

    /// Consensus received an equivocating order vote
    ConsensusEquivocatingOrderVote,
```
