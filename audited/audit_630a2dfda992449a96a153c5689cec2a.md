# Audit Report

## Title
Missing BLS Signature Verification in One-Off State Snapshot Restoration Enables Arbitrary State Injection

## Summary
The one-off state snapshot restoration command (`db-tool restore oneoff state-snapshot`) fails to verify BLS signatures on `LedgerInfoWithSignatures` objects, allowing an attacker with filesystem access to backup storage to inject completely arbitrary state into a node by replacing backup files with malicious but internally consistent data.

## Finding Description

The backup restoration system has two code paths:
1. **Coordinated restore** (`bootstrap-db`) - verifies BLS signatures via `EpochHistory`
2. **One-off restore** (`oneoff state-snapshot`) - skips signature verification

The vulnerability exists in the one-off restoration path where `epoch_history` is explicitly set to `None`: [1](#0-0) 

During restoration, signature verification is conditionally skipped based on whether `epoch_history` is present: [2](#0-1) 

The only cryptographic verification performed is:

1. **TransactionInfoWithProof verification** - Only validates Merkle accumulator proofs, NOT BLS signatures: [3](#0-2) 

The underlying `verify_transaction_info` function only checks Merkle proofs: [4](#0-3) 

2. **SparseMerkleRangeProof verification** - Validates chunk consistency with the root hash: [5](#0-4) 

However, this only proves internal consistency—the attacker controls both the root hash and the proofs.

**Attack Scenario:**

1. Attacker gains filesystem access to backup storage (cloud bucket misconfiguration, compromised backup credentials, etc.)
2. Attacker generates a malicious state tree with arbitrary values (e.g., inflated account balances, modified validator set)
3. Attacker computes the Merkle root hash of this malicious state
4. Attacker creates valid `SparseMerkleRangeProofs` for all chunks (trivial since they have the data)
5. Attacker creates a `TransactionInfoWithProof` with the malicious root hash
6. Attacker creates a `LedgerInfoWithSignatures` with invalid/missing BLS signatures (doesn't matter—won't be checked)
7. Attacker replaces all backup files (manifest, proof files, blob files)
8. Node operator runs: `aptos-db-tool restore oneoff state-snapshot --state-manifest <manifest> ...`
9. Restoration succeeds without any validator signature verification
10. Node now has completely fabricated state, breaking consensus

**Broken Invariants:**
- **Cryptographic Correctness**: BLS signatures are not verified
- **State Consistency**: State is not bound to any validator consensus
- **Consensus Safety**: Different nodes could restore different states

## Impact Explanation

**Critical Severity** - This vulnerability enables:

1. **Arbitrary State Injection**: Attacker can inject any state values, including:
   - Inflated account balances (fund creation/theft)
   - Modified validator set (governance takeover)
   - Altered smart contract state (protocol manipulation)
   - Corrupted system resources

2. **Consensus Violation**: Nodes restored with malicious backups will have different state than the canonical chain, causing:
   - Permanent network partition
   - Conflicting transaction execution
   - Invalid block proposals

3. **Fund Theft**: By injecting inflated balances or modifying ownership, attacker can steal funds

4. **Non-Recoverable Damage**: Once a node is restored with malicious state, it requires manual intervention and re-synchronization from trusted sources

This meets the **Critical Severity** criteria: Loss of Funds, Consensus/Safety violations, and Non-recoverable network partition.

## Likelihood Explanation

**Moderate to High Likelihood:**

**Attacker Requirements:**
- Filesystem access to backup storage (S3 bucket, local storage, NFS mount)
- Ability to generate valid Merkle proofs (trivial with any Merkle tree library)
- Knowledge of the one-off restore command

**Realistic Scenarios:**
1. **Cloud Storage Misconfiguration**: Publicly accessible S3 buckets with backup data (common misconfiguration)
2. **Compromised Backup Credentials**: Stolen AWS credentials with backup write access
3. **Supply Chain Attack**: Compromised backup service provider
4. **Insider Threat**: Malicious node operator or backup administrator
5. **Automated Backup Systems**: Compromised CI/CD pipeline that generates backups

**Exploitation Complexity:** LOW
- No cryptographic breaking required
- Standard Merkle tree construction tools available
- Simple file replacement operation
- Well-documented restoration command

The likelihood is significant because backup storage is often a weak point in infrastructure security, and the attack requires no specialized cryptographic knowledge.

## Recommendation

**Immediate Fix:** Always require and verify BLS signatures during state snapshot restoration.

1. **Remove the one-off restore option** or make `epoch_history` mandatory:

```rust
// In storage/db-tool/src/restore.rs
Oneoff::StateSnapshot {
    storage,
    opt,
    global,
} => {
    // Load epoch history first - REQUIRED for security
    let epoch_history = EpochHistoryRestoreController::new(
        /* manifest handles from config or required parameter */,
        global.clone().try_into()?,
        storage.init_storage().await?,
    )
    .run()
    .await?;
    
    StateSnapshotRestoreController::new(
        opt,
        global.try_into()?,
        storage.init_storage().await?,
        Some(Arc::new(epoch_history)), // ALWAYS require epoch_history
    )
    .run()
    .await?;
},
```

2. **Add signature verification as a mandatory step:** [2](#0-1) 

Change from optional to mandatory:

```rust
// Make epoch_history non-optional in the struct
pub struct StateSnapshotRestoreController {
    // ... other fields
    epoch_history: Arc<EpochHistory>, // Remove Option<>
}

// In run_impl, always verify signatures
let epoch_history = self.epoch_history.as_ref();
epoch_history.verify_ledger_info(&li)?; // Always verify, no if let
```

3. **Add explicit warnings** if attempting to restore without signature verification:

```rust
ensure!(
    epoch_history.is_some(),
    "SECURITY ERROR: State snapshot restoration requires epoch history for BLS signature verification. \
     Restoring without signature verification allows arbitrary state injection attacks."
);
```

4. **Document the security requirement** in the command help text and operational documentation.

## Proof of Concept

```bash
#!/bin/bash
# PoC: Demonstrate arbitrary state injection via backup replacement

# Step 1: Generate malicious state tree
# (Using hypothetical tool - actual implementation would use aptos-jellyfish-merkle)
./generate_malicious_state.sh \
  --account 0x1 \
  --balance 1000000000000 \
  --output malicious_state_chunk.bin

# Step 2: Compute Merkle root and generate proofs
./compute_merkle_root.sh \
  --input malicious_state_chunk.bin \
  --output malicious_root_hash.txt \
  --proofs malicious_proofs/

# Step 3: Create fake manifest
cat > malicious_manifest.json <<EOF
{
  "version": 12345,
  "epoch": 100,
  "root_hash": "$(cat malicious_root_hash.txt)",
  "chunks": [{
    "first_idx": 0,
    "last_idx": 999,
    "first_key": "0x00...",
    "last_key": "0xff...",
    "blobs": "chunk_0.bin",
    "proof": "proof_0.bin"
  }],
  "proof": "fake_txn_proof.bin"
}
EOF

# Step 4: Create fake TransactionInfoWithProof
# (Can be completely fabricated - signatures won't be checked)
./create_fake_proof.sh \
  --root-hash $(cat malicious_root_hash.txt) \
  --output fake_txn_proof.bin

# Step 5: Replace backup files in storage
aws s3 cp malicious_manifest.json s3://backup-bucket/state_snapshot_manifest.json
aws s3 cp malicious_state_chunk.bin s3://backup-bucket/chunk_0.bin
aws s3 cp malicious_proofs/proof_0.bin s3://backup-bucket/proof_0.bin
aws s3 cp fake_txn_proof.bin s3://backup-bucket/fake_txn_proof.bin

# Step 6: Victim node operator runs one-off restore
aptos-db-tool restore oneoff state-snapshot \
  --state-manifest s3://backup-bucket/state_snapshot_manifest.json \
  --state-into-version 12345 \
  --target-db-dir /opt/aptos/data

# Result: Node now has malicious state with inflated balances
# No signature verification occurred!
```

**Verification Steps:**
1. Set up backup storage with legitimate backups
2. Generate malicious state tree with modified account balances
3. Replace backup files with malicious versions
4. Run one-off restore command
5. Verify node restored malicious state successfully
6. Check that no signature verification errors occurred
7. Demonstrate state divergence from canonical chain

## Notes

This vulnerability exists because the one-off restore path was designed for operational convenience (quick restoration without epoch history) but sacrificed the critical security property of cryptographic verification. The code assumes that filesystem access to backups is equivalent to trust, which violates defense-in-depth principles.

The coordinated restore path (`bootstrap-db`) correctly verifies signatures via `EpochHistory`, demonstrating that the developers understood the security requirement but created an unsafe alternative path. This is a classic example of security-versus-usability trade-offs leading to exploitable vulnerabilities.

**Related Code Paths:**
- Transaction restoration also has similar issues with optional `epoch_history`
- The `EpochHistory::verify_ledger_info` implementation is correct when called
- The `StateSnapshotRestore` receiver correctly verifies `SparseMerkleRangeProofs`

The fix must make BLS signature verification mandatory for all restoration paths, not just the coordinated one.

### Citations

**File:** storage/db-tool/src/restore.rs (L88-95)
```rust
                        StateSnapshotRestoreController::new(
                            opt,
                            global.try_into()?,
                            storage.init_storage().await?,
                            None, /* epoch_history */
                        )
                        .run()
                        .await?;
```

**File:** storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs (L125-136)
```rust
        let (txn_info_with_proof, li): (TransactionInfoWithProof, LedgerInfoWithSignatures) =
            self.storage.load_bcs_file(&manifest.proof).await?;
        txn_info_with_proof.verify(li.ledger_info(), manifest.version)?;
        let state_root_hash = txn_info_with_proof
            .transaction_info()
            .ensure_state_checkpoint_hash()?;
        ensure!(
            state_root_hash == manifest.root_hash,
            "Root hash mismatch with that in proof. root hash: {}, expected: {}",
            manifest.root_hash,
            state_root_hash,
        );
```

**File:** storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs (L137-139)
```rust
        if let Some(epoch_history) = self.epoch_history.as_ref() {
            epoch_history.verify_ledger_info(&li)?;
        }
```

**File:** types/src/proof/mod.rs (L40-60)
```rust
fn verify_transaction_info(
    ledger_info: &LedgerInfo,
    transaction_version: Version,
    transaction_info: &TransactionInfo,
    ledger_info_to_transaction_info_proof: &TransactionAccumulatorProof,
) -> Result<()> {
    ensure!(
        transaction_version <= ledger_info.version(),
        "Transaction version {} is newer than LedgerInfo version {}.",
        transaction_version,
        ledger_info.version(),
    );

    let transaction_info_hash = transaction_info.hash();
    ledger_info_to_transaction_info_proof.verify(
        ledger_info.transaction_accumulator_hash(),
        transaction_info_hash,
        transaction_version,
    )?;

    Ok(())
```

**File:** storage/jellyfish-merkle/src/restore/mod.rs (L390-391)
```rust
        // Verify what we have added so far is all correct.
        self.verify(proof)?;
```
