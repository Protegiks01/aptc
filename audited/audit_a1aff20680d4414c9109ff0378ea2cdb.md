# Audit Report

## Title
Consensus Node Liveness Failure Due to Missing Protocol Fallback Mechanism

## Summary
When consensus nodes cannot establish RPC communication due to protocol mismatches with all available peers, the system lacks safe fallback behavior, causing nodes to enter a non-functional state where they cannot sync blocks or participate in consensus.

## Finding Description

The Aptos consensus network layer defines preferred protocols in order of preference: [1](#0-0) [2](#0-1) 

When a consensus node attempts to sync blocks via RPC, the network client must select a protocol supported by both the local node and the remote peer: [3](#0-2) 

**Critical Issue**: If none of the preferred RPC protocols are supported by a peer (despite having a valid connection established via other protocols), the function returns an error with no fallback mechanism. This error propagates through the consensus sync chain:

1. The RPC error is returned from `send_to_peer_rpc`
2. It propagates through `ConsensusNetworkClient::send_rpc` to `NetworkSender::send_rpc`: [4](#0-3) 

3. Then to `NetworkSender::request_block`: [5](#0-4) 

4. The sync manager retries with different peers, but if ALL peers lack compatible RPC protocols: [6](#0-5) 

5. **Most Critical**: In the main consensus event loop, sync errors are merely logged and the node continues processing: [7](#0-6) 

**The Vulnerability**: The node remains operational but cannot sync blocks or participate in consensus. There is no:
- Automatic protocol renegotiation
- Connection reset with fallback protocols  
- Graceful degradation to alternative sync methods
- Alert mechanism for operators
- Automatic recovery attempt

This breaks the **Consensus Liveness** invariant - a connected node with valid peers should be able to participate in consensus.

## Impact Explanation

**Medium Severity** - This causes **state inconsistencies requiring intervention** per the Aptos bug bounty criteria:

- Individual validator nodes become unable to sync state while remaining nominally "running"
- Operators may not immediately notice the failure (only logged warnings)
- Affected nodes cannot vote on proposals or produce blocks
- Network liveness degrades proportionally to the number of affected nodes
- Requires manual operator intervention to diagnose and resolve

This doesn't reach High severity because it doesn't cause total network failure (only affects misconfigured nodes) and doesn't enable direct attacks.

## Likelihood Explanation

**Medium Likelihood** - This can realistically occur during:

1. **Rolling network upgrades** where protocol support changes between versions
2. **Configuration errors** where nodes have mismatched protocol preferences  
3. **Version skew scenarios** during deployment of protocol changes
4. **Partial network partitions** where some nodes only support older/newer protocols

The likelihood increases in large decentralized networks where coordinating protocol upgrades across all validators is challenging.

## Recommendation

Implement a comprehensive fallback mechanism:

```rust
// In NetworkClient::get_preferred_protocol_for_peer
fn get_preferred_protocol_for_peer(
    &self,
    peer: &PeerNetworkId,
    preferred_protocols: &[ProtocolId],
) -> Result<ProtocolId, Error> {
    let protocols_supported_by_peer = self.get_supported_protocols(peer)?;
    
    // Try preferred protocols first
    for protocol in preferred_protocols {
        if protocols_supported_by_peer.contains(*protocol) {
            return Ok(*protocol);
        }
    }
    
    // FALLBACK: Find ANY common protocol from all supported protocols
    let all_protocols = ProtocolId::all();
    for protocol in all_protocols {
        if protocols_supported_by_peer.contains(*protocol) {
            warn!(
                "Falling back to non-preferred protocol {:?} for peer {:?}",
                protocol, peer
            );
            return Ok(*protocol);
        }
    }
    
    // Only error if absolutely no common protocols exist
    Err(Error::NetworkError(format!(
        "No common protocols with peer! Peer: {:?}, supported: {:?}",
        peer, protocols_supported_by_peer
    )))
}
```

Additionally, in the consensus event loop, implement automatic recovery:

```rust
// In RoundManager main event loop
match result {
    Ok(_) => trace!(RoundStateLogSchema::new(round_state)),
    Err(e) => {
        counters::ERROR_COUNT.inc();
        error!(kind = error_kind(&e), "Consensus sync error: {:#}", e);
        
        // NEW: Trigger recovery for protocol errors
        if is_protocol_error(&e) {
            self.attempt_protocol_recovery().await;
        }
    }
}
```

## Proof of Concept

```rust
// This demonstrates the error path when protocols fail
// File: consensus/src/network_tests.rs (test demonstration)

#[tokio::test]
async fn test_protocol_fallback_failure() {
    // Setup: Create two nodes with incompatible RPC protocols
    let mut node1 = create_test_node(vec![ProtocolId::ConsensusRpcCompressed]);
    let mut node2 = create_test_node(vec![ProtocolId::ConsensusDirectSendBcs]); // Only direct send, no RPC
    
    // Connect them (succeeds because they have *some* common protocol for handshake)
    connect_peers(&mut node1, &mut node2).await;
    
    // Node1 tries to request block from Node2 via RPC
    let result = node1.network
        .request_block(
            BlockRetrievalRequest::new_test(),
            node2.author,
            Duration::from_secs(5)
        )
        .await;
    
    // FAILS: Returns error because no common RPC protocol
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("None of the preferred protocols"));
    
    // Node1 is now stuck - cannot sync, but continues running
    // No automatic recovery mechanism exists
}
```

**Notes**

This vulnerability represents a **reliability gap** in protocol negotiation rather than an active security exploit. While it doesn't enable direct attacks, it creates operational risk during network upgrades and can cause consensus participation failures. The missing fallback behavior violates defensive programming principles for distributed systems and should be addressed to improve network resilience.

### Citations

**File:** consensus/src/network_interface.rs (L157-161)
```rust
pub const RPC: &[ProtocolId] = &[
    ProtocolId::ConsensusRpcCompressed,
    ProtocolId::ConsensusRpcBcs,
    ProtocolId::ConsensusRpcJson,
];
```

**File:** consensus/src/network_interface.rs (L164-168)
```rust
pub const DIRECT_SEND: &[ProtocolId] = &[
    ProtocolId::ConsensusDirectSendCompressed,
    ProtocolId::ConsensusDirectSendBcs,
    ProtocolId::ConsensusDirectSendJson,
];
```

**File:** network/framework/src/application/interface.rs (L142-158)
```rust
    fn get_preferred_protocol_for_peer(
        &self,
        peer: &PeerNetworkId,
        preferred_protocols: &[ProtocolId],
    ) -> Result<ProtocolId, Error> {
        let protocols_supported_by_peer = self.get_supported_protocols(peer)?;
        for protocol in preferred_protocols {
            if protocols_supported_by_peer.contains(*protocol) {
                return Ok(*protocol);
            }
        }
        Err(Error::NetworkError(format!(
            "None of the preferred protocols are supported by this peer! \
            Peer: {:?}, supported protocols: {:?}",
            peer, protocols_supported_by_peer
        )))
    }
```

**File:** consensus/src/network.rs (L277-314)
```rust
    pub async fn request_block(
        &self,
        retrieval_request: BlockRetrievalRequest,
        from: Author,
        timeout: Duration,
    ) -> anyhow::Result<BlockRetrievalResponse> {
        fail_point!("consensus::send::any", |_| {
            Err(anyhow::anyhow!("Injected error in request_block"))
        });
        fail_point!("consensus::send::block_retrieval", |_| {
            Err(anyhow::anyhow!("Injected error in request_block"))
        });

        ensure!(from != self.author, "Retrieve block from self");
        let msg = ConsensusMsg::BlockRetrievalRequest(Box::new(retrieval_request.clone()));
        counters::CONSENSUS_SENT_MSGS
            .with_label_values(&[msg.name()])
            .inc();
        let response_msg = monitor!("block_retrieval", self.send_rpc(from, msg, timeout).await)?;
        let response = match response_msg {
            ConsensusMsg::BlockRetrievalResponse(resp) => *resp,
            _ => return Err(anyhow!("Invalid response to request")),
        };

        // Verify response against retrieval request
        response
            .verify(retrieval_request, &self.validators)
            .map_err(|e| {
                error!(
                    SecurityEvent::InvalidRetrievedBlock,
                    request_block_response = response,
                    error = ?e,
                );
                e
            })?;

        Ok(response)
    }
```

**File:** consensus/src/network.rs (L334-356)
```rust
    pub async fn send_rpc(
        &self,
        receiver: Author,
        msg: ConsensusMsg,
        timeout_duration: Duration,
    ) -> anyhow::Result<ConsensusMsg> {
        fail_point!("consensus::send::any", |_| {
            Err(anyhow::anyhow!("Injected error in send_rpc"))
        });
        counters::CONSENSUS_SENT_MSGS
            .with_label_values(&[msg.name()])
            .inc();
        if receiver == self.author() {
            self.send_rpc_to_self(msg, timeout_duration).await
        } else {
            Ok(monitor!(
                "send_rpc",
                self.consensus_network_client
                    .send_rpc(receiver, msg, timeout_duration)
                    .await
            )?)
        }
    }
```

**File:** consensus/src/block_storage/sync_manager.rs (L754-756)
```rust
                        if next_peers.is_empty() && futures.is_empty() {
                            bail!("Couldn't fetch block")
                        }
```

**File:** consensus/src/round_manager.rs (L2136-2142)
```rust
                        match result {
                            Ok(_) => trace!(RoundStateLogSchema::new(round_state)),
                            Err(e) => {
                                counters::ERROR_COUNT.inc();
                                warn!(kind = error_kind(&e), RoundStateLogSchema::new(round_state), "Error: {:#}", e);
                            }
                        }
```
