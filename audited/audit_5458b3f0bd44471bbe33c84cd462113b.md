# Audit Report

## Title
Abort Hook Bypass Allows Account Creation at Protected Framework Reserved Addresses

## Summary
The abort hook mechanism in user transaction processing can create Account resources at protected framework reserved addresses (0x2, 0x4-0xa) and @core_resources (0xA550C18) through sponsored transaction abuse. The `create_account_if_does_not_exist` function only validates three specific addresses but fails to protect all framework reserved addresses, violating the critical invariant that system addresses must be protected from user transactions.

## Finding Description

The vulnerability exists in the interaction between three components:

1. **Abort Hook Account Creation**: When a user transaction aborts with `sponsored_automatic_account_creation` or `default_account_resource` features enabled and sequence number 0, the abort hook calls `create_account_if_does_not_exist` for the transaction sender to enable fee charging. [1](#0-0) 

2. **Insufficient Address Protection**: The `create_account_if_does_not_exist` function only checks three addresses (@vm_reserved, @aptos_framework, @aptos_token) but fails to validate framework reserved addresses (0x2, 0x4-0xa) or @core_resources: [2](#0-1) 

3. **Sponsored Transaction Validation Bypass**: With sponsored automatic account creation enabled, the prologue skips authentication key validation for non-existent sender accounts when sender ≠ gas_payer and sequence_number = 0: [3](#0-2) 

**Attack Path:**

1. Attacker creates account A with sufficient balance to pay gas
2. Attacker submits sponsored transaction:
   - Sender: 0x2 (or 0x4-0xa, or 0xA550C18 for @core_resources)
   - Gas payer: Account A (attacker's account)
   - Sequence number: 0
   - Transaction payload: any operation that will abort
3. Prologue validation passes due to sponsored account creation logic bypassing authentication checks
4. Transaction executes and aborts
5. Abort hook invokes `create_account_if_does_not_exist(sender_address)`
6. Function validates sender ≠ @vm_reserved, @aptos_framework, @aptos_token ✓
7. Account resource created at protected framework reserved address

**Invariant Violation:**

The framework explicitly defines addresses 0x1-0xa as "framework reserved" and "under on chain governance's control": [4](#0-3) 

These addresses should only have accounts created via the friend-only `create_framework_reserved_account` function: [5](#0-4) 

Similarly, @core_resources is created only during genesis via `create_account`: [6](#0-5) 

## Impact Explanation

**Medium Severity** - This qualifies as "State inconsistencies requiring intervention" per the bug bounty program:

1. **Protocol Violation**: Breaks the documented invariant that framework reserved addresses are protected from user transaction modification
2. **Access Control Bypass**: Allows unprivileged users to create Account resources at system addresses that should only be manipulated by framework code
3. **Potential Denial of Service**: Future system operations expecting these addresses to be empty may fail, requiring manual intervention
4. **Formal Verification Violations**: Breaks specifications that assume only genesis/framework code can populate these addresses

While the attacker cannot control the created account (authentication key is set to BCS encoding of the address, requiring preimage attack on SHA3-256), the mere existence of Account resources at protected addresses violates critical security boundaries.

## Likelihood Explanation

**High Likelihood** given the following conditions:

1. **Feature Availability**: Either `SPONSORED_AUTOMATIC_ACCOUNT_V1_CREATION` (with fee payer) or `DEFAULT_ACCOUNT_RESOURCE` must be enabled. These are production features designed for user experience improvements. [7](#0-6) 

2. **Low Attack Cost**: Attacker only needs:
   - One account with gas balance (trivial to obtain)
   - Knowledge of framework reserved addresses (publicly documented)
   - Ability to submit transactions (standard blockchain access)

3. **Deterministic Exploitation**: The attack path is straightforward with no race conditions or timing dependencies

4. **No Rate Limiting**: Attacker can potentially create accounts at all unprotected reserved addresses (0x2, 0x4-0xa, @core_resources)

## Recommendation

Add comprehensive validation in `create_account_if_does_not_exist` to protect all framework reserved addresses and @core_resources:

```move
public fun create_account_if_does_not_exist(account_address: address) {
    if (!resource_exists_at(account_address)) {
        // Validate not a reserved address
        assert!(
            !system_addresses::is_reserved_address(account_address) &&
            !system_addresses::is_framework_reserved_address(account_address) &&
            !system_addresses::is_core_resource_address(account_address) &&
            account_address != @aptos_token,
            error::invalid_argument(ECANNOT_RESERVED_ADDRESS)
        );
        create_account_unchecked(account_address);
    }
}
```

This aligns with the protection already present in the friend-only `create_account` function and ensures abort hooks cannot bypass framework reserved address protection.

## Proof of Concept

```rust
// Add to aptos-move/e2e-move-tests/src/tests/fee_payer.rs

#[test]
fn test_abort_hook_framework_reserved_address_bypass() {
    let mut h = MoveHarness::new();
    
    // Enable sponsored automatic account creation
    let features = vec![FeatureFlag::SPONSORED_AUTOMATIC_ACCOUNT_V1_CREATION];
    let framework = h.new_account_at(AccountAddress::ONE);
    h.enable_features(framework, features);
    
    // Create attacker account (gas payer)
    let attacker = h.new_account_with_balance_and_sequence_number(1_000_000, 0);
    
    // Target framework reserved address 0x2 (not protected in create_account_if_does_not_exist)
    let target_reserved_addr = AccountAddress::TWO;
    
    // Verify account doesn't exist yet
    assert!(!h.exists_account(target_reserved_addr));
    
    // Submit sponsored transaction with sender=0x2, gas_payer=attacker
    // Transaction will abort (invalid entry function)
    let txn = h.create_entry_function(
        target_reserved_addr,  // sender (non-existent framework reserved address)
        str::parse("0x1::account::create_account").unwrap(),
        vec![],
        vec![bcs::to_bytes(&AccountAddress::from_hex_literal("0xdead").unwrap()).unwrap()],
    )
    .sequence_number(0)
    .gas_payer(attacker)
    .sign();
    
    // Execute transaction - should abort but create account at 0x2
    let result = h.run(txn);
    
    // Verify: Account resource now exists at framework reserved address 0x2
    // This should NOT be possible - only framework code should create accounts here
    assert!(h.exists_account(target_reserved_addr), 
        "Vulnerability: Account created at framework reserved address 0x2 via abort hook");
}
```

## Notes

The vulnerability affects multiple protected addresses:
- Framework reserved addresses: 0x2, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa (0x1 and 0x3 are already checked)
- Special system address: @core_resources (0xA550C18)

While @aptos_framework (0x1) is protected, the inconsistent validation across reserved addresses suggests this is an implementation oversight rather than intentional design. The comment in `create_account` noting "@core_resources gets created via a `create_account` call, so we do not include it below" was not carried over to `create_account_if_does_not_exist`, creating this security gap. [8](#0-7)

### Citations

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L705-739)
```rust
        let should_create_account_resource =
            should_create_account_resource(txn_data, self.features(), resolver, module_storage)?;

        let (previous_session_change_set, fee_statement) = if should_create_account_resource {
            let mut abort_hook_session =
                AbortHookSession::new(self, txn_data, resolver, prologue_session_change_set);

            abort_hook_session.execute(|session| {
                create_account_if_does_not_exist(
                    session,
                    module_storage,
                    gas_meter,
                    txn_data.sender(),
                    traversal_context,
                )
                // If this fails, it is likely due to out of gas, so we try again without metering
                // and then validate below that we charged sufficiently.
                .or_else(|_err| {
                    create_account_if_does_not_exist(
                        session,
                        module_storage,
                        &mut UnmeteredGasMeter,
                        txn_data.sender(),
                        traversal_context,
                    )
                })
                .map_err(expect_no_verification_errors)
                .or_else(|err| {
                    expect_only_successful_execution(
                        err,
                        &format!("{:?}::{}", ACCOUNT_MODULE, CREATE_ACCOUNT_IF_DOES_NOT_EXIST),
                        log_context,
                    )
                })
            })?;
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L3451-3483)
```rust
pub(crate) fn should_create_account_resource(
    txn_data: &TransactionMetadata,
    features: &Features,
    resolver: &impl AptosMoveResolver,
    module_storage: &impl ModuleStorage,
) -> VMResult<bool> {
    if (features.is_enabled(FeatureFlag::DEFAULT_ACCOUNT_RESOURCE)
        || (features.is_enabled(FeatureFlag::SPONSORED_AUTOMATIC_ACCOUNT_V1_CREATION)
            && txn_data.fee_payer.is_some()))
        && txn_data.replay_protector == ReplayProtector::SequenceNumber(0)
    {
        let account_tag = AccountResource::struct_tag();

        // INVARIANT:
        //   Account lives at a special address, so we should not be charging for it and unmetered
        //   access is safe. There are tests that ensure that address is always special.
        assert!(account_tag.address.is_special());
        let module = module_storage.unmetered_get_existing_deserialized_module(
            &account_tag.address,
            &account_tag.module,
        )?;

        let (maybe_bytes, _) = resolver
            .get_resource_bytes_with_metadata_and_layout(
                &txn_data.sender(),
                &account_tag,
                &module.metadata,
                None,
            )
            .map_err(|e| e.finish(Location::Undefined))?;
        return Ok(maybe_bytes.is_none());
    }
    Ok(false)
```

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L276-284)
```text
    public fun create_account_if_does_not_exist(account_address: address) {
        if (!resource_exists_at(account_address)) {
            assert!(
                account_address != @vm_reserved && account_address != @aptos_framework && account_address != @aptos_token,
                error::invalid_argument(ECANNOT_RESERVED_ADDRESS)
            );
            create_account_unchecked(account_address);
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L289-302)
```text
    public(friend) fun create_account(new_address: address): signer {
        // there cannot be an Account resource under new_addr already.
        assert!(!exists<Account>(new_address), error::already_exists(EACCOUNT_ALREADY_EXISTS));
        // NOTE: @core_resources gets created via a `create_account` call, so we do not include it below.
        assert!(
            new_address != @vm_reserved && new_address != @aptos_framework && new_address != @aptos_token,
            error::invalid_argument(ECANNOT_RESERVED_ADDRESS)
        );
        if (features::is_default_account_resource_enabled()) {
            create_signer(new_address)
        } else {
            create_account_unchecked(new_address)
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L1156-1173)
```text
    public(friend) fun create_framework_reserved_account(addr: address): (signer, SignerCapability) {
        assert!(
            addr == @0x1 ||
                addr == @0x2 ||
                addr == @0x3 ||
                addr == @0x4 ||
                addr == @0x5 ||
                addr == @0x6 ||
                addr == @0x7 ||
                addr == @0x8 ||
                addr == @0x9 ||
                addr == @0xa,
            error::permission_denied(ENO_VALID_FRAMEWORK_RESERVED_ADDRESS),
        );
        let signer = create_account_unchecked(addr);
        let signer_cap = SignerCapability { account: addr };
        (signer, signer_cap)
    }
```

**File:** aptos-move/framework/aptos-framework/sources/transaction_validation.move (L148-167)
```text
        // Check if the authentication key is valid
        if (!skip_auth_key_check(is_simulation, &txn_authentication_key)) {
            if (option::is_some(&txn_authentication_key)) {
                if (
                    sender_address == gas_payer_address ||
                    account::exists_at(sender_address) ||
                    !features::sponsored_automatic_account_creation_enabled()
                ) {
                    assert!(
                        txn_authentication_key == option::some(account::get_authentication_key(sender_address)),
                        error::invalid_argument(PROLOGUE_EINVALID_ACCOUNT_AUTH_KEY),
                    );
                };
            } else {
                assert!(
                    allow_missing_txn_authentication_key(sender_address),
                    error::invalid_argument(PROLOGUE_EINVALID_ACCOUNT_AUTH_KEY)
                );
            };
        };
```

**File:** aptos-move/framework/aptos-framework/sources/system_addresses.move (L44-56)
```text
    /// Return true if `addr` is 0x0 or under the on chain governance's control.
    public fun is_framework_reserved_address(addr: address): bool {
        is_aptos_framework_address(addr) ||
            addr == @0x2 ||
            addr == @0x3 ||
            addr == @0x4 ||
            addr == @0x5 ||
            addr == @0x6 ||
            addr == @0x7 ||
            addr == @0x8 ||
            addr == @0x9 ||
            addr == @0xa
    }
```

**File:** aptos-move/framework/aptos-framework/sources/genesis.move (L169-172)
```text
        let core_resources = account::create_account(@core_resources);
        account::rotate_authentication_key_internal(&core_resources, core_resources_auth_key);
        aptos_account::register_apt(&core_resources); // registers APT store
        aptos_coin::configure_accounts_for_test(aptos_framework, &core_resources, mint_cap);
```
