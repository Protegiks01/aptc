# Audit Report

## Title
Integer Overflow in API Balance Aggregation During Coin-to-Fungible-Asset Migration

## Summary
The `Account::balance()` function in the REST API aggregates balances from multiple sources (CoinStore, FungibleStore, and ConcurrentFungibleBalance) using unchecked Rust `+=` operations. During the coin-to-fungible-asset migration period, both legacy CoinStore and new primary fungible stores can coexist for the same asset, allowing their balances to sum beyond `u64::MAX`, causing integer overflow. This results in API crashes in debug builds or silent balance wraparound in release builds.

## Finding Description

The vulnerability exists in the balance aggregation logic where the API sums balances from multiple storage locations without overflow protection. [1](#0-0) 

The function initializes `balance` with either the coin balance from CoinStore or 0, then unconditionally adds balances from the primary fungible store: [2](#0-1) [3](#0-2) 

These are standard Rust `+=` operations on `u64` values, which panic on overflow in debug mode and silently wrap in release mode.

**Why Both Stores Can Coexist:**

The Move framework explicitly acknowledges this scenario during migration: [4](#0-3) 

The migration function removes the CoinStore only when converting, meaning before migration both stores can hold balances simultaneously: [5](#0-4) 

**Attack Scenario:**

1. User has `CoinStore<APT>` with balance = `u64::MAX - 100`
2. Attacker sends 200 APT via fungible asset pathway (not coin), which creates/updates the primary fungible store
3. User now has:
   - CoinStore balance: `u64::MAX - 100`
   - Primary store balance: `200`
   - Actual total: `u64::MAX + 100` (overflows)
4. When API queries balance: `balance = (u64::MAX - 100) + 200` â†’ overflow
5. Result: 
   - Debug mode: API panics and crashes
   - Release mode: Balance wraps to `100` (incorrect)

This violates the **State Consistency** invariant (returning incorrect data) and **Deterministic Execution** invariant (different behavior between debug/release builds).

## Impact Explanation

**High Severity (API Crashes):** In debug builds, the overflow causes a panic that crashes the API server endpoint, qualifying as "API crashes" under High Severity ($50,000 category).

**Critical Severity (Data Corruption):** In release builds, the silent wraparound returns drastically incorrect balance information. Users or applications making financial decisions based on this data could experience loss of funds. For example:
- A user seeing wrapped balance of `100` instead of actual `u64::MAX + 100` might transfer all visible funds elsewhere, while the API/system believes they have more
- Smart contracts or defi protocols querying balances for collateralization or limits get wrong values
- Exchange integrations calculating user balances get corrupted data

This data integrity violation can lead to "Loss of Funds" scenarios, meeting Critical Severity criteria.

## Likelihood Explanation

**MEDIUM to HIGH Likelihood:**

This is not a theoretical edge case but a realistic scenario during the ongoing coin-to-fungible-asset migration:

1. **Natural Occurrence:** Users with large legacy CoinStore balances who receive fungible assets (via FA-native transfers, airdrops, or protocols) will naturally trigger this condition

2. **Attacker-Triggered:** An attacker can deliberately trigger this by:
   - Identifying accounts with large CoinStore balances (publicly visible on-chain)
   - Sending small amounts via fungible asset pathway to create the overflow condition
   - Cost is minimal (just transfer fees)

3. **Migration Period Vulnerability:** The Aptos network is actively migrating from coins to fungible assets, making this a current real-world issue, not a historical or future concern

4. **No Special Privileges Required:** Any user can send fungible assets to any address, making this exploitable by unprivileged actors

## Recommendation

Replace unchecked `+=` operations with checked arithmetic:

```rust
pub fn balance(
    &self,
    asset_type: AssetType,
    accept_type: &AcceptType,
) -> BasicResultWith404<u64> {
    let (fa_metadata_address, mut balance) = match asset_type {
        // ... existing coin balance logic ...
    };
    
    // ... existing fungible store query logic ...
    
    if fa_store_resource.balance != 0 {
        balance = balance.checked_add(fa_store_resource.balance())
            .ok_or_else(|| {
                BasicErrorWith404::internal_with_code(
                    "Balance overflow when summing coin and fungible asset balances",
                    AptosErrorCode::InternalError,
                    &self.latest_ledger_info,
                )
            })?;
    } else if let Some(concurrent_fa_balance) = ... {
        balance = balance.checked_add(concurrent_fa_balance_resource.balance())
            .ok_or_else(|| {
                BasicErrorWith404::internal_with_code(
                    "Balance overflow when summing balances",
                    AptosErrorCode::InternalError,
                    &self.latest_ledger_info,
                )
            })?;
    }
    // ... rest of function
}
```

**Alternative Solution:** If both stores legitimately contain balances that sum beyond `u64::MAX`, the API should return an error indicating the balance exceeds representable limits rather than silently wrapping or panicking.

## Proof of Concept

```rust
#[cfg(test)]
mod test {
    use super::*;
    
    #[test]
    #[should_panic(expected = "attempt to add with overflow")]
    fn test_balance_overflow_debug() {
        // Simulate the overflow scenario
        let mut balance: u64 = u64::MAX - 100;
        let fa_balance: u64 = 200;
        
        // This will panic in debug mode
        balance += fa_balance;
    }
    
    #[test]
    fn test_balance_overflow_release() {
        // In release mode, this wraps around
        let mut balance: u64 = u64::MAX - 100;
        let fa_balance: u64 = 200;
        
        balance = balance.wrapping_add(fa_balance);
        
        // Balance wraps to a small number instead of being > u64::MAX
        assert_eq!(balance, 99);
        // This is incorrect - the actual total should be u64::MAX + 100
    }
    
    #[test]
    fn test_balance_checked_add() {
        let balance: u64 = u64::MAX - 100;
        let fa_balance: u64 = 200;
        
        let result = balance.checked_add(fa_balance);
        assert!(result.is_none()); // Correctly detects overflow
    }
}
```

**Move Integration Test:**

```move
#[test(framework = @0x1, user = @0x42)]
public fun test_balance_overflow_scenario(framework: &signer, user: &signer) {
    // Setup: Create paired FA for APT with large coin balance
    // and primary store with balance, then query via API
    // Expected: API should return error, not overflow
}
```

## Notes

This vulnerability is particularly concerning because:

1. **Silent in Production:** Release builds silently return incorrect data rather than failing safely
2. **Migration-Period Specific:** Only affects the transition period where both store types coexist
3. **Affects Financial Data:** Balance queries are critical for financial operations and security decisions
4. **Easy to Trigger:** Requires no special permissions, just a fungible asset transfer

The issue should be fixed immediately given the active migration to fungible assets across the Aptos ecosystem.

### Citations

**File:** api/src/accounts.rs (L319-424)
```rust
    pub fn balance(
        &self,
        asset_type: AssetType,
        accept_type: &AcceptType,
    ) -> BasicResultWith404<u64> {
        let (fa_metadata_address, mut balance) = match asset_type {
            AssetType::Coin(move_struct_tag) => {
                let coin_store_type_tag =
                    StructTag::from_str(&format!("0x1::coin::CoinStore<{}>", move_struct_tag))
                        .map_err(|err| {
                            BasicErrorWith404::internal_with_code(
                                err,
                                AptosErrorCode::InternalError,
                                &self.latest_ledger_info,
                            )
                        })?;
                // query coin balance
                let state_value = self.context.get_state_value_poem(
                    &StateKey::resource(&self.address.into(), &coin_store_type_tag).map_err(
                        |err| {
                            BasicErrorWith404::internal_with_code(
                                err,
                                AptosErrorCode::InternalError,
                                &self.latest_ledger_info,
                            )
                        },
                    )?,
                    self.ledger_version,
                    &self.latest_ledger_info,
                )?;
                let coin_balance = match state_value {
                    None => 0,
                    Some(bytes) => bcs::from_bytes::<CoinStoreResourceUntyped>(&bytes)
                        .map_err(|err| {
                            BasicErrorWith404::internal_with_code(
                                err,
                                AptosErrorCode::InternalError,
                                &self.latest_ledger_info,
                            )
                        })?
                        .coin(),
                };
                (
                    get_paired_fa_metadata_address(&move_struct_tag),
                    coin_balance,
                )
            },
            AssetType::FungibleAsset(fa_metadata_adddress) => (fa_metadata_adddress.into(), 0),
        };
        let primary_fungible_store_address =
            get_paired_fa_primary_store_address(self.address.into(), fa_metadata_address);
        if let Some(data_blob) = self.context.get_state_value_poem(
            &StateKey::resource_group(
                &primary_fungible_store_address,
                &ObjectGroupResource::struct_tag(),
            ),
            self.ledger_version,
            &self.latest_ledger_info,
        )? {
            if let Ok(object_group) = bcs::from_bytes::<ObjectGroupResource>(&data_blob) {
                if let Some(fa_store) = object_group.group.get(&FungibleStoreResource::struct_tag())
                {
                    let fa_store_resource = bcs::from_bytes::<FungibleStoreResource>(fa_store)
                        .map_err(|err| {
                            BasicErrorWith404::internal_with_code(
                                err,
                                AptosErrorCode::InternalError,
                                &self.latest_ledger_info,
                            )
                        })?;
                    if fa_store_resource.balance != 0 {
                        balance += fa_store_resource.balance();
                    } else if let Some(concurrent_fa_balance) = object_group
                        .group
                        .get(&ConcurrentFungibleBalanceResource::struct_tag())
                    {
                        // query potential concurrent fa balance
                        let concurrent_fa_balance_resource =
                            bcs::from_bytes::<ConcurrentFungibleBalanceResource>(
                                concurrent_fa_balance,
                            )
                            .map_err(|err| {
                                BasicErrorWith404::internal_with_code(
                                    err,
                                    AptosErrorCode::InternalError,
                                    &self.latest_ledger_info,
                                )
                            })?;
                        balance += concurrent_fa_balance_resource.balance();
                    }
                }
            }
        }
        match accept_type {
            AcceptType::Json => BasicResponse::try_from_json((
                balance,
                &self.latest_ledger_info,
                BasicResponseStatus::Ok,
            )),
            AcceptType::Bcs => BasicResponse::try_from_encoded((
                bcs::to_bytes(&balance).unwrap(),
                &self.latest_ledger_info,
                BasicResponseStatus::Ok,
            )),
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/coin.move (L653-655)
```text
        if (exists<CoinStore<CoinType>>(account)) {
            let CoinStore<CoinType> { coin, frozen, deposit_events, withdraw_events } =
                move_from<CoinStore<CoinType>>(account);
```

**File:** aptos-move/framework/aptos-framework/sources/coin.move (L687-694)
```text
                // Note:
                // It is possible the primary fungible store may already exist before this function call.
                // In this case, if the account owns a frozen CoinStore and an unfrozen primary fungible store, this
                // function would convert and deposit the rest coin into the primary store and freeze it to make the
                // `frozen` semantic as consistent as possible.
                if (frozen != fungible_asset::is_frozen(store)) {
                    fungible_asset::set_frozen_flag_internal(store, frozen);
                }
```
