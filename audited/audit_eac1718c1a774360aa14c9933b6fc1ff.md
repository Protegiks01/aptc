# Audit Report

## Title
Missing Epoch Validation in State Snapshot Backup Creation Allows Epoch-Version Mismatch in Backup Manifests

## Summary
The `write_manifest()` function in the state snapshot backup process fails to validate that the `LedgerInfoWithSignatures` returned from `get_state_root_proof()` corresponds to the same epoch as the requested backup epoch, violating a documented invariant and potentially creating corrupted backup manifests.

## Finding Description

The state snapshot backup process has a critical validation gap in `write_manifest()`: [1](#0-0) 

The function calls `get_state_root_proof(self.version())` which returns a tuple of `(TransactionInfoWithProof, LedgerInfoWithSignatures)`, but the `LedgerInfoWithSignatures` is **immediately discarded** without verification using the `_` pattern. [2](#0-1) 

The manifest is then created with `epoch: self.epoch` (the user-requested epoch), but there is **no validation** that the epoch in the discarded `LedgerInfoWithSignatures` actually matches `self.epoch`.

The documentation explicitly states this invariant must hold: [3](#0-2) 

The `get_state_root_proof()` implementation derives the epoch from the version, not from the requested epoch: [4](#0-3) 

At line 193, `get_epoch(version)` determines which epoch the version belongs to, and line 194 gets the latest ledger info **in that derived epoch**, not the requested epoch.

**Broken Invariant**: The documented requirement that the LedgerInfoWithSignatures must be "within the same epoch" as the backup is not enforced during backup creation.

## Impact Explanation

This vulnerability creates **State Consistency** violations with **Medium to High severity**:

1. **Backup Integrity Compromise**: If there is database inconsistency where `get_version_for_epoch_ending(N)` returns a version V that doesn't belong to epoch N according to `get_epoch(V)`, the backup manifest will contain mismatched epoch metadata.

2. **Undetected Restoration Failures**: During restore without `epoch_history` (which is optional), the epoch mismatch is not detected: [5](#0-4) 

The epoch validation only occurs if `epoch_history` is provided, making this an optional check.

3. **Consensus Risk**: A restored node with incorrect epoch boundaries could participate in consensus with invalid state assumptions, potentially causing:
   - Incorrect validator set transitions
   - Misaligned epoch change handling
   - State root verification failures in edge cases

**Severity Assessment**: Medium - State inconsistencies requiring intervention. While not directly exploitable for fund theft, it violates critical state consistency invariants and could require manual intervention to detect and correct.

## Likelihood Explanation

**Likelihood: Low to Medium**

This vulnerability manifests under specific conditions:

1. **Database Corruption**: Most likely trigger - if the database has inconsistencies where epoch ending ledger infos don't accurately reflect epoch boundaries
2. **Race Conditions**: During epoch transitions, if there's timing issues in metadata updates
3. **Compromised Backup Service**: If an attacker controls the backup service endpoint (requires privileged access)

The lack of defensive validation means any database inconsistency will silently propagate into backups without detection until restoration attempts fail or produce incorrect state.

## Recommendation

Add epoch validation in `write_manifest()` to verify the returned `LedgerInfoWithSignatures` matches the expected epoch:

```rust
async fn write_manifest(
    &self,
    backup_handle: &BackupHandleRef,
    chunks: Vec<StateSnapshotChunk>,
) -> Result<FileHandle> {
    let proof_bytes = self.client.get_state_root_proof(self.version()).await?;
    let (txn_info, ledger_info): (TransactionInfoWithProof, LedgerInfoWithSignatures) =
        bcs::from_bytes(&proof_bytes)?;

    // VALIDATE: Ensure the ledger info is in the expected epoch
    ensure!(
        ledger_info.ledger_info().epoch() == self.epoch,
        "Epoch mismatch: expected epoch {}, but ledger info is in epoch {}. \
         This indicates database inconsistency or invalid backup service response.",
        self.epoch,
        ledger_info.ledger_info().epoch()
    );

    // VALIDATE: Verify the proof is valid for the expected version
    txn_info.verify(ledger_info.ledger_info(), self.version())?;

    let (proof_handle, mut proof_file) = self
        .storage
        .create_for_write(backup_handle, Self::proof_name())
        .await?;
    proof_file.write_all(&proof_bytes).await?;
    proof_file.shutdown().await?;

    let manifest = StateSnapshotBackup {
        epoch: self.epoch,
        version: self.version(),
        root_hash: txn_info.transaction_info().ensure_state_checkpoint_hash()?,
        chunks,
        proof: proof_handle,
    };
    
    // ... rest of function
}
```

This defensive validation ensures:
1. The documented invariant is enforced
2. Database inconsistencies are detected early
3. Backup integrity is verified at creation time
4. Clear error messages help diagnose issues

## Proof of Concept

```rust
// Reproduction scenario demonstrating the vulnerability
// This would be added to backup.rs tests (not included in scope but shown for demonstration)

#[tokio::test]
async fn test_epoch_mismatch_not_detected() {
    // Setup: Create a mock backup service that returns mismatched epoch
    let mock_service = MockBackupService::new();
    
    // Configure mock to return version from epoch 100
    // but ledger info from epoch 99
    mock_service.set_epoch_ending_version(100, 1000);
    mock_service.set_state_root_proof_epoch(1000, 99); // Mismatch!
    
    let controller = StateSnapshotBackupController::new(
        StateSnapshotBackupOpt { epoch: 100 },
        global_opt,
        Arc::new(mock_service),
        storage,
    );
    
    // Execute backup
    let result = controller.run().await;
    
    // Current behavior: Succeeds despite epoch mismatch
    assert!(result.is_ok()); // This SHOULD fail but doesn't!
    
    // Verify manifest has incorrect epoch metadata
    let manifest: StateSnapshotBackup = storage.load_json_file(&result.unwrap()).await?;
    assert_eq!(manifest.epoch, 100); // Manifest claims epoch 100
    
    // But the proof is actually from epoch 99
    let (_, ledger_info): (TransactionInfoWithProof, LedgerInfoWithSignatures) = 
        storage.load_bcs_file(&manifest.proof).await?;
    assert_eq!(ledger_info.ledger_info().epoch(), 99); // Actual proof epoch is 99!
    
    // This mismatch violates the documented invariant and could cause
    // restoration issues or consensus problems
}
```

## Notes

This vulnerability highlights a defensive programming failure where a documented invariant is not enforced at the point of backup creation. While the restore process includes verification via `txn_info_with_proof.verify()`, it does not validate that the epoch in the LedgerInfo matches the epoch claimed in the manifest, especially when `epoch_history` is not provided (which is optional). This creates a critical gap in the backup/restore integrity chain.

### Citations

**File:** storage/backup/backup-cli/src/backup_types/state_snapshot/backup.rs (L454-456)
```rust
        let proof_bytes = self.client.get_state_root_proof(self.version()).await?;
        let (txn_info, _): (TransactionInfoWithProof, LedgerInfoWithSignatures) =
            bcs::from_bytes(&proof_bytes)?;
```

**File:** storage/backup/backup-cli/src/backup_types/state_snapshot/backup.rs (L465-471)
```rust
        let manifest = StateSnapshotBackup {
            epoch: self.epoch,
            version: self.version(),
            root_hash: txn_info.transaction_info().ensure_state_checkpoint_hash()?,
            chunks,
            proof: proof_handle,
        };
```

**File:** storage/backup/backup-cli/src/backup_types/state_snapshot/manifest.rs (L45-49)
```rust
    ///   - The signatures on the `LedgerInfoWithSignatures` has a version greater than or equal to
    /// the version of this backup but is within the same epoch, so the signatures on it can be
    /// verified by the validator set in the same epoch, which can be provided by an
    /// `EpochStateBackup` recovered prior to this to the DB; Requiring it to be in the same epoch
    /// limits the requirement on such `EpochStateBackup` to no older than the same epoch.
```

**File:** storage/aptosdb/src/backup/backup_handler.rs (L188-204)
```rust
    pub fn get_state_root_proof(
        &self,
        version: Version,
    ) -> Result<(TransactionInfoWithProof, LedgerInfoWithSignatures)> {
        let ledger_metadata_db = self.ledger_db.metadata_db();
        let epoch = ledger_metadata_db.get_epoch(version)?;
        let ledger_info = ledger_metadata_db.get_latest_ledger_info_in_epoch(epoch)?;
        let txn_info = self
            .ledger_db
            .transaction_info_db()
            .get_transaction_info_with_proof(
                version,
                ledger_info.ledger_info().version(),
                self.ledger_db.transaction_accumulator_db(),
            )?;

        Ok((txn_info, ledger_info))
```

**File:** storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs (L137-139)
```rust
        if let Some(epoch_history) = self.epoch_history.as_ref() {
            epoch_history.verify_ledger_info(&li)?;
        }
```
