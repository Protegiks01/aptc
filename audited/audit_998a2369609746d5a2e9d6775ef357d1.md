# Audit Report

## Title
Division by Zero in Leader Election Due to Unchecked Zero Weight Configuration

## Summary
The consensus leader election mechanism lacks validation of reputation weight parameters, allowing on-chain governance to set all weights (active_weight, inactive_weight, failed_weight) to zero. This causes a division by zero panic in the `choose_index()` function, resulting in total network halt.

## Finding Description
The vulnerability exists in the interaction between consensus configuration validation and the leader election algorithm.

**Root Cause:** The `copy_slice_to_vec()` function itself correctly handles empty slices (length 0). [1](#0-0) 

However, the **calling code** in the leader election system has a critical division by zero vulnerability. When reputation weights are all zero, the `choose_index()` function calculates a `total_weight` of zero and passes it to `next_in_range()`. [2](#0-1) 

The `next_in_range()` function then performs modulo division with this zero value, causing a panic. [3](#0-2) 

**Attack Path:**
1. On-chain governance proposes consensus configuration with all reputation weights set to zero (active_weight=0, inactive_weight=0, failed_weight=0)
2. The governance validation only checks that config bytes are non-empty, not the actual weight values [4](#0-3) 
3. On next epoch or leader election, `ProposerAndVoterHeuristic::get_weights()` returns all zeros [5](#0-4) 
4. The `stake_weights` calculation produces all zeros (0 * voting_power = 0) [6](#0-5) 
5. `choose_index()` is called with all-zero weights [7](#0-6) 
6. Division by zero panic occurs, crashing all consensus nodes

**Missing Validation:** The `ProposerAndVoterConfig` struct has no validation requiring weights to be non-zero. [8](#0-7) 

## Impact Explanation
**CRITICAL Severity** - Total loss of liveness/network availability (up to $1,000,000 per Aptos Bug Bounty).

When all consensus nodes panic due to division by zero during leader election, the network completely halts. No new blocks can be proposed or committed. This breaks the fundamental consensus liveness invariant and would require an emergency hardfork to recover, as the network cannot self-heal from this state.

This affects both Jolteon (standard BFT) and DAG consensus modes, as both use the same `LeaderReputation` mechanism. [9](#0-8) 

## Likelihood Explanation
**Medium-High Likelihood**

While this requires governance approval (2/3 voting power), the vulnerability can manifest through:
1. **Malicious governance proposal** - Coordinated attack by compromised validators
2. **Honest mistake** - Configuration error in governance tooling or proposal
3. **Automated tooling bug** - Error in governance proposal generation scripts

The default values are non-zero (active_weight: 1000, inactive_weight: 10, failed_weight: 1), but there is no enforcement preventing zero values. [10](#0-9) 

## Recommendation
Add validation in multiple layers:

**Layer 1 - Move validation:**
```move
public fun set_for_next_epoch(account: &signer, config: vector<u8>) {
    system_addresses::assert_aptos_framework(account);
    assert!(vector::length(&config) > 0, error::invalid_argument(EINVALID_CONFIG));
    
    // Add validation: decode config and verify weights are non-zero
    validate_consensus_config(&config);
    
    std::config_buffer::upsert<ConsensusConfig>(ConsensusConfig {config});
}
```

**Layer 2 - Rust validation in ProposerAndVoterConfig:**
```rust
impl ProposerAndVoterConfig {
    pub fn validate(&self) -> Result<()> {
        ensure!(self.active_weight > 0, "active_weight must be positive");
        ensure!(self.inactive_weight > 0, "inactive_weight must be positive");
        ensure!(self.failed_weight > 0, "failed_weight must be positive");
        Ok(())
    }
}
```

**Layer 3 - Defensive check in choose_index:**
```rust
pub(crate) fn choose_index(mut weights: Vec<u128>, state: Vec<u8>) -> usize {
    let mut total_weight = 0;
    for w in &mut weights {
        total_weight = total_weight.checked_add(w)
            .expect("Total stake shouldn't exceed u128::MAX");
        *w = total_weight;
    }
    
    // Add defensive check
    assert!(total_weight > 0, "Total weight must be positive for leader election");
    
    let chosen_weight = next_in_range(state, total_weight);
    // ... rest of function
}
```

## Proof of Concept
```rust
#[test]
#[should_panic(expected = "attempt to calculate the remainder with a divisor of zero")]
fn test_zero_weights_cause_panic() {
    use aptos_crypto::HashValue;
    
    // Create all-zero weights (simulating governance setting all weights to 0)
    let weights = vec![0u128, 0u128, 0u128];
    let state = HashValue::random().to_vec();
    
    // This will panic with division by zero
    let _chosen = choose_index(weights, state);
}
```

**Notes:**
- The `copy_slice_to_vec()` function itself is not vulnerable; it correctly handles empty slices
- The vulnerability is in the unchecked zero weights propagating to division by zero in `next_in_range()`
- Both Jolteon and DAG consensus modes are affected
- The bug requires governance-level access to trigger, but has catastrophic impact
- No existing validation prevents zero weight configuration in consensus_config.move or consensus_config.rs

### Citations

**File:** crates/fallible/src/copy_from_slice.rs (L7-18)
```rust
pub fn copy_slice_to_vec<T>(slice: &[T], vec: &mut [T]) -> Result<(), CopySliceError>
where
    T: Copy,
{
    if slice.len() != vec.len() {
        return Err(CopySliceError);
    }

    vec.copy_from_slice(slice);

    Ok(())
}
```

**File:** consensus/src/liveness/proposer_election.rs (L38-46)
```rust
// next consumes seed and returns random deterministic u64 value in [0, max) range
fn next_in_range(state: Vec<u8>, max: u128) -> u128 {
    // hash = SHA-3-256(state)
    let hash = aptos_crypto::HashValue::sha3_256_of(&state).to_vec();
    let mut temp = [0u8; 16];
    copy_slice_to_vec(&hash[..16], &mut temp).expect("next failed");
    // return hash[0..16]
    u128::from_le_bytes(temp) % max
}
```

**File:** consensus/src/liveness/proposer_election.rs (L49-69)
```rust
pub(crate) fn choose_index(mut weights: Vec<u128>, state: Vec<u8>) -> usize {
    let mut total_weight = 0;
    // Create cumulative weights vector
    // Since we own the vector, we can safely modify it in place
    for w in &mut weights {
        total_weight = total_weight
            .checked_add(w)
            .expect("Total stake shouldn't exceed u128::MAX");
        *w = total_weight;
    }
    let chosen_weight = next_in_range(state, total_weight);
    weights
        .binary_search_by(|w| {
            if *w <= chosen_weight {
                Ordering::Less
            } else {
                Ordering::Greater
            }
        })
        .expect_err("Comparison never returns equals, so it's always guaranteed to be error")
}
```

**File:** aptos-move/framework/aptos-framework/sources/configs/consensus_config.move (L52-56)
```text
    public fun set_for_next_epoch(account: &signer, config: vector<u8>) {
        system_addresses::assert_aptos_framework(account);
        assert!(vector::length(&config) > 0, error::invalid_argument(EINVALID_CONFIG));
        std::config_buffer::upsert<ConsensusConfig>(ConsensusConfig {config});
    }
```

**File:** consensus/src/liveness/leader_reputation.rs (L521-552)
```rust
impl ReputationHeuristic for ProposerAndVoterHeuristic {
    fn get_weights(
        &self,
        epoch: u64,
        epoch_to_candidates: &HashMap<u64, Vec<Author>>,
        history: &[NewBlockEvent],
    ) -> Vec<u64> {
        assert!(epoch_to_candidates.contains_key(&epoch));

        let (votes, proposals, failed_proposals) =
            self.aggregation
                .get_aggregated_metrics(epoch_to_candidates, history, &self.author);

        epoch_to_candidates[&epoch]
            .iter()
            .map(|author| {
                let cur_votes = *votes.get(author).unwrap_or(&0);
                let cur_proposals = *proposals.get(author).unwrap_or(&0);
                let cur_failed_proposals = *failed_proposals.get(author).unwrap_or(&0);

                if cur_failed_proposals * 100
                    > (cur_proposals + cur_failed_proposals) * self.failure_threshold_percent
                {
                    self.failed_weight
                } else if cur_proposals > 0 || cur_votes > 0 {
                    self.active_weight
                } else {
                    self.inactive_weight
                }
            })
            .collect()
    }
```

**File:** consensus/src/liveness/leader_reputation.rs (L711-715)
```rust
        let stake_weights: Vec<u128> = weights
            .iter_mut()
            .enumerate()
            .map(|(i, w)| *w as u128 * self.voting_powers[i] as u128)
            .collect();
```

**File:** consensus/src/liveness/leader_reputation.rs (L732-732)
```rust
        let chosen_index = choose_index(stake_weights, state);
```

**File:** types/src/on_chain_config/consensus_config.rs (L489-493)
```rust
                LeaderReputationType::ProposerAndVoterV2(ProposerAndVoterConfig {
                    active_weight: 1000,
                    inactive_weight: 10,
                    failed_weight: 1,
                    failure_threshold_percent: 10, // = 10%
```

**File:** types/src/on_chain_config/consensus_config.rs (L552-575)
```rust
#[derive(Clone, Copy, Debug, Deserialize, Eq, PartialEq, Serialize)]
pub struct ProposerAndVoterConfig {
    // Selection weight for active validators with proposer failures below threshold
    pub active_weight: u64,
    // Selection weight for inactive validators with proposer failures below threshold
    pub inactive_weight: u64,
    // Selection weight for validators with proposer failures above threshold
    pub failed_weight: u64,
    // Thresholed of failures in the rounds validator was selected to be proposer
    // integer values representing percentages, i.e. 12 is 12%.
    pub failure_threshold_percent: u32,
    // Window into history considered for proposer statistics, multiplier
    // on top of number of validators
    pub proposer_window_num_validators_multiplier: usize,
    // Window into history considered for votre statistics, multiplier
    // on top of number of validators
    pub voter_window_num_validators_multiplier: usize,
    // Flag whether to use voting power as multiplier to the weights
    pub weight_by_voting_power: bool,
    // Flag whether to use history from previous epoch (0 if not),
    // representing a number of historical epochs (beyond the current one)
    // to consider.
    pub use_history_from_previous_epoch_max_count: u32,
}
```

**File:** consensus/src/dag/anchor_election/leader_reputation_adapter.rs (L121-130)
```rust
            reputation: LeaderReputation::new(
                epoch,
                epoch_to_proposers,
                voting_powers,
                backend.clone(),
                heuristic,
                0,
                true,
                window_for_chain_health,
            ),
```
