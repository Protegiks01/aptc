# Audit Report

## Title
Proposal ID Integer Overflow in Indexer Database Storage Causes Data Corruption

## Summary
The indexer's `ProposalVote` model performs an unsafe wrapping cast from `u64` to `i64` when storing proposal IDs in the database. When on-chain proposal IDs exceed `i64::MAX` (9,223,372,036,854,775,807), they wrap to negative values, potentially creating duplicate proposal IDs in the indexer and breaking governance tracking integrity.

## Finding Description

The vulnerability exists in the data flow between on-chain governance events and the indexer database:

**On-Chain Layer**: The Move governance system uses `u64` for proposal IDs, with a comment stating "This allows for 2 * 10**19 proposals" [1](#0-0) , acknowledging the full `u64` range will be utilized.

**Event Structure**: The `VoteEvent` struct in the governance module correctly uses `u64` for `proposal_id` [2](#0-1) .

**Indexer Deserialization**: The `GovernanceVoteEvent` struct in the indexer correctly deserializes `proposal_id` as `u64` from string representation [3](#0-2) . The `deserialize_from_string` function uses `s.parse::<T>()` [4](#0-3) , which safely errors on values exceeding `u64::MAX`.

**Database Storage Bug**: The critical vulnerability occurs when converting to the database model. The `ProposalVote` struct uses `i64` for `proposal_id` [5](#0-4) , and performs an **unsafe wrapping cast** using `ev.proposal_id as i64` [6](#0-5) .

**Database Schema**: The PostgreSQL schema confirms `proposal_id -> Int8` (BIGINT/i64) [7](#0-6) .

**Wrapping Behavior**: In Rust, the `as i64` cast performs wrapping conversion:
- Proposal ID `9,223,372,036,854,775,808` (i64::MAX + 1) → wraps to `-9,223,372,036,854,775,808` (i64::MIN)
- Proposal ID `18,446,744,073,709,551,615` (u64::MAX) → wraps to `-1`

This breaks the **Governance Integrity** invariant as the indexer's representation of proposal IDs no longer matches the on-chain source of truth, and breaks **State Consistency** as wrapped negative IDs can collide with other wrapped IDs.

## Impact Explanation

**Severity: Medium** per Aptos Bug Bounty criteria - "State inconsistencies requiring intervention"

**Specific Impacts:**
1. **Duplicate Proposal IDs**: Wrapped negative values can collide with other wrapped proposal IDs, violating primary key uniqueness and corrupting governance records
2. **Data Integrity Loss**: Queries by proposal ID will fail or return incorrect results when IDs exceed i64::MAX
3. **Governance Tracking Failure**: Vote tallying, proposal lookups, and governance analytics become unreliable
4. **Off-chain Infrastructure Corruption**: Any service relying on the indexer for governance data will receive incorrect information

This does not directly affect on-chain consensus or execution, but critically compromises off-chain governance infrastructure and data analysis tools.

## Likelihood Explanation

**Likelihood: Low to Medium**

While reaching 9.2 quintillion proposals would take an extremely long time at current proposal creation rates, several factors increase the likelihood of impact:

1. **Design Intent**: The voting module explicitly acknowledges supporting "2 * 10**19 proposals" [1](#0-0) , showing this range is intentionally supported
2. **No Overflow Protection**: The proposal ID counter increments without bounds [8](#0-7)  until reaching u64::MAX (at which point Move will abort)
3. **Long-term System Design**: As a blockchain designed for decades of operation, edge cases in numeric ranges become increasingly relevant
4. **Multiple Voting Forums**: Different proposal types can each have their own voting forums with independent counters, potentially accelerating the approach to problematic values

## Recommendation

Replace the unsafe wrapping cast with a checked conversion that validates the proposal ID fits within i64 range:

```rust
// In proposal_votes.rs, line 42
proposal_id: ev.proposal_id.try_into()
    .context(format!(
        "Proposal ID {} exceeds i64::MAX and cannot be stored in database", 
        ev.proposal_id
    ))?,
```

**Alternative Solutions:**
1. **Change Schema**: Modify the database schema to use `NUMERIC` type for `proposal_id` to support the full u64 range
2. **Use String Storage**: Store proposal IDs as strings in the database to preserve full precision
3. **Add Validation Layer**: Implement a global check that prevents indexing when proposal IDs approach i64::MAX

The first option (checked conversion with error) is the safest immediate fix as it prevents silent data corruption and makes the overflow explicit.

## Proof of Concept

```rust
#[test]
fn test_proposal_id_overflow_wrapping() {
    use std::convert::TryInto;
    
    // Demonstrate the wrapping behavior
    let large_proposal_id: u64 = 9_223_372_036_854_775_808; // i64::MAX + 1
    let wrapped_id: i64 = large_proposal_id as i64;
    
    println!("Original u64 proposal_id: {}", large_proposal_id);
    println!("Wrapped i64 value: {}", wrapped_id);
    assert_eq!(wrapped_id, i64::MIN); // -9223372036854775808
    
    // This demonstrates two different proposal IDs mapping to the same database value
    let proposal_id_1: u64 = 9_223_372_036_854_775_808;
    let proposal_id_2: u64 = 9_223_372_036_854_775_809;
    
    let db_id_1: i64 = proposal_id_1 as i64;
    let db_id_2: i64 = proposal_id_2 as i64;
    
    println!("Proposal 1 ({}): database stores as {}", proposal_id_1, db_id_1);
    println!("Proposal 2 ({}): database stores as {}", proposal_id_2, db_id_2);
    
    // These are different proposals but with sequential wrapped values
    assert_eq!(db_id_1, -9_223_372_036_854_775_808);
    assert_eq!(db_id_2, -9_223_372_036_854_775_807);
    
    // Demonstrate that checked conversion would prevent this
    let safe_conversion: Result<i64, _> = large_proposal_id.try_into();
    assert!(safe_conversion.is_err(), "try_into should fail for values > i64::MAX");
}
```

This PoC demonstrates that the `as i64` cast silently wraps large proposal IDs to negative values, while `try_into()` would properly error, preventing data corruption.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/voting.move (L134-135)
```text
        /// Unique identifier for a proposal. This allows for 2 * 10**19 proposals.
        next_proposal_id: u64,
```

**File:** aptos-move/framework/aptos-framework/sources/voting.move (L314-315)
```text
        let proposal_id = voting_forum.next_proposal_id;
        voting_forum.next_proposal_id = voting_forum.next_proposal_id + 1;
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L131-137)
```text
    struct VoteEvent has drop, store {
        proposal_id: u64,
        voter: address,
        stake_pool: address,
        num_votes: u64,
        should_pass: bool,
    }
```

**File:** crates/indexer/src/models/stake_models/stake_utils.rs (L41-49)
```rust
pub struct GovernanceVoteEvent {
    #[serde(deserialize_with = "deserialize_from_string")]
    pub proposal_id: u64,
    pub voter: String,
    pub stake_pool: String,
    #[serde(deserialize_with = "deserialize_from_string")]
    pub num_votes: BigDecimal,
    pub should_pass: bool,
}
```

**File:** api/types/src/lib.rs (L63-73)
```rust
pub fn deserialize_from_string<'de, D, T>(deserializer: D) -> Result<T, D::Error>
where
    D: Deserializer<'de>,
    T: FromStr,
    <T as FromStr>::Err: std::fmt::Display,
{
    use serde::de::Error;

    let s = <String>::deserialize(deserializer)?;
    s.parse::<T>().map_err(D::Error::custom)
}
```

**File:** crates/indexer/src/models/stake_models/proposal_votes.rs (L20-28)
```rust
pub struct ProposalVote {
    pub transaction_version: i64,
    pub proposal_id: i64,
    pub voter_address: String,
    pub staking_pool_address: String,
    pub num_votes: BigDecimal,
    pub should_pass: bool,
    pub transaction_timestamp: chrono::NaiveDateTime,
}
```

**File:** crates/indexer/src/models/stake_models/proposal_votes.rs (L40-48)
```rust
                    proposal_votes.push(Self {
                        transaction_version: txn_version,
                        proposal_id: ev.proposal_id as i64,
                        voter_address: standardize_address(&ev.voter),
                        staking_pool_address: standardize_address(&ev.stake_pool),
                        num_votes: ev.num_votes.clone(),
                        should_pass: ev.should_pass,
                        transaction_timestamp: parse_timestamp(user_txn.timestamp.0, txn_version),
                    });
```

**File:** crates/indexer/src/schema.rs (L627-638)
```rust
    proposal_votes (transaction_version, proposal_id, voter_address) {
        transaction_version -> Int8,
        proposal_id -> Int8,
        #[max_length = 66]
        voter_address -> Varchar,
        #[max_length = 66]
        staking_pool_address -> Varchar,
        num_votes -> Numeric,
        should_pass -> Bool,
        transaction_timestamp -> Timestamp,
        inserted_at -> Timestamp,
    }
```
