# Audit Report

## Title
HTTP Header Injection in Proxy Connections via Malicious DNS Names in NetworkAddress

## Summary
The `DnsName` validation in `types/src/network_address/mod.rs` does not sanitize CRLF characters (`\r\n`), allowing HTTP header injection when NetworkAddresses are used with proxy connections in `connect_via_proxy()`. While technically exploitable, this requires validator operator privileges.

## Finding Description

The vulnerability exists in the DNS name validation logic that fails to sanitize newline characters. The attack chain is:

1. **Input Validation Gap**: [1](#0-0) 
   The `DnsName::validate()` function only checks for: non-empty strings, length â‰¤255 bytes, no '/' characters, and ASCII-only. Critically, it does NOT reject CRLF characters (`\r` = ASCII 13, `\n` = ASCII 10), which are valid ASCII.

2. **Unsafe String Interpolation**: [2](#0-1) 
   The `connect_via_proxy()` function extracts the host via `parse_tcp()` and directly interpolates it into an HTTP CONNECT request without sanitization.

3. **Host Extraction**: [3](#0-2) 
   The `parse_tcp()` function converts Protocol::Dns variants to strings via `to_string()`, preserving any CRLF characters.

**Attack Path:**
A malicious validator operator could:
1. Update their network address via [4](#0-3) 
   The `update_network_and_fullnode_addresses()` function accepts raw bytes without Move-level validation.

2. Supply a DNS name like `"evil.com\r\nX-Injected: malicious"` through [5](#0-4) 
   The CLI parsing accepts CRLF in DNS names.

3. The resulting HTTP CONNECT request becomes:
   ```
   CONNECT evil.com
   X-Injected: malicious:6180 HTTP/1.0
   ```
   enabling request smuggling, authentication bypass, or connection hijacking.

## Impact Explanation

**Severity: N/A - Requires Privileged Access**

While this represents a genuine protocol violation enabling HTTP header injection, proxy authentication bypass, and request smuggling, it requires validator operator privileges to exploit. The attack only affects nodes connecting through HTTP proxies (configured via environment variables).

Per the Aptos bug bounty criteria, valid vulnerabilities must be "exploitable by unprivileged attacker (no validator insider access required)." This vulnerability fails that requirement.

## Likelihood Explanation

**Likelihood: Not Applicable**

The trust model explicitly states: "Do not assume [validator operators] behave maliciously unless the question explicitly explores insider threats." Since exploitation requires validator operator privileges to update on-chain network addresses, this falls outside the defined threat model for unprivileged attackers.

## Recommendation

Despite not meeting bug bounty criteria, the validation gap should be fixed for defense-in-depth:

Add CRLF validation to `DnsName::validate()`:
```rust
} else if s.contains(['\r', '\n']) {
    Err(ParseError::InvalidDnsNameCharacter)
```

Alternatively, sanitize in `connect_via_proxy()` before string interpolation.

## Proof of Concept

```rust
#[test]
fn test_dns_name_crlf_injection() {
    use aptos_types::network_address::*;
    
    // Malicious DNS name with CRLF passes validation
    let malicious = "evil.com\r\nX-Injected: header";
    let dns_name = DnsName::from_str(malicious).unwrap(); // Should fail but doesn't
    
    // Create NetworkAddress
    let addr = NetworkAddress::try_from(vec![
        Protocol::Dns(dns_name),
        Protocol::Tcp(6180),
    ]).unwrap();
    
    // parse_tcp returns the malicious host
    let ((host, port), _) = parse_tcp(addr.as_slice()).unwrap();
    assert!(host.contains("\r\n")); // CRLF preserved
    
    // Would create malformed HTTP request in connect_via_proxy()
    let request = format!("CONNECT {0}:{1} HTTP/1.0\r\n\r\n", host, port);
    assert!(request.contains("X-Injected: header")); // Header injection succeeds
}
```

**Note:** This PoC demonstrates the technical vulnerability but exploitation requires validator operator privileges, placing it outside the defined threat model for the Aptos bug bounty program.

## Notes

While the technical vulnerability is valid (CRLF characters in DNS names enable HTTP header injection), it requires validator operator privileges to exploit through on-chain network address updates. According to the trust model: "Do not assume [validator operators] behave maliciously unless the question explicitly explores insider threats."

The vulnerability also has limited practical impact since:
1. Only affects nodes using HTTP proxies (environment variable configured)
2. Requires compromised validator operator credentials
3. Primarily affects peer connectivity, not consensus or funds

From a defense-in-depth perspective, the validation gap should be fixed, but it does not constitute a valid bug bounty submission under current criteria.

### Citations

**File:** types/src/network_address/mod.rs (L667-679)
```rust
    fn validate(s: &str) -> Result<(), ParseError> {
        if s.is_empty() {
            Err(ParseError::EmptyDnsNameString)
        } else if s.len() > MAX_DNS_NAME_SIZE {
            Err(ParseError::DnsNameTooLong(s.len()))
        } else if s.contains('/') {
            Err(ParseError::InvalidDnsNameCharacter)
        } else if !s.is_ascii() {
            Err(ParseError::DnsNameNonASCII(s.into()))
        } else {
            Ok(())
        }
    }
```

**File:** types/src/network_address/mod.rs (L823-839)
```rust
pub fn parse_tcp(protos: &[Protocol]) -> Option<((String, u16), &[Protocol])> {
    use Protocol::*;

    if protos.len() < 2 {
        return None;
    }

    let (prefix, suffix) = protos.split_at(2);
    match prefix {
        [Ip4(ip), Tcp(port)] => Some(((ip.to_string(), *port), suffix)),
        [Ip6(ip), Tcp(port)] => Some(((ip.to_string(), *port), suffix)),
        [Dns(name), Tcp(port)] => Some(((name.to_string(), *port), suffix)),
        [Dns4(name), Tcp(port)] => Some(((name.to_string(), *port), suffix)),
        [Dns6(name), Tcp(port)] => Some(((name.to_string(), *port), suffix)),
        _ => None,
    }
}
```

**File:** network/netcore/src/transport/tcp.rs (L264-271)
```rust
    if let Some(((host, port), _addr_suffix)) = parse_tcp(protos) {
        let mut stream = TcpStream::connect(proxy_addr).await?;
        let mut buffer = [0; 4096];
        let mut read = 0;

        stream
            .write_all(&format!("CONNECT {0}:{1} HTTP/1.0\r\n\r\n", host, port).into_bytes())
            .await?;
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L955-971)
```text
    public entry fun update_network_and_fullnode_addresses(
        operator: &signer,
        pool_address: address,
        new_network_addresses: vector<u8>,
        new_fullnode_addresses: vector<u8>,
    ) acquires StakePool, ValidatorConfig {
        check_stake_permission(operator);
        assert_reconfig_not_in_progress();
        assert_stake_pool_exists(pool_address);
        let stake_pool = borrow_global_mut<StakePool>(pool_address);
        assert!(signer::address_of(operator) == stake_pool.operator_address, error::unauthenticated(ENOT_OPERATOR));
        assert!(exists<ValidatorConfig>(pool_address), error::not_found(EVALIDATOR_CONFIG));
        let validator_info = borrow_global_mut<ValidatorConfig>(pool_address);
        let old_network_addresses = validator_info.network_addresses;
        validator_info.network_addresses = new_network_addresses;
        let old_fullnode_addresses = validator_info.fullnode_addresses;
        validator_info.fullnode_addresses = new_fullnode_addresses;
```

**File:** crates/aptos-genesis/src/config.rs (L326-340)
```rust
impl FromStr for HostAndPort {
    type Err = anyhow::Error;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let parts: Vec<_> = s.split(':').collect();
        if parts.len() != 2 {
            Err(anyhow::Error::msg(
                "Invalid host and port, must be of the form 'host:port` e.g. '127.0.0.1:6180'",
            ))
        } else {
            let host_str = *parts.first().unwrap();
            if host_str.trim().is_empty() {
                Err(anyhow::Error::msg("Invalid host, host is empty"))
            } else {
                let host = DnsName::from_str(host_str)?;
```
