# Audit Report

## Title
Database Key-Value Mismatch Leading to Incorrect Entry Deletion in Randomness Beacon Storage

## Summary
The `remove_aug_data()` function recomputes database keys from `AugData` values instead of using the actual stored keys, creating a fragile design that could cause wrong entries to be deleted if key-value mismatches occur in the database.

## Finding Description
The randomness beacon storage system maintains augmented data (`AugData<D>`) in a key-value database where keys are `AugDataId {epoch, author}` tuples. [1](#0-0) 

The critical flaw occurs in the data lifecycle:

1. **Storage**: When data is saved, the key is computed from the value's fields [2](#0-1) 

2. **Retrieval**: `get_all_aug_data()` returns both keys AND values as pairs [3](#0-2) 

3. **Filtering**: During epoch initialization, `filter_by_epoch` checks the stored KEY's epoch to decide what to remove, but then **discards the keys** and only passes the VALUES [4](#0-3) [5](#0-4) 

4. **Deletion**: `remove_aug_data` receives only values and **recomputes** keys using `d.id()` from the value's internal fields [1](#0-0) 

This creates a dangerous assumption: `stored_key == value.id()` must ALWAYS hold. The `id()` method extracts epoch and author from the value: [6](#0-5) 

**When Key-Value Mismatch Occurs:**

If database contains: `Key = AugDataId{epoch: 1, author: Alice}`, `Value = AugData{epoch: 2, author: Alice, data: X}` (due to corruption, deserialization bug, or software defect)

During epoch 2 initialization:
- `filter_by_epoch` sees `key.epoch = 1 ≠ 2`, decides to remove
- Passes `AugData{epoch: 2, author: Alice, ...}` to `remove_aug_data`
- `remove_aug_data` computes `AugDataId{epoch: 2, author: Alice}` from the value
- Attempts to delete entry with key `{epoch: 2, author: Alice}` — **WRONG KEY!**
- Original corrupted entry remains under `{epoch: 1, author: Alice}`
- If legitimate epoch-2 data exists, it gets wrongly deleted

## Impact Explanation
**Medium Severity** — State inconsistencies requiring intervention

The vulnerability breaks the **State Consistency** invariant. While network validation prevents direct exploitation: [7](#0-6) [8](#0-7) 

The design flaw makes the system vulnerable to:
- **Consensus disruption**: Wrong deletion of current-epoch randomness data breaks beacon generation
- **Storage corruption**: Stale data not cleaned up; active data incorrectly removed
- **Validator inconsistency**: Different nodes with different corruption states diverge

This qualifies as Medium severity per Aptos bounty criteria: "State inconsistencies requiring intervention."

## Likelihood Explanation
**Low to Medium** likelihood. Requires precondition (key-value mismatch) that cannot be directly created by external attackers. However, realistic scenarios include:

1. **Database corruption** from hardware failures, disk errors, or power loss
2. **BCS deserialization bugs** causing field corruption
3. **Software bugs** in storage layer creating mismatches
4. **Race conditions** during concurrent database operations

While not immediately exploitable, production blockchain systems run continuously for years, making such conditions increasingly probable over time.

## Recommendation
**Fix the API design** to eliminate key recomputation:

**Option 1**: Pass actual database keys to deletion function
```rust
fn remove_aug_data(&self, ids: Vec<AugDataId>) -> Result<()> {
    Ok(self.delete::<AugDataSchema<D>>(ids.into_iter())?)
}
```

**Option 2**: Use key-value pairs to preserve database keys
```rust
fn remove_aug_data(&self, entries: Vec<(AugDataId, AugData<D>)>) -> Result<()> {
    Ok(self.delete::<AugDataSchema<D>>(entries.into_iter().map(|(id, _)| id))?)
}
```

Update `filter_by_epoch` to pass keys:
```rust
fn filter_by_epoch<T>(
    epoch: u64,
    all_data: impl Iterator<Item = (AugDataId, T)>,
) -> (Vec<AugDataId>, Vec<(AugDataId, T)>) {  // Return IDs for removal
    let mut ids_to_remove = vec![];
    let mut to_keep = vec![];
    for (id, data) in all_data {
        if id.epoch() != epoch {
            ids_to_remove.push(id);  // Keep the actual key
        } else {
            to_keep.push((id, data))
        }
    }
    (ids_to_remove, to_keep)
}
```

This ensures deletion always uses the exact key that was stored, eliminating the fragile assumption.

## Proof of Concept
```rust
#[cfg(test)]
mod test {
    use super::*;
    use aptos_types::account_address::AccountAddress;
    
    #[test]
    fn test_key_value_mismatch_causes_wrong_deletion() {
        // Simulate corrupted database state
        let db = create_test_db();
        
        // Manually inject mismatched entry:
        // Key: epoch=1, author=Alice
        // Value: epoch=2, author=Alice (corrupted)
        let alice = AccountAddress::random();
        let corrupted_key = AugDataId::new(1, alice);
        let corrupted_value = AugData::new(2, alice, MockAugData);
        
        // Directly insert mismatched pair (simulating corruption)
        db.raw_put(corrupted_key, corrupted_value);
        
        // Also insert legitimate epoch-2 data
        let legit_value = AugData::new(2, alice, MockAugData);
        db.save_aug_data(&legit_value).unwrap();
        
        // Now initialize for epoch 2 (should clean epoch 1)
        let all_data = db.get_all_aug_data().unwrap();
        let (to_remove, _) = filter_by_epoch(2, all_data.into_iter());
        
        // to_remove contains AugData{epoch: 2, ...} (from corrupted entry)
        db.remove_aug_data(to_remove).unwrap();
        
        // VERIFICATION: Wrong deletion occurred
        // - Corrupted entry (key=epoch:1) still exists
        // - Legitimate entry (key=epoch:2) was deleted
        let remaining = db.get_all_aug_data().unwrap();
        assert!(remaining.iter().any(|(id, _)| id.epoch() == 1)); // Corruption remains
        assert!(remaining.iter().all(|(id, _)| id.epoch() != 2)); // Legit data deleted
    }
}
```

### Citations

**File:** consensus/src/rand/rand_gen/storage/db.rs (L90-92)
```rust
    fn save_aug_data(&self, aug_data: &AugData<D>) -> Result<()> {
        Ok(self.put::<AugDataSchema<D>>(&aug_data.id(), aug_data)?)
    }
```

**File:** consensus/src/rand/rand_gen/storage/db.rs (L110-112)
```rust
    fn remove_aug_data(&self, aug_data: Vec<AugData<D>>) -> Result<()> {
        Ok(self.delete::<AugDataSchema<D>>(aug_data.into_iter().map(|d| d.id()))?)
    }
```

**File:** consensus/src/rand/rand_gen/storage/interface.rs (L15-15)
```rust
    fn get_all_aug_data(&self) -> anyhow::Result<Vec<(AugDataId, AugData<D>)>>;
```

**File:** consensus/src/rand/rand_gen/aug_data_store.rs (L28-42)
```rust
    fn filter_by_epoch<T>(
        epoch: u64,
        all_data: impl Iterator<Item = (AugDataId, T)>,
    ) -> (Vec<T>, Vec<(AugDataId, T)>) {
        let mut to_remove = vec![];
        let mut to_keep = vec![];
        for (id, data) in all_data {
            if id.epoch() != epoch {
                to_remove.push(data)
            } else {
                to_keep.push((id, data))
            }
        }
        (to_remove, to_keep)
    }
```

**File:** consensus/src/rand/rand_gen/aug_data_store.rs (L51-55)
```rust
        let all_data = db.get_all_aug_data().unwrap_or_default();
        let (to_remove, aug_data) = Self::filter_by_epoch(epoch, all_data.into_iter());
        if let Err(e) = db.remove_aug_data(to_remove) {
            error!("[AugDataStore] failed to remove aug data: {:?}", e);
        }
```

**File:** consensus/src/rand/rand_gen/types.rs (L476-481)
```rust
    pub fn id(&self) -> AugDataId {
        AugDataId {
            epoch: self.epoch,
            author: self.author,
        }
    }
```

**File:** consensus/src/rand/rand_gen/types.rs (L487-497)
```rust
    pub fn verify(
        &self,
        rand_config: &RandConfig,
        fast_rand_config: &Option<RandConfig>,
        sender: Author,
    ) -> anyhow::Result<()> {
        ensure!(self.author == sender, "Invalid author");
        self.data
            .verify(rand_config, fast_rand_config, &self.author)?;
        Ok(())
    }
```

**File:** consensus/src/rand/rand_gen/network_messages.rs (L36-49)
```rust
    pub fn verify(
        &self,
        epoch_state: &EpochState,
        rand_config: &RandConfig,
        fast_rand_config: &Option<RandConfig>,
        sender: Author,
    ) -> anyhow::Result<()> {
        ensure!(self.epoch() == epoch_state.epoch);
        match self {
            RandMessage::RequestShare(_) => Ok(()),
            RandMessage::Share(share) => share.verify(rand_config),
            RandMessage::AugData(aug_data) => {
                aug_data.verify(rand_config, fast_rand_config, sender)
            },
```
