# Audit Report

## Title
View Function Validation Bypass Allows Signer Parameter Injection via Incomplete Early Return Checks

## Summary

The `validate_view_function()` function's early return checks at lines 49-52 and 56-61 are insufficient to prevent malicious view functions with signer parameters from executing. An attacker can bypass the intended security model by crafting bytecode that passes publish-time validation but violates the fundamental invariant that view functions cannot have signer parameters, leading to access control bypass and information disclosure.

## Finding Description

The vulnerability exists across multiple validation layers:

**1. Incomplete Publish-Time Validation** [1](#0-0) 

The `is_valid_view_function` check only validates that the function returns values, but does NOT validate parameter types or check for signer parameters.

**2. Insufficient Runtime Early Returns** [2](#0-1) 

The early return checks only verify:
- Function is marked as view (lines 49-52)
- Function returns values (lines 56-61)

They do NOT validate the function signature or parameter types.

**3. Permissive Runtime Argument Validation** [3](#0-2) 

When `is_view = true`, Signer type arguments are ALLOWED, contrary to the security invariant.

**4. Compile-Time Checks Not Enforced at Publish** [4](#0-3) 

The extended checker validates that view functions cannot have signer parameters, but this only runs during normal Move compilation, not during bytecode publishing validation.

**Attack Path:**

1. Attacker crafts bytecode directly (bypassing Move compiler) containing a function that:
   - Is marked with the view function attribute in metadata
   - Returns values (to pass `is_valid_view_function`)
   - Has signer parameters (violating the intended invariant)

2. Module is published and passes validation because `is_valid_view_function` only checks return signature

3. Attacker calls the view function via API, supplying arbitrary addresses as signer arguments

4. Runtime validation:
   - Early return at lines 49-52 does NOT trigger (function is marked as view)
   - Early return at lines 56-61 does NOT trigger (function returns values)
   - Argument construction allows signer arguments (line 316: `if is_view { Ok(arg) }`)

5. View function executes with attacker-controlled signer addresses, bypassing access control

## Impact Explanation

**Medium Severity** - This vulnerability enables:

- **Access Control Bypass**: View functions can access resources/data protected by signer ownership checks that should only be readable by the account owner
- **Information Disclosure**: Private account data can be read and returned to unauthorized parties
- **Security Model Violation**: Breaks the fundamental invariant that only account owners provide their signers

While view functions cannot persist state changes (limiting impact), they can read protected resources and return sensitive data. This violates critical access control expectations and the documented security model for view functions.

## Likelihood Explanation

**High Likelihood:**

- Requires only bytecode crafting capability (publicly documented Move bytecode format)
- No special privileges required - any user can publish modules
- Validation gap is systematic across all three layers (compile, publish, runtime)
- View functions are frequently used for querying blockchain state
- Attack is deterministic once malicious module is published

The primary barrier is bytecode crafting knowledge, which is within reach of skilled attackers given Move's open-source tooling.

## Recommendation

Add parameter type validation to both publish-time and runtime checks:

**Fix 1: Enhance `is_valid_view_function` in module_metadata.rs:**

```rust
pub fn is_valid_view_function(
    module: &CompiledModule,
    functions: &BTreeMap<&IdentStr, (&FunctionHandle, &FunctionDefinition)>,
    fun: &str,
) -> Result<(), AttributeValidationError> {
    if let Ok(ident_fun) = Identifier::new(fun) {
        if let Some((func_handle, _func_def)) = functions.get(ident_fun.as_ident_str()) {
            let return_sig = module.signature_at(func_handle.return_);
            if return_sig.0.is_empty() {
                return Err(AttributeValidationError {
                    key: fun.to_string(),
                    attribute: KnownAttributeKind::ViewFunction as u8,
                });
            }
            
            // NEW: Validate parameters don't include Signer types
            let param_sig = module.signature_at(func_handle.parameters);
            for param_type in &param_sig.0 {
                if matches!(param_type, SignatureToken::Signer) {
                    return Err(AttributeValidationError {
                        key: fun.to_string(),
                        attribute: KnownAttributeKind::ViewFunction as u8,
                    });
                }
                // Also check for &signer references
                if let SignatureToken::Reference(inner) = param_type {
                    if matches!(**inner, SignatureToken::Signer) {
                        return Err(AttributeValidationError {
                            key: fun.to_string(),
                            attribute: KnownAttributeKind::ViewFunction as u8,
                        });
                    }
                }
            }
            
            return Ok(());
        }
    }
    
    Err(AttributeValidationError {
        key: fun.to_string(),
        attribute: KnownAttributeKind::ViewFunction as u8,
    })
}
```

**Fix 2: Add runtime validation in `validate_view_function`:** [5](#0-4) 

Add parameter type check after line 61:

```rust
// NEW: Validate parameters don't include Signer types
for param_ty in func.param_tys() {
    if param_ty.is_signer_or_signer_ref() {
        return Err(
            PartialVMError::new(StatusCode::INVALID_MAIN_FUNCTION_SIGNATURE)
                .with_message("view function cannot have signer parameters".to_string()),
        );
    }
}
```

## Proof of Concept

```rust
// Proof of Concept outline (requires bytecode crafting):

// Step 1: Craft malicious module bytecode
// Create a CompiledModule with:
// - Function marked with view attribute in RuntimeModuleMetadataV1
// - Function signature: `public fun malicious_view(s: signer): u64`
// - Function body that accesses signer-protected resources

// Step 2: Publish the module
// The module will pass is_valid_view_function() because:
// - Function exists
// - Returns u64 (non-empty return signature)
// - Signer parameter NOT checked

// Step 3: Call view function via API
POST /v1/view
{
  "function": "0xATTACKER::malicious::malicious_view",
  "type_arguments": [],
  "arguments": ["0xVICTIM"]  // Arbitrary victim address as signer
}

// Step 4: View function executes
// - Passes early returns (lines 49-52, 56-61)
// - construct_arg() allows Signer with is_view=true (line 316)
// - Function reads victim's private resources
// - Returns sensitive data to attacker

// Expected: Function should reject signer parameter
// Actual: Function executes with attacker-controlled signer address
```

## Notes

This vulnerability demonstrates a critical gap between the three validation layers (compile-time, publish-time, runtime). The compile-time checker in `extended_checks.rs` correctly prevents developers from writing view functions with signer parameters, but this protection is not enforced when modules are published via raw bytecode. The inconsistent validation logic at line 316 of `transaction_arg_validation.rs` (allowing signers for view functions) further compounds the issue, creating an exploitable security hole.

### Citations

**File:** types/src/vm/module_metadata.rs (L378-396)
```rust
pub fn is_valid_view_function(
    module: &CompiledModule,
    functions: &BTreeMap<&IdentStr, (&FunctionHandle, &FunctionDefinition)>,
    fun: &str,
) -> Result<(), AttributeValidationError> {
    if let Ok(ident_fun) = Identifier::new(fun) {
        if let Some((func_handle, _func_def)) = functions.get(ident_fun.as_ident_str()) {
            let sig = module.signature_at(func_handle.return_);
            if !sig.0.is_empty() {
                return Ok(());
            }
        }
    }

    Err(AttributeValidationError {
        key: fun.to_string(),
        attribute: KnownAttributeKind::ViewFunction as u8,
    })
}
```

**File:** aptos-move/aptos-vm/src/verifier/view_function.rs (L35-61)
```rust
pub(crate) fn validate_view_function(
    session: &mut SessionExt<impl AptosMoveResolver>,
    loader: &impl Loader,
    gas_meter: &mut impl GasMeter,
    traversal_context: &mut TraversalContext,
    args: Vec<Vec<u8>>,
    fun_name: &IdentStr,
    func: &LoadedFunction,
    module_metadata: Option<&RuntimeModuleMetadataV1>,
    struct_constructors_feature: bool,
) -> PartialVMResult<Vec<Vec<u8>>> {
    // Must be marked as view function.
    let is_view = determine_is_view(module_metadata, fun_name);
    if !is_view {
        return Err(
            PartialVMError::new(StatusCode::INVALID_MAIN_FUNCTION_SIGNATURE)
                .with_message("function not marked as view function".to_string()),
        );
    }

    // Must return values.
    if func.return_tys().is_empty() {
        return Err(
            PartialVMError::new(StatusCode::INVALID_MAIN_FUNCTION_SIGNATURE)
                .with_message("view function must return values".to_string()),
        );
    }
```

**File:** aptos-move/aptos-vm/src/verifier/transaction_arg_validation.rs (L314-320)
```rust
        Signer => {
            if is_view {
                Ok(arg)
            } else {
                Err(invalid_signature())
            }
        },
```

**File:** aptos-move/framework/src/extended_checks.rs (L700-729)
```rust
            fun.get_parameters()
                .iter()
                .for_each(
                    |Parameter(_sym, parameter_type, param_loc)| match parameter_type {
                        Type::Primitive(inner) => {
                            if inner == &PrimitiveType::Signer {
                                self.env.error(
                                    param_loc,
                                    "`#[view]` function cannot use a `signer` parameter",
                                )
                            }
                        },
                        Type::Reference(mutability, inner) => {
                            if let Type::Primitive(inner) = inner.as_ref() {
                                if inner == &PrimitiveType::Signer
                                // Avoid a redundant error message for `&mut signer`, which is
                                // always disallowed for transaction entries, not just for
                                // `#[view]`.
                                    && mutability == &ReferenceKind::Immutable
                                {
                                    self.env.error(
                                        param_loc,
                                        "`#[view]` function cannot use the `&signer` parameter",
                                    )
                                }
                            }
                        },
                        _ => (),
                    },
                );
```
