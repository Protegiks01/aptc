# Audit Report

## Title
Missing Equivocation Detection in OptProposalMsg Buffering Allows Consensus Liveness Attack

## Summary
A malicious block proposer can send multiple `OptProposalMsg` messages for the same round with different timestamps to different validators. Due to missing equivocation detection during the buffering phase, each validator silently overwrites previous proposals in their `pending_opt_proposals` map, and different validators may process and vote on different blocks for the same round, preventing quorum certificate formation and causing round timeouts.

## Finding Description

The vulnerability exists in the `process_opt_proposal_msg` function where optimistic proposals are buffered for future rounds. [1](#0-0) 

When an optimistic proposal arrives for a future round, the code only validates that the sender is the valid proposer for that round, but does NOT check if a proposal for that round has already been buffered. The `pending_opt_proposals` BTreeMap silently overwrites any existing entry for the same round.

The timestamp is included in the block hash computation because `BlockData` derives `CryptoHasher`. [2](#0-1) 

**Attack Flow:**

1. A malicious validator becomes the valid proposer for round R
2. They create two `OptProposalMsg` instances with the same round but different timestamps:
   - OptMsg_A with timestamp T1
   - OptMsg_B with timestamp T2
3. They selectively send OptMsg_A to validators V1-V3 and OptMsg_B to validators V4-V6
4. Each validator stores their received message in `pending_opt_proposals[R]`:
   - If a validator receives both messages, the second silently overwrites the first
   - Different validators end up storing different proposals
5. When round R starts, each validator processes their buffered proposal via `process_opt_proposal` [3](#0-2) 
6. The `OptBlockData` is converted to a `Block` using the current highest QC [4](#0-3) 
7. Different timestamps result in different block IDs (hashes differ)
8. Each validator's `is_valid_proposal` check passes for their first block [5](#0-4) 
9. Validators vote on different blocks:
   - V1-V3 vote for Block_A
   - V4-V6 vote for Block_B
10. Neither block achieves quorum, causing a timeout

The `UnequivocalProposerElection` mechanism that should detect this equivocation only triggers during `process_proposal`, which happens independently per validator AFTER they've committed to a specific block. [6](#0-5) 

## Impact Explanation

This vulnerability enables a **liveness attack** classified as **Medium Severity** per the Aptos bug bounty criteria:

- **State inconsistencies requiring intervention**: Different validators maintain conflicting blocks for the same round in their block storage, creating inconsistent local state
- The attack prevents consensus progress for targeted rounds, forcing timeouts and wasting validator resources
- If the malicious proposer is selected frequently, this creates sustained consensus delays affecting network performance
- While the system eventually recovers via timeout mechanisms, repeated attacks can significantly degrade throughput

The attack does NOT cause safety violations (no double-commits or chain forks) but does violate the liveness guarantee and creates temporary state divergence across validators.

## Likelihood Explanation

**Likelihood: Medium-High**

- The attacker must be selected as the valid proposer (probability ~1/N per round where N is validator count)
- Requires no collusion or special privileges beyond being a validator
- Attack is simple to execute - just send different messages to different peers
- Detection is difficult as the overwriting happens silently without security events
- Can be repeated each time the malicious validator is selected as proposer
- Under 1/3 Byzantine assumption, multiple malicious validators could execute this frequently

## Recommendation

Add equivocation detection BEFORE buffering optimistic proposals:

```rust
// In process_opt_proposal_msg, replace lines 832-833 with:
if let Some(existing_opt_data) = self.pending_opt_proposals.get(&proposal_msg.round()) {
    // Check if this is the same proposal (same hash) or equivocation
    let existing_hash = existing_opt_data.hash();
    let new_hash = proposal_msg.block_data().hash();
    
    if existing_hash != new_hash {
        // Log security event for attempted equivocation
        error!(
            SecurityEvent::InvalidConsensusProposal,
            "Received different optimistic proposal for round {} from {}: existing hash {}, new hash {}",
            proposal_msg.round(),
            proposal_msg.proposer(),
            existing_hash,
            new_hash
        );
        bail!(
            "Equivocating optimistic proposal detected for round {} from {}",
            proposal_msg.round(),
            proposal_msg.proposer()
        );
    }
    // Same proposal, ignore duplicate
    return Ok(());
}
self.pending_opt_proposals.insert(proposal_msg.round(), proposal_msg.take_block_data());
```

Additionally, `OptBlockData` should implement `CryptoHasher` to enable hash comparison before conversion to `Block`: [7](#0-6) 

Add `#[derive(CryptoHasher)]` to the `OptBlockData` struct.

## Proof of Concept

```rust
// Test case demonstrating the vulnerability
#[tokio::test]
async fn test_optimistic_proposal_equivocation_attack() {
    let (mut playground, validators) = consensus_playground();
    let proposer_idx = 0;
    let proposer = validators[proposer_idx].signer();
    
    // Create two different optimistic proposals for the same round with different timestamps
    let round = 3;
    let epoch = 1;
    
    let opt_block_data_1 = OptBlockData::new(
        vec![],
        Payload::empty(false, true),
        proposer.author(),
        epoch,
        round,
        1000, // timestamp T1
        parent_block_info.clone(),
        grandparent_qc.clone(),
    );
    
    let opt_block_data_2 = OptBlockData::new(
        vec![],
        Payload::empty(false, true),
        proposer.author(),
        epoch,
        round,
        2000, // timestamp T2 - different from T1
        parent_block_info.clone(),
        grandparent_qc.clone(),
    );
    
    let opt_proposal_1 = OptProposalMsg::new(opt_block_data_1, sync_info.clone());
    let opt_proposal_2 = OptProposalMsg::new(opt_block_data_2, sync_info.clone());
    
    // Send proposal 1 to validators 0-2
    for i in 0..3 {
        playground.send_to(i, opt_proposal_1.clone()).await;
    }
    
    // Send proposal 2 to validators 3-5  
    for i in 3..6 {
        playground.send_to(i, opt_proposal_2.clone()).await;
    }
    
    // Advance to round 3
    playground.advance_to_round(round).await;
    
    // Verify that different validators voted for different blocks (vote split)
    let votes_1 = playground.get_votes_for_round(round);
    let unique_block_ids: HashSet<HashValue> = votes_1.iter()
        .map(|v| v.vote_data().proposed().id())
        .collect();
    
    // This should show 2 different block IDs being voted on
    assert_eq!(unique_block_ids.len(), 2, "Vote split attack succeeded");
    
    // Neither block should achieve quorum
    assert!(playground.get_qc_for_round(round).is_none(), "No QC formed due to split");
}
```

**Notes:**

The vulnerability is confirmed by examining the code paths. The silent overwrite in the BTreeMap combined with timestamp-dependent block hashing allows a Byzantine proposer to split validator votes across different blocks for the same round. While the consensus protocol eventually recovers through timeouts, this represents a preventable liveness attack that should be mitigated through early equivocation detection.

### Citations

**File:** consensus/src/round_manager.rs (L822-833)
```rust
            // Pre-check that proposal is from valid proposer before queuing it.
            // This check is done after syncing up to sync info to ensure proposer
            // election provider is up to date.
            ensure!(
                self.proposer_election
                    .is_valid_proposer(proposal_msg.proposer(), proposal_msg.round()),
                "[OptProposal] Not a valid proposer for round {}: {}",
                proposal_msg.round(),
                proposal_msg.proposer()
            );
            self.pending_opt_proposals
                .insert(proposal_msg.round(), proposal_msg.take_block_data());
```

**File:** consensus/src/round_manager.rs (L843-875)
```rust
    async fn process_opt_proposal(&mut self, opt_block_data: OptBlockData) -> anyhow::Result<()> {
        ensure!(
            self.block_store
                .get_block_for_round(opt_block_data.round())
                .is_none(),
            "Proposal has already been processed for round: {}",
            opt_block_data.round()
        );
        let hqc = self.block_store.highest_quorum_cert().as_ref().clone();
        ensure!(
            hqc.certified_block().round() + 1 == opt_block_data.round(),
            "Opt proposal round {} is not the next round after the highest qc round {}",
            opt_block_data.round(),
            hqc.certified_block().round()
        );
        ensure!(
            hqc.certified_block().id() == opt_block_data.parent_id(),
            "Opt proposal parent id {} is not the same as the highest qc certified block id {}",
            opt_block_data.parent_id(),
            hqc.certified_block().id()
        );
        let proposal = Block::new_from_opt(opt_block_data, hqc);
        observe_block(proposal.timestamp_usecs(), BlockStage::PROCESS_OPT_PROPOSAL);
        info!(
            self.new_log(LogEvent::ProcessOptProposal),
            block_author = proposal.author(),
            block_epoch = proposal.epoch(),
            block_round = proposal.round(),
            block_hash = proposal.id(),
            block_parent_hash = proposal.quorum_cert().certified_block().id(),
        );
        self.process_proposal(proposal).await
    }
```

**File:** consensus/src/round_manager.rs (L1195-1200)
```rust
        ensure!(
            self.proposer_election.is_valid_proposal(&proposal),
            "[RoundManager] Proposer {} for block {} is not a valid proposer for this round or created duplicate proposal",
            author,
            proposal,
        );
```

**File:** consensus/consensus-types/src/block_data.rs (L72-97)
```rust
#[derive(Deserialize, Serialize, Clone, Debug, PartialEq, Eq, CryptoHasher)]
/// Block has the core data of a consensus block that should be persistent when necessary.
/// Each block must know the id of its parent and keep the QuorurmCertificate to that parent.
pub struct BlockData {
    /// Epoch number corresponds to the set of validators that are active for this block.
    epoch: u64,
    /// The round of a block is an internal monotonically increasing counter used by Consensus
    /// protocol.
    round: Round,
    /// The approximate physical time a block is proposed by a proposer.  This timestamp is used
    /// for
    /// * Time-dependent logic in smart contracts (the current time of execution)
    /// * Clients determining if they are relatively up-to-date with respect to the block chain.
    ///
    /// It makes the following guarantees:
    ///   1. Time Monotonicity: Time is monotonically increasing in the block chain.
    ///      (i.e. If H1 < H2, H1.Time < H2.Time).
    ///   2. If a block of transactions B is agreed on with timestamp T, then at least
    ///      f+1 honest validators think that T is in the past. An honest validator will
    ///      only vote on a block when its own clock >= timestamp T.
    ///   3. If a block of transactions B has a QC with timestamp T, an honest validator
    ///      will not serve such a block to other validators until its own clock >= timestamp T.
    ///   4. Current: an honest validator is not issuing blocks with a timestamp in the
    ///       future. Currently we consider a block is malicious if it was issued more
    ///       that 5 minutes in the future.
    timestamp_usecs: u64,
```

**File:** consensus/consensus-types/src/block.rs (L410-416)
```rust
    pub fn new_from_opt(opt_block_data: OptBlockData, quorum_cert: QuorumCert) -> Self {
        let block_data = BlockData::new_from_opt(opt_block_data, quorum_cert);
        Block {
            id: block_data.hash(),
            block_data,
            signature: None,
        }
```

**File:** consensus/src/liveness/unequivocal_proposer_election.rs (L46-87)
```rust
    pub fn is_valid_proposal(&self, block: &Block) -> bool {
        block.author().is_some_and(|author| {
            let valid_author = self.is_valid_proposer(author, block.round());
            if !valid_author {
                warn!(
                    SecurityEvent::InvalidConsensusProposal,
                    "Proposal is not from valid author {}, expected {} for round {} and id {}",
                    author,
                    self.get_valid_proposer(block.round()),
                    block.round(),
                    block.id()
                );

                return false;
            }
            let mut already_proposed = self.already_proposed.lock();
            // detect if the leader proposes more than once in this round
            match block.round().cmp(&already_proposed.0) {
                Ordering::Greater => {
                    already_proposed.0 = block.round();
                    already_proposed.1 = block.id();
                    true
                },
                Ordering::Equal => {
                    if already_proposed.1 != block.id() {
                        error!(
                            SecurityEvent::InvalidConsensusProposal,
                            "Multiple proposals from {} for round {}: {} and {}",
                            author,
                            block.round(),
                            already_proposed.1,
                            block.id()
                        );
                        false
                    } else {
                        true
                    }
                },
                Ordering::Less => false,
            }
        })
    }
```

**File:** consensus/consensus-types/src/opt_block_data.rs (L20-28)
```rust
#[derive(Deserialize, Serialize, Clone, Debug, PartialEq, Eq, CryptoHasher)]
/// Same as BlockData, without QC and with parent id
pub struct OptBlockData {
    pub epoch: u64,
    pub round: Round,
    pub timestamp_usecs: u64,
    pub parent: BlockInfo,
    pub block_body: OptBlockBody,
}
```
