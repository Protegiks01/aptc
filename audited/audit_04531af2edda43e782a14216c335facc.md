# Audit Report

## Title
Database Corruption: Orphaned Event Index Entries During Ledger Truncation

## Summary
During database truncation operations at node startup, the `delete_event_data` function deletes events from `EventSchema` without removing corresponding entries from `EventByKeySchema` and `EventByVersionSchema`, creating orphaned index entries that point to non-existent events. This violates database integrity and causes query failures.

## Finding Description
The vulnerability exists in the database truncation logic that synchronizes commit progress across different database components during node startup. When `StateStore::sync_commit_progress` detects a mismatch between overall commit progress and individual database progress, it calls `truncate_ledger_db` to remove data after the synchronization point. [1](#0-0) 

The truncation process calls `delete_event_data`, which invokes `prune_event_indices` with a `None` parameter for the indices batch: [2](#0-1) 

This `None` parameter causes the function to skip deleting index entries from `EventByKeySchema` and `EventByVersionSchema`: [3](#0-2) 

However, the actual events are still deleted from `EventSchema` in the subsequent `prune_events` call: [4](#0-3) 

This creates orphaned entries in `EventByKeySchema` and `EventByVersionSchema` that reference `(version, index)` tuples no longer present in `EventSchema`. When queries attempt to look up events using these indices, they successfully retrieve the reference but fail when fetching the actual event: [5](#0-4) 

The code comment acknowledges this issue with a TODO but assumes data will be rewritten, which is incorrect for truncation operations where data is permanently deleted: [6](#0-5) 

This breaks the **State Consistency** invariant that requires state transitions to be atomic and verifiable.

## Impact Explanation
This issue qualifies as **Medium Severity** under the Aptos bug bounty program category: "State inconsistencies requiring intervention."

The impact includes:
1. **Database Integrity Violation**: Orphaned index entries violate the referential integrity between `EventByKeySchema`/`EventByVersionSchema` and `EventSchema`
2. **Query Failures**: Event lookups by key return `AptosDbError::NotFound` despite index entries indicating events should exist
3. **Inconsistent Database State**: The database is left in an inconsistent state requiring manual cleanup
4. **Node Reliability**: Affects node startup and recovery procedures when database synchronization is needed

While this doesn't directly cause funds loss or consensus violations, it corrupts the database state and requires intervention to resolve.

## Likelihood Explanation
**Likelihood: High**

This issue occurs automatically during normal node operations:
- Triggers during `StateStore::new` initialization when `sync_commit_progress` is called
- Happens whenever there's a mismatch between overall commit progress and individual database commit progress
- Common during node restart/recovery scenarios
- No malicious action requiredâ€”it's a design flaw in the truncation logic

The code is executed in production during legitimate database synchronization operations at node startup.

## Recommendation
Modify `delete_event_data` to properly delete event indices before deleting events. The fix should create a batch for index deletion and pass it to `prune_event_indices`:

```rust
fn delete_event_data(
    ledger_db: &LedgerDb,
    start_version: Version,
    batch: &mut SchemaBatch,
) -> Result<()> {
    if let Some(latest_version) = ledger_db.event_db().latest_version()? {
        if latest_version >= start_version {
            info!(
                start_version = start_version,
                latest_version = latest_version,
                "Truncate event data."
            );
            // Create a batch for index deletion instead of passing None
            let num_events_per_version = ledger_db.event_db().prune_event_indices(
                start_version,
                latest_version + 1,
                Some(batch), // Pass the batch to ensure indices are deleted
            )?;
            ledger_db.event_db().prune_events(
                num_events_per_version,
                start_version,
                latest_version + 1,
                batch,
            )?;
        }
    }
    Ok(())
}
```

Alternatively, if indices should be stored in a separate internal indexer database, ensure proper coordination between the two databases during truncation operations and remove the assumption that data will be rewritten.

## Proof of Concept

```rust
#[test]
fn test_event_truncation_orphans_indices() {
    use aptos_temppath::TempPath;
    use aptos_types::contract_event::{ContractEvent, ContractEventV1};
    use aptos_types::event::EventKey;
    
    let tmp_dir = TempPath::new();
    let db = AptosDB::new_for_test(&tmp_dir);
    
    // Create and commit events at versions 0-10
    let event_key = EventKey::random();
    for version in 0..11 {
        let events = vec![ContractEvent::V1(ContractEventV1::new(
            event_key,
            version, // sequence number
            vec![],  // event data
            None,
        ))];
        
        let txns = vec![create_test_transaction_with_events(events)];
        db.save_transactions_for_test(&txns, version, None, true).unwrap();
    }
    
    // Verify events exist
    for seq_num in 0..11 {
        let result = db.get_events_by_event_key(&event_key, seq_num, 1, 10);
        assert!(result.is_ok());
    }
    
    // Close and reopen with truncation (simulating sync_commit_progress)
    drop(db);
    
    // Manually trigger truncation to version 5
    let (ledger_db, _, _, _) = AptosDB::open_dbs(...);
    truncate_ledger_db(Arc::new(ledger_db), 5).unwrap();
    
    // Reopen database
    let db = AptosDB::new_for_test(&tmp_dir);
    
    // Events 0-5 should exist
    for seq_num in 0..6 {
        assert!(db.get_events_by_event_key(&event_key, seq_num, 1, 10).is_ok());
    }
    
    // Events 6-10 are deleted from EventSchema
    for seq_num in 6..11 {
        let result = db.get_events_by_event_key(&event_key, seq_num, 1, 10);
        // This will succeed in finding the index but fail to fetch the event
        // demonstrating the orphaned index issue
        match result {
            Err(AptosDbError::NotFound(_)) => {
                // Orphaned index: index exists but event doesn't
                println!("Orphaned index detected for seq_num {}", seq_num);
            }
            Ok(_) => panic!("Event should not exist after truncation"),
            Err(e) => panic!("Unexpected error: {:?}", e),
        }
    }
    
    // Verify indices still exist for deleted events
    let event_store = EventStore::new(ledger_db.event_db().db_arc());
    for seq_num in 6..11 {
        // This will return (version, index) from the orphaned index
        let result = event_store.get_txn_ver_by_seq_num(&event_key, seq_num);
        assert!(result.is_ok(), "Orphaned index should still exist");
    }
}
```

## Notes
The TODO comment in the code explicitly acknowledges this issue but states an incorrect assumption that "same data will be overwritten into indices." During truncation operations, data is permanently deleted, not rewritten, making this assumption invalid. The bug affects both the event database (when internal indexer is disabled) and could affect the internal indexer database (when enabled but not properly synchronized during truncation). This is a production bug that requires fixing to maintain database integrity during node recovery operations.

### Citations

**File:** storage/aptosdb/src/state_store/mod.rs (L448-449)
```rust
            truncate_ledger_db(ledger_db.clone(), overall_commit_progress)
                .expect("Failed to truncate ledger db.");
```

**File:** storage/aptosdb/src/utils/truncation_helper.rs (L532-539)
```rust
            let num_events_per_version = ledger_db.event_db().prune_event_indices(
                start_version,
                latest_version + 1,
                // Assuming same data will be overwritten into indices, we don't bother to deal
                // with the existence or placement of indices
                // TODO: prune data from internal indices
                None,
            )?;
```

**File:** storage/aptosdb/src/ledger_db/event_db.rs (L206-217)
```rust
            if let Some(ref mut batch) = indices_batch {
                for event in events {
                    if let ContractEvent::V1(v1) = event {
                        batch.delete::<EventByKeySchema>(&(*v1.key(), v1.sequence_number()))?;
                        batch.delete::<EventByVersionSchema>(&(
                            *v1.key(),
                            current_version,
                            v1.sequence_number(),
                        ))?;
                    }
                }
            }
```

**File:** storage/aptosdb/src/ledger_db/event_db.rs (L235-236)
```rust
            for idx in 0..num_events {
                db_batch.delete::<EventSchema>(&(current_version, idx as u64))?;
```

**File:** storage/aptosdb/src/event_store/mod.rs (L42-50)
```rust
    pub fn get_event_by_version_and_index(
        &self,
        version: Version,
        index: u64,
    ) -> Result<ContractEvent> {
        self.event_db
            .get::<EventSchema>(&(version, index))?
            .ok_or_else(|| AptosDbError::NotFound(format!("Event {} of Txn {}", index, version)))
    }
```
