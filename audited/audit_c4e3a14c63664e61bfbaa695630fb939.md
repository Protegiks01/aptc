# Audit Report

## Title
State Injection via Unverified State Snapshot Restore Allows Complete Chain Compromise

## Summary
The `db-tool restore Oneoff StateSnapshot` command writes state snapshot data directly to the database without verifying validator signatures on the accompanying `LedgerInfoWithSignatures`. An attacker can craft a malicious backup containing arbitrary state values (including validator set, governance parameters, and coin balances) that will be accepted as long as it is internally consistent, enabling complete chain compromise.

## Finding Description

The vulnerability exists in the state snapshot restore workflow when `epoch_history` is `None`. [1](#0-0) 

When the `StateSnapshotRestoreController` is instantiated with `epoch_history: None`, a critical security check is bypassed: [2](#0-1) 

The `epoch_history.verify_ledger_info()` check is only performed if `epoch_history` is `Some`. This check is responsible for verifying that the `LedgerInfoWithSignatures` was actually signed by the validator set: [3](#0-2) 

This verification ensures that either:
1. The ledger info matches genesis (epoch 0)
2. The ledger info matches a trusted waypoint
3. **Most critically**: The ledger info is signed by the previous epoch's validator set

When `epoch_history` is `None`, none of these checks occur. The code even explicitly acknowledges this behavior: [4](#0-3) 

The only remaining checks verify internal consistency (that the transaction proof matches the ledger info and root hash), but do not verify authenticity: [5](#0-4) 

Once these internal consistency checks pass, the state is written directly to the database with no filtering on which state keys can be modified: [6](#0-5) 

The `StateSnapshotRestore.add_chunk()` writes arbitrary `(StateKey, StateValue)` pairs, including critical system resources: [7](#0-6) 

Critical system state that can be overwritten includes:
- `ValidatorSet` (controls active validators and voting power)
- Governance parameters (voting thresholds, proposal settings)
- Coin balances and supply (CoinStore resources)
- Any on-chain configuration or resource

When the node starts with this corrupted database, it performs minimal validation: [8](#0-7) 

The `maybe_bootstrap` function only validates genesis if the database version matches the waypoint version. For a database with existing state, it simply returns without validation, and the node will use the injected malicious state.

**Attack Path:**
1. Attacker creates a malicious state snapshot backup containing crafted state values (e.g., modified ValidatorSet with attacker-controlled validators)
2. Attacker generates a fake `LedgerInfoWithSignatures` with invalid or missing validator signatures
3. Attacker ensures internal consistency by making the Merkle proofs and root hash match
4. Victim operator obtains the malicious backup (via compromised storage, social engineering, or supply chain attack)
5. Victim runs `aptos-debugger aptos-db restore oneoff state-snapshot` pointing to the malicious backup
6. No signature verification occurs because `epoch_history` is `None`
7. Malicious state is written to database
8. Node restarts and uses the corrupted state without re-validation
9. Attacker now controls the validator set, can mint coins, or manipulate governance

## Impact Explanation

This vulnerability qualifies as **CRITICAL** severity under the Aptos bug bounty program for multiple reasons:

1. **Consensus/Safety Violations**: By overwriting the `ValidatorSet` on-chain configuration, an attacker can replace legitimate validators with attacker-controlled nodes, completely compromising the AptosBFT consensus protocol. This breaks the fundamental safety guarantee that <1/3 Byzantine validators cannot compromise consensus.

2. **Loss of Funds (Minting)**: By modifying `CoinStore<AptosCoin>` resources, an attacker can arbitrarily mint coins to any address or modify the total coin supply, directly causing loss of funds for legitimate holders through inflation.

3. **Governance Integrity Compromise**: By overwriting governance-related resources and configurations, an attacker can manipulate voting power, threshold parameters, and execute arbitrary governance proposals, permanently compromising the chain's governance mechanism.

4. **Non-Recoverable Without Hard Fork**: Once this corrupted state is committed to the database and the node participates in consensus, recovering requires identifying the corruption, coordinating a hard fork, and redistributing correct state to all nodes - a catastrophic failure mode.

The impact affects:
- **All network participants**: Consensus safety violation affects the entire chain
- **All token holders**: Coin supply manipulation dilutes all holdings
- **Governance**: Complete bypass of democratic decision-making
- **Trust in the protocol**: Requires hard fork to recover

## Likelihood Explanation

The likelihood is **MEDIUM to HIGH** because:

**Attack Vectors:**
1. **Compromised Backup Storage**: If an attacker gains access to the backup storage location (S3 bucket, cloud storage), they can replace legitimate backups with malicious ones. Operators regularly restore from backups during:
   - Node initialization in new deployments
   - Recovery from hardware failures
   - Scaling operations (spinning up new archive nodes)

2. **Social Engineering**: Attackers could impersonate infrastructure providers and provide "helpful" backup files to operators experiencing issues

3. **Supply Chain Attack**: Compromise of backup tooling or distribution channels

4. **Insider Threat**: Malicious insiders with database access could use this tool to inject state

**Factors Increasing Likelihood:**
- The tool is officially provided and documented
- The README explicitly mentions it can "manually hack a local DB"
- No warnings about verifying backup authenticity
- Common operational scenarios (node recovery) require restore operations
- The `trusted_waypoints` parameter that could provide some protection is optional and not enforced

**Factors Decreasing Likelihood:**
- Requires operator to actually run the restore command
- The tool is marked as "experimental" (though still used in production)
- Sophisticated attack requiring understanding of Aptos internals

## Recommendation

**Immediate Fix: Always Require Epoch History Verification**

The `StateSnapshotRestoreController` should **never** be instantiated with `epoch_history: None` in production scenarios. Modify the restore command to require epoch history: [1](#0-0) 

**Required Changes:**

1. **Require Epoch History in db-tool**: Modify the `Oneoff::StateSnapshot` handler to first restore epoch endings and build the epoch history before restoring state snapshots.

2. **Add Explicit Signature Verification**: Even with epoch history, add an additional explicit check that ensures signatures are verified:

```rust
// In StateSnapshotRestoreController::run_impl()
// After line 139, add:
if self.epoch_history.is_none() {
    return Err(anyhow!(
        "State snapshot restore requires epoch history for signature verification. \
         This is a critical security check. First restore epoch endings to build epoch history."
    ));
}
```

3. **Update Documentation**: Add explicit security warnings in the README that backup sources must be trusted and verified.

4. **Add Waypoint Enforcement**: At minimum, require trusted waypoints for any production restore operation:

```rust
// Enforce trusted waypoint verification
if self.epoch_history.is_none() && global_opt.trusted_waypoints.is_empty() {
    return Err(anyhow!(
        "Security Error: State snapshot restore requires either epoch history or \
         trusted waypoints to verify authenticity. Never restore from untrusted sources."
    ));
}
```

5. **Implement Backup Signing**: Add cryptographic signatures to backup manifests that can be verified against a known public key.

## Proof of Concept

**Step-by-Step Reproduction:**

```bash
# 1. Create a legitimate backup as baseline
cargo run -p aptos-debugger -- aptos-db backup one-shot state-snapshot \
    --backup-service-address http://localhost:6186 \
    --state-version 1000000 \
    --local-fs-dir /tmp/legitimate_backup

# 2. Craft malicious backup (attacker action)
# Modify the state snapshot chunks to include:
# - StateKey::on_chain_config::<ValidatorSet>() with attacker's validator set
# - StateKey::resource(&CoinStore<AptosCoin>) with inflated balances
# Create fake LedgerInfoWithSignatures with no valid signatures
# Ensure Merkle proofs are internally consistent with the fake root hash

# 3. Victim restores from malicious backup
cargo run -p aptos-debugger -- aptos-db restore oneoff state-snapshot \
    --state-manifest /tmp/malicious_backup/state_ver_1000000/manifest.json \
    --state-into-version 1000000 \
    --target-db-dir /tmp/victim_db \
    --validate-modules false

# 4. Observe that restore succeeds despite invalid signatures
# The only checks performed are:
# - txn_info_with_proof.verify(li.ledger_info(), ...) ✓ (internally consistent)
# - root_hash == manifest.root_hash ✓ (attacker-controlled)
# - epoch_history.verify_ledger_info() ✗ (SKIPPED - epoch_history is None)

# 5. Start node with corrupted database
# Node will use the malicious state without validation
aptos-node --config node_config.yaml

# Result: Node now uses attacker's ValidatorSet, accepts their blocks,
# and has inflated coin supply
```

**Rust Unit Test Demonstrating the Issue:**

```rust
#[tokio::test]
async fn test_state_snapshot_restore_without_signature_verification() {
    // Setup: Create fake backup with invalid signatures
    let fake_ledger_info = create_fake_ledger_info_with_no_signatures();
    let malicious_state = vec![
        (StateKey::on_chain_config::<ValidatorSet>(), malicious_validator_set_value()),
        (StateKey::resource(&account_addr, &CoinStore), inflated_balance_value()),
    ];
    
    // Create backup with internal consistency but invalid signatures
    let backup = create_malicious_backup(fake_ledger_info, malicious_state);
    
    // Restore WITHOUT epoch_history (vulnerability trigger)
    let controller = StateSnapshotRestoreController::new(
        opts,
        global_opts,
        storage,
        None, // epoch_history = None - VULNERABILITY
    );
    
    // This should FAIL but actually SUCCEEDS
    let result = controller.run().await;
    assert!(result.is_ok()); // VULNERABILITY: Succeeds despite invalid signatures!
    
    // Verify malicious state was written
    let validator_set = db.get_validator_set();
    assert_eq!(validator_set, malicious_validator_set); // CONFIRMED: Malicious state accepted
}
```

**Notes**

This vulnerability represents a **complete breakdown of state authenticity guarantees** in the restore pathway. The explicit comment in the code acknowledging that "LedgerInfos are NOT checked at all when doing one-shot restoring" suggests this may have been considered acceptable for operational convenience, but it creates a critical security hole.

The restore tool is meant for emergency recovery and operational scenarios, making this a realistic attack vector. Any compromise of backup storage or supply chain could lead to complete chain compromise through malicious state injection.

The fix is straightforward: always require and verify epoch history before accepting state snapshots, or at minimum enforce trusted waypoints for production use. The operational inconvenience of requiring epoch history first is far outweighed by the catastrophic security risk of accepting unverified state.

### Citations

**File:** storage/db-tool/src/restore.rs (L83-96)
```rust
                    Oneoff::StateSnapshot {
                        storage,
                        opt,
                        global,
                    } => {
                        StateSnapshotRestoreController::new(
                            opt,
                            global.try_into()?,
                            storage.init_storage().await?,
                            None, /* epoch_history */
                        )
                        .run()
                        .await?;
                    },
```

**File:** storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs (L127-136)
```rust
        txn_info_with_proof.verify(li.ledger_info(), manifest.version)?;
        let state_root_hash = txn_info_with_proof
            .transaction_info()
            .ensure_state_checkpoint_hash()?;
        ensure!(
            state_root_hash == manifest.root_hash,
            "Root hash mismatch with that in proof. root hash: {}, expected: {}",
            manifest.root_hash,
            state_root_hash,
        );
```

**File:** storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs (L137-139)
```rust
        if let Some(epoch_history) = self.epoch_history.as_ref() {
            epoch_history.verify_ledger_info(&li)?;
        }
```

**File:** storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs (L212-215)
```rust
            tokio::task::spawn_blocking(move || {
                receiver.lock().as_mut().unwrap().add_chunk(blobs, proof)
            })
            .await??;
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L276-312)
```rust
    pub fn verify_ledger_info(&self, li_with_sigs: &LedgerInfoWithSignatures) -> Result<()> {
        let epoch = li_with_sigs.ledger_info().epoch();
        ensure!(!self.epoch_endings.is_empty(), "Empty epoch history.",);
        if epoch > self.epoch_endings.len() as u64 {
            // TODO(aldenhu): fix this from upper level
            warn!(
                epoch = epoch,
                epoch_history_until = self.epoch_endings.len(),
                "Epoch is too new and can't be verified. Previous chunks are verified and node \
                won't be able to start if this data is malicious."
            );
            return Ok(());
        }
        if epoch == 0 {
            ensure!(
                li_with_sigs.ledger_info() == &self.epoch_endings[0],
                "Genesis epoch LedgerInfo info doesn't match.",
            );
        } else if let Some(wp_trusted) = self
            .trusted_waypoints
            .get(&li_with_sigs.ledger_info().version())
        {
            let wp_li = Waypoint::new_any(li_with_sigs.ledger_info());
            ensure!(
                *wp_trusted == wp_li,
                "Waypoints don't match. In backup: {}, trusted: {}",
                wp_li,
                wp_trusted,
            );
        } else {
            self.epoch_endings[epoch as usize - 1]
                .next_epoch_state()
                .ok_or_else(|| anyhow!("Shouldn't contain non- epoch bumping LIs."))?
                .verify(li_with_sigs)?;
        };
        Ok(())
    }
```

**File:** storage/backup/backup-cli/src/utils/mod.rs (L341-343)
```rust
        N.B. LedgerInfos are verified only when restoring / verifying the epoch ending backups, \
        i.e. they are NOT checked at all when doing one-shot restoring of the transaction \
        and state backups."
```

**File:** storage/aptosdb/src/state_restore/mod.rs (L228-258)
```rust
    fn add_chunk(&mut self, chunk: Vec<(K, V)>, proof: SparseMerkleRangeProof) -> Result<()> {
        let kv_fn = || {
            let _timer = OTHER_TIMERS_SECONDS.timer_with(&["state_value_add_chunk"]);
            self.kv_restore
                .lock()
                .as_mut()
                .unwrap()
                .add_chunk(chunk.clone())
        };

        let tree_fn = || {
            let _timer = OTHER_TIMERS_SECONDS.timer_with(&["jmt_add_chunk"]);
            self.tree_restore
                .lock()
                .as_mut()
                .unwrap()
                .add_chunk_impl(chunk.iter().map(|(k, v)| (k, v.hash())).collect(), proof)
        };
        match self.restore_mode {
            StateSnapshotRestoreMode::KvOnly => kv_fn()?,
            StateSnapshotRestoreMode::TreeOnly => tree_fn()?,
            StateSnapshotRestoreMode::Default => {
                // We run kv_fn with TreeOnly to restore the usage of DB
                let (r1, r2) = IO_POOL.join(kv_fn, tree_fn);
                r1?;
                r2?;
            },
        }

        Ok(())
    }
```

**File:** execution/executor/src/db_bootstrapper/mod.rs (L48-71)
```rust
pub fn maybe_bootstrap<V: VMBlockExecutor>(
    db: &DbReaderWriter,
    genesis_txn: &Transaction,
    waypoint: Waypoint,
) -> Result<Option<LedgerInfoWithSignatures>> {
    let ledger_summary = db.reader.get_pre_committed_ledger_summary()?;
    // if the waypoint is not targeted with the genesis txn, it may be either already bootstrapped, or
    // aiming for state sync to catch up.
    if ledger_summary.version().map_or(0, |v| v + 1) != waypoint.version() {
        info!(waypoint = %waypoint, "Skip genesis txn.");
        return Ok(None);
    }

    let committer = calculate_genesis::<V>(db, ledger_summary, genesis_txn)?;
    ensure!(
        waypoint == committer.waypoint(),
        "Waypoint verification failed. Expected {:?}, got {:?}.",
        waypoint,
        committer.waypoint(),
    );
    let ledger_info = committer.output.ledger_info_opt.clone();
    committer.commit()?;
    Ok(ledger_info)
}
```
