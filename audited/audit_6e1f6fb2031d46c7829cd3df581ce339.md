# Audit Report

## Title
Epoch 0 Bootstrap Failure Due to Off-by-One Error in Epoch Range Request Handling

## Summary
A critical off-by-one error in the epoch ending ledger info request handling prevents new nodes from bootstrapping from genesis (epoch 0). The stream engine creates requests with inclusive epoch ranges, but the database iterator interprets them as exclusive, causing epoch 0 requests to return empty results and fail bootstrap.

## Finding Description

The vulnerability stems from a semantic mismatch between how epoch ranges are specified in requests versus how they are interpreted by the storage layer.

When the `ContinuouslySyncingStreamEngine` detects an epoch change and needs to fetch epoch ending ledger info for epoch 0, it creates a request with both `start_epoch` and `end_epoch` set to 0, intending this to be an inclusive range requesting just epoch 0: [1](#0-0) 

However, the database iterator treats `end_epoch` as **exclusive**, implementing a range of `[start_epoch, end_epoch)`. When both values are 0, it checks if `next_epoch >= end_epoch` (i.e., `0 >= 0`), which is true, causing it to immediately return empty results without fetching any data: [2](#0-1) 

The stream engine's tracking logic confirms this is meant to be inclusive, as it updates the next request epoch to `end_epoch + 1`: [3](#0-2) 

When the bootstrapper receives an empty epoch ending ledger info list, it explicitly rejects it and throws an error: [4](#0-3) 

The genesis ledger info at epoch 0 is designed to end the epoch (transitioning to epoch 1), as verified during bootstrap: [5](#0-4) 

However, nodes attempting to fetch this critical genesis data receive empty results, causing bootstrap to fail.

## Impact Explanation

This is a **High Severity** vulnerability that affects network availability:

- **Liveness Failure**: New nodes cannot bootstrap from genesis and join the network
- **Network Growth**: The network cannot onboard new validators or fullnodes that start from genesis
- **Operational Impact**: Any node requiring a fresh genesis bootstrap (e.g., after storage corruption, new deployment) will fail indefinitely

While this doesn't directly cause consensus safety violations or fund loss, it represents a **significant protocol violation** and **validator node dysfunction** (nodes cannot start), qualifying as High Severity per the bug bounty criteria. The impact is particularly severe because it affects the most fundamental operation: genesis bootstrap.

## Likelihood Explanation

This bug has **HIGH** likelihood of occurrence:

- **Automatic Trigger**: Happens automatically whenever a new node attempts to bootstrap from genesis
- **No Attacker Required**: This is a logic bug that occurs during normal operations
- **Universal Impact**: Affects all node types (validators, fullnodes) attempting genesis bootstrap
- **Deterministic**: Will fail 100% of the time for epoch 0 requests with this request pattern

The bug may not have been discovered in production because:
1. Most nodes bootstrap from snapshots rather than genesis
2. Test environments may use different code paths or have workarounds
3. The issue specifically manifests with epoch 0 due to the `start_epoch == end_epoch` condition

## Recommendation

Fix the off-by-one error by making the `end_epoch` parameter inclusive at the request creation site. When requesting a single epoch's ending ledger info, set `end_epoch` to `start_epoch + 1` to create a range `[start_epoch, start_epoch+1)` that includes only the target epoch:

```rust
// In stream_engine.rs line 1204-1209
return Ok(vec![DataClientRequest::EpochEndingLedgerInfos(
    EpochEndingLedgerInfosRequest {
        start_epoch: next_request_epoch,
        end_epoch: next_request_epoch + 1,  // FIX: Make range exclusive-end compatible
    },
)]);
```

Similarly, update all other locations where `EpochEndingLedgerInfosRequest` is created to use exclusive-end semantics: [6](#0-5) 

Ensure that `end_index` is calculated as the inclusive end epoch plus 1.

## Proof of Concept

**Reproduction Steps:**

1. Start a fresh Aptos node with empty storage
2. Configure the node to bootstrap from genesis (epoch 0)
3. Start the node and observe bootstrap process
4. The node will attempt to fetch epoch ending ledger info for epoch 0
5. The request will have `start_epoch=0, end_epoch=0`
6. The database iterator returns empty results
7. The bootstrapper receives empty payload and errors with: "The epoch ending payload was empty!"
8. Bootstrap fails, node cannot sync

**Expected Behavior:**
- Node should successfully fetch the genesis epoch ending ledger info (epoch 0)
- Bootstrap should proceed to fetch subsequent data
- Node should successfully join the network

**Actual Behavior:**
- Empty epoch ending ledger info list is returned
- Bootstrap fails with verification error
- Node cannot progress and remains unsynced

The bug can be verified by tracing through the code paths identified in this report, particularly examining the iterator's exclusive-end behavior versus the request creation's implicit inclusive-end intention.

## Notes

This vulnerability demonstrates a classic API contract mismatch where different layers of the system interpret range boundaries differently (inclusive vs. exclusive). The issue is particularly insidious because it only manifests for epoch 0 where `start_epoch == end_epoch`, making it easy to miss in testing that focuses on later epochs. The fix requires careful coordination to ensure all request creators use the same exclusive-end convention that the iterator expects.

### Citations

**File:** state-sync/data-streaming-service/src/stream_engine.rs (L1204-1209)
```rust
                    return Ok(vec![DataClientRequest::EpochEndingLedgerInfos(
                        EpochEndingLedgerInfosRequest {
                            start_epoch: next_request_epoch,
                            end_epoch: next_request_epoch,
                        },
                    )]);
```

**File:** state-sync/data-streaming-service/src/stream_engine.rs (L1526-1530)
```rust
                EpochEndingLedgerInfos(request) => {
                    self.next_request_epoch =
                        request.end_epoch.checked_add(1).ok_or_else(|| {
                            Error::IntegerOverflow("Next request epoch has overflown!".into())
                        })?;
```

**File:** state-sync/data-streaming-service/src/stream_engine.rs (L2149-2152)
```rust
            EpochEndingLedgerInfos(EpochEndingLedgerInfosRequest {
                start_epoch: start_index,
                end_epoch: end_index,
            })
```

**File:** storage/aptosdb/src/utils/iterators.rs (L209-212)
```rust
    fn next_impl(&mut self) -> Result<Option<LedgerInfoWithSignatures>> {
        if self.next_epoch >= self.end_epoch {
            return Ok(None);
        }
```

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L1080-1090)
```rust
        // Verify the payload isn't empty
        if epoch_ending_ledger_infos.is_empty() {
            self.reset_active_stream(Some(NotificationAndFeedback::new(
                notification_id,
                NotificationFeedback::EmptyPayloadData,
            )))
            .await?;
            return Err(Error::VerificationError(
                "The epoch ending payload was empty!".into(),
            ));
        }
```

**File:** execution/executor/src/db_bootstrapper/mod.rs (L151-154)
```rust
    ensure!(
        execution_output.next_epoch_state.is_some(),
        "Genesis txn didn't output reconfig event."
    );
```
