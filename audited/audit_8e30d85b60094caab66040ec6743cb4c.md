# Audit Report

## Title
Network Isolation Bypass in Peer Monitoring Service Allows Public Peers to Query Validator Network Topology

## Summary
The Peer Monitoring Service improperly handles NetworkId authorization, allowing attackers connected through the Public network to query sensitive information about peers connected to Validator and VFN networks. This violates the network isolation security model and exposes validator network topology to untrusted public peers.

## Finding Description

The `event_to_request()` function correctly captures the originating `network_id` when transforming network events into requests: [1](#0-0) 

However, the request handler completely ignores this NetworkId when serving responses. The `Handler::call()` method receives the `network_id` parameter but only uses it for metrics tracking: [2](#0-1) 

The critical vulnerability occurs in `get_network_information()`, which returns **all connected peers across all networks** without filtering: [3](#0-2) 

The underlying `get_connected_peers_and_metadata()` method iterates through all networks indiscriminately: [4](#0-3) 

The response includes sensitive data for each peer across all networks: [5](#0-4) 

**Attack Path:**
1. Attacker connects to an Aptos node via the Public network (requires no special privileges)
2. Attacker sends `GetNetworkInformation` request to the Peer Monitoring Service
3. Server processes request, calling `get_connected_peers_and_metadata()` without network filtering
4. Server returns complete list of ALL connected peers including:
   - Peers on Validator network (NetworkId::Validator)
   - Peers on VFN network (NetworkId::Vfn)  
   - Peers on Public network (NetworkId::Public)
5. For each peer, attacker receives:
   - `PeerNetworkId` (containing NetworkId and PeerId)
   - `NetworkAddress` (IP address/connection details)
   - `PeerRole` (Validator, ValidatorFullNode, etc.)
   - Distance from validators

This breaks the **network isolation invariant** - Aptos uses separate NetworkIds to isolate validator communications from public peers: [6](#0-5) 

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos Bug Bounty program for the following reasons:

1. **Information Disclosure of Critical Infrastructure**: Exposes complete validator network topology including IP addresses, peer IDs, and connection metadata to untrusted public peers

2. **Enables Targeted Attacks**: Attackers can use this information to:
   - Map the validator network topology in real-time
   - Identify specific validator nodes and their network addresses
   - Monitor validator connectivity patterns
   - Plan coordinated attacks against specific validators
   - Conduct reconnaissance for DDoS or eclipse attacks

3. **Protocol Violation**: Breaks the fundamental network isolation security model that separates validator networks from public networks

4. **No Special Privileges Required**: Any peer that can connect to the Public network can exploit this vulnerability

While this does not directly cause loss of funds or consensus violations, it significantly weakens the security posture of the validator network by providing attackers with reconnaissance capabilities that should not be available to public peers.

## Likelihood Explanation

**Likelihood: HIGH**

- **Ease of Exploitation**: Trivial - requires only a standard network connection to the Public network and sending a single RPC request
- **Attacker Requirements**: None - no special permissions, stake, or insider access needed
- **Detection Difficulty**: Hard to detect - appears as legitimate peer monitoring traffic
- **Automatic Occurrence**: Happens on every `GetNetworkInformation` request from any network
- **Current Deployment**: Vulnerability exists in production code and is exploitable immediately

The existing test suite even demonstrates this behavior inadvertently: [7](#0-6) 

This test shows peers from different networks (Public and Validator) being returned together in the response.

## Recommendation

Filter the connected peers by the requesting peer's NetworkId before returning the response. Modify the `get_network_information()` handler to only return peers from the same network:

```rust
fn get_network_information(
    &self,
    network_id: NetworkId,  // Pass through from Handler::call()
) -> Result<PeerMonitoringServiceResponse, Error> {
    // Get all connected peers
    let all_connected_peers = self.peers_and_metadata.get_connected_peers_and_metadata()?;
    
    // Filter to only include peers from the same network as the requester
    let connected_peers = all_connected_peers
        .into_iter()
        .filter(|(peer_network_id, _)| peer_network_id.network_id() == network_id)
        .map(|(peer, metadata)| {
            let connection_metadata = metadata.get_connection_metadata();
            (
                peer,
                ConnectionMetadata::new(
                    connection_metadata.addr,
                    connection_metadata.remote_peer_id,
                    connection_metadata.role,
                ),
            )
        })
        .collect();

    // Calculate distance from validators (unchanged)
    let distance_from_validators =
        get_distance_from_validators(&self.base_config, self.peers_and_metadata.clone());

    let network_information_response = NetworkInformationResponse {
        connected_peers,
        distance_from_validators,
    };
    Ok(PeerMonitoringServiceResponse::NetworkInformation(
        network_information_response,
    ))
}
```

Update the method signature to accept `network_id`: [8](#0-7) 

## Proof of Concept

```rust
#[tokio::test]
async fn test_network_isolation_vulnerability() {
    use aptos_config::{config::BaseConfig, network_id::PeerNetworkId};
    use aptos_peer_monitoring_service_types::request::PeerMonitoringServiceRequest;
    
    // Setup: Create a node with peers on multiple networks
    let base_config = BaseConfig {
        role: RoleType::FullNode,
        ..Default::default()
    };
    let (mut mock_client, service, _, peers_and_metadata) =
        MockClient::new(Some(base_config), None, None);
    tokio::spawn(service.start());
    
    // Connect a validator peer on the Validator network
    let validator_peer_id = PeerId::random();
    let validator_network_id = PeerNetworkId::new(NetworkId::Validator, validator_peer_id);
    let validator_metadata = create_connection_metadata(validator_peer_id, PeerRole::Validator);
    peers_and_metadata
        .insert_connection_metadata(validator_network_id, validator_metadata.clone())
        .unwrap();
    
    // Connect a public peer on the Public network
    let public_peer_id = PeerId::random();
    let public_network_id = PeerNetworkId::new(NetworkId::Public, public_peer_id);
    let public_metadata = create_connection_metadata(public_peer_id, PeerRole::Unknown);
    peers_and_metadata
        .insert_connection_metadata(public_network_id, public_metadata.clone())
        .unwrap();
    
    // EXPLOIT: Send GetNetworkInformation request
    // (Note: mock_client.send_request() simulates a request from a random network,
    // which could be Public network based on get_random_network_id())
    let request = PeerMonitoringServiceRequest::GetNetworkInformation;
    let response = mock_client.send_request(request).await.unwrap();
    
    // VULNERABILITY DEMONSTRATED: Response contains peers from BOTH networks
    match response {
        PeerMonitoringServiceResponse::NetworkInformation(info) => {
            // The response should only contain peers from the requesting network
            // But it actually contains ALL peers regardless of NetworkId
            println!("Connected peers returned: {:?}", info.connected_peers.keys());
            
            // Verify both Validator and Public peers are returned
            let has_validator_peer = info.connected_peers.contains_key(&validator_network_id);
            let has_public_peer = info.connected_peers.contains_key(&public_network_id);
            
            // VULNERABILITY: Both should not be visible to a Public network requester
            assert!(has_validator_peer, "Validator peer leaked to public network query");
            assert!(has_public_peer, "Public peer visible");
            
            // This proves a Public peer can see Validator network topology
            if has_validator_peer {
                let leaked_validator_info = &info.connected_peers[&validator_network_id];
                println!("LEAKED VALIDATOR INFO:");
                println!("  Network Address: {:?}", leaked_validator_info.network_address);
                println!("  Peer ID: {:?}", leaked_validator_info.peer_id);
                println!("  Role: {:?}", leaked_validator_info.peer_role);
            }
        }
        _ => panic!("Unexpected response type"),
    }
}
```

**Notes:**
- This vulnerability exists in production code and is exploitable today
- The issue affects all Aptos nodes running the Peer Monitoring Service
- Network isolation is a fundamental security property that protects validator infrastructure
- The fix requires minimal code changes - adding a single filter operation
- All handler methods (`get_node_information`, `get_server_protocol_version`) should also be reviewed for similar authorization issues, though `get_network_information` is the most critical due to its exposure of peer topology

### Citations

**File:** peer-monitoring-service/server/src/network.rs (L62-84)
```rust
    fn event_to_request(
        network_id: NetworkId,
        event: Event<PeerMonitoringServiceMessage>,
    ) -> Option<NetworkRequest> {
        match event {
            Event::RpcRequest(
                peer_id,
                PeerMonitoringServiceMessage::Request(peer_monitoring_service_request),
                protocol_id,
                response_tx,
            ) => {
                let response_sender = ResponseSender::new(response_tx);
                let peer_network_id = PeerNetworkId::new(network_id, peer_id);
                Some(NetworkRequest {
                    peer_network_id,
                    protocol_id,
                    peer_monitoring_service_request,
                    response_sender,
                })
            },
            _ => None, // We don't use direct send and don't care about connection events
        }
    }
```

**File:** peer-monitoring-service/server/src/lib.rs (L155-183)
```rust
    pub fn call(
        &self,
        network_id: NetworkId,
        request: PeerMonitoringServiceRequest,
    ) -> Result<PeerMonitoringServiceResponse> {
        // Update the request count
        increment_counter(
            &metrics::PEER_MONITORING_REQUESTS_RECEIVED,
            network_id,
            request.get_label(),
        );

        // Time the request processing (the timer will stop when it's dropped)
        let _timer = start_timer(
            &metrics::PEER_MONITORING_REQUEST_PROCESSING_LATENCY,
            network_id,
            request.get_label(),
        );

        // Process the request
        let response = match &request {
            PeerMonitoringServiceRequest::GetNetworkInformation => self.get_network_information(),
            PeerMonitoringServiceRequest::GetServerProtocolVersion => {
                self.get_server_protocol_version()
            },
            PeerMonitoringServiceRequest::GetNodeInformation => self.get_node_information(),
            PeerMonitoringServiceRequest::LatencyPing(request) => self.handle_latency_ping(request),
        };

```

**File:** peer-monitoring-service/server/src/lib.rs (L217-248)
```rust
    fn get_network_information(&self) -> Result<PeerMonitoringServiceResponse, Error> {
        // Get the connected peers
        let connected_peers_and_metadata =
            self.peers_and_metadata.get_connected_peers_and_metadata()?;
        let connected_peers = connected_peers_and_metadata
            .into_iter()
            .map(|(peer, metadata)| {
                let connection_metadata = metadata.get_connection_metadata();
                (
                    peer,
                    ConnectionMetadata::new(
                        connection_metadata.addr,
                        connection_metadata.remote_peer_id,
                        connection_metadata.role,
                    ),
                )
            })
            .collect();

        // Get the distance from the validators
        let distance_from_validators =
            get_distance_from_validators(&self.base_config, self.peers_and_metadata.clone());

        // Create and return the response
        let network_information_response = NetworkInformationResponse {
            connected_peers,
            distance_from_validators,
        };
        Ok(PeerMonitoringServiceResponse::NetworkInformation(
            network_information_response,
        ))
    }
```

**File:** network/framework/src/application/storage.rs (L108-125)
```rust
    pub fn get_connected_peers_and_metadata(
        &self,
    ) -> Result<HashMap<PeerNetworkId, PeerMetadata>, Error> {
        // Get the cached peers and metadata
        let cached_peers_and_metadata = self.cached_peers_and_metadata.load();

        // Collect all connected peers
        let mut connected_peers_and_metadata = HashMap::new();
        for (network_id, peers_and_metadata) in cached_peers_and_metadata.iter() {
            for (peer_id, peer_metadata) in peers_and_metadata.iter() {
                if peer_metadata.is_connected() {
                    let peer_network_id = PeerNetworkId::new(*network_id, *peer_id);
                    connected_peers_and_metadata.insert(peer_network_id, peer_metadata.clone());
                }
            }
        }
        Ok(connected_peers_and_metadata)
    }
```

**File:** peer-monitoring-service/types/src/response.rs (L50-85)
```rust
/// A response for the network information request
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
pub struct NetworkInformationResponse {
    pub connected_peers: BTreeMap<PeerNetworkId, ConnectionMetadata>, // Connected peers
    pub distance_from_validators: u64, // The distance of the peer from the validator set
}

// Display formatting provides a high-level summary of the response
impl Display for NetworkInformationResponse {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "{{ num_connected_peers: {:?}, distance_from_validators: {:?} }}",
            self.connected_peers.len(),
            self.distance_from_validators,
        )
    }
}

/// Simple connection metadata associated with each peer
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
pub struct ConnectionMetadata {
    pub network_address: NetworkAddress,
    pub peer_id: PeerId,
    pub peer_role: PeerRole,
}

impl ConnectionMetadata {
    pub fn new(network_address: NetworkAddress, peer_id: PeerId, peer_role: PeerRole) -> Self {
        Self {
            network_address,
            peer_id,
            peer_role,
        }
    }
}
```

**File:** config/src/network_id.rs (L72-83)
```rust
/// A representation of the network being used in communication.
/// There should only be one of each NetworkId used for a single node (except for NetworkId::Public),
/// and handshakes should verify that the NetworkId being used is the same during a handshake,
/// to effectively ensure communication is restricted to a network.  Network should be checked that
/// it is not the `DEFAULT_NETWORK`
#[derive(Clone, Copy, Eq, Hash, PartialEq, PartialOrd, Ord, EnumIter)]
#[repr(u8)]
pub enum NetworkId {
    Validator = 0,
    Vfn = 3,
    Public = 4,
}
```

**File:** peer-monitoring-service/server/src/tests.rs (L175-200)
```rust
    // Connect another peer to the fullnode
    let peer_id_2 = PeerId::random();
    let peer_network_id_2 = PeerNetworkId::new(NetworkId::Validator, peer_id_2);
    let peer_distance_2 = 0; // The peer is a validator
    let connection_metadata_2 = create_connection_metadata(peer_id_2, PeerRole::Validator);
    let expected_peers = btreemap! {peer_network_id_1 => connection_metadata_1.clone(), peer_network_id_2 => connection_metadata_2.clone()};
    let latest_network_info_response = NetworkInformationResponse {
        connected_peers: transform_connection_metadata(expected_peers),
        distance_from_validators: peer_distance_2,
    };
    let peer_monitoring_metadata_2 =
        PeerMonitoringMetadata::new(None, None, Some(latest_network_info_response), None, None);
    peers_and_metadata
        .insert_connection_metadata(peer_network_id_2, connection_metadata_2.clone())
        .unwrap();
    peers_and_metadata
        .update_peer_monitoring_metadata(peer_network_id_2, peer_monitoring_metadata_2.clone())
        .unwrap();

    // Process a client request to fetch the network information and verify the response
    verify_network_information(
        &mut mock_client,
        btreemap! {peer_network_id_1 => connection_metadata_1.clone(), peer_network_id_2 => connection_metadata_2},
        peer_distance_2 + 1,
    )
    .await;
```
