# Audit Report

## Title
Fullnode Ledger Lag Enables Client Decisions Based on Stale Blockchain State

## Summary
The Aptos REST API can return stale blockchain data to clients when querying fullnodes that lag behind the current chain state. The SDK's convenience methods discard timestamp metadata, preventing clients from detecting this staleness, which can lead to incorrect business logic decisions and financial losses.

## Finding Description

When clients query the Aptos REST API without specifying a `ledger_version` parameter, they receive data from whatever version is currently synced on the fullnode they're connected to. The codebase explicitly acknowledges that fullnodes lag behind the authoritative blockchain state: [1](#0-0) 

This lag is inherent to distributed systems and state synchronization. However, the issue becomes a vulnerability when:

1. **The API returns data without freshness validation**: When a client calls `get_account`, `get_account_balance`, or similar endpoints without a `ledger_version`, the API simply returns the latest synced version: [2](#0-1) 

2. **The SDK discards staleness metadata**: The high-level SDK methods like `get_account_balance()` return only the data value, discarding the `State` metadata that contains `timestamp_usecs`: [3](#0-2) 

3. **No staleness detection utilities exist**: The REST client library provides no functions to help developers detect stale responses (grep search confirmed no staleness checking utilities in the client library).

**Attack Scenario**:
1. Attacker identifies or operates a public fullnode that is lagging (due to network issues, high load, or intentional throttling)
2. Victim client queries this node for account balance: `coin_client.get_account_balance(address).await`
3. Client receives balance from 60+ seconds ago (but has no way to know it's stale)
4. Client makes a business decision: "I have sufficient funds to process payment X"
5. Client constructs and submits a transaction based on this stale view
6. The transaction fails due to insufficient funds in the actual current state, causing loss of gas fees and poor UX, OR worse, succeeds with unintended consequences if the stale state showed different balances

The system has lag detection in internal components for state sync operations: [4](#0-3) 

But this protection only applies to `wait_for_transaction` operations, not regular read queries.

## Impact Explanation

This qualifies as **Medium Severity** per the Aptos bug bounty criteria:
- **"Limited funds loss or manipulation"**: Clients making decisions on stale data can experience financial losses through failed transactions (gas fees), incorrect pricing decisions, or executing trades based on outdated market state
- **"State inconsistencies requiring intervention"**: While the blockchain state itself remains consistent, clients can enter inconsistent states requiring manual intervention when their view diverges from reality

The impact is client-side rather than protocol-level, which limits severity. Validators and consensus remain unaffected.

## Likelihood Explanation

**Likelihood: Medium-High**

This occurs naturally during:
- Network congestion or partitions
- Fullnode catching up after downtime  
- High transaction throughput periods
- Geographic distance from validator set

The recommended `max_server_lag_wait` of 60 seconds confirms this is a known and expected condition: [5](#0-4) 

Attackers can increase likelihood by:
- Operating public fullnodes that are intentionally throttled
- Advertising these nodes as faster/more reliable to attract users
- Timing attacks around known high-load periods

## Recommendation

**Solution 1: Add Staleness Detection to SDK**

Add a method to check response freshness:

```rust
impl State {
    pub fn is_stale(&self, max_age_secs: u64) -> bool {
        let current_time = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap()
            .as_micros() as u64;
        let age_usecs = current_time.saturating_sub(self.timestamp_usecs);
        age_usecs > (max_age_secs * 1_000_000)
    }
}
```

Update SDK methods to expose staleness information:

```rust
pub async fn get_account_balance(&self, account: &AccountAddress) -> Result<(u64, State)> {
    let response = self
        .api_client
        .view_apt_account_balance(*account)
        .await
        .context("Failed to get account balance")?;
    let (balance, state) = response.into_parts();
    Ok((balance, state))
}
```

**Solution 2: Add Staleness Warnings**

Add optional staleness checking with configurable thresholds:

```rust
pub struct ClientConfig {
    max_acceptable_lag_secs: Option<u64>,
    warn_on_stale_data: bool,
}

// Check and warn on every response
if let Some(max_lag) = config.max_acceptable_lag_secs {
    if state.is_stale(max_lag) {
        if config.warn_on_stale_data {
            warn!("Received stale data: {}s behind current time", ...);
        }
        return Err(Error::StaleData);
    }
}
```

**Solution 3: Documentation**

Add prominent warnings in SDK documentation about fullnode lag and best practices for freshness checking.

## Proof of Concept

```rust
use aptos_sdk::{
    coin_client::CoinClient,
    rest_client::Client,
    types::account_address::AccountAddress,
};
use std::{str::FromStr, time::{SystemTime, UNIX_EPOCH}};

#[tokio::main]
async fn main() {
    // Connect to a potentially lagging fullnode
    let client = Client::new("https://fullnode.example.com".parse().unwrap());
    let coin_client = CoinClient::new(&client);
    
    let account = AccountAddress::from_str("0x1").unwrap();
    
    // Vulnerable: Gets balance without checking freshness
    let balance = coin_client.get_account_balance(&account).await.unwrap();
    println!("Balance: {}", balance); // Could be from 60+ seconds ago!
    
    // The State metadata that could detect staleness is discarded
    
    // Correct approach (requires using lower-level API):
    let response = client.view_apt_account_balance(account).await.unwrap();
    let balance = response.inner();
    let state = response.state();
    
    // Check freshness manually
    let current_time = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap()
        .as_micros() as u64;
    let age_usecs = current_time.saturating_sub(state.timestamp_usecs);
    let age_secs = age_usecs / 1_000_000;
    
    if age_secs > 10 {
        eprintln!("WARNING: Data is {} seconds old!", age_secs);
        // Should retry or abort operation
    } else {
        println!("Fresh balance: {}", balance);
    }
}
```

This demonstrates how the high-level SDK method loses freshness information that developers need to make safe decisions.

## Notes

The vulnerability arises from the interaction between expected fullnode lag and SDK design choices. While the underlying API provides all necessary metadata for staleness detection via the `State` structure containing `timestamp_usecs`, the SDK's convenience methods prioritize ease of use over safety by discarding this metadata. This creates a gap where well-intentioned developers using the recommended SDK patterns are unknowingly exposed to stale data risks.

### Citations

**File:** crates/aptos-rest-client/src/lib.rs (L742-747)
```rust
    /// * `max_server_lag_wait`:
    ///     Fullnodes generally lag some amount behind the authoritative blockchain ledger state.
    ///     This field gives the node some time to update its ledger state to the point
    ///     where your transaction might have expired.
    ///     We recommend setting this value to at least 60 seconds.
    /// * `timeout_from_call`:
```

**File:** crates/aptos-rest-client/src/lib.rs (L824-834)
```rust
            if let Some(max_server_lag_wait_duration) = max_server_lag_wait {
                if aptos_infallible::duration_since_epoch().as_secs()
                    > expiration_timestamp_secs + max_server_lag_wait_duration.as_secs()
                {
                    return Err(anyhow!(
                        "Ledger on endpoint ({}) is more than {}s behind current time, timing out waiting for the transaction. Warning, transaction ({}) might still succeed.",
                        self.path_prefix_string(),
                        max_server_lag_wait_duration.as_secs(),
                        hash,
                    ).into());
                }
```

**File:** api/src/context.rs (L294-317)
```rust
    pub fn get_latest_ledger_info_and_verify_lookup_version<E: StdApiError>(
        &self,
        requested_ledger_version: Option<Version>,
    ) -> Result<(LedgerInfo, Version), E> {
        let latest_ledger_info = self.get_latest_ledger_info()?;

        let requested_ledger_version =
            requested_ledger_version.unwrap_or_else(|| latest_ledger_info.version());

        // This is too far in the future, a retriable case
        if requested_ledger_version > latest_ledger_info.version() {
            return Err(version_not_found(
                requested_ledger_version,
                &latest_ledger_info,
            ));
        } else if requested_ledger_version < latest_ledger_info.oldest_ledger_version.0 {
            return Err(version_pruned(
                requested_ledger_version,
                &latest_ledger_info,
            ));
        }

        Ok((latest_ledger_info, requested_ledger_version))
    }
```

**File:** sdk/src/coin_client.rs (L100-107)
```rust
    pub async fn get_account_balance(&self, account: &AccountAddress) -> Result<u64> {
        let response = self
            .api_client
            .view_apt_account_balance(*account)
            .await
            .context("Failed to get account balance")?;
        Ok(response.into_inner())
    }
```
