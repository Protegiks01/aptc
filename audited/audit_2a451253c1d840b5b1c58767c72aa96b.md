# Audit Report

## Title
Invariant Violation via Deserialization Bypass in AnalyzedTransaction Leading to Node Crash

## Summary
The `AnalyzedTransaction` struct maintains a critical invariant that `predictable_transaction=true` implies all storage locations are `Specific` variants. This invariant is enforced in the constructor but can be bypassed through serde deserialization, potentially causing validator node crashes when the remote executor service processes maliciously crafted messages.

## Finding Description

The `AnalyzedTransaction` struct enforces an invariant during construction where `predictable_transaction` is set to `!hints_contain_wildcard`, ensuring that if `predictable_transaction` is `true`, all entries in `read_hints` and `write_hints` must be `StorageLocation::Specific` variants. [1](#0-0) 

However, the struct derives `Serialize` and `Deserialize`, which bypasses the constructor's invariant enforcement: [2](#0-1) 

**Attack Path:**

An attacker crafts a malicious serialized `AnalyzedTransaction` with `predictable_transaction=true` but containing `WildCardStruct` or `WildCardTable` variants in the hints. This message is sent to the remote executor service, which deserializes it without validation: [3](#0-2) 

**First Panic Point:** The deserialized transaction is processed by `extract_state_keys()`, which calls `.state_key()` on all storage locations: [4](#0-3) 

The `.state_key()` method panics on wildcard variants: [5](#0-4) 

**Second Panic Point:** If the PTX executor were used (experimental), `expect_p_txn()` would be called: [6](#0-5) 

The assertion passes because `predictable_transaction` is `true`, but then `expect_specific_locations()` hits the unreachable: [7](#0-6) 

The remote executor service uses an unauthenticated gRPC interface: [8](#0-7) 

## Impact Explanation

**Severity: HIGH (Validator Node Crashes)**

This vulnerability causes immediate node panic and crash, affecting validator availability. The impact aligns with the **"API Crashes (High)"** category in the Aptos bug bounty program, which covers crashes affecting network participation.

If a validator deploys the remote executor service with network exposure, an attacker can crash the validator node by sending a single malicious message, causing:
- Immediate validator unavailability
- Potential consensus delays if multiple validators are affected
- Service disruption requiring manual intervention

However, this does NOT cause:
- Consensus violations or chain splits
- Fund theft or unauthorized transfers
- Permanent network damage

## Likelihood Explanation

**Likelihood: LOW to MEDIUM**

The vulnerability exists in production code, but exploitability depends on deployment configuration:

1. **Remote Executor is Optional:** The remote executor service is conditional and not enabled by default: [9](#0-8) 

2. **Network Exposure Required:** The service must be network-accessible to external attackers. The design suggests it's intended for internal shard-to-shard communication within validator infrastructure.

3. **No Authentication:** The gRPC service has no authentication mechanism, making it vulnerable if exposed.

4. **PTX Executor Not in Production:** The second panic path through PTX executor is in experimental code only: [10](#0-9) 

The vulnerability becomes immediately exploitable if validators deploy the remote executor service with external network access.

## Recommendation

**Short-term Fix:**
Add custom serialization logic that validates the invariant during deserialization:

```rust
impl<'de> Deserialize<'de> for AnalyzedTransaction {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        // Deserialize to a temporary struct
        // Then validate the invariant matches constructor logic
        // Return error if predictable_transaction=true but wildcards exist
    }
}
```

**Long-term Recommendations:**
1. Add authentication/authorization to the remote executor gRPC service
2. Implement network access controls limiting service to trusted internal addresses
3. Add runtime validation before calling `.state_key()` or `expect_p_txn()`
4. Consider using a validated builder pattern instead of direct deserialization

## Proof of Concept

```rust
#[test]
fn test_invariant_violation_via_deserialization() {
    use aptos_types::transaction::analyzed_transaction::{AnalyzedTransaction, StorageLocation};
    use move_core_types::language_storage::StructTag;
    
    // Create a malicious AnalyzedTransaction that violates the invariant
    // by manually constructing the struct through deserialization
    let malicious_data = /* BCS-encoded AnalyzedTransaction with:
        - predictable_transaction = true
        - read_hints containing WildCardStruct variant
    */;
    
    let malicious_txn: AnalyzedTransaction = bcs::from_bytes(&malicious_data).unwrap();
    
    assert!(malicious_txn.predictable_transaction()); // Passes
    
    // This will panic because wildcards exist despite predictable=true
    let _ = malicious_txn.read_hints()[0].state_key(); // PANIC
}
```

## Notes

- This is a **logic vulnerability** (invariant violation through deserialization bypass) that exists in production code
- The remote executor service is production-ready infrastructure with deployment tooling and metrics, though optional
- Exploitability is conditional on network deployment configuration
- The vulnerability is reachable through the remote executor service path but not through normal transaction processing
- PTX executor path is experimental only and not a production concern

### Citations

**File:** types/src/transaction/analyzed_transaction.rs (L23-37)
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct AnalyzedTransaction {
    transaction: SignatureVerifiedTransaction,
    /// Set of storage locations that are read by the transaction - this doesn't include location
    /// that are written by the transactions to avoid duplication of locations across read and write sets
    /// This can be accurate or strictly overestimated.
    pub read_hints: Vec<StorageLocation>,
    /// Set of storage locations that are written by the transaction. This can be accurate or strictly
    /// overestimated.
    pub write_hints: Vec<StorageLocation>,
    /// A transaction is predictable if neither the read_hint or the write_hint have wildcards.
    predictable_transaction: bool,
    /// The hash of the transaction - this is cached for performance reasons.
    hash: HashValue,
}
```

**File:** types/src/transaction/analyzed_transaction.rs (L59-64)
```rust
    pub fn state_key(&self) -> &StateKey {
        match self {
            StorageLocation::Specific(state_key) => state_key,
            _ => panic!("Cannot convert wildcard storage location to state key"),
        }
    }
```

**File:** types/src/transaction/analyzed_transaction.rs (L68-82)
```rust
    pub fn new(transaction: SignatureVerifiedTransaction) -> Self {
        let (read_hints, write_hints) = transaction.get_read_write_hints();
        let hints_contain_wildcard = read_hints
            .iter()
            .chain(write_hints.iter())
            .any(|hint| !matches!(hint, StorageLocation::Specific(_)));
        let hash = transaction.hash();
        AnalyzedTransaction {
            transaction,
            read_hints,
            write_hints,
            predictable_transaction: !hints_contain_wildcard,
            hash,
        }
    }
```

**File:** types/src/transaction/analyzed_transaction.rs (L108-115)
```rust
    pub fn expect_p_txn(self) -> (SignatureVerifiedTransaction, Vec<StateKey>, Vec<StateKey>) {
        assert!(self.predictable_transaction());
        (
            self.transaction,
            Self::expect_specific_locations(self.read_hints),
            Self::expect_specific_locations(self.write_hints),
        )
    }
```

**File:** types/src/transaction/analyzed_transaction.rs (L117-125)
```rust
    fn expect_specific_locations(locations: Vec<StorageLocation>) -> Vec<StateKey> {
        locations
            .into_iter()
            .map(|loc| match loc {
                StorageLocation::Specific(key) => key,
                _ => unreachable!(),
            })
            .collect()
    }
```

**File:** execution/executor-service/src/remote_cordinator_client.rs (L62-68)
```rust
                        for storage_location in txn
                            .txn()
                            .read_hints()
                            .iter()
                            .chain(txn.txn().write_hints().iter())
                        {
                            state_keys.push(storage_location.state_key().clone());
```

**File:** execution/executor-service/src/remote_cordinator_client.rs (L89-89)
```rust
                let request: RemoteExecutionRequest = bcs::from_bytes(&message.data).unwrap();
```

**File:** secure/net/src/grpc_network_service/mod.rs (L75-86)
```rust
        Server::builder()
            .timeout(std::time::Duration::from_millis(rpc_timeout_ms))
            .add_service(
                NetworkMessageServiceServer::new(self).max_decoding_message_size(MAX_MESSAGE_SIZE),
            )
            .add_service(reflection_service)
            .serve_with_shutdown(server_addr, async {
                server_shutdown_rx.await.ok();
                info!("Received signal to shutdown server at {:?}", server_addr);
            })
            .await
            .unwrap();
```

**File:** execution/executor/src/workflow/do_get_execution_output.rs (L261-267)
```rust
        if !get_remote_addresses().is_empty() {
            Ok(V::execute_block_sharded(
                &REMOTE_SHARDED_BLOCK_EXECUTOR.lock(),
                partitioned_txns,
                state_view,
                onchain_config,
            )?)
```

**File:** experimental/execution/ptx-executor/src/sorter.rs (L98-98)
```rust
        let (txn, reads, read_writes) = txn.expect_p_txn();
```
