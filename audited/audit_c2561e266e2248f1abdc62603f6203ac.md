# Audit Report

## Title
Atomicity Violation in Randomness Generation Storage: Persistent Crash Loop via Failed Augmentation

## Summary
The `add_certified_aug_data` function lacks atomicity between persisting certified augmented data to storage and completing the augmentation operation. If the augmentation step fails after persistence, the node enters a permanent crash loop on restart.

## Finding Description

In the randomness generation subsystem, certified augmented data undergoes a multi-step process: [1](#0-0) 

The vulnerability occurs in this sequence:
1. **Step 1 (Line 124)**: Certified augmented data is persisted to storage via `save_certified_aug_data`
2. **Step 2 (Lines 125-127)**: The `augment()` method is called, which internally uses `.expect()` 
3. **Step 3 (Lines 128-129)**: In-memory state is updated

The `augment()` implementation uses `.expect()` which panics on failure: [2](#0-1) 

If `add_certified_delta()` fails (which calls `derive_apk()` internally), the `.expect()` causes a panic. The failure can occur when `augment_pubkey` rejects invalid randomized public keys: [3](#0-2) 

**Critical Issue**: If augmentation fails after persistence (line 124), the certified_aug_data remains in storage but the node crashes. On restart, the node attempts to load and re-augment all stored certified data: [4](#0-3) 

This creates a permanent crash loop - the node cannot start because it repeatedly attempts to augment the same invalid data.

## Impact Explanation

**Severity: High** (Validator node unavailability)

This violates the **State Consistency** invariant which requires atomic state transitions. Once triggered, it causes:

- **Permanent node crash**: Affected validator cannot restart without manual database intervention
- **Consensus degradation**: If multiple validators are affected, consensus performance degrades
- **Recovery complexity**: Requires manual database editing to remove corrupted certified_aug_data

While not a Critical severity issue (doesn't cause network-wide failure), it qualifies as High severity per the bug bounty criteria as it causes validator node unavailability and requires manual intervention to recover.

## Likelihood Explanation

**Likelihood: Low-Medium**

The vulnerability can be triggered if:
1. Network message containing CertifiedAugData with cryptographically valid signatures but mathematically invalid delta values (wrong length or failed pairing check)
2. State corruption causing pk_shares length mismatch between verification and augmentation
3. Configuration race condition during epoch transitions
4. Byzantine validator creates malformed delta that passes initial checks but fails deeper cryptographic validation

While validators should verify deltas before signing, the fact that `CertifiedAugData` verification only checks signatures (not delta validity) creates a gap: [5](#0-4) 

## Recommendation

**Solution**: Make the operation atomic by validating before persisting, or handle augmentation failures gracefully.

**Option 1 - Validate Before Persist**:
```rust
pub fn add_certified_aug_data(
    &mut self,
    certified_data: CertifiedAugData<D>,
) -> anyhow::Result<CertifiedAugDataAck> {
    if self.certified_data.contains_key(certified_data.author()) {
        return Ok(CertifiedAugDataAck::new(self.epoch));
    }
    
    // VALIDATE FIRST - attempt augmentation without side effects
    let temp_result = self.config.derive_apk(
        certified_data.author(), 
        certified_data.data().delta.clone()
    );
    if let Err(e) = temp_result {
        return Err(anyhow::anyhow!("Invalid delta in certified_aug_data: {}", e));
    }
    
    // Only persist after validation succeeds
    self.db.save_certified_aug_data(&certified_data)?;
    
    // Now augment (should not fail since we validated)
    certified_data
        .data()
        .augment(&self.config, &self.fast_config, certified_data.author());
    
    self.certified_data
        .insert(*certified_data.author(), certified_data);
    Ok(CertifiedAugDataAck::new(self.epoch))
}
```

**Option 2 - Graceful Error Handling**:
Change `augment()` to return `Result` instead of using `.expect()`, and handle failures properly in both `add_certified_aug_data` and the recovery path in `new()`.

## Proof of Concept

The vulnerability can be demonstrated by corrupting storage to contain certified_aug_data with invalid deltas:

```rust
#[test]
fn test_crash_loop_on_invalid_certified_aug_data() {
    // Setup: Create AugDataStore with valid data
    let db = Arc::new(InMemRandDb::new());
    let config = /* valid RandConfig */;
    
    // Manually inject invalid certified_aug_data into storage
    let invalid_delta = RandomizedPKs {
        pi: G1Projective::generator(),
        rks: vec![], // WRONG LENGTH - will fail augmentation
    };
    let invalid_aug_data = AugData::new(epoch, author, AugmentedData {
        delta: invalid_delta,
        fast_delta: None,
    });
    let certified_invalid = CertifiedAugData::new(
        invalid_aug_data,
        /* valid signatures */
    );
    
    // Save directly to storage, bypassing add_certified_aug_data
    db.save_certified_aug_data(&certified_invalid).unwrap();
    
    // Attempt to create AugDataStore - this will panic at line 70
    // demonstrating the crash loop
    let _store = AugDataStore::new(epoch, signer, config, None, db);
    // Node cannot start - permanent crash
}
```

**Notes**:
- The in-memory storage implementation has no transactional guarantees across separate write operations
- The persistent database implementation commits each operation separately, providing no atomicity across `save_aug_data` and `save_certified_aug_data`
- Recovery requires manual database manipulation to remove corrupted entries
- The vulnerability exists in both storage backends (in-memory and persistent)

### Citations

**File:** consensus/src/rand/rand_gen/aug_data_store.rs (L57-71)
```rust
        let all_certified_data = db.get_all_certified_aug_data().unwrap_or_default();
        let (to_remove, certified_data) =
            Self::filter_by_epoch(epoch, all_certified_data.into_iter());
        if let Err(e) = db.remove_certified_aug_data(to_remove) {
            error!(
                "[AugDataStore] failed to remove certified aug data: {:?}",
                e
            );
        }

        for (_, certified_data) in &certified_data {
            certified_data
                .data()
                .augment(&config, &fast_config, certified_data.author());
        }
```

**File:** consensus/src/rand/rand_gen/aug_data_store.rs (L117-131)
```rust
    pub fn add_certified_aug_data(
        &mut self,
        certified_data: CertifiedAugData<D>,
    ) -> anyhow::Result<CertifiedAugDataAck> {
        if self.certified_data.contains_key(certified_data.author()) {
            return Ok(CertifiedAugDataAck::new(self.epoch));
        }
        self.db.save_certified_aug_data(&certified_data)?;
        certified_data
            .data()
            .augment(&self.config, &self.fast_config, certified_data.author());
        self.certified_data
            .insert(*certified_data.author(), certified_data);
        Ok(CertifiedAugDataAck::new(self.epoch))
    }
```

**File:** consensus/src/rand/rand_gen/types.rs (L178-194)
```rust
    fn augment(
        &self,
        rand_config: &RandConfig,
        fast_rand_config: &Option<RandConfig>,
        author: &Author,
    ) {
        let AugmentedData { delta, fast_delta } = self;
        rand_config
            .add_certified_delta(author, delta.clone())
            .expect("Add delta should succeed");

        if let (Some(config), Some(fast_delta)) = (fast_rand_config, fast_delta) {
            config
                .add_certified_delta(author, fast_delta.clone())
                .expect("Add delta for fast path should succeed");
        }
    }
```

**File:** consensus/src/rand/rand_gen/types.rs (L555-558)
```rust
    pub fn verify(&self, verifier: &ValidatorVerifier) -> anyhow::Result<()> {
        verifier.verify_multi_signatures(&self.aug_data, &self.signatures)?;
        Ok(())
    }
```

**File:** crates/aptos-dkg/src/weighted_vuf/pinkas/mod.rs (L108-143)
```rust
    fn augment_pubkey(
        pp: &Self::PublicParameters,
        pk: Self::PubKeyShare,
        // lpk: &Self::BlsPubKey,
        delta: Self::Delta,
    ) -> anyhow::Result<Self::AugmentedPubKeyShare> {
        if delta.rks.len() != pk.len() {
            bail!(
                "Expected PKs and RKs to be of the same length. Got {} and {}, respectively.",
                delta.rks.len(),
                pk.len()
            );
        }

        // TODO: Fiat-Shamir transform instead of RNG
        let tau = random_scalar(&mut thread_rng());

        let pks = pk
            .iter()
            .map(|pk| *pk.as_group_element())
            .collect::<Vec<G2Projective>>();
        let taus = get_powers_of_tau(&tau, pks.len());

        let pks_combined = g2_multi_exp(&pks[..], &taus[..]);
        let rks_combined = g1_multi_exp(&delta.rks[..], &taus[..]);

        if multi_pairing(
            [&delta.pi, &rks_combined].into_iter(),
            [&pks_combined, &pp.g_hat.neg()].into_iter(),
        ) != Gt::identity()
        {
            bail!("RPKs were not correctly randomized.");
        }

        Ok((delta, pk))
    }
```
