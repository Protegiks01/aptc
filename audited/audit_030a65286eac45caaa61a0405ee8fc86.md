# Audit Report

## Title
Bypass of CHARGE_INVARIANT_VIOLATION Feature Flag for Prologue Validation Errors

## Summary
The `unwrap_or_discard!` macro in the AptosVM transaction execution path bypasses the `CHARGE_INVARIANT_VIOLATION` feature flag, causing invariant violations during prologue validation to be discarded without gas charges, regardless of whether the flag is enabled. This creates an inconsistency in how invariant violations are handled across different transaction execution phases.

## Finding Description

The Aptos codebase implements a `CHARGE_INVARIANT_VIOLATION` feature flag (value 20) to prevent attackers from exploiting invariant violations for free VM security auditing. [1](#0-0)  When enabled, invariant violations should result in kept transactions with gas charges rather than discarded transactions.

The intended behavior is implemented in `TransactionStatus::from_vm_status()`, which checks if the status type is `InvariantViolation` and the feature flag is enabled: [2](#0-1) 

However, during transaction execution, the `unwrap_or_discard!` macro is used to handle errors from prologue validation: [3](#0-2) 

This macro directly calls `discarded_output()` when errors occur: [4](#0-3) 

The `discarded_output()` function creates a `TransactionStatus::Discard` without going through `from_vm_status()`: [5](#0-4) 

When unexpected errors occur during prologue execution, they are converted to `UNEXPECTED_ERROR_FROM_KNOWN_MOVE_FUNCTION` via `convert_prologue_error()`: [6](#0-5) [7](#0-6) 

This status code (2015) falls within the invariant violation range [2000, 2999]: [8](#0-7) [9](#0-8) 

The prologue validation invokes `convert_prologue_error()` to handle errors: [10](#0-9) 

**Critical Gap**: While invariant violations during transaction execution and epilogue are subject to the `CHARGE_INVARIANT_VIOLATION` feature flag check via `failed_transaction_cleanup()` [11](#0-10) , invariant violations during prologue validation bypass this check entirely due to the `unwrap_or_discard!` macro.

The existing test for this feature only validates execution-phase invariant violations, not prologue-phase ones: [12](#0-11) 

## Impact Explanation

This vulnerability has **Medium** severity per Aptos bug bounty categories, qualifying as a "Limited Protocol Violation" that undermines a deliberate security mitigation.

The practical impact is limited because:
1. An attacker cannot arbitrarily trigger invariant violations - these only occur when there are actual bugs in the framework or VM
2. The bypass only affects prologue validation errors, not all invariant violations  
3. Normal validation errors (like insufficient balance, sequence number mismatches) are properly converted to validation error codes and correctly discarded

However, IF a bug exists in prologue code that causes invariant violations (unexpected errors not matching known abort codes), this bypass allows exploitation without gas costs, defeating the purpose of the `CHARGE_INVARIANT_VIOLATION` mitigation. This could enable attackers to probe for and exploit VM bugs more easily, as the feature flag was specifically designed to prevent free security auditing.

## Likelihood Explanation

**Likelihood: Low to Medium**

The likelihood depends on the existence of exploitable bugs in the prologue validation code. Since the prologue is framework code that runs before user code execution, bugs there would be rare but impactful.

The bypass itself is deterministic and affects all transactions, but requires a pre-existing vulnerability in prologue code to be practically exploitable. An attacker cannot use this for systematic "free security auditing" without finding actual bugs that cause unexpected invariant violations first.

This is a **logic vulnerability** - the inconsistency in applying the security feature flag exists independently of whether there are current exploitable bugs.

## Recommendation

Modify the prologue error handling to respect the `CHARGE_INVARIANT_VIOLATION` feature flag by routing errors through `failed_transaction_cleanup()` or by having `unwrap_or_discard!` check the feature flag before deciding to discard.

One approach would be to replace the `unwrap_or_discard!` macro usage for prologue errors with proper error handling that calls `failed_transaction_cleanup()`, similar to how execution and epilogue errors are handled. This would ensure consistent application of the feature flag across all transaction execution phases.

## Proof of Concept

The vulnerability can be verified through code inspection by tracing the execution paths:

1. Prologue errors → `unwrap_or_discard!` → `discarded_output()` → `TransactionStatus::Discard` (bypasses flag)
2. Execution/epilogue errors → `failed_transaction_cleanup()` → `from_vm_status()` → checks flag

A test could be created similar to the existing invariant violation test, but using a fail point in the prologue path (e.g., `transaction_validation::run_script_prologue`) rather than in `execute_script_or_entry_function`, demonstrating that prologue invariant violations are always discarded regardless of the feature flag setting.

## Notes

This represents an architectural inconsistency rather than a directly exploitable vulnerability. The security impact is contingent on the existence of bugs in prologue validation code that cause invariant violations. However, the bypass of the `CHARGE_INVARIANT_VIOLATION` feature flag is real and deterministic, undermining the defense-in-depth security mechanism that was explicitly added to prevent free VM bug testing.

### Citations

**File:** types/src/on_chain_config/aptos_features.rs (L20-20)
```rust
    CODE_DEPENDENCY_CHECK = 1,
```

**File:** types/src/transaction/mod.rs (L1640-1646)
```rust
                if code.status_type() == StatusType::InvariantViolation
                    && features.is_enabled(FeatureFlag::CHARGE_INVARIANT_VIOLATION)
                {
                    Self::Keep(ExecutionStatus::MiscellaneousError(Some(code)))
                } else {
                    Self::Discard(code)
                }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L176-186)
```rust
macro_rules! unwrap_or_discard {
    ($res:expr) => {
        match $res {
            Ok(s) => s,
            Err(e) => {
                // covers both VMStatus itself and VMError which can convert to VMStatus
                let s: VMStatus = e.into();

                let o = discarded_output(s.status_code());
                return (s, o);
            },
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L596-600)
```rust
        let txn_status = TransactionStatus::from_vm_status(
            error_vm_status.clone(),
            self.features(),
            self.gas_feature_version() >= RELEASE_V1_38,
        );
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L2001-2012)
```rust
        let serialized_signers = unwrap_or_discard!(prologue_session.execute(|session| {
            self.validate_signed_transaction(
                session,
                code_storage,
                txn,
                &txn_data,
                log_context,
                is_approved_gov_script,
                &mut traversal_context,
                gas_meter,
            )
        }));
```

**File:** aptos-move/aptos-vm/src/errors.rs (L111-114)
```rust
                    return Err(VMStatus::error(
                        StatusCode::UNEXPECTED_ERROR_FROM_KNOWN_MOVE_FUNCTION,
                        Some(err_msg),
                    ));
```

**File:** aptos-move/aptos-vm/src/errors.rs (L166-170)
```rust
                    return Err(VMStatus::Error {
                        status_code: StatusCode::UNEXPECTED_ERROR_FROM_KNOWN_MOVE_FUNCTION,
                        sub_status: None,
                        message: Some(err_msg),
                    });
```

**File:** aptos-move/aptos-vm/src/errors.rs (L307-309)
```rust
pub(crate) fn discarded_output(status_code: StatusCode) -> VMOutput {
    VMOutput::empty_with_status(TransactionStatus::Discard(status_code))
}
```

**File:** third_party/move/move-core/types/src/vm_status.rs (L846-846)
```rust
    UNEXPECTED_ERROR_FROM_KNOWN_MOVE_FUNCTION = 2015,
```

**File:** third_party/move/move-core/types/src/vm_status.rs (L995-998)
```rust
        if major_status_number >= INVARIANT_VIOLATION_STATUS_MIN_CODE
            && major_status_number <= INVARIANT_VIOLATION_STATUS_MAX_CODE
        {
            return StatusType::InvariantViolation;
```

**File:** aptos-move/aptos-vm/src/transaction_validation.rs (L243-245)
```rust
            .map(|_return_vals| ())
            .map_err(expect_no_verification_errors)
            .or_else(|err| convert_prologue_error(err, log_context))
```

**File:** aptos-move/e2e-testsuite/src/tests/invariant_violation.rs (L14-61)
```rust
fn invariant_violation_error() {
    let _scenario = fail::FailScenario::setup();
    fail::cfg("aptos_vm::execute_script_or_entry_function", "100%return").unwrap();

    ::aptos_logger::Logger::init_for_testing();

    let mut executor = FakeExecutor::from_head_genesis();

    let sender = executor.create_raw_account_data(1_000_000, 10);
    let receiver = executor.create_raw_account_data(100_000, 10);
    executor.add_account_data(&sender);
    executor.add_account_data(&receiver);

    let transfer_amount = 1_000;
    let txn = peer_to_peer_txn(sender.account(), receiver.account(), 10, transfer_amount, 0);

    // execute transaction
    let output = executor.execute_transaction(txn.clone());

    // CHARGE_INVARIANT_VIOLATION enabled at genesis so this txn is kept.
    assert_eq!(
        output.status(),
        &TransactionStatus::Keep(ExecutionStatus::MiscellaneousError(Some(
            StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR
        ))),
    );

    // Disable the CHARGE_INVARIANT_VIOLATION flag.
    executor.exec("features", "change_feature_flags_internal", vec![], vec![
        MoveValue::Signer(AccountAddress::ONE)
            .simple_serialize()
            .unwrap(),
        MoveValue::Vector(vec![]).simple_serialize().unwrap(),
        MoveValue::Vector(vec![MoveValue::U64(
            FeatureFlag::CHARGE_INVARIANT_VIOLATION as u64,
        )])
        .simple_serialize()
        .unwrap(),
    ]);

    let output = executor.execute_transaction(txn);

    // With CHARGE_INVARIANT_VIOLATION disabled this transaction will be discarded.
    assert_eq!(
        output.status(),
        &TransactionStatus::Discard(DiscardedVMStatus::UNKNOWN_INVARIANT_VIOLATION_ERROR),
    );
}
```
