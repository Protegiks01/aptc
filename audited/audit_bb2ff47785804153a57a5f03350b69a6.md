# Audit Report

## Title
Insufficient Genesis Validation in WrappedLedgerInfo Allows Fake Genesis Injection During Synchronization

## Summary
The `WrappedLedgerInfo::verify()` function performs inadequate validation for genesis blocks (round 0), checking only that voter count is zero while failing to validate internal consistency of block information. Combined with `SyncInfo::verify()` explicitly skipping genesis commit certificate verification, this creates a path for malicious peers to inject fake genesis blocks during synchronization, potentially causing permanent chain forks.

## Finding Description
The vulnerability exists in the genesis validation logic across two critical files:

**Insufficient WrappedLedgerInfo Validation:** [1](#0-0) 

This validation only checks voter count for genesis blocks, unlike the more comprehensive `QuorumCert::verify()` which validates: [2](#0-1) 

**Explicit Exemption in SyncInfo:** [3](#0-2) 

The comment explicitly states "we do not verify genesis ledger info", creating a bypass for genesis validation.

**Attack Propagation Path:**

1. Malicious peer crafts a `SyncInfo` message with a fake genesis `WrappedLedgerInfo` as `highest_commit_cert`:
   - Round = 0 (appears as genesis)
   - `num_voters` = 0 (passes minimal check)
   - Arbitrary `BlockInfo` content (different id, parent, state_root, version)
   - Inconsistent internal structure (commit_info doesn't match certified_block)

2. Victim node receives and processes the SyncInfo in `BlockStore::add_certs()`: [4](#0-3) 

3. The fake genesis bypasses verification at line 197 of `sync_info.rs` and is passed to synchronization logic: [5](#0-4) 

4. The fake genesis ledger info is used to construct recovery data: [6](#0-5) 

5. Genesis block is deterministically generated from the fake ledger info: [7](#0-6) 

This breaks **Consensus Safety** (Invariant #2): Different nodes could accept different genesis blocks for the same epoch, leading to a permanent chain split where validators commit divergent blocks.

## Impact Explanation
**Severity: HIGH â†’ CRITICAL**

This vulnerability causes a **Consensus Safety Violation**, meeting Critical severity criteria:

- **Chain Fork**: Nodes accepting different genesis blocks cannot reconcile, creating a permanent split requiring hardfork intervention
- **Consensus Break**: Violates the fundamental AptosBFT safety guarantee that <1/3 Byzantine nodes cannot cause different committed blocks
- **Network Partition**: Subset of nodes building on fake genesis become isolated from honest nodes
- **Epoch Transition Attack**: Most effective during epoch changes when new genesis blocks are legitimately created

The impact qualifies as **"Consensus/Safety violations"** and potentially **"Non-recoverable network partition (requires hardfork)"** under the Critical severity category (up to $1,000,000).

## Likelihood Explanation
**Likelihood: MEDIUM-HIGH**

The attack is feasible because:

1. **No Authentication Required**: Any peer can send `SyncInfo` messages during normal P2P communication
2. **Sync Window**: Most effective during:
   - Node initial sync
   - Epoch transitions when legitimate genesis creation occurs
   - Fast-forward sync after downtime
3. **Minimal Complexity**: Attacker only needs to craft a single malicious `SyncInfo` message
4. **Race Condition Exploitation**: If malicious SyncInfo arrives before legitimate genesis propagates, node accepts fake genesis

However, likelihood is reduced by:
- State sync validation may reject inconsistent state roots
- Block retrieval from honest peers would fail to provide blocks matching fake genesis
- Multiple defense layers exist beyond initial verification

## Recommendation

**Option 1: Strengthen WrappedLedgerInfo Validation**

Add comprehensive genesis validation matching `QuorumCert::verify()`:

```rust
pub fn verify(&self, validator: &ValidatorVerifier) -> anyhow::Result<()> {
    if self.ledger_info().ledger_info().round() == 0 {
        let commit_info = self.ledger_info().ledger_info().commit_info();
        
        ensure!(
            commit_info.round() == 0,
            "Genesis WrappedLedgerInfo commit_info must have round 0"
        );
        
        ensure!(
            commit_info.id() == commit_info.parent_id(),
            "Genesis WrappedLedgerInfo must have consistent parent and block id"
        );
        
        ensure!(
            self.ledger_info().get_num_voters() == 0,
            "Genesis WrappedLedgerInfo should not carry signatures"
        );
        
        return Ok(());
    }
    // ... existing non-genesis validation
}
```

**Option 2: Remove Genesis Exemption in SyncInfo (Recommended)**

Remove the exemption at line 197 in `sync_info.rs`:

```rust
// Always verify commit certificates, including genesis
self.highest_commit_cert
    .verify(validator)
    .context("Fail to verify commit certificate")?;
```

**Option 3: Deterministic Genesis Validation**

Add explicit validation that genesis WrappedLedgerInfo matches deterministically generated genesis:

```rust
if self.ledger_info().ledger_info().round() == 0 
    && self.ledger_info().ledger_info().ends_epoch() {
    // Verify this matches the deterministic genesis from epoch-ending LedgerInfo
    let expected_genesis = Block::make_genesis_block_from_ledger_info(
        self.ledger_info().ledger_info()
    );
    let expected_qc = QuorumCert::certificate_for_genesis_from_ledger_info(
        self.ledger_info().ledger_info(),
        expected_genesis.id()
    );
    
    ensure!(
        self.commit_info() == expected_qc.certified_block(),
        "Genesis commit_info does not match deterministic genesis"
    );
}
```

## Proof of Concept

```rust
// PoC: Craft malicious SyncInfo with fake genesis
use aptos_consensus_types::{
    block_info::BlockInfo,
    sync_info::SyncInfo,
    wrapped_ledger_info::WrappedLedgerInfo,
    vote_data::VoteData,
};
use aptos_crypto::HashValue;
use aptos_types::{
    aggregate_signature::AggregateSignature,
    ledger_info::{LedgerInfo, LedgerInfoWithSignatures},
};

fn create_fake_genesis_attack() -> SyncInfo {
    // Create fake genesis BlockInfo with arbitrary content
    let fake_genesis_info = BlockInfo::new(
        1,                      // epoch 1
        0,                      // round 0 (genesis)
        HashValue::random(),    // arbitrary fake id
        HashValue::random(),    // arbitrary fake state_root
        1000,                   // arbitrary version
        1234567890,             // arbitrary timestamp
        None,
    );
    
    // Create WrappedLedgerInfo with genesis round but inconsistent content
    let fake_genesis_li = LedgerInfo::new(
        fake_genesis_info.clone(),
        HashValue::zero(),
    );
    
    let fake_genesis_cert = WrappedLedgerInfo::new(
        VoteData::new(fake_genesis_info.clone(), fake_genesis_info.clone()),
        LedgerInfoWithSignatures::new(
            fake_genesis_li,
            AggregateSignature::empty(), // 0 voters - passes check!
        ),
    );
    
    // Create malicious SyncInfo with fake genesis as highest_commit_cert
    // This will bypass verification in SyncInfo::verify() line 197
    let malicious_sync_info = SyncInfo::new_decoupled(
        legitimate_qc,  // Use legitimate QC for highest_quorum_cert
        fake_genesis_cert.clone(),  // Fake genesis as ordered cert
        fake_genesis_cert,  // Fake genesis as commit cert
        None,
    );
    
    malicious_sync_info
}

// When sent to a victim node during synchronization:
// 1. SyncInfo::verify() skips genesis commit cert verification (line 197)
// 2. Node accepts fake genesis and attempts to sync
// 3. Block tree rebuilt with fake genesis as root
// 4. Node forks from network, consensus safety broken
```

**Testing Steps:**
1. Deploy test network with 4 validators
2. Trigger epoch change to create legitimate genesis scenario
3. Before new genesis propagates, send malicious SyncInfo to 2 validators
4. Observe validators accepting different genesis blocks
5. Confirm permanent fork: validators cannot reach consensus on subsequent blocks

## Notes

This vulnerability is particularly dangerous because:

1. **Silent Failure**: The insufficient validation doesn't raise errors; nodes silently accept malicious genesis
2. **Permanent Impact**: Once a node builds state from fake genesis, it cannot automatically recover without manual intervention
3. **Epoch Transitions**: Attack surface increases during regular epoch changes when legitimate genesis creation occurs
4. **Trust Assumption**: Code comment suggests reliance on "round constraint" defense, but this is insufficient during initial sync or state reconstruction

The defense-in-depth principle requires that `WrappedLedgerInfo::verify()` provide the same level of validation as `QuorumCert::verify()`, and that `SyncInfo::verify()` not create special exemptions that bypass critical security checks.

### Citations

**File:** consensus/consensus-types/src/wrapped_ledger_info.rs (L97-102)
```rust
        if self.ledger_info().ledger_info().round() == 0 {
            ensure!(
                self.ledger_info().get_num_voters() == 0,
                "Genesis QC should not carry signatures"
            );
            return Ok(());
```

**File:** consensus/consensus-types/src/quorum_cert.rs (L128-141)
```rust
        if self.certified_block().round() == 0 {
            ensure!(
                self.parent_block() == self.certified_block(),
                "Genesis QC has inconsistent parent block with certified block"
            );
            ensure!(
                self.certified_block() == self.ledger_info().ledger_info().commit_info(),
                "Genesis QC has inconsistent commit block with certified block"
            );
            ensure!(
                self.ledger_info().get_num_voters() == 0,
                "Genesis QC should not carry signatures"
            );
            return Ok(());
```

**File:** consensus/consensus-types/src/sync_info.rs (L196-203)
```rust
                // we do not verify genesis ledger info
                if self.highest_commit_cert.commit_info().round() > 0 {
                    self.highest_commit_cert
                        .verify(validator)
                        .context("Fail to verify commit certificate")?
                }
                Ok(())
            })
```

**File:** consensus/src/block_storage/sync_manager.rs (L116-133)
```rust
    pub async fn add_certs(
        &self,
        sync_info: &SyncInfo,
        mut retriever: BlockRetriever,
    ) -> anyhow::Result<()> {
        // When the local ordered round is very old than the received sync_info, this function will
        // (1) resets the block store with highest commit cert = sync_info.highest_quorum_cert()
        // (2) insert all the blocks between (inclusive) highest_commit_cert.commit_info().id() to
        // highest_quorum_cert.certified_block().id() into the block store and storage
        // (3) insert the quorum cert for all the above blocks into the block store and storage
        // (4) executes all the blocks that are ordered while inserting the above quorum certs
        self.sync_to_highest_quorum_cert(
            sync_info.highest_quorum_cert().clone(),
            sync_info.highest_commit_cert().clone(),
            &mut retriever,
        )
        .await?;

```

**File:** consensus/src/block_storage/sync_manager.rs (L279-287)
```rust
    async fn sync_to_highest_quorum_cert(
        &self,
        highest_quorum_cert: QuorumCert,
        highest_commit_cert: WrappedLedgerInfo,
        retriever: &mut BlockRetriever,
    ) -> anyhow::Result<()> {
        if !self.need_sync_for_ledger_info(highest_commit_cert.ledger_info()) {
            return Ok(());
        }
```

**File:** consensus/src/block_storage/sync_manager.rs (L477-501)
```rust
        LedgerRecoveryData::new(highest_commit_cert.ledger_info().clone())
            .find_root(
                &mut blocks.clone(),
                &mut quorum_certs.clone(),
                order_vote_enabled,
                window_size,
            )
            .with_context(|| {
                // for better readability
                quorum_certs.sort_by_key(|qc| qc.certified_block().round());
                format!(
                    "\nRoot: {:?}\nBlocks in db: {}\nQuorum Certs in db: {}\n",
                    highest_commit_cert.commit_info(),
                    blocks
                        .iter()
                        .map(|b| format!("\n\t{}", b))
                        .collect::<Vec<String>>()
                        .concat(),
                    quorum_certs
                        .iter()
                        .map(|qc| format!("\n\t{}", qc))
                        .collect::<Vec<String>>()
                        .concat(),
                )
            })?;
```

**File:** consensus/src/persistent_liveness_storage.rs (L112-123)
```rust
            if self.storage_ledger.ledger_info().ends_epoch() {
                let genesis =
                    Block::make_genesis_block_from_ledger_info(self.storage_ledger.ledger_info());
                let genesis_qc = QuorumCert::certificate_for_genesis_from_ledger_info(
                    self.storage_ledger.ledger_info(),
                    genesis.id(),
                );
                let genesis_ledger_info = genesis_qc.ledger_info().clone();
                let genesis_id = genesis.id();
                blocks.push(genesis);
                quorum_certs.push(genesis_qc);
                (genesis_id, genesis_ledger_info)
```
