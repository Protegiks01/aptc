# Audit Report

## Title
Cryptographic Key Material Not Zeroized From Memory in Telemetry Authentication

## Summary
Private key material used in Noise protocol handshakes for telemetry authentication is not explicitly zeroized from memory after use, violating documented security coding guidelines and potentially exposing keys through memory dumps.

## Finding Description

The `authenticate()` function in the telemetry sender accesses private key material through `noise_config` to perform Noise protocol handshakes. [1](#0-0) 

During the handshake process, sensitive cryptographic material is created and used:

1. **Static private key**: The `NoiseConfig` struct stores an x25519 private key that persists for the lifetime of the `TelemetrySender`. [2](#0-1) 

2. **Ephemeral private key**: During `initiate_connection()`, an ephemeral private key is generated and stored in `InitiatorHandshakeState`. [3](#0-2) 

3. **Derived key material**: Diffie-Hellman shared secrets and derived encryption keys are computed during the handshake. [4](#0-3) 

The critical issue is that **none of this sensitive cryptographic material is explicitly zeroized** after use. The code relies entirely on Rust's `Drop` trait for cleanup, which directly violates the documented security guidelines.

The Aptos secure coding standards explicitly state: [5](#0-4) 

Furthermore, a comprehensive search of the codebase reveals that the `zeroize` crate is not used anywhere in the Rust code, and is not even included as a dependency, despite the security guidelines recommending its use for cryptographic material.

## Impact Explanation

This issue is classified as **Medium** severity because:

1. **Information Disclosure**: Private keys can leak through crash dumps, core files, swap space, or memory disclosure vulnerabilities
2. **Defense-in-Depth Violation**: Even if an attacker compromises a validator node, cryptographic material should not persist in memory
3. **Guideline Violation**: Explicitly violates documented RUST_SECURE_CODING.md requirements

While this does not directly lead to consensus violations or fund theft, it weakens the overall security posture by allowing key material to persist in memory longer than necessary. An attacker who gains memory access through other vulnerabilities could extract these keys to impersonate nodes or decrypt past telemetry communications.

## Likelihood Explanation

The likelihood is **Medium** because:

1. **Prerequisite**: Requires attacker to gain access to process memory through:
   - Crash dump analysis
   - Memory disclosure vulnerabilities elsewhere in the codebase
   - Swap file access
   - Cold boot attacks on physical hardware

2. **Common Scenarios**: Memory dumps are routinely generated for crash analysis, and swap files may contain stale key material

3. **Persistent Exposure**: The static private key in `NoiseConfig` persists for the entire lifetime of the `TelemetrySender`, increasing exposure window

## Recommendation

**Immediate Actions:**

1. Add `zeroize` as a dependency in the workspace `Cargo.toml`
2. Implement `ZeroizeOnDrop` for structures containing private keys
3. Explicitly zeroize sensitive buffers after use

**Implementation Example:**

```rust
// In Cargo.toml
zeroize = { version = "1.7", features = ["derive"] }

// In noise.rs
use zeroize::{Zeroize, ZeroizeOnDrop};

#[derive(ZeroizeOnDrop)]
pub struct InitiatorHandshakeState {
    h: Vec<u8>,
    ck: Vec<u8>,
    e: x25519::PrivateKey,
    rs: x25519::PublicKey,
}

// Explicitly zeroize DH outputs and derived keys
let mut dh_output = e.diffie_hellman(&rs);
let k = mix_key(&mut ck, &dh_output)?;
dh_output.zeroize();
// Use k...
k.zeroize();
```

**Long-term Actions:**

1. Audit all cryptographic code for similar issues
2. Add automated checks to enforce zeroization of key material
3. Consider using hardware security modules (HSMs) for long-lived keys

## Proof of Concept

```rust
use aptos_crypto::{noise, x25519, traits::Uniform};
use std::io::Write;

#[test]
fn test_key_material_in_memory() {
    let mut rng = rand::thread_rng();
    let private_key = x25519::PrivateKey::generate(&mut rng);
    let noise_config = noise::NoiseConfig::new(private_key);
    
    // Perform handshake
    let mut buffer = vec![0u8; noise::handshake_init_msg_len(0)];
    let remote_pub = x25519::PrivateKey::generate(&mut rng).public_key();
    
    let state = noise_config.initiate_connection(
        &mut rng,
        b"test",
        remote_pub,
        None,
        &mut buffer
    ).unwrap();
    
    // At this point, ephemeral key 'e' in 'state' is in memory
    // Drop state
    drop(state);
    
    // Key material may still be in memory here, not zeroized
    // Could be extracted via memory dump or /proc/[pid]/mem
    
    // To verify: Use memory inspection tools like:
    // - gcore to create core dump
    // - strings on the dump to search for key patterns
    // - Memory scanning tools to locate x25519 key patterns
}
```

**Notes**

This vulnerability represents a violation of defense-in-depth principles. While the Aptos codebase uses a forked version of `x25519-dalek` that supports `zeroize` compatibility [6](#0-5) , the feature is not enabled and explicit zeroization is not performed anywhere in the codebase.

The issue affects the telemetry subsystem specifically, which uses Noise protocol handshakes for authentication. While telemetry is not consensus-critical, compromised telemetry credentials could allow attackers to inject false metrics or impersonate nodes in the telemetry infrastructure.

### Citations

**File:** crates/aptos-telemetry/src/sender.rs (L287-291)
```rust
    pub async fn authenticate(&self) -> Result<String, anyhow::Error> {
        let noise_config = match &self.auth_context.noise_config {
            Some(config) => config,
            None => return Err(anyhow!("Cannot send telemetry without private key")),
        };
```

**File:** crates/aptos-crypto/src/noise.rs (L222-226)
```rust
#[derive(Debug)]
pub struct NoiseConfig {
    private_key: x25519::PrivateKey,
    public_key: x25519::PublicKey,
}
```

**File:** crates/aptos-crypto/src/noise.rs (L300-346)
```rust
        let e = x25519::PrivateKey::generate(rng);
        let e_pub = e.public_key();

        mix_hash(&mut h, e_pub.as_slice());
        let mut response_buffer = Cursor::new(response_buffer);
        response_buffer
            .write(e_pub.as_slice())
            .map_err(|_| NoiseError::ResponseBufferTooSmall)?;

        // -> es
        let dh_output = e.diffie_hellman(&rs);
        let k = mix_key(&mut ck, &dh_output)?;

        // -> s
        let aead = aes_key(&k[..]);
        let mut in_out = self.public_key.to_bytes();
        let nonce = aead::Nonce::assume_unique_for_key([0u8; AES_NONCE_SIZE]);

        aead.seal_in_place_append_tag(nonce, Aad::from(&h), &mut in_out)
            .map_err(|_| NoiseError::Encrypt)?;

        mix_hash(&mut h, &in_out[..]);
        response_buffer
            .write(&in_out[..])
            .map_err(|_| NoiseError::ResponseBufferTooSmall)?;

        // -> ss
        let dh_output = self.private_key.diffie_hellman(&rs);
        let k = mix_key(&mut ck, &dh_output)?;

        // -> payload
        let aead = aes_key(&k[..]);
        let mut in_out = payload.unwrap_or(&[]).to_vec();
        let nonce = aead::Nonce::assume_unique_for_key([0u8; AES_NONCE_SIZE]);

        aead.seal_in_place_append_tag(nonce, Aad::from(&h), &mut in_out)
            .map_err(|_| NoiseError::Encrypt)?;

        mix_hash(&mut h, &in_out[..]);

        response_buffer
            .write(&in_out[..])
            .map_err(|_| NoiseError::ResponseBufferTooSmall)?;

        // return
        let handshake_state = InitiatorHandshakeState { h, ck, e, rs };
        Ok(handshake_state)
```

**File:** RUST_SECURE_CODING.md (L89-96)
```markdown
### Drop Trait

Implement the `Drop` trait selectively, only when necessary for specific destructor logic. It's mainly used for managing external resources or memory in structures like Box or Rc, often involving unsafe code and security-critical operations.

In a Rust secure development, the implementation of the `std::ops::Drop` trait
must not panic.

Do not rely on `Drop` trait in security material treatment after the use, use [zeroize](https://docs.rs/zeroize/latest/zeroize/#) to explicit destroy security material, e.g. private keys.
```

**File:** Cargo.toml (L864-865)
```text
# This allows for zeroize 1.6 to be used. Version 1.2.0 of x25519-dalek locks zeroize to 1.3.
x25519-dalek = { git = "https://github.com/aptos-labs/x25519-dalek", rev = "b9cdbaf36bf2a83438d9f660e5a708c82ed60d8e" }
```
