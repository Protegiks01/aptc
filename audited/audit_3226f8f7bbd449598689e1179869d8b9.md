# Audit Report

## Title
Symlink Following in Backup Restore Allows Arbitrary File Read and Validator Key Leakage

## Summary
The `open_for_read()` function in the LocalFs backup storage implementation does not validate symbolic links or verify that file paths remain within the intended backup directory. This allows an attacker with write access to backup storage to create symlinks pointing to sensitive validator files (such as consensus private keys), which are then read and potentially exfiltrated during restore operations.

## Finding Description

The `open_for_read()` function unconditionally follows symbolic links without validation. [1](#0-0) 

The function performs no checks to ensure:
1. The resolved path remains within `self.dir` (the backup directory)
2. The file is not a symbolic link pointing outside the backup directory
3. Path canonicalization to detect directory traversal or symlink attacks

The `FileHandle` type is simply a String alias with no validation. [2](#0-1) 

During restore operations, file handles are loaded from backup manifests and passed to `open_for_read()`. [3](#0-2) 

Validator consensus private keys are stored in well-known locations such as `/opt/aptos/genesis/validator-identity.yaml` and contain critical security material. [4](#0-3) 

**Attack Scenario:**

1. **Attacker Gains Backup Storage Access**: An attacker compromises cloud backup storage (e.g., misconfigured S3 bucket permissions, compromised backup credentials) but does not have direct access to validator nodes.

2. **Symlink Injection**: The attacker creates a symlink in the backup metadata directory:
   ```bash
   ln -s /opt/aptos/genesis/validator-identity.yaml /backup/dir/metadata/malicious.meta
   ```

3. **Trigger via Metadata Listing**: When `list_metadata_files()` is called, it includes the symlink in results. [5](#0-4) 

4. **Exploitation During Restore**: When a restore operation reads the file, `open_for_read()` follows the symlink and reads the validator identity file containing the consensus private key.

5. **Key Exfiltration**: The sensitive file contents are exposed through the restore API or could be sent to attacker-controlled backup storage during backup operations.

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos bug bounty program criteria for the following reasons:

1. **Validator Consensus Key Compromise**: Successful exploitation exposes the validator's BLS12-381 consensus private key, which is used to sign blocks and participate in AptosBFT consensus.

2. **Potential Consensus Safety Violation**: An attacker with the consensus private key can impersonate the validator, sign malicious blocks, and potentially contribute to consensus safety violations if they compromise enough validators.

3. **Information Disclosure of Critical Security Material**: Beyond consensus keys, the attack could expose network private keys, account private keys, and other sensitive validator configuration data.

4. **Cross-Domain Privilege Escalation**: The attack exploits weaker security controls in backup storage to access more privileged validator key material, representing a defense-in-depth failure.

While this does not directly cause consensus failure or fund theft, the exposure of validator consensus keys is a critical security breach that could enable such attacks.

## Likelihood Explanation

The likelihood of exploitation is **Medium to High** due to:

1. **Common Misconfigurations**: Cloud storage misconfigurations (overly permissive S3/GCS bucket policies) are extremely common and regularly exploited in production environments.

2. **Separate Security Domains**: Backup storage often has different access controls than production validator nodes, creating an attack surface where backup storage compromise doesn't require validator node access.

3. **Automated Backup/Restore Operations**: Organizations regularly perform backup and restore operations, providing opportunities for exploitation without raising suspicion.

4. **Well-Known File Paths**: Validator key locations are documented and predictable, making targeted attacks straightforward.

5. **No Detection Mechanisms**: The absence of symlink validation means attacks leave no obvious traces in logs or monitoring systems.

## Recommendation

Implement path validation and symlink detection in `open_for_read()`:

```rust
async fn open_for_read(
    &self,
    file_handle: &FileHandleRef,
) -> Result<Box<dyn AsyncRead + Send + Unpin>> {
    let path = self.dir.join(file_handle);
    
    // Canonicalize both paths to resolve symlinks and get absolute paths
    let canonical_path = tokio::fs::canonicalize(&path)
        .await
        .err_notes(&path)?;
    let canonical_dir = tokio::fs::canonicalize(&self.dir)
        .await
        .err_notes(&self.dir)?;
    
    // Verify the canonical path is within the backup directory
    if !canonical_path.starts_with(&canonical_dir) {
        bail!(
            "Security violation: file path '{}' resolves outside backup directory '{}'",
            path.display(),
            self.dir.display()
        );
    }
    
    let file = OpenOptions::new()
        .read(true)
        .open(&path)
        .await
        .err_notes(&path)?;
    Ok(Box::new(file))
}
```

Additional recommendations:
1. Apply the same validation to `create_for_write()` to prevent symlink-based write operations
2. Implement similar checks in `backup_metadata_file()` 
3. Add security documentation warning operators about backup directory permissions
4. Consider implementing a restricted file handle format that explicitly prevents path traversal

## Proof of Concept

```rust
#[cfg(test)]
mod symlink_exploitation_test {
    use super::*;
    use std::os::unix::fs::symlink;
    use tempfile::TempDir;
    use tokio::fs::write;

    #[tokio::test]
    async fn test_symlink_follows_outside_backup_dir() -> Result<()> {
        // Create temporary directories
        let backup_dir = TempDir::new()?;
        let sensitive_dir = TempDir::new()?;
        
        // Create a sensitive file (simulating validator-identity.yaml)
        let sensitive_file = sensitive_dir.path().join("validator-identity.yaml");
        write(&sensitive_file, b"consensus_private_key: SECRET_KEY_DATA").await?;
        
        // Create LocalFs instance
        let storage = LocalFs::new(backup_dir.path().to_path_buf());
        
        // Create metadata directory
        tokio::fs::create_dir_all(storage.metadata_dir()).await?;
        
        // Create a symlink in the backup metadata directory pointing to sensitive file
        let symlink_path = storage.metadata_dir().join("malicious.meta");
        symlink(&sensitive_file, &symlink_path)?;
        
        // Attempt to read via the symlink
        let file_handle = "metadata/malicious.meta";
        let result = storage.open_for_read(file_handle).await;
        
        // Current implementation: PASSES (vulnerability exists)
        // The symlink is followed and sensitive data is read
        assert!(result.is_ok(), "Symlink was followed - vulnerability confirmed");
        
        // Expected behavior after fix: should fail with security error
        // assert!(result.is_err(), "Should reject symlinks outside backup directory");
        
        Ok(())
    }
}
```

## Notes

This vulnerability represents a failure of defense-in-depth principles. While an attacker needs write access to backup storage, this is a different security domain than validator node access. Backup storage is frequently:
- Managed by different teams with different access controls
- Stored in cloud environments with common misconfiguration vulnerabilities  
- Subject to different security policies and monitoring

The lack of path validation enables privilege escalation from backup storage access to validator key compromise, which could ultimately lead to consensus safety violations if multiple validators are compromised through this vector.

### Citations

**File:** storage/backup/backup-cli/src/storage/local_fs/mod.rs (L98-109)
```rust
    async fn open_for_read(
        &self,
        file_handle: &FileHandleRef,
    ) -> Result<Box<dyn AsyncRead + Send + Unpin>> {
        let path = self.dir.join(file_handle);
        let file = OpenOptions::new()
            .read(true)
            .open(&path)
            .await
            .err_notes(&path)?;
        Ok(Box::new(file))
    }
```

**File:** storage/backup/backup-cli/src/storage/local_fs/mod.rs (L111-123)
```rust
    async fn list_metadata_files(&self) -> Result<Vec<FileHandle>> {
        let dir = self.metadata_dir();
        let rel_path = Path::new(Self::METADATA_DIR);

        let mut res = Vec::new();
        if path_exists(&dir).await {
            let mut entries = read_dir(&dir).await.err_notes(&dir)?;
            while let Some(entry) = entries.next_entry().await.err_notes(&dir)? {
                res.push(rel_path.join(entry.file_name()).path_to_string()?)
            }
        }
        Ok(res)
    }
```

**File:** storage/backup/backup-cli/src/storage/mod.rs (L40-41)
```rust
pub type FileHandle = String;
pub type FileHandleRef = str;
```

**File:** storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs (L123-126)
```rust
        let manifest: StateSnapshotBackup =
            self.storage.load_json_file(&self.manifest_handle).await?;
        let (txn_info_with_proof, li): (TransactionInfoWithProof, LedgerInfoWithSignatures) =
            self.storage.load_bcs_file(&manifest.proof).await?;
```

**File:** config/src/config/identity_config.rs (L24-37)
```rust
#[derive(Deserialize, Serialize)]
pub struct IdentityBlob {
    /// Optional account address. Used for validators and validator full nodes
    #[serde(skip_serializing_if = "Option::is_none")]
    pub account_address: Option<AccountAddress>,
    /// Optional account key. Only used for validators
    #[serde(skip_serializing_if = "Option::is_none")]
    pub account_private_key: Option<Ed25519PrivateKey>,
    /// Optional consensus key. Only used for validators
    #[serde(skip_serializing_if = "Option::is_none")]
    pub consensus_private_key: Option<bls12381::PrivateKey>,
    /// Network private key. Peer id is derived from this if account address is not present
    pub network_private_key: x25519::PrivateKey,
}
```
