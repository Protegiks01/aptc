# Audit Report

## Title
Missing Genesis Validation in TrustedState Creation Allows Alternative Genesis State Forgery

## Summary
The `try_from_epoch_change_li()` function in `types/src/trusted_state.rs` accepts arbitrary genesis epoch (epoch 0) LedgerInfo without validation, allowing creation of TrustedState with attacker-controlled validator sets. This bypasses the cryptographic trust anchor model that light clients should rely on.

## Finding Description

The `try_from_epoch_change_li()` function creates a TrustedState from an epoch-change LedgerInfo without signature verification. [1](#0-0) 

For genesis (epoch 0), LedgerInfoWithSignatures are intentionally unsigned because no validators exist yet to sign them: [2](#0-1) 

The genesis LedgerInfo created by nodes also uses empty signatures: [3](#0-2) 

**The vulnerability:** An attacker can craft a fake genesis LedgerInfo at epoch 0 with:
- A malicious validator set in `next_epoch_state` for epoch 1
- Any arbitrary state root hash
- A consistent accumulator summary

When passed to `try_from_epoch_change_li()`, it creates a TrustedState that will accept epoch change proofs signed by the attacker's validators. The function only checks accumulator consistency and the presence of `next_epoch_state`, without validating that this is the canonical genesis: [4](#0-3) 

**Attack path:**
1. Malicious SDK/application calls `try_from_epoch_change_li()` with fake genesis
2. Creates TrustedState with attacker-controlled validators
3. Provides epoch change proofs signed by those validators via `verify_and_ratchet()`
4. Users unknowingly sync from forked/fake chain

The proper initialization method `from_epoch_waypoint()` uses cryptographic waypoints from trusted sources, but `try_from_epoch_change_li()` is a public API that bypasses this security model: [5](#0-4) 

## Impact Explanation

**High Severity** - This breaks the fundamental trust model for light clients:

- **Protocol Violation**: Light clients can be tricked into accepting forked chains, violating consensus safety guarantees
- **User Impact**: Applications using this API incorrectly could sync fake blockchain state, leading to loss of funds if users transact on the fake chain
- **Trust Anchor Bypass**: The waypoint-based security model is completely bypassed

While this doesn't directly affect validator nodes running the mainnet (they use proper genesis initialization), it creates a dangerous API surface for light client implementations and SDKs that could lead to significant security compromises.

## Likelihood Explanation

**Medium to High Likelihood:**

- The function is public and exported in the `types` crate
- SDK developers building light clients may use it without understanding the security implications  
- No documentation warns about the genesis validation gap
- The function name suggests it's safe to use with any epoch-change LedgerInfo
- Only used in tests currently, but external applications could call it

The lack of clear security boundaries makes misuse likely in third-party integrations.

## Recommendation

Add explicit genesis validation for epoch 0:

```rust
pub fn try_from_epoch_change_li(
    epoch_change_li: &LedgerInfo,
    accumulator: TransactionAccumulatorSummary,
) -> Result<Self> {
    // Ensure the accumulator and ledger info are at the same version/root hash.
    accumulator.verify_consistency(epoch_change_li)?;

    let epoch_state = epoch_change_li.next_epoch_state().cloned().ok_or_else(|| {
        format_err!("No EpochState in LedgerInfo; it must not be on an epoch boundary")
    })?;

    // SECURITY: Reject genesis epoch without trusted waypoint verification
    ensure!(
        epoch_change_li.epoch() != GENESIS_EPOCH,
        "Cannot create TrustedState from genesis epoch without waypoint verification. Use from_epoch_waypoint() instead."
    );

    Ok(Self::EpochState {
        waypoint: Waypoint::new_epoch_boundary(epoch_change_li)?,
        epoch_state,
    })
}
```

**Alternative approaches:**
1. Make the function `pub(crate)` if only meant for internal use
2. Add a separate `try_from_genesis()` that requires a trusted waypoint parameter
3. Add security documentation warning about genesis epoch handling

## Proof of Concept

```rust
use aptos_types::{
    block_info::BlockInfo,
    epoch_state::EpochState,
    ledger_info::LedgerInfo,
    trusted_state::TrustedState,
    validator_verifier::ValidatorVerifier,
    on_chain_config::ValidatorSet,
    proof::accumulator::mock::MockTransactionAccumulator,
};
use aptos_crypto::hash::HashValue;
use std::sync::Arc;

#[test]
fn test_forged_genesis_attack() {
    // Attacker creates fake genesis with malicious validators
    let malicious_validator_set = ValidatorSet::empty(); // Attacker's validators
    let fake_genesis_li = LedgerInfo::new(
        BlockInfo::new(
            0, // GENESIS_EPOCH
            0,
            HashValue::zero(),
            HashValue::random(), // arbitrary state root
            0, // genesis version
            0,
            Some(EpochState {
                epoch: 1,
                verifier: Arc::new(ValidatorVerifier::from(&malicious_validator_set)),
            }),
        ),
        HashValue::zero(),
    );
    
    // Create consistent accumulator
    let accumulator = MockTransactionAccumulator::with_version(0);
    
    // VULNERABILITY: This succeeds without validating genesis authenticity!
    let forged_trusted_state = TrustedState::try_from_epoch_change_li(
        &fake_genesis_li,
        accumulator.get_accumulator_summary(0),
    ).expect("Should reject fake genesis but doesn't!");
    
    // Now attacker has TrustedState with their validators
    // They can create epoch change proofs signed by their validators
    // Users syncing with this state will accept the fake chain
    assert_eq!(forged_trusted_state.version(), 0);
}
```

## Notes

This vulnerability specifically affects light client implementations and SDK usage. While the mainnet validators use proper genesis initialization through `maybe_bootstrap()` with trusted waypoints [6](#0-5) , the public API surface exposes this dangerous function without sufficient safeguards for epoch 0 handling.

### Citations

**File:** types/src/trusted_state.rs (L61-68)
```rust
    /// Create an initial trusted state from a trusted epoch waypoint constructed
    /// from an epoch-change ledger info.
    ///
    /// Note: we can't actually guarantee this waypoint is actually an epoch
    /// waypoint, but the sync will always fail to verify it's not.
    pub fn from_epoch_waypoint(epoch_waypoint: Waypoint) -> Self {
        Self::EpochWaypoint(epoch_waypoint)
    }
```

**File:** types/src/trusted_state.rs (L75-90)
```rust
    pub fn try_from_epoch_change_li(
        epoch_change_li: &LedgerInfo,
        accumulator: TransactionAccumulatorSummary,
    ) -> Result<Self> {
        // Ensure the accumulator and ledger info are at the same version/root hash.
        accumulator.verify_consistency(epoch_change_li)?;

        let epoch_state = epoch_change_li.next_epoch_state().cloned().ok_or_else(|| {
            format_err!("No EpochState in LedgerInfo; it must not be on an epoch boundary")
        })?;

        Ok(Self::EpochState {
            waypoint: Waypoint::new_epoch_boundary(epoch_change_li)?,
            epoch_state,
        })
    }
```

**File:** types/src/ledger_info.rs (L269-281)
```rust
    /// Create a new `LedgerInfoWithSignatures` at genesis with the given genesis
    /// state and initial validator set.
    ///
    /// Note that the genesis `LedgerInfoWithSignatures` is unsigned. Validators
    /// and FullNodes are configured with the same genesis transaction and generate
    /// an identical genesis `LedgerInfoWithSignatures` independently. In contrast,
    /// Clients will likely use a waypoint generated from the genesis `LedgerInfo`.
    pub fn genesis(genesis_state_root_hash: HashValue, validator_set: ValidatorSet) -> Self {
        Self::new(
            LedgerInfo::genesis(genesis_state_root_hash, validator_set),
            AggregateSignature::empty(),
        )
    }
```

**File:** execution/executor/src/db_bootstrapper/mod.rs (L48-71)
```rust
pub fn maybe_bootstrap<V: VMBlockExecutor>(
    db: &DbReaderWriter,
    genesis_txn: &Transaction,
    waypoint: Waypoint,
) -> Result<Option<LedgerInfoWithSignatures>> {
    let ledger_summary = db.reader.get_pre_committed_ledger_summary()?;
    // if the waypoint is not targeted with the genesis txn, it may be either already bootstrapped, or
    // aiming for state sync to catch up.
    if ledger_summary.version().map_or(0, |v| v + 1) != waypoint.version() {
        info!(waypoint = %waypoint, "Skip genesis txn.");
        return Ok(None);
    }

    let committer = calculate_genesis::<V>(db, ledger_summary, genesis_txn)?;
    ensure!(
        waypoint == committer.waypoint(),
        "Waypoint verification failed. Expected {:?}, got {:?}.",
        waypoint,
        committer.waypoint(),
    );
    let ledger_info = committer.output.ledger_info_opt.clone();
    committer.commit()?;
    Ok(ledger_info)
}
```

**File:** execution/executor/src/db_bootstrapper/mod.rs (L176-193)
```rust
    let ledger_info_with_sigs = LedgerInfoWithSignatures::new(
        LedgerInfo::new(
            BlockInfo::new(
                epoch,
                GENESIS_ROUND,
                genesis_block_id(),
                output
                    .ensure_ledger_update_output()?
                    .transaction_accumulator
                    .root_hash(),
                genesis_version,
                timestamp_usecs,
                output.execution_output.next_epoch_state.clone(),
            ),
            genesis_block_id(), /* consensus_data_hash */
        ),
        AggregateSignature::empty(), /* signatures */
    );
```
