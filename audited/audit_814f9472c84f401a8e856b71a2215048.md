# Audit Report

## Title
Database Resource Leak: V2 Batches Never Deleted from Disk in Quorum Store

## Summary
The quorum store batch cleanup mechanism fails to delete V2 batches from the database, causing unbounded disk growth on validators running with `enable_batch_v2: true`. Two critical code paths incorrectly use V1 deletion methods when cleaning up V2 batches.

## Finding Description

The Aptos quorum store maintains two separate database column families for batch storage:
- `"batch"` (V1 format) using `BatchSchema` [1](#0-0) 
- `"batch_v2"` (V2 format) using `BatchV2Schema` [2](#0-1) [3](#0-2) 

When `enable_batch_v2: true` is configured [4](#0-3) , batches are saved to the V2 column family via `save_batch_v2()` [5](#0-4) .

However, the cleanup mechanisms contain two critical bugs:

**Bug 1: Epoch Cleanup (Line 241)**

The function `gc_previous_epoch_batches_from_db_v2()` reads batches from the V2 column family [6](#0-5)  but attempts to delete them using the V1 deletion method [7](#0-6) . This is a copy-paste error from the V1 cleanup function [8](#0-7) .

The correct V2 deletion method exists and is properly used elsewhere in the codebase [9](#0-8) .

**Bug 2: Expiration Cleanup (Line 536)**

The function `update_certified_timestamp()` cleans up expired batches from the cache and attempts to delete them from disk [10](#0-9) , but only calls the V1 deletion method regardless of batch version. The cache stores `PersistedValue<BatchInfoExt>` [11](#0-10)  which can contain both V1 and V2 batches.

The database operations clearly distinguish between V1 and V2:
- `delete_batches()` deletes from `BatchSchema` (V1) [12](#0-11) 
- `delete_batches_v2()` deletes from `BatchV2Schema` (V2) [13](#0-12) 

## Impact Explanation

**Severity: Medium** (per Aptos bug bounty criteria: "State inconsistencies requiring intervention")

**Impact:**
- Unbounded database growth on validators with `enable_batch_v2: true`
- Progressive disk space exhaustion over time
- Eventually causes validator node failure when disk is full
- Requires manual intervention (database cleanup or node replacement)
- Does not immediately affect consensus safety but degrades network health over time

This breaks the resource limits invariant. The database grows without bound, violating storage limits.

**Affected Nodes:**
- Any validator running with `enable_batch_v2: true` in their quorum store configuration [14](#0-13) 
- Default configuration has this flag set to `false` [15](#0-14) , limiting immediate impact

## Likelihood Explanation

**Likelihood: High** (for nodes with `enable_batch_v2: true`)

The vulnerability triggers automatically without attacker intervention:
1. Validator sets `enable_batch_v2: true` in configuration
2. Batches are created and saved via the V2 path during normal operation [16](#0-15) 
3. When batches expire or epochs change, cleanup functions execute [17](#0-16) 
4. V2 batches remain in database indefinitely due to the bugs
5. Database grows continuously during consensus operation

The vulnerability requires no special privileges - just a configuration change that may be deployed during protocol upgrades when the V2 format becomes standard.

## Recommendation

Fix both cleanup paths to use the correct V2 deletion method:

**Fix for Bug 1 (Line 241):**
Replace `db.delete_batches(expired_keys)` with `db.delete_batches_v2(expired_keys)` in the `gc_previous_epoch_batches_from_db_v2()` function.

**Fix for Bug 2 (Line 536):**
In `update_certified_timestamp()`, check the batch version before deletion and call the appropriate method. Alternatively, separate the expired keys by version and call both deletion methods with their respective key sets.

## Proof of Concept

While no executable PoC is provided, the bug can be reproduced by:
1. Starting a validator node with `enable_batch_v2: true` in the quorum store configuration
2. Allowing the node to participate in consensus and create batches
3. Waiting for epoch changes or batch expirations to trigger cleanup
4. Observing that the `batch_v2` column family in the database grows unbounded
5. Monitoring disk usage over time to confirm progressive growth

The vulnerability is evident from code inspection alone - the cleanup functions demonstrably call V1 deletion methods on V2 data.

### Citations

**File:** consensus/src/quorum_store/schema.rs (L14-26)
```rust
pub(crate) const BATCH_CF_NAME: ColumnFamilyName = "batch";
pub(crate) const BATCH_ID_CF_NAME: ColumnFamilyName = "batch_ID";
pub(crate) const BATCH_V2_CF_NAME: ColumnFamilyName = "batch_v2";

#[derive(Debug)]
pub(crate) struct BatchSchema;

impl Schema for BatchSchema {
    type Key = HashValue;
    type Value = PersistedValue<BatchInfo>;

    const COLUMN_FAMILY_NAME: aptos_schemadb::ColumnFamilyName = BATCH_CF_NAME;
}
```

**File:** consensus/src/quorum_store/schema.rs (L49-56)
```rust
pub(crate) struct BatchV2Schema;

impl Schema for BatchV2Schema {
    type Key = HashValue;
    type Value = PersistedValue<BatchInfoExt>;

    const COLUMN_FAMILY_NAME: aptos_schemadb::ColumnFamilyName = BATCH_V2_CF_NAME;
}
```

**File:** config/src/config/quorum_store_config.rs (L102-102)
```rust
    pub enable_batch_v2: bool,
```

**File:** config/src/config/quorum_store_config.rs (L144-144)
```rust
            enable_batch_v2: false,
```

**File:** consensus/src/quorum_store/batch_store.rs (L116-116)
```rust
    db_cache: DashMap<HashValue, PersistedValue<BatchInfoExt>>,
```

**File:** consensus/src/quorum_store/batch_store.rs (L158-159)
```rust
                Self::gc_previous_epoch_batches_from_db_v1(db_clone.clone(), epoch);
                Self::gc_previous_epoch_batches_from_db_v2(db_clone, epoch);
```

**File:** consensus/src/quorum_store/batch_store.rs (L208-209)
```rust
        db.delete_batches(expired_keys)
            .expect("Deletion of expired keys should not fail");
```

**File:** consensus/src/quorum_store/batch_store.rs (L213-215)
```rust
        let db_content = db
            .get_all_batches_v2()
            .expect("failed to read data from db");
```

**File:** consensus/src/quorum_store/batch_store.rs (L241-242)
```rust
        db.delete_batches(expired_keys)
            .expect("Deletion of expired keys should not fail");
```

**File:** consensus/src/quorum_store/batch_store.rs (L333-334)
```rust
            db.delete_batches_v2(expired_keys)
                .expect("Deletion of expired keys should not fail");
```

**File:** consensus/src/quorum_store/batch_store.rs (L508-513)
```rust
                    } else {
                        #[allow(clippy::unwrap_in_result)]
                        self.db
                            .save_batch_v2(persist_request)
                            .expect("Could not write to DB")
                    }
```

**File:** consensus/src/quorum_store/batch_store.rs (L535-538)
```rust
        let expired_keys = self.clear_expired_payload(certified_time);
        if let Err(e) = self.db.delete_batches(expired_keys) {
            debug!("Error deleting batches: {:?}", e)
        }
```

**File:** consensus/src/quorum_store/quorum_store_db.rs (L93-101)
```rust
    fn delete_batches(&self, digests: Vec<HashValue>) -> Result<(), DbError> {
        let mut batch = SchemaBatch::new();
        for digest in digests.iter() {
            trace!("QS: db delete digest {}", digest);
            batch.delete::<BatchSchema>(digest)?;
        }
        self.db.write_schemas_relaxed(batch)?;
        Ok(())
    }
```

**File:** consensus/src/quorum_store/quorum_store_db.rs (L123-131)
```rust
    fn delete_batches_v2(&self, digests: Vec<HashValue>) -> Result<(), DbError> {
        let mut batch = SchemaBatch::new();
        for digest in digests.iter() {
            trace!("QS: db delete digest {}", digest);
            batch.delete::<BatchV2Schema>(digest)?;
        }
        self.db.write_schemas_relaxed(batch)?;
        Ok(())
    }
```

**File:** consensus/src/quorum_store/batch_generator.rs (L190-190)
```rust
        if self.config.enable_batch_v2 {
```
