# Audit Report

## Title
Stack Overflow DoS via Deeply Nested BooleanTransactionFilter in Indexer-gRPC Service

## Summary
The indexer-grpc service is vulnerable to a stack overflow attack through deeply nested `BooleanTransactionFilter` structures. An attacker can craft a malicious filter with thousands of nested `LogicalNot` operations that passes size validation but causes stack exhaustion during protobuf-to-Rust conversion, crashing the indexer-grpc service.

## Finding Description

The vulnerability exists in the `BooleanTransactionFilter::new_from_proto()` conversion logic. The function validates the protobuf message size but does not enforce any recursion depth limit. [1](#0-0) 

The `parse_transaction_filter()` function calls `new_from_proto()` with a maximum size check (default 10,000 bytes). [2](#0-1) 

The size validation only occurs when `max_filter_size` is `Some(...)` at the top level. However, during recursive conversion of nested structures, all subsequent calls pass `None`: [3](#0-2) [4](#0-3) [5](#0-4) 

**Attack Path:**
1. Attacker constructs a deeply nested protobuf message: `Not(Not(Not(...Not(APIFilter)...)))` with 3,000+ levels
2. Each nesting level adds only ~3 bytes to the protobuf encoding, staying under the 10KB limit
3. Attacker sends malicious `GetTransactionsRequest` to any indexer-grpc endpoint [6](#0-5) 

4. The service calls `parse_transaction_filter()` which invokes `new_from_proto()`
5. Size check passes (under 10KB), but recursive conversion creates 3,000+ stack frames
6. Stack overflow occurs, panicking the thread/process and crashing the service [7](#0-6) 

The protobuf schema allows arbitrary nesting depth: [8](#0-7) 

## Impact Explanation

**Severity: High** - This qualifies as "API crashes" per the Aptos bug bounty criteria.

- **Service Availability**: Complete denial of service for the indexer-grpc API with a single request
- **Ecosystem Impact**: All applications depending on indexer-grpc for transaction data will fail
- **No Authentication Required**: Any client can exploit this without credentials
- **Trivial Exploitation**: Crafting the malicious protobuf message requires minimal effort
- **All Endpoints Affected**: Historical data service, live data service, and localnet data service all use the same vulnerable parsing logic

While this doesn't directly affect consensus or validator operations, the indexer-grpc service is critical infrastructure for the Aptos ecosystem, providing the official API for blockchain data access.

## Likelihood Explanation

**Likelihood: High**

- **Easy to Exploit**: Attacker only needs to construct a nested protobuf message and send it via gRPC
- **No Prerequisites**: No authentication, stake, or special permissions required
- **Reliable**: Stack overflow will occur deterministically with sufficient nesting depth
- **Publicly Exposed**: Indexer-grpc services are typically public-facing APIs
- **Low Cost**: Single malicious request causes crash, no sustained attack needed

With Rust's typical 2MB default stack size and ~1-2KB stack frame overhead per recursive call, approximately 1,000-2,000 nesting levels will cause overflow. The 10KB size limit allows for 3,000+ levels at ~3 bytes per level.

## Recommendation

Implement a maximum recursion depth check in `BooleanTransactionFilter::new_from_proto()`:

```rust
const MAX_FILTER_DEPTH: usize = 100;

impl BooleanTransactionFilter {
    pub fn new_from_proto(
        proto_filter: aptos_protos::indexer::v1::BooleanTransactionFilter,
        max_filter_size: Option<usize>,
    ) -> Result<Self> {
        Self::new_from_proto_with_depth(proto_filter, max_filter_size, 0)
    }

    fn new_from_proto_with_depth(
        proto_filter: aptos_protos::indexer::v1::BooleanTransactionFilter,
        max_filter_size: Option<usize>,
        current_depth: usize,
    ) -> Result<Self> {
        ensure!(
            current_depth <= MAX_FILTER_DEPTH,
            format!("Filter recursion depth exceeds maximum of {}", MAX_FILTER_DEPTH)
        );
        
        // Existing size check
        if let Some(max_filter_size) = max_filter_size {
            ensure!(
                proto_filter.encoded_len() <= max_filter_size,
                // ... existing error message
            );
        }
        
        // Pattern match and recurse with incremented depth
        Ok(match proto_filter.filter.ok_or(...)? {
            // ... pass current_depth + 1 to all recursive calls
        })
    }
}
```

Update `TryFrom` implementations for `LogicalAnd`, `LogicalOr`, and `LogicalNot` to pass depth parameter.

## Proof of Concept

```rust
#[cfg(test)]
mod stack_overflow_poc {
    use super::*;
    use aptos_protos::indexer::v1;

    #[test]
    #[should_panic(expected = "stack overflow")]
    fn test_deeply_nested_filter_causes_stack_overflow() {
        // Create a minimal APIFilter as the base
        let base_filter = v1::BooleanTransactionFilter {
            filter: Some(v1::boolean_transaction_filter::Filter::ApiFilter(
                v1::ApiFilter {
                    filter: Some(v1::api_filter::Filter::TransactionRootFilter(
                        v1::TransactionRootFilter {
                            success: Some(true),
                            transaction_type: None,
                        },
                    )),
                },
            )),
        };

        // Wrap in 3000 layers of LogicalNot
        let mut nested_filter = base_filter;
        for _ in 0..3000 {
            nested_filter = v1::BooleanTransactionFilter {
                filter: Some(v1::boolean_transaction_filter::Filter::LogicalNot(
                    Box::new(nested_filter),
                )),
            };
        }

        // Verify size is under 10KB
        let encoded_size = prost::Message::encoded_len(&nested_filter);
        assert!(encoded_size < 10_000, "Filter size: {} bytes", encoded_size);

        // This should cause stack overflow during conversion
        let _ = BooleanTransactionFilter::new_from_proto(
            nested_filter,
            Some(10_000),
        );
    }
}
```

**Notes**

This vulnerability is specific to the indexer-grpc auxiliary service and does not directly impact consensus, Move VM execution, or core blockchain operations. However, it represents a critical availability issue for the ecosystem's primary data access API. The fix is straightforward: add depth tracking to the recursive conversion logic and reject filters exceeding a reasonable nesting limit (e.g., 100 levels).

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/filter_utils.rs (L9-15)
```rust
pub fn parse_transaction_filter(
    proto_filter: aptos_protos::indexer::v1::BooleanTransactionFilter,
    max_filter_size_bytes: usize,
) -> Result<BooleanTransactionFilter, Status> {
    BooleanTransactionFilter::new_from_proto(proto_filter, Some(max_filter_size_bytes))
        .map_err(|e| Status::invalid_argument(format!("Invalid transaction_filter: {e:?}.")))
}
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/boolean_transaction_filter.rs (L94-127)
```rust
    pub fn new_from_proto(
        proto_filter: aptos_protos::indexer::v1::BooleanTransactionFilter,
        max_filter_size: Option<usize>,
    ) -> Result<Self> {
        if let Some(max_filter_size) = max_filter_size {
            ensure!(
                proto_filter.encoded_len() <= max_filter_size,
                format!(
                    "Filter is too complicated. Max size: {} bytes, Actual size: {} bytes",
                    max_filter_size,
                    proto_filter.encoded_len()
                )
            );
        }
        Ok(
            match proto_filter
                .filter
                .ok_or(anyhow!("Oneof is not set in BooleanTransactionFilter."))?
            {
                aptos_protos::indexer::v1::boolean_transaction_filter::Filter::ApiFilter(
                    api_filter,
                ) => TryInto::<APIFilter>::try_into(api_filter)?.into(),
                aptos_protos::indexer::v1::boolean_transaction_filter::Filter::LogicalAnd(
                    logical_and,
                ) => BooleanTransactionFilter::And(logical_and.try_into()?),
                aptos_protos::indexer::v1::boolean_transaction_filter::Filter::LogicalOr(
                    logical_or,
                ) => BooleanTransactionFilter::Or(logical_or.try_into()?),
                aptos_protos::indexer::v1::boolean_transaction_filter::Filter::LogicalNot(
                    logical_not,
                ) => BooleanTransactionFilter::Not(logical_not.try_into()?),
            },
        )
    }
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/boolean_transaction_filter.rs (L265-277)
```rust
impl TryFrom<aptos_protos::indexer::v1::LogicalAndFilters> for LogicalAnd {
    type Error = anyhow::Error;

    fn try_from(proto_filter: aptos_protos::indexer::v1::LogicalAndFilters) -> Result<Self> {
        Ok(Self {
            and: proto_filter
                .filters
                .into_iter()
                .map(|f| BooleanTransactionFilter::new_from_proto(f, None))
                .collect::<Result<_>>()?,
        })
    }
}
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/boolean_transaction_filter.rs (L305-317)
```rust
impl TryFrom<aptos_protos::indexer::v1::LogicalOrFilters> for LogicalOr {
    type Error = anyhow::Error;

    fn try_from(proto_filter: aptos_protos::indexer::v1::LogicalOrFilters) -> Result<Self> {
        Ok(Self {
            or: proto_filter
                .filters
                .into_iter()
                .map(|f| BooleanTransactionFilter::new_from_proto(f, None))
                .collect::<Result<_>>()?,
        })
    }
}
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/boolean_transaction_filter.rs (L345-358)
```rust
impl TryFrom<Box<aptos_protos::indexer::v1::BooleanTransactionFilter>> for LogicalNot {
    type Error = anyhow::Error;

    fn try_from(
        proto_filter: Box<aptos_protos::indexer::v1::BooleanTransactionFilter>,
    ) -> Result<Self> {
        Ok(Self {
            not: Box::new(BooleanTransactionFilter::new_from_proto(
                *proto_filter,
                None,
            )?),
        })
    }
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/mod.rs (L98-115)
```rust
                let filter = if let Some(proto_filter) = request.transaction_filter {
                    match filter_utils::parse_transaction_filter(
                        proto_filter,
                        self.max_transaction_filter_size_bytes,
                    ) {
                        Ok(filter) => Some(filter),
                        Err(err) => {
                            info!("Client error: {err:?}.");
                            let _ = response_sender.blocking_send(Err(err));
                            COUNTER
                                .with_label_values(&["live_data_service_invalid_filter"])
                                .inc();
                            continue;
                        },
                    }
                } else {
                    None
                };
```

**File:** config/src/config/indexer_grpc_config.rs (L21-21)
```rust
const DEFAULT_MAX_TRANSACTION_FILTER_SIZE_BYTES: usize = 10_000;
```

**File:** protos/proto/aptos/indexer/v1/filter.proto (L58-65)
```text
message BooleanTransactionFilter {
  oneof filter {
      APIFilter api_filter = 1;
      LogicalAndFilters logical_and = 2;
      LogicalOrFilters logical_or = 3;
      BooleanTransactionFilter logical_not = 4;
  }
}
```
