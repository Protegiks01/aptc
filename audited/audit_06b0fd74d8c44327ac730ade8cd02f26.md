# Audit Report

## Title
Distance-Based Peer Routing Manipulation via Unchecked Self-Reported Metrics

## Summary
The Aptos peer monitoring service allows nodes to self-report their `distance_from_validators` metric with insufficient validation for distance values ≥ 2. Malicious peers can claim artificially low distances to gain priority in mempool transaction forwarding, state-sync peer selection, and consensus observer subscriptions, enabling network degradation and eclipse attacks on non-validator nodes.

## Finding Description

The `NetworkInformationResponse` struct contains a self-reported `distance_from_validators` field that indicates how many network hops a peer is from the validator set. [1](#0-0) 

When nodes calculate their own distance, they query connected peers and use the minimum reported distance plus one. [2](#0-1) 

The validation logic in the client only checks basic role-based constraints for distance values 0 and 1, but accepts any distance ≥ 2 as long as it's under the maximum threshold of 100. [3](#0-2) 

**The Attack Path:**

1. A malicious public fullnode at actual distance 10 from validators reports `distance_from_validators = 2` in its `NetworkInformationResponse`
2. This false value passes validation since distance ≥ 2 only requires `distance_from_validators <= MAX_DISTANCE_FROM_VALIDATORS` (100)
3. Other nodes trust this value and store it in their peer monitoring metadata
4. The malicious peer gains priority in three critical systems:

**Mempool Transaction Routing:** The `compare_validator_distance` function prioritizes peers with lower distances for transaction forwarding. [4](#0-3) 

**State-Sync Peer Selection:** The `choose_random_peers_by_distance_and_latency` function groups peers by distance in ascending order and selects from lower-distance groups first. [5](#0-4) 

**Consensus Observer Subscriptions:** The `sort_peers_by_subscription_optimality` function explicitly prioritizes distance over latency, stating "we want to avoid close but not up-to-date peers." [6](#0-5) 

5. The malicious peer can then selectively delay/drop transactions, provide stale state data, or delay consensus messages

**No Cross-Validation:** The system has no mechanism to detect conflicting distance reports from multiple peers or validate that a peer's claimed distance is consistent with network topology.

## Impact Explanation

This vulnerability enables **Medium severity** network degradation attacks:

- **Eclipse Attacks on Non-Validators:** Malicious peers can position themselves as preferred upstream peers for transaction propagation, state synchronization, and consensus observation
- **Selective Transaction Censorship:** By gaining mempool routing priority, attackers can delay or drop specific transactions before they reach validators
- **State Synchronization Delays:** Nodes may receive stale or incorrect data from attackers claiming low distance
- **Privacy Leaks:** Attackers gain visibility into transaction flow and network topology by becoming preferred peers

However, this does NOT reach Critical or High severity because:
- Validator consensus remains unaffected (BFT protocols don't rely on distance metrics)
- No direct fund loss or protocol safety violations
- Honest peers can eventually detect issues through timeout mechanisms
- Multiple peer redundancy provides some resilience

## Likelihood Explanation

**High Likelihood:**
- Any network peer can launch this attack without special privileges
- No validator collusion required
- Simple to execute: just return false distance values in monitoring responses
- Difficult to detect: no cross-validation or anomaly detection exists
- Multiple attackers can coordinate to eclipse specific targets

The attack is particularly effective because the distance metric is used across multiple critical subsystems, amplifying the impact of a single false value.

## Recommendation

Implement multi-layered validation and cross-checking:

1. **Add Topology-Based Validation:** Track the distance claims from each peer's connected peers and detect inconsistencies
2. **Implement Distance Bounds Checking:** Validate that a peer's claimed distance is consistent with its role and network connections
3. **Add Reputation Scoring:** Downgrade peers whose distance claims are inconsistent with observed behavior
4. **Implement Cross-Peer Verification:** Compare distance reports from multiple peers to detect outliers

Example fix for enhanced validation:

```rust
// In network_info.rs, enhance validation for distance >= 2
distance_from_validators => {
    // Check if distance is within bounds
    if distance_from_validators > MAX_DISTANCE_FROM_VALIDATORS {
        return false;
    }
    
    // For non-validator roles, enforce minimum distance based on network
    let min_expected_distance = match (self.base_config.role, network_id) {
        (RoleType::Validator, NetworkId::Public) => 2,
        (RoleType::FullNode, NetworkId::Public) => {
            if peer_metadata.get_connection_metadata().role.is_vfn() {
                1 // VFN on public network
            } else {
                2 // PFN on public network
            }
        },
        _ => 0,
    };
    
    distance_from_validators >= min_expected_distance
}
```

Additionally, implement cross-validation by tracking distance reports over time and flagging peers whose reported distances deviate significantly from their peers.

## Proof of Concept

```rust
// Malicious peer implementation demonstrating the attack
use aptos_peer_monitoring_service_types::{
    response::{NetworkInformationResponse, ConnectionMetadata},
};

// Attacker at actual distance 10 reports distance 2
fn create_malicious_response() -> NetworkInformationResponse {
    NetworkInformationResponse {
        connected_peers: BTreeMap::new(), // Empty or fabricated
        distance_from_validators: 2, // FALSE: actual distance is 10+
    }
}

// This response passes validation because distance >= 2 has no checks
// The attacker gains priority in:
// 1. Mempool transaction routing (compare_validator_distance)
// 2. State-sync peer selection (choose_random_peers_by_distance_and_latency)  
// 3. Consensus observer subscriptions (sort_peers_by_subscription_optimality)

// Impact: The attacker becomes a preferred upstream peer and can:
// - Selectively delay/drop transactions
// - Provide stale state data
// - Monitor transaction patterns (privacy leak)
// - Eclipse victim nodes from honest peers
```

**Notes:**
The vulnerability exists because distance validation relies solely on role-based checks for values 0-1, with no verification for distance ≥ 2. The system assumes peers honestly report their distance, but provides no cross-validation mechanism to detect lies or inconsistencies. This breaks the implicit trust model where routing decisions assume accurate distance metrics.

### Citations

**File:** peer-monitoring-service/types/src/response.rs (L51-55)
```rust
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
pub struct NetworkInformationResponse {
    pub connected_peers: BTreeMap<PeerNetworkId, ConnectionMetadata>, // Connected peers
    pub distance_from_validators: u64, // The distance of the peer from the validator set
}
```

**File:** peer-monitoring-service/server/src/lib.rs (L296-340)
```rust
/// Returns the distance from the validators using the given base config
/// and the peers and metadata information.
fn get_distance_from_validators(
    base_config: &BaseConfig,
    peers_and_metadata: Arc<PeersAndMetadata>,
) -> u64 {
    // Get the connected peers and metadata
    let connected_peers_and_metadata = match peers_and_metadata.get_connected_peers_and_metadata() {
        Ok(connected_peers_and_metadata) => connected_peers_and_metadata,
        Err(error) => {
            warn!(LogSchema::new(LogEntry::PeerMonitoringServiceError).error(&error.into()));
            return MAX_DISTANCE_FROM_VALIDATORS;
        },
    };

    // If we're a validator and we have active validator peers, we're in the validator set.
    // TODO: figure out if we need to deal with validator set forks here.
    if base_config.role.is_validator() {
        for peer_metadata in connected_peers_and_metadata.values() {
            if peer_metadata.get_connection_metadata().role.is_validator() {
                return 0;
            }
        }
    }

    // Otherwise, go through our peers, find the min, and return a distance relative to the min
    let mut min_peer_distance_from_validators = MAX_DISTANCE_FROM_VALIDATORS;
    for peer_metadata in connected_peers_and_metadata.values() {
        if let Some(ref latest_network_info_response) = peer_metadata
            .get_peer_monitoring_metadata()
            .latest_network_info_response
        {
            min_peer_distance_from_validators = min(
                min_peer_distance_from_validators,
                latest_network_info_response.distance_from_validators,
            );
        }
    }

    // We're one hop away from the peer
    min(
        MAX_DISTANCE_FROM_VALIDATORS,
        min_peer_distance_from_validators + 1,
    )
}
```

**File:** peer-monitoring-service/client/src/peer_states/network_info.rs (L116-154)
```rust
        // Sanity check the response depth from the peer metadata
        let network_id = peer_network_id.network_id();
        let is_valid_depth = match network_info_response.distance_from_validators {
            0 => {
                // Verify the peer is a validator and has the correct network id
                let peer_is_validator = peer_metadata.get_connection_metadata().role.is_validator();
                let peer_has_correct_network = match self.base_config.role {
                    RoleType::Validator => network_id.is_validator_network(), // We're a validator
                    RoleType::FullNode => network_id.is_vfn_network(),        // We're a VFN
                };
                peer_is_validator && peer_has_correct_network
            },
            1 => {
                // Verify the peer is a VFN and has the correct network id
                let peer_is_vfn = peer_metadata.get_connection_metadata().role.is_vfn();
                let peer_has_correct_network = match self.base_config.role {
                    RoleType::Validator => network_id.is_vfn_network(), // We're a validator
                    RoleType::FullNode => network_id.is_public_network(), // We're a VFN or PFN
                };
                peer_is_vfn && peer_has_correct_network
            },
            distance_from_validators => {
                // The distance must be less than or equal to the max
                distance_from_validators <= MAX_DISTANCE_FROM_VALIDATORS
            },
        };

        // If the depth did not pass our sanity checks, handle a failure
        if !is_valid_depth {
            warn!(LogSchema::new(LogEntry::NetworkInfoRequest)
                .event(LogEvent::InvalidResponse)
                .peer(peer_network_id)
                .message(&format!(
                    "Peer returned invalid depth from validators: {}",
                    network_info_response.distance_from_validators
                )));
            self.handle_request_failure();
            return;
        }
```

**File:** mempool/src/shared_mempool/priority.rs (L613-639)
```rust
/// Compares the validator distance for the given pair of monitoring metadata.
/// The peer with the lowest validator distance is prioritized.
fn compare_validator_distance(
    monitoring_metadata_a: &Option<&PeerMonitoringMetadata>,
    monitoring_metadata_b: &Option<&PeerMonitoringMetadata>,
) -> Ordering {
    // Get the validator distance from the monitoring metadata
    let validator_distance_a = get_distance_from_validators(monitoring_metadata_a);
    let validator_distance_b = get_distance_from_validators(monitoring_metadata_b);

    // Compare the distances
    match (validator_distance_a, validator_distance_b) {
        (Some(validator_distance_a), Some(validator_distance_b)) => {
            // Prioritize the peer with the lowest validator distance
            validator_distance_a.cmp(&validator_distance_b).reverse()
        },
        (Some(_), None) => {
            Ordering::Greater // Prioritize the peer with a validator distance
        },
        (None, Some(_)) => {
            Ordering::Less // Prioritize the peer with a validator distance
        },
        (None, None) => {
            Ordering::Equal // Neither peer has a validator distance
        },
    }
}
```

**File:** state-sync/aptos-data-client/src/utils.rs (L26-64)
```rust
pub fn choose_random_peers_by_distance_and_latency(
    peers: HashSet<PeerNetworkId>,
    peers_and_metadata: Arc<PeersAndMetadata>,
    num_peers_to_choose: usize,
) -> HashSet<PeerNetworkId> {
    // Group peers and latency weights by validator distance, i.e., distance -> [(peer, latency weight)]
    let mut peers_and_latencies_by_distance = BTreeMap::new();
    for peer in peers {
        if let Some((distance, latency)) =
            get_distance_and_latency_for_peer(&peers_and_metadata, peer)
        {
            let latency_weight = convert_latency_to_weight(latency);
            peers_and_latencies_by_distance
                .entry(distance)
                .or_insert_with(Vec::new)
                .push((peer, latency_weight));
        }
    }

    // Select the peers by distance and latency weights. Note: BTreeMaps are
    // sorted by key, so the entries will be sorted by distance in ascending order.
    let mut selected_peers = HashSet::new();
    for (_, peers_and_latencies) in peers_and_latencies_by_distance {
        // Select the peers by latency weights
        let num_peers_remaining = num_peers_to_choose.saturating_sub(selected_peers.len()) as u64;
        let peers = choose_random_peers_by_weight(num_peers_remaining, peers_and_latencies);

        // Add the peers to the entire set
        selected_peers.extend(peers);

        // If we have selected enough peers, return early
        if selected_peers.len() >= num_peers_to_choose {
            return selected_peers;
        }
    }

    // Return the selected peers
    selected_peers
}
```

**File:** consensus/src/consensus_observer/observer/subscription_utils.rs (L275-312)
```rust
/// Sorts the peers by subscription optimality (in descending order of
/// optimality). This requires: (i) sorting the peers by distance from the
/// validator set and ping latency (lower values are more optimal); and (ii)
/// filtering out peers that don't support consensus observer.
///
/// Note: we prioritize distance over latency as we want to avoid close
/// but not up-to-date peers. If peers don't have sufficient metadata
/// for sorting, they are given a lower priority.
pub fn sort_peers_by_subscription_optimality(
    peers_and_metadata: &HashMap<PeerNetworkId, PeerMetadata>,
) -> Vec<PeerNetworkId> {
    // Group peers and latencies by validator distance, i.e., distance -> [(peer, latency)]
    let mut unsupported_peers = Vec::new();
    let mut peers_and_latencies_by_distance = BTreeMap::new();
    for (peer_network_id, peer_metadata) in peers_and_metadata {
        // Verify that the peer supports consensus observer
        if !supports_consensus_observer(peer_metadata) {
            unsupported_peers.push(*peer_network_id);
            continue; // Skip the peer
        }

        // Get the distance and latency for the peer
        let distance = get_distance_for_peer(peer_network_id, peer_metadata);
        let latency = get_latency_for_peer(peer_network_id, peer_metadata);

        // If the distance is not found, use the maximum distance
        let distance =
            distance.unwrap_or(aptos_peer_monitoring_service_types::MAX_DISTANCE_FROM_VALIDATORS);

        // If the latency is not found, use a large latency
        let latency = latency.unwrap_or(MAX_PING_LATENCY_SECS);

        // Add the peer and latency to the distance group
        peers_and_latencies_by_distance
            .entry(distance)
            .or_insert_with(Vec::new)
            .push((*peer_network_id, OrderedFloat(latency)));
    }
```
