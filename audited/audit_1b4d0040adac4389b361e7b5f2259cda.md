# Audit Report

## Title
Permanent Permit Exhaustion DoS in BoundedExecutor Due to Missing Timeout Mechanism for Blocking Tasks

## Summary
The `BoundedExecutor::spawn_blocking()` method lacks any timeout or cancellation mechanism for blocking tasks. If blocking tasks hang indefinitely due to bugs, deadlocks, or I/O issues, their permits are permanently lost, eventually exhausting all available permits and causing a complete Denial of Service. This critically affects the peer monitoring service used by validator nodes.

## Finding Description

The `BoundedExecutor` is designed to limit concurrent task execution through a semaphore-based permit system. [1](#0-0) 

The `spawn_blocking()` method acquires a permit and wraps the blocking function with `function_with_permit()`, which only releases the permit when the function completes normally. [2](#0-1) 

**The Critical Flaw**: There is no timeout mechanism, no cancellation mechanism, and no way to recover permits from hung tasks. Once a blocking task hangs for any reason (deadlock, infinite loop, blocking I/O that never completes, or bugs in storage operations), its permit is permanently lost.

**Real-World Usage in Peer Monitoring Service**: The peer monitoring service creates a `BoundedExecutor` with a capacity based on `max_concurrent_requests` and uses `spawn_blocking()` to process incoming peer requests. [3](#0-2) 

Each peer request is processed in a blocking task that performs storage operations and peer metadata queries. [4](#0-3) 

The `Handler::call()` method invoked in these blocking tasks performs various operations including storage reads. [5](#0-4) 

**Attack Scenario**:
1. Network peers send peer monitoring requests to a validator node
2. These requests are processed in blocking tasks via `BoundedExecutor`
3. If any storage operation, lock acquisition, or I/O operation blocks indefinitely (due to bugs, race conditions, or resource contention), the blocking task never completes
4. The permit for that task is permanently lost (no timeout to reclaim it)
5. Repeated occurrences exhaust all available permits
6. Once all permits are consumed, the peer monitoring service stops accepting new requests
7. This constitutes a permanent DoS until the validator node is restarted

**Invariant Violation**: This breaks the **Resource Limits** invariant (#9) - operations should respect computational and resource limits with proper bounds and recovery mechanisms. The absence of timeout protection allows unbounded resource consumption.

## Impact Explanation

**Severity: High** (per Aptos bug bounty criteria: "Validator node slowdowns" and "Significant protocol violations")

1. **Validator Node Service Degradation**: The peer monitoring service becomes completely unresponsive, degrading validator monitoring capabilities
2. **Permanent DoS**: Unlike temporary service disruptions, this DoS persists until manual node restart
3. **Amplification Effect**: Any transient bug or rare condition that causes temporary blocking becomes amplified into permanent permit loss
4. **No Recovery Mechanism**: The design provides no way to detect or recover from hung blocking tasks
5. **Affects Critical Infrastructure**: Peer monitoring is used by validators to monitor network health and peer connectivity

While this doesn't directly compromise consensus safety or cause fund loss, it significantly degrades validator node operations and is a critical availability issue.

## Likelihood Explanation

**Likelihood: Medium to High**

The likelihood is higher than might initially appear because:

1. **Multiple Trigger Conditions**: Any of the following can cause blocking tasks to hang:
   - Bugs in storage layer causing deadlocks or infinite loops
   - Lock contention under high load
   - Network I/O timeouts in underlying operations
   - Database query issues or corruption
   - Race conditions in peer metadata management

2. **No Defensive Programming**: The complete absence of timeout protection means even rare edge cases have permanent consequences

3. **Cumulative Effect**: Even infrequent hangs accumulate over time, gradually exhausting permits

4. **External Trigger**: Network peers can send requests that exercise different code paths, potentially triggering edge cases

The exact exploitability depends on whether there are exploitable bugs in the storage layer or peer metadata system that cause indefinite blocking. However, the design flaw itself is certain - any such bug, whether malicious or accidental, results in permanent DoS.

## Recommendation

Implement a timeout mechanism for blocking tasks in `BoundedExecutor::spawn_blocking()`:

```rust
pub async fn spawn_blocking<F, R>(&self, func: F) -> JoinHandle<R>
where
    F: FnOnce() -> R + Send + 'static,
    R: Send + 'static,
{
    let permit = self.acquire_permit().await;
    let handle = self.executor
        .spawn_blocking(function_with_permit(func, permit));
    
    // Wrap with timeout monitoring
    let timeout_duration = Duration::from_secs(60); // Configurable
    self.executor.spawn(async move {
        match tokio::time::timeout(timeout_duration, handle).await {
            Ok(result) => result,
            Err(_) => {
                // Log timeout and return error
                error!("Blocking task exceeded timeout");
                Err(JoinError::from(...))
            }
        }
    })
}
```

Additionally:
1. Add metrics to track blocking task duration and detect hangs
2. Implement a watchdog mechanism to periodically check for long-running blocking tasks
3. Add configuration options for timeout durations per use case
4. Consider using `tokio::time::timeout()` to wrap storage operations themselves

## Proof of Concept

```rust
#[cfg(test)]
mod test {
    use super::*;
    use std::time::Duration;
    use tokio::runtime::Runtime;
    use std::sync::{Arc, atomic::{AtomicBool, Ordering}};

    #[test]
    fn test_blocking_task_permit_exhaustion() {
        let rt = Runtime::new().unwrap();
        let executor = rt.handle().clone();
        
        // Create BoundedExecutor with capacity of 2
        let bounded_executor = BoundedExecutor::new(2, executor);
        
        let hung_flag = Arc::new(AtomicBool::new(false));
        let hung_flag_clone = hung_flag.clone();
        
        // Spawn two blocking tasks that never complete
        let _handle1 = rt.block_on(bounded_executor.spawn_blocking(move || {
            // Simulate a hung task (infinite loop)
            loop {
                std::thread::sleep(Duration::from_secs(1));
            }
        }));
        
        let _handle2 = rt.block_on(bounded_executor.spawn_blocking(move || {
            // Another hung task
            loop {
                std::thread::sleep(Duration::from_secs(1));
            }
        }));
        
        // Wait a bit for tasks to start
        std::thread::sleep(Duration::from_millis(100));
        
        // Try to spawn a third task - this should block forever
        // because all permits are held by hung tasks
        let result = std::panic::catch_unwind(|| {
            rt.block_on(async {
                tokio::time::timeout(
                    Duration::from_secs(2),
                    bounded_executor.spawn_blocking(|| {
                        hung_flag_clone.store(true, Ordering::SeqCst);
                        println!("Third task started");
                    })
                ).await
            })
        });
        
        // Verify that the third task never started due to permit exhaustion
        assert!(!hung_flag.load(Ordering::SeqCst), 
                "Third task should not have started - permits exhausted");
        
        // This demonstrates permanent DoS: no new tasks can be spawned
        // until the node is restarted
    }
}
```

**Notes**

This vulnerability is a **design flaw** rather than a traditional exploit. The absence of defensive programming (timeout/cancellation) in `BoundedExecutor::spawn_blocking()` means that any condition causing blocking tasks to hang results in permanent permit loss and DoS. While the peer monitoring service is the primary affected component identified, any service using `BoundedExecutor::spawn_blocking()` is vulnerable to this issue. The vulnerability amplifies other bugs (deadlocks, infinite loops, I/O hangs) from transient issues into permanent DoS conditions requiring node restarts.

### Citations

**File:** crates/bounded-executor/src/executor.rs (L70-80)
```rust
    /// Like [`BoundedExecutor::spawn`] but spawns the given closure onto a
    /// blocking task (see [`tokio::task::spawn_blocking`] for details).
    pub async fn spawn_blocking<F, R>(&self, func: F) -> JoinHandle<R>
    where
        F: FnOnce() -> R + Send + 'static,
        R: Send + 'static,
    {
        let permit = self.acquire_permit().await;
        self.executor
            .spawn_blocking(function_with_permit(func, permit))
    }
```

**File:** crates/bounded-executor/src/executor.rs (L111-124)
```rust
fn function_with_permit<F, R>(
    func: F,
    permit: OwnedSemaphorePermit,
) -> impl FnOnce() -> R + Send + 'static
where
    F: FnOnce() -> R + Send + 'static,
    R: Send + 'static,
{
    move || {
        let ret = func();
        drop(permit);
        ret
    }
}
```

**File:** peer-monitoring-service/server/src/lib.rs (L66-69)
```rust
        let bounded_executor = BoundedExecutor::new(
            node_config.peer_monitoring_service.max_concurrent_requests as usize,
            executor,
        );
```

**File:** peer-monitoring-service/server/src/lib.rs (L105-120)
```rust
            self.bounded_executor
                .spawn_blocking(move || {
                    let response = Handler::new(
                        base_config,
                        peers_and_metadata,
                        start_time,
                        storage,
                        time_service,
                    )
                    .call(
                        peer_network_id.network_id(),
                        peer_monitoring_service_request,
                    );
                    log_monitoring_service_response(&response);
                    response_sender.send(response);
                })
```

**File:** peer-monitoring-service/server/src/lib.rs (L259-267)
```rust
    fn get_node_information(&self) -> Result<PeerMonitoringServiceResponse, Error> {
        // Get the node information
        let build_information = aptos_build_info::get_build_information();
        let current_time: Instant = self.time_service.now();
        let uptime = current_time.duration_since(self.start_time);
        let (highest_synced_epoch, highest_synced_version) =
            self.storage.get_highest_synced_epoch_and_version()?;
        let ledger_timestamp_usecs = self.storage.get_ledger_timestamp_usecs()?;
        let lowest_available_version = self.storage.get_lowest_available_version()?;
```
