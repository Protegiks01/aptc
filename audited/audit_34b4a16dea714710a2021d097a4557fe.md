# Audit Report

## Title
Index Integrity Violation in Transaction Pruner - Dangling Indices Cause API Crashes

## Summary
The `TransactionPruner` in AptosDB fails to prune `OrderedTransactionByAccountSchema` index entries when `internal_indexer_db` is `None`, while still pruning the underlying transaction data. This creates dangling index entries that point to non-existent transactions, causing API crashes and incorrect query results in nodes configured without storage sharding.

## Finding Description
The vulnerability exists in the conditional index pruning logic within `TransactionPruner::prune()`. When transactions are committed without storage sharding enabled, `OrderedTransactionByAccountSchema` index entries are created to map `(account_address, sequence_number)` to transaction versions. However, during pruning, these indices are only deleted when an internal indexer database is configured. [1](#0-0) 

The pruning logic shows that:
1. Primary transaction data (`TransactionSchema`) is always pruned (lines 47-51)
2. Other indices (`TransactionByHashSchema`, `TransactionSummariesByAccountSchema`) are always pruned (lines 43-46, 52-53)
3. **But** `OrderedTransactionByAccountSchema` is only pruned if `internal_indexer_db.is_some()` (lines 58-72)

When `internal_indexer_db` is `None`, the entire conditional block is skipped, leaving `OrderedTransactionByAccountSchema` entries dangling after their corresponding transactions are deleted.

The index entries are written during transaction commit: [2](#0-1) 

These entries are stored in the transaction database: [3](#0-2) 

When the API queries these dangling indices, it retrieves transaction versions that no longer exist: [4](#0-3) 

Attempting to fetch the transaction at the returned version fails: [5](#0-4) 

This causes the `get_account_transaction` API to crash: [6](#0-5) 

## Impact Explanation
This vulnerability qualifies as **High Severity** under the Aptos bug bounty criteria because it causes:
- **API crashes**: The `get_account_transaction` API fails with `NotFound` errors when querying pruned transactions
- **Validator node slowdowns**: Repeated crashes can degrade node performance
- **Protocol violation**: Breaks the database consistency invariant that indices must accurately reflect stored data

The issue affects nodes configured without storage sharding (non-default but supported configuration), particularly:
- Development/test nodes
- Private network nodes  
- Nodes providing account-based transaction APIs

## Likelihood Explanation
**Likelihood: Medium**

The vulnerability occurs automatically in affected configurations:
1. Node operator configures storage sharding disabled (`enable_storage_sharding = false`)
2. Node operator does not enable internal indexer (default: `internal_indexer_db = None`)
3. Pruner runs automatically based on configured prune window
4. Any API query for historical transactions by account triggers the crash

While this is not the default mainnet configuration (storage sharding is enforced there), the code explicitly supports non-sharded mode and provides APIs that depend on it working correctly. The bug represents a logic error where the pruner's behavior is inconsistent with the transaction commit path.

## Recommendation
Add unconditional pruning of `OrderedTransactionByAccountSchema` when `internal_indexer_db` is `None`. The index should be pruned to the same batch as the primary transaction data to maintain atomicity:

```rust
fn prune(&self, current_progress: Version, target_version: Version) -> Result<()> {
    let mut batch = SchemaBatch::new();
    let candidate_transactions =
        self.get_pruning_candidate_transactions(current_progress, target_version)?;
    self.ledger_db
        .transaction_db()
        .prune_transaction_by_hash_indices(
            candidate_transactions.iter().map(|(_, txn)| txn.hash()),
            &mut batch,
        )?;
    self.ledger_db.transaction_db().prune_transactions(
        current_progress,
        target_version,
        &mut batch,
    )?;
    self.transaction_store
        .prune_transaction_summaries_by_account(&candidate_transactions, &mut batch)?;
    
    if let Some(indexer_db) = self.internal_indexer_db.as_ref() {
        if indexer_db.transaction_enabled() {
            let mut index_batch = SchemaBatch::new();
            self.transaction_store
                .prune_transaction_by_account(&candidate_transactions, &mut index_batch)?;
            index_batch.put::<InternalIndexerMetadataSchema>(
                &IndexerMetadataKey::TransactionPrunerProgress,
                &IndexerMetadataValue::Version(target_version),
            )?;
            indexer_db.get_inner_db_ref().write_schemas(index_batch)?;
        } else {
            self.transaction_store
                .prune_transaction_by_account(&candidate_transactions, &mut batch)?;
        }
    } else {
        // FIX: Prune OrderedTransactionByAccountSchema even when indexer is disabled
        self.transaction_store
            .prune_transaction_by_account(&candidate_transactions, &mut batch)?;
    }
    
    batch.put::<DbMetadataSchema>(
        &DbMetadataKey::TransactionPrunerProgress,
        &DbMetadataValue::Version(target_version),
    )?;
    self.ledger_db.transaction_db().write_schemas(batch)
}
```

## Proof of Concept

```rust
#[test]
fn test_transaction_pruner_index_integrity() {
    use tempfile::TempDir;
    
    // Create AptosDB without storage sharding (vulnerable config)
    let tmp_dir = TempDir::new().unwrap();
    let aptos_db = AptosDB::new_for_test(tmp_dir.path());
    let transaction_store = &aptos_db.transaction_store;
    
    // Create and store signed user transactions
    let sender = AccountAddress::random();
    let txns: Vec<Transaction> = (0..10)
        .map(|i| {
            let signed_txn = generate_signed_txn(sender, i);
            Transaction::UserTransaction(signed_txn)
        })
        .collect();
    
    // Write transactions with indexing (skip_index=false)
    let mut batch = SchemaBatch::new();
    for (version, txn) in txns.iter().enumerate() {
        aptos_db.ledger_db.transaction_db()
            .put_transaction(version as u64, txn, false, &mut batch)
            .unwrap();
    }
    aptos_db.ledger_db.transaction_db().write_schemas(batch).unwrap();
    
    // Verify index exists before pruning
    let version_before = transaction_store
        .get_account_ordered_transaction_version(sender, 0, 10)
        .unwrap();
    assert_eq!(version_before, Some(0));
    
    // Create pruner without internal_indexer_db (None)
    let pruner = LedgerPrunerManager::new(
        Arc::clone(&aptos_db.ledger_db),
        LedgerPrunerConfig {
            enable: true,
            prune_window: 0,
            batch_size: 10,
            user_pruning_window_offset: 0,
        },
        None, // internal_indexer_db is None
    );
    
    // Run pruner to delete transactions 0-4
    pruner.wake_and_wait_pruner(5).unwrap();
    
    // BUG: Index entry still exists (dangling)
    let version_after = transaction_store
        .get_account_ordered_transaction_version(sender, 0, 10)
        .unwrap();
    assert_eq!(version_after, Some(0)); // Index still points to version 0
    
    // But transaction at version 0 is deleted
    let txn_result = aptos_db.ledger_db.transaction_db()
        .get_transaction(0);
    assert!(txn_result.is_err()); // NotFound error
    
    // This breaks API consistency - index exists but data doesn't
    // In production, get_account_transaction would crash here
}
```

## Notes

This vulnerability demonstrates a critical database consistency violation where the pruner's behavior diverges based on configuration, creating an inconsistent state between indices and primary data. The issue is particularly concerning because:

1. **Silent corruption**: The system continues operating with corrupted indices rather than failing fast
2. **API reliability**: Production nodes serving account-based APIs become unreliable after pruning begins
3. **Data integrity**: Violates fundamental database invariant that indices must accurately reflect stored data

The fix is straightforward but critical: ensure `OrderedTransactionByAccountSchema` is always pruned when the corresponding transaction data is pruned, regardless of internal indexer configuration.

### Citations

**File:** storage/aptosdb/src/pruner/ledger_pruner/transaction_pruner.rs (L58-72)
```rust
        if let Some(indexer_db) = self.internal_indexer_db.as_ref() {
            if indexer_db.transaction_enabled() {
                let mut index_batch = SchemaBatch::new();
                self.transaction_store
                    .prune_transaction_by_account(&candidate_transactions, &mut index_batch)?;
                index_batch.put::<InternalIndexerMetadataSchema>(
                    &IndexerMetadataKey::TransactionPrunerProgress,
                    &IndexerMetadataValue::Version(target_version),
                )?;
                indexer_db.get_inner_db_ref().write_schemas(index_batch)?;
            } else {
                self.transaction_store
                    .prune_transaction_by_account(&candidate_transactions, &mut batch)?;
            }
        }
```

**File:** storage/aptosdb/src/ledger_db/transaction_db.rs (L56-60)
```rust
    pub(crate) fn get_transaction(&self, version: Version) -> Result<Transaction> {
        self.db
            .get::<TransactionSchema>(&version)?
            .ok_or_else(|| AptosDbError::NotFound(format!("Txn {version}")))
    }
```

**File:** storage/aptosdb/src/ledger_db/transaction_db.rs (L137-146)
```rust
        if !skip_index {
            if let Some(txn) = transaction.try_as_signed_user_txn() {
                if let ReplayProtector::SequenceNumber(seq_num) = txn.replay_protector() {
                    batch.put::<OrderedTransactionByAccountSchema>(
                        &(txn.sender(), seq_num),
                        &version,
                    )?;
                }
            }
        }
```

**File:** storage/aptosdb/src/db_options.rs (L78-86)
```rust
pub(super) fn transaction_db_column_families() -> Vec<ColumnFamilyName> {
    vec![
        /* empty cf */ DEFAULT_COLUMN_FAMILY_NAME,
        DB_METADATA_CF_NAME,
        TRANSACTION_CF_NAME,
        ORDERED_TRANSACTION_BY_ACCOUNT_CF_NAME,
        TRANSACTION_SUMMARIES_BY_ACCOUNT_CF_NAME,
        TRANSACTION_BY_HASH_CF_NAME,
    ]
```

**File:** storage/aptosdb/src/transaction_store/mod.rs (L36-52)
```rust
    pub fn get_account_ordered_transaction_version(
        &self,
        address: AccountAddress,
        sequence_number: u64,
        ledger_version: Version,
    ) -> Result<Option<Version>> {
        if let Some(version) =
            self.ledger_db
                .transaction_db_raw()
                .get::<OrderedTransactionByAccountSchema>(&(address, sequence_number))?
        {
            if version <= ledger_version {
                return Ok(Some(version));
            }
        }
        Ok(None)
    }
```

**File:** storage/aptosdb/src/db/aptosdb_reader.rs (L150-162)
```rust
        gauged_api("get_account_transaction", || {
            ensure!(
                !self.state_kv_db.enabled_sharding(),
                "This API is not supported with sharded DB"
            );
            self.transaction_store
                .get_account_ordered_transaction_version(address, seq_num, ledger_version)?
                .map(|txn_version| {
                    self.get_transaction_with_proof(txn_version, ledger_version, include_events)
                })
                .transpose()
        })
    }
```
