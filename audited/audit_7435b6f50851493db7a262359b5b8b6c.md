# Audit Report

## Title
DKG Range Proof Verification Panic Due to Missing Length Validation Causes Validator Node Crashes

## Summary
The `verify()` function in the DeKART univariate range proof implementation fails to validate that proof vector lengths match the expected `ell` parameter before performing multi-scalar multiplication (MSM) operations. A Byzantine validator can craft a DKG transcript with mismatched vector lengths, causing verifying validators to panic and crash during consensus execution.

## Finding Description

The range proof verification function in the DKG system contains a critical missing validation that allows panics during verification. The `Proof` struct contains vectors `c` and `c_hat` that are commented as "of size ℓ" but this constraint is never enforced. [1](#0-0) 

The struct uses derived `CanonicalDeserialize` which deserializes arbitrary-length vectors without validation against the expected `ell` parameter. During verification, the function performs MSM operations without validating vector lengths: [2](#0-1) 

This MSM call uses `&self.c` (arbitrary length from untrusted input) and `&vk.powers_of_two[..ell]` (exactly `ell` elements). If these lengths differ, the arkworks MSM implementation returns an error, which triggers a panic via `.expect()`.

Additional panic points exist from array indexing operations and `.unwrap()` calls: [3](#0-2) [4](#0-3) 

**Attack Path:**

1. Byzantine validator creates malicious DKG transcript with range proof vectors where `c.len() ≠ ell` or `c_hat.len() ≠ ell`
2. Transcript is serialized and submitted as a ValidatorTransaction::DKGResult
3. Honest validators deserialize the transcript (no length validation during deserialization)
4. VM processes the DKG result transaction: [5](#0-4) 

5. Transcript verification calls the range proof verification: [6](#0-5) [7](#0-6) 

6. MSM fails due to length mismatch → panic → validator node crashes

The panic propagates to the global panic handler which terminates the process: [8](#0-7) 

Since DKG range proof verification is not in the bytecode verifier or deserializer, the panic causes `process::exit(12)`, crashing the validator node.

## Impact Explanation

**Severity: High**

This vulnerability aligns with the Aptos bug bounty HIGH severity category for "API Crashes" and "Validator Node Slowdowns":

- **Validator Node Crashes**: Each validator processing the malicious transcript will panic and crash, requiring manual restart
- **Consensus Disruption**: Multiple validator crashes can cause consensus delays or temporary liveness loss
- **Deterministic Failure**: All honest validators crash identically when processing the same malicious block containing the transcript
- **Byzantine Fault Tolerance Violation**: A single Byzantine validator (well within the <1/3 BFT threshold) can crash honest validators

This breaks the consensus liveness guarantee that the system should maintain progress under <1/3 Byzantine validators. The panics also violate the principle that cryptographic verification should return errors rather than crash the process.

While this causes validator node crashes, it differs from out-of-scope "Network DoS attacks" because it exploits a protocol bug (missing validation) through normal consensus mechanisms, not external network-level attacks.

## Likelihood Explanation

**Likelihood: High**

- **Low Barrier to Attack**: Any validator can create and submit DKG transcripts during epoch transitions as part of normal DKG protocol operations
- **Simple Exploitation**: Crafting a malicious proof only requires modifying vector lengths before serialization - no complex cryptographic or timing manipulation needed
- **No Upstream Detection**: The vulnerability exists in core verification logic with no prior validation that would catch malformed proofs
- **Guaranteed Impact**: The attack deterministically crashes all validators that process the malicious transcript
- **Regular Opportunity**: DKG runs during every epoch transition, providing recurring attack windows

The attack requires validator status, which is within the Byzantine threat model (<1/3 Byzantine validators) that Aptos consensus is designed to tolerate.

## Recommendation

Add explicit length validation before performing any operations on proof vectors:

```rust
fn verify(
    &self,
    vk: &Self::VerificationKey,
    n: usize,
    ell: usize,
    comm: &Self::Commitment,
) -> anyhow::Result<()> {
    let mut fs_t = merlin::Transcript::new(Self::DST);

    ensure!(
        ell <= vk.max_ell,
        "ell (got {}) must be ≤ max_ell (which is {})",
        ell,
        vk.max_ell
    );
    
    // ADD THESE VALIDATIONS:
    ensure!(
        self.c.len() == ell,
        "proof.c length ({}) must equal ell ({})",
        self.c.len(),
        ell
    );
    ensure!(
        self.c_hat.len() == ell,
        "proof.c_hat length ({}) must equal ell ({})",
        self.c_hat.len(),
        ell
    );

    // ... rest of verification
}
```

Replace all `.expect()` and `.unwrap()` calls in verification functions with proper error returns using `?` operator. Consider adding similar length validations in the `Proof` deserialization logic for defense in depth.

## Proof of Concept

```rust
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    #[should_panic(expected = "Failed to compute msm")]
    fn test_malformed_proof_length_causes_panic() {
        // Setup DKG parameters with ell = 8
        let ell = 8;
        let (pk, vk) = Proof::<Bls12_381>::setup(
            10, // max_n
            ell,
            GroupGenerators::default(),
            &mut rand::thread_rng(),
        );
        
        // Create valid commitment
        let values: Vec<_> = (0..10).map(|_| Scalar::rand(&mut rand::thread_rng())).collect();
        let r = Scalar::rand(&mut rand::thread_rng());
        let comm = Proof::commit_with_randomness(&pk, &values, &r);
        
        // Create malformed proof with wrong vector lengths
        let mut malformed_proof = Proof::prove(&pk, &values, ell, &comm, &r, &mut rand::thread_rng());
        
        // Truncate vectors to trigger length mismatch
        malformed_proof.c.truncate(ell - 2);  // c.len() = 6, but ell = 8
        
        // This should panic with "Failed to compute msm"
        malformed_proof.verify(&vk, 10, ell, &comm).unwrap();
    }
}
```

The test demonstrates that a proof with mismatched vector lengths will panic during verification, confirming the vulnerability. In production, this would crash validator nodes processing malicious DKG transcripts.

### Citations

**File:** crates/aptos-dkg/src/range_proofs/dekart_univariate.rs (L31-36)
```rust
#[derive(CanonicalSerialize, CanonicalDeserialize, Debug, Clone, PartialEq, Eq)]
pub struct Proof<E: Pairing> {
    d: E::G1,                // commitment to h(X) = \sum_{j=0}^{\ell-1} beta_j h_j(X)
    c: Vec<E::G1Affine>,     // of size \ell
    c_hat: Vec<E::G2Affine>, // of size \ell
}
```

**File:** crates/aptos-dkg/src/range_proofs/dekart_univariate.rs (L580-582)
```rust
        let commitment_recomputed: E::G1 =
            VariableBaseMSM::msm(&self.c, &vk.powers_of_two[..ell]).expect("Failed to compute msm");
        ensure!(comm.0 == commitment_recomputed);
```

**File:** crates/aptos-dkg/src/range_proofs/dekart_univariate.rs (L599-608)
```rust
        let h_check = E::multi_pairing(
            (0..ell)
                .map(|j| self.c[j] * betas[j]) // E::G1
                .chain(once(-self.d)) // add -d
                .collect::<Vec<_>>(), // collect into Vec<E::G1>
            (0..ell)
                .map(|j| self.c_hat[j] - vk.tau_2) // E::G2
                .chain(once(vk.vanishing_com)) // add vanishing commitment
                .collect::<Vec<_>>(), // collect into Vec<E::G2>
        );
```

**File:** crates/aptos-dkg/src/range_proofs/dekart_univariate.rs (L614-617)
```rust
        let g1_comb = VariableBaseMSM::msm(&self.c, &alphas).unwrap();

        // Compute MSM in G2: sum_j (alphas[j] * proof.c_hat[j])
        let g2_comb = VariableBaseMSM::msm(&self.c_hat, &alphas).unwrap();
```

**File:** aptos-move/aptos-vm/src/validator_txns/dkg.rs (L104-112)
```rust
        // Deserialize transcript and verify it.
        let pub_params = DefaultDKG::new_public_params(&in_progress_session_state.metadata);
        let transcript = bcs::from_bytes::<<DefaultDKG as DKGTrait>::Transcript>(
            dkg_node.transcript_bytes.as_slice(),
        )
        .map_err(|_| Expected(TranscriptDeserializationFailed))?;

        DefaultDKG::verify_transcript(&pub_params, &transcript)
            .map_err(|_| Expected(TranscriptVerificationFailed))?;
```

**File:** types/src/dkg/real_dkg/mod.rs (L368-374)
```rust
        trx.main.verify(
            &params.pvss_config.wconfig,
            &params.pvss_config.pp,
            &spks,
            &all_eks,
            &aux,
        )?;
```

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcriptv2.rs (L532-539)
```rust
            if let Err(err) = self.sharing_proof.range_proof.verify(
                &pp.pk_range_proof.vk,
                sc.get_total_weight() * num_chunks_per_scalar::<E::ScalarField>(pp.ell) as usize,
                pp.ell as usize,
                &self.sharing_proof.range_proof_commitment,
            ) {
                bail!("Range proof batch verification failed: {:?}", err);
            }
```

**File:** crates/crash-handler/src/lib.rs (L48-57)
```rust
    // Do not kill the process if the panics happened at move-bytecode-verifier.
    // This is safe because the `state::get_state()` uses a thread_local for storing states. Thus the state can only be mutated to VERIFIER by the thread that's running the bytecode verifier.
    //
    // TODO: once `can_unwind` is stable, we should assert it. See https://github.com/rust-lang/rust/issues/92988.
    if state::get_state() == VMState::VERIFIER || state::get_state() == VMState::DESERIALIZER {
        return;
    }

    // Kill the process
    process::exit(12);
```
