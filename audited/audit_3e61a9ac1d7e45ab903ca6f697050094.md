# Audit Report

## Title
Event V2 Translation Race Condition Causes Silent Event Dropping in Indexer

## Summary

The `TokenMutation` event (and other V2 events) implementing `MoveEventV2Type` can be silently dropped from the event indexer when the event translator queries the **latest state** instead of the **state at the event's emission version**. This creates a race condition where valid events emitted at version N are lost from V1 event indices if their associated resources are deleted between version N and when the indexer processes them. [1](#0-0) 

## Finding Description

The vulnerability exists in the event V2 to V1 translation system used by the internal indexer. When a `TokenMutation` V2 event is processed, the translation engine attempts to convert it to a V1 event format for backward compatibility. However, the translator queries resource state using `latest_state_checkpoint_view()` rather than the state at the event's actual emission version. [2](#0-1) [3](#0-2) 

The `TokenMutationTranslator` fails when the token resource is not found in state: [4](#0-3) 

When translation fails, the indexer silently skips adding the event to V1 event indices: [5](#0-4) 

The critical issue is that the `version` variable is available in the processing loop but is **never passed** to the translation engine: [6](#0-5) 

The `EventV2Translator` trait signature does not include a version parameter: [7](#0-6) 

**Attack Scenario:**
1. User mints an NFT token at version 1000
2. User mutates token metadata at version 1005 (emits `TokenMutation` V2 event)
3. User burns the token at version 1006
4. Indexer processes the batch at version 1010, querying latest state
5. Token resource no longer exists at version 1010
6. Translation fails, `TokenMutation` event from version 1005 is dropped from V1 indices
7. API queries by event key will NOT return this event, even though it was valid when emitted
8. Transaction queries show the V2 event (untranslated), but event key queries return nothing

This breaks the invariant that **all events should be queryable** and creates **inconsistent API responses** where the same event appears in transaction queries but not in event key queries.

## Impact Explanation

This is a **Medium Severity** vulnerability under the Aptos bug bounty program criteria:

**"State inconsistencies requiring intervention"** - The indexer state becomes inconsistent with the ledger state. Events that exist in transaction outputs are missing from event indices, requiring manual database reconciliation or reindexing to fix.

**Limited API reliability impact:**
- Off-chain indexers querying by event key miss critical events
- NFT marketplaces tracking token mutations may miss mutation events for subsequently burned tokens
- Audit trails and compliance systems relying on complete event histories are incomplete
- Different API endpoints return inconsistent results for the same data

The events remain in the ledger and are accessible via transaction version queries, preventing this from being Critical severity. However, the inconsistency affects API reliability and off-chain systems that depend on event stream completeness.

## Likelihood Explanation

**High likelihood of occurrence:**

1. **Common pattern**: Token mutation followed by burning is a legitimate use case (e.g., burning NFTs after metadata updates, limited edition collectibles)
2. **Guaranteed race condition**: The indexer ALWAYS queries latest state, not versioned state - this is not a timing edge case but a systematic design flaw
3. **No user awareness**: Users have no indication that their events are being dropped from indices
4. **Affects multiple event types**: This affects all V2 events that depend on resource lookups (not just `TokenMutation`), including other token events that check for burned resources

The vulnerability triggers deterministically whenever:
- An event references a resource at version N
- The resource is deleted at version N+K (where K â‰¥ 1)
- The indexer processes version N after the deletion occurs

## Recommendation

**Fix the state version query in event translation:**

Modify the `EventV2TranslationEngine` to accept a version parameter and query state at the specific version where the event was emitted:

1. Add version parameter to `EventV2Translator::translate_event_v2_to_v1`:
```rust
fn translate_event_v2_to_v1(
    &self,
    v2: &ContractEventV2,
    engine: &EventV2TranslationEngine,
    version: Version,  // NEW PARAMETER
) -> Result<ContractEventV1>;
```

2. Update `EventV2TranslationEngine` to use `state_view_at_version`:
```rust
pub fn get_state_value_bytes_for_resource(
    &self,
    address: &AccountAddress,
    struct_tag: &StructTag,
    version: Version,  // NEW PARAMETER
) -> Result<Option<Bytes>> {
    let state_view = self
        .main_db_reader
        .state_view_at_version(Some(version))?;  // CHANGED
    // ... rest of implementation
}
```

3. Pass version from the indexer processing loop:
```rust
if let Some(translated_v1_event) =
    self.translate_event_v2_to_v1(v2, version).map_err(|e| {  // PASS VERSION
        // ... error handling
    })?
```

This ensures the translator sees the state as it existed when the event was emitted, eliminating the race condition.

## Proof of Concept

**Move Test Scenario:**

```move
#[test(creator = @0xcafe, framework = @aptos_framework)]
public fun test_token_mutation_event_dropped_on_burn(
    creator: &signer,
    framework: &signer,
) {
    // Setup: Create token collection and mint token
    let token_addr = create_token_with_mutation_capability(creator);
    
    // Step 1: Mutate token (emits TokenMutation V2 event at version N)
    mutate_token_metadata(creator, token_addr, b"new_value");
    
    // Step 2: Burn the token (deletes Token resource at version N+1)
    burn_token(creator, token_addr);
    
    // Expected: TokenMutation event should be in transaction events
    // Actual: Event is missing from V1 event key indices
    // When indexer processes after burn, translation fails, event dropped
    
    // Query by transaction version: Event appears as V2 (untranslated)
    // Query by event key: Event is MISSING
}
```

**Rust Reproduction:**

The issue can be reproduced by:
1. Setting up an indexer with `enable_event_v2_translation = true`
2. Executing a transaction that emits a `TokenMutation` event
3. Executing a subsequent transaction that burns the token
4. Allowing the indexer to process both transactions
5. Querying events by the mutation event's EventKey
6. Observing that the mutation event is absent from results despite being in the transaction output

The indexer will log: `"Failed to translate event: ... Error: Token resource not found"` but continue processing, silently dropping the event from V1 indices.

---

**Notes:**

This vulnerability specifically violates API consistency guarantees rather than consensus safety. The events remain in the blockchain ledger and are accessible via direct transaction queries, but the indexer's V1 event key indices become incomplete. This primarily affects off-chain systems and API consumers that rely on event streams for state tracking, but does not compromise on-chain execution or validator consensus.

### Citations

**File:** types/src/account_config/events/token_mutation.rs (L64-64)
```rust
impl MoveEventV2Type for TokenMutation {}
```

**File:** storage/indexer/src/event_v2_translator.rs (L60-66)
```rust
pub trait EventV2Translator: Send + Sync {
    fn translate_event_v2_to_v1(
        &self,
        v2: &ContractEventV2,
        engine: &EventV2TranslationEngine,
    ) -> Result<ContractEventV1>;
}
```

**File:** storage/indexer/src/event_v2_translator.rs (L207-214)
```rust
        let state_view = self
            .main_db_reader
            .latest_state_checkpoint_view()
            .expect("Failed to get state view");
        let state_key = StateKey::resource(address, struct_tag)?;
        let maybe_state_value = state_view.get_state_value(&state_key)?;
        Ok(maybe_state_value.map(|state_value| state_value.bytes().clone()))
    }
```

**File:** storage/indexer/src/event_v2_translator.rs (L221-224)
```rust
        let state_view = self
            .main_db_reader
            .latest_state_checkpoint_view()
            .expect("Failed to get state view");
```

**File:** storage/indexer/src/event_v2_translator.rs (L440-456)
```rust
        let (key, sequence_number) = if let Some(state_value_bytes) = engine
            .get_state_value_bytes_for_object_group_resource(
                token_mutation.token_address(),
                &struct_tag,
            )? {
            let token_resource: TokenResource = bcs::from_bytes(&state_value_bytes)?;
            let key = *token_resource.mutation_events().key();
            let sequence_number =
                engine.get_next_sequence_number(&key, token_resource.mutation_events().count())?;
            (key, sequence_number)
        } else {
            // If the token resource is not found, we skip the event translation to avoid panic
            // because the creation number cannot be decided. The token may have been burned.
            return Err(AptosDbError::from(anyhow::format_err!(
                "Token resource not found"
            )));
        };
```

**File:** storage/indexer/src/db_indexer.rs (L448-484)
```rust
                    if self.indexer_db.event_v2_translation_enabled() {
                        if let ContractEvent::V2(v2) = event {
                            if let Some(translated_v1_event) =
                                self.translate_event_v2_to_v1(v2).map_err(|e| {
                                    anyhow::anyhow!(
                                        "Failed to translate event: {:?}. Error: {}",
                                        v2,
                                        e
                                    )
                                })?
                            {
                                let key = *translated_v1_event.key();
                                let sequence_number = translated_v1_event.sequence_number();
                                self.event_v2_translation_engine
                                    .cache_sequence_number(&key, sequence_number);
                                event_keys.insert(key);
                                batch
                                    .put::<EventByKeySchema>(
                                        &(key, sequence_number),
                                        &(version, idx as u64),
                                    )
                                    .expect("Failed to put events by key to a batch");
                                batch
                                    .put::<EventByVersionSchema>(
                                        &(key, version, sequence_number),
                                        &(idx as u64),
                                    )
                                    .expect("Failed to put events by version to a batch");
                                batch
                                    .put::<TranslatedV1EventSchema>(
                                        &(version, idx as u64),
                                        &translated_v1_event,
                                    )
                                    .expect("Failed to put translated v1 events to a batch");
                            }
                        }
                    }
```
