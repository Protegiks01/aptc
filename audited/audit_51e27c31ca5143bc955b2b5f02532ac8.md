# Audit Report

## Title
Unrecoverable Validator State After Interrupted Genesis Commit

## Summary
When a validator crashes or loses power after `pre_commit_ledger` completes but before `commit_ledger` writes the `OverallCommitProgress` marker during genesis initialization, the database recovery mechanism fails to clean up partially committed data. This leaves the validator in an inconsistent state that cannot self-recover, requiring manual database deletion and full reset.

## Finding Description

The genesis initialization process in Aptos follows a two-phase commit pattern where `pre_commit_ledger` writes all transaction data to multiple databases, and `commit_ledger` finalizes the commit by writing the `OverallCommitProgress` marker. [1](#0-0) 

During genesis, the `GenesisCommitter.commit()` method calls `save_transactions` with `sync_commit=true`: [2](#0-1) 

The `pre_commit_ledger` phase writes genesis data to multiple databases in parallel (ledger_db, state_kv_db, state_merkle_db, etc.): [3](#0-2) 

The critical vulnerability exists in the `sync_commit_progress` function, which is responsible for crash recovery. When `OverallCommitProgress` does not exist in the database, the function simply logs a message and performs NO cleanup: [4](#0-3) 

**Attack Scenario:**
1. Validator starts genesis process
2. `pre_commit_ledger` successfully writes all genesis data to databases (transactions, state values, merkle tree nodes, accumulator data)
3. **Crash occurs** (power failure, OOM kill, hardware failure) before `commit_ledger` writes `OverallCommitProgress`
4. On restart, `sync_commit_progress` finds no `OverallCommitProgress` and assumes the database is fresh
5. No truncation or cleanup is performed despite databases containing partial genesis data
6. `create_buffered_state_from_latest_snapshot` reconstructs state with `num_transactions=0` (since `get_synced_version()` returns None): [5](#0-4) 
7. The validator is now in an **inconsistent state**: databases have genesis data at version 0, but the commit progress system believes the database is empty
8. Subsequent attempts to apply genesis may fail or create further inconsistencies

The `OverallCommitProgress` marker is written only in `commit_ledger`: [6](#0-5) 

## Impact Explanation

This vulnerability has **HIGH severity** per the Aptos bug bounty criteria: "State inconsistencies requiring intervention."

**Concrete Impact:**
- Validators that crash during genesis initialization cannot self-recover
- The inconsistent database state prevents proper genesis completion on restart
- Manual intervention is required: operators must delete the entire database and restart from scratch
- In a production network launch, this could prevent validators from joining at genesis, potentially delaying network start
- No data loss occurs (since genesis hasn't completed), but operational availability is impacted

This meets the "State inconsistencies requiring intervention" category because:
1. The state is objectively inconsistent (data exists but is not acknowledged by commit markers)
2. The node cannot automatically recover through normal restart procedures
3. Manual database deletion is required to restore functionality
4. This breaks the **State Consistency** invariant: "State transitions must be atomic and verifiable via Merkle proofs"

## Likelihood Explanation

This vulnerability has **MEDIUM-HIGH likelihood**:

**Favorable Conditions:**
- Genesis is a critical one-time operation that all validators must perform
- Process crashes, power failures, and OOM kills are common in production environments
- The vulnerability window exists between two sequential operations (pre_commit and commit)
- No special conditions or race conditions requiredâ€”any crash during this window triggers the bug

**Mitigating Factors:**
- Genesis is typically performed once at network launch or validator initialization
- Modern systems have battery backup and stable power in datacenters
- The time window between pre_commit and commit is relatively small (milliseconds to seconds)

However, when this does occur, **every affected validator requires manual intervention**, making the operational impact significant despite moderate probability.

## Recommendation

The `sync_commit_progress` function should check for the existence of `LedgerCommitProgress` or `StateKvCommitProgress` even when `OverallCommitProgress` is missing. If these markers exist without a corresponding `OverallCommitProgress`, it indicates an interrupted commit that requires cleanup.

**Recommended Fix:**

```rust
pub fn sync_commit_progress(
    ledger_db: Arc<LedgerDb>,
    state_kv_db: Arc<StateKvDb>,
    state_merkle_db: Arc<StateMerkleDb>,
    crash_if_difference_is_too_large: bool,
) {
    let ledger_metadata_db = ledger_db.metadata_db();
    if let Some(overall_commit_progress) = ledger_metadata_db
        .get_synced_version()
        .expect("DB read failed.")
    {
        // Existing truncation logic...
    } else {
        // NEW: Check for interrupted commits
        let ledger_commit_progress = ledger_metadata_db
            .get_ledger_commit_progress()
            .ok();
        let state_kv_commit_progress = state_kv_db
            .metadata_db()
            .get::<DbMetadataSchema>(&DbMetadataKey::StateKvCommitProgress)
            .ok()
            .flatten();
        
        if ledger_commit_progress.is_some() || state_kv_commit_progress.is_some() {
            // Partial commit detected - truncate everything back to empty state
            info!("Detected incomplete commit without OverallCommitProgress. Cleaning up...");
            truncate_ledger_db(ledger_db.clone(), 0)
                .expect("Failed to truncate ledger db.");
            truncate_state_kv_db(&state_kv_db, 0, 0, 1)
                .expect("Failed to truncate state K/V db.");
            truncate_state_merkle_db(&state_merkle_db, 0)
                .expect("Failed to truncate state merkle db.");
        } else {
            info!("No overall commit progress was found - fresh database.");
        }
    }
}
```

This ensures that any partially committed data is cleaned up before the node attempts to proceed with genesis initialization.

## Proof of Concept

**Reproduction Steps:**

1. Set up a local Aptos validator node with genesis configuration
2. Modify the genesis commit process to add a delay between pre_commit and commit:

```rust
// In storage/aptosdb/src/db/aptosdb_writer.rs, in pre_commit_ledger:
self.state_store.buffered_state().lock().update(
    chunk.result_ledger_state_with_summary(),
    chunk.estimated_total_state_updates(),
    sync_commit || chunk.is_reconfig,
)?;

// Add this for testing:
std::thread::sleep(std::time::Duration::from_secs(5));

Ok(())
```

3. Start the validator to begin genesis
4. Kill the process (SIGKILL) during the 5-second window after pre_commit completes
5. Restart the validator
6. Observe that:
   - `sync_commit_progress` logs "No overall commit progress was found!"
   - The database still contains partial genesis data
   - Subsequent genesis application attempts may fail or create inconsistencies
   - The validator cannot complete initialization without manual database deletion

**Expected Behavior After Fix:**
- On restart, `sync_commit_progress` detects the partial commit
- Automatically truncates all databases back to clean state
- Genesis proceeds normally without manual intervention

**Notes:**
- This can be observed by examining database contents before/after the crash
- Check for presence of data in TransactionSchema, StateValueSchema, etc. without OverallCommitProgress
- The inconsistency becomes evident when comparing `get_synced_version()` (returns None) with actual database contents (contains data)

### Citations

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L44-76)
```rust
    fn pre_commit_ledger(&self, chunk: ChunkToCommit, sync_commit: bool) -> Result<()> {
        gauged_api("pre_commit_ledger", || {
            // Pre-committing and committing in concurrency is allowed but not pre-committing at the
            // same time from multiple threads, the same for committing.
            // Consensus and state sync must hand over to each other after all pending execution and
            // committing complete.
            let _lock = self
                .pre_commit_lock
                .try_lock()
                .expect("Concurrent committing detected.");
            let _timer = OTHER_TIMERS_SECONDS.timer_with(&["pre_commit_ledger"]);

            chunk
                .state_summary
                .latest()
                .global_state_summary
                .log_generation("db_save");

            self.pre_commit_validation(&chunk)?;
            let _new_root_hash =
                self.calculate_and_commit_ledger_and_state_kv(&chunk, self.skip_index_and_usage)?;

            let _timer = OTHER_TIMERS_SECONDS.timer_with(&["save_transactions__others"]);

            self.state_store.buffered_state().lock().update(
                chunk.result_ledger_state_with_summary(),
                chunk.estimated_total_state_updates(),
                sync_commit || chunk.is_reconfig,
            )?;

            Ok(())
        })
    }
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L103-107)
```rust
            ledger_batch.put::<DbMetadataSchema>(
                &DbMetadataKey::OverallCommitProgress,
                &DbMetadataValue::Version(version),
            )?;
            self.ledger_db.metadata_db().write_schemas(ledger_batch)?;
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L263-322)
```rust
    fn calculate_and_commit_ledger_and_state_kv(
        &self,
        chunk: &ChunkToCommit,
        skip_index_and_usage: bool,
    ) -> Result<HashValue> {
        let _timer = OTHER_TIMERS_SECONDS.timer_with(&["save_transactions__work"]);

        let mut new_root_hash = HashValue::zero();
        THREAD_MANAGER.get_non_exe_cpu_pool().scope(|s| {
            // TODO(grao): Write progress for each of the following databases, and handle the
            // inconsistency at the startup time.
            //
            // TODO(grao): Consider propagating the error instead of panic, if necessary.
            s.spawn(|_| {
                self.commit_events(
                    chunk.first_version,
                    chunk.transaction_outputs,
                    skip_index_and_usage,
                )
                .unwrap()
            });
            s.spawn(|_| {
                self.ledger_db
                    .write_set_db()
                    .commit_write_sets(chunk.first_version, chunk.transaction_outputs)
                    .unwrap()
            });
            s.spawn(|_| {
                self.ledger_db
                    .transaction_db()
                    .commit_transactions(
                        chunk.first_version,
                        chunk.transactions,
                        skip_index_and_usage,
                    )
                    .unwrap()
            });
            s.spawn(|_| {
                self.ledger_db
                    .persisted_auxiliary_info_db()
                    .commit_auxiliary_info(chunk.first_version, chunk.persisted_auxiliary_infos)
                    .unwrap()
            });
            s.spawn(|_| {
                self.commit_state_kv_and_ledger_metadata(chunk, skip_index_and_usage)
                    .unwrap()
            });
            s.spawn(|_| {
                self.commit_transaction_infos(chunk.first_version, chunk.transaction_infos)
                    .unwrap()
            });
            s.spawn(|_| {
                new_root_hash = self
                    .commit_transaction_accumulator(chunk.first_version, chunk.transaction_infos)
                    .unwrap()
            });
        });

        Ok(new_root_hash)
    }
```

**File:** execution/executor/src/db_bootstrapper/mod.rs (L99-112)
```rust
    pub fn commit(self) -> Result<()> {
        self.db.save_transactions(
            self.output
                .output
                .expect_complete_result()
                .as_chunk_to_commit(),
            self.output.ledger_info_opt.as_ref(),
            true, /* sync_commit */
        )?;
        info!("Genesis commited.");
        // DB bootstrapped, avoid anything that could fail after this.

        Ok(())
    }
```

**File:** storage/aptosdb/src/state_store/mod.rs (L410-502)
```rust
    pub fn sync_commit_progress(
        ledger_db: Arc<LedgerDb>,
        state_kv_db: Arc<StateKvDb>,
        state_merkle_db: Arc<StateMerkleDb>,
        crash_if_difference_is_too_large: bool,
    ) {
        let ledger_metadata_db = ledger_db.metadata_db();
        if let Some(overall_commit_progress) = ledger_metadata_db
            .get_synced_version()
            .expect("DB read failed.")
        {
            info!(
                overall_commit_progress = overall_commit_progress,
                "Start syncing databases..."
            );
            let ledger_commit_progress = ledger_metadata_db
                .get_ledger_commit_progress()
                .expect("Failed to read ledger commit progress.");
            assert_ge!(ledger_commit_progress, overall_commit_progress);

            let state_kv_commit_progress = state_kv_db
                .metadata_db()
                .get::<DbMetadataSchema>(&DbMetadataKey::StateKvCommitProgress)
                .expect("Failed to read state K/V commit progress.")
                .expect("State K/V commit progress cannot be None.")
                .expect_version();
            assert_ge!(state_kv_commit_progress, overall_commit_progress);

            // LedgerCommitProgress was not guaranteed to commit after all ledger changes finish,
            // have to attempt truncating every column family.
            info!(
                ledger_commit_progress = ledger_commit_progress,
                "Attempt ledger truncation...",
            );
            let difference = ledger_commit_progress - overall_commit_progress;
            if crash_if_difference_is_too_large {
                assert_le!(difference, MAX_COMMIT_PROGRESS_DIFFERENCE);
            }
            truncate_ledger_db(ledger_db.clone(), overall_commit_progress)
                .expect("Failed to truncate ledger db.");

            // State K/V commit progress isn't (can't be) written atomically with the data,
            // because there are shards, so we have to attempt truncation anyway.
            info!(
                state_kv_commit_progress = state_kv_commit_progress,
                "Start state KV truncation..."
            );
            let difference = state_kv_commit_progress - overall_commit_progress;
            if crash_if_difference_is_too_large {
                assert_le!(difference, MAX_COMMIT_PROGRESS_DIFFERENCE);
            }
            truncate_state_kv_db(
                &state_kv_db,
                state_kv_commit_progress,
                overall_commit_progress,
                std::cmp::max(difference as usize, 1), /* batch_size */
            )
            .expect("Failed to truncate state K/V db.");

            let state_merkle_max_version = get_max_version_in_state_merkle_db(&state_merkle_db)
                .expect("Failed to get state merkle max version.")
                .expect("State merkle max version cannot be None.");
            if state_merkle_max_version > overall_commit_progress {
                let difference = state_merkle_max_version - overall_commit_progress;
                if crash_if_difference_is_too_large {
                    assert_le!(difference, MAX_COMMIT_PROGRESS_DIFFERENCE);
                }
            }
            let state_merkle_target_version = find_tree_root_at_or_before(
                ledger_metadata_db,
                &state_merkle_db,
                overall_commit_progress,
            )
            .expect("DB read failed.")
            .unwrap_or_else(|| {
                panic!(
                    "Could not find a valid root before or at version {}, maybe it was pruned?",
                    overall_commit_progress
                )
            });
            if state_merkle_target_version < state_merkle_max_version {
                info!(
                    state_merkle_max_version = state_merkle_max_version,
                    target_version = state_merkle_target_version,
                    "Start state merkle truncation..."
                );
                truncate_state_merkle_db(&state_merkle_db, state_merkle_target_version)
                    .expect("Failed to truncate state merkle db.");
            }
        } else {
            info!("No overall commit progress was found!");
        }
    }
```

**File:** storage/aptosdb/src/state_store/mod.rs (L561-565)
```rust
        let num_transactions = state_db
            .ledger_db
            .metadata_db()
            .get_synced_version()?
            .map_or(0, |v| v + 1);
```
