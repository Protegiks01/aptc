# Audit Report

## Title
TRANSACTIONS_INVARIANT_VIOLATION Counter Defined But Never Incremented: Critical Monitoring Gap for VM Invariant Violations

## Summary
The `TRANSACTIONS_INVARIANT_VIOLATION` counter is defined in the codebase to track VM invariant violations, but it is never incremented anywhere in the system. Meanwhile, multiple types of critical VM invariant violations are occurring and being logged during transaction execution, including paranoid mode failures, reference safety violations, and type resolution errors. This creates a critical monitoring gap where serious VM bugs or potential exploits cannot be detected through metrics-based alerting, relying solely on passive log review.

## Finding Description

The vulnerability exists across three key components:

**1. Unused Counter Definition:** [1](#0-0) 

The counter is defined with the description "Number of transactions that broke VM invariant" but a comprehensive grep search shows it is never incremented (`TRANSACTIONS_INVARIANT_VIOLATION.inc()`) anywhere in the codebase.

**2. Unmonitored Invariant Violations:** [2](#0-1) 

During transaction execution, multiple critical invariant violations are logged but not tracked via metrics:
- `UNKNOWN_INVARIANT_VIOLATION_ERROR` with paranoid mode failures (EPARANOID_FAILURE, EREFERENCE_COUNTING_FAILURE, EREFERENCE_SAFETY_FAILURE)
- `UNEXPECTED_ERROR_FROM_KNOWN_MOVE_FUNCTION`
- `TYPE_RESOLUTION_FAILURE`
- `SPECULATIVE_EXECUTION_ABORT_ERROR`

Notably, there's a TODO comment at line 2991: "TODO: Add different counters for the error categories here."

**3. Transactions with Violations Can Be Committed:** [3](#0-2) 

The `CHARGE_INVARIANT_VIOLATION` feature flag allows transactions with invariant violations to be kept and committed to the blockchain rather than discarded, making monitoring even more critical.

**How This Breaks Security Guarantees:**

VM invariant violations represent critical bugs in the Move VM implementation that break safety guarantees defined in the paranoid mode runtime checks: [4](#0-3) [5](#0-4) 

These checks enforce type safety and reference safety invariants. When they fail, it indicates:
- Type confusion attacks bypassing Move's safety guarantees
- Memory corruption through reference safety violations  
- Incorrect bytecode execution that could enable unauthorized operations

While consensus state root verification would catch **non-deterministic** violations (where validators get different results), **deterministic** violations (where all validators execute the same buggy code) would:
1. Not be caught by consensus SafetyRules verification
2. Only appear in logs, not metrics
3. Have no automated response mechanism
4. Be committable to the blockchain if CHARGE_INVARIANT_VIOLATION is enabled

## Impact Explanation

**Severity: Medium to High**

This monitoring gap represents a **"Significant Protocol Violation"** (High severity per bug bounty) because:

1. **Detection Failure**: VM invariant violations that could indicate active exploits are not actively monitored through standard metrics/alerting infrastructure

2. **Response Delay**: Without counter-based alerts, detection requires manual log review, potentially allowing exploits to continue for extended periods

3. **Deterministic Bugs**: VM bugs that execute identically across all validators will bypass consensus state root checks but still violate Move's safety guarantees: [6](#0-5) 
   
   This check only catches **inconsistent** execution results, not **consistently wrong** results from deterministic VM bugs.

4. **Paranoid Mode Failures**: Reference counting and type safety violations logged here indicate serious VM bugs: [7](#0-6) 

5. **No Emergency Response**: Despite infrastructure for halt mechanisms in BlockSTM parallel execution: [8](#0-7) 
   
   There is no equivalent emergency response at the transaction validation level for invariant violations.

## Likelihood Explanation

**Likelihood: High**

The TODO comment and counter definition indicate this was intended functionality that was never completed. The likelihood of this gap causing security harm is high because:

1. **Invariant violations ARE occurring** - the extensive logging infrastructure proves these are real, not theoretical events

2. **Test infrastructure expects them** - the invariant_violation.rs test demonstrates these are known scenarios: [9](#0-8) 

3. **No metrics visibility** - Standard monitoring systems cannot alert on these conditions without counter increments

4. **Production deployments** - The CHARGE_INVARIANT_VIOLATION feature is enabled at genesis, meaning these violations can be committed to production chains

## Recommendation

**Immediate Fix:**

1. **Implement Counter Increments:**
```rust
// In aptos-move/aptos-vm/src/aptos_vm.rs around line 2990
match vm_status.status_code() {
    StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR => {
        TRANSACTIONS_INVARIANT_VIOLATION.inc();
        match vm_status.sub_status() {
            Some(unknown_invariant_violation::EPARANOID_FAILURE) => {
                error!(*log_context, "[aptos_vm] Paranoid mode failure: {:?}", vm_status);
            },
            // ... other cases
        }
    },
    StatusCode::UNEXPECTED_ERROR_FROM_KNOWN_MOVE_FUNCTION => {
        TRANSACTIONS_INVARIANT_VIOLATION.inc();
        speculative_error!(log_context, ...);
    },
    // ... other invariant violation types
}
```

2. **Add Category-Specific Counters** (addressing the TODO at line 2991):
```rust
pub static TRANSACTIONS_INVARIANT_VIOLATION_BY_TYPE: Lazy<IntCounterVec> = Lazy::new(|| {
    register_int_counter_vec!(
        "aptos_vm_transactions_invariant_violation_by_type",
        "Number of transactions that broke VM invariant by violation type",
        &["type"]
    ).unwrap()
});
```

3. **Implement Alert Thresholds:**
Add alerting when counter increments exceed expected baseline, triggering investigation.

4. **Consider Emergency Response:**
For critical paranoid mode failures (EREFERENCE_SAFETY_FAILURE, EREFERENCE_COUNTING_FAILURE), consider implementing an automatic fallback or halt mechanism similar to BlockSTM's error handling.

## Proof of Concept

**Demonstrating the Gap:**

```rust
// This test can be added to aptos-move/aptos-vm/src/tests/
#[test]
fn test_invariant_violation_counter_gap() {
    use fail::FailScenario;
    
    let _scenario = FailScenario::setup();
    fail::cfg("aptos_vm::execute_script_or_entry_function", "return").unwrap();
    
    let mut executor = FakeExecutor::from_head_genesis();
    let sender = executor.create_raw_account_data(1_000_000, 10);
    let receiver = executor.create_raw_account_data(100_000, 10);
    executor.add_account_data(&sender);
    executor.add_account_data(&receiver);
    
    // Get counter value before transaction
    let counter_before = TRANSACTIONS_INVARIANT_VIOLATION.get();
    
    // Execute transaction that triggers invariant violation
    let txn = peer_to_peer_txn(sender.account(), receiver.account(), 10, 1000, 0);
    let output = executor.execute_transaction(txn);
    
    // Verify invariant violation occurred
    assert_eq!(
        output.status(),
        &TransactionStatus::Keep(ExecutionStatus::MiscellaneousError(
            Some(StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR)
        ))
    );
    
    // BUG: Counter should have incremented but didn't
    let counter_after = TRANSACTIONS_INVARIANT_VIOLATION.get();
    assert_eq!(counter_before, counter_after, "Counter never increments despite invariant violation!");
}
```

**Notes:**

This vulnerability represents a **defense-in-depth failure** where critical VM safety violations lack active monitoring infrastructure. While consensus state root verification provides protection against non-deterministic execution bugs, deterministic VM bugs that violate Move's type safety and reference safety guarantees can be committed to the blockchain without triggering any metrics-based alerts. The defined-but-unused counter and explicit TODO comment demonstrate this is a known gap that needs resolution.

### Citations

**File:** aptos-move/aptos-vm/src/counters.rs (L45-52)
```rust
/// Count the number of transactions that brake invariants of VM.
pub static TRANSACTIONS_INVARIANT_VIOLATION: Lazy<IntCounter> = Lazy::new(|| {
    register_int_counter!(
        "aptos_vm_transactions_invariant_violation",
        "Number of transactions that broke VM invariant",
    )
    .unwrap()
});
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L2929-3000)
```rust
                    match vm_status.status_code() {
                        // Type resolution failure can be triggered by user input when providing a bad type argument, skip this case.
                        StatusCode::TYPE_RESOLUTION_FAILURE
                        if vm_status.sub_status()
                            == Some(move_core_types::vm_status::sub_status::type_resolution_failure::EUSER_TYPE_LOADING_FAILURE) => {},
                        // The known Move function failure and type resolution failure could be a result of speculative execution. Use speculative logger.
                        StatusCode::UNEXPECTED_ERROR_FROM_KNOWN_MOVE_FUNCTION
                        | StatusCode::TYPE_RESOLUTION_FAILURE => {
                            speculative_error!(
                                log_context,
                                format!(
                                    "[aptos_vm] Transaction breaking invariant violation: {:?}\ntxn: {:?}",
                                    vm_status,
                                    bcs::to_bytes::<SignedTransaction>(txn),
                                ),
                            );
                        },
                        // Paranoid mode failure. We need to be alerted about this ASAP.
                        StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR
                        if vm_status.sub_status()
                            == Some(unknown_invariant_violation::EPARANOID_FAILURE) =>
                            {
                                error!(
                                *log_context,
                                "[aptos_vm] Transaction breaking paranoid mode: {:?}\ntxn: {:?}",
                                vm_status,
                                bcs::to_bytes::<SignedTransaction>(txn),
                            );
                            },
                        // Paranoid mode failure but with reference counting
                        StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR
                        if vm_status.sub_status()
                            == Some(unknown_invariant_violation::EREFERENCE_COUNTING_FAILURE) =>
                            {
                                error!(
                                *log_context,
                                "[aptos_vm] Transaction breaking paranoid mode: {:?}\ntxn: {:?}",
                                vm_status,
                                bcs::to_bytes::<SignedTransaction>(txn),
                            );
                            },
                        // Paranoid mode failure but with reference safety checks
                        StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR
                        if matches!(
                            vm_status.sub_status(),
                            Some(
                                unknown_invariant_violation::EREFERENCE_SAFETY_FAILURE
                                | unknown_invariant_violation::EINDEXED_REF_TAG_MISMATCH
                            )
                        ) =>
                        {
                            error!(
                            *log_context,
                            "[aptos_vm] Transaction breaking paranoid reference safety check (including enum tag guard). txn: {:?}, status: {:?}",
                            bcs::to_bytes::<SignedTransaction>(txn),
                            vm_status,
                            );
                        }
                        // Ignore DelayedFields speculative errors as it can be intentionally triggered by parallel execution.
                        StatusCode::SPECULATIVE_EXECUTION_ABORT_ERROR => (),
                        // We will log the rest of invariant violation directly with regular logger as they shouldn't happen.
                        //
                        // TODO: Add different counters for the error categories here.
                        _ => {
                            error!(
                                *log_context,
                                "[aptos_vm] Transaction breaking invariant violation: {:?}\ntxn: {:?}, ",
                                vm_status,
                                bcs::to_bytes::<SignedTransaction>(txn),
                            );
                        },
                    }
```

**File:** types/src/transaction/mod.rs (L1640-1646)
```rust
                if code.status_type() == StatusType::InvariantViolation
                    && features.is_enabled(FeatureFlag::CHARGE_INVARIANT_VIOLATION)
                {
                    Self::Keep(ExecutionStatus::MiscellaneousError(Some(code)))
                } else {
                    Self::Discard(code)
                }
```

**File:** third_party/move/move-vm/runtime/src/runtime_type_checks.rs (L1-20)
```rust
// Copyright © Aptos Foundation
// SPDX-License-Identifier: Apache-2.0

use crate::{
    frame::Frame, frame_type_cache::FrameTypeCache, interpreter::Stack,
    reentrancy_checker::CallType, Function, LoadedFunction,
};
use move_binary_format::errors::*;
use move_core_types::{
    ability::{Ability, AbilitySet},
    function::ClosureMask,
    vm_status::{sub_status::unknown_invariant_violation::EPARANOID_FAILURE, StatusCode},
};
use move_vm_types::{
    instr::Instruction,
    loaded_data::runtime_types::{Type, TypeBuilder},
};

pub(crate) trait RuntimeTypeCheck {
    /// Paranoid type checks to perform before instruction execution.
```

**File:** third_party/move/move-vm/runtime/src/runtime_ref_checks.rs (L1-20)
```rust
// Copyright © Aptos Foundation
// SPDX-License-Identifier: Apache-2.0

//! This module implements the runtime reference checks for Move bytecode.
//!
//! Move bytecode has a bytecode verifier pass for enforcing reference safety rules:
//! the runtime checks implemented here are the relaxed dynamic semantics of that pass.
//! If the bytecode verifier pass succeeds, then the runtime checks should also succeed
//! for any execution path.
//! However, there may be Move bytecode that the bytecode verifier pass rejects, but
//! the runtime checks may still succeed, as long as reference-safety rules are not
//! violated (i.e., relaxed semantics).
//!
//! This checker maintains shadow state as the execution proceeds: the shadow state
//! contains information needed about the references in order to check for reference safety.
//! Note that simpler techniques such as reference counting are insufficient to
//! implement the dynamic relaxed semantics of the bytecode verifier pass.
//!
//! The shadow state contains:
//! - A shadow stack of values. Values which can either be non-references (we don't
```

**File:** consensus/safety-rules/src/safety_rules.rs (L395-403)
```rust
        if !old_ledger_info
            .commit_info()
            .match_ordered_only(new_ledger_info.commit_info())
        {
            return Err(Error::InconsistentExecutionResult(
                old_ledger_info.commit_info().to_string(),
                new_ledger_info.commit_info().to_string(),
            ));
        }
```

**File:** aptos-move/block-executor/src/executor.rs (L1789-1798)
```rust
                        if let PanicOr::CodeInvariantError(err_msg) = err {
                            alert!(
                                "[BlockSTMv2] worker loop: CodeInvariantError({:?})",
                                err_msg
                            );
                        }
                        shared_maybe_error.store(true, Ordering::SeqCst);

                        // Make sure to halt the scheduler if it hasn't already been halted.
                        scheduler.halt();
```

**File:** aptos-move/e2e-testsuite/src/tests/invariant_violation.rs (L14-40)
```rust
fn invariant_violation_error() {
    let _scenario = fail::FailScenario::setup();
    fail::cfg("aptos_vm::execute_script_or_entry_function", "100%return").unwrap();

    ::aptos_logger::Logger::init_for_testing();

    let mut executor = FakeExecutor::from_head_genesis();

    let sender = executor.create_raw_account_data(1_000_000, 10);
    let receiver = executor.create_raw_account_data(100_000, 10);
    executor.add_account_data(&sender);
    executor.add_account_data(&receiver);

    let transfer_amount = 1_000;
    let txn = peer_to_peer_txn(sender.account(), receiver.account(), 10, transfer_amount, 0);

    // execute transaction
    let output = executor.execute_transaction(txn.clone());

    // CHARGE_INVARIANT_VIOLATION enabled at genesis so this txn is kept.
    assert_eq!(
        output.status(),
        &TransactionStatus::Keep(ExecutionStatus::MiscellaneousError(Some(
            StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR
        ))),
    );

```
