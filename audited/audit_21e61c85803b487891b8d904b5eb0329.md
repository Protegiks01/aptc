# Audit Report

## Title
Consensus Split Vulnerability During Metadata Version Upgrades Due to Hardcoded Validation

## Summary
The metadata validation logic hardcodes the list of acceptable metadata keys in the binary, making it impossible to safely introduce new metadata versions without risking consensus splits during validator upgrades. When validators run different code versions, they will accept/reject modules with newer metadata keys differently, causing deterministic execution to break.

## Finding Description

The `check_metadata_format` function validates module metadata during publishing by checking against a hardcoded list of known keys. [1](#0-0) 

This function only recognizes three metadata keys (`APTOS_METADATA_KEY`, `APTOS_METADATA_KEY_V1`, and `COMPILATION_METADATA_KEY`) and rejects any unknown key with `MalformedError::UnknownKey`. [2](#0-1) 

This validation is invoked during module publishing when the `RESOURCE_GROUPS` feature is enabled (which is enabled by default). [3](#0-2) 

The validation occurs in `validate_publish_request`, which is part of the transaction execution path. [4](#0-3) 

When validation fails, it returns a `CONSTRAINT_NOT_SATISFIED` error. [5](#0-4) 

**Attack Scenario:**
1. Aptos releases a new version that adds support for `APTOS_METADATA_KEY_V2` by updating `check_metadata_format`
2. During the rollout, Validator A upgrades but Validator B has not yet upgraded
3. An attacker publishes a module containing `APTOS_METADATA_KEY_V2` metadata
4. Validator A (new code): Recognizes the key as valid → transaction succeeds → module published to state
5. Validator B (old code): Key is unknown → returns `UnknownKey` error → transaction fails → module NOT published
6. Different state roots are produced for the same block → **consensus split**

This breaks the critical **Deterministic Execution** invariant that all validators must produce identical state roots for identical blocks.

## Impact Explanation

This is a **Critical Severity** vulnerability (Consensus/Safety violation) because:

1. **Consensus Split**: Validators running different code versions will disagree on block validity, causing the network to split into incompatible chains
2. **Non-recoverable Network Partition**: Once validators have diverged state, automatic recovery is impossible and requires manual intervention or hard fork
3. **No Byzantine Behavior Required**: This vulnerability can be triggered during normal validator upgrades without any malicious validator behavior
4. **Wide Attack Surface**: Any user can trigger this by publishing a module during the upgrade window

Per Aptos bug bounty categories, "Non-recoverable network partition (requires hardfork)" and "Consensus/Safety violations" are Critical severity with bounties up to $1,000,000.

## Likelihood Explanation

**High Likelihood** because:

1. **Inevitable Scenario**: Any future metadata version upgrade will require updating the hardcoded validation logic in `check_metadata_format`
2. **Upgrade Window Vulnerability**: Even with coordinated upgrades, there's always a window where validators are running mixed versions
3. **Observable**: Attackers can monitor GitHub commits, testnets, or release announcements to learn about upcoming metadata versions
4. **No Barrier**: Any user can publish modules; no special privileges required
5. **Timing Attack**: Attacker only needs to submit the transaction during the rollout window when validators have mixed versions

The lack of feature flag protection means there's no safe way to gate the new functionality until all validators are ready.

## Recommendation

Implement feature-flag-gated metadata version validation:

```rust
fn check_metadata_format(module: &CompiledModule, features: &Features) -> Result<(), MalformedError> {
    let mut exist = false;
    let mut compilation_key_exist = false;
    for data in module.metadata.iter() {
        if data.key == *APTOS_METADATA_KEY || data.key == *APTOS_METADATA_KEY_V1 {
            // V0 and V1 validation (always supported)
            if exist {
                return Err(MalformedError::DuplicateKey);
            }
            exist = true;
            // ... existing validation ...
        } else if features.is_enabled(FeatureFlag::METADATA_V2_SUPPORT) 
            && data.key == *APTOS_METADATA_KEY_V2 {
            // V2 validation (only when feature enabled)
            if exist {
                return Err(MalformedError::DuplicateKey);
            }
            exist = true;
            bcs::from_bytes::<RuntimeModuleMetadataV2>(&data.value)
                .map_err(|e| MalformedError::DeserializedError(data.key.clone(), e))?;
        } else if data.key == *COMPILATION_METADATA_KEY {
            // ... existing validation ...
        } else {
            return Err(MalformedError::UnknownKey(data.key.clone()));
        }
    }
    Ok(())
}
```

Update the function signature to accept `features: &Features` parameter: [6](#0-5) 

**Deployment Process:**
1. Add new `METADATA_V2_SUPPORT` feature flag (disabled by default)
2. Deploy updated code to all validators that accepts V2 when flag is enabled
3. Wait for all validators to upgrade
4. Enable `METADATA_V2_SUPPORT` feature via governance
5. Now all validators simultaneously accept V2 metadata

This ensures deterministic behavior: all validators either accept or reject V2 metadata based on the same on-chain feature flag.

## Proof of Concept

```rust
// This test demonstrates the consensus split scenario
// Place in: types/src/vm/module_metadata.rs

#[cfg(test)]
mod consensus_split_test {
    use super::*;
    use move_binary_format::file_format::CompiledModule;
    use move_core_types::metadata::Metadata;
    
    #[test]
    fn test_metadata_version_mismatch_causes_split() {
        // Create a module with future metadata version
        let mut module = create_test_module();
        
        // Add "aptos::metadata_v2" key (not yet recognized)
        module.metadata.push(Metadata {
            key: b"aptos::metadata_v2".to_vec(),
            value: vec![0u8; 10], // dummy data
        });
        
        let features = Features::default(); // RESOURCE_GROUPS enabled
        
        // Validator with OLD code: This would reject with UnknownKey
        let result = check_metadata_format(&module);
        assert!(result.is_err());
        assert!(matches!(result.unwrap_err(), MalformedError::UnknownKey(_)));
        
        // Validator with NEW code (hypothetical): Would accept if V2 was added
        // This creates a consensus split!
        // Old validators: Transaction FAILS
        // New validators: Transaction SUCCEEDS
        // → Different state roots → Chain split
    }
}
```

**Real-world exploitation:**
1. Monitor Aptos GitHub for commits adding new metadata versions
2. Wait for new release announcement
3. Observe validators upgrading (via version RPC endpoints)
4. When ~50% upgraded but not all, publish module with new metadata
5. Network splits: upgraded validators accept, non-upgraded reject
6. Chain halts due to consensus failure

## Notes

The vulnerability exists because on-chain `Features` configuration controls WHETHER to validate metadata, but not WHICH metadata versions are valid. [7](#0-6) 

While `RESOURCE_GROUPS` is enabled by default ensuring validation occurs, the actual validation logic remains hardcoded in the binary, making safe metadata version upgrades impossible without coordinated binary updates across all validators. [8](#0-7)

### Citations

**File:** types/src/vm/module_metadata.rs (L54-55)
```rust
pub static APTOS_METADATA_KEY: &[u8] = "aptos::metadata_v0".as_bytes();
pub static APTOS_METADATA_KEY_V1: &[u8] = "aptos::metadata_v1".as_bytes();
```

**File:** types/src/vm/module_metadata.rs (L253-283)
```rust
fn check_metadata_format(module: &CompiledModule) -> Result<(), MalformedError> {
    let mut exist = false;
    let mut compilation_key_exist = false;
    for data in module.metadata.iter() {
        if data.key == *APTOS_METADATA_KEY || data.key == *APTOS_METADATA_KEY_V1 {
            if exist {
                return Err(MalformedError::DuplicateKey);
            }
            exist = true;

            if data.key == *APTOS_METADATA_KEY {
                bcs::from_bytes::<RuntimeModuleMetadata>(&data.value)
                    .map_err(|e| MalformedError::DeserializedError(data.key.clone(), e))?;
            } else if data.key == *APTOS_METADATA_KEY_V1 {
                bcs::from_bytes::<RuntimeModuleMetadataV1>(&data.value)
                    .map_err(|e| MalformedError::DeserializedError(data.key.clone(), e))?;
            }
        } else if data.key == *COMPILATION_METADATA_KEY {
            if compilation_key_exist {
                return Err(MalformedError::DuplicateKey);
            }
            compilation_key_exist = true;
            bcs::from_bytes::<CompilationMetadata>(&data.value)
                .map_err(|e| MalformedError::DeserializedError(data.key.clone(), e))?;
        } else {
            return Err(MalformedError::UnknownKey(data.key.clone()));
        }
    }

    Ok(())
}
```

**File:** types/src/vm/module_metadata.rs (L441-444)
```rust
pub fn verify_module_metadata_for_module_publishing(
    module: &CompiledModule,
    features: &Features,
) -> Result<(), MetaDataValidationError> {
```

**File:** types/src/vm/module_metadata.rs (L449-451)
```rust
    if features.are_resource_groups_enabled() {
        check_metadata_format(module)?;
    }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1715-1716)
```rust
            verify_module_metadata_for_module_publishing(m, self.features())
                .map_err(|err| Self::metadata_validation_error(&err.to_string()))?;
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1773-1777)
```rust
    fn metadata_validation_error(msg: &str) -> VMError {
        PartialVMError::new(StatusCode::CONSTRAINT_NOT_SATISFIED)
            .with_message(format!("metadata and code bundle mismatch: {}", msg))
            .finish(Location::Undefined)
    }
```

**File:** types/src/on_chain_config/aptos_features.rs (L183-183)
```rust
            FeatureFlag::RESOURCE_GROUPS,
```

**File:** types/src/on_chain_config/aptos_features.rs (L352-354)
```rust
    pub fn are_resource_groups_enabled(&self) -> bool {
        self.is_enabled(FeatureFlag::RESOURCE_GROUPS)
    }
```
