# Audit Report

## Title
Epoch Ending Backup Manifest Tampering Enables Validator Set Manipulation

## Summary
The epoch ending backup system accepts manifest files without cryptographic integrity verification. When restoring from backups without trusted waypoints, attackers who compromise the backup storage can replace manifest files and epoch ending data with malicious versions that specify attacker-controlled validator sets, completely compromising the restored node's view of the blockchain and enabling consensus safety violations.

## Finding Description

The `EpochEndingBackupMeta` struct stores the manifest FileHandle as an unprotected string [1](#0-0) . This FileHandle is just a type alias for String with no integrity protection [2](#0-1) .

During epoch ending restoration, the manifest is loaded directly from storage without any cryptographic verification [3](#0-2) . The `manifest.verify()` method only checks structural consistency (epoch ranges and chunk continuity) but performs no cryptographic authentication [4](#0-3) .

The critical vulnerability occurs in the verification logic for LedgerInfos. The system checks waypoints from the manifest against waypoints calculated from the chunk data [5](#0-4) , but this only ensures internal consistency, not authenticity. An attacker can create fake LedgerInfos, calculate matching waypoints, and place them in the manifest.

The actual security verification happens in two optional branches [6](#0-5) :
1. Check against trusted waypoints (if provided via `--trust-waypoint`)
2. Verify signatures using the previous LedgerInfo's validator set

For the **first LedgerInfo** in the **first manifest** being restored, when no trusted waypoints are provided, `previous_li` is None (initialized at line 88), so **neither verification branch executes**. The malicious LedgerInfo is accepted without any cryptographic verification and added to the epoch history.

Trusted waypoints are optional [7](#0-6) , and operators may not understand the security implications of omitting them.

**Attack Scenario:**
1. Attacker gains write access to backup storage (e.g., misconfigured S3 bucket)
2. Attacker creates malicious `EpochEndingBackup` manifest with fake waypoints
3. Attacker creates fake chunk files containing `LedgerInfoWithSignatures` with attacker-controlled validator set
4. Victim executes: `aptos-db-restore --epoch-ending-manifest <malicious-handle>` (without `--trust-waypoint` flags)
5. The first epoch's fake validator set is accepted without verification
6. Subsequent epochs chain off this fake genesis, inheriting the malicious validator set
7. The restored node accepts blocks signed by the attacker's validators

## Impact Explanation

This is a **Critical Severity** vulnerability meeting the "Consensus/Safety violations" criterion from the Aptos bug bounty program.

**Specific Impacts:**
- **Consensus Safety Violation**: The restored node has a completely different view of the validator set, violating the fundamental consensus invariant that all honest nodes agree on blockchain state
- **Network Partition Risk**: If multiple nodes restore from tampered backups, they form a parallel network accepting blocks from fake validators, requiring a hard fork to resolve
- **Fund Theft Potential**: Attacker-controlled validator set can approve malicious transactions, potentially draining funds from the compromised chain
- **State Inconsistency**: The compromised node's state diverges from the canonical chain, breaking state consistency guarantees

This breaks Critical Invariant #2: "Consensus Safety: AptosBFT must prevent double-spending and chain splits under < 1/3 Byzantine" - the attack enables chain splits without requiring Byzantine validators.

## Likelihood Explanation

**Likelihood: Medium-High**

**Attacker Requirements:**
- Write access to backup storage (S3/GCS/Azure bucket or local filesystem)
- Victim must restore without providing `--trust-waypoint` flags

**Realistic Attack Vectors:**
1. **Misconfigured Cloud Storage**: S3 buckets with overly permissive access policies are common
2. **Compromised Credentials**: Cloud IAM keys can be stolen via phishing, compromised CI/CD, or insider threats
3. **Supply Chain Attacks**: Compromised backup infrastructure providers
4. **Insider Threats**: Malicious employees with backup storage access

**Exploitation Complexity:** Low
- No cryptographic attacks required
- Simple file replacement operation
- Victim behavior (omitting trusted waypoints) is likely if operators don't understand the security model

**Detection Difficulty:** High
- No integrity checks alert operators to tampering
- Restored node appears to function normally until consensus divergence is discovered

## Recommendation

**Immediate Mitigation:**
1. **Mandate Trusted Waypoints**: Make `--trust-waypoint` required (at minimum for genesis) during restore operations
2. **Document Security Model**: Clearly document that backup storage must be treated as untrusted and trusted waypoints are critical for security

**Long-term Solution:**
Implement cryptographic manifest signing:

```rust
// Add to EpochEndingBackupMeta
pub struct EpochEndingBackupMeta {
    pub first_epoch: u64,
    pub last_epoch: u64,
    pub first_version: Version,
    pub last_version: Version,
    pub manifest: FileHandle,
    pub manifest_signature: Option<Ed25519Signature>,  // NEW: Cryptographic signature
    pub signer_pubkey: Option<Ed25519PublicKey>,       // NEW: Public key for verification
}

// Add verification in restore.rs preheat_impl:
async fn preheat_impl(&self) -> Result<EpochEndingRestorePreheatData> {
    let manifest: EpochEndingBackup = 
        self.storage.load_json_file(&self.manifest_handle).await?;
    
    // Verify manifest signature if present
    if let (Some(sig), Some(pubkey)) = (&manifest.signature, &manifest.signer_pubkey) {
        let manifest_bytes = bcs::to_bytes(&manifest)?;
        sig.verify(&manifest_bytes, pubkey)
            .map_err(|_| anyhow!("Manifest signature verification failed"))?;
    }
    
    manifest.verify()?;
    // ... rest of existing logic
}
```

**Additional Hardening:**
1. Add hash verification for chunk files referenced in manifests
2. Implement backup storage access logging and alerting
3. Add restore operation audit logs with waypoint information
4. Provide tooling to generate trusted waypoints from known-good genesis/checkpoints

## Proof of Concept

```rust
// PoC demonstrating the vulnerability
// This would be added as a test in storage/backup/backup-cli/src/backup_types/epoch_ending/tests.rs

#[tokio::test]
async fn test_manifest_tampering_without_trusted_waypoints() {
    use aptos_types::{
        ledger_info::{LedgerInfo, LedgerInfoWithSignatures},
        validator_verifier::ValidatorVerifier,
        waypoint::Waypoint,
    };
    use std::collections::HashMap;
    
    // Step 1: Create a fake validator set (attacker-controlled)
    let fake_validator_set = create_fake_validator_set();
    
    // Step 2: Create fake genesis LedgerInfo with the malicious validator set
    let fake_genesis_li = LedgerInfo::new(
        BlockInfo::new(0, 0, HashValue::zero(), HashValue::zero(), 0, 0, None),
        HashValue::zero(),
    );
    let fake_genesis_li_with_sigs = LedgerInfoWithSignatures::new(
        fake_genesis_li,
        AggregateSignature::empty(), // No signatures needed - won't be checked!
    );
    
    // Step 3: Create fake manifest with calculated waypoint
    let fake_waypoint = Waypoint::new_epoch_boundary(&fake_genesis_li_with_sigs.ledger_info()).unwrap();
    let fake_manifest = EpochEndingBackup {
        first_epoch: 0,
        last_epoch: 0,
        waypoints: vec![fake_waypoint],
        chunks: vec![/* fake chunk references */],
    };
    
    // Step 4: Save fake manifest and chunks to storage
    let storage = Arc::new(setup_fake_storage_with_tampered_data(fake_manifest, vec![fake_genesis_li_with_sigs]));
    
    // Step 5: Attempt restore WITHOUT trusted waypoints
    let global_opt = GlobalRestoreOptions {
        target_version: Version::MAX,
        trusted_waypoints: Arc::new(HashMap::new()), // EMPTY - no trusted waypoints!
        run_mode: Arc::new(RestoreRunMode::Verify),
        concurrent_downloads: 1,
        replay_concurrency_level: 1,
    };
    
    let controller = EpochHistoryRestoreController::new(
        vec![fake_manifest_handle],
        global_opt,
        storage,
    );
    
    // Step 6: Restore succeeds - fake validator set is accepted!
    let epoch_history = controller.run().await.expect("Restore should succeed");
    
    // Step 7: Verify that the fake validator set was accepted
    assert_eq!(epoch_history.epoch_endings.len(), 1);
    let restored_li = &epoch_history.epoch_endings[0];
    
    // The restored LedgerInfo contains the attacker's validator set
    // This demonstrates complete compromise of the node's blockchain view
    assert!(restored_li.next_epoch_state().is_some());
    // Further assertions would verify the fake validator set is now trusted
}
```

**Reproduction Steps:**
1. Set up local backup storage with epoch ending backups
2. Tamper with manifest file to point to modified chunk files
3. Modify chunk files to contain LedgerInfos with different validator set
4. Run `aptos-db-restore` without `--trust-waypoint` flags
5. Observe that restore succeeds and fake validator set is accepted
6. Verify restored database contains the manipulated epoch ending information

### Citations

**File:** storage/backup/backup-cli/src/metadata/mod.rs (L175-182)
```rust
#[derive(Clone, Debug, Deserialize, Serialize, Eq, PartialEq, Ord, PartialOrd)]
pub struct EpochEndingBackupMeta {
    pub first_epoch: u64,
    pub last_epoch: u64,
    pub first_version: Version,
    pub last_version: Version,
    pub manifest: FileHandle,
}
```

**File:** storage/backup/backup-cli/src/storage/mod.rs (L36-41)
```rust
/// URI pointing to a file in a backup storage, like "s3:///bucket/path/file".
/// These are created by the storage when `create_for_write()`, stored in manifests by the backup
/// controller, and passed back to the storage when `open_for_read()` by the restore controller
/// to retrieve a file referred to in the manifest.
pub type FileHandle = String;
pub type FileHandleRef = str;
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L80-83)
```rust
    async fn preheat_impl(&self) -> Result<EpochEndingRestorePreheatData> {
        let manifest: EpochEndingBackup =
            self.storage.load_json_file(&self.manifest_handle).await?;
        manifest.verify()?;
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L119-128)
```rust
                let wp_manifest = waypoint_iter.next().ok_or_else(|| {
                    anyhow!("More LedgerInfo's found than waypoints in manifest.")
                })?;
                let wp_li = Waypoint::new_epoch_boundary(li.ledger_info())?;
                ensure!(
                    *wp_manifest == wp_li,
                    "Waypoints don't match. In manifest: {}, In chunk: {}",
                    wp_manifest,
                    wp_li,
                );
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L129-147)
```rust
                if let Some(wp_trusted) = self.trusted_waypoints.get(&wp_li.version()) {
                    ensure!(
                        *wp_trusted == wp_li,
                        "Waypoints don't match. In backup: {}, trusted: {}",
                        wp_li,
                        wp_trusted,
                    );
                } else if let Some(pre_li) = previous_li {
                    pre_li
                        .ledger_info()
                        .next_epoch_state()
                        .ok_or_else(|| {
                            anyhow!(
                                "Next epoch state not found from LI at epoch {}.",
                                pre_li.ledger_info().epoch()
                            )
                        })?
                        .verify(&li)?;
                }
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/manifest.rs (L29-68)
```rust
    pub fn verify(&self) -> Result<()> {
        // check number of waypoints
        ensure!(
            self.first_epoch <= self.last_epoch
                && self.last_epoch - self.first_epoch + 1 == self.waypoints.len() as u64,
            "Malformed manifest. first epoch: {}, last epoch {}, num waypoints {}",
            self.first_epoch,
            self.last_epoch,
            self.waypoints.len(),
        );

        // check chunk ranges
        ensure!(!self.chunks.is_empty(), "No chunks.");
        let mut next_epoch = self.first_epoch;
        for chunk in &self.chunks {
            ensure!(
                chunk.first_epoch == next_epoch,
                "Chunk ranges not continuous. Expected first epoch: {}, actual: {}.",
                next_epoch,
                chunk.first_epoch,
            );
            ensure!(
                chunk.last_epoch >= chunk.first_epoch,
                "Chunk range invalid. [{}, {}]",
                chunk.first_epoch,
                chunk.last_epoch,
            );
            next_epoch = chunk.last_epoch + 1;
        }

        // check last epoch in chunk matches manifest
        ensure!(
            next_epoch - 1 == self.last_epoch, // okay to -1 because chunks is not empty.
            "Last epoch in chunks: {}, in manifest: {}",
            next_epoch - 1,
            self.last_epoch,
        );

        Ok(())
    }
```

**File:** storage/backup/backup-cli/src/utils/mod.rs (L331-346)
```rust
#[derive(Clone, Default, Parser)]
pub struct TrustedWaypointOpt {
    #[clap(
        long,
        help = "(multiple) When provided, an epoch ending LedgerInfo at the waypoint version will be \
        checked against the hash in the waypoint, but signatures on it are NOT checked. \
        Use this for two purposes: \
        1. set the genesis or the latest waypoint to confirm the backup is compatible. \
        2. set waypoints at versions where writeset transactions were used to overwrite the \
        validator set, so that the signature check is skipped. \
        N.B. LedgerInfos are verified only when restoring / verifying the epoch ending backups, \
        i.e. they are NOT checked at all when doing one-shot restoring of the transaction \
        and state backups."
    )]
    pub trust_waypoint: Vec<Waypoint>,
}
```
