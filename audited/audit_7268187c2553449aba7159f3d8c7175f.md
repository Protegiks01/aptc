# Audit Report

## Title
Missing Version Validation and ReadOptions in State Snapshot Scanner Allows Data Leakage in Edge Cases

## Summary
The state snapshot scanner in `db_debugger/state_kv/scan_snapshot.rs` creates `ReadOptions` with `prefix_same_as_start=true` but fails to pass it to the database iterator. Additionally, the code does not validate that the returned version matches the expected version or that it satisfies `version <= self.version`. This can cause incorrect entries (including future versions from different keys) to leak into scan results when the database contains inconsistencies.

## Finding Description

The worker thread function contains three critical bugs that violate version ordering guarantees: [1](#0-0) 

**Bug 1: Unused ReadOptions**
The code creates `ReadOptions` and sets `prefix_same_as_start(true)` to ensure the iterator returns `None` when the state key changes. However, it calls `.iter()` instead of `.iter_with_opts(read_opts)`, causing these options to be completely ignored.

Compare with the correct implementation in production code: [2](#0-1) 

**Bug 2: No Key Validation**
The returned key is discarded with `_` pattern matching, meaning the code never verifies that the entry belongs to the expected key. Without `prefix_same_as_start`, the iterator can return entries for different keys.

**Bug 3: No Version Validation**  
The code extracts `value_version` but never validates that:
- `value_version == key_version` (expected version from Merkle tree)
- `value_version <= self.version` (snapshot boundary) [3](#0-2) 

**Attack Scenario:**
When database inconsistencies exist (corrupted entries, missing values, race conditions):

1. Merkle tree at version 100 returns `(keyA, version_50)`  
2. Code seeks to `(keyA.hash(), 50)` in state_kv_db
3. If that entry is missing/corrupted, seek positions at next entry
4. Without `prefix_same_as_start`, next entry could be `(keyB.hash(), version_150)` where `keyB > keyA` lexicographically and `version_150 > 100`
5. Code extracts `version_150` without validation
6. Future version leaks into scan results, violating snapshot isolation

The version encoding (using `!version` for reverse ordering) normally prevents future versions from the same key from leaking, but does NOT prevent future versions from different keys when the prefix boundary is not enforced: [4](#0-3) 

## Impact Explanation

**Severity Assessment: Medium** 

This qualifies as **Medium severity** under the "State inconsistencies requiring intervention" category because:

1. **Debugging Tool Corruption**: The scanner is designed to validate database consistency and detect corruption. If it produces incorrect results, operators may miss real corruption or incorrectly flag valid data.

2. **Snapshot Isolation Violation**: The tool explicitly scans snapshots at a specific version for debugging purposes. Leaking future versions violates the fundamental snapshot isolation guarantee and produces meaningless diagnostic output.

3. **Operational Impact**: Incorrect scan results could lead to:
   - Failed database recovery operations
   - Incorrect corruption detection
   - Wasted operator time investigating false positives/negatives
   - Potential data loss if operators make decisions based on bad scan results

While this is not consensus-critical production code, it affects the reliability of critical database operations and debugging workflows that directly support blockchain operations.

## Likelihood Explanation

**Likelihood: Medium-Low**

The vulnerability requires:
1. Running the db_debugger scan tool (common for database validation)
2. Database inconsistencies (missing entries, corruption) - can occur due to hardware failures, bugs, or incomplete writes
3. Specific key ordering where a different key's entry follows the missing entry

While db_debugger is not run in the hot path, it is regularly used by operators for:
- Validating database snapshots before restoration
- Debugging state synchronization issues  
- Investigating reported corruption
- Database migration validation

The likelihood increases during high-stress scenarios (node failures, recovery operations) when database validation is most critical and inconsistencies are more likely.

## Recommendation

**Fix 1: Use ReadOptions correctly**
```rust
let (value_version, value) = if enable_sharding {
    let mut iter = state_kv_db
        .db_shard(key.get_shard_id())
        .iter_with_opts::<StateValueByKeyHashSchema>(read_opts)?; // Use iter_with_opts
    iter.seek(&(key.hash(), key_version))?;
    // ... rest of code
```

**Fix 2: Validate returned entry**
```rust
.and_then(|((returned_hash, version), value_opt)| {
    // Validate key matches
    if returned_hash != key.hash() {
        return None; // Different key, skip
    }
    // Validate version is not from future
    if version > self.version {
        panic!("Future version {} leaked into snapshot at version {}", version, self.version);
    }
    // Validate version matches expected
    if version != key_version {
        panic!("Version mismatch: expected {}, got {}", key_version, version);
    }
    value_opt.map(|value| (version, value))
})
```

## Proof of Concept

**Setup**: Create a database with intentional inconsistency where the Merkle tree references a missing entry, and a subsequent key has a future version.

```rust
#[test]
fn test_future_version_leak() {
    // 1. Create database with state at version 100
    // 2. Add entry for keyA at version 50 to Merkle tree
    // 3. Remove (keyA, 50) from state_kv_db (simulate corruption)
    // 4. Add (keyB, 150) where keyB > keyA lexicographically
    // 5. Run scan_snapshot at version 100
    // 6. Observe that version 150 appears in results despite 150 > 100
    
    // Expected: Scan should fail or return None
    // Actual: Scan returns (keyB, 150) without validation
    
    // This demonstrates:
    // - Missing ReadOptions causes iteration across key boundaries
    // - Missing validation accepts future version 150 > snapshot version 100
    // - Violates snapshot isolation guarantee
}
```

**Notes:**

While this vulnerability exists in debugging code rather than consensus-critical paths, it has real operational impact because incorrect diagnostic tools can lead to wrong decisions during critical database operations. The fix is straightforward: use the ReadOptions that are already created, and add validation checks that should have been present from the start to enforce snapshot isolation guarantees.

### Citations

**File:** storage/aptosdb/src/db_debugger/state_kv/scan_snapshot.rs (L79-111)
```rust
                            let mut read_opts = ReadOptions::default();
                            // We want `None` if the state_key changes in iteration.
                            read_opts.set_prefix_same_as_start(true);

                            let enable_sharding = state_kv_db.enabled_sharding();

                            let (value_version, value) = if enable_sharding {
                                let mut iter = state_kv_db
                                    .db_shard(key.get_shard_id())
                                    .iter::<StateValueByKeyHashSchema>()
                                    .unwrap();
                                iter.seek(&(key.hash(), key_version)).unwrap();
                                iter.next()
                                    .transpose()
                                    .unwrap()
                                    .and_then(|((_, version), value_opt)| {
                                        value_opt.map(|value| (version, value))
                                    })
                                    .expect("Value must exist.")
                            } else {
                                let mut iter = state_kv_db
                                    .db_shard(key.get_shard_id())
                                    .iter::<StateValueSchema>()
                                    .unwrap();
                                iter.seek(&(key.clone(), key_version)).unwrap();
                                iter.next()
                                    .transpose()
                                    .unwrap()
                                    .and_then(|((_, version), value_opt)| {
                                        value_opt.map(|value| (version, value))
                                    })
                                    .expect("Value must exist.")
                            };
```

**File:** storage/aptosdb/src/db_debugger/state_kv/scan_snapshot.rs (L114-116)
```rust
                            result_tx
                                .send((index, key, key_version, value_version, value, elapsed))
                                .unwrap();
```

**File:** storage/aptosdb/src/state_kv_db.rs (L379-401)
```rust
        let mut read_opts = ReadOptions::default();

        // We want `None` if the state_key changes in iteration.
        read_opts.set_prefix_same_as_start(true);
        if !self.enabled_sharding() {
            let mut iter = self
                .db_shard(state_key.get_shard_id())
                .iter_with_opts::<StateValueSchema>(read_opts)?;
            iter.seek(&(state_key.clone(), version))?;
            Ok(iter
                .next()
                .transpose()?
                .and_then(|((_, version), value_opt)| value_opt.map(|value| (version, value))))
        } else {
            let mut iter = self
                .db_shard(state_key.get_shard_id())
                .iter_with_opts::<StateValueByKeyHashSchema>(read_opts)?;
            iter.seek(&(state_key.hash(), version))?;
            Ok(iter
                .next()
                .transpose()?
                .and_then(|((_, version), value_opt)| value_opt.map(|value| (version, value))))
        }
```

**File:** storage/aptosdb/src/schema/state_value_by_key_hash/mod.rs (L37-43)
```rust
impl KeyCodec<StateValueByKeyHashSchema> for Key {
    fn encode_key(&self) -> Result<Vec<u8>> {
        let mut encoded = vec![];
        encoded.write_all(self.0.as_ref())?;
        encoded.write_u64::<BigEndian>(!self.1)?;
        Ok(encoded)
    }
```
