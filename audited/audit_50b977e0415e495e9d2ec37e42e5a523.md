# Audit Report

## Title 
Non-Atomic Config File Write Enables Private Key Corruption and CLI Denial of Service

## Summary
The `CliConfig::save()` method in the Aptos CLI tool uses a non-atomic file write operation that truncates the config file before writing new content. If the write operation fails mid-execution due to disk space exhaustion or I/O errors, the config file is left in a corrupted state containing partial YAML data, potentially exposing fragments of Ed25519 private keys and rendering the CLI unusable.

## Finding Description

The vulnerability exists in the config persistence mechanism used by the Aptos CLI initialization flow: [1](#0-0) 

The `config.save()` method implementation uses a non-atomic write pattern: [2](#0-1) 

This calls `write_to_user_only_file()`, which performs the actual write operation: [3](#0-2) 

**The Critical Flaw:**

The file is opened with `.truncate(true)`, which immediately clears the file to 0 bytes **before** writing new content. If `file.write_all(bytes)` fails mid-write, the original config is permanently lost and replaced with partial YAML data.

**Sensitive Data at Risk:**

The config stores Ed25519 private keys in plaintext: [4](#0-3) 

These private keys are set during initialization: [5](#0-4) 

**Attack Scenarios:**

1. **Disk Space Exhaustion**: User runs `aptos init` with limited disk space. The config write begins, truncates the file, but fails when disk fills during the YAML write. Result: Corrupted config with partial private key bytes.

2. **I/O Errors**: Filesystem errors, hardware issues, or system crash during write leaves the config file in an inconsistent state with incomplete YAML structure.

3. **Process Termination**: If the process is killed (SIGKILL, system shutdown) during the write operation, partial data remains in the file.

**Security Impact:**

- **Private Key Fragment Exposure**: If the write fails after writing part of the private key field but before completion, the file contains partial key material. While not directly usable, this reduces the entropy for brute force attacks and may expose recognizable patterns in the key encoding.

- **Denial of Service**: Corrupted YAML cannot be parsed by subsequent CLI commands. The user loses access to their CLI profile and the private key stored within it. If this was the only copy of the key, funds become inaccessible.

- **No Recovery Mechanism**: The original config is destroyed the moment the file is truncated. There is no rollback, backup, or atomic rename mechanism.

## Impact Explanation

This qualifies as **Medium Severity** under the Aptos bug bounty criteria for the following reasons:

1. **State Inconsistencies Requiring Intervention** (Medium criterion): The corrupted config file prevents normal CLI operation. Users must manually intervene to recover, potentially losing access to their private keys if not backed up elsewhere.

2. **Limited Funds Loss or Manipulation** (Medium criterion): If a user's private key is only stored in this config file and the corruption occurs before backup, they lose access to on-chain funds controlled by that key. While users should maintain backups, the non-atomic write creates an unnecessary risk window.

3. **Information Disclosure**: Partial private key exposure (even fragments) constitutes a security weakness that violates the principle of secure key storage.

This does not qualify as Critical or High severity because:
- It affects individual CLI users, not the validator network or consensus
- It does not directly compromise blockchain state or validator operations
- It requires specific environmental conditions (disk/I/O errors)

## Likelihood Explanation

This vulnerability has **Medium to High likelihood** of occurring in real-world scenarios:

**Common Triggering Conditions:**
- Disk space exhaustion on developer machines or CI/CD systems
- Network-mounted filesystems with connectivity issues
- Docker containers with storage quotas
- Cloud VMs with disk limits
- Hardware failures (disk errors, USB drive disconnection)
- System crashes or power outages during write
- Process termination (user CTRL-C, OOM killer)

**User Population at Risk:**
- New users running `aptos init` for the first time
- Developers frequently reinitializing profiles
- Automated scripts running CLI operations in constrained environments
- Users on systems with unreliable storage

The likelihood is elevated because `aptos init` is one of the first commands new users execute, often in unfamiliar environments where disk space or I/O reliability may not have been verified.

## Recommendation

Implement atomic file writes using the write-to-temporary-file-then-rename pattern:

```rust
pub fn save(&self) -> CliTypedResult<()> {
    let aptos_folder = Self::aptos_folder(ConfigSearchMode::CurrentDir)?;
    let no_dir = !aptos_folder.exists();
    create_dir_if_not_exist(aptos_folder.as_path())?;

    if no_dir {
        write_to_user_only_file(
            aptos_folder.join(GIT_IGNORE).as_path(),
            GIT_IGNORE,
            APTOS_FOLDER_GIT_IGNORE.as_bytes(),
        )?;
    }

    // FIX: Write to temporary file first
    let config_file = aptos_folder.join(CONFIG_FILE);
    let temp_file = aptos_folder.join(".config.yaml.tmp");
    
    let config_bytes = serde_yaml::to_string(&self).map_err(|err| {
        CliError::UnexpectedError(format!("Failed to serialize config {}", err))
    })?;
    
    // Write to temp file
    write_to_user_only_file(&temp_file, "temp config", config_bytes.as_bytes())?;
    
    // Sync to disk before rename
    if let Ok(file) = std::fs::File::open(&temp_file) {
        let _ = file.sync_all();
    }
    
    // Atomic rename (POSIX guarantee)
    std::fs::rename(&temp_file, &config_file)
        .map_err(|e| CliError::IO(CONFIG_FILE.to_string(), e))?;

    // Cleanup legacy file
    let legacy_config_file = aptos_folder.join(LEGACY_CONFIG_FILE);
    if legacy_config_file.exists() {
        eprintln!("Removing legacy config file {}", LEGACY_CONFIG_FILE);
        let _ = std::fs::remove_file(legacy_config_file);
    }
    Ok(())
}
```

**Why This Fix Works:**
1. Writes complete config to temporary file
2. Syncs to disk to ensure data persistence
3. Uses `std::fs::rename()` which is atomic on POSIX systems
4. Either the old file exists (if rename fails) or the new file exists (if rename succeeds)
5. Never leaves the config in a partial state

## Proof of Concept

```rust
#[cfg(test)]
mod test {
    use super::*;
    use std::fs;
    use std::io::Write;
    use tempfile::TempDir;

    #[test]
    fn test_config_corruption_on_disk_full() {
        // Create a temporary directory for testing
        let temp_dir = TempDir::new().unwrap();
        let aptos_folder = temp_dir.path().join(".aptos");
        fs::create_dir_all(&aptos_folder).unwrap();

        // Create an initial valid config
        let mut config = CliConfig::default();
        let mut profile = ProfileConfig::default();
        
        // Simulate a private key (using deterministic bytes for testing)
        let private_key_bytes = [0x42u8; 32];
        let private_key = Ed25519PrivateKey::try_from(&private_key_bytes[..]).unwrap();
        profile.private_key = Some(private_key);
        
        config.profiles = Some(BTreeMap::new());
        config.profiles.as_mut().unwrap().insert("test".to_string(), profile);

        // Manually write the config using the vulnerable method
        let config_file = aptos_folder.join("config.yaml");
        let config_yaml = serde_yaml::to_string(&config).unwrap();
        
        // Simulate disk full by writing partial content
        // This mimics what happens when write_all fails mid-write
        let mut file = fs::OpenOptions::new()
            .write(true)
            .create(true)
            .truncate(true)  // This truncates the file to 0 immediately
            .open(&config_file)
            .unwrap();
        
        // Write only first 50 bytes to simulate partial write
        let partial_bytes = &config_yaml.as_bytes()[..50.min(config_yaml.len())];
        file.write_all(partial_bytes).unwrap();
        drop(file);

        // Now try to load the config - it should fail with parse error
        let result = fs::read_to_string(&config_file).unwrap();
        let parse_result = serde_yaml::from_str::<CliConfig>(&result);
        
        // Verify that parsing fails due to corrupted YAML
        assert!(parse_result.is_err(), "Corrupted config should fail to parse");
        
        // Verify that the file contains partial data (corrupted state)
        assert_eq!(result.len(), 50, "File should contain only partial data");
        
        println!("PoC: Config file successfully corrupted with partial YAML");
        println!("Partial content: {:?}", result);
        println!("This demonstrates that a failed write leaves the config in an unusable state");
    }
}
```

**To Run:**
```bash
cd crates/aptos
cargo test test_config_corruption_on_disk_full -- --nocapture
```

**Expected Output:**
- Test demonstrates that truncate+partial write leaves corrupted YAML
- Parsing fails with YAML syntax error
- Original config is permanently lost
- Private key data may be partially exposed in the corrupted file

## Notes

This vulnerability specifically affects the **Aptos CLI tool** (client-side), not the core validator/consensus components. It does not impact blockchain consensus, validator operations, or on-chain state integrity. However, it represents a legitimate security and usability issue for CLI users who may lose access to their private keys and experience denial of service when using the tool.

The atomic write pattern (temp file + rename) is a well-established best practice for persisting sensitive configuration data and should be implemented for all config file writes in the CLI tool.

### Citations

**File:** crates/aptos/src/common/init.rs (L280-282)
```rust
        profile_config.private_key = private_key;
        profile_config.public_key = Some(public_key);
        profile_config.account = Some(address);
```

**File:** crates/aptos/src/common/init.rs (L333-333)
```rust
        config.save()?;
```

**File:** crates/aptos/src/common/types.rs (L276-282)
```rust
    #[serde(
        skip_serializing_if = "Option::is_none",
        default,
        serialize_with = "serialize_material_with_prefix",
        deserialize_with = "deserialize_material_with_prefix"
    )]
    pub private_key: Option<Ed25519PrivateKey>,
```

**File:** crates/aptos/src/common/types.rs (L423-445)
```rust
    pub fn save(&self) -> CliTypedResult<()> {
        let aptos_folder = Self::aptos_folder(ConfigSearchMode::CurrentDir)?;

        // Create if it doesn't exist
        let no_dir = !aptos_folder.exists();
        create_dir_if_not_exist(aptos_folder.as_path())?;

        // If the `.aptos/` doesn't exist, we'll add a .gitignore in it to ignore the config file
        // so people don't save their credentials...
        if no_dir {
            write_to_user_only_file(
                aptos_folder.join(GIT_IGNORE).as_path(),
                GIT_IGNORE,
                APTOS_FOLDER_GIT_IGNORE.as_bytes(),
            )?;
        }

        // Save over previous config file
        let config_file = aptos_folder.join(CONFIG_FILE);
        let config_bytes = serde_yaml::to_string(&self).map_err(|err| {
            CliError::UnexpectedError(format!("Failed to serialize config {}", err))
        })?;
        write_to_user_only_file(&config_file, CONFIG_FILE, config_bytes.as_bytes())?;
```

**File:** crates/aptos/src/common/utils.rs (L224-246)
```rust
pub fn write_to_user_only_file(path: &Path, name: &str, bytes: &[u8]) -> CliTypedResult<()> {
    let mut opts = OpenOptions::new();
    #[cfg(unix)]
    opts.mode(0o600);
    write_to_file_with_opts(path, name, bytes, &mut opts)
}

/// Write a `&[u8]` to a file with the given options
pub fn write_to_file_with_opts(
    path: &Path,
    name: &str,
    bytes: &[u8],
    opts: &mut OpenOptions,
) -> CliTypedResult<()> {
    let mut file = opts
        .write(true)
        .create(true)
        .truncate(true)
        .open(path)
        .map_err(|e| CliError::IO(name.to_string(), e))?;
    file.write_all(bytes)
        .map_err(|e| CliError::IO(name.to_string(), e))
}
```
