# Audit Report

## Title
Consensus Safety Bypass via Configuration Sanitizer Escape Hatch on Mainnet Validators

## Summary
The `skip_config_sanitizer` flag in `NodeStartupConfig` allows node operators to bypass critical mainnet-specific security validations, including mandatory runtime type safety checks and validator network mutual authentication requirements. This creates execution path divergence where validators with different configurations will produce different outcomes for the same transactions, leading to consensus splits and potential network partition.

## Finding Description

The vulnerability exists in the node configuration startup flow where two boolean flags create an escape hatch that bypasses essential security controls: [1](#0-0) 

When `skip_config_sanitizer` is set to `true`, the sanitization process returns early without performing any validation: [2](#0-1) 

This bypasses multiple **critical** mainnet-specific security checks:

**1. Move VM Runtime Type Safety Bypass:**
The sanitizer enforces that mainnet validators MUST enable paranoid type verification: [3](#0-2) 

These paranoid checks perform runtime validation that "type safety cannot be violated at runtime": [4](#0-3) 

The execution config flows directly to VM configuration: [5](#0-4) 

When paranoid checks are disabled (via `NoRuntimeTypeCheck`), ALL runtime type validations are skipped: [6](#0-5) 

**2. Validator Network Mutual Authentication Bypass:**
The sanitizer also enforces that validators MUST enable mutual authentication: [7](#0-6) 

**Exploitation Scenario:**

A malicious or misconfigured validator sets these config values:
```yaml
node_startup:
  skip_config_sanitizer: true
execution:
  paranoid_type_verification: false
  paranoid_hot_potato_verification: false
```

When a transaction containing Move bytecode with type violations (that should fail paranoid checks) is executed:

- **Validators with sanitizer enabled (majority):** Paranoid checks detect type violation → transaction fails with `UNKNOWN_INVARIANT_VIOLATION_ERROR` → specific state root
- **Validator with sanitizer bypassed:** No paranoid checks → execution continues with undefined behavior → different state root or crash

This breaks the **Deterministic Execution** invariant: validators no longer produce identical state roots for identical blocks.

## Impact Explanation

**CRITICAL Severity** - This vulnerability enables:

1. **Consensus Safety Violation:** Different validators produce different state roots for the same block, breaking BFT consensus safety guarantees. This can cause:
   - Chain splits requiring emergency intervention
   - Network partition if validators disagree on block validity
   - Potential hardfork requirement for recovery

2. **Determinism Failure:** The core blockchain invariant that "all validators must produce identical state roots for identical blocks" is violated, allowing divergent execution paths on the same transaction set.

3. **Network Security Compromise:** Disabling mutual authentication on validator networks allows unauthorized connections and potential man-in-the-middle attacks between validators.

This directly maps to the Critical severity category: "Consensus/Safety violations" and "Non-recoverable network partition (requires hardfork)".

## Likelihood Explanation

**Medium-High Likelihood:**

1. **Easy to trigger:** Requires only YAML config modification by a single validator operator
2. **No special privileges needed beyond node operation:** Any validator can set these flags
3. **Misconfiguration risk:** Advanced operators seeking "performance optimization" might disable sanitization without understanding security implications
4. **Poor visibility:** The test suite explicitly demonstrates this bypass is intentional: [8](#0-7) 

5. **Production impact:** Even one misconfigured validator can cause consensus issues affecting the entire network

## Recommendation

**Remove the escape hatch flags entirely** or make them compile-time only (not runtime configurable). These flags were likely intended for development/testing but create unacceptable security risks in production.

**Immediate fix:**

1. **Hard-code mainnet enforcement:**
```rust
impl ConfigSanitizer for NodeConfig {
    fn sanitize(
        node_config: &NodeConfig,
        node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        // NEVER skip sanitization on mainnet
        if let Some(chain_id) = chain_id {
            if chain_id.is_mainnet() && node_config.node_startup.skip_config_sanitizer {
                return Err(Error::ConfigSanitizerFailed(
                    "NodeConfigSanitizer".to_string(),
                    "skip_config_sanitizer cannot be enabled on mainnet!".into(),
                ));
            }
        }
        
        // Original sanitization logic (don't allow early return)
        if node_config.node_startup.skip_config_sanitizer {
            // Only allow on non-mainnet chains
            if let Some(chain_id) = chain_id {
                if !chain_id.is_mainnet() {
                    return Ok(());
                }
            }
        }
        
        // Perform all sanitization checks...
    }
}
```

2. **Add runtime assertion** in node startup that validates mainnet nodes cannot have these flags enabled

3. **Remove the flags entirely** in future versions - they represent dangerous technical debt

## Proof of Concept

```rust
// Reproduction steps:
// 1. Create two validator configs for mainnet

// validator_a.yaml (honest validator)
node_startup:
  skip_config_sanitizer: false
execution:
  paranoid_type_verification: true
  paranoid_hot_potato_verification: true

// validator_b.yaml (misconfigured/malicious validator)  
node_startup:
  skip_config_sanitizer: true
execution:
  paranoid_type_verification: false
  paranoid_hot_potato_verification: false

// 2. Submit a Move transaction that triggers type violation in paranoid checks
//    (e.g., struct field with wrong ability set, or type assignability violation)

// 3. Validator A will execute with paranoid checks:
//    - Type violation detected
//    - Transaction fails with UNKNOWN_INVARIANT_VIOLATION_ERROR  
//    - State root = H(S + FAILURE)

// 4. Validator B will execute without paranoid checks:
//    - Type violation NOT detected
//    - Undefined behavior occurs (may succeed, crash, or produce garbage)
//    - State root = H(S + ???) ≠ Validator A's state root

// 5. Validators cannot agree on block validity → consensus failure

// Test demonstrating sanitizer bypass is allowed:
#[test]
fn test_mainnet_sanitizer_bypass() {
    let mut node_config = NodeConfig {
        node_startup: NodeStartupConfig {
            skip_config_sanitizer: true,
            ..Default::default()
        },
        execution: ExecutionConfig {
            paranoid_type_verification: false, // INVALID on mainnet!
            paranoid_hot_potato_verification: false, // INVALID on mainnet!
            ..Default::default()
        },
        ..Default::default()
    };
    
    // This SHOULD fail but currently passes due to sanitizer bypass
    let result = NodeConfig::sanitize(
        &node_config, 
        NodeType::Validator, 
        Some(ChainId::mainnet())
    );
    
    assert!(result.is_ok()); // BUG: Sanitization bypassed on mainnet!
}
```

## Notes

The existence of these escape hatch flags fundamentally expands the attack surface by creating multiple execution paths (with/without critical safety checks) that validators can choose between. This violates the principle that all validators must execute identical logic to maintain consensus safety. While intended as development conveniences, these flags create a severe production vulnerability that enables consensus splits through configuration alone.

### Citations

**File:** config/src/config/node_startup_config.rs (L8-11)
```rust
pub struct NodeStartupConfig {
    pub skip_config_optimizer: bool, // Whether or not to skip the config optimizer at startup
    pub skip_config_sanitizer: bool, // Whether or not to skip the config sanitizer at startup
}
```

**File:** config/src/config/config_sanitizer.rs (L45-48)
```rust
        // If config sanitization is disabled, don't do anything!
        if node_config.node_startup.skip_config_sanitizer {
            return Ok(());
        }
```

**File:** config/src/config/config_sanitizer.rs (L191-197)
```rust
        // Ensure that mutual authentication is enabled
        if !validator_network_config.mutual_authentication {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "Mutual authentication must be enabled for the validator network!".into(),
            ));
        }
```

**File:** config/src/config/config_sanitizer.rs (L212-239)
```rust
    fn test_disable_config_sanitizer() {
        // Create a default node config (with sanitization enabled)
        let mut node_config = NodeConfig::default();

        // Set a bad node config for mainnet
        node_config.execution.paranoid_hot_potato_verification = false;

        // Sanitize the config and verify the sanitizer fails
        let error =
            NodeConfig::sanitize(&node_config, NodeType::Validator, Some(ChainId::mainnet()))
                .unwrap_err();
        assert!(matches!(error, Error::ConfigSanitizerFailed(_, _)));

        // Create a node config with the sanitizer disabled
        let mut node_config = NodeConfig {
            node_startup: NodeStartupConfig {
                skip_config_sanitizer: true,
                ..Default::default()
            },
            ..Default::default()
        };

        // Set a bad node config for mainnet
        node_config.execution.paranoid_hot_potato_verification = false;

        // Sanitize the config and verify the sanitizer passes
        NodeConfig::sanitize(&node_config, NodeType::Validator, Some(ChainId::mainnet())).unwrap();
    }
```

**File:** config/src/config/execution_config.rs (L166-183)
```rust
        // If this is a mainnet node, ensure that additional verifiers are enabled
        if let Some(chain_id) = chain_id {
            if chain_id.is_mainnet() {
                if !execution_config.paranoid_hot_potato_verification {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "paranoid_hot_potato_verification must be enabled for mainnet nodes!"
                            .into(),
                    ));
                }
                if !execution_config.paranoid_type_verification {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "paranoid_type_verification must be enabled for mainnet nodes!".into(),
                    ));
                }
            }
        }
```

**File:** third_party/move/move-vm/runtime/src/config.rs (L18-22)
```rust
    /// When this flag is set to true, MoveVM will perform type checks at every instruction
    /// execution to ensure that type safety cannot be violated at runtime. Note: these
    /// are more than type checks, for example, stack balancing, visibility, but the name
    /// is kept for historical reasons.
    pub paranoid_type_checks: bool,
```

**File:** aptos-node/src/utils.rs (L53-56)
```rust
pub fn set_aptos_vm_configurations(node_config: &NodeConfig) {
    set_layout_caches(node_config.execution.layout_caches_enabled);
    set_paranoid_type_checks(node_config.execution.paranoid_type_verification);
    set_async_runtime_checks(node_config.execution.async_runtime_checks);
```

**File:** third_party/move/move-vm/runtime/src/runtime_type_checks.rs (L220-252)
```rust
impl RuntimeTypeCheck for NoRuntimeTypeCheck {
    #[cfg_attr(feature = "force-inline", inline(always))]
    fn pre_execution_type_stack_transition(
        _frame: &Frame,
        _operand_stack: &mut Stack,
        _instruction: &Instruction,
        _ty_cache: &mut FrameTypeCache,
    ) -> PartialVMResult<()> {
        Ok(())
    }

    #[cfg_attr(feature = "force-inline", inline(always))]
    fn post_execution_type_stack_transition(
        _frame: &Frame,
        _operand_stack: &mut Stack,
        _instruction: &Instruction,
        _ty_cache: &mut FrameTypeCache,
    ) -> PartialVMResult<()> {
        Ok(())
    }

    #[cfg_attr(feature = "force-inline", inline(always))]
    fn should_perform_checks(_for_fun: &Function) -> bool {
        false
    }

    #[cfg_attr(feature = "force-inline", inline(always))]
    fn check_cross_module_regular_call_visibility(
        _caller: &LoadedFunction,
        _callee: &LoadedFunction,
    ) -> PartialVMResult<()> {
        Ok(())
    }
```
