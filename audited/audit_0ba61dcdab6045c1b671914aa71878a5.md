# Audit Report

## Title
Unauthenticated Access to Sensitive Validator Information via Inspection Service Enables Targeted Network Attacks

## Summary
The Aptos inspection service exposes highly sensitive validator information (peer IDs, network topology, connection metadata, consensus metrics, and system details) over HTTP without any authentication or authorization mechanism. By default, the service binds to all network interfaces (`0.0.0.0`) with multiple sensitive endpoints enabled, allowing any network attacker to reconnaissance the validator network and gather intelligence for targeted attacks on consensus nodes.

## Finding Description

The `start_inspection_service()` function initializes an HTTP server that handles multiple diagnostic endpoints without implementing any authentication checks. [1](#0-0) 

The `serve_requests()` function processes all incoming HTTP requests by routing them to various endpoint handlers based on the URI path, with no authentication or authorization validation whatsoever. [2](#0-1) 

The service's default configuration binds to all network interfaces (`0.0.0.0:9101`) with three critical endpoints enabled by default that expose sensitive validator information: [3](#0-2) 

**Sensitive Information Exposed:**

1. **Identity Information Endpoint** (`/identity_information`) - Enabled by default, exposes validator peer IDs and network identifiers without authentication: [4](#0-3) 

2. **Peer Information Endpoint** (`/peer_information`) - Enabled by default, exposes detailed peer connection metadata, trusted peer sets, state sync data, and internal client state: [5](#0-4) 

3. **System Information Endpoint** (`/system_information`) - Enabled by default, exposes system and build information: [6](#0-5) 

4. **Metrics Endpoints** (`/metrics`, `/json_metrics`, `/forge_metrics`, `/consensus_health_check`) - Always accessible with no configuration flag to disable them, exposing all node metrics including consensus participation status: [7](#0-6) 

While the configuration system includes a sanitizer to prevent mainnet validators from exposing the `/configuration` endpoint, **it does not restrict the other highly sensitive endpoints**: [8](#0-7) 

**Exploitation Path:**

1. Attacker scans for validators exposing port 9101 (default inspection service port)
2. Attacker sends HTTP GET request to `http://VALIDATOR_IP:9101/identity_information`
3. Response reveals validator peer IDs and network configuration
4. Attacker queries `http://VALIDATOR_IP:9101/peer_information` 
5. Response exposes complete network topology, trusted peer sets, connection states, and state sync metadata
6. Attacker queries `http://VALIDATOR_IP:9101/metrics` or `/consensus_health_check`
7. Response reveals consensus participation status, performance metrics, and operational state
8. Attacker uses this intelligence to identify specific validators for targeted attacks (e.g., eclipse attacks, targeted DoS, consensus manipulation)

In contrast, the Admin Service implements proper authentication using passcode verification before exposing sensitive operations: [9](#0-8) 

## Impact Explanation

**Severity: CRITICAL**

This vulnerability qualifies as **Critical Severity** under the Aptos Bug Bounty program for the following reasons:

1. **Enables Targeted Consensus Attacks**: By revealing the complete validator network topology, peer connections, and consensus participation patterns, attackers can identify specific validators to target for eclipse attacks, network partitioning, or consensus disruption. This directly threatens **Consensus Safety** (Critical Invariant #2).

2. **Facilitates Network-Level Attacks**: The exposed peer information reveals trusted peer sets, connection metadata, and network identifiers, enabling attackers to craft sophisticated network attacks targeting specific validators or network segments.

3. **No Authentication Required**: Unlike the Admin Service which requires passcode authentication, the inspection service has zero authentication barriers. Any attacker who can reach the service port can access all information.

4. **Default Configuration is Insecure**: The service binds to `0.0.0.0` (all interfaces) by default with sensitive endpoints enabled, maximizing the attack surface. Operators must actively secure it rather than it being secure by default.

5. **Reconnaissance for Advanced Attacks**: The information disclosed (validator identities, network topology, consensus state) provides the intelligence needed to launch sophisticated attacks on the Aptos network, potentially leading to consensus violations or network partition.

While this is primarily an information disclosure vulnerability, the intelligence gathered enables attacks that could result in:
- Consensus safety violations through targeted validator attacks
- Network partition through strategic peer manipulation
- Eclipse attacks isolating specific validators
- Denial of service targeting critical network nodes

## Likelihood Explanation

**Likelihood: HIGH**

The likelihood of exploitation is high because:

1. **Common Misconfiguration**: Validator operators may forget to configure firewall rules to restrict access to port 9101, especially during initial setup or testing phases.

2. **Default Configuration is Vulnerable**: The service is enabled by default when nodes start, binds to all interfaces, and has sensitive endpoints enabled. Security depends entirely on external firewall configuration.

3. **No Warning or Documentation**: The code contains no warnings about the security implications of exposing this service, and operators may not realize they need to protect it.

4. **Simple Exploitation**: No special tools or sophisticated techniques are required - simple HTTP GET requests reveal all information.

5. **High-Value Target**: Validator nodes are high-value targets for attackers seeking to disrupt consensus or gain network intelligence.

6. **Real-World Precedent**: History shows that services relying solely on network-level protection (without application-level authentication) frequently get exposed due to configuration errors, cloud misconfigurations, or evolving network architectures.

## Recommendation

Implement application-level authentication for the inspection service similar to the Admin Service pattern. This should include:

1. **Add Authentication Configuration**:
   - Extend `InspectionServiceConfig` to include `authentication_configs` field similar to `AdminServiceConfig`
   - Support multiple authentication methods (minimally, passcode SHA256)

2. **Implement Authentication Logic**:
   - Add authentication validation in `serve_requests()` before processing any endpoint
   - Return HTTP 511 (Network Authentication Required) for unauthenticated requests
   - Allow bypass only if `authentication_configs` is explicitly empty (opt-in to no auth)

3. **Update Default Configuration**:
   - Require authentication by default
   - Consider binding to `127.0.0.1` (localhost) by default instead of `0.0.0.0`
   - Add configuration validation warnings when binding to all interfaces without authentication

4. **Add Security Documentation**:
   - Document security implications in config files
   - Add warnings about exposing the service to untrusted networks
   - Provide example secure configurations

**Code Fix Example** (for `serve_requests()` function):

```rust
async fn serve_requests(
    req: Request<Body>,
    node_config: NodeConfig,
    aptos_data_client: AptosDataClient,
    peers_and_metadata: Arc<PeersAndMetadata>,
) -> Result<Response<Body>, hyper::Error> {
    // AUTHENTICATION CHECK - Add before processing requests
    let mut authenticated = false;
    if node_config.inspection_service.authentication_configs.is_empty() {
        authenticated = true;
    } else {
        for authentication_config in &node_config.inspection_service.authentication_configs {
            match authentication_config {
                AuthenticationConfig::PasscodeSha256(passcode_sha256) => {
                    let query = req.uri().query().unwrap_or("");
                    let query_pairs: HashMap<_, _> =
                        url::form_urlencoded::parse(query.as_bytes()).collect();
                    if let Some(passcode) = query_pairs.get("passcode").map(|p| p.to_string()) {
                        if sha256::digest(passcode) == *passcode_sha256 {
                            authenticated = true;
                        }
                    }
                },
            }
        }
    }

    if !authenticated {
        return Ok(Response::builder()
            .status(StatusCode::NETWORK_AUTHENTICATION_REQUIRED)
            .body(Body::from("Authentication required to access inspection service"))
            .unwrap());
    }

    // Continue with existing endpoint routing...
    let (status_code, body, content_type) = match req.uri().path() {
        // ... existing endpoint handlers
    };
    // ... rest of function
}
```

## Proof of Concept

**Setup**: Start an Aptos validator node with default inspection service configuration.

**Exploitation Steps**:

```bash
# Step 1: Enumerate validator identity information
curl http://VALIDATOR_IP:9101/identity_information

# Expected Response (no authentication required):
# Identity Information:
#   - Validator network (Validator), peer ID: <VALIDATOR_PEER_ID>
#   - Fullnode network (Public), peer ID: <FULLNODE_PEER_ID>

# Step 2: Retrieve complete peer network topology
curl http://VALIDATOR_IP:9101/peer_information

# Expected Response (no authentication required):
# Peer information summary:
#   - Number of peers: X
#   - Registered networks: [Validator, Public]
#   - Peers and network IDs: [...]
# Connection metadata for each peer:
#   - Peer: <peer_id>, connection state: Connected, connection metadata: {...}
# Trusted peers (validator set & seeds):
#   - Network: Validator
#     - Peer: <peer_id>, peer information: {...}
# [Additional detailed peer metadata, state sync data, internal client state...]

# Step 3: Access consensus and node metrics
curl http://VALIDATOR_IP:9101/metrics

# Expected Response (no authentication required):
# [Complete Prometheus metrics including consensus state, performance data, etc.]

curl http://VALIDATOR_IP:9101/consensus_health_check

# Expected Response (no authentication required):
# Consensus health check passed! (or failed with details)

# Step 4: Retrieve system information
curl http://VALIDATOR_IP:9101/system_information

# Expected Response (no authentication required):
# {"system_info": {...}, "build_info": {...}}
```

**Result**: All sensitive endpoints return full information without requiring any credentials, confirming the authentication bypass vulnerability.

**Notes**

The inspection service was likely designed for internal debugging and monitoring, with the expectation that network-level access controls (firewalls, VPNs) would restrict access. However, this architectural decision creates significant security risks:

1. **Defense in Depth Violation**: Relying solely on network controls violates defense-in-depth principles. Application-level authentication provides an essential second layer of protection.

2. **Configuration Drift Risk**: Network configurations can change over time (cloud migrations, network reconfigurations, misconfigurations), potentially exposing previously protected services.

3. **Inconsistent Security Model**: The Admin Service requires authentication for similar sensitive operations, creating an inconsistent security posture across the codebase.

4. **Validator Operator Burden**: The current design places the entire security burden on operators to correctly configure network controls, with no application-level safety net.

The sanitizer that prevents mainnet validators from exposing the `/configuration` endpoint demonstrates awareness of security concerns, but only addresses one endpoint while leaving equally sensitive endpoints (identity, peer information, metrics) unprotected.

### Citations

**File:** crates/aptos-inspection-service/src/server/mod.rs (L50-101)
```rust
pub fn start_inspection_service(
    node_config: NodeConfig,
    aptos_data_client: AptosDataClient,
    peers_and_metadata: Arc<PeersAndMetadata>,
) {
    // Fetch the service port and address
    let service_port = node_config.inspection_service.port;
    let service_address = node_config.inspection_service.address.clone();

    // Create the inspection service socket address
    let address: SocketAddr = (service_address.as_str(), service_port)
        .to_socket_addrs()
        .unwrap_or_else(|_| {
            panic!(
                "Failed to parse {}:{} as address",
                service_address, service_port
            )
        })
        .next()
        .unwrap();

    // Create a runtime for the inspection service
    let runtime = aptos_runtimes::spawn_named_runtime("inspection".into(), None);

    // Spawn the inspection service
    thread::spawn(move || {
        // Create the service function that handles the endpoint requests
        let make_service = make_service_fn(move |_conn| {
            let node_config = node_config.clone();
            let aptos_data_client = aptos_data_client.clone();
            let peers_and_metadata = peers_and_metadata.clone();
            async move {
                Ok::<_, Infallible>(service_fn(move |request| {
                    serve_requests(
                        request,
                        node_config.clone(),
                        aptos_data_client.clone(),
                        peers_and_metadata.clone(),
                    )
                }))
            }
        });

        // Start and block on the server
        runtime
            .block_on(async {
                let server = Server::bind(&address).serve(make_service);
                server.await
            })
            .unwrap();
    });
}
```

**File:** crates/aptos-inspection-service/src/server/mod.rs (L104-169)
```rust
async fn serve_requests(
    req: Request<Body>,
    node_config: NodeConfig,
    aptos_data_client: AptosDataClient,
    peers_and_metadata: Arc<PeersAndMetadata>,
) -> Result<Response<Body>, hyper::Error> {
    // Process the request and get the response components
    let (status_code, body, content_type) = match req.uri().path() {
        CONFIGURATION_PATH => {
            // /configuration
            // Exposes the node configuration
            configuration::handle_configuration_request(&node_config)
        },
        CONSENSUS_HEALTH_CHECK_PATH => {
            // /consensus_health_check
            // Exposes the consensus health check
            metrics::handle_consensus_health_check(&node_config).await
        },
        FORGE_METRICS_PATH => {
            // /forge_metrics
            // Exposes forge encoded metrics
            metrics::handle_forge_metrics()
        },
        IDENTITY_INFORMATION_PATH => {
            // /identity_information
            // Exposes the identity information of the node
            identity_information::handle_identity_information_request(&node_config)
        },
        INDEX_PATH => {
            // /
            // Exposes the index and list of available endpoints
            index::handle_index_request()
        },
        JSON_METRICS_PATH => {
            // /json_metrics
            // Exposes JSON encoded metrics
            metrics::handle_json_metrics_request()
        },
        METRICS_PATH => {
            // /metrics
            // Exposes text encoded metrics
            metrics::handle_metrics_request()
        },
        PEER_INFORMATION_PATH => {
            // /peer_information
            // Exposes the peer information
            peer_information::handle_peer_information_request(
                &node_config,
                aptos_data_client,
                peers_and_metadata,
            )
        },
        SYSTEM_INFORMATION_PATH => {
            // /system_information
            // Exposes the system and build information
            system_information::handle_system_information_request(node_config)
        },
        _ => {
            // Handle the invalid path
            (
                StatusCode::NOT_FOUND,
                Body::from(INVALID_ENDPOINT_MESSAGE),
                CONTENT_TYPE_TEXT.into(),
            )
        },
    };
```

**File:** config/src/config/inspection_service_config.rs (L26-36)
```rust
impl Default for InspectionServiceConfig {
    fn default() -> InspectionServiceConfig {
        InspectionServiceConfig {
            address: "0.0.0.0".to_string(),
            port: 9101,
            expose_configuration: false,
            expose_identity_information: true,
            expose_peer_information: true,
            expose_system_information: true,
        }
    }
```

**File:** config/src/config/inspection_service_config.rs (L45-68)
```rust
impl ConfigSanitizer for InspectionServiceConfig {
    fn sanitize(
        node_config: &NodeConfig,
        node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();
        let inspection_service_config = &node_config.inspection_service;

        // Verify that mainnet validators do not expose the configuration
        if let Some(chain_id) = chain_id {
            if node_type.is_validator()
                && chain_id.is_mainnet()
                && inspection_service_config.expose_configuration
            {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "Mainnet validators should not expose the node configuration!".to_string(),
                ));
            }
        }

        Ok(())
    }
```

**File:** crates/aptos-inspection-service/src/server/identity_information.rs (L13-26)
```rust
pub fn handle_identity_information_request(node_config: &NodeConfig) -> (StatusCode, Body, String) {
    // Only return identity information if the endpoint is enabled
    let (status_code, body) = if node_config.inspection_service.expose_identity_information {
        let identity_information = get_identity_information(node_config);
        (StatusCode::OK, Body::from(identity_information))
    } else {
        (
            StatusCode::FORBIDDEN,
            Body::from(IDENTITY_INFO_DISABLED_MESSAGE),
        )
    };

    (status_code, body, CONTENT_TYPE_TEXT.into())
}
```

**File:** crates/aptos-inspection-service/src/server/peer_information.rs (L21-37)
```rust
pub fn handle_peer_information_request(
    node_config: &NodeConfig,
    aptos_data_client: AptosDataClient,
    peers_and_metadata: Arc<PeersAndMetadata>,
) -> (StatusCode, Body, String) {
    // Only return peer information if the endpoint is enabled
    let (status_code, body) = if node_config.inspection_service.expose_peer_information {
        let peer_information = get_peer_information(aptos_data_client, peers_and_metadata);
        (StatusCode::OK, Body::from(peer_information))
    } else {
        (
            StatusCode::FORBIDDEN,
            Body::from(PEER_INFO_DISABLED_MESSAGE),
        )
    };

    (status_code, body, CONTENT_TYPE_TEXT.into())
```

**File:** crates/aptos-inspection-service/src/server/system_information.rs (L14-28)
```rust
pub fn handle_system_information_request(node_config: NodeConfig) -> (StatusCode, Body, String) {
    // Only return system information if the endpoint is enabled
    if node_config.inspection_service.expose_system_information {
        (
            StatusCode::OK,
            Body::from(get_system_information_json()),
            CONTENT_TYPE_JSON.into(),
        )
    } else {
        (
            StatusCode::FORBIDDEN,
            Body::from(SYS_INFO_DISABLED_MESSAGE),
            CONTENT_TYPE_TEXT.into(),
        )
    }
```

**File:** crates/aptos-inspection-service/src/server/metrics.rs (L16-47)
```rust
/// Handles a consensus health check request. This method returns
/// 200 if the node is currently participating in consensus.
///
/// Note: we assume that this endpoint will only be used every few seconds.
pub async fn handle_consensus_health_check(node_config: &NodeConfig) -> (StatusCode, Body, String) {
    // Verify the node is a validator. If not, return an error.
    if !node_config.base.role.is_validator() {
        return (
            StatusCode::BAD_REQUEST,
            Body::from("This node is not a validator!"),
            CONTENT_TYPE_TEXT.into(),
        );
    }

    // Check the value of the consensus execution gauge
    let metrics = utils::get_all_metrics();
    if let Some(gauge_value) = metrics.get(CONSENSUS_EXECUTION_GAUGE) {
        if gauge_value == "1" {
            return (
                StatusCode::OK,
                Body::from("Consensus health check passed!"),
                CONTENT_TYPE_TEXT.into(),
            );
        }
    }

    // Otherwise, consensus is not executing
    (
        StatusCode::INTERNAL_SERVER_ERROR,
        Body::from("Consensus health check failed! Consensus is not executing!"),
        CONTENT_TYPE_TEXT.into(),
    )
```

**File:** crates/aptos-admin-service/src/server/mod.rs (L154-181)
```rust
        let mut authenticated = false;
        if context.config.authentication_configs.is_empty() {
            authenticated = true;
        } else {
            for authentication_config in &context.config.authentication_configs {
                match authentication_config {
                    AuthenticationConfig::PasscodeSha256(passcode_sha256) => {
                        let query = req.uri().query().unwrap_or("");
                        let query_pairs: HashMap<_, _> =
                            url::form_urlencoded::parse(query.as_bytes()).collect();
                        let passcode: Option<String> =
                            query_pairs.get("passcode").map(|p| p.to_string());
                        if let Some(passcode) = passcode {
                            if sha256::digest(passcode) == *passcode_sha256 {
                                authenticated = true;
                            }
                        }
                    },
                }
            }
        };

        if !authenticated {
            return Ok(reply_with_status(
                StatusCode::NETWORK_AUTHENTICATION_REQUIRED,
                format!("{} endpoint requires authentication.", req.uri().path()),
            ));
        }
```
