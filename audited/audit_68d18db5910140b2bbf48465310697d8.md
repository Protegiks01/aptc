# Audit Report

## Title
Memory Exhaustion via Unbounded EncryptedPayload Ciphertext Before Size Validation

## Summary
An attacker can submit EncryptedPayload transactions with ciphertexts up to 8 MB in size that are fully deserialized into memory before transaction size validation occurs. This creates a gap between the HTTP content-length limit (8 MB) and the actual transaction size limit (64 KB), allowing memory exhaustion attacks that can cause validator node slowdowns and API crashes.

## Finding Description

The vulnerability exists in how encrypted transactions are processed through the submission pipeline. The `EncryptedPayload` structure contains a `Ciphertext` field which includes an unbounded `Vec<u8>` for the encrypted data body. [1](#0-0) 

The `Ciphertext` type resolves to a structure containing a `BIBECiphertext` or `BIBESuccinctCiphertext`, both of which contain a `SymmetricCiphertext` with an unbounded `ct_body: Vec<u8>` field: [2](#0-1) 

**Attack Flow:**

1. The API accepts POST requests up to 8 MB via the `content_length_limit`: [3](#0-2) 

2. Transactions are deserialized **before** size validation: [4](#0-3) 

3. The BCS deserialization fully allocates memory for the entire `Vec<u8>` ciphertext, potentially up to 8 MB per transaction.

4. Only **after** deserialization, the transaction enters VM validation where size is checked: [5](#0-4) 

5. The size check in `check_gas()` compares against 64 KB limit: [6](#0-5) 

6. The transaction is **rejected**, but memory has already been allocated during steps 2-5.

The transaction size is calculated from the `RawTransaction`: [7](#0-6) [8](#0-7) 

This creates a **7.9 MB gap** where transactions pass HTTP validation but fail VM validation after full deserialization.

## Impact Explanation

This vulnerability meets **High Severity** criteria per the Aptos bug bounty program:
- **Validator node slowdowns**: An attacker flooding the API with 7.9 MB transactions causes excessive memory allocation and garbage collection pressure
- **API crashes**: Sufficient concurrent requests can exhaust available memory, triggering OOM conditions

**Amplification Factor:**
- 100 concurrent requests = 790 MB memory consumption
- 1,000 concurrent requests = 7.9 GB memory consumption
- 10,000 concurrent requests = 79 GB memory consumption

This affects all validator nodes running the API endpoint, compromising network availability.

## Likelihood Explanation

**Likelihood: HIGH**

- **No authentication required**: Public API endpoint accessible to any attacker
- **Low complexity**: Simple to craft malicious transactions with large ciphertext payloads
- **No rate limiting**: No inherent rate limiting on transaction submission beyond worker thread count
- **Concurrent amplification**: Async processing allows many transactions to be in-flight simultaneously
- **Repeatable**: Attacker can continuously submit requests as old ones are rejected

The encrypted transaction submission feature is controlled by a configuration flag: [9](#0-8) 

When enabled, this attack vector becomes immediately exploitable.

## Recommendation

**Immediate Fix**: Enforce transaction size limits **before** BCS deserialization by checking the raw byte length of the POST body against the VM transaction size limit (64 KB).

**Implementation:**

1. Add size pre-validation in `get_signed_transaction()`:

```rust
// In api/src/transactions.rs, before deserialization
match data {
    SubmitTransactionPost::Bcs(data) => {
        // Check size before deserialization
        let max_txn_size = self.context.node_config.api.max_transaction_size_bytes
            .unwrap_or(64 * 1024); // 64 KB default
        
        if data.0.len() as u64 > max_txn_size {
            return Err(SubmitTransactionError::bad_request_with_code(
                format!("Transaction size {} exceeds maximum {}", data.0.len(), max_txn_size),
                AptosErrorCode::InvalidInput,
                ledger_info,
            ));
        }
        
        // Then deserialize...
        let signed_transaction: SignedTransaction = 
            bcs::from_bytes_with_limit(&data.0, Self::MAX_SIGNED_TRANSACTION_DEPTH)
```

2. Reduce the HTTP `content_length_limit` to match the transaction size limit or add specific handling for encrypted payloads.

3. Add size validation for `SymmetricCiphertext.ct_body` during encryption to prevent creation of oversized ciphertexts.

## Proof of Concept

```rust
// PoC: Create and submit oversized EncryptedPayload transaction
use aptos_types::transaction::*;
use aptos_crypto::ed25519::*;
use bcs;

#[test]
fn test_oversized_encrypted_payload_memory_exhaustion() {
    // Create a massive ciphertext (7.9 MB)
    let large_ciphertext_body = vec![0u8; 7_900_000];
    
    // Create SymmetricCiphertext with oversized ct_body
    let symmetric_ct = SymmetricCiphertext {
        nonce: /* 12 byte nonce */,
        ct_body: large_ciphertext_body, // 7.9 MB Vec<u8>
    };
    
    // Wrap in BIBECiphertext
    let bibe_ct = BIBECiphertext {
        id: /* ... */,
        ct_g2: /* ... */,
        padded_key: /* ... */,
        symmetric_ciphertext: symmetric_ct,
    };
    
    // Create Ciphertext
    let ciphertext = Ciphertext {
        vk: /* ... */,
        bibe_ct,
        associated_data_bytes: vec![],
        signature: /* ... */,
    };
    
    // Create EncryptedPayload
    let encrypted_payload = EncryptedPayload::Encrypted {
        ciphertext,
        extra_config: TransactionExtraConfig::V1 { /* ... */ },
        payload_hash: HashValue::zero(),
    };
    
    // Create RawTransaction with EncryptedPayload
    let raw_txn = RawTransaction::new(
        sender,
        0,
        TransactionPayload::EncryptedPayload(encrypted_payload),
        1_000_000, // max_gas_amount
        0, // gas_unit_price
        u64::MAX, // expiration
        ChainId::test(),
    );
    
    // Sign and serialize
    let signed_txn = SignedTransaction::new(/* ... */);
    let serialized = bcs::to_bytes(&signed_txn).unwrap();
    
    // This will be ~7.9 MB
    assert!(serialized.len() > 7_000_000);
    assert!(serialized.len() < 8_000_000); // Under HTTP limit
    
    // POST to /transactions endpoint
    // Memory allocated during bcs::from_bytes_with_limit()
    // Transaction rejected in check_gas() for size > 64 KB
    // But 7.9 MB already allocated
}

// Stress test: Submit 1000 concurrent oversized transactions
// Expected: Memory exhaustion, potential OOM crash
```

**Notes:**
- The vulnerability exploits the gap between HTTP-layer validation (8 MB) and VM-layer validation (64 KB)
- BCS deserialization eagerly allocates memory for `Vec<u8>` fields without size bounds checking
- The `from_bytes_with_limit` depth parameter (16) only limits nesting depth, not data size
- Encrypted transactions bypass normal payload validation until VM execution phase

### Citations

**File:** types/src/transaction/encrypted_payload.rs (L42-64)
```rust
pub enum EncryptedPayload {
    Encrypted {
        ciphertext: Ciphertext,
        extra_config: TransactionExtraConfig,
        payload_hash: HashValue,
    },
    FailedDecryption {
        ciphertext: Ciphertext,
        extra_config: TransactionExtraConfig,
        payload_hash: HashValue,
        eval_proof: EvalProof,
    },
    Decrypted {
        ciphertext: Ciphertext,
        extra_config: TransactionExtraConfig,
        payload_hash: HashValue,
        eval_proof: EvalProof,

        // decrypted things
        executable: TransactionExecutable,
        decryption_nonce: u64,
    },
}
```

**File:** crates/aptos-batch-encryption/src/shared/symmetric.rs (L45-50)
```rust
#[derive(Debug, Clone, Serialize, Deserialize, Hash, PartialEq, Eq)]
pub struct SymmetricCiphertext {
    nonce: SymmetricNonce,
    #[serde(with = "serde_bytes")]
    ct_body: Vec<u8>,
}
```

**File:** config/src/config/api_config.rs (L97-97)
```rust
const DEFAULT_REQUEST_CONTENT_LENGTH_LIMIT: u64 = 8 * 1024 * 1024; // 8 MB
```

**File:** api/src/transactions.rs (L1223-1232)
```rust
                let signed_transaction: SignedTransaction =
                    bcs::from_bytes_with_limit(&data.0, Self::MAX_SIGNED_TRANSACTION_DEPTH)
                        .context("Failed to deserialize input into SignedTransaction")
                        .map_err(|err| {
                            SubmitTransactionError::bad_request_with_code(
                                err,
                                AptosErrorCode::InvalidInput,
                                ledger_info,
                            )
                        })?;
```

**File:** api/src/transactions.rs (L1324-1330)
```rust
                if !self.context.node_config.api.allow_encrypted_txns_submission {
                    return Err(SubmitTransactionError::bad_request_with_code(
                        "Encrypted Transaction submission is not allowed yet",
                        AptosErrorCode::InvalidInput,
                        ledger_info,
                    ));
                }
```

**File:** mempool/src/shared_mempool/tasks.rs (L490-503)
```rust
    let validation_results = VALIDATION_POOL.install(|| {
        transactions
            .par_iter()
            .map(|t| {
                let result = smp.validator.read().validate_transaction(t.0.clone());
                // Pre-compute the hash and length if the transaction is valid, before locking mempool
                if result.is_ok() {
                    t.0.committed_hash();
                    t.0.txn_bytes_len();
                }
                result
            })
            .collect::<Vec<_>>()
    });
```

**File:** aptos-move/aptos-vm/src/gas.rs (L109-121)
```rust
    } else if txn_metadata.transaction_size > txn_gas_params.max_transaction_size_in_bytes {
        speculative_warn!(
            log_context,
            format!(
                "[VM] Transaction size too big {} (max {})",
                txn_metadata.transaction_size, txn_gas_params.max_transaction_size_in_bytes
            ),
        );
        return Err(VMStatus::error(
            StatusCode::EXCEEDED_MAX_TRANSACTION_SIZE,
            None,
        ));
    }
```

**File:** aptos-move/aptos-vm/src/transaction_metadata.rs (L63-63)
```rust
            transaction_size: (txn.raw_txn_bytes_len() as u64).into(),
```

**File:** types/src/transaction/mod.rs (L1294-1298)
```rust
    pub fn raw_txn_bytes_len(&self) -> usize {
        *self.raw_txn_size.get_or_init(|| {
            bcs::serialized_size(&self.raw_txn).expect("Unable to serialize RawTransaction")
        })
    }
```
