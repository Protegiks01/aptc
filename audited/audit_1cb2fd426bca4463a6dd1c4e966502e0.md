# Audit Report

## Title
Panic-Induced Denial of Service in Indexer-gRPC Transaction Filter via Oversized Address String

## Summary
The `validate_state()` function in `UserTransactionFilter` fails to validate the sender address format, allowing attackers to provide maliciously long address strings (>64 hex characters) that cause a panic in `standardize_address()`, crashing the indexer-gRPC transaction stream service.

## Finding Description

The vulnerability exists in the transaction filtering system used by the Aptos indexer-gRPC service. When a client requests a filtered transaction stream, they can specify a `UserTransactionFilter` with a sender address. The validation logic only checks that at least one field is set, but never validates the address format or length. [1](#0-0) 

When the filter is later applied to transactions, the `matches()` method calls `get_standardized_sender()`, which lazily initializes the standardized address by calling `standardize_address()`: [2](#0-1) 

The `standardize_address()` function contains the critical flaw. When the input address (after removing "0x" prefix) exceeds 64 hex characters, it attempts to compute `&ZEROS[..64 - trimmed.len()]`: [3](#0-2) 

If `trimmed.len() > 64`, the subtraction in release mode wraps to a huge unsigned integer, and the subsequent slice operation panics with "index out of bounds" since `ZEROS` is only 64 characters long.

**Attack Flow:**
1. Attacker sends `GetTransactionsRequest` with a `UserTransactionFilter` containing `sender = "0x" + "1"*65` (or any string >64 hex chars after removing "0x")
2. Filter passes validation via `parse_transaction_filter()` because `validate_state()` only checks field presence
3. Filter is passed to `IndexerStreamCoordinator` and stored for transaction matching
4. When processing transactions, the coordinator spawns tasks that call `filter.matches(txn)` 
5. First call to `matches()` triggers `standardize_address()` which panics
6. Task failure causes `try_join_all()` to return error, triggering panic at coordinator level
7. Entire transaction stream crashes, disconnecting all clients [4](#0-3) [5](#0-4) 

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos bug bounty program category "API crashes". An unauthenticated attacker can remotely crash the indexer-gRPC service by sending a single malformed filter request. This causes:

- **Service Disruption**: The indexer-gRPC transaction stream terminates for all clients subscribed to that coordinator
- **Denial of Service**: Repeated attacks can prevent the indexer service from functioning
- **Availability Impact**: External applications relying on the indexer API for transaction data cannot operate

While this does not affect validator nodes or blockchain consensus, the indexer-gRPC service is a critical infrastructure component for dApps, explorers, and data analytics services.

## Likelihood Explanation

**Likelihood: High**

- **Attack Complexity**: Trivial - requires only a single gRPC request with a malformed filter
- **Authentication**: None required - public gRPC endpoint
- **Detectability**: Low - legitimate filter requests are indistinguishable from attack until panic occurs
- **Skill Level**: Minimal - any user with gRPC client can exploit this
- **Attack Vector**: Network - remote exploitation via public API

The vulnerability is easily discoverable through fuzzing or basic input validation testing.

## Recommendation

Add address format validation in the `validate_state()` method before allowing the filter to be used:

**Fix for `user_transaction.rs`:**
```rust
fn validate_state(&self) -> Result<(), FilterError> {
    if self.sender.is_none() && self.payload.is_none() {
        return Err(Error::msg("At least one of sender or payload must be set").into());
    };
    
    // Validate sender address format if present
    if let Some(ref address) = self.sender {
        let trimmed = address.strip_prefix("0x").unwrap_or(address);
        if trimmed.len() > 64 {
            return Err(Error::msg("Sender address exceeds maximum length of 64 hex characters").into());
        }
        if !trimmed.chars().all(|c| c.is_ascii_hexdigit()) {
            return Err(Error::msg("Sender address contains non-hexadecimal characters").into());
        }
    }
    
    self.payload.is_valid()?;
    Ok(())
}
```

**Alternative: Make `standardize_address()` return `Result`:**
```rust
pub fn standardize_address(address: &str) -> Result<String, &'static str> {
    let trimmed = address.strip_prefix("0x").unwrap_or(address);
    
    if trimmed.len() > 64 {
        return Err("Address exceeds maximum length of 64 hex characters");
    }
    
    // Rest of implementation unchanged...
    Ok(result)
}
```

The same validation should be applied to `EntryFunctionFilter.address` at line 183-187.

## Proof of Concept

**Rust Unit Test:**
```rust
#[cfg(test)]
mod panic_test {
    use super::*;
    use aptos_transaction_filter::Filterable;
    
    #[test]
    #[should_panic(expected = "index out of bounds")]
    fn test_oversized_address_causes_panic() {
        // Create filter with oversized address (65 hex chars after 0x)
        let oversized_address = format!("0x{}", "1".repeat(65));
        
        let filter = UserTransactionFilterBuilder::default()
            .sender(oversized_address)
            .build()
            .unwrap();
        
        // Validation passes - this is the bug
        assert!(filter.is_valid().is_ok());
        
        // Create a mock transaction
        let mock_txn = create_mock_user_transaction();
        
        // This will panic when standardize_address is called
        filter.matches(&mock_txn);
    }
    
    #[test]
    fn test_address_validation_should_fail() {
        let oversized_address = format!("0x{}", "1".repeat(65));
        
        let filter = UserTransactionFilterBuilder::default()
            .sender(oversized_address)
            .build()
            .unwrap();
        
        // This SHOULD fail but currently passes
        let validation_result = filter.is_valid();
        assert!(validation_result.is_err(), "Oversized address should fail validation");
    }
}
```

**Notes:**
- This vulnerability only affects the indexer-gRPC service, not validator nodes or blockchain consensus
- The impact is limited to API availability and does not compromise funds, state integrity, or consensus safety
- The fix requires adding input validation at the filter construction/validation stage to prevent panic conditions during execution

### Citations

**File:** ecosystem/indexer-grpc/transaction-filter/src/filters/user_transaction.rs (L39-45)
```rust
    fn get_standardized_sender(&self) -> &Option<String> {
        self.standardized_sender.get_or_init(|| {
            self.sender
                .clone()
                .map(|address| standardize_address(&address))
        })
    }
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/filters/user_transaction.rs (L74-79)
```rust
    fn validate_state(&self) -> Result<(), FilterError> {
        if self.sender.is_none() && self.payload.is_none() {
            return Err(Error::msg("At least one of sender or payload must be set").into());
        };
        self.payload.is_valid()?;
        Ok(())
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/utils.rs (L10-36)
```rust
pub fn standardize_address(address: &str) -> String {
    // Remove "0x" prefix if it exists
    let trimmed = address.strip_prefix("0x").unwrap_or(address);

    // Check if the address is a special address by seeing if the first 31 bytes are zero and the last byte is smaller than 0b10000
    if let Some(last_char) = trimmed.chars().last() {
        if trimmed[..trimmed.len().saturating_sub(1)]
            .chars()
            .all(|c| c == '0')
            && last_char.is_ascii_hexdigit()
            && last_char <= 'f'
        {
            // Return special addresses in short format
            let mut result = String::with_capacity(3);
            result.push_str("0x");
            result.push(last_char);
            return result;
        }
    }

    // Return non-special addresses in long format
    let mut result = String::with_capacity(66);
    result.push_str("0x");
    result.push_str(&ZEROS[..64 - trimmed.len()]);
    result.push_str(trimmed);
    result
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/stream_coordinator.rs (L175-179)
```rust
                let pb_txns = if let Some(ref filter) = filter {
                    pb_txns
                        .into_iter()
                        .filter(|txn| filter.matches(txn))
                        .collect::<Vec<_>>()
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/stream_coordinator.rs (L202-207)
```rust
        let responses = match futures::future::try_join_all(tasks).await {
            Ok(res) => res.into_iter().flatten().collect::<Vec<_>>(),
            Err(err) => panic!(
                "[Indexer Fullnode] Error processing transaction batches: {:?}",
                err
            ),
```
