# Audit Report

## Title
Quorum Store V2 Message Routing Failure Causes Consensus State Inconsistencies

## Summary
The network routing layer fails to handle V2 quorum store messages (`BatchMsgV2`, `SignedBatchInfoMsgV2`, `ProofOfStoreMsgV2`), causing them to be silently dropped. This creates a critical state inconsistency between consensus and quorum store components, where batches sent by validators are never received by peers, preventing consensus from progressing.

## Finding Description

The `ConsensusMsg` enum defines both V1 and V2 variants of quorum store messages to support protocol upgrades, with V2 variants using `BatchInfoExt` instead of `BatchInfo`: [1](#0-0) 

However, the network message routing logic in `NetworkTask::start()` has an incomplete implementation. When messages are received via direct-send, only V1 quorum store messages are routed to the quorum store channel: [2](#0-1) 

V2 messages (`BatchMsgV2`, `SignedBatchInfoMsgV2`, `ProofOfStoreMsgV2`) are not matched in this pattern, causing them to fall through to the default case which logs a warning and drops them: [3](#0-2) 

Even if V2 messages bypassed the network layer, the `EpochManager::check_epoch` method also fails to recognize them. It only matches V1 message variants: [4](#0-3) 

V2 messages would trigger the default case and be rejected with an error: [5](#0-4) 

Despite this incomplete routing, the codebase actively sends V2 messages when the `enable_batch_v2` configuration flag is enabled: [6](#0-5) [7](#0-6) 

The batch coordinator dynamically sends V2 messages based on batch type: [8](#0-7) 

The proof coordinator also sends V2 messages based on proof type: [9](#0-8) 

The V2 message sending infrastructure is implemented: [10](#0-9) [11](#0-10) [12](#0-11) 

The verification layer supports V2 messages through `UnverifiedEvent`: [13](#0-12) 

And the conversion from `ConsensusMsg` to `UnverifiedEvent` includes V2 variants: [14](#0-13) 

**Attack Scenario:**

1. During a rolling network upgrade, some validators enable `enable_batch_v2=true` to use the new batch format with `BatchInfoExt`
2. These validators create and broadcast batches using `BatchMsgV2`
3. Other validators receive these messages but the network layer silently drops them
4. The batches never accumulate enough signatures to form a valid proof of store
5. Proposals referencing these batch IDs cannot be validated by validators who never received the batch data
6. **Result**: Consensus experiences liveness failures or significant degradation as validators disagree on available batches

This breaks the **State Consistency** invariant: different validators maintain inconsistent views of which batches are available, causing the consensus and quorum store components to be out of sync.

## Impact Explanation

This vulnerability meets **High Severity** criteria per Aptos bug bounty:

1. **Validator node slowdowns**: Consensus cannot proceed efficiently when batches are unavailable, causing increased latency and potential timeouts. This directly matches the "Validator node slowdowns" category.

2. **State inconsistencies requiring intervention**: Different validators have divergent views of available batches, requiring manual intervention to resolve during upgrades. This matches the "State inconsistencies requiring manual intervention" Medium Severity category.

The severity escalates based on deployment:
- During mixed-version rolling upgrades: High Severity (partial liveness loss, slowdowns)
- If all validators enable V2 simultaneously: Could reach Critical Severity (total liveness loss)

## Likelihood Explanation

**High likelihood** during network operations:

1. The `enable_batch_v2` flag exists in production configuration, indicating planned usage
2. The flag defaults to false but is clearly intended for future activation
3. During any rolling upgrade where this flag is enabled on some validators, the bug will manifest deterministically
4. No attacker action is requiredâ€”normal protocol upgrade procedures trigger the vulnerability
5. Every V2 message sent will be dropped by nodes not handling them

The vulnerability is latent but guaranteed to trigger when the feature is activated. An attacker could exploit this during upgrade windows by submitting transactions specifically to validators with V2 enabled, amplifying disruption beyond normal upgrade issues.

## Recommendation

Add V2 message routing to `NetworkTask::start()` method:

```rust
quorum_store_msg @ (ConsensusMsg::SignedBatchInfo(_)
| ConsensusMsg::BatchMsg(_)
| ConsensusMsg::ProofOfStoreMsg(_)
| ConsensusMsg::SignedBatchInfoMsgV2(_)
| ConsensusMsg::BatchMsgV2(_)
| ConsensusMsg::ProofOfStoreMsgV2(_)) => {
    Self::push_msg(
        peer_id,
        quorum_store_msg,
        &self.quorum_store_messages_tx,
    );
},
```

Add V2 message handling to `EpochManager::check_epoch()`:

```rust
ConsensusMsg::ProposalMsg(_)
| ConsensusMsg::OptProposalMsg(_)
| ConsensusMsg::SyncInfo(_)
| ConsensusMsg::VoteMsg(_)
| ConsensusMsg::RoundTimeoutMsg(_)
| ConsensusMsg::OrderVoteMsg(_)
| ConsensusMsg::CommitVoteMsg(_)
| ConsensusMsg::CommitDecisionMsg(_)
| ConsensusMsg::BatchMsg(_)
| ConsensusMsg::BatchRequestMsg(_)
| ConsensusMsg::SignedBatchInfo(_)
| ConsensusMsg::ProofOfStoreMsg(_)
| ConsensusMsg::BatchMsgV2(_)
| ConsensusMsg::SignedBatchInfoMsgV2(_)
| ConsensusMsg::ProofOfStoreMsgV2(_) => {
    // ... existing logic
}
```

## Proof of Concept

The vulnerability can be demonstrated by:
1. Enabling `enable_batch_v2 = true` in validator configuration
2. Observing that `BatchMsgV2` messages are sent via `broadcast_batch_msg_v2()`
3. Confirming these messages are dropped at the receiving end with "Unexpected direct send msg" warnings
4. Verifying that batches fail to accumulate signatures and consensus stalls

The complete execution path is verified through code inspection, showing the disconnect between message sending and routing infrastructure.

### Citations

**File:** consensus/src/network_interface.rs (L97-102)
```rust
    BatchMsgV2(Box<BatchMsg<BatchInfoExt>>),
    /// Quorum Store: Send a signed batch digest with BatchInfoExt. This is a vote for the batch and a promise that
    /// the batch of transactions was received and will be persisted until batch expiration.
    SignedBatchInfoMsgV2(Box<SignedBatchInfoMsg<BatchInfoExt>>),
    /// Quorum Store: Broadcast a certified proof of store (a digest that received 2f+1 votes) with BatchInfoExt.
    ProofOfStoreMsgV2(Box<ProofOfStoreMsg<BatchInfoExt>>),
```

**File:** consensus/src/network.rs (L605-605)
```rust
        let msg = ConsensusMsg::SignedBatchInfoMsgV2(Box::new(SignedBatchInfoMsg::new(
```

**File:** consensus/src/network.rs (L619-619)
```rust
        let msg = ConsensusMsg::BatchMsgV2(Box::new(BatchMsg::new(batches)));
```

**File:** consensus/src/network.rs (L631-631)
```rust
        let msg = ConsensusMsg::ProofOfStoreMsgV2(Box::new(ProofOfStoreMsg::new(proofs)));
```

**File:** consensus/src/network.rs (L823-831)
```rust
                        quorum_store_msg @ (ConsensusMsg::SignedBatchInfo(_)
                        | ConsensusMsg::BatchMsg(_)
                        | ConsensusMsg::ProofOfStoreMsg(_)) => {
                            Self::push_msg(
                                peer_id,
                                quorum_store_msg,
                                &self.quorum_store_messages_tx,
                            );
                        },
```

**File:** consensus/src/network.rs (L937-940)
```rust
                        _ => {
                            warn!(remote_peer = peer_id, "Unexpected direct send msg");
                            continue;
                        },
```

**File:** consensus/src/epoch_manager.rs (L1641-1644)
```rust
            | ConsensusMsg::BatchMsg(_)
            | ConsensusMsg::BatchRequestMsg(_)
            | ConsensusMsg::SignedBatchInfo(_)
            | ConsensusMsg::ProofOfStoreMsg(_) => {
```

**File:** consensus/src/epoch_manager.rs (L1687-1689)
```rust
            _ => {
                bail!("[EpochManager] Unexpected messages: {:?}", msg);
            },
```

**File:** config/src/config/quorum_store_config.rs (L102-102)
```rust
    pub enable_batch_v2: bool,
```

**File:** consensus/src/quorum_store/batch_generator.rs (L494-495)
```rust
                            if self.config.enable_batch_v2 {
                                network_sender.broadcast_batch_msg_v2(batches).await;
```

**File:** consensus/src/quorum_store/batch_coordinator.rs (L102-110)
```rust
            if persist_requests[0].batch_info().is_v2() {
                let signed_batch_infos = batch_store.persist(persist_requests);
                if !signed_batch_infos.is_empty() {
                    if approx_created_ts_usecs > 0 {
                        observe_batch(approx_created_ts_usecs, peer_id, BatchStage::SIGNED);
                    }
                    network_sender
                        .send_signed_batch_info_msg_v2(signed_batch_infos, vec![peer_id])
                        .await;
```

**File:** consensus/src/quorum_store/proof_coordinator.rs (L485-487)
```rust
                                    if proofs_iter.peek().is_some_and(|p| p.info().is_v2()) {
                                        let proofs: Vec<_> = proofs_iter.collect();
                                        network_sender.broadcast_proof_of_store_msg_v2(proofs).await;
```

**File:** consensus/src/round_manager.rs (L97-101)
```rust
    BatchMsgV2(Box<BatchMsg<BatchInfoExt>>),
    SignedBatchInfo(Box<SignedBatchInfoMsg<BatchInfo>>),
    SignedBatchInfoMsgV2(Box<SignedBatchInfoMsg<BatchInfoExt>>),
    ProofOfStoreMsg(Box<ProofOfStoreMsg<BatchInfo>>),
    ProofOfStoreMsgV2(Box<ProofOfStoreMsg<BatchInfoExt>>),
```

**File:** consensus/src/round_manager.rs (L263-265)
```rust
            ConsensusMsg::BatchMsgV2(m) => UnverifiedEvent::BatchMsgV2(m),
            ConsensusMsg::SignedBatchInfoMsgV2(m) => UnverifiedEvent::SignedBatchInfoMsgV2(m),
            ConsensusMsg::ProofOfStoreMsgV2(m) => UnverifiedEvent::ProofOfStoreMsgV2(m),
```
