# Audit Report

## Title
Unvalidated Node Information Responses Enable Eclipse Attacks via Peer Health Manipulation

## Summary
The `handle_monitoring_service_response()` function in the peer monitoring service client accepts `NodeInformationResponse` data from peers without validation, allowing Byzantine peers to send manipulated `ledger_timestamp_usecs` values that cause them to be incorrectly classified as "healthy" peers. This enables eclipse attacks where honest validators preferentially connect to and trust Byzantine peers over honest ones. [1](#0-0) 

## Finding Description
The peer monitoring system collects health metadata from connected peers, including their `ledger_timestamp_usecs` (the timestamp of their latest blockchain state). This information is used by the mempool to prioritize "healthy" peers over "unhealthy" ones when forwarding transactions.

**The vulnerability exists in the following flow:**

1. A Byzantine peer sends a `NodeInformationResponse` containing a fake `ledger_timestamp_usecs` value (e.g., current time or future time).

2. The victim node's `handle_monitoring_service_response()` function accepts this response with **zero validation**: [2](#0-1) 

The function only checks the response type matches `NodeInformation`, but performs no validation on the actual data fields.

3. The malicious data is stored and later extracted into `PeerMonitoringMetadata`: [3](#0-2) 

4. The mempool's peer prioritization uses this unvalidated data to determine peer health: [4](#0-3) 

5. **Critical vulnerability at line 584**: The health check uses `saturating_sub`, which means if an attacker sends `peer_ledger_timestamp_usecs >= current_timestamp_usecs`, the result is 0, making the peer **always appear healthy** regardless of actual sync state. [5](#0-4) 

6. During intelligent peer prioritization, health is the **first comparison factor**, giving highest priority to these fake "healthy" peers: [6](#0-5) 

**Eclipse Attack Scenario:**
- Attacker controls multiple Byzantine nodes on the network
- Each Byzantine node sends `NodeInformationResponse` with `ledger_timestamp_usecs` equal to or greater than current time
- Byzantine nodes appear perfectly synchronized with 0 sync lag
- Honest nodes with even 1 second of sync lag (within the 30-second default threshold) are deprioritized
- Victim node preferentially connects to and trusts Byzantine peers
- Byzantine peers can suppress transactions, provide false network information, and isolate the victim from the honest network

## Impact Explanation
This vulnerability qualifies as **High Severity** per Aptos bug bounty criteria:

1. **Validator Node Security**: Enables eclipse attacks where validators can be isolated from the honest network by preferentially connecting to Byzantine peers
2. **Protocol Violation**: Breaks the peer selection integrity assumption that nodes should prefer well-synchronized honest peers
3. **Mempool Manipulation**: Allows attackers to control which peers receive transaction broadcasts, potentially censoring transactions
4. **Consensus Risk**: While not a direct consensus break, isolating validators from honest peers can lead to consensus participation issues

The default configuration shows the attack is highly feasible: [7](#0-6) 

With only a 30-second threshold, attackers can easily manipulate peer preferences by reporting timestamps at or slightly ahead of current time.

## Likelihood Explanation
**Likelihood: High**

1. **Low Attack Complexity**: Attacker only needs to run modified peer monitoring service that sends fake timestamps
2. **No Special Privileges Required**: Any network peer can connect and send peer monitoring responses
3. **Automatic Propagation**: The malicious data automatically propagates through the system via the metadata updater
4. **Persistent Effect**: Once marked as "healthy," Byzantine peers remain prioritized for up to 10 minutes (priority update interval)
5. **No Detection Mechanism**: There is no validation to detect impossible or inconsistent timestamp values

## Recommendation

**Immediate Fix**: Add validation to `handle_monitoring_service_response()` to verify node information responses contain realistic values:

```rust
fn handle_monitoring_service_response(
    &mut self,
    peer_network_id: &PeerNetworkId,
    _peer_metadata: PeerMetadata,
    _monitoring_service_request: PeerMonitoringServiceRequest,
    monitoring_service_response: PeerMonitoringServiceResponse,
    _response_time_secs: f64,
) {
    // Verify the response type is valid
    let node_info_response = match monitoring_service_response {
        PeerMonitoringServiceResponse::NodeInformation(node_information_response) => {
            node_information_response
        },
        _ => {
            warn!(LogSchema::new(LogEntry::NodeInfoRequest)
                .event(LogEvent::ResponseError)
                .peer(peer_network_id)
                .message("An unexpected response was received instead of a node info response!"));
            self.handle_request_failure();
            return;
        },
    };

    // VALIDATION: Check that ledger_timestamp_usecs is not in the future
    let current_timestamp_usecs = std::time::SystemTime::now()
        .duration_since(std::time::UNIX_EPOCH)
        .unwrap()
        .as_micros() as u64;
    
    // Allow a small clock drift tolerance (e.g., 5 seconds)
    const MAX_CLOCK_DRIFT_USECS: u64 = 5_000_000; // 5 seconds
    
    if node_info_response.ledger_timestamp_usecs > current_timestamp_usecs + MAX_CLOCK_DRIFT_USECS {
        warn!(LogSchema::new(LogEntry::NodeInfoRequest)
            .event(LogEvent::ResponseError)
            .peer(peer_network_id)
            .message(&format!(
                "Node info response contains future timestamp: {} vs current: {}",
                node_info_response.ledger_timestamp_usecs,
                current_timestamp_usecs
            )));
        self.handle_request_failure();
        return;
    }

    // Store the validated node info
    self.record_node_info_response(node_info_response);
}
```

**Additional Recommendations:**
1. Consider validating `highest_synced_version` consistency with the timestamp
2. Add bounds checking to ensure ledger timestamp is not impossibly old (e.g., before genesis)
3. Consider cross-validating peer-reported data with known blockchain state when available
4. Add metrics to track and alert on suspicious peer monitoring responses

## Proof of Concept

```rust
#[cfg(test)]
mod exploit_test {
    use super::*;
    use aptos_config::{config::NodeMonitoringConfig, network_id::PeerNetworkId};
    use aptos_network::application::metadata::PeerMetadata;
    use aptos_peer_monitoring_service_types::{
        request::PeerMonitoringServiceRequest,
        response::{NodeInformationResponse, PeerMonitoringServiceResponse},
    };
    use aptos_time_service::TimeService;
    use std::time::Duration;

    #[test]
    fn test_future_timestamp_bypass() {
        // Setup
        let node_monitoring_config = NodeMonitoringConfig::default();
        let time_service = TimeService::mock();
        let mut node_info_state = NodeInfoState::new(node_monitoring_config, time_service.clone());
        
        // Get current time
        let current_time_usecs = time_service.now_unix_time().as_micros() as u64;
        
        // Attacker sends node info with timestamp in the future
        let malicious_response = NodeInformationResponse {
            build_information: Default::default(),
            highest_synced_epoch: 1000,
            highest_synced_version: 1_000_000,
            ledger_timestamp_usecs: current_time_usecs + 60_000_000, // 1 minute in the future
            lowest_available_version: 900_000,
            uptime: Duration::from_secs(3600),
        };
        
        // Create mock peer metadata
        let peer_network_id = PeerNetworkId::random();
        let peer_metadata = PeerMetadata::mock();
        
        // Handle the malicious response - NO VALIDATION OCCURS
        node_info_state.handle_monitoring_service_response(
            &peer_network_id,
            peer_metadata,
            PeerMonitoringServiceRequest::GetNodeInformation,
            PeerMonitoringServiceResponse::NodeInformation(malicious_response.clone()),
            0.0,
        );
        
        // Verify the malicious data was stored
        let stored_response = node_info_state.get_latest_node_info_response().unwrap();
        assert_eq!(stored_response.ledger_timestamp_usecs, current_time_usecs + 60_000_000);
        
        // This peer will now pass the health check even though its timestamp is impossible
        // In mempool, saturating_sub will return 0, marking it as perfectly healthy
        println!("EXPLOIT SUCCESS: Future timestamp accepted without validation");
        println!("Attacker can now be prioritized as 'healthy' peer for eclipse attack");
    }
}
```

## Notes
This vulnerability demonstrates a critical failure in the peer monitoring system's trust model. The system assumes peer-reported metrics are trustworthy without validation, enabling trivial eclipse attacks. The fix requires adding proper validation boundaries on all peer-reported time-sensitive data before using it for security-critical decisions like peer prioritization.

### Citations

**File:** peer-monitoring-service/client/src/peer_states/node_info.rs (L79-106)
```rust
    fn handle_monitoring_service_response(
        &mut self,
        peer_network_id: &PeerNetworkId,
        _peer_metadata: PeerMetadata,
        _monitoring_service_request: PeerMonitoringServiceRequest,
        monitoring_service_response: PeerMonitoringServiceResponse,
        _response_time_secs: f64,
    ) {
        // Verify the response type is valid
        let node_info_response = match monitoring_service_response {
            PeerMonitoringServiceResponse::NodeInformation(node_information_response) => {
                node_information_response
            },
            _ => {
                warn!(LogSchema::new(LogEntry::NodeInfoRequest)
                    .event(LogEvent::ResponseError)
                    .peer(peer_network_id)
                    .message(
                        "An unexpected response was received instead of a node info response!"
                    ));
                self.handle_request_failure();
                return;
            },
        };

        // Store the new latency ping result
        self.record_node_info_response(node_info_response);
    }
```

**File:** peer-monitoring-service/client/src/peer_states/peer_state.rs (L208-211)
```rust
        // Get and store the latest node info response
        let node_info_state = self.get_node_info_state()?;
        let node_info_response = node_info_state.get_latest_node_info_response();
        peer_monitoring_metadata.latest_node_info_response = node_info_response;
```

**File:** mempool/src/shared_mempool/priority.rs (L74-92)
```rust
    fn compare_intelligent(
        &self,
        peer_a: &(PeerNetworkId, Option<&PeerMonitoringMetadata>),
        peer_b: &(PeerNetworkId, Option<&PeerMonitoringMetadata>),
    ) -> Ordering {
        // Deconstruct the peer tuples
        let (peer_network_id_a, monitoring_metadata_a) = peer_a;
        let (peer_network_id_b, monitoring_metadata_b) = peer_b;

        // First, compare the peers by health (e.g., sync lag)
        let unhealthy_ordering = compare_peer_health(
            &self.mempool_config,
            &self.time_service,
            monitoring_metadata_a,
            monitoring_metadata_b,
        );
        if !unhealthy_ordering.is_eq() {
            return unhealthy_ordering; // Only return if it's not equal
        }
```

**File:** mempool/src/shared_mempool/priority.rs (L562-589)
```rust
fn check_peer_metadata_health(
    mempool_config: &MempoolConfig,
    time_service: &TimeService,
    monitoring_metadata: &Option<&PeerMonitoringMetadata>,
) -> bool {
    monitoring_metadata
        .and_then(|metadata| {
            metadata
                .latest_node_info_response
                .as_ref()
                .map(|node_information_response| {
                    // Get the peer's ledger timestamp and the current timestamp
                    let peer_ledger_timestamp_usecs =
                        node_information_response.ledger_timestamp_usecs;
                    let current_timestamp_usecs = get_timestamp_now_usecs(time_service);

                    // Calculate the max sync lag before the peer is considered unhealthy (in microseconds)
                    let max_sync_lag_secs =
                        mempool_config.max_sync_lag_before_unhealthy_secs as u64;
                    let max_sync_lag_usecs = max_sync_lag_secs * MICROS_PER_SECOND;

                    // Determine if the peer is healthy
                    current_timestamp_usecs.saturating_sub(peer_ledger_timestamp_usecs)
                        < max_sync_lag_usecs
                })
        })
        .unwrap_or(false) // If metadata is missing, consider the peer unhealthy
}
```

**File:** config/src/config/mempool_config.rs (L118-118)
```rust
            max_sync_lag_before_unhealthy_secs: 30, // 30 seconds
```
