# Audit Report

## Title
Event Data Corruption via Duplicate Property Keys in Token Mutation

## Summary
The `mutate_tokendata_property` function in the Aptos Token framework does not validate for duplicate keys in the input parameters, causing incorrect `old_values` to be recorded in `DefaultPropertyMutate` events. When duplicate property names are provided, subsequent iterations read already-updated values as "old values," corrupting the event's audit trail. [1](#0-0) 

## Finding Description
The vulnerability exists in the token property mutation flow. When `mutate_tokendata_property` is called with duplicate keys, the function iterates through each key sequentially, reading the current property value, recording it as the "old value," then updating the property map. If the same key appears multiple times in the `keys` vector, subsequent iterations will read the already-modified value as the "old value" rather than the original pre-mutation value. [2](#0-1) 

The function only validates that keys don't start with reserved "TOKEN_" prefix, but does not check for duplicates: [3](#0-2) 

The corrupted data is then emitted in both V1 and V2 events and persists through the event translation layer without validation: [4](#0-3) 

**Attack Scenario:**
1. Attacker creates a token with property `color: "red"`
2. Calls `mutate_tokendata_property(keys=["color", "color"], values=[b"blue", b"green"], types=["String", "String"])`
3. First iteration: reads "red" as old_value, updates to "blue"
4. Second iteration: reads "blue" (already updated!) as old_value, updates to "green"
5. Event emitted: `keys=["color","color"], old_values=[Some("red"), Some("blue")], new_values=["blue", "green"]`
6. Final on-chain state: `color: "green"` (correct)
7. Event data: Shows "blue" as an old_value when it was never a committed state

This breaks the **event integrity invariant** - events should accurately represent state transitions for audit and indexing purposes.

## Impact Explanation
This qualifies as **Medium Severity** per Aptos bug bounty criteria for the following reasons:

1. **Event Data Integrity Violation**: Events are part of the blockchain's data availability layer and serve as the canonical audit trail for state changes. Corrupted events undermine this guarantee.

2. **Indexer/Explorer Misrepresentation**: Off-chain infrastructure (indexers, block explorers, analytics platforms) relies on events to reconstruct historical state. Corrupted events lead to incorrect historical data being displayed to users.

3. **Audit Trail Corruption**: Regulatory compliance and forensic analysis depend on accurate event logs. This vulnerability allows token creators to obfuscate the true history of property changes.

4. **Downstream System Confusion**: Wallets, marketplaces, and other applications that consume events to make decisions about token properties may be misled by phantom intermediate states.

While this does not directly cause funds loss or consensus violations, it represents a **state inconsistency in the event layer** that could require manual intervention to correct in dependent systems, aligning with Medium severity criteria.

## Likelihood Explanation
**High Likelihood** - This vulnerability is:
- Trivially exploitable by any token creator with no special permissions required
- Requires only passing duplicate keys in a standard function call
- Has no cost or complexity barriers
- Deterministically produces the vulnerability every time

Any malicious or careless token creator can corrupt event data, whether intentionally for obfuscation or accidentally through programming errors.

## Recommendation
Add duplicate key validation before processing property mutations:

```move
public fun mutate_tokendata_property(
    creator: &signer,
    token_data_id: TokenDataId,
    keys: vector<String>,
    values: vector<vector<u8>>,
    types: vector<String>,
) acquires Collections {
    assert_tokendata_exists(creator, token_data_id);
    let key_len = keys.length();
    let val_len = values.length();
    let typ_len = types.length();
    assert!(key_len == val_len, error::invalid_state(ETOKEN_PROPERTIES_COUNT_NOT_MATCH));
    assert!(key_len == typ_len, error::invalid_state(ETOKEN_PROPERTIES_COUNT_NOT_MATCH));
    
    // NEW: Validate no duplicate keys
    assert_no_duplicate_keys(&keys);
    
    // ... rest of function
}

fun assert_no_duplicate_keys(keys: &vector<String>) {
    let len = keys.length();
    for (i in 0..len) {
        for (j in (i + 1)..len) {
            assert!(keys[i] != keys[j], error::invalid_argument(EDUPLICATE_PROPERTY_KEY));
        }
    }
}
```

This ensures each property is mutated at most once per transaction, maintaining event integrity.

## Proof of Concept

```move
#[test(creator = @0xCAFE)]
fun test_duplicate_key_event_corruption(creator: &signer) acquires Collections {
    // Setup: Create token with initial property
    account::create_account_for_test(signer::address_of(creator));
    create_collection_and_token(
        creator,
        1, 1, 1,
        vector[string::utf8(b"color")],
        vector[b"red"],
        vector[string::utf8(b"String")],
        vector[false, false, false],
        vector[true, false, false, false, false],
    );
    
    let token_data_id = create_token_data_id(
        signer::address_of(creator),
        string::utf8(b"collection"),
        string::utf8(b"token")
    );
    
    // Attack: Mutate with duplicate keys
    mutate_tokendata_property(
        creator,
        token_data_id,
        vector[string::utf8(b"color"), string::utf8(b"color")],
        vector[b"blue", b"green"],
        vector[string::utf8(b"String"), string::utf8(b"String")],
    );
    
    // Verify: On-chain state is "green" (correct)
    let token_data = get_tokendata(creator, token_data_id);
    assert!(token_data.default_properties.read_string(&string::utf8(b"color")) == string::utf8(b"green"), 0);
    
    // Issue: The emitted event contains old_values=[Some("red"), Some("blue")]
    // where "blue" appears as an old_value despite never being committed state
    // (Cannot directly verify event contents in Move test, but observable via event logs)
}
```

The test demonstrates that while on-chain state remains correct (final value is "green"), the event emitted will contain corrupted old_values showing "blue" as a previous state when it was only an intermediate value during the same transaction.

### Citations

**File:** aptos-move/framework/aptos-token/sources/token.move (L863-900)
```text
    public fun mutate_tokendata_property(
        creator: &signer,
        token_data_id: TokenDataId,
        keys: vector<String>,
        values: vector<vector<u8>>,
        types: vector<String>,
    ) acquires Collections {
        assert_tokendata_exists(creator, token_data_id);
        let key_len = keys.length();
        let val_len = values.length();
        let typ_len = types.length();
        assert!(key_len == val_len, error::invalid_state(ETOKEN_PROPERTIES_COUNT_NOT_MATCH));
        assert!(key_len == typ_len, error::invalid_state(ETOKEN_PROPERTIES_COUNT_NOT_MATCH));

        let all_token_data = &mut Collections[token_data_id.creator].token_data;
        let token_data = all_token_data.borrow_mut(token_data_id);
        assert!(token_data.mutability_config.properties, error::permission_denied(EFIELD_NOT_MUTABLE));
        let old_values: vector<Option<PropertyValue>> = vector::empty();
        let new_values: vector<PropertyValue> = vector::empty();
        assert_non_standard_reserved_property(&keys);
        for (i in 0..keys.length()){
            let key = keys.borrow(i);
            let old_pv = if (token_data.default_properties.contains_key(key)) {
                option::some(*token_data.default_properties.borrow(key))
            } else {
                option::none<PropertyValue>()
            };
            old_values.push_back(old_pv);
            let new_pv = property_map::create_property_value_raw(values[i], types[i]);
            new_values.push_back(new_pv);
            if (old_pv.is_some()) {
                token_data.default_properties.update_property_value(key, new_pv);
            } else {
                token_data.default_properties.add(*key, new_pv);
            };
        };
        token_event_store::emit_default_property_mutate_event(creator, token_data_id.collection, token_data_id.name, keys, old_values, new_values);
    }
```

**File:** storage/indexer/src/event_v2_translator.rs (L1186-1193)
```rust
        let default_property_mutate_event = DefaultPropertyMutateEvent::new(
            *default_property_mutate.creator(),
            default_property_mutate.collection().clone(),
            default_property_mutate.token().clone(),
            default_property_mutate.keys().clone(),
            default_property_mutate.old_values().clone(),
            default_property_mutate.new_values().clone(),
        );
```
