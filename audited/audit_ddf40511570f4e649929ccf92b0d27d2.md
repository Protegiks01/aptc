# Audit Report

## Title
Federated JWK Validation Gap: Insufficient Cryptographic Strength Validation Allows Weak or Malicious Keys

## Summary
Federated keyless accounts can use JWKs stored at arbitrary user-controlled addresses without adequate cryptographic strength validation. Unlike governance-controlled central JWKs at address 0x1, federated JWKs lack validation for RSA exponent strength, issuer legitimacy, and key quality, enabling malicious dapp owners to install weak or compromised keys that users unwittingly trust.

## Finding Description

The Aptos keyless authentication system supports two types of JWK storage: central JWKs at the governance-controlled address 0x1, and federated JWKs at user-controlled addresses for dapp-specific OIDC providers. However, there is a critical security gap in how these two types are validated.

**Central JWKs (at 0x1):**
- Require governance approval via proposals [1](#0-0) 
- Updated through validator consensus [2](#0-1) 
- Typically from trusted OIDC providers (Google, Facebook, etc.)

**Federated JWKs (at user addresses):**
- Can be installed by any account owner [3](#0-2) 
- No governance or consensus required
- Only three validation checks performed: [4](#0-3) 

The validation logic treats both sources identically during authentication [5](#0-4)  - first checking 0x1, then falling back to the federated address if not found, with both using the same verification function [6](#0-5) .

**The Security Gap:**

When installing federated JWKs, there is NO validation of:
1. **RSA exponent strength**: The system accepts any exponent value via the jsonwebtoken library [7](#0-6) , including weak values like e=3
2. **Issuer legitimacy**: No verification that the dapp owner represents a legitimate OIDC provider
3. **Cryptographic key quality**: No checks for known-compromised keys or weak parameters
4. **Provider trustworthiness**: No validation beyond basic size limits

**Attack Scenario:**

1. A malicious actor creates a federated keyless dapp at address 0xmalicious
2. They generate an RSA key pair with a weak exponent (e=3) or use keys they fully control
3. They install this JWK via `update_federated_jwk_set` [8](#0-7)  which passes all validation (size check only)
4. Users create federated keyless accounts tied to this address [9](#0-8) 
5. Users trust these accounts with the same security expectations as central keyless accounts
6. The malicious dapp owner can forge JWT signatures or exploit weak cryptographic parameters to compromise user accounts

This breaks the **Cryptographic Correctness** invariant, as the system allows cryptographically weak keys to be used for authentication without validation.

## Impact Explanation

This vulnerability qualifies as **Medium Severity** under the Aptos Bug Bounty program criteria:

- **Limited funds loss or manipulation**: Attackers controlling weak/malicious federated JWKs can forge signatures for user accounts, leading to unauthorized fund transfers
- **State inconsistencies requiring intervention**: Compromised federated accounts would require off-chain coordination to identify and migrate users to secure JWKs
- The 0x1 fallback mechanism [10](#0-9)  provides some mitigation but doesn't protect users who explicitly trust federated JWKs

The impact is NOT Critical/High because:
- It doesn't affect consensus safety or validator operations
- It requires users to explicitly choose federated keyless accounts
- The vulnerability is limited to accounts trusting specific malicious dapp addresses
- No network-wide state corruption occurs

## Likelihood Explanation

**Likelihood: Medium**

This vulnerability is moderately likely to be exploited because:

1. **Low barrier to entry**: Any account owner can install federated JWKs without special privileges
2. **Easy execution**: Installing a weak JWK requires only calling an entry function [11](#0-10) 
3. **Trust assumption**: Users expect federated JWKs to have similar security to central JWKs
4. **No monitoring**: The system has no mechanism to detect or warn about weak JWK parameters
5. **Real-world scenarios**: Both malicious dapp setup and compromised dapp account takeover are realistic attack vectors

The likelihood is not Higher because:
- Users must actively choose to use federated keyless accounts
- Reputable dapps are likely to use proper JWK management
- The 0x1 fallback provides some protection

## Recommendation

Implement cryptographic strength validation for federated JWKs at installation time. Specifically:

1. **Add RSA exponent validation** in `update_federated_jwk_set` and `patch_federated_jwks`:
```move
// In aptos-move/framework/aptos-framework/sources/jwks.move
// Add validation that RSA exponent is AQAB (65537)
public entry fun update_federated_jwk_set(
    jwk_owner: &signer, 
    iss: vector<u8>, 
    kid_vec: vector<String>, 
    alg_vec: vector<String>, 
    e_vec: vector<String>, 
    n_vec: vector<String>
) acquires FederatedJWKs {
    // Existing length checks...
    
    // NEW: Validate RSA exponent strength
    let i = 0;
    while (i < vector::length(&e_vec)) {
        let e = vector::borrow(&e_vec, i);
        assert!(e == &utf8(b"AQAB"), error::invalid_argument(EWEAK_RSA_EXPONENT));
        i = i + 1;
    };
    
    // Continue with existing logic...
}
```

2. **Add modulus size validation** during installation (not just at verification time):
```move
// Validate that n (modulus) decodes to exactly 256 bytes
// This prevents weak key sizes from being installed
```

3. **Add issuer validation**: Require federated JWK owners to prove they control the issuer domain or implement an allow-list mechanism

4. **Implement monitoring**: Emit events when federated JWKs are installed for off-chain analysis

5. **Documentation**: Clearly document the trust model difference between central and federated JWKs to inform users of the risks

## Proof of Concept

The following Move test demonstrates installing a federated JWK with a weak exponent that would be rejected by reputable OIDC providers:

```move
#[test(jwk_owner = @0xadd)]
fun test_weak_exponent_federated_jwk(jwk_owner: &signer) {
    use std::string::utf8;
    
    // Initialize the system
    aptos_framework::jwks::initialize_for_test(jwk_owner);
    
    // Install a JWK with weak exponent e=3 (AWE in base64)
    // This would be rejected by security-conscious providers but is accepted here
    aptos_framework::jwks::update_federated_jwk_set(
        jwk_owner,
        b"https://malicious-provider.com",
        vector[utf8(b"weak-kid-123")],
        vector[utf8(b"RS256")],
        vector[utf8(b"Aw==")], // e=3 in base64 (weak!)
        vector[utf8(b"xGOr_2oO49vhN5SXCvzF8...")], // n (some modulus)
    );
    
    // The installation succeeds despite the weak exponent
    // Users creating accounts trusting this address are now vulnerable
}
```

The test demonstrates that the current validation only checks size limits [12](#0-11)  and address restrictions [13](#0-12) , allowing cryptographically weak parameters to be installed without any warning or rejection.

## Notes

This finding represents a design-level security gap rather than an implementation bug. The federated keyless feature intentionally allows dapp owners to manage their own JWKs, but the lack of cryptographic strength validation creates a trust assumption mismatch where users expect federated JWKs to meet the same security standards as governance-controlled central JWKs, when in fact they have significantly weaker guarantees.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L183-203)
```text
    public fun patch_federated_jwks(jwk_owner: &signer, patches: vector<Patch>) acquires FederatedJWKs {
        // Prevents accidental calls in 0x1::jwks that install federated JWKs at the Aptos framework address.
        assert!(!system_addresses::is_aptos_framework_address(signer::address_of(jwk_owner)),
            error::invalid_argument(EINSTALL_FEDERATED_JWKS_AT_APTOS_FRAMEWORK)
        );

        let jwk_addr = signer::address_of(jwk_owner);
        if (!exists<FederatedJWKs>(jwk_addr)) {
            move_to(jwk_owner, FederatedJWKs { jwks: AllProvidersJWKs { entries: vector[] } });
        };

        let fed_jwks = borrow_global_mut<FederatedJWKs>(jwk_addr);
        vector::for_each_ref(&patches, |obj|{
            let patch: &Patch = obj;
            apply_patch(&mut fed_jwks.jwks, *patch);
        });

        // TODO: Can we check the size more efficiently instead of serializing it via BCS?
        let num_bytes = vector::length(&bcs::to_bytes(fed_jwks));
        assert!(num_bytes < MAX_FEDERATED_JWKS_SIZE_BYTES, error::invalid_argument(EFEDERATED_JWKS_TOO_LARGE));
    }
```

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L258-277)
```text
    public entry fun update_federated_jwk_set(jwk_owner: &signer, iss: vector<u8>, kid_vec: vector<String>, alg_vec: vector<String>, e_vec: vector<String>, n_vec: vector<String>) acquires FederatedJWKs {
        assert!(!vector::is_empty(&kid_vec), error::invalid_argument(EINVALID_FEDERATED_JWK_SET));
        let num_jwk = vector::length<String>(&kid_vec);
        assert!(vector::length(&alg_vec) == num_jwk , error::invalid_argument(EINVALID_FEDERATED_JWK_SET));
        assert!(vector::length(&e_vec) == num_jwk, error::invalid_argument(EINVALID_FEDERATED_JWK_SET));
        assert!(vector::length(&n_vec) == num_jwk, error::invalid_argument(EINVALID_FEDERATED_JWK_SET));

        let remove_all_patch = new_patch_remove_all();
        let patches = vector[remove_all_patch];
        while (!vector::is_empty(&kid_vec)) {
            let kid = vector::pop_back(&mut kid_vec);
            let alg = vector::pop_back(&mut alg_vec);
            let e = vector::pop_back(&mut e_vec);
            let n = vector::pop_back(&mut n_vec);
            let jwk = new_rsa_jwk(kid, alg, e, n);
            let patch = new_patch_upsert_jwk(iss, jwk);
            vector::push_back(&mut patches, patch)
        };
        patch_federated_jwks(jwk_owner, patches);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L379-383)
```text
    public fun set_patches(fx: &signer, patches: vector<Patch>) acquires Patches, PatchedJWKs, ObservedJWKs {
        system_addresses::assert_aptos_framework(fx);
        borrow_global_mut<Patches>(@aptos_framework).patches = patches;
        regenerate_patched_jwks();
    }
```

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L462-505)
```text
    public fun upsert_into_observed_jwks(fx: &signer, provider_jwks_vec: vector<ProviderJWKs>) acquires ObservedJWKs, PatchedJWKs, Patches {
        system_addresses::assert_aptos_framework(fx);
        let observed_jwks = borrow_global_mut<ObservedJWKs>(@aptos_framework);

        if (features::is_jwk_consensus_per_key_mode_enabled()) {
            vector::for_each(provider_jwks_vec, |proposed_provider_jwks|{
                let maybe_cur_issuer_jwks = remove_issuer(&mut observed_jwks.jwks, proposed_provider_jwks.issuer);
                let cur_issuer_jwks = if (option::is_some(&maybe_cur_issuer_jwks)) {
                    option::extract(&mut maybe_cur_issuer_jwks)
                } else {
                    ProviderJWKs {
                        issuer: proposed_provider_jwks.issuer,
                        version: 0,
                        jwks: vector[],
                    }
                };
                assert!(cur_issuer_jwks.version + 1 == proposed_provider_jwks.version, error::invalid_argument(EUNEXPECTED_VERSION));
                vector::for_each(proposed_provider_jwks.jwks, |jwk|{
                    let variant_type_name = *string::bytes(copyable_any::type_name(&jwk.variant));
                    let is_delete = if (variant_type_name == b"0x1::jwks::UnsupportedJWK") {
                        let repr = copyable_any::unpack<UnsupportedJWK>(jwk.variant);
                        &repr.payload == &DELETE_COMMAND_INDICATOR
                    } else {
                        false
                    };
                    if (is_delete) {
                        remove_jwk(&mut cur_issuer_jwks, get_jwk_id(&jwk));
                    } else {
                        upsert_jwk(&mut cur_issuer_jwks, jwk);
                    }
                });
                cur_issuer_jwks.version = cur_issuer_jwks.version + 1;
                upsert_provider_jwks(&mut observed_jwks.jwks, cur_issuer_jwks);
            });
        } else {
            vector::for_each(provider_jwks_vec, |provider_jwks| {
                upsert_provider_jwks(&mut observed_jwks.jwks, provider_jwks);
            });
        };

        let epoch = reconfiguration::current_epoch();
        emit(ObservedJWKsUpdated { epoch, jwks: observed_jwks.jwks });
        regenerate_patched_jwks();
    }
```

**File:** aptos-move/aptos-vm/src/keyless_validation.rs (L112-150)
```rust
fn get_jwk_for_authenticator(
    jwks: &AllProvidersJWKs,
    pk: &KeylessPublicKey,
    sig: &KeylessSignature,
) -> Result<JWK, VMStatus> {
    let jwt_header = sig
        .parse_jwt_header()
        .map_err(|_| invalid_signature!("Failed to parse JWT header"))?;

    let jwk_move_struct = jwks.get_jwk(&pk.iss_val, &jwt_header.kid).map_err(|_| {
        invalid_signature!(format!(
            "JWK for {} with KID {} was not found",
            pk.iss_val, jwt_header.kid
        ))
    })?;

    let jwk = JWK::try_from(jwk_move_struct)
        .map_err(|_| invalid_signature!("Could not unpack Any in JWK Move struct"))?;

    match &jwk {
        JWK::RSA(rsa_jwk) => {
            if rsa_jwk.alg != jwt_header.alg {
                return Err(invalid_signature!(format!(
                    "JWK alg ({}) does not match JWT header's alg ({})",
                    rsa_jwk.alg, jwt_header.alg
                )));
            }
        },
        JWK::Unsupported(jwk) => {
            return Err(invalid_signature!(format!(
                "JWK with KID {} and hex-encoded payload {} is not supported",
                jwt_header.kid,
                hex::encode(&jwk.payload)
            )))
        },
    }

    Ok(jwk)
}
```

**File:** aptos-move/aptos-vm/src/keyless_validation.rs (L236-260)
```rust
        // Try looking up the jwk in 0x1.
        let jwk = match get_jwk_for_authenticator(&patched_jwks.jwks, pk.inner_keyless_pk(), sig) {
            // 1: If found in 0x1, then we consider that the ground truth & we are done.
            Ok(jwk) => jwk,
            // 2: If not found in 0x1, we check the Keyless PK type.
            Err(e) => {
                match pk {
                    // 2.a: If this is a federated keyless account; look in `jwk_addr` for JWKs
                    AnyKeylessPublicKey::Federated(fed_pk) => {
                        let federated_jwks =
                            get_federated_jwks_onchain(resolver, &fed_pk.jwk_addr, module_storage)
                                .map_err(|_| {
                                    invalid_signature!(format!(
                                        "Could not fetch federated PatchedJWKs at {}",
                                        fed_pk.jwk_addr
                                    ))
                                })?;
                        // 2.a.i If not found in jwk_addr either, then we fail the validation.
                        get_jwk_for_authenticator(&federated_jwks.jwks, pk.inner_keyless_pk(), sig)?
                    },
                    // 2.b: If this is not a federated keyless account, then we fail the validation.
                    AnyKeylessPublicKey::Normal(_) => return Err(e),
                }
            },
        };
```

**File:** types/src/jwks/rsa/mod.rs (L89-95)
```rust
    pub fn verify_signature_without_exp_check(&self, jwt_token: &str) -> Result<TokenData<Claims>> {
        let mut validation = Validation::new(Algorithm::RS256);
        validation.validate_exp = false;
        let key = &DecodingKey::from_rsa_components(&self.n, &self.e)?;
        let claims = jsonwebtoken::decode::<Claims>(jwt_token, key, &validation)?;
        Ok(claims)
    }
```

**File:** aptos-move/e2e-move-tests/src/tests/keyless_feature_gating.rs (L313-367)
```rust
fn test_federated_keyless_override_at_0x1() {
    let mut h = MoveHarness::new_with_features(
        vec![
            FeatureFlag::CRYPTOGRAPHY_ALGEBRA_NATIVES,
            FeatureFlag::BN254_STRUCTURES,
            FeatureFlag::KEYLESS_ACCOUNTS,
            FeatureFlag::FEDERATED_KEYLESS,
        ],
        vec![],
    );

    let jwk_addr = AccountAddress::from_hex_literal("0xadd").unwrap();
    let iss = get_sample_iss();
    let jwk = secure_test_rsa_jwk(); // this will be the wrong JWK
    let core_resources = install_federated_jwks_and_set_keyless_config(&mut h, jwk_addr, iss, jwk);

    // Step 0: Make sure the default VK is installed
    run_upgrade_vk_script(
        &mut h,
        core_resources.clone(),
        Groth16VerificationKey::from(VERIFICATION_KEY_FOR_TESTING.clone()),
    );

    // Step 1: Make sure the TXN does not validate, since the wrong JWK is installed at JWK addr
    let (sig, pk) = get_sample_groth16_sig_and_pk();
    let sender = create_federated_keyless_account(&mut h, jwk_addr, pk);
    let recipient = h.new_account_at(AccountAddress::from_hex_literal("0xb0b").unwrap());
    let txn = spend_keyless_account(&mut h, sig.clone(), &sender, *recipient.address());
    let output = h.run_raw(txn);

    match output.status() {
        TransactionStatus::Discard(status) => {
            assert_eq!(
                *status, INVALID_SIGNATURE,
                "Expected TransactionStatus::Discard to be INVALID_SIGNATURE, but got: {:?}",
                status
            )
        },
        _ => panic!(
            "Expected TransactionStatus::Discard, got: {:?}",
            output.status()
        ),
    }

    // Step 2: Install the correct JWK at 0x1 and resubmit the TXN; it should now validate
    run_jwk_and_config_script(&mut h);
    let txn = spend_keyless_account(&mut h, sig, &sender, *recipient.address());
    let output = h.run_raw(txn);

    assert_success!(
        output.status().clone(),
        "Expected TransactionStatus::Keep(ExecutionStatus::Success), but got: {:?}",
        output.status()
    );
}
```

**File:** aptos-move/e2e-move-tests/src/tests/keyless_feature_gating.rs (L432-453)
```rust
fn create_federated_keyless_account(
    h: &mut MoveHarness,
    jwk_addr: AccountAddress,
    pk: KeylessPublicKey,
) -> Account {
    let fed_pk = FederatedKeylessPublicKey { jwk_addr, pk };
    let addr = AuthenticationKey::any_key(AnyPublicKey::federated_keyless(fed_pk.clone()))
        .account_address();
    let account = h.store_and_fund_account(
        &Account::new_from_addr(
            addr,
            AccountPublicKey::AnyPublicKey(AnyPublicKey::FederatedKeyless { public_key: fed_pk }),
        ),
        100000000,
        0,
    );

    println!("Actual address: {}", addr.to_hex());
    println!("Account address: {}", account.address().to_hex());

    account
}
```

**File:** aptos-move/e2e-move-tests/src/tests/keyless_feature_gating.rs (L553-583)
```rust
fn federated_keyless_install_jwk(
    h: &mut MoveHarness,
    jwk_owner: AccountAddress,
    iss: String,
    jwk: RSA_JWK,
) {
    let jwk_owner_account = h.new_account_at(jwk_owner);

    let txn = TransactionBuilder::new(jwk_owner_account.clone())
        .entry_function(EntryFunction::new(
            ModuleId::new(CORE_CODE_ADDRESS, ident_str!("jwks").to_owned()),
            ident_str!("update_federated_jwk_set").to_owned(),
            vec![],
            serialize_values(&vec![
                MoveValue::vector_u8(iss.into_bytes()),
                MoveValue::Vector(vec![MoveValue::vector_u8(jwk.kid.into_bytes())]),
                MoveValue::Vector(vec![MoveValue::vector_u8(jwk.alg.into_bytes())]),
                MoveValue::Vector(vec![MoveValue::vector_u8(jwk.e.into_bytes())]),
                MoveValue::Vector(vec![MoveValue::vector_u8(jwk.n.into_bytes())]),
            ]),
        ))
        .sequence_number(h.sequence_number(jwk_owner_account.address()))
        .max_gas_amount(1_000_000)
        .gas_unit_price(1)
        .sign();

    // NOTE: We cannot write the Configuration and Groth16Verification key via MoveHarness::set_resource
    // because it does not (yet) work with resource groups.

    assert_success!(h.run(txn));
}
```
