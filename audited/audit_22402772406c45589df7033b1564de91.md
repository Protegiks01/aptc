# Audit Report

## Title
Inconsistent Round Count in Sharded Block Execution Leads to Array Bounds Panic

## Summary
While the `ShardedBlockExecutor::execute_block` method correctly validates that shard counts match via assertion, it fails to validate that all shards return consistent round counts. This allows a malicious remote executor to cause an out-of-bounds panic in the coordinator node, leading to validator crash and potential consensus disruption.

## Finding Description

**Direct Answer to Security Question:** The assertion in `ShardedBlockExecutor::execute_block` DOES catch shard count mismatches and prevents array bounds violations from that specific issue. [1](#0-0) 

However, a **related and more severe vulnerability** exists: the code assumes all shards return identical round counts without validation.

The aggregation logic assumes all execution results have the same number of rounds by sampling only the first shard: [2](#0-1) 

It then allocates `ordered_results` based on this assumed `num_rounds`: [3](#0-2) 

When iterating through results, if any shard returns more rounds than `sharded_output[0].len()`, the index calculation causes an out-of-bounds panic: [4](#0-3) 

**Attack Vector:** For `RemoteExecutorClient`, execution results are received from remote executors over the network and deserialized without validation of round counts: [5](#0-4) 

A malicious remote executor can send a `RemoteExecutionResult` with an arbitrary number of rounds, different from other shards. When the coordinator attempts to aggregate results, the calculation `round * num_executor_shards + shard_id` exceeds the bounds of `ordered_results`, causing a panic.

This breaks the **Deterministic Execution** invariant (all validators must process blocks identically) and the **Move VM Safety** invariant (execution must respect memory constraints).

## Impact Explanation

**Severity: High** ($50,000 category per Aptos Bug Bounty)

This vulnerability enables:
1. **Validator Node Crash**: An out-of-bounds panic terminates the validator process
2. **Consensus Liveness Impact**: If multiple validators use remote executors with malicious shards, consensus could stall
3. **Determinism Violation**: Different validators may crash at different points depending on their executor configuration

The impact qualifies as "Validator node slowdowns" and "Significant protocol violations" under High severity criteria.

## Likelihood Explanation

**Likelihood: Medium-High**

**Required Conditions:**
- Validator must use remote sharded block execution (via `REMOTE_SHARDED_BLOCK_EXECUTOR`)
- Attacker must control or compromise a remote executor shard
- Malicious shard must send back results with incorrect round counts

**Complexity:** Low - attacker only needs to modify the `RemoteExecutionResult` message to include extra rounds

**Mitigation Factors:** Not all validators use remote execution; local execution via `LocalExecutorClient` is deterministic and unexploitable through this path

## Recommendation

Add validation to ensure all shards return consistent round counts before aggregation:

```rust
pub fn execute_block(
    &self,
    state_view: Arc<S>,
    transactions: PartitionedTransactions,
    concurrency_level_per_shard: usize,
    onchain_config: BlockExecutorConfigFromOnchain,
) -> Result<Vec<TransactionOutput>, VMStatus> {
    let _timer = SHARDED_BLOCK_EXECUTION_SECONDS.start_timer();
    let num_executor_shards = self.executor_client.num_shards();
    NUM_EXECUTOR_SHARDS.set(num_executor_shards as i64);
    assert_eq!(
        num_executor_shards,
        transactions.num_shards(),
        "Block must be partitioned into {} sub-blocks",
        num_executor_shards
    );
    let (sharded_output, global_output) = self
        .executor_client
        .execute_block(
            state_view,
            transactions,
            concurrency_level_per_shard,
            onchain_config,
        )?
        .into_inner();
    
    info!("ShardedBlockExecutor Received all results");
    let _aggregation_timer = SHARDED_EXECUTION_RESULT_AGGREGATION_SECONDS.start_timer();
    
    // ADDED VALIDATION: Ensure all shards return same number of rounds
    if sharded_output.is_empty() {
        return Err(VMStatus::error(StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR, None));
    }
    let num_rounds = sharded_output[0].len();
    for (shard_id, results) in sharded_output.iter().enumerate() {
        assert_eq!(
            results.len(),
            num_rounds,
            "Shard {} returned {} rounds but expected {} rounds",
            shard_id,
            results.len(),
            num_rounds
        );
    }
    
    // Continue with existing aggregation logic...
    let mut aggregated_results = vec![];
    let mut ordered_results = vec![vec![]; num_executor_shards * num_rounds];
    for (shard_id, results_from_shard) in sharded_output.into_iter().enumerate() {
        for (round, result) in results_from_shard.into_iter().enumerate() {
            ordered_results[round * num_executor_shards + shard_id] = result;
        }
    }
    for result in ordered_results.into_iter() {
        aggregated_results.extend(result);
    }
    aggregated_results.extend(global_output);
    Ok(aggregated_results)
}
```

## Proof of Concept

```rust
// Malicious remote executor exploitation PoC
// This demonstrates how a compromised remote executor shard could trigger the vulnerability

use aptos_types::transaction::TransactionOutput;
use bcs;

// Attacker controls remote executor shard and crafts malicious response
fn craft_malicious_remote_execution_result(expected_rounds: usize) -> Vec<u8> {
    // Create result with MORE rounds than expected
    let malicious_rounds = expected_rounds + 5;  // Add extra rounds
    
    let mut fake_results = Vec::new();
    for _ in 0..malicious_rounds {
        // Each round contains some transaction outputs
        let round_outputs = vec![
            TransactionOutput::new(/* ... */)
        ];
        fake_results.push(round_outputs);
    }
    
    // Serialize as RemoteExecutionResult
    let result = RemoteExecutionResult {
        inner: Ok(fake_results)
    };
    
    bcs::to_bytes(&result).unwrap()
}

// When coordinator receives this in RemoteExecutorClient::get_output_from_shards():
// 1. It deserializes the malicious result with extra rounds
// 2. Returns ShardedExecutionOutput where one shard has more rounds
// 3. ShardedBlockExecutor::execute_block allocates ordered_results[num_shards * num_rounds]
//    where num_rounds = sharded_output[0].len() (could be from honest shard)
// 4. When iterating malicious shard's results, round > num_rounds
// 5. Index = round * num_shards + shard_id >= num_shards * num_rounds
// 6. PANIC: index out of bounds

// Result: Validator node crashes, consensus disrupted
```

## Notes

The original security question asks specifically about shard count mismatches, which ARE properly validated by the assertion. However, this investigation uncovered a related vulnerability where round count inconsistencies within the same shard count can still cause array bounds violations. This represents a gap in validation logic that an attacker can exploit via the remote execution path.

### Citations

**File:** aptos-move/aptos-vm/src/sharded_block_executor/mod.rs (L80-85)
```rust
        assert_eq!(
            num_executor_shards,
            transactions.num_shards(),
            "Block must be partitioned into {} sub-blocks",
            num_executor_shards
        );
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/mod.rs (L98-98)
```rust
        let num_rounds = sharded_output[0].len();
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/mod.rs (L100-100)
```rust
        let mut ordered_results = vec![vec![]; num_executor_shards * num_rounds];
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/mod.rs (L102-106)
```rust
        for (shard_id, results_from_shard) in sharded_output.into_iter().enumerate() {
            for (round, result) in results_from_shard.into_iter().enumerate() {
                ordered_results[round * num_executor_shards + shard_id] = result;
            }
        }
```

**File:** execution/executor-service/src/remote_executor_client.rs (L163-172)
```rust
    fn get_output_from_shards(&self) -> Result<Vec<Vec<Vec<TransactionOutput>>>, VMStatus> {
        trace!("RemoteExecutorClient Waiting for results");
        let mut results = vec![];
        for rx in self.result_rxs.iter() {
            let received_bytes = rx.recv().unwrap().to_bytes();
            let result: RemoteExecutionResult = bcs::from_bytes(&received_bytes).unwrap();
            results.push(result.inner?);
        }
        Ok(results)
    }
```
