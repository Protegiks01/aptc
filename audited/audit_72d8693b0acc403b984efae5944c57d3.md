# Audit Report

## Title
Missing Telemetry for Delayed Values Code Invariant Errors Creates Attack Detection Blind Spot

## Summary
The Aptos Core codebase lacks dedicated metrics collection for `code_invariant_error()` occurrences in the delayed values subsystem, preventing operators from detecting anomalous error patterns that could indicate an ongoing attack or exploitation attempt.

## Finding Description

The `code_invariant_error()` function in the delayed values error handling system creates errors indicating code invariant violations, but does not increment any specific metric counter. [1](#0-0) 

When these errors occur, the only observable output is a `println!` statement to stdout. There is no structured telemetry collection at the point of error creation.

While a `TRANSACTIONS_INVARIANT_VIOLATION` counter exists in the codebase for tracking VM invariant violations, [2](#0-1)  this counter is never actually incremented anywhere in the codebase (confirmed by grep search showing zero usages of `TRANSACTIONS_INVARIANT_VIOLATION.inc`).

The transaction processing metrics in `update_counters_for_processed_chunk` do collect failure reasons in `PROCESSED_FAILED_TXNS_REASON_COUNT`, [3](#0-2)  but this is a general-purpose counter that aggregates all transaction failures, making it impossible to isolate and alert on code invariant error patterns specifically.

When invariant violations occur during transaction execution, the code logs them but does not increment the available invariant violation counter. [4](#0-3)  The TODO comment at line 2991 explicitly acknowledges this gap: "TODO: Add different counters for the error categories here."

**Attack scenario**: An attacker could systematically probe for bugs in delayed field handling by crafting transactions with edge-case parameters that trigger code invariant errors. Without specific metrics:
- Operators cannot distinguish between isolated spurious errors and sustained attack patterns
- No baseline exists to trigger alerts for unusual error rates  
- Errors are buried in general "critical errors" or transaction failure metrics
- Detection requires manual log parsing instead of automated monitoring

## Impact Explanation

This finding falls under **Low Severity** per the Aptos bug bounty criteria as a "non-critical implementation bug" and operational monitoring gap. 

The impact is **indirect**:
- Does not directly cause fund loss, consensus breaks, or liveness failures
- Makes it harder to detect and respond to potential attacks in progress
- Reduces operational visibility into the health of the delayed values subsystem
- Could enable attackers to operate undetected while probing for more serious vulnerabilities

This is an operational security weakness rather than a directly exploitable vulnerability.

## Likelihood Explanation

**High likelihood of occurrence**: Code invariant errors can be triggered by:
- Edge cases in delayed field operations during normal usage
- Parallel execution race conditions
- Malicious transactions crafted to probe system boundaries
- Software bugs in the delayed values implementation

**Low likelihood of exploitation impact**: While the monitoring gap exists, exploiting it requires:
- Finding actual bugs in delayed field handling that trigger these errors
- The lack of metrics alone doesn't create new attack vectors
- Operators can still detect issues through log analysis (though less efficiently)

## Recommendation

1. **Increment the existing counter**: Modify the invariant violation handling code to increment `TRANSACTIONS_INVARIANT_VIOLATION` when code invariant errors occur:

```rust
// In aptos-move/aptos-vm/src/aptos_vm.rs around line 2992
StatusCode::DELAYED_FIELD_OR_BLOCKSTM_CODE_INVARIANT_ERROR => {
    TRANSACTIONS_INVARIANT_VIOLATION.inc();
    error!(
        *log_context,
        "[aptos_vm] Delayed field code invariant violation: {:?}\ntxn: {:?}",
        vm_status,
        bcs::to_bytes::<SignedTransaction>(txn),
    );
}
```

2. **Add specific counter for delayed field errors**: Create a dedicated metric counter:

```rust
// In aptos-move/aptos-vm/src/counters.rs
pub static DELAYED_FIELD_INVARIANT_ERRORS: Lazy<IntCounter> = Lazy::new(|| {
    register_int_counter!(
        "aptos_vm_delayed_field_invariant_errors",
        "Number of delayed field code invariant violations"
    ).unwrap()
});
```

3. **Increment at error source**: Modify the `code_invariant_error()` function to increment metrics:

```rust
// In third_party/move/move-vm/types/src/delayed_values/error.rs
pub fn code_invariant_error<M: std::fmt::Debug>(message: M) -> PartialVMError {
    let msg = format!(
        "Delayed logic code invariant broken (there is a bug in the code), {:?}",
        message
    );
    println!("ERROR: {}", msg);
    
    // Add metric increment here (requires importing the counter)
    // DELAYED_FIELD_INVARIANT_ERRORS.inc();
    
    PartialVMError::new(StatusCode::DELAYED_FIELD_OR_BLOCKSTM_CODE_INVARIANT_ERROR)
        .with_message(msg)
}
```

4. **Set up alerting**: Configure monitoring dashboards and alerts to trigger when the rate of these errors exceeds baseline thresholds.

## Proof of Concept

This is an operational/monitoring gap rather than a directly exploitable vulnerability, so a traditional PoC demonstrating exploitation is not applicable. However, the absence of metrics can be verified by:

1. Searching the codebase for `TRANSACTIONS_INVARIANT_VIOLATION.inc()` - returns zero results
2. Examining the `code_invariant_error()` function - contains only `println!`, no metric calls
3. Checking transaction metrics collection - only general-purpose counters exist

To demonstrate the monitoring gap, operators can:
- Grep logs for "Delayed logic code invariant broken" to count occurrences manually
- Observe that Prometheus/Grafana dashboards lack specific delayed field error metrics
- Note that the `aptos_vm_transactions_invariant_violation` metric never increments despite invariant errors occurring

---

## Notes

While this is a legitimate operational security concern that should be addressed, it does not meet the strict criteria for a **directly exploitable vulnerability** with clear attack path and immediate impact on funds, consensus, or availability. The finding represents a gap in defensive monitoring capabilities rather than an active security hole.

The categorization as Low severity aligns with the question's own severity assessment and the bug bounty program's definition of "non-critical implementation bugs."

### Citations

**File:** third_party/move/move-vm/types/src/delayed_values/error.rs (L11-19)
```rust
pub fn code_invariant_error<M: std::fmt::Debug>(message: M) -> PartialVMError {
    let msg = format!(
        "Delayed logic code invariant broken (there is a bug in the code), {:?}",
        message
    );
    println!("ERROR: {}", msg);
    PartialVMError::new(StatusCode::DELAYED_FIELD_OR_BLOCKSTM_CODE_INVARIANT_ERROR)
        .with_message(msg)
}
```

**File:** aptos-move/aptos-vm/src/counters.rs (L45-52)
```rust
/// Count the number of transactions that brake invariants of VM.
pub static TRANSACTIONS_INVARIANT_VIOLATION: Lazy<IntCounter> = Lazy::new(|| {
    register_int_counter!(
        "aptos_vm_transactions_invariant_violation",
        "Number of transactions that broke VM invariant",
    )
    .unwrap()
});
```

**File:** execution/executor/src/metrics.rs (L287-347)
```rust
        let (state, reason, error_code) = match output.status() {
            TransactionStatus::Keep(execution_status) => match execution_status {
                ExecutionStatus::Success => ("keep_success", "", "".to_string()),
                ExecutionStatus::OutOfGas => ("keep_rejected", "OutOfGas", "error".to_string()),
                ExecutionStatus::MoveAbort { info, .. } => (
                    "keep_rejected",
                    "MoveAbort",
                    if detailed_counters {
                        info.as_ref()
                            .map(|v| v.reason_name.to_lowercase())
                            .unwrap_or_else(|| "none".to_string())
                    } else {
                        "error".to_string()
                    },
                ),
                ExecutionStatus::ExecutionFailure { .. } => {
                    ("keep_rejected", "ExecutionFailure", "error".to_string())
                },
                ExecutionStatus::MiscellaneousError(e) => (
                    "keep_rejected",
                    "MiscellaneousError",
                    if detailed_counters {
                        e.map(|v| format!("{:?}", v).to_lowercase())
                            .unwrap_or_else(|| "none".to_string())
                    } else {
                        "error".to_string()
                    },
                ),
            },
            TransactionStatus::Discard(discard_status_code) => {
                (
                    // Specialize duplicate txns for alerts
                    if *discard_status_code == StatusCode::SEQUENCE_NUMBER_TOO_OLD {
                        "discard_sequence_number_too_old"
                    } else if *discard_status_code == StatusCode::SEQUENCE_NUMBER_TOO_NEW {
                        "discard_sequence_number_too_new"
                    } else if *discard_status_code == StatusCode::TRANSACTION_EXPIRED {
                        "discard_transaction_expired"
                    } else if *discard_status_code == StatusCode::NONCE_ALREADY_USED {
                        "discard_nonce_already_used"
                    } else {
                        // Only log if it is an interesting discard
                        sample!(
                            SampleRate::Duration(Duration::from_secs(15)),
                            warn!(
                                "[sampled] Txn being discarded is {:?} with status code {:?}",
                                txn, discard_status_code
                            );
                        );
                        "discard"
                    },
                    "error_code",
                    if detailed_counters {
                        format!("{:?}", discard_status_code).to_lowercase()
                    } else {
                        "error".to_string()
                    },
                )
            },
            TransactionStatus::Retry => ("retry", "", "".to_string()),
        };
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L2928-3001)
```rust
                if let StatusType::InvariantViolation = vm_status.status_type() {
                    match vm_status.status_code() {
                        // Type resolution failure can be triggered by user input when providing a bad type argument, skip this case.
                        StatusCode::TYPE_RESOLUTION_FAILURE
                        if vm_status.sub_status()
                            == Some(move_core_types::vm_status::sub_status::type_resolution_failure::EUSER_TYPE_LOADING_FAILURE) => {},
                        // The known Move function failure and type resolution failure could be a result of speculative execution. Use speculative logger.
                        StatusCode::UNEXPECTED_ERROR_FROM_KNOWN_MOVE_FUNCTION
                        | StatusCode::TYPE_RESOLUTION_FAILURE => {
                            speculative_error!(
                                log_context,
                                format!(
                                    "[aptos_vm] Transaction breaking invariant violation: {:?}\ntxn: {:?}",
                                    vm_status,
                                    bcs::to_bytes::<SignedTransaction>(txn),
                                ),
                            );
                        },
                        // Paranoid mode failure. We need to be alerted about this ASAP.
                        StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR
                        if vm_status.sub_status()
                            == Some(unknown_invariant_violation::EPARANOID_FAILURE) =>
                            {
                                error!(
                                *log_context,
                                "[aptos_vm] Transaction breaking paranoid mode: {:?}\ntxn: {:?}",
                                vm_status,
                                bcs::to_bytes::<SignedTransaction>(txn),
                            );
                            },
                        // Paranoid mode failure but with reference counting
                        StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR
                        if vm_status.sub_status()
                            == Some(unknown_invariant_violation::EREFERENCE_COUNTING_FAILURE) =>
                            {
                                error!(
                                *log_context,
                                "[aptos_vm] Transaction breaking paranoid mode: {:?}\ntxn: {:?}",
                                vm_status,
                                bcs::to_bytes::<SignedTransaction>(txn),
                            );
                            },
                        // Paranoid mode failure but with reference safety checks
                        StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR
                        if matches!(
                            vm_status.sub_status(),
                            Some(
                                unknown_invariant_violation::EREFERENCE_SAFETY_FAILURE
                                | unknown_invariant_violation::EINDEXED_REF_TAG_MISMATCH
                            )
                        ) =>
                        {
                            error!(
                            *log_context,
                            "[aptos_vm] Transaction breaking paranoid reference safety check (including enum tag guard). txn: {:?}, status: {:?}",
                            bcs::to_bytes::<SignedTransaction>(txn),
                            vm_status,
                            );
                        }
                        // Ignore DelayedFields speculative errors as it can be intentionally triggered by parallel execution.
                        StatusCode::SPECULATIVE_EXECUTION_ABORT_ERROR => (),
                        // We will log the rest of invariant violation directly with regular logger as they shouldn't happen.
                        //
                        // TODO: Add different counters for the error categories here.
                        _ => {
                            error!(
                                *log_context,
                                "[aptos_vm] Transaction breaking invariant violation: {:?}\ntxn: {:?}, ",
                                vm_status,
                                bcs::to_bytes::<SignedTransaction>(txn),
                            );
                        },
                    }
                }
```
