# Audit Report

## Title
Unbounded Computational Work in Aggregator Change Set Processing Without Gas Metering

## Summary
The `into_change_set()` function in the aggregator context performs unbounded computational work after Move VM execution completes, without gas metering. An attacker can create transactions with up to 81,920 aggregators (8,192 resources Ã— 10 aggregators per resource), causing unmetered processing during change set finalization.

## Finding Description

The vulnerability exists in the aggregator change set processing flow:

1. **During Transaction Execution**: Aggregator operations (add, sub, read) are properly gas-metered through native function gas parameters. [1](#0-0) 

2. **After Execution Completes**: The `Session::finish()` method calls `aggregator_context.into_change_set()` without passing a gas meter. [2](#0-1) 

3. **Unmetered Processing**: The `into_change_set()` function performs computational work that scales with the number of aggregators: [3](#0-2) 

The function loops through all aggregators (line 115-134), all destroyed aggregators (line 137-139), and calls `get_reads_needing_exchange()` which iterates through all reads (line 155-156).

4. **Known Issue**: There's an explicit TODO comment acknowledging this gap: [4](#0-3) 

5. **Attack Surface**: An attacker can exploit the following limits:
   - Maximum 8,192 write operations per transaction [5](#0-4) 
   
   - Maximum 10 aggregators per resource [6](#0-5) 

This yields a theoretical maximum of 81,920 aggregators per transaction, all processed without gas metering.

## Impact Explanation

This issue qualifies as **Medium Severity** rather than High because:

1. **Limited DoS Potential**: While the work is unmetered, the per-aggregator processing (struct creation, BTreeMap insertion) is lightweight. With 81,920 aggregators, this adds approximately 10-100ms of extra processing time.

2. **Transaction Limits Constrain Attack**: The 8,192 write ops limit and per-resource costs during execution limit the practical attack scale.

3. **No Consensus Impact**: The processing is deterministic and does not cause consensus splits or state inconsistencies.

4. **Acknowledged Issue**: The developers are aware of this gap (TODO comments) and have implemented temporary mitigations (10 aggregators per resource limit).

The impact aligns with **Medium Severity** per the bug bounty program: "State inconsistencies requiring intervention" - while not causing direct inconsistencies, it violates the gas metering invariant and could contribute to validator performance degradation under sustained attack.

## Likelihood Explanation

**Likelihood: Medium to High**

An attacker can realistically execute this attack by:
1. Creating Move modules that generate multiple resources with aggregators
2. Submitting transactions that maximize write operations (up to 8,192)
3. Each resource containing the maximum 10 aggregators
4. Paying for the gas-metered execution but exploiting the unmetered change set processing

However, the actual impact per transaction is limited by the computational overhead being relatively small compared to normal transaction processing.

## Recommendation

Implement gas charging for aggregator change set processing:

1. **Pass gas meter to `into_change_set()`**: Modify the function signature to accept a gas meter parameter.

2. **Charge per aggregator processed**: Add gas charges for each aggregator in the loops at lines 115-134 and 137-139.

3. **Charge for `get_reads_needing_exchange` calls**: Add gas charges proportional to the number of reads processed.

4. **Update gas schedule**: Add new gas parameters for aggregator change set operations:
   - `aggregator_change_set_per_aggregator_base`
   - `aggregator_change_set_per_read_base`

This addresses the TODO at line 1158 and ensures all computational work is properly metered.

## Proof of Concept

```move
// Module that creates many resources with aggregators
module attacker::dos_test {
    use aptos_framework::aggregator_v2;
    
    struct ResourceWithAggregators has key {
        agg1: aggregator_v2::Aggregator<u64>,
        agg2: aggregator_v2::Aggregator<u64>,
        agg3: aggregator_v2::Aggregator<u64>,
        agg4: aggregator_v2::Aggregator<u64>,
        agg5: aggregator_v2::Aggregator<u64>,
        agg6: aggregator_v2::Aggregator<u64>,
        agg7: aggregator_v2::Aggregator<u64>,
        agg8: aggregator_v2::Aggregator<u64>,
        agg9: aggregator_v2::Aggregator<u64>,
        agg10: aggregator_v2::Aggregator<u64>,
    }
    
    // Create many resources, each with 10 aggregators
    public entry fun create_dos_resources(account: &signer) {
        let i = 0;
        // Create as many as possible within gas limits
        while (i < 1000) {
            move_to(account, ResourceWithAggregators {
                agg1: aggregator_v2::create_aggregator(1000),
                agg2: aggregator_v2::create_aggregator(1000),
                agg3: aggregator_v2::create_aggregator(1000),
                agg4: aggregator_v2::create_aggregator(1000),
                agg5: aggregator_v2::create_aggregator(1000),
                agg6: aggregator_v2::create_aggregator(1000),
                agg7: aggregator_v2::create_aggregator(1000),
                agg8: aggregator_v2::create_aggregator(1000),
                agg9: aggregator_v2::create_aggregator(1000),
                agg10: aggregator_v2::create_aggregator(1000),
            });
            i = i + 1;
        }
    }
}
```

The transaction would pay for gas during execution but cause unmetered processing in `into_change_set()` proportional to the number of aggregators created.

## Notes

While this vulnerability represents a violation of the gas metering invariant, the practical DoS impact is limited by:
- The lightweight nature of per-aggregator processing
- Transaction limits that constrain the attack scale
- Developer awareness (TODO comments indicate known issue)

The issue should still be addressed to ensure complete gas accounting and prevent potential abuse vectors in future optimizations or protocol changes.

### Citations

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/aptos_framework.rs (L329-348)
```rust
        [aggregator_add_base: InternalGas, "aggregator.add.base", 1102],
        [aggregator_read_base: InternalGas, "aggregator.read.base", 1102],
        [aggregator_sub_base: InternalGas, "aggregator.sub.base", 1102],
        [aggregator_destroy_base: InternalGas, "aggregator.destroy.base", 1838],
        [aggregator_factory_new_aggregator_base: InternalGas, "aggregator_factory.new_aggregator.base", 1838],

        [aggregator_v2_create_aggregator_base: InternalGas, {RELEASE_V1_9_SKIPPED.. => "aggregator_v2.create_aggregator.base"}, 1838],
        [aggregator_v2_try_add_base: InternalGas, {RELEASE_V1_9_SKIPPED.. => "aggregator_v2.try_add.base"}, 1102],
        [aggregator_v2_try_sub_base: InternalGas, {RELEASE_V1_9_SKIPPED.. => "aggregator_v2.try_sub.base"}, 1102],
        [aggregator_v2_is_at_least_base: InternalGas, {RELEASE_V1_14.. => "aggregator_v2.is_at_least.base"}, 500],

        [aggregator_v2_read_base: InternalGas, {RELEASE_V1_9_SKIPPED.. => "aggregator_v2.read.base"}, 2205],
        [aggregator_v2_snapshot_base: InternalGas, {RELEASE_V1_9_SKIPPED.. => "aggregator_v2.snapshot.base"}, 1102],

        [aggregator_v2_create_snapshot_base: InternalGas, {RELEASE_V1_8.. => "aggregator_v2.create_snapshot.base"}, 1102],
        [aggregator_v2_create_snapshot_per_byte: InternalGasPerByte, { RELEASE_V1_9_SKIPPED.. =>"aggregator_v2.create_snapshot.per_byte" }, 3],
        [aggregator_v2_copy_snapshot_base: InternalGas, {RELEASE_V1_8.. => "aggregator_v2.copy_snapshot.base"}, 1102],
        [aggregator_v2_read_snapshot_base: InternalGas, {RELEASE_V1_8.. => "aggregator_v2.read_snapshot.base"}, 2205],
        [aggregator_v2_string_concat_base: InternalGas, {RELEASE_V1_8.. => "aggregator_v2.string_concat.base"}, 1102],
        [aggregator_v2_string_concat_per_byte: InternalGasPerByte, { RELEASE_V1_9_SKIPPED.. =>"aggregator_v2.string_concat.per_byte" }, 3],
```

**File:** aptos-move/aptos-vm/src/move_vm_ext/session/mod.rs (L225-228)
```rust
        let aggregator_context: NativeAggregatorContext = extensions.remove();
        let aggregator_change_set = aggregator_context
            .into_change_set()
            .map_err(|e| e.finish(Location::Undefined))?;
```

**File:** aptos-move/framework/src/natives/aggregator_natives/context.rs (L104-165)
```rust
    pub fn into_change_set(self) -> PartialVMResult<AggregatorChangeSet> {
        let NativeAggregatorContext {
            aggregator_v1_data,
            delayed_field_data,
            ..
        } = self;
        let (_, destroyed_aggregators, aggregators) = aggregator_v1_data.into_inner().into();

        let mut aggregator_v1_changes = BTreeMap::new();

        // First, process all writes and deltas.
        for (id, aggregator) in aggregators {
            let (value, state, limit, history) = aggregator.into();

            let change = match state {
                AggregatorState::Data => AggregatorChangeV1::Write(value),
                AggregatorState::PositiveDelta => {
                    let history = history.unwrap();
                    let plus = SignedU128::Positive(value);
                    let delta_op = DeltaOp::new(plus, limit, history);
                    AggregatorChangeV1::Merge(delta_op)
                },
                AggregatorState::NegativeDelta => {
                    let history = history.unwrap();
                    let minus = SignedU128::Negative(value);
                    let delta_op = DeltaOp::new(minus, limit, history);
                    AggregatorChangeV1::Merge(delta_op)
                },
            };
            aggregator_v1_changes.insert(id.0, change);
        }

        // Additionally, do not forget to delete destroyed values from storage.
        for id in destroyed_aggregators {
            aggregator_v1_changes.insert(id.0, AggregatorChangeV1::Delete);
        }

        let delayed_field_changes = delayed_field_data.into_inner().into();
        let delayed_write_set_ids = delayed_field_changes
            .keys()
            .cloned()
            .collect::<HashSet<_>>();
        Ok(AggregatorChangeSet {
            aggregator_v1_changes,
            delayed_field_changes,
            // is_empty check covers both whether delayed fields are enabled or not, as well as whether there
            // are any changes that would require computing reads needing exchange.
            // TODO[agg_v2](optimize) we only later compute the write set, so cannot pass the correct skip values here.
            reads_needing_exchange: if delayed_write_set_ids.is_empty() {
                BTreeMap::new()
            } else {
                self.delayed_field_resolver
                    .get_reads_needing_exchange(&delayed_write_set_ids, &HashSet::new())?
            },
            group_reads_needing_exchange: if delayed_write_set_ids.is_empty() {
                BTreeMap::new()
            } else {
                self.delayed_field_resolver
                    .get_group_reads_needing_exchange(&delayed_write_set_ids, &HashSet::new())?
            },
        })
    }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1158-1158)
```rust
        // TODO[agg_v1](fix): Charge for aggregator writes
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L174-177)
```rust
            max_write_ops_per_transaction: NumSlots,
            { 11.. => "max_write_ops_per_transaction" },
            8192,
        ],
```

**File:** third_party/move/move-vm/types/src/value_serde.rs (L49-54)
```rust
impl DelayedFieldsExtension<'_> {
    // Temporarily limit the number of delayed fields per resource, until proper charges are
    // implemented.
    // TODO[agg_v2](clean):
    //   Propagate up, so this value is controlled by the gas schedule version.
    const MAX_DELAYED_FIELDS_PER_RESOURCE: usize = 10;
```
