# Audit Report

## Title
Non-Atomic Transaction Commit During Database Restore Allows Temporary State Inconsistency

## Summary
The `save_transactions()` function in the database restore flow performs two separate, non-atomic commits to state_kv_db and ledger_db. If an error occurs between these commits (process crash, I/O error, disk space exhaustion), the database is left in an inconsistent state where state KV data is ahead of ledger data. While a recovery mechanism exists, there is a window of inconsistency that violates the atomic state transition invariant.

## Finding Description
During transaction restore operations, the `save_before_replay_version()` function spawns a blocking task that calls `save_transactions()`. [1](#0-0) 

The `save_transactions()` function delegates to `restore_utils::save_transactions()`, which performs two sequential commits: [2](#0-1) 

The critical issue is that these commits are not atomic:
1. **First commit** (line 170): `state_kv_db.commit()` writes state data and updates `StateKvCommitProgress` metadata
2. **Second commit** (line 172): `ledger_db.write_schemas()` writes transactions, transaction infos, events, and updates `OverallCommitProgress` metadata

If any error occurs between these two commits (I/O error, disk full, process termination, panic), the database enters an inconsistent state:
- State KV database contains data up to version X with `StateKvCommitProgress = X`
- Ledger database only contains data up to version Y (where Y < X) with `OverallCommitProgress = Y`
- Transaction data, transaction infos, and events for versions Y+1 to X exist in state KV but not in ledger DB

**Recovery Mechanism**: The system includes `sync_commit_progress()` that runs on database initialization to detect and fix such inconsistencies by truncating state_kv_db back to the overall commit progress. [3](#0-2) 

However, this recovery only occurs during node restart/reinitialization, leaving a window where the database is inconsistent.

## Impact Explanation
This issue represents a **Medium Severity** vulnerability per Aptos bug bounty criteria:

**State Inconsistencies Requiring Intervention**: The database can enter an inconsistent state where different storage components are at different versions. While automatic recovery exists via `sync_commit_progress()`, it only activates on node restart, requiring operator intervention.

**Violated Invariant**: This breaks the **State Consistency** invariant: "State transitions must be atomic and verifiable via Merkle proofs." The non-atomic nature of the commit means the database can be in a partially committed state.

**Limited Impact Factors**:
- Recovery mechanism exists and runs automatically on restart
- No permanent data loss (truncation restores consistency)
- Restore operations are typically performed offline
- Maximum inconsistency per failure is limited to BATCH_SIZE (10,000 transactions) [4](#0-3) 

The issue does NOT rise to High or Critical severity because:
- It does not cause permanent consensus violations
- It does not result in irrecoverable data loss
- The recovery mechanism prevents long-term impact

## Likelihood Explanation
**Likelihood: Medium to Low**

This vulnerability can be triggered when:
1. A database restore operation is in progress
2. An error occurs during the precise window between the two commits (lines 170-172)
3. Possible triggers include: disk space exhaustion, I/O errors, hardware failures, process termination (SIGKILL), or panics

**Factors Reducing Likelihood**:
- Restore operations are typically performed by operators in controlled environments
- The error window is small (only between two sequential commit operations)
- The double `??` operator propagates errors immediately, stopping further processing [5](#0-4) 
- Panic handler causes process exit, triggering recovery on next start [6](#0-5) 

**Factors Increasing Likelihood**:
- Restore operations handle large volumes of data, increasing chance of resource issues
- Concurrent I/O operations could cause contention
- Disk space can be exhausted during large restores

## Recommendation

**Solution 1: Make Commits Atomic Using Write-Ahead Logging**
Implement a two-phase commit protocol where:
1. Prepare both batches
2. Write a commit intent record
3. Commit both batches
4. Remove commit intent record

**Solution 2: Reverse Commit Order with Validation**
Commit ledger_db first, then state_kv_db. On startup, verify that state_kv_commit_progress >= overall_commit_progress (not <=), and apply missing state updates from write sets if state_kv is behind.

**Solution 3: Add Progress Validation Before Commit**
Before starting the non-atomic commit sequence, write a "commit-in-progress" marker. If this marker exists on startup, trigger recovery. Remove the marker only after both commits succeed.

**Recommended Fix (Solution 3 - Minimal Change)**:

In `restore_utils.rs`, modify `save_transactions()`:

```rust
// Before line 167, add:
ledger_db.metadata_db().put::<DbMetadataSchema>(
    &DbMetadataKey::SaveTransactionsInProgress,
    &DbMetadataValue::Version(last_version),
)?;

// After line 172, add:
ledger_db.metadata_db().delete::<DbMetadataSchema>(
    &DbMetadataKey::SaveTransactionsInProgress,
)?;
```

In `state_store/mod.rs`, modify `sync_commit_progress()` to check for the in-progress marker and trigger full recovery if found.

## Proof of Concept

```rust
// Test to reproduce the inconsistency
#[tokio::test]
async fn test_non_atomic_save_transactions_inconsistency() {
    // Setup: Create a test database with initial state
    let tmpdir = aptos_temppath::TempPath::new();
    let db = AptosDB::new_for_test(&tmpdir);
    let restore_handler = db.get_restore_handler();
    
    // Prepare test transactions
    let mut txns = vec![];
    let mut txn_infos = vec![];
    let mut events = vec![];
    let mut write_sets = vec![];
    let mut persisted_aux_info = vec![];
    
    for i in 0..100 {
        let txn = Transaction::dummy_with_version(i);
        let txn_info = TransactionInfo::dummy();
        txns.push(txn);
        txn_infos.push(txn_info);
        events.push(vec![]);
        write_sets.push(WriteSet::default());
        persisted_aux_info.push(PersistedAuxiliaryInfo::None);
    }
    
    // Simulate failure after state_kv_db commit but before ledger_db commit
    // by injecting an error in ledger_db write operation
    let result = tokio::task::spawn_blocking(move || {
        restore_handler.save_transactions(
            0,
            &txns,
            &persisted_aux_info,
            &txn_infos,
            &events,
            write_sets,
        )
    }).await;
    
    // Verify the database is in inconsistent state
    let state_kv_progress = db.state_kv_db.metadata_db()
        .get::<DbMetadataSchema>(&DbMetadataKey::StateKvCommitProgress)
        .unwrap()
        .unwrap()
        .expect_version();
    
    let overall_progress = db.ledger_db.metadata_db()
        .get_synced_version()
        .unwrap()
        .unwrap();
    
    // Assert inconsistency
    assert!(state_kv_progress > overall_progress, 
        "State KV is ahead of overall progress, indicating inconsistency");
    
    // Verify recovery by calling sync_commit_progress
    StateStore::sync_commit_progress(
        db.ledger_db.clone(),
        db.state_kv_db.clone(),
        db.state_merkle_db.clone(),
        true,
    );
    
    // After recovery, verify consistency is restored
    let state_kv_progress_after = db.state_kv_db.metadata_db()
        .get::<DbMetadataSchema>(&DbMetadataKey::StateKvCommitProgress)
        .unwrap()
        .unwrap()
        .expect_version();
    
    assert_eq!(state_kv_progress_after, overall_progress,
        "Recovery should have truncated state KV to match overall progress");
}
```

## Notes

The code contains an explicit comment acknowledging this non-atomic behavior: [7](#0-6) 

The recovery mechanism's comment also acknowledges the lack of atomicity: [8](#0-7) 

This suggests the developers are aware of the limitation and have designed the recovery mechanism to handle it. However, the temporary window of inconsistency still violates the atomic state transition invariant and could cause operational issues if a node attempts to use the database before restart.

### Citations

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L62-62)
```rust
const BATCH_SIZE: usize = if cfg!(test) { 2 } else { 10000 };
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L507-517)
```rust
                        tokio::task::spawn_blocking(move || {
                            restore_handler.save_transactions(
                                first_version,
                                &txns_to_save,
                                &persisted_aux_info_to_save,
                                &txn_infos_to_save,
                                &event_vecs_to_save,
                                write_sets_to_save,
                            )
                        })
                        .await??;
```

**File:** storage/aptosdb/src/backup/restore_utils.rs (L165-165)
```rust
        // commit the state kv before ledger in case of failure happens
```

**File:** storage/aptosdb/src/backup/restore_utils.rs (L167-172)
```rust
        state_store
            .state_db
            .state_kv_db
            .commit(last_version, None, sharded_kv_schema_batch)?;

        ledger_db.write_schemas(ledger_db_batch)?;
```

**File:** storage/aptosdb/src/state_store/mod.rs (L410-467)
```rust
    pub fn sync_commit_progress(
        ledger_db: Arc<LedgerDb>,
        state_kv_db: Arc<StateKvDb>,
        state_merkle_db: Arc<StateMerkleDb>,
        crash_if_difference_is_too_large: bool,
    ) {
        let ledger_metadata_db = ledger_db.metadata_db();
        if let Some(overall_commit_progress) = ledger_metadata_db
            .get_synced_version()
            .expect("DB read failed.")
        {
            info!(
                overall_commit_progress = overall_commit_progress,
                "Start syncing databases..."
            );
            let ledger_commit_progress = ledger_metadata_db
                .get_ledger_commit_progress()
                .expect("Failed to read ledger commit progress.");
            assert_ge!(ledger_commit_progress, overall_commit_progress);

            let state_kv_commit_progress = state_kv_db
                .metadata_db()
                .get::<DbMetadataSchema>(&DbMetadataKey::StateKvCommitProgress)
                .expect("Failed to read state K/V commit progress.")
                .expect("State K/V commit progress cannot be None.")
                .expect_version();
            assert_ge!(state_kv_commit_progress, overall_commit_progress);

            // LedgerCommitProgress was not guaranteed to commit after all ledger changes finish,
            // have to attempt truncating every column family.
            info!(
                ledger_commit_progress = ledger_commit_progress,
                "Attempt ledger truncation...",
            );
            let difference = ledger_commit_progress - overall_commit_progress;
            if crash_if_difference_is_too_large {
                assert_le!(difference, MAX_COMMIT_PROGRESS_DIFFERENCE);
            }
            truncate_ledger_db(ledger_db.clone(), overall_commit_progress)
                .expect("Failed to truncate ledger db.");

            // State K/V commit progress isn't (can't be) written atomically with the data,
            // because there are shards, so we have to attempt truncation anyway.
            info!(
                state_kv_commit_progress = state_kv_commit_progress,
                "Start state KV truncation..."
            );
            let difference = state_kv_commit_progress - overall_commit_progress;
            if crash_if_difference_is_too_large {
                assert_le!(difference, MAX_COMMIT_PROGRESS_DIFFERENCE);
            }
            truncate_state_kv_db(
                &state_kv_db,
                state_kv_commit_progress,
                overall_commit_progress,
                std::cmp::max(difference as usize, 1), /* batch_size */
            )
            .expect("Failed to truncate state K/V db.");
```

**File:** crates/crash-handler/src/lib.rs (L56-57)
```rust
    // Kill the process
    process::exit(12);
```
