# Audit Report

## Title
Unbounded Memory Allocation in JWK Consensus from Malicious OIDC Providers

## Summary
The JWK consensus module lacks size validation when fetching JWKs from external OIDC providers, allowing compromised or malicious providers to serve arbitrarily large payloads that cause memory exhaustion in validator nodes through `ObservationAggregationState`.

## Finding Description

The vulnerability exists in the JWK observation and consensus flow where validators fetch JSON Web Keys from external OIDC providers without any size constraints.

**Attack Flow:**

1. A compromised or malicious OIDC provider (registered on-chain) serves an extremely large JWK set (hundreds of MiB or GiB)

2. The `fetch_jwks_from_jwks_uri()` function fetches the response with no size limit: [1](#0-0) 

3. For unsupported JWK types, the entire JSON payload is stored as raw bytes: [2](#0-1) 

4. The `ProviderJWKs` structure has no size limits on its vector of JWKs: [3](#0-2) 

5. When `start_produce()` is called, it creates an `ObservationAggregationState` that stores the entire large payload in memory: [4](#0-3) 

6. The `ObservationAggregationState` holds the large `ProviderJWKs` in `local_view` for the duration of the consensus session: [5](#0-4) 

7. With multiple on-chain issuers serving large JWK sets, validators allocate multiple large `ObservationAggregationState` instances concurrently, leading to memory exhaustion.

**Why Network Limits Don't Protect:**
While the network layer enforces a 64 MiB message size limit for P2P communication, JWK fetching happens via direct HTTP requests to external OIDC providers, bypassing these network-layer protections entirely.

**Invariant Violation:**
This breaks the "Resource Limits" invariant: "All operations must respect gas, storage, and computational limits." JWK fetching and storage have no resource constraints.

## Impact Explanation

**Severity: High** (up to $50,000)

This qualifies as **"Validator node slowdowns"** under the High severity category. The impact includes:

- **Memory Exhaustion**: Each malicious issuer can cause validators to allocate hundreds of MiB to GiB of memory
- **Performance Degradation**: Memory pressure causes increased GC overhead, swap usage, and slower consensus participation  
- **Potential Node Crashes**: Extreme cases may trigger OOM conditions
- **Network-Wide Impact**: All validators fetching from the malicious provider are affected simultaneously

While this doesn't directly cause consensus violations or fund loss, it significantly degrades validator performance and network health.

## Likelihood Explanation

**Likelihood: Medium-High**

Prerequisites:
1. An OIDC provider must be registered on-chain (requires governance approval)
2. The provider must be compromised OR a malicious provider must be approved

**Why this is realistic:**
- Legitimate OIDC providers (Google, Facebook, etc.) can be compromised
- Supply chain attacks on OIDC infrastructure are documented threats
- Once registered, a provider can serve arbitrary responses
- No size validation gives attackers complete control over memory allocation
- Attack affects all validators simultaneously

The attack requires no validator access or collusionâ€”only control of an externally registered OIDC provider.

## Recommendation

Implement multi-layered size limits:

**1. HTTP Response Size Limit:**
```rust
// In crates/jwk-utils/src/lib.rs
const MAX_JWK_RESPONSE_SIZE: usize = 1024 * 1024; // 1 MiB

pub async fn fetch_jwks_from_jwks_uri(
    my_addr: Option<AccountAddress>,
    jwks_uri: &str,
) -> Result<Vec<JWK>> {
    let client = reqwest::Client::builder()
        .timeout(Duration::from_secs(10))
        .build()?;
    
    let mut request_builder = client.get(jwks_uri);
    if let Some(addr) = my_addr {
        request_builder = request_builder.header(COOKIE, addr.to_hex());
    }
    
    let response = request_builder.send().await?;
    let content_length = response.content_length().unwrap_or(0);
    
    ensure!(
        content_length <= MAX_JWK_RESPONSE_SIZE as u64,
        "JWK response size {} exceeds maximum {}",
        content_length,
        MAX_JWK_RESPONSE_SIZE
    );
    
    let bytes = response.bytes().await?;
    ensure!(
        bytes.len() <= MAX_JWK_RESPONSE_SIZE,
        "JWK response actual size {} exceeds maximum",
        bytes.len()
    );
    
    let JWKsResponse { keys } = serde_json::from_slice(&bytes)?;
    let jwks = keys.into_iter().map(JWK::from).collect();
    Ok(jwks)
}
```

**2. Individual JWK Payload Size Limit:**
```rust
// In types/src/jwks/unsupported/mod.rs
const MAX_UNSUPPORTED_JWK_PAYLOAD_SIZE: usize = 16 * 1024; // 16 KiB

impl From<serde_json::Value> for UnsupportedJWK {
    fn from(json_value: serde_json::Value) -> Self {
        let payload = json_value.to_string().into_bytes();
        assert!(
            payload.len() <= MAX_UNSUPPORTED_JWK_PAYLOAD_SIZE,
            "Unsupported JWK payload exceeds maximum size"
        );
        Self {
            id: HashValue::sha3_256_of(payload.as_slice()).to_vec(),
            payload,
        }
    }
}
```

**3. Total JWK Count Limit:**
```rust
// In types/src/jwks/mod.rs
const MAX_JWKS_PER_PROVIDER: usize = 100;

impl ProviderJWKs {
    pub fn new(issuer: Issuer) -> Self {
        Self {
            issuer,
            version: 0,
            jwks: vec![],
        }
    }
    
    pub fn validate(&self) -> Result<()> {
        ensure!(
            self.jwks.len() <= MAX_JWKS_PER_PROVIDER,
            "Provider has {} JWKs, exceeds maximum of {}",
            self.jwks.len(),
            MAX_JWKS_PER_PROVIDER
        );
        Ok(())
    }
}
```

## Proof of Concept

```rust
// Mock OIDC server serving malicious large JWK set
use warp::Filter;
use serde_json::json;

#[tokio::test]
async fn test_large_jwk_memory_exhaustion() {
    // Start malicious OIDC server
    let malicious_server = warp::path!(".well-known" / "openid-configuration")
        .map(|| {
            warp::reply::json(&json!({
                "issuer": "https://evil.com",
                "jwks_uri": "https://evil.com/jwks"
            }))
        })
        .or(warp::path("jwks").map(|| {
            // Serve 10,000 large JWKs
            let mut keys = vec![];
            for i in 0..10000 {
                keys.push(json!({
                    "kty": "unsupported",
                    "kid": format!("key_{}", i),
                    "payload": "A".repeat(100_000) // 100 KB per key
                }));
            }
            warp::reply::json(&json!({"keys": keys}))
        }));
    
    tokio::spawn(warp::serve(malicious_server).run(([127, 0, 0, 1], 8080)));
    
    // Validator attempts to fetch JWKs
    let config_url = "http://127.0.0.1:8080/.well-known/openid-configuration";
    
    // This will allocate ~1 GB of memory with no validation
    let result = fetch_jwks(config_url, None).await;
    
    // Without size limits, this succeeds and consumes massive memory
    assert!(result.is_ok());
    
    let jwks = result.unwrap();
    assert_eq!(jwks.len(), 10000);
    
    // Each JWK with 100KB payload = 1 GB total memory allocation
    // Multiple issuers = multiple GBs
    // Memory exhaustion achieved
}
```

**Notes:**

The vulnerability has two attack vectors: (1) compromised OIDC providers serving unbounded responses, and (2) Byzantine validators crafting large local payloads. The OIDC provider attack is more severe as it bypasses network message size limits entirely. The network layer's 64 MiB limit only applies to validator P2P communication, not external HTTP fetches. While deserialization tasks are bounded by CPU count, this doesn't prevent memory exhaustion when multiple large payloads are held simultaneously in `ObservationAggregationState` instances across different issuers.

### Citations

**File:** crates/jwk-utils/src/lib.rs (L25-37)
```rust
pub async fn fetch_jwks_from_jwks_uri(
    my_addr: Option<AccountAddress>,
    jwks_uri: &str,
) -> Result<Vec<JWK>> {
    let client = reqwest::Client::new();
    let mut request_builder = client.get(jwks_uri);
    if let Some(addr) = my_addr {
        request_builder = request_builder.header(COOKIE, addr.to_hex());
    }
    let JWKsResponse { keys } = request_builder.send().await?.json().await?;
    let jwks = keys.into_iter().map(JWK::from).collect();
    Ok(jwks)
}
```

**File:** types/src/jwks/unsupported/mod.rs (L51-59)
```rust
impl From<serde_json::Value> for UnsupportedJWK {
    fn from(json_value: serde_json::Value) -> Self {
        let payload = json_value.to_string().into_bytes(); //TODO: canonical to_string.
        Self {
            id: HashValue::sha3_256_of(payload.as_slice()).to_vec(),
            payload,
        }
    }
}
```

**File:** types/src/jwks/mod.rs (L122-128)
```rust
#[derive(Clone, Default, Eq, PartialEq, Serialize, Deserialize, CryptoHasher, BCSCryptoHash)]
pub struct ProviderJWKs {
    #[serde(with = "serde_bytes")]
    pub issuer: Issuer,
    pub version: u64,
    pub jwks: Vec<JWKMoveStruct>,
}
```

**File:** crates/aptos-jwk-consensus/src/update_certifier.rs (L49-66)
```rust
    fn start_produce(
        &self,
        epoch_state: Arc<EpochState>,
        payload: ProviderJWKs,
        qc_update_tx: aptos_channel::Sender<
            ConsensusMode::ConsensusSessionKey,
            QuorumCertifiedUpdate,
        >,
    ) -> anyhow::Result<AbortHandle> {
        ConsensusMode::log_certify_start(epoch_state.epoch, &payload);
        let rb = self.reliable_broadcast.clone();
        let epoch = epoch_state.epoch;
        let req = ConsensusMode::new_rb_request(epoch, &payload)
            .context("UpdateCertifier::start_produce failed at rb request construction")?;
        let agg_state = Arc::new(ObservationAggregationState::<ConsensusMode>::new(
            epoch_state,
            payload,
        ));
```

**File:** crates/aptos-jwk-consensus/src/observation_aggregation/mod.rs (L24-39)
```rust
pub struct ObservationAggregationState<ConsensusMode> {
    epoch_state: Arc<EpochState>,
    local_view: ProviderJWKs,
    inner_state: Mutex<PartialSignatures>,
    _phantom: PhantomData<ConsensusMode>,
}

impl<ConsensusMode> ObservationAggregationState<ConsensusMode> {
    pub fn new(epoch_state: Arc<EpochState>, local_view: ProviderJWKs) -> Self {
        Self {
            epoch_state,
            local_view,
            inner_state: Mutex::new(PartialSignatures::empty()),
            _phantom: Default::default(),
        }
    }
```
