# Audit Report

## Title
Genesis State Inconsistency During Partial Config Save Failure

## Summary
The `Builder::build()` function in the genesis generation process lacks atomic transaction guarantees when saving validator configurations. If `save_config()` fails for any validator after others have been saved, the system is left in an inconsistent state where some validators have genesis and waypoint data persisted to disk while others do not. This breaks the critical invariant that all validators must start from identical genesis state.

## Finding Description

The vulnerability exists in the genesis generation flow where validator configurations are saved sequentially without rollback capabilities. [1](#0-0) 

The `genesis_ceremony()` function generates a single genesis transaction and waypoint, then inserts them into all validators' in-memory configurations: [2](#0-1) 

The critical flaw occurs in the save loop which uses the `?` operator without any atomicity guarantees. If `save_config()` fails at validator index N (after successfully saving configs for validators 0 through N-1), the function returns early, leaving partial state on disk. [3](#0-2) 

The `save_config()` method performs multiple file I/O operations that can fail: [4](#0-3) 

This includes writing the genesis blob file: [5](#0-4) 

**Failure Scenario:**
1. Genesis ceremony completes, generating genesis transaction and waypoint
2. Both values are inserted into all validators' in-memory configs
3. Save loop begins: validators 0, 1, 2, ...
4. Validator 0: `save_config()` succeeds → genesis.blob and node.yaml written to disk
5. Validator 1: `save_config()` succeeds → genesis.blob and node.yaml written to disk
6. Validator 2: `save_config()` fails due to disk full, permission error, or I/O failure
7. Function returns error via `?` operator
8. Validators 2+ do NOT have configs saved

**Result:** Validators 0-1 have complete genesis/waypoint data on disk, while validators 2+ have none (or stale data from previous runs).

This violates the **State Consistency** and **Deterministic Execution** invariants - all validators must start from identical genesis state to reach consensus.

## Impact Explanation

This qualifies as **High Severity** per Aptos bug bounty criteria:
- **Significant protocol violation**: Validators cannot start with inconsistent genesis state
- **State inconsistencies requiring intervention**: Manual detection and correction needed

The impact includes:
1. **Network Failure to Start**: Validators with different genesis/waypoint cannot sync or reach consensus
2. **Silent Data Corruption**: Partial state may go undetected until validators attempt to start
3. **Operational Risk**: No automatic detection or rollback mechanism exists
4. **Manual Recovery Required**: Operators must identify which validators have stale/missing configs

This breaks critical invariants:
- **Invariant 1 (Deterministic Execution)**: Validators do not have identical starting state
- **Invariant 4 (State Consistency)**: Genesis state is not atomic across all validators

## Likelihood Explanation

**Likelihood: Medium to High**

Common failure conditions that trigger this bug:
1. **Disk Space Exhaustion**: Genesis blob files can be large; running out of disk space during save is realistic
2. **Permission Errors**: Incorrect file system permissions on validator directories
3. **File System Failures**: Network-mounted storage, corrupted file systems, I/O errors
4. **Process Interruption**: System crashes, OOM kills, manual termination during genesis generation
5. **Concurrent Access**: Multiple processes attempting to write to the same directories

This is particularly likely in:
- **Production deployments** with many validators (more opportunities for failure)
- **Cloud environments** with ephemeral storage or quota limits
- **Automated deployment pipelines** where errors may not be immediately detected

## Recommendation

Implement atomic transaction semantics for validator config saves. Use a two-phase commit approach:

**Option 1: Write to Temporary Location First**
```rust
pub fn build<R>(
    mut self,
    mut rng: R,
) -> anyhow::Result<(
    Ed25519PrivateKey,
    Transaction,
    Waypoint,
    Vec<ValidatorNodeConfig>,
)>
where
    R: rand::RngCore + rand::CryptoRng,
{
    // ... existing genesis generation code ...

    // Phase 1: Save all configs to temporary locations
    let temp_dirs: Vec<PathBuf> = validators
        .iter_mut()
        .map(|validator| {
            let temp_dir = validator.dir.with_extension("tmp");
            std::fs::create_dir_all(&temp_dir)?;
            
            // Save to temp location
            let original_dir = validator.dir.clone();
            validator.dir = temp_dir.clone();
            validator.save_config()?;
            validator.dir = original_dir;
            
            Ok(temp_dir)
        })
        .collect::<anyhow::Result<Vec<PathBuf>>>()?;

    // Phase 2: Atomically move temp dirs to final locations (or rollback all on failure)
    for (validator, temp_dir) in validators.iter().zip(temp_dirs.iter()) {
        std::fs::rename(temp_dir, &validator.dir)
            .map_err(|e| {
                // Rollback: remove all temporary directories
                for td in &temp_dirs {
                    let _ = std::fs::remove_dir_all(td);
                }
                e
            })?;
    }

    Ok((root_key, genesis, waypoint, validators))
}
```

**Option 2: Pre-validate Before Saving**
```rust
// Before the save loop, validate all directories are writable
for validator in validators.iter() {
    ensure!(
        validator.dir.exists() || std::fs::create_dir_all(&validator.dir).is_ok(),
        "Cannot create directory for validator {}: {:?}",
        validator.index,
        validator.dir
    );
    
    // Test write permission
    let test_file = validator.dir.join(".write_test");
    std::fs::write(&test_file, b"test")
        .and_then(|_| std::fs::remove_file(&test_file))
        .context("Directory not writable")?;
}

// Save configs with explicit cleanup on failure
let mut saved_validators = Vec::new();
for validator in validators.iter_mut() {
    match validator.save_config() {
        Ok(_) => saved_validators.push(validator.index),
        Err(e) => {
            // Rollback: remove configs for successfully saved validators
            for idx in saved_validators {
                let dir = &validators[idx].dir;
                let _ = std::fs::remove_file(dir.join(CONFIG_FILE));
                let _ = std::fs::remove_file(dir.join(GENESIS_BLOB));
            }
            return Err(e);
        }
    }
}
```

## Proof of Concept

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use aptos_cached_packages::head_release_bundle;
    use std::fs;
    use std::os::unix::fs::PermissionsExt;
    use tempfile::TempDir;

    #[test]
    fn test_partial_save_failure_leaves_inconsistent_state() {
        let temp_dir = TempDir::new().unwrap();
        let base_dir = temp_dir.path();

        // Build genesis with 3 validators
        let builder = Builder::new(base_dir, head_release_bundle().clone())
            .unwrap()
            .with_num_validators(NonZeroUsize::new(3).unwrap());

        // Create validator directories
        for i in 0..3 {
            fs::create_dir_all(base_dir.join(i.to_string())).unwrap();
        }

        // Make validator 2's directory read-only to trigger save failure
        let validator_2_dir = base_dir.join("2");
        let mut perms = fs::metadata(&validator_2_dir).unwrap().permissions();
        perms.set_mode(0o444); // Read-only
        fs::set_permissions(&validator_2_dir, perms).unwrap();

        // Attempt build - should fail at validator 2
        let mut rng = rand::thread_rng();
        let result = builder.build(&mut rng);
        
        assert!(result.is_err(), "Build should fail due to permission error");

        // Verify inconsistent state
        let validator_0_config = base_dir.join("0").join("node.yaml");
        let validator_1_config = base_dir.join("1").join("node.yaml");
        let validator_2_config = base_dir.join("2").join("node.yaml");

        // Validators 0 and 1 have configs saved
        assert!(validator_0_config.exists(), "Validator 0 config should exist");
        assert!(validator_1_config.exists(), "Validator 1 config should exist");
        
        // Validator 2 does not have config saved (due to permission error)
        assert!(!validator_2_config.exists(), "Validator 2 config should NOT exist");

        // This demonstrates the inconsistency:
        // - Validators 0 & 1 have genesis/waypoint on disk
        // - Validator 2 does not
        // - Network cannot start with this inconsistent state
    }
}
```

**Notes:**
- This vulnerability affects the genesis generation process, a critical initialization step for any Aptos network
- The lack of atomicity guarantees means operators may unknowingly deploy validators with inconsistent genesis state
- Detection requires manual inspection of each validator's configuration directory
- The issue is particularly severe in production deployments with many validators where partial failures are more likely
- Current code provides no automatic rollback or cleanup mechanism on failure

### Citations

**File:** crates/aptos-genesis/src/builder.rs (L179-189)
```rust
    fn save_config(&mut self) -> anyhow::Result<()> {
        // Save the execution config to disk along with the full config.
        self.config
            .override_config_mut()
            .save_to_path(self.dir.join(CONFIG_FILE))?;

        // Overwrite the full config with the override config
        self.config
            .save_config(self.dir.join(CONFIG_FILE))
            .map_err(Into::into)
    }
```

**File:** crates/aptos-genesis/src/builder.rs (L544-553)
```rust
        // Build genesis
        let (genesis, waypoint) = self.genesis_ceremony(&mut validators, root_key.public_key())?;

        // Save configs for validators so they can run
        for validator in validators.iter_mut() {
            validator.save_config()?;
        }

        Ok((root_key, genesis, waypoint, validators))
    }
```

**File:** crates/aptos-genesis/src/builder.rs (L687-694)
```rust
        // Insert genesis and waypoint into validators
        // TODO: verify genesis?
        for validator in validators {
            validator.insert_waypoint(&waypoint);
            validator.insert_genesis(genesis);
        }

        Ok((genesis.clone(), waypoint))
```

**File:** config/src/config/node_config.rs (L171-181)
```rust
    pub fn save_to_path<P: AsRef<Path>>(&mut self, output_path: P) -> Result<(), Error> {
        // Save the execution config to disk.
        let output_dir = RootPath::new(&output_path);
        self.execution.save_to_path(&output_dir)?;

        // Write the node config to disk. Note: this must be called last
        // as calling save_to_path() on subconfigs may change fields.
        self.save_config(&output_path)?;

        Ok(())
    }
```

**File:** config/src/config/execution_config.rs (L142-154)
```rust
    pub fn save_to_path(&mut self, root_dir: &RootPath) -> Result<(), Error> {
        if let Some(genesis) = &self.genesis {
            if self.genesis_file_location.as_os_str().is_empty() {
                self.genesis_file_location = PathBuf::from(GENESIS_BLOB_FILENAME);
            }
            let path = root_dir.full_path(&self.genesis_file_location);
            let mut file = File::create(path).map_err(|e| Error::IO("genesis".into(), e))?;
            let data = bcs::to_bytes(&genesis).map_err(|e| Error::BCS("genesis", e))?;
            file.write_all(&data)
                .map_err(|e| Error::IO("genesis".into(), e))?;
        }
        Ok(())
    }
```
