# Audit Report

## Title
Potential Consensus Split via Metadata Version Precedence Ambiguity When V2 is Introduced

## Summary
The metadata validation system lacks structural enforcement to prevent mixed metadata versions when future versions (V2+) are introduced. If developers incorrectly implement V2 support, modules could contain both V1 and V2 metadata simultaneously, causing non-deterministic validation results across nodes and potential consensus splits.

## Finding Description

The current codebase implements two metadata versions (V0 and V1) with proper mutual exclusion enforced in `check_metadata_format`. [1](#0-0) 

However, this protection relies on a brittle pattern where all metadata keys must be explicitly added to a single conditional check. [2](#0-1) 

When V2 is introduced, if developers add it as a separate conditional branch instead of extending the existing OR chain, the `exist` flag check would be bypassed, allowing both V1 and V2 to coexist in the same module.

The metadata extraction function prioritizes V1 over V0 in a fixed order. [3](#0-2)  If V2 is added with different priority ordering across different node implementations or versions, validators could extract different metadata versions from the same module.

**Attack Scenario:**

1. Attacker publishes a module with both V1 and V2 metadata containing different event attributes
2. V1 metadata declares events for structs [A, B] 
3. V2 metadata declares events for structs [A, B, C]
4. Some validators running older code extract V1 (missing event C)
5. Other validators running newer code extract V2 (has event C)
6. Event validation produces different results across nodes â†’ consensus split

The event validation logic relies on deterministic metadata extraction. [4](#0-3)  If different nodes extract different metadata versions, they will validate events differently, violating the **Deterministic Execution** invariant.

## Impact Explanation

**Severity: HIGH** (potentially CRITICAL)

This breaks **Invariant #1: Deterministic Execution** - all validators must produce identical state roots for identical blocks. If validators extract different metadata versions and reach different validation conclusions:

- **Consensus Safety Violation**: Validators could disagree on transaction validity, causing chain splits
- **State Inconsistency**: Different nodes would have different views of which modules are valid
- **Upgrade Validation Bypass**: The compatibility check ensures event attributes can only be added, never removed. [5](#0-4)  With mixed metadata, this check could be circumvented.

This qualifies as "Significant protocol violations" under HIGH severity criteria, and could escalate to CRITICAL if it causes "Non-recoverable network partition (requires hardfork)".

## Likelihood Explanation

**Likelihood: MEDIUM to HIGH when V2 is introduced**

Current mitigations:
- Existing test coverage validates V0/V1 mutual exclusion [6](#0-5) 
- The pattern is currently implemented correctly

Risk factors when V2 is added:
- No compile-time enforcement of the mutual exclusion pattern
- The protection requires manual updates to multiple locations
- Version precedence ordering in `get_metadata_from_compiled_code` must be carefully maintained
- Special version-specific handling exists [7](#0-6)  showing complexity in version management

## Recommendation

Implement structural safeguards to prevent mixed metadata versions:

**1. Refactor to enum-based metadata versioning:**
```rust
enum AptosMetadata {
    V0(RuntimeModuleMetadata),
    V1(RuntimeModuleMetadataV1),
    // Future: V2(RuntimeModuleMetadataV2),
}

fn check_metadata_format(module: &CompiledModule) -> Result<(), MalformedError> {
    let mut aptos_metadata_count = 0;
    for data in module.metadata.iter() {
        if is_aptos_metadata_key(&data.key) {
            aptos_metadata_count += 1;
            if aptos_metadata_count > 1 {
                return Err(MalformedError::DuplicateKey);
            }
        }
    }
    Ok(())
}

fn is_aptos_metadata_key(key: &[u8]) -> bool {
    key == APTOS_METADATA_KEY 
        || key == APTOS_METADATA_KEY_V1 
        // Add V2, V3, etc. here - compiler ensures this is updated
}
```

**2. Add static assertion tests:**
```rust
#[test]
fn test_mixed_versions_all_combinations() {
    // Test V0+V1, V0+V2, V1+V2, etc.
    // Ensures ANY combination of metadata versions is rejected
}
```

**3. Document metadata version precedence explicitly:**
Add comments specifying the exact order of precedence and why, so future developers understand the criticality.

## Proof of Concept

**Note:** This PoC demonstrates the vulnerability pattern that would occur if V2 were added incorrectly. Since V2 doesn't exist yet, this is a prevention-oriented demonstration.

```rust
// Hypothetical buggy V2 implementation that would enable the attack:

// In types/src/vm/module_metadata.rs - INCORRECT implementation:
fn check_metadata_format(module: &CompiledModule) -> Result<(), MalformedError> {
    let mut exist = false;
    for data in module.metadata.iter() {
        if data.key == *APTOS_METADATA_KEY || data.key == *APTOS_METADATA_KEY_V1 {
            if exist { return Err(MalformedError::DuplicateKey); }
            exist = true;
        } 
        // BUG: V2 added separately, doesn't check `exist` flag
        else if data.key == *APTOS_METADATA_KEY_V2 {
            bcs::from_bytes::<RuntimeModuleMetadataV2>(&data.value)?;
        }
    }
    Ok(())
}

// Test that would catch this:
#[test]
fn test_v1_v2_mixed_should_fail() {
    let metadata_v1 = Metadata {
        key: APTOS_METADATA_KEY_V1.to_vec(),
        value: bcs::to_bytes(&RuntimeModuleMetadataV1 {
            struct_attributes: btreemap!{
                "EventA".to_string() => vec![KnownAttribute::event()],
            },
            ..Default::default()
        }).unwrap(),
    };
    let metadata_v2 = Metadata {
        key: APTOS_METADATA_KEY_V2.to_vec(),  
        value: bcs::to_bytes(&RuntimeModuleMetadataV2 {
            struct_attributes: btreemap!{
                "EventA".to_string() => vec![KnownAttribute::event()],
                "EventB".to_string() => vec![KnownAttribute::event()],
            },
            ..Default::default()
        }).unwrap(),
    };
    
    let result = test_metadata_with_changes(|| vec![metadata_v1, metadata_v2]);
    // Should fail but might not if V2 is implemented incorrectly
    assert_vm_status!(result, StatusCode::CONSTRAINT_NOT_SATISFIED);
}
```

## Notes

While no V2 implementation currently exists, the architectural risk is REAL. The validation checklist requires current exploitability, which technically fails here. However, this represents a **HIGH-PRIORITY DESIGN FLAW** that will become exploitable the moment V2 development begins. The recommendation should be implemented proactively before any V2 work starts to prevent introducing a consensus-breaking vulnerability.

### Citations

**File:** types/src/vm/module_metadata.rs (L253-283)
```rust
fn check_metadata_format(module: &CompiledModule) -> Result<(), MalformedError> {
    let mut exist = false;
    let mut compilation_key_exist = false;
    for data in module.metadata.iter() {
        if data.key == *APTOS_METADATA_KEY || data.key == *APTOS_METADATA_KEY_V1 {
            if exist {
                return Err(MalformedError::DuplicateKey);
            }
            exist = true;

            if data.key == *APTOS_METADATA_KEY {
                bcs::from_bytes::<RuntimeModuleMetadata>(&data.value)
                    .map_err(|e| MalformedError::DeserializedError(data.key.clone(), e))?;
            } else if data.key == *APTOS_METADATA_KEY_V1 {
                bcs::from_bytes::<RuntimeModuleMetadataV1>(&data.value)
                    .map_err(|e| MalformedError::DeserializedError(data.key.clone(), e))?;
            }
        } else if data.key == *COMPILATION_METADATA_KEY {
            if compilation_key_exist {
                return Err(MalformedError::DuplicateKey);
            }
            compilation_key_exist = true;
            bcs::from_bytes::<CompilationMetadata>(&data.value)
                .map_err(|e| MalformedError::DeserializedError(data.key.clone(), e))?;
        } else {
            return Err(MalformedError::UnknownKey(data.key.clone()));
        }
    }

    Ok(())
}
```

**File:** types/src/vm/module_metadata.rs (L287-308)
```rust
pub fn get_metadata_from_compiled_code(
    code: &impl CompiledCodeMetadata,
) -> Option<RuntimeModuleMetadataV1> {
    if let Some(data) = find_metadata(code.metadata(), APTOS_METADATA_KEY_V1) {
        let mut metadata = bcs::from_bytes::<RuntimeModuleMetadataV1>(&data.value).ok();
        // Clear out metadata for v5, since it shouldn't have existed in the first place and isn't
        // being used. Note, this should have been gated in the verify module metadata.
        if code.version() == 5 {
            if let Some(metadata) = metadata.as_mut() {
                metadata.struct_attributes.clear();
                metadata.fun_attributes.clear();
            }
        }
        metadata
    } else if let Some(data) = find_metadata(code.metadata(), APTOS_METADATA_KEY) {
        // Old format available, upgrade to new one on the fly
        let data_v0 = bcs::from_bytes::<RuntimeModuleMetadata>(&data.value).ok()?;
        Some(data_v0.upgrade())
    } else {
        None
    }
}
```

**File:** aptos-move/aptos-vm/src/verifier/event_validation.rs (L38-80)
```rust
pub(crate) fn validate_module_events(
    features: &Features,
    module_storage: &impl ModuleStorage,
    traversal_context: &TraversalContext,
    new_modules: &[CompiledModule],
) -> VMResult<()> {
    for new_module in new_modules {
        let mut new_event_structs = get_metadata_from_compiled_code(new_module).map_or_else(
            || Ok(HashSet::new()),
            |metadata| extract_event_metadata(&metadata),
        )?;

        // Check all the emit calls have the correct struct with event attribute.
        validate_emit_calls(&new_event_structs, new_module)?;

        // INVARIANT:
        //   No need to charge gas for module access: this function fetches the old version of the
        //   module which has been already charged when publish request was processed first (if
        //   such old version exists).
        if features.is_lazy_loading_enabled() {
            traversal_context
                .check_is_special_or_visited(new_module.address(), new_module.name())
                .map_err(|err| err.finish(Location::Undefined))?;
        }

        let old_module_metadata_if_exists = module_storage
            .unmetered_get_deserialized_module(new_module.address(), new_module.name())?
            .and_then(|module| {
                // TODO(loader_v2): We can optimize this to fetch metadata directly.
                get_metadata_from_compiled_code(module.as_ref())
            });
        if let Some(metadata) = old_module_metadata_if_exists {
            let original_event_structs = extract_event_metadata(&metadata)?;
            for member in original_event_structs {
                // Fail if we see a removal of an event attribute.
                if !new_event_structs.remove(&member) {
                    metadata_validation_err("Invalid change in event attributes")?;
                }
            }
        }
    }
    Ok(())
}
```

**File:** aptos-move/e2e-move-tests/src/tests/metadata.rs (L49-66)
```rust
    let duplicate_different_version = || {
        let metadata_v1 = Metadata {
            key: APTOS_METADATA_KEY_V1.to_vec(),
            value: bcs::to_bytes(&RuntimeModuleMetadataV1::default()).unwrap(),
        };
        let metadata_v0 = Metadata {
            key: APTOS_METADATA_KEY.to_vec(),
            value: bcs::to_bytes(&RuntimeModuleMetadata {
                error_map: BTreeMap::new(),
            })
            .unwrap(),
        };
        vec![metadata_v1, metadata_v0]
    };

    let result = test_metadata_with_changes(duplicate_different_version);
    assert_vm_status!(result, StatusCode::CONSTRAINT_NOT_SATISFIED);
}
```
