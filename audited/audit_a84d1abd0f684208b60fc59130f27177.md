# Audit Report

## Title
Incomplete `verify_only` Filtering Allows Verification-Only Enum Variants in Production Bytecode

## Summary

The `verify_only` attribute filter does not recursively process enum variant attributes, allowing variants marked with `#[verify_only]` to bypass filtering and be included in production bytecode. This breaks the intended semantics of verification-only code separation and could enable unintended behavior in deployed modules.

## Finding Description

The Move compiler supports the `#[verify_only]` attribute to mark code elements that should only be included during formal verification, not in production compilation. According to the attribute position definitions, `verify_only` is allowed on modules, functions, structs, and other positions. [1](#0-0) 

However, enum variants (a Move v2 feature) can also have attributes [2](#0-1) , and during the expansion phase, variant attributes are validated using `AttributePosition::Struct` rather than a variant-specific position [3](#0-2) . Since `verify_only` is allowed on `AttributePosition::Struct`, it passes validation when placed on variants.

The critical flaw is in the filtering logic. The `filter_map_struct` function only checks the struct's own attributes, not the attributes of variants contained within [4](#0-3) . This means when a struct definition is retained (because the struct itself doesn't have `#[verify_only]`), all its variants are retained regardless of their individual attributes.

The filtering mechanism is invoked once during compilation [5](#0-4) , and there is no subsequent check for variant-level attributes.

## Impact Explanation

This vulnerability falls under **Medium Severity** as it can lead to state inconsistencies requiring intervention:

1. **Broken Semantic Guarantees**: Developers expect `#[verify_only]` to work consistently across all allowed positions. When it silently fails on variants, verification-only code becomes part of production deployments.

2. **Unintended Code Paths**: Verification-only variants may be designed with relaxed security properties for proof purposes. Their presence in production enables attackers to construct values using these variants, potentially bypassing intended access controls or invariants.

3. **Module Behavior Divergence**: The module behaves differently than intended, as verification-only states become accessible in production. This breaks the **State Consistency** invariant where state transitions should match developer-specified semantics.

4. **Potential Access Control Bypass**: If verification variants are used to test edge cases or provide privileged access for proofs, their availability in production could enable unauthorized operations.

## Likelihood Explanation

**Likelihood: Medium**

- **Preconditions**: Requires a module using Move v2 enum variants (increasingly common) where a developer marks a variant with `#[verify_only]`
- **Developer Intent**: Developers familiar with `#[verify_only]` on functions/structs may naturally assume it works on variants
- **Silent Failure**: The attribute passes validation without warnings, so developers have no indication of the filtering failure
- **Exploitation**: Once such code exists, exploitation is trivialâ€”the vulnerable variant is automatically available in all deployed modules

The likelihood increases as enum variant usage grows in the Aptos ecosystem.

## Recommendation

Extend the filtering logic to recursively process variant attributes within struct definitions. Modify `filter_map_struct` in `parser/filter.rs`:

```rust
fn filter_map_struct(
    &mut self,
    struct_def: P::StructDefinition,
    is_source_def: bool,
    filtered_members: &mut BTreeSet<Symbol>,
) -> Option<P::StructDefinition> {
    if self.should_remove_by_attributes(&struct_def.attributes, is_source_def) {
        filtered_members.insert(struct_def.name.0.value);
        None
    } else {
        // Filter variants recursively
        let layout = match struct_def.layout {
            P::StructLayout::Variants(variants) => {
                let filtered_variants: Vec<_> = variants
                    .into_iter()
                    .filter(|v| !self.should_remove_by_attributes(&v.attributes, is_source_def))
                    .collect();
                P::StructLayout::Variants(filtered_variants)
            }
            other => other,
        };
        
        Some(P::StructDefinition {
            layout,
            ..struct_def
        })
    }
}
```

Additionally, consider introducing `AttributePosition::Variant` to make variant attribute validation explicit.

## Proof of Concept

Create a Move module demonstrating the issue:

```move
module 0x1::vulnerable_enum {
    enum MyEnum {
        ProductionVariant { value: u64 },
        
        #[verify_only]
        VerificationOnlyVariant { debug_info: vector<u8> },
    }
    
    public fun use_verify_variant(data: vector<u8>): MyEnum {
        // This should not be possible in production builds
        // but will work due to the filtering bug
        MyEnum::VerificationOnlyVariant { debug_info: data }
    }
}
```

**Compilation Test**:
1. Compile this module WITHOUT the `--verify` flag (production mode)
2. Expected behavior: Compilation should fail or variant should be absent
3. Actual behavior: Module compiles successfully with `VerificationOnlyVariant` present in bytecode
4. The variant can be constructed and used in production, breaking the `verify_only` guarantee

**Verification**: Inspect the generated bytecode using the Move disassembler to confirm `VerificationOnlyVariant` is present in the struct definition despite being marked `#[verify_only]`.

### Citations

**File:** third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/mod.rs (L872-886)
```rust
            static VERIFY_ONLY_POSITIONS: Lazy<BTreeSet<AttributePosition>> = Lazy::new(|| {
                IntoIterator::into_iter([
                    AttributePosition::AddressBlock,
                    AttributePosition::Module,
                    AttributePosition::Use,
                    AttributePosition::Friend,
                    AttributePosition::Constant,
                    AttributePosition::Struct,
                    AttributePosition::Function,
                ])
                .collect()
            });
            match self {
                Self::VerifyOnly => &VERIFY_ONLY_POSITIONS,
            }
```

**File:** third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/ast.rs (L233-239)
```rust
pub struct StructVariant {
    pub attributes: Vec<Attributes>,
    pub loc: Loc,
    pub name: VariantName,
    pub fields: Vec<(Field, Type)>,
    pub is_positional: bool,
}
```

**File:** third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/translate.rs (L1495-1500)
```rust
                        E::StructVariant {
                            attributes: flatten_attributes(
                                context,
                                AttributePosition::Struct,
                                v.attributes,
                            ),
```

**File:** third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/filter.rs (L74-86)
```rust
    fn filter_map_struct(
        &mut self,
        struct_def: P::StructDefinition,
        is_source_def: bool,
        filtered_members: &mut BTreeSet<Symbol>,
    ) -> Option<P::StructDefinition> {
        if self.should_remove_by_attributes(&struct_def.attributes, is_source_def) {
            filtered_members.insert(struct_def.name.0.value);
            None
        } else {
            Some(struct_def)
        }
    }
```

**File:** third_party/move/move-compiler-v2/legacy-move-compiler/src/command_line/compiler.rs (L583-583)
```rust
            let prog = verification::ast_filter::program(compilation_env, prog);
```
