# Audit Report

## Title
Silent Error Masking in Gas Feature Version Retrieval Causes Potential State Divergence Under Storage Corruption

## Summary
The `get_gas_feature_version()` function and the OnChainConfig infrastructure silently mask storage read errors and deserialization failures, treating them identically to "configuration doesn't exist" scenarios. This allows validators experiencing transient storage failures to execute blocks with incorrect gas parameters (version 0 fallback) while healthy validators use correct parameters, violating the deterministic execution invariant and potentially causing consensus-breaking state divergence.

## Finding Description

The vulnerability exists in multiple layers of the configuration retrieval system:

**Layer 1: ConfigStorage Implementation** [1](#0-0) 

The `.ok()?` operator converts all `StateViewError` types (including `Other` errors representing disk corruption, I/O failures, or database errors) into `None`, treating critical storage failures identically to legitimate absence of configuration data.

**Layer 2: OnChainConfig::fetch_config_and_bytes** [2](#0-1) 

Both deserialization failures (`.ok()?` on line 191) and storage read failures are converted to `None`, with no distinction between "data is absent" vs "data is corrupted/unreadable".

**Layer 3: get_gas_feature_version** [3](#0-2) 

The `unwrap_or(0)` blindly returns version 0 when `GasScheduleV2::fetch_config` returns `None`, regardless of the underlying cause (legitimate absence vs critical error).

**Layer 4: get_gas_config_from_storage fallback** [4](#0-3) 

The fallback from `GasScheduleV2` to `GasSchedule` (v1) silently occurs on any failure, updating the SHA3 hash with different bytes depending on which schedule was successfully read.

**Exploitation Path:**

1. Validator A and Validator B are executing block N with parent state root R
2. State root R contains valid `GasScheduleV2` with `feature_version = 12`
3. Validator A experiences transient disk corruption or I/O error reading the `GasScheduleV2` state key
4. Validator A's storage layer returns `Err(StateViewError::Other("I/O error"))` 
5. The error is masked to `None` by `.ok()?`, triggering fallback to `GasSchedule` v1
6. Validator A executes with `gas_feature_version = 0`
7. Validator B successfully reads `GasScheduleV2`, executes with `gas_feature_version = 12`
8. **Different gas parameters lead to different execution results:**
   - Different gas costs for identical operations
   - Version-specific gas behavior (see version switches at lines 69-93 in gas.rs)
   - Potentially different transaction success/failure outcomes if gas runs out at different points
9. Validators compute different state roots for block N
10. **Consensus breaks** - validators cannot agree on block validity

**Environment Hash Divergence:** [5](#0-4) [6](#0-5) 

The SHA3 hash computed during environment initialization includes the gas schedule bytes. Different validators reading different schedules (due to masked errors) will compute different environment hashes, yet both proceed with execution rather than detecting the inconsistency.

## Impact Explanation

**Critical Severity** - This vulnerability breaks the fundamental "Deterministic Execution" invariant of blockchain consensus. All validators must produce identical state roots for identical blocks to maintain consensus safety.

The impact includes:
- **Consensus Failure**: Validators computing different state roots cannot reach agreement on block validity
- **Network Partition**: Subsets of validators may fork onto different chains depending on which gas version they used
- **Requires Manual Intervention**: Recovery requires identifying affected validators, forcing state sync, and potentially rolling back blocks
- **Silent Failure**: The error masking means validators don't detect they're using incorrect parameters until consensus already fails

Per the Aptos bug bounty program, this qualifies as **Critical** because it causes "Consensus/Safety violations" and could lead to "Non-recoverable network partition (requires hardfork)" if enough validators are affected.

## Likelihood Explanation

**Medium-High Likelihood** in production environments:

1. **Storage failures occur in practice**: Enterprise SSDs have annual failure rates of 0.5-2%, validators running on cloud infrastructure experience transient I/O errors, database corruption can occur during crashes

2. **No error detection**: Current code provides no monitoring or alerting when fallback occurs silently

3. **No self-healing**: Once a validator falls back to version 0 due to a transient error, it continues with wrong parameters even if storage recovers

4. **Scale amplification**: With 100+ validators, probability of at least one experiencing storage issues during any given block is significant

However, likelihood is reduced by:
- Requires storage-level failure coinciding with block execution
- Modern storage systems have redundancy
- State sync mechanisms may help validators recover consistent state

## Recommendation

**Fix 1: Distinguish error types explicitly**

Replace the silent conversion in `ConfigStorage::fetch_config_bytes`: [1](#0-0) 

```rust
impl<S: StateView> ConfigStorage for S {
    fn fetch_config_bytes(&self, state_key: &StateKey) -> Option<Bytes> {
        match self.get_state_value(state_key) {
            Ok(Some(state_value)) => Some(state_value.bytes().clone()),
            Ok(None) => None,  // Legitimate absence
            Err(err) => {
                // Critical: storage read failure must halt execution
                panic!("Critical storage error reading config at {:?}: {}", state_key, err);
            }
        }
    }
}
```

**Fix 2: Fail loudly on deserialization errors** [2](#0-1) 

```rust
fn fetch_config_and_bytes<T>(storage: &T) -> Option<(Self, Bytes)>
where
    T: ConfigStorage + ?Sized,
{
    let state_key = StateKey::on_chain_config::<Self>().ok()?;
    let bytes = storage.fetch_config_bytes(&state_key)?;
    let config = Self::deserialize_into_config(&bytes)
        .expect("Critical: On-chain config deserialization failed - potential state corruption");
    Some((config, bytes))
}
```

**Fix 3: Add explicit version checking**

Modify `get_gas_config_from_storage` to verify the fallback is legitimate:

```rust
fn get_gas_config_from_storage(
    sha3_256: &mut Sha3_256,
    state_view: &impl StateView,
) -> (Result<AptosGasParameters, String>, u64) {
    // First check if v2 state key exists without deserializing
    let v2_key = StateKey::on_chain_config::<GasScheduleV2>().unwrap();
    let v2_exists = state_view.contains_state_value(&v2_key)
        .expect("Critical: cannot check GasScheduleV2 existence");
    
    match GasScheduleV2::fetch_config_and_bytes(state_view) {
        Some((gas_schedule, bytes)) => {
            // Success path unchanged
        },
        None if v2_exists => {
            // CRITICAL: v2 key exists but deserialization failed
            panic!("Critical: GasScheduleV2 exists but cannot be read - storage corruption");
        },
        None => {
            // Legitimate fallback to v1 when v2 doesn't exist
            // ... existing v1 fallback code ...
        }
    }
}
```

## Proof of Concept

While a full end-to-end PoC requires simulating storage layer failures, the vulnerability can be demonstrated with a unit test showing the silent error masking:

```rust
#[test]
#[should_panic(expected = "storage error")]
fn test_storage_error_not_masked() {
    use aptos_types::state_store::{StateView, StateViewId, TStateView};
    use aptos_types::state_store::state_key::StateKey;
    use aptos_types::state_store::errors::StateViewError;
    
    // Mock StateView that returns errors
    struct ErrorStateView;
    impl TStateView for ErrorStateView {
        type Key = StateKey;
        fn id(&self) -> StateViewId { StateViewId::Miscellaneous }
        
        fn get_state_value(&self, _key: &StateKey) 
            -> Result<Option<aptos_types::state_store::state_value::StateValue>, StateViewError> 
        {
            // Simulate storage corruption
            Err(StateViewError::Other("disk I/O error".to_string()))
        }
    }
    
    impl StateView for ErrorStateView {}
    
    let state_view = ErrorStateView;
    
    // This should panic but currently returns 0 silently
    let version = get_gas_feature_version(&state_view);
    
    // If we reach here, the error was masked (current buggy behavior)
    assert_eq!(version, 0);  // This passes, proving the bug
}
```

**Notes**

While this vulnerability requires storage-level failures (not directly attacker-controlled), it represents a **critical gap in defensive programming** that can cause consensus failures in production. Modern distributed systems must handle storage failures gracefully without breaking safety guarantees. The silent error masking transforms transient operational issues into consensus-breaking state divergence, which is precisely what this code must never do.

The fix is straightforward and should be applied to all OnChainConfig reads to ensure validators halt execution when they cannot reliably read configuration data, rather than proceeding with potentially incorrect parameters that break deterministic execution guarantees.

### Citations

**File:** types/src/on_chain_config/mod.rs (L185-193)
```rust
    fn fetch_config_and_bytes<T>(storage: &T) -> Option<(Self, Bytes)>
    where
        T: ConfigStorage + ?Sized,
    {
        let state_key = StateKey::on_chain_config::<Self>().ok()?;
        let bytes = storage.fetch_config_bytes(&state_key)?;
        let config = Self::deserialize_into_config(&bytes).ok()?;
        Some((config, bytes))
    }
```

**File:** types/src/on_chain_config/mod.rs (L204-210)
```rust
impl<S: StateView> ConfigStorage for S {
    fn fetch_config_bytes(&self, state_key: &StateKey) -> Option<Bytes> {
        self.get_state_value(state_key)
            .ok()?
            .map(|s| s.bytes().clone())
    }
}
```

**File:** aptos-move/aptos-vm-environment/src/gas.rs (L15-19)
```rust
pub fn get_gas_feature_version(state_view: &impl StateView) -> u64 {
    GasScheduleV2::fetch_config(state_view)
        .map(|gas_schedule| gas_schedule.feature_version)
        .unwrap_or(0)
}
```

**File:** aptos-move/aptos-vm-environment/src/gas.rs (L27-45)
```rust
    match GasScheduleV2::fetch_config_and_bytes(state_view) {
        Some((gas_schedule, bytes)) => {
            sha3_256.update(&bytes);
            let feature_version = gas_schedule.feature_version;
            let map = gas_schedule.into_btree_map();
            (
                AptosGasParameters::from_on_chain_gas_schedule(&map, feature_version),
                feature_version,
            )
        },
        None => match GasSchedule::fetch_config_and_bytes(state_view) {
            Some((gas_schedule, bytes)) => {
                sha3_256.update(&bytes);
                let map = gas_schedule.into_btree_map();
                (AptosGasParameters::from_on_chain_gas_schedule(&map, 0), 0)
            },
            None => (Err("Neither gas schedule v2 nor v1 exists.".to_string()), 0),
        },
    }
```

**File:** aptos-move/aptos-vm-environment/src/environment.rs (L246-247)
```rust
        let (gas_params, storage_gas_params, gas_feature_version) =
            get_gas_parameters(&mut sha3_256, &features, state_view);
```

**File:** aptos-move/aptos-vm-environment/src/environment.rs (L300-300)
```rust
        let hash = sha3_256.finalize().into();
```
