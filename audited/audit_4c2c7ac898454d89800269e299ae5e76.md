# Audit Report

## Title
Configuration-Dependent Storage Usage Non-Determinism Leading to Consensus Failure

## Summary
The `get_state_storage_usage()` function exhibits configuration-dependent behavior based on the `skip_usage` flag, which is derived from `enable_storage_sharding`. When VersionData is missing from the database, validators with different configurations return different values (error vs. Untracked), causing consensus-critical gas calculation divergence during epoch transitions.

## Finding Description

The vulnerability stems from a determinism violation in storage usage retrieval that manifests during epoch boundaries when storage usage data is queried for gas price recalculation.

**Root Cause:** The `skip_usage` flag creates configuration-dependent behavior in `StateDb::get_state_storage_usage()`: [1](#0-0) 

When `skip_usage=true` (enabled with storage sharding) and VersionData is missing, the function returns `StateStorageUsage::Untracked` which yields (0, 0) for items and bytes. When `skip_usage=false`, it returns an error.

**Configuration Source:** The flag is set based on `enable_storage_sharding`: [2](#0-1) 

**Consensus Impact Chain:**

1. During epoch transitions, `state_storage::on_new_block()` queries storage usage via native function: [3](#0-2) 

2. The native function calls the resolver's `get_usage()`: [4](#0-3) 

3. This ultimately reaches `DbStateView::get_usage()` which delegates to `get_state_storage_usage()`: [5](#0-4) 

4. The returned usage values are used to calculate gas prices in `storage_gas::on_reconfig()`: [6](#0-5) 

**Divergence Scenario:** If Validator A (skip_usage=false) and Validator B (skip_usage=true) encounter missing VersionData:
- Validator A: errors or returns actual cached values
- Validator B: returns (0, 0) via Untracked
- Different gas prices calculated → different transaction execution → different state roots → **consensus failure**

## Impact Explanation

This is a **Critical Severity** vulnerability under Aptos bug bounty criteria as it causes:

1. **Consensus/Safety Violation**: Validators with different configurations produce different state roots for identical blocks due to divergent gas price calculations
2. **Non-Recoverable Network Partition**: Once divergence occurs at epoch boundary, all subsequent blocks will have different state roots, requiring emergency intervention or hardfork

The vulnerability violates the **Deterministic Execution** invariant: "All validators must produce identical state roots for identical blocks."

## Likelihood Explanation

**Likelihood: Low to Medium**

The vulnerability requires two conditions:
1. **Configuration Heterogeneity** (Plausible): Different validator operators may choose different `enable_storage_sharding` settings based on hardware capabilities, leading to different `skip_usage` values
2. **Missing VersionData** (Rare but possible): Could occur during:
   - State sync edge cases or interruptions
   - Database recovery after crashes
   - Bugs in the storage commit path
   - Database pruning edge cases

While missing data shouldn't occur in normal operation per the design, the defensive `skip_usage` flag's existence suggests the developers anticipated scenarios where data might be unavailable. The configuration heterogeneity is the more likely component - validator operators independently configure their nodes.

## Recommendation

**Remove configuration-dependent behavior from consensus-critical code paths:**

1. **Immediate Fix**: Make `skip_usage` behavior uniform across all validators by removing configuration dependency or enforcing it never affects consensus-critical reads:

```rust
fn get_state_storage_usage(&self, version: Option<Version>) -> Result<StateStorageUsage> {
    version.map_or(Ok(StateStorageUsage::zero()), |version| {
        // Always error on missing data for consensus-critical paths
        // Remove skip_usage check entirely
        Ok(self.ledger_db.metadata_db().get_usage(version)?)
    })
}
```

2. **Long-term Fix**: Separate operational recovery flags from consensus-affecting behavior. If `skip_usage` is needed for recovery operations, ensure it never affects values returned during transaction execution.

3. **Validation**: Add startup checks that verify all validators in the network have compatible configurations for consensus-critical parameters.

## Proof of Concept

```rust
// Pseudo-code demonstrating the divergence

// Setup: Two validators with different configurations
let validator_a = AptosDB::open_with_config(/* enable_storage_sharding: false */);
let validator_b = AptosDB::open_with_config(/* enable_storage_sharding: true */);

// Simulate missing VersionData for epoch boundary version
// (could happen during state sync interruption or crash recovery)
let epoch_boundary_version = 1000000;

// Both validators execute epoch transition transaction
// Native function get_state_storage_usage_only_at_epoch_beginning() is called

// Validator A with skip_usage=false
let usage_a = validator_a.get_usage(epoch_boundary_version);
// Returns: Error("VersionData at 1000000 is missing") or cached value

// Validator B with skip_usage=true  
let usage_b = validator_b.get_usage(epoch_boundary_version);
// Returns: StateStorageUsage::Untracked → (items: 0, bytes: 0)

// Divergence in storage_gas::on_reconfig()
// Validator A calculates gas prices based on actual/cached usage
// Validator B calculates gas prices based on (0, 0)

// Result: Different StorageGas resource states
// → Different gas charges for subsequent transactions
// → Different transaction execution results
// → Different state roots → CONSENSUS FAILURE
```

## Notes

This vulnerability highlights a critical design principle violation: **configuration parameters must not affect deterministic execution**. The `skip_usage` flag was likely introduced for operational flexibility (recovery, debugging), but placing it in a code path that affects consensus-critical values creates a hidden non-determinism source. While the triggering condition (missing VersionData) is rare, the mere existence of configuration-dependent behavior in the execution path represents a systemic design flaw that could be exploited if the missing data condition occurs through bugs, state sync issues, or database corruption scenarios.

### Citations

**File:** storage/aptosdb/src/state_store/mod.rs (L238-248)
```rust
    fn get_state_storage_usage(&self, version: Option<Version>) -> Result<StateStorageUsage> {
        version.map_or(Ok(StateStorageUsage::zero()), |version| {
            Ok(match self.ledger_db.metadata_db().get_usage(version) {
                Ok(data) => data,
                _ => {
                    ensure!(self.skip_usage, "VersionData at {version} is missing.");
                    StateStorageUsage::new_untracked()
                },
            })
        })
    }
```

**File:** storage/aptosdb/src/db/aptosdb_internal.rs (L157-157)
```rust
            rocksdb_configs.enable_storage_sharding,
```

**File:** aptos-move/framework/aptos-framework/sources/state_storage.move (L39-49)
```text
    public(friend) fun on_new_block(epoch: u64) acquires StateStorageUsage {
        assert!(
            exists<StateStorageUsage>(@aptos_framework),
            error::not_found(ESTATE_STORAGE_USAGE)
        );
        let usage = borrow_global_mut<StateStorageUsage>(@aptos_framework);
        if (epoch != usage.epoch) {
            usage.epoch = epoch;
            usage.usage = get_state_storage_usage_only_at_epoch_beginning();
        }
    }
```

**File:** aptos-move/framework/src/natives/state_storage.rs (L59-79)
```rust
fn native_get_usage(
    context: &mut SafeNativeContext,
    _ty_args: &[Type],
    _args: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    assert!(_ty_args.is_empty());
    assert!(_args.is_empty());

    context.charge(STATE_STORAGE_GET_USAGE_BASE_COST)?;

    let ctx = context.extensions().get::<NativeStateStorageContext>();
    let usage = ctx.resolver.get_usage().map_err(|err| {
        PartialVMError::new(StatusCode::VM_EXTENSION_ERROR)
            .with_message(format!("Failed to get state storage usage: {}", err))
    })?;

    Ok(smallvec![Value::struct_(Struct::pack(vec![
        Value::u64(usage.items() as u64),
        Value::u64(usage.bytes() as u64),
    ]))])
}
```

**File:** storage/storage-interface/src/state_store/state_view/db_state_view.rs (L66-70)
```rust
    fn get_usage(&self) -> StateViewResult<StateStorageUsage> {
        self.db
            .get_state_storage_usage(self.version)
            .map_err(Into::into)
    }
```

**File:** aptos-move/framework/aptos-framework/sources/storage_gas.move (L524-532)
```text
        let (items, bytes) = state_storage::current_items_and_bytes();
        let gas_config = borrow_global<StorageGasConfig>(@aptos_framework);
        let gas = borrow_global_mut<StorageGas>(@aptos_framework);
        gas.per_item_read = calculate_read_gas(&gas_config.item_config, items);
        gas.per_item_create = calculate_create_gas(&gas_config.item_config, items);
        gas.per_item_write = calculate_write_gas(&gas_config.item_config, items);
        gas.per_byte_read = calculate_read_gas(&gas_config.byte_config, bytes);
        gas.per_byte_create = calculate_create_gas(&gas_config.byte_config, bytes);
        gas.per_byte_write = calculate_write_gas(&gas_config.byte_config, bytes);
```
