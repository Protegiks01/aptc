# Audit Report

## Title
Integer Overflow Panic in Block Info Retrieval with Maximum Sequence Number

## Summary
The `lookup_event_before_or_at_version()` function uses `u64::MAX` as a sentinel value in `seek_for_prev`, which is safe. However, if a NewBlockEvent with sequence number `u64::MAX` exists in the database, downstream code in `to_api_block_info()` performs an unchecked addition `block_height + 1` that causes a panic due to integer overflow, leading to node crash via the public API endpoint.

## Finding Description
The vulnerability exists in a multi-step code path:

1. **Safe seek operation**: The `lookup_event_before_or_at_version()` function uses `u64::MAX` as the third component of the seek key to find the last event at a given version. [1](#0-0) 

2. **Sequence number returned**: This function returns the actual sequence number from the database as the third tuple component. For NewBlockEvents, this sequence number equals the block height. [2](#0-1) 

3. **Unchecked arithmetic**: In `to_api_block_info()`, the code performs `block_height + 1` without overflow checking to retrieve the next block's information. [3](#0-2) 

4. **Panic on overflow**: With `overflow-checks = true` in the release profile, if `block_height = u64::MAX`, the addition panics. [4](#0-3) 

5. **Public API exposure**: This code path is exposed via the `/blocks/by_version/{version}` REST API endpoint. [5](#0-4) 

## Impact Explanation
This constitutes a **Medium Severity** issue per the Aptos bug bounty criteria:
- **Availability Impact**: Causes node crash when querying block information for a block at height `u64::MAX`
- **API Surface**: Exposed via public REST API, allowing external triggers
- **Node Crash**: Violates the availability requirement (similar to "API crashes" at High severity)

However, the impact is limited to specific database state.

## Likelihood Explanation
**Extremely Low** likelihood under normal operation:

1. **Precondition**: Requires a NewBlockEvent with sequence number `u64::MAX` to exist in the database
2. **Practical impossibility**: The blockchain would need `u64::MAX` (18,446,744,073,709,551,615) blocks
3. **Time requirement**: Even at 1 block/second, this would take 584+ billion years
4. **Controlled emission**: Block heights are strictly controlled by the Move framework's event counter with assertions [6](#0-5) 

The only realistic scenarios would be:
- Database corruption introducing invalid data
- A separate bug allowing invalid sequence numbers (not found in analysis)

## Recommendation
Add overflow checking before the arithmetic operation:

```rust
pub(super) fn to_api_block_info(
    &self,
    block_height: u64,
    block_info: BlockInfo,
) -> Result<(Version, Version, NewBlockEvent)> {
    let committed_version = self.get_latest_ledger_info_version()?;
    ensure!(
        block_info.first_version() <= committed_version,
        "block first version {} > committed version {committed_version}",
        block_info.first_version(),
    );

    let new_block_event = self
        .ledger_db
        .event_db()
        .expect_new_block_event(block_info.first_version())?;

    // Add overflow protection
    let next_block_height = block_height.checked_add(1)
        .ok_or_else(|| AptosDbError::Other(
            format!("Block height {} is at maximum value", block_height)
        ))?;
        
    let last_version = match self.get_raw_block_info_by_height(next_block_height) {
        Ok(next_block_info) => next_block_info.first_version().checked_sub(1)
            .ok_or_else(|| AptosDbError::Other(
                "Next block first version is 0".to_string()
            ))?,
        Err(AptosDbError::NotFound(..)) => committed_version,
        Err(err) => return Err(err),
    };

    Ok((
        block_info.first_version(),
        last_version,
        bcs::from_bytes(new_block_event.event_data())?,
    ))
}
```

## Proof of Concept
This vulnerability cannot be demonstrated with a practical PoC because:
1. Creating `u64::MAX` blocks is computationally infeasible
2. Directly injecting database entries bypasses normal validation and doesn't represent a realistic attack vector
3. The Move framework enforces strict invariants preventing such values under normal operation

A theoretical test would require:
- Mocking the database to return a NewBlockEvent with seq_num = `u64::MAX`
- Calling `get_block_info_by_version()` for a version in that block
- Observing the panic

However, this represents a **boundary condition bug** rather than an **exploitable vulnerability** per the strict validation criteria, as there is no realistic attack path for an unprivileged attacker to trigger this state.

---

**Notes**: While this is a legitimate code quality issue that should be fixed for defensive programming and graceful error handling, it fails the "realistic attack path" requirement of the validation checklist. The precondition (block height = u64::MAX) is effectively impossible to achieve through any known exploit vector.

### Citations

**File:** storage/aptosdb/src/event_store/mod.rs (L163-187)
```rust
    pub fn lookup_event_before_or_at_version(
        &self,
        event_key: &EventKey,
        version: Version,
    ) -> Result<
        Option<(
            Version, // version
            u64,     // index
            u64,     // sequence number
        )>,
    > {
        let mut iter = self.event_db.iter::<EventByVersionSchema>()?;
        iter.seek_for_prev(&(*event_key, version, u64::MAX))?;

        match iter.next().transpose()? {
            None => Ok(None),
            Some(((key, ver, seq_num), idx)) => {
                if key == *event_key {
                    Ok(Some((ver, idx, seq_num)))
                } else {
                    Ok(None)
                }
            },
        }
    }
```

**File:** storage/aptosdb/src/db/aptosdb_internal.rs (L351-354)
```rust
            let (first_version, event_index, block_height) = self
                .event_store
                .lookup_event_before_or_at_version(&new_block_event_key(), version)?
                .ok_or_else(|| AptosDbError::NotFound("NewBlockEvent".to_string()))?;
```

**File:** storage/aptosdb/src/db/aptosdb_internal.rs (L394-398)
```rust
        let last_version = match self.get_raw_block_info_by_height(block_height + 1) {
            Ok(next_block_info) => next_block_info.first_version() - 1,
            Err(AptosDbError::NotFound(..)) => committed_version,
            Err(err) => return Err(err),
        };
```

**File:** Cargo.toml (L921-923)
```text
[profile.release]
debug = true
overflow-checks = true
```

**File:** storage/aptosdb/src/db/aptosdb_reader.rs (L779-788)
```rust
    fn get_block_info_by_version(
        &self,
        version: Version,
    ) -> Result<(Version, Version, NewBlockEvent)> {
        gauged_api("get_block_info", || {
            self.error_if_ledger_pruned("NewBlockEvent", version)?;

            let (block_height, block_info) = self.get_raw_block_info_by_version(version)?;
            self.to_api_block_info(block_height, block_info)
        })
```

**File:** aptos-move/framework/aptos-framework/sources/block.move (L282-286)
```text
        assert!(
            event::counter(event_handle) == new_block_event.height,
            error::invalid_argument(ENUM_NEW_BLOCK_EVENTS_DOES_NOT_MATCH_BLOCK_HEIGHT),
        );
        event::emit_event<NewBlockEvent>(event_handle, new_block_event);
```
