# Audit Report

## Title
Race Condition in State KV Pruner: min_readable_version Updated Before Actual Pruning Causes Premature Query Rejections

## Summary
The `set_pruner_target_db_version()` function in `StateKvPrunerManager` updates the in-memory `min_readable_version` atomic variable **before** the pruner worker actually deletes any data. This creates a race window where queries are rejected with "data is pruned" errors even though the data still exists in the database, causing unnecessary API failures and potential validator operational issues.

## Finding Description

The vulnerability exists in the update ordering within the `set_pruner_target_db_version()` method: [1](#0-0) 

The problematic sequence is:
1. **Line 130**: Calculate new `min_readable_version` = `latest_version - prune_window`
2. **Lines 131-132**: **Immediately store** this value in the atomic `self.min_readable_version`
3. **Lines 138-141**: Notify the worker thread to start pruning (asynchronous operation)

Between step 2 and when the worker thread actually completes pruning, queries check the updated `min_readable_version` and fail: [2](#0-1) 

The query validation retrieves `min_readable_version` from the manager's atomic variable (which was already updated), not from the pruner's actual progress: [3](#0-2) 

The actual pruning happens asynchronously in a background worker thread: [4](#0-3) 

**The Core Issue**: The `min_readable_version` represents what **should be** pruned (the target), not what **has been** pruned (the actual progress). The pruner tracks its own progress separately: [5](#0-4) 

This same pattern exists in all pruner managers (Ledger, State Merkle, and State KV), indicating a systemic issue: [6](#0-5) 

## Impact Explanation

**High Severity** - This meets the Aptos bug bounty criteria for HIGH severity issues:

1. **API Crashes/Failures**: Legitimate API queries for historical state values will fail with "data is pruned" errors during the race window, even though the data exists
2. **Validator Node Impact**: If validators need to access historical state during block execution or validation, queries will fail, potentially causing validator slowdowns or operational issues
3. **State Sync Disruption**: Nodes performing state synchronization may request versions that fall in the race window, causing sync failures and preventing nodes from catching up to the network
4. **Service Availability**: Every pruning cycle (which occurs frequently based on `pruning_batch_size` threshold) creates a window of unavailability for historical queries

The race window duration depends on:
- Amount of data to prune (could be seconds to minutes for large batches)
- System load and I/O performance
- Batch size configuration

## Likelihood Explanation

**HIGH Likelihood**:

1. **Automatic Occurrence**: Happens automatically during normal node operation whenever pruning is triggered
2. **Frequency**: Triggered every time the ledger grows by `pruning_batch_size + prune_window` versions beyond the current min_readable_version: [7](#0-6) 

3. **No Attacker Required**: This is a design flaw that affects all nodes running with pruning enabled
4. **Affects All Users**: Any external API client, state sync participant, or validator querying historical state during the race window will experience failures

## Recommendation

**Solution: Update min_readable_version Based on Actual Pruning Progress**

The `min_readable_version` should reflect the pruner's actual completed progress, not the target. Here are two recommended approaches:

**Approach 1: Progressive Updates (Preferred)**
- Do NOT update `min_readable_version` in `set_pruner_target_db_version()`
- Instead, have the pruner worker update `min_readable_version` as it completes each batch
- Modify the `record_progress()` calls to also update the manager's `min_readable_version`

**Approach 2: Synchronization Point**
- Before updating `min_readable_version`, wait for any pending pruning to complete using the existing `is_pruning_pending()` check: [8](#0-7) 

**Recommended Fix (Approach 1 - Progressive Updates):**

Modify `set_pruner_target_db_version()` to NOT update `min_readable_version` immediately:
```rust
fn set_pruner_target_db_version(&self, latest_version: Version) {
    assert!(self.pruner_worker.is_some());
    let target_version = latest_version.saturating_sub(self.prune_window);
    
    // Only set the target, don't update min_readable_version yet
    self.pruner_worker
        .as_ref()
        .unwrap()
        .set_target_db_version(target_version);
}
```

Then, update the pruner to callback and update `min_readable_version` as it makes progress, or have queries check the pruner's actual `progress()` instead of the manager's `min_readable_version`.

## Proof of Concept

```rust
#[cfg(test)]
mod race_condition_test {
    use super::*;
    use std::sync::{Arc, atomic::{AtomicBool, Ordering}};
    use std::thread;
    use std::time::Duration;
    
    #[test]
    fn test_min_readable_version_race_condition() {
        // Setup: Create a StateKvPrunerManager with pruning enabled
        let state_kv_db = /* initialize StateKvDb */;
        let config = LedgerPrunerConfig {
            enable: true,
            prune_window: 10000,
            batch_size: 1000,
        };
        let manager = StateKvPrunerManager::new(state_kv_db.clone(), config);
        
        // Write data at versions 0-20000
        // ... (populate database with test data)
        
        // Initial state: min_readable_version = 0, all data accessible
        assert_eq!(manager.get_min_readable_version(), 0);
        
        // Trigger pruning: should prune versions < 10000 (20000 - 10000)
        manager.set_pruner_target_db_version(20000);
        
        // BUG: min_readable_version is immediately updated to 10000
        let min_readable = manager.get_min_readable_version();
        assert_eq!(min_readable, 10000);
        
        // Try to query version 5000 (which should still exist!)
        let result = state_kv_db.get_state_value_with_version_by_version(&test_key, 5000);
        
        // The query will be rejected by error_if_state_kv_pruned()
        // even though the data at version 5000 still exists in the database
        // This demonstrates the race condition vulnerability
        
        // Give pruner time to actually delete the data
        thread::sleep(Duration::from_secs(5));
        
        // Now the data is actually deleted, query should still fail
        let result_after = state_kv_db.get_state_value_with_version_by_version(&test_key, 5000);
    }
}
```

**Notes**

This vulnerability represents a systemic design flaw across all three pruner managers (State KV, Ledger, and State Merkle). The conservative approach of updating `min_readable_version` before pruning prevents reading potentially-being-deleted data, but causes false rejections that impact availability. A more sophisticated design that tracks actual pruning completion is needed to eliminate this race window while maintaining safety guarantees.

### Citations

**File:** storage/aptosdb/src/pruner/state_kv_pruner/state_kv_pruner_manager.rs (L46-55)
```rust
    fn maybe_set_pruner_target_db_version(&self, latest_version: Version) {
        let min_readable_version = self.get_min_readable_version();
        // Only wake up the state kv pruner if there are `ledger_pruner_pruning_batch_size` pending
        if self.is_pruner_enabled()
            && latest_version
                >= min_readable_version + self.pruning_batch_size as u64 + self.prune_window
        {
            self.set_pruner_target_db_version(latest_version);
        }
    }
```

**File:** storage/aptosdb/src/pruner/state_kv_pruner/state_kv_pruner_manager.rs (L128-142)
```rust
    fn set_pruner_target_db_version(&self, latest_version: Version) {
        assert!(self.pruner_worker.is_some());
        let min_readable_version = latest_version.saturating_sub(self.prune_window);
        self.min_readable_version
            .store(min_readable_version, Ordering::SeqCst);

        PRUNER_VERSIONS
            .with_label_values(&["state_kv_pruner", "min_readable"])
            .set(min_readable_version as i64);

        self.pruner_worker
            .as_ref()
            .unwrap()
            .set_target_db_version(min_readable_version);
    }
```

**File:** storage/aptosdb/src/db/aptosdb_internal.rs (L305-315)
```rust
    pub(super) fn error_if_state_kv_pruned(&self, data_type: &str, version: Version) -> Result<()> {
        let min_readable_version = self.state_store.state_kv_pruner.get_min_readable_version();
        ensure!(
            version >= min_readable_version,
            "{} at version {} is pruned, min available version is {}.",
            data_type,
            version,
            min_readable_version
        );
        Ok(())
    }
```

**File:** storage/aptosdb/src/db/aptosdb_reader.rs (L631-642)
```rust
    fn get_state_value_by_version(
        &self,
        state_store_key: &StateKey,
        version: Version,
    ) -> Result<Option<StateValue>> {
        gauged_api("get_state_value_by_version", || {
            self.error_if_state_kv_pruned("StateValue", version)?;

            self.state_store
                .get_state_value_by_version(state_store_key, version)
        })
    }
```

**File:** storage/aptosdb/src/pruner/pruner_worker.rs (L53-69)
```rust
    fn work(&self) {
        while !self.quit_worker.load(Ordering::SeqCst) {
            let pruner_result = self.pruner.prune(self.batch_size);
            if pruner_result.is_err() {
                sample!(
                    SampleRate::Duration(Duration::from_secs(1)),
                    error!(error = ?pruner_result.err().unwrap(),
                        "Pruner has error.")
                );
                sleep(Duration::from_millis(self.pruning_time_interval_in_ms));
                continue;
            }
            if !self.pruner.is_pruning_pending() {
                sleep(Duration::from_millis(self.pruning_time_interval_in_ms));
            }
        }
    }
```

**File:** storage/aptosdb/src/pruner/state_kv_pruner/mod.rs (L80-82)
```rust
            progress = current_batch_target_version;
            self.record_progress(progress);
            info!(progress = progress, "Pruning state kv data is done.");
```

**File:** storage/aptosdb/src/pruner/ledger_pruner/ledger_pruner_manager.rs (L162-176)
```rust
    fn set_pruner_target_db_version(&self, latest_version: Version) {
        assert!(self.pruner_worker.is_some());
        let min_readable_version = latest_version.saturating_sub(self.prune_window);
        self.min_readable_version
            .store(min_readable_version, Ordering::SeqCst);

        PRUNER_VERSIONS
            .with_label_values(&["ledger_pruner", "min_readable"])
            .set(min_readable_version as i64);

        self.pruner_worker
            .as_ref()
            .unwrap()
            .set_target_db_version(min_readable_version);
    }
```

**File:** storage/aptosdb/src/pruner/pruner_manager.rs (L49-71)
```rust
    fn wait_for_pruner(&self) -> Result<()> {
        use aptos_storage_interface::{db_other_bail, AptosDbError};
        use std::{
            thread::sleep,
            time::{Duration, Instant},
        };

        if !self.is_pruner_enabled() {
            return Ok(());
        }

        // Assuming no big pruning chunks will be issued by a test.
        const TIMEOUT: Duration = Duration::from_secs(60);
        let end = Instant::now() + TIMEOUT;

        while Instant::now() < end {
            if !self.is_pruning_pending() {
                return Ok(());
            }
            sleep(Duration::from_millis(1));
        }
        db_other_bail!("Timeout waiting for pruner worker.");
    }
```
