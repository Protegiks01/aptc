# Audit Report

## Title
Per-User Lock Insufficient for Shared MOVE_HOME: Git Dependency Race Condition in Multi-User Environments

## Summary
The `PACKAGE_PROCESS_MUTEX` lock uses a per-user naming scheme, allowing race conditions when multiple users access a shared `MOVE_HOME` directory. This can cause incomplete git dependencies to be used during framework compilation, potentially leading to non-deterministic builds and validator divergence.

## Finding Description

The package lock implementation creates a separate named lock for each user: [1](#0-0) 

Git dependencies are downloaded to a shared cache directory determined by `MOVE_HOME`: [2](#0-1) [3](#0-2) 

The vulnerability occurs when:

1. **Shared MOVE_HOME Configuration**: Multiple users (or CI/CD workers under different user accounts) configure `MOVE_HOME` to a shared location like `/opt/move_cache` or `/tmp/move_deps`

2. **Per-User Locks Don't Protect Shared Resources**: User A's lock (`move_pkg_lock_userA`) and User B's lock (`move_pkg_lock_userB`) are completely independent

3. **Race Condition During Download**: The git dependency check and download logic: [4](#0-3) 

The race occurs:
- User A: Acquires `move_pkg_lock_userA`, checks `!download_to.exists()` → true
- User A: Git creates directory, starts cloning
- User B: Acquires `move_pkg_lock_userB` (different lock!), checks `!download_to.exists()` → false (directory exists now)
- User B: Skips download, attempts to parse manifest from incomplete directory
- User B: File not found errors during build

4. **No Directory Validation**: There is no verification that an existing git directory is complete and valid. If a previous clone failed mid-way, the directory exists but is corrupted.

5. **Aptos Framework Impact**: If this occurs during Aptos Framework compilation for validator deployment, different validators could end up with different bytecode, violating the **Deterministic Execution** invariant.

## Impact Explanation

**Medium Severity** - While primarily a build-time issue, this can lead to:

1. **Consensus Divergence Risk**: If different validators compile the Aptos Framework with different git dependency states, they may produce different bytecode, leading to state root mismatches and consensus failures.

2. **Validator Deployment Failures**: Automated validator deployment systems using shared caches could randomly fail, causing operational disruptions.

3. **CI/CD Pipeline Corruption**: Shared build environments (common in enterprise deployments) experience random build failures that are difficult to diagnose.

The impact is **not** Critical because:
- Requires specific multi-user/shared cache configurations
- Doesn't affect running validators (only deployment/build)
- Can be detected through bytecode verification before deployment

## Likelihood Explanation

**Moderate Likelihood** in enterprise/CI environments:

**Common Scenarios:**
- Kubernetes CI/CD with shared persistent volumes
- Enterprise build systems with centralized dependency caches  
- Multi-tenant build environments running as different service accounts
- Docker builds with mounted shared volumes

**Unlikely Scenarios:**
- Single-user development environments (default `~/.move` is isolated)
- Production validators (use pre-built verified artifacts)

The vulnerability is **more likely** to manifest as:
- Random CI failures requiring cache clearing
- Non-reproducible builds in shared environments

## Recommendation

**Fix 1: Global Lock Regardless of User**
```rust
static PACKAGE_PROCESS_MUTEX: Lazy<NamedLock> = Lazy::new(|| {
    // Remove username from lock name to make it global
    NamedLock::create(PACKAGE_LOCK_NAME).unwrap()
});
```

**Fix 2: Validate Git Directory Completeness**
Add validation after existence check:
```rust
if !git_info.download_to.exists() {
    // download
} else {
    // Validate the git directory is complete
    if !is_valid_git_repo(&git_info.download_to) {
        // Remove incomplete directory and re-download
        fs::remove_dir_all(&git_info.download_to)?;
        git::clone(git_url, git_path, dep_name)?;
        git::checkout(git_path, git_rev, dep_name)?;
    }
}
```

**Fix 3: Per-Repository Locks**
Instead of a single global lock, use per-repository locks based on the download path, ensuring that only one process can access a specific git repository at a time.

## Proof of Concept

```bash
#!/bin/bash
# Simulate multi-user race condition

# Setup shared MOVE_HOME
export MOVE_HOME=/tmp/shared_move_cache
mkdir -p $MOVE_HOME

# Terminal 1 (as user1):
sudo -u user1 bash -c "
export MOVE_HOME=/tmp/shared_move_cache
cd /path/to/aptos-framework
# Start slow git clone (simulate network delay)
move build --dev &
"

# Terminal 2 (as user2) - start immediately after:
sudo -u user2 bash -c "
export MOVE_HOME=/tmp/shared_move_cache  
cd /path/to/aptos-framework
# This may see partial git directory and fail
move build --dev
"

# Expected: user2's build fails with "Unable to find package manifest" 
# or file not found errors due to incomplete git clone by user1
```

**Rust Test Case:**
```rust
#[test]
fn test_concurrent_git_download_different_users() {
    // This test would require mocking the username() function
    // to simulate different users with shared MOVE_HOME
    
    let shared_cache = tempdir().unwrap();
    std::env::set_var("MOVE_HOME", shared_cache.path());
    
    // Spawn two threads simulating different users
    let handle1 = thread::spawn(|| {
        // Mock user1
        download_package_with_git_dep();
    });
    
    let handle2 = thread::spawn(|| {
        // Mock user2  
        download_package_with_git_dep();
    });
    
    // At least one should succeed, but with per-user locks,
    // both might access the git directory concurrently
}
```

**Notes:**
- This vulnerability exists in the build tooling layer, not the runtime blockchain protocol
- Primary risk is to CI/CD and validator deployment processes, not running validators
- The issue is exacerbated when `MOVE_HOME` is explicitly set to shared locations
- Per-user locks were likely intended to avoid lock contention in single-user dev environments, but break in multi-user scenarios

### Citations

**File:** third_party/move/tools/move-package/src/package_lock.rs (L12-15)
```rust
static PACKAGE_PROCESS_MUTEX: Lazy<NamedLock> = Lazy::new(|| {
    let user_lock_file = format!("{}_{}", PACKAGE_LOCK_NAME, username());
    NamedLock::create(user_lock_file.as_str()).unwrap()
});
```

**File:** third_party/move/move-command-line-common/src/env.rs (L48-58)
```rust
pub static MOVE_HOME: Lazy<String> = Lazy::new(|| {
    std::env::var("MOVE_HOME").unwrap_or_else(|_| {
        format!(
            "{}/.move",
            dirs_next::home_dir()
                .expect("user's home directory not found")
                .to_str()
                .unwrap()
        )
    })
});
```

**File:** third_party/move/tools/move-package/src/source_package/manifest_parser.rs (L566-573)
```rust
pub fn git_repo_cache_path(git_url: &str, rev_name: &str) -> PathBuf {
    let move_home = MOVE_HOME.clone();
    PathBuf::from(move_home).join(format!(
        "{}_{}",
        url_to_file_name(git_url),
        rev_name.replace('/', "__")
    ))
}
```

**File:** third_party/move/tools/move-package/src/resolution/resolution_graph.rs (L562-576)
```rust
            // If there is no cached dependency, download it
            if !git_info.download_to.exists() {
                writeln!(
                    writer,
                    "{} {}",
                    "FETCHING GIT DEPENDENCY".bold().green(),
                    git_url,
                )?;

                // Confirm git is available.
                git::confirm_git_available()?;

                // If the cached folder does not exist, download and clone accordingly
                git::clone(git_url, git_path, dep_name)?;
                git::checkout(git_path, git_rev, dep_name)?;
```
