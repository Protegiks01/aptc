# Audit Report

## Title
Config Optimizer Lacks Validation of User-Provided Seeds Enabling Eclipse Attacks on Bootstrap

## Summary
The configuration optimizer in `config_optimizer.rs` respects user-provided seed peers without validating their legitimacy or trustworthiness. When combined with the bootstrap dependency on seeds for initial network connectivity, this enables eclipse attacks where an attacker can isolate a fullnode by controlling all initial peer connections, preventing proper state synchronization and onchain peer discovery.

## Finding Description

The `optimize_public_network_config()` function checks whether user has provided seeds and respects them without validation: [1](#0-0) 

When seeds are NOT null (user-provided), the optimizer skips adding trusted hardcoded seeds (MAINNET_SEED_PEERS or TESTNET_SEED_PEERS). The only validation that occurs is format validation in `verify_seeds()`: [2](#0-1) 

This validation only checks:
1. Address format (must be aptosnet format)
2. Presence of at least one public key

It does NOT validate:
- Whether seeds are trusted/legitimate peers
- Whether seeds match the chain_id (testnet vs mainnet)
- Whether seeds are on the correct network

**Attack Flow:**

1. **Bootstrap Dependency**: Fullnodes require initial network connections to bootstrap. Onchain discovery depends on reconfiguration events: [3](#0-2) 

2. **State Sync Dependency**: Reconfiguration events require state synchronization, which requires existing network connections from seeds: [4](#0-3) 

3. **Connection Limit**: Fullnodes have a maximum outbound connection limit: [5](#0-4) [6](#0-5) 

4. **Eclipse Attack**: If all user-provided seeds are attacker-controlled:
   - Node connects only to malicious peers (up to 6 outbound connections)
   - Attacker can delay or prevent state synchronization
   - Without state sync, onchain discovery never receives reconfiguration events
   - Node remains isolated from honest network indefinitely
   - Attacker can censor transactions, delay blocks, perform timing attacks

## Impact Explanation

This vulnerability enables **High severity** impact:

1. **Eclipse Attack**: Complete network isolation where node only connects to attacker-controlled peers
2. **State Sync DoS**: Attacker can prevent node from synchronizing blockchain state by refusing to serve data or serving it extremely slowly
3. **Transaction Censorship**: Attacker controls which transactions the node sees and can broadcast
4. **Liveness Degradation**: Node cannot participate in network or serve users
5. **Validator Fullnode Impact**: If a VFN is eclipsed, it cannot properly support its validator, potentially affecting consensus participation

While waypoint validation prevents accepting wrong-chain data, it doesn't prevent:
- Network-layer isolation and censorship
- Denial of service through delayed/refused state sync
- Timing and correlation attacks
- Resource exhaustion from malicious peers

## Likelihood Explanation

**Likelihood: Medium**

The attack requires:
1. Attacker to provide malicious configuration file to victim
2. Victim to use that configuration without verification
3. Configuration files are often shared, copied from untrusted sources, or generated by scripts

This is realistic because:
- New node operators frequently copy configurations from community sources
- Deployment scripts may fetch configurations from compromised endpoints
- Malicious validators could provide "helpful" configurations to new operators
- Configuration templates in forums/Discord could be trojaned

The attack does NOT require:
- Compromising validator keys
- Gaining validator consensus majority
- Breaking cryptographic primitives

## Recommendation

Add validation in `optimize_public_network_config()` to verify user-provided seeds:

```rust
// After line 203, add validation:
if !local_network_config_yaml["seeds"].is_null() {
    // Validate that user seeds contain at least one trusted seed
    if let Some(chain_id) = chain_id {
        let trusted_seeds = if chain_id.is_testnet() {
            &TESTNET_SEED_PEERS
        } else if chain_id.is_mainnet() {
            &MAINNET_SEED_PEERS
        } else {
            // For non-standard networks, skip validation
            continue;
        };
        
        // Check if ANY trusted seed is present
        let has_trusted_seed = fullnode_network_config.seeds
            .keys()
            .any(|peer_id| {
                trusted_seeds.iter().any(|(addr, _, _)| {
                    PeerId::from_hex(addr).ok() == Some(*peer_id)
                })
            });
        
        if !has_trusted_seed {
            warn!(
                "User-provided seeds for chain {:?} do not include any trusted seeds. \
                 This may result in eclipse attacks. Consider merging with trusted seeds.",
                chain_id
            );
            // Optionally: merge trusted seeds with user seeds instead of skipping
        }
    }
}
```

Alternatively, always merge user seeds WITH trusted seeds rather than replacing them entirely:

```rust
// Merge user seeds with trusted seeds
if let Some(chain_id) = chain_id {
    if chain_id.is_testnet() || chain_id.is_mainnet() {
        let default_seeds = if chain_id.is_testnet() {
            create_seed_peers(TESTNET_SEED_PEERS.into())?
        } else {
            create_seed_peers(MAINNET_SEED_PEERS.into())?
        };
        
        // Merge default seeds with user seeds
        for (peer_id, peer) in default_seeds {
            fullnode_network_config.seeds.entry(peer_id).or_insert(peer);
        }
        modified_config = true;
    }
}
```

## Proof of Concept

Create a malicious configuration file:

```yaml
# malicious_fullnode.yaml
base:
  chain_id: 1  # Mainnet
  
full_node_networks:
  - network_id: "public"
    seeds:
      # Attacker-controlled seeds only
      aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa:
        addresses:
          - "/ip4/attacker.evil.com/tcp/6182/noise-ik/0xaaa.../handshake/0"
        role: "Upstream"
      bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb:
        addresses:
          - "/ip4/attacker2.evil.com/tcp/6182/noise-ik/0xbbb.../handshake/0"
        role: "Upstream"
```

Start fullnode with this configuration:
1. Node loads config, sees seeds are not null
2. Optimizer skips adding MAINNET_SEED_PEERS
3. Format validation passes (valid addresses, has pubkeys)
4. Node starts and connects only to attacker.evil.com and attacker2.evil.com
5. Attacker delays state sync responses or refuses to serve
6. Onchain discovery never receives reconfiguration events
7. Node remains eclipsed indefinitely
8. Attacker can censor transactions, correlate user activity, perform timing attacks

## Notes

This vulnerability specifically affects **public fullnodes** during bootstrap. The test `test_optimize_public_network_config_no_override` verifies the no-override behavior but does not validate seed trustworthiness. While waypoint validation provides defense-in-depth against accepting wrong-chain data, it does not prevent network-layer eclipse attacks where the attacker serves valid (but delayed/censored) chain data from malicious peers.

### Citations

**File:** config/src/config/config_optimizer.rs (L203-215)
```rust
            if local_network_config_yaml["seeds"].is_null() {
                if let Some(chain_id) = chain_id {
                    if chain_id.is_testnet() {
                        fullnode_network_config.seeds =
                            create_seed_peers(TESTNET_SEED_PEERS.into())?;
                        modified_config = true;
                    } else if chain_id.is_mainnet() {
                        fullnode_network_config.seeds =
                            create_seed_peers(MAINNET_SEED_PEERS.into())?;
                        modified_config = true;
                    }
                }
            }
```

**File:** config/src/config/network_config.rs (L43-43)
```rust
pub const MAX_FULLNODE_OUTBOUND_CONNECTIONS: usize = 6;
```

**File:** config/src/config/network_config.rs (L319-340)
```rust
    pub fn verify_seeds(&self) -> Result<(), Error> {
        for (peer_id, addrs) in self.seed_addrs.iter() {
            for addr in addrs {
                Self::verify_address(peer_id, addr)?;
            }
        }

        for (peer_id, seed) in self.seeds.iter() {
            for addr in seed.addresses.iter() {
                Self::verify_address(peer_id, addr)?;
            }

            // Require there to be a pubkey somewhere, either in the address (assumed by `is_aptosnet_addr`)
            if seed.keys.is_empty() && seed.addresses.is_empty() {
                return Err(Error::InvariantViolation(format!(
                    "Seed peer {} has no pubkeys",
                    peer_id.short_str(),
                )));
            }
        }
        Ok(())
    }
```

**File:** network/builder/src/builder.rs (L357-370)
```rust
                DiscoveryMethod::Onchain => {
                    let reconfig_events = reconfig_subscription_service
                        .as_mut()
                        .expect("An event subscription service is required for on-chain discovery!")
                        .subscribe_to_reconfigurations()
                        .expect("On-chain discovery is unable to subscribe to reconfigurations!");
                    let identity_key = config.identity_key();
                    let pubkey = identity_key.public_key();
                    DiscoveryChangeListener::validator_set(
                        self.network_context,
                        conn_mgr_reqs_tx.clone(),
                        pubkey,
                        reconfig_events,
                    )
```

**File:** network/framework/src/connectivity_manager/mod.rs (L400-402)
```rust
        // Set the initial seed config addresses and public keys
        connmgr.handle_update_discovered_peers(DiscoverySource::Config, seeds);
        connmgr
```

**File:** network/framework/src/connectivity_manager/mod.rs (L595-620)
```rust
        // Limit the number of dialed connections from a fullnode. Note: this does not
        // limit the number of incoming connections. It only enforces that a fullnode
        // cannot have more outgoing connections than the limit (including in-flight dials).
        let num_eligible_peers = eligible_peers.len();
        let num_peers_to_dial =
            if let Some(outbound_connection_limit) = self.outbound_connection_limit {
                // Get the number of outbound connections
                let num_outbound_connections = self
                    .connected
                    .iter()
                    .filter(|(_, metadata)| metadata.origin == ConnectionOrigin::Outbound)
                    .count();

                // Add any pending dials to the count
                let total_outbound_connections =
                    num_outbound_connections.saturating_add(self.dial_queue.len());

                // Calculate the potential number of peers to dial
                let num_peers_to_dial =
                    outbound_connection_limit.saturating_sub(total_outbound_connections);

                // Limit the number of peers to dial by the total number of eligible peers
                min(num_peers_to_dial, num_eligible_peers)
            } else {
                num_eligible_peers // Otherwise, we attempt to dial all eligible peers
            };
```
