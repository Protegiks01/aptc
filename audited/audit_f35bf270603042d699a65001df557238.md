# Audit Report

## Title
Insufficient Error Handling in DirectMempoolQuorumStore Allows Silent Transaction Starvation

## Summary
The `handle_block_request()` function in `DirectMempoolQuorumStore` suppresses error details when `GetBatch` fails, only logging a generic error message and recording a histogram metric. Repeated failures result in consensus receiving empty blocks without clear alerts, allowing persistent mempool compromise to starve transactions undetected.

## Finding Description

In the `handle_block_request()` function, when `pull_internal()` fails to retrieve transactions from mempool, the error handling mechanism has critical deficiencies: [1](#0-0) 

The error handling exhibits three critical problems:

1. **Error Detail Suppression**: The pattern `Err(_)` discards all error information (timeout, channel failure, unexpected response type)
2. **Minimal Logging**: Only `error!("GetBatch failed")` is logged without context about the failure reason
3. **Silent Failure Propagation**: An empty transaction vector is returned, but the response to consensus is wrapped in `Ok()`: [2](#0-1) 

This means consensus receives what appears to be a successful response with an empty payload, not an error signal. The `pull_internal()` function can fail in multiple ways: [3](#0-2) 

All these distinct failure modes (channel send failure, timeout, unexpected response) are collapsed into the same generic error log.

### Attack Scenario

An attacker who compromises the mempool service or causes persistent network disruption between mempool and quorum store can:

1. Trigger repeated `GetBatch` timeouts or failures
2. Cause consensus to receive empty payloads wrapped in `Ok()` responses
3. Result in continuous empty block proposals while appearing operational
4. Starve all user transactions indefinitely

The consensus client will retry empty payloads but eventually accept them: [4](#0-3) 

### Monitoring Gaps

While a histogram metric is recorded for failures: [5](#0-4) 

This metric (`quorum_store_service_latency_ms` with label `["get_batch", "fail"]`) is suboptimal for alerting because:
- Histograms track latency distributions, not failure counts
- No counter exists for consecutive GetBatch failures
- No explicit mechanism to alert on persistent mempool unavailability
- Empty blocks are valid in the protocol (e.g., during reconfiguration), making detection harder

## Impact Explanation

**Severity: Medium** ($10,000 per Aptos bug bounty)

This vulnerability causes **transaction starvation** (availability/liveness issue):
- All user transactions are blocked from consensus
- The network appears healthy (blocks continue being produced)
- Requires manual investigation of generic error logs to diagnose
- Does not directly cause fund loss or consensus safety violations
- Does not require hardfork to recover (fixing mempool or network restores service)

This meets the Medium severity criteria: "State inconsistencies requiring intervention" - the blockchain state progresses with empty blocks while user transactions accumulate in mempool, requiring operator intervention to diagnose and fix.

## Likelihood Explanation

**Likelihood: Medium to High**

The attack requires:
- Compromise of mempool service OR
- Persistent network disruption between mempool and quorum store OR
- Resource exhaustion causing timeouts

These conditions are realistic in production environments:
- Mempool is an externally-facing component vulnerable to DoS
- Network partitions can occur due to infrastructure issues
- No authentication/authorization shown for mempool communication channel

Detection difficulty is **High** due to:
- Generic error logs without failure context
- Histogram metrics unsuitable for consecutive failure alerting
- Empty blocks appearing as normal protocol behavior
- No health check mechanism for mempool connectivity

## Recommendation

Implement comprehensive error handling and monitoring:

1. **Preserve Error Context**:
```rust
Err(e) => {
    error!(
        error = ?e,
        "GetBatch failed: {}",
        e
    );
    counters::GETBATCH_FAILURE_COUNT.inc(); // Add counter metric
    (vec![], counters::REQUEST_FAIL_LABEL)
}
```

2. **Add Failure Counter Metric**:
```rust
pub static GETBATCH_FAILURE_COUNT: Lazy<IntCounter> = Lazy::new(|| {
    register_int_counter!(
        "quorum_store_getbatch_failure_count",
        "Count of failed GetBatch requests from mempool"
    ).unwrap()
});

pub static GETBATCH_CONSECUTIVE_EMPTY_BLOCKS: Lazy<IntCounter> = Lazy::new(|| {
    register_int_counter!(
        "quorum_store_consecutive_empty_blocks",
        "Count of consecutive empty blocks due to GetBatch failures"
    ).unwrap()
});
```

3. **Propagate Failure to Consensus** (optional, requires protocol change):
```rust
let result = if txns.is_empty() && result == counters::REQUEST_FAIL_LABEL {
    callback.send(Err(anyhow::anyhow!("GetBatch failed")))
} else {
    callback.send(Ok(GetPayloadResponse::GetPayloadResponse(payload)))
};
```

4. **Add Health Check**: Implement periodic health checks that verify mempool connectivity and alert on failures.

## Proof of Concept

```rust
#[tokio::test]
async fn test_getbatch_failure_starvation() {
    // Setup: Create DirectMempoolQuorumStore with failing mempool
    let (consensus_to_qs_tx, consensus_to_qs_rx) = mpsc::channel(1);
    let (qs_to_mempool_tx, mut qs_to_mempool_rx) = mpsc::channel(1);
    
    let qs = DirectMempoolQuorumStore::new(
        consensus_to_qs_rx,
        qs_to_mempool_tx,
        100, // 100ms timeout
    );
    
    // Spawn QS handler
    tokio::spawn(async move {
        qs.start().await;
    });
    
    // Spawn mempool handler that never responds (simulating timeout/failure)
    tokio::spawn(async move {
        while let Some(req) = qs_to_mempool_rx.next().await {
            // Drop all requests - simulating mempool compromise/failure
            drop(req);
        }
    });
    
    // Send GetPayload request from consensus
    let (callback_tx, callback_rx) = oneshot::channel();
    let request = GetPayloadCommand::GetPayloadRequest(GetPayloadRequest {
        max_txns: PayloadTxnsSize::new(100, 100_000),
        max_txns_after_filtering: 100,
        soft_max_txns_after_filtering: 80,
        maybe_optqs_payload_pull_params: None,
        max_inline_txns: PayloadTxnsSize::new(10, 10_000),
        filter: PayloadFilter::Empty,
        return_non_full: false,
        callback: callback_tx,
        block_timestamp: Duration::from_secs(0),
    });
    
    consensus_to_qs_tx.send(request).await.unwrap();
    
    // Verify: Consensus receives Ok() with empty payload, not Err()
    let response = callback_rx.await.unwrap();
    assert!(response.is_ok()); // BUG: Should be Err() but is Ok()
    
    if let Ok(GetPayloadResponse::GetPayloadResponse(payload)) = response {
        assert!(payload.is_empty()); // Empty block despite mempool failure
        println!("VULNERABILITY: Empty block accepted as Ok() despite GetBatch timeout");
    }
}
```

## Notes

The vulnerability is exacerbated by the fact that empty blocks are valid in Aptos consensus (e.g., during epoch transitions), making it difficult to distinguish legitimate empty blocks from those caused by mempool failures. A robust solution requires both improved error handling AND explicit monitoring for mempool health/connectivity separate from normal empty block metrics.

### Citations

**File:** consensus/src/quorum_store/direct_mempool_quorum_store.rs (L64-86)
```rust
        self.mempool_sender
            .clone()
            .try_send(msg)
            .map_err(anyhow::Error::from)?;
        // wait for response
        match monitor!(
            "pull_txn",
            timeout(
                Duration::from_millis(self.mempool_txn_pull_timeout_ms),
                callback_rcv
            )
            .await
        ) {
            Err(_) => Err(anyhow::anyhow!(
                "[direct_mempool_quorum_store] did not receive GetBatchResponse on time"
            )),
            Ok(resp) => match resp.map_err(anyhow::Error::from)?? {
                QuorumStoreResponse::GetBatchResponse(txns) => Ok(txns),
                _ => Err(anyhow::anyhow!(
                    "[direct_mempool_quorum_store] did not receive expected GetBatchResponse"
                )),
            },
        }
```

**File:** consensus/src/quorum_store/direct_mempool_quorum_store.rs (L106-115)
```rust
        let (txns, result) = match self
            .pull_internal(max_txns, max_bytes, return_non_full, exclude_txns)
            .await
        {
            Err(_) => {
                error!("GetBatch failed");
                (vec![], counters::REQUEST_FAIL_LABEL)
            },
            Ok(txns) => (txns, counters::REQUEST_SUCCESS_LABEL),
        };
```

**File:** consensus/src/quorum_store/direct_mempool_quorum_store.rs (L116-120)
```rust
        counters::quorum_store_service_latency(
            counters::GET_BATCH_LABEL,
            result,
            get_batch_start_time.elapsed(),
        );
```

**File:** consensus/src/quorum_store/direct_mempool_quorum_store.rs (L122-124)
```rust
        let get_block_response_start_time = Instant::now();
        let payload = Payload::DirectMempool(txns);
        let result = match callback.send(Ok(GetPayloadResponse::GetPayloadResponse(payload))) {
```

**File:** consensus/src/payload_client/user/quorum_store_client.rs (L124-128)
```rust
            if payload.is_empty() && !return_empty && !done {
                sleep(Duration::from_millis(NO_TXN_DELAY)).await;
                continue;
            }
            break payload;
```
