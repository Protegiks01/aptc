# Audit Report

## Title
Peer Health Tracking Bypass via Index Validation Gap in State Values Requests

## Summary
The `validate_request` function in the storage service moderator incorrectly classifies certain invalid requests as valid, allowing malicious peers to bypass peer health tracking. Specifically, `GetStateValuesWithProof` requests with invalid index ranges (where `end_index < start_index` or `end_index == u64::MAX`) pass validation but fail during processing, resulting in `Error::InvalidRequest` being returned without incrementing the peer's `invalid_request_count`. This enables malicious peers to send unlimited invalid requests without being temporarily ignored.

## Finding Description
The storage service implements a peer health tracking mechanism to protect against misbehaving peers. When a peer sends invalid requests, the system increments an `invalid_request_count`, and after exceeding a threshold, public network peers are temporarily ignored. [1](#0-0) 

The validation occurs in `RequestModerator::validate_request`, which calls `StorageServerSummary::can_service` to check if a request can be satisfied: [2](#0-1) 

However, for `GetStateValuesWithProof` requests, the `can_service` method only validates the version, not the index range: [3](#0-2) 

Notice that unlike transaction-related requests which validate the range using `CompleteDataRange::new()`: [4](#0-3) 

The state values validation does NOT check if `end_index >= start_index` or if `end_index == u64::MAX`. These validations only occur during actual processing: [5](#0-4) 

When `inclusive_range_len` is called with invalid indices, it returns `Error::InvalidRequest`: [6](#0-5) 

However, this error occurs AFTER validation has already passed, so `invalid_request_count` was never incremented. The error is caught in the handler but only increments a generic metrics counter: [7](#0-6) 

**Attack Path:**
1. Malicious peer crafts `GetStateValuesWithProof` request with valid `version` but `end_index < start_index` (e.g., start=100, end=50)
2. Request passes `can_service` validation (only checks version is in range)
3. `invalid_request_count` is NOT incremented
4. Request processing calls `inclusive_range_len(100, 50)`
5. Function returns `Error::InvalidRequest("end (50) must be >= start (100)")`
6. Error is logged and returned to peer, but peer remains unpunished
7. Peer repeats attack indefinitely without being temporarily ignored

## Impact Explanation
This vulnerability is **HIGH severity** per Aptos bug bounty criteria because it enables:

1. **Peer Health Tracking Bypass**: Malicious peers can send unlimited invalid requests without triggering the temporary ignore mechanism, completely bypassing the intended protection against misbehaving peers.

2. **Resource Exhaustion**: While each request fails relatively quickly, it still consumes server resources (validation, iterator creation, error handling, metrics updates). A coordinated attack from multiple peers could cause validator node slowdowns.

3. **Metrics Pollution**: The generic error counter is incremented but not the peer-specific `invalid_request_count`, making it harder to identify and ban specific misbehaving peers.

4. **Protocol Violation**: This breaks the fundamental security guarantee that invalid requests from peers will be tracked and penalized.

This qualifies as "Validator node slowdowns" and "Significant protocol violations" under the HIGH severity category.

## Likelihood Explanation
**Likelihood: HIGH**

This vulnerability is trivial to exploit:
- No special permissions required (any peer can send requests)
- Attack is deterministic and reliable
- Requires minimal resources to execute
- No timing or race conditions involved
- Works on all nodes running the affected code

The only requirement is network connectivity to send storage service requests, which is available to any peer on the public network.

## Recommendation
Add index range validation to the `can_service` method for `GetStateValuesWithProof` requests. Modify the validation in `responses.rs` to check the index range validity before checking data availability:

```rust
GetStateValuesWithProof(request) => {
    // Validate the index range first
    let index_range = match CompleteDataRange::new(request.start_index, request.end_index) {
        Ok(range) => range,
        Err(_) => return false, // Invalid range, reject immediately
    };
    
    let proof_version = request.version;
    let can_serve_states = self
        .states
        .map(|range| range.contains(request.version))
        .unwrap_or(false);

    let can_create_proof = self
        .synced_ledger_info
        .as_ref()
        .map(|li| li.ledger_info().version() >= proof_version)
        .unwrap_or(false);

    can_serve_states && can_create_proof
}
```

This ensures that invalid index ranges are caught during validation, properly incrementing `invalid_request_count` and enabling the peer health tracking mechanism to work as intended.

## Proof of Concept

```rust
#[cfg(test)]
mod test_index_validation_bypass {
    use super::*;
    use aptos_config::config::StorageServiceConfig;
    use aptos_storage_service_types::requests::{DataRequest, StateValuesWithProofRequest, StorageServiceRequest};
    use aptos_types::PeerId;
    use aptos_config::network_id::{NetworkId, PeerNetworkId};
    use aptos_time_service::TimeService;
    
    #[tokio::test]
    async fn test_invalid_index_bypasses_tracking() {
        // Setup
        let config = StorageServiceConfig::default();
        let time_service = TimeService::mock();
        let peer_network_id = PeerNetworkId::new(NetworkId::Public, PeerId::random());
        
        // Create a moderator instance (simplified setup)
        // ... moderator initialization code ...
        
        // Attack: Send request with invalid indices (end < start)
        let malicious_request = StorageServiceRequest {
            data_request: DataRequest::GetStateValuesWithProof(
                StateValuesWithProofRequest {
                    version: 100,      // Valid version in range
                    start_index: 100,  // Start index
                    end_index: 50,     // End index < start_index (INVALID!)
                }
            ),
            use_compression: false,
        };
        
        // First request - should fail during processing, not validation
        let result = moderator.validate_request(&peer_network_id, &malicious_request);
        
        // Verify: validation PASSES (this is the bug!)
        assert!(result.is_ok(), "Validation should pass for invalid indices");
        
        // Check that invalid_request_count was NOT incremented
        let peer_states = moderator.get_unhealthy_peer_states();
        let peer_state = peer_states.get(&peer_network_id);
        assert!(peer_state.is_none() || peer_state.unwrap().invalid_request_count == 0,
                "Invalid request count should not be incremented during validation");
        
        // Send many such requests - peer should never be ignored
        for _ in 0..config.max_invalid_requests_per_peer + 10 {
            let _ = moderator.validate_request(&peer_network_id, &malicious_request);
        }
        
        // Verify: peer is still not ignored (demonstrates the bypass)
        let peer_state = peer_states.get(&peer_network_id);
        assert!(peer_state.is_none() || !peer_state.unwrap().is_ignored(),
                "Peer should have been ignored but wasn't due to validation bypass");
    }
    
    #[tokio::test]
    async fn test_max_u64_index_bypasses_tracking() {
        // Similar test with end_index = u64::MAX which also causes overflow
        let malicious_request = StorageServiceRequest {
            data_request: DataRequest::GetStateValuesWithProof(
                StateValuesWithProofRequest {
                    version: 100,
                    start_index: 0,
                    end_index: u64::MAX, // Causes overflow in range calculation
                }
            ),
            use_compression: false,
        };
        
        // Validation passes, processing fails, no penalty
        // ... similar test structure ...
    }
}
```

## Notes
This vulnerability affects all nodes running the storage service. The fix is straightforward and should be applied to ensure proper peer health tracking. While transaction-related requests properly validate their ranges during the `can_service` check, state value requests were overlooked, creating this security gap.

### Citations

**File:** state-sync/storage-service/server/src/moderator.rs (L47-69)
```rust
    /// Increments the invalid request count for the peer and marks
    /// the peer to be ignored if it has sent too many invalid requests.
    /// Note: we only ignore peers on the public network.
    pub fn increment_invalid_request_count(&mut self, peer_network_id: &PeerNetworkId) {
        // Increment the invalid request count
        self.invalid_request_count += 1;

        // If the peer is a PFN and has sent too many invalid requests, start ignoring it
        if self.ignore_start_time.is_none()
            && peer_network_id.network_id().is_public_network()
            && self.invalid_request_count >= self.max_invalid_requests
        {
            // TODO: at some point we'll want to terminate the connection entirely

            // Start ignoring the peer
            self.ignore_start_time = Some(self.time_service.now());

            // Log the fact that we're now ignoring the peer
            warn!(LogSchema::new(LogEntry::RequestModeratorIgnoredPeer)
                .peer_network_id(peer_network_id)
                .message("Ignoring peer due to too many invalid requests!"));
        }
    }
```

**File:** state-sync/storage-service/server/src/moderator.rs (L155-184)
```rust
            if !storage_server_summary.can_service(
                &self.aptos_data_client_config,
                self.time_service.clone(),
                request,
            ) {
                // Increment the invalid request count for the peer
                let mut unhealthy_peer_state = self
                    .unhealthy_peer_states
                    .entry(*peer_network_id)
                    .or_insert_with(|| {
                        // Create a new unhealthy peer state (this is the first invalid request)
                        let max_invalid_requests =
                            self.storage_service_config.max_invalid_requests_per_peer;
                        let min_time_to_ignore_peers_secs =
                            self.storage_service_config.min_time_to_ignore_peers_secs;
                        let time_service = self.time_service.clone();

                        UnhealthyPeerState::new(
                            max_invalid_requests,
                            min_time_to_ignore_peers_secs,
                            time_service,
                        )
                    });
                unhealthy_peer_state.increment_invalid_request_count(peer_network_id);

                // Return the validation error
                return Err(Error::InvalidRequest(format!(
                    "The given request cannot be satisfied. Request: {:?}, storage summary: {:?}",
                    request, storage_server_summary
                )));
```

**File:** state-sync/storage-service/types/src/responses.rs (L727-741)
```rust
            GetStateValuesWithProof(request) => {
                let proof_version = request.version;

                let can_serve_states = self
                    .states
                    .map(|range| range.contains(request.version))
                    .unwrap_or(false);

                let can_create_proof = self
                    .synced_ledger_info
                    .as_ref()
                    .map(|li| li.ledger_info().version() >= proof_version)
                    .unwrap_or(false);

                can_serve_states && can_create_proof
```

**File:** state-sync/storage-service/types/src/responses.rs (L833-846)
```rust
    fn can_service_transaction_outputs_with_proof(
        &self,
        start_version: u64,
        end_version: u64,
        proof_version: u64,
    ) -> bool {
        let desired_range = match CompleteDataRange::new(start_version, end_version) {
            Ok(desired_range) => desired_range,
            Err(_) => return false,
        };

        let can_service_outputs = self.can_service_transaction_outputs(&desired_range);
        let can_create_proof = self.can_create_proof(proof_version);
        can_service_outputs && can_create_proof
```

**File:** state-sync/storage-service/server/src/storage.rs (L909-909)
```rust
        let expected_num_state_values = inclusive_range_len(start_index, end_index)?;
```

**File:** state-sync/storage-service/server/src/storage.rs (L1485-1493)
```rust
fn inclusive_range_len(start: u64, end: u64) -> aptos_storage_service_types::Result<u64, Error> {
    // len = end - start + 1
    let len = end.checked_sub(start).ok_or_else(|| {
        Error::InvalidRequest(format!("end ({}) must be >= start ({})", end, start))
    })?;
    let len = len
        .checked_add(1)
        .ok_or_else(|| Error::InvalidRequest(format!("end ({}) must not be u64::MAX", end)))?;
    Ok(len)
```

**File:** state-sync/storage-service/server/src/handler.rs (L151-172)
```rust
            match self.validate_and_handle_request(peer_network_id, &request) {
                Err(error) => {
                    // Update the error counter
                    increment_counter(
                        &metrics::STORAGE_ERRORS_ENCOUNTERED,
                        peer_network_id.network_id(),
                        error.get_label().into(),
                    );

                    // Periodically log the failure
                    sample!(
                            SampleRate::Duration(Duration::from_secs(ERROR_LOG_FREQUENCY_SECS)),
                            warn!(LogSchema::new(LogEntry::StorageServiceError)
                                .error(&error)
                                .peer_network_id(peer_network_id)
                                .request(&request)
                                .optimistic_fetch_related(optimistic_fetch_related)
                        );
                    );

                    // Return the error
                    Err(error)
```
