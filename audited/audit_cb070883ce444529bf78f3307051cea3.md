# Audit Report

## Title
Debug Trait Derivation on Sensitive Cryptographic Types Violates Security Guidelines and Risks Information Leakage

## Summary
Multiple cryptographic data types in the `aptos-batch-encryption` crate and related modules have `#[derive(Debug)]`, which exposes sensitive key material when printed or logged. While the error types in `errors.rs` themselves don't contain sensitive data, the broader pattern of deriving Debug on cryptographic types (`SymmetricKey`, `OneTimePad`, `BIBEDecryptionKey`, `BIBEMasterSecretKeyShare`, etc.) violates Aptos' security guidelines and creates potential for cryptographic material leakage through debugging, logging, or panic messages. [1](#0-0) 

## Finding Description

The error types in `errors.rs` use `#[derive(Debug, Error)]` but do not themselves contain sensitive cryptographic data in their variants. However, investigating the broader codebase reveals a systematic security issue: numerous types containing sensitive cryptographic material have `Debug` derived, which will expose their contents when formatted for debugging.

**Sensitive types with Debug derived:**

1. **Symmetric encryption keys:** [2](#0-1) 

2. **Master secret key shares:** [3](#0-2) 

3. **Decryption keys:** [4](#0-3) 

4. **Ciphertext structures containing padded keys:** [5](#0-4) 

5. **Production secret sharing types:** [6](#0-5) [7](#0-6) 

**Security Guidelines Violation:**

Aptos' own security guidelines explicitly require secure handling of cryptographic material: [8](#0-7) 

The crate does NOT use `zeroize` and exposes all key material through Debug formatting, violating these guidelines.

## Impact Explanation

This issue falls under **Low Severity** per Aptos Bug Bounty criteria: "Minor information leaks." 

The vulnerability requires specific conditions to be exploited:
- Debug logging must be enabled and these types must be logged with `{:?}` formatting
- Panic messages containing these types would expose keys in stack traces
- Error handling that includes Debug formatting of these types in error contexts
- Development/debugging scenarios where `.unwrap()` or `.expect()` reveals these types

While not directly exploitable by external attackers without log access, this creates multiple attack vectors:
- Compromised validator nodes with log access could extract keys
- Development/staging environments with verbose logging could leak keys
- Crash dumps or error reports containing panic information could expose keys
- Internal debugging sessions could inadvertently expose sensitive material

## Likelihood Explanation

The likelihood of exposure is **MEDIUM** because:

1. Production consensus code uses these types for secret sharing [9](#0-8) 

2. Multiple `.expect()` calls exist that would print Debug information on panic

3. Future code changes could easily introduce logging that exposes these types

4. The pattern is systemic across the entire cryptographic module

However, exploitation requires either:
- Internal access to logs/debugging output, OR
- A separate vulnerability that exposes error messages/logs to external parties

## Recommendation

**Immediate fixes required:**

1. **Remove Debug derivation from all cryptographic types** or implement custom Debug that redacts sensitive fields:

```rust
// For SymmetricKey in shared/symmetric.rs
impl std::fmt::Debug for SymmetricKey {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("SymmetricKey")
            .field("key", &"<REDACTED>")
            .finish()
    }
}

// Similar implementations for OneTimePad, OneTimePaddedKey, 
// BIBEDecryptionKey, BIBEMasterSecretKeyShare, etc.
```

2. **Add zeroize crate and implement Drop + Zeroize:**

```rust
use zeroize::{Zeroize, ZeroizeOnDrop};

#[derive(Clone, Serialize, Deserialize, ZeroizeOnDrop)]
pub struct SymmetricKey(GenericArray<u8, KeySize>);

// Remove Debug derivation
impl std::fmt::Debug for SymmetricKey {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("SymmetricKey").finish_non_exhaustive()
    }
}
```

3. **Audit all error handling** to ensure sensitive types are never included in error messages or contexts

4. **Add clippy lint** to prevent future Debug derivations on crypto types

## Proof of Concept

```rust
// This demonstrates the information leakage vulnerability
use aptos_batch_encryption::shared::symmetric::SymmetricKey;
use ark_std::rand::thread_rng;

fn main() {
    let mut rng = thread_rng();
    let key = SymmetricKey::new(&mut rng);
    
    // This will print the actual key material in plaintext!
    println!("Debug output: {:?}", key);
    
    // In panic messages, the key would also be exposed:
    panic!("Failed with key: {:?}", key);
    
    // The output would show:
    // SymmetricKey(GenericArray([random_bytes_here...]))
    // exposing the actual 128-bit AES key!
}
```

**Notes:**

The specific question about `errors.rs` has a nuanced answer: the error enum types themselves don't directly contain sensitive data. However, the investigation reveals a broader systemic issue where cryptographic types throughout the module violate security best practices by deriving Debug. This creates multiple pathways for sensitive key material to leak through logging, debugging, or error handling scenarios. While requiring specific conditions to exploit, this violates Aptos' documented security guidelines and represents a security debt that should be addressed.

### Citations

**File:** crates/aptos-batch-encryption/src/errors.rs (L5-35)
```rust
#[derive(Debug, Error)]
pub enum BatchEncryptionError {
    #[error("Tried to setup w/ happy path MPK that doesn't match slow path MPK")]
    HappySlowPathMismatchError,
    #[error("Tried to setup w/ VK that does not match MSK share")]
    VKMSKMismatchError,
    #[error("Serialization error")]
    SerializationError,
    #[error("Deserialization error")]
    DeserializationError,
    #[error("Symmetric encryption error")]
    SymmetricEncryptionError,
    #[error("Symmetric decryption error")]
    SymmetricDecryptionError,
    #[error("Could not initialize an FFT domain of the appropriate size")]
    FFTDomainError,
    #[error("Error when verifying ciphertext: {0}")]
    CTVerifyError(CTVerifyError),
    #[error("Error when verifying eval proof")]
    EvalProofVerifyError,
    #[error("Decryption key share verification error")]
    DecryptionKeyShareVerifyError,
    #[error("Decryption key verification error")]
    DecryptionKeyVerifyError,
    #[error("Tried to decrypt a ciphertext whose eval proof wasn't yet computed")]
    UncomputedEvalProofError,
    #[error("Tried to compute eval proofs for an id set whose coefficients weren't computed yet")]
    EvalProofsWithUncomputedCoefficients,
    #[error("Hash2Curve failed: couldn't find a quadratic residue, or couldn't map to subgroup")]
    Hash2CurveFailure,
}
```

**File:** crates/aptos-batch-encryption/src/shared/symmetric.rs (L37-43)
```rust
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, Hash, Eq)]
pub struct SymmetricKey(GenericArray<u8, KeySize>);

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, Hash, Eq)]
pub struct OneTimePad(GenericArray<u8, KeySize>);
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, Hash, Eq)]
pub struct OneTimePaddedKey(GenericArray<u8, KeySize>);
```

**File:** crates/aptos-batch-encryption/src/shared/key_derivation.rs (L23-30)
```rust
#[derive(Clone, Debug, Serialize, Deserialize, PartialEq, Eq)]
pub struct BIBEMasterSecretKeyShare {
    #[serde(serialize_with = "ark_se", deserialize_with = "ark_de")]
    pub(crate) mpk_g2: G2Affine,
    pub(crate) player: Player,
    #[serde(serialize_with = "ark_se", deserialize_with = "ark_de")]
    pub(crate) shamir_share_eval: Fr,
}
```

**File:** crates/aptos-batch-encryption/src/shared/key_derivation.rs (L40-44)
```rust
#[derive(Clone, Debug, Serialize, Deserialize, PartialEq, Eq)]
pub struct BIBEDecryptionKey {
    #[serde(serialize_with = "ark_se", deserialize_with = "ark_de")]
    pub signature_g1: G1Affine,
}
```

**File:** crates/aptos-batch-encryption/src/shared/ciphertext/bibe.rs (L41-48)
```rust
#[derive(Clone, Serialize, Deserialize, Debug, Hash, Eq, PartialEq)]
pub struct BIBECiphertext {
    pub id: Id,
    #[serde(serialize_with = "ark_se", deserialize_with = "ark_de")]
    ct_g2: [G2Affine; 3],
    padded_key: OneTimePaddedKey,
    symmetric_ciphertext: SymmetricCiphertext,
}
```

**File:** types/src/secret_sharing.rs (L59-64)
```rust
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct SecretShare {
    pub author: Author,
    pub metadata: SecretShareMetadata,
    pub share: SecretKeyShare,
}
```

**File:** types/src/secret_sharing.rs (L122-126)
```rust
#[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]
pub struct SecretSharedKey {
    pub metadata: SecretShareMetadata,
    pub key: DecryptionKey,
}
```

**File:** RUST_SECURE_CODING.md (L139-146)
```markdown
### Cryptographic Material Management

Adhere strictly to established protocols for generating, storing, and managing cryptographic keys. This includes using secure random sources for key generation, ensuring keys are stored in protected environments, and implementing robust management practices to handle key lifecycle events like rotation and revocation [Key Management Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Key_Management_Cheat_Sheet.html).

### Zeroing Sensitive Data

Use [zeroize](https://docs.rs/zeroize/latest/zeroize/#) for zeroing memory containing sensitive data.

```

**File:** consensus/src/rand/secret_sharing/secret_share_manager.rs (L130-148)
```rust
    }

    async fn process_incoming_block(&self, block: &PipelinedBlock) -> DropGuard {
        let futures = block.pipeline_futs().expect("pipeline must exist");
        let self_secret_share = futures
            .secret_sharing_derive_self_fut
            .await
            .expect("Decryption share computation is expected to succeed")
            .expect("Must not be None");
        let metadata = self_secret_share.metadata().clone();

        // Now acquire lock and update store
        {
            let mut secret_share_store = self.secret_share_store.lock();
            secret_share_store.update_highest_known_round(block.round());
            secret_share_store
                .add_self_share(self_secret_share.clone())
                .expect("Add self dec share should succeed");
        }
```
