# Audit Report

## Title
Missing Per-Player Weight Distribution Validation in DKG Transcript Verification Allows DoS and Cryptographic Misalignment

## Summary
The PVSS transcript verification in `weighted_transcript.rs` fails to validate that each player's ciphertext array (`Cs[player.id]`) has the correct length corresponding to their weight in the secret sharing configuration. This allows a malicious dealer to create transcripts with incorrect weight distributions that pass verification but cause validator node crashes during decryption, and break Lagrange basis alignment in the HKZG commitment scheme. [1](#0-0) 

## Finding Description

The `HkzgWeightedElgamalWitness` structure contains `chunked_plaintexts` with a nested structure `Vec<Vec<Vec<Scalar<F>>>>` representing [player][weight_within_player][chunk]. During proof generation, this structure is flattened using iterator chains to compute the HKZG commitment: [2](#0-1) 

The HKZG commitment formula expects chunks to be aligned with Lagrange basis polynomials indexed by `i * B + j + 1` where `i` is the virtual player (share) index and `j` is the chunk index: [3](#0-2) 

The verification function checks the outer dimensions but **not** the per-player weight distribution: [4](#0-3) 

It also validates the total flattened length: [5](#0-4) 

However, a malicious dealer can create a transcript where `Cs[0]` contains all 3 weight units and `Cs[1]` contains 0, which satisfies:
- `Cs.len() == 2` (player count) ✓
- `Cs.flatten().len() == 3` (total weight) ✓
- Homomorphism verification ✓ (because Cs was generated from the malformed witness)

During decryption, the code attempts to decrypt based on the expected weight without validation: [6](#0-5) 

Notice the TODO comment indicating missing validation: [7](#0-6) 

The second implementation has only a `debug_assert_eq!` which is compiled out in release builds: [8](#0-7) 

**Attack Path:**
1. Malicious dealer creates witness with `chunked_plaintexts[0] = [[...], [...], [...]]` (all 3 weight units)
2. Malicious dealer creates witness with `chunked_plaintexts[1] = []` (0 weight units)
3. Generates corresponding `Cs[0]` with 3 elements and `Cs[1]` with 0 elements
4. Creates valid Sigma protocol proof linking witness to statement
5. Transcript passes all verification checks
6. When player 1 (expecting weight 1) tries to decrypt, indexing `Cs[1][0]` causes panic or out-of-bounds access
7. Simultaneously, the Lagrange basis alignment is broken because chunks are not grouped according to the expected configuration

## Impact Explanation

**Severity: High** (up to $50,000 per bug bounty program)

This vulnerability causes:
1. **Validator Node Crashes (DoS)**: Honest validators attempting to decrypt malformed transcripts will panic due to index out-of-bounds access, causing node crashes during DKG protocol execution
2. **Protocol Violation**: The DKG protocol cannot complete successfully, preventing epoch transitions and validator set updates
3. **Cryptographic Misalignment**: The HKZG commitment does not commit to shares at the expected Lagrange evaluation points, breaking the cryptographic correctness of the secret sharing scheme

This constitutes a "Significant protocol violation" per the High Severity category, as it disrupts the distributed key generation process which is critical for validator operations and network consensus.

## Likelihood Explanation

**Likelihood: High**

- **Attacker Requirements**: Only requires ability to act as a dealer in the DKG protocol (any validator can be a dealer)
- **Complexity**: Low - simply requires constructing a witness with incorrect weight distribution
- **Detection**: The malformed transcript passes all cryptographic verification checks, making it undetectable until decryption
- **Impact Surface**: Affects all honest validators attempting to participate in DKG with the malicious dealer

The attack is straightforward to execute and guaranteed to cause disruption if a malicious dealer participates in the protocol.

## Recommendation

Add explicit validation in the `verify()` function to check that each player's ciphertext array length matches their expected weight:

```rust
// In weighted_transcript.rs verify() function, after line 153:
for i in 0..sc.get_total_num_players() {
    let expected_weight = sc.get_player_weight(&sc.get_player(i));
    if self.subtrs.Cs[i].len() != expected_weight {
        bail!(
            "Player {} ciphertext array has length {}, but expected weight {}",
            i,
            self.subtrs.Cs[i].len(),
            expected_weight
        );
    }
    if self.subtrs.Vs[i].len() != expected_weight {
        bail!(
            "Player {} commitment array has length {}, but expected weight {}",
            i,
            self.subtrs.Vs[i].len(),
            expected_weight
        );
    }
}
```

Additionally, replace the `debug_assert_eq!` with a proper runtime check:

```rust
// In decrypt_own_share() at line 578:
if Cs.len() != sc.get_player_weight(player) {
    return Err(anyhow::anyhow!(
        "Ciphertext array length {} does not match expected weight {}",
        Cs.len(),
        sc.get_player_weight(player)
    ));
}
```

## Proof of Concept

```rust
#[test]
fn test_malformed_weight_distribution_attack() {
    use aptos_dkg::pvss::chunky::{weighted_transcript::*, hkzg_chunked_elgamal::*};
    use aptos_crypto::weighted_config::WeightedConfigArkworks;
    
    // Setup: 2 players with weights [2, 1]
    let mut rng = rand::thread_rng();
    let weights = vec![2, 1]; // Player 0: weight 2, Player 1: weight 1
    let threshold = 2;
    let sc = WeightedConfigArkworks::new(threshold, weights);
    
    // Malicious dealer creates witness with wrong distribution:
    // Player 0 gets all 3 weight units, Player 1 gets 0
    let malicious_witness = HkzgWeightedElgamalWitness {
        hkzg_randomness: CommitmentRandomness::rand(&mut rng),
        chunked_plaintexts: vec![
            vec![random_chunks(), random_chunks(), random_chunks()], // All 3 on player 0
            vec![], // None for player 1
        ],
        elgamal_randomness: vec![random_randomness(); 2],
    };
    
    // Generate Cs from malicious witness (would have Cs[0].len()==3, Cs[1].len()==0)
    // Create transcript with these Cs
    // Verification PASSES because:
    // - Cs.len() == 2 (player count)
    // - Cs.flatten().len() == 3 (total weight)
    // - Homomorphism verification succeeds
    
    // When player 1 tries to decrypt with expected weight 1:
    // Cs[1][0] access causes panic!
    
    // Expected: Verification should FAIL with proper weight validation
    // Actual: Verification PASSES, decryption PANICS
}
```

---

**Notes:**

The vulnerability stems from insufficient validation of the internal structure of nested vectors in the witness. While the verification checks outer dimensions and total flattened length, it does not validate that the distribution matches the secret sharing configuration. This allows cryptographically valid but structurally incorrect transcripts to pass verification, leading to runtime failures and protocol violations.

### Citations

**File:** crates/aptos-dkg/src/pvss/chunky/hkzg_chunked_elgamal.rs (L110-118)
```rust
// In other words, the tuple homomorphism is roughly given as follows:
//
// ( rho, z_{i,j} , r_j ) │----> ( HKZG(rho, (0, z_{i,j}) ) , chunked_elgamal( z_{i,j} , r_j )
//                             = (
//			                         \rho [\xi]_1 + \sum_i,j z_i,j [\ell_{i * B + j + 1}(\tau)]_1,
//                                  ( z_i,j G_1 + r_j ek_i )_i,j,
//                                  ( r_j H_1 )_j,
//			                   )
// where B denotes the number of chunks.
```

**File:** crates/aptos-dkg/src/pvss/chunky/hkzg_chunked_elgamal.rs (L204-218)
```rust
            projection: |dom: &HkzgWeightedElgamalWitness<E::ScalarField>| {
                let HkzgWeightedElgamalWitness {
                    hkzg_randomness,
                    chunked_plaintexts,
                    ..
                } = dom;
                let flattened_chunked_plaintexts: Vec<Scalar<E::ScalarField>> =
                    std::iter::once(Scalar(E::ScalarField::ZERO))
                        .chain(chunked_plaintexts.iter().flatten().flatten().cloned())
                        .collect();
                univariate_hiding_kzg::Witness::<E::ScalarField> {
                    hiding_randomness: hkzg_randomness.clone(),
                    values: flattened_chunked_plaintexts,
                }
            },
```

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcript.rs (L140-153)
```rust
        if self.subtrs.Cs.len() != sc.get_total_num_players() {
            bail!(
                "Expected {} arrays of chunked ciphertexts, but got {}",
                sc.get_total_num_players(),
                self.subtrs.Cs.len()
            );
        }
        if self.subtrs.Vs.len() != sc.get_total_num_players() {
            bail!(
                "Expected {} arrays of commitment elements, but got {}",
                sc.get_total_num_players(),
                self.subtrs.Vs.len()
            );
        }
```

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcript.rs (L247-252)
```rust
        let Cs_flat: Vec<_> = self.subtrs.Cs.iter().flatten().cloned().collect();
        assert_eq!(
            Cs_flat.len(),
            sc.get_total_weight(),
            "Number of ciphertexts does not equal number of weights"
        ); // TODO what if zero weight?
```

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcript.rs (L325-355)
```rust
        let weight = sc.get_player_weight(player);

        let Cs = &self.Cs[player.id];

        // TODO: put an assert here saying that len(Cs) = weight

        let ephemeral_keys: Vec<_> = self
            .Rs
            .iter()
            .take(weight)
            .map(|R_i_vec| R_i_vec.iter().map(|R_i| R_i.mul(dk.dk)).collect::<Vec<_>>())
            .collect();

        if let Some(first_key) = ephemeral_keys.first() {
            debug_assert_eq!(
                first_key.len(),
                Cs[0].len(),
                "Number of ephemeral keys does not match the number of ciphertext chunks"
            );
        }

        let mut sk_shares: Vec<Scalar<E::ScalarField>> = Vec::with_capacity(weight);
        let pk_shares = self.get_public_key_share(sc, player);

        for i in 0..weight {
            // TODO: should really put this in a separate function
            let dealt_encrypted_secret_key_share_chunks: Vec<_> = Cs[i]
                .iter()
                .zip(ephemeral_keys[i].iter())
                .map(|(C_ij, ephemeral_key)| C_ij.sub(ephemeral_key))
                .collect();
```

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcript.rs (L578-578)
```rust
        debug_assert_eq!(Cs.len(), sc.get_player_weight(player));
```
