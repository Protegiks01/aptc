# Audit Report

## Title
Incorrect Peer Penalty for Cryptographic Proof Verification Failures in State Sync

## Summary
The `handle_error_notification()` function in the state sync driver hardcodes `NotificationFeedback::InvalidPayloadData` for all storage synchronizer errors, including cryptographic proof verification failures. This causes malicious peers sending invalid proofs to be under-penalized (0.95x score multiplier) instead of being marked as malicious (0.8x multiplier), allowing them to continue attacks longer and waste node resources. [1](#0-0) 

## Finding Description

The state sync driver receives error notifications from the storage synchronizer when data processing fails. The critical issue is that **all error types** are treated identically with `InvalidPayloadData` feedback, despite different error causes requiring different peer reputation penalties. [2](#0-1) 

**The Vulnerability Chain:**

1. **Proof Verification in Chunk Executor**: When the storage synchronizer processes transactions or outputs, the chunk executor performs cryptographic verification of proofs: [3](#0-2) [4](#0-3) 

2. **Additional Verification During Ledger Update**: The chunk verifier performs additional cryptographic checks: [5](#0-4) 

3. **Error Propagation**: When verification fails, errors propagate through the storage synchronizer pipeline: [6](#0-5) 

4. **All Errors Wrapped as UnexpectedError**: The storage synchronizer wraps all errors uniformly: [7](#0-6) 

5. **Incorrect Feedback Mapping**: The notification feedback system maps to different peer score penalties: [8](#0-7) [9](#0-8) [10](#0-9) 

**The Broken Invariant**: Proof verification failures indicate **malicious behavior** (sending cryptographically invalid data) but are penalized as **not useful errors** (0.95x multiplier vs 0.8x multiplier). This violates the peer reputation system's correctness invariant.

**Attack Path:**
1. Malicious peer sends `TransactionListWithProofV2` with invalid cryptographic proof
2. Continuous syncer/bootstrapper passes it to storage synchronizer without verification (only ledger info signatures are verified beforehand)
3. Chunk executor detects invalid proof and returns error
4. Error propagates as `ErrorNotification` to driver
5. Driver incorrectly uses `InvalidPayloadData` feedback
6. Peer score multiplied by 0.95 instead of 0.8
7. Attacker can send approximately 4x more invalid responses before being ignored (score threshold of 25)

## Impact Explanation

**Medium Severity** - This meets the "State inconsistencies requiring intervention" criterion:

- **Peer Reputation State Corruption**: The peer scoring system's state becomes inconsistent with actual peer behavior - malicious peers (sending invalid proofs) are categorized as "not useful" rather than "malicious"

- **Resource Exhaustion**: Malicious peers can waste significantly more node resources before being ignored:
  - Starting score: 50
  - Ignore threshold: 25
  - With 0.95 multiplier: ~47 bad responses needed
  - With 0.8 multiplier: ~12 bad responses needed
  - **~4x more attack opportunities**

- **State Sync Performance Degradation**: Each invalid proof wastes CPU cycles on verification and network bandwidth on retries, delaying blockchain synchronization

- **Protocol Violation**: The peer reputation mechanism is a critical security component that protects against Sybil attacks and resource exhaustion

This does not qualify as High/Critical severity because:
- No direct fund loss or consensus break
- Network remains operational
- No validator node compromise
- Can be mitigated by node operators monitoring peer behavior

## Likelihood Explanation

**High Likelihood** - This vulnerability will trigger in any realistic attack scenario:

1. **No Special Access Required**: Any network peer can connect and send data
2. **Guaranteed Code Path**: Invalid proofs will definitely trigger chunk executor verification failure
3. **No Rate Limiting Bypass Needed**: The incorrect feedback is applied on every error
4. **Realistic Attack Vector**: Sending invalid cryptographic data is trivial for attackers
5. **Already Occurring in Production**: Buggy or malicious peers likely already trigger this incorrectly

The vulnerability is not theoretical - it affects every node performing state synchronization with external peers.

## Recommendation

**Solution 1 (Recommended)**: Enhance `ErrorNotification` to carry semantic error type information that the driver can use to select appropriate feedback:

```rust
// In notification_handlers.rs
pub enum ErrorCategory {
    ProofVerificationFailure,
    InvalidDataStructure,
    InternalSystemError,
}

pub struct ErrorNotification {
    pub error: Error,
    pub error_category: ErrorCategory,
    pub notification_id: NotificationId,
}

// In driver.rs handle_error_notification()
let notification_feedback = match error_notification.error_category {
    ErrorCategory::ProofVerificationFailure => NotificationFeedback::PayloadProofFailed,
    ErrorCategory::InvalidDataStructure => NotificationFeedback::InvalidPayloadData,
    ErrorCategory::InternalSystemError => {
        // Don't penalize peer for our internal errors
        return; // or use a different mechanism
    }
};
```

**Solution 2 (Simpler)**: Inspect error messages to infer error type:

```rust
// In driver.rs handle_error_notification()
let notification_feedback = if error_notification.error.to_string().contains("verif") 
    || error_notification.error.to_string().contains("proof") {
    NotificationFeedback::PayloadProofFailed
} else {
    NotificationFeedback::InvalidPayloadData
};
```

**Solution 3**: Move verification earlier to continuous syncer/bootstrapper level where proper feedback can be provided immediately, similar to how epoch ending ledger infos are verified: [11](#0-10) 

## Proof of Concept

```rust
// Test to demonstrate the vulnerability
// File: state-sync/state-sync-driver/src/tests/driver_proof_feedback_test.rs

#[tokio::test]
async fn test_proof_verification_error_uses_wrong_feedback() {
    // Setup a driver with mock components
    let (mut driver, mut error_listener, streaming_client) = setup_test_driver();
    
    // Simulate storage synchronizer sending error about proof verification failure
    let notification_id = NotificationId::new(1);
    let error = Error::VerificationError("Transaction proof verification failed".into());
    let error_notification = ErrorNotification {
        error,
        notification_id,
    };
    
    // Send error notification to driver
    error_listener.send(error_notification).await.unwrap();
    
    // Process the notification
    driver.handle_error_notification(error_notification).await;
    
    // Verify the streaming client received InvalidPayloadData feedback
    // (This is WRONG - it should be PayloadProofFailed)
    let feedback = streaming_client.get_last_feedback();
    assert_eq!(feedback, NotificationFeedback::InvalidPayloadData); // BUG: Should be PayloadProofFailed
    
    // Verify peer score was penalized with wrong multiplier
    let peer_score_after = get_peer_score(test_peer);
    // With InvalidPayloadData: score * 0.95
    // With PayloadProofFailed: score * 0.8 (correct)
    assert!(peer_score_after > expected_malicious_score); // Peer was under-penalized!
}

// Integration test showing real-world exploit
#[tokio::test]
async fn test_malicious_peer_sends_invalid_proof() {
    let (mut driver, peer_states, storage) = setup_full_driver();
    
    // Malicious peer sends transaction chunk with invalid proof
    let malicious_peer = create_test_peer("malicious");
    let invalid_txn_proof = create_invalid_transaction_proof(); // Invalid accumulator proof
    
    // Driver processes the chunk
    driver.process_transaction_chunk(malicious_peer, invalid_txn_proof).await;
    
    // Proof verification fails in chunk executor
    // Error propagates as ErrorNotification with InvalidPayloadData feedback
    
    // Check peer score after multiple invalid proofs
    for _ in 0..20 {
        driver.process_transaction_chunk(malicious_peer, invalid_txn_proof).await;
    }
    
    let score = peer_states.get_peer_score(malicious_peer);
    
    // With InvalidPayloadData (0.95^20 = ~0.36): score would be ~18
    // With PayloadProofFailed (0.8^20 = ~0.01): score would be ~0.5
    
    assert!(score > 10.0); // Malicious peer still has relatively high score!
    assert!(!peer_states.is_peer_ignored(malicious_peer)); // Still not ignored!
}
```

**Notes:**

- The vulnerability is confirmed in production code paths used by all nodes performing state synchronization
- Proof verification is the **only** line of defense against malicious peers in transaction/output syncing (unlike epoch ending ledger infos which are verified earlier)
- The fix requires minimal code changes but has significant security impact
- This issue affects the **Resource Limits** invariant (operations must respect computational limits) by allowing malicious peers to waste excessive resources

### Citations

**File:** state-sync/state-sync-driver/src/driver.rs (L495-533)
```rust
    async fn handle_error_notification(&mut self, error_notification: ErrorNotification) {
        warn!(LogSchema::new(LogEntry::SynchronizerNotification)
            .error_notification(error_notification.clone())
            .message("Received an error notification from the storage synchronizer!"));

        // Terminate the currently active streams
        let notification_id = error_notification.notification_id;
        let notification_feedback = NotificationFeedback::InvalidPayloadData;
        if self.bootstrapper.is_bootstrapped() {
            if let Err(error) = self
                .continuous_syncer
                .handle_storage_synchronizer_error(NotificationAndFeedback::new(
                    notification_id,
                    notification_feedback,
                ))
                .await
            {
                error!(LogSchema::new(LogEntry::SynchronizerNotification)
                    .message(&format!(
                        "Failed to terminate the active stream for the continuous syncer! Error: {:?}",
                        error
                    )));
            }
        } else if let Err(error) = self
            .bootstrapper
            .handle_storage_synchronizer_error(NotificationAndFeedback::new(
                notification_id,
                notification_feedback,
            ))
            .await
        {
            error!(
                LogSchema::new(LogEntry::SynchronizerNotification).message(&format!(
                    "Failed to terminate the active stream for the bootstrapper! Error: {:?}",
                    error
                ))
            );
        };
    }
```

**File:** execution/executor/src/chunk_executor/mod.rs (L125-132)
```rust
        // Verify input data.
        // In consensus-only mode, txn_list_with_proof is fake.
        if !cfg!(feature = "consensus-only-perf-test") {
            txn_list_with_proof.verify(
                verified_target_li.ledger_info(),
                txn_list_with_proof.get_first_transaction_version(),
            )?;
        }
```

**File:** execution/executor/src/chunk_executor/mod.rs (L167-174)
```rust
        // Verify input data.
        THREAD_MANAGER.get_exe_cpu_pool().install(|| {
            let _timer = CHUNK_OTHER_TIMERS.timer_with(&["apply_chunk__verify"]);
            txn_output_list_with_proof.verify(
                verified_target_li.ledger_info(),
                txn_output_list_with_proof.get_first_output_version(),
            )
        })?;
```

**File:** execution/executor/src/chunk_executor/mod.rs (L365-365)
```rust
        chunk_verifier.verify_chunk_result(&parent_accumulator, &ledger_update_output)?;
```

**File:** state-sync/state-sync-driver/src/storage_synchronizer.rs (L572-586)
```rust
                Err(error) => {
                    // Send an error notification to the driver (we failed to execute/apply the chunk)
                    let error = if executed_chunk {
                        format!("Failed to execute the data chunk! Error: {:?}", error)
                    } else {
                        format!("Failed to apply the data chunk! Error: {:?}", error)
                    };
                    handle_storage_synchronizer_error(
                        notification_metadata,
                        error,
                        &error_notification_sender,
                        &pending_data_chunks,
                    )
                    .await;
                },
```

**File:** state-sync/state-sync-driver/src/storage_synchronizer.rs (L1320-1347)
```rust
/// Sends an error notification to the driver
async fn send_storage_synchronizer_error(
    mut error_notification_sender: mpsc::UnboundedSender<ErrorNotification>,
    notification_id: NotificationId,
    error_message: String,
) {
    // Log the storage synchronizer error
    let error_message = format!("Storage synchronizer error: {:?}", error_message);
    error!(LogSchema::new(LogEntry::StorageSynchronizer).message(&error_message));

    // Update the storage synchronizer error metrics
    let error = Error::UnexpectedError(error_message);
    metrics::increment_counter(&metrics::STORAGE_SYNCHRONIZER_ERRORS, error.get_label());

    // Send an error notification to the driver
    let error_notification = ErrorNotification {
        error: error.clone(),
        notification_id,
    };
    if let Err(error) = error_notification_sender.send(error_notification).await {
        error!(
            LogSchema::new(LogEntry::StorageSynchronizer).message(&format!(
                "Failed to send error notification! Error: {:?}",
                error
            ))
        );
    }
}
```

**File:** state-sync/data-streaming-service/src/data_stream.rs (L1383-1394)
```rust
fn extract_response_error(
    notification_feedback: &NotificationFeedback,
) -> Result<ResponseError, Error> {
    match notification_feedback {
        NotificationFeedback::InvalidPayloadData => Ok(ResponseError::InvalidData),
        NotificationFeedback::PayloadTypeIsIncorrect => Ok(ResponseError::InvalidPayloadDataType),
        NotificationFeedback::PayloadProofFailed => Ok(ResponseError::ProofVerificationError),
        _ => Err(Error::UnexpectedErrorEncountered(format!(
            "Invalid notification feedback given: {:?}",
            notification_feedback
        ))),
    }
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L32-43)
```rust
/// Scores for peer rankings based on preferences and behavior.
const MAX_SCORE: f64 = 100.0;
const MIN_SCORE: f64 = 0.0;
const STARTING_SCORE: f64 = 50.0;
/// Add this score on a successful response.
const SUCCESSFUL_RESPONSE_DELTA: f64 = 1.0;
/// Not necessarily a malicious response, but not super useful.
const NOT_USEFUL_MULTIPLIER: f64 = 0.95;
/// Likely to be a malicious response.
const MALICIOUS_MULTIPLIER: f64 = 0.8;
/// Ignore a peer when their score dips below this threshold.
const IGNORE_PEER_THRESHOLD: f64 = 25.0;
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L54-62)
```rust
impl From<ResponseError> for ErrorType {
    fn from(error: ResponseError) -> Self {
        match error {
            ResponseError::InvalidData | ResponseError::InvalidPayloadDataType => {
                ErrorType::NotUseful
            },
            ResponseError::ProofVerificationError => ErrorType::Malicious,
        }
    }
```

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L1294-1312)
```rust
                match transaction_outputs_with_proof.verify(
                    ledger_info_to_sync.ledger_info(),
                    Some(expected_start_version),
                ) {
                    Ok(()) => {
                        self.state_value_syncer
                            .set_transaction_output_to_sync(transaction_outputs_with_proof);
                    },
                    Err(error) => {
                        self.reset_active_stream(Some(NotificationAndFeedback::new(
                            notification_id,
                            NotificationFeedback::PayloadProofFailed,
                        )))
                        .await?;
                        return Err(Error::VerificationError(format!(
                            "Transaction outputs with proof is invalid! Error: {:?}",
                            error
                        )));
                    },
```
