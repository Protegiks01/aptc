# Audit Report

## Title
Message Type Confusion in Quorum Store V2 Protocol Causes Consensus State Inconsistencies

## Summary
The network routing layer in `NetworkTask::start()` does not handle Quorum Store V2 message types (`BatchMsgV2`, `SignedBatchInfoMsgV2`, `ProofOfStoreMsgV2`), causing these messages to be silently dropped when received. This creates state inconsistencies between validators with different `enable_batch_v2` configurations, potentially causing consensus liveness failures and breaking the quorum store protocol.

## Finding Description

The Aptos consensus layer supports two versions of quorum store messages through the `enable_batch_v2` configuration flag in `QuorumStoreConfig`. [1](#0-0) 

When `enable_batch_v2` is enabled, validators create V2 batches and broadcast them using V2 message types. [2](#0-1)  The `BatchGenerator` broadcasts these batches via `broadcast_batch_msg_v2`. [3](#0-2) 

The V2 message variants are properly defined in the `ConsensusMsg` enum: `BatchMsgV2`, `SignedBatchInfoMsgV2`, and `ProofOfStoreMsgV2`. [4](#0-3) 

However, the network message routing layer in `NetworkTask::start()` only handles V1 message variants in its match pattern. [5](#0-4)  The V2 message variants are **not included** in this pattern and fall through to the default case which logs a warning and drops the message. [6](#0-5) 

Additionally, the `check_epoch()` function in `EpochManager` also excludes V2 messages from its accepted message types. [7](#0-6)  V2 messages that somehow bypass the network layer would be rejected by the default case. [8](#0-7) 

Notably, the conversion infrastructure exists and is ready to handle V2 messages - the `From<ConsensusMsg>` implementation for `UnverifiedEvent` includes V2 variants [9](#0-8)  and the `UnverifiedEvent` enum defines them. [10](#0-9)  However, this conversion is never reached because messages are dropped at the routing layer.

**Attack Scenario:**

1. Validator A enables `enable_batch_v2 = true` in its configuration
2. Validator A creates batches using `BatchInfoExt` and broadcasts them via `ConsensusMsg::BatchMsgV2`
3. Validator B (with default routing code) receives the `BatchMsgV2` message
4. The message does not match any pattern in `NetworkTask::start()` and falls through to the default case
5. The message is dropped with warning "Unexpected direct send msg"
6. Validator B's quorum store never receives Validator A's batch
7. Validator B cannot sign Validator A's batch to form a proof of store
8. If Validator A is the proposer and includes its batches in proposals, other validators lack the batch data
9. This causes consensus state inconsistencies and potential liveness failures

This breaks the **State Consistency** invariant (all validators must maintain consistent views of available batches) and the **Consensus Safety** invariant (validators may disagree on available transaction batches).

## Impact Explanation

**MEDIUM to HIGH Severity** - This vulnerability qualifies as:

1. **"State inconsistencies requiring manual intervention"** (MEDIUM per Aptos Bug Bounty) - Validators with different `enable_batch_v2` settings will have divergent views of available batches, requiring configuration synchronization or manual intervention to resolve.

2. **Potential consensus liveness impact** (HIGH if materialized) - If a proposer sends V2 batches but other validators drop them, those validators cannot verify the proposal's batch references, potentially stalling consensus progress.

3. **Protocol coordination failure** - The quorum store protocol fundamentally breaks when V2 messages are silently dropped. Validators cannot coordinate on batch creation and proof of store formation during mixed-configuration scenarios.

4. **Silent failure mode** - Messages are dropped with only a warning log, making this difficult to diagnose in production environments.

The impact is particularly severe during feature rollouts when validators may have mixed configurations during the transition period.

## Likelihood Explanation

**MEDIUM Likelihood:**

1. **Trivial to trigger** - Any validator operator can set `enable_batch_v2 = true` in their configuration file. [11](#0-10) 

2. **No malicious intent required** - This is a legitimate configuration option intended for feature rollout, not an attack vector requiring adversarial behavior.

3. **Realistic scenario** - During staged rollouts of the V2 feature, some validators will enable V2 while others haven't yet, creating the exact conditions for this bug.

4. **Incomplete implementation** - The V2 infrastructure exists in the codebase (message definitions, sending methods, conversion logic) but the routing layer was not updated to handle these messages.

5. **Default configuration prevents issue** - The default value is `false`, meaning validators must explicitly opt-in. This reduces likelihood in production but increases it during testing/rollout phases.

## Recommendation

Update the network routing layer to handle V2 message variants:

1. In `consensus/src/network.rs`, add V2 variants to the match pattern in `NetworkTask::start()`:

```rust
quorum_store_msg @ (ConsensusMsg::SignedBatchInfo(_)
| ConsensusMsg::BatchMsg(_)
| ConsensusMsg::ProofOfStoreMsg(_)
| ConsensusMsg::SignedBatchInfoMsgV2(_)  // Add this
| ConsensusMsg::BatchMsgV2(_)            // Add this
| ConsensusMsg::ProofOfStoreMsgV2(_)) => // Add this
{
    Self::push_msg(
        peer_id,
        quorum_store_msg,
        &self.quorum_store_messages_tx,
    );
},
```

2. In `consensus/src/epoch_manager.rs`, add V2 variants to `check_epoch()`:

```rust
ConsensusMsg::BatchMsg(_)
| ConsensusMsg::BatchRequestMsg(_)
| ConsensusMsg::SignedBatchInfo(_)
| ConsensusMsg::ProofOfStoreMsg(_)
| ConsensusMsg::BatchMsgV2(_)           // Add this
| ConsensusMsg::SignedBatchInfoMsgV2(_) // Add this
| ConsensusMsg::ProofOfStoreMsgV2(_) => // Add this
```

3. Consider adding protocol version negotiation or compatibility checks to prevent mixed-version deployments from causing silent failures.

## Proof of Concept

A PoC would involve:
1. Setting up two validators with the current codebase
2. Configuring Validator A with `enable_batch_v2 = true`
3. Configuring Validator B with `enable_batch_v2 = false` (or using default routing)
4. Observing that Validator A's batch messages are dropped by Validator B
5. Demonstrating state inconsistency when Validator A becomes proposer

The infrastructure for creating and sending V2 messages exists per the citations above, but the receiving side does not process them, causing the demonstrated failure mode.

---

**Notes:**

This vulnerability represents an incomplete feature implementation where the sending infrastructure for V2 messages was added but the receiving/routing infrastructure was not updated accordingly. While the default configuration prevents this issue, any validator operator enabling `enable_batch_v2` during testing or staged rollout would trigger this bug, causing their messages to be silently dropped by other validators. This is a legitimate protocol bug that should be fixed before the V2 feature is promoted for wider use.

### Citations

**File:** config/src/config/quorum_store_config.rs (L102-102)
```rust
    pub enable_batch_v2: bool,
```

**File:** config/src/config/quorum_store_config.rs (L144-144)
```rust
            enable_batch_v2: false,
```

**File:** consensus/src/quorum_store/batch_generator.rs (L190-201)
```rust
        if self.config.enable_batch_v2 {
            // TODO(ibalajiarun): Specify accurate batch kind
            let batch_kind = BatchKind::Normal;
            Batch::new_v2(
                batch_id,
                txns,
                self.epoch,
                expiry_time,
                self.my_peer_id,
                bucket_start,
                batch_kind,
            )
```

**File:** consensus/src/quorum_store/batch_generator.rs (L494-495)
```rust
                            if self.config.enable_batch_v2 {
                                network_sender.broadcast_batch_msg_v2(batches).await;
```

**File:** consensus/src/network_interface.rs (L97-102)
```rust
    BatchMsgV2(Box<BatchMsg<BatchInfoExt>>),
    /// Quorum Store: Send a signed batch digest with BatchInfoExt. This is a vote for the batch and a promise that
    /// the batch of transactions was received and will be persisted until batch expiration.
    SignedBatchInfoMsgV2(Box<SignedBatchInfoMsg<BatchInfoExt>>),
    /// Quorum Store: Broadcast a certified proof of store (a digest that received 2f+1 votes) with BatchInfoExt.
    ProofOfStoreMsgV2(Box<ProofOfStoreMsg<BatchInfoExt>>),
```

**File:** consensus/src/network.rs (L823-831)
```rust
                        quorum_store_msg @ (ConsensusMsg::SignedBatchInfo(_)
                        | ConsensusMsg::BatchMsg(_)
                        | ConsensusMsg::ProofOfStoreMsg(_)) => {
                            Self::push_msg(
                                peer_id,
                                quorum_store_msg,
                                &self.quorum_store_messages_tx,
                            );
                        },
```

**File:** consensus/src/network.rs (L937-940)
```rust
                        _ => {
                            warn!(remote_peer = peer_id, "Unexpected direct send msg");
                            continue;
                        },
```

**File:** consensus/src/epoch_manager.rs (L1641-1644)
```rust
            | ConsensusMsg::BatchMsg(_)
            | ConsensusMsg::BatchRequestMsg(_)
            | ConsensusMsg::SignedBatchInfo(_)
            | ConsensusMsg::ProofOfStoreMsg(_) => {
```

**File:** consensus/src/epoch_manager.rs (L1687-1689)
```rust
            _ => {
                bail!("[EpochManager] Unexpected messages: {:?}", msg);
            },
```

**File:** consensus/src/round_manager.rs (L97-101)
```rust
    BatchMsgV2(Box<BatchMsg<BatchInfoExt>>),
    SignedBatchInfo(Box<SignedBatchInfoMsg<BatchInfo>>),
    SignedBatchInfoMsgV2(Box<SignedBatchInfoMsg<BatchInfoExt>>),
    ProofOfStoreMsg(Box<ProofOfStoreMsg<BatchInfo>>),
    ProofOfStoreMsgV2(Box<ProofOfStoreMsg<BatchInfoExt>>),
```

**File:** consensus/src/round_manager.rs (L263-265)
```rust
            ConsensusMsg::BatchMsgV2(m) => UnverifiedEvent::BatchMsgV2(m),
            ConsensusMsg::SignedBatchInfoMsgV2(m) => UnverifiedEvent::SignedBatchInfoMsgV2(m),
            ConsensusMsg::ProofOfStoreMsgV2(m) => UnverifiedEvent::ProofOfStoreMsgV2(m),
```
