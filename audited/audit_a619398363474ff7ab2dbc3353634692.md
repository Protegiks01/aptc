# Audit Report

## Title
Identity Mismatch Vulnerability: Network Authentication Not Bound to Consensus Public Key Enables MITM Attacks

## Summary
Validator network connections are authenticated using x25519 public keys embedded in network addresses, completely independent from BLS12-381 consensus public keys. There is no cryptographic binding or validation between these two identity systems. A compromised or malicious operator can update network addresses with attacker-controlled x25519 keys while keeping legitimate consensus keys, enabling man-in-the-middle attacks on validator network traffic.

## Finding Description

The Aptos validator network uses two separate cryptographic identity systems with no binding between them:

1. **Consensus Identity**: BLS12-381 `consensus_public_key` stored in `ValidatorConfig` [1](#0-0) 

2. **Network Identity**: x25519 public key embedded in `network_addresses` via the NoiseIK protocol [2](#0-1) 

When validators establish connections, they use validator-set-discovery to read on-chain `ValidatorConfig`: [3](#0-2) 

The x25519 public keys are extracted from network addresses and used for Noise IK handshake authentication: [4](#0-3) 

During handshake, connections are authenticated ONLY against the x25519 key: [5](#0-4) 

**The Critical Flaw**: When operators update network addresses, there is NO validation that the x25519 network key is bound to or controlled by the same entity as the consensus key: [6](#0-5) 

**Attack Scenario**:
1. Attacker compromises operator private key (or validator owner delegates to malicious operator)
2. Attacker calls `update_network_and_fullnode_addresses` with network address containing:
   - Attacker's IP address (e.g., `/dns/attacker.com/tcp/6180/...`)
   - Attacker's x25519 public key in NoiseIK protocol field
3. Transaction succeeds (only validates operator authorization, NOT key binding)
4. Next epoch: All validators read updated `ValidatorSet` with attacker's network coordinates
5. Other validators attempt connections to `attacker.com` expecting attacker's x25519 key
6. Attacker completes Noise handshake (possesses corresponding private key)
7. **Attacker now has MITM position**: Can read, modify, delay, or drop all network traffic to/from victim validator
8. Victim validator's consensus messages remain valid (signed with legitimate BLS key), but attacker controls network layer

While a detection mechanism exists (logs when local key mismatches on-chain key), it provides no prevention: [7](#0-6) 

## Impact Explanation

**Critical Severity** - This vulnerability enables:

1. **Privacy Breach**: Attacker can decrypt and read all consensus traffic (proposals, votes, blocks) intended for victim validator using Noise session keys they control

2. **Liveness Attack**: Attacker can selectively drop or delay messages, causing:
   - Victim validator to miss proposal deadlines
   - Timeouts in consensus rounds
   - Potential exclusion from validator set due to poor performance

3. **Safety Risk**: While attacker cannot forge BLS signatures, they can:
   - Prevent victim from seeing certain proposals
   - Cause inconsistent views of network state
   - Potentially trigger safety violations through carefully timed message manipulation

4. **Network Partition**: If multiple validators are compromised, attacker could partition the network

This meets **Critical Severity** per Aptos Bug Bounty as it enables significant protocol violations and potential consensus disruption, though requires operator compromise rather than being exploitable by completely unprivileged attackers.

## Likelihood Explanation

**Moderate-to-High Likelihood**:

1. **Operator keys are high-value targets**: Operators manage critical validator infrastructure and their keys are exposed to:
   - Infrastructure compromise (server breaches)
   - Supply chain attacks on key management systems
   - Insider threats from delegated operator services

2. **No defense in depth**: Once operator key is compromised, there is NO additional validation to prevent the attack

3. **Silent exploitation**: The attack is difficult to detect - only the victim validator sees error logs, other validators function normally while connecting to attacker

4. **Persistent impact**: The MITM position persists until the validator owner notices and updates credentials (which requires operator key to fix)

The main limitation is that it requires operator-level access, but operator key compromise is a realistic threat model for production blockchain networks.

## Recommendation

Implement cryptographic binding between consensus and network identities:

**Option 1: Proof-of-Possession for Network Key**
```move
public entry fun update_network_and_fullnode_addresses(
    operator: &signer,
    pool_address: address,
    new_network_addresses: vector<u8>,
    new_fullnode_addresses: vector<u8>,
    // NEW: Signature proving control of network private key
    network_key_signature: vector<u8>,
) acquires StakePool, ValidatorConfig {
    // ... existing checks ...
    
    // Extract x25519 public key from network addresses
    let network_pubkey = extract_network_pubkey(&new_network_addresses);
    
    // Create challenge message binding network key to consensus key
    let challenge = concat(
        validator_info.consensus_pubkey,
        network_pubkey,
        timestamp
    );
    
    // Verify signature proves possession of network private key
    assert!(
        x25519::verify_signature(&network_pubkey, &challenge, &network_key_signature),
        error::invalid_argument(EINVALID_NETWORK_KEY_PROOF)
    );
    
    // ... rest of function ...
}
```

**Option 2: Derived Network Keys**
Derive network x25519 keys deterministically from consensus BLS keys using a standardized KDF, ensuring same entity controls both.

**Option 3: Multi-Signature Requirement**
Require owner signature in addition to operator signature for network address updates, providing separation of duties.

**Immediate Mitigation**:
- Add monitoring alerts for network key mismatches
- Implement stricter operator key management policies
- Add governance review process for network address changes

## Proof of Concept

```rust
// Reproduction steps:
// 1. Setup validator with legitimate consensus and network keys
// 2. Operator calls update_network_and_fullnode_addresses with attacker keys
// 3. Observe other validators connect to attacker instead of legitimate validator

#[test]
fn test_network_identity_mismatch_mitm() {
    // 1. Initialize validator with legitimate keys
    let legit_consensus_key = generate_bls_key();
    let legit_network_key = generate_x25519_key();
    let legit_network_addr = format!(
        "/dns/legit-validator.com/tcp/6180/noise-ik/{}/handshake/0",
        hex::encode(legit_network_key.public_key())
    );
    
    // Register validator
    stake::initialize_validator(
        &validator_account,
        legit_consensus_key.to_bytes(),
        proof_of_possession,
        bcs::to_bytes(&vec![NetworkAddress::from_str(&legit_network_addr).unwrap()]).unwrap(),
        fullnode_addrs,
    );
    
    // 2. Attacker compromises operator key
    let attacker_network_key = generate_x25519_key();
    let attacker_network_addr = format!(
        "/dns/attacker.com/tcp/6180/noise-ik/{}/handshake/0",
        hex::encode(attacker_network_key.public_key())
    );
    
    // 3. Attacker updates network address (no validation of key binding!)
    stake::update_network_and_fullnode_addresses(
        &operator_account,  // Compromised operator
        validator_addr,
        bcs::to_bytes(&vec![NetworkAddress::from_str(&attacker_network_addr).unwrap()]).unwrap(),
        fullnode_addrs,
    );
    
    // 4. Next epoch: Other validators read ValidatorSet
    let validator_set = get_validator_set();
    let victim_config = validator_set.get(validator_addr);
    
    // 5. Extract network address and key
    let network_addrs = victim_config.validator_network_addresses();
    let attacker_key_from_addr = network_addrs[0].find_noise_proto().unwrap();
    
    // VULNERABILITY: attacker_key_from_addr matches attacker's key, not legit_network_key!
    assert_eq!(attacker_key_from_addr, attacker_network_key.public_key());
    assert_ne!(attacker_key_from_addr, legit_network_key.public_key());
    
    // 6. Other validators will now connect to attacker.com with attacker's key
    // Consensus key is still legitimate, but network authentication is compromised
    assert_eq!(victim_config.consensus_public_key, legit_consensus_key.public_key());
    
    // Result: MITM position established - attacker intercepts all network traffic
}
```

## Notes

This vulnerability represents a fundamental design issue where two critical identity systems (consensus and network) operate independently without cryptographic binding. While exploitation requires operator-level access (making it less severe than issues exploitable by completely unprivileged attackers), operator key compromise is a realistic threat in production environments.

The detection mechanism (`find_key_mismatches`) only logs errors without preventing the attack, and only alerts the victim validator while other validators unknowingly connect to the attacker. This lack of defense-in-depth violates security best practices for high-stakes blockchain infrastructure.

The impact is particularly severe because network-layer MITM attacks enable privacy breaches, liveness attacks, and potential safety violations, all while consensus message signatures remain valid, making the attack difficult to diagnose.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L161-168)
```text
    struct ValidatorConfig has key, copy, store, drop {
        consensus_pubkey: vector<u8>,
        network_addresses: vector<u8>,
        // to make it compatible with previous definition, remove later
        fullnode_addresses: vector<u8>,
        // Index in the active set if the validator corresponding to this stake pool is active.
        validator_index: u64,
    }
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L954-995)
```text
    /// Update the network and full node addresses of the validator. This only takes effect in the next epoch.
    public entry fun update_network_and_fullnode_addresses(
        operator: &signer,
        pool_address: address,
        new_network_addresses: vector<u8>,
        new_fullnode_addresses: vector<u8>,
    ) acquires StakePool, ValidatorConfig {
        check_stake_permission(operator);
        assert_reconfig_not_in_progress();
        assert_stake_pool_exists(pool_address);
        let stake_pool = borrow_global_mut<StakePool>(pool_address);
        assert!(signer::address_of(operator) == stake_pool.operator_address, error::unauthenticated(ENOT_OPERATOR));
        assert!(exists<ValidatorConfig>(pool_address), error::not_found(EVALIDATOR_CONFIG));
        let validator_info = borrow_global_mut<ValidatorConfig>(pool_address);
        let old_network_addresses = validator_info.network_addresses;
        validator_info.network_addresses = new_network_addresses;
        let old_fullnode_addresses = validator_info.fullnode_addresses;
        validator_info.fullnode_addresses = new_fullnode_addresses;

        if (std::features::module_event_migration_enabled()) {
            event::emit(
                UpdateNetworkAndFullnodeAddresses {
                    pool_address,
                    old_network_addresses,
                    new_network_addresses,
                    old_fullnode_addresses,
                    new_fullnode_addresses,
                },
            );
        } else {
            event::emit_event(
                &mut stake_pool.update_network_and_fullnode_addresses_events,
                UpdateNetworkAndFullnodeAddressesEvent {
                    pool_address,
                    old_network_addresses,
                    new_network_addresses,
                    old_fullnode_addresses,
                    new_fullnode_addresses,
                },
            );
        };
    }
```

**File:** types/src/network_address/mod.rs (L34-45)
```rust
/// Most validators will advertise a network address like:
///
/// `/dns/example.com/tcp/6180/noise-ik/<x25519-pubkey>/handshake/1`
///
/// Unpacking, the above effectively means:
///
/// 1. Resolve the DNS name "example.com" to an ip address, `addr`.
/// 2. Open a TCP connection to `(addr, 6180)`.
/// 3. Perform a Noise IK handshake and assume the peer's static pubkey is
///    `<x25519-pubkey>`. After this step, we will have a secure, authenticated
///    connection with the peer.
/// 4. Perform a AptosNet version negotiation handshake (version 1).
```

**File:** network/discovery/src/validator_set.rs (L44-66)
```rust
    fn find_key_mismatches(&self, onchain_keys: Option<&HashSet<x25519::PublicKey>>) {
        let mismatch = onchain_keys.map_or(0, |pubkeys| {
            if !pubkeys.contains(&self.expected_pubkey) {
                error!(
                    NetworkSchema::new(&self.network_context),
                    "Onchain pubkey {:?} differs from local pubkey {}",
                    pubkeys,
                    self.expected_pubkey
                );
                1
            } else {
                0
            }
        });

        NETWORK_KEY_MISMATCH
            .with_label_values(&[
                self.network_context.role().as_str(),
                self.network_context.network_id().as_str(),
                self.network_context.peer_id().short_str().as_str(),
            ])
            .set(mismatch);
    }
```

**File:** network/discovery/src/validator_set.rs (L108-149)
```rust
pub(crate) fn extract_validator_set_updates(
    network_context: NetworkContext,
    node_set: ValidatorSet,
) -> PeerSet {
    let is_validator = network_context.network_id().is_validator_network();

    // Decode addresses while ignoring bad addresses
    node_set
        .into_iter()
        .map(|info| {
            let peer_id = *info.account_address();
            let config = info.into_config();

            let addrs = if is_validator {
                config
                    .validator_network_addresses()
                    .map_err(anyhow::Error::from)
            } else {
                config
                    .fullnode_network_addresses()
                    .map_err(anyhow::Error::from)
            }
            .map_err(|err| {
                inc_by_with_context(&DISCOVERY_COUNTS, &network_context, "read_failure", 1);

                warn!(
                    NetworkSchema::new(&network_context),
                    "OnChainDiscovery: Failed to parse any network address: peer: {}, err: {}",
                    peer_id,
                    err
                )
            })
            .unwrap_or_default();

            let peer_role = if is_validator {
                PeerRole::Validator
            } else {
                PeerRole::ValidatorFullNode
            };
            (peer_id, Peer::from_addrs(peer_role, addrs))
        })
        .collect()
```

**File:** config/src/config/network_config.rs (L498-504)
```rust
    pub fn from_addrs(role: PeerRole, addresses: Vec<NetworkAddress>) -> Peer {
        let keys: HashSet<x25519::PublicKey> = addresses
            .iter()
            .filter_map(NetworkAddress::find_noise_proto)
            .collect();
        Peer::new(addresses, keys, role)
    }
```

**File:** network/framework/src/noise/handshake.rs (L488-500)
```rust
    fn authenticate_inbound(
        remote_peer_short: ShortHexStr,
        peer: &Peer,
        remote_public_key: &x25519::PublicKey,
    ) -> Result<PeerRole, NoiseHandshakeError> {
        if !peer.keys.contains(remote_public_key) {
            return Err(NoiseHandshakeError::UnauthenticatedClientPubkey(
                remote_peer_short,
                hex::encode(remote_public_key.as_slice()),
            ));
        }
        Ok(peer.role)
    }
```
