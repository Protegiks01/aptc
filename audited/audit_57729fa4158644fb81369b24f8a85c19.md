# Audit Report

## Title
Race Condition in NFT Burn Ownership Recording Causes Incorrect Historical Data in Indexer

## Summary
A race condition exists in the indexer's `get_burned_nft_v2_from_delete_resource()` function that causes incorrect owner attribution in NFT burn records when transfers and burns occur in the same transaction batch without Token resource writes.

## Finding Description

The Aptos indexer processes transactions in batches and maintains an in-memory cache (`prior_nft_ownership`) to track NFT ownership changes within a batch. When an NFT is burned via ObjectCore deletion, the indexer must determine who owned the token at burn time. [1](#0-0) 

The vulnerability occurs when:

1. **Transaction N**: NFT is transferred from Alice to Bob
   - ObjectCore resource is written with `owner=Bob`
   - TransferEvent is emitted
   - Token resource is NOT written (simple ownership transfer) [2](#0-1) 

2. **Transaction N+1**: NFT is burned
   - ObjectCore resource is deleted
   - BurnEvent is emitted [3](#0-2) 

During batch processing, `prior_nft_ownership` is only updated when `TokenDataV2::get_v2_from_write_resource()` successfully parses a Token resource write. A simple transfer that only updates ObjectCore will NOT trigger this update: [4](#0-3) [5](#0-4) 

When the burn is processed, the cache lookup fails and falls back to querying the database, which still contains Alice as the owner (batch hasn't committed yet). The burn record is then created with Alice as the owner instead of Bob. [6](#0-5) 

This breaks the data integrity invariant: **indexer records must accurately reflect on-chain events and state transitions**.

## Impact Explanation

This qualifies as **Medium severity** under "State inconsistencies requiring intervention" because:

1. **Data Integrity Violation**: Historical burn records permanently contain incorrect ownership information
2. **Downstream System Impact**: Off-chain systems relying on indexer data (UIs, analytics, airdrops, rewards, compliance) will have incorrect information
3. **Manipulation Vector**: Attackers can deliberately create misleading burn records to:
   - Hide evidence of NFT transfers before burns
   - Frame original owners for burning valuable NFTs
   - Manipulate analytics and tracking systems
   - Affect reward distributions based on burn history

While this doesn't directly affect on-chain consensus, it corrupts the indexer's historical record which is critical infrastructure for the Aptos ecosystem.

## Likelihood Explanation

**High likelihood** because:

1. **Common Pattern**: Transfer followed by burn in subsequent transactions is a normal usage pattern (e.g., marketplace sales followed by burns, token consolidation)
2. **No Special Privileges Required**: Any user can trigger this with normal transactions
3. **Simple Execution**: Only requires two transactions in the same batch
4. **Automatic Occurrence**: Happens whenever ObjectCore-only transfers precede burns within a batch window

The issue will occur automatically in normal operations without requiring attacker intent.

## Recommendation

Update `prior_nft_ownership` cache whenever ObjectCore ownership changes, not just when Token resources are written:

```rust
// In token_processor.rs, after processing ObjectCore writes for transfers
WriteSetChange::WriteResource(resource) => {
    // After parsing ObjectCore (around line 1093-1115)
    if let Some(object) = ObjectWithMetadata::from_write_resource(resource, txn_version)? {
        let token_address = standardize_address(&resource.address.to_string());
        
        // Check if this is a transfer event
        if let Some(metadata) = token_v2_metadata_helper.get(&token_address) {
            if metadata.transfer_event.is_some() {
                // Update prior_nft_ownership even without Token write
                prior_nft_ownership.insert(
                    token_address.clone(),
                    NFTOwnershipV2 {
                        token_data_id: token_address.clone(),
                        owner_address: object.object_core.get_owner_address(),
                        is_soulbound: Some(!object.object_core.allow_ungated_transfer),
                    },
                );
            }
        }
    }
}
```

## Proof of Concept

**Setup**: Create two transactions in the same indexer batch:

**Transaction 1 (Transfer):**
```move
// Using object::transfer_raw (only writes ObjectCore)
public entry fun transfer_nft(owner: &signer, nft: Object<Token>, recipient: address) {
    object::transfer_raw(owner, object::object_address(&nft), recipient);
    // Note: No Token resource write, only ObjectCore.owner updated
}
```

**Transaction 2 (Burn):**
```move
// Using token::burn (deletes ObjectCore and Token)
public entry fun burn_nft(burn_ref: BurnRef) {
    token::burn(burn_ref);
    // ObjectCore deleted, burn event emitted
}
```

**Expected Result**: Burn record shows Bob as owner (new owner from Transaction 1)

**Actual Result**: Burn record shows Alice as owner (old owner from database before batch commit)

**Verification**: Query `token_ownerships_v2` table for the burn record and observe `owner_address` field contains Alice instead of Bob.

---

## Notes

This is an **indexer data quality issue** rather than a blockchain consensus vulnerability. The on-chain state remains correct - only the indexer's historical records are affected. However, given the critical role of the indexer in the Aptos ecosystem and the potential for downstream system impacts, this represents a meaningful data integrity vulnerability warranting Medium severity classification.

### Citations

**File:** crates/indexer/src/models/token_models/v2_token_ownerships.rs (L275-305)
```rust
    pub fn get_burned_nft_v2_from_delete_resource(
        write_resource: &DeleteResource,
        txn_version: i64,
        write_set_change_index: i64,
        txn_timestamp: chrono::NaiveDateTime,
        prior_nft_ownership: &HashMap<String, NFTOwnershipV2>,
        tokens_burned: &TokenV2Burned,
        conn: &mut PgPoolConnection,
    ) -> anyhow::Result<Option<(Self, CurrentTokenOwnershipV2)>> {
        if let Some(token_address) =
            tokens_burned.get(&standardize_address(&write_resource.address.to_string()))
        {
            let latest_nft_ownership: NFTOwnershipV2 = match prior_nft_ownership.get(token_address)
            {
                Some(inner) => inner.clone(),
                None => {
                    match CurrentTokenOwnershipV2Query::get_nft_by_token_data_id(
                        conn,
                        token_address,
                    ) {
                        Ok(nft) => nft,
                        Err(_) => {
                            aptos_logger::error!(
                                transaction_version = txn_version,
                                lookup_key = &token_address,
                                "Failed to find NFT for burned token. You probably should backfill db."
                            );
                            return Ok(None);
                        },
                    }
                },
```

**File:** aptos-move/framework/aptos-framework/sources/object.move (L534-570)
```text
    public fun transfer_raw(
        owner: &signer,
        object: address,
        to: address,
    ) acquires ObjectCore {
        let owner_address = signer::address_of(owner);
        assert!(
            permissioned_signer::check_permission_exists(owner, TransferPermission { object }),
            error::permission_denied(EOBJECT_NOT_TRANSFERRABLE)
        );
        verify_ungated_and_descendant(owner_address, object);
        transfer_raw_inner(object, to);
    }

    inline fun transfer_raw_inner(object: address, to: address) {
        let object_core = borrow_global_mut<ObjectCore>(object);
        if (object_core.owner != to) {
            if (std::features::module_event_migration_enabled()) {
                event::emit(
                    Transfer {
                        object,
                        from: object_core.owner,
                        to,
                    },
                );
            } else {
                event::emit_event(
                    &mut object_core.transfer_events,
                    TransferEvent {
                        object,
                        from: object_core.owner,
                        to,
                    },
                );
            };
            object_core.owner = to;
        };
```

**File:** aptos-move/framework/aptos-token-objects/sources/token.move (L734-772)
```text
    public fun burn(burn_ref: BurnRef) acquires Token, TokenIdentifiers {
        let (addr, previous_owner) = if (burn_ref.inner.is_some()) {
            let delete_ref = burn_ref.inner.extract();
            let addr = object::address_from_delete_ref(&delete_ref);
            let previous_owner = object::owner(object::address_to_object<Token>(addr));
            object::delete(delete_ref);
            (addr, previous_owner)
        } else {
            let addr = burn_ref.self.extract();
            let previous_owner = object::owner(object::address_to_object<Token>(addr));
            (addr, previous_owner)
        };

        if (royalty::exists_at(addr)) {
            royalty::delete(addr)
        };

        let Token {
            collection,
            index: deprecated_index,
            description: _,
            name: _,
            uri: _,
            mutation_events,
        } = move_from<Token>(addr);

        let index = if (exists<TokenIdentifiers>(addr)) {
            let TokenIdentifiers {
                index,
                name: _,
            } = move_from<TokenIdentifiers>(addr);
            aggregator_v2::read_snapshot(&index)
        } else {
            deprecated_index
        };

        event::destroy_handle(mutation_events);
        collection::decrement_supply(&collection, addr, option::some(index), previous_owner);
    }
```

**File:** crates/indexer/src/processors/token_processor.rs (L1345-1408)
```rust
                        if let Some((token_data, current_token_data)) =
                            TokenDataV2::get_v2_from_write_resource(
                                resource,
                                txn_version,
                                wsc_index,
                                txn_timestamp,
                                &token_v2_metadata_helper,
                            )
                            .unwrap()
                        {
                            // Add NFT ownership
                            if let Some(inner) = TokenOwnershipV2::get_nft_v2_from_token_data(
                                &token_data,
                                &token_v2_metadata_helper,
                            )
                            .unwrap()
                            {
                                let (
                                    nft_ownership,
                                    current_nft_ownership,
                                    from_nft_ownership,
                                    from_current_nft_ownership,
                                ) = inner;
                                token_ownerships_v2.push(nft_ownership);
                                // this is used to persist latest owner for burn event handling
                                prior_nft_ownership.insert(
                                    current_nft_ownership.token_data_id.clone(),
                                    NFTOwnershipV2 {
                                        token_data_id: current_nft_ownership.token_data_id.clone(),
                                        owner_address: current_nft_ownership.owner_address.clone(),
                                        is_soulbound: current_nft_ownership.is_soulbound_v2,
                                    },
                                );
                                current_token_ownerships_v2.insert(
                                    (
                                        current_nft_ownership.token_data_id.clone(),
                                        current_nft_ownership.property_version_v1.clone(),
                                        current_nft_ownership.owner_address.clone(),
                                        current_nft_ownership.storage_id.clone(),
                                    ),
                                    current_nft_ownership,
                                );
                                // Add the previous owner of the token transfer
                                if let Some(from_nft_ownership) = from_nft_ownership {
                                    let from_current_nft_ownership =
                                        from_current_nft_ownership.unwrap();
                                    token_ownerships_v2.push(from_nft_ownership);
                                    current_token_ownerships_v2.insert(
                                        (
                                            from_current_nft_ownership.token_data_id.clone(),
                                            from_current_nft_ownership.property_version_v1.clone(),
                                            from_current_nft_ownership.owner_address.clone(),
                                            from_current_nft_ownership.storage_id.clone(),
                                        ),
                                        from_current_nft_ownership,
                                    );
                                }
                            }
                            token_datas_v2.push(token_data);
                            current_token_datas_v2.insert(
                                current_token_data.token_data_id.clone(),
                                current_token_data,
                            );
                        }
```

**File:** crates/indexer/src/processors/token_processor.rs (L1481-1513)
```rust
                    WriteSetChange::DeleteResource(resource) => {
                        // Add burned NFT handling
                        if let Some((nft_ownership, current_nft_ownership)) =
                            TokenOwnershipV2::get_burned_nft_v2_from_delete_resource(
                                resource,
                                txn_version,
                                wsc_index,
                                txn_timestamp,
                                &prior_nft_ownership,
                                &tokens_burned,
                                conn,
                            )
                            .unwrap()
                        {
                            token_ownerships_v2.push(nft_ownership);
                            prior_nft_ownership.insert(
                                current_nft_ownership.token_data_id.clone(),
                                NFTOwnershipV2 {
                                    token_data_id: current_nft_ownership.token_data_id.clone(),
                                    owner_address: current_nft_ownership.owner_address.clone(),
                                    is_soulbound: current_nft_ownership.is_soulbound_v2,
                                },
                            );
                            current_token_ownerships_v2.insert(
                                (
                                    current_nft_ownership.token_data_id.clone(),
                                    current_nft_ownership.property_version_v1.clone(),
                                    current_nft_ownership.owner_address.clone(),
                                    current_nft_ownership.storage_id.clone(),
                                ),
                                current_nft_ownership,
                            );
                        }
```

**File:** crates/indexer/src/models/token_models/v2_token_datas.rs (L76-109)
```rust
    pub fn get_v2_from_write_resource(
        write_resource: &APIWriteResource,
        txn_version: i64,
        write_set_change_index: i64,
        txn_timestamp: chrono::NaiveDateTime,
        token_v2_metadata: &TokenV2AggregatedDataMapping,
    ) -> anyhow::Result<Option<(Self, CurrentTokenDataV2)>> {
        if let Some(inner) = &TokenV2::from_write_resource(write_resource, txn_version)? {
            let token_data_id = standardize_address(&write_resource.address.to_string());
            // Get maximum, supply, and is fungible from fungible asset if this is a fungible token
            let (mut maximum, mut supply, mut decimals, mut is_fungible_v2) =
                (None, BigDecimal::zero(), 0, Some(false));
            // Get token properties from 0x4::property_map::PropertyMap
            let mut token_properties = serde_json::Value::Null;
            if let Some(metadata) = token_v2_metadata.get(&token_data_id) {
                let fungible_asset_metadata = metadata.fungible_asset_metadata.as_ref();
                let fungible_asset_supply = metadata.fungible_asset_supply.as_ref();
                if let Some(metadata) = fungible_asset_metadata {
                    if let Some(fa_supply) = fungible_asset_supply {
                        maximum = fa_supply.get_maximum();
                        supply = fa_supply.current.clone();
                        decimals = metadata.decimals as i64;
                        is_fungible_v2 = Some(true);
                    }
                }
                token_properties = metadata
                    .property_map
                    .as_ref()
                    .map(|m| m.inner.clone())
                    .unwrap_or(token_properties);
            } else {
                // ObjectCore should not be missing, returning from entire function early
                return Ok(None);
            }
```
