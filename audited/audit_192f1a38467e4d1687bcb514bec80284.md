# Audit Report

## Title
LedgerInfoWithSignatures Verification Bypass in Transaction Restore When epoch_history is None

## Summary
The `LoadedChunk::load()` function in the transaction restore system fails to validate `LedgerInfoWithSignatures` when `epoch_history` is None, allowing an attacker with control over backup storage to inject arbitrary fake transactions into a restored node's database without cryptographic verification.

## Finding Description

In the transaction backup/restore system, the `LoadedChunk::load()` function is responsible for loading and verifying transaction chunks from backup storage. The function loads a `LedgerInfoWithSignatures` object from untrusted backup storage and only verifies it if an `epoch_history` parameter is provided. [1](#0-0) 

The critical security issue occurs when `epoch_history` is `None` - the `LedgerInfoWithSignatures` is never validated against any trusted source. The subsequent range proof verification only checks that transaction infos are consistent with the accumulator root hash in the unverified `LedgerInfo`: [2](#0-1) 

The range proof verification delegates to `TransactionInfoListWithProof::verify()`, which only validates that the transaction infos match the accumulator root in the provided `LedgerInfo` - it does NOT validate the `LedgerInfo` itself: [3](#0-2) 

**Attack Scenario:**

When the oneoff transaction restore command is executed, `epoch_history` is explicitly set to `None`: [4](#0-3) 

An attacker who has compromised the backup storage can:

1. Create fake transactions they wish to inject
2. Compute transaction infos for these fake transactions
3. Create a malicious `LedgerInfoWithSignatures` with:
   - An arbitrary transaction accumulator root hash matching the fake transaction infos
   - No valid signatures (they won't be checked)
4. Create a valid `TransactionAccumulatorRangeProof` that proves the fake transaction infos exist in the accumulator with that malicious root
5. When a victim runs oneoff transaction restore, the system accepts these fake transactions because:
   - The epoch_history check is skipped
   - The range proof only verifies consistency with the unverified LedgerInfo
   - No cryptographic validation of the LedgerInfo occurs

The `EpochHistory::verify_ledger_info()` method, which should verify signatures, is completely bypassed: [5](#0-4) 

## Impact Explanation

This vulnerability represents a **HIGH severity** security issue under the Aptos bug bounty criteria:

**State Consistency Violation**: The vulnerability directly breaks the "State Consistency: State transitions must be atomic and verifiable via Merkle proofs" invariant. Fake transactions injected through this path would create state that cannot be verified against the actual blockchain.

**Cryptographic Correctness Violation**: This violates the "Cryptographic Correctness: BLS signatures, VRF, and hash operations must be secure" invariant by completely bypassing signature verification on `LedgerInfoWithSignatures`.

**Potential Impacts:**
- **State Database Corruption**: A restored node would have incorrect state that doesn't match the canonical blockchain
- **Consensus Participation Failure**: If the corrupted node attempts to participate in consensus, it will produce invalid votes and proposals
- **Node Denial of Service**: The corrupted state could cause the node to halt or crash when attempting to sync with the network
- **Data Integrity Compromise**: Operators relying on the restored data would have false information

While this doesn't directly lead to fund theft (CRITICAL), it represents a significant protocol violation that could be used to disrupt nodes and create confusion, qualifying as HIGH severity.

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH**

**Attack Prerequisites:**
1. Attacker must compromise backup storage or perform MITM attack on backup retrieval
2. Victim must use oneoff transaction restore command (or similar code path with epoch_history=None)
3. Victim must trust the backup source without additional validation

**Factors increasing likelihood:**
- Backup storage is often stored in cloud providers (S3, GCS) which could be compromised through credential theft or misconfiguration
- The oneoff restore commands are administrative tools that operators might use during disaster recovery
- No additional warnings in the code alert operators about the security implications of restoring without epoch_history

**Factors decreasing likelihood:**
- Requires access to backup storage infrastructure
- Downstream validation may eventually detect the corruption (though not before damage occurs)
- Normal restore operations (via RestoreCoordinator) properly provide epoch_history

## Recommendation

**Immediate Fix:** Make `epoch_history` a required parameter for `LoadedChunk::load()` and fail explicitly if verification cannot be performed:

```rust
// In LoadedChunk::load()
let (range_proof, ledger_info) = storage
    .load_bcs_file::<(TransactionAccumulatorRangeProof, LedgerInfoWithSignatures)>(
        &manifest.proof,
    )
    .await?;

// REQUIRED: Always verify LedgerInfoWithSignatures
let epoch_history = epoch_history.ok_or_else(|| {
    anyhow!(
        "epoch_history is required for secure transaction restore. \
         Cannot verify LedgerInfoWithSignatures without epoch history."
    )
})?;
epoch_history.verify_ledger_info(&ledger_info)?;
```

**For oneoff restore commands:** Require epoch_history to be loaded from a separate trusted source:

```rust
// In db-tool/src/restore.rs
Oneoff::Transaction { storage, opt, global } => {
    // Load epoch history from trusted waypoints or fail
    let epoch_history = load_epoch_history_or_fail(&storage, &global).await?;
    
    TransactionRestoreController::new(
        opt,
        global.try_into()?,
        storage.init_storage().await?,
        Some(epoch_history), // REQUIRED
        VerifyExecutionMode::NoVerify,
    )
    .run()
    .await?;
}
```

**Alternative approach:** Add explicit warnings and require operator acknowledgment when restoring without epoch_history verification.

## Proof of Concept

```rust
#[tokio::test]
async fn test_ledger_info_bypass_with_no_epoch_history() {
    // Setup: Create fake transactions
    let fake_txn = create_fake_transaction();
    let fake_txn_info = create_fake_transaction_info(&fake_txn);
    
    // Create a fake LedgerInfoWithSignatures with arbitrary root hash
    let fake_accumulator_root = compute_accumulator_root(&[fake_txn_info.hash()]);
    let fake_ledger_info = LedgerInfoWithSignatures::new(
        LedgerInfo::new(
            BlockInfo::new(
                0,  // epoch
                0,  // round
                HashValue::zero(),
                fake_accumulator_root,  // malicious root
                0,  // version
                0,  // timestamp
                None,
            ),
            HashValue::zero(),
        ),
        AggregateSignature::empty(),  // No valid signatures!
    );
    
    // Create valid range proof for the fake data
    let range_proof = create_range_proof(&[fake_txn_info.hash()], fake_accumulator_root);
    
    // Write malicious data to backup storage
    let manifest = TransactionChunk {
        first_version: 0,
        last_version: 0,
        transactions: "fake_txns.bcs".into(),
        proof: "fake_proof.bcs".into(),
        format: TransactionChunkFormat::V1,
    };
    
    storage.save_bcs_file(&manifest.proof, &(range_proof, fake_ledger_info)).await?;
    
    // EXPLOIT: Load chunk with epoch_history = None
    let loaded_chunk = LoadedChunk::load(
        manifest,
        &storage,
        None,  // epoch_history is None - verification bypassed!
    ).await?;
    
    // VULNERABILITY: The fake transaction was accepted without signature verification!
    assert_eq!(loaded_chunk.txns[0], fake_txn);
    // Node now has corrupted state that would diverge from the real blockchain
}
```

## Notes

The same vulnerability pattern exists in `StateSnapshotRestoreController::run_impl()`: [6](#0-5) 

This indicates a systemic issue where the codebase allows optional verification when it should be mandatory. Both code paths should be fixed to require epoch_history verification.

### Citations

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L147-154)
```rust
        let (range_proof, ledger_info) = storage
            .load_bcs_file::<(TransactionAccumulatorRangeProof, LedgerInfoWithSignatures)>(
                &manifest.proof,
            )
            .await?;
        if let Some(epoch_history) = epoch_history {
            epoch_history.verify_ledger_info(&ledger_info)?;
        }
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L167-167)
```rust
        txn_list_with_proof.verify(ledger_info.ledger_info(), Some(manifest.first_version))?;
```

**File:** types/src/proof/definition.rs (L910-925)
```rust
    pub fn verify(
        &self,
        ledger_info: &LedgerInfo,
        first_transaction_info_version: Option<Version>,
    ) -> Result<()> {
        let txn_info_hashes: Vec<_> = self
            .transaction_infos
            .iter()
            .map(CryptoHash::hash)
            .collect();
        self.ledger_info_to_transaction_infos_proof.verify(
            ledger_info.transaction_accumulator_hash(),
            first_transaction_info_version,
            &txn_info_hashes,
        )
    }
```

**File:** storage/db-tool/src/restore.rs (L102-108)
```rust
                        TransactionRestoreController::new(
                            opt,
                            global.try_into()?,
                            storage.init_storage().await?,
                            None, /* epoch_history */
                            VerifyExecutionMode::NoVerify,
                        )
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L275-312)
```rust
impl EpochHistory {
    pub fn verify_ledger_info(&self, li_with_sigs: &LedgerInfoWithSignatures) -> Result<()> {
        let epoch = li_with_sigs.ledger_info().epoch();
        ensure!(!self.epoch_endings.is_empty(), "Empty epoch history.",);
        if epoch > self.epoch_endings.len() as u64 {
            // TODO(aldenhu): fix this from upper level
            warn!(
                epoch = epoch,
                epoch_history_until = self.epoch_endings.len(),
                "Epoch is too new and can't be verified. Previous chunks are verified and node \
                won't be able to start if this data is malicious."
            );
            return Ok(());
        }
        if epoch == 0 {
            ensure!(
                li_with_sigs.ledger_info() == &self.epoch_endings[0],
                "Genesis epoch LedgerInfo info doesn't match.",
            );
        } else if let Some(wp_trusted) = self
            .trusted_waypoints
            .get(&li_with_sigs.ledger_info().version())
        {
            let wp_li = Waypoint::new_any(li_with_sigs.ledger_info());
            ensure!(
                *wp_trusted == wp_li,
                "Waypoints don't match. In backup: {}, trusted: {}",
                wp_li,
                wp_trusted,
            );
        } else {
            self.epoch_endings[epoch as usize - 1]
                .next_epoch_state()
                .ok_or_else(|| anyhow!("Shouldn't contain non- epoch bumping LIs."))?
                .verify(li_with_sigs)?;
        };
        Ok(())
    }
```

**File:** storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs (L137-139)
```rust
        if let Some(epoch_history) = self.epoch_history.as_ref() {
            epoch_history.verify_ledger_info(&li)?;
        }
```
