# Audit Report

## Title
Unverifiable Share Decryption in DKG PVSS Allows Malicious Validators to Disrupt Randomness Generation

## Summary
The DKG (Distributed Key Generation) system lacks verification that validators decrypt their shares correctly. When a validator calls `decrypt_own_share`, the decrypted secret key share (sk) and public key share (pk) are not validated for consistency, allowing malicious validators to claim false decryption failures and disrupt the DKG protocol.

## Finding Description
The PVSS (Publicly Verifiable Secret Sharing) decryption process in the DKG system fails to verify that decrypted shares are correct. When validators decrypt their shares during epoch transitions:

1. The `decrypt_own_share` method performs ElGamal-style decryption to extract secret key shares (sk) from encrypted ciphertexts [1](#0-0) 

2. The public key shares (pk) are retrieved directly from the transcript's verified commitments (V_hat) [2](#0-1) 

3. The method returns (sk, pk) without verifying they are cryptographically consistent (i.e., that pk = g2^scalar where scalar is the discrete log of sk)

4. In the epoch manager, these unverified shares are immediately used to generate augmented key pairs for randomness generation [3](#0-2) 

5. The comment at line 1063 explicitly states "No need to verify the transcript" but this omits verification of the decryption correctness [4](#0-3) 

**Attack Vector:**
A malicious validator can:
- Use an incorrect decryption key deliberately
- Obtain mismatched (sk, pk) pairs where sk does not correspond to pk
- Claim "decryption failed" or that the DKG transcript is invalid
- Refuse to participate in randomness generation
- Cause the DKG process to fail repeatedly

**Contrast with Batch Encryption:** The batch encryption system correctly implements this verification by checking that verification keys match master secret key shares [5](#0-4) , but this verification is missing from the DKG flow.

## Impact Explanation
This is a **High Severity** vulnerability per Aptos bug bounty criteria:
- **Significant Protocol Violation**: The DKG protocol's security relies on the verifiability of secret sharing, which is violated
- **Liveness Failure**: A single malicious validator can prevent the network from completing DKG, blocking randomness generation for the entire epoch
- **Randomness Generation Disruption**: The on-chain randomness system depends on successful DKG completion; repeated failures degrade availability

While this requires a malicious validator (not an unprivileged attacker), the security question explicitly explores this threat model: "can malicious validators claim decryption failures to disrupt DKG?"

## Likelihood Explanation
**Likelihood: High**
- **Attack Complexity: Low** - A validator simply needs to use an incorrect decryption key or modify the decryption logic
- **Detection: Difficult** - Other validators cannot distinguish between honest decryption failures and malicious false claims
- **Byzantine Tolerance: None** - A single malicious validator is sufficient to disrupt DKG
- **Motivation: High** - Disrupting randomness can benefit validators in various ways (e.g., denying competitors access to VRF-based leader election)

## Recommendation
Add cryptographic verification that decrypted secret key shares match their corresponding public key shares before using them. The verification should check the pairing relationship for each share:

```rust
fn decrypt_own_share(
    &self,
    sc: &Self::SecretSharingConfig,
    player: &Player,
    dk: &Self::DecryptPrivKey,
    pp: &Self::PublicParameters,
) -> anyhow::Result<(Self::DealtSecretKeyShare, Self::DealtPubKeyShare)> {
    let weight = sc.get_player_weight(player);
    let mut sk_shares = Vec::with_capacity(weight);
    let pk_shares = self.get_public_key_share(sc, player);

    for j in 0..weight {
        let k = sc.get_share_index(player.id, j).unwrap();
        
        let ctxt = self.C[k];
        let ephemeral_key = self.R[k].mul(dk.dk);
        let dealt_secret_key_share = ctxt.sub(ephemeral_key);
        
        // VERIFICATION: Check that sk corresponds to pk
        // For G1 sk and G2 pk: e(sk, g2) should equal e(g1, pk)
        let g1 = pp.get_encryption_public_params().pubkey_base();
        let g2 = pp.get_commitment_base();
        
        use blstrs::pairing;
        let lhs = pairing(&dealt_secret_key_share.to_affine(), &g2.to_affine());
        let rhs = pairing(&g1.to_affine(), &self.V_hat[k].to_affine());
        
        if lhs != rhs {
            bail!("Decrypted secret key share does not match public key share at index {}", k);
        }
        
        sk_shares.push(pvss::dealt_secret_key_share::g1::DealtSecretKeyShare::new(
            Self::DealtSecretKey::new(dealt_secret_key_share),
        ));
    }

    Ok((sk_shares, pk_shares))
}
```

Alternatively, perform the verification in the epoch manager after decryption and before using the shares.

## Proof of Concept
```rust
#[test]
fn test_unverifiable_decryption_attack() {
    use aptos_dkg::pvss::{
        das::WeightedTranscript,
        traits::Transcript,
        Player,
    };
    use rand::thread_rng;
    
    let mut rng = thread_rng();
    
    // Setup DKG parameters
    let sc = /* weighted config */;
    let pp = /* public parameters */;
    let eks = /* encryption keys */;
    
    // Dealer creates a valid transcript
    let dealer_sk = /* signing key */;
    let dealer_pk = /* signing pub key */;
    let secret = /* input secret */;
    let transcript = WeightedTranscript::deal(
        &sc, &pp, &dealer_sk, &dealer_pk, &eks, &secret, &(), &Player { id: 0 }, &mut rng
    );
    
    // Verify transcript is valid
    assert!(transcript.verify(&sc, &pp, &[dealer_pk], &eks, &[()]).is_ok());
    
    // Honest validator decrypts correctly
    let honest_dk = /* correct decryption key */;
    let (honest_sk, honest_pk) = transcript.decrypt_own_share(&sc, &Player { id: 1 }, &honest_dk, &pp);
    
    // Malicious validator uses WRONG decryption key
    let malicious_dk = /* incorrect/random decryption key */;
    let (malicious_sk, malicious_pk) = transcript.decrypt_own_share(&sc, &Player { id: 1 }, &malicious_dk, &pp);
    
    // The public key shares are the same (from transcript)
    assert_eq!(honest_pk, malicious_pk);
    
    // But the secret key shares are DIFFERENT (one is wrong)
    assert_ne!(honest_sk, malicious_sk);
    
    // NO ERROR IS RAISED! The malicious decryption succeeds without verification
    // The validator can now claim the DKG failed or use the wrong share
    // to disrupt threshold operations
}
```

## Notes
This vulnerability specifically addresses the security question about whether "malicious validators can claim decryption failures to disrupt DKG." The lack of verifiable decryption means:

1. Validators cannot prove they decrypted correctly
2. Other validators cannot verify if a claimed "decryption failure" is legitimate
3. The DKG protocol lacks the "publicly verifiable" property that PVSS is designed to provide

The fix should add pairing-based verification similar to the batch encryption system, ensuring cryptographic consistency between secret and public key shares before they are used for randomness generation.

### Citations

**File:** crates/aptos-dkg/src/pvss/das/weighted_protocol.rs (L197-213)
```rust
    fn get_public_key_share(
        &self,
        sc: &Self::SecretSharingConfig,
        player: &Player,
    ) -> Self::DealtPubKeyShare {
        let weight = sc.get_player_weight(player);
        let mut pk_shares = Vec::with_capacity(weight);

        for j in 0..weight {
            let k = sc.get_share_index(player.id, j).unwrap();
            pk_shares.push(pvss::dealt_pub_key_share::g2::DealtPubKeyShare::new(
                Self::DealtPubKey::new(self.V_hat[k]),
            ));
        }

        pk_shares
    }
```

**File:** crates/aptos-dkg/src/pvss/das/weighted_protocol.rs (L220-244)
```rust
    fn decrypt_own_share(
        &self,
        sc: &Self::SecretSharingConfig,
        player: &Player,
        dk: &Self::DecryptPrivKey,
        _pp: &Self::PublicParameters,
    ) -> (Self::DealtSecretKeyShare, Self::DealtPubKeyShare) {
        let weight = sc.get_player_weight(player);
        let mut sk_shares = Vec::with_capacity(weight);
        let pk_shares = self.get_public_key_share(sc, player);

        for j in 0..weight {
            let k = sc.get_share_index(player.id, j).unwrap();

            let ctxt = self.C[k]; // h_1^{f(s_i + j - 1)} \ek_i^{r_{s_i + j}}
            let ephemeral_key = self.R[k].mul(dk.dk); // (g_1^{r_{s_i + j}})
            let dealt_secret_key_share = ctxt.sub(ephemeral_key);

            sk_shares.push(pvss::dealt_secret_key_share::g1::DealtSecretKeyShare::new(
                Self::DealtSecretKey::new(dealt_secret_key_share),
            ));
        }

        (sk_shares, pk_shares)
    }
```

**File:** consensus/src/epoch_manager.rs (L1063-1063)
```rust
        // No need to verify the transcript.
```

**File:** consensus/src/epoch_manager.rs (L1066-1104)
```rust
        let (sk, pk) = DefaultDKG::decrypt_secret_share_from_transcript(
            &dkg_pub_params,
            &transcript,
            my_index as u64,
            &dkg_decrypt_key,
        )
        .map_err(NoRandomnessReason::SecretShareDecryptionFailed)?;

        let fast_randomness_is_enabled = onchain_randomness_config.fast_randomness_enabled()
            && sk.fast.is_some()
            && pk.fast.is_some()
            && transcript.fast.is_some()
            && dkg_pub_params.pvss_config.fast_wconfig.is_some();

        let pk_shares = (0..new_epoch_state.verifier.len())
            .map(|id| {
                transcript
                    .main
                    .get_public_key_share(&dkg_pub_params.pvss_config.wconfig, &Player { id })
            })
            .collect::<Vec<_>>();

        // Recover existing augmented key pair or generate a new one
        let (augmented_key_pair, fast_augmented_key_pair) = if let Some((_, key_pair)) = self
            .rand_storage
            .get_key_pair_bytes()
            .map_err(NoRandomnessReason::RandDbNotAvailable)?
            .filter(|(epoch, _)| *epoch == new_epoch)
        {
            info!(epoch = new_epoch, "Recovering existing augmented key");
            bcs::from_bytes(&key_pair).map_err(NoRandomnessReason::KeyPairDeserializationError)?
        } else {
            info!(
                epoch = new_epoch_state.epoch,
                "Generating a new augmented key"
            );
            let mut rng =
                StdRng::from_rng(thread_rng()).map_err(NoRandomnessReason::RngCreationError)?;
            let augmented_key_pair = WVUF::augment_key_pair(&vuf_pp, sk.main, pk.main, &mut rng);
```

**File:** crates/aptos-batch-encryption/src/schemes/fptx_weighted.rs (L280-283)
```rust
                (G2Projective::from(*vk_raw) == G2Affine::generator() * msk_share_raw)
                    .then_some(())
                    .ok_or(BatchEncryptionError::VKMSKMismatchError)
            })?;
```
