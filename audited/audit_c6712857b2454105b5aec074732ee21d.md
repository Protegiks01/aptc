# Audit Report

## Title
DKG Proof Reuse Attack: Malicious Dealer Can Copy Another Dealer's PVSS Contribution via Stateless PoK Verification

## Summary
The stateless Schnorr Proof-of-Knowledge (PoK) verification in `pok_batch_verify()` does not track or bind proofs to dealer identities, allowing a malicious dealer to copy another dealer's entire PVSS contribution (commitment + PoK), re-sign it with their own BLS key, and pass all verification checks. This enables double-counting of contributions and breaks the DKG security assumption that each dealer contributes independent randomness.

## Finding Description

The DKG protocol relies on Schnorr PoKs to prove that each dealer knows the discrete logarithm of their committed secret. However, the verification is stateless and doesn't bind the PoK to the dealer's identity. [1](#0-0) 

The PoK structure contains only `(R, s)` where the challenge is computed as `H(R, pk, g)` - notably excluding any dealer identity: [2](#0-1) 

**Attack Path:**

1. Dealer A creates a valid transcript with commitment `c_A`, PoK `pok_A`, and BLS signature `sig_A` over `Contribution{comm: c_A, player: A, aux: (epoch, addr_A)}` [3](#0-2) 

2. Dealer B observes Dealer A's transcript and copies `c_A` and `pok_A` exactly

3. Dealer B creates their own BLS signature `sig_B` over `Contribution{comm: c_A, player: B, aux: (epoch, addr_B)}` - note the `aux` contains B's address: [4](#0-3) 

4. Both transcripts pass individual verification and enter aggregation

5. During aggregation, the dealt public keys are summed: [5](#0-4) 

6. The aggregated transcript has `V[n] = c_A + c_A = 2*c_A` and `soks = [(A, c_A, sig_A, pok_A), (B, c_A, sig_B, pok_A)]`

7. During verification, `batch_verify_soks` checks that the sum of commitments equals the dealt public key: [6](#0-5) 

8. The check passes: `c_A + c_A == 2*c_A` âœ“, both PoKs verify (they're valid for the same `c_A`), and both BLS signatures verify (different dealers signed their own contributions)

The transcript aggregator only prevents the same dealer from contributing twice but doesn't detect when different dealers submit identical commitments: [7](#0-6) 

## Impact Explanation

**High Severity** - This breaks critical DKG security properties:

1. **Randomness Compromise**: The final DKG output lacks independent randomness from all claimed dealers, as Dealer B contributed zero entropy
2. **Collusion Attack**: If Dealer A and Dealer B collude, they can predict the final randomness output since it's effectively `2*secret_A` instead of `secret_A + secret_B`
3. **Validator Set Manipulation**: In Aptos's randomness beacon for leader selection, compromised randomness could enable validator set manipulation
4. **Consensus Impact**: While not directly causing consensus splits, predictable randomness affects the security guarantees of consensus protocols that rely on unpredictable leader election

This meets **High Severity** criteria per Aptos bug bounty: "Significant protocol violations" affecting the randomness generation subsystem critical for consensus security.

## Likelihood Explanation

**High Likelihood:**

1. **No Special Access Required**: Any validator participating in DKG can execute this attack
2. **Simple Execution**: The attacker only needs to copy another dealer's commitment and PoK, then sign with their own key
3. **Network Observable**: Transcripts are broadcast over the network, making them easily observable by all validators
4. **No Detection**: The verification logic has no mechanism to detect identical commitments from different dealers
5. **Economic Incentive**: Malicious validators could gain advantage in leader selection by compromising randomness

The attack is straightforward to implement and requires no special cryptographic knowledge beyond basic transcript manipulation.

## Recommendation

**Solution**: Bind the Schnorr PoK to the dealer's identity by including it in the Fiat-Shamir challenge.

**Code Fix** in `crates/aptos-dkg/src/pvss/schnorr.rs`:

Modify the `Challenge` struct to include dealer identity:
```rust
#[derive(Serialize, Deserialize, BCSCryptoHash, CryptoHasher)]
#[allow(non_snake_case)]
struct Challenge<Gr> {
    R: Gr,      // g^r
    pk: Gr,     // g^a
    g: Gr,
    dealer_id: usize,  // ADD THIS
}
```

Update `pok_prove` to include dealer ID:
```rust
pub fn pok_prove<Gr, R>(a: &Scalar, g: &Gr, pk: &Gr, dealer_id: usize, rng: &mut R) -> PoK<Gr>
{
    let r = random_scalar(rng);
    let R = g.mul(&r);
    let e = schnorr_hash(Challenge::<Gr> { R, pk: *pk, g: *g, dealer_id });
    let s = r + e * a;
    (R, s)
}
```

Update `pok_batch_verify` to accept and verify dealer IDs:
```rust
pub fn pok_batch_verify<'a, Gr>(
    poks: &Vec<(usize, Gr, PoK<Gr>)>,  // Include dealer_id
    g: &Gr,
    gamma: &Scalar,
) -> anyhow::Result<()>
{
    // Include dealer_id in challenge computation
    let e_i = schnorr_hash(Challenge::<Gr> { R, pk, g: *g, dealer_id });
    // ... rest of verification
}
```

This ensures each PoK is uniquely bound to its dealer and cannot be reused.

## Proof of Concept

```rust
// Conceptual PoC demonstrating the attack
#[test]
fn test_dkg_proof_reuse_attack() {
    use aptos_dkg::pvss::*;
    
    // Setup: 3 validators, Dealer A, Dealer B, and Dealer C
    let mut rng = thread_rng();
    let pub_params = /* initialize DKG public parameters */;
    
    // Dealer A creates a legitimate transcript
    let sk_a = bls12381::PrivateKey::generate(&mut rng);
    let pk_a = bls12381::PublicKey::from(&sk_a);
    let secret_a = InputSecret::generate(&mut rng);
    
    let transcript_a = WTrx::deal(
        &config, &pub_params, &sk_a, &pk_a,
        &encryption_keys, &secret_a,
        &(epoch, addr_a), &Player { id: 0 }, &mut rng
    );
    
    // Dealer B COPIES Dealer A's commitment and PoK
    let sk_b = bls12381::PrivateKey::generate(&mut rng);
    let copied_commitment = transcript_a.get_dealt_public_key();
    let copied_pok = transcript_a.soks[0].3; // Copy the PoK
    
    // Dealer B creates their own signature over the COPIED commitment
    let sig_b = sk_b.sign(&Contribution {
        comm: copied_commitment,
        player: Player { id: 1 },
        aux: (epoch, addr_b)
    }).unwrap();
    
    // Construct malicious transcript with copied values
    let transcript_b = /* construct with copied_commitment and copied_pok */;
    
    // Both transcripts should verify individually
    assert!(transcript_a.verify(&config, &pub_params, &[pk_a], &eks, &auxs).is_ok());
    assert!(transcript_b.verify(&config, &pub_params, &[pk_b], &eks, &auxs).is_ok());
    
    // Aggregate transcripts
    let mut aggregated = transcript_a.clone();
    aggregated.aggregate_with(&config, &transcript_b).unwrap();
    
    // VULNERABILITY: Aggregated transcript verifies successfully!
    assert!(aggregated.verify(&config, &pub_params, &[pk_a, pk_b], &eks, &auxs).is_ok());
    
    // The final secret is 2*secret_a instead of secret_a + secret_b
    // Dealer B contributed ZERO randomness but appears as a valid contributor
}
```

**Notes:**
- The vulnerability exists because Schnorr PoKs are purely mathematical proofs of discrete logarithm knowledge that don't incorporate dealer identity
- While BLS signatures bind contributions to dealers, they only verify that each dealer signed *their claimed* contribution, not that contributions are unique
- The aggregation logic assumes all contributions are independent, which this attack violates
- This affects both weighted and unweighted DAS PVSS implementations in Aptos Core

### Citations

**File:** crates/aptos-dkg/src/pvss/schnorr.rs (L16-58)
```rust
/// A Schnorr PoK for (g, g^a) is a tuple:
///
///   $$(R = g^r, s = r + H(g^r, g^a, g) a)$$
pub type PoK<Gr> = (Gr, Scalar);

/// This is the Schnorr prover transcript that is hashed to obtain a Fiat-Shamir challenge.
/// TODO(TechDebt): Cannot have references here because CryptoHasher doesn't work with lifetimes.
#[derive(Serialize, Deserialize, BCSCryptoHash, CryptoHasher)]
#[allow(non_snake_case)]
struct Challenge<Gr> {
    R: Gr,  // g^r
    pk: Gr, // g^a
    g: Gr,
}

#[allow(non_snake_case)]
pub fn pok_prove<Gr, R>(a: &Scalar, g: &Gr, pk: &Gr, rng: &mut R) -> PoK<Gr>
where
    Gr: Serialize + Group + for<'a> Mul<&'a Scalar, Output = Gr>,
    R: rand_core::RngCore + rand_core::CryptoRng,
{
    debug_assert!(g.mul(a).eq(pk));

    let r = random_scalar(rng);
    let R = g.mul(&r);
    let e = schnorr_hash(Challenge::<Gr> { R, pk: *pk, g: *g });
    let s = r + e * a;

    (R, s)
}

/// Computes the Fiat-Shamir challenge in the Schnorr PoK protocol given an instance $(g, pk = g^a)$
/// and the commitment $R = g^r$.
#[allow(non_snake_case)]
fn schnorr_hash<Gr>(c: Challenge<Gr>) -> Scalar
where
    Gr: Serialize,
{
    let c = signing_message(&c)
        .expect("unexpected error during Schnorr challenge struct serialization");

    hash_to_scalar(&c, SCHNORR_POK_DST)
}
```

**File:** crates/aptos-dkg/src/pvss/schnorr.rs (L69-109)
```rust
pub fn pok_batch_verify<'a, Gr>(
    poks: &Vec<(Gr, PoK<Gr>)>,
    g: &Gr,
    gamma: &Scalar,
) -> anyhow::Result<()>
where
    Gr: Serialize + Group + Mul<&'a Scalar> + HasMultiExp,
{
    let n = poks.len();
    let mut exps = Vec::with_capacity(2 * n + 1);
    let mut bases = Vec::with_capacity(2 * n + 1);

    // Compute \gamma_i = \gamma^i, for all i \in [0, n]
    let mut gammas = Vec::with_capacity(n);
    gammas.push(Scalar::ONE);
    for _ in 0..(n - 1) {
        gammas.push(gammas.last().unwrap().mul(gamma));
    }

    let mut last_exp = Scalar::ZERO;
    for i in 0..n {
        let (pk, (R, s)) = poks[i];

        bases.push(R);
        exps.push(gammas[i]);

        bases.push(pk);
        exps.push(schnorr_hash(Challenge::<Gr> { R, pk, g: *g }) * gammas[i]);

        last_exp += s * gammas[i];
    }

    bases.push(*g);
    exps.push(last_exp.neg());

    if Gr::multi_exp_iter(bases.iter(), exps.iter()) != Gr::identity() {
        bail!("Schnorr PoK batch verification failed");
    }

    Ok(())
}
```

**File:** crates/aptos-dkg/src/pvss/das/unweighted_protocol.rs (L140-156)
```rust
        // Compute PoK of input secret committed in V[n]
        let pok = schnorr::pok_prove(&f[0], g_2, &V[sc.n], rng);

        debug_assert_eq!(V.len(), sc.n + 1);
        debug_assert_eq!(C.len(), sc.n);

        // Sign the secret commitment, player ID and `aux`
        let sig = Transcript::sign_contribution(ssk, dealer, aux, &V[sc.n]);

        Transcript {
            soks: vec![(*dealer, V[sc.n], sig, pok)],
            hat_w: g_2.mul(r),
            V,
            C,
            C_0: g_1.mul(r),
        }
    }
```

**File:** crates/aptos-dkg/src/pvss/das/unweighted_protocol.rs (L319-344)
```rust
    fn aggregate_with(
        &mut self,
        sc: &ThresholdConfigBlstrs,
        other: &Transcript,
    ) -> anyhow::Result<()> {
        debug_assert_eq!(self.C.len(), sc.n);
        debug_assert_eq!(self.V.len(), sc.n + 1);

        self.hat_w += other.hat_w;
        self.C_0 += other.C_0;

        for i in 0..sc.n {
            self.C[i] += other.C[i];
            self.V[i] += other.V[i];
        }
        self.V[sc.n] += other.V[sc.n];

        for sok in &other.soks {
            self.soks.push(sok.clone());
        }

        debug_assert_eq!(self.C.len(), other.C.len());
        debug_assert_eq!(self.V.len(), other.V.len());

        Ok(())
    }
```

**File:** types/src/dkg/real_dkg/mod.rs (L249-263)
```rust
        let my_index = my_index as usize;
        let my_addr = pub_params.session_metadata.dealer_validator_set[my_index].addr;
        let aux = (pub_params.session_metadata.dealer_epoch, my_addr);

        let wtrx = WTrx::deal(
            &pub_params.pvss_config.wconfig,
            &pub_params.pvss_config.pp,
            sk,
            pk,
            &pub_params.pvss_config.eks,
            input_secret,
            &aux,
            &Player { id: my_index },
            rng,
        );
```

**File:** crates/aptos-dkg/src/pvss/contribution.rs (L56-77)
```rust
    // First, the PoKs
    let mut c = Gr::identity();
    for (_, c_i, _, _) in soks {
        c.add_assign(c_i)
    }

    if c.ne(pk) {
        bail!(
            "The PoK does not correspond to the dealt secret. Expected {} but got {}",
            pk,
            c
        );
    }

    let poks = soks
        .iter()
        .map(|(_, c, _, pok)| (*c, *pok))
        .collect::<Vec<(Gr, schnorr::PoK<Gr>)>>();

    // TODO(Performance): 128-bit exponents instead of powers of tau
    schnorr::pok_batch_verify::<Gr>(&poks, pk_base, &tau)?;

```

**File:** dkg/src/transcript_aggregation/mod.rs (L91-101)
```rust
        let mut trx_aggregator = self.trx_aggregator.lock();
        if trx_aggregator.contributors.contains(&metadata.author) {
            return Ok(None);
        }

        S::verify_transcript_extra(&transcript, &self.epoch_state.verifier, false, Some(sender))
            .context("extra verification failed")?;

        S::verify_transcript(&self.dkg_pub_params, &transcript).map_err(|e| {
            anyhow!("[DKG] adding peer transcript failed with trx verification failure: {e}")
        })?;
```
