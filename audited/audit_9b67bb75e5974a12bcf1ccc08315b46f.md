# Audit Report

## Title
Premature Min-Readable-Version Update Causes False Data Unavailability in Ledger Pruner

## Summary
The `LedgerPrunerManager` updates `min_readable_version` before actual pruning occurs, causing read requests to be rejected for data that still exists in the database. This creates a race condition where metrics and availability checks become inconsistent with the actual database state.

## Finding Description

The vulnerability exists in the pruner lifecycle management. When transactions are committed, the system calls `maybe_set_pruner_target_db_version()` [1](#0-0) , which can trigger `set_pruner_target_db_version()`.

The critical flaw is in `set_pruner_target_db_version()` [2](#0-1) , which:
1. Calculates `min_readable_version = latest_version - prune_window`
2. **Immediately** updates the in-memory atomic `min_readable_version`
3. Updates the `PRUNER_VERSIONS` metric with label "min_readable"
4. **Then** sets the worker thread target to begin pruning

The pruning happens **asynchronously** in a separate worker thread [3](#0-2) . During the time window between step 2 and when pruning actually completes, the system is in an inconsistent state.

Read operations use `error_if_ledger_pruned()` [4](#0-3)  which checks `min_readable_version` to determine if data is available. This check will **falsely reject** read requests for data that still exists in the database.

If the pruning operation fails (disk errors, crashes, etc.), the data remains in the database permanently, but `min_readable_version` continues to indicate it was pruned, making the data inaccessible until node restart.

The actual pruning in `LedgerPruner::prune()` updates metrics only **after** successful completion [5](#0-4) , but this update is for the "progress" metric, not "min_readable" which was already updated prematurely.

## Impact Explanation

This qualifies as **Medium Severity** per the Aptos bug bounty criteria: "State inconsistencies requiring intervention."

**Specific impacts:**
1. **False Data Unavailability**: Legitimate read requests are rejected with "data is pruned" errors even though the data exists in the database
2. **Incorrect Metrics**: Monitoring systems receive false information about pruning progress via `PRUNER_VERSIONS` metrics
3. **Non-deterministic Behavior**: The window of inconsistency depends on worker thread scheduling, making debugging difficult
4. **Persistent Unavailability on Failure**: If pruning fails but `min_readable_version` was updated, data becomes inaccessible until node restart

The inconsistency resolves on restart because initialization reads from the database's actual pruning progress [6](#0-5) , which only reflects successfully completed pruning operations.

## Likelihood Explanation

This issue occurs **automatically** during normal node operation whenever the pruning threshold is reached. The likelihood is **high** because:

1. The pruner activates periodically based on the condition in `maybe_set_pruner_target_db_version()` [7](#0-6) 
2. The race window exists on every pruning cycle
3. If disk I/O is slow or the node experiences high load, the window can be significant (seconds to minutes)
4. Pruning failures (disk full, permission errors, crashes) leave the system in a permanently inconsistent state

## Recommendation

The fix requires deferring the `min_readable_version` update until pruning actually completes. Implement a callback mechanism:

1. Remove the premature update from `set_pruner_target_db_version()`
2. After successful pruning completion in `LedgerPruner::prune()`, add a callback to the manager
3. The manager should then update `min_readable_version` and metrics only after confirming successful pruning

Modified flow in `ledger_pruner_manager.rs`:
- `set_pruner_target_db_version()` should only set the worker target, not update `min_readable_version`
- Add `confirm_pruning_completed(version)` method that updates `min_readable_version` after verification
- Call this method from the worker thread after successful `prune()` completion

This ensures the happens-before relationship: actual pruning → min_readable_version update → read rejection.

## Proof of Concept

```rust
// Reproduction steps in Rust integration test:
// 
// 1. Configure pruner with prune_window=100, batch_size=1000
// 2. Commit transactions up to version 1200
// 3. Trigger maybe_set_pruner_target_db_version(1200)
// 4. Immediately after, before worker thread runs:
//    - Query min_readable_version: returns 1100
//    - Attempt to read transaction at version 1000
//    - Expected: Success (data exists)
//    - Actual: Error "data is pruned at min version 1100"
// 5. Query database directly: transaction at version 1000 exists
// 6. Check PRUNER_VERSIONS metric: shows 1100 as min_readable
// 7. Inject pruning failure (simulate disk error in worker)
// 8. Verify data remains inaccessible indefinitely
// 9. Restart node
// 10. Verify data becomes accessible again (min_readable resets to 0)
```

## Notes

The root cause is violating the atomicity principle: the metadata update (`min_readable_version`) should be atomic with the actual data modification (pruning). The current implementation updates metadata **before** the data modification completes, breaking this invariant.

The separate metrics for "min_readable", "target", and "progress" create confusion. The "min_readable" metric should reflect actual pruning completion (like "progress"), not the pruning target.

### Citations

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L628-629)
```rust
            self.ledger_pruner
                .maybe_set_pruner_target_db_version(version);
```

**File:** storage/aptosdb/src/pruner/ledger_pruner/ledger_pruner_manager.rs (L72-77)
```rust
        if self.is_pruner_enabled()
            && latest_version
                >= min_readable_version + self.pruning_batch_size as u64 + self.prune_window
        {
            self.set_pruner_target_db_version(latest_version);
        }
```

**File:** storage/aptosdb/src/pruner/ledger_pruner/ledger_pruner_manager.rs (L123-128)
```rust
        let min_readable_version =
            pruner_utils::get_ledger_pruner_progress(&ledger_db).expect("Must succeed.");

        PRUNER_VERSIONS
            .with_label_values(&["ledger_pruner", "min_readable"])
            .set(min_readable_version as i64);
```

**File:** storage/aptosdb/src/pruner/ledger_pruner/ledger_pruner_manager.rs (L162-176)
```rust
    fn set_pruner_target_db_version(&self, latest_version: Version) {
        assert!(self.pruner_worker.is_some());
        let min_readable_version = latest_version.saturating_sub(self.prune_window);
        self.min_readable_version
            .store(min_readable_version, Ordering::SeqCst);

        PRUNER_VERSIONS
            .with_label_values(&["ledger_pruner", "min_readable"])
            .set(min_readable_version as i64);

        self.pruner_worker
            .as_ref()
            .unwrap()
            .set_target_db_version(min_readable_version);
    }
```

**File:** storage/aptosdb/src/pruner/pruner_worker.rs (L53-68)
```rust
    fn work(&self) {
        while !self.quit_worker.load(Ordering::SeqCst) {
            let pruner_result = self.pruner.prune(self.batch_size);
            if pruner_result.is_err() {
                sample!(
                    SampleRate::Duration(Duration::from_secs(1)),
                    error!(error = ?pruner_result.err().unwrap(),
                        "Pruner has error.")
                );
                sleep(Duration::from_millis(self.pruning_time_interval_in_ms));
                continue;
            }
            if !self.pruner.is_pruning_pending() {
                sleep(Duration::from_millis(self.pruning_time_interval_in_ms));
            }
        }
```

**File:** storage/aptosdb/src/db/aptosdb_internal.rs (L261-271)
```rust
    pub(super) fn error_if_ledger_pruned(&self, data_type: &str, version: Version) -> Result<()> {
        let min_readable_version = self.ledger_pruner.get_min_readable_version();
        ensure!(
            version >= min_readable_version,
            "{} at version {} is pruned, min available version is {}.",
            data_type,
            version,
            min_readable_version
        );
        Ok(())
    }
```

**File:** storage/aptosdb/src/pruner/ledger_pruner/mod.rs (L86-88)
```rust
            progress = current_batch_target_version;
            self.record_progress(progress);
            info!(progress = progress, "Pruning ledger data is done.");
```
