# Audit Report

## Title
HotStateLRU Cache Memory Exhaustion Due to Item-Count-Based Capacity Limit

## Summary
The `HotStateLRU` cache uses an item-count-based capacity limit rather than a byte-based memory limit, allowing the cache to consume excessive memory when `StateSlot` entries contain large values. While capacity is enforced at 250,000 items per shard by default, there is no limit on the total byte size, enabling theoretical memory consumption of up to 250GB per shard (4TB across 16 shards) if maximum-sized state values (1MB each) are cached.

## Finding Description
The `HotStateLRU` struct enforces capacity limits based on the number of items (`num_items`) rather than total memory consumption in bytes. [1](#0-0) 

The eviction logic only checks if the item count exceeds capacity: [2](#0-1) 

Each `StateSlot` can contain a `StateValue` with data up to 1MB in size, as enforced by the transaction gas parameters: [3](#0-2) 

The default capacity is 250,000 items per shard: [4](#0-3) 

While the `Committer` tracks total byte sizes for metrics, these are not used to enforce any memory limits: [5](#0-4) [6](#0-5) 

**Attack Vector**: A user could create transactions writing state values approaching the 1MB maximum size. Over time, with 250,000 such entries per shard (16 shards total), the cache could theoretically consume 250GB × 16 = 4TB of memory, potentially causing out-of-memory (OOM) conditions on validator nodes.

## Impact Explanation
This issue is classified as **Low Severity** per the bug bounty criteria for the following reasons:

1. **Economic Barrier**: Writing large state values incurs substantial storage fees (based on `storage_fee_per_state_slot` and `storage_fee_per_state_byte`), making it economically prohibitive to fill the cache with maximum-sized values.

2. **Limited Scope**: The issue affects individual validator nodes through memory exhaustion, not the broader network consensus or safety. Other validators would continue operating normally.

3. **Operational Mitigation**: Node operators can monitor memory metrics (`hot_state_key_bytes` and `hot_state_value_bytes` gauges) and take corrective action (restart, adjust capacity limits) before OOM occurs.

4. **No Consensus Impact**: This does not violate consensus safety, deterministic execution, or state consistency invariants—only resource management.

Per the Aptos bug bounty program, this falls under Low Severity: "Non-critical implementation bugs" with limited security impact.

## Likelihood Explanation
The likelihood of exploitation is **very low** because:

1. **Cost**: Writing 250,000 state values of 1MB each requires paying gas for 250GB of state writes. Even with discounted pricing, this would cost millions of APT tokens.

2. **Detection**: The byte-level metrics expose this behavior, allowing operators to detect abnormal memory growth before critical thresholds are reached.

3. **Self-Limiting**: An attacker must sustain continuous high-cost transactions to maintain the attack, which is economically unsustainable.

4. **Legitimate Use Cases**: In practice, most state values are much smaller than 1MB, keeping actual memory consumption well below theoretical maximums.

## Recommendation
Implement a byte-based memory limit in addition to the item-count limit:

```rust
pub struct HotStateLRU<'a> {
    capacity: NonZeroUsize,
    max_bytes: Option<usize>,  // Add byte-based limit
    committed: Arc<dyn HotStateView>,
    overlay: &'a LayeredMap<StateKey, StateSlot>,
    pending: HashMap<StateKey, StateSlot>,
    head: Option<StateKey>,
    tail: Option<StateKey>,
    num_items: usize,
    total_bytes: usize,  // Track current byte usage
}
```

Modify `maybe_evict()` to check both conditions:

```rust
pub fn maybe_evict(&mut self) -> Vec<(StateKey, StateSlot)> {
    let mut evicted = Vec::new();
    while self.num_items > self.capacity.get() 
       || (self.max_bytes.is_some() && self.total_bytes > self.max_bytes.unwrap()) {
        // ... existing eviction logic ...
    }
    evicted
}
```

Update `total_bytes` on insert/delete operations by adding `key.size() + slot.size()`.

Configure `max_bytes` in `HotStateConfig` with a reasonable default (e.g., 10GB per shard).

## Proof of Concept
A theoretical PoC would involve:

1. Create 250,000 unique state keys per shard
2. Write maximum-sized values (1MB each) to these keys via transactions
3. Monitor node memory usage via `/metrics` endpoint
4. Observe cache consuming ~250GB per shard

**Practical Note**: This PoC is not feasible to execute due to prohibitive gas costs (estimated at millions of APT tokens) and would take substantial time to complete. The vulnerability is confirmed through code analysis rather than practical demonstration.

## Notes
- This is a **design limitation** rather than a critical security flaw
- The byte-tracking metrics already exist but are only used for monitoring, not enforcement
- The comment at line 24 of `storage_config.rs` shows awareness of memory consumption for other LRU caches, but similar consideration was not applied to the hot state cache
- This issue would only manifest under extreme conditions (intentional attack or bug causing large state values)
- The Low severity classification is appropriate given the economic and operational barriers to exploitation

### Citations

**File:** storage/storage-interface/src/state_store/hot_state.rs (L11-27)
```rust
pub(crate) struct HotStateLRU<'a> {
    /// Max total number of items in the cache.
    capacity: NonZeroUsize,
    /// The entire committed hot state. While this contains all the shards, this struct is supposed
    /// to handle a single shard.
    committed: Arc<dyn HotStateView>,
    /// Additional entries resulted from previous speculative execution.
    overlay: &'a LayeredMap<StateKey, StateSlot>,
    /// The new entries from current execution.
    pending: HashMap<StateKey, StateSlot>,
    /// Points to the latest entry. `None` if empty.
    head: Option<StateKey>,
    /// Points to the oldest entry. `None` if empty.
    tail: Option<StateKey>,
    /// Total number of items.
    num_items: usize,
}
```

**File:** storage/storage-interface/src/state_store/hot_state.rs (L82-106)
```rust
    pub fn maybe_evict(&mut self) -> Vec<(StateKey, StateSlot)> {
        let mut current = match &self.tail {
            Some(tail) => tail.clone(),
            None => {
                assert_eq!(self.num_items, 0);
                return Vec::new();
            },
        };

        let mut evicted = Vec::new();
        while self.num_items > self.capacity.get() {
            let slot = self
                .delete(&current)
                .expect("There must be entries to evict when current size is above capacity.");
            let prev_key = slot
                .prev()
                .cloned()
                .expect("There must be at least one newer entry (num_items > capacity >= 1).");
            evicted.push((current.clone(), slot.clone()));
            self.pending.insert(current, slot.to_cold());
            current = prev_key;
            self.num_items -= 1;
        }
        evicted
    }
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L154-157)
```rust
            max_bytes_per_write_op: NumBytes,
            { 5.. => "max_bytes_per_write_op" },
            1 << 20, // a single state item is 1MB max
        ],
```

**File:** config/src/config/storage_config.rs (L256-264)
```rust
impl Default for HotStateConfig {
    fn default() -> Self {
        Self {
            max_items_per_shard: 250_000,
            refresh_interval_versions: 100_000,
            delete_on_restart: true,
            compute_root_hash: true,
        }
    }
```

**File:** storage/aptosdb/src/state_store/hot_state.rs (L160-170)
```rust
pub struct Committer {
    base: Arc<HotStateBase>,
    committed: Arc<Mutex<State>>,
    rx: Receiver<State>,
    total_key_bytes: usize,
    total_value_bytes: usize,
    /// Points to the newest entry. `None` if empty.
    heads: [Option<StateKey>; NUM_STATE_SHARDS],
    /// Points to the oldest entry. `None` if empty.
    tails: [Option<StateKey>; NUM_STATE_SHARDS],
}
```

**File:** storage/aptosdb/src/state_store/hot_state.rs (L199-201)
```rust
            GAUGE.set_with(&["hot_state_items"], self.base.len() as i64);
            GAUGE.set_with(&["hot_state_key_bytes"], self.total_key_bytes as i64);
            GAUGE.set_with(&["hot_state_value_bytes"], self.total_value_bytes as i64);
```
