# Audit Report

## Title
Transaction Filter Bypass via First-Match-Wins Rule Ordering Exploitation

## Summary
The `allows_transaction()` function in the transaction filter implements a first-match-wins evaluation strategy that can be exploited by attackers to bypass deny rules when broader allow rules are positioned earlier in the filter list. This affects critical security boundaries in mempool, consensus, and execution layers.

## Finding Description

The transaction filter system processes rules sequentially and returns on the first match, as documented in the code. [1](#0-0) 

The vulnerability arises from the interaction between:
1. First-match-wins evaluation logic [2](#0-1) 
2. Matcher granularity differences, particularly the `AccountAddress` matcher which checks multiple transaction fields [3](#0-2) 

**Attack Scenario:**

An operator intends to allow system framework transactions but deny a specific dangerous function, configuring:
```
Rule 1: Allow(AccountAddress(0x1))
Rule 2: Deny(EntryFunction(0x1, "governance", "force_execute"))
```

An attacker crafting a transaction calling `0x1::governance::force_execute`:
- Rule 1's `AccountAddress` matcher evaluates the transaction
- Since the entry function's module address is `0x1`, the matcher returns true
- Rule 1 matches → transaction ALLOWED
- Rule 2 never evaluated → deny bypassed

This applies to all filter layers where transactions are validated: [4](#0-3) 

The filters are deployed in critical security boundaries: [5](#0-4) 

## Impact Explanation

**High Severity** - This enables bypassing transaction validation filters at multiple critical layers:

1. **Mempool Filter Bypass**: Unauthorized transactions can enter the transaction pool, potentially flooding mempool with malicious transactions
2. **Consensus Filter Bypass**: Malicious transactions can be included in blocks despite deny rules, affecting all validators
3. **Execution Filter Bypass**: Unauthorized state transitions could be executed

The vulnerability breaks the **Transaction Validation** invariant: security filters must enforce all access control policies to prevent unauthorized transactions from being processed.

While the code works as documented, the design creates an exploitable attack surface where operators' intuitive security configurations (allow broad category, deny specific threats) result in complete filter bypasses.

## Likelihood Explanation

**High Likelihood** - Exploitation requires:
- No privileged access
- No validator collusion  
- Only understanding of matcher semantics

Operators naturally configure "allow then deny" patterns when thinking about security policies, making misconfiguration likely. The `AccountAddress` matcher's broad matching semantics (sender, module address, multisig, script args, authenticator) amplifies the attack surface.

Evidence of configuration vulnerability: smoke tests demonstrate correct patterns [6](#0-5)  but operators may not follow this pattern without explicit guidance.

## Recommendation

**Short-term**: Add explicit documentation and validation checks:

1. Add configuration validation to detect dangerous patterns:
```rust
impl TransactionFilter {
    pub fn validate(&self) -> Result<(), String> {
        // Check for broad Allow rules before specific Deny rules
        let mut found_allow_all = false;
        for rule in &self.transaction_rules {
            match rule {
                TransactionRule::Allow(matchers) if matchers.iter().any(|m| matches!(m, TransactionMatcher::All)) => {
                    found_allow_all = true;
                }
                TransactionRule::Deny(_) if found_allow_all => {
                    return Err("Deny rules after Allow(All) will never be evaluated".to_string());
                }
                _ => {}
            }
        }
        Ok(())
    }
}
```

2. Add warnings when broader Allow rules precede narrower Deny rules

**Long-term**: Consider alternative evaluation strategies:
- Evaluate all Deny rules first, then Allow rules
- Require explicit rule priorities
- Default-deny with explicit allows only

## Proof of Concept

```rust
#[test]
fn test_filter_bypass_via_broad_allow() {
    use aptos_transaction_filters::transaction_filter::{TransactionFilter, TransactionMatcher};
    use aptos_types::{
        account_address::AccountAddress,
        transaction::{TransactionPayload, SignedTransaction, Script},
    };
    use aptos_crypto::{ed25519::Ed25519PrivateKey, PrivateKey, SigningKey};
    use aptos_types::chain_id::ChainId;

    // Create a transaction calling a protected entry function at address 0x1
    let system_address = AccountAddress::from_hex_literal("0x1").unwrap();
    let private_key = Ed25519PrivateKey::generate_for_testing();
    
    // Simulate transaction calling 0x1::governance::admin_function
    let entry_function = aptos_types::transaction::EntryFunction::new(
        aptos_types::transaction::ModuleId::new(system_address, "governance".parse().unwrap()),
        "admin_function".parse().unwrap(),
        vec![],
        vec![],
    );
    
    let raw_txn = aptos_types::transaction::RawTransaction::new(
        AccountAddress::random(),
        0,
        TransactionPayload::EntryFunction(entry_function),
        1_000_000,
        1,
        0,
        ChainId::new(1),
    );
    
    let signature = private_key.sign(&raw_txn).unwrap();
    let signed_txn = SignedTransaction::new(raw_txn, private_key.public_key(), signature);

    // VULNERABLE CONFIGURATION: Broad allow before specific deny
    let vulnerable_filter = TransactionFilter::empty()
        .add_account_address_filter(true, system_address)  // Allow 0x1 transactions
        .add_entry_function_filter(false, system_address, "governance".to_string(), "admin_function".to_string());  // Deny admin_function
    
    // Attack succeeds: transaction is ALLOWED despite deny rule
    assert!(vulnerable_filter.allows_transaction(&signed_txn)); // BYPASS!

    // SECURE CONFIGURATION: Specific deny before broad allow  
    let secure_filter = TransactionFilter::empty()
        .add_entry_function_filter(false, system_address, "governance".to_string(), "admin_function".to_string())  // Deny admin_function FIRST
        .add_account_address_filter(true, system_address);  // Then allow 0x1 transactions
    
    // Correctly blocked
    assert!(!secure_filter.allows_transaction(&signed_txn)); // BLOCKED
}
```

## Notes

This vulnerability exists at the intersection of design and implementation. While the first-match-wins behavior is documented [7](#0-6) , the design creates an exploitable attack surface where intuitive security configurations result in complete bypasses. The `AccountAddress` matcher's broad semantics particularly amplify this risk by matching transactions in multiple contexts beyond what operators might expect.

### Citations

**File:** crates/aptos-transaction-filters/src/transaction_filter.rs (L13-22)
```rust
/// A transaction filter that applies a set of rules to determine
/// if a transaction should be allowed or denied.
///
/// Rules are applied in the order they are defined, and the first
/// matching rule determines the outcome for the transaction.
/// If no rules match, the transaction is allowed by default.
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
pub struct TransactionFilter {
    transaction_rules: Vec<TransactionRule>,
}
```

**File:** crates/aptos-transaction-filters/src/transaction_filter.rs (L36-47)
```rust
        // Check if any rule matches the transaction
        for transaction_rule in &self.transaction_rules {
            if transaction_rule.matches(signed_transaction) {
                return match transaction_rule {
                    TransactionRule::Allow(_) => true,
                    TransactionRule::Deny(_) => false,
                };
            }
        }

        true // No rules match (allow the transaction by default)
    }
```

**File:** crates/aptos-transaction-filters/src/transaction_filter.rs (L197-203)
```rust
            TransactionMatcher::AccountAddress(address) => {
                matches_sender_address(signed_transaction, address)
                    || matches_entry_function_module_address(signed_transaction, address)
                    || matches_multisig_address(signed_transaction, address)
                    || matches_script_argument_address(signed_transaction, address)
                    || matches_transaction_authenticator_address(signed_transaction, address)
            },
```

**File:** mempool/src/shared_mempool/tasks.rs (L408-466)
```rust
fn filter_transactions(
    transaction_filter_config: &TransactionFilterConfig,
    transactions: Vec<(
        SignedTransaction,
        Option<u64>,
        Option<BroadcastPeerPriority>,
    )>,
    statuses: &mut Vec<(SignedTransaction, (MempoolStatus, Option<StatusCode>))>,
) -> Vec<(
    SignedTransaction,
    Option<u64>,
    Option<BroadcastPeerPriority>,
)> {
    // If the filter is not enabled, return early
    if !transaction_filter_config.is_enabled() {
        return transactions;
    }

    // Start the filter processing timer
    let transaction_filter_timer = counters::PROCESS_TXN_BREAKDOWN_LATENCY
        .with_label_values(&[counters::FILTER_TRANSACTIONS_LABEL])
        .start_timer();

    // Filter the transactions and update the statuses accordingly
    let transactions = transactions
        .into_iter()
        .filter_map(|(transaction, account_sequence_number, priority)| {
            if transaction_filter_config
                .transaction_filter()
                .allows_transaction(&transaction)
            {
                Some((transaction, account_sequence_number, priority))
            } else {
                info!(LogSchema::event_log(
                    LogEntry::TransactionFilter,
                    LogEvent::TransactionRejected
                )
                .message(&format!(
                    "Transaction {} rejected by filter",
                    transaction.committed_hash()
                )));

                statuses.push((
                    transaction.clone(),
                    (
                        MempoolStatus::new(MempoolStatusCode::RejectedByFilter),
                        None,
                    ),
                ));
                None
            }
        })
        .collect();

    // Update the filter processing latency metrics
    transaction_filter_timer.stop_and_record();

    transactions
}
```

**File:** config/src/config/transaction_filters_config.rs (L10-18)
```rust
#[derive(Clone, Debug, Default, Deserialize, PartialEq, Eq, Serialize)]
#[serde(default, deny_unknown_fields)]
pub struct TransactionFiltersConfig {
    pub api_filter: TransactionFilterConfig, // Filter for the API (e.g., txn simulation)
    pub consensus_filter: BlockTransactionFilterConfig, // Filter for consensus (e.g., proposal voting)
    pub execution_filter: BlockTransactionFilterConfig, // Filter for execution (e.g., block execution)
    pub mempool_filter: TransactionFilterConfig,        // Filter for mempool (e.g., txn submission)
    pub quorum_store_filter: BatchTransactionFilterConfig, // Filter for quorum store (e.g., batch voting)
}
```

**File:** testsuite/smoke-test/src/transaction_filter.rs (L246-258)
```rust
/// Adds a filter to the consensus config to ignore transactions from the given sender
fn filter_inline_transactions(node_config: &mut NodeConfig, sender_address: AccountAddress) {
    // Create the block transaction filter
    let block_transaction_filter = BlockTransactionFilter::empty()
        .add_multiple_matchers_filter(false, vec![BlockTransactionMatcher::Transaction(
            TransactionMatcher::Sender(sender_address),
        )])
        .add_all_filter(true);

    // Update the node config with the new filter
    node_config.transaction_filters.consensus_filter =
        BlockTransactionFilterConfig::new(true, block_transaction_filter);
}
```
