# Audit Report

## Title
Consensus Private Keys Stored in Plaintext on Disk via OnDiskStorage Backend

## Summary
The `OnDiskStorage::write()` function serializes consensus private keys to JSON without encryption, storing them as plaintext hex-encoded strings on the filesystem. While the documentation warns against production use, the mainnet configuration sanitizer does not prevent OnDiskStorage from being used by validators, and example configurations demonstrate its usage. This allows any attacker with filesystem read access to steal consensus private keys and compromise validator consensus participation.

## Finding Description

The vulnerability exists across multiple components:

**1. Plaintext Serialization in OnDiskStorage** [1](#0-0) 

The `write()` function uses `serde_json::to_vec()` without any encryption layer. Data is written to disk via `File::create()` with no file permission restrictions.

**2. Key Encoding Without Encryption** [2](#0-1) 

The `SerializeKey` macro generates Serde serialization that converts private keys to hex-encoded strings via `to_encoded_string()` for human-readable formats (JSON): [3](#0-2) 

This produces plaintext output like `"0x<hex_encoded_32_bytes>"` with no encryption.

**3. Consensus Keys Stored via OnDiskStorage** [4](#0-3) 

The `PersistentSafetyStorage::initialize_keys_and_accounts()` function stores the BLS12-381 consensus private key using `internal_store.set(CONSENSUS_KEY, consensus_private_key)`, where `internal_store` can be an OnDiskStorage instance.

**4. Configuration Sanitizer Weakness** [5](#0-4) 

The mainnet configuration sanitizer only blocks `InMemoryStorage` but **does not prevent OnDiskStorage** from being used in production, despite explicit warnings: [6](#0-5) 

**5. Production Configuration Examples** [7](#0-6) 

Example validator configurations demonstrate OnDiskStorage usage with the `secure-data.json` file path.

**Attack Path:**
1. Attacker gains filesystem read access to validator node (via container escape, process compromise, backup leak, or other vulnerability)
2. Reads the OnDiskStorage file (e.g., `/opt/aptos/data/secure-data.json`)
3. Parses JSON to extract consensus private key stored as hex string
4. Reconstructs BLS12-381 private key from hex bytes
5. Uses stolen key to sign arbitrary consensus messages, enabling:
   - Equivocation (signing conflicting blocks at same round)
   - Double-signing attacks
   - Consensus safety violations
   - Potential chain splits if attacker controls multiple compromised validators

## Impact Explanation

This vulnerability meets **CRITICAL severity** criteria per the Aptos Bug Bounty program:

- **Consensus/Safety Violations**: An attacker with the consensus private key can violate AptosBFT safety guarantees by double-signing or equivocating, breaking the fundamental invariant that "AptosBFT must prevent double-spending and chain splits under < 1/3 Byzantine."

- **Validator Node Compromise**: Complete compromise of validator consensus participation. The stolen key allows the attacker to impersonate the validator indefinitely.

- **Cryptographic Correctness Violation**: Breaks the invariant that "BLS signatures, VRF, and hash operations must be secure" by exposing the private signing key material.

The impact is amplified because:
- Consensus keys are long-lived and not rotated frequently
- Compromise of even a single validator key can enable targeted attacks
- Filesystem access vulnerabilities are common (container escapes, privilege escalation, backup exposure)
- The gap between documentation warnings and code enforcement creates a false sense of security

## Likelihood Explanation

**HIGH likelihood** in practice:

1. **Configuration Gap**: The sanitizer blocks `InMemoryStorage` but not `OnDiskStorage`, suggesting developers recognized the need for persistent storage but failed to enforce the secure option (Vault).

2. **Example Configurations**: Official example configs demonstrate OnDiskStorage usage, increasing the likelihood that operators deploy it incorrectly.

3. **Common Attack Vector**: Filesystem read access is a frequent attack outcome from:
   - Container escape vulnerabilities
   - Process privilege escalation
   - Backup/snapshot exposure
   - Log aggregation systems capturing config files
   - Kubernetes secret misconfigurations
   - Side-channel attacks on shared infrastructure

4. **No Defense in Depth**: Unlike Vault which provides encryption-at-rest, access controls, and audit logging, OnDiskStorage provides zero security layers beyond OS file permissions (which aren't even explicitly set).

## Recommendation

**Immediate Fix - Enforce Vault Storage for Mainnet:**

Modify the configuration sanitizer to block OnDiskStorage on mainnet validators:

```rust
// In config/src/config/safety_rules_config.rs, around line 86-96
if chain_id.is_mainnet()
    && node_type.is_validator()
    && (safety_rules_config.backend.is_in_memory() 
        || matches!(safety_rules_config.backend, SecureBackend::OnDiskStorage(_)))
{
    return Err(Error::ConfigSanitizerFailed(
        sanitizer_name,
        "The secure backend must use Vault storage for mainnet validators. OnDiskStorage provides no encryption or security guarantees."
            .to_string(),
    ));
}
```

**Additional Hardening Measures:**

1. **Set Restrictive File Permissions**: If OnDiskStorage must be supported for testing, set permissions to 0600 (owner read/write only):
```rust
#[cfg(unix)]
use std::os::unix::fs::PermissionsExt;

// After File::create in write()
#[cfg(unix)]
std::fs::set_permissions(&self.file_path, std::fs::Permissions::from_mode(0o600))?;
```

2. **Runtime Warning**: Add a loud warning when OnDiskStorage is instantiated to remind operators of the risk.

3. **Documentation**: Update validator deployment guides to explicitly require Vault storage and explain the security implications.

## Proof of Concept

```rust
// File: consensus/safety-rules/src/test_ondisk_key_leak.rs
#[cfg(test)]
mod test_ondisk_key_leak {
    use aptos_config::config::{SafetyRulesConfig, SecureBackend, OnDiskStorageConfig};
    use aptos_crypto::{bls12381, PrivateKey, Uniform};
    use aptos_secure_storage::{KVStorage, OnDiskStorage, Storage};
    use aptos_global_constants::CONSENSUS_KEY;
    use aptos_temppath::TempPath;
    use std::fs;
    
    #[test]
    fn test_consensus_key_stored_plaintext() {
        // Create a temporary file for OnDiskStorage
        let temp_path = TempPath::new();
        temp_path.create_as_file().unwrap();
        let storage_path = temp_path.path().to_path_buf();
        
        // Initialize OnDiskStorage
        let mut storage = Storage::from(OnDiskStorage::new(storage_path.clone()));
        
        // Generate a consensus private key
        let mut rng = rand::rngs::OsRng;
        let consensus_key = bls12381::PrivateKey::generate(&mut rng);
        let consensus_key_bytes = consensus_key.to_bytes();
        
        // Store the key (simulating what PersistentSafetyStorage does)
        storage.set(CONSENSUS_KEY, consensus_key.clone()).unwrap();
        
        // Simulate attacker: read the file directly
        let file_contents = fs::read_to_string(&storage_path).unwrap();
        
        // Verify key is in plaintext JSON
        assert!(file_contents.contains("0x"), "Key should be hex-encoded");
        assert!(file_contents.contains(&hex::encode(&consensus_key_bytes)), 
                "Key bytes should be present in plaintext");
        
        // Demonstrate key extraction
        let json: serde_json::Value = serde_json::from_str(&file_contents).unwrap();
        let key_value = &json[CONSENSUS_KEY]["value"];
        let key_str = key_value.as_str().unwrap();
        
        // Remove "0x" prefix and decode
        let key_hex = key_str.strip_prefix("0x").unwrap();
        let decoded_bytes = hex::decode(key_hex).unwrap();
        let recovered_key = bls12381::PrivateKey::try_from(decoded_bytes.as_slice()).unwrap();
        
        // Prove the attacker recovered the same key
        assert_eq!(consensus_key.to_bytes(), recovered_key.to_bytes());
        println!("âœ“ VULNERABILITY CONFIRMED: Consensus private key extracted from plaintext file");
    }
}
```

This proof of concept demonstrates that:
1. Consensus keys are stored via OnDiskStorage
2. The storage file contains plaintext hex-encoded keys
3. An attacker with filesystem access can trivially extract and reconstruct the private key
4. The recovered key is identical to the original, enabling full consensus participation impersonation

**Notes**

The vulnerability exists because of a gap between documentation and enforcement. While the README warns against production use of OnDiskStorage, the configuration validation system does not prevent its deployment on mainnet validators. Combined with example configurations that demonstrate OnDiskStorage usage and the lack of encryption in the storage layer, this creates a critical security risk where consensus private keys can be stolen via filesystem access, enabling consensus safety violations and validator compromise.

### Citations

**File:** secure/storage/src/on_disk.rs (L64-70)
```rust
    fn write(&self, data: &HashMap<String, Value>) -> Result<(), Error> {
        let contents = serde_json::to_vec(data)?;
        let mut file = File::create(self.temp_path.path())?;
        file.write_all(&contents)?;
        fs::rename(&self.temp_path, &self.file_path)?;
        Ok(())
    }
```

**File:** crates/aptos-crypto-derive/src/lib.rs (L185-210)
```rust
#[proc_macro_derive(SerializeKey)]
pub fn serialize_key(source: TokenStream) -> TokenStream {
    let ast: DeriveInput = syn::parse(source).expect("Incorrect macro input");
    let name = &ast.ident;
    let name_string = find_key_name(&ast, name.to_string());
    quote! {
        impl ::serde::Serialize for #name {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: ::serde::Serializer,
            {
                if serializer.is_human_readable() {
                    self.to_encoded_string()
                        .map_err(<S::Error as ::serde::ser::Error>::custom)
                        .and_then(|str| serializer.serialize_str(&str[..]))
                } else {
                    // See comment in deserialize_key.
                    serializer.serialize_newtype_struct(
                        #name_string,
                        serde_bytes::Bytes::new(&ValidCryptoMaterial::to_bytes(self).as_slice()),
                    )
                }
            }
        }
    }
    .into()
```

**File:** crates/aptos-crypto/src/traits/mod.rs (L102-104)
```rust
    fn to_encoded_string(&self) -> Result<String> {
        Ok(format!("0x{}", ::hex::encode(self.to_bytes())))
    }
```

**File:** consensus/safety-rules/src/persistent_safety_storage.rs (L63-81)
```rust
    fn initialize_keys_and_accounts(
        internal_store: &mut Storage,
        author: Author,
        consensus_private_key: bls12381::PrivateKey,
    ) -> Result<(), Error> {
        let result = internal_store.set(CONSENSUS_KEY, consensus_private_key);
        // Attempting to re-initialize existing storage. This can happen in environments like
        // forge. Rather than be rigid here, leave it up to the developer to detect
        // inconsistencies or why they did not reset storage between rounds. Do not repeat the
        // checks again below, because it is just too strange to have a partially configured
        // storage.
        if let Err(aptos_secure_storage::Error::KeyAlreadyExists(_)) = result {
            warn!("Attempted to re-initialize existing storage");
            return Ok(());
        }

        internal_store.set(OWNER_ACCOUNT, author)?;
        Ok(())
    }
```

**File:** config/src/config/safety_rules_config.rs (L85-96)
```rust
        if let Some(chain_id) = chain_id {
            // Verify that the secure backend is appropriate for mainnet validators
            if chain_id.is_mainnet()
                && node_type.is_validator()
                && safety_rules_config.backend.is_in_memory()
            {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "The secure backend should not be set to in memory storage in mainnet!"
                        .to_string(),
                ));
            }
```

**File:** secure/storage/README.md (L37-42)
```markdown
- `OnDisk`: Similar to InMemory, the OnDisk secure storage implementation provides another
useful testing implementation: an on-disk storage engine, where the storage backend is
implemented using a single file written to local disk. In a similar fashion to the in-memory
storage, on-disk should not be used in production environments as it provides no security
guarantees (e.g., encryption before writing to disk). Moreover, OnDisk storage does not
currently support concurrent data accesses.
```

**File:** docker/compose/aptos-node/validator.yaml (L8-14)
```yaml
  safety_rules:
    service:
      type: "local"
    backend:
      type: "on_disk_storage"
      path: secure-data.json
      namespace: ~
```
