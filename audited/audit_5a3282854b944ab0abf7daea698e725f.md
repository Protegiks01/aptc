# Audit Report

## Title
Emergency Gas Schedule Updates Delayed by DKG Reconfiguration Window

## Summary
When critical gas undercharging is discovered in `TableGasParameters`, emergency updates via governance cannot be applied immediately in DKG-enabled mode. The gas schedule update is staged but not applied until DKG completes, creating an extended exploitation window (50-100+ blocks) where transactions continue executing at critically undercharged rates.

## Finding Description

The Aptos gas schedule update mechanism uses a two-phase commit pattern through `config_buffer`: [1](#0-0) 

When governance executes an emergency gas schedule update, it calls `set_for_next_epoch()` which stages the new schedule in the config buffer but does not apply it immediately: [2](#0-1) 

In DKG-enabled mode (when validator transactions and randomness are both enabled), the `aptos_governance::reconfigure()` function calls `reconfiguration_with_dkg::try_start()` instead of immediately applying changes: [3](#0-2) 

The new gas schedule is only applied when `reconfiguration_with_dkg::finish()` is called, which happens after DKG completes: [4](#0-3) 

**The Critical Gap:**

During DKG execution (which can take 50-100+ blocks), each block's execution environment is created from the parent block's state, which still contains the OLD `GasScheduleV2` resource: [5](#0-4) 

The `AptosEnvironment` is created once per block from this state view and loads the OLD gas parameters: [6](#0-5) 

This environment with OLD gas parameters is then used to initialize the VM for all transaction executions in that block: [7](#0-6) 

**Attack Scenario:**

1. Critical gas undercharging discovered (e.g., `TableGasParameters.add_box_base` is 100x too low)
2. Emergency governance proposal submitted and approved
3. Proposal executes `set_for_next_epoch()` + `reconfigure()`, which starts DKG
4. **EXPLOITATION WINDOW: 50-100+ blocks where ALL transactions execute with OLD undercharged rates**
5. Attacker submits transactions exploiting undercharged table operations
6. Attacker can create massive state bloat, exhaust validator resources, or profit from gas refunds
7. Eventually DKG completes and new rates apply, but damage is done

**No Emergency Bypass:**

The `force_end_epoch()` function exists but requires `@aptos_framework` signer access, making it unavailable for emergency response by operators: [8](#0-7) 

## Impact Explanation

This qualifies as **HIGH SEVERITY** under the Aptos bug bounty program:

1. **Validator node slowdowns**: Undercharged operations (e.g., table insertions at 1/100th cost) can be spammed during the DKG window, causing validators to process expensive operations while charging minimal gas, leading to resource exhaustion.

2. **Significant protocol violations**: The protocol's gas metering invariant is violated - operations execute at incorrect (undercharged) rates for an extended period despite governance attempting emergency fixes.

3. **Economic damage**: Attackers can extract value through gas refunds or create state bloat that requires validators to bear storage costs far exceeding collected gas fees.

The impact is bounded by the DKG duration (typically 50-100 blocks) but is guaranteed to occur in every emergency gas fix scenario when DKG is enabled.

## Likelihood Explanation

**Likelihood: HIGH**

1. **Trigger condition is realistic**: Gas undercharging bugs have occurred in other blockchains and are explicitly contemplated by having emergency governance mechanisms.

2. **DKG is standard on mainnet**: Randomness features require DKG, making this the default reconfiguration path.

3. **Exploitation is trivial**: Once the governance proposal executes, any user can observe that DKG has started but gas rates haven't updated, then submit transactions exploiting the undercharged operations.

4. **No operator intervention possible**: Unlike other emergency scenarios, operators cannot bypass DKG to force immediate application of gas fixes without governance control.

## Recommendation

Implement a two-tier reconfiguration mechanism for critical security updates:

1. Add a new `emergency_set_gas_schedule()` function that requires multisig authorization from a separate emergency response key (not full governance):

```move
public entry fun emergency_set_gas_schedule(
    emergency_signer: &signer,
    gas_schedule_blob: vector<u8>
) acquires GasScheduleV2 {
    // Verify emergency multisig authorization
    system_addresses::assert_aptos_framework(emergency_signer);
    
    // Apply immediately without waiting for epoch boundary
    let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
    if (exists<GasScheduleV2>(@aptos_framework)) {
        *borrow_global_mut<GasScheduleV2>(@aptos_framework) = new_gas_schedule;
    } else {
        move_to(emergency_signer, new_gas_schedule);
    };
    
    // Force reconfiguration without DKG
    reconfiguration_with_dkg::finish(emergency_signer);
}
```

2. Alternatively, modify `aptos_governance::reconfigure()` to detect pending critical config updates (via a flag) and call `finish()` directly instead of `try_start()` to bypass DKG.

3. Document that emergency gas fixes should use `force_end_epoch()` through governance in testnet, or implement a separate emergency response framework with dedicated keys.

## Proof of Concept

```move
#[test_only]
module test_addr::gas_schedule_dkg_delay_poc {
    use aptos_framework::gas_schedule;
    use aptos_framework::aptos_governance;
    use aptos_framework::reconfiguration;
    use std::features;
    
    #[test(aptos_framework = @aptos_framework)]
    fun test_gas_update_delayed_by_dkg(aptos_framework: &signer) {
        // Setup: Enable DKG features
        features::change_feature_flags_for_next_epoch(
            aptos_framework,
            vector[/* DKG feature flags */],
            vector[]
        );
        
        // 1. Submit emergency gas schedule update
        let new_gas_blob = /* serialized GasScheduleV2 with fixed rates */;
        gas_schedule::set_for_next_epoch(aptos_framework, new_gas_blob);
        
        // 2. Trigger reconfiguration (starts DKG)
        let initial_epoch = reconfiguration::current_epoch();
        aptos_governance::reconfigure(aptos_framework);
        
        // 3. Verify gas schedule NOT yet updated (still in config_buffer)
        let current_gas = /* fetch GasScheduleV2 from @aptos_framework */;
        assert!(/* current_gas still has OLD undercharged values */, 0);
        
        // 4. Simulate attacker submitting transactions during DKG window
        // These execute at OLD undercharged rates
        for (i in 0..50) {
            // Submit transaction exploiting undercharged table operation
            // Transaction executes with OLD gas parameters
        }
        
        // 5. Simulate DKG completion via validator transaction
        // (In reality this happens after 50-100 blocks)
        aptos_governance::force_end_epoch(aptos_framework);
        
        // 6. NOW gas schedule is updated
        let updated_gas = /* fetch GasScheduleV2 from @aptos_framework */;
        assert!(/* updated_gas has NEW fixed values */, 1);
        
        // Conclusion: 50+ blocks executed with exploitable gas rates
    }
}
```

## Notes

This vulnerability is inherent to the DKG-based reconfiguration design and affects all on-chain config updates in DKG mode, not just gas schedules. However, gas schedule updates are particularly critical as undercharging can be directly exploited for economic gain or DoS attacks.

The issue cannot be fully mitigated without either:
1. Implementing an emergency bypass mechanism for critical updates
2. Accepting that DKG introduces mandatory update delays
3. Disabling DKG for emergency scenarios (requires governance vote, defeating the purpose)

Current operator best practices should document this limitation and potentially maintain emergency response procedures that can execute `force_end_epoch()` through rapid governance votes, though this still requires proposal voting delays.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L91-103)
```text
    public fun set_for_next_epoch(aptos_framework: &signer, gas_schedule_blob: vector<u8>) acquires GasScheduleV2 {
        system_addresses::assert_aptos_framework(aptos_framework);
        assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));
        let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
        if (exists<GasScheduleV2>(@aptos_framework)) {
            let cur_gas_schedule = borrow_global<GasScheduleV2>(@aptos_framework);
            assert!(
                new_gas_schedule.feature_version >= cur_gas_schedule.feature_version,
                error::invalid_argument(EINVALID_GAS_FEATURE_VERSION)
            );
        };
        config_buffer::upsert(new_gas_schedule);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L135-145)
```text
    public(friend) fun on_new_epoch(framework: &signer) acquires GasScheduleV2 {
        system_addresses::assert_aptos_framework(framework);
        if (config_buffer::does_exist<GasScheduleV2>()) {
            let new_gas_schedule = config_buffer::extract_v2<GasScheduleV2>();
            if (exists<GasScheduleV2>(@aptos_framework)) {
                *borrow_global_mut<GasScheduleV2>(@aptos_framework) = new_gas_schedule;
            } else {
                move_to(framework, new_gas_schedule);
            }
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L685-692)
```text
    public entry fun reconfigure(aptos_framework: &signer) {
        system_addresses::assert_aptos_framework(aptos_framework);
        if (consensus_config::validator_txn_enabled() && randomness_config::enabled()) {
            reconfiguration_with_dkg::try_start();
        } else {
            reconfiguration_with_dkg::finish(aptos_framework);
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L700-703)
```text
    public entry fun force_end_epoch(aptos_framework: &signer) {
        system_addresses::assert_aptos_framework(aptos_framework);
        reconfiguration_with_dkg::finish(aptos_framework);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/reconfiguration_with_dkg.move (L46-61)
```text
    public(friend) fun finish(framework: &signer) {
        system_addresses::assert_aptos_framework(framework);
        dkg::try_clear_incomplete_session(framework);
        consensus_config::on_new_epoch(framework);
        execution_config::on_new_epoch(framework);
        gas_schedule::on_new_epoch(framework);
        std::version::on_new_epoch(framework);
        features::on_new_epoch(framework);
        jwk_consensus_config::on_new_epoch(framework);
        jwks::on_new_epoch(framework);
        keyless_account::on_new_epoch(framework);
        randomness_config_seqnum::on_new_epoch(framework);
        randomness_config::on_new_epoch(framework);
        randomness_api_v0_config::on_new_epoch(framework);
        reconfiguration::reconfigure();
    }
```

**File:** execution/executor/src/block_executor/mod.rs (L226-233)
```rust
                let state_view = {
                    let _timer = OTHER_TIMERS.timer_with(&["get_state_view"]);
                    CachedStateView::new(
                        StateViewId::BlockExecution { block_id },
                        Arc::clone(&self.db.reader),
                        parent_output.result_state().latest().clone(),
                    )?
                };
```

**File:** aptos-move/aptos-vm-environment/src/environment.rs (L246-247)
```rust
        let (gas_params, storage_gas_params, gas_feature_version) =
            get_gas_parameters(&mut sha3_256, &features, state_view);
```

**File:** aptos-move/aptos-vm/src/block_executor/vm_wrapper.rs (L35-42)
```rust
    fn init(
        environment: &AptosEnvironment,
        state_view: &impl StateView,
        async_runtime_checks_enabled: bool,
    ) -> Self {
        let vm = AptosVM::new_for_block_executor(environment, async_runtime_checks_enabled);
        let id = state_view.id();
        Self { vm, id }
```
