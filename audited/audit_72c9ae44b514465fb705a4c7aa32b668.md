# Audit Report

## Title
Mainnet Failpoints Protection Bypass via Genesis Transaction Manipulation

## Summary
A node operator can bypass the mainnet failpoints protection in `ApiConfig::sanitize()` by omitting or corrupting the genesis transaction in their node configuration, causing `chain_id` to become `None` and allowing failpoints to be enabled on mainnet nodes.

## Finding Description

The `ApiConfig::sanitize()` function is designed to prevent failpoints from being enabled on mainnet nodes as a critical security control. [1](#0-0) 

However, this protection can be bypassed through the chain ID extraction logic. When a node starts up, the `extract_node_type_and_chain_id()` function attempts to extract the chain ID from the genesis transaction. If this extraction fails, the error is caught and the function returns `None` for the chain_id instead of failing the startup process. [2](#0-1) 

The chain ID extraction depends on the genesis transaction being present and valid. [3](#0-2) 

The genesis transaction is loaded from the execution configuration: [4](#0-3) 

When `chain_id` is `None`, the mainnet check in `ApiConfig::sanitize()` is completely skipped due to the `if let Some(chain_id) = chain_id` guard, allowing failpoints to be enabled even on what should be a mainnet node. This behavior is even demonstrated in the test suite as "expected" for unknown networks. [5](#0-4) 

**Attack Path:**
1. Node operator compiles `aptos-node` with `--features failpoints` (development build)
2. Operator configures their node with `api.failpoints_enabled = true`
3. Operator either omits the `execution.genesis` field or provides a corrupted genesis transaction
4. When the node starts, `get_chain_id()` fails and returns an error
5. The error is caught and `chain_id` becomes `None`
6. The sanitizer skips the mainnet failpoints check
7. Node starts successfully with failpoints enabled and the `/set_failpoint` API endpoint active

Once failpoints are enabled, an attacker (or the node operator themselves) can inject arbitrary faults via the API. The consensus layer contains numerous failpoints that could be exploited: [6](#0-5) 

Additional consensus failpoints can create invalid votes or manipulate voting behavior: [7](#0-6) 

## Impact Explanation

According to the Aptos bug bounty program, this qualifies as **High Severity** because it enables:

1. **API Crashes**: Failpoints can be configured to crash the API endpoint, which is explicitly listed as High Severity ($50,000) in the bounty program
2. **Validator Node Slowdowns**: Failpoints in consensus code can be used to inject delays or errors, causing validator performance degradation (also High Severity)

While production builds don't typically compile with the `failpoints` feature flag enabled [8](#0-7) , this represents a defense-in-depth failure. The config sanitizer exists specifically to prevent this misconfiguration, but the bypass undermines this protection for development builds that might be accidentally deployed to mainnet.

## Likelihood Explanation

**Likelihood: Low-Medium**

This vulnerability requires:
- Node operator access to modify configuration files (privileged position)
- A development build compiled with `--features failpoints`
- Intentional manipulation of the config to omit/corrupt genesis

The likelihood is reduced because:
- It requires privileged access (node operator role)
- Production builds don't have failpoints enabled by default
- Mainnet nodes typically have proper genesis files

However, likelihood increases in scenarios where:
- Development builds are accidentally deployed to mainnet
- Operators are testing with development builds on mainnet infrastructure
- Insider threat scenarios (malicious validator operator)

## Recommendation

The `extract_node_type_and_chain_id()` function should fail the startup process when critical security configurations are enabled but the chain ID cannot be determined. Specifically:

```rust
fn extract_node_type_and_chain_id(node_config: &NodeConfig) -> Result<(NodeType, Option<ChainId>), Error> {
    let node_type = NodeType::extract_from_config(node_config);
    
    match get_chain_id(node_config) {
        Ok(chain_id) => Ok((node_type, Some(chain_id))),
        Err(error) => {
            // If failpoints are enabled, we MUST know the chain ID to validate against mainnet
            if node_config.api.enabled && node_config.api.failpoints_enabled {
                return Err(Error::InvariantViolation(format!(
                    "Cannot start with failpoints enabled when chain ID cannot be determined. Error: {:?}",
                    error
                )));
            }
            
            println!("Failed to extract the chain ID from the genesis transaction: {:?}! Continuing with None.", error);
            Ok((node_type, None))
        },
    }
}
```

Additionally, the sanitizer should explicitly reject configurations where failpoints are enabled but chain_id is unknown:

```rust
// In ApiConfig::sanitize()
if api_config.failpoints_enabled && chain_id.is_none() {
    return Err(Error::ConfigSanitizerFailed(
        sanitizer_name,
        "Failpoints cannot be enabled when chain ID is unknown!".into(),
    ));
}
```

## Proof of Concept

```rust
#[test]
fn test_failpoints_bypass_via_missing_genesis() {
    // Create a mainnet-like node config with failpoints enabled but no genesis
    let node_config = NodeConfig {
        api: ApiConfig {
            enabled: true,
            failpoints_enabled: true,
            ..Default::default()
        },
        execution: ExecutionConfig {
            genesis: None,  // Missing genesis
            ..Default::default()
        },
        ..Default::default()
    };
    
    // Extract node type and chain ID - this will fail to get chain_id and return None
    let (node_type, chain_id) = extract_node_type_and_chain_id(&node_config);
    assert!(chain_id.is_none(), "Chain ID should be None when genesis is missing");
    
    // Sanitize the config - this should FAIL but currently succeeds
    let result = ApiConfig::sanitize(&node_config, node_type, chain_id);
    
    // BUG: This passes when it should fail!
    // On a real mainnet node, this would allow failpoints to be enabled
    assert!(result.is_ok(), "Sanitizer incorrectly allows failpoints with unknown chain_id");
    
    // Expected behavior: Should return error preventing failpoints with unknown chain_id
    // assert!(result.is_err());
}
```

---

**Notes:**

This finding represents a defense-in-depth violation where the config sanitizer's intended protection can be bypassed. While it requires node operator access (a privileged role), the security question explicitly frames this as an attack scenario involving "attackers manipulating chain_id". The impact is classified as High Severity per the bug bounty program due to the potential for API crashes and validator slowdowns through failpoint injection in consensus-critical code paths.

### Citations

**File:** config/src/config/api_config.rs (L177-185)
```rust
        // Verify that failpoints are not enabled in mainnet
        if let Some(chain_id) = chain_id {
            if chain_id.is_mainnet() && api_config.failpoints_enabled {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "Failpoints are not supported on mainnet nodes!".into(),
                ));
            }
        }
```

**File:** config/src/config/api_config.rs (L286-288)
```rust
        // Sanitize the config for an unknown network and verify that it succeeds
        ApiConfig::sanitize(&node_config, NodeType::Validator, None).unwrap();
    }
```

**File:** config/src/config/node_config_loader.rs (L112-124)
```rust
fn extract_node_type_and_chain_id(node_config: &NodeConfig) -> (NodeType, Option<ChainId>) {
    // Get the node type from the node config
    let node_type = NodeType::extract_from_config(node_config);

    // Get the chain ID from the genesis transaction
    match get_chain_id(node_config) {
        Ok(chain_id) => (node_type, Some(chain_id)),
        Err(error) => {
            println!("Failed to extract the chain ID from the genesis transaction: {:?}! Continuing with None.", error);
            (node_type, None)
        },
    }
}
```

**File:** config/src/config/node_config_loader.rs (L158-198)
```rust
fn get_chain_id(node_config: &NodeConfig) -> Result<ChainId, Error> {
    // TODO: can we make this less hacky?

    // Load the genesis transaction from disk
    let genesis_txn = get_genesis_txn(node_config).ok_or_else(|| {
        Error::InvariantViolation("The genesis transaction was not found!".to_string())
    })?;

    // Extract the chain ID from the genesis transaction
    match genesis_txn {
        Transaction::GenesisTransaction(WriteSetPayload::Direct(change_set)) => {
            let chain_id_state_key = StateKey::on_chain_config::<ChainId>()?;

            // Get the write op from the write set
            let write_set_mut = change_set.clone().write_set().clone().into_mut();
            let write_op = write_set_mut.get(&chain_id_state_key).ok_or_else(|| {
                Error::InvariantViolation(
                    "The genesis transaction does not contain the write op for the chain id!"
                        .into(),
                )
            })?;

            // Extract the chain ID from the write op
            let write_op_bytes = write_op.bytes().ok_or_else(|| Error::InvariantViolation(
                "The genesis transaction does not contain the correct write op for the chain ID!".into(),
            ))?;
            let chain_id = ChainId::deserialize_into_config(write_op_bytes).map_err(|error| {
                Error::InvariantViolation(format!(
                    "Failed to deserialize the chain ID: {:?}",
                    error
                ))
            })?;

            Ok(chain_id)
        },
        _ => Err(Error::InvariantViolation(format!(
            "The genesis transaction has the incorrect type: {:?}!",
            genesis_txn
        ))),
    }
}
```

**File:** config/src/utils.rs (L220-222)
```rust
pub fn get_genesis_txn(config: &NodeConfig) -> Option<&Transaction> {
    config.execution.genesis.as_ref()
}
```

**File:** consensus/src/round_manager.rs (L727-729)
```rust
        fail_point!("consensus::process_proposal_msg", |_| {
            Err(anyhow::anyhow!("Injected error in process_proposal_msg"))
        });
```

**File:** consensus/src/round_manager.rs (L1369-1375)
```rust
        fail_point!("consensus::create_invalid_vote", |_| {
            use aptos_crypto::bls12381;
            let faulty_vote = Vote::new_with_signature(
                vote.vote_data().clone(),
                vote.author(),
                vote.ledger_info().clone(),
                bls12381::Signature::dummy_signature(),
```

**File:** aptos-node/Cargo.toml (L90-95)
```text
[features]
assert-private-keys-not-cloneable = ["aptos-crypto/assert-private-keys-not-cloneable"]
check-vm-features = []
consensus-only-perf-test = ["aptos-executor/consensus-only-perf-test", "aptos-mempool/consensus-only-perf-test", "aptos-db/consensus-only-perf-test"]
default = []
failpoints = ["fail/failpoints", "aptos-consensus/failpoints", "aptos-executor/failpoints", "aptos-mempool/failpoints", "aptos-api/failpoints", "aptos-config/failpoints"]
```
