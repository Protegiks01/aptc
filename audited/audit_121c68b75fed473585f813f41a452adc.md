# Audit Report

## Title
Symlink-Based Code Injection via Transitive Dependencies in Move Package System

## Summary
The Move package build system follows symbolic links when collecting source files from dependencies, allowing malicious transitive dependencies to inject unauthorized code into compilation by creating symlinks pointing to files outside their package boundary. This supply chain vulnerability could enable module shadowing, dependency isolation bypasses, and unauthorized code inclusion during the package build process.

## Finding Description

The vulnerability exists in the Move package system's file discovery mechanism, which unconditionally follows symbolic links when collecting source files from dependencies.

**Root Cause:** [1](#0-0) 

The `find_filenames` function uses `walkdir::WalkDir::new(path).follow_links(true)`, which recursively follows symbolic links without validating that discovered files remain within the package boundary.

**Attack Vector:**

1. An attacker creates a malicious git repository for package "MaliciousDep" containing a symbolic link in its `sources/` directory:
   ```
   sources/injected.move -> ../../TargetPackage_{rev}/sources/sensitive_module.move
   ```

2. When a project depends on both MaliciousDep and TargetPackage, they are cloned to predictable paths in `MOVE_HOME`: [2](#0-1) 

3. During dependency resolution and source collection: [3](#0-2) 

4. The symlinked file is included in MaliciousDep's source list and compiled with MaliciousDep's address mappings: [4](#0-3) 

5. The same source file from TargetPackage is compiled twice with different address namespaces, breaking dependency isolation.

**Propagation Path:**

Git preserves symbolic links by default during clone operations. The digest computation also follows symlinks: [5](#0-4) 

This allows the attacker to compute a "valid" digest that includes the symlinked content, bypassing digest validation.

## Impact Explanation

**Severity: Medium**

This vulnerability represents a **significant protocol violation** in the Move package dependency system. While it does not directly compromise consensus, funds, or liveness at the blockchain runtime level, it creates a supply chain attack vector with several concerning implications:

1. **Dependency Isolation Bypass**: Malicious packages can access source code from other dependencies without declaring them, violating the dependency isolation principle.

2. **Module Shadowing**: The same module can be compiled multiple times with different address mappings, potentially creating confusion in the module resolution system.

3. **Unauthorized Code Inclusion**: Transitive dependencies can force the inclusion of arbitrary code during compilation, which may contain backdoors or malicious logic.

4. **Framework Compromise Risk**: If a malicious dependency is included in the Aptos Framework build chain, it could inject unauthorized code into system modules, potentially affecting all validators.

The impact is currently limited to the build/compilation phase and does not directly break runtime invariants. Additional on-chain verification (bytecode verification, upgrade policies, dependency checks) would still need to be bypassed for actual funds loss or consensus violations. However, as a supply chain vulnerability in critical infrastructure, it meets the **Medium severity** threshold for "significant protocol violations."

## Likelihood Explanation

**Likelihood: Medium to High**

The attack is feasible with moderate complexity:

**Attacker Requirements:**
- Ability to publish a malicious package to a public git repository
- Knowledge of target package git URLs and revisions (obtainable from public dependency declarations)
- Understanding of MOVE_HOME directory structure (deterministic and documented)

**Feasibility Factors:**
- Git automatically preserves symlinks during clone operations (default behavior)
- MOVE_HOME paths are predictable: `{MOVE_HOME}/{sanitized_git_url}_{rev}`
- No validation exists to prevent symlinks from escaping package boundaries
- Developers frequently use transitive dependencies without auditing them

**Barriers to Exploitation:**
- Requires convincing projects to depend on the malicious package (directly or transitively)
- On-chain deployment still requires passing bytecode verification and upgrade policy checks
- Developer tooling may warn about suspicious symlinks (though not enforced)

The lack of any validation or sanitization of symbolic links in the source collection pipeline makes this vulnerability readily exploitable once a malicious dependency enters the dependency graph.

## Recommendation

Implement symlink validation in the file discovery mechanism to prevent escape from package boundaries:

**Fix Location 1**: In `find_filenames` function: [6](#0-5) 

**Recommended Fix:**
```rust
// Add after line 84, inside the filter_map
let canonical_entry = entry_path.canonicalize()?;
let canonical_root = path.canonicalize()?;
if !canonical_entry.starts_with(&canonical_root) {
    eprintln!("Warning: Skipping file outside package boundary: {:?}", entry_path);
    continue;
}
```

**Fix Location 2**: In `compute_digest` function: [5](#0-4) 

Apply the same validation to ensure digest computation only includes files within the package boundary.

**Additional Recommendations:**
1. Add a configuration flag to disable symlink following entirely for security-conscious builds
2. Log warnings when symlinks are encountered during package builds
3. Document the security implications of symlinks in package documentation
4. Consider adding a package manifest field to explicitly declare allowed external file paths (opt-in)

## Proof of Concept

**Setup Malicious Repository:**
```bash
# Create malicious package
mkdir MaliciousDep
cd MaliciousDep
cat > Move.toml << EOF
[package]
name = "MaliciousDep"
version = "1.0.0"

[dependencies]
EOF

mkdir sources
# Create symlink pointing to another package's sources
# Assuming TargetPackage is at ../TargetPackage_v1.0.0
ln -s ../../TargetPackage_v1.0.0/sources/critical_module.move sources/injected.move

git init
git add .
git commit -m "Malicious package with symlink"
```

**Victim Project:**
```toml
# Move.toml
[package]
name = "VictimProject"
version = "1.0.0"

[dependencies]
MaliciousDep = { git = "https://github.com/attacker/MaliciousDep", rev = "main" }
TargetPackage = { git = "https://github.com/victim/TargetPackage", rev = "v1.0.0" }
```

**Verification Steps:**
1. Run `aptos move compile` on VictimProject
2. Observe that MaliciousDep's compilation includes `critical_module.move` from TargetPackage
3. Examine build artifacts to confirm the module is compiled with MaliciousDep's address namespace
4. This demonstrates unauthorized code inclusion and dependency isolation bypass

**Expected Outcome:** The compilation succeeds with `critical_module.move` being compiled as part of MaliciousDep, creating a duplicate module with different address mappings than the original in TargetPackage.

---

**Notes:**

This vulnerability is specific to the Move package build tooling and affects the supply chain security of Move development. While it does not directly compromise blockchain runtime security (consensus, funds, liveness), it represents a significant weakness in the package dependency isolation model that could be exploited as part of a broader attack chain targeting framework packages or validator builds.

### Citations

**File:** third_party/move/move-command-line-common/src/files.rs (L80-91)
```rust
        for entry in walkdir::WalkDir::new(path)
            .follow_links(true)
            .into_iter()
            .filter_map(|e| e.ok())
        {
            let entry_path = entry.path();
            if !entry.file_type().is_file() || !is_file_desired(entry_path) {
                continue;
            }

            result.push(path_to_string(entry_path)?);
        }
```

**File:** third_party/move/tools/move-package/src/source_package/manifest_parser.rs (L566-573)
```rust
pub fn git_repo_cache_path(git_url: &str, rev_name: &str) -> PathBuf {
    let move_home = MOVE_HOME.clone();
    PathBuf::from(move_home).join(format!(
        "{}_{}",
        url_to_file_name(git_url),
        rev_name.replace('/', "__")
    ))
}
```

**File:** third_party/move/tools/move-package/src/resolution/resolution_graph.rs (L108-116)
```rust
                    ResolvingNamedAddress::new(Some(addr)),
                )
            })
            .collect();

        let mut resolution_graph = Self {
            root_package_path: root_package_path.clone(),
            build_options: build_options.clone(),
            root_package: root_package.clone(),
```

**File:** third_party/move/tools/move-package/src/compilation/compiled_package.rs (L563-566)
```rust
        for (dep_package_name, source_paths, _, _) in &transitive_dependencies {
            for dep_path in source_paths.clone() {
                source_package_map.insert(dep_path.as_str().to_string(), *dep_package_name);
            }
```

**File:** third_party/move/tools/move-package/src/resolution/digest.rs (L30-38)
```rust
            for entry in walkdir::WalkDir::new(path)
                .follow_links(true)
                .into_iter()
                .filter_map(|e| e.ok())
            {
                if entry.file_type().is_file() {
                    maybe_hash_file(entry.path())?
                }
            }
```
