# Audit Report

## Title
Event Sequence Number Collision During V1/V2 Migration Rollback

## Summary
During the transition from V1 to V2 events, the `EventHandle.count` field in on-chain resources becomes desynchronized from the `EventSequenceNumberSchema` database used for tracking translated V2 event sequence numbers. If the `MODULE_EVENT_MIGRATION` feature flag is disabled after V2 events have been emitted, subsequent V1 events will reuse sequence numbers already assigned to translated V2 events, breaking the uniqueness invariant for event sequence numbers.

## Finding Description

The Aptos event system supports two modes:
- **V1 Events**: Use `EventHandle<T>` with a `counter` field that increments with each emission via `emit_event()`
- **V2 Events**: Use `emit<T>()` without EventHandles or sequence numbers [1](#0-0) 

For backward compatibility, V2 events are translated to V1 format by reading the `EventHandle.count` from on-chain resources and using `EventSequenceNumberSchema` to track assigned sequence numbers: [2](#0-1) 

The critical issue is that **V2 events do not update `EventHandle.count`** in the on-chain resource: [3](#0-2) 

The `MODULE_EVENT_MIGRATION` feature flag (value 57) controls whether code emits V1 or V2 events, and can be toggled through governance: [4](#0-3) [5](#0-4) 

**Attack Scenario:**

1. **Initial State**: `CoinStore` has `deposit_events` EventHandle with `count=10` (10 V1 events with seq 0-9 emitted)
2. **Feature Flag Enabled**: Governance enables `MODULE_EVENT_MIGRATION`
3. **V2 Event #1**: User deposits coins → V2 `CoinDeposit` event emitted
   - Translator reads `EventHandle.count=10` from state
   - Assigns translated sequence number = 10
   - Stores in `EventSequenceNumberSchema: (key, 10)`
   - **EventHandle.count remains 10** (unchanged)
4. **V2 Event #2**: Another deposit → translated seq=11, EventHandle.count still 10
5. **Feature Flag Disabled**: Governance disables flag (rollback scenario)
6. **V1 Event**: User deposits again → `emit_event()` uses `EventHandle.count=10`
   - **CONFLICT**: Sequence number 10 already used by translated V2 event [6](#0-5) [7](#0-6) 

## Impact Explanation

**Medium Severity** - State inconsistencies requiring intervention:

1. **Event Sequence Number Uniqueness Violated**: The fundamental invariant that each event for a given `EventKey` has a unique sequence number is broken
2. **Indexer Data Corruption**: The `EventByKeySchema` and `EventSequenceNumberSchema` will contain duplicate sequence numbers for the same key
3. **API Query Inconsistencies**: Event queries by sequence number may return incorrect or multiple events
4. **Cross-Node State Divergence**: Different nodes processing the rollback at different times may have inconsistent event views
5. **Historical Data Integrity**: Event replay and audit trails become unreliable

While this doesn't directly cause fund loss or consensus violations, it corrupts critical indexer state used by APIs, explorers, and applications relying on event history.

## Likelihood Explanation

**Medium Likelihood** - This requires specific conditions:

1. **Governance Action Required**: Feature flag must be toggled, which requires either:
   - Governance proposal with majority stake approval
   - Emergency system administrator action

2. **Realistic Rollback Scenario**: Feature rollbacks are legitimate operations if:
   - Critical bugs discovered in V2 event system
   - Performance issues detected
   - Ecosystem compatibility problems
   - Emergency protocol changes

3. **No Safeguards**: The code has no synchronization mechanism between `EventHandle.count` and `EventSequenceNumberSchema`, and no validation prevents this scenario

While not directly attacker-triggered, this is a systemic flaw that will cause corruption during legitimate migration/rollback operations that governance may need to perform.

## Recommendation

Implement synchronization between `EventHandle.count` and `EventSequenceNumberSchema`:

**Option 1: Update EventHandle.count during V2 translation**
When translating V2 events, write back the updated sequence number to the on-chain `EventHandle.count` field. This requires modifying the state during indexing, which may have performance implications.

**Option 2: Prevent feature flag rollback**
Make `MODULE_EVENT_MIGRATION` a one-way flag that cannot be disabled once enabled. Add validation in the governance `toggle_features()` function.

**Option 3: Reset EventSequenceNumberSchema on rollback**
When the flag is disabled, clear the `EventSequenceNumberSchema` database to force re-initialization from current `EventHandle.count` values. This may cause gaps in sequence numbers but prevents collisions.

**Recommended Fix (Option 2 + Validation):**

```rust
// In features.move or aptos_governance.move
public fun toggle_features(
    aptos_framework: &signer,
    enable: vector<u64>,
    disable: vector<u64>,
) {
    // Validate MODULE_EVENT_MIGRATION cannot be disabled once enabled
    if (vector::contains(&disable, &MODULE_EVENT_MIGRATION)) {
        assert!(!is_enabled(MODULE_EVENT_MIGRATION), 
                error::invalid_argument(ECANNOT_DISABLE_MODULE_EVENT_MIGRATION));
    };
    change_feature_flags_for_next_epoch(aptos_framework, enable, disable);
}
```

## Proof of Concept

```rust
#[test]
fn test_event_sequence_number_conflict_on_rollback() {
    let mut harness = MoveHarness::new();
    
    // Setup: Create account with CoinStore (EventHandle.count = 0)
    let account = harness.new_account_at(AccountAddress::from_hex_literal("0xcafe").unwrap());
    harness.run_transaction_payload(
        &account,
        aptos_stdlib::aptos_coin_mint(account.address(), 1000),
    );
    
    // Phase 1: Emit V1 event (MODULE_EVENT_MIGRATION disabled)
    harness.set_feature_flag(MODULE_EVENT_MIGRATION, false);
    harness.run_transaction_payload(
        &account,
        aptos_stdlib::coin_transfer(account.address(), 100),
    );
    // EventHandle.count = 1, V1 event with seq=0 emitted
    
    // Phase 2: Enable V2 migration
    harness.set_feature_flag(MODULE_EVENT_MIGRATION, true);
    
    // Phase 3: Emit V2 event - will be translated with seq=1
    harness.run_transaction_payload(
        &account,
        aptos_stdlib::coin_transfer(account.address(), 100),
    );
    // EventSequenceNumberSchema: (key, 1)
    // EventHandle.count still = 1 (not updated by V2)
    
    // Phase 4: Disable flag (rollback)
    harness.set_feature_flag(MODULE_EVENT_MIGRATION, false);
    
    // Phase 5: Emit V1 event - will reuse seq=1
    harness.run_transaction_payload(
        &account,
        aptos_stdlib::coin_transfer(account.address(), 100),
    );
    // CONFLICT: Both translated V2 event and new V1 event have seq=1
    
    // Verify: Query events by sequence number returns ambiguous results
    let events = harness.read_events_by_sequence_number(account.address(), 2, 1);
    assert!(events.len() > 1, "Multiple events with same sequence number");
}
```

## Notes

This vulnerability is triggered during legitimate governance-controlled migration operations rather than direct attacker exploitation. However, it represents a systemic design flaw that breaks the event sequence number uniqueness invariant during rollback scenarios. The lack of synchronization between `EventHandle.count` (on-chain state) and `EventSequenceNumberSchema` (indexer state) creates inevitable conflicts when transitioning between V1 and V2 modes in either direction.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/event.move (L36-60)
```text
    struct EventHandle<phantom T: drop + store> has store {
        /// Total number of events emitted to this event stream.
        counter: u64,
        /// A globally unique ID for this event stream.
        guid: GUID,
    }

    #[deprecated]
    /// Use EventHandleGenerator to generate a unique event handle for `sig`
    public(friend) fun new_event_handle<T: drop + store>(guid: GUID): EventHandle<T> {
        EventHandle<T> {
            counter: 0,
            guid,
        }
    }

    #[deprecated]
    /// Emit an event with payload `msg` by using `handle_ref`'s key and counter.
    public fun emit_event<T: drop + store>(handle_ref: &mut EventHandle<T>, msg: T) {
        write_to_event_store<T>(bcs::to_bytes(&handle_ref.guid), handle_ref.counter, msg);
        spec {
            assume handle_ref.counter + 1 <= MAX_U64;
        };
        handle_ref.counter += 1;
    }
```

**File:** storage/indexer/src/event_v2_translator.rs (L190-200)
```rust
    pub fn get_next_sequence_number(&self, event_key: &EventKey, default: u64) -> Result<u64> {
        if let Some(seq) = self.get_cached_sequence_number(event_key) {
            Ok(seq + 1)
        } else {
            let seq = self
                .internal_indexer_db
                .get::<EventSequenceNumberSchema>(event_key)?
                .map_or(default, |seq| seq + 1);
            Ok(seq)
        }
    }
```

**File:** storage/indexer/src/event_v2_translator.rs (L238-274)
```rust
struct CoinDepositTranslator;
impl EventV2Translator for CoinDepositTranslator {
    fn translate_event_v2_to_v1(
        &self,
        v2: &ContractEventV2,
        engine: &EventV2TranslationEngine,
    ) -> Result<ContractEventV1> {
        let coin_deposit = CoinDeposit::try_from_bytes(v2.event_data())?;
        let struct_tag_str = format!("0x1::coin::CoinStore<{}>", coin_deposit.coin_type());
        let struct_tag = StructTag::from_str(&struct_tag_str)?;
        let (key, sequence_number) = if let Some(state_value_bytes) =
            engine.get_state_value_bytes_for_resource(coin_deposit.account(), &struct_tag)?
        {
            // We can use `DummyCoinType` as it does not affect the correctness of deserialization.
            let coin_store_resource: CoinStoreResource<DummyCoinType> =
                bcs::from_bytes(&state_value_bytes)?;
            let key = *coin_store_resource.deposit_events().key();
            let sequence_number = engine
                .get_next_sequence_number(&key, coin_store_resource.deposit_events().count())?;
            (key, sequence_number)
        } else {
            // The creation number of DepositEvent is deterministically 2.
            static DEPOSIT_EVENT_CREATION_NUMBER: u64 = 2;
            (
                EventKey::new(DEPOSIT_EVENT_CREATION_NUMBER, *coin_deposit.account()),
                0,
            )
        };
        let deposit_event = DepositEvent::new(coin_deposit.amount());
        Ok(ContractEventV1::new(
            key,
            sequence_number,
            DEPOSIT_EVENT_TYPE.clone(),
            bcs::to_bytes(&deposit_event)?,
        )?)
    }
}
```

**File:** aptos-move/framework/src/natives/event.rs (L247-323)
```rust
fn native_write_module_event_to_store(
    context: &mut SafeNativeContext,
    ty_args: &[Type],
    mut arguments: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    debug_assert!(ty_args.len() == 1);
    debug_assert!(arguments.len() == 1);

    let ty = &ty_args[0];
    let msg = arguments.pop_back().unwrap();

    context.charge(
        EVENT_WRITE_TO_EVENT_STORE_BASE
            + EVENT_WRITE_TO_EVENT_STORE_PER_ABSTRACT_VALUE_UNIT * context.abs_val_size(&msg)?,
    )?;

    let type_tag = context.type_to_type_tag(ty)?;

    // Additional runtime check for module call.
    let stack_frames = context.stack_frames(1);
    let id = stack_frames
        .stack_trace()
        .first()
        .map(|(caller, _, _)| caller)
        .ok_or_else(|| {
            let err = PartialVMError::new_invariant_violation(
                "Caller frame for 0x1::emit::event is not found",
            );
            SafeNativeError::InvariantViolation(err)
        })?
        .as_ref()
        .ok_or_else(|| {
            // If module is not known, this call must come from the script, which is not allowed.
            let err = PartialVMError::new_invariant_violation("Scripts cannot emit events");
            SafeNativeError::InvariantViolation(err)
        })?;

    if let TypeTag::Struct(ref struct_tag) = type_tag {
        if id != &struct_tag.module_id() {
            return Err(SafeNativeError::InvariantViolation(PartialVMError::new(
                StatusCode::INTERNAL_TYPE_ERROR,
            )));
        }
    } else {
        return Err(SafeNativeError::InvariantViolation(PartialVMError::new(
            StatusCode::INTERNAL_TYPE_ERROR,
        )));
    }

    let (layout, contains_delayed_fields) = context
        .type_to_type_layout_with_delayed_fields(ty)?
        .unpack();

    let function_value_extension = context.function_value_extension();
    let max_value_nest_depth = context.max_value_nest_depth();
    let blob = ValueSerDeContext::new(max_value_nest_depth)
        .with_delayed_fields_serde()
        .with_func_args_deserialization(&function_value_extension)
        .serialize(&msg, &layout)?
        .ok_or_else(|| {
            SafeNativeError::InvariantViolation(PartialVMError::new_invariant_violation(
                "Event serialization failure",
            ))
        })?;

    let ctx = context.extensions_mut().get_mut::<NativeEventContext>();
    let event = ContractEvent::new_v2(type_tag, blob).map_err(|_| SafeNativeError::Abort {
        abort_code: ECANNOT_CREATE_EVENT,
    })?;
    // TODO(layouts): avoid cloning layouts for events with delayed fields.
    ctx.events.push((
        event,
        contains_delayed_fields.then(|| layout.as_ref().clone()),
    ));

    Ok(smallvec![])
}
```

**File:** api/src/tests/event_v2_translation_test.rs (L15-29)
```rust
static MODULE_EVENT_MIGRATION: u64 = 57;
static NEW_ACCOUNTS_DEFAULT_TO_FA_APT_STORE: u64 = 64;
static OPERATIONS_DEFAULT_TO_FA_APT_STORE: u64 = 65;
static NEW_ACCOUNTS_DEFAULT_TO_FA_STORE: u64 = 90;

#[tokio::test(flavor = "multi_thread", worker_threads = 2)]
async fn test_feature_enable_disable() {
    let mut context = new_test_context(current_function_name!());
    context.enable_feature(MODULE_EVENT_MIGRATION).await;
    assert!(context.is_feature_enabled(MODULE_EVENT_MIGRATION).await);
    context.disable_feature(MODULE_EVENT_MIGRATION).await;
    assert!(!context.is_feature_enabled(MODULE_EVENT_MIGRATION).await);
    context.enable_feature(MODULE_EVENT_MIGRATION).await;
    assert!(context.is_feature_enabled(MODULE_EVENT_MIGRATION).await);
}
```

**File:** aptos-move/framework/aptos-token/sources/token_event_store.move (L232-257)
```text
    /// Emit the collection uri mutation event
    friend fun emit_collection_uri_mutate_event(creator: &signer, collection: String, old_uri: String, new_uri: String) acquires TokenEventStoreV1 {
        let event = CollectionUriMutateEvent {
            creator_addr: signer::address_of(creator),
            collection_name: collection,
            old_uri,
            new_uri,
        };
        initialize_token_event_store(creator);
        let token_event_store = &mut TokenEventStoreV1[signer::address_of(creator)];
        if (std::features::module_event_migration_enabled()) {
            event::emit(
                CollectionUriMutate {
                    creator_addr: signer::address_of(creator),
                    collection_name: collection,
                    old_uri,
                    new_uri,
                }
            );
        } else {
            event::emit_event<CollectionUriMutateEvent>(
                &mut token_event_store.collection_uri_mutate_events,
                event,
            );
        };
    }
```

**File:** storage/indexer/src/db_indexer.rs (L459-482)
```rust
                                let key = *translated_v1_event.key();
                                let sequence_number = translated_v1_event.sequence_number();
                                self.event_v2_translation_engine
                                    .cache_sequence_number(&key, sequence_number);
                                event_keys.insert(key);
                                batch
                                    .put::<EventByKeySchema>(
                                        &(key, sequence_number),
                                        &(version, idx as u64),
                                    )
                                    .expect("Failed to put events by key to a batch");
                                batch
                                    .put::<EventByVersionSchema>(
                                        &(key, version, sequence_number),
                                        &(idx as u64),
                                    )
                                    .expect("Failed to put events by version to a batch");
                                batch
                                    .put::<TranslatedV1EventSchema>(
                                        &(version, idx as u64),
                                        &translated_v1_event,
                                    )
                                    .expect("Failed to put translated v1 events to a batch");
                            }
```
