# Audit Report

## Title
Version Monotonicity Violation in Fast Sync Storage: Duplicate Commit Vulnerability

## Summary
The `FastSyncStorageWrapper.commit_ledger()` function fails to verify strict version monotonicity after fast sync completion. The underlying `AptosDB.get_and_check_commit_range()` uses a non-strict inequality (`>=`) instead of strict (`>`) when validating commit versions, allowing the same version to be committed multiple times after `finalize_state_snapshot()` completes.

## Finding Description
The FastSyncStorageWrapper delegates all commit operations to the underlying AptosDB without additional version validation: [1](#0-0) 

The delegated `commit_ledger()` implementation performs version validation via `get_and_check_commit_range()`: [2](#0-1) 

The critical bug lies in the version range check: [3](#0-2) 

The check at line 525-530 uses `>=` allowing `version_to_commit == old_committed_ver`, which violates version monotonicity. After `finalize_state_snapshot()` sets `OverallCommitProgress` to version V: [4](#0-3) 

A subsequent `commit_ledger(V, ledger_info, None)` call would pass validation because V >= V, allowing duplicate commits at the same version. This is particularly problematic when `commit_ledger()` is called without a chunk (chunk_opt = None), as seen in the block executor: [5](#0-4) 

When called this way, there's no `pre_commit_validation()` to enforce `chunk.first_version == next_version`, leaving only the flawed `>=` check as protection.

## Impact Explanation
**Severity: Medium** - State inconsistencies requiring intervention

This vulnerability can cause:
1. **Ledger info duplication**: The same version's ledger info could be overwritten with potentially different signatures or metadata
2. **State synchronization issues**: Lack of forward progress if the system repeatedly tries to commit the same version
3. **Database integrity concerns**: Violation of the version monotonicity invariant critical for blockchain correctness

The additional validation in `check_and_put_ledger_info()` (root hash, epoch continuity checks) provides some defense-in-depth: [6](#0-5) 

However, the fundamental invariant violation remains exploitable in edge cases.

## Likelihood Explanation
**Likelihood: Low to Medium**

This requires specific timing conditions:
1. Fast sync completes via `finalize_state_snapshot()` at version V
2. Due to race conditions, message reordering, or coordination bugs between consensus and state sync components, `commit_ledger()` is invoked for version V again
3. The call bypasses pre-commit validation (chunk_opt = None)

While not directly exploitable by external attackers (requires internal component coordination), it represents a defensive programming failure that could manifest during:
- Network partitions healing
- Epoch transitions with fast sync
- State sync and consensus handover coordination errors

## Recommendation
Change the version monotonicity check from non-strict to strict inequality:

```rust
fn get_and_check_commit_range(&self, version_to_commit: Version) -> Result<Option<Version>> {
    let old_committed_ver = self.ledger_db.metadata_db().get_synced_version()?;
    let pre_committed_ver = self.state_store.current_state_locked().version();
    
    // Change from >= to > for strict monotonicity
    ensure!(
        old_committed_ver.is_none() || version_to_commit > old_committed_ver.unwrap(),
        "Version too old to commit. Committed: {:?}; Trying to commit: {}",
        old_committed_ver,
        version_to_commit,
    );
    
    ensure!(
        pre_committed_ver.is_some() && version_to_commit <= pre_committed_ver.unwrap(),
        "Version too new to commit. Pre-committed: {:?}, Trying to commit: {}",
        pre_committed_ver,
        version_to_commit,
    );
    Ok(old_committed_ver)
}
```

Additionally, consider adding version validation in `FastSyncStorageWrapper.commit_ledger()` to explicitly prevent commits at or below the finalized snapshot version.

## Proof of Concept
```rust
// Integration test demonstrating the vulnerability
#[test]
fn test_duplicate_version_commit_after_fast_sync() {
    let db = create_test_aptosdb();
    
    // 1. Fast sync to version 1000
    let snapshot_version = 1000;
    let target_output = create_test_output_with_proof(snapshot_version);
    let ledger_infos = vec![create_test_ledger_info(snapshot_version)];
    
    db.finalize_state_snapshot(
        snapshot_version,
        target_output,
        &ledger_infos
    ).unwrap();
    
    // Verify OverallCommitProgress is 1000
    assert_eq!(db.ledger_db.metadata_db().get_synced_version().unwrap(), Some(1000));
    
    // 2. Attempt to commit version 1000 again with just ledger info
    let ledger_info = create_test_ledger_info(1000);
    
    // This should fail but currently succeeds due to >= bug
    let result = db.commit_ledger(1000, Some(&ledger_info), None);
    
    // BUG: This passes when it should fail
    assert!(result.is_ok(), "Duplicate version commit should be rejected but was accepted");
    
    // Expected behavior: result.is_err()
    // Expected error: "Version too old to commit. Committed: Some(1000); Trying to commit: 1000"
}
```

## Notes
The root cause is a defensive programming failure rather than a directly exploitable security vulnerability by external attackers, as `commit_ledger()` is only accessible to internal blockchain components. However, it violates the critical **State Consistency** invariant (#4: "State transitions must be atomic and verifiable") and could manifest during complex distributed system scenarios like fast sync completion, making it worthy of remediation.

### Citations

**File:** storage/aptosdb/src/fast_sync_storage_wrapper.rs (L177-185)
```rust
    fn commit_ledger(
        &self,
        version: Version,
        ledger_info_with_sigs: Option<&LedgerInfoWithSignatures>,
        chunk_opt: Option<ChunkToCommit>,
    ) -> Result<()> {
        self.get_aptos_db_write_ref()
            .commit_ledger(version, ledger_info_with_sigs, chunk_opt)
    }
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L78-112)
```rust
    fn commit_ledger(
        &self,
        version: Version,
        ledger_info_with_sigs: Option<&LedgerInfoWithSignatures>,
        chunk_opt: Option<ChunkToCommit>,
    ) -> Result<()> {
        gauged_api("commit_ledger", || {
            // Pre-committing and committing in concurrency is allowed but not pre-committing at the
            // same time from multiple threads, the same for committing.
            // Consensus and state sync must hand over to each other after all pending execution and
            // committing complete.
            let _lock = self
                .commit_lock
                .try_lock()
                .expect("Concurrent committing detected.");
            let _timer = OTHER_TIMERS_SECONDS.timer_with(&["commit_ledger"]);

            let old_committed_ver = self.get_and_check_commit_range(version)?;

            let mut ledger_batch = SchemaBatch::new();
            // Write down LedgerInfo if provided.
            if let Some(li) = ledger_info_with_sigs {
                self.check_and_put_ledger_info(version, li, &mut ledger_batch)?;
            }
            // Write down commit progress
            ledger_batch.put::<DbMetadataSchema>(
                &DbMetadataKey::OverallCommitProgress,
                &DbMetadataValue::Version(version),
            )?;
            self.ledger_db.metadata_db().write_schemas(ledger_batch)?;

            // Notify the pruners, invoke the indexer, and update in-memory ledger info.
            self.post_commit(old_committed_ver, version, ledger_info_with_sigs, chunk_opt)
        })
    }
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L207-218)
```rust
            ledger_db_batch
                .ledger_metadata_db_batches
                .put::<DbMetadataSchema>(
                    &DbMetadataKey::LedgerCommitProgress,
                    &DbMetadataValue::Version(version),
                )?;
            ledger_db_batch
                .ledger_metadata_db_batches
                .put::<DbMetadataSchema>(
                    &DbMetadataKey::OverallCommitProgress,
                    &DbMetadataValue::Version(version),
                )?;
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L522-538)
```rust
    fn get_and_check_commit_range(&self, version_to_commit: Version) -> Result<Option<Version>> {
        let old_committed_ver = self.ledger_db.metadata_db().get_synced_version()?;
        let pre_committed_ver = self.state_store.current_state_locked().version();
        ensure!(
            old_committed_ver.is_none() || version_to_commit >= old_committed_ver.unwrap(),
            "Version too old to commit. Committed: {:?}; Trying to commit with LI: {}",
            old_committed_ver,
            version_to_commit,
        );
        ensure!(
            pre_committed_ver.is_some() && version_to_commit <= pre_committed_ver.unwrap(),
            "Version too new to commit. Pre-committed: {:?}, Trying to commit with LI: {}",
            pre_committed_ver,
            version_to_commit,
        );
        Ok(old_committed_ver)
    }
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L540-601)
```rust
    fn check_and_put_ledger_info(
        &self,
        version: Version,
        ledger_info_with_sig: &LedgerInfoWithSignatures,
        ledger_batch: &mut SchemaBatch,
    ) -> Result<(), AptosDbError> {
        let ledger_info = ledger_info_with_sig.ledger_info();

        // Verify the version.
        ensure!(
            ledger_info.version() == version,
            "Version in LedgerInfo doesn't match last version. {:?} vs {:?}",
            ledger_info.version(),
            version,
        );

        // Verify the root hash.
        let db_root_hash = self
            .ledger_db
            .transaction_accumulator_db()
            .get_root_hash(version)?;
        let li_root_hash = ledger_info_with_sig
            .ledger_info()
            .transaction_accumulator_hash();
        ensure!(
            db_root_hash == li_root_hash,
            "Root hash pre-committed doesn't match LedgerInfo. pre-commited: {:?} vs in LedgerInfo: {:?}",
            db_root_hash,
            li_root_hash,
        );

        // Verify epoch continuity.
        let current_epoch = self
            .ledger_db
            .metadata_db()
            .get_latest_ledger_info_option()
            .map_or(0, |li| li.ledger_info().next_block_epoch());
        ensure!(
            ledger_info_with_sig.ledger_info().epoch() == current_epoch,
            "Gap in epoch history. Trying to put in LedgerInfo in epoch: {}, current epoch: {}",
            ledger_info_with_sig.ledger_info().epoch(),
            current_epoch,
        );

        // Ensure that state tree at the end of the epoch is persisted.
        if ledger_info_with_sig.ledger_info().ends_epoch() {
            let state_snapshot = self.state_store.get_state_snapshot_before(version + 1)?;
            ensure!(
                state_snapshot.is_some() && state_snapshot.as_ref().unwrap().0 == version,
                "State checkpoint not persisted at the end of the epoch, version {}, next_epoch {}, snapshot in db: {:?}",
                version,
                ledger_info_with_sig.ledger_info().next_block_epoch(),
                state_snapshot,
            );
        }

        // Put write to batch.
        self.ledger_db
            .metadata_db()
            .put_ledger_info(ledger_info_with_sig, ledger_batch)?;
        Ok(())
    }
```

**File:** execution/executor/src/block_executor/mod.rs (L387-390)
```rust
        let target_version = ledger_info_with_sigs.ledger_info().version();
        self.db
            .writer
            .commit_ledger(target_version, Some(&ledger_info_with_sigs), None)?;
```
