# Audit Report

## Title
Empty Code Vector Allows Phantom Package Creation and Namespace DoS

## Summary
The `code_publish_package_txn()` function accepts empty code vectors combined with empty module metadata, allowing attackers to publish "phantom packages" - packages registered in the PackageRegistry with no actual modules. When combined with an immutable upgrade policy, this creates a permanent denial-of-service on package namespaces.

## Finding Description

The code publishing flow contains a critical validation gap that allows publishing packages with no modules: [1](#0-0) 

This entry function deserializes metadata and passes it to `publish_package` without validating that modules exist. The function extracts module names from metadata and adds the package to the registry: [2](#0-1) 

When module metadata is empty, `get_module_names()` returns an empty vector, but the package is still added to the PackageRegistry. The code then calls the native publish function: [3](#0-2) 

In the native implementation, both empty code and empty expected_modules are accepted: [4](#0-3) 

The critical failure occurs in validation where empty expected_modules with empty actual modules passes: [5](#0-4) 

The loop at line 1692 never executes when `modules` is empty, leaving `expected_modules` empty. The check at line 1733 only fails if expected_modules is non-empty, so when both are empty, validation succeeds.

**Attack Scenario:**
1. Attacker creates metadata with empty `modules` vector and `upgrade_policy: immutable`
2. Attacker calls `code_publish_package_txn()` with empty code vector
3. Package with no modules is permanently registered
4. Future attempts to publish with this name fail due to immutability check: [6](#0-5) 

This creates permanent namespace denial-of-service.

## Impact Explanation

**Medium Severity** - State inconsistencies requiring intervention:
- **Namespace DoS**: Attackers can permanently claim package names with immutable empty packages, preventing legitimate developers from using those names
- **Storage Waste**: Multiple empty packages consume blockchain storage with no functional value
- **Registry Corruption**: PackageRegistry contains semantically invalid entries (packages with no modules), violating the invariant that published packages should contain executable code
- **Tooling Impact**: Indexers and developer tools expecting packages to have modules may malfunction

This meets Medium severity criteria as it causes state inconsistencies and limited resource manipulation, though it doesn't directly result in fund loss or consensus violations.

## Likelihood Explanation

**High Likelihood:**
- **No Special Privileges Required**: Any account can exploit this by simply having code publishing permission
- **Simple Attack**: Creating empty metadata and code vectors is trivial
- **No Detection**: The transaction succeeds normally with no error indication
- **Permanent Effect**: With immutable policy, the damage is irreversible without governance intervention
- **Scalability**: Attacker can claim multiple package names in a single transaction batch

## Recommendation

Add explicit validation to reject packages with empty modules. In `code.move`, add a check after line 187:

```move
let module_names = get_module_names(&pack);
assert!(!vector::is_empty(&module_names), error::invalid_argument(EMODULE_EMPTY));
```

Add a new error constant:
```move
const EMODULE_EMPTY: u64 = 0xC;
```

Additionally, add a validation in the native layer as defense-in-depth. In `aptos_vm.rs` at line 1688, add:

```rust
if expected_modules.is_empty() {
    return Err(Self::metadata_validation_error(
        "cannot publish package with no modules",
    ));
}
```

This ensures empty packages are rejected at both the Move and native layers.

## Proof of Concept

```move
#[test(publisher = @0xcafe)]
fun test_empty_package_exploit(publisher: &signer) {
    use aptos_framework::code;
    use aptos_framework::account;
    use std::vector;
    use std::string;
    
    // Create account
    account::create_account_for_test(signer::address_of(publisher));
    
    // Create metadata for package with NO modules
    let metadata = code::PackageMetadata {
        name: string::utf8(b"phantom_package"),
        upgrade_policy: code::upgrade_policy_immutable(), // Permanent!
        upgrade_number: 0,
        source_digest: string::utf8(b""),
        manifest: vector::empty(),
        modules: vector::empty(), // Empty modules!
        deps: vector::empty(),
        extension: option::none(),
    };
    
    // Serialize metadata
    let metadata_serialized = bcs::to_bytes(&metadata);
    
    // Empty code vector
    let code: vector<vector<u8>> = vector::empty();
    
    // This should fail but currently succeeds!
    code::publish_package_txn(publisher, metadata_serialized, code);
    
    // Package is now registered with no modules
    // Any future attempts to publish "phantom_package" will fail
}
```

### Citations

**File:** aptos-move/framework/aptos-framework/sources/code.move (L187-214)
```text
        let module_names = get_module_names(&pack);
        let package_immutable = &borrow_global<PackageRegistry>(addr).packages;
        let len = vector::length(package_immutable);
        let index = len;
        let upgrade_number = 0;
        vector::enumerate_ref(package_immutable
        , |i, old| {
            let old: &PackageMetadata = old;
            if (old.name == pack.name) {
                upgrade_number = old.upgrade_number + 1;
                check_upgradability(old, &pack, &module_names);
                index = i;
            } else {
                check_coexistence(old, &module_names)
            };
        });

        // Assign the upgrade counter.
        pack.upgrade_number = upgrade_number;

        let packages = &mut borrow_global_mut<PackageRegistry>(addr).packages;
        // Update registry
        let policy = pack.upgrade_policy;
        if (index < len) {
            *vector::borrow_mut(packages, index) = pack
        } else {
            vector::push_back(packages, pack)
        };
```

**File:** aptos-move/framework/aptos-framework/sources/code.move (L222-227)
```text
        if (features::code_dependency_check_enabled())
            request_publish_with_allowed_deps(addr, module_names, allowed_deps, code, policy.policy)
        else
        // The new `request_publish_with_allowed_deps` has not yet rolled out, so call downwards
        // compatible code.
            request_publish(addr, module_names, code, policy.policy)
```

**File:** aptos-move/framework/aptos-framework/sources/code.move (L256-259)
```text
    public entry fun publish_package_txn(owner: &signer, metadata_serialized: vector<u8>, code: vector<vector<u8>>)
    acquires PackageRegistry {
        publish_package(owner, util::from_bytes<PackageMetadata>(metadata_serialized), code)
    }
```

**File:** aptos-move/framework/aptos-framework/sources/code.move (L267-268)
```text
        assert!(old_pack.upgrade_policy.policy < upgrade_policy_immutable().policy,
            error::invalid_argument(EUPGRADE_IMMUTABLE));
```

**File:** aptos-move/framework/src/natives/code.rs (L295-333)
```rust
    let mut code = vec![];
    for module in safely_pop_arg!(args, Vec<Value>) {
        let module_code = module.value_as::<Vec<u8>>()?;

        context.charge(CODE_REQUEST_PUBLISH_PER_BYTE * NumBytes::new(module_code.len() as u64))?;
        code.push(module_code);
    }

    let allowed_deps = if with_allowed_deps {
        let mut allowed_deps: BTreeMap<AccountAddress, BTreeSet<String>> = BTreeMap::new();

        for dep in safely_pop_arg!(args, Vec<Value>) {
            let (account, module_name) = unpack_allowed_dep(dep)?;

            let entry = allowed_deps.entry(account);

            if let Entry::Vacant(_) = &entry {
                // TODO: Is the 32 here supposed to indicate the length of an account address in bytes?
                context.charge(CODE_REQUEST_PUBLISH_PER_BYTE * NumBytes::new(32))?;
            }

            context
                .charge(CODE_REQUEST_PUBLISH_PER_BYTE * NumBytes::new(module_name.len() as u64))?;
            entry.or_default().insert(module_name);
        }

        Some(allowed_deps)
    } else {
        None
    };

    let mut expected_modules = BTreeSet::new();
    for name in safely_pop_arg!(args, Vec<Value>) {
        let str = get_move_string(name)?;

        // TODO(Gas): fine tune the gas formula
        context.charge(CODE_REQUEST_PUBLISH_PER_BYTE * NumBytes::new(str.len() as u64))?;
        expected_modules.insert(str);
    }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1692-1738)
```rust
        for m in modules {
            if !expected_modules.remove(m.self_id().name().as_str()) {
                return Err(Self::metadata_validation_error(&format!(
                    "unregistered module: '{}'",
                    m.self_id().name()
                )));
            }
            if let Some(allowed) = &allowed_deps {
                for dep in m.immediate_dependencies() {
                    if !allowed
                        .get(dep.address())
                        .map(|modules| {
                            modules.contains("") || modules.contains(dep.name().as_str())
                        })
                        .unwrap_or(false)
                    {
                        return Err(Self::metadata_validation_error(&format!(
                            "unregistered dependency: '{}'",
                            dep
                        )));
                    }
                }
            }
            verify_module_metadata_for_module_publishing(m, self.features())
                .map_err(|err| Self::metadata_validation_error(&err.to_string()))?;
        }

        resource_groups::validate_resource_groups(
            self.features(),
            module_storage,
            traversal_context,
            gas_meter,
            modules,
        )?;
        event_validation::validate_module_events(
            self.features(),
            module_storage,
            traversal_context,
            modules,
        )?;

        if !expected_modules.is_empty() {
            return Err(Self::metadata_validation_error(
                "not all registered modules published",
            ));
        }
        Ok(())
```
