# Audit Report

## Title
Consensus Deadlock via Feature Flag Inconsistency in order_vote_enabled Configuration

## Summary
Validators can have inconsistent `order_vote_enabled` settings when on-chain configuration deserialization fails, causing hash verification failures during sync and potentially leading to consensus deadlock.

## Finding Description

The vulnerability exists in the consensus configuration loading and sync processing logic. When validators have inconsistent `order_vote_enabled` settings, they create incompatible `WrappedLedgerInfo` objects that cannot be processed by peers with different settings.

**Root Cause**: The epoch manager uses `unwrap_or_default()` as a fallback when on-chain consensus configuration loading fails: [1](#0-0) 

The default configuration sets `order_vote_enabled: false`: [2](#0-1) 

However, genesis and active networks use `order_vote_enabled: true`: [3](#0-2) 

**Attack Scenario**:

1. Validator A successfully loads on-chain config → `order_vote_enabled=true`
2. Validator B's config deserialization fails (logged as warning) → falls back to default → `order_vote_enabled=false`: [4](#0-3) 

3. Validator A creates `WrappedLedgerInfo` with `VoteData::dummy()` and `consensus_data_hash=HashValue::zero()`: [5](#0-4) [6](#0-5) 

4. Validator B receives this in a `SyncInfo` message and calls `certified_block(false)` on the received `WrappedLedgerInfo`: [7](#0-6) 

5. The `certified_block()` method passes the first check but calls `verify_consensus_data_hash()`: [8](#0-7) 

6. The hash verification checks if `vote_data.hash() == ledger_info().consensus_data_hash()`: [9](#0-8) 

7. Since `VoteData::dummy()` contains two `BlockInfo::empty()` structures: [10](#0-9) 

Its BCS-serialized SHA3-256 hash cannot equal `HashValue::zero()`, causing verification failure and sync deadlock.

## Impact Explanation

**Critical Severity** - This vulnerability meets the Critical category: "Total loss of liveness/network availability" and "Non-recoverable network partition."

If multiple validators fail to read the on-chain config and fall into the inconsistent state, they cannot sync with correctly-configured validators. If affected validators represent >1/3 of voting power, consensus will stall entirely. Recovery requires manual intervention (node restart, state wipe, or config override), potentially requiring coordinated network-wide recovery.

The error handling only logs warnings, so operators may not immediately detect the misconfiguration until consensus failures occur.

## Likelihood Explanation

**Medium Likelihood** - BCS deserialization can fail during network upgrades when configuration format changes, due to storage backend errors, data corruption, or version mismatches. The code provides no safeguards to validate that all validators have consistent feature flag settings before critical sync operations. During upgrades where `order_vote_enabled` is toggled, any validator that fails config loading will diverge from the network.

## Recommendation

1. **Add configuration validation** before entering new epoch to ensure all validators agree on critical feature flags
2. **Use more robust default fallback** that matches the expected network state (e.g., query peers for their config)
3. **Add explicit error handling** that prevents epoch transition if config loading fails
4. **Implement health checks** that detect configuration inconsistencies early and alert operators
5. **Add SyncInfo validation** to reject messages with incompatible `order_vote_enabled` indicators

## Proof of Concept

The vulnerability can be demonstrated by:
1. Simulating config deserialization failure on one validator (return error from `payload.get::<OnChainConsensusConfig>()`)
2. Having that validator fall back to default config with `order_vote_enabled=false`
3. Receiving a `SyncInfo` from a peer with `order_vote_enabled=true`
4. Observing hash verification failure in `verify_consensus_data_hash()` when processing the sync message

The PoC would require modifying the test framework to inject config loading failures and observe the resulting sync deadlock.

### Citations

**File:** consensus/src/epoch_manager.rs (L1187-1189)
```rust
        if let Err(error) = &onchain_consensus_config {
            warn!("Failed to read on-chain consensus config {}", error);
        }
```

**File:** consensus/src/epoch_manager.rs (L1201-1201)
```rust
        let consensus_config = onchain_consensus_config.unwrap_or_default();
```

**File:** types/src/on_chain_config/consensus_config.rs (L30-36)
```rust
    pub fn default_for_genesis() -> Self {
        Self::JolteonV2 {
            main: ConsensusConfigV1::default(),
            quorum_store_enabled: true,
            order_vote_enabled: true,
        }
    }
```

**File:** types/src/on_chain_config/consensus_config.rs (L46-52)
```rust
    pub fn default_if_missing() -> Self {
        Self::JolteonV2 {
            main: ConsensusConfigV1::default(),
            quorum_store_enabled: true,
            order_vote_enabled: false,
        }
    }
```

**File:** consensus/src/persistent_liveness_storage.rs (L149-150)
```rust
            let root_ordered_cert =
                WrappedLedgerInfo::new(VoteData::dummy(), latest_ledger_info_sig.clone());
```

**File:** consensus/src/pipeline/buffer_item.rs (L32-33)
```rust
        if order_vote_enabled {
            HashValue::zero()
```

**File:** consensus/src/block_storage/sync_manager.rs (L417-418)
```rust
            let highest_commit_certified_block =
                highest_commit_cert.certified_block(order_vote_enabled)?;
```

**File:** consensus/consensus-types/src/wrapped_ledger_info.rs (L53-62)
```rust
    fn verify_consensus_data_hash(&self) -> anyhow::Result<()> {
        let vote_hash = self.vote_data.hash();
        ensure!(
            self.ledger_info().ledger_info().consensus_data_hash() == vote_hash,
            "WrappedLedgerInfo's vote data hash mismatch LedgerInfo, {} {}",
            self.ledger_info(),
            self.vote_data
        );
        Ok(())
    }
```

**File:** consensus/consensus-types/src/wrapped_ledger_info.rs (L64-71)
```rust
    pub fn certified_block(&self, order_vote_enabled: bool) -> anyhow::Result<&BlockInfo> {
        ensure!(
            !order_vote_enabled,
            "wrapped_ledger_info.certified_block should not be called when order votes are enabled"
        );
        self.verify_consensus_data_hash()?;
        Ok(self.vote_data.proposed())
    }
```

**File:** consensus/consensus-types/src/vote_data.rs (L41-46)
```rust
    pub fn dummy() -> Self {
        Self {
            proposed: BlockInfo::empty(),
            parent: BlockInfo::empty(),
        }
    }
```
