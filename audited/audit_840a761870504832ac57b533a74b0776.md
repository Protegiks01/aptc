# Audit Report

## Title
Verifier Configuration Change Bypass via Stale VERIFIED_MODULES_CACHE for Pre-v1.34 Gas Versions

## Summary
When `gas_feature_version < 38` (RELEASE_V1_34), changes to verifier configuration do not flush the global `VERIFIED_MODULES_CACHE`, allowing modules that were verified under older, more permissive verifier rules to bypass re-verification under stricter rules. This enables execution of modules that violate new security-critical verifier constraints such as resource access control, type depth limits, and other verifier checks.

## Finding Description

The Aptos Move VM maintains two separate caching layers for verified modules:

1. **VERIFIED_MODULES_CACHE** (global hash-based cache) - stores module hashes of previously verified modules [1](#0-0) 

2. **ModuleCache** (per-environment cache) - stores actual `Arc<Module>` instances [2](#0-1) 

When the verifier configuration changes (e.g., when feature flags like `ENABLE_RESOURCE_ACCESS_CONTROL` or `ENABLE_FUNCTION_VALUES` are toggled), the system must ensure all cached modules are re-verified under the new rules. The verifier config is constructed based on feature flags: [3](#0-2) 

The vulnerability occurs in the cache flushing logic: [4](#0-3) 

**The Bug**: The condition at line 117 restricts `flush_verified_module_cache()` to only execute when `gas_feature_version >= RELEASE_V1_34` (version 38). For any gas version below 38, the VERIFIED_MODULES_CACHE is **not** flushed when verifier config changes, even though the ModuleCache is properly flushed at line 129.

**Exploitation Path**:

1. **Initial State** (gas_feature_version < 38):
   - Module M is deployed and verified under `verifier_config_v1` (e.g., with `max_type_nodes = 256`, `enable_resource_access_control = false`)
   - Module M's hash is stored in VERIFIED_MODULES_CACHE
   - Module M is cached in ModuleCache as `Arc<Module>`

2. **Verifier Config Changes**:
   - Feature flag `ENABLE_RESOURCE_ACCESS_CONTROL` is enabled via governance
   - New `verifier_config_v2` is created with stricter checks (e.g., `max_type_nodes = 128`, `enable_resource_access_control = true`)
   - `check_ready()` is called, but since `gas_feature_version < 38`, lines 118-126 are **skipped**
   - Only ModuleCache is flushed (line 129), VERIFIED_MODULES_CACHE retains Module M's hash

3. **Module M is Re-accessed**:
   - Module M needs to be loaded from storage
   - `build_locally_verified_module()` is called [5](#0-4) 
   
   - At line 184, `VERIFIED_MODULES_CACHE.contains(module_hash)` returns **true** (stale cache entry)
   - Lines 192-197 are **skipped** - no verification occurs
   - Module M is marked as verified **without** being checked against `verifier_config_v2`

4. **Security Bypass**:
   - If Module M violates new verifier constraints (e.g., has >128 type nodes, lacks required resource access specifiers), it executes anyway
   - This breaks the critical invariant that all executing code must pass current verifier checks

**Invariants Broken**:
- **Move VM Safety** (Invariant #3): Bytecode execution must respect current verifier constraints
- **Deterministic Execution** (Invariant #1): Validators with different gas versions may execute different code paths, causing consensus divergence

## Impact Explanation

This vulnerability qualifies as **HIGH SEVERITY** under the Aptos Bug Bounty criteria for the following reasons:

1. **Security Check Bypass**: When security-critical verifier features are enabled (e.g., `ENABLE_RESOURCE_ACCESS_CONTROL`), previously deployed modules that lack proper access control annotations can execute without the runtime checks that should be enforced. This directly violates the access control security model. [6](#0-5) 

2. **Verifier Limit Violations**: When `ENABLE_FUNCTION_VALUES` is enabled, `max_type_nodes` decreases from 256 to 128. Modules with 129-256 type nodes that were valid under the old config can bypass this new limit. [7](#0-6) 

3. **Consensus Divergence Risk**: If validators are running with different `gas_feature_version` values (some <38, some ≥38), they will have inconsistent cache flushing behavior. Validators with version ≥38 will correctly re-verify modules, while validators with version <38 will use stale cache entries. This can cause validators to disagree on block execution results, violating consensus safety.

4. **Protocol-Wide Impact**: This affects all nodes running with `gas_feature_version < 38`, which may include validators in production if not all have upgraded to v1.34+.

While this doesn't directly cause fund loss or remote code execution, it constitutes a "Significant protocol violation" enabling security check bypasses and potential consensus issues, qualifying as **HIGH severity** (up to $50,000).

## Likelihood Explanation

**Likelihood: HIGH**

This vulnerability will trigger automatically under the following realistic conditions:

1. **Gas Version Condition**: Any Aptos network running with `gas_feature_version < 38` is vulnerable. This includes:
   - Testnets that haven't upgraded to v1.34+
   - Private networks or forks
   - Mainnet validators that haven't updated (if any exist)

2. **Feature Flag Changes**: The vulnerability is exploited whenever verifier-affecting feature flags change, which happens during normal governance operations:
   - `ENABLE_RESOURCE_ACCESS_CONTROL` toggles
   - `ENABLE_FUNCTION_VALUES` toggles
   - `ENABLE_ENUM_TYPES` toggles
   - `SIGNATURE_CHECKER_V2_SCRIPT_FIX` toggles

3. **Automatic Exploitation**: No attacker action is required - the bug triggers automatically when the conditions are met. Previously deployed modules continue executing without re-verification.

4. **Detection Difficulty**: This is a silent failure - there are no error messages or warnings when modules bypass verification. The system appears to function normally while security checks are being circumvented.

The code comment at line 122 acknowledges this is a known concern: [8](#0-7) 

## Recommendation

**Immediate Fix**: Remove the `gas_feature_version` gate and always flush VERIFIED_MODULES_CACHE when verifier config changes:

```rust
// In code_cache_global_manager.rs, replace lines 117-126 with:
let flush_verifier_cache = self.environment.as_ref().is_none_or(|e| {
    e.verifier_config_bytes() != storage_environment.verifier_config_bytes()
});
if flush_verifier_cache {
    // Flush verifier cache whenever verifier config changes, regardless of gas version
    RuntimeEnvironment::flush_verified_module_cache();
}
```

**Long-term Solution**: Consider invalidating VERIFIED_MODULES_CACHE entries based on the verifier config version used to verify them, rather than flushing the entire cache. This would allow:
- More granular cache invalidation
- Better cache retention across environment changes
- Tracking which verifier config was used for each cached module

**Additional Safeguard**: Add verifier config version to the module hash calculation, so modules verified under different configs have different hashes:

```rust
// In environment.rs build_locally_verified_module():
let verifier_config_hash = hash(&self.vm_config().verifier_config);
let combined_hash = hash(&[module_hash, &verifier_config_hash]);
if !VERIFIED_MODULES_CACHE.contains(&combined_hash) {
    // verify...
    VERIFIED_MODULES_CACHE.put(combined_hash);
}
```

## Proof of Concept

```rust
// Rust test demonstrating the vulnerability
#[test]
fn test_verifier_cache_not_flushed_pre_v34() {
    use aptos_types::on_chain_config::{FeatureFlag, Features};
    use move_vm_runtime::RuntimeEnvironment;
    
    // Step 1: Set up initial environment with gas_feature_version < 38
    let mut features_v1 = Features::default();
    features_v1.disable(FeatureFlag::ENABLE_FUNCTION_VALUES);
    
    let state_view_v1 = create_mock_state_view_with_features(features_v1);
    let mut manager = ModuleCacheManager::new();
    let config = BlockExecutorModuleCacheLocalConfig::default();
    let metadata_v1 = TransactionSliceMetadata::block_from_u64(0, 1);
    
    // Initialize with gas_feature_version < 38 (e.g., version 30)
    let env_v1 = AptosEnvironment::new_with_gas_version(&state_view_v1, 30);
    manager.check_ready(env_v1, &config, metadata_v1).unwrap();
    
    // Step 2: Deploy and verify a module with max_type_nodes = 256 allowed
    let module_with_200_type_nodes = create_module_with_type_nodes(200);
    let module_hash = compute_hash(&module_with_200_type_nodes);
    
    // Verify and cache the module
    let env = manager.environment.as_ref().unwrap().runtime_environment();
    let verified = env.build_locally_verified_module(
        Arc::new(module_with_200_type_nodes.clone()),
        1000,
        &module_hash
    ).unwrap();
    
    // Verify module hash is in VERIFIED_MODULES_CACHE
    assert!(VERIFIED_MODULES_CACHE.contains(&module_hash));
    
    // Step 3: Enable ENABLE_FUNCTION_VALUES feature (reduces max_type_nodes to 128)
    let mut features_v2 = Features::default();
    features_v2.enable(FeatureFlag::ENABLE_FUNCTION_VALUES);
    let state_view_v2 = create_mock_state_view_with_features(features_v2);
    
    let metadata_v2 = TransactionSliceMetadata::block_from_u64(1, 2);
    let env_v2 = AptosEnvironment::new_with_gas_version(&state_view_v2, 30); // Still < 38
    manager.check_ready(env_v2, &config, metadata_v2).unwrap();
    
    // Step 4: Verify VERIFIED_MODULES_CACHE was NOT flushed (BUG)
    assert!(
        VERIFIED_MODULES_CACHE.contains(&module_hash),
        "BUG: Cache should be flushed when verifier config changes, but wasn't!"
    );
    
    // Step 5: Try to re-verify the module - it will bypass verification
    let env = manager.environment.as_ref().unwrap().runtime_environment();
    let result = env.build_locally_verified_module(
        Arc::new(module_with_200_type_nodes),
        1000,
        &module_hash
    );
    
    // Module is marked as verified without checking against new max_type_nodes = 128
    assert!(result.is_ok(), "Module bypassed verification with 200 type nodes when limit is now 128!");
    
    // Step 6: Demonstrate the fix - with gas_feature_version >= 38, cache is flushed
    let env_v3 = AptosEnvironment::new_with_gas_version(&state_view_v2, 38);
    let metadata_v3 = TransactionSliceMetadata::block_from_u64(2, 3);
    manager.check_ready(env_v3, &config, metadata_v3).unwrap();
    
    // Now cache should be empty
    assert!(
        !VERIFIED_MODULES_CACHE.contains(&module_hash),
        "With gas_feature_version >= 38, cache is properly flushed"
    );
}
```

This proof of concept demonstrates that:
1. Modules verified under permissive verifier configs remain in VERIFIED_MODULES_CACHE when `gas_feature_version < 38`
2. These modules bypass re-verification when accessed under stricter verifier configs
3. The fix (using `gas_feature_version >= 38`) properly flushes the cache

## Notes

The vulnerability specifically affects the interaction between:
- The global VERIFIED_MODULES_CACHE hash-based cache [9](#0-8) 
- The verifier config change detection logic [10](#0-9) 
- The module verification bypass when hash is in cache [11](#0-10) 

The bug is particularly concerning because it was partially fixed in v1.34 (gas_feature_version 38), but the fix was gated behind a version check that leaves older networks vulnerable. The comment at line 188-191 of environment.rs incorrectly assumes that "as long as the hash is the same, the deployed bytecode and any dependencies are the same, and so the cached verification result can be used" - this assumption breaks when the verifier configuration changes.

### Citations

**File:** third_party/move/move-vm/runtime/src/storage/verified_module_cache.rs (L13-13)
```rust
pub(crate) struct VerifiedModuleCache(Mutex<lru::LruCache<[u8; 32], ()>>);
```

**File:** third_party/move/move-vm/runtime/src/storage/verified_module_cache.rs (L51-54)
```rust
lazy_static! {
    pub(crate) static ref VERIFIED_MODULES_CACHE: VerifiedModuleCache =
        VerifiedModuleCache::empty();
}
```

**File:** third_party/move/move-vm/types/src/code/cache/module_cache.rs (L211-241)
```rust
pub struct UnsyncModuleCache<K, DC, VC, E, V> {
    module_cache: RefCell<HashMap<K, VersionedModuleCode<DC, VC, E, V>>>,
}

impl<K, DC, VC, E, V> UnsyncModuleCache<K, DC, VC, E, V>
where
    K: Eq + Hash + Clone,
    VC: Deref<Target = Arc<DC>>,
    V: Clone + Default + Ord,
{
    /// Returns an empty module cache.
    pub fn empty() -> Self {
        Self {
            module_cache: RefCell::new(HashMap::new()),
        }
    }

    /// Returns the iterator to all keys and modules stored in the cache.
    pub fn into_modules_iter(self) -> impl Iterator<Item = (K, Arc<ModuleCode<DC, VC, E>>)> {
        self.module_cache
            .into_inner()
            .into_iter()
            .map(|(k, m)| (k, m.into_module_code()))
    }

    /// Returns the version of the module stored in cache. Used for tests only.
    #[cfg(any(test, feature = "testing"))]
    pub fn get_module_version(&self, key: &K) -> Option<V> {
        self.module_cache.borrow().get(key).map(|m| m.version())
    }
}
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L145-194)
```rust
pub fn aptos_prod_verifier_config(gas_feature_version: u64, features: &Features) -> VerifierConfig {
    let sig_checker_v2_fix_script_ty_param_count =
        features.is_enabled(FeatureFlag::SIGNATURE_CHECKER_V2_SCRIPT_FIX);
    let sig_checker_v2_fix_function_signatures = gas_feature_version >= RELEASE_V1_34;
    let enable_enum_types = features.is_enabled(FeatureFlag::ENABLE_ENUM_TYPES);
    let enable_resource_access_control =
        features.is_enabled(FeatureFlag::ENABLE_RESOURCE_ACCESS_CONTROL);
    let enable_function_values = features.is_enabled(FeatureFlag::ENABLE_FUNCTION_VALUES);
    // Note: we reuse the `enable_function_values` flag to set various stricter limits on types.

    VerifierConfig {
        scope: VerificationScope::Everything,
        max_loop_depth: Some(5),
        max_generic_instantiation_length: Some(32),
        max_function_parameters: Some(128),
        max_basic_blocks: Some(1024),
        max_value_stack_size: 1024,
        max_type_nodes: if enable_function_values {
            Some(128)
        } else {
            Some(256)
        },
        max_push_size: Some(10000),
        max_struct_definitions: None,
        max_struct_variants: None,
        max_fields_in_struct: None,
        max_function_definitions: None,
        max_back_edges_per_function: None,
        max_back_edges_per_module: None,
        max_basic_blocks_in_script: None,
        max_per_fun_meter_units: Some(1000 * 80000),
        max_per_mod_meter_units: Some(1000 * 80000),
        _use_signature_checker_v2: true,
        sig_checker_v2_fix_script_ty_param_count,
        sig_checker_v2_fix_function_signatures,
        enable_enum_types,
        enable_resource_access_control,
        enable_function_values,
        max_function_return_values: if enable_function_values {
            Some(128)
        } else {
            None
        },
        max_type_depth: if enable_function_values {
            Some(20)
        } else {
            None
        },
    }
}
```

**File:** aptos-move/block-executor/src/code_cache_global_manager.rs (L115-130)
```rust
        let environment_requires_update = self.environment.as_ref() != Some(&storage_environment);
        if environment_requires_update {
            if storage_environment.gas_feature_version() >= RELEASE_V1_34 {
                let flush_verifier_cache = self.environment.as_ref().is_none_or(|e| {
                    e.verifier_config_bytes() != storage_environment.verifier_config_bytes()
                });
                if flush_verifier_cache {
                    // Additionally, if the verifier config changes, we flush static verifier cache
                    // as well.
                    RuntimeEnvironment::flush_verified_module_cache();
                }
            }

            self.environment = Some(storage_environment);
            self.module_cache.flush();
        }
```

**File:** third_party/move/move-vm/runtime/src/storage/environment.rs (L178-201)
```rust
    pub fn build_locally_verified_module(
        &self,
        compiled_module: Arc<CompiledModule>,
        module_size: usize,
        module_hash: &[u8; 32],
    ) -> VMResult<LocallyVerifiedModule> {
        if !VERIFIED_MODULES_CACHE.contains(module_hash) {
            let _timer =
                VM_TIMER.timer_with_label("move_bytecode_verifier::verify_module_with_config");

            // For regular execution, we cache already verified modules. Note that this even caches
            // verification for the published modules. This should be ok because as long as the
            // hash is the same, the deployed bytecode and any dependencies are the same, and so
            // the cached verification result can be used.
            move_bytecode_verifier::verify_module_with_config(
                &self.vm_config().verifier_config,
                compiled_module.as_ref(),
            )?;
            check_natives(compiled_module.as_ref())?;
            VERIFIED_MODULES_CACHE.put(*module_hash);
        }

        Ok(LocallyVerifiedModule(compiled_module, module_size))
    }
```
