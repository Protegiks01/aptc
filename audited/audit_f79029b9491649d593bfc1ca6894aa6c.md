# Audit Report

## Title
Validator Node Crash via Panic in schemadb decode_value() During Critical State Reads

## Summary
If `decode_value()` panics during BCS deserialization in schemadb operations, the validator node process will crash with `process::exit(12)` due to the global panic handler. This affects critical consensus recovery paths and state reads, causing complete loss of validator availability.

## Finding Description

The vulnerability chain is as follows:

1. **SchemaDB `get()` calls `decode_value()` without panic handling** [1](#0-0) 

2. **Consensus recovery calls `storage.start()` which retrieves blocks and QCs** [2](#0-1) 

3. **ConsensusDB.get_data() internally uses schemadb get operations** [3](#0-2) 

4. **Global panic handler terminates process on panics (except VERIFIER/DESERIALIZER)** [4](#0-3) 

5. **Panic handler is installed at validator node startup** [5](#0-4) 

6. **EpochManager spawned with tokio, but panic handler overrides default behavior** [6](#0-5) 

**Key Issue**: SchemaDB decode operations do NOT set `VMState::DESERIALIZER` (which is only for Move bytecode), so panics trigger `process::exit(12)`. [7](#0-6) 

**Defense Gap**: Unlike Move module deserialization, schemadb operations lack `catch_unwind` protection. [8](#0-7) 

While fuzzing exists to prevent panics, it cannot guarantee zero panics across all scenarios: [9](#0-8) 

## Impact Explanation

**Critical Severity** - This meets the "Total loss of liveness/network availability" criterion because:

- **Consensus Unavailable**: If decode panics during consensus recovery (`storage.start()`), the validator exits immediately and cannot participate in consensus
- **Deterministic Crash**: If corrupted data exists in storage, every restart attempt will hit the same panic, causing crash loops
- **Network-wide Impact**: If multiple validators encounter similar issues (e.g., from a consensus bug that allowed bad data), network liveness degrades
- **No Graceful Degradation**: Unlike error returns which allow recovery mode, panics offer no fallback

## Likelihood Explanation

**Low-to-Medium Likelihood**:

**Mitigating Factors**:
- Comprehensive fuzzing tests exist for all schemas
- BCS library is well-tested
- Deterministic serialization means valid data serializes and deserializes correctly

**Risk Factors**:
- Disk corruption or memory corruption could create un-decodeable data
- Undiscovered BCS library edge cases
- Supply chain risk from BCS dependency updates
- No runtime defense-in-depth (catch_unwind) unlike Move VM operations

## Recommendation

Implement defensive panic catching for all schemadb decode operations, similar to Move module deserialization:

```rust
// In storage/schemadb/src/lib.rs, modify get() method:
pub fn get<S: Schema>(&self, schema_key: &S::Key) -> DbResult<Option<S::Value>> {
    let _timer = APTOS_SCHEMADB_GET_LATENCY_SECONDS.timer_with(&[S::COLUMN_FAMILY_NAME]);
    
    let k = <S::Key as KeyCodec<S>>::encode_key(schema_key)?;
    let cf_handle = self.get_cf_handle(S::COLUMN_FAMILY_NAME)?;
    
    let result = self.inner.get_cf(cf_handle, k).into_db_res()?;
    APTOS_SCHEMADB_GET_BYTES.observe_with(
        &[S::COLUMN_FAMILY_NAME],
        result.as_ref().map_or(0.0, |v| v.len() as f64),
    );
    
    // Add panic protection
    result
        .map(|raw_value| {
            std::panic::catch_unwind(|| {
                <S::Value as ValueCodec<S>>::decode_value(&raw_value)
            })
            .unwrap_or_else(|_| {
                Err(anyhow::anyhow!(
                    "Panic during decode_value for schema {} - possible data corruption",
                    S::COLUMN_FAMILY_NAME
                ))
            })
        })
        .transpose()
        .map_err(Into::into)
}
```

This provides defense-in-depth without impacting normal operation.

## Proof of Concept

**Note**: This vulnerability cannot be exploited by an unprivileged attacker as there is no way to inject malformed data into validator storage. However, it represents a reliability and defensive programming concern.

To demonstrate the crash behavior (requires manual data corruption):

```rust
// Test demonstrating panic propagation (for illustration only)
#[test]
#[should_panic]
fn test_decode_panic_crashes_without_catch_unwind() {
    // Simulate corrupted data that causes BCS panic
    let corrupted_data = vec![0xFF; 100]; // Invalid BCS encoding
    
    // Without catch_unwind, this would propagate to panic handler
    let result: Result<Transaction, _> = bcs::from_bytes(&corrupted_data);
    
    // In production, this panic would trigger process::exit(12)
    result.expect("Should panic on corrupted data");
}
```

The actual exploitation requires physical access or hardware failure - not a remote attack vector.

## Notes

While the investigation confirms that a panic in `decode_value()` **will** crash validator nodes, this fails the exploitability requirement: there is no realistic attack path for an unprivileged attacker to cause such a panic. The issue is better characterized as a **defensive programming/reliability concern** rather than an exploitable security vulnerability, as data corruption scenarios are not attacker-controlled.

### Citations

**File:** storage/schemadb/src/lib.rs (L216-232)
```rust
    pub fn get<S: Schema>(&self, schema_key: &S::Key) -> DbResult<Option<S::Value>> {
        let _timer = APTOS_SCHEMADB_GET_LATENCY_SECONDS.timer_with(&[S::COLUMN_FAMILY_NAME]);

        let k = <S::Key as KeyCodec<S>>::encode_key(schema_key)?;
        let cf_handle = self.get_cf_handle(S::COLUMN_FAMILY_NAME)?;

        let result = self.inner.get_cf(cf_handle, k).into_db_res()?;
        APTOS_SCHEMADB_GET_BYTES.observe_with(
            &[S::COLUMN_FAMILY_NAME],
            result.as_ref().map_or(0.0, |v| v.len() as f64),
        );

        result
            .map(|raw_value| <S::Value as ValueCodec<S>>::decode_value(&raw_value))
            .transpose()
            .map_err(Into::into)
    }
```

**File:** consensus/src/persistent_liveness_storage.rs (L520-524)
```rust
        info!("Start consensus recovery.");
        let raw_data = self
            .db
            .get_data()
            .expect("unable to recover consensus data");
```

**File:** consensus/src/consensusdb/mod.rs (L207-209)
```rust
    pub fn get<S: Schema>(&self, key: &S::Key) -> Result<Option<S::Value>, DbError> {
        Ok(self.db.get::<S>(key)?)
    }
```

**File:** crates/crash-handler/src/lib.rs (L26-58)
```rust
pub fn setup_panic_handler() {
    panic::set_hook(Box::new(move |pi: &PanicHookInfo<'_>| {
        handle_panic(pi);
    }));
}

// Formats and logs panic information
fn handle_panic(panic_info: &PanicHookInfo<'_>) {
    // The Display formatter for a PanicHookInfo contains the message, payload and location.
    let details = format!("{}", panic_info);
    let backtrace = format!("{:#?}", Backtrace::new());

    let info = CrashInfo { details, backtrace };
    let crash_info = toml::to_string_pretty(&info).unwrap();
    error!("{}", crash_info);
    // TODO / HACK ALARM: Write crash info synchronously via eprintln! to ensure it is written before the process exits which error! doesn't guarantee.
    // This is a workaround until https://github.com/aptos-labs/aptos-core/issues/2038 is resolved.
    eprintln!("{}", crash_info);

    // Wait till the logs have been flushed
    aptos_logger::flush();

    // Do not kill the process if the panics happened at move-bytecode-verifier.
    // This is safe because the `state::get_state()` uses a thread_local for storing states. Thus the state can only be mutated to VERIFIER by the thread that's running the bytecode verifier.
    //
    // TODO: once `can_unwind` is stable, we should assert it. See https://github.com/rust-lang/rust/issues/92988.
    if state::get_state() == VMState::VERIFIER || state::get_state() == VMState::DESERIALIZER {
        return;
    }

    // Kill the process
    process::exit(12);
}
```

**File:** aptos-node/src/lib.rs (L233-234)
```rust
    // Setup panic handler
    aptos_crash_handler::setup_panic_handler();
```

**File:** consensus/src/consensus_provider.rs (L119-120)
```rust
    runtime.spawn(network_task.start());
    runtime.spawn(epoch_mgr.start(timeout_receiver, network_receiver));
```

**File:** third_party/move/move-binary-format/src/deserializer.rs (L52-71)
```rust
    pub fn deserialize_with_config(
        binary: &[u8],
        config: &DeserializerConfig,
    ) -> BinaryLoaderResult<Self> {
        let prev_state = move_core_types::state::set_state(VMState::DESERIALIZER);
        let result = std::panic::catch_unwind(|| {
            let module = deserialize_compiled_module(binary, config)?;
            BoundsChecker::verify_module(&module)?;

            Ok(module)
        })
        .unwrap_or_else(|_| {
            Err(PartialVMError::new(
                StatusCode::VERIFIER_INVARIANT_VIOLATION,
            ))
        });
        move_core_types::state::set_state(prev_state);

        result
    }
```

**File:** storage/schemadb/src/schema.rs (L165-170)
```rust
    /// Helper used in tests and fuzzers to make sure a schema never panics when decoding random bytes.
    #[allow(unused_must_use)]
    pub fn assert_no_panic_decoding<S: Schema>(bytes: &[u8]) {
        S::Key::decode_key(bytes);
        S::Value::decode_value(bytes);
    }
```
