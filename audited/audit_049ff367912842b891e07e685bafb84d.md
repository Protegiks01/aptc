# Audit Report

## Title
Unmetered Resource Exhaustion via Excessive Struct Handles in Script Loading

## Summary
An attacker can submit script transactions containing thousands of struct handles that trigger unmetered CPU-intensive processing during `Script::new()`, causing validator performance degradation. The processing loop iterates over all struct handles performing expensive operations including string cloning, hash map lookups, and synchronization primitives, with no gas metering or explicit limits on the number of handles.

## Finding Description

The vulnerability exists in the script loading pipeline where `Script::new()` performs unmetered processing of struct handles without any gas metering or count limits. [1](#0-0) 

This loop iterates over every struct handle in the script, performing:
1. Array lookups for identifiers and module handles
2. Module ID creation with string clones via `to_owned()`
3. `StructIdentifier::new()` which interns module IDs and clones strings
4. `struct_name_index_map.struct_name_to_idx()` which performs expensive operations

The `struct_name_to_idx` function acquires read/write locks, performs BTreeMap lookups (O(log n)), and clones the struct identifier twice on cache misses: [2](#0-1) 

**Attack Path:**

1. Attacker crafts a malicious script with maximum struct handles within transaction size limits
2. Binary format allows up to 65,535 struct handles (u16 index type)
3. Transaction size limit is 64 KB for regular transactions: [3](#0-2) 
4. With careful encoding (short identifiers, reused addresses/modules, minimal bytecode), attacker can fit ~10,000-15,000 struct handles within 64 KB
5. Script is submitted as a valid transaction payload (scripts are actively supported)
6. During script loading, the unmetered verification path calls `build_verified_script`: [4](#0-3) 
7. This invokes `Script::new()` which performs unmetered iteration over all struct handles
8. For 10,000+ handles, this causes significant CPU consumption through string operations, lock contention, and BTreeMap operations

**Verification Gaps:**

The bytecode verifier only checks type parameters within each struct handle, not the total count: [5](#0-4) 

The `VerifierConfig` has no limit for total struct handle count in scripts: [6](#0-5) 

While modules have `max_struct_definitions`, scripts have no equivalent limit for struct *handles* (references to external structs): [7](#0-6) 

**Cache Bypass:**

While scripts are cached by hash, attackers can submit many unique scripts by changing a few bytes, forcing repeated processing: [8](#0-7) 

## Impact Explanation

This qualifies as **High Severity** under Aptos bug bounty criteria: "Validator node slowdowns."

- Each malicious script could consume 10-100+ milliseconds of unmetered CPU time depending on handle count and cache state
- Attacker can submit multiple unique scripts to amplify the effect
- No gas is charged for this processing, making the attack economically cheap
- Could degrade validator performance during block production
- Affects all validators processing the same transactions
- Could be used strategically during critical operations to slow consensus

The attack breaks the principle that all computational work should be metered and limited. Operations during script loading do not respect computational limits or gas metering.

## Likelihood Explanation

**High Likelihood:**
- Scripts are fully supported transaction types (confirmed by usage throughout the codebase including [9](#0-8) )
- No special permissions required - any user can submit script transactions
- Attack is technically straightforward - craft binary with many struct handle entries
- Transaction size limit (64 KB) allows sufficient struct handles for impact
- Caching only prevents identical scripts, easily bypassed with minor variations
- No monitoring or rate limiting specifically for this attack pattern
- The vulnerable code path is executed for every new/unique script submitted

## Recommendation

Add a configurable limit for the maximum number of struct handles allowed in scripts, similar to `max_struct_definitions` for modules:

1. Add `max_struct_handles: Option<usize>` to `VerifierConfig`
2. Implement validation in `LimitsVerifier::verify_script_impl()` to check total struct handle count
3. Return `StatusCode::TOO_MANY_STRUCT_HANDLES` if the limit is exceeded
4. Set a reasonable production limit (e.g., 1000-2000 struct handles)

Alternatively, charge gas proportional to the number of struct handles during script verification, ensuring the processing time is properly metered and limited by the transaction's gas budget.

## Proof of Concept

A complete PoC would require generating a Move script bytecode with thousands of struct handles. The attack works as follows:

1. Generate a CompiledScript with minimal code but maximum struct_handles entries
2. Each StructHandle references unique or partially unique module/name combinations
3. Serialize the script to bytes (ensuring size < 64KB)
4. Submit as Script transaction payload
5. Observe unmetered processing time during script loading

The vulnerability is confirmed by code inspection showing the unmetered loop in `Script::new()` with no limits on struct handle count in the verifier configuration.

### Citations

**File:** third_party/move/move-vm/runtime/src/loader/script.rs (L62-70)
```rust
        let mut struct_names = vec![];
        for struct_handle in script.struct_handles() {
            let struct_name = script.identifier_at(struct_handle.name);
            let module_handle = script.module_handle_at(struct_handle.module);
            let module_id = script.module_id_for_handle(module_handle);
            let struct_name =
                StructIdentifier::new(module_id_pool, module_id, struct_name.to_owned());
            struct_names.push(struct_name_index_map.struct_name_to_idx(&struct_name)?);
        }
```

**File:** third_party/move/move-vm/types/src/loaded_data/struct_name_indexing.rs (L70-99)
```rust
    pub fn struct_name_to_idx(
        &self,
        struct_name: &StructIdentifier,
    ) -> PartialVMResult<StructNameIndex> {
        {
            let index_map = self.0.read();
            if let Some(idx) = index_map.forward_map.get(struct_name) {
                return Ok(StructNameIndex(*idx));
            }
        }

        // Possibly need to insert, so make the copies outside of the lock.
        let forward_key = struct_name.clone();
        let backward_value = Arc::new(struct_name.clone());

        let idx = {
            let mut index_map = self.0.write();

            if let Some(idx) = index_map.forward_map.get(struct_name) {
                return Ok(StructNameIndex(*idx));
            }

            let idx = index_map.backward_map.len() as u32;
            index_map.backward_map.push(backward_value);
            index_map.forward_map.insert(forward_key, idx);
            idx
        };

        Ok(StructNameIndex(idx))
    }
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L73-76)
```rust
            max_transaction_size_in_bytes: NumBytes,
            "max_transaction_size_in_bytes",
            64 * 1024
        ],
```

**File:** third_party/move/move-vm/runtime/src/storage/environment.rs (L154-173)
```rust
    pub fn build_verified_script(
        &self,
        locally_verified_script: LocallyVerifiedScript,
        immediate_dependencies: &[Arc<Module>],
    ) -> VMResult<Script> {
        dependencies::verify_script(
            &self.vm_config.verifier_config,
            locally_verified_script.0.as_ref(),
            immediate_dependencies
                .iter()
                .map(|module| module.as_ref().as_ref()),
        )?;
        Script::new(
            locally_verified_script.0,
            self.struct_name_index_map(),
            self.ty_pool(),
            self.module_id_pool(),
        )
        .map_err(|err| err.finish(Location::Script))
    }
```

**File:** third_party/move/move-bytecode-verifier/src/limits.rs (L53-63)
```rust
    fn verify_struct_handles(&self, config: &VerifierConfig) -> PartialVMResult<()> {
        if let Some(limit) = config.max_generic_instantiation_length {
            for (idx, struct_handle) in self.resolver.struct_handles().iter().enumerate() {
                if struct_handle.type_parameters.len() > limit {
                    return Err(PartialVMError::new(StatusCode::TOO_MANY_TYPE_PARAMETERS)
                        .at_index(IndexKind::StructHandle, idx as u16));
                }
            }
        }
        Ok(())
    }
```

**File:** third_party/move/move-bytecode-verifier/src/limits.rs (L197-214)
```rust
    fn verify_definitions(&self, config: &VerifierConfig) -> PartialVMResult<()> {
        if let Some(defs) = self.resolver.function_defs() {
            if let Some(max_function_definitions) = config.max_function_definitions {
                if defs.len() > max_function_definitions {
                    return Err(PartialVMError::new(
                        StatusCode::MAX_FUNCTION_DEFINITIONS_REACHED,
                    ));
                }
            }
        }
        if let Some(defs) = self.resolver.struct_defs() {
            if let Some(max_struct_definitions) = config.max_struct_definitions {
                if defs.len() > max_struct_definitions {
                    return Err(PartialVMError::new(
                        StatusCode::MAX_STRUCT_DEFINITIONS_REACHED,
                    ));
                }
            }
```

**File:** third_party/move/move-bytecode-verifier/src/verifier.rs (L36-67)
```rust
pub struct VerifierConfig {
    pub scope: VerificationScope,
    pub max_loop_depth: Option<usize>,
    pub max_function_parameters: Option<usize>,
    pub max_generic_instantiation_length: Option<usize>,
    pub max_basic_blocks: Option<usize>,
    pub max_value_stack_size: usize,
    pub max_type_nodes: Option<usize>,
    pub max_push_size: Option<usize>,
    pub max_struct_definitions: Option<usize>,
    pub max_struct_variants: Option<usize>,
    pub max_fields_in_struct: Option<usize>,
    pub max_function_definitions: Option<usize>,
    pub max_back_edges_per_function: Option<usize>,
    pub max_back_edges_per_module: Option<usize>,
    pub max_basic_blocks_in_script: Option<usize>,
    pub max_per_fun_meter_units: Option<u128>,
    pub max_per_mod_meter_units: Option<u128>,
    // signature checker v2 is enabled on mainnet and cannot be disabled
    pub _use_signature_checker_v2: bool,
    pub sig_checker_v2_fix_script_ty_param_count: bool,
    pub enable_enum_types: bool,
    pub enable_resource_access_control: bool,
    pub enable_function_values: bool,
    /// Maximum number of function return values.
    pub max_function_return_values: Option<usize>,
    /// Maximum depth of a type node.
    pub max_type_depth: Option<usize>,
    /// If enabled, signature checker V2 also checks parameter and return types in function
    /// signatures.
    pub sig_checker_v2_fix_function_signatures: bool,
}
```

**File:** third_party/move/move-vm/runtime/src/storage/loader/eager.rs (L106-138)
```rust
    fn unmetered_verify_and_cache_script(&self, serialized_script: &[u8]) -> VMResult<Arc<Script>> {
        use Code::*;

        let hash = sha3_256(serialized_script);
        let deserialized_script = match self.module_storage.get_script(&hash) {
            Some(Verified(script)) => return Ok(script),
            Some(Deserialized(deserialized_script)) => deserialized_script,
            None => self
                .runtime_environment()
                .deserialize_into_script(serialized_script)
                .map(Arc::new)?,
        };

        let locally_verified_script = self
            .runtime_environment()
            .build_locally_verified_script(deserialized_script)?;

        let immediate_dependencies = locally_verified_script
            .immediate_dependencies_iter()
            .map(|(addr, name)| {
                self.module_storage
                    .unmetered_get_existing_eagerly_verified_module(addr, name)
            })
            .collect::<VMResult<Vec<_>>>()?;

        let verified_script = self
            .runtime_environment()
            .build_verified_script(locally_verified_script, &immediate_dependencies)?;

        Ok(self
            .module_storage
            .insert_verified_script(hash, verified_script))
    }
```

**File:** types/src/transaction/mod.rs (L77-86)
```rust
pub use change_set::ChangeSet;
pub use module::{Module, ModuleBundle};
pub use move_core_types::transaction_argument::TransactionArgument;
use move_core_types::{
    value::{MoveStruct, MoveValue},
    vm_status::AbortLocation,
};
pub use multisig::{ExecutionError, Multisig, MultisigTransactionPayload};
use once_cell::sync::OnceCell;
pub use script::{
```
