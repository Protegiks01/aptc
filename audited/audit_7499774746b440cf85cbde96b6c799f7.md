# Audit Report

## Title
Inverted Role Logic in Peer::extend() Causes Validator Startup Panic During Seed Configuration Merge

## Summary
The `Peer::extend()` method in `config/src/config/network_config.rs` contains inverted comparison logic that returns an error when peer roles match, contradicting its error message. This causes validator startup to panic when merging seed configurations where the same peer ID appears in both legacy `seed_addrs` and modern `seeds` with matching roles, leading to validator crashes and potential network liveness issues during reconfiguration.

## Finding Description

The vulnerability exists in the `Peer::extend()` method which merges two peer configurations. [1](#0-0) 

The logic checks `if self.role == other.role` (roles are EQUAL) and then returns an error stating "Roles don't match". This is backwardsâ€”the intended behavior should reject peers when roles are DIFFERENT, not when they are the SAME.

This bug is triggered during validator startup in the `merge_seeds()` function. [2](#0-1) 

The merge process:
1. Creates `Peer` objects from legacy `seed_addrs` with hardcoded role `ValidatorFullNode` [3](#0-2) 
2. Attempts to extend existing seeds with `.unwrap()` [4](#0-3) 
3. When the existing seed has role `ValidatorFullNode` (matching), `extend()` returns an error
4. The `.unwrap()` panics, crashing the validator

This occurs during `NetworkBuilder::create()` which is called during validator startup. [5](#0-4) 

The validator startup process invokes this code path. [6](#0-5) 

**Invariant Violated:** Network availability and validator liveness. Validators must start successfully to maintain network health.

## Impact Explanation

This qualifies as **High Severity** per Aptos bug bounty criteria:
- **Validator node crashes**: Validators fail to start, more severe than slowdowns
- **Network liveness issues**: During reconfiguration events, if multiple validators have duplicate seed configurations, simultaneous crashes could impact network availability
- **Operational disruption**: Requires manual intervention to fix configurations and restart validators

The bug affects critical network infrastructure during:
- Configuration migrations from legacy `seed_addrs` to modern `seeds` format
- Network upgrades requiring configuration updates  
- Reconfiguration events where seed lists are updated
- Operational scenarios where administrators inadvertently create duplicate entries

## Likelihood Explanation

**Moderate to High Likelihood** in production scenarios:

**Triggering Conditions:**
- Same `peer_id` appears in both `config.seeds` and `config.seed_addrs`
- Both entries have the same role (specifically `ValidatorFullNode` for seed_addrs)
- This commonly occurs during configuration format migrations

**Risk Factors:**
- The legacy `seed_addrs` field is still supported (see "TODO: Once fully migrated, remove seed_addrs")
- Configuration generators might produce both formats during transitions
- Manual configuration edits can accidentally introduce duplicates
- No validation prevents this scenario before the panic [7](#0-6) 

## Recommendation

**Fix the inverted logic in `Peer::extend()`:**

Change line 487 in `config/src/config/network_config.rs` from:
```rust
if self.role == other.role {
```

To:
```rust
if self.role != other.role {
```

This ensures the method correctly rejects peers with DIFFERENT roles (as the error message indicates) and successfully merges peers with MATCHING roles.

**Additional safeguards:**
1. Add validation in `verify_seeds()` to detect duplicate peer IDs across `seeds` and `seed_addrs`
2. Add unit tests for `Peer::extend()` covering both matching and non-matching roles
3. Add integration tests for `merge_seeds()` with duplicate peer scenarios
4. Consider graceful handling instead of `.unwrap()` to log errors rather than panic

## Proof of Concept

```rust
#[cfg(test)]
mod test_peer_extend_panic {
    use super::*;
    use aptos_crypto::x25519;
    use aptos_types::network_address::NetworkAddress;
    use std::collections::{HashMap, HashSet};
    
    #[test]
    #[should_panic(expected = "Roles don't match")]
    fn test_merge_seeds_panic_on_matching_roles() {
        // Create a NetworkConfig with duplicate peer in seeds and seed_addrs
        let mut config = NetworkConfig::default();
        
        let peer_id = PeerId::random();
        let addr: NetworkAddress = "/ip4/127.0.0.1/tcp/6180".parse().unwrap();
        
        // Add peer to seeds with ValidatorFullNode role
        let mut peer_seeds = Peer::from_addrs(
            PeerRole::ValidatorFullNode, 
            vec![addr.clone()]
        );
        config.seeds.insert(peer_id, peer_seeds);
        
        // Add same peer to seed_addrs (will be converted to ValidatorFullNode)
        config.seed_addrs.insert(peer_id, vec![addr]);
        
        // This will panic due to inverted logic in Peer::extend()
        let _merged = merge_seeds(&config);
    }
}
```

## Notes

The security question asks about "keys being incompatible," but the actual panic occurs due to **inverted role-checking logic**, not key incompatibility. The `keys` field is simply extended without compatibility checks. [8](#0-7) 

The vulnerability is exacerbated by the confusing error message that says "Roles don't match" when they actually DO match, making debugging difficult for operators.

### Citations

**File:** config/src/config/network_config.rs (L319-340)
```rust
    pub fn verify_seeds(&self) -> Result<(), Error> {
        for (peer_id, addrs) in self.seed_addrs.iter() {
            for addr in addrs {
                Self::verify_address(peer_id, addr)?;
            }
        }

        for (peer_id, seed) in self.seeds.iter() {
            for addr in seed.addresses.iter() {
                Self::verify_address(peer_id, addr)?;
            }

            // Require there to be a pubkey somewhere, either in the address (assumed by `is_aptosnet_addr`)
            if seed.keys.is_empty() && seed.addresses.is_empty() {
                return Err(Error::InvariantViolation(format!(
                    "Seed peer {} has no pubkeys",
                    peer_id.short_str(),
                )));
            }
        }
        Ok(())
    }
```

**File:** config/src/config/network_config.rs (L486-496)
```rust
    pub fn extend(&mut self, other: Peer) -> Result<(), Error> {
        if self.role == other.role {
            return Err(Error::InvariantViolation(format!(
                "Roles don't match self {:?} vs other {:?}",
                self.role, other.role
            )));
        }
        self.addresses.extend(other.addresses);
        self.keys.extend(other.keys);
        Ok(())
    }
```

**File:** network/builder/src/builder.rs (L207-207)
```rust
        let seeds = merge_seeds(config);
```

**File:** network/builder/src/builder.rs (L472-494)
```rust
/// Retrieve and merge seeds so that they have all keys associated
fn merge_seeds(config: &NetworkConfig) -> PeerSet {
    config.verify_seeds().expect("Seeds must be well formed");
    let mut seeds = config.seeds.clone();

    // Merge old seed configuration with new seed configuration
    // TODO(gnazario): Once fully migrated, remove `seed_addrs`
    config
        .seed_addrs
        .iter()
        .map(|(peer_id, addrs)| {
            (
                peer_id,
                Peer::from_addrs(PeerRole::ValidatorFullNode, addrs.clone()),
            )
        })
        .for_each(|(peer_id, peer)| {
            seeds
                .entry(*peer_id)
                // Sad clone due to Rust not realizing these are two distinct paths
                .and_modify(|seed| seed.extend(peer.clone()).unwrap())
                .or_insert(peer);
        });
```

**File:** aptos-node/src/network.rs (L283-290)
```rust
        let mut network_builder = NetworkBuilder::create(
            chain_id,
            node_config.base.role,
            &network_config,
            TimeService::real(),
            Some(event_subscription_service),
            peers_and_metadata.clone(),
        );
```
