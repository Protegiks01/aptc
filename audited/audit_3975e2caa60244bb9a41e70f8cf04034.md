# Audit Report

## Title
Consensus Observer Payload Store Exhaustion Enables Silent Drop of Critical Payloads

## Summary
The consensus observer's payload store silently drops incoming block payloads when exceeding `max_num_pending_blocks` without any notification or recovery mechanism. A subscribed peer (malicious validator or compromised node) can exploit this by flooding the store with unverified future-epoch payloads, causing legitimate current-epoch payloads to be dropped and breaking consensus observation.

## Finding Description

The vulnerability exists in the `insert_block_payload()` function which enforces a hard limit on stored payloads but provides no error propagation or recovery when this limit is exceeded. [1](#0-0) 

When the payload store reaches `max_num_pending_blocks` (default: 150), new payloads are silently dropped with only a warning log and an early return. The function has a void return type, so callers cannot detect this failure. [2](#0-1) 

The attack exploits the lack of upper bound validation on epoch/round values for incoming payloads. When processing block payloads, the system only validates that they are not behind the last ordered block, but places no restriction on how far ahead they can be: [3](#0-2) 

For payloads from future epochs, signature verification is skipped and they are stored as unverified: [4](#0-3) 

**Attack Path:**

1. **Prerequisite**: Attacker controls a subscribed peer (Byzantine validator, compromised VFN, or malicious node selected for subscription)

2. **Payload Flooding**: Attacker sends 150+ block payloads for arbitrarily high future epochs (e.g., epoch 999999, rounds 0-149)
   - These bypass the "behind last ordered block" check
   - Pass digest verification
   - Skip signature verification (future epoch)
   - Get stored as `BlockPayloadStatus::AvailableAndUnverified`

3. **Legitimate Payload Drop**: When legitimate current-epoch payloads arrive, the store is full and silently drops them

4. **Verification Failure**: When ordered blocks arrive referencing dropped payloads, verification fails because payloads are missing: [5](#0-4) 

5. **Consensus Observation Breakdown**: The observer rejects legitimate ordered blocks and eventually enters fallback mode, forced to use slower state sync instead of real-time consensus observation

**Key Security Violations:**

- **No recovery mechanism**: System does not re-request dropped payloads (consensus observer is passive)
- **No cleanup of future-epoch payloads**: Unverified payloads remain until commits clear space
- **No upper bound validation**: Attackers can specify arbitrarily high epoch/round values
- **Silent failure**: No error propagation to detect or respond to dropped payloads

## Impact Explanation

**Severity: HIGH**

This vulnerability qualifies as HIGH severity under Aptos bug bounty criteria:

1. **Validator node slowdowns**: Consensus observer nodes are forced into fallback mode, degrading from real-time consensus observation to periodic state sync, significantly impacting synchronization performance

2. **Significant protocol violations**: Breaks the consensus observer protocol's ability to provide real-time block observation, a critical feature for nodes requiring low-latency chain state updates

3. **Availability impact**: While not total liveness loss, affected nodes experience degraded operation requiring state sync recovery

The attack causes denial of service against consensus observer nodes, which are designed to provide efficient real-time consensus tracking without full validator participation. Organizations running observer nodes (exchanges, indexers, analytics services) would experience service degradation.

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH**

The attack has moderate barriers but is realistic:

**Requirements:**
- Attacker must control a subscribed peer (Byzantine validator, compromised VFN, or optimally-positioned malicious node)
- Observer must have active subscription to attacker's peer
- Default limit of 150 blocks is modest and easily fillable

**Mitigating Factors:**
- Requires network positioning or validator control
- Subscription health checks may eventually terminate malicious subscriptions
- Fallback mode provides recovery (though degraded)

**Amplifying Factors:**
- Single Byzantine validator (within 1/3 BFT threshold) can execute attack
- No rate limiting on payload messages from subscribed peers
- Attack is silent and may go undetected except via warning logs
- Can be repeated after observer recovers

In production networks with Byzantine validators (realistic under BFT threat model), this attack is feasible and impactful.

## Recommendation

Implement multi-layered defense:

**1. Add epoch/round bounds validation:**

```rust
pub fn insert_block_payload(
    &mut self,
    block_payload: BlockPayload,
    verified_payload_signatures: bool,
) -> Result<(), Error> {
    // Verify epoch/round are within acceptable bounds
    let max_future_epochs = 2; // Allow at most 2 epochs ahead
    let max_future_rounds = self.consensus_observer_config.max_num_pending_blocks as Round;
    
    let (block_epoch, block_round) = (block_payload.epoch(), block_payload.round());
    if block_epoch > current_epoch + max_future_epochs {
        return Err(Error::InvalidMessageError(
            format!("Block payload epoch {} too far in future (current: {})", 
                    block_epoch, current_epoch)
        ));
    }
    
    // Verify that the number of payloads doesn't exceed the maximum
    let max_num_pending_blocks = self.consensus_observer_config.max_num_pending_blocks as usize;
    if self.block_payloads.lock().len() >= max_num_pending_blocks {
        return Err(Error::PayloadStoreFull(format!(
            "Payload store at capacity: {:?}. Cannot insert block: {:?}",
            max_num_pending_blocks,
            block_payload.block(),
        )));
    }
    
    // Rest of insertion logic...
    Ok(())
}
```

**2. Change return type from void to Result:** [6](#0-5) 

**3. Propagate errors in caller:** [2](#0-1) 

Update to handle errors and potentially disconnect malicious peers.

**4. Add aggressive cleanup of unverified future-epoch payloads** during epoch transitions and when approaching capacity limits.

**5. Implement rate limiting** on payload messages per peer per time window.

## Proof of Concept

```rust
#[tokio::test]
async fn test_payload_store_exhaustion_attack() {
    use crate::consensus_observer::observer::payload_store::BlockPayloadStore;
    use crate::consensus_observer::network::observer_message::{BlockPayload, BlockTransactionPayload};
    use aptos_config::config::ConsensusObserverConfig;
    use aptos_types::block_info::BlockInfo;
    
    // Create payload store with small limit for testing
    let max_num_pending_blocks = 10;
    let config = ConsensusObserverConfig {
        max_num_pending_blocks,
        ..Default::default()
    };
    let mut payload_store = BlockPayloadStore::new(config);
    
    // Attack Phase 1: Fill store with future-epoch payloads
    let malicious_epoch = 999999;
    for round in 0..max_num_pending_blocks {
        let block_info = BlockInfo::random_with_epoch(malicious_epoch, round as u64);
        let payload = BlockPayload::new(block_info, BlockTransactionPayload::empty());
        payload_store.insert_block_payload(payload, false); // Unverified
    }
    
    // Attack Phase 2: Legitimate current-epoch payload arrives
    let current_epoch = 100;
    let legitimate_round = 50;
    let block_info = BlockInfo::random_with_epoch(current_epoch, legitimate_round);
    let legitimate_payload = BlockPayload::new(block_info, BlockTransactionPayload::empty());
    
    // This payload will be SILENTLY DROPPED (store is full)
    payload_store.insert_block_payload(legitimate_payload.clone(), true);
    
    // Attack Phase 3: Verify legitimate payload was dropped
    assert!(!payload_store.existing_payload_entry(&legitimate_payload));
    
    // Attack succeeds: Critical current-epoch payload lost, future ordered 
    // blocks referencing it will fail verification
}
```

## Notes

This vulnerability is particularly concerning because:

1. **Silent failure mode**: Dropped payloads generate only warning logs, making attacks difficult to detect until ordered block verification fails

2. **No active recovery**: The consensus observer is passive and cannot re-request dropped payloads - it must rely on publishers to resend

3. **Cleanup delays**: Unverified future-epoch payloads persist until commits clear space, which may not happen if legitimate progress stalls

4. **Cascade effect**: Once legitimate payloads are dropped, subsequent ordered block verification fails, triggering fallback mode and further degrading observer performance

The attack exploits the asymmetry between the consensus observer's passive reception model and the active resource limit enforcement, creating a denial-of-service vector against observer nodes through a single malicious subscribed peer.

### Citations

**File:** consensus/src/consensus_observer/observer/payload_store.rs (L79-109)
```rust
    pub fn insert_block_payload(
        &mut self,
        block_payload: BlockPayload,
        verified_payload_signatures: bool,
    ) {
        // Verify that the number of payloads doesn't exceed the maximum
        let max_num_pending_blocks = self.consensus_observer_config.max_num_pending_blocks as usize;
        if self.block_payloads.lock().len() >= max_num_pending_blocks {
            warn!(
                LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                    "Exceeded the maximum number of payloads: {:?}. Dropping block: {:?}!",
                    max_num_pending_blocks,
                    block_payload.block(),
                ))
            );
            return; // Drop the block if we've exceeded the maximum
        }

        // Create the new payload status
        let epoch_and_round = (block_payload.epoch(), block_payload.round());
        let payload_status = if verified_payload_signatures {
            BlockPayloadStatus::AvailableAndVerified(block_payload)
        } else {
            BlockPayloadStatus::AvailableAndUnverified(block_payload)
        };

        // Insert the new payload status
        self.block_payloads
            .lock()
            .insert(epoch_and_round, payload_status);
    }
```

**File:** consensus/src/consensus_observer/observer/payload_store.rs (L201-208)
```rust
                Entry::Vacant(_) => {
                    // The payload is missing (this should never happen)
                    return Err(Error::InvalidMessageError(format!(
                        "Payload verification failed! Missing block payload for epoch: {:?} and round: {:?}",
                        ordered_block.epoch(),
                        ordered_block.round()
                    )));
                },
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L366-380)
```rust
        // Determine if the payload is behind the last ordered block, or if it already exists
        let last_ordered_block = self.observer_block_data.lock().get_last_ordered_block();
        let payload_out_of_date =
            (block_epoch, block_round) <= (last_ordered_block.epoch(), last_ordered_block.round());
        let payload_exists = self
            .observer_block_data
            .lock()
            .existing_payload_entry(&block_payload);

        // If the payload is out of date or already exists, ignore it
        if payload_out_of_date || payload_exists {
            // Update the metrics for the dropped block payload
            update_metrics_for_dropped_block_payload_message(peer_network_id, &block_payload);
            return;
        }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L399-430)
```rust
        // If the payload is for the current epoch, verify the proof signatures
        let epoch_state = self.get_epoch_state();
        let verified_payload = if block_epoch == epoch_state.epoch {
            // Verify the block proof signatures
            if let Err(error) = block_payload.verify_payload_signatures(&epoch_state) {
                // Log the error and update the invalid message counter
                error!(
                    LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                        "Failed to verify block payload signatures! Ignoring block: {:?}, from peer: {:?}. Error: {:?}",
                        block_payload.block(), peer_network_id, error
                    ))
                );
                increment_invalid_message_counter(&peer_network_id, metrics::BLOCK_PAYLOAD_LABEL);
                return;
            }

            true // We have successfully verified the signatures
        } else {
            false // We can't verify the signatures yet
        };

        // Update the latency metrics for block payload processing
        update_message_processing_latency_metrics(
            message_received_time,
            &peer_network_id,
            metrics::BLOCK_PAYLOAD_LABEL,
        );

        // Update the payload store with the payload
        self.observer_block_data
            .lock()
            .insert_block_payload(block_payload, verified_payload);
```
