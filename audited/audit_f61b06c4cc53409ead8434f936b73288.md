# Audit Report

## Title
Missing Docker Socket Ownership Verification in Local Development Tooling

## Summary
The `get_docker()` function in `crates/aptos-localnet/src/docker.rs` connects to a Docker socket at `~/.docker/run/docker.sock` without verifying the socket's owner or group ownership, potentially allowing an attacker with home directory write access to substitute a malicious socket. [1](#0-0) 

## Finding Description
When the default Docker socket connection fails, the function falls back to connecting to a socket in the user's home directory at `~/.docker/run/docker.sock`. [1](#0-0) 

The connection is established without verifying:
1. The socket file's owner (uid) matches the expected user or root
2. The socket file's group ownership (gid) is appropriate
3. The socket file's permissions are restrictive
4. The file is actually a Unix socket (not a symlink or regular file)

An attacker with write access to the user's home directory could:
1. Create the directory structure `~/.docker/run/`
2. Create a malicious Unix socket at `~/.docker/run/docker.sock`
3. When the application runs and the default Docker socket is unavailable, it connects to the attacker's socket
4. The attacker gains full control over all Docker operations performed by the application

Since Docker commands can execute arbitrary code in containers and manipulate the host system, this provides a path to arbitrary code execution.

## Impact Explanation
This qualifies as **Medium Severity** per the Aptos bug bounty criteria because:
- It requires a precondition (write access to the user's home directory)
- It only affects local development environments using `aptos-localnet`
- It does **not** affect production validator nodes or blockchain consensus
- It could lead to arbitrary code execution on a developer's local machine

However, **critically important**: This vulnerability is in the **local development tooling** (`aptos-localnet`), not in the core blockchain protocol. It does not affect:
- Consensus safety or liveness
- Move VM execution on validators
- State management or storage
- On-chain governance or staking
- Production validator deployments

## Likelihood Explanation
The likelihood is **LOW to MEDIUM** because:

**Required preconditions:**
1. Attacker must have write access to the victim's home directory
2. The default Docker socket must be unavailable or fail to connect
3. The victim must run the `aptos-localnet` tool after the malicious socket is planted

**Mitigating factors:**
- If an attacker already has home directory write access, they can typically achieve code execution through other means (.bashrc, .ssh/authorized_keys, etc.)
- This only affects developers running local testnets, not production systems
- Most developers have Docker running at the default socket location

## Recommendation
Add socket ownership and permission verification before connecting:

```rust
#[cfg(unix)]
{
    use std::os::unix::fs::MetadataExt;
    
    let path = dirs::home_dir()
        .context(format!("{} (home_dir)", ERROR_MESSAGE))?
        .join(".docker")
        .join("run")
        .join("docker.sock");
    
    info!("Looking for Docker socket at {}", path.display());
    
    // Verify socket ownership and permissions
    let metadata = std::fs::metadata(&path)
        .context("Failed to get socket metadata")?;
    
    // Check if it's a socket
    if !metadata.file_type().is_socket() {
        anyhow::bail!("Path is not a Unix socket: {}", path.display());
    }
    
    // Check ownership (should be owned by current user or root)
    let current_uid = unsafe { libc::getuid() };
    let socket_uid = metadata.uid();
    if socket_uid != 0 && socket_uid != current_uid {
        anyhow::bail!(
            "Socket has unexpected owner (uid: {}). Expected root (0) or current user ({})",
            socket_uid, current_uid
        );
    }
    
    // Check permissions (should not be world-writable)
    let mode = metadata.permissions().mode();
    if mode & 0o002 != 0 {
        anyhow::bail!("Socket is world-writable, which is insecure");
    }
    
    let path_str = path.to_str().context(format!("{} (path)", ERROR_MESSAGE))?;
    let docker = Docker::connect_with_socket(path_str, 120, API_DEFAULT_VERSION)
        .context(format!("{} (init_home)", ERROR_MESSAGE))?;
    // ... rest of the code
}
```

## Proof of Concept

**Setup malicious socket (attacker):**
```bash
# On the victim's machine (with home dir write access)
mkdir -p ~/.docker/run
# Create a malicious socket that logs all commands
socat UNIX-LISTEN:$HOME/.docker/run/docker.sock,fork EXEC:"/tmp/malicious_handler.sh"
```

**Trigger the vulnerability:**
```bash
# Stop the legitimate Docker daemon or make it unavailable
# Then run aptos-localnet
cargo run -p aptos-localnet

# The code will connect to the malicious socket at ~/.docker/run/docker.sock
# without verifying ownership
```

**Expected behavior:** The application connects to the attacker's socket, giving them control over all Docker operations.

**Note:** This vulnerability only affects local development environments and does not impact the Aptos blockchain protocol, consensus mechanism, or production validator operations.

### Citations

**File:** crates/aptos-localnet/src/docker.rs (L38-46)
```rust
                    let path = dirs::home_dir()
                        .context(format!("{} (home_dir)", ERROR_MESSAGE))?
                        .join(".docker")
                        .join("run")
                        .join("docker.sock");
                    info!("Looking for Docker socket at {}", path.display());
                    let path = path.to_str().context(format!("{} (path)", ERROR_MESSAGE))?;
                    let docker = Docker::connect_with_socket(path, 120, API_DEFAULT_VERSION)
                        .context(format!("{} (init_home)", ERROR_MESSAGE))?;
```
