# Audit Report

## Title
Vault Token Credential Leakage via Debug Output in SecureBackend Configuration

## Summary
The `Token` enum in `SecureBackend` configuration derives the standard `Debug` trait without implementing `SilentDebug`, causing Vault authentication tokens to be leaked in plaintext through node startup logs and the inspection service HTTP endpoint. This exposes validator consensus keys and other critical secrets stored in HashiCorp Vault.

## Finding Description

The Aptos codebase uses HashiCorp Vault for secure storage of validator consensus keys, network keys, and other sensitive cryptographic material. The `SecureBackend` configuration system supports storing tokens either directly in the config file (`Token::FromConfig`) or reading them from disk (`Token::FromDisk`).

**Vulnerability Location:**

The `Token` enum derives the standard Rust `Debug` trait without using the security-conscious `SilentDebug` macro: [1](#0-0) 

This enum is contained within `VaultConfig`: [2](#0-1) 

Which is contained within `SecureBackend`: [3](#0-2) 

**Exposure Points:**

1. **Node Startup Logging**: The entire `NodeConfig` (which contains `SecureBackend` in multiple places) is logged using Debug formatting at node startup: [4](#0-3) 

Note that while postgres passwords are masked (lines 91-99), **no masking is applied to Vault tokens**.

2. **Inspection Service HTTP Endpoint**: When the configuration exposure endpoint is enabled, the NodeConfig is returned via HTTP using Debug formatting: [5](#0-4) 

The comment on lines 16-18 states that Debug formatting is used to prevent secret keys from being serialized, relying on `SilentDisplay` and `SilentDebug`. However, `Token` does **not** use these protective traits.

3. **Safety Rules Configuration**: The consensus layer's `SafetyRulesConfig` also contains a `SecureBackend` field that derives Debug: [6](#0-5) 

**Comparison with Proper Implementation:**

The codebase correctly protects private keys using `SilentDebug` and `SilentDisplay`. For example, `Ed25519PrivateKey`: [7](#0-6) 

The `SilentDebug` macro implementation replaces sensitive values with `<elided secret for {TypeName}>`: [8](#0-7) 

**Attack Scenario:**

1. A validator operator configures their node with Vault storage and sets `token: from_config: "hvs.CAES..."` in the configuration YAML
2. When the node starts, the full token is logged to disk in plaintext
3. An attacker gains read access to log files through:
   - Compromised log aggregation systems
   - Misconfigured log file permissions
   - Backup system vulnerabilities
   - Cloud storage bucket misconfigurations
4. Alternatively, if `inspection_service.expose_configuration: true`, the attacker can retrieve the token via HTTP request
5. With the Vault token, the attacker can:
   - Read the validator's consensus private key (BLS12-381)
   - Read network authentication keys
   - Read other secrets stored in Vault
   - Potentially write new values to compromise the validator

## Impact Explanation

This vulnerability qualifies as **High Severity** per the Aptos bug bounty program for the following reasons:

**Primary Impact - Validator Compromise:**
- Vault tokens provide full access to all secrets stored in that Vault namespace
- Validator consensus keys stored in Vault can be exfiltrated
- An attacker with the consensus private key can:
  - Sign malicious proposals
  - Participate in double-signing attacks
  - Impersonate the validator in consensus protocols
  - Potentially violate consensus safety if combined with other compromised validators

**Secondary Impacts:**
- Network keys compromise allows man-in-the-middle attacks on validator communications
- Could lead to validator node slowdowns or API crashes (High severity per bounty)
- Enables targeted attacks against specific validators
- May facilitate broader consensus attacks when multiple validators are compromised

**Does NOT Reach Critical Severity Because:**
- Requires attacker to first gain access to logs or the inspection endpoint (not direct remote exploitation)
- Does not directly cause loss of funds, but enables attacks that could
- Does not directly break consensus safety, but facilitates attacks that could

The vulnerability breaks the **Cryptographic Correctness** invariant: "BLS signatures, VRF, and hash operations must be secure" - by exposing the private keys that underpin these operations.

## Likelihood Explanation

**Likelihood: Medium to High**

**Factors Increasing Likelihood:**
1. **Common Configuration Pattern**: Using `Token::FromConfig` is convenient for testing and development, and may be used in production
2. **Multiple Exposure Paths**: Both logging and HTTP endpoint can leak credentials
3. **Persistent Exposure**: Once written to logs, tokens remain accessible indefinitely unless logs are rotated/purged
4. **Log Aggregation Systems**: Many production deployments use centralized logging, expanding the attack surface
5. **Human Error**: Operators may inadvertently expose logs through:
   - Sharing debug output in support tickets
   - Uploading logs to public issue trackers
   - Misconfigured cloud storage for log backups
   - Inadequate access controls on monitoring systems

**Factors Decreasing Likelihood:**
1. **Best Practice**: Documentation likely recommends `Token::FromDisk` over `Token::FromConfig`
2. **Inspection Endpoint**: Typically disabled in production (`expose_configuration: false` by default)
3. **Log Access Required**: Attacker needs some level of system access to read log files

**Real-World Scenarios:**
- Kubernetes pods with improper log access controls
- Compromised CI/CD pipelines that access logs
- Insider threats with legitimate but excessive access
- Supply chain attacks on log management providers

## Recommendation

Implement `SilentDebug` and `SilentDisplay` for the `Token` enum to prevent credential leakage:

```rust
// In config/src/config/secure_backend_config.rs

use aptos_crypto_derive::{SilentDebug, SilentDisplay};

// Change line 100 from:
#[derive(Clone, Debug, Deserialize, PartialEq, Eq, Serialize)]
// To:
#[derive(Clone, SilentDebug, SilentDisplay, Deserialize, PartialEq, Eq, Serialize)]
#[serde(rename_all = "snake_case")]
pub enum Token {
    FromConfig(String),
    FromDisk(PathBuf),
}
```

**Alternative Approach** (if path-based tokens should be visible):

Implement custom Debug that redacts `FromConfig` but shows `FromDisk` paths:

```rust
impl std::fmt::Debug for Token {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Token::FromConfig(_) => write!(f, "Token::FromConfig(<redacted>)"),
            Token::FromDisk(path) => f.debug_tuple("Token::FromDisk").field(path).finish(),
        }
    }
}
```

**Additional Hardening:**
1. Add a configuration validator that warns when `Token::FromConfig` is used in production
2. Document the security implications in configuration guides
3. Add a sanitizer check that fails if `Token::FromConfig` is used on mainnet
4. Audit all other configuration types for similar credential leakage issues

## Proof of Concept

```rust
// Add this test to config/src/config/secure_backend_config.rs

#[cfg(test)]
mod security_tests {
    use super::*;

    #[test]
    fn test_vault_token_not_leaked_in_debug_output() {
        let sensitive_token = "hvs.CAESIBxZtest_secret_token_12345";
        
        // Create a VaultConfig with a token from config
        let vault_config = VaultConfig {
            ca_certificate: None,
            namespace: Some("test_namespace".to_string()),
            renew_ttl_secs: None,
            server: "https://vault.example.com".to_string(),
            token: Token::FromConfig(sensitive_token.to_string()),
            disable_cas: None,
            connection_timeout_ms: None,
            response_timeout_ms: None,
        };

        // Create a SecureBackend containing the vault config
        let backend = SecureBackend::Vault(vault_config);

        // Format using Debug (as done in logger.rs and configuration.rs)
        let debug_output = format!("{:?}", backend);
        
        // VULNERABILITY: The token is exposed in plaintext!
        // This assertion PASSES, demonstrating the vulnerability
        assert!(
            debug_output.contains(sensitive_token),
            "SECURITY ISSUE: Token leaked in debug output!\nDebug output: {}",
            debug_output
        );
        
        // Expected behavior after fix: token should be redacted
        // assert!(!debug_output.contains(sensitive_token));
        // assert!(debug_output.contains("<elided") || debug_output.contains("<redacted"));
    }

    #[test]
    fn test_token_from_disk_behavior() {
        // FromDisk variant should be safe to display as it only contains a path
        let token = Token::FromDisk(PathBuf::from("/path/to/token/file"));
        let debug_output = format!("{:?}", token);
        
        // Path is not sensitive, can be shown
        assert!(debug_output.contains("/path/to/token/file"));
    }
}
```

To run the PoC:
```bash
cd config
cargo test security_tests::test_vault_token_not_leaked_in_debug_output -- --nocapture
```

The test will **pass**, demonstrating that the token is indeed leaked in Debug output. After applying the fix with `SilentDebug`, the test should be inverted to verify the token is properly redacted.

## Notes

- This vulnerability affects all deployments using `Token::FromConfig` with Vault storage
- The issue also applies to `WaypointConfig::FromStorage(SecureBackend)` in base configuration
- Similar patterns should be audited throughout the codebase (database passwords, API keys, etc.)
- The postgres password masking in `logger.rs` (lines 91-99) shows the team is aware of credential leakage risks, but this case was missed
- The `Token::FromDisk` variant is less sensitive since it only exposes a file path, not the actual credential
- Priority should be given to fixing this before any mainnet deployments that use Vault with `FromConfig` tokens

### Citations

**File:** config/src/config/secure_backend_config.rs (L16-22)
```rust
#[derive(Clone, Debug, Deserialize, PartialEq, Eq, Serialize)]
#[serde(rename_all = "snake_case", tag = "type")]
pub enum SecureBackend {
    InMemoryStorage,
    Vault(VaultConfig),
    OnDiskStorage(OnDiskStorageConfig),
}
```

**File:** config/src/config/secure_backend_config.rs (L51-74)
```rust
#[derive(Clone, Debug, Deserialize, PartialEq, Eq, Serialize)]
#[serde(deny_unknown_fields)]
pub struct VaultConfig {
    /// Optional SSL Certificate for the vault host, this is expected to be a full path.
    pub ca_certificate: Option<PathBuf>,
    /// A namespace is an optional portion of the path to a key stored within Vault. For example,
    /// a secret, S, without a namespace would be available in secret/data/S, with a namespace, N, it
    /// would be in secret/data/N/S.
    pub namespace: Option<String>,
    /// Vault leverages leases on many tokens, specify this to automatically have your lease
    /// renewed up to that many seconds more. If this is not specified, the lease will not
    /// automatically be renewed.
    pub renew_ttl_secs: Option<u32>,
    /// Vault's URL, note: only HTTP is currently supported.
    pub server: String,
    /// The authorization token for accessing secrets
    pub token: Token,
    /// Disable check-and-set when writing secrets to Vault
    pub disable_cas: Option<bool>,
    /// Timeout for new vault socket connections, in milliseconds.
    pub connection_timeout_ms: Option<u64>,
    /// Timeout for generic vault operations (e.g., reads and writes), in milliseconds.
    pub response_timeout_ms: Option<u64>,
}
```

**File:** config/src/config/secure_backend_config.rs (L100-106)
```rust
#[derive(Clone, Debug, Deserialize, PartialEq, Eq, Serialize)]
#[serde(rename_all = "snake_case")]
pub enum Token {
    FromConfig(String),
    /// This is an absolute path and not relative to data_dir
    FromDisk(PathBuf),
}
```

**File:** aptos-node/src/logger.rs (L88-101)
```rust
    // Log the node config
    let mut config = node_config;
    let mut masked_config;
    if let Some(u) = &node_config.indexer.postgres_uri {
        let mut parsed_url = url::Url::parse(u).expect("Invalid postgres uri");
        if parsed_url.password().is_some() {
            masked_config = node_config.clone();
            parsed_url.set_password(Some("*")).unwrap();
            masked_config.indexer.postgres_uri = Some(parsed_url.to_string());
            config = &masked_config;
        }
    }

    info!("Loaded node config: {:?}", config);
```

**File:** crates/aptos-inspection-service/src/server/configuration.rs (L13-29)
```rust
pub fn handle_configuration_request(node_config: &NodeConfig) -> (StatusCode, Body, String) {
    // Only return configuration if the endpoint is enabled
    let (status_code, body) = if node_config.inspection_service.expose_configuration {
        // We format the configuration using debug formatting. This is important to
        // prevent secret/private keys from being serialized and leaked (i.e.,
        // all secret keys are marked with SilentDisplay and SilentDebug).
        let encoded_configuration = format!("{:?}", node_config);
        (StatusCode::OK, Body::from(encoded_configuration))
    } else {
        (
            StatusCode::FORBIDDEN,
            Body::from(CONFIGURATION_DISABLED_MESSAGE),
        )
    };

    (status_code, body, CONTENT_TYPE_TEXT.into())
}
```

**File:** config/src/config/safety_rules_config.rs (L23-34)
```rust
#[derive(Clone, Debug, Deserialize, PartialEq, Serialize)]
#[serde(default, deny_unknown_fields)]
pub struct SafetyRulesConfig {
    pub backend: SecureBackend,
    pub logger: LoggerConfig,
    pub service: SafetyRulesService,
    pub test: Option<SafetyRulesTestConfig>,
    // Read/Write/Connect networking operation timeout in milliseconds.
    pub network_timeout_ms: u64,
    pub enable_cached_safety_data: bool,
    pub initial_safety_rules_config: InitialSafetyRulesConfig,
}
```

**File:** crates/aptos-crypto/src/ed25519/ed25519_keys.rs (L22-24)
```rust
/// An Ed25519 private key
#[derive(DeserializeKey, SerializeKey, SilentDebug, SilentDisplay)]
pub struct Ed25519PrivateKey(pub(crate) ed25519_dalek::SecretKey);
```

**File:** crates/aptos-crypto-derive/src/lib.rs (L128-143)
```rust
#[proc_macro_derive(SilentDebug)]
pub fn silent_debug(source: TokenStream) -> TokenStream {
    let ast: DeriveInput = syn::parse(source).expect("Incorrect macro input");
    let name = &ast.ident;
    let (impl_generics, ty_generics, where_clause) = ast.generics.split_for_impl();

    quote! {
        // In order to ensure that secrets are never leaked, Debug is elided
        impl #impl_generics ::std::fmt::Debug for #name #ty_generics #where_clause {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                write!(f, "<elided secret for {}>", stringify!(#name))
            }
        }
    }
    .into()
}
```
