# Audit Report

## Title
Lazy Module Verification Allows Cyclic Dependencies to Bypass Safety Checks During Bundle Publishing

## Summary
The lazy module loading mechanism in Move VM runtime fails to detect cyclic module dependencies during bundle publishing, violating a fundamental Move safety invariant. An attacker can publish module bundles containing circular dependencies that would be rejected under eager verification, potentially causing consensus failures, infinite loops, or validator crashes.

## Finding Description

The `unmetered_get_existing_lazily_verified_module()` function performs only local bytecode verification without checking for cyclic dependencies in the module dependency graph. This creates a critical safety gap during bundle publishing when lazy loading is enabled (default configuration).

**Root Cause Analysis:**

In the lazy loading code path, module verification happens in two separate locations:

1. **Lazy Verification Path** [1](#0-0) 
   - Only performs local module verification
   - Calls `build_verified_module_skip_linking_checks()` which bypasses dependency validation [2](#0-1) 
   - No cycle detection mechanism

2. **Publishing with Lazy Loading** [3](#0-2) 
   - Explicitly states: "Note that we do not check cyclic dependencies here" [4](#0-3) 
   - Loads immediate dependencies using `unmetered_get_existing_lazily_verified_module()` [5](#0-4) 
   - Performs linking checks only against immediate dependencies, no transitive validation

**Contrast with Eager Verification:**

The eager verification path explicitly detects and rejects cyclic dependencies through recursive traversal with a `visited` set [6](#0-5) 

**Attack Scenario:**

An attacker publishes a bundle `[Module A, Module B]` where:
- Module A depends on Module B
- Module B depends on Module A (cyclic dependency)

During verification:
1. When verifying Module A, dependency Module B is loaded via `unmetered_get_existing_lazily_verified_module()`
2. Module B (from same bundle) undergoes lazy verificationâ€”marked as "verified" without checking its dependencies
3. When verifying Module B, dependency Module A is already cached as "verified" from step 1
4. Both modules pass verification and are published
5. The cycle is never detected because lazy verification doesn't maintain a global `visited` set across modules in the bundle

This violates the Move invariant that modules must form a directed acyclic graph (DAG).

## Impact Explanation

**Severity: Critical** (per Aptos Bug Bounty)

This vulnerability breaks multiple critical invariants:

1. **Consensus Safety Violation**: Different validator nodes may handle cyclic dependencies differently during execution, leading to state divergence and potential chain splits
   
2. **Deterministic Execution Failure**: Cyclic dependencies can cause non-deterministic behavior depending on module load order and cache state

3. **Denial of Service**: Publishing modules with cyclic dependencies can cause:
   - Infinite loops during module initialization
   - Stack overflows during recursive dependency resolution
   - Validator crashes requiring node restarts
   - Network-wide liveness failures if critical framework modules are affected

4. **Move VM Safety Breach**: Violates the fundamental Move guarantee that module dependencies form a DAG, undermining the entire bytecode verification framework

The impact is network-wide since lazy loading is enabled by default [7](#0-6) 

## Likelihood Explanation

**Likelihood: High**

- **Attack Complexity**: Low - attacker only needs to craft two modules with mutual dependencies and submit them as a bundle
- **Prerequisites**: None - any user with module publishing privileges can exploit this
- **Detection Difficulty**: High - the vulnerability is in the verification logic itself, not detectable by standard monitoring
- **Default Configuration**: Lazy loading is enabled by default in production, making all Aptos networks vulnerable
- **Historical Precedent**: Move explicitly defines cyclic dependencies as an error condition [8](#0-7) , indicating this is a known dangerous condition

## Recommendation

**Immediate Fix:**

Add cycle detection to the lazy loading publishing path. Maintain a `visited` set across all modules in a bundle during verification:

```rust
// In publishing.rs, around line 232
let mut visited_for_cycle_check = HashSet::new();

for (addr, name, bytes, compiled_module) in staged_module_storage.storage.byte_storage().staged_modules.iter()... {
    if is_lazy_loading_enabled {
        // Add cycle detection
        if !visited_for_cycle_check.insert(ModuleId::new(*addr, name.to_owned())) {
            return Err(module_cyclic_dependency_error!(addr, name));
        }
        
        // Verify dependencies don't create cycles
        for (dep_addr, dep_name) in locally_verified_code.immediate_dependencies_iter() {
            let dep_id = ModuleId::new(*dep_addr, dep_name.to_owned());
            
            // Check if dependency is in the current bundle being verified
            if staged_modules.contains(&dep_id) && visited_for_cycle_check.contains(&dep_id) {
                // Potential cycle - need deeper check
                detect_cycle_in_bundle(&staged_modules, &module_id, &visited_for_cycle_check)?;
            }
            
            let dependency = staged_module_storage.unmetered_get_existing_lazily_verified_module(&dep_id)?;
            verified_dependencies.push(dependency);
        }
        
        // ... rest of verification
    }
}
```

**Long-term Solution:**

Consider re-evaluating whether lazy loading should skip transitive dependency verification during publishing. The performance benefit may not justify the safety risks.

## Proof of Concept

Create two Move modules with cyclic dependencies:

```move
// Module A at 0x1::CyclicA
module 0x1::CyclicA {
    use 0x1::CyclicB;
    
    public fun call_b(): u64 {
        CyclicB::get_value()
    }
}

// Module B at 0x1::CyclicB  
module 0x1::CyclicB {
    use 0x1::CyclicA;
    
    public fun get_value(): u64 {
        CyclicA::call_b() + 1  // Creates infinite recursion
    }
}
```

**Exploitation Steps:**

1. Compile both modules into bytecode
2. Submit them as a bundle via `aptos move publish --package-dir <path> --included-artifacts none`
3. With lazy loading enabled, publishing succeeds (should fail with `CYCLIC_MODULE_DEPENDENCY`)
4. Any attempt to execute functions from these modules will cause infinite recursion and stack overflow
5. Validator nodes crash or hang, causing network disruption

**Expected Behavior:** Publishing should fail with error code `CYCLIC_MODULE_DEPENDENCY` as defined in the error macros [9](#0-8) 

**Actual Behavior:** Publishing succeeds, modules are stored on-chain with undetected cyclic dependency.

---

**Notes:**

This vulnerability exists because the performance optimization of lazy loading (avoiding transitive dependency loading) was implemented without preserving the critical safety property of cycle detection. The explicit comment in the code acknowledging the missing check confirms this is a known limitation that creates a security gap.

### Citations

**File:** third_party/move/move-vm/runtime/src/storage/module_storage.rs (L295-329)
```rust
    fn unmetered_get_lazily_verified_module(
        &self,
        module_id: &ModuleId,
    ) -> VMResult<Option<Arc<Module>>> {
        let (module, version) = match self.get_module_or_build_with(module_id, self)? {
            Some(module_and_version) => module_and_version,
            None => return Ok(None),
        };

        if module.code().is_verified() {
            return Ok(Some(module.code().verified().clone()));
        }

        let _timer = VM_TIMER.timer_with_label("unmetered_get_lazily_verified_module [cache miss]");
        let runtime_environment = self.runtime_environment();
        runtime_environment.paranoid_check_module_address_and_name(
            module.code().deserialized(),
            module_id.address(),
            module_id.name(),
        )?;
        let locally_verified_code = runtime_environment.build_locally_verified_module(
            module.code().deserialized().clone(),
            module.extension().size_in_bytes(),
            module.extension().hash(),
        )?;
        let verified_code =
            runtime_environment.build_verified_module_skip_linking_checks(locally_verified_code)?;
        let verified_module = self.insert_verified_module(
            module_id.clone(),
            verified_code,
            module.extension().clone(),
            version,
        )?;
        Ok(Some(verified_module.code().verified().clone()))
    }
```

**File:** third_party/move/move-vm/runtime/src/storage/module_storage.rs (L399-415)
```rust
        if visited.insert(dependency_id.clone()) {
            // Dependency is not verified, and we have not visited it yet.
            let verified_dependency = visit_dependencies_and_verify(
                dependency_id.clone(),
                dependency,
                dependency_version,
                visited,
                module_cache_with_context,
            )?;
            verified_dependencies.push(verified_dependency);
        } else {
            // We must have found a cycle otherwise.
            return Err(module_cyclic_dependency_error!(
                dependency_id.address(),
                dependency_id.name()
            ));
        }
```

**File:** third_party/move/move-vm/runtime/src/storage/publishing.rs (L245-275)
```rust
            if is_lazy_loading_enabled {
                // Local bytecode verification.
                staged_runtime_environment.paranoid_check_module_address_and_name(
                    compiled_module,
                    compiled_module.self_addr(),
                    compiled_module.self_name(),
                )?;
                let locally_verified_code = staged_runtime_environment
                    .build_locally_verified_module(
                        compiled_module.clone(),
                        bytes.len(),
                        &sha3_256(bytes),
                    )?;

                // Linking checks to immediate dependencies. Note that we do not check cyclic
                // dependencies here.
                let mut verified_dependencies = vec![];
                for (dep_addr, dep_name) in locally_verified_code.immediate_dependencies_iter() {
                    // INVARIANT:
                    //   Immediate dependency of the module in a bundle must be metered at the
                    //   caller side.
                    let dependency =
                        staged_module_storage.unmetered_get_existing_lazily_verified_module(
                            &ModuleId::new(*dep_addr, dep_name.to_owned()),
                        )?;
                    verified_dependencies.push(dependency);
                }
                staged_runtime_environment.build_verified_module_with_linking_checks(
                    locally_verified_code,
                    &verified_dependencies,
                )?;
```

**File:** third_party/move/move-vm/runtime/src/config.rs (L77-77)
```rust
            enable_lazy_loading: true,
```

**File:** third_party/move/move-vm/types/src/code/errors.rs (L37-49)
```rust
macro_rules! module_cyclic_dependency_error {
    ($addr:expr, $name:expr) => {
        move_binary_format::errors::PartialVMError::new(
            move_core_types::vm_status::StatusCode::CYCLIC_MODULE_DEPENDENCY,
        )
        .with_message(format!(
            "Module {}::{} forms a cyclic dependency",
            $addr, $name
        ))
        .finish(move_binary_format::errors::Location::Module(
            move_core_types::language_storage::ModuleId::new(*$addr, $name.to_owned()),
        ))
    };
```
