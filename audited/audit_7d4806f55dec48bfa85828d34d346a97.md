# Audit Report

## Title
Empty Response from Remote Executor Provides False Confirmation Leading to Silent Liveness Failure

## Summary
The `simple_msg_exchange()` gRPC method returns an `Empty` response regardless of whether a message handler exists or message processing succeeds, providing insufficient confirmation of successful execution. This allows malicious or misconfigured executor shards to accept block execution commands without processing them, causing the coordinator to hang indefinitely while waiting for results that will never arrive.

## Finding Description

The remote executor communication system uses a gRPC-based message exchange protocol where the coordinator sends execution commands to shards and waits for results. The vulnerability exists in how message receipt confirmation is handled: [1](#0-0) 

The `simple_msg_exchange()` implementation always returns `Empty {}` on line 114, regardless of whether:
- A handler is registered for the message type (checked at line 105)
- The message was successfully queued to the handler
- The handler will process the message

When no handler exists, the implementation only logs an error (lines 109-112) but still returns success. The coordinator sends execution commands through this channel: [2](#0-1) 

After sending commands, the coordinator blocks waiting for execution results: [3](#0-2) 

The `recv()` call at line 167 has no timeout mechanism and will block indefinitely if results are never sent.

**Attack Scenario:**
A malicious or misconfigured shard can:
1. Start the gRPC server without registering execute command handlers
2. Receive `ExecuteBlockCommand` messages via `simple_msg_exchange()`
3. Return `Empty` response (automatically, line 114)
4. Never process the execution command
5. Never send results back to the coordinator

The coordinator interprets the `Empty` response as successful message delivery and waits indefinitely for results. The system has no timeout or error detection mechanism to identify this failure.

The handler registration happens correctly in properly configured shards: [4](#0-3) 

However, nothing prevents a Byzantine shard from omitting this registration or ensures handlers are registered before the gRPC server accepts messages.

## Impact Explanation

**Critical Severity** - This vulnerability causes **total loss of liveness/network availability**:

- When a malicious shard returns `Empty` without executing blocks, the coordinator blocks indefinitely at the `recv()` call with no timeout
- Block execution cannot proceed, halting the entire validator
- The network cannot make progress if any shard in the sharded execution system fails this way
- This breaks the fundamental **Deterministic Execution** invariant (validators cannot produce identical state if some don't execute)
- No recovery mechanism exists without manual intervention or process restart

Per the Aptos bug bounty program, this meets **Critical Severity** criteria for "Total loss of liveness/network availability."

## Likelihood Explanation

**High Likelihood** for the following reasons:

1. **Byzantine Fault Tolerance Gap**: The system is designed for sharded execution but lacks validation that shards are properly configured before accepting commands
2. **No Defense-in-Depth**: Multiple missing safeguards:
   - No validation that handler exists before returning `Empty`
   - No timeout on result reception
   - No health checks or heartbeat mechanism
   - No result acknowledgment protocol
3. **Easy to Exploit**: A malicious shard simply needs to start the gRPC server without calling `create_inbound_channel()` for execute commands
4. **Silent Failure**: The coordinator has no visibility into whether handlers exist - it only discovers the problem when results never arrive

While this requires a malicious validator (Byzantine behavior), the security question explicitly asks about "malicious shards," indicating this threat model is in scope.

## Recommendation

Implement proper error handling and validation:

1. **Return error if no handler exists**:
```rust
async fn simple_msg_exchange(
    &self,
    request: Request<NetworkMessage>,
) -> Result<Response<Empty>, Status> {
    let network_message = request.into_inner();
    let msg = Message::new(network_message.message);
    let message_type = MessageType::new(network_message.message_type);

    if let Some(handler) = self.inbound_handlers.lock().unwrap().get(&message_type) {
        handler.send(msg).map_err(|e| {
            Status::internal(format!("Failed to queue message: {}", e))
        })?;
        Ok(Response::new(Empty {}))
    } else {
        Err(Status::not_found(format!(
            "No handler registered for message type: {:?}",
            message_type
        )))
    }
}
```

2. **Add timeout to result reception**:
```rust
fn get_output_from_shards(&self) -> Result<Vec<Vec<Vec<TransactionOutput>>>, VMStatus> {
    let timeout = Duration::from_secs(30); // Configurable timeout
    let mut results = vec![];
    for (shard_id, rx) in self.result_rxs.iter().enumerate() {
        match rx.recv_timeout(timeout) {
            Ok(received_bytes) => {
                let result: RemoteExecutionResult = bcs::from_bytes(&received_bytes.to_bytes())?;
                results.push(result.inner?);
            },
            Err(RecvTimeoutError::Timeout) => {
                return Err(VMStatus::error(
                    StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR,
                    Some(format!("Timeout waiting for result from shard {}", shard_id))
                ));
            },
            Err(RecvTimeoutError::Disconnected) => {
                return Err(VMStatus::error(
                    StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR,
                    Some(format!("Shard {} disconnected", shard_id))
                ));
            }
        }
    }
    Ok(results)
}
```

3. **Add health check mechanism** to verify shards have registered required handlers before coordinator starts sending commands.

## Proof of Concept

```rust
#[cfg(test)]
mod malicious_shard_test {
    use super::*;
    use std::net::{IpAddr, Ipv4Addr, SocketAddr};
    use std::time::Duration;
    use aptos_config::utils;
    
    #[test]
    fn test_malicious_shard_empty_response_without_handler() {
        // Setup malicious shard - server without handler registration
        let malicious_shard_addr = SocketAddr::new(
            IpAddr::V4(Ipv4Addr::LOCALHOST), 
            utils::get_available_port()
        );
        
        // Create server wrapper with EMPTY handler map (malicious configuration)
        let empty_handlers = Arc::new(Mutex::new(HashMap::new()));
        let malicious_server = GRPCNetworkMessageServiceServerWrapper::new(
            empty_handlers,
            malicious_shard_addr,
        );
        
        let rt = Runtime::new().unwrap();
        let (shutdown_tx, shutdown_rx) = oneshot::channel();
        
        // Start malicious server without registered handlers
        malicious_server.start(
            &rt,
            "malicious_shard".to_string(),
            malicious_shard_addr,
            5000,
            shutdown_rx,
        );
        
        std::thread::sleep(Duration::from_millis(100));
        
        // Setup coordinator
        let coordinator_addr = SocketAddr::new(
            IpAddr::V4(Ipv4Addr::LOCALHOST),
            utils::get_available_port()
        );
        
        let mut client = GRPCNetworkMessageServiceClientWrapper::new(&rt, malicious_shard_addr);
        
        // Coordinator sends execute command
        let execute_cmd = Message::new(vec![1, 2, 3, 4]);
        let message_type = MessageType::new("execute_command_0".to_string());
        
        // This will succeed and return Empty, even though no handler exists!
        rt.block_on(async {
            client.send_message(coordinator_addr, execute_cmd, &message_type).await;
            // Returns successfully with Empty, falsely indicating delivery
        });
        
        // Coordinator would now wait forever for results that will never come
        // In real code: rx.recv().unwrap() would block indefinitely
        
        shutdown_tx.send(()).unwrap();
        
        // Test demonstrates: Empty returned despite no handler, 
        // coordinator has no way to detect the failure
    }
}
```

This PoC demonstrates that a shard without registered handlers successfully returns `Empty` responses, providing false confirmation to the coordinator that commands were delivered and will be processed.

### Citations

**File:** secure/net/src/grpc_network_service/mod.rs (L93-115)
```rust
    async fn simple_msg_exchange(
        &self,
        request: Request<NetworkMessage>,
    ) -> Result<Response<Empty>, Status> {
        let _timer = NETWORK_HANDLER_TIMER
            .with_label_values(&[&self.self_addr.to_string(), "inbound_msgs"])
            .start_timer();
        let remote_addr = request.remote_addr();
        let network_message = request.into_inner();
        let msg = Message::new(network_message.message);
        let message_type = MessageType::new(network_message.message_type);

        if let Some(handler) = self.inbound_handlers.lock().unwrap().get(&message_type) {
            // Send the message to the registered handler
            handler.send(msg).unwrap();
        } else {
            error!(
                "No handler registered for sender: {:?} and msg type {:?}",
                remote_addr, message_type
            );
        }
        Ok(Response::new(Empty {}))
    }
```

**File:** execution/executor-service/src/remote_executor_client.rs (L163-172)
```rust
    fn get_output_from_shards(&self) -> Result<Vec<Vec<Vec<TransactionOutput>>>, VMStatus> {
        trace!("RemoteExecutorClient Waiting for results");
        let mut results = vec![];
        for rx in self.result_rxs.iter() {
            let received_bytes = rx.recv().unwrap().to_bytes();
            let result: RemoteExecutionResult = bcs::from_bytes(&received_bytes).unwrap();
            results.push(result.inner?);
        }
        Ok(results)
    }
```

**File:** execution/executor-service/src/remote_executor_client.rs (L193-206)
```rust
        for (shard_id, sub_blocks) in sub_blocks.into_iter().enumerate() {
            let senders = self.command_txs.clone();
            let execution_request = RemoteExecutionRequest::ExecuteBlock(ExecuteBlockCommand {
                sub_blocks,
                concurrency_level: concurrency_level_per_shard,
                onchain_config: onchain_config.clone(),
            });

            senders[shard_id]
                .lock()
                .unwrap()
                .send(Message::new(bcs::to_bytes(&execution_request).unwrap()))
                .unwrap();
        }
```

**File:** execution/executor-service/src/remote_cordinator_client.rs (L27-36)
```rust
    pub fn new(
        shard_id: ShardId,
        controller: &mut NetworkController,
        coordinator_address: SocketAddr,
    ) -> Self {
        let execute_command_type = format!("execute_command_{}", shard_id);
        let execute_result_type = format!("execute_result_{}", shard_id);
        let command_rx = controller.create_inbound_channel(execute_command_type);
        let result_tx =
            controller.create_outbound_channel(coordinator_address, execute_result_type);
```
