# Audit Report

## Title
Governance Gas Schedule Update Allows All-Zero Gas Costs Enabling Unlimited Transaction Spam

## Summary
The Aptos governance gas schedule update mechanism lacks validation on gas parameter entries, allowing malicious governance proposals to set all gas costs to zero. This makes all transactions free, enabling unlimited spam attacks and potential network collapse through database bloat and resource exhaustion.

## Finding Description

The `gas_schedule.move` module allows governance to update the on-chain gas schedule through `set_gas_schedule()` and `set_for_next_epoch()` functions. These functions only validate that the serialized blob is non-empty and that the feature version is monotonically increasing, but perform **no validation** on the actual gas parameter entries. [1](#0-0) 

The validation only checks:
1. The blob is non-empty (line 59)
2. The feature_version is >= current version (lines 65-66)
3. **Nothing else** - there are explicit TODO comments indicating missing consistency checks [2](#0-1) [3](#0-2) [4](#0-3) 

An attacker can craft a malicious `GasScheduleV2` structure with:
- `feature_version`: Any value >= current version (to pass validation)
- `entries`: Vector of all gas parameters set to value `0`

Example malicious payload:
```
GasScheduleV2 {
    feature_version: 46,  // Current + 1
    entries: [
        ("instr.nop", 0),
        ("instr.ret", 0),
        ("instr.add", 0),
        // ... all parameters set to 0
    ]
}
```

This blob would pass all Move-level validations and be applied to the network. When the VM loads this gas schedule, it succeeds (all required parameters are present), but every gas cost is zero. [5](#0-4) 

The gas meter then charges zero for all operations: [6](#0-5) 

When gas parameters are zero, expressions like `self.algebra.charge_execution(NOP)` charge 0 gas, making all transactions free regardless of their `gas_unit_price`.

**Attack Path:**
1. Attacker creates governance proposal with malicious gas schedule blob
2. Proposal passes governance vote (requires stake but is politically feasible for gas "optimization")
3. At next epoch, malicious gas schedule is activated via `on_new_epoch()` [7](#0-6) 
4. All validators load the zero-cost gas schedule successfully
5. Every transaction now costs 0 gas regardless of complexity
6. Attackers spam unlimited transactions (transfers, contract deployments, etc.)
7. Network becomes unusable due to mempool saturation, block space exhaustion
8. Database grows uncontrollably, eventually requiring hardfork to recover

**Broken Invariants:**
- **Resource Limits** (Invariant #9): Gas limits are completely bypassed
- **Move VM Safety** (Invariant #3): Bytecode execution no longer respects gas constraints
- **Total loss of liveness/network availability** due to spam

## Impact Explanation

This vulnerability qualifies as **Critical Severity** under the Aptos Bug Bounty program criteria:

1. **Total loss of liveness/network availability**: Unlimited free transactions would overwhelm the network, filling blocks, saturating mempools, and making the network unusable for legitimate users.

2. **Non-recoverable network partition (requires hardfork)**: Once the malicious gas schedule is activated, reverting it requires either:
   - Another governance proposal (which would be difficult to execute if the network is under spam attack)
   - A hardfork to reset the gas schedule and potentially prune spam transactions

3. **State bloat attack**: Free transactions enable attackers to create unlimited storage entries, events, and modules, causing database size to grow uncontrollably and potentially crash validator nodes.

The impact affects **all validators and all users** simultaneously, making this a network-wide critical failure.

## Likelihood Explanation

**Likelihood: Medium-High**

**Requirements for exploitation:**
- Attacker needs governance proposal to pass (requires convincing stake holders)
- However, this could be presented as a "gas optimization" proposal
- Or could result from an accidental bug in legitimate gas schedule update tooling
- No technical barriers exist once governance passes

**Factors increasing likelihood:**
1. The validation gap is documented in TODO comments, indicating known technical debt
2. Gas schedule updates are regular governance activities, providing cover
3. The tooling in `aptos-gas-schedule-updator/` doesn't validate entries either [8](#0-7) 
4. No runtime checks prevent this until after activation

**Factors decreasing likelihood:**
- Requires governance approval
- Likely to be caught during community review (if malicious)
- But could slip through as bug in legitimate update

## Recommendation

**Immediate Fix:** Add comprehensive validation to `set_for_next_epoch()` and `set_gas_schedule()`:

```move
public fun set_for_next_epoch(aptos_framework: &signer, gas_schedule_blob: vector<u8>) acquires GasScheduleV2 {
    system_addresses::assert_aptos_framework(aptos_framework);
    assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));
    
    let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
    
    // NEW VALIDATION: Check entries are non-empty
    assert!(!vector::is_empty(&new_gas_schedule.entries), error::invalid_argument(EINVALID_GAS_SCHEDULE));
    
    // NEW VALIDATION: Check all values are non-zero
    let i = 0;
    let len = vector::length(&new_gas_schedule.entries);
    while (i < len) {
        let entry = vector::borrow(&new_gas_schedule.entries, i);
        assert!(entry.val > 0, error::invalid_argument(EINVALID_GAS_SCHEDULE));
        i = i + 1;
    };
    
    // NEW VALIDATION: Check minimum required parameters exist
    // (Implementation would verify all critical parameters like instr.*, txn.*, etc. are present)
    
    if (exists<GasScheduleV2>(@aptos_framework)) {
        let cur_gas_schedule = borrow_global<GasScheduleV2>(@aptos_framework);
        assert!(
            new_gas_schedule.feature_version >= cur_gas_schedule.feature_version,
            error::invalid_argument(EINVALID_GAS_FEATURE_VERSION)
        );
    };
    config_buffer::upsert(new_gas_schedule);
}
```

**Additional recommendations:**
1. Implement the TODO consistency checks
2. Create a whitelist of expected gas parameter keys for each feature version
3. Add minimum/maximum bounds for gas values (e.g., `min_transaction_gas_units` must be > 0)
4. Add Rust-level validation in the governance proposal generation tooling
5. Consider adding an emergency pause mechanism for gas schedule changes

## Proof of Concept

```move
#[test(framework = @aptos_framework)]
fun test_zero_gas_schedule_attack(framework: &signer) {
    use std::vector;
    use aptos_framework::gas_schedule;
    
    // Create malicious gas schedule with all zeros
    let malicious_schedule = GasScheduleV2 {
        feature_version: 46,  // Valid feature version
        entries: vector[
            GasEntry { key: string::utf8(b"instr.nop"), val: 0 },
            GasEntry { key: string::utf8(b"instr.ret"), val: 0 },
            GasEntry { key: string::utf8(b"instr.add"), val: 0 },
            GasEntry { key: string::utf8(b"txn.min_transaction_gas_units"), val: 0 },
            // ... all other parameters set to 0
        ]
    };
    
    // Serialize the malicious schedule
    let malicious_blob = bcs::to_bytes(&malicious_schedule);
    
    // This should fail with proper validation but currently succeeds
    gas_schedule::set_for_next_epoch(framework, malicious_blob);
    
    // After epoch change, all transactions would be free
    // Attacker can now spam unlimited transactions at zero cost
}
```

**Notes:**

While the security question specifically asked about `feature_version` manipulation in `current_gas_schedule()`, the actual exploitable vulnerability is in the **governance gas schedule update mechanism** that lacks validation on the gas parameter values themselves. The `current_gas_schedule()` function is a helper that uses `AptosGasParameters::initial()` which has hardcoded non-zero values, so feature_version alone cannot cause zero costs in that specific function. However, governance proposals can directly set arbitrary gas schedules, bypassing this entirely, which is the real attack vector.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L47-47)
```text
        // TODO(Gas): check if gas schedule is consistent
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L57-81)
```text
    public fun set_gas_schedule(aptos_framework: &signer, gas_schedule_blob: vector<u8>) acquires GasSchedule, GasScheduleV2 {
        system_addresses::assert_aptos_framework(aptos_framework);
        assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));
        chain_status::assert_genesis();

        if (exists<GasScheduleV2>(@aptos_framework)) {
            let gas_schedule = borrow_global_mut<GasScheduleV2>(@aptos_framework);
            let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
            assert!(new_gas_schedule.feature_version >= gas_schedule.feature_version,
                error::invalid_argument(EINVALID_GAS_FEATURE_VERSION));
            // TODO(Gas): check if gas schedule is consistent
            *gas_schedule = new_gas_schedule;
        }
        else {
            if (exists<GasSchedule>(@aptos_framework)) {
                _ = move_from<GasSchedule>(@aptos_framework);
            };
            let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
            // TODO(Gas): check if gas schedule is consistent
            move_to<GasScheduleV2>(aptos_framework, new_gas_schedule);
        };

        // Need to trigger reconfiguration so validator nodes can sync on the updated gas schedule.
        reconfiguration::reconfigure();
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L135-145)
```text
    public(friend) fun on_new_epoch(framework: &signer) acquires GasScheduleV2 {
        system_addresses::assert_aptos_framework(framework);
        if (config_buffer::does_exist<GasScheduleV2>()) {
            let new_gas_schedule = config_buffer::extract_v2<GasScheduleV2>();
            if (exists<GasScheduleV2>(@aptos_framework)) {
                *borrow_global_mut<GasScheduleV2>(@aptos_framework) = new_gas_schedule;
            } else {
                move_to(framework, new_gas_schedule);
            }
        }
    }
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/macros.rs (L48-61)
```rust
        impl $crate::traits::ToOnChainGasSchedule for $params_name {
            #[allow(unused)]
            fn to_on_chain_gas_schedule(&self, feature_version: u64) -> Vec<(String, u64)> {
                let mut output = vec![];

                $(
                    if let Some(key) = $crate::gas_schedule::macros::define_gas_parameters_extract_key_at_version!($key_bindings, feature_version) {
                        output.push((format!("{}.{}", $prefix, key), self.$name.into()))
                    }
                )*

                output
            }
        }
```

**File:** aptos-move/aptos-gas-meter/src/meter.rs (L122-129)
```rust
    fn charge_simple_instr(&mut self, instr: SimpleInstruction) -> PartialVMResult<()> {
        macro_rules! dispatch {
            ($($name: ident => $cost: expr),* $(,)?) => {
                match instr {
                    $(SimpleInstruction::$name => self.algebra.charge_execution($cost)),*
                }
            };
        }
```

**File:** aptos-move/aptos-gas-schedule-updator/src/lib.rs (L115-121)
```rust
/// Constructs the current gas schedule in on-chain format.
pub fn current_gas_schedule(feature_version: u64) -> GasScheduleV2 {
    GasScheduleV2 {
        feature_version,
        entries: AptosGasParameters::initial().to_on_chain_gas_schedule(feature_version),
    }
}
```
