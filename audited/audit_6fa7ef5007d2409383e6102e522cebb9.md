# Audit Report

## Title
Insufficient Runtime Protection Against consensus-only-perf-test Feature in Production Validators

## Summary
The `consensus-only-perf-test` feature can be accidentally enabled in production builds despite runtime safeguards, potentially causing validators to run with `FakeAptosDB` and lose all post-genesis state persistence. The protection mechanism has critical bypass conditions that allow the feature to activate when the chain ID cannot be determined or for non-mainnet networks.

## Finding Description

The `consensus-only-perf-test` feature is a compile-time flag that replaces the persistent `AptosDB` with `FakeAptosDB`, which stores all transactions after genesis only in memory. [1](#0-0) 

`FakeAptosDB` wraps a real `AptosDB` instance but stores transactions in in-memory `DashMap` structures. Only the genesis transaction (version 0) is persisted to disk; all subsequent transactions exist only in RAM. [2](#0-1) 

The runtime protection against enabling this feature in production exists in `ConsensusConfig::sanitize()`, which checks if the feature is enabled on mainnet. [3](#0-2) 

However, this check has **three critical weaknesses**:

**Weakness 1: Chain ID Bypass** - The check only executes if `chain_id` is `Some(chain_id)`. When the chain ID cannot be extracted from the genesis transaction (due to missing or malformed genesis file), the function `extract_node_type_and_chain_id()` catches the error and returns `None`, completely bypassing the protection. [4](#0-3) 

**Weakness 2: Mainnet-Only Check** - The protection only validates `chain_id.is_mainnet()`, leaving testnet and devnet production validators unprotected from accidental compilation with this feature.

**Weakness 3: Sanitizer Bypass** - The entire config sanitizer can be disabled by setting `skip_config_sanitizer = true` in the node configuration. [5](#0-4) 

**Attack Scenario:**
1. Validator operator accidentally compiles aptos-node with `--features consensus-only-perf-test` (e.g., using wrong build command or CI/CD configuration)
2. Genesis file is missing, corrupted, or path misconfigured in node config
3. `get_chain_id()` fails to extract chain ID from genesis
4. `extract_node_type_and_chain_id()` returns `None` for chain_id
5. `ConsensusConfig::sanitize()` check is bypassed (line 516 condition fails)
6. Node starts successfully with `FakeAptosDB`
7. All transactions after genesis are stored only in memory
8. On node restart/crash, all post-genesis state is permanently lost
9. Validator cannot rejoin network without full state sync from scratch

This breaks **Critical Invariant #4 (State Consistency)**: "State transitions must be atomic and verifiable via Merkle proofs" - state persistence is completely broken.

## Impact Explanation

**Critical Severity** - This meets the "Total loss of liveness/network availability" criterion from the Aptos bug bounty program.

When a validator runs with `FakeAptosDB`:
- All state after genesis exists only in RAM
- Any restart results in complete loss of ledger state
- Validator cannot participate in consensus without full state restore
- If multiple validators are affected, network availability degrades
- State must be reconstructed via state synchronization (multi-hour process)

The in-memory data structures are initialized empty on each node restart, as seen in `FakeAptosDB::new()`. [6](#0-5) 

## Likelihood Explanation

**Medium to Low Likelihood** - While the feature requires specific conditions to bypass safeguards:

**Factors Increasing Likelihood:**
- Build systems may cache feature flags or use incorrect build profiles
- Genesis file path misconfiguration is a common operational error
- Testnet/devnet validators are completely unprotected by the check
- CI/CD pipelines show the feature is built with special labels, but these could be misapplied [7](#0-6) 

**Factors Decreasing Likelihood:**
- Feature logging at startup provides visibility [8](#0-7) 
- Requires compilation with explicit feature flag
- Docker images with this feature have distinct tagging

**Realistic Scenario:** A validator operator clones the repository, runs a build command with the wrong feature set (perhaps copied from a performance testing document), and deploys with a slightly misconfigured genesis path. The node starts without error, but state persistence is silently disabled.

## Recommendation

**Primary Fix:** Add explicit runtime checks in `bootstrap_db()` itself:

```rust
#[cfg(feature = "consensus-only-perf-test")]
pub(crate) fn bootstrap_db(
    node_config: &NodeConfig,
) -> Result<...> {
    // CRITICAL: This build uses FakeAptosDB - for testing only!
    error!("CRITICAL WARNING: consensus-only-perf-test feature is ENABLED!");
    error!("All state after genesis will be stored IN MEMORY ONLY!");
    error!("DO NOT USE IN PRODUCTION - ALL DATA WILL BE LOST ON RESTART!");
    
    // Hard fail if genesis indicates production network
    if let Ok(chain_id) = utils::fetch_chain_id_from_genesis(node_config) {
        if chain_id.is_mainnet() || chain_id.is_testnet() {
            panic!("FATAL: consensus-only-perf-test cannot be used on production networks (mainnet/testnet). Chain ID: {:?}", chain_id);
        }
    }
    
    // Even if chain_id cannot be determined, require explicit override
    let allow_consensus_only = std::env::var("APTOS_ALLOW_CONSENSUS_ONLY_PERF_TEST")
        .map(|v| v == "true")
        .unwrap_or(false);
    
    if !allow_consensus_only {
        panic!("FATAL: consensus-only-perf-test is enabled but APTOS_ALLOW_CONSENSUS_ONLY_PERF_TEST=true is not set. This feature disables state persistence and should NEVER be used in production.");
    }
    
    // ... existing code ...
}
```

**Secondary Fix:** Strengthen `ConsensusConfig::sanitize()`:

```rust
// Verify that the consensus-only feature is not enabled in production
if is_consensus_only_perf_test_enabled() {
    // Fail if we cannot determine chain_id (defensive)
    let chain_id = chain_id.ok_or_else(|| {
        Error::ConfigSanitizerFailed(
            sanitizer_name,
            "consensus-only-perf-test is enabled but chain_id cannot be determined. This is unsafe.".to_string(),
        )
    })?;
    
    // Fail for ANY production network (mainnet, testnet, devnet)
    if !chain_id.is_test() {  // Add is_test() method to ChainId
        return Err(Error::ConfigSanitizerFailed(
            sanitizer_name,
            format!("consensus-only-perf-test must not be enabled for production networks! Chain ID: {:?}", chain_id),
        ));
    }
}
```

**Tertiary Fix:** Add build-time warnings in Cargo.toml:

```toml
[features]
consensus-only-perf-test = [
    "aptos-executor/consensus-only-perf-test",
    # WARNING: This feature disables state persistence!
    # Only for performance testing. DO NOT use in production.
]
```

## Proof of Concept

This PoC demonstrates the bypass condition:

```rust
// File: config/src/config/test_consensus_only_bypass.rs
#[cfg(test)]
mod test_consensus_only_sanitizer_bypass {
    use super::*;
    use aptos_types::chain_id::ChainId;
    
    #[test]
    #[cfg(feature = "consensus-only-perf-test")]
    fn test_consensus_only_bypassed_when_chain_id_none() {
        // Create a mainnet node config
        let mut node_config = NodeConfig::default();
        
        // Simulate missing genesis file (chain_id will be None)
        node_config.execution.genesis = None;
        node_config.execution.genesis_file_location = PathBuf::from("/nonexistent/genesis.blob");
        
        // Try to sanitize with None chain_id (simulating failed genesis load)
        let result = ConsensusConfig::sanitize(
            &node_config,
            NodeType::Validator,
            None  // Chain ID is None - check is bypassed!
        );
        
        // VULNERABILITY: Sanitizer passes even though consensus-only-perf-test
        // is enabled and this could be a mainnet validator
        assert!(result.is_ok(), "Sanitizer should have failed but passed!");
        
        println!("VULNERABILITY CONFIRMED: consensus-only-perf-test bypassed when chain_id=None");
    }
    
    #[test]
    #[cfg(feature = "consensus-only-perf-test")]
    fn test_consensus_only_not_blocked_for_testnet() {
        let node_config = NodeConfig::default();
        
        // Testnet chain_id - should this be allowed in production?
        let result = ConsensusConfig::sanitize(
            &node_config,
            NodeType::Validator,
            Some(ChainId::testnet())
        );
        
        // VULNERABILITY: Testnet validators are not protected
        assert!(result.is_ok(), "Testnet not protected from consensus-only-perf-test");
        
        println!("VULNERABILITY CONFIRMED: testnet validators can run with FakeAptosDB");
    }
}
```

To reproduce operationally:
1. Compile aptos-node: `cargo build --release --features consensus-only-perf-test`
2. Create node config with missing/invalid genesis path
3. Start node: `./target/release/aptos-node --config misconfigured.yaml`
4. Observe: Node starts successfully, logs show feature is enabled
5. Process transactions (all go to memory only)
6. Restart node
7. Observe: All post-genesis state is lost

## Notes

This vulnerability represents a **defense-in-depth failure** where multiple safeguards exist but have critical gaps:

1. The CI/CD system controls feature enablement via PR labels, but this is a process control, not a technical enforcement
2. The runtime sanitizer check exists but can be trivially bypassed
3. Feature logging provides visibility but no prevention
4. Docker image tagging helps but doesn't prevent manual builds

The root issue is that `consensus-only-perf-test` fundamentally changes system behavior (disabling persistence) but relies on weak runtime checks that can fail silently. A defense-in-depth approach requires checks at the actual point of use (`bootstrap_db()`), not just in config validation which can be skipped or bypassed.

### Citations

**File:** aptos-node/src/storage.rs (L111-130)
```rust
#[cfg(feature = "consensus-only-perf-test")]
pub(crate) fn bootstrap_db(
    node_config: &NodeConfig,
) -> Result<(Arc<dyn DbReader>, DbReaderWriter, Option<Runtime>)> {
    use aptos_db::db::fake_aptosdb::FakeAptosDB;

    let aptos_db = AptosDB::open(
        node_config.storage.get_dir_paths(),
        false, /* readonly */
        node_config.storage.storage_pruner_config,
        node_config.storage.rocksdb_configs,
        node_config.storage.enable_indexer,
        node_config.storage.buffered_state_target_items,
        node_config.storage.max_num_nodes_per_lru_cache_shard,
    )
    .map_err(|err| anyhow!("DB failed to open {}", err))?;
    let (aptos_db, db_rw) = DbReaderWriter::wrap(FakeAptosDB::new(aptos_db));
    maybe_apply_genesis(&db_rw, node_config)?;
    Ok((aptos_db, db_rw, None))
}
```

**File:** storage/aptosdb/src/db/fake_aptosdb.rs (L176-189)
```rust
    pub fn new(db: AptosDB) -> Self {
        Self {
            inner: db,
            txn_by_version: Arc::new(DashMap::new()),
            txn_version_by_hash: Arc::new(DashMap::new()),
            txn_info_by_version: Arc::new(DashMap::new()),
            txn_hash_by_position: Arc::new(DashMap::new()),
            account_seq_num: Arc::new(DashMap::new()),
            latest_block_timestamp: AtomicU64::new(0),
            latest_version: Mutex::new(None),
            ledger_commit_lock: std::sync::Mutex::new(()),
            buffered_state: Mutex::new(FakeBufferedState::new_empty()),
        }
    }
```

**File:** storage/aptosdb/src/db/fake_aptosdb.rs (L406-416)
```rust
            if first_version == 0 {
                self.inner.save_transactions_for_test(
                    txns_to_commit,
                    first_version,
                    base_state_version,
                    ledger_info_with_sigs,
                    sync_commit,
                    &latest_in_memory_state,
                    true,
                )?;
            }
```

**File:** config/src/config/consensus_config.rs (L516-523)
```rust
        if let Some(chain_id) = chain_id {
            if chain_id.is_mainnet() && is_consensus_only_perf_test_enabled() {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "consensus-only-perf-test should not be enabled in mainnet!".to_string(),
                ));
            }
        }
```

**File:** config/src/config/node_config_loader.rs (L117-122)
```rust
    match get_chain_id(node_config) {
        Ok(chain_id) => (node_type, Some(chain_id)),
        Err(error) => {
            println!("Failed to extract the chain ID from the genesis transaction: {:?}! Continuing with None.", error);
            (node_type, None)
        },
```

**File:** config/src/config/config_sanitizer.rs (L45-48)
```rust
        // If config sanitization is disabled, don't do anything!
        if node_config.node_startup.skip_config_sanitizer {
            return Ok(());
        }
```

**File:** .github/workflows/docker-build-test.yaml (L183-196)
```yaml
  rust-images-consensus-only-perf-test:
    needs: [permission-check, determine-docker-build-metadata]
    if: |
      contains(github.event.pull_request.labels.*.name, 'CICD:build-consensus-only-image') ||
      contains(github.event.pull_request.labels.*.name, 'CICD:run-consensus-only-perf-test')
    uses: aptos-labs/aptos-core/.github/workflows/workflow-run-docker-rust-build.yaml@main
    secrets: inherit
    with:
      GIT_SHA: ${{ needs.determine-docker-build-metadata.outputs.gitSha }}
      TARGET_CACHE_ID: ${{ needs.determine-docker-build-metadata.outputs.targetCacheId }}
      PROFILE: release
      FEATURES: consensus-only-perf-test
      BUILD_ADDL_TESTING_IMAGES: true
      TARGET_REGISTRY: ${{ needs.determine-docker-build-metadata.outputs.targetRegistry }}
```

**File:** aptos-node/src/logger.rs (L78-86)
```rust
    log_feature_info!(
        "assert-private-keys-not-cloneable",
        "check-vm-features",
        "consensus-only-perf-test",
        "default",
        "failpoints",
        "indexer",
        "tokio-console"
    );
```
