# Audit Report

## Title
Consensus Safety Violation: Config Version Mismatch Causes Validators to Create Different Block Metadata

## Summary
A validator that fails to read the on-chain `OnChainConsensusConfig` during epoch transition will fall back to V4 (with `rand_check_enabled=false`), while other validators successfully reading V5 config (with `rand_check_enabled=true`) will skip waiting for randomness. This causes validators to create different block metadata transactions, violating the deterministic execution invariant and breaking consensus safety.

## Finding Description

The vulnerability exists in the interaction between three components:

1. **Config Loading with Silent Fallback** [1](#0-0) 

When validators start a new epoch, they read `OnChainConsensusConfig` from on-chain state. If this fails (due to deserialization errors, storage issues, or network problems), the error is only logged as a warning, and the code falls back to `OnChainConsensusConfig::default()`, which returns V4.

2. **Version-Dependent rand_check_enabled Behavior** [2](#0-1) 

The `rand_check_enabled()` function returns `false` for V1-V4 but can return `true` for V5. This difference controls whether validators skip waiting for randomness when blocks don't contain randomness-requiring transactions.

3. **Divergent Metadata Creation** [3](#0-2) 

When `rand_check_enabled=true` and `has_randomness=false`, validators immediately return `None` without waiting for randomness. When `rand_check_enabled=false`, validators wait for and receive randomness from the RandManager (which generates it for all blocks). [4](#0-3) 

Both paths create block metadata using `new_metadata_with_randomness()`, but with different randomness values:
- Validator with `rand_check_enabled=true`: passes `None`
- Validator with `rand_check_enabled=false`: passes the received randomness (could be `Some(Randomness)`) [5](#0-4) 

The `BlockMetadataWithRandomness` struct includes `randomness: Option<Randomness>` as a field, meaning different randomness values create fundamentally different transactions.

**Attack Scenario:**
1. On-chain config is upgraded to V5 with `rand_check_enabled=true`
2. During epoch transition, Validator A successfully reads V5 config
3. Validator B encounters a transient deserialization or storage error, falls back to V4 default
4. For a block without randomness-requiring transactions:
   - Validator A: Creates metadata with `randomness=None`
   - Validator B: Creates metadata with `randomness=Some(actual_randomness)` (from RandManager)
5. Different metadata transactions lead to different execution results and state roots
6. Validators cannot reach 2/3+ agreement on state commitment â†’ consensus halts

## Impact Explanation

**Critical Severity** - This vulnerability causes a consensus safety violation, which falls under the Critical Severity category ($1,000,000 max bounty):

- **Consensus Safety Breach**: Validators executing identical blocks produce different state roots, violating the fundamental invariant that "all validators must produce identical state roots for identical blocks"
- **Network Partition**: Unable to achieve quorum on commits, the network effectively partitions between validators with different configs
- **Requires Hardfork**: Recovery requires coordinated intervention to force all validators to the same config version
- **Non-Byzantine Failure**: Occurs without any malicious actors, just from transient infrastructure issues

The impact meets the "Consensus/Safety violations" and "Non-recoverable network partition (requires hardfork)" criteria for Critical severity.

## Likelihood Explanation

**Medium Likelihood:**

While the scenario requires a validator to fail reading on-chain config, several factors make this realistic:

1. **Transient Failures**: Network partitions, storage corruption, or temporary resource exhaustion can cause read failures
2. **Silent Degradation**: The failure is only logged as a warning, not treated as fatal [6](#0-5) 

3. **Version Migration Period**: Most likely to occur during the upgrade from V4 to V5 when some validators may have outdated clients or experience deserialization issues with the new config format
4. **No Recovery Mechanism**: Once a validator loads the wrong config, it continues until the next epoch

The likelihood is not "High" because it requires a failure condition, but it's not "Low" because such failures are common in distributed systems and the impact is catastrophic.

## Recommendation

**Immediate Fix**: Make config reading errors fatal during epoch start instead of falling back to default:

```rust
// In epoch_manager.rs, around line 1201
let consensus_config = onchain_consensus_config
    .expect("Failed to read on-chain consensus config - cannot start epoch");
```

**Better Solution**: Implement retry logic and only fail after multiple attempts:

```rust
let consensus_config = match onchain_consensus_config {
    Ok(config) => config,
    Err(error) => {
        error!("Failed to read on-chain consensus config: {}", error);
        // Retry logic here
        panic!("Cannot start epoch without valid consensus config");
    }
};
```

**Defense in Depth**: Add validation that all validators loaded the same config version:
- Include config version hash in the first block of each epoch
- Validators verify they have matching configs before processing blocks
- Fail-stop if mismatch detected

## Proof of Concept

```rust
// Simulation demonstrating the vulnerability
// This would be a Rust integration test in consensus/src/epoch_manager_test.rs

#[tokio::test]
async fn test_config_mismatch_breaks_consensus() {
    // Setup: Two validators with same epoch state
    let epoch_state = create_test_epoch_state();
    
    // Validator A successfully loads V5 config
    let config_v5 = OnChainConsensusConfig::V5 {
        alg: ConsensusAlgorithmConfig::default_for_genesis(),
        vtxn: ValidatorTxnConfig::default_for_genesis(),
        window_size: None,
        rand_check_enabled: true, // KEY: randomness check enabled
    };
    
    // Validator B falls back to V4 default (simulating read failure)
    let config_v4 = OnChainConsensusConfig::default(); // V4 with rand_check_enabled=false
    
    // Create pipeline builders with different configs
    let pipeline_a = create_pipeline_builder_with_config(&config_v5);
    let pipeline_b = create_pipeline_builder_with_config(&config_v4);
    
    // Create a block with NO randomness-requiring transactions
    let block = create_block_without_randomness_txns();
    
    // Build pipelines for both validators
    let futs_a = pipeline_a.build_internal(/* ... */);
    let futs_b = pipeline_b.build_internal(/* ... */);
    
    // Wait for execution
    let result_a = futs_a.execute_fut.await.unwrap();
    let result_b = futs_b.execute_fut.await.unwrap();
    
    // Get state roots
    let root_a = get_state_root_from_result(&result_a);
    let root_b = get_state_root_from_result(&result_b);
    
    // ASSERTION FAILS: Different state roots!
    assert_ne!(root_a, root_b, 
        "Validators with different rand_check_enabled produced different state roots!");
}
```

**Steps to reproduce in live network:**
1. Deploy V5 config with `rand_check_enabled=true` to testnet
2. Simulate storage failure on one validator during epoch transition (e.g., inject fault in `payload.get::<OnChainConsensusConfig>()`)
3. Observe that validator falls back to V4 default
4. Submit blocks without randomness transactions
5. Monitor consensus - validators will fail to agree on state roots
6. Network halts due to inability to reach quorum

### Citations

**File:** consensus/src/epoch_manager.rs (L1178-1201)
```rust
        let onchain_consensus_config: anyhow::Result<OnChainConsensusConfig> = payload.get();
        let onchain_execution_config: anyhow::Result<OnChainExecutionConfig> = payload.get();
        let onchain_randomness_config_seq_num: anyhow::Result<RandomnessConfigSeqNum> =
            payload.get();
        let randomness_config_move_struct: anyhow::Result<RandomnessConfigMoveStruct> =
            payload.get();
        let onchain_jwk_consensus_config: anyhow::Result<OnChainJWKConsensusConfig> = payload.get();
        let dkg_state = payload.get::<DKGState>();

        if let Err(error) = &onchain_consensus_config {
            warn!("Failed to read on-chain consensus config {}", error);
        }

        if let Err(error) = &onchain_execution_config {
            warn!("Failed to read on-chain execution config {}", error);
        }

        if let Err(error) = &randomness_config_move_struct {
            warn!("Failed to read on-chain randomness config {}", error);
        }

        self.epoch_state = Some(epoch_state.clone());

        let consensus_config = onchain_consensus_config.unwrap_or_default();
```

**File:** types/src/on_chain_config/consensus_config.rs (L414-425)
```rust
    pub fn rand_check_enabled(&self) -> bool {
        match self {
            OnChainConsensusConfig::V1(_)
            | OnChainConsensusConfig::V2(_)
            | OnChainConsensusConfig::V3 { .. }
            | OnChainConsensusConfig::V4 { .. } => false,
            OnChainConsensusConfig::V5 {
                rand_check_enabled: rand_check,
                ..
            } => *rand_check,
        }
    }
```

**File:** consensus/src/pipeline/pipeline_builder.rs (L775-783)
```rust
        let maybe_rand = if rand_check_enabled && !has_randomness {
            None
        } else {
            rand_rx
                .await
                .map_err(|_| anyhow!("randomness tx cancelled"))?
        };
        Ok((Some(maybe_rand), has_randomness))
    }
```

**File:** consensus/src/pipeline/pipeline_builder.rs (L803-811)
```rust
        let (rand_result, _has_randomness) = rand_check.await?;

        tracker.start_working();
        // if randomness is disabled, the metadata skips DKG and triggers immediate reconfiguration
        let metadata_txn = if let Some(maybe_rand) = rand_result {
            block.new_metadata_with_randomness(&validator, maybe_rand)
        } else {
            block.new_block_metadata(&validator).into()
        };
```

**File:** types/src/block_metadata_ext.rs (L24-34)
```rust
pub struct BlockMetadataWithRandomness {
    pub id: HashValue,
    pub epoch: u64,
    pub round: u64,
    pub proposer: AccountAddress,
    #[serde(with = "serde_bytes")]
    pub previous_block_votes_bitvec: Vec<u8>,
    pub failed_proposer_indices: Vec<u32>,
    pub timestamp_usecs: u64,
    pub randomness: Option<Randomness>,
}
```
