# Audit Report

## Title
REST API Lacks Cryptographic State Proofs for VotingRecords, Enabling Malicious Full Nodes to Serve Unverifiable Fake Governance Data

## Summary
The REST API's `get_account_resource_bcs` endpoint returns governance-critical `VotingRecords` data without cryptographic state proofs, allowing malicious full node operators to serve fabricated table handles and voting data that clients cannot verify. This violates the security principle that full node operators should be untrusted actors.

## Finding Description

The `VotingRecords` struct contains a single field `votes` of type `AccountAddress` that serves as a table handle for accessing individual voting records: [1](#0-0) 

When the Aptos CLI governance tool checks voting status, it retrieves this resource via the REST API client: [2](#0-1) 

The REST client implementation simply deserializes the response without any cryptographic verification: [3](#0-2) 

The underlying HTTP response processing provides no state proof verification: [4](#0-3) 

And response validation only checks HTTP status codes, not cryptographic integrity: [5](#0-4) 

The REST API server-side implementation retrieves data from storage without generating proofs: [6](#0-5) 

**Critical Gap:** While the storage layer provides methods to retrieve state values with Merkle proofs (`get_state_value_with_proof_by_version_ext`), and proof verification infrastructure exists, the REST API does not expose these proofs to clients. [7](#0-6) 

**Attack Scenario:**

1. Alice connects to a malicious full node (via misconfigured RPC endpoint, DNS hijacking, or malicious RPC provider)
2. Alice queries `VotingRecords` to check if her stake pool has voted on a proposal
3. The malicious full node returns a fabricated `VotingRecords` with a fake table handle
4. When Alice queries the fake table for her voting record, it returns `true` (already voted)
5. Alice's CLI skips voting, believing she's already voted: [8](#0-7) 
6. Alice's voting power is effectively censored

Alternatively, the attacker could display fake voting data to mislead governance participants about proposal status, vote counts, or voting power distribution.

## Impact Explanation

**High Severity** per Aptos bug bounty criteria for "Significant protocol violations." This issue:

- Violates the **State Consistency** invariant: "State transitions must be atomic and verifiable via Merkle proofs" - verification is impossible via REST API
- Violates the **Governance Integrity** invariant by allowing manipulation of voting information
- Enables vote censorship attacks against governance participants
- Allows information manipulation that could affect critical governance decisions
- Undermines the trust model by forcing clients to trust full node operators despite them being classified as untrusted actors

While this does not directly compromise on-chain state (validators still validate transactions correctly), it severely compromises off-chain information integrity for governance operations.

## Likelihood Explanation

**Medium to High likelihood:**

- **Low barrier to attack:** Any actor can operate a full node and serve malicious REST API responses
- **Realistic victim scenarios:** 
  - Users connecting to public RPC providers (inherently untrusted)
  - DNS hijacking redirecting users to malicious nodes
  - Misconfigured wallet/CLI RPC endpoints
  - Compromised infrastructure providers
- **High-value target:** Governance participants with significant voting power are attractive targets
- **No client-side detection:** Current implementation provides zero cryptographic verification

The only mitigation is running a trusted full node, which is impractical for most users and defeats the purpose of having public APIs.

## Recommendation

**Immediate Fix:** Add a `with_proof` variant to account resource endpoints that returns resources with SparseMerkleProof:

```rust
// Add to api/src/state.rs
pub async fn get_account_resource_with_proof(
    &self,
    address: Address,
    resource_type: MoveStructTag,
    ledger_version: Option<u64>,
) -> BasicResultWith404<ResourceWithProof> {
    let (ledger_info, ledger_version, state_view) = self.context.state_view(ledger_version)?;
    let state_key = StateKey::resource(&address, &resource_type)?;
    
    // Use existing proof-generating storage method
    let (state_value, proof) = self.context.db
        .get_state_value_with_proof_by_version_ext(&state_key, ledger_version)?;
    
    // Return both data and proof
    Ok(ResourceWithProof {
        data: state_value,
        proof: proof,
        ledger_info: ledger_info,
    })
}
```

**Client-side Fix:** Update REST client to verify proofs when available:

```rust
// In crates/aptos-rest-client/src/lib.rs
pub async fn get_account_resource_bcs_verified<T: DeserializeOwned>(
    &self,
    address: AccountAddress,
    resource_type: &str,
    trusted_state_root: HashValue,
) -> AptosResult<Response<T>> {
    let response = self.get_account_resource_with_proof(address, resource_type).await?;
    
    // Verify the proof against trusted state root
    response.proof.verify(trusted_state_root, response.state_key, Some(&response.data))?;
    
    Ok(Response::new(bcs::from_bytes(&response.data)?, response.state))
}
```

Clients should maintain a `TrustedState` (using the existing light client infrastructure) and verify all resource responses against it.

## Proof of Concept

```rust
// Simulated malicious full node attack
use aptos_rest_client::Client;
use aptos_types::{account_address::AccountAddress, governance::VotingRecords};

#[tokio::test]
async fn test_malicious_full_node_fake_voting_records() {
    // Victim connects to what they believe is a legitimate full node
    let malicious_node_url = "http://malicious-node.example.com";
    let client = Client::new(malicious_node_url.parse().unwrap());
    
    // Victim queries VotingRecords to check voting status
    let voting_records = client
        .get_account_resource_bcs::<VotingRecords>(
            AccountAddress::ONE,
            "0x1::aptos_governance::VotingRecords",
        )
        .await
        .unwrap()
        .into_inner();
    
    // The malicious node returns a fake table handle
    // (e.g., pointing to an attacker-controlled table or fake data)
    let fake_table_handle = voting_records.votes;
    
    // When victim queries individual voting records using this handle,
    // they get fake data (e.g., "already voted" when they haven't)
    let voting_record = client
        .get_table_item(
            fake_table_handle,
            "0x1::aptos_governance::RecordKey",
            "bool",
            serde_json::json!({
                "proposal_id": "1",
                "stake_pool": "0x123..."
            }),
        )
        .await
        .unwrap();
    
    // Victim believes they've already voted and skips voting
    // Their voting power is effectively censored
    // There is NO WAY for the victim to detect this manipulation
    // because the REST API provides no cryptographic proofs
}
```

The attack succeeds because the REST API provides no mechanism for clients to verify the authenticity of the returned data against the blockchain's cryptographically verified state.

### Citations

**File:** types/src/governance.rs (L7-10)
```rust
#[derive(Debug, Serialize, Deserialize)]
pub struct VotingRecords {
    pub votes: AccountAddress,
}
```

**File:** crates/aptos/src/governance/mod.rs (L538-546)
```rust
        let voting_records = client
            .get_account_resource_bcs::<VotingRecords>(
                CORE_CODE_ADDRESS,
                "0x1::aptos_governance::VotingRecords",
            )
            .await
            .unwrap()
            .into_inner()
            .votes;
```

**File:** crates/aptos/src/governance/mod.rs (L566-569)
```rust
            if voted {
                println!("Stake pool {} already voted", *pool_address);
                continue;
            }
```

**File:** crates/aptos-rest-client/src/lib.rs (L1209-1220)
```rust
    pub async fn get_account_resource_bcs<T: DeserializeOwned>(
        &self,
        address: AccountAddress,
        resource_type: &str,
    ) -> AptosResult<Response<T>> {
        let url = self.build_path(&format!(
            "accounts/{}/resource/{}",
            address.to_hex(),
            resource_type
        ))?;
        let response = self.get_bcs(url).await?;
        Ok(response.and_then(|inner| bcs::from_bytes(&inner))?)
```

**File:** crates/aptos-rest-client/src/lib.rs (L1645-1656)
```rust
    async fn check_response(
        &self,
        response: reqwest::Response,
    ) -> AptosResult<(reqwest::Response, State)> {
        if !response.status().is_success() {
            Err(parse_error(response).await)
        } else {
            let state = parse_state(&response)?;

            Ok((response, state))
        }
    }
```

**File:** crates/aptos-rest-client/src/lib.rs (L1687-1690)
```rust
    async fn get_bcs(&self, url: Url) -> AptosResult<Response<bytes::Bytes>> {
        let response = self.inner.get(url).header(ACCEPT, BCS).send().await?;
        self.check_and_parse_bcs_response(response).await
    }
```

**File:** api/src/state.rs (L274-305)
```rust
    fn resource(
        &self,
        accept_type: &AcceptType,
        address: Address,
        resource_type: MoveStructTag,
        ledger_version: Option<u64>,
    ) -> BasicResultWith404<MoveResource> {
        let tag: StructTag = (&resource_type)
            .try_into()
            .context("Failed to parse given resource type")
            .map_err(|err| {
                BasicErrorWith404::bad_request_with_code_no_info(err, AptosErrorCode::InvalidInput)
            })?;

        let (ledger_info, ledger_version, state_view) = self.context.state_view(ledger_version)?;
        let bytes = state_view
            .as_converter(self.context.db.clone(), self.context.indexer_reader.clone())
            .find_resource(&state_view, address, &tag)
            .context(format!(
                "Failed to query DB to check for {} at {}",
                tag.to_canonical_string(),
                address
            ))
            .map_err(|err| {
                BasicErrorWith404::internal_with_code(
                    err,
                    AptosErrorCode::InternalError,
                    &ledger_info,
                )
            })?
            .ok_or_else(|| resource_not_found(address, &tag, ledger_version, &ledger_info))?;

```

**File:** types/src/proof/definition.rs (L302-326)
```rust
    pub fn verify<V: CryptoHash>(
        &self,
        expected_root_hash: HashValue,
        element_key: HashValue,
        element_value: Option<&V>,
    ) -> Result<()> {
        self.verify_by_hash(
            expected_root_hash,
            element_key,
            element_value.map(|v| v.hash()),
        )
    }

    /// If `element_hash` is present, verifies an element whose key is `element_key` and value is
    /// authenticated by `element_hash` exists in the Sparse Merkle Tree using the provided proof.
    /// Otherwise verifies the proof is a valid non-inclusion proof that shows this key doesn't
    /// exist in the tree.
    pub fn verify_by_hash(
        &self,
        expected_root_hash: HashValue,
        element_key: HashValue,
        element_hash: Option<HashValue>,
    ) -> Result<()> {
        self.verify_by_hash_partial(expected_root_hash, element_key, element_hash, 0)
    }
```
