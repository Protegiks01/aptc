# Audit Report

## Title
Critical VM Errors Bypass Alert System Due to Inconsistent Use of alert! Macro

## Summary
Multiple critical error paths in `aptos_vm.rs` and `block-executor` use the standard `error!()` macro instead of the `alert!()` macro, causing critical VM invariant violations—including mandatory paranoid mode failures—to be logged without incrementing the `CRITICAL_ERRORS` monitoring counter. This creates a monitoring blind spot where critical security issues may go undetected.

## Finding Description

The `alert!()` macro is designed to both log errors AND increment the `CRITICAL_ERRORS` counter for triggering alerts: [1](#0-0) 

However, several critical error paths use the standard `error!()` macro instead, creating inconsistency where critical errors are logged but not counted:

**1. Paranoid Mode Failures (aptos_vm.rs)**

Despite an explicit comment stating "We need to be alerted about this ASAP", all paranoid mode failures use `error!()` instead of `alert!()`: [2](#0-1) 

This affects four types of paranoid failures:
- `EPARANOID_FAILURE` (general paranoid type checking)
- `EREFERENCE_COUNTING_FAILURE` (reference counting violations)  
- `EREFERENCE_SAFETY_FAILURE` (reference safety violations)
- `EINDEXED_REF_TAG_MISMATCH` (enum tag guard violations)

Paranoid mode is **mandatory on mainnet**: [3](#0-2) 

**2. FatalVMError in Sequential Execution (block-executor)**

Sequential execution logs FatalVMErrors with `error!()`, inconsistent with similar errors that use `alert!()`: [4](#0-3) 

Note the inconsistency: `ExecutionStatus::Abort` uses `error!()` (line 2241), while `DelayedFieldsCodeInvariantError` (line 2254) and `SpeculativeExecutionAbortError` (line 2263) use `alert!()`.

**3. FatalVMError in Parallel Execution**

Parallel execution commit also uses `error!()` for FatalVMError: [5](#0-4) 

**4. BlockEpilogue Unexpected Errors**

BlockEpilogue errors (which affect fee distribution) use `error!()`: [6](#0-5) 

**5. WriteSet Execution Invariant**

Critical invariant violations use `error!()`: [7](#0-6) 

## Impact Explanation

This qualifies as **High Severity** per the bug bounty criteria ("Significant protocol violations") for these reasons:

1. **Delayed Vulnerability Detection**: If an attacker discovers a bytecode verifier bypass or VM bug, paranoid mode would catch the violation but operators wouldn't receive alerts. This delays incident response and allows prolonged exploitation.

2. **Consensus Monitoring Gap**: VM invariant violations can indicate consensus-breaking issues. Without alerts, validators may continue processing blocks with divergent state until manual log review occurs.

3. **Operational Security Failure**: The `CRITICAL_ERRORS` metric is explicitly designed for alerting, not dashboards: [8](#0-7) 

4. **Mandatory Safety Checks Ignored**: Paranoid mode is required on mainnet and exists to catch verifier bugs and type safety violations that could compromise the chain.

5. **Block Discarding Goes Unnoticed**: When `discard_failed_blocks` is enabled, FatalVMErrors cause entire blocks to be discarded with only `error!()` logging: [9](#0-8) 

## Likelihood Explanation

**Occurrence Likelihood**: Medium to High
- These error paths activate when VM bugs, verifier bypasses, or type safety violations occur
- Paranoid mode is mandatory on mainnet and actively checking every transaction
- Historical Move VM research shows verifier bugs are discoverable
- The TODO comment suggests the team is aware this needs fixing: [10](#0-9) 

**Detection Likelihood**: Very Low
- Without CRITICAL_ERRORS increments, automated monitoring won't trigger
- Operators must manually review logs to discover these errors
- During active exploitation, the attack could continue undetected for extended periods

## Recommendation

Replace all `error!()` calls for critical VM errors with `alert!()` to ensure consistent monitoring:

**For paranoid mode failures (aptos_vm.rs lines 2951, 2963, 2980, 2993):**
```rust
alert!(
    *log_context,
    "[aptos_vm] Transaction breaking paranoid mode: {:?}\ntxn: {:?}",
    vm_status,
    bcs::to_bytes::<SignedTransaction>(txn),
);
```

**For FatalVMError in sequential execution (executor.rs line 2241):**
```rust
alert!(
    "Sequential execution FatalVMError by transaction {}",
    idx as TxnIndex
);
```

**For FatalVMError in parallel execution (txn_last_input_output.rs line 333):**
```rust
alert!(
    "FatalVMError from parallel execution {:?} at txn {}",
    msg, txn_idx
);
```

**For BlockEpilogue errors (aptos_vm.rs line 2612):**
```rust
alert!(
    "Unexpected error from BlockEpilogue txn: {e:?}, fallback to return success."
);
```

**For WriteSet invariant violations (aptos_vm.rs line 2291):**
```rust
alert!(
    "[aptos_vm] direct write set finished without requiring should_restart_execution"
);
```

Additionally, implement the TODO to add different counter categories for error types.

## Proof of Concept

This demonstrates that paranoid failures don't increment CRITICAL_ERRORS:

```rust
// In aptos-move/aptos-vm/tests/vm_critical_errors_test.rs
use aptos_types::transaction::SignedTransaction;
use aptos_vm_logging::prelude::CRITICAL_ERRORS;

#[test]
fn test_paranoid_failure_missing_alert() {
    // Get initial counter value
    let initial_count = CRITICAL_ERRORS.get();
    
    // Execute a transaction that triggers paranoid mode failure
    // (This requires setting up a scenario with verifier disabled and paranoid mode enabled)
    // The exact setup would need access to test harness with:
    // - paranoid_type_verification: true
    // - bytecode that passes verification but fails runtime checks
    
    // After execution completes with EPARANOID_FAILURE:
    // - Logs will contain "[aptos_vm] Transaction breaking paranoid mode"
    // - But CRITICAL_ERRORS counter remains unchanged
    
    let final_count = CRITICAL_ERRORS.get();
    assert_eq!(
        initial_count, final_count,
        "CRITICAL_ERRORS was not incremented despite paranoid mode failure"
    );
    
    // This demonstrates the vulnerability: critical errors are logged but not counted
}
```

To verify in production:
1. Monitor logs for "[aptos_vm] Transaction breaking paranoid mode" or "FatalVMError"
2. Check `aptos_vm_critical_errors` metric
3. Observe that metric doesn't increment despite critical error logs

## Notes

The vulnerability is confirmed by:
- Explicit comment indicating alerts are needed ASAP for paranoid failures
- Inconsistent error handling where similar severity errors use `alert!()` 
- TODO comment acknowledging the need for proper counters
- Mandatory paranoid mode on mainnet making this operationally critical

The primary security concern is the monitoring blind spot this creates. When critical VM invariant violations occur (whether from bugs or attacks), the absence of metric increments prevents:
- Automated alerting systems from triggering
- Dashboards from showing anomalies  
- Incident response teams from being notified
- Early detection of verifier bypasses or VM exploits

This monitoring gap could allow critical security issues to persist undetected, violating the defense-in-depth principle where multiple detection mechanisms should catch critical failures.

### Citations

**File:** aptos-move/aptos-vm-logging/src/lib.rs (L163-169)
```rust
#[macro_export]
macro_rules! alert {
    ($($args:tt)+) => {
	error!($($args)+);
	CRITICAL_ERRORS.inc();
    };
}
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L2285-2293)
```rust
                if !Self::should_restart_execution(change_set.events()) {
                    // This invariant needs to hold irrespectively, so we log error always.
                    // but if we are in delayed_field_optimization_capable context, we cannot execute any transaction after this.
                    // as transaction afterwards would be executed assuming delayed fields are exchanged and
                    // resource groups are split, but WriteSetPayload::Direct has materialized writes,
                    // and so after executing this transaction versioned state is inconsistent.
                    error!(
                        "[aptos_vm] direct write set finished without requiring should_restart_execution");
                }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L2611-2617)
```rust
            Err(e) => {
                error!(
                    "Unexpected error from BlockEpilogue txn: {e:?}, fallback to return success."
                );
                let status = TransactionStatus::Keep(ExecutionStatus::Success);
                VMOutput::empty_with_status(status)
            },
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L2946-2999)
```rust
                        // Paranoid mode failure. We need to be alerted about this ASAP.
                        StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR
                        if vm_status.sub_status()
                            == Some(unknown_invariant_violation::EPARANOID_FAILURE) =>
                            {
                                error!(
                                *log_context,
                                "[aptos_vm] Transaction breaking paranoid mode: {:?}\ntxn: {:?}",
                                vm_status,
                                bcs::to_bytes::<SignedTransaction>(txn),
                            );
                            },
                        // Paranoid mode failure but with reference counting
                        StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR
                        if vm_status.sub_status()
                            == Some(unknown_invariant_violation::EREFERENCE_COUNTING_FAILURE) =>
                            {
                                error!(
                                *log_context,
                                "[aptos_vm] Transaction breaking paranoid mode: {:?}\ntxn: {:?}",
                                vm_status,
                                bcs::to_bytes::<SignedTransaction>(txn),
                            );
                            },
                        // Paranoid mode failure but with reference safety checks
                        StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR
                        if matches!(
                            vm_status.sub_status(),
                            Some(
                                unknown_invariant_violation::EREFERENCE_SAFETY_FAILURE
                                | unknown_invariant_violation::EINDEXED_REF_TAG_MISMATCH
                            )
                        ) =>
                        {
                            error!(
                            *log_context,
                            "[aptos_vm] Transaction breaking paranoid reference safety check (including enum tag guard). txn: {:?}, status: {:?}",
                            bcs::to_bytes::<SignedTransaction>(txn),
                            vm_status,
                            );
                        }
                        // Ignore DelayedFields speculative errors as it can be intentionally triggered by parallel execution.
                        StatusCode::SPECULATIVE_EXECUTION_ABORT_ERROR => (),
                        // We will log the rest of invariant violation directly with regular logger as they shouldn't happen.
                        //
                        // TODO: Add different counters for the error categories here.
                        _ => {
                            error!(
                                *log_context,
                                "[aptos_vm] Transaction breaking invariant violation: {:?}\ntxn: {:?}, ",
                                vm_status,
                                bcs::to_bytes::<SignedTransaction>(txn),
                            );
                        },
```

**File:** config/src/config/execution_config.rs (L166-183)
```rust
        // If this is a mainnet node, ensure that additional verifiers are enabled
        if let Some(chain_id) = chain_id {
            if chain_id.is_mainnet() {
                if !execution_config.paranoid_hot_potato_verification {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "paranoid_hot_potato_verification must be enabled for mainnet nodes!"
                            .into(),
                    ));
                }
                if !execution_config.paranoid_type_verification {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "paranoid_type_verification must be enabled for mainnet nodes!".into(),
                    ));
                }
            }
        }
```

**File:** aptos-move/block-executor/src/executor.rs (L2237-2267)
```rust
                ExecutionStatus::Abort(err) => {
                    if let Some(commit_hook) = &self.transaction_commit_hook {
                        commit_hook.on_execution_aborted(idx as TxnIndex);
                    }
                    error!(
                        "Sequential execution FatalVMError by transaction {}",
                        idx as TxnIndex
                    );
                    // Record the status indicating the unrecoverable VM failure.
                    return Err(SequentialBlockExecutionError::ErrorToReturn(
                        BlockExecutionError::FatalVMError(err),
                    ));
                },
                ExecutionStatus::DelayedFieldsCodeInvariantError(msg) => {
                    if let Some(commit_hook) = &self.transaction_commit_hook {
                        commit_hook.on_execution_aborted(idx as TxnIndex);
                    }
                    alert!("Sequential execution DelayedFieldsCodeInvariantError error by transaction {}: {}", idx as TxnIndex, msg);
                    return Err(SequentialBlockExecutionError::ErrorToReturn(
                        BlockExecutionError::FatalBlockExecutorError(code_invariant_error(msg)),
                    ));
                },
                ExecutionStatus::SpeculativeExecutionAbortError(msg) => {
                    if let Some(commit_hook) = &self.transaction_commit_hook {
                        commit_hook.on_execution_aborted(idx as TxnIndex);
                    }
                    alert!("Sequential execution SpeculativeExecutionAbortError error by transaction {}: {}", idx as TxnIndex, msg);
                    return Err(SequentialBlockExecutionError::ErrorToReturn(
                        BlockExecutionError::FatalBlockExecutorError(code_invariant_error(msg)),
                    ));
                },
```

**File:** aptos-move/block-executor/src/executor.rs (L2648-2662)
```rust
        if self.config.local.discard_failed_blocks {
            // We cannot execute block, discard everything (including block metadata and validator transactions)
            // (TODO: maybe we should add fallback here to first try BlockMetadataTransaction alone)
            let error_code = match sequential_error {
                BlockExecutionError::FatalBlockExecutorError(_) => {
                    StatusCode::DELAYED_FIELD_OR_BLOCKSTM_CODE_INVARIANT_ERROR
                },
                BlockExecutionError::FatalVMError(_) => {
                    StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR
                },
            };
            let ret = (0..signature_verified_block.num_txns())
                .map(|_| E::Output::discard_output(error_code))
                .collect();
            return Ok(BlockOutput::new(ret, None));
```

**File:** aptos-move/block-executor/src/txn_last_input_output.rs (L331-337)
```rust
        if let OutputStatusKind::Abort(msg) = &output_wrapper.output_status_kind {
            // Fatal VM error.
            error!(
                "FatalVMError from parallel execution {:?} at txn {}",
                msg, txn_idx
            );
            return Err(PanicOr::Or(ParallelBlockExecutionError::FatalVMError));
```

**File:** aptos-move/aptos-vm-logging/src/counters.rs (L7-11)
```rust
/// Count the number of errors. This is not intended for display on a dashboard,
/// but rather for triggering alerts.
pub static CRITICAL_ERRORS: Lazy<IntCounter> = Lazy::new(|| {
    register_int_counter!("aptos_vm_critical_errors", "Number of critical errors").unwrap()
});
```
