# Audit Report

## Title
UTF-8 Character Boundary Panic in Logger String Truncation

## Summary
The `TruncatedLogString::new()` function in the Aptos logger truncates strings at a fixed byte length without respecting UTF-8 character boundaries. When a multi-byte Unicode character (e.g., emoji, Chinese characters) spans the truncation point, `String::truncate()` panics, causing validator node crashes. [1](#0-0) 

## Finding Description
The vulnerability occurs in the string truncation logic used by the Aptos structured logging system. When log values formatted with `Display` exceed the configured maximum length (default 10KB), the logger attempts to truncate them: [2](#0-1) 

The issue is that `String::truncate()` panics if the specified byte position does not lie on a UTF-8 character boundary. Per Rust documentation, this method requires: "Panics if `new_len` does not lie on a char boundary."

Multi-byte UTF-8 characters include:
- 2-byte characters: Latin Extended, Greek, Cyrillic, etc. (U+0080 to U+07FF)
- 3-byte characters: CJK, Arabic, Hebrew, Indic scripts, most emoji (U+0800 to U+FFFF)
- 4-byte characters: Less common emoji, historic scripts (U+10000+)

The vulnerable code path is:
1. A value is logged using Display formatting (`key = %value`)
2. The Display implementation produces output exceeding `RUST_LOG_FIELD_MAX_LEN`
3. `JsonVisitor::visit_pair()` calls `d.to_string()` to format the value
4. The resulting `String` is passed to `TruncatedLogString::from()`
5. If truncation occurs at a multi-byte character boundary, the node panics [3](#0-2) 

The logger crate explicitly forbids unsafe code, meaning there's no panic recovery mechanism: [4](#0-3) 

## Impact Explanation
**Severity: High** - This qualifies as "Validator node crashes" per the Aptos bug bounty program.

When this panic occurs:
- The validator node process terminates immediately
- All in-progress operations are aborted
- The node stops participating in consensus until manually restarted
- No data corruption occurs, but availability is impacted

While this affects individual nodes rather than the entire network (hence not "Critical" - "Total loss of liveness"), a coordinated attack targeting multiple validators or repeated crashes during critical operations could significantly impact network health.

The issue breaks the fundamental expectation that logging operations should be panic-safe and never crash production systems.

## Likelihood Explanation
**Likelihood: Low to Medium**

The vulnerability requires specific conditions:
1. A logged value's Display output must exceed 10KB (or the configured `RUST_LOG_FIELD_MAX_LEN`)
2. A multi-byte UTF-8 character must span the exact truncation boundary
3. The truncation length must not coincidentally align with a character boundary

However, likelihood increases if:
- The codebase logs large user-provided strings, transaction data, or error messages with non-ASCII content
- International deployments where node operators or logged data use CJK characters or emoji
- Future code changes introduce logging of untrusted or large-volume data

The default 10KB limit and the statistical distribution of multi-byte characters make accidental triggering possible but not guaranteed.

## Recommendation
Replace the unsafe `truncate()` call with UTF-8-aware truncation that finds the nearest character boundary:

```rust
fn new(s: String) -> Self {
    let mut truncated = s;
    let max_len = *RUST_LOG_FIELD_MAX_LEN;
    
    if truncated.len() > max_len.saturating_add(Self::TRUNCATION_SUFFIX.len()) {
        // Find the last valid UTF-8 character boundary at or before max_len
        let truncate_at = truncated
            .char_indices()
            .take_while(|(idx, _)| *idx <= max_len)
            .last()
            .map(|(idx, ch)| idx + ch.len_utf8())
            .unwrap_or(max_len.min(truncated.len()));
        
        truncated.truncate(truncate_at);
        truncated.push_str(Self::TRUNCATION_SUFFIX);
    }
    TruncatedLogString(truncated)
}
```

Alternative simpler fix using `floor_char_boundary()` (stable in Rust 1.59+):

```rust
if truncated.len() > max_len.saturating_add(Self::TRUNCATION_SUFFIX.len()) {
    let truncate_at = truncated.floor_char_boundary(max_len);
    truncated.truncate(truncate_at);
    truncated.push_str(Self::TRUNCATION_SUFFIX);
}
```

## Proof of Concept

```rust
#[test]
fn test_truncation_panic_with_unicode() {
    use std::fmt;
    
    // Create a string that will cause truncation at a multi-byte character boundary
    // Using 3-byte emoji characters
    let emoji = "ðŸ”¥"; // U+1F525, 4 bytes in UTF-8
    let base_len = TruncatedLogString::DEFAULT_MAX_LEN;
    
    // Create a string that's just over the limit, with emoji at the boundary
    let mut s = "a".repeat(base_len - 2);
    s.push_str(emoji); // This emoji will span the truncation point
    
    struct DisplayWrapper(String);
    impl fmt::Display for DisplayWrapper {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            write!(f, "{}", self.0)
        }
    }
    
    let wrapper = DisplayWrapper(s);
    
    // This should panic when String::truncate() hits a non-character-boundary
    let result = std::panic::catch_unwind(|| {
        let _ = TruncatedLogString::from(wrapper.to_string());
    });
    
    assert!(result.is_err(), "Expected panic due to UTF-8 boundary violation");
}
```

To demonstrate the crash in a realistic logging scenario:

```rust
#[test] 
fn test_logging_unicode_panic() {
    use crate::{info, Value, KeyValue};
    
    // Create a large string with multi-byte characters near the truncation point
    let large_string = format!("{}ðŸŽ‰", "x".repeat(10240));
    
    // This will panic during logging if truncation hits the emoji
    info!(
        test_key = %large_string
    );
}
```

**Notes:**

The security question asked about "malformed UTF-8" causing panics. While malformed UTF-8 cannot exist in safe Rust (Strings are guaranteed valid UTF-8), I found that **valid** multi-byte UTF-8 characters cause panics when truncated incorrectly. This is a real vulnerability in the logging subsystem that can crash validator nodes.

The root cause is using byte-based truncation (`String::truncate()` with a raw byte count) instead of character-boundary-aware truncation. This is a common pitfall when handling UTF-8 strings and represents a violation of Rust's panic safety expectations for production systems.

### Citations

**File:** crates/aptos-logger/src/aptos_logger.rs (L64-72)
```rust
    fn new(s: String) -> Self {
        let mut truncated = s;

        if truncated.len() > RUST_LOG_FIELD_MAX_LEN.saturating_add(Self::TRUNCATION_SUFFIX.len()) {
            truncated.truncate(*RUST_LOG_FIELD_MAX_LEN);
            truncated.push_str(Self::TRUNCATION_SUFFIX);
        }
        TruncatedLogString(truncated)
    }
```

**File:** crates/aptos-logger/src/aptos_logger.rs (L173-175)
```rust
                    Value::Display(d) => {
                        serde_json::Value::String(TruncatedLogString::from(d.to_string()).into())
                    },
```

**File:** crates/aptos-logger/src/lib.rs (L134-134)
```rust
#![deny(unsafe_code)]
```
