# Audit Report

## Title
Proxy Protocol Header Parsing Allows Unbounded Memory Allocation Leading to Resource Exhaustion

## Summary
The proxy protocol implementation in `network/netcore/src/transport/proxy_protocol.rs` does not validate the upper bound of the `address_size` field before allocating memory and reading data from the network. An attacker can send malformed proxy protocol v2 headers with arbitrarily large `address_size` values (up to 65,535 bytes), forcing validator nodes to allocate and read excessive amounts of memory per connection, enabling resource exhaustion attacks.

## Finding Description

The `read_header` function in the proxy protocol implementation reads the `address_size` field from the proxy protocol v2 header and immediately allocates a vector of that size without any upper bound validation. [1](#0-0) 

The `address_size` is a `u16` value that can be up to 65,535 bytes. For legitimate proxy protocol usage:
- IPv4 TCP requires only 12 bytes [2](#0-1) 
- IPv6 TCP requires only 36 bytes [3](#0-2) 

While the proxy protocol specification allows TLV (Type-Length-Value) extensions, the code explicitly states it does not interpret TLVs [4](#0-3) , yet still allocates and reads all the data.

The validation checks only ensure `address_size` is NOT TOO SMALL for the address family, but never check if it's TOO LARGE: [5](#0-4) [6](#0-5) 

The proxy protocol is enabled via configuration [7](#0-6)  and processed during inbound connection upgrades [8](#0-7) .

**Attack Scenario:**
1. Attacker connects to a validator node with proxy protocol enabled
2. Sends valid PPv2 signature, version, and command bytes
3. Sets `address_size` to 65,535 (0xFFFF)
4. Either sends all 65,535 bytes (wasting bandwidth) or partial data (causing `read_exact` to block until timeout)
5. Repeats with multiple connections (up to `max_inbound_connections`, default 100) [9](#0-8) 

Each malicious connection wastes up to 65KB of memory. With 100 concurrent connections, this is ~6.5MB of unnecessary allocation. An attacker can sustain this by repeatedly opening and closing connections.

This breaks **Invariant 9: Resource Limits** - the system fails to enforce reasonable limits on memory allocation based on untrusted network input.

## Impact Explanation

This vulnerability qualifies as **Medium Severity** per the Aptos bug bounty program:

1. **Resource Exhaustion**: Each connection can allocate up to 65KB unnecessarily, with 100 concurrent connections wasting ~6.5MB
2. **Validator Degradation**: Sustained attacks with repeated connection cycling can degrade validator performance
3. **Memory Pressure**: On nodes with higher `max_inbound_connections` configuration or under sustained attack, this can create memory pressure
4. **Unnecessary Resource Consumption**: The code allocates and reads data it explicitly states it won't use (TLVs)

While the default connection limit (100) prevents catastrophic impact, this is a clear input validation failure that enables resource exhaustion attacks against a critical network component. If configurations allow more connections or attackers can bypass rate limits, impact scales proportionally.

## Likelihood Explanation

**High likelihood** - The attack is trivial to execute:
- Requires only the ability to open TCP connections to the validator
- No authentication needed (proxy protocol header is processed before Noise handshake)
- Attack can be automated and sustained
- Proxy protocol is commonly enabled in production deployments behind load balancers
- The malformed headers are technically valid per HAProxy spec (large TLV data is allowed), making detection harder

## Recommendation

Add an upper bound check on `address_size` before allocation. Since the code doesn't use TLVs, limit the size to what's actually needed:

```rust
// After line 82, add validation:
const MAX_ALLOWED_ADDRESS_SIZE: u16 = 1024; // Generous allowance for addresses + some TLVs

if address_size > MAX_ALLOWED_ADDRESS_SIZE {
    return Err(io::Error::new(
        io::ErrorKind::InvalidInput,
        format!(
            "ProxyProtocol: Address size {} exceeds maximum allowed {}",
            address_size, MAX_ALLOWED_ADDRESS_SIZE
        ),
    ));
}
```

Alternatively, enforce stricter limits based on the address family:
- For IPv4: reject if `address_size > 512`
- For IPv6: reject if `address_size > 1024`
- For LOCAL/UNSPEC: reject if `address_size > 256`

## Proof of Concept

```rust
#[cfg(test)]
mod exploit_test {
    use super::*;
    use aptos_memsocket::MemorySocket;
    use futures::{executor::block_on, io::AsyncWriteExt};

    #[test]
    fn test_unbounded_allocation_attack() {
        let (mut sender, mut receiver) = MemorySocket::new_pair();
        let original_addr = NetworkAddress::mock();

        let attack = async move {
            // Send valid PPv2 header with maximum address_size
            sender.write_all(&PPV2_SIGNATURE).await.unwrap();
            sender.write_all(&[PPV2_PROXY]).await.unwrap();
            sender.write_all(&[TCP_IPV4]).await.unwrap();
            
            // Set address_size to maximum (65535)
            let max_size: u16 = 0xFFFF;
            sender.write_all(&max_size.to_be_bytes()).await.unwrap();
            
            // Send minimal valid IPv4 data (12 bytes)
            sender.write_all(&[0u8; 12]).await.unwrap();
            
            // Optionally send garbage TLV data to fill the allocation
            // or don't send it to cause read timeout
            sender.write_all(&[0u8; 65535 - 12]).await.unwrap();
        };

        let read = async move {
            // This will allocate 65KB for a connection that only needs 12 bytes
            let result = read_header(&original_addr, &mut receiver).await;
            assert!(result.is_ok());
        };

        block_on(futures::future::join(attack, read));
        
        // With 100 connections, this wastes 6.5MB
        // With repeated connection cycling, this sustains resource exhaustion
    }
}
```

This test demonstrates that the code accepts and processes headers with maximum `address_size`, allocating 65KB per connection when only 12 bytes are needed.

### Citations

**File:** network/netcore/src/transport/proxy_protocol.rs (L12-12)
```rust
//! - Does not interpret TLVs
```

**File:** network/netcore/src/transport/proxy_protocol.rs (L47-47)
```rust
const IPV4_SIZE: u16 = 12;
```

**File:** network/netcore/src/transport/proxy_protocol.rs (L48-48)
```rust
const IPV6_SIZE: u16 = 36;
```

**File:** network/netcore/src/transport/proxy_protocol.rs (L81-85)
```rust
    let address_size: [u8; 2] = header[14..16].try_into().unwrap();
    let address_size = u16::from_be_bytes(address_size);

    let mut address_bytes: Vec<u8> = vec![0; address_size as usize];
    stream.read_exact(&mut address_bytes).await?;
```

**File:** network/netcore/src/transport/proxy_protocol.rs (L96-101)
```rust
            if address_size < IPV4_SIZE {
                return Err(io::Error::new(
                    io::ErrorKind::InvalidInput,
                    "ProxyProtocol: Header size doesn't match expected address type",
                ));
            }
```

**File:** network/netcore/src/transport/proxy_protocol.rs (L110-115)
```rust
            if address_size < IPV6_SIZE {
                return Err(io::Error::new(
                    io::ErrorKind::InvalidInput,
                    "ProxyProtocol: Header size doesn't match expected address type",
                ));
            }
```

**File:** network/builder/src/builder.rs (L188-188)
```rust
            config.enable_proxy_protocol,
```

**File:** network/framework/src/transport/mod.rs (L260-271)
```rust
    let addr = if proxy_protocol_enabled {
        proxy_protocol::read_header(&addr, &mut socket)
            .await
            .map_err(|err| {
                debug!(
                    network_address = addr,
                    error = %err,
                    "ProxyProtocol: Failed to read header: {}",
                    err
                );
                err
            })?
```

**File:** config/src/config/network_config.rs (L44-44)
```rust
pub const MAX_INBOUND_CONNECTIONS: usize = 100;
```
