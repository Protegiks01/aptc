# Audit Report

## Title
Spec Function Transitive Impurity Detection Bypass via SpecFunction Call Chain

## Summary
The `FunctionPurenessChecker` in the Move compiler v2 fails to recursively validate spec function calls when checking for pureness, allowing spec helper functions to transitively call impure Move functions through intermediate spec functions without detection.

## Finding Description
The Move specification language enforces that spec functions must be pure (side-effect free). The `FunctionPurenessChecker` validates this by performing DFS traversal through function call chains to detect impure operations. However, there is a critical gap in the checker's implementation. [1](#0-0) 

The checker explicitly handles `Call(id, MoveFunction(mid, sid), ..)` operations by recursively validating the called function's body. However, it does not handle `Call(id, SpecFunction(...), ..)` operations, which fall through to the default case: [2](#0-1) 

The `Operation` enum defines `SpecFunction` as a distinct operation type for calls to specification functions: [3](#0-2) 

**Attack Scenario:**
1. Define `spec fun helper()` that directly calls an impure Move function with mutable borrows
2. Define `spec fun outer()` that calls `helper()`  
3. Use `outer()` in a specification (ensures/requires clause)
4. The pureness checker validates `outer()`, encounters the call to `helper()` as a `SpecFunction` operation, but does NOT recursively check `helper()`'s body
5. The transitive impurity chain `outer() -> helper() -> impure_move_function()` goes undetected

Existing tests verify that direct calls (spec fun -> impure move fun) and Move-to-Move transitive calls (spec fun -> move fun -> impure move fun) are caught: [4](#0-3) 

However, there is no test coverage for spec-to-spec-to-impure call chains.

## Impact Explanation
This vulnerability breaks the **formal verification soundness** of Move smart contracts. Spec functions with transitive impurity could be used in specifications, leading to:

- **Incorrect verification results**: Contracts may appear to satisfy safety properties when they don't
- **False sense of security**: Developers rely on verification to prove critical invariants (governance voting, staking rewards, etc.)
- **Potential for undetected bugs**: Impure operations in specs could mask bugs in critical system contracts

While this is primarily a verification/compiler issue rather than a direct runtime vulnerability, it undermines the entire formal verification framework that Aptos uses to ensure correctness of critical system contracts (governance, staking, etc.). This maps to **High Severity** as it represents a significant protocol violation in the verification system.

## Likelihood Explanation
**Likelihood: Medium to High**

The vulnerability is easy to triggerâ€”any developer can write spec functions calling other spec functions. The gap exists because:
1. The pureness checker was likely designed assuming spec functions are always independently validated
2. The missing case for `SpecFunction` operations is a clear oversight
3. Test coverage doesn't include spec-to-spec-to-impure transitive chains

Given that Move specifications are used extensively in the Aptos Framework for critical contracts, this gap could affect production code verification.

## Recommendation
Add handling for `Call(id, SpecFunction(mid, fid, _), ..)` in the `FunctionPurenessChecker` to recursively validate spec function bodies:

```rust
// In pureness_checker.rs, add after line 141:
Call(id, SpecFunction(mid, fid, _), ..) => {
    // Get spec function and check its body
    let module = env.get_module(*mid);
    let spec_fun = module.get_spec_fun(*fid);
    if let Some(body) = &spec_fun.body {
        let qid = mid.qualified(*fid);
        // Similar logic to MoveFunction handling
        if !self.pureness.contains_key(&qid) {
            self.visiting.push((qid, *id));
            let old_impure = mem::take(&mut self.is_impure);
            self.check_exp(env, body);
            self.pureness.insert(qid, !self.is_impure);
            self.visiting.pop();
            self.is_impure |= old_impure;
        }
        if !self.pureness.get(&qid).unwrap_or(&true) {
            (self.impure_action)(
                *id,
                "calls a spec function which transitively modifies state",
                &self.visiting,
            );
            self.is_impure = true
        }
    }
},
```

**Note:** The actual fix requires adapting the `visiting` stack to handle `QualifiedId<SpecFunId>` in addition to `QualifiedId<FunId>`, which may require refactoring the type.

## Proof of Concept
```move
module 0x42::transitive_impurity_poc {
    // Impure Move function with mutable borrow
    fun impure_function(x: u64): u64 {
        let r = &mut x;
        *r = *r + 1;
        x
    }
    
    // Spec helper that calls the impure function
    // This SHOULD be caught but may not be when called transitively
    spec fun helper_spec(): u64 {
        impure_function(1)
    }
    
    // Outer spec function that calls the helper
    // The transitive impurity may go undetected
    spec fun outer_spec(): u64 {
        helper_spec()
    }
    
    // Function using the outer spec
    fun test_function(): u64 {
        42
    }
    
    spec test_function {
        // Using outer_spec which transitively calls impure code
        ensures result == outer_spec();
    }
}
```

Compile this with Move compiler v2 with spec checking enabled. If the vulnerability exists, no error will be reported for the transitive impurity chain `outer_spec() -> helper_spec() -> impure_function()`.

### Citations

**File:** third_party/move/move-model/src/pureness_checker.rs (L122-142)
```rust
                Call(id, MoveFunction(mid, sid), ..) => {
                    let qid = mid.qualified(*sid);
                    // false positive: can't use entry because of borrow conflict
                    #[allow(clippy::map_entry)]
                    if !self.pureness.contains_key(&qid) {
                        self.visiting.push((qid, *id));
                        let old_impure = mem::take(&mut self.is_impure);
                        self.check_function(env, qid);
                        self.pureness.insert(qid, !self.is_impure);
                        self.visiting.pop();
                        self.is_impure |= old_impure;
                    }
                    if !self.pureness.get(&qid).unwrap() {
                        (self.impure_action)(
                            *id,
                            "calls a function which modifies state",
                            &self.visiting,
                        );
                        self.is_impure = true
                    }
                },
```

**File:** third_party/move/move-model/src/pureness_checker.rs (L143-143)
```rust
                _ => {},
```

**File:** third_party/move/move-model/src/ast.rs (L2039-2039)
```rust
    SpecFunction(ModuleId, SpecFunId, Option<Vec<MemoryLabel>>),
```

**File:** third_party/move/move-compiler-v2/tests/checking/specs/spec_pureness_checks.move (L29-31)
```text
    spec fun cannot_call_impure(x: u64): u64 { impure_borrow(1) }

    spec fun cannot_call_impure_indirect(x: u64): u64 { impure_indirect(1) }
```
