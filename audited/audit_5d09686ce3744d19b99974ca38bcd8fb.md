# Audit Report

## Title
Config Sanitizer Bypass Allows Mainnet Validators to Run with Test-Level Security

## Summary
The `skip_config_sanitizer` flag in `NodeStartupConfig` can be set in production configuration files to completely bypass all security validations, allowing mainnet validators to run without critical safety features like paranoid verification, mutual authentication, and secure storage backends.

## Finding Description

Test-generated NodeConfigs and production configs follow fundamentally different validation paths:

**Test Path:** [1](#0-0) 

Test configs use templates and generate random configurations without sanitization or optimization. Test code explicitly disables security features for performance: [2](#0-1) 

**Production Path:** [3](#0-2) 

Production configs normally go through `optimize_and_sanitize_node_config()` which enforces critical security requirements.

**The Vulnerability:**

The sanitizer can be completely bypassed by setting a single YAML field: [4](#0-3) 

This flag is user-controllable via the config file: [5](#0-4) 

**Bypassed Security Validations:**

When `skip_config_sanitizer: true`, mainnet validators can run without:

1. **Paranoid VM verification** (required for mainnet): [6](#0-5) 

2. **Mutual authentication on validator networks** (required for consensus security): [7](#0-6) 

3. **Secure backend for safety rules** (prevents in-memory storage on mainnet): [8](#0-7) 

4. **AdminService authentication** (prevents unauthorized access): [9](#0-8) 

**Attack Scenario:**

1. Attacker creates a config based on test templates
2. Adds `node_startup: { skip_config_sanitizer: true }` to YAML
3. Disables paranoid verification: `execution: { paranoid_hot_potato_verification: false, paranoid_type_verification: false }`
4. Disables mutual authentication: `validator_network: { mutual_authentication: false }`
5. Config passes tests (which don't run sanitization)
6. When deployed to mainnet, node starts successfully with test-level security

## Impact Explanation

**Critical Severity** - This vulnerability breaks multiple critical invariants:

1. **Deterministic Execution**: Without paranoid verification, validators may produce different state roots for identical blocks due to undetected type safety violations
2. **Consensus Safety**: Without mutual authentication on validator networks, the network is vulnerable to man-in-the-middle attacks and unauthorized participation
3. **Move VM Safety**: Disabling paranoid checks allows bytecode execution that could violate type safety and memory constraints

This could lead to:
- Consensus splits requiring hard fork
- Loss of funds through VM exploits
- Network partition or complete loss of liveness
- Validator set manipulation

Meets the "Consensus/Safety violations" and "Non-recoverable network partition" criteria for Critical severity ($1,000,000).

## Likelihood Explanation

**Medium-to-High Likelihood**:

- The bypass mechanism is trivial (one YAML line)
- No code-level protection prevents this in production
- Test configs explicitly demonstrate the bypass capability
- Operators could accidentally or intentionally deploy insecure configs
- Social engineering could target validator operators to deploy malicious configs
- The gap between test and production validation is undocumented

While this requires ability to deploy validator configs (typically validator operators), the ease of exploitation and lack of safeguards make this a realistic attack vector, especially in:
- Compromised validator operations
- Social engineering scenarios
- Accidental misconfigurations copying from test examples

## Recommendation

Implement multiple layers of protection:

1. **Remove the bypass flag entirely** or make it only available via compile-time feature flag (not runtime config)

2. **Add sanity checks for the skip flags themselves** in the sanitizer:
```rust
impl ConfigSanitizer for NodeConfig {
    fn sanitize(
        node_config: &NodeConfig,
        node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        // NEVER allow skipping sanitizer on mainnet
        if let Some(chain_id) = chain_id {
            if chain_id.is_mainnet() && node_config.node_startup.skip_config_sanitizer {
                return Err(Error::ConfigSanitizerFailed(
                    "NodeStartupConfig".to_string(),
                    "skip_config_sanitizer cannot be enabled on mainnet!".into(),
                ));
            }
        }
        
        // Rest of sanitization logic...
    }
}
```

3. **Make test configs go through the same validation** to ensure consistency:
```rust
pub fn generate_random_config_with_template(template: &Self, rng: &mut StdRng) -> Self {
    let mut node_config = template.clone();
    // ... existing randomization ...
    
    // Sanitize even test configs with a test chain_id
    NodeConfig::sanitize(&node_config, NodeType::Validator, Some(ChainId::test()))
        .expect("Test config must pass sanitization");
    
    node_config
}
```

4. **Add CI checks** that verify production config schemas match test schemas exactly

## Proof of Concept

Create a file `malicious_validator.yaml`:

```yaml
base:
    data_dir: "/opt/aptos/data"
    role: "validator"
    
node_startup:
    skip_config_sanitizer: true  # Bypass all security checks
    
execution:
    paranoid_hot_potato_verification: false  # Disable VM safety
    paranoid_type_verification: false
    genesis_file_location: "./genesis.blob"
    
validator_network:
    discovery_method: "onchain"
    listen_address: "/ip4/0.0.0.0/tcp/6180"
    network_id: "validator"
    mutual_authentication: false  # Disable consensus security
    identity:
        type: "from_config"
        key: "b0f405a3e75516763c43a2ae1d70423699f34cd68fa9f8c6bb2d67aa87d0af69"
        peer_id: "00000000000000000000000000000000d58bc7bb154b38039bc9096ce04e1237"
```

Deploy this to a mainnet validator node:
```bash
aptos-node -f malicious_validator.yaml
```

The node will start successfully and participate in mainnet consensus WITHOUT:
- Paranoid type verification
- Mutual authentication
- Any other security checks

This demonstrates that malicious configs can bypass all validation and run on mainnet, creating severe security risks.

## Notes

The test `test_disable_config_sanitizer` explicitly documents this bypass capability, confirming it's intentional behavior: [10](#0-9) 

However, there is no protection preventing this dangerous flag from being used in production mainnet deployments, creating a critical security gap between test and production validation paths.

### Citations

**File:** network/framework/src/testutils/builder.rs (L51-54)
```rust
        let config = NodeConfig::generate_random_config_with_template(
            &NodeConfig::get_default_validator_config(),
            &mut self.rng,
        );
```

**File:** aptos-node/src/lib.rs (L501-502)
```rust
    node_config.execution.paranoid_hot_potato_verification = false;
    node_config.execution.paranoid_type_verification = false;
```

**File:** config/src/config/node_config_loader.rs (L72-89)
```rust
    pub fn load_and_sanitize_config(&self) -> Result<NodeConfig, Error> {
        // Load the node config from disk
        let mut node_config = NodeConfig::load_config(&self.node_config_path)?;

        // Load the execution config
        let input_dir = RootPath::new(&self.node_config_path);
        node_config.execution.load_from_path(&input_dir)?;

        // Update the data directory. This needs to be done before
        // we optimize and sanitize the node configs (because some optimizers
        // rely on the data directory for file reading/writing).
        node_config.set_data_dir(node_config.get_data_dir().to_path_buf());

        // Optimize and sanitize the node config
        let local_config_yaml = get_local_config_yaml(&self.node_config_path)?;
        optimize_and_sanitize_node_config(&mut node_config, local_config_yaml)?;

        Ok(node_config)
```

**File:** config/src/config/config_sanitizer.rs (L44-48)
```rust
    ) -> Result<(), Error> {
        // If config sanitization is disabled, don't do anything!
        if node_config.node_startup.skip_config_sanitizer {
            return Ok(());
        }
```

**File:** config/src/config/config_sanitizer.rs (L191-197)
```rust
        // Ensure that mutual authentication is enabled
        if !validator_network_config.mutual_authentication {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "Mutual authentication must be enabled for the validator network!".into(),
            ));
        }
```

**File:** config/src/config/config_sanitizer.rs (L212-239)
```rust
    fn test_disable_config_sanitizer() {
        // Create a default node config (with sanitization enabled)
        let mut node_config = NodeConfig::default();

        // Set a bad node config for mainnet
        node_config.execution.paranoid_hot_potato_verification = false;

        // Sanitize the config and verify the sanitizer fails
        let error =
            NodeConfig::sanitize(&node_config, NodeType::Validator, Some(ChainId::mainnet()))
                .unwrap_err();
        assert!(matches!(error, Error::ConfigSanitizerFailed(_, _)));

        // Create a node config with the sanitizer disabled
        let mut node_config = NodeConfig {
            node_startup: NodeStartupConfig {
                skip_config_sanitizer: true,
                ..Default::default()
            },
            ..Default::default()
        };

        // Set a bad node config for mainnet
        node_config.execution.paranoid_hot_potato_verification = false;

        // Sanitize the config and verify the sanitizer passes
        NodeConfig::sanitize(&node_config, NodeType::Validator, Some(ChainId::mainnet())).unwrap();
    }
```

**File:** config/src/config/node_startup_config.rs (L6-11)
```rust
#[derive(Clone, Copy, Debug, Deserialize, PartialEq, Eq, Serialize)]
#[serde(default, deny_unknown_fields)]
pub struct NodeStartupConfig {
    pub skip_config_optimizer: bool, // Whether or not to skip the config optimizer at startup
    pub skip_config_sanitizer: bool, // Whether or not to skip the config sanitizer at startup
}
```

**File:** config/src/config/execution_config.rs (L166-183)
```rust
        // If this is a mainnet node, ensure that additional verifiers are enabled
        if let Some(chain_id) = chain_id {
            if chain_id.is_mainnet() {
                if !execution_config.paranoid_hot_potato_verification {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "paranoid_hot_potato_verification must be enabled for mainnet nodes!"
                            .into(),
                    ));
                }
                if !execution_config.paranoid_type_verification {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "paranoid_type_verification must be enabled for mainnet nodes!".into(),
                    ));
                }
            }
        }
```

**File:** config/src/config/safety_rules_config.rs (L86-96)
```rust
            // Verify that the secure backend is appropriate for mainnet validators
            if chain_id.is_mainnet()
                && node_type.is_validator()
                && safety_rules_config.backend.is_in_memory()
            {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "The secure backend should not be set to in memory storage in mainnet!"
                        .to_string(),
                ));
            }
```

**File:** config/src/config/admin_service_config.rs (L68-76)
```rust
            if let Some(chain_id) = chain_id {
                if chain_id.is_mainnet()
                    && node_config.admin_service.authentication_configs.is_empty()
                {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "Must enable authentication for AdminService on mainnet.".into(),
                    ));
                }
```
