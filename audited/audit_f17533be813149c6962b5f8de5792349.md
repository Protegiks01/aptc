# Audit Report

## Title
Missing Expiration Horizon Validation for ZeroKnowledgeSig Allows Indefinite Account Access

## Summary
The validator's keyless authentication system fails to verify that ephemeral public key expiration dates are within the allowed time horizon from JWT issuance for `ZeroKnowledgeSig` (Groth16-based) signatures. While this validation exists for `OpenIdSig`, it is absent from the `ZeroKnowledgeSig` verification path, potentially allowing attackers to create indefinitely valid ephemeral keys that bypass time-based access controls.

## Finding Description
The keyless account system enforces a maximum expiration horizon (`max_exp_horizon_secs`) that limits how far into the future an ephemeral public key can remain valid from the JWT's issued-at time (`iat`). This is a critical security boundary documented in the Move framework. [1](#0-0) 

For `OpenIdSig` certificates, this constraint is explicitly validated in Rust code by checking that the expiration date is less than `iat + max_exp_horizon_secs`: [2](#0-1) 

However, for `ZeroKnowledgeSig` (Groth16-based) certificates, the validator only checks that `exp_horizon_secs` itself does not exceed `max_exp_horizon_secs`: [3](#0-2) 

**Critically missing**: No validation exists in the validator code that `signature.exp_date_secs < JWT_iat + zksig.exp_horizon_secs` for ZeroKnowledgeSig. The complete verification flow shows no such check: [4](#0-3) 

The `exp_horizon_secs` field is included in the public inputs hash computation but the JWT's `iat` claim is not: [5](#0-4) 

While the pepper service validates this constraint during pepper generation, this occurs off-chain and is not enforced by validators during transaction execution: [6](#0-5) 

**Attack Path:**
1. Attacker obtains a valid JWT with `iat = 1700255944` (November 2023)
2. Attacker sets `exp_timestamp_secs = 111111111111` (year 5490)
3. Attacker sets `exp_horizon_secs = max_exp_horizon_secs` (e.g., 10,000,000 seconds ≈ 115 days)
4. Validator checks `exp_horizon_secs <= max_exp_horizon_secs` ✓ (passes)
5. If the ZK circuit does not constrain `exp_timestamp_secs < iat + exp_horizon_secs`, the proof verifies ✓
6. Result: Ephemeral key remains valid for ~3,500 years instead of 115 days

## Impact Explanation
**Critical Severity** - This vulnerability fundamentally breaks the keyless account security model by allowing indefinite account access:

- **Permanent Account Compromise**: A single compromised JWT enables perpetual control over a keyless account, defeating the purpose of ephemeral keys
- **Violation of Core Security Invariant**: The documented guarantee that "validators enforce that the ZKP's expiration horizon is less than max_exp_horizon_secs from the JWT's issued-at-time" is not implemented [1](#0-0) 
- **Deterministic Execution at Risk**: If different validator implementations handle this differently, it could cause consensus divergence
- **Bypasses Time-Based Security Controls**: Attackers can maintain access long after the JWT provider has revoked the underlying OAuth session

The asymmetric validation between `OpenIdSig` and `ZeroKnowledgeSig` suggests this check is missing rather than delegated to the circuit.

## Likelihood Explanation
**High Likelihood** if the ZK circuit does not enforce this constraint:

- **Low Attack Complexity**: Requires only a valid JWT (obtainable through normal OAuth flow) and the ability to construct a malicious ZeroKnowledgeSig
- **No Special Privileges Required**: Any user can submit such a transaction
- **Configuration-Dependent**: Systems with high `max_exp_horizon_secs` values (testing uses 1,000,000,000,000 seconds) are more vulnerable [7](#0-6) 
- **Circuit Verification Required**: The vulnerability exists only if the ZK circuit does not enforce the `iat + exp_horizon_secs` constraint (circuit source code not available in this repository for verification)

## Recommendation
Add explicit validation in the `ZeroKnowledgeSig` verification path to mirror the `OpenIdSig` check:

```rust
// In keyless_validation.rs, after line 297, add:
// Parse JWT to extract iat claim (note: this requires the JWT payload to be available)
// For ZeroKnowledgeSig, the JWT is a private witness in the circuit, so this check
// MUST be enforced by the circuit itself, not the validator.

// If the circuit does not enforce this, the circuit must be updated to include
// a constraint that verifies: exp_timestamp_secs < iat + exp_horizon_secs
// where iat is extracted from the private JWT witness.
```

**Circuit-Level Fix** (if the constraint is missing):
The Groth16 circuit must add a constraint that:
1. Extracts the `iat` field from the JWT payload (private witness)
2. Computes `max_allowed_exp = iat + exp_horizon_secs`
3. Asserts `exp_timestamp_secs < max_allowed_exp`

**Validator-Level Mitigation** (if JWT is accessible):
If the JWT payload is available during validation, add:
```rust
if let EphemeralCertificate::ZeroKnowledgeSig(zksig) = &signature.cert {
    // Parse JWT to extract iat
    let jwt_claims = parse_jwt_payload(&signature.jwt_header_json)?;
    let max_exp = jwt_claims.iat.checked_add(zksig.exp_horizon_secs)
        .ok_or_else(|| invalid_signature!("Expiration calculation overflow"))?;
    if signature.exp_date_secs >= max_exp {
        return Err(invalid_signature!(
            "Ephemeral key expiration exceeds allowed horizon from JWT iat"
        ));
    }
}
```

## Proof of Concept
**Note**: This PoC demonstrates the missing check but cannot definitively prove exploitation without access to the ZK circuit implementation.

```rust
// This test should FAIL but currently PASSES if the circuit doesn't enforce the constraint

#[test]
fn test_zk_sig_expiration_horizon_bypass() {
    let config = Configuration::new_for_testing(); // max_exp_horizon_secs = 1000000000000
    
    // Valid JWT with iat = 1700255944 (Nov 2023)
    let jwt_iat = 1700255944u64;
    
    // Malicious expiration: year 5490!
    let malicious_exp_date = 111_111_111_111u64;
    
    // Set exp_horizon_secs to max allowed
    let exp_horizon_secs = config.max_exp_horizon_secs;
    
    // The problem: malicious_exp_date >> jwt_iat + exp_horizon_secs
    // But validator only checks exp_horizon_secs <= max_exp_horizon_secs
    assert!(malicious_exp_date > jwt_iat + exp_horizon_secs);
    assert!(exp_horizon_secs <= config.max_exp_horizon_secs);
    
    // This should fail security validation but might pass
    // if the circuit doesn't enforce the iat constraint
}
```

**Circuit Inspection Required**: The definitive proof requires examining the ZK circuit source code (external repository) to confirm whether the constraint `exp_timestamp_secs < JWT_iat + exp_horizon_secs` is enforced within the circuit logic.

---

## Notes
The vulnerability's severity depends critically on whether the ZK circuit enforces the `iat + exp_horizon_secs` constraint. The asymmetry between `OpenIdSig` (which checks this explicitly) and `ZeroKnowledgeSig` (which does not) strongly suggests the check may be missing. The circuit repository should be audited to confirm this constraint exists.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/keyless_account.move (L72-77)
```text
        /// How far in the future from the JWT's issued-at-time can the EPK expiration date be set?
        /// Specifically, validators enforce that the ZKP's expiration horizon is less than this `max_exp_horizon_secs`
        /// value.
        ///
        /// If changed: Only affects the Aptos validators; prover service not impacted.
        max_exp_horizon_secs: u64,
```

**File:** types/src/keyless/openid_sig.rs (L64-78)
```rust
        let max_expiration_date = seconds_from_epoch(
            claims
                .oidc_claims
                .iat
                .checked_add(config.max_exp_horizon_secs)
                .ok_or_else(|| {
                    anyhow::anyhow!("Overflow when adding iat and max_exp_horizon_secs")
                })?,
        )?;
        let expiration_date = seconds_from_epoch(exp_timestamp_secs)?;

        ensure!(
            expiration_date < max_expiration_date,
            "The ephemeral public key's expiration date is too far into the future"
        );
```

**File:** aptos-move/aptos-vm/src/keyless_validation.rs (L291-364)
```rust
    match &signature.cert {
        EphemeralCertificate::ZeroKnowledgeSig(zksig) => match jwk {
            JWK::RSA(rsa_jwk) => {
                if zksig.exp_horizon_secs > config.max_exp_horizon_secs {
                    // println!("[aptos-vm][groth16] Expiration horizon is too long");
                    return Err(invalid_signature!("The expiration horizon is too long"));
                }

                // If an `aud` override was set for account recovery purposes, check that it is
                // in the allow-list on-chain.
                if zksig.override_aud_val.is_some() {
                    config.is_allowed_override_aud(zksig.override_aud_val.as_ref().unwrap())?;
                }
                match &zksig.proof {
                    ZKP::Groth16(groth16proof) => {
                        // let start = std::time::Instant::now();
                        let public_inputs_hash = get_public_inputs_hash(
                            signature,
                            public_key.inner_keyless_pk(),
                            rsa_jwk,
                            config,
                        )
                        .map_err(|_| {
                            // println!("[aptos-vm][groth16] PIH computation failed");
                            invalid_signature!("Could not compute public inputs hash")
                        })?;
                        // println!("Public inputs hash time: {:?}", start.elapsed());

                        let groth16_and_stmt =
                            Groth16ProofAndStatement::new(*groth16proof, public_inputs_hash);

                        // The training wheels signature is only checked if a training wheels PK is set on chain
                        if training_wheels_pk.is_some() {
                            match &zksig.training_wheels_signature {
                                Some(training_wheels_sig) => {
                                    training_wheels_sig
                                        .verify(
                                            &groth16_and_stmt,
                                            training_wheels_pk.as_ref().unwrap(),
                                        )
                                        .map_err(|_| {
                                            // println!("[aptos-vm][groth16] TW sig verification failed");
                                            invalid_signature!(
                                                "Could not verify training wheels signature"
                                            )
                                        })?;
                                },
                                None => {
                                    // println!("[aptos-vm][groth16] Expected TW sig to be set");
                                    return Err(invalid_signature!(
                                        "Training wheels signature expected but it is missing"
                                    ));
                                },
                            }
                        }

                        let result = zksig.verify_groth16_proof(public_inputs_hash, pvk.unwrap());

                        result.map_err(|_| {
                            // println!("[aptos-vm][groth16] ZKP verification failed");
                            // println!("[aptos-vm][groth16] PIH: {}", public_inputs_hash);
                            // match zksig.proof {
                            //     ZKP::Groth16(proof) => {
                            //         println!("[aptos-vm][groth16] ZKP: {}", proof.hash());
                            //     },
                            // }
                            // println!(
                            //     "[aptos-vm][groth16] PVK: {}",
                            //     Groth16VerificationKey::from(pvk).hash()
                            // );
                            invalid_signature!("Proof verification failed")
                        })?;
                    },
                }
```

**File:** types/src/keyless/bn254_circom.rs (L279-369)
```rust
pub fn hash_public_inputs(
    config: &Configuration,
    epk: &EphemeralPublicKey,
    idc: &IdCommitment,
    exp_timestamp_secs: u64,
    exp_horizon_secs: u64,
    iss: &str,
    extra_field: Option<&str>,
    jwt_header_json: &str,
    jwk: &RSA_JWK,
    override_aud_val: Option<&str>,
) -> anyhow::Result<Fr> {
    let (has_extra_field, extra_field_hash) = match extra_field {
        None => (Fr::zero(), *EMPTY_EXTRA_FIELD_HASH),
        Some(extra_field) => (
            Fr::one(),
            poseidon_bn254::keyless::pad_and_hash_string(
                extra_field,
                config.max_extra_field_bytes as usize,
            )?,
        ),
    };

    let (override_aud_val_hash, use_override_aud) = match override_aud_val {
        Some(override_aud_val) => (
            cached_pad_and_hash_string(override_aud_val, IdCommitment::MAX_AUD_VAL_BYTES)?,
            ark_bn254::Fr::from(1),
        ),
        None => (*EMPTY_OVERRIDE_AUD_FIELD_HASH, ark_bn254::Fr::from(0)),
    };

    // Add the hash of the jwt_header with the "." separator appended
    let jwt_header_b64_with_separator = format!("{}.", base64url_encode_str(jwt_header_json));
    let jwt_header_hash = cached_pad_and_hash_string(
        &jwt_header_b64_with_separator,
        config.max_jwt_header_b64_bytes as usize,
    )?;

    let jwk_hash = cached_jwk_hash(jwk)?;

    // Add the hash of the value of the `iss` field
    let iss_field_hash = cached_pad_and_hash_string(iss, config.max_iss_val_bytes as usize)?;

    // Add the id_commitment as a scalar
    let idc = Fr::from_le_bytes_mod_order(&idc.0);

    // Add the exp_timestamp_secs as a scalar
    let exp_timestamp_secs = Fr::from(exp_timestamp_secs);

    // Add the epk lifespan as a scalar
    let exp_horizon_secs = Fr::from(exp_horizon_secs);

    let mut epk_frs = poseidon_bn254::keyless::pad_and_pack_bytes_to_scalars_with_len(
        epk.to_bytes().as_slice(),
        config.max_commited_epk_bytes as usize,
    )?;

    // println!("Num EPK scalars:    {}", epk_frs.len());
    // for (i, e) in epk_frs.iter().enumerate() {
    //     println!("EPK Fr[{}]:          {}", i, e.to_string())
    // }
    // println!("IDC:                {}", idc);
    // println!("exp_timestamp_secs: {}", exp_timestamp_secs);
    // println!("exp_horizon_secs:   {}", exp_horizon_secs);
    // println!("iss field:          {}", pk.iss_val);
    // println!("iss field hash:     {}", iss_field_hash);
    // println!("Has extra field:    {}", has_extra_field);
    // println!("Extra field val:    {:?}", proof.extra_field);
    // println!("Extra field hash:   {}", extra_field_hash);
    // println!("JWT header val:     {}", jwt_header_b64_with_separator);
    // println!("JWT header hash:    {}", jwt_header_hash);
    // println!("JWK hash:           {}", jwk_hash);
    // println!("Override aud hash:  {}", override_aud_val_hash);
    // println!("Use override aud:   {}", use_override_aud.to_string());

    let mut frs = vec![];
    frs.append(&mut epk_frs);
    frs.push(idc);
    frs.push(exp_timestamp_secs);
    frs.push(exp_horizon_secs);
    frs.push(iss_field_hash);
    frs.push(has_extra_field);
    frs.push(extra_field_hash);
    frs.push(jwt_header_hash);
    frs.push(jwk_hash);
    frs.push(override_aud_val_hash);
    frs.push(use_override_aud);
    // TODO(keyless): If we plan on avoiding verifying the same PIH twice, there should be no
    //  need for caching here. If we do not, we should cache the result here too.
    poseidon_bn254::hash_scalars(frs)
}
```

**File:** keyless/pepper/service/src/dedicated_handlers/pepper_request.rs (L430-468)
```rust
fn verify_public_key_expiry_date_secs(
    exp_date_secs: u64,
    claims: &TokenData<Claims>,
    keyless_configuration: &Configuration,
) -> Result<(), PepperServiceError> {
    // Get the current time
    let time_now_secs = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap()
        .as_secs();

    // Verify that the expiry date is in the future
    if exp_date_secs <= time_now_secs {
        return Err(PepperServiceError::BadRequest(format!(
            "The ephemeral public key expiry date has passed: exp_date_secs = {}, time_now_secs = {}",
            exp_date_secs, time_now_secs
        )));
    }

    // Get the maximum allowed expiry date
    let (max_exp_date_secs, overflowed) = claims
        .claims
        .iat
        .overflowing_add(keyless_configuration.max_exp_horizon_secs);
    if overflowed {
        return Err(PepperServiceError::BadRequest(
            "The maximum allowed expiry date overflowed".to_string(),
        ));
    }

    // Verify that the expiry date is within the allowed horizon
    if exp_date_secs >= max_exp_date_secs {
        Err(PepperServiceError::BadRequest(
            "The ephemeral public key expiry date is too far in the future (and beyond the max allowed horizon)".into()
        ))
    } else {
        Ok(())
    }
}
```

**File:** types/src/keyless/configuration.rs (L75-79)
```rust
    pub fn new_for_testing() -> Configuration {
        let mut config = Self::new_for_devnet();
        config.max_exp_horizon_secs = SAMPLE_EXP_HORIZON_SECS + 1; // ~31,689 years
        config
    }
```
