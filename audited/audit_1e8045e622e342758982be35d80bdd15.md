# Audit Report

## Title
State Snapshot Restoration Bypasses LedgerInfo Signature Verification When Epoch History Is Absent

## Summary
The state snapshot restoration process in `StateSnapshotRestoreController::run_impl()` optionally validates the cryptographic signatures of the `LedgerInfoWithSignatures` only when `epoch_history` is provided. When `epoch_history` is `None` (which occurs when using db-tool or the `--skip-epoch-endings` flag), an attacker controlling backup storage can restore arbitrary blockchain state by providing a self-consistent but completely fabricated manifest, proof, and state chunks, bypassing all signature verification.

## Finding Description

The vulnerability exists in the state snapshot restoration logic where the validation of the `LedgerInfoWithSignatures` is conditional: [1](#0-0) 

When `epoch_history` is `None`, this validation is completely skipped. This occurs in two scenarios:

**Scenario 1: db-tool usage** - The epoch_history parameter is hardcoded to `None`: [2](#0-1) 

**Scenario 2: restore-coordinator with --skip-epoch-endings flag** - The flag causes epoch_history to be set to `None`: [3](#0-2) 

The restoration process performs the following validations:

1. Loads the manifest and proof file from backup storage: [4](#0-3) 

2. Verifies the `TransactionInfoWithProof` against the `LedgerInfo`: [5](#0-4) 

The `verify()` method only checks that the `TransactionInfo` exists in the transaction accumulator whose root is in the `LedgerInfo`: [6](#0-5) 

**Critically**, this verification does NOT validate the `LedgerInfo` itself - it doesn't check BLS signatures, validator quorum, or any cryptographic proof that the `LedgerInfo` is legitimate.

3. The `expected_root_hash` used for subsequent chunk validation comes directly from the manifest: [7](#0-6) 

4. Each state chunk's `SparseMerkleRangeProof` is then verified against this `expected_root_hash`: [8](#0-7) 

**Attack Path:**

An attacker controlling the backup storage can:

1. Create a malicious manifest with an arbitrary `root_hash` value
2. Generate a fake `LedgerInfoWithSignatures` with no valid signatures (or invalid signatures)
3. Create a `TransactionInfoWithProof` where:
   - The `TransactionInfo` contains the same `root_hash` as the manifest
   - The `TransactionAccumulatorProof` correctly links this `TransactionInfo` to the fake `LedgerInfo`'s transaction accumulator hash
4. Generate state chunk files with `SparseMerkleRangeProofs` that are mathematically valid for the chosen fake `root_hash`

Since all these components are self-consistent with each other but completely fabricated, the validation passes:
- The `TransactionInfo` is proven to exist in the fake `LedgerInfo`'s accumulator ✓
- The `root_hash` in the manifest matches the one in the `TransactionInfo` ✓
- The `LedgerInfo` signature validation is skipped (epoch_history is None) ✗
- Each chunk's proof validates against the fake root hash ✓

The attacker successfully restores completely arbitrary state into the validator node's database.

## Impact Explanation

This is a **Critical** severity vulnerability per the Aptos bug bounty criteria because it enables:

1. **Complete Node State Compromise**: An attacker can restore arbitrary state into a validator node's database, including:
   - Modified account balances and resources
   - Manipulated validator set and staking state
   - Corrupted governance state and voting records
   - Fabricated transaction history and smart contract state

2. **Consensus Safety Violations**: When the node restarts with corrupted state, it will:
   - Sign blocks based on false state information
   - Participate in consensus with fabricated data
   - Potentially cause network forks if multiple nodes are compromised

3. **Loss of Funds**: The attacker can create state that shows:
   - Inflated account balances
   - Stolen staked tokens
   - Manipulated validator rewards

This breaks the fundamental **State Consistency** invariant: "State transitions must be atomic and verifiable via Merkle proofs." It also violates the **Cryptographic Correctness** invariant: "BLS signatures, VRF, and hash operations must be secure."

The vulnerability allows an attacker to completely bypass the cryptographic guarantees that ensure only legitimate, validator-signed state is accepted by the system.

## Likelihood Explanation

The likelihood is **HIGH** because:

1. **Low Attack Complexity**: The attacker only needs to control the backup storage location, which is often a cloud storage bucket or filesystem location that may have misconfigured access controls

2. **Multiple Attack Vectors**: Two separate code paths allow exploitation:
   - Using the `db-tool` for oneoff state snapshot restore
   - Using the restore coordinator with the `--skip-epoch-endings` flag

3. **Operational Necessity**: Operators regularly use these restore tools for legitimate purposes (disaster recovery, setting up new nodes, testing), creating natural opportunities for exploitation

4. **No Privileged Access Required**: The attacker doesn't need validator keys, consensus participation, or any on-chain privileges - just control over backup files

## Recommendation

The fix requires making `LedgerInfo` signature verification **mandatory** rather than optional. The `epoch_history` parameter should either be required, or there should be an alternative mechanism to verify the `LedgerInfo` when epoch history is not available.

**Option 1: Require trusted waypoints**
When `epoch_history` is not available, require the operator to provide trusted waypoints and verify the `LedgerInfo` against them:

```rust
// In StateSnapshotRestoreController::run_impl()
if let Some(epoch_history) = self.epoch_history.as_ref() {
    epoch_history.verify_ledger_info(&li)?;
} else {
    // Require at least one trusted waypoint for verification
    ensure!(
        !self.trusted_waypoints.is_empty(),
        "Cannot restore state snapshot without epoch history or trusted waypoints"
    );
    let wp_li = Waypoint::new_any(li.ledger_info());
    let trusted_wp = self.trusted_waypoints.get(&li.ledger_info().version())
        .ok_or_else(|| anyhow!(
            "No trusted waypoint found for version {}. Refusing to restore potentially malicious state.",
            li.ledger_info().version()
        ))?;
    ensure!(
        *trusted_wp == wp_li,
        "Waypoint verification failed. Expected: {}, Got: {}",
        trusted_wp,
        wp_li
    );
}
```

**Option 2: Remove the --skip-epoch-endings flag**
The `--skip-epoch-endings` flag should be removed or deprecated, as it fundamentally undermines the security model by allowing unverified state restoration.

**Option 3: Add explicit operator acknowledgment**
If the flag must remain for specific use cases, add explicit warnings and require the operator to provide a second confirmation that they understand the security implications.

## Proof of Concept

The following Rust test demonstrates the vulnerability:

```rust
// Test in storage/backup/backup-cli/src/backup_types/state_snapshot/tests.rs

#[tokio::test]
async fn test_state_snapshot_restore_without_epoch_history_allows_fake_state() {
    use aptos_types::{
        ledger_info::LedgerInfo,
        transaction::{TransactionInfo, Version},
        proof::TransactionInfoWithProof,
    };
    use aptos_crypto::HashValue;
    
    // Step 1: Create a fake root hash for our malicious state
    let fake_root_hash = HashValue::random();
    
    // Step 2: Create a fake LedgerInfo (no valid signatures)
    let fake_ledger_info = LedgerInfo::new(
        /* Block info with fake transaction accumulator root */
    );
    let fake_li_with_sigs = LedgerInfoWithSignatures::new(
        fake_ledger_info,
        BTreeMap::new(), // Empty signatures!
    );
    
    // Step 3: Create a fake TransactionInfo containing our fake root hash
    let fake_txn_info = TransactionInfo::new(
        /* ... */
        fake_root_hash, // Our fake state root
        /* ... */
    );
    
    // Step 4: Create a valid TransactionAccumulatorProof for the fake accumulator
    let fake_proof = TransactionInfoWithProof::new(
        /* proof that connects fake_txn_info to fake_ledger_info */
    );
    
    // Step 5: Create fake manifest pointing to these fake components
    let fake_manifest = StateSnapshotBackup {
        root_hash: fake_root_hash,
        proof: /* file handle to fake proof */,
        /* ... */
    };
    
    // Step 6: Attempt restore with epoch_history = None
    let controller = StateSnapshotRestoreController::new(
        /* ... */,
        None, // epoch_history is None - bypasses validation!
    );
    
    // This should FAIL but currently SUCCEEDS
    let result = controller.run().await;
    assert!(result.is_ok()); // Vulnerability: fake state is accepted!
}
```

To fully demonstrate the exploit, an attacker would:
1. Generate a complete fake state tree with desired balances/state
2. Calculate the resulting Jellyfish Merkle root hash
3. Create fake manifest, LedgerInfo, and proof files as shown above
4. Run `db-tool restore` with these files
5. Observe that arbitrary state is loaded into the database without any signature verification

## Notes

The root cause is an architectural decision to make `LedgerInfo` signature verification optional, presumably for operational convenience. However, this fundamentally breaks the security model where all state must be cryptographically provable back to a chain of validator signatures.

The `EpochHistory::verify_ledger_info()` method does perform proper verification when available: [9](#0-8) 

But there's also a concerning fallback at lines 279-287 that returns `Ok()` without verification if the epoch is beyond known history, though this is at least logged as a warning.

The vulnerability demonstrates that operational convenience features (like `--skip-epoch-endings` or oneoff restores without epoch history) can create critical security holes when they bypass fundamental cryptographic validation.

### Citations

**File:** storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs (L123-126)
```rust
        let manifest: StateSnapshotBackup =
            self.storage.load_json_file(&self.manifest_handle).await?;
        let (txn_info_with_proof, li): (TransactionInfoWithProof, LedgerInfoWithSignatures) =
            self.storage.load_bcs_file(&manifest.proof).await?;
```

**File:** storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs (L127-136)
```rust
        txn_info_with_proof.verify(li.ledger_info(), manifest.version)?;
        let state_root_hash = txn_info_with_proof
            .transaction_info()
            .ensure_state_checkpoint_hash()?;
        ensure!(
            state_root_hash == manifest.root_hash,
            "Root hash mismatch with that in proof. root hash: {}, expected: {}",
            manifest.root_hash,
            state_root_hash,
        );
```

**File:** storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs (L137-139)
```rust
        if let Some(epoch_history) = self.epoch_history.as_ref() {
            epoch_history.verify_ledger_info(&li)?;
        }
```

**File:** storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs (L141-145)
```rust
        let receiver = Arc::new(Mutex::new(Some(self.run_mode.get_state_restore_receiver(
            self.version,
            manifest.root_hash,
            self.restore_mode,
        )?)));
```

**File:** storage/db-tool/src/restore.rs (L88-95)
```rust
                        StateSnapshotRestoreController::new(
                            opt,
                            global.try_into()?,
                            storage.init_storage().await?,
                            None, /* epoch_history */
                        )
                        .run()
                        .await?;
```

**File:** storage/backup/backup-cli/src/coordinators/restore.rs (L219-231)
```rust
        let epoch_history = if !self.skip_epoch_endings {
            Some(Arc::new(
                EpochHistoryRestoreController::new(
                    epoch_handles,
                    self.global_opt.clone(),
                    self.storage.clone(),
                )
                .run()
                .await?,
            ))
        } else {
            None
        };
```

**File:** types/src/proof/mod.rs (L40-61)
```rust
fn verify_transaction_info(
    ledger_info: &LedgerInfo,
    transaction_version: Version,
    transaction_info: &TransactionInfo,
    ledger_info_to_transaction_info_proof: &TransactionAccumulatorProof,
) -> Result<()> {
    ensure!(
        transaction_version <= ledger_info.version(),
        "Transaction version {} is newer than LedgerInfo version {}.",
        transaction_version,
        ledger_info.version(),
    );

    let transaction_info_hash = transaction_info.hash();
    ledger_info_to_transaction_info_proof.verify(
        ledger_info.transaction_accumulator_hash(),
        transaction_info_hash,
        transaction_version,
    )?;

    Ok(())
}
```

**File:** storage/jellyfish-merkle/src/restore/mod.rs (L390-391)
```rust
        // Verify what we have added so far is all correct.
        self.verify(proof)?;
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L276-312)
```rust
    pub fn verify_ledger_info(&self, li_with_sigs: &LedgerInfoWithSignatures) -> Result<()> {
        let epoch = li_with_sigs.ledger_info().epoch();
        ensure!(!self.epoch_endings.is_empty(), "Empty epoch history.",);
        if epoch > self.epoch_endings.len() as u64 {
            // TODO(aldenhu): fix this from upper level
            warn!(
                epoch = epoch,
                epoch_history_until = self.epoch_endings.len(),
                "Epoch is too new and can't be verified. Previous chunks are verified and node \
                won't be able to start if this data is malicious."
            );
            return Ok(());
        }
        if epoch == 0 {
            ensure!(
                li_with_sigs.ledger_info() == &self.epoch_endings[0],
                "Genesis epoch LedgerInfo info doesn't match.",
            );
        } else if let Some(wp_trusted) = self
            .trusted_waypoints
            .get(&li_with_sigs.ledger_info().version())
        {
            let wp_li = Waypoint::new_any(li_with_sigs.ledger_info());
            ensure!(
                *wp_trusted == wp_li,
                "Waypoints don't match. In backup: {}, trusted: {}",
                wp_li,
                wp_trusted,
            );
        } else {
            self.epoch_endings[epoch as usize - 1]
                .next_epoch_state()
                .ok_or_else(|| anyhow!("Shouldn't contain non- epoch bumping LIs."))?
                .verify(li_with_sigs)?;
        };
        Ok(())
    }
```
