# Audit Report

## Title
IPv4-Mapped IPv6 Address Bypass in Faucet IP Range Manager

## Summary
The `IpRangeManager::contains_ip()` method in the Aptos faucet does not normalize IPv4-mapped IPv6 addresses (e.g., `::ffff:192.0.2.1`) before checking against IP blocklists/allowlists. This allows attackers to bypass IP-based security controls by connecting via IPv4-mapped IPv6 address representations when the faucet server is configured for dual-stack (IPv4/IPv6) operation. [1](#0-0) 

## Finding Description

The vulnerability exists in the IP address matching logic that separates IPv4 and IPv6 checks without normalizing IPv4-mapped IPv6 addresses. [2](#0-1) 

When an administrator blocks an IPv4 address like `192.0.2.1` by adding it to the blocklist file, it gets parsed and stored in the `ipv4_list`. However, if the faucet server is configured to listen on IPv6 (e.g., `listen_address: "::"` for dual-stack), incoming IPv4 connections may be represented as IPv4-mapped IPv6 addresses (`::ffff:192.0.2.1`). [3](#0-2) 

The `contains_ip()` method uses Rust's `IpAddr` enum matching, treating IPv4-mapped IPv6 addresses as `IpAddr::V6` variants, which are checked against the `ipv6_list` only.

**Attack Path:**

1. Administrator configures faucet with dual-stack IPv6 listening (e.g., `listen_address: "::"`)
2. Administrator blocks malicious IPv4 address `203.0.113.42` in blocklist file
3. Blocklist entry gets added to `ipv4_list` during parsing
4. Attacker connects from same IP, but server represents connection as `::ffff:203.0.113.42`
5. When blocklist checker calls `contains_ip()`, the IPv6 variant matches line 58
6. Check evaluates `ipv6_list.contains(::ffff:203.0.113.42)` - returns false (not in list)
7. Attacker bypasses blocklist [4](#0-3) 

The same issue affects the IP allowlist bypasser, where legitimate IPv4 addresses won't match their IPv6-mapped representations: [5](#0-4) 

## Impact Explanation

**High Severity** - This vulnerability enables multiple attack vectors:

1. **Security Control Bypass**: Attackers can evade IP blocklists designed to prevent abuse, spam, or malicious actors
2. **Rate Limit Circumvention**: Combined with rate limiting bypasses, enables faucet fund drainage
3. **Authorization Bypass**: Allowlisted IPs fail to match, denying legitimate access
4. **Resource Exhaustion**: Unbounded requests from blocked IPs can drain faucet funds or cause DoS

This qualifies as **High Severity** under Aptos bug bounty criteria as "Significant protocol violations" affecting the faucet API's security controls and potentially leading to service disruption or limited fund loss. [6](#0-5) 

## Likelihood Explanation

**Medium-to-High Likelihood:**

**Preconditions:**
- Faucet server configured for dual-stack IPv6 operation (not default, but common in production)
- Administrator has configured IP blocklists/allowlists (common security practice)
- Attacker can control connection representation (OS-dependent, but achievable)

**Exploitation Complexity:** Low
- No special privileges required
- Trivial to attempt connecting via IPv4-mapped IPv6 representation
- No cryptographic or protocol-level attacks needed

**Real-World Scenarios:**
- Cloud deployments often use dual-stack by default
- Kubernetes environments commonly expose services on `::`
- Docker containers frequently use IPv6 dual-stack networking

## Recommendation

Normalize IPv4-mapped IPv6 addresses before checking IP ranges. Add the following method to `IpRangeManager`:

```rust
impl IpRangeManager {
    // ... existing code ...
    
    pub fn contains_ip(&self, ip: &IpAddr) -> bool {
        match ip {
            IpAddr::V4(ipv4) => self.ipv4_list.contains(ipv4),
            IpAddr::V6(ipv6) => {
                // Normalize IPv4-mapped IPv6 addresses
                if let Some(ipv4) = ipv6.to_ipv4_mapped() {
                    self.ipv4_list.contains(&ipv4)
                } else {
                    self.ipv6_list.contains(ipv6)
                }
            }
        }
    }
}
```

Apply the same normalization in `IpBlocklistChecker`:

```rust
match &data.source_ip {
    IpAddr::V4(source_ip) => {
        if self.manager.ipv4_list.contains(source_ip) {
            return Ok(vec![RejectionReason::new(...)]);
        }
    },
    IpAddr::V6(source_ip) => {
        // Check for IPv4-mapped addresses first
        if let Some(ipv4) = source_ip.to_ipv4_mapped() {
            if self.manager.ipv4_list.contains(&ipv4) {
                return Ok(vec![RejectionReason::new(...)]);
            }
        } else if self.manager.ipv6_list.contains(source_ip) {
            return Ok(vec![RejectionReason::new(...)]);
        }
    },
}
```

## Proof of Concept

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};
    use std::fs;
    use std::io::Write;
    
    #[test]
    fn test_ipv4_mapped_ipv6_bypass() {
        // Create a temporary blocklist file with IPv4 address
        let blocklist_path = "/tmp/test_blocklist_ipv4_mapped.txt";
        let mut file = fs::File::create(blocklist_path).unwrap();
        writeln!(file, "192.0.2.1/32").unwrap();
        drop(file);
        
        // Initialize IpRangeManager
        let config = IpRangeManagerConfig {
            file: blocklist_path.into(),
        };
        let manager = IpRangeManager::new(config).unwrap();
        
        // Test 1: IPv4 address should be blocked
        let ipv4_addr = IpAddr::V4(Ipv4Addr::new(192, 0, 2, 1));
        assert!(manager.contains_ip(&ipv4_addr), "IPv4 address should be in blocklist");
        
        // Test 2: IPv4-mapped IPv6 address BYPASSES blocklist (vulnerability)
        let ipv4_mapped_ipv6 = IpAddr::V6(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc000, 0x0201));
        assert!(!manager.contains_ip(&ipv4_mapped_ipv6), 
            "VULNERABILITY: IPv4-mapped IPv6 bypasses blocklist");
        
        // Test 3: Demonstrate the bypass
        println!("IPv4 address {} is blocked: {}", ipv4_addr, manager.contains_ip(&ipv4_addr));
        println!("IPv4-mapped IPv6 {} bypasses blocklist: {}", 
            ipv4_mapped_ipv6, !manager.contains_ip(&ipv4_mapped_ipv6));
        
        // Cleanup
        fs::remove_file(blocklist_path).ok();
    }
    
    #[test]
    fn test_with_normalization_fix() {
        // Proposed fix implementation
        fn contains_ip_normalized(manager: &IpRangeManager, ip: &IpAddr) -> bool {
            match ip {
                IpAddr::V4(ipv4) => manager.ipv4_list.contains(ipv4),
                IpAddr::V6(ipv6) => {
                    if let Some(ipv4) = ipv6.to_ipv4_mapped() {
                        manager.ipv4_list.contains(&ipv4)
                    } else {
                        manager.ipv6_list.contains(ipv6)
                    }
                }
            }
        }
        
        // Setup same as above
        let blocklist_path = "/tmp/test_blocklist_fixed.txt";
        let mut file = fs::File::create(blocklist_path).unwrap();
        writeln!(file, "192.0.2.1/32").unwrap();
        drop(file);
        
        let config = IpRangeManagerConfig {
            file: blocklist_path.into(),
        };
        let manager = IpRangeManager::new(config).unwrap();
        
        // Test with fixed implementation
        let ipv4_mapped_ipv6 = IpAddr::V6(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc000, 0x0201));
        assert!(contains_ip_normalized(&manager, &ipv4_mapped_ipv6),
            "FIXED: IPv4-mapped IPv6 is now properly blocked");
        
        fs::remove_file(blocklist_path).ok();
    }
}
```

**Notes:**
- This vulnerability is specific to the faucet auxiliary service, not core blockchain consensus
- Exploitation requires dual-stack IPv6 configuration (non-default but common in production)
- The same pattern may exist in other IP-based security controls throughout the codebase
- Standard library's `Ipv6Addr::to_ipv4_mapped()` provides built-in normalization capability
- Both blocklist checking and allowlist bypassing are affected

### Citations

**File:** crates/aptos-faucet/core/src/common/ip_range_manager.rs (L18-21)
```rust
pub struct IpRangeManager {
    pub ipv4_list: IpRange<Ipv4Net>,
    pub ipv6_list: IpRange<Ipv6Net>,
}
```

**File:** crates/aptos-faucet/core/src/common/ip_range_manager.rs (L55-60)
```rust
    pub fn contains_ip(&self, ip: &IpAddr) -> bool {
        match ip {
            IpAddr::V4(ipv4) => self.ipv4_list.contains(ipv4),
            IpAddr::V6(ipv6) => self.ipv6_list.contains(ipv6),
        }
    }
```

**File:** crates/aptos-faucet/core/src/server/server_args.rs (L7-19)
```rust
pub struct ServerConfig {
    /// What address to listen on, e.g. localhost / 0.0.0.0
    #[serde(default = "ServerConfig::default_listen_address")]
    pub listen_address: String,

    /// What port to listen on.
    #[serde(default = "ServerConfig::default_listen_port")]
    pub listen_port: u16,

    /// API path base. e.g. "/v1"
    #[serde(default = "ServerConfig::default_api_path_base")]
    pub api_path_base: String,
}
```

**File:** crates/aptos-faucet/core/src/checkers/ip_blocklist.rs (L32-49)
```rust
        match &data.source_ip {
            IpAddr::V4(source_ip) => {
                if self.manager.ipv4_list.contains(source_ip) {
                    return Ok(vec![RejectionReason::new(
                        format!("IP {} is in blocklist", source_ip),
                        RejectionReasonCode::IpInBlocklist,
                    )]);
                }
            },
            IpAddr::V6(source_ip) => {
                if self.manager.ipv6_list.contains(source_ip) {
                    return Ok(vec![RejectionReason::new(
                        format!("IP {} is in blocklist", source_ip),
                        RejectionReasonCode::IpInBlocklist,
                    )]);
                }
            },
        }
```

**File:** crates/aptos-faucet/core/src/bypasser/ip_allowlist.rs (L26-28)
```rust
    async fn request_can_bypass(&self, data: CheckerData) -> Result<bool> {
        Ok(self.manager.contains_ip(&data.source_ip))
    }
```

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L244-259)
```rust
        // See if this request meets the criteria to bypass checkers / storage.
        for bypasser in &self.bypassers {
            if bypasser
                .request_can_bypass(checker_data.clone())
                .await
                .map_err(|e| {
                    AptosTapError::new_with_error_code(e, AptosTapErrorCode::BypasserError)
                })?
            {
                info!(
                    "Allowing request from {} to bypass checks / storage",
                    source_ip
                );
                return Ok((checker_data, true, permit));
            }
        }
```
