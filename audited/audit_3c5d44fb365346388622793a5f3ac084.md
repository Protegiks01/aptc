# Audit Report

## Title
Eclipse Attack via Unverified Peer Advertisements Enabling Network Isolation and Double-Spend

## Summary
The Aptos state sync system aggregates `LedgerInfoWithSignatures` from peer advertisements into `GlobalDataSummary` without cryptographic verification. This allows eclipse attackers who control all peer connections to advertise old but validly-signed blockchain states, causing victims to sync to outdated network states while believing they are fully synchronized, enabling double-spend attacks against fullnodes.

## Finding Description

The vulnerability exists in the state synchronization flow where peer-advertised data summaries are aggregated and used to make critical sync decisions without signature verification.

**Vulnerable Code Path:**

1. **Unverified Aggregation**: In `calculate_global_data_summary()`, peer-advertised `synced_ledger_info` values are collected without verification: [1](#0-0) 

2. **Critical Decision Point**: The bootstrapper uses unverified `highest_synced_ledger_info()` to determine waypoint satisfiability: [2](#0-1) [3](#0-2) 

3. **Sync Target Selection**: The stream engine uses unverified advertised data to select streaming targets: [4](#0-3) 

4. **False "Caught Up" Detection**: The latency monitor compares synced version against unverified advertised version: [5](#0-4) [6](#0-5) 

**Attack Scenario:**

1. Attacker performs eclipse attack on victim fullnode (controls all peer connections)
2. Attacker advertises `StorageServerSummary` with `synced_ledger_info` pointing to version 1000 (old but valid blockchain state with legitimate BLS signatures)
3. Real network is at version 2000
4. Victim's `GlobalDataSummary` aggregates this unverified data
5. Victim checks: `1000 >= waypoint_version (e.g., 500)` ✓ Passes
6. Victim requests data up to version 1000 from attacker
7. Attacker provides old but validly-signed transactions, states, and ledger infos
8. All cryptographic verification passes (signatures are legitimate from that historical point)
9. Victim commits data up to version 1000
10. Latency monitor checks: `synced(1000) + 10000 >= advertised(1000)` ✓ "Caught up"
11. Victim believes it's fully synchronized but is actually 1000 versions behind

**Why Verification is Absent:**

While `LedgerInfoWithSignatures` has a `verify_signatures()` method: [7](#0-6) 

And `EpochState` properly verifies ledger infos: [8](#0-7) 

These verification methods are **only called when processing actual data payloads**, not when aggregating peer advertisements: [9](#0-8) 

## Impact Explanation

**Severity: Critical**

This vulnerability enables **network isolation and double-spend attacks**:

1. **Fullnode Isolation**: Exchange/wallet fullnodes can be isolated to old blockchain states while believing they're synchronized
2. **Double-Spend Enablement**: Services display balances from old states, allowing users to withdraw funds already spent on the real network
3. **Network Partition Risk**: Multiple eclipsed nodes sync to different historical states, fragmenting the network's view
4. **Consensus Safety Violation**: Different nodes have inconsistent blockchain state views

**Example Attack Impact:**
- Victim exchange syncs to version 1000 (old state)
- User had 100 APT at version 1000
- User spent 100 APT at version 1500 on real network
- Victim shows balance of 100 APT (from old state)
- User withdraws 100 APT from exchange (double-spend)

This breaks the **State Consistency** invariant: nodes must have verifiable, consistent views of blockchain state.

## Likelihood Explanation

**Likelihood: Medium-High**

**Requirements:**
- Eclipse attack capability (achievable via Sybil attacks, BGP hijacking, or targeted network attacks)
- Access to historical blockchain data (publicly available)
- No validator collusion needed

**Ease of Exploitation:**
- Moderate complexity - requires network-level control
- No cryptographic breaking required
- Historical blockchain data is public and contains valid signatures
- No special privileges or validator keys needed

**Realistic Scenarios:**
- Targeted attacks against high-value exchanges/wallets
- State-level adversaries with BGP control
- Large-scale Sybil attacks on P2P network layer

## Recommendation

**Immediate Fix: Verify Peer Advertisements**

Modify `calculate_global_data_summary()` to verify `LedgerInfoWithSignatures` before aggregation:

```rust
pub fn calculate_global_data_summary(&self) -> GlobalDataSummary {
    let storage_summaries: Vec<StorageServerSummary> = self
        .peer_to_state
        .iter()
        .filter_map(|peer_state| {
            peer_state
                .value()
                .get_storage_summary_if_not_ignored()
                .cloned()
        })
        .collect();

    if storage_summaries.is_empty() {
        return GlobalDataSummary::empty();
    }

    let mut advertised_data = AdvertisedData::empty();
    // ... chunk size collection ...
    
    for summary in storage_summaries {
        // NEW: Verify synced_ledger_info before including it
        if let Some(synced_ledger_info) = summary.data_summary.synced_ledger_info.as_ref() {
            // Verify signatures against current epoch state
            // Only include if verification passes
            if let Ok(()) = self.verify_ledger_info_advertisement(synced_ledger_info) {
                advertised_data.synced_ledger_infos.push(synced_ledger_info.clone());
            } else {
                // Mark peer as malicious for advertising unverifiable data
                self.update_score_error(peer_id, ErrorType::Malicious);
            }
        }
        // ... rest of aggregation ...
    }
    // ... return GlobalDataSummary ...
}
```

**Additional Mitigations:**

1. **Waypoint Validation Enhancement**: Check advertised versions are reasonably close to waypoint age (detect very old states)
2. **Out-of-Band State Verification**: Periodically verify blockchain tip against trusted sources (e.g., multiple independent APIs)
3. **Peer Diversity Requirements**: Require connections to peers from multiple network segments
4. **Advertisement Rate Limiting**: Flag peers advertising significantly older states than majority

## Proof of Concept

```rust
// Theoretical PoC demonstrating the attack flow
#[test]
fn test_eclipse_attack_via_unverified_advertisements() {
    // Setup: Create victim node and malicious peers
    let victim_node = create_test_node_with_waypoint(version_500);
    let attacker_peers = create_malicious_peers(num_peers = 10);
    
    // Step 1: Attacker eclipses victim (controls all peer connections)
    victim_node.disconnect_all_honest_peers();
    for peer in attacker_peers {
        victim_node.connect_peer(peer);
    }
    
    // Step 2: Attacker advertises old but valid state
    let old_ledger_info = get_historical_ledger_info(version_1000);
    // Note: This LedgerInfo has VALID signatures from validators at that time
    assert!(old_ledger_info.verify_signatures(&validator_verifier_epoch_X).is_ok());
    
    for peer in attacker_peers {
        let malicious_summary = StorageServerSummary {
            data_summary: DataSummary {
                synced_ledger_info: Some(old_ledger_info.clone()), // Old but valid!
                // ... other fields ...
            },
            // ... protocol metadata ...
        };
        peer.advertise_summary(malicious_summary);
    }
    
    // Step 3: Victim aggregates WITHOUT verification
    let global_summary = victim_node.get_global_data_summary();
    let highest = global_summary.advertised_data.highest_synced_ledger_info().unwrap();
    assert_eq!(highest.ledger_info().version(), 1000); // Old state!
    
    // Step 4: Waypoint check passes (1000 >= 500)
    assert!(victim_node.verify_waypoint_is_satisfiable(&global_summary).is_ok());
    
    // Step 5: Victim syncs to old state
    victim_node.sync_to_target(highest);
    
    // Step 6: Attacker provides old but valid blockchain data
    // All verification passes because signatures are legitimate from that era
    
    // Step 7: Victim believes it's caught up
    let synced_version = victim_node.get_synced_version();
    assert_eq!(synced_version, 1000);
    assert!(victim_node.is_caught_up()); // FALSE POSITIVE!
    
    // Step 8: Double-spend scenario
    let user_balance_at_v1000 = victim_node.query_balance(user_address);
    assert_eq!(user_balance_at_v1000, 100_APT);
    
    // On real network (v2000), user already spent these coins at v1500
    let user_balance_on_real_network = real_network.query_balance(user_address);
    assert_eq!(user_balance_on_real_network, 0_APT);
    
    // Victim allows withdrawal based on old state -> DOUBLE SPEND
    victim_node.process_withdrawal(user_address, 100_APT); // SUCCEEDS with old state
}
```

## Notes

This vulnerability is particularly insidious because:

1. **All Cryptographic Verification Passes**: The attacker uses legitimately signed historical blockchain data, so signature verification succeeds
2. **No Alert Mechanisms**: The node has no way to detect it's viewing old state since all validations pass
3. **Persistent Isolation**: The victim remains isolated indefinitely as long as eclipse conditions persist
4. **Affects Critical Infrastructure**: Exchanges, wallets, and block explorers are primary targets

The fix requires adding verification at the advertisement aggregation stage, not just at data delivery stage. The `LedgerInfoWithSignatures` objects in peer advertisements should be verified against trusted epoch state before being used for sync decisions.

### Citations

**File:** state-sync/aptos-data-client/src/peer_states.rs (L374-377)
```rust
            if let Some(synced_ledger_info) = summary.data_summary.synced_ledger_info.as_ref() {
                advertised_data
                    .synced_ledger_infos
                    .push(synced_ledger_info.clone());
```

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L894-902)
```rust
        let highest_advertised_ledger_info = global_data_summary
            .advertised_data
            .highest_synced_ledger_info()
            .ok_or_else(|| {
                Error::UnsatisfiableWaypoint(
                    "Unable to check waypoint satisfiability! No highest advertised ledger info found in the network!".into(),
                )
            })?;
        let highest_advertised_version = highest_advertised_ledger_info.ledger_info().version();
```

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L905-914)
```rust
        if highest_advertised_version < waypoint_version {
            Err(Error::UnsatisfiableWaypoint(
                format!(
                    "The waypoint is not satisfiable! No advertised version higher than our waypoint! Highest version: {:?}, waypoint version: {:?}.",
                    highest_advertised_version, waypoint_version
                )
            ))
        } else {
            Ok(())
        }
```

**File:** state-sync/data-streaming-service/src/stream_engine.rs (L523-528)
```rust
        if let Some(highest_synced_ledger_info) = advertised_data.highest_synced_ledger_info() {
            let (next_request_version, _) = self.next_request_version_and_epoch;
            if next_request_version > highest_synced_ledger_info.ledger_info().version() {
                Ok(None) // We're already at the highest synced ledger info. There's no known target.
            } else {
                Ok(Some(highest_synced_ledger_info))
```

**File:** state-sync/aptos-data-client/src/latency_monitor.rs (L127-141)
```rust
            let advertised_data = &self.data_client.get_global_data_summary().advertised_data;
            let highest_advertised_version = match advertised_data.highest_synced_ledger_info() {
                Some(ledger_info) => ledger_info.ledger_info().version(),
                None => {
                    sample!(
                        SampleRate::Duration(Duration::from_secs(LATENCY_MONITOR_LOG_FREQ_SECS)),
                        warn!(
                            (LogSchema::new(LogEntry::LatencyMonitor)
                                .event(LogEvent::AggregateSummary)
                                .message("Unable to get the highest advertised version!"))
                        );
                    );
                    continue; // Continue to the next round
                },
            };
```

**File:** state-sync/aptos-data-client/src/latency_monitor.rs (L242-251)
```rust
        if !self.caught_up_to_latest {
            if highest_synced_version + MAX_VERSION_LAG_TO_TOLERATE >= highest_advertised_version {
                info!(
                    (LogSchema::new(LogEntry::LatencyMonitor)
                        .event(LogEvent::CaughtUpToLatest)
                        .message(
                            "We've caught up to the latest version! Starting the latency monitor."
                        ))
                );
                self.caught_up_to_latest = true; // We've caught up
```

**File:** types/src/ledger_info.rs (L303-308)
```rust
    pub fn verify_signatures(
        &self,
        validator: &ValidatorVerifier,
    ) -> ::std::result::Result<(), VerifyError> {
        validator.verify_multi_signatures(self.ledger_info(), &self.signatures)
    }
```

**File:** types/src/epoch_state.rs (L41-49)
```rust
    fn verify(&self, ledger_info: &LedgerInfoWithSignatures) -> anyhow::Result<()> {
        ensure!(
            self.epoch == ledger_info.ledger_info().epoch(),
            "LedgerInfo has unexpected epoch {}, expected {}",
            ledger_info.ledger_info().epoch(),
            self.epoch
        );
        ledger_info.verify_signatures(&self.verifier)?;
        Ok(())
```

**File:** state-sync/state-sync-driver/src/utils.rs (L101-109)
```rust
    pub fn verify_ledger_info_with_signatures(
        &mut self,
        ledger_info_with_signatures: &LedgerInfoWithSignatures,
    ) -> Result<(), Error> {
        self.epoch_state
            .verify(ledger_info_with_signatures)
            .map_err(|error| {
                Error::VerificationError(format!("Ledger info failed verification: {:?}", error))
            })
```
