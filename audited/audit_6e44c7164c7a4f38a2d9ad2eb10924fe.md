# Audit Report

## Title
JWK Observer Resource Exhaustion via Missing HTTP Client Timeouts

## Summary
The JWK consensus observer implementation creates HTTP clients without configuring timeouts when fetching JWKs from OIDC provider endpoints. This allows unresponsive or malicious endpoints to cause observer tasks to hang indefinitely, consuming validator resources (memory, file descriptors, TCP connections) and potentially degrading validator node performance.

## Finding Description

The vulnerability exists in the HTTP client initialization code used by JWK observers. When each `JWKObserver` fetches JWKs from OIDC provider endpoints, it uses `reqwest::Client::new()` which creates an HTTP client **without any timeout configuration**. [1](#0-0) [2](#0-1) 

The JWK observer loop awaits these HTTP fetch operations synchronously: [3](#0-2) 

When the provider endpoint accepts the connection but never sends a response (slowloris attack), or responds extremely slowly, the observer task blocks indefinitely on the `.await` at line 74. This violates the **Resource Limits** invariant (#9) which requires all operations to respect computational limits.

**Attack Propagation Path:**
1. Governance adds OIDC providers via `upsert_oidc_provider_for_next_epoch()` [4](#0-3) 
2. JWK consensus manager spawns one `JWKObserver` per provider [5](#0-4) 
3. Each observer periodically fetches JWKs with a 10-second interval [6](#0-5) 
4. If a provider endpoint hangs indefinitely, the observer task blocks
5. Multiple hanging observers accumulate, consuming:
   - Memory for blocked tokio tasks
   - Open TCP connections to malicious endpoints
   - File descriptors for sockets
6. With no limit on the number of OIDC providers [7](#0-6) , this amplifies the resource exhaustion

**Contrast with Proper Implementation:**
Other parts of the codebase correctly configure timeouts: [8](#0-7) [9](#0-8) 

**Important Note:** The security question mentions "infinite retry loops" from "transient errors." The actual vulnerability is different: endpoints that return HTTP errors (500, 503) are handled gracefully and don't cause hangs. The issue occurs when endpoints accept connections but never respond, causing indefinite blocking rather than retry loops.

## Impact Explanation

**Severity: High** (up to $50,000 per Aptos bug bounty)

This qualifies as **"Validator node slowdowns"** under the High severity category. While the hanging observers run in separate tokio tasks and don't directly block consensus operations, they consume critical system resources:

1. **File Descriptor Exhaustion**: Each stuck connection holds a file descriptor. If enough observers hang, the validator could hit the OS limit (typically ulimit -n), preventing new connections for consensus, networking, or RPC services.

2. **Memory Consumption**: Each blocked tokio task holds memory for stack frames and task state. With many providers, this becomes non-trivial.

3. **TCP Connection Slots**: Hanging connections consume TCP connection tracking resources in the kernel.

4. **Degraded Node Performance**: Resource contention affects overall validator responsiveness, potentially causing consensus timeouts or slower block processing.

The impact doesn't reach Critical severity because:
- It doesn't directly compromise consensus safety
- It doesn't cause total loss of liveness (consensus can still operate)
- It requires governance to add providers (though legitimate providers could be compromised)

## Likelihood Explanation

**Likelihood: Medium to High**

Factors increasing likelihood:
1. **No explicit limit on OIDC providers** - governance could add many providers
2. **Legitimate providers can fail** - even trusted providers like Google/Facebook can have outages or misconfigurations
3. **Network issues** - transient network problems can cause endpoints to hang
4. **MitM attacks** - network adversaries could intercept and hang requests
5. **Provider compromises** - legitimate providers could be compromised to serve slow/hanging responses

Factors decreasing likelihood:
1. **Governance requirement** - adding providers requires governance approval
2. **Bounded by provider count** - only one stuck request per provider at a time
3. **Not automatic** - requires providers to actually hang, not just return errors

The issue is particularly concerning because it can occur **without malicious intent** through normal operational failures of legitimate OIDC providers.

## Recommendation

Configure HTTP client timeouts in the JWK utils crate. Add timeout configuration for both connection and total request duration:

```rust
// In crates/jwk-utils/src/lib.rs

use std::time::Duration;

// Timeout for JWK fetch operations (both connection and total request)
const JWK_FETCH_TIMEOUT_SECS: u64 = 15;

pub async fn fetch_jwks_from_jwks_uri(
    my_addr: Option<AccountAddress>,
    jwks_uri: &str,
) -> Result<Vec<JWK>> {
    let client = reqwest::Client::builder()
        .timeout(Duration::from_secs(JWK_FETCH_TIMEOUT_SECS))
        .build()
        .map_err(|e| anyhow!("Failed to build HTTP client: {}", e))?;
    
    let mut request_builder = client.get(jwks_uri);
    if let Some(addr) = my_addr {
        request_builder = request_builder.header(COOKIE, addr.to_hex());
    }
    let JWKsResponse { keys } = request_builder.send().await?.json().await?;
    let jwks = keys.into_iter().map(JWK::from).collect();
    Ok(jwks)
}

pub async fn fetch_jwks_uri_from_openid_config(config_url: &str) -> Result<String> {
    let client = reqwest::Client::builder()
        .timeout(Duration::from_secs(JWK_FETCH_TIMEOUT_SECS))
        .build()
        .map_err(|e| anyhow!("Failed to build HTTP client: {}", e))?;
    
    let OpenIDConfiguration { jwks_uri, .. } = client.get(config_url).send().await?.json().await?;
    Ok(jwks_uri)
}
```

Additionally, consider:
1. **Maximum provider limit** - add a governance-enforced maximum number of OIDC providers
2. **Circuit breaker** - temporarily disable observers that consistently fail or timeout
3. **Monitoring** - add metrics for observer task health and stuck tasks

## Proof of Concept

```rust
// Test demonstrating the vulnerability
// Add to crates/aptos-jwk-consensus/src/jwk_observer.rs or a separate test file

#[cfg(test)]
mod hanging_endpoint_test {
    use super::*;
    use tokio::time::{timeout, Duration};
    use std::net::TcpListener;

    #[tokio::test]
    async fn test_observer_hangs_on_unresponsive_endpoint() {
        // Start a TCP server that accepts connections but never responds
        let listener = TcpListener::bind("127.0.0.1:0").unwrap();
        let addr = listener.local_addr().unwrap();
        
        // Spawn a server that accepts connections but hangs
        tokio::spawn(async move {
            loop {
                if let Ok((mut _socket, _)) = listener.accept() {
                    // Accept connection but never send any data
                    tokio::time::sleep(Duration::from_secs(3600)).await;
                }
            }
        });

        let config_url = format!("http://{}/config", addr);
        
        // Try to fetch JWKs - this will hang indefinitely with the current implementation
        let fetch_result = timeout(
            Duration::from_secs(5),
            crate::jwk_observer::fetch_jwks(&config_url, None)
        ).await;
        
        // Without timeout fix, this will fail because the fetch never completes
        assert!(
            fetch_result.is_err(),
            "Fetch should timeout, but it hung indefinitely (or the fix is already applied)"
        );
    }
}
```

**To observe the vulnerability:**
1. Set up a malicious OIDC provider endpoint that accepts TCP connections but never sends HTTP responses
2. Add this provider via governance proposal
3. Monitor validator resource usage (open file descriptors, memory)
4. Observe that the JWKObserver task remains blocked indefinitely
5. Add multiple such providers to amplify the effect

## Notes

This vulnerability represents a violation of defensive programming principles where external dependencies (HTTP endpoints) must have strict resource limits. While the immediate impact doesn't compromise consensus safety, it degrades validator node reliability and could lead to cascading failures under resource pressure.

The fix is straightforward and follows established patterns elsewhere in the Aptos codebase. The 15-second timeout recommendation balances responsiveness with tolerance for slower OIDC providers.

### Citations

**File:** crates/jwk-utils/src/lib.rs (L29-29)
```rust
    let client = reqwest::Client::new();
```

**File:** crates/jwk-utils/src/lib.rs (L41-41)
```rust
    let client = reqwest::Client::new();
```

**File:** crates/aptos-jwk-consensus/src/jwk_observer.rs (L72-83)
```rust
                _ = interval.tick().fuse() => {
                    let timer = Instant::now();
                    let result = fetch_jwks(open_id_config_url.as_str(), my_addr).await;
                    debug!(issuer = issuer, "observe_result={:?}", result);
                    let secs = timer.elapsed().as_secs_f64();
                    if let Ok(mut jwks) = result {
                        OBSERVATION_SECONDS.with_label_values(&[issuer.as_str(), "ok"]).observe(secs);
                        jwks.sort();
                        let _ = observation_tx.push((), (issuer.as_bytes().to_vec(), jwks));
                    } else {
                        OBSERVATION_SECONDS.with_label_values(&[issuer.as_str(), "err"]).observe(secs);
                    }
```

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L64-66)
```text
    struct SupportedOIDCProviders has copy, drop, key, store {
        providers: vector<OIDCProvider>,
    }
```

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L317-330)
```text
    public fun upsert_oidc_provider_for_next_epoch(fx: &signer, name: vector<u8>, config_url: vector<u8>): Option<vector<u8>> acquires SupportedOIDCProviders {
        system_addresses::assert_aptos_framework(fx);

        let provider_set = if (config_buffer::does_exist<SupportedOIDCProviders>()) {
            config_buffer::extract_v2<SupportedOIDCProviders>()
        } else {
            *borrow_global<SupportedOIDCProviders>(@aptos_framework)
        };

        let old_config_url = remove_oidc_provider_internal(&mut provider_set, name);
        vector::push_back(&mut provider_set.providers, OIDCProvider { name, config_url });
        config_buffer::upsert(provider_set);
        old_config_url
    }
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager/mod.rs (L108-134)
```rust
        this.jwk_observers = oidc_providers
            .unwrap_or_default()
            .into_provider_vec()
            .into_iter()
            .filter_map(|provider| {
                let OIDCProvider { name, config_url } = provider;
                let maybe_issuer = String::from_utf8(name);
                let maybe_config_url = String::from_utf8(config_url);
                match (maybe_issuer, maybe_config_url) {
                    (Ok(issuer), Ok(config_url)) => Some(JWKObserver::spawn(
                        this.epoch_state.epoch,
                        this.my_addr,
                        issuer,
                        config_url,
                        Duration::from_secs(10),
                        local_observation_tx.clone(),
                    )),
                    (maybe_issuer, maybe_config_url) => {
                        warn!(
                            "unable to spawn observer, issuer={:?}, config_url={:?}",
                            maybe_issuer, maybe_config_url
                        );
                        None
                    },
                }
            })
            .collect();
```

**File:** crates/aptos-rest-client/src/faucet.rs (L25-28)
```rust
            inner: ReqwestClient::builder()
                .timeout(Duration::from_secs(10))
                .build()
                .unwrap(),
```

**File:** keyless/pepper/service/src/utils.rs (L17-22)
```rust
pub fn create_request_client() -> Client {
    Client::builder()
        .timeout(Duration::from_secs(CLIENT_REQUEST_TIMEOUT_SECS))
        .build()
        .expect("Failed to build the request client!")
}
```
