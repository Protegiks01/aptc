# Audit Report

## Title
Faucet Information Disclosure Through Multiple Rejection Reasons and Magic Header Key Leakage

## Summary
The Aptos Faucet's `MagicHeaderChecker` and the system's rejection aggregation mechanism leak sensitive security configuration details to potential attackers through error messages and multiple rejection reasons, enabling systematic reconnaissance of the faucet's security posture.

## Finding Description

The faucet implements two information disclosure mechanisms that, when combined, allow attackers to map the complete security architecture:

**Issue 1: Magic Header Key Name Disclosure**

The `MagicHeaderChecker.check()` function includes the configured header key name in rejection messages: [1](#0-0) [2](#0-1) 

When `USE_HELPFUL_ERRORS` is enabled (default behavior), the actual `magic_header_key` configuration value is exposed to attackers: [3](#0-2) 

**Issue 2: Aggregated Rejection Reasons**

When configured with `return_rejections_early: false`, the system aggregates rejection reasons from ALL checkers before returning them: [4](#0-3) 

This allows attackers to receive multiple rejection codes simultaneously (e.g., `MagicHeaderIncorrect`, `AuthTokenInvalid`, `IpInBlocklist`), revealing all active security controls.

**Attack Scenario:**
1. Attacker sends a single malformed request to the faucet
2. Receives multiple rejection reasons revealing: magic header name, auth token requirement, IP blocklist, captcha requirement, etc.
3. Systematically addresses each control to craft a bypass request
4. The magic header key name leak reduces the search space for brute-forcing the header value

## Impact Explanation

This is a **Low Severity** information disclosure vulnerability per Aptos bug bounty criteria. While it does not directly compromise blockchain consensus, funds, or availability, it:

- Reduces the effectiveness of security-through-obscurity measures
- Enables targeted attacks against faucet rate-limiting and anti-abuse mechanisms  
- Allows attackers to optimize resource expenditure when attempting to exploit the faucet
- Violates the principle of minimal information disclosure

The faucet is an auxiliary service, not a core blockchain component, limiting the overall impact.

## Likelihood Explanation

**Likelihood: High**

The vulnerability is trivially exploitable:
- Requires only standard HTTP requests
- No authentication or privileged access needed
- Occurs by default when `USE_HELPFUL_ERRORS: true` (recommended) and `return_rejections_early: false`
- Test configurations demonstrate this exact behavior: [5](#0-4) 

## Recommendation

**1. Remove Configuration Details from Error Messages**

Modify rejection messages to use generic descriptions:

```rust
// Instead of:
format!("Magic header {} not found", self.config.magic_header_key)

// Use:
"Required header not found".to_string()
```

**2. Default to Early Rejection Return**

Change the recommended default to prevent information aggregation:

```rust
pub return_rejections_early: bool = true,  // Default to true
```

**3. Document Security Implications**

Add explicit warnings in configuration documentation about the information disclosure risks when setting `return_rejections_early: false`.

## Proof of Concept

```bash
# Send a request missing all security checks
curl -X POST http://faucet-endpoint/fund \
  -H "Content-Type: application/json" \
  -d '{"address":"0x1","amount":1000}'

# With return_rejections_early: false, response reveals:
# {
#   "rejection_reasons": [
#     {"reason": "Magic header what_wallet_my_guy not found", "code": "MagicHeaderIncorrect"},
#     {"reason": "Auth token invalid", "code": "AuthTokenInvalid"},
#     {"reason": "IP in blocklist", "code": "IpInBlocklist"}
#   ]
# }
#
# Attacker now knows:
# 1. Need header "what_wallet_my_guy" (only need to brute-force value)
# 2. Need valid auth token
# 3. Must bypass IP blocklist
```

## Notes

While this is a valid Low severity information disclosure issue, it should be noted that:

1. The code includes intentional configuration options for this behavior, suggesting awareness of the tradeoff
2. The faucet is an auxiliary service for testnet/devnet, not mainnet infrastructure
3. This does not affect core blockchain security (consensus, execution, storage, governance, staking)
4. The recommended configuration (`return_rejections_early: true`) mitigates the aggregation issue

The primary concern is the hardcoded inclusion of `magic_header_key` in error messages, which occurs regardless of the `return_rejections_early` setting.

### Citations

**File:** crates/aptos-faucet/core/src/checkers/magic_header.rs (L36-40)
```rust
                return Ok(vec![RejectionReason::new(
                    format!("Magic header {} not found", self.config.magic_header_key),
                    RejectionReasonCode::MagicHeaderIncorrect,
                )])
            },
```

**File:** crates/aptos-faucet/core/src/checkers/magic_header.rs (L43-49)
```rust
            return Ok(vec![RejectionReason::new(
                format!(
                    "Magic header value wrong {} not found",
                    self.config.magic_header_key
                ),
                RejectionReasonCode::MagicHeaderIncorrect,
            )]);
```

**File:** crates/aptos-faucet/core/src/endpoints/errors.rs (L207-213)
```rust
    pub fn new(reason: String, code: RejectionReasonCode) -> Self {
        if *USE_HELPFUL_ERRORS.get().unwrap() {
            Self {
                reason,
                code,
                retry_after: None,
            }
```

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L261-270)
```rust
        // Ensure request passes checkers.
        let mut rejection_reasons = Vec::new();
        for checker in &self.checkers {
            rejection_reasons.extend(checker.check(checker_data.clone(), dry_run).await.map_err(
                |e| AptosTapError::new_with_error_code(e, AptosTapErrorCode::CheckerError),
            )?);
            if !rejection_reasons.is_empty() && self.return_rejections_early {
                break;
            }
        }
```

**File:** crates/aptos-faucet/core/src/server/run.rs (L43-47)
```rust
    /// Whether we should return rejections the moment a Checker returns any,
    /// or should instead run through all Checkers first. Generally prefer
    /// setting this to true, as it is less work on the tap, but setting it
    /// to false does give the user more immediate information.
    pub return_rejections_early: bool,
```
