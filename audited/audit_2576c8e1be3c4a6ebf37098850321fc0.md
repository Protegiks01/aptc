# Audit Report

## Title
Google reCAPTCHA Token Replay Attack in Faucet Due to Missing State Persistence

## Summary
The `GoogleCaptchaChecker` in the Aptos faucet service does not store any state after successful captcha verification, relying entirely on Google's external API to prevent token reuse. This creates a race condition window where an attacker can make multiple concurrent requests with the same valid captcha token, potentially bypassing captcha protection before Google marks the token as used.

## Finding Description

At line 107 in `google_captcha.rs`, after successful captcha verification, the function returns immediately without storing any state about the used token: [1](#0-0) 

This contrasts sharply with the `TapCaptchaChecker` implementation, which properly implements replay protection by removing used captcha challenges from storage: [2](#0-1) 

The codebase demonstrates proper replay attack prevention in the `ChallengeCache` implementation used elsewhere: [3](#0-2) 

The comment explicitly states the importance of consuming challenges to prevent replay attacks: [4](#0-3) 

**Attack Vector:**

1. Checkers execute sequentially in cost order, with GoogleCaptchaChecker (cost 10) running BEFORE rate limiters (cost 20-100): [5](#0-4) [6](#0-5) 

2. Multiple concurrent requests are processed independently through the checker pipeline: [7](#0-6) 

3. Each concurrent request validates the same captcha token with Google's API independently, creating a race condition window where multiple requests may succeed before Google marks the token as consumed.

The codebase even acknowledges similar race condition issues in the rate limiter: [8](#0-7) 

## Impact Explanation

This issue allows an attacker to bypass captcha protection by solving one captcha and making concurrent requests with the same token. While rate limiting by IP address still applies, the captcha's fundamental purpose—human verification to prevent automated abuse—is defeated. An attacker can drain the faucet more efficiently by reducing the number of captchas they need to solve.

However, this vulnerability affects only the **testnet faucet service**, which is an auxiliary utility for distributing test tokens, not the core Aptos blockchain protocol. The impact is limited to:
- Accelerated drainage of testnet funds (which have no real value)
- Potential faucet API overload if heavily exploited
- Degradation of testnet user experience

This does NOT affect consensus, Move VM execution, blockchain state integrity, validator operations, or any core protocol functionality.

## Likelihood Explanation

**High likelihood** - The attack is straightforward:
1. Requires only standard HTTP client capability for concurrent requests
2. No special privileges or validator access needed
3. Easy to automate with common tools
4. The race condition window exists in any network-based validation system

The issue is inherent to the architecture and will occur whenever concurrent requests are made with the same token.

## Recommendation

Implement local state tracking similar to `TapCaptchaChecker` and `ChallengeCache`. Store validated captcha tokens in memory (or Redis for distributed deployments) with TTL-based expiration:

```rust
// Add to CaptchaChecker struct
pub struct CaptchaChecker {
    config: GoogleCaptchaCheckerConfig,
    used_tokens: Arc<Mutex<LruCache<String, Instant>>>, // Track used tokens
}

// In check() method, after line 106:
if resp["success"].as_bool().unwrap_or(false) {
    // Store the token to prevent reuse
    let mut used_tokens = self.used_tokens.lock().await;
    let token_hash = sha256(captcha_token); // Hash for privacy
    
    // Check if already used
    if used_tokens.contains(&token_hash) {
        return Ok(vec![RejectionReason::new(
            "Captcha token already used".to_string(),
            RejectionReasonCode::CaptchaInvalid,
        )]);
    }
    
    // Mark as used
    used_tokens.put(token_hash, Instant::now());
    
    return Ok(vec![]);
}
```

Additionally, implement periodic cleanup of expired tokens (5-10 minute TTL) to prevent memory exhaustion.

## Proof of Concept

```rust
// Concurrent captcha replay attack simulation
#[tokio::test]
async fn test_captcha_replay_attack() {
    use reqwest::Client;
    use futures::future::join_all;
    
    let client = Client::new();
    let faucet_url = "http://faucet.testnet.aptoslabs.com/fund";
    
    // 1. Solve one captcha and get token
    let captcha_token = "valid_solved_captcha_token";
    let target_address = "0x1234567890abcdef";
    
    // 2. Make 10 concurrent requests with the same token
    let mut futures = vec![];
    for _ in 0..10 {
        let fut = client.post(faucet_url)
            .header("COMPLETED_CAPTCHA_TOKEN", captcha_token)
            .json(&serde_json::json!({
                "address": target_address,
                "amount": 100000000 // 1 APT
            }))
            .send();
        futures.push(fut);
    }
    
    // 3. Execute all requests concurrently
    let results = join_all(futures).await;
    
    // 4. Without proper state tracking, multiple requests may succeed
    let successful = results.iter()
        .filter(|r| r.as_ref().unwrap().status().is_success())
        .count();
    
    // Expected: 1 success (proper implementation)
    // Actual: Multiple successes (vulnerable implementation)
    assert_eq!(successful, 1, "Captcha replay attack succeeded: {} requests passed with same token", successful);
}
```

## Notes

While this vulnerability exists and demonstrates poor security practice (lack of defense-in-depth), its practical impact is limited because:

1. **Testnet Only**: The faucet distributes testnet tokens with no real-world value
2. **Rate Limiting Applies**: IP-based rate limiting still constrains total requests per day
3. **Not Core Protocol**: The faucet is auxiliary infrastructure, not part of the blockchain consensus, VM, or state management systems

The developers demonstrate understanding of replay protection elsewhere in the codebase (ChallengeCache, TapCaptcha), suggesting this is an oversight rather than a fundamental design flaw.

### Citations

**File:** crates/aptos-faucet/core/src/checkers/google_captcha.rs (L106-107)
```rust
            if resp["success"].as_bool().unwrap_or(false) {
                return Ok(vec![]);
```

**File:** crates/aptos-faucet/core/src/checkers/google_captcha.rs (L123-125)
```rust
    fn cost(&self) -> u8 {
        10
    }
```

**File:** crates/aptos-faucet/core/src/checkers/tap_captcha.rs (L165-177)
```rust
    pub fn check_challenge(&mut self, key: u32, value: &str) -> Result<bool> {
        match self.challenges.get(&key) {
            Some(captcha) => {
                if captcha == value {
                    self.challenges.remove(&key);
                    Ok(true)
                } else {
                    Ok(false)
                }
            },
            None => bail!("Captcha key unknown: {}", key),
        }
    }
```

**File:** crates/aptos-telemetry-service/src/challenge_cache.rs (L154-165)
```rust
    /// Verify and consume a challenge
    ///
    /// Returns Ok(()) if the challenge was valid and has been consumed.
    /// Returns Err with a message if the challenge is invalid or expired.
    ///
    /// IMPORTANT: This method consumes the challenge on success, preventing replay.
    pub fn verify_and_consume(
        &self,
        contract_name: &str,
        chain_id: &ChainId,
        address: &AccountAddress,
        challenge: &str,
```

**File:** crates/aptos-faucet/core/src/server/run.rs (L141-143)
```rust
        // Sort Checkers by cost, where lower numbers is lower cost, and lower
        // cost Checkers are at the start of the vec.
        checkers.sort_by_key(|a| a.cost());
```

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L261-270)
```rust
        // Ensure request passes checkers.
        let mut rejection_reasons = Vec::new();
        for checker in &self.checkers {
            rejection_reasons.extend(checker.check(checker_data.clone(), dry_run).await.map_err(
                |e| AptosTapError::new_with_error_code(e, AptosTapErrorCode::CheckerError),
            )?);
            if !rejection_reasons.is_empty() && self.return_rejections_early {
                break;
            }
        }
```

**File:** crates/aptos-faucet/core/src/checkers/redis_ratelimit.rs (L121-145)
```rust
/// If we're not careful, it is possible for people to exceed the intended limit
/// by sending many requests simultaneously. We avoid this problem with this
/// order of operations:
///   1. Read the current value of the limit for the given key (e.g. IP / Firebase UID).
///   2. If value is greater than limit, reject.
///   3. Otherwise, increment and set TTL if necessary.
///   4. Increment returns the new value. Check if this is greater than the limit also.
///
/// Incrementing the limit is an atomic operation (meaning each client will see
/// value increment, never reading the same value), so steps 1 and 2 are not
/// actually necessary for correctness. Instead, steps 1 and 2 are just an optimization
/// to avoid incrementing the limit unnecessarily if the limit has already been
/// reached. With steps 1 and 2 we end up having more unnecessary reads when
/// they're under their limit vs more unnecessary writes when they're over their
/// limit, but we'll happily take more reads over more writes.
///
/// Note: Previously I made an attempt (d4fbf6db675e9036a967b52bf8d13e1b2566787e) at
/// doing these steps atomically, but it became very unwieldy:
///   1. Start a transaction.
///   2. Increment current value for limit for source key, set TTL if necessary.
///   3. If value is greater than limit, revert the transaction.
///
/// This second way leaves a small window for someone to slip in multiple requests,
/// therein blowing past the configured limit, but it's a very small window, so we'll
/// worry about it as a followup: https://github.com/aptos-labs/aptos-tap/issues/15.
```
