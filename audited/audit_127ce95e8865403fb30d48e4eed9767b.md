# Audit Report

## Title
SafetyData Upgrade Test Fails to Cover Critical Safety Check Bypass During Mid-Epoch Upgrades

## Summary
The `test_safety_data_upgrade` test in `consensus/consensus-types/src/safety_data.rs` only validates basic deserialization compatibility but fails to test the most critical edge case: validators upgrading mid-epoch with active consensus state. When a validator upgrades from the old SafetyData format (without `one_chain_round` and `highest_timeout_round` fields) to the new format during an active epoch, these fields default to 0 despite the validator having been actively participating at much higher rounds. This creates a window where critical 2-chain consensus safety checks are effectively bypassed, potentially allowing the validator to sign invalid timeouts and order votes.

## Finding Description

The SafetyData structure uses `#[serde(default)]` to provide backward compatibility for the `one_chain_round` and `highest_timeout_round` fields, which were added for the 2-chain consensus protocol. [1](#0-0) 

The upgrade test creates an OldSafetyData structure with minimal values and verifies deserialization works, but does NOT test realistic upgrade scenarios. [2](#0-1) 

**The Critical Untested Path:**

When a validator operating at high rounds (e.g., epoch 5, round 1000) upgrades its software mid-epoch, the persistent storage contains:
- `epoch: 5`
- `last_voted_round: 1000` 
- `preferred_round: 999`
- `last_vote: Some(Vote)`

After deserialization with the new code:
- `one_chain_round: 0` (should be ~999-1000)
- `highest_timeout_round: 0` (should be last timeout round, potentially ~900-950)

**Safety Check Bypass #1 - Timeout Safety:**

The `safe_to_timeout` function enforces the 2-chain timeout safety rule requiring `qc_round >= safety_data.one_chain_round`. [3](#0-2) 

With `one_chain_round = 0` after upgrade, this check accepts ANY QC round >= 0, allowing the validator to sign timeouts for QCs that don't meet the 2-chain safety requirement. A malicious actor could send a timeout proposal at round 1001 with a QC for round 100 (which is << preferred_round 999), and this would incorrectly pass the safety check because `100 >= 0`.

**Safety Check Bypass #2 - Order Vote Safety:**

The `safe_for_order_vote` function prevents signing order votes for rounds where timeouts were already signed. [4](#0-3) 

With `highest_timeout_round = 0` after upgrade, this check accepts ANY round > 0, potentially allowing double-signing if the validator had previously timed out at higher rounds before the upgrade.

**Why This Breaks Consensus Safety:**

The 2-chain protocol's safety guarantees depend on validators maintaining accurate state about:
1. The highest 1-chain round observed (`one_chain_round`) - used to ensure timeouts don't regress
2. The highest timeout round (`highest_timeout_round`) - used to prevent conflicting order votes

When these values reset to 0 mid-epoch, the validator temporarily loses memory of its consensus commitments, creating a window where it may sign messages that violate 2-chain safety invariants. While the values will be updated as the validator processes new QCs and timeouts via `observe_qc()` and `update_highest_timeout_round()`, the window between restart and recovery is exploitable. [5](#0-4) [6](#0-5) 

## Impact Explanation

This qualifies as **Medium Severity** under the Aptos bug bounty criteria for "State inconsistencies requiring intervention."

**Affected Components:**
- All validators performing mid-epoch software upgrades
- 2-chain consensus safety guarantees
- Timeout and order vote signing logic

**Potential Consequences:**
1. **Consensus Safety Degradation**: Validators may sign conflicting messages during the vulnerability window
2. **Equivocation Risk**: If multiple validators upgrade simultaneously, coordinated Byzantine actors could exploit the weakened safety checks to cause validators to double-sign
3. **Chain Fork Risk**: In adversarial conditions with precisely timed attacks, this could contribute to temporary consensus disagreement
4. **Operational Intervention**: Network operators may need to coordinate upgrade timing or implement safeguards

While this doesn't guarantee a consensus break (other safety mechanisms remain active), it weakens critical defense-in-depth protections during a sensitive operational window. The impact is limited by:
- The vulnerability window self-corrects after processing legitimate consensus messages
- Other safety checks (epoch verification, last_voted_round, preferred_round) remain intact
- Requires Byzantine actors to send malicious proposals during the window
- Requires multiple validators to upgrade near-simultaneously for maximum impact

## Likelihood Explanation

**Likelihood: Medium to High**

This vulnerability WILL occur on every mid-epoch validator upgrade, making it deterministic rather than probabilistic. However, successful exploitation requires:

1. **Guaranteed Trigger**: Any validator upgrading from old SafetyData format to new format mid-epoch (100% occurrence during upgrade cycles)
2. **Exploitation Window**: Narrow window between node restart and processing first QC/timeout (seconds to minutes)
3. **Attacker Requirements**: Byzantine actor with ability to send malicious timeout/order vote proposals (moderate barrier)
4. **Network Conditions**: Most impactful during coordinated upgrade rollouts across multiple validators

The test's failure to cover this edge case means this issue could go undetected until production deployment, where upgrade cycles are common operational events. Given the inevitability of mid-epoch upgrades in production networks, the likelihood of this creating exploitable conditions is significant.

## Recommendation

**1. Enhance the upgrade test to cover realistic scenarios:**

```rust
#[test]
fn test_safety_data_upgrade_with_active_state() {
    #[derive(Debug, Deserialize, Eq, PartialEq, Serialize, Clone)]
    struct OldSafetyData {
        pub epoch: u64,
        pub last_voted_round: u64,
        pub preferred_round: u64,
        pub last_vote: Option<Vote>,
    }
    
    // Simulate validator at high rounds (realistic mid-epoch state)
    let old_data = OldSafetyData {
        epoch: 5,
        last_voted_round: 1000,
        preferred_round: 999,
        last_vote: Some(make_test_vote(1000)),
    };
    
    let value = serde_json::to_value(old_data).unwrap();
    let new_data: SafetyData = serde_json::from_value(value).unwrap();
    
    // CRITICAL: Verify safety checks aren't bypassed
    assert_eq!(new_data.epoch, 5);
    assert_eq!(new_data.last_voted_round, 1000);
    assert_eq!(new_data.preferred_round, 999);
    
    // These should NOT be 0 - this is the vulnerability
    // Without migration logic, this test would fail
    assert!(new_data.one_chain_round >= new_data.preferred_round,
        "one_chain_round must be >= preferred_round to maintain safety");
    assert!(new_data.highest_timeout_round < new_data.last_voted_round,
        "highest_timeout_round must be consistent with last_voted_round");
}
```

**2. Implement migration logic to preserve safety invariants:**

```rust
impl SafetyData {
    pub fn migrate_from_old_format(self) -> Self {
        let mut migrated = self;
        
        // If one_chain_round is 0 but we have active state, it's a fresh upgrade
        if migrated.one_chain_round == 0 && migrated.last_voted_round > 0 {
            // Conservative approach: set one_chain_round to preferred_round
            // This maintains safety by requiring future QCs to be >= the last known 2-chain
            migrated.one_chain_round = migrated.preferred_round;
        }
        
        // highest_timeout_round can stay at 0 - conservative (allows all order votes)
        // This is safe because we err on the side of being more permissive
        
        migrated
    }
}
```

**3. Call migration logic in persistent storage layer:**

```rust
pub fn safety_data(&mut self) -> Result<SafetyData, Error> {
    let mut safety_data = if !self.enable_cached_safety_data {
        self.internal_store.get(SAFETY_DATA).map(|v| v.value)?
    } else {
        // ... existing cache logic ...
    };
    
    // Apply migration if needed
    if safety_data.one_chain_round == 0 && safety_data.last_voted_round > 0 {
        safety_data = safety_data.migrate_from_old_format();
        // Persist the migrated data
        self.set_safety_data(safety_data.clone())?;
    }
    
    Ok(safety_data)
}
```

## Proof of Concept

```rust
#[test]
fn test_safety_check_bypass_after_upgrade() {
    use aptos_consensus_types::{
        safety_data::SafetyData,
        timeout_2chain::TwoChainTimeout,
        quorum_cert::QuorumCert,
    };
    
    // Simulate old format deserialization at high rounds
    #[derive(Serialize, Deserialize)]
    struct OldSafetyData {
        epoch: u64,
        last_voted_round: u64,
        preferred_round: u64,
        last_vote: Option<Vote>,
    }
    
    let old = OldSafetyData {
        epoch: 5,
        last_voted_round: 1000,
        preferred_round: 999,
        last_vote: None,
    };
    
    // Deserialize to new format
    let json = serde_json::to_string(&old).unwrap();
    let new: SafetyData = serde_json::from_str(&json).unwrap();
    
    // Demonstrate the vulnerability: critical fields are 0
    assert_eq!(new.one_chain_round, 0);
    assert_eq!(new.highest_timeout_round, 0);
    
    // Create a timeout with QC round far below preferred_round
    // This SHOULD fail safe_to_timeout, but WILL PASS due to one_chain_round=0
    let malicious_timeout = create_timeout(
        /* round */ 1001,
        /* qc_round */ 100,  // << preferred_round (999)
        /* epoch */ 5
    );
    
    // The safety check: qc_round >= one_chain_round
    // Should be: 100 >= 999 (FAIL)
    // Actually is: 100 >= 0 (PASS) - VULNERABILITY!
    assert!(malicious_timeout.hqc_round() >= new.one_chain_round,
        "Safety check bypassed: low QC round passes due to one_chain_round=0");
    
    // Similarly for order votes: round > highest_timeout_round  
    // Should require round > last_actual_timeout
    // Actually only requires: round > 0 - VULNERABILITY!
    let malicious_order_vote_round = 1;  // Any round > 0 passes
    assert!(malicious_order_vote_round > new.highest_timeout_round,
        "Order vote safety bypassed: any round > 0 passes due to highest_timeout_round=0");
}
```

## Notes

The vulnerability exists because backward compatibility via `#[serde(default)]` prioritizes deployability over safety preservation. While epoch changes reset SafetyData completely (which is safe), mid-epoch upgrades create an inconsistent state where some fields reflect the validator's actual history while others are artificially reset. The test suite's failure to cover this realistic scenario means the vulnerability could persist undetected into production deployments.

### Citations

**File:** consensus/consensus-types/src/safety_data.rs (L16-20)
```rust
    #[serde(default)]
    pub one_chain_round: u64,
    pub last_vote: Option<Vote>,
    #[serde(default)]
    pub highest_timeout_round: u64,
```

**File:** consensus/consensus-types/src/safety_data.rs (L53-70)
```rust
#[test]
fn test_safety_data_upgrade() {
    #[derive(Debug, Deserialize, Eq, PartialEq, Serialize, Clone, Default)]
    struct OldSafetyData {
        pub epoch: u64,
        pub last_voted_round: u64,
        pub preferred_round: u64,
        pub last_vote: Option<Vote>,
    }
    let old_data = OldSafetyData {
        epoch: 1,
        last_voted_round: 10,
        preferred_round: 100,
        last_vote: None,
    };
    let value = serde_json::to_value(old_data).unwrap();
    let _: SafetyData = serde_json::from_value(value).unwrap();
}
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L121-145)
```rust
    /// Core safety timeout rule for 2-chain protocol. Return success if 1 and 2 are true
    /// 1. round == timeout.qc.round + 1 || round == tc.round + 1
    /// 2. timeout.qc.round >= one_chain_round
    fn safe_to_timeout(
        &self,
        timeout: &TwoChainTimeout,
        maybe_tc: Option<&TwoChainTimeoutCertificate>,
        safety_data: &SafetyData,
    ) -> Result<(), Error> {
        let round = timeout.round();
        let qc_round = timeout.hqc_round();
        let tc_round = maybe_tc.map_or(0, |tc| tc.round());
        if (round == next_round(qc_round)? || round == next_round(tc_round)?)
            && qc_round >= safety_data.one_chain_round
        {
            Ok(())
        } else {
            Err(Error::NotSafeToTimeout(
                round,
                qc_round,
                tc_round,
                safety_data.one_chain_round,
            ))
        }
    }
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L168-178)
```rust
    fn safe_for_order_vote(&self, block: &Block, safety_data: &SafetyData) -> Result<(), Error> {
        let round = block.round();
        if round > safety_data.highest_timeout_round {
            Ok(())
        } else {
            Err(Error::NotSafeForOrderVote(
                round,
                safety_data.highest_timeout_round,
            ))
        }
    }
```

**File:** consensus/safety-rules/src/safety_rules.rs (L135-156)
```rust
    pub(crate) fn observe_qc(&self, qc: &QuorumCert, safety_data: &mut SafetyData) -> bool {
        let mut updated = false;
        let one_chain = qc.certified_block().round();
        let two_chain = qc.parent_block().round();
        if one_chain > safety_data.one_chain_round {
            safety_data.one_chain_round = one_chain;
            trace!(
                SafetyLogSchema::new(LogEntry::OneChainRound, LogEvent::Update)
                    .preferred_round(safety_data.one_chain_round)
            );
            updated = true;
        }
        if two_chain > safety_data.preferred_round {
            safety_data.preferred_round = two_chain;
            trace!(
                SafetyLogSchema::new(LogEntry::PreferredRound, LogEvent::Update)
                    .preferred_round(safety_data.preferred_round)
            );
            updated = true;
        }
        updated
    }
```

**File:** consensus/safety-rules/src/safety_rules.rs (L158-170)
```rust
    pub(crate) fn update_highest_timeout_round(
        &self,
        timeout: &TwoChainTimeout,
        safety_data: &mut SafetyData,
    ) {
        if timeout.round() > safety_data.highest_timeout_round {
            safety_data.highest_timeout_round = timeout.round();
            trace!(
                SafetyLogSchema::new(LogEntry::HighestTimeoutRound, LogEvent::Update)
                    .highest_timeout_round(safety_data.highest_timeout_round)
            );
        }
    }
```
