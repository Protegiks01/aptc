# Audit Report

## Title
State-Sync Request Overwrite Causes Lost Consensus Notifications

## Summary
The `initialize_sync_duration_request()` and `initialize_sync_target_request()` functions in the state-sync driver unconditionally overwrite existing active sync requests without responding to their notification callbacks. This causes consensus to receive errors instead of successful completion notifications, potentially leaving the consensus observer in a broken state.

## Finding Description

The state-sync driver maintains a single `consensus_sync_request` field to track active sync requests from consensus. When consensus sends a sync request (either sync-for-duration or sync-to-target), the driver stores the request along with a oneshot callback channel that consensus is waiting on for the response. [1](#0-0) 

The critical vulnerability occurs when a new sync request arrives while another is still active. The code directly overwrites `self.consensus_sync_request` by creating a new `Arc::new(Mutex::new(Some(...)))`, replacing the old one. When the old Arc is dropped, the notification callback inside it is also dropped without being used. [2](#0-1) 

The same issue exists in `initialize_sync_target_request()` which also unconditionally overwrites at line 315.

On the consensus side, when the oneshot callback sender is dropped, the receiver gets a `RecvError`. This propagates as an `Error::UnexpectedErrorEncountered`: [3](#0-2) 

When consensus observer receives this error from `sync_for_duration()`, it logs the error and returns without sending the fallback completion notification: [4](#0-3) 

This breaks the critical invariant that consensus and state-sync must maintain coordinated state. The consensus observer remains stuck waiting for a sync completion that will never arrive, while state-sync proceeds with the new request, creating a desynchronization between the two components.

**Realistic Scenario:**
1. Consensus observer enters fallback mode and sends `sync_for_duration()` request
2. State-sync driver stores this request and begins syncing
3. Before the duration expires, consensus observer receives a commit decision from peers
4. Consensus observer sends `sync_to_target()` to sync to the specific commit
5. State-sync driver receives the second request and overwrites the first at line 315
6. The first request's callback is dropped, causing consensus to receive an error
7. Consensus observer fails to complete the fallback sync properly
8. State continues with the second request, but consensus coordination is broken

This scenario is realistic and can occur during normal network operation when the consensus observer needs to transition between different sync modes.

## Impact Explanation

This qualifies as **High Severity** based on the Aptos bug bounty criteria:

- **Significant protocol violations**: The coordination protocol between consensus and state-sync is violated when notifications are lost. Consensus expects responses to all sync requests, and dropping callbacks without response breaks this contract.

- **Validator node slowdowns**: The consensus observer may become stuck or behave erratically when it doesn't receive expected sync completion notifications, degrading node performance.

The issue affects the availability and reliability of the consensus observer, which is critical for node operation. While it doesn't directly cause fund loss or consensus safety violations, it can cause nodes to fail to participate properly in consensus, affecting network availability.

## Likelihood Explanation

**Likelihood: Medium-High**

This can occur naturally during normal operation without requiring any malicious behavior:

- Consensus observer frequently transitions between sync modes (fallback, sync-to-target)
- Network conditions and timing can cause multiple sync requests to be queued
- The state-sync driver processes notifications sequentially, so rapid transitions in consensus observer state can trigger this issue
- No validation exists in the driver to prevent or detect this scenario

The driver code path shows no checks for existing active requests before initialization: [5](#0-4) [6](#0-5) 

Both handlers directly call the initialization functions without checking `active_sync_request()`.

## Recommendation

Add validation to prevent overwriting active requests. Before initializing a new sync request, check if one already exists and either:

1. **Reject the new request with an error response** (preferred):
   - Check if `self.consensus_sync_request.lock().is_some()` before initialization
   - If an active request exists, respond to the new request with an error immediately
   - This ensures consensus is always notified and prevents request loss

2. **Complete the old request first**:
   - Respond to the old request's callback with an error indicating it was superseded
   - Then proceed with the new request
   - This ensures both requests receive responses

**Suggested fix for `initialize_sync_duration_request()`:**

```rust
pub async fn initialize_sync_duration_request(
    &mut self,
    sync_duration_notification: ConsensusSyncDurationNotification,
) -> Result<(), Error> {
    // Check if there's already an active sync request
    if self.consensus_sync_request.lock().is_some() {
        let error = Err(Error::UnexpectedErrorEncountered(
            "Cannot start new sync duration request while another sync request is active".to_string()
        ));
        self.respond_to_sync_duration_notification(
            sync_duration_notification,
            error.clone(),
            None,
        )?;
        return error;
    }

    // Get the current time
    let start_time = self.time_service.now();

    // Save the request so we can notify consensus once we've hit the duration
    let consensus_sync_request =
        ConsensusSyncRequest::new_with_duration(start_time, sync_duration_notification);
    self.consensus_sync_request = Arc::new(Mutex::new(Some(consensus_sync_request)));

    Ok(())
}
```

Apply the same fix to `initialize_sync_target_request()`.

## Proof of Concept

```rust
// Rust test demonstrating the vulnerability
#[tokio::test]
async fn test_sync_request_overwrite_bug() {
    use aptos_consensus_notifications::{ConsensusNotificationSender, new_consensus_notifier_listener_pair};
    use std::time::Duration;
    
    // Create consensus notifier and listener
    let (consensus_notifier, consensus_listener) = 
        new_consensus_notifier_listener_pair(5000);
    
    // Create notification handler
    let time_service = TimeService::mock();
    let mut handler = ConsensusNotificationHandler::new(
        consensus_listener,
        time_service,
    );
    
    // Send first sync duration request
    let first_request = tokio::spawn(async move {
        consensus_notifier.sync_for_duration(Duration::from_secs(10)).await
    });
    
    // Allow first request to be initialized
    tokio::time::sleep(Duration::from_millis(100)).await;
    
    // Create second notifier for second request
    let (consensus_notifier2, consensus_listener2) = 
        new_consensus_notifier_listener_pair(5000);
    
    // Send second sync duration request (this will overwrite the first)
    let notification = ConsensusSyncDurationNotification::new(Duration::from_secs(5));
    handler.initialize_sync_duration_request(notification.0).await.unwrap();
    
    // Wait for first request to complete
    let result = first_request.await.unwrap();
    
    // First request should receive an error because its callback was dropped
    assert!(result.is_err(), "First request should fail due to dropped callback");
    assert!(matches!(result, Err(Error::UnexpectedErrorEncountered(_))));
    
    // This demonstrates the bug: consensus receives an error instead of 
    // a successful completion, leaving it in an inconsistent state
}
```

## Notes

This vulnerability exists due to missing request lifecycle management in the state-sync driver. The driver assumes only one sync request will be active at a time, but provides no enforcement of this invariant. Consensus observer can legitimately send multiple requests during state transitions, and the driver must handle this gracefully rather than silently dropping notifications.

### Citations

**File:** state-sync/state-sync-driver/src/notification_handlers.rs (L246-259)
```rust
    pub async fn initialize_sync_duration_request(
        &mut self,
        sync_duration_notification: ConsensusSyncDurationNotification,
    ) -> Result<(), Error> {
        // Get the current time
        let start_time = self.time_service.now();

        // Save the request so we can notify consensus once we've hit the duration
        let consensus_sync_request =
            ConsensusSyncRequest::new_with_duration(start_time, sync_duration_notification);
        self.consensus_sync_request = Arc::new(Mutex::new(Some(consensus_sync_request)));

        Ok(())
    }
```

**File:** state-sync/state-sync-driver/src/notification_handlers.rs (L312-318)
```rust
        // Save the request so we can notify consensus once we've hit the target
        let consensus_sync_request =
            ConsensusSyncRequest::new_with_target(sync_target_notification);
        self.consensus_sync_request = Arc::new(Mutex::new(Some(consensus_sync_request)));

        Ok(())
    }
```

**File:** state-sync/inter-component/consensus-notifications/src/lib.rs (L162-178)
```rust
        match callback_receiver.await {
            Ok(response) => match response.get_result() {
                Ok(_) => response.get_latest_synced_ledger_info().ok_or_else(|| {
                    Error::UnexpectedErrorEncountered(
                        "Sync for duration returned an empty latest synced ledger info!".into(),
                    )
                }),
                Err(error) => Err(Error::UnexpectedErrorEncountered(format!(
                    "Sync for duration returned an error: {:?}",
                    error
                ))),
            },
            Err(error) => Err(Error::UnexpectedErrorEncountered(format!(
                "Sync for duration failure: {:?}",
                error
            ))),
        }
```

**File:** consensus/src/consensus_observer/observer/state_sync_manager.rs (L150-161)
```rust
                let latest_synced_ledger_info = match execution_client
                    .clone()
                    .sync_for_duration(fallback_duration)
                    .await
                {
                    Ok(latest_synced_ledger_info) => latest_synced_ledger_info,
                    Err(error) => {
                        error!(LogSchema::new(LogEntry::ConsensusObserver)
                            .message(&format!("Failed to sync for fallback! Error: {:?}", error)));
                        return;
                    },
                };
```

**File:** state-sync/state-sync-driver/src/driver.rs (L401-405)
```rust
        // Initialize a new sync request
        self.consensus_notification_handler
            .initialize_sync_duration_request(sync_duration_notification)
            .await
    }
```

**File:** state-sync/state-sync-driver/src/driver.rs (L434-442)
```rust
        // Initialize a new sync request
        self.consensus_notification_handler
            .initialize_sync_target_request(
                sync_target_notification,
                latest_pre_committed_version,
                latest_synced_ledger_info,
            )
            .await
    }
```
