# Audit Report

## Title
Validator Fingerprinting via Unauthenticated Inspection Service Endpoints Enables Targeted Reconnaissance Attacks

## Summary
The Aptos inspection service exposes multiple HTTP endpoints without authentication or rate limiting, allowing attackers to fingerprint validator hardware, identify consensus roles, and map network topology through response timing/size analysis and direct information disclosure. This enables targeted attacks on specific validators.

## Finding Description

The inspection service endpoints expose sensitive information that allows complete validator fingerprinting: [1](#0-0) 

The service binds to a publicly accessible address by default (0.0.0.0:9101) with no authentication mechanism: [2](#0-1) 

**Attack Vector 1: Hardware Fingerprinting via `/system_information`**

The system information endpoint exposes complete hardware specifications including CPU brand, vendor, frequency, core count, and memory details: [3](#0-2) 

**Attack Vector 2: Validator Role Identification via `/metrics`**

Validators expose consensus-specific metrics that fullnodes do not have. The metrics encoder processes ALL Prometheus metrics: [4](#0-3) 

Consensus metrics like `aptos_consensus_proposals_count`, `aptos_consensus_vote_nil_count`, and `aptos_consensus_last_committed_round` only exist on validators: [5](#0-4) 

**Attack Vector 3: Response Timing/Size Analysis**

The metrics gathering process measures total bytes and warns about large metric families, creating timing variations: [6](#0-5) 

Validators have significantly more metrics than fullnodes (consensus metrics, voting metrics, proposal metrics), causing detectable size differences.

**Attack Vector 4: Network Topology via `/peer_information`**

The peer information endpoint exposes complete network topology including trusted validators and connection metadata: [7](#0-6) 

**No Rate Limiting or Authentication**

The service handles requests without any rate limiting or authentication checks: [8](#0-7) 

**Exploitation Scenario:**

1. Attacker scans network for inspection service ports (9101)
2. Queries `/system_information` to fingerprint exact hardware (CPU model, RAM, disk type)
3. Queries `/metrics` repeatedly to:
   - Identify validators (presence of consensus metrics)
   - Measure response timing variations (hardware performance profiling)
   - Detect response size differences (metric count reveals node role)
4. Queries `/identity_information` and `/peer_information` to map network topology
5. Uses fingerprinting data to:
   - Target validators with weaker hardware for resource exhaustion
   - Identify geographic location via hostname/networking patterns
   - Prioritize attacks on high-stake validators
   - Plan eclipse attacks by mapping peer connections

## Impact Explanation

**Medium Severity** per Aptos bug bounty criteria. This vulnerability enables:

1. **Targeted Validator Attacks**: Adversaries can identify and profile specific validators to focus attacks on high-value targets or nodes with vulnerable hardware configurations.

2. **Network Topology Reconnaissance**: Complete mapping of validator network enables sophisticated eclipse attacks and network partition strategies.

3. **Hardware-Specific Exploits**: Knowledge of exact CPU models and memory configurations enables attackers to craft hardware-specific timing attacks or resource exhaustion exploits.

4. **Consensus Role Profiling**: Identifying which validators are actively proposing blocks enables targeted DoS during critical consensus rounds.

While this doesn't directly compromise consensus safety or cause fund loss, it significantly reduces the attack surface complexity for subsequent exploitation attempts. The lack of any protective measures (authentication, rate limiting, IP filtering) on publicly exposed endpoints violates defense-in-depth principles.

## Likelihood Explanation

**High Likelihood**: The attack requires no special privileges, cryptographic operations, or complex exploitation. Any network-accessible attacker can:
- Query publicly exposed endpoints
- Perform unlimited reconnaissance (no rate limits)
- Obtain complete hardware and network fingerprints in seconds

The default configuration exposes these endpoints on all interfaces (0.0.0.0), making them discoverable through standard port scans. While mainnet validators have some protection for configuration endpoints, metrics and system information remain fully exposed: [9](#0-8) 

## Recommendation

Implement defense-in-depth security for the inspection service:

1. **Add Authentication**: Require authentication tokens for sensitive endpoints
2. **Implement Rate Limiting**: Prevent unlimited reconnaissance queries
3. **Network Restrictions**: Bind to localhost by default for validators, or restrict to trusted IP ranges
4. **Minimize Information Exposure**: Remove or aggregate metrics that uniquely identify validators
5. **Configuration Hardening**: Default to minimal exposure on mainnet validators

**Proposed Fix** for `inspection_service_config.rs`:

```rust
impl Default for InspectionServiceConfig {
    fn default() -> InspectionServiceConfig {
        InspectionServiceConfig {
            address: "127.0.0.1".to_string(), // Bind to localhost by default
            port: 9101,
            expose_configuration: false,
            expose_identity_information: false, // Disable by default
            expose_peer_information: false, // Disable by default  
            expose_system_information: false, // Disable by default
            require_authentication: true, // New field
            rate_limit_requests_per_minute: 60, // New field
        }
    }
}
```

Additionally, add authentication middleware in the server handler and filter sensitive metrics before exposure.

## Proof of Concept

**Fingerprinting Script** (Python):

```python
import requests
import time
import json

def fingerprint_validator(target_ip, port=9101):
    base_url = f"http://{target_ip}:{port}"
    fingerprint = {}
    
    # 1. Get hardware specs
    try:
        resp = requests.get(f"{base_url}/system_information", timeout=2)
        system_info = resp.json()
        fingerprint['hardware'] = {
            'cpu_brand': system_info.get('cpu_brand'),
            'cpu_cores': system_info.get('cpu_core_count'),
            'memory_total': system_info.get('memory_total'),
            'hostname': system_info.get('system_host_name')
        }
    except:
        pass
    
    # 2. Detect validator role via metrics
    start_time = time.time()
    try:
        resp = requests.get(f"{base_url}/json_metrics", timeout=5)
        metrics_time = time.time() - start_time
        metrics = resp.json()
        
        # Check for validator-specific metrics
        is_validator = any(k.startswith('aptos_consensus_proposals') for k in metrics)
        
        fingerprint['role'] = 'validator' if is_validator else 'fullnode'
        fingerprint['metrics_count'] = len(metrics)
        fingerprint['response_time'] = metrics_time
        fingerprint['response_size'] = len(resp.content)
        
        # Extract consensus metrics if validator
        if is_validator:
            fingerprint['consensus'] = {
                k: v for k, v in metrics.items() 
                if 'consensus' in k
            }
    except:
        pass
    
    # 3. Get network topology
    try:
        resp = requests.get(f"{base_url}/peer_information", timeout=5)
        peer_info = resp.text
        fingerprint['peer_count'] = peer_info.count('Peer:')
    except:
        pass
    
    return fingerprint

# Scan multiple targets
targets = ['validator1.example.com', 'validator2.example.com']
for target in targets:
    print(f"\n[+] Fingerprinting {target}...")
    profile = fingerprint_validator(target)
    print(json.dumps(profile, indent=2))
    
    if profile.get('role') == 'validator':
        print(f"[!] VALIDATOR IDENTIFIED: {target}")
        print(f"    Hardware: {profile.get('hardware', {}).get('cpu_brand')}")
        print(f"    Metrics: {profile.get('metrics_count')} exposed")
```

**Expected Output:**
```
[+] Fingerprinting validator1.example.com...
{
  "hardware": {
    "cpu_brand": "Intel(R) Xeon(R) CPU E5-2686 v4 @ 2.30GHz",
    "cpu_cores": "16",
    "memory_total": "67108864",
    "hostname": "ip-10-0-1-100"
  },
  "role": "validator",
  "metrics_count": 2847,
  "response_time": 0.234,
  "response_size": 245678
}
[!] VALIDATOR IDENTIFIED: validator1.example.com
    Hardware: Intel(R) Xeon(R) CPU E5-2686 v4 @ 2.30GHz
    Metrics: 2847 exposed
```

This demonstrates complete validator fingerprinting enabling targeted attacks.

### Citations

**File:** crates/aptos-inspection-service/src/server/mod.rs (L50-101)
```rust
pub fn start_inspection_service(
    node_config: NodeConfig,
    aptos_data_client: AptosDataClient,
    peers_and_metadata: Arc<PeersAndMetadata>,
) {
    // Fetch the service port and address
    let service_port = node_config.inspection_service.port;
    let service_address = node_config.inspection_service.address.clone();

    // Create the inspection service socket address
    let address: SocketAddr = (service_address.as_str(), service_port)
        .to_socket_addrs()
        .unwrap_or_else(|_| {
            panic!(
                "Failed to parse {}:{} as address",
                service_address, service_port
            )
        })
        .next()
        .unwrap();

    // Create a runtime for the inspection service
    let runtime = aptos_runtimes::spawn_named_runtime("inspection".into(), None);

    // Spawn the inspection service
    thread::spawn(move || {
        // Create the service function that handles the endpoint requests
        let make_service = make_service_fn(move |_conn| {
            let node_config = node_config.clone();
            let aptos_data_client = aptos_data_client.clone();
            let peers_and_metadata = peers_and_metadata.clone();
            async move {
                Ok::<_, Infallible>(service_fn(move |request| {
                    serve_requests(
                        request,
                        node_config.clone(),
                        aptos_data_client.clone(),
                        peers_and_metadata.clone(),
                    )
                }))
            }
        });

        // Start and block on the server
        runtime
            .block_on(async {
                let server = Server::bind(&address).serve(make_service);
                server.await
            })
            .unwrap();
    });
}
```

**File:** crates/aptos-inspection-service/src/server/mod.rs (L103-198)
```rust
/// A simple helper function that handles each endpoint request
async fn serve_requests(
    req: Request<Body>,
    node_config: NodeConfig,
    aptos_data_client: AptosDataClient,
    peers_and_metadata: Arc<PeersAndMetadata>,
) -> Result<Response<Body>, hyper::Error> {
    // Process the request and get the response components
    let (status_code, body, content_type) = match req.uri().path() {
        CONFIGURATION_PATH => {
            // /configuration
            // Exposes the node configuration
            configuration::handle_configuration_request(&node_config)
        },
        CONSENSUS_HEALTH_CHECK_PATH => {
            // /consensus_health_check
            // Exposes the consensus health check
            metrics::handle_consensus_health_check(&node_config).await
        },
        FORGE_METRICS_PATH => {
            // /forge_metrics
            // Exposes forge encoded metrics
            metrics::handle_forge_metrics()
        },
        IDENTITY_INFORMATION_PATH => {
            // /identity_information
            // Exposes the identity information of the node
            identity_information::handle_identity_information_request(&node_config)
        },
        INDEX_PATH => {
            // /
            // Exposes the index and list of available endpoints
            index::handle_index_request()
        },
        JSON_METRICS_PATH => {
            // /json_metrics
            // Exposes JSON encoded metrics
            metrics::handle_json_metrics_request()
        },
        METRICS_PATH => {
            // /metrics
            // Exposes text encoded metrics
            metrics::handle_metrics_request()
        },
        PEER_INFORMATION_PATH => {
            // /peer_information
            // Exposes the peer information
            peer_information::handle_peer_information_request(
                &node_config,
                aptos_data_client,
                peers_and_metadata,
            )
        },
        SYSTEM_INFORMATION_PATH => {
            // /system_information
            // Exposes the system and build information
            system_information::handle_system_information_request(node_config)
        },
        _ => {
            // Handle the invalid path
            (
                StatusCode::NOT_FOUND,
                Body::from(INVALID_ENDPOINT_MESSAGE),
                CONTENT_TYPE_TEXT.into(),
            )
        },
    };

    // Create a response builder
    let response_builder = Response::builder()
        .header(HEADER_CONTENT_TYPE, content_type)
        .status(status_code);

    // Build the response based on the request methods
    let response = match *req.method() {
        Method::HEAD => response_builder.body(Body::empty()), // Return only the headers
        Method::GET => response_builder.body(body),           // Include the response body
        _ => {
            // Invalid method found
            Response::builder()
                .status(StatusCode::METHOD_NOT_ALLOWED)
                .body(Body::empty())
        },
    };

    // Return the processed response
    Ok(response.unwrap_or_else(|error| {
        // Log the internal error
        debug!("Error encountered when generating response: {:?}", error);

        // Return a failure response
        let mut response = Response::new(Body::from(UNEXPECTED_ERROR_MESSAGE));
        *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
        response
    }))
}
```

**File:** config/src/config/inspection_service_config.rs (L26-37)
```rust
impl Default for InspectionServiceConfig {
    fn default() -> InspectionServiceConfig {
        InspectionServiceConfig {
            address: "0.0.0.0".to_string(),
            port: 9101,
            expose_configuration: false,
            expose_identity_information: true,
            expose_peer_information: true,
            expose_system_information: true,
        }
    }
}
```

**File:** config/src/config/inspection_service_config.rs (L54-68)
```rust
        // Verify that mainnet validators do not expose the configuration
        if let Some(chain_id) = chain_id {
            if node_type.is_validator()
                && chain_id.is_mainnet()
                && inspection_service_config.expose_configuration
            {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "Mainnet validators should not expose the node configuration!".to_string(),
                ));
            }
        }

        Ok(())
    }
```

**File:** crates/aptos-telemetry/src/system_information.rs (L70-93)
```rust
/// Collects the cpu info and appends it to the given map
fn collect_cpu_info(
    system_information: &mut BTreeMap<String, String>,
    system: &Lazy<Mutex<System>>,
) {
    // Collect the number of CPUs and cores
    let system_lock = system.lock();
    let cpus = system_lock.cpus();
    system_information.insert(CPU_COUNT.into(), cpus.len().to_string());
    utils::insert_optional_value(
        system_information,
        CPU_CORE_COUNT,
        system_lock
            .physical_core_count()
            .map(|count| count.to_string()),
    );

    // Collect the overall CPU info
    let global_cpu = system_lock.global_cpu_info();
    system_information.insert(CPU_BRAND.into(), global_cpu.brand().into());
    system_information.insert(CPU_FREQUENCY.into(), global_cpu.frequency().to_string());
    system_information.insert(CPU_NAME.into(), global_cpu.name().into());
    system_information.insert(CPU_VENDOR_ID.into(), global_cpu.vendor_id().into());
}
```

**File:** crates/aptos-inspection-service/src/server/json_encoder.rs (L24-75)
```rust
    fn encode<W: Write>(&self, metric_families: &[MetricFamily], writer: &mut W) -> Result<()> {
        let mut encoded_metrics: HashMap<String, f64> = HashMap::new();

        // Go through each metric family and encode it
        for metric_family in metric_families {
            let name = metric_family.get_name();
            let metric_type = metric_family.get_field_type();
            for metric in metric_family.get_metric() {
                match metric_type {
                    MetricType::COUNTER => {
                        encoded_metrics.insert(
                            flatten_metric_with_labels(name, metric),
                            metric.get_counter().get_value(),
                        );
                    },
                    MetricType::GAUGE => {
                        encoded_metrics.insert(
                            flatten_metric_with_labels(name, metric),
                            metric.get_gauge().get_value(),
                        );
                    },
                    MetricType::HISTOGRAM => {
                        // write the sum and counts
                        let h = metric.get_histogram();
                        encoded_metrics.insert(
                            flatten_metric_with_labels(&format!("{}_count", name), metric),
                            h.get_sample_count() as f64,
                        );
                        encoded_metrics.insert(
                            flatten_metric_with_labels(&format!("{}_sum", name), metric),
                            h.get_sample_sum(),
                        );
                    },
                    _ => {
                        // Do nothing (not supported)
                    },
                }
            }
        }

        // Write the encoded metrics to the writer
        match serde_json::to_string(&encoded_metrics) {
            Ok(json_encoded_metrics) => {
                writer.write_all(json_encoded_metrics.as_bytes())?;
            },
            Err(error) => {
                error!("Failed to JSON encode the metrics! Error: {}", error);
            },
        };

        Ok(())
    }
```

**File:** consensus/src/counters.rs (L174-196)
```rust
/// Count of the block proposals sent by this validator since last restart
/// (both primary and secondary)
pub static PROPOSALS_COUNT: Lazy<IntCounter> = Lazy::new(|| {
    register_int_counter!("aptos_consensus_proposals_count", "Count of the block proposals sent by this validator since last restart (both primary and secondary)").unwrap()
});

/// Count the number of times a validator voted for a nil block since last restart.
pub static VOTE_NIL_COUNT: Lazy<IntCounter> = Lazy::new(|| {
    register_int_counter!(
        "aptos_consensus_vote_nil_count",
        "Count the number of times a validator voted for a nil block since last restart."
    )
    .unwrap()
});

/// Total voting power of validators in validator set
pub static TOTAL_VOTING_POWER: Lazy<Gauge> = Lazy::new(|| {
    register_gauge!(
        "aptos_total_voting_power",
        "Total voting power of validators in validator set"
    )
    .unwrap()
});
```

**File:** crates/aptos-inspection-service/src/server/utils.rs (L31-47)
```rust
/// A simple utility function that encodes the metrics using the given encoder
pub fn get_encoded_metrics(encoder: impl Encoder) -> Vec<u8> {
    // Gather and encode the metrics
    let metric_families = get_metric_families();
    let mut encoded_buffer = vec![];
    if let Err(error) = encoder.encode(&metric_families, &mut encoded_buffer) {
        error!("Failed to encode metrics! Error: {}", error);
        return vec![];
    }

    // Update the total metric bytes counter
    NUM_METRICS
        .with_label_values(&["total_bytes"])
        .inc_by(encoded_buffer.len() as u64);

    encoded_buffer
}
```

**File:** crates/aptos-inspection-service/src/server/peer_information.rs (L273-300)
```rust
/// Displays the entire set of trusted peers
fn display_trusted_peers(
    peer_information_output: &mut Vec<String>,
    registered_networks: Vec<NetworkId>,
    peers_and_metadata: &PeersAndMetadata,
) {
    peer_information_output.push("Trusted peers (validator set & seeds):".into());

    // Fetch and display the trusted peers for each network
    for network in registered_networks {
        peer_information_output.push(format!("\t- Network: {}", network));
        if let Ok(trusted_peers) = peers_and_metadata.get_trusted_peers(&network) {
            // Sort the peers before displaying them
            let mut sorted_trusted_peers = BTreeMap::new();
            for (peer_id, peer_info) in trusted_peers {
                sorted_trusted_peers.insert(peer_id, peer_info);
            }

            // Display the trusted peers
            for (peer_id, peer_info) in sorted_trusted_peers {
                peer_information_output.push(format!(
                    "\t\t- Peer: {:?}, peer information: {:?}",
                    peer_id, peer_info
                ));
            }
        }
    }
}
```
