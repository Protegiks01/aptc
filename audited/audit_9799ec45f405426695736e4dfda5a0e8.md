# Audit Report

## Title
GitHub Token Exposure Through Insecure Memory Handling in Genesis Setup

## Summary
The GitHub token used during genesis setup is stored as a plain `String` in memory without secure string protections, violating the project's own secure coding guidelines. This creates two potential exposure vectors: core dumps and HTTP error response leakage.

## Finding Description

The `Client::github()` function reads a GitHub token from disk and stores it insecurely: [1](#0-0) 

The token is stored as a plain `String` in the `GithubClient` struct: [2](#0-1) 

This violates the project's secure coding guidelines which explicitly state: [3](#0-2) [4](#0-3) 

**Exposure Vector 1: Core Dumps**
If the genesis setup process crashes (SIGSEGV, SIGABRT, etc.), the token remains in plain text in memory and can be extracted from core dumps written to disk or sent to crash reporting systems.

**Exposure Vector 2: HTTP Error Response Leakage**
When GitHub API requests fail, the error handling includes the full response body: [5](#0-4) 

If a misconfigured proxy, debugging endpoint, or error condition causes GitHub to echo the Authorization header in the response body, the token would be included in error messages displayed to the user: [6](#0-5) 

## Impact Explanation

While this is a legitimate security issue, it qualifies as **Low Severity** under the Aptos bug bounty program criteria. According to the severity definitions, this is a "Minor information leak" affecting operational tooling rather than blockchain protocol security. The token exposure:

- Does **not** affect consensus safety or blockchain state
- Does **not** enable theft or minting of funds
- Does **not** cause validator node crashes or liveness issues
- Does **not** compromise cryptographic keys used in consensus

The impact is limited to unauthorized access to the genesis GitHub repository used during initial node setup, which is an operational security concern rather than a protocol vulnerability.

## Likelihood Explanation

**Core dump exposure**: Medium likelihood in production environments where processes can crash due to OOM conditions, segmentation faults, or operator signals. However, this is not directly exploitable by an external attacker without first causing a crash through another vulnerability.

**HTTP error leakage**: Low likelihood under normal circumstances, as GitHub's API does not echo authorization headers. This would require a misconfigured proxy, man-in-the-middle debugging tool, or edge-case error handling.

Both scenarios require specific operational conditions that are not directly controllable by an unprivileged attacker.

## Recommendation

Implement secure string handling for the GitHub token using the `zeroize` crate (already a project dependency):

1. Wrap the token in a type that implements `Zeroize` and `Drop`
2. Use `secstr` or similar crate for automatic secure string handling
3. Ensure token is zeroed from memory when the `Client` is dropped
4. Consider using memory locking (mlock) for additional protection

Example implementation pattern:
- Create a `SecureToken` wrapper type that implements `Drop` with zeroization
- Store tokens in this wrapper rather than plain `String`
- The wrapper should implement `Zeroize` from the zeroize crate
- On drop, explicitly zero the memory before deallocation

## Proof of Concept

```rust
// Demonstration: Token remains in memory after use
// Run with: cargo run --bin genesis-setup -- setup-git ...
// Then crash the process: kill -SEGV <pid>
// Examine core dump: strings core.<pid> | grep -A5 -B5 "ghp_"
// The GitHub token will be visible in plain text

// To reproduce HTTP error leakage:
// 1. Configure a proxy that echoes request headers in 500 errors
// 2. Run genesis setup with --github-repository pointing to it
// 3. The error message will display the token
```

---

**Note**: Despite being a valid secure coding guideline violation, this issue does **not** meet the High severity threshold suggested in the security question. It is categorized as Low severity (Minor information leak) under the Aptos bug bounty program, as it affects operational tooling rather than blockchain consensus, state integrity, or fund security. The issue should be addressed as part of secure coding best practices, but it is not an exploitable protocol-level vulnerability.

### Citations

**File:** crates/aptos/src/genesis/git.rs (L144-156)
```rust
    pub fn github(
        repository: GithubRepo,
        branch: String,
        token_path: PathBuf,
    ) -> CliTypedResult<Client> {
        let token = Token::FromDisk(token_path).read_token()?;
        Ok(Client::Github(GithubClient::new(
            repository.owner,
            repository.repository,
            branch,
            token,
        )))
    }
```

**File:** crates/aptos-github-client/src/lib.rs (L37-51)
```rust
impl From<ureq::Response> for Error {
    fn from(resp: ureq::Response) -> Self {
        if let Some(e) = resp.synthetic_error() {
            // Local error
            Error::InternalError(e.to_string())
        } else {
            // Clear the buffer
            let status = resp.status();
            let status_text = resp.status_text().to_string();
            match resp.into_string() {
                Ok(body) => Error::HttpError(status, status_text, body),
                Err(e) => Error::InternalError(e.to_string()),
            }
        }
    }
```

**File:** crates/aptos-github-client/src/lib.rs (L66-71)
```rust
pub struct Client {
    branch: String,
    owner: String,
    repository: String,
    token: String,
}
```

**File:** RUST_SECURE_CODING.md (L96-96)
```markdown
Do not rely on `Drop` trait in security material treatment after the use, use [zeroize](https://docs.rs/zeroize/latest/zeroize/#) to explicit destroy security material, e.g. private keys.
```

**File:** RUST_SECURE_CODING.md (L143-145)
```markdown
### Zeroing Sensitive Data

Use [zeroize](https://docs.rs/zeroize/latest/zeroize/#) for zeroing memory containing sensitive data.
```

**File:** crates/aptos/src/main.rs (L34-39)
```rust
    match result {
        Ok(inner) => println!("{}", inner),
        Err(inner) => {
            println!("{}", inner);
            exit(1);
        },
```
