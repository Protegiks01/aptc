# Audit Report

## Title
Chain ID Collision Vulnerability in Test Genesis Creation Enables Cross-Network Transaction Replay Attacks

## Summary
The `GenesisInfo::new()` function in `crates/aptos-genesis/src/lib.rs` accepts any chain ID without validation, allowing creation of test networks with mainnet chain ID (or vice versa). Combined with a hardcoded `is_test: true` value, this enables an attacker to create a malicious network with the same chain ID as mainnet, facilitating transaction replay attacks where users' signed transactions can be replayed across networks.

## Finding Description

The vulnerability exists in the genesis creation flow for test networks. [1](#0-0) 

The `GenesisInfo::new()` function accepts a `chain_id` parameter without any validation to ensure it doesn't conflict with production networks. More critically, the `generate_genesis_txn()` function hardcodes `is_test: true` regardless of the actual network type: [2](#0-1) 

This differs from the mainnet genesis path, which properly validates that test mode is disabled: [3](#0-2) 

The regular test genesis function `encode_genesis_transaction()` lacks this validation: [4](#0-3) 

**Attack Flow:**
1. Attacker creates a malicious network using `GenesisInfo::new(ChainId::mainnet(), ...)` 
2. The genesis transaction is created with `chain_id=1` (mainnet) stored on-chain via `chain_id::initialize()` [5](#0-4) 
3. Attacker markets this network as a "testnet" or development network
4. Users connect and sign transactions with `chain_id=1` embedded in the transaction
5. Transaction validation accepts these transactions because the on-chain chain ID matches: [6](#0-5) 
6. Attacker captures signed transactions and replays them on the real mainnet
7. If the user's account exists on mainnet with matching sequence numbers, the transaction executes, causing unauthorized fund transfers

This violates the **Transaction Validation** invariant: "Prologue/epilogue checks must enforce all invariants" - specifically, the chain ID is supposed to prevent cross-network transaction replay, but the lack of validation during genesis creation undermines this protection.

## Impact Explanation

**Severity: Medium**

This vulnerability enables:
- **Limited Funds Loss**: Users who interact with the malicious network can have their signed transactions replayed on mainnet, potentially causing unauthorized transfers
- **State Inconsistencies**: Networks with colliding chain IDs violate the fundamental assumption that chain IDs uniquely identify networks
- **Phishing Vector**: Attackers can create convincing fake networks that appear legitimate due to matching chain IDs

The impact is limited to Medium (rather than Critical) because:
1. Requires social engineering to get users to connect to the malicious network
2. Requires sequence number alignment between networks for successful replay
3. Does not directly compromise consensus or cause network-wide failure
4. Requires user action (signing transactions on the fake network)

Per Aptos Bug Bounty criteria, this qualifies as Medium Severity: "Limited funds loss or manipulation" and "State inconsistencies requiring intervention."

## Likelihood Explanation

**Likelihood: Medium-High**

The attack is feasible because:
1. Creating a malicious genesis is straightforward using the CLI tools with a custom layout YAML file [7](#0-6) 
2. No runtime validation prevents this configuration
3. Users frequently test on multiple networks and may not verify chain ID consistency
4. The hardcoded `is_test: true` bug makes the issue worse by ignoring the developer's intent

However, successful exploitation requires:
- Convincing users to connect to the malicious network
- Users having accounts on both networks
- Sequence number synchronization for replay to succeed

## Recommendation

**1. Add Chain ID Validation in GenesisInfo::new():**

```rust
pub fn new(
    chain_id: ChainId,
    root_key: Ed25519PublicKey,
    configs: Vec<ValidatorConfiguration>,
    framework: ReleaseBundle,
    genesis_config: &GenesisConfiguration,
) -> anyhow::Result<GenesisInfo> {
    // Validate chain_id consistency with is_test flag
    if chain_id.is_mainnet() {
        anyhow::ensure!(
            !genesis_config.is_test,
            "Cannot create test genesis with mainnet chain_id"
        );
    }
    
    // Prevent using reserved production chain IDs for test networks
    if genesis_config.is_test {
        anyhow::ensure!(
            !chain_id.is_mainnet() && !chain_id.is_testnet(),
            "Test genesis cannot use production chain IDs (mainnet=1, testnet=2)"
        );
    }
    
    // ... rest of function
}
```

**2. Fix the hardcoded is_test bug:**

Change line 145 in `generate_genesis_txn()` from:
```rust
is_test: true,
```
to:
```rust
is_test: self.is_test,
```

**3. Add validation in encode_genesis_transaction():**

Add a check similar to `encode_aptos_mainnet_genesis_transaction()`:
```rust
if chain_id.is_mainnet() || chain_id.is_testnet() {
    assert!(!genesis_config.is_test, "Production chain IDs require is_test=false");
}
```

## Proof of Concept

```rust
// File: malicious_genesis_poc.rs
use aptos_genesis::{GenesisInfo, config::{Layout, ValidatorConfiguration}};
use aptos_types::chain_id::ChainId;
use aptos_crypto::ed25519::Ed25519PublicKey;
use aptos_framework::ReleaseBundle;

fn create_malicious_genesis() -> anyhow::Result<()> {
    // Attacker creates a layout with mainnet chain_id but is_test=true
    let mut layout = Layout::default();
    layout.chain_id = ChainId::mainnet(); // Chain ID = 1 (MAINNET)
    layout.is_test = true; // But configured as test network
    
    // Create genesis - NO VALIDATION ERROR!
    let genesis_info = GenesisInfo::new(
        layout.chain_id,
        root_key,
        vec![], // validators
        framework,
        &genesis_config,
    )?;
    
    // Genesis is created with chain_id=1 stored on-chain
    // Users connecting to this network will sign transactions with chain_id=1
    // These transactions can be replayed on real mainnet!
    
    println!("Malicious genesis created with mainnet chain_id!");
    println!("Transactions signed here can be replayed on mainnet");
    
    Ok(())
}

// The fix would add validation that prevents this:
// Error: "Cannot create test genesis with mainnet chain_id"
```

## Notes

The vulnerability stems from architectural separation between mainnet genesis (`MainnetGenesisInfo`) and test genesis (`GenesisInfo`) paths. While mainnet has proper validation, the test path was left unprotected, likely assuming it would only be used in controlled environments. However, the availability of CLI tools and configuration files means anyone can create a genesis, making validation essential.

The hardcoded `is_test: true` at line 145 appears to be a bug where the developer forgot to use `self.is_test`, further compounding the issue by forcing all `GenesisInfo`-created networks into test mode regardless of configuration.

### Citations

**File:** crates/aptos-genesis/src/lib.rs (L86-125)
```rust
    pub fn new(
        chain_id: ChainId,
        root_key: Ed25519PublicKey,
        configs: Vec<ValidatorConfiguration>,
        framework: ReleaseBundle,
        genesis_config: &GenesisConfiguration,
    ) -> anyhow::Result<GenesisInfo> {
        let mut validators = Vec::new();

        for config in configs {
            validators.push(config.try_into()?)
        }

        Ok(GenesisInfo {
            chain_id,
            root_key,
            validators,
            framework,
            genesis: None,
            allow_new_validators: genesis_config.allow_new_validators,
            epoch_duration_secs: genesis_config.epoch_duration_secs,
            is_test: genesis_config.is_test,
            min_stake: genesis_config.min_stake,
            min_voting_threshold: genesis_config.min_voting_threshold,
            max_stake: genesis_config.max_stake,
            recurring_lockup_duration_secs: genesis_config.recurring_lockup_duration_secs,
            required_proposer_stake: genesis_config.required_proposer_stake,
            rewards_apy_percentage: genesis_config.rewards_apy_percentage,
            voting_duration_secs: genesis_config.voting_duration_secs,
            voting_power_increase_limit: genesis_config.voting_power_increase_limit,
            consensus_config: genesis_config.consensus_config.clone(),
            execution_config: genesis_config.execution_config.clone(),
            gas_schedule: genesis_config.gas_schedule.clone(),
            initial_features_override: genesis_config.initial_features_override.clone(),
            randomness_config_override: genesis_config.randomness_config_override.clone(),
            jwk_consensus_config_override: genesis_config.jwk_consensus_config_override.clone(),
            initial_jwks: genesis_config.initial_jwks.clone(),
            keyless_groth16_vk: genesis_config.keyless_groth16_vk.clone(),
        })
    }
```

**File:** crates/aptos-genesis/src/lib.rs (L136-166)
```rust
    fn generate_genesis_txn(&self) -> Transaction {
        aptos_vm_genesis::encode_genesis_transaction(
            self.root_key.clone(),
            &self.validators,
            &self.framework,
            self.chain_id,
            &aptos_vm_genesis::GenesisConfiguration {
                allow_new_validators: self.allow_new_validators,
                epoch_duration_secs: self.epoch_duration_secs,
                is_test: true,
                min_stake: self.min_stake,
                min_voting_threshold: self.min_voting_threshold,
                max_stake: self.max_stake,
                recurring_lockup_duration_secs: self.recurring_lockup_duration_secs,
                required_proposer_stake: self.required_proposer_stake,
                rewards_apy_percentage: self.rewards_apy_percentage,
                voting_duration_secs: self.voting_duration_secs,
                voting_power_increase_limit: self.voting_power_increase_limit,
                employee_vesting_start: 1663456089,
                employee_vesting_period_duration: 5 * 60, // 5 minutes
                initial_features_override: self.initial_features_override.clone(),
                randomness_config_override: self.randomness_config_override.clone(),
                jwk_consensus_config_override: self.jwk_consensus_config_override.clone(),
                initial_jwks: self.initial_jwks.clone(),
                keyless_groth16_vk: self.keyless_groth16_vk.clone(),
            },
            &self.consensus_config,
            &self.execution_config,
            &self.gas_schedule,
        )
    }
```

**File:** aptos-move/vm-genesis/src/lib.rs (L135-144)
```rust
pub fn encode_aptos_mainnet_genesis_transaction(
    accounts: &[AccountBalance],
    employees: &[EmployeePool],
    validators: &[ValidatorWithCommissionRate],
    framework: &ReleaseBundle,
    chain_id: ChainId,
    genesis_config: &GenesisConfiguration,
) -> Transaction {
    assert!(!genesis_config.is_test, "This is mainnet!");
    validate_genesis_config(genesis_config);
```

**File:** aptos-move/vm-genesis/src/lib.rs (L240-260)
```rust
pub fn encode_genesis_transaction(
    aptos_root_key: Ed25519PublicKey,
    validators: &[Validator],
    framework: &ReleaseBundle,
    chain_id: ChainId,
    genesis_config: &GenesisConfiguration,
    consensus_config: &OnChainConsensusConfig,
    execution_config: &OnChainExecutionConfig,
    gas_schedule: &GasScheduleV2,
) -> Transaction {
    Transaction::GenesisTransaction(WriteSetPayload::Direct(encode_genesis_change_set(
        &aptos_root_key,
        validators,
        framework,
        chain_id,
        genesis_config,
        consensus_config,
        execution_config,
        gas_schedule,
    )))
}
```

**File:** aptos-move/framework/aptos-framework/sources/chain_id.move (L13-18)
```text
    /// Only called during genesis.
    /// Publish the chain ID `id` of this instance under the SystemAddresses address
    public(friend) fun initialize(aptos_framework: &signer, id: u8) {
        system_addresses::assert_aptos_framework(aptos_framework);
        move_to(aptos_framework, ChainId { id })
    }
```

**File:** aptos-move/framework/aptos-framework/sources/transaction_validation.move (L126-143)
```text
    fun prologue_common(
        sender: &signer,
        gas_payer: &signer,
        replay_protector: ReplayProtector,
        txn_authentication_key: Option<vector<u8>>,
        txn_gas_price: u64,
        txn_max_gas_units: u64,
        txn_expiration_time: u64,
        chain_id: u8,
        is_simulation: bool,
    ) {
        let sender_address = signer::address_of(sender);
        let gas_payer_address = signer::address_of(gas_payer);
        assert!(
            timestamp::now_seconds() < txn_expiration_time,
            error::invalid_argument(PROLOGUE_ETRANSACTION_EXPIRED),
        );
        assert!(chain_id::get() == chain_id, error::invalid_argument(PROLOGUE_EBAD_CHAIN_ID));
```

**File:** crates/aptos-genesis/src/config.rs (L27-90)
```rust
/// Template for setting up Github for Genesis
///
#[derive(Debug, Deserialize, Serialize)]
pub struct Layout {
    /// Root key for the blockchain only for test chains
    #[serde(default)]
    pub root_key: Option<Ed25519PublicKey>,
    /// List of usernames or identifiers
    pub users: Vec<String>,
    /// ChainId for the target network
    pub chain_id: ChainId,
    /// Whether to allow new validators to join the set after genesis
    ///
    /// Ignored for mainnet
    #[serde(default)]
    pub allow_new_validators: bool,
    /// Duration of an epoch
    pub epoch_duration_secs: u64,
    /// Whether this is a test network or not
    ///
    /// Ignored for mainnet
    #[serde(default)]
    pub is_test: bool,
    /// Minimum stake to be in the validator set
    pub min_stake: u64,
    /// Minimum number of votes to consider a proposal valid.
    pub min_voting_threshold: u128,
    /// Maximum stake to be in the validator set
    pub max_stake: u64,
    /// Minimum number of seconds to lockup staked coins
    pub recurring_lockup_duration_secs: u64,
    /// Required amount of stake to create proposals.
    pub required_proposer_stake: u64,
    /// Percentage of stake given out as rewards a year (0-100%).
    pub rewards_apy_percentage: u64,
    /// Voting duration for a proposal in seconds.
    pub voting_duration_secs: u64,
    /// % of current epoch's total voting power that can be added in this epoch.
    pub voting_power_increase_limit: u64,
    /// Total supply of coins
    pub total_supply: Option<u64>,
    /// Timestamp (in seconds) when employee vesting starts.
    pub employee_vesting_start: Option<u64>,
    /// Duration of each vesting period (in seconds).
    pub employee_vesting_period_duration: Option<u64>,
    /// Onchain Consensus Config
    #[serde(default = "OnChainConsensusConfig::default_for_genesis")]
    pub on_chain_consensus_config: OnChainConsensusConfig,
    /// Onchain Execution Config
    #[serde(default = "OnChainExecutionConfig::default_for_genesis")]
    pub on_chain_execution_config: OnChainExecutionConfig,

    /// An optional JWK consensus config to use, instead of `default_for_genesis()`.
    #[serde(default)]
    pub jwk_consensus_config_override: Option<OnChainJWKConsensusConfig>,

    /// JWKs to patch in genesis.
    #[serde(default)]
    pub initial_jwks: Vec<IssuerJWK>,

    /// Keyless Groth16 verification key to install in genesis.
    #[serde(default)]
    pub keyless_groth16_vk_override: Option<Groth16VerificationKey>,
}
```
