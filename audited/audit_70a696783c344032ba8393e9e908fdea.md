# Audit Report

## Title
Stake Balance Accounting Inconsistency in Rosetta API - Double-Counting of Pending Active Stake

## Summary
The `get_stake_balances()` function in the Aptos Rosetta API contains an accounting inconsistency where querying individual stake components and summing them produces a different result than querying total stake directly. Specifically, `pending_active` stake is double-counted when summing individual components, leading to an overcount equal to the full `pending_active` amount.

## Finding Description

The Rosetta API provides multiple endpoints to query different types of stake balances (active, pending_active, inactive, pending_inactive, total). However, these balances are calculated inconsistently, violating the fundamental accounting principle that the sum of components should equal the total. [1](#0-0) 

The root cause lies in how `active_stake` is calculated. The function retrieves `total_active_stake` from the staking contract's view function, which is defined as: [2](#0-1) 

This means `total_active_stake = stake_pool.active + stake_pool.pending_active`.

When a user queries for `active_stake`, they receive: [3](#0-2) 

This returns `(active + pending_active) - commission`, incorrectly including `pending_active` in the "active stake" component.

When querying `pending_active_stake`, users receive: [4](#0-3) 

This correctly returns just `pending_active`.

However, when querying `total_stake` directly: [5](#0-4) 

Where `get_total_staked_amount()` correctly sums all four components: [6](#0-5) 

**The Inconsistency:**

Summing individual components:
- `active_stake`: `(active + pending_active) - commission`
- `pending_active_stake`: `pending_active`
- `inactive_stake`: `inactive`  
- `pending_inactive_stake`: `pending_inactive`
- **Sum**: `active + 2×pending_active + inactive + pending_inactive - commission`

Querying total directly:
- `total_stake`: `active + pending_active + inactive + pending_inactive - commission`

**The difference is exactly `pending_active`**, meaning external systems that sum individual components will overcount by the full pending_active amount.

Notably, there is even a TODO comment acknowledging potential issues with these calculations: [7](#0-6) 

## Impact Explanation

This qualifies as **Medium Severity** based on the following impacts:

1. **Ecosystem Integration Errors**: Exchanges, explorers, and analytics platforms using the Rosetta API to display or verify stake balances will encounter inconsistent data when attempting to validate totals by summing components.

2. **Financial Display Errors**: Systems displaying individual stake components will show inflated total balances (overcounted by `pending_active` amount), potentially confusing users about their actual stake positions.

3. **Auditing and Reconciliation Failures**: Any automated system attempting to verify balance consistency will detect discrepancies, potentially triggering false alarms or halting operations.

4. **Trust and Reliability Impact**: As the Rosetta API is a standardized interface for blockchain integration, inconsistencies undermine trust in the Aptos integration and could delay or prevent ecosystem adoption.

While this does not directly affect on-chain state or consensus, it represents a "State inconsistency requiring intervention" (per Medium severity criteria) in the critical external API layer that ecosystem participants rely upon.

## Likelihood Explanation

**Likelihood: High**

This issue will manifest for any staking contract that has both:
1. Non-zero `pending_active` stake
2. External systems querying individual stake components

This is extremely common in active validator operations, as newly added stake goes to `pending_active` before being activated in the next epoch (per the StakePool design): [8](#0-7) 

Any integration that validates totals by summing components (a standard accounting practice) will immediately detect this inconsistency.

## Recommendation

**Fix the `active_stake` calculation to exclude `pending_active`:**

The issue is that `active_stake` should return only the `stake_pool.active` component after commission deduction, not the combined `total_active_stake`. The commission should be calculated proportionally only from the `active` portion, or the staking contract view function should return separate values.

**Recommended Fix:**

```rust
if owner_account.is_active_stake() {
    // Calculate commission only on the active portion
    let active_stake = stake_pool.active;
    let commission_on_active = if total_active_stake > 0 {
        (commission_amount * active_stake) / total_active_stake
    } else {
        0
    };
    requested_balance = Some((active_stake - commission_on_active).to_string());
}
```

Alternatively, modify the staking contract to return separate `active` and `pending_active` amounts with their respective commissions, or create a new view function that provides the correct breakdown.

The key principle: **active_stake + pending_active_stake + inactive_stake + pending_inactive_stake = total_stake** must hold as an invariant.

## Proof of Concept

**Test Scenario:**

1. Create a staking contract with 1000 APT initial stake
2. Add 500 APT of new stake (goes to `pending_active`)
3. Accumulate 100 APT in rewards with 10% commission

**Expected State:**
- `active`: 1100 (original 1000 + 100 rewards)
- `pending_active`: 500
- `commission`: 10 (10% of 100 rewards)

**Current Behavior:**
- Query `active_stake`: returns `(1100 + 500) - 10 = 1590`
- Query `pending_active_stake`: returns `500`
- Query `inactive_stake`: returns `0`
- Query `pending_inactive_stake`: returns `0`
- **Sum**: `1590 + 500 + 0 + 0 = 2090`

- Query `total_stake`: returns `(1100 + 500 + 0 + 0) - 10 = 1590`

**Inconsistency**: Sum of components (2090) ≠ Total stake (1590), difference = 500 = `pending_active`

This can be reproduced by deploying a staking contract, adding stake while active, and querying the Rosetta API endpoints for individual components versus total.

## Notes

This vulnerability is acknowledged in the codebase via the TODO comment, indicating developer awareness that "all of these are off". The issue stems from reusing the staking contract's `total_active_stake` (which combines active and pending_active for commission calculation purposes) as the value for the "active stake" component in the Rosetta API, creating semantic confusion between "total active stake for commission purposes" and "active stake as a discrete component".

The on-chain staking logic itself is correct—this is purely a presentation/API layer issue in the Rosetta implementation. However, given the Rosetta API's role as a critical integration point for exchanges and external services, this data consistency issue warrants Medium severity classification and should be addressed to maintain ecosystem trust and prevent integration errors.

### Citations

**File:** crates/aptos-rosetta/src/types/misc.rs (L338-340)
```rust
        let total_active_stake = staking_contract_amounts_response[0];
        let accumulated_rewards = staking_contract_amounts_response[1];
        let commission_amount = staking_contract_amounts_response[2];
```

**File:** crates/aptos-rosetta/src/types/misc.rs (L342-344)
```rust
        // TODO: I think all of these are off, probably need to recalculate all of them
        // see the get_staking_contract_amounts_internal function in staking_contract.move for more
        // information on why commission is only subtracted from active and total stake
```

**File:** crates/aptos-rosetta/src/types/misc.rs (L345-347)
```rust
        if owner_account.is_active_stake() {
            // active stake is principal and rewards (including commission) so subtract the commission
            requested_balance = Some((total_active_stake - commission_amount).to_string());
```

**File:** crates/aptos-rosetta/src/types/misc.rs (L348-350)
```rust
        } else if owner_account.is_pending_active_stake() {
            // pending_active cannot have commission because it is new principal
            requested_balance = Some(stake_pool.pending_active.to_string());
```

**File:** crates/aptos-rosetta/src/types/misc.rs (L357-360)
```rust
        } else if owner_account.is_total_stake() {
            // total stake includes commission since it includes active stake, which includes commission
            requested_balance =
                Some((stake_pool.get_total_staked_amount() - commission_amount).to_string());
```

**File:** aptos-move/framework/aptos-framework/sources/staking_contract.move (L1064-1066)
```text
        let (active, _, pending_active, _) =
            stake::get_stake(staking_contract.pool_address);
        let total_active_stake = active + pending_active;
```

**File:** types/src/stake_pool.rs (L32-34)
```rust
    pub fn get_total_staked_amount(&self) -> u64 {
        self.active + self.inactive + self.pending_active + self.pending_inactive
    }
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L115-119)
```text
    /// Changes in stake for an active validator:
    /// 1. If a validator calls add_stake, the newly added stake is moved to pending_active.
    /// 2. If validator calls unlock, their stake is moved to pending_inactive.
    /// 2. When the next epoch starts, any pending_inactive stake is moved to inactive and can be withdrawn.
    ///    Any pending_active stake is moved to active and adds to the validator's voting power.
```
