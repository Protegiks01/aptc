# Audit Report

## Title
Multi-Pool Operator Change Results in Split Control Due to Non-Atomic Transaction Processing

## Summary
The `SetOperator::execute()` CLI command processes multiple stake pools sequentially through separate transactions without atomicity guarantees. When a staker attempts to consolidate multiple staking contracts under a single new operator, the operation fails partway through due to the on-chain constraint preventing multiple staking contracts with the same operator. This creates a split control scenario where some pools successfully switch to the new operator while others retain their original operators.

## Finding Description

The vulnerability exists in the interaction between the CLI and the on-chain staking contract logic. The attack path is as follows: [1](#0-0) 

The `SetOperator::execute()` function retrieves all stake pools for an owner and iterates through them, submitting a separate transaction for each pool. Each transaction is awaited before proceeding to the next one. [2](#0-1) 

The `get_stake_pools()` function explicitly supports retrieving multiple staking contracts per owner, as confirmed by the staking contract documentation. [3](#0-2) 

The critical constraint is enforced in the `switch_operator` function: [4](#0-3) 

Lines 842-845 explicitly prevent a staker from having multiple staking contracts with the same operator, aborting with `ECANT_MERGE_STAKING_CONTRACTS`.

**Exploitation Scenario:**
1. Staker Alice has two staking contracts: one with operator A, one with operator B
2. Alice runs: `aptos stake set-operator --operator-address C`
3. First iteration: `switch_operator_with_same_commission(A, C)` succeeds
   - Contract with operator A is removed from Alice's Store
   - Contract with operator C is added to Alice's Store
4. Second iteration: `switch_operator_with_same_commission(B, C)` fails
   - Check at line 842-845 detects Alice already has a contract with operator C
   - Transaction aborts with `ECANT_MERGE_STAKING_CONTRACTS`
5. Result: Alice has split control - one pool under operator C, one still under operator B

The CLI uses the `?` operator which causes early return on transaction failure, but the first transaction has already been committed to the blockchain.

## Impact Explanation

**Medium Severity** - This issue qualifies as "State inconsistencies requiring intervention" per the Aptos bug bounty criteria.

**Security Impact:**
- **Split Control Scenario**: User intends atomic operator change across all pools but achieves only partial success
- **Incomplete Security Migration**: If switching away from a compromised/malicious operator, some pools remain under the old operator's control while the user believes all pools are secure
- **Operational Confusion**: The system is left in an inconsistent state that requires manual intervention to resolve
- **Invariant Violation**: Breaks the state consistency invariant - the operation is not atomic and leaves the system in a partially updated state

While this doesn't directly cause fund loss or consensus violations, it creates a security-relevant state inconsistency where pools remain under potentially malicious operator control when the user intended otherwise.

## Likelihood Explanation

**Likelihood: Medium-High**

This vulnerability is easily triggered in realistic scenarios:

1. **Common Use Case**: Stakers frequently need to consolidate operations under a single operator for operational efficiency
2. **Explicit Support**: The system explicitly supports multiple staking contracts per staker (as documented)
3. **No Warning**: The CLI provides no pre-validation or warning that this operation will fail for staking contracts
4. **User Expectation**: Users reasonably expect the `set-operator` command to work uniformly across all pool types

The only requirement is that a user has multiple staking contracts and attempts to switch them to the same operator using the provided CLI tool - a completely normal operational scenario.

## Recommendation

**Immediate Fix**: Add pre-validation in the CLI to detect when multiple staking contracts would be consolidated to the same operator, and either:

1. **Reject the operation** with a clear error message explaining the constraint
2. **Warn the user** and require explicit confirmation
3. **Handle sequentially** by switching one contract at a time with different intermediary operators

**Preferred Solution**: Modify the CLI to validate the operation before submitting any transactions:

```rust
async fn execute(mut self) -> CliTypedResult<Vec<TransactionSummary>> {
    let client = self.txn_options.rest_options.client(&self.txn_options.profile_options)?;
    let owner_address = self.txn_options.sender_address()?;
    let new_operator_address = self.operator_address;
    
    let stake_pool_results = get_stake_pools(&client, owner_address).await?;
    
    // Pre-validation: Check if multiple staking contracts would consolidate to same operator
    let staking_contract_count = stake_pool_results.iter()
        .filter(|p| matches!(p.pool_type, StakePoolType::StakingContract))
        .count();
    
    if staking_contract_count > 1 {
        return Err(CliError::UnexpectedError(
            format!("Cannot consolidate {} staking contracts to the same operator. \
                    The on-chain constraint prevents multiple staking contracts with the same operator. \
                    Please switch each contract individually or switch to different operators.",
                    staking_contract_count)
        ));
    }
    
    // Continue with existing logic...
    let mut transaction_summaries: Vec<TransactionSummary> = vec![];
    for stake_pool in stake_pool_results {
        // ... existing transaction submission logic
    }
    Ok(transaction_summaries)
}
```

**Long-term Fix**: Consider modifying the on-chain staking contract logic to support merging multiple staking contracts into one, or provide a dedicated CLI command for sequential operator changes with proper state management.

## Proof of Concept

```move
#[test_only]
module aptos_framework::staking_contract_split_control_test {
    use std::signer;
    use aptos_framework::staking_contract;
    use aptos_framework::aptos_coin;
    use aptos_framework::account;
    
    #[test(aptos_framework = @aptos_framework, staker = @0x123, operator_a = @0xa11ce, operator_b = @0xb0b, operator_c = @0xca101)]
    #[expected_failure(abort_code = 0x60005, location = aptos_framework::staking_contract)]
    public entry fun test_split_control_on_operator_switch(
        aptos_framework: &signer,
        staker: &signer,
        operator_a: &signer,
        operator_b: &signer,
        operator_c: &signer,
    ) {
        // Setup accounts and initialize staking
        let staker_addr = signer::address_of(staker);
        let operator_a_addr = signer::address_of(operator_a);
        let operator_b_addr = signer::address_of(operator_b);
        let operator_c_addr = signer::address_of(operator_c);
        
        account::create_account_for_test(staker_addr);
        account::create_account_for_test(operator_a_addr);
        account::create_account_for_test(operator_b_addr);
        account::create_account_for_test(operator_c_addr);
        
        // Fund staker account
        aptos_coin::mint(aptos_framework, staker_addr, 2000000);
        
        // Create two staking contracts with different operators
        staking_contract::create_staking_contract(
            staker,
            operator_a_addr,
            operator_a_addr,
            1000000,
            10,
            vector::empty()
        );
        
        staking_contract::create_staking_contract(
            staker,
            operator_b_addr,
            operator_b_addr,
            1000000,
            10,
            vector::empty()
        );
        
        // First switch succeeds: operator A -> operator C
        staking_contract::switch_operator_with_same_commission(
            staker,
            operator_a_addr,
            operator_c_addr
        );
        
        // Second switch fails: operator B -> operator C
        // This aborts with ECANT_MERGE_STAKING_CONTRACTS (0x60005)
        // because staker now already has a contract with operator C
        staking_contract::switch_operator_with_same_commission(
            staker,
            operator_b_addr,
            operator_c_addr
        );
        
        // At this point:
        // - Staking contract with operator C exists (from first switch)
        // - Staking contract with operator B still exists (second switch failed)
        // - Split control achieved!
    }
}
```

## Notes

This vulnerability demonstrates a classic atomicity failure where a multi-step operation in the CLI layer is not matched by atomic guarantees in the on-chain layer. The design explicitly supports multiple staking contracts per staker (for operational flexibility) but prevents consolidation to a single operator (to avoid merging complexity). The CLI should validate this constraint before submitting transactions, rather than discovering it mid-execution and leaving the system in a partially updated state.

The same issue affects vesting contracts, as they also use the staking contract mechanism internally and would encounter the same constraint.

### Citations

**File:** crates/aptos/src/stake/mod.rs (L369-420)
```rust
    async fn execute(mut self) -> CliTypedResult<Vec<TransactionSummary>> {
        let client = self
            .txn_options
            .rest_options
            .client(&self.txn_options.profile_options)?;
        let owner_address = self.txn_options.sender_address()?;
        let new_operator_address = self.operator_address;
        let mut transaction_summaries: Vec<TransactionSummary> = vec![];

        let stake_pool_results = get_stake_pools(&client, owner_address).await?;
        for stake_pool in stake_pool_results {
            match stake_pool.pool_type {
                StakePoolType::Direct => {
                    transaction_summaries.push(
                        self.txn_options
                            .submit_transaction(aptos_stdlib::stake_set_operator(
                                new_operator_address,
                            ))
                            .await
                            .map(|inner| inner.into())?,
                    );
                },
                StakePoolType::StakingContract => {
                    transaction_summaries.push(
                        self.txn_options
                            .submit_transaction(
                                aptos_stdlib::staking_contract_switch_operator_with_same_commission(
                                    stake_pool.operator_address,
                                    new_operator_address,
                                ),
                            )
                            .await
                            .map(|inner| inner.into())?,
                    );
                },
                StakePoolType::Vesting => {
                    transaction_summaries.push(
                        self.txn_options
                            .submit_transaction(
                                aptos_stdlib::vesting_update_operator_with_same_commission(
                                    stake_pool.vesting_contract.unwrap(),
                                    new_operator_address,
                                ),
                            )
                            .await
                            .map(|inner| inner.into())?,
                    );
                },
            }
        }
        Ok(transaction_summaries)
    }
```

**File:** crates/aptos/src/node/mod.rs (L417-479)
```rust
pub async fn get_stake_pools(
    client: &Client,
    owner_address: AccountAddress,
) -> CliTypedResult<Vec<StakePoolResult>> {
    let epoch_info = get_epoch_info(client).await?;
    let validator_set = &client
        .get_account_resource_bcs::<ValidatorSet>(CORE_CODE_ADDRESS, "0x1::stake::ValidatorSet")
        .await?
        .into_inner();
    let mut stake_pool_results: Vec<StakePoolResult> = vec![];
    // Add direct stake pool if any.
    let direct_stake_pool = get_stake_pool_info(
        client,
        owner_address,
        StakePoolType::Direct,
        0,
        0,
        epoch_info.clone(),
        validator_set,
        None,
    )
    .await;
    if let Ok(direct_stake_pool) = direct_stake_pool {
        stake_pool_results.push(direct_stake_pool);
    };

    // Fetch all stake pools managed via staking contracts.
    let staking_contract_pools = get_staking_contract_pools(
        client,
        owner_address,
        StakePoolType::StakingContract,
        epoch_info.clone(),
        validator_set,
        None,
    )
    .await;
    if let Ok(mut staking_contract_pools) = staking_contract_pools {
        stake_pool_results.append(&mut staking_contract_pools);
    };

    // Fetch all stake pools managed via employee vesting accounts.
    let vesting_admin_store = client
        .get_account_resource_bcs::<VestingAdminStore>(owner_address, "0x1::vesting::AdminStore")
        .await;
    if let Ok(vesting_admin_store) = vesting_admin_store {
        let vesting_contracts = vesting_admin_store.into_inner().vesting_contracts;
        for vesting_contract in vesting_contracts {
            let mut staking_contract_pools = get_staking_contract_pools(
                client,
                vesting_contract,
                StakePoolType::Vesting,
                epoch_info.clone(),
                validator_set,
                Some(vesting_contract),
            )
            .await
            .unwrap();
            stake_pool_results.append(&mut staking_contract_pools);
        }
    };

    Ok(stake_pool_results)
}
```

**File:** aptos-move/framework/aptos-framework/sources/staking_contract.move (L439-440)
```text
        // Initialize the stake pool in a new resource account. This allows the same staker to contract with multiple
        // different operators.
```

**File:** aptos-move/framework/aptos-framework/sources/staking_contract.move (L826-879)
```text
    public entry fun switch_operator(
        staker: &signer,
        old_operator: address,
        new_operator: address,
        new_commission_percentage: u64
    ) acquires Store, BeneficiaryForOperator {
        let staker_address = signer::address_of(staker);
        assert_staking_contract_exists(staker_address, old_operator);

        assert!(
            new_commission_percentage <= 100,
            error::invalid_argument(EINVALID_COMMISSION_PERCENTAGE)
        );
        // Merging two existing staking contracts is too complex as we'd need to merge two separate stake pools.
        let store = borrow_global_mut<Store>(staker_address);
        let staking_contracts = &mut store.staking_contracts;
        assert!(
            !simple_map::contains_key(staking_contracts, &new_operator),
            error::invalid_state(ECANT_MERGE_STAKING_CONTRACTS)
        );

        let (_, staking_contract) = simple_map::remove(staking_contracts, &old_operator);
        // Force distribution of any already inactive stake.
        distribute_internal(
            staker_address,
            old_operator,
            &mut staking_contract,
            &mut store.distribute_events
        );

        // For simplicity, we request commission to be paid out first. This avoids having to ensure to staker doesn't
        // withdraw into the commission portion.
        request_commission_internal(
            old_operator,
            &mut staking_contract,
            &mut store.add_distribution_events,
            &mut store.request_commission_events
        );

        // Update the staking contract's commission rate and stake pool's operator.
        stake::set_operator_with_cap(&staking_contract.owner_cap, new_operator);
        staking_contract.commission_percentage = new_commission_percentage;

        let pool_address = staking_contract.pool_address;
        simple_map::add(staking_contracts, new_operator, staking_contract);
        if (std::features::module_event_migration_enabled()) {
            emit(SwitchOperator { pool_address, old_operator, new_operator });
        } else {
            emit_event(
                &mut store.switch_operator_events,
                SwitchOperatorEvent { pool_address, old_operator, new_operator }
            );
        };
    }
```
