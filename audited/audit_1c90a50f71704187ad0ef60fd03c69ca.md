# Audit Report

## Title
Integer Overflow Vulnerability in Block Gas Limit Accumulation Due to Inadequate Test Coverage

## Summary
The `get_gas_limit_variants` function provides insufficient test coverage for gas limit edge cases. The production code in `BlockGasLimitProcessor::accumulate_fee_statement` uses unchecked arithmetic that could overflow if on-chain governance parameters are set to extreme values, potentially causing consensus divergence and network-wide failure.

## Finding Description

The test coverage gap exists between the combinatorial test values and production scenarios:

**Test Environment**: [1](#0-0) 

The test uses `MAX_GAS_PER_TXN = 4`, while production uses `MAX_GAS_AMOUNT = 2,000,000` (500,000Ã— larger): [2](#0-1) 

**Test Variants**: [3](#0-2) 

The function only tests gas limits of 0 and small random values, never approaching production magnitudes or testing multiplier edge cases.

**Production Vulnerability**: [4](#0-3) 

The critical arithmetic operations use unchecked `*` and `+` operators without overflow protection. The multipliers come from on-chain governance configuration: [5](#0-4) 

**No Input Validation**: [6](#0-5) 

The Move contract only validates that the config vector is non-empty, with no bounds checking on multiplier values within the serialized data.

## Impact Explanation

If governance (maliciously or accidentally) sets `execution_gas_effective_multiplier` or `io_gas_effective_multiplier` to large values (e.g., u64::MAX / 100), the multiplication `fee_statement.execution_gas_used() * multiplier` would overflow u64, wrapping to incorrect small values. This breaks the **"Deterministic Execution"** and **"Resource Limits"** invariants.

The accumulation would become incorrect, causing:
1. Block gas limit checks to fail incorrectly
2. Different nodes potentially accepting different transaction counts
3. Consensus divergence requiring manual intervention or hard fork

This qualifies as **Critical Severity** - "Non-recoverable network partition (requires hardfork)" if nodes diverge on block content due to different overflow behavior.

## Likelihood Explanation

**Likelihood: Low to Medium** - Requires governance proposal to set extreme multiplier values. However:
- Could occur accidentally through misconfigured proposal
- No validation prevents extreme values
- Once set, affects ALL validators simultaneously
- Tests don't catch this critical edge case

## Recommendation

**Immediate Fixes:**

1. **Add checked arithmetic**: [4](#0-3) 

Replace unchecked operations with:
```rust
let raw_gas_used = fee_statement.execution_gas_used()
    .checked_mul(self.block_gas_limit_type.execution_gas_effective_multiplier())
    .and_then(|v| v.checked_add(
        fee_statement.io_gas_used()
            .checked_mul(self.block_gas_limit_type.io_gas_effective_multiplier())?
    ))
    .expect("Block gas calculation overflow");
```

2. **Add validation in Move contract**: [6](#0-5) 

Add bounds checking:
```move
const MAX_GAS_MULTIPLIER: u64 = 1000; // reasonable upper bound
assert!(execution_gas_effective_multiplier <= MAX_GAS_MULTIPLIER, EINVALID_MULTIPLIER);
```

3. **Expand test coverage**: [3](#0-2) 

Add tests with:
- Production-scale gas values (2,000,000)
- Large multipliers (100, 1000, u64::MAX/2)
- Large conflict_penalty_window values
- Edge cases near u64::MAX

## Proof of Concept

```rust
#[test]
#[should_panic(expected = "overflow")]
fn test_gas_multiplier_overflow() {
    use aptos_types::on_chain_config::BlockGasLimitType;
    use aptos_types::fee_statement::FeeStatement;
    
    // Governance sets extreme multiplier
    let block_gas_limit = BlockGasLimitType::ComplexLimitV1 {
        effective_block_gas_limit: u64::MAX,
        execution_gas_effective_multiplier: u64::MAX / 10, // Extreme value
        io_gas_effective_multiplier: 1,
        conflict_penalty_window: 1,
        use_module_publishing_block_conflict: false,
        block_output_limit: None,
        include_user_txn_size_in_block_output: true,
        add_block_limit_outcome_onchain: false,
        use_granular_resource_group_conflicts: false,
    };
    
    let mut processor = BlockGasLimitProcessor::new(block_gas_limit, None, 10);
    
    // Production-scale transaction
    let fee = FeeStatement::new(2_000_000, 2_000_000, 0, 0, 0);
    
    // This will overflow: 2_000_000 * (u64::MAX / 10)
    processor.accumulate_fee_statement(fee, None, None);
}
```

## Notes

This vulnerability requires governance control to exploit, making it a **configuration vulnerability** rather than a direct attack vector. However, the complete lack of input validation, combined with inadequate test coverage and unchecked arithmetic, creates a critical failure mode that could catastrophically affect the entire network if triggered.

The test coverage gap is severe: testing with `MAX_GAS_PER_TXN = 4` while production uses 2,000,000 means the tests are off by 6 orders of magnitude, fundamentally failing to validate production-scale gas handling.

### Citations

**File:** aptos-move/block-executor/src/combinatorial_tests/types.rs (L43-43)
```rust
pub(crate) const MAX_GAS_PER_TXN: u64 = 4;
```

**File:** config/global-constants/src/lib.rs (L28-31)
```rust
#[cfg(any(test, feature = "testing"))]
pub const MAX_GAS_AMOUNT: u64 = 100_000_000;
#[cfg(not(any(test, feature = "testing")))]
pub const MAX_GAS_AMOUNT: u64 = 2_000_000;
```

**File:** aptos-move/block-executor/src/combinatorial_tests/resource_tests.rs (L38-50)
```rust
pub(crate) fn get_gas_limit_variants(
    use_gas_limit: bool,
    transaction_count: usize,
) -> Vec<Option<u64>> {
    if use_gas_limit {
        vec![
            Some(rand::thread_rng().gen_range(0, (transaction_count as u64) * MAX_GAS_PER_TXN / 2)),
            Some(0),
        ]
    } else {
        vec![None]
    }
}
```

**File:** aptos-move/block-executor/src/limit_processor.rs (L103-109)
```rust
        let raw_gas_used = fee_statement.execution_gas_used()
            * self
                .block_gas_limit_type
                .execution_gas_effective_multiplier()
            + fee_statement.io_gas_used() * self.block_gas_limit_type.io_gas_effective_multiplier();
        self.accumulated_raw_block_gas += raw_gas_used;
        self.accumulated_effective_block_gas += conflict_multiplier * raw_gas_used;
```

**File:** types/src/on_chain_config/execution_config.rs (L280-312)
```rust
    ComplexLimitV1 {
        /// Formula for effective block gas limit:
        /// effective_block_gas_limit <
        /// (execution_gas_effective_multiplier * execution_gas_used +
        ///  io_gas_effective_multiplier * io_gas_used
        /// ) * (1 + num conflicts in conflict_penalty_window)
        effective_block_gas_limit: u64,
        execution_gas_effective_multiplier: u64,
        io_gas_effective_multiplier: u64,
        conflict_penalty_window: u32,

        /// If true we look at granular resource group conflicts (i.e. if same Tag
        /// within a resource group has a conflict)
        /// If false, we treat any conclicts inside of resource groups (even across
        /// non-overlapping tags) as conflicts).
        use_granular_resource_group_conflicts: bool,
        /// Module publishing today fallbacks to sequential execution,
        /// even though there is no read-write conflict.
        /// When enabled, this flag allows us to account for that conflict.
        /// NOTE: Currently not supported.
        use_module_publishing_block_conflict: bool,

        /// Block limit on the total (approximate) txn output size in bytes.
        block_output_limit: Option<u64>,
        /// When set, we include the user txn size in the approximate computation
        /// of block output size, which is compared against the block_output_limit above.
        include_user_txn_size_in_block_output: bool,

        /// When set, we create BlockEpilogue (instead of StateCheckpint) transaction,
        /// which contains BlockEndInfo
        /// NOTE: Currently not supported.
        add_block_limit_outcome_onchain: bool,
    },
```

**File:** aptos-move/framework/aptos-framework/sources/configs/execution_config.move (L48-52)
```text
    public fun set_for_next_epoch(account: &signer, config: vector<u8>) {
        system_addresses::assert_aptos_framework(account);
        assert!(vector::length(&config) > 0, error::invalid_argument(EINVALID_CONFIG));
        config_buffer::upsert(ExecutionConfig { config });
    }
```
