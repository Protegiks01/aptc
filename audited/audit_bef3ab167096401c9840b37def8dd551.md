# Audit Report

## Title
SAFER_RESOURCE_GROUPS Protection Bypass via Empty Metadata Module Upgrade

## Summary
The `SAFER_RESOURCE_GROUPS` feature flag protection can be bypassed when upgrading from a module without metadata. The `extract_resource_group_metadata_from_module()` function incorrectly returns an empty structs set when the old module lacks metadata, allowing attackers to add resource group attributes to existing structs without validation. [1](#0-0) 

## Finding Description
The `SAFER_RESOURCE_GROUPS` feature flag is designed to prevent adding resource_group or resource_group_member attributes to existing structs during module upgrades, as this can cause storage inconsistencies and violate Move's upgrade compatibility guarantees. [2](#0-1) 

The validation at lines 176-186 checks if new resource group attributes are being added to existing structs by testing if struct names exist in the `structs` set extracted from the old module. However, the `extract_resource_group_metadata_from_module()` function has a critical flaw: [3](#0-2) 

When the old module has no metadata section (line 211), the function returns an empty `structs` set. This is incorrect because the old module may still contain struct definitions. The correct behavior should be to extract struct names from the old module regardless of whether metadata exists.

**Attack Path**:
1. Attacker publishes module V1 with struct definitions but without metadata section (explicitly allowed by the validation) [4](#0-3) 

2. Attacker upgrades to module V2, adding `#[resource_group]` or `#[resource_group_member]` attributes to existing structs from V1
3. During validation, `extract_resource_group_metadata_from_module(V1)` returns empty `structs` set (line 211)
4. The SAFER_RESOURCE_GROUPS validation at lines 176-186 checks against empty set, finding no conflicts
5. Resource group attributes are successfully added to existing structs, bypassing protection

This violates the **Deterministic Execution** and **State Consistency** invariants, as resource group semantics change the storage model from individual resources to grouped resources. Existing instances of these structs may not follow resource group layout assumptions, leading to undefined behavior.

## Impact Explanation
This is a **High Severity** vulnerability (up to $50,000) under the "Significant protocol violations" category. The issue:

- **Bypasses Security Feature**: Circumvents SAFER_RESOURCE_GROUPS, which is enabled by default and expected to protect against unsafe upgrades
- **Storage Corruption Risk**: Adding resource group semantics to existing structs retroactively can cause storage model inconsistencies
- **Breaks Upgrade Guarantees**: Violates Move's upgrade compatibility rules that existing struct instances must remain valid [5](#0-4) 

The test above demonstrates that this exact scenario (adding resource_group_member to existing struct) is considered unsafe and should be prevented when SAFER_RESOURCE_GROUPS is enabled.

## Likelihood Explanation
**HIGH likelihood** because:

1. **Attack Requirements**: Only requires publishing a module without metadata (explicitly permitted), then upgrading it
2. **Feasibility**: Modules can be published without metadata through older compilers or manually crafted bytecode
3. **Attacker Capability**: Any unprivileged module publisher can execute this attack
4. **Expected Protection**: Users and developers expect SAFER_RESOURCE_GROUPS (enabled by default) to prevent these unsafe upgrades [6](#0-5) 

## Recommendation
Fix `extract_resource_group_metadata_from_module()` to always extract struct names from the old module, regardless of metadata presence:

```rust
pub(crate) fn extract_resource_group_metadata_from_module(
    old_module: &CompiledModule,
) -> VMResult<(
    BTreeMap<String, ResourceGroupScope>,
    BTreeMap<String, StructTag>,
    BTreeSet<String>,
)> {
    // Always extract struct names for upgrade validation
    let structs = old_module
        .struct_defs()
        .iter()
        .map(|struct_def| {
            let struct_handle = old_module.struct_handle_at(struct_def.struct_handle);
            old_module.identifier_at(struct_handle.name).to_string()
        })
        .collect::<BTreeSet<_>>();
    
    if let Some(metadata) = get_metadata_from_compiled_code(old_module) {
        let (groups, members) = extract_resource_group_metadata(&metadata)?;
        Ok((groups, members, structs))
    } else {
        // Return empty resource group info but preserve struct names
        Ok((BTreeMap::new(), BTreeMap::new(), structs))
    }
}
```

## Proof of Concept

```move
// V1: Module with struct but no metadata (compile with older compiler or manually craft bytecode)
module 0xCAFE::M {
    struct ExistingStruct has key {
        value: u64
    }
}

// V2: Upgrade adding resource_group_member to existing struct
module 0xCAFE::M {
    #[resource_group_member(group = 0xCAFE::M::MyGroup)]
    struct ExistingStruct has key {
        value: u64
    }
    
    #[resource_group(scope = address)]
    struct MyGroup {}
}

// Expected: CONSTRAINT_NOT_SATISFIED due to SAFER_RESOURCE_GROUPS
// Actual: Success (protection bypassed if V1 has no metadata)
```

**Notes**:
The vulnerability specifically affects module upgrades where the original module lacks metadata. The empty structs set causes the SAFER_RESOURCE_GROUPS validation to incorrectly pass, allowing resource group attributes to be added to existing structs despite this being an unsafe operation that can cause storage inconsistencies.

### Citations

**File:** aptos-move/aptos-vm/src/verifier/resource_groups.rs (L167-186)
```rust
    if !features.is_enabled(FeatureFlag::SAFER_RESOURCE_GROUPS) {
        return Ok((new_groups, new_members));
    }

    // At this point, only original structs that do not have resource group affiliation are left.
    // Note, we do not validate for being both a member and a group, because there are other
    // checks earlier on, such as, a resource group must have no abilities, while a resource group
    // member must.

    for group in new_groups.keys() {
        if structs.remove(group) {
            metadata_validation_err("Invalid addition of resource_group attribute")?;
        }
    }

    for member in new_members.keys() {
        if structs.remove(member) {
            metadata_validation_err("Invalid addition of resource_group_member attribute")?;
        }
    }
```

**File:** aptos-move/aptos-vm/src/verifier/resource_groups.rs (L199-212)
```rust
    if let Some(metadata) = get_metadata_from_compiled_code(old_module) {
        let (groups, members) = extract_resource_group_metadata(&metadata)?;
        let structs = old_module
            .struct_defs()
            .iter()
            .map(|struct_def| {
                let struct_handle = old_module.struct_handle_at(struct_def.struct_handle);
                old_module.identifier_at(struct_handle.name).to_string()
            })
            .collect::<BTreeSet<_>>();
        Ok((groups, members, structs))
    } else {
        Ok((BTreeMap::new(), BTreeMap::new(), BTreeSet::new()))
    }
```

**File:** types/src/vm/module_metadata.rs (L452-456)
```rust
    let metadata = if let Some(metadata) = get_metadata_from_compiled_code(module) {
        metadata
    } else {
        return Ok(());
    };
```

**File:** aptos-move/e2e-move-tests/src/tests/resource_groups.rs (L474-508)
```rust
fn verify_unsafe_resource_group_member_upgrades() {
    let mut h = MoveHarness::new_with_features(vec![], vec![FeatureFlag::SAFER_RESOURCE_GROUPS]);
    let account = h.new_account_at(AccountAddress::from_hex_literal("0xf00d").unwrap());

    // Initial code
    let source = r#"
        module 0xf00d::M {
            struct NotResourceGroupMember has key { }

            #[resource_group(scope = address)]
            struct ResourceGroup { }
        }
        "#;
    let mut builder = PackageBuilder::new("Package");
    builder.add_source("m.move", source);
    let path = builder.write_to_temp().unwrap();
    let result = h.publish_package(&account, path.path());
    assert_success!(result);

    // Incompatible addition of ResourceGroupMember
    let source = r#"
        module 0xf00d::M {
            #[resource_group_member(group = 0xf00d::M::ResourceGroup)]
            struct NotResourceGroupMember has key { }

            #[resource_group(scope = address)]
            struct ResourceGroup { }
        }
        "#;
    let mut builder = PackageBuilder::new("Package");
    builder.add_source("m.move", source);
    let path = builder.write_to_temp().unwrap();
    let result = h.publish_package(&account, path.path());
    assert_success!(result);
}
```

**File:** aptos-move/e2e-move-tests/src/tests/resource_groups.rs (L592-626)
```rust
fn verify_unsafe_resource_group_upgrades() {
    let mut h = MoveHarness::new_with_features(vec![], vec![FeatureFlag::SAFER_RESOURCE_GROUPS]);
    let account = h.new_account_at(AccountAddress::from_hex_literal("0xf00d").unwrap());

    // Initial code
    let source = r#"
        module 0xf00d::M {
            #[resource_group(scope = address)]
            struct ResourceGroup { }

            struct NotResourceGroup { }
        }
        "#;
    let mut builder = PackageBuilder::new("Package");
    builder.add_source("m.move", source);
    let path = builder.write_to_temp().unwrap();
    let result = h.publish_package(&account, path.path());
    assert_success!(result);

    // Incompatible promotion of ResourceGroup
    let source = r#"
        module 0xf00d::M {
            #[resource_group(scope = address)]
            struct ResourceGroup { }

            #[resource_group(scope = address)]
            struct NotResourceGroup { }
        }
        "#;
    let mut builder = PackageBuilder::new("Package");
    builder.add_source("m.move", source);
    let path = builder.write_to_temp().unwrap();
    let result = h.publish_package(&account, path.path());
    assert_success!(result);
}
```
