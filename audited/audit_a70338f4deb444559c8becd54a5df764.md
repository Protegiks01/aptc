# Audit Report

## Title
Script Type Parameter Limit Bypass Allows Excessive Type Instantiation Beyond Intended 32-Parameter Limit

## Summary
The LimitsVerifier does not enforce the `max_generic_instantiation_length` limit on a script's own type parameters, allowing scripts with up to 255 type parameters to pass verification despite the production limit being set to 32. This bypasses security controls intended to prevent excessive type complexity during execution.

## Finding Description

The Aptos bytecode verifier establishes a `max_generic_instantiation_length` limit of 32 in production to control type parameter complexity: [1](#0-0) 

However, during script verification, the `LimitsVerifier` only checks this limit against function handles and struct handles, but **not** against the script's own `type_parameters` field: [2](#0-1) 

The `verify_script_impl` function calls `verify_function_handles` and `verify_struct_handles`, but neither checks the script's direct `type_parameters` field: [3](#0-2) 

Meanwhile, the serialization format allows up to 255 type parameters: [4](#0-3) 

The signature_v2 verifier provides a much higher limit of 256: [5](#0-4) 

The `SIGNATURE_CHECKER_V2_SCRIPT_FIX` feature flag is enabled by default but only fixes bitset sizing, not the limit enforcement: [6](#0-5) 

**Attack Path:**
1. Attacker crafts a CompiledScript with `type_parameters` containing 100+ entries
2. Script serialization succeeds (limit: 255)
3. During verification via `verify_script_with_config`: [7](#0-6) 
   - BoundsChecker passes (only checks indices are in bounds)
   - LimitsVerifier passes (doesn't check script.type_parameters.len())
   - signature_v2 passes (allows up to 256)
4. Script is executed with excessive type arguments

**Test Evidence:** The codebase includes a test that successfully executes a script with 33 type parameters, confirming the bypass: [8](#0-7) 

## Impact Explanation

**Medium Severity** - This vulnerability allows bypassing the intended type parameter limit, which can lead to:

1. **Excessive Memory Consumption**: Loading 255 type arguments with maximum complexity (128 nodes each) consumes approximately 8x more memory than the intended limit (32 parameters × 128 nodes = 4,096 nodes vs. 255 × 128 = 32,640 nodes)

2. **Increased CPU Usage**: Type instantiation operations scale with type parameter count

3. **Security Control Bypass**: The 32-parameter limit exists as an intentional security boundary that is being circumvented

While gas metering prevents complete resource exhaustion, the vulnerability still allows consumption of significantly more resources than intended by the security policy. This represents a violation of defense-in-depth principles where multiple layers of protection should enforce consistent limits.

## Likelihood Explanation

**High Likelihood** - This vulnerability is:
- Easy to exploit (requires crafting a script with >32 type parameters)
- No special permissions required (any transaction sender can submit scripts)
- Not dependent on race conditions or timing
- Repeatable and deterministic
- Confirmed by existing test evidence showing successful execution with 33 type parameters

The only mitigating factor is that gas costs increase proportionally with type parameter count, but attacks in the 33-100 type parameter range remain economically viable.

## Recommendation

Add a validation check in `LimitsVerifier::verify_script_impl` to enforce the `max_generic_instantiation_length` limit on the script's own `type_parameters` field:

```rust
fn verify_script_impl(
    config: &VerifierConfig,
    script: &'a CompiledScript,
) -> PartialVMResult<()> {
    let limit_check = Self {
        resolver: BinaryIndexedView::Script(script),
    };
    
    // Add this check for script's own type parameters
    if let Some(limit) = config.max_generic_instantiation_length {
        if script.type_parameters.len() > limit {
            return Err(PartialVMError::new(StatusCode::TOO_MANY_TYPE_PARAMETERS));
        }
    }
    
    limit_check.verify_function_handles(config)?;
    limit_check.verify_struct_handles(config)?;
    limit_check.verify_type_nodes(config)
}
```

## Proof of Concept

The existing test in the codebase serves as a proof of concept, demonstrating that scripts with 33 type parameters (exceeding the intended limit of 32) execute successfully: [9](#0-8) 

To reproduce:
1. Compile a Move script with 50+ generic type parameters
2. Submit the script transaction with corresponding type arguments
3. Observe successful execution despite exceeding the production limit of 32

## Notes

While gas metering provides a fallback defense mechanism that prevents catastrophic resource exhaustion, the security model should enforce consistent limits across all validation layers. The 32-parameter limit was established intentionally, and its bypass represents a security control failure even with gas-based mitigation in place.

### Citations

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L158-158)
```rust
        max_generic_instantiation_length: Some(32),
```

**File:** third_party/move/move-bytecode-verifier/src/limits.rs (L41-51)
```rust
    fn verify_script_impl(
        config: &VerifierConfig,
        script: &'a CompiledScript,
    ) -> PartialVMResult<()> {
        let limit_check = Self {
            resolver: BinaryIndexedView::Script(script),
        };
        limit_check.verify_function_handles(config)?;
        limit_check.verify_struct_handles(config)?;
        limit_check.verify_type_nodes(config)
    }
```

**File:** third_party/move/move-bytecode-verifier/src/limits.rs (L65-94)
```rust
    fn verify_function_handles(&self, config: &VerifierConfig) -> PartialVMResult<()> {
        for (idx, function_handle) in self.resolver.function_handles().iter().enumerate() {
            if let Some(limit) = config.max_generic_instantiation_length {
                if function_handle.type_parameters.len() > limit {
                    return Err(PartialVMError::new(StatusCode::TOO_MANY_TYPE_PARAMETERS)
                        .at_index(IndexKind::FunctionHandle, idx as u16));
                }
            };
            if let Some(limit) = config.max_function_parameters {
                if self
                    .resolver
                    .signature_at(function_handle.parameters)
                    .0
                    .len()
                    > limit
                {
                    return Err(PartialVMError::new(StatusCode::TOO_MANY_PARAMETERS)
                        .at_index(IndexKind::FunctionHandle, idx as u16));
                }
            }
            if let Some(limit) = config.max_function_return_values {
                if self.resolver.signature_at(function_handle.return_).0.len() > limit {
                    return Err(PartialVMError::new(StatusCode::TOO_MANY_PARAMETERS)
                        .at_index(IndexKind::FunctionHandle, idx as u16));
                }
            };
            // Note: the size of `attributes` is limited by the deserializer.
        }
        Ok(())
    }
```

**File:** third_party/move/move-binary-format/src/file_format_common.rs (L83-83)
```rust
pub const TYPE_PARAMETER_COUNT_MAX: u64 = 255;
```

**File:** third_party/move/move-bytecode-verifier/src/signature_v2.rs (L1273-1290)
```rust
pub fn verify_script(config: &VerifierConfig, script: &CompiledScript) -> VMResult<()> {
    let mut max_num = max_num_of_ty_params_or_args(BinaryIndexedView::Script(script));
    if config.sig_checker_v2_fix_script_ty_param_count {
        max_num = max_num.max(script.type_parameters.len());
    }

    let res = if max_num <= NUM_PARAMS_PER_WORD {
        verify_script_impl::<1>(config, script)
    } else if max_num <= NUM_PARAMS_PER_WORD * 2 {
        verify_script_impl::<2>(config, script)
    } else if max_num <= NUM_PARAMS_PER_WORD * 16 {
        verify_script_impl::<16>(config, script)
    } else {
        return Err(
            PartialVMError::new(StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR)
                .with_message("too many type parameters/arguments in the program".to_string())
                .finish(Location::Undefined),
        );
```

**File:** types/src/on_chain_config/aptos_features.rs (L203-203)
```rust
            FeatureFlag::SIGNATURE_CHECKER_V2_SCRIPT_FIX,
```

**File:** third_party/move/move-bytecode-verifier/src/verifier.rs (L189-222)
```rust
pub fn verify_script_with_config(config: &VerifierConfig, script: &CompiledScript) -> VMResult<()> {
    if config.verify_nothing() {
        return Ok(());
    }
    let prev_state = move_core_types::state::set_state(VMState::VERIFIER);
    let result = std::panic::catch_unwind(|| {
        // Always needs to run bound checker first as subsequent passes depend on it
        BoundsChecker::verify_script(script).map_err(|e| {
            // We can't point the error at the script, because if bounds-checking
            // failed, we cannot safely index into script
            e.finish(Location::Undefined)
        })?;
        FeatureVerifier::verify_script(config, script)?;
        LimitsVerifier::verify_script(config, script)?;
        DuplicationChecker::verify_script(script)?;

        signature_v2::verify_script(config, script)?;

        InstructionConsistency::verify_script(script)?;
        constants::verify_script(script)?;
        CodeUnitVerifier::verify_script(config, script)?;
        script_signature::verify_script(script, no_additional_script_signature_checks)
    })
    .unwrap_or_else(|_| {
        Err(
            PartialVMError::new(StatusCode::VERIFIER_INVARIANT_VIOLATION)
                .with_message("[VM] bytecode verifier panicked for script".to_string())
                .finish(Location::Undefined),
        )
    });
    move_core_types::state::set_state(prev_state);

    result
}
```

**File:** aptos-move/e2e-move-tests/src/tests/scripts.rs (L122-148)
```rust
fn test_script_with_type_parameter() {
    let mut h = MoveHarness::new();

    let alice = h.new_account_at(AccountAddress::from_hex_literal("0xa11ce").unwrap());

    let package = BuiltPackage::build(
        common::test_dir_path("script_with_ty_param.data/pack"),
        aptos_framework::BuildOptions::default(),
    )
    .expect("building package must succeed");

    let code = package.extract_script_code().into_iter().next().unwrap();

    let txn = TransactionBuilder::new(alice.clone())
        .script(Script::new(
            code,
            std::iter::repeat_with(|| TypeTag::U64).take(33).collect(),
            vec![],
        ))
        .sequence_number(10)
        .max_gas_amount(1_000_000)
        .gas_unit_price(1)
        .sign();

    let status = h.run(txn);
    assert_success!(status);
}
```
