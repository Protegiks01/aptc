# Audit Report

## Title
Timeout Certificate Verification Allows QC Substitution Leading to Consensus Safety Violations

## Summary
The `TwoChainTimeoutCertificate::verify()` function only validates that the embedded QuorumCert's round number matches the maximum signed round from validators' timeout messages, but does not verify that the full QC content (block ID, state root, etc.) matches what validators actually had when signing. This allows a malicious aggregator to substitute a different valid QC with the same round number, potentially causing validators to sync to divergent chains and violating consensus safety.

## Finding Description

When validators create timeout messages, they sign a `TimeoutSigningRepr` structure containing only three fields: `epoch`, `round`, and `hqc_round` (the round number of their highest quorum cert). Critically, they do NOT sign the full QuorumCert content. [1](#0-0) 

During timeout aggregation, individual timeout messages from different validators (each potentially having different QCs) are collected. The aggregator keeps the timeout with the highest `hqc_round`: [2](#0-1) 

However, if multiple validators have different QCs for the **same round** (which can occur during Byzantine scenarios with equivocating validators), the aggregator's choice of which QC to include becomes arbitrary - it depends on the order timeouts are received, not on which QC the majority actually had.

The verification process reconstructs what each validator signed using only the round numbers from `signatures_with_rounds`, then verifies signatures against these reconstructed messages: [3](#0-2) 

Finally, it checks that the embedded QC's round equals the maximum signed round: [4](#0-3) 

**The Critical Gap**: The verification ensures round number consistency but not QC content consistency. If there exist two different valid QCs for the same round (QC_A and QC_B, both for round 10 but with different block IDs), a malicious aggregator can:

1. Collect timeout signatures from validators where some had QC_A and others had QC_B
2. All validators sign `TimeoutSigningRepr(epoch=E, round=11, hqc_round=10)` - identical messages
3. The aggregator creates a certificate with QC_A (or QC_B, their choice)
4. Verification passes because all signatures are valid for `hqc_round=10`
5. But validators who actually had QC_B signed expecting their peers to know about QC_B, not QC_A

This breaks the consensus invariant that timeout certificates accurately represent the network's highest known QC. When validators receive this timeout certificate via `SyncInfo`, they may sync to the wrong chain, causing safety violations. [5](#0-4) 

## Impact Explanation

**Severity: Critical** - This vulnerability enables consensus safety violations, which falls under the Critical category: "Consensus/Safety violations" worth up to $1,000,000.

**Attack Impact**:
- **Chain Fork**: Different validators may build on different QCs for the same round, creating divergent chains
- **Double-Spending**: Transactions could be committed on one fork but not the other
- **Network Split**: The network could partition into validators following chain A versus chain B
- **Loss of Byzantine Fault Tolerance**: The protocol is supposed to tolerate f Byzantine validators, but this weakness allows Byzantine behavior to be amplified through timeout certificate manipulation

The vulnerability undermines the fundamental consensus safety guarantee that all honest validators agree on a single blockchain history.

## Likelihood Explanation

**Likelihood: Medium to High**

**Prerequisites**:
1. **Multiple valid QCs for the same round exist** - Requires Byzantine validators to equivocate (double-vote). With f Byzantine validators, this is possible if they coordinate to create conflicting QCs.
2. **Validators timeout with different QCs** - During network delays or Byzantine attacks, different validators may have different views of the highest QC when timing out.
3. **Malicious aggregator** - Any validator receiving enough timeout messages can act as aggregator. A single Byzantine validator in the right position can exploit this.

**Realistic Scenarios**:
- Network partition during round R causes validators to form conflicting QCs
- Byzantine validators deliberately create conflicting QCs then cause a timeout
- During epoch transitions or periods of high network latency

The attack does not require controlling >f validators or special privileges - a single Byzantine validator acting as aggregator during a timeout round can exploit this verification weakness.

## Recommendation

The verification must ensure that the embedded QC's content (not just its round number) corresponds to what validators actually signed. Since validators only sign the round number, the verification cannot directly check QC content matching. Instead, implement one of these solutions:

**Solution 1: Sign Full QC Hash**
Modify `TimeoutSigningRepr` to include the QC's hash:

```rust
#[derive(Serialize, Deserialize, Debug, CryptoHasher, BCSCryptoHash)]
pub struct TimeoutSigningRepr {
    pub epoch: u64,
    pub round: Round,
    pub hqc_round: Round,
    pub hqc_hash: HashValue,  // Add hash of the QC
}
```

Update `signing_format()` and `verify()` accordingly to include and verify the QC hash.

**Solution 2: Majority Vote on QC**
During aggregation, track which specific QC each validator had. Only include a QC in the final certificate if at least f+1 validators had that exact QC. Reject certificates where validators are split between different QCs for the same round.

**Solution 3: Stricter Aggregation**
In `TwoChainTimeoutWithPartialSignatures::add()`, verify that all added timeouts with the same `hqc_round` have identical QC content (not just round numbers). Reject mixing timeouts with different QCs:

```rust
let hqc_round = timeout.hqc_round();
if timeout.hqc_round() == self.timeout.hqc_round() {
    // Verify QC content matches exactly
    ensure!(
        timeout.quorum_cert() == self.timeout.quorum_cert(),
        "Cannot aggregate timeouts with different QCs for the same round"
    );
} else if timeout.hqc_round() > self.timeout.hqc_round() {
    self.timeout = timeout;
}
```

## Proof of Concept

```rust
#[cfg(test)]
mod timeout_qc_substitution_test {
    use super::*;
    use aptos_types::{
        validator_verifier::random_validator_verifier,
        block_info::BlockInfo,
    };
    use aptos_crypto::hash::HashValue;
    
    #[test]
    fn test_timeout_cert_accepts_wrong_qc() {
        // Setup: 4 validators
        let (signers, validators) = random_validator_verifier(4, None, false);
        
        // Create two DIFFERENT valid QCs for round 10
        // (In practice, this requires Byzantine equivocation)
        let qc_a = generate_valid_qc(10, HashValue::random(), &signers[0..3], &validators);
        let qc_b = generate_valid_qc(10, HashValue::random(), &signers[1..4], &validators);
        
        // Validators timeout at round 11
        // Validators 0,1 have QC_A; Validators 2,3 have QC_B
        let timeout_a = TwoChainTimeout::new(1, 11, qc_a.clone());
        let timeout_b = TwoChainTimeout::new(1, 11, qc_b.clone());
        
        // All sign the SAME TimeoutSigningRepr (only includes round number!)
        let sig_0 = timeout_a.sign(&signers[0]).unwrap();
        let sig_1 = timeout_a.sign(&signers[1]).unwrap();
        let sig_2 = timeout_b.sign(&signers[2]).unwrap();  // Same signing format
        let sig_3 = timeout_b.sign(&signers[3]).unwrap();  // Same signing format
        
        // Malicious aggregator creates cert with QC_A
        let mut tc_partial = TwoChainTimeoutWithPartialSignatures::new(timeout_a);
        tc_partial.add(signers[0].author(), timeout_a.clone(), sig_0);
        tc_partial.add(signers[1].author(), timeout_a.clone(), sig_1);
        tc_partial.add(signers[2].author(), timeout_b.clone(), sig_2);  // Has QC_B!
        tc_partial.add(signers[3].author(), timeout_b.clone(), sig_3);  // Has QC_B!
        
        let tc = tc_partial.aggregate_signatures(&validators).unwrap();
        
        // Verification PASSES even though validators 2,3 signed with QC_B in mind
        assert!(tc.verify(&validators).is_ok());
        
        // But the certificate contains QC_A, not QC_B!
        assert_eq!(tc.timeout.quorum_cert(), &qc_a);
        // This misleads the network about which QC validators actually had
    }
}
```

**Notes**

The vulnerability exists because `TimeoutSigningRepr` only includes `hqc_round`, not the full QC content, making it impossible for verification to detect QC substitution. This is a design flaw that allows Byzantine validators to manipulate timeout certificates during periods of network disagreement, potentially causing consensus safety violations by misleading honest validators about which chain has the most support.

### Citations

**File:** consensus/consensus-types/src/timeout_2chain.rs (L96-103)
```rust
/// Validators sign this structure that allows the TwoChainTimeoutCertificate to store a round number
/// instead of a quorum cert per validator in the signatures field.
#[derive(Serialize, Deserialize, Debug, CryptoHasher, BCSCryptoHash)]
pub struct TimeoutSigningRepr {
    pub epoch: u64,
    pub round: Round,
    pub hqc_round: Round,
}
```

**File:** consensus/consensus-types/src/timeout_2chain.rs (L147-166)
```rust
                let timeout_messages: Vec<_> = self
                    .signatures_with_rounds
                    .get_voters_and_rounds(
                        &validators
                            .get_ordered_account_addresses_iter()
                            .collect_vec(),
                    )
                    .into_iter()
                    .map(|(_, round)| TimeoutSigningRepr {
                        epoch: self.timeout.epoch(),
                        round: self.timeout.round(),
                        hqc_round: round,
                    })
                    .collect();
                let timeout_messages_ref: Vec<_> = timeout_messages.iter().collect();
                validators.verify_aggregate_signatures(
                    &timeout_messages_ref,
                    self.signatures_with_rounds.sig(),
                )
            },
```

**File:** consensus/consensus-types/src/timeout_2chain.rs (L170-181)
```rust
        let signed_hqc = self
            .signatures_with_rounds
            .rounds()
            .iter()
            .max()
            .ok_or_else(|| anyhow::anyhow!("Empty rounds"))?;
        ensure!(
            hqc_round == *signed_hqc,
            "Inconsistent hqc round, qc has round {}, highest signed round {}",
            hqc_round,
            *signed_hqc
        );
```

**File:** consensus/consensus-types/src/timeout_2chain.rs (L258-262)
```rust
        let hqc_round = timeout.hqc_round();
        if timeout.hqc_round() > self.timeout.hqc_round() {
            self.timeout = timeout;
        }
        self.signatures.add_signature(author, hqc_round, signature);
```

**File:** consensus/consensus-types/src/sync_info.rs (L23-24)
```rust
    /// Optional highest timeout certificate if available.
    highest_2chain_timeout_cert: Option<TwoChainTimeoutCertificate>,
```
