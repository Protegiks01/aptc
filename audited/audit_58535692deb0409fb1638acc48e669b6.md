# Audit Report

## Title
Consensus Divergence via Features::default() Fallback in Gas Calculation

## Summary
The `AptosEnvironment::new()` function uses `Features::default()` as a fallback when the on-chain `Features` configuration is not found in the state view. This fallback has a hardcoded set of 100+ enabled features that may differ from production on-chain Features (modified through governance). Since Features determines which `DiskSpacePricing` version (V1 or V2) is used for gas calculation, validators executing with different Features values will calculate different gas amounts, producing different state roots and causing consensus failure. [1](#0-0) 

## Finding Description
The vulnerability exists in the VM environment initialization flow:

1. **Environment Creation with Fallback**: When creating an execution environment, Features is fetched from on-chain state with a fallback to `Features::default()`: [1](#0-0) 

2. **Features Determines Gas Pricing**: The fetched Features is passed to `get_gas_parameters()` which creates `StorageGasParameters`: [2](#0-1) 

3. **StorageGasParameters Uses Features for Pricing Selection**: The `DiskSpacePricing::new()` function checks if `REFUNDABLE_BYTES` feature is enabled to decide between V1 and V2 pricing: [3](#0-2) 

4. **Different Pricing Versions Use Different Gas Formulas**: V1 and V2 have completely different gas calculation algorithms. For example, event storage fees differ fundamentally: [4](#0-3) 

5. **Features::default() Has Hardcoded Feature Set**: The default includes `REFUNDABLE_BYTES` and 100+ other features: [5](#0-4) [6](#0-5) 

6. **Features Can Be Modified Through Governance**: Production Features can differ from defaults through governance proposals: [7](#0-6) 

**Breaking the Deterministic Execution Invariant**: If one validator executes with `Features::default()` (when Features is missing from state) while others execute with actual on-chain Features that have been modified through governance, they will:
- Use different `DiskSpacePricing` versions
- Calculate different gas amounts for identical transactions
- Produce different state roots
- Fail to reach consensus

## Impact Explanation
**Critical Severity** - This vulnerability causes consensus divergence, breaking the fundamental "Deterministic Execution" invariant. When validators produce different state roots for the same block, AptosBFT consensus cannot proceed, causing:
- Complete network halt requiring manual intervention
- Potential network split if validators diverge on which state root is correct
- Violation of the safety guarantee that all honest validators commit identical blocks

This meets the **Critical Severity** criteria: "Consensus/Safety violations" and "Total loss of liveness/network availability".

## Likelihood Explanation
**Medium-to-Low Likelihood** but catastrophic impact:

**Scenarios where Features could be missing:**
1. **State sync edge cases**: Validator joining network before Features is fully synced
2. **Database restoration**: Validator restoring from backup missing on-chain config
3. **Genesis initialization**: Brief window before Features is written
4. **State corruption**: Database corruption affecting the Features resource at @std

**Requirements for exploitation:**
- Production Features must differ from `Features::default()` (through governance)
- At least one validator must execute transactions without Features in state view
- That validator must participate in block execution/consensus

While the likelihood is reduced by safeguards in state sync and initialization, the catastrophic nature of consensus failure makes this a critical concern requiring defensive fixes.

## Recommendation
**Primary Fix**: Remove the fallback and treat missing Features as a critical error:

```rust
let features = fetch_config_and_update_hash::<Features>(&mut sha3_256, state_view)
    .expect("Features configuration must exist in state view for transaction execution");
```

**Alternative Fix**: Add explicit validation before executing transactions:

```rust
fn validate_state_completeness(state_view: &impl StateView) -> Result<(), String> {
    if Features::fetch_config(state_view).is_none() {
        return Err("Cannot execute transactions: Features configuration missing from state".to_string());
    }
    // Validate other critical on-chain configs...
    Ok(())
}
```

**Additional Safeguards**:
1. Add state sync validation ensuring Features is synced before allowing consensus participation
2. Add genesis validation ensuring Features is initialized before any transaction execution
3. Add monitoring/alerts when `Features::default()` fallback is used in production
4. Document that `Features::default()` should only be used in testing contexts

## Proof of Concept
```rust
// Test demonstrating gas divergence when Features differ
#[test]
fn test_gas_divergence_from_features_mismatch() {
    use aptos_types::{
        on_chain_config::{Features, FeatureFlag},
        state_store::MockStateView,
    };
    use aptos_vm_types::storage::StorageGasParameters;
    use aptos_gas_schedule::AptosGasParameters;
    
    // Scenario 1: Validator with Features in state (REFUNDABLE_BYTES disabled)
    let mut production_features = Features::default();
    production_features.disable(FeatureFlag::REFUNDABLE_BYTES);
    
    let mut state_view_with_features = MockStateView::empty();
    state_view_with_features.set_features(production_features.clone());
    
    // Scenario 2: Validator without Features in state (uses default with REFUNDABLE_BYTES enabled)
    let state_view_empty = MockStateView::empty();
    
    // Create environments
    let env1 = AptosEnvironment::new(&state_view_with_features);
    let env2 = AptosEnvironment::new(&state_view_empty);
    
    // Get storage gas params
    let storage_params_1 = env1.storage_gas_params().unwrap();
    let storage_params_2 = env2.storage_gas_params().unwrap();
    
    // Create identical write operations
    let write_op_info = WriteOpInfo {
        key: &StateKey::raw(&[1, 2, 3]),
        op_size: WriteOpSize::Creation { write_len: 100 },
        prev_size: 0,
        metadata_mut: &mut StateValueMetadata::new(0, 0, &timestamp),
    };
    
    // Calculate gas for both
    let gas_1 = storage_params_1.space_pricing.charge_refund_write_op(&params, write_op_info.clone());
    let gas_2 = storage_params_2.space_pricing.charge_refund_write_op(&params, write_op_info.clone());
    
    // ASSERTION FAILS: Different validators calculate different gas for identical operation
    assert_eq!(gas_1.charge, gas_2.charge, 
        "Validators with different Features calculate different gas amounts, causing consensus divergence");
}
```

**Notes**
The vulnerability is theoretical but demonstrable through the code flow. The actual exploitation in production depends on operational scenarios where validators could execute with incomplete state. However, the defensive programming principle requires treating this as a critical issue: **gas calculation must be deterministic across all validators**, and relying on a hardcoded default when on-chain configuration differs is a violation of this principle.

### Citations

**File:** aptos-move/aptos-vm-environment/src/environment.rs (L219-220)
```rust
        let features =
            fetch_config_and_update_hash::<Features>(&mut sha3_256, state_view).unwrap_or_default();
```

**File:** aptos-move/aptos-vm-environment/src/environment.rs (L246-247)
```rust
        let (gas_params, storage_gas_params, gas_feature_version) =
            get_gas_parameters(&mut sha3_256, &features, state_view);
```

**File:** aptos-move/aptos-vm-types/src/storage/space_pricing.rs (L37-43)
```rust
    pub fn new(gas_feature_version: u64, features: &Features) -> Self {
        if gas_feature_version >= 13 && features.is_refundable_bytes_enabled() {
            Self::V2
        } else {
            Self::V1
        }
    }
```

**File:** aptos-move/aptos-vm-types/src/storage/space_pricing.rs (L57-69)
```rust
    /// Calculates the storage fee for an event.
    pub fn legacy_storage_fee_per_event(
        &self,
        params: &TransactionGasParameters,
        event: &ContractEvent,
    ) -> Fee {
        match self {
            Self::V1 => {
                NumBytes::new(event.size() as u64) * params.legacy_storage_fee_per_event_byte
            },
            Self::V2 => 0.into(),
        }
    }
```

**File:** types/src/on_chain_config/aptos_features.rs (L222-222)
```rust
            FeatureFlag::REFUNDABLE_BYTES,
```

**File:** types/src/on_chain_config/aptos_features.rs (L287-297)
```rust
impl Default for Features {
    fn default() -> Self {
        let mut features = Features {
            features: vec![0; 5],
        };

        for feature in FeatureFlag::default_features() {
            features.enable(feature);
        }
        features
    }
```

**File:** aptos-move/framework/move-stdlib/sources/configs/features.move (L805-828)
```text
    public fun change_feature_flags_for_next_epoch(
        framework: &signer,
        enable: vector<u64>,
        disable: vector<u64>
    ) acquires PendingFeatures, Features {
        assert!(signer::address_of(framework) == @std, error::permission_denied(EFRAMEWORK_SIGNER_NEEDED));

        // Figure out the baseline feature vec that the diff will be applied to.
        let new_feature_vec = if (exists<PendingFeatures>(@std)) {
            // If there is a buffered feature vec, use it as the baseline.
            let PendingFeatures { features } = move_from<PendingFeatures>(@std);
            features
        } else if (exists<Features>(@std)) {
            // Otherwise, use the currently effective feature flag vec as the baseline, if it exists.
            Features[@std].features
        } else {
            // Otherwise, use an empty feature vec.
            vector[]
        };

        // Apply the diff and save it to the buffer.
        apply_diff(&mut new_feature_vec, enable, disable);
        move_to(framework, PendingFeatures { features: new_feature_vec });
    }
```
