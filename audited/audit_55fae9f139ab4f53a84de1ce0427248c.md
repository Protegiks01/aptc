# Audit Report

## Title
Failure Epilogue Error Handling Allows Transaction Discard Without Gas Charging

## Summary
When a transaction execution fails and enters the "keep, only charge gas" flow, if the failure epilogue itself encounters an error, the transaction is discarded without charging any gas. This contradicts the system's own defensive comments and creates a potential DoS vector if the epilogue can be made to fail reliably.

## Finding Description

The vulnerability exists in the transaction failure handling path in `aptos-move/aptos-vm/src/aptos_vm.rs`. When a transaction fails during execution, the system calls `failed_transaction_cleanup` to charge gas for the failed transaction. [1](#0-0) 

The code includes an explicit comment acknowledging that discarding failed transactions would enable DoS attacks: [2](#0-1) 

However, when `finish_aborted_transaction` returns an error, the code uses `unwrap_or_else` to discard the transaction: [3](#0-2) 

The `finish_aborted_transaction` function executes the failure epilogue which is responsible for charging gas: [4](#0-3) 

If the epilogue execution fails, it's caught by `expect_only_successful_execution` which converts any error to an invariant violation: [5](#0-4) 

This error propagates back and triggers the `unwrap_or_else` fallback, resulting in a discarded transaction with no gas charged: [6](#0-5) 

Even though the `CHARGE_INVARIANT_VIOLATION` feature flag is enabled by default to prevent discarding invariant violations: [7](#0-6) 

The `unwrap_or_else` at line 623 bypasses this protection entirely by directly calling `discarded_output`, which creates a `TransactionStatus::Discard`.

## Impact Explanation

This issue represents a **High Severity** vulnerability under the Aptos bug bounty program criteria for "Significant protocol violations" and potential "Validator node slowdowns."

While the attack path requires making the failure epilogue fail (which is difficult under normal circumstances), the impact would be significant:

1. **Free Transaction Spam**: If triggered, attackers could submit transactions that fail execution but don't pay gas, enabling free network spam
2. **Validator Resource Exhaustion**: Validators would process transactions without compensation
3. **Network Degradation**: Sustained attacks could slow down the network

The severity is tempered by the difficulty of exploitation - the failure epilogue is designed not to fail and has multiple safeguards. However, edge cases exist:
- Race conditions in parallel execution (Block-STM)
- Storage system anomalies
- Unexpected state during concurrent modifications
- Bugs in native functions called by the epilogue

## Likelihood Explanation

**Likelihood: Low to Medium**

The likelihood is low because:
- The epilogue is executed with `UnmeteredGasMeter`, so it cannot fail due to gas limits
- State changes from failed transactions are rolled back, so balance checks should pass
- The prologue already validates all preconditions

However, the likelihood increases due to:
- Block-STM parallel execution introducing race conditions
- Complex state interactions in the Move epilogue
- Dependency on external functions (`transaction_fee::burn_fee`, `account::increment_sequence_number`)
- The contradiction between the code comment warning about DoS and the actual implementation

The fact that the code explicitly warns against this pattern but then implements it suggests this is a known theoretical risk.

## Recommendation

**Primary Fix**: Ensure gas is always charged for kept transactions, even if epilogue execution encounters errors. Modify `failed_transaction_cleanup` to never discard transactions that should be kept:

```rust
match txn_status {
    TransactionStatus::Keep(status) => {
        let output = self
            .finish_aborted_transaction(...)
            .unwrap_or_else(|epilogue_error| {
                // CRITICAL: Even if epilogue fails, we must charge gas to prevent DoS
                // Create a minimal output that charges gas based on gas_meter state
                warn!("Epilogue failed for already-failed transaction: {:?}", epilogue_error);
                
                // Calculate fee from current gas meter state
                let fee_statement = AptosVM::fee_statement_from_gas_meter(
                    txn_data, 
                    gas_meter, 
                    0 // zero storage refund
                );
                
                // Create output that keeps transaction and charges gas
                VMOutput::empty_with_fee(
                    fee_statement,
                    status,
                )
            });
        (error_vm_status, output)
    },
    // ... rest unchanged
}
```

**Secondary Measures**:
1. Add comprehensive testing for epilogue failure scenarios
2. Add monitoring/alerting when epilogue failures occur
3. Review all code paths in the epilogue to ensure robustness
4. Consider making epilogue execution infallible through defensive programming

## Proof of Concept

Due to the defensive design of the epilogue, creating a reliable PoC requires either:
1. Injecting faults into the storage layer
2. Triggering race conditions in Block-STM
3. Finding a bug in epilogue dependencies

A theoretical PoC structure (requires fault injection framework):

```rust
// This is a conceptual PoC - actual exploitation requires triggering epilogue failures
#[test]
fn test_epilogue_failure_discards_transaction() {
    // Setup: Create a transaction that will fail execution
    let txn = create_failing_transaction();
    
    // Inject fault: Make epilogue fail (requires test framework support)
    inject_epilogue_failure();
    
    // Execute: Transaction fails, enters failure cleanup
    let (status, output) = vm.execute_user_transaction(...);
    
    // Verify: Transaction was discarded, no gas charged
    assert_eq!(output.status(), TransactionStatus::Discard(_));
    assert_eq!(output.gas_used(), 0); // No gas charged - vulnerability confirmed
}
```

## Notes

This vulnerability demonstrates a disconnect between the code's defensive comments and its actual implementation. The comment at lines 580-586 explicitly states "Option (2) does not work, since it would enable DoS attacks," yet the `unwrap_or_else` at line 623 implements exactly that option.

While exploitation requires triggering epilogue failures (which is difficult), the existence of this code path contradicts fundamental gas charging invariants and creates unnecessary risk. The fix should ensure that gas is always charged for transactions that pass the keep/discard decision point.

### Citations

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L561-632)
```rust
    pub(crate) fn failed_transaction_cleanup(
        &self,
        prologue_session_change_set: SystemSessionChangeSet,
        error_vm_status: VMStatus,
        gas_meter: &mut impl AptosGasMeter,
        txn_data: &TransactionMetadata,
        resolver: &impl AptosMoveResolver,
        module_storage: &impl AptosModuleStorage,
        serialized_signers: &SerializedSigners,
        log_context: &AdapterLogSchema,
        change_set_configs: &ChangeSetConfigs,
        traversal_context: &mut TraversalContext,
    ) -> (VMStatus, VMOutput) {
        if self.gas_feature_version() >= 12 {
            // Check if the gas meter's internal counters are consistent.
            //
            // Since we are already in the failure epilogue, there is not much we can do
            // other than logging the inconsistency.
            //
            // This is a tradeoff. We have to either
            //   1. Continue to calculate the gas cost based on the numbers we have.
            //   2. Discard the transaction.
            //
            // Option (2) does not work, since it would enable DoS attacks.
            // Option (1) is not ideal, but optimistically, it should allow the network
            // to continue functioning, less the transactions that run into this problem.
            if let Err(err) = gas_meter.algebra().check_consistency() {
                println!(
                    "[aptos-vm][gas-meter][failure-epilogue] {}",
                    err.message()
                        .unwrap_or("No message found -- this should not happen.")
                );
            }
        }

        let txn_status = TransactionStatus::from_vm_status(
            error_vm_status.clone(),
            self.features(),
            self.gas_feature_version() >= RELEASE_V1_38,
        );

        match txn_status {
            TransactionStatus::Keep(status) => {
                // The transaction should be kept. Run the appropriate post transaction workflows
                // including epilogue. This runs a new session that ignores any side effects that
                // might abort the execution (e.g., spending additional funds needed to pay for
                // gas). Even if the previous failure occurred while running the epilogue, it
                // should not fail now. If it somehow fails here, there is no choice but to
                // discard the transaction.
                let output = self
                    .finish_aborted_transaction(
                        prologue_session_change_set,
                        gas_meter,
                        txn_data,
                        resolver,
                        module_storage,
                        serialized_signers,
                        status,
                        log_context,
                        change_set_configs,
                        traversal_context,
                    )
                    .unwrap_or_else(|status| discarded_output(status.status_code()));
                (error_vm_status, output)
            },
            TransactionStatus::Discard(status_code) => {
                let discarded_output = discarded_output(status_code);
                (error_vm_status, discarded_output)
            },
            TransactionStatus::Retry => unreachable!(),
        }
    }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L689-822)
```rust
    fn finish_aborted_transaction(
        &self,
        prologue_session_change_set: SystemSessionChangeSet,
        gas_meter: &mut impl AptosGasMeter,
        txn_data: &TransactionMetadata,
        resolver: &impl AptosMoveResolver,
        module_storage: &impl AptosModuleStorage,
        serialized_signers: &SerializedSigners,
        status: ExecutionStatus,
        log_context: &AdapterLogSchema,
        change_set_configs: &ChangeSetConfigs,
        traversal_context: &mut TraversalContext,
    ) -> Result<VMOutput, VMStatus> {
        // Storage refund is zero since no slots are deleted in aborted transactions.
        const ZERO_STORAGE_REFUND: u64 = 0;

        let should_create_account_resource =
            should_create_account_resource(txn_data, self.features(), resolver, module_storage)?;

        let (previous_session_change_set, fee_statement) = if should_create_account_resource {
            let mut abort_hook_session =
                AbortHookSession::new(self, txn_data, resolver, prologue_session_change_set);

            abort_hook_session.execute(|session| {
                create_account_if_does_not_exist(
                    session,
                    module_storage,
                    gas_meter,
                    txn_data.sender(),
                    traversal_context,
                )
                // If this fails, it is likely due to out of gas, so we try again without metering
                // and then validate below that we charged sufficiently.
                .or_else(|_err| {
                    create_account_if_does_not_exist(
                        session,
                        module_storage,
                        &mut UnmeteredGasMeter,
                        txn_data.sender(),
                        traversal_context,
                    )
                })
                .map_err(expect_no_verification_errors)
                .or_else(|err| {
                    expect_only_successful_execution(
                        err,
                        &format!("{:?}::{}", ACCOUNT_MODULE, CREATE_ACCOUNT_IF_DOES_NOT_EXIST),
                        log_context,
                    )
                })
            })?;

            let mut abort_hook_session_change_set =
                abort_hook_session.finish(change_set_configs, module_storage)?;
            if let Err(err) = self.charge_change_set(
                &mut abort_hook_session_change_set,
                gas_meter,
                txn_data,
                resolver,
                module_storage,
            ) {
                info!(
                    *log_context,
                    "Failed during charge_change_set: {:?}. Most likely exceeded gas limited.", err,
                );
            };

            let fee_statement =
                AptosVM::fee_statement_from_gas_meter(txn_data, gas_meter, ZERO_STORAGE_REFUND);

            // Verify we charged sufficiently for creating an account slot
            let gas_params = self.gas_params(log_context)?;
            let gas_unit_price = u64::from(txn_data.gas_unit_price());
            if gas_unit_price != 0 || !self.features().is_default_account_resource_enabled() {
                let gas_used = fee_statement.gas_used();
                let storage_fee = fee_statement.storage_fee_used();
                let storage_refund = fee_statement.storage_fee_refund();

                let actual = gas_used * gas_unit_price + storage_fee - storage_refund;
                let expected = u64::from(
                    gas_meter
                        .disk_space_pricing()
                        .hack_account_creation_fee_lower_bound(&gas_params.vm.txn),
                );
                if actual < expected {
                    expect_only_successful_execution(
                        PartialVMError::new(StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR)
                            .with_message(
                                "Insufficient fee for storing account for lazy account creation"
                                    .to_string(),
                            )
                            .finish(Location::Undefined),
                        &format!("{:?}::{}", ACCOUNT_MODULE, CREATE_ACCOUNT_IF_DOES_NOT_EXIST),
                        log_context,
                    )?;
                }
            }
            (abort_hook_session_change_set, fee_statement)
        } else {
            let fee_statement =
                AptosVM::fee_statement_from_gas_meter(txn_data, gas_meter, ZERO_STORAGE_REFUND);
            (prologue_session_change_set, fee_statement)
        };

        let mut epilogue_session = EpilogueSession::on_user_session_failure(
            self,
            txn_data,
            resolver,
            previous_session_change_set,
        );

        // Abort information is injected using the user defined error in the Move contract.
        let status = self.inject_abort_info_if_available(
            module_storage,
            traversal_context,
            log_context,
            status,
        );
        epilogue_session.execute(|session| {
            transaction_validation::run_failure_epilogue(
                session,
                module_storage,
                serialized_signers,
                gas_meter.balance(),
                fee_statement,
                self.features(),
                txn_data,
                log_context,
                traversal_context,
                self.is_simulation,
            )
        })?;
        epilogue_session.finish(fee_statement, status, change_set_configs, module_storage)
    }
```

**File:** aptos-move/aptos-vm/src/errors.rs (L275-305)
```rust
pub fn expect_only_successful_execution(
    error: VMError,
    function_name: &str,
    log_context: &AdapterLogSchema,
) -> Result<(), VMStatus> {
    let status = error.into_vm_status();
    Err(match status {
        VMStatus::Executed => VMStatus::Executed,
        // Speculative errors are returned for caller to handle.
        e @ VMStatus::Error {
            status_code:
                StatusCode::SPECULATIVE_EXECUTION_ABORT_ERROR
                | StatusCode::DELAYED_FIELD_OR_BLOCKSTM_CODE_INVARIANT_ERROR,
            ..
        } => e,
        status => {
            // Only trigger a warning here as some errors could be a result of the speculative parallel execution.
            // We will report the errors after we obtained the final transaction output in update_counters_for_processed_chunk
            let err_msg = format!(
                "[aptos_vm] Unexpected error from known Move function, '{}'. Error: {:?}",
                function_name, status
            );
            speculative_warn!(log_context, err_msg.clone());
            VMStatus::Error {
                status_code: StatusCode::UNEXPECTED_ERROR_FROM_KNOWN_MOVE_FUNCTION,
                sub_status: status.sub_status(),
                message: Some(err_msg),
            }
        },
    })
}
```

**File:** aptos-move/aptos-vm/src/errors.rs (L307-309)
```rust
pub(crate) fn discarded_output(status_code: StatusCode) -> VMOutput {
    VMOutput::empty_with_status(TransactionStatus::Discard(status_code))
}
```

**File:** types/src/on_chain_config/aptos_features.rs (L194-194)
```rust
            FeatureFlag::CHARGE_INVARIANT_VIOLATION,
```
