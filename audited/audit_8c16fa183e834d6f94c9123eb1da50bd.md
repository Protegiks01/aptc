# Audit Report

## Title
Division by Zero in Gas Storage Fee Calculation Causes Network-Wide Validator Crash

## Summary
When all `AptosGasParameters` are set to zero (either through governance or configuration), the gas validation allows transactions with `gas_unit_price = 0`. Any such transaction that incurs storage fees triggers a division-by-zero panic in the `charge_storage_fee()` function, causing immediate validator node crashes and network-wide liveness failure.

## Finding Description

The vulnerability exists in the storage fee calculation logic when gas parameters are set to zero:

**1. Missing Governance Validation**

The gas schedule update mechanism lacks validation to prevent zero gas parameters: [1](#0-0) [2](#0-1) [3](#0-2) 

The `set_for_next_epoch()` and `set_gas_schedule()` functions only validate that the blob is non-empty and feature version is monotonic, but do NOT validate that gas parameters are non-zero or consistent.

**2. Zero Gas Parameters Creation**

The `AptosGasParameters::zeros()` method creates all-zero gas parameters: [4](#0-3) 

When `min_price_per_gas_unit` is zero, the gas price validation passes for transactions with `gas_unit_price = 0`: [5](#0-4) 

**3. Division by Zero in Storage Fee Calculation**

The critical vulnerability occurs in `charge_storage_fee()`: [6](#0-5) 

The `div_ceil()` helper function performs unprotected division by `gas_unit_price`. When `gas_unit_price = 0`, this causes a Rust panic.

**4. Insufficient Protection**

While there is protection for `gas_unit_scaling_factor` being zero: [7](#0-6) 

This protection only applies to the scaling factor in the numerator, NOT to `gas_unit_price` in the denominator.

**Attack Path:**

1. Malicious governance proposal sets all gas parameters to zero (no validation prevents this)
2. Proposal is approved and applied at epoch boundary
3. User submits transaction with `gas_unit_price = 0` (allowed because `min_price_per_gas_unit = 0`)
4. Transaction performs state writes, module deployment, or emits events (storage fee > 0)
5. `charge_storage_fee()` is called during transaction execution: [8](#0-7) 

6. Division by zero occurs, causing validator node to panic and crash
7. All validators processing this transaction crash simultaneously
8. Network experiences complete liveness failure

## Impact Explanation

**Critical Severity (up to $1,000,000)**

This vulnerability meets multiple Critical severity criteria from the Aptos Bug Bounty program:

- **Total loss of liveness/network availability**: All validator nodes crash when processing any transaction with storage fees and zero gas price
- **Non-recoverable network partition**: Requires emergency hardfork to fix the gas schedule on-chain
- **Consensus failure**: Once triggered, the network cannot process any blocks until fixed

The impact is catastrophic because:
1. **Immediate and complete**: First transaction with storage fees crashes all validators
2. **Cannot self-recover**: Gas schedule must be fixed through emergency governance or hardfork
3. **Affects entire network**: All validators, not just a subset
4. **Breaks deterministic execution invariant**: Nodes crash instead of producing state roots

## Likelihood Explanation

**Likelihood: Medium-High**

While requiring a governance proposal, the likelihood is elevated because:

1. **No validation barrier**: The gas schedule update functions explicitly lack validation (TODO comments indicate this is known)
2. **Governance is trust-based**: If governance is compromised or makes an error, there's no safety net
3. **Testing scenarios**: Zero gas parameters are used for testing (`StorageGasParameters::unlimited()`), and could accidentally leak into production
4. **Fallback scenarios**: Code exists that falls back to zero parameters when gas schedule cannot be loaded: [9](#0-8) 

5. **Simple trigger**: Once gas parameters are zero, ANY user can trigger the crash with a normal transaction

## Recommendation

**Immediate Fix:**

1. Add validation in `charge_storage_fee()` to handle zero `gas_unit_price`:

```rust
fn div_ceil(n: u128, d: u128) -> u128 {
    if d == 0 {
        return 0; // or return error instead of panicking
    }
    if n % d == 0 {
        n / d
    } else {
        n / d + 1
    }
}
```

2. Add validation in gas schedule updates to prevent zero critical parameters:

```move
public fun set_for_next_epoch(aptos_framework: &signer, gas_schedule_blob: vector<u8>) acquires GasScheduleV2 {
    system_addresses::assert_aptos_framework(aptos_framework);
    assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));
    let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
    
    // NEW: Validate critical gas parameters are non-zero
    validate_gas_schedule_consistency(&new_gas_schedule);
    
    if (exists<GasScheduleV2>(@aptos_framework)) {
        let cur_gas_schedule = borrow_global<GasScheduleV2>(@aptos_framework);
        assert!(
            new_gas_schedule.feature_version >= cur_gas_schedule.feature_version,
            error::invalid_argument(EINVALID_GAS_FEATURE_VERSION)
        );
    };
    config_buffer::upsert(new_gas_schedule);
}
```

3. Add early validation in `check_gas()` to reject transactions with zero gas price when not explicitly allowed:

```rust
let below_min_bound = txn_metadata.gas_unit_price() < txn_gas_params.min_price_per_gas_unit;
if below_min_bound || (txn_metadata.gas_unit_price() == 0 && txn_gas_params.min_price_per_gas_unit > 0) {
    // reject transaction
}
```

## Proof of Concept

```rust
#[test]
#[should_panic(expected = "attempt to divide by zero")]
fn test_division_by_zero_in_storage_fee() {
    use aptos_gas_schedule::AptosGasParameters;
    use aptos_gas_meter::StandardGasAlgebra;
    use aptos_vm_types::storage::StorageGasParameters;
    
    // Create zero gas parameters
    let gas_params = AptosGasParameters::zeros();
    let storage_params = StorageGasParameters::unlimited();
    
    // Create gas algebra with zero parameters
    let mut algebra = StandardGasAlgebra::new(
        0, // gas_feature_version
        gas_params.vm.clone(),
        storage_params,
        false, // is_approved_gov_script
        Gas::new(1000000), // balance
        &NoopBlockSynchronizationKillSwitch,
    );
    
    // Try to charge storage fee with gas_unit_price = 0
    // This will panic with division by zero
    let fee = Fee::new(100); // non-zero storage fee
    let gas_unit_price = FeePerGasUnit::new(0); // zero gas price
    
    algebra.charge_storage_fee(fee, gas_unit_price).unwrap();
    // ^ This line will panic: "attempt to divide by zero"
}
```

**To reproduce the vulnerability:**

1. Deploy a governance proposal that sets `GasScheduleV2` with all entries set to zero values
2. Wait for proposal to be approved and applied at epoch boundary
3. Submit any transaction with `gas_unit_price = 0` that writes state or emits events
4. Observe validator nodes crash with "attempt to divide by zero" panic in `charge_storage_fee()`

### Citations

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L47-47)
```text
        // TODO(Gas): check if gas schedule is consistent
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L67-67)
```text
            // TODO(Gas): check if gas schedule is consistent
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L75-75)
```text
            // TODO(Gas): check if gas schedule is consistent
```

**File:** aptos-move/aptos-vm-types/src/storage/mod.rs (L42-50)
```rust
    pub fn unlimited() -> Self {
        Self::new_impl(
            LATEST_GAS_FEATURE_VERSION,
            &Features::default(),
            &AptosGasParameters::zeros(), // free of charge
            &DummyConfigStorage,
            ChangeSetConfigs::unlimited_at_gas_feature_version(LATEST_GAS_FEATURE_VERSION), // no limits
        )
    }
```

**File:** aptos-move/aptos-vm/src/gas.rs (L174-192)
```rust
    // The submitted gas price is less than the minimum gas unit price set by the VM.
    // NB: MIN_PRICE_PER_GAS_UNIT may equal zero, but need not in the future. Hence why
    // we turn off the clippy warning.
    #[allow(clippy::absurd_extreme_comparisons)]
    let below_min_bound = txn_metadata.gas_unit_price() < txn_gas_params.min_price_per_gas_unit;
    if below_min_bound {
        speculative_warn!(
            log_context,
            format!(
                "[VM] Gas unit error; min {}, submitted {}",
                txn_gas_params.min_price_per_gas_unit,
                txn_metadata.gas_unit_price()
            ),
        );
        return Err(VMStatus::error(
            StatusCode::GAS_UNIT_PRICE_BELOW_MIN_BOUND,
            None,
        ));
    }
```

**File:** aptos-move/aptos-gas-meter/src/algebra.rs (L253-263)
```rust
        fn div_ceil(n: u128, d: u128) -> u128 {
            if n % d == 0 {
                n / d
            } else {
                n / d + 1
            }
        }
        let gas_consumed_internal = div_ceil(
            (u64::from(amount) as u128) * (u64::from(txn_params.gas_unit_scaling_factor) as u128),
            u64::from(gas_unit_price) as u128,
        );
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L291-298)
```rust
    // TODO(Gas): Right now we are relying on this to avoid div by zero errors when using the all-zero
    //            gas parameters. See if there's a better way we can handle this.
    pub fn scaling_factor(&self) -> GasScalingFactor {
        match u64::from(self.gas_unit_scaling_factor) {
            0 => 1.into(),
            x => x.into(),
        }
    }
```

**File:** aptos-move/aptos-gas-meter/src/traits.rs (L195-212)
```rust
        // Events (no event fee in v2)
        let event_fee = change_set.events_iter().fold(Fee::new(0), |acc, event| {
            acc + pricing.legacy_storage_fee_per_event(params, event)
        });
        let event_discount = pricing.legacy_storage_discount_for_events(params, event_fee);
        let event_net_fee = event_fee
            .checked_sub(event_discount)
            .expect("event discount should always be less than or equal to total amount");

        // Txn (no txn fee in v2)
        let txn_fee = pricing.legacy_storage_fee_for_transaction_storage(params, txn_size);

        let fee = write_fee + event_net_fee + txn_fee;
        self.charge_storage_fee(fee, gas_unit_price)
            .map_err(|err| err.finish(Location::Undefined))?;

        Ok(total_refund)
    }
```

**File:** aptos-move/aptos-vm-environment/src/environment.rs (L257-264)
```rust
            Err(_) => {
                let ty_builder = aptos_default_ty_builder();
                (
                    NativeGasParameters::zeros(),
                    MiscGasParameters::zeros(),
                    ty_builder,
                )
            },
```
