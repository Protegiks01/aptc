# Audit Report

## Title
Race Condition in InMemoryCache Causes Silent Transaction Gaps in Indexer Data Service

## Summary
The `get_data_with_tasks()` function in the indexer-grpc-data-service lacks validation that in-memory cache results start at the requested version. Due to a race condition between the cache cleanup task and read operations, the service can silently skip transactions, returning data starting at a later version than requested. This violates data integrity guarantees and causes indexer processors to miss transactions permanently.

## Finding Description

The vulnerability exists in the interaction between three components:

**1. InMemoryCache Race Condition:**

The cleanup task in [1](#0-0)  removes cache entries while holding only a local copy of metadata. This creates a race window where:
- Cache entries are removed from the shared DashMap (line 317-318)
- But the shared `cache_metadata.first_version` is only updated later (line 325)

**2. Missing Version Range Validation:**

The `get_transactions()` method in [2](#0-1)  only checks if `starting_version < latest_version`, with no validation against `first_version`. When it iterates through requested versions [3](#0-2) , it breaks on the first missing key, potentially returning data starting at a different version than requested.

**3. Missing Start Version Validation in Service:**

When in-memory cache returns data, the service immediately chunks and returns it [4](#0-3)  without validating the starting version matches the request.

The `ensure_sequential_transactions()` function [5](#0-4)  returns immediately if there's only one batch, performing no validation that the first transaction's version matches the requested `start_version`.

**Attack Scenario:**
1. InMemoryCache contains versions [1000-5000], `first_version=1000`, `latest_version=5000`
2. Cleanup task begins evicting old entries, removes versions 1000-1500 from cache
3. Before cleanup updates metadata, a client requests `starting_version=1200`
4. `get_transactions(1200)` sees `latest_version=5000`, proceeds to fetch
5. Iterates through versions: 1200 returns None (evicted), breaks immediately
6. If cleanup is still in progress, might return versions [1501-2500] instead of [1200-2250]
7. Service validates sequential ordering between batches but NOT that first batch starts at requested version
8. Client receives data starting at version 1501, silently missing versions 1200-1500
9. Current version updates to 2501 [6](#0-5) , permanently skipping the gap

## Impact Explanation

**Severity: Medium**

This qualifies as Medium severity under "State inconsistencies requiring intervention":

1. **Data Integrity Violation:** Indexer processors receive incomplete transaction history with permanent gaps
2. **Silent Failure:** No error is raised; gaps are undetected by downstream consumers
3. **Cascading Impact:** Applications relying on complete transaction data (analytics, portfolio tracking, event monitoring) operate on incomplete state
4. **Intervention Required:** Once gaps occur, manual reindexing is required to fix inconsistent indexer databases

While this doesn't affect blockchain consensus directly, it violates the indexer's core guarantee of providing complete, sequential transaction data. The v2 service explicitly validates this property [7](#0-6) , confirming it's a recognized requirement.

## Likelihood Explanation

**Likelihood: High under normal operation**

This is not an attack scenario but a race condition that occurs naturally:
- The cleanup task runs continuously every 100ms [8](#0-7) 
- High-traffic deployments with concurrent read requests increase collision probability
- No synchronization exists between cache eviction and reads
- The race window exists whenever cache size exceeds eviction threshold (3.5GB default) [9](#0-8) 

## Recommendation

Add validation that returned data starts at the requested version:

```rust
// In ecosystem/indexer-grpc/indexer-grpc-data-service/src/service.rs
// After line 239:
let in_memory_transactions = in_memory_cache.get_transactions(start_version).await;
if !in_memory_transactions.is_empty() {
    // Validate that we got data starting at the requested version
    if in_memory_transactions.first().unwrap().version != start_version {
        // Data doesn't start at requested version - fall through to Redis/filestore
        // to ensure we get complete sequential data
    } else {
        log_grpc_step(...);
        return DataFetchSubTaskResult::BatchSuccess(chunk_transactions(
            in_memory_transactions,
            MESSAGE_SIZE_LIMIT,
        ));
    }
}
```

Additionally, fix the race condition in InMemoryCache:

```rust
// In ecosystem/indexer-grpc/indexer-grpc-utils/src/in_memory_cache.rs
// In get_transactions(), check against first_version:
pub async fn get_transactions(&self, starting_version: u64) -> Vec<Transaction> {
    let (versions_to_fetch, in_memory_latest_version) = loop {
        let metadata = self.cache_metadata.read().await;
        let latest_version = metadata.latest_version;
        let first_version = metadata.first_version;
        
        if starting_version >= latest_version {
            drop(metadata);
            tokio::time::sleep(...).await;
            continue;
        }
        
        // Return empty if requested version has been evicted
        if starting_version < first_version {
            return vec![];
        }
        // ... rest of logic
    };
}
```

## Proof of Concept

Due to the race condition nature, a PoC would require:

1. Deploy indexer-grpc-data-service with default 3.5GB cache limit
2. Populate cache with >3.5GB of transaction data to trigger cleanup
3. Concurrent load test with requests for versions near eviction boundary
4. Monitor returned data for gaps: `assert_eq!(returned[0].version, requested_version)`
5. Under sufficient load, violations will occur when cleanup coincides with reads

The validation can be tested by checking that the v2 implementation's pattern [7](#0-6)  is applied to v1.

---

**Notes:**

This vulnerability is specific to the indexer-grpc-data-service (v1) and does not affect blockchain consensus. However, it violates data integrity guarantees critical for indexer reliability. The existence of explicit validation in the v2 service confirms this is a recognized requirement that was missed in v1. The race condition in InMemoryCache exacerbates the issue by allowing the cache to return partial data without raising errors.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/in_memory_cache.rs (L17-17)
```rust
const IN_MEMORY_CACHE_GC_INTERVAL_MS: u64 = 100;
```

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/in_memory_cache.rs (L42-43)
```rust
            // 3.5 GB.
            cache_eviction_trigger_size_bytes: 3_500_000_000,
```

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/in_memory_cache.rs (L147-167)
```rust
    pub async fn get_transactions(&self, starting_version: u64) -> Vec<Transaction> {
        let start_time = std::time::Instant::now();
        let (versions_to_fetch, in_memory_latest_version) = loop {
            let latest_version = self.latest_version().await;
            if starting_version >= latest_version {
                tokio::time::sleep(std::time::Duration::from_millis(
                    IN_MEMORY_CACHE_LOOKUP_RETRY_INTERVAL_MS,
                ))
                .await;
                continue;
            }
            // This is to avoid fetching too many transactions at once.
            let ending_version = std::cmp::min(
                latest_version,
                starting_version + MAX_FETCH_BATCH_SIZE as u64,
            );
            break (
                (starting_version..ending_version).collect::<Vec<u64>>(),
                latest_version,
            );
        };
```

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/in_memory_cache.rs (L170-176)
```rust
        for key in versions_to_fetch {
            if let Some(transaction) = self.cache.get(&key) {
                arc_transactions.push(transaction.clone());
            } else {
                break;
            }
        }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/in_memory_cache.rs (L315-325)
```rust
            while bytes_to_remove > 0 {
                let key_to_remove = current_cache_metadata.first_version;
                let (_k, v) = cache
                    .remove(&key_to_remove)
                    .expect("Failed to remove the key");
                bytes_to_remove = bytes_to_remove.saturating_sub(v.encoded_len() as u64);
                actual_bytes_removed += v.encoded_len() as u64;
                current_cache_metadata.first_version += 1;
            }
            current_cache_metadata.total_size_in_bytes -= actual_bytes_removed;
            *cache_metadata.write().await = current_cache_metadata;
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service/src/service.rs (L239-256)
```rust
    let in_memory_transactions = in_memory_cache.get_transactions(start_version).await;
    if !in_memory_transactions.is_empty() {
        log_grpc_step(
            SERVICE_TYPE,
            IndexerGrpcStep::DataServiceFetchingDataFromInMemoryCache,
            Some(start_version as i64),
            Some(in_memory_transactions.last().as_ref().unwrap().version as i64),
            None,
            None,
            Some(start_time.elapsed().as_secs_f64()),
            None,
            Some(in_memory_transactions.len() as i64),
            Some(&request_metadata),
        );
        return DataFetchSubTaskResult::BatchSuccess(chunk_transactions(
            in_memory_transactions,
            MESSAGE_SIZE_LIMIT,
        ));
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service/src/service.rs (L571-571)
```rust
        current_version = end_of_batch_version + 1;
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service/src/service.rs (L592-596)
```rust
fn ensure_sequential_transactions(mut batches: Vec<Vec<Transaction>>) -> Vec<Transaction> {
    // If there's only one, no sorting required
    if batches.len() == 1 {
        return batches.pop().unwrap();
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/data_client.rs (L37-39)
```rust
                if transactions.first().unwrap().version == starting_version {
                    return transactions;
                }
```
