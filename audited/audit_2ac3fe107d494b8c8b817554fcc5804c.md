# Audit Report

## Title
Indexer gRPC Service Crash on Port Binding Failure Due to Improper Error Handling

## Summary
The indexer gRPC service uses `.unwrap()` on `TcpListener::bind()`, causing the entire Aptos node to crash and exit with code 12 if the configured port is already in use or binding fails for any reason. This differs from the API service which handles binding failures gracefully.

## Finding Description
The indexer gRPC fullnode service binds to its configured address during node startup. The binding operation in `ecosystem/indexer-grpc/indexer-grpc-fullnode/src/runtime.rs` uses `.unwrap()` which panics on failure: [1](#0-0) 

When this binding fails (e.g., port already in use, permission denied, invalid address), the spawned tokio task panics. The global panic handler is configured to call `process::exit(12)` for most panics: [2](#0-1) 

This panic handler is set up globally during node initialization: [3](#0-2) 

The indexer gRPC service is bootstrapped during node startup as part of the API and indexer initialization: [4](#0-3) 

In contrast, the API service handles binding failures properly using `.with_context()` for error propagation: [5](#0-4) 

Additionally, the indexer gRPC configuration lacks address validation in its sanitizer: [6](#0-5) 

The configuration is loaded once at startup and there is no hot-reload mechanism - the address cannot be changed while the service is running: [7](#0-6) 

## Impact Explanation
This vulnerability has **High to Critical severity** depending on deployment context:

- **Critical Impact ("Total loss of liveness/network availability")**: If an attacker with local system access can occupy the indexer gRPC port (default 50051) before the node starts, the validator/fullnode will crash during startup and remain offline. This prevents consensus participation and data service availability.

- **High Impact ("API crashes")**: The entire node crashes when only the indexer service (a non-critical auxiliary service) fails to bind, affecting all node operations including consensus, mempool, and state sync.

The indexer gRPC service is not required for core consensus operations, yet its failure crashes the entire node. This violates availability guarantees and creates unnecessary operational fragility.

## Likelihood Explanation
The likelihood depends on the deployment environment:

**High Likelihood Scenarios:**
- Shared hosting environments where port conflicts can occur
- Container orchestration with dynamic port allocation
- Configuration errors during deployment
- Automated restart scenarios after crashes

**Lower Likelihood Scenarios:**
- Dedicated validator hosts with controlled port allocation
- Properly configured firewall rules

However, this requires local system access to occupy the port, which is a privileged position. An attacker with such access has other attack vectors available, making this primarily an **operational robustness issue** rather than a remote exploit.

## Recommendation
Replace `.unwrap()` with proper error handling that propagates errors gracefully:

```rust
// Current problematic code at line 123:
let listener = TcpListener::bind(address).await.unwrap();

// Recommended fix:
let listener = TcpListener::bind(address)
    .await
    .with_context(|| format!("Failed to bind indexer gRPC to address: {}", address))?;
```

Additionally, the `bootstrap()` function signature should return `anyhow::Result<Option<Runtime>>` instead of `Option<Runtime>` to properly propagate errors: [8](#0-7) 

Add address validation in the config sanitizer to fail fast during config validation rather than at runtime: [6](#0-5) 

## Proof of Concept
```rust
// Test demonstrating the crash behavior
#[tokio::test]
async fn test_indexer_grpc_bind_failure_crashes_node() {
    // First, occupy the port
    let listener = TcpListener::bind("127.0.0.1:50051").await.unwrap();
    
    // Now try to start an indexer gRPC service on the same port
    // This will panic and crash due to .unwrap() on bind failure
    let mut config = NodeConfig::default();
    config.indexer_grpc.enabled = true;
    config.indexer_grpc.address = "127.0.0.1:50051".parse().unwrap();
    
    // This will panic and crash the test unless panic handler is disabled
    let runtime = bootstrap(&config, ChainId::test(), /* ... */);
    // Expected: graceful error, Actual: panic and crash
}
```

---

## Notes

**Answer to Original Security Question:**
The indexer gRPC service address **CANNOT** be changed while the service is running. There is **NO hot-reload capability**. Changes to the `address` field in the configuration require a full node restart. The address is read once during node startup and used to bind the TCP listener, which remains bound for the lifetime of the service.

**Critical Finding:**
While investigating the hot-reload question, I discovered that improper error handling causes the entire node to crash if the indexer gRPC port binding fails. This is inconsistent with other services (like the API) which handle binding failures gracefully. However, this vulnerability requires local system access to exploit, placing it in a gray area for bug bounty eligibility.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/runtime.rs (L36-43)
```rust
pub fn bootstrap(
    config: &NodeConfig,
    chain_id: ChainId,
    db: Arc<dyn DbReader>,
    mp_sender: MempoolClientSender,
    indexer_reader: Option<Arc<dyn IndexerReader>>,
    port_tx: Option<oneshot::Sender<u16>>,
) -> Option<Runtime> {
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/runtime.rs (L52-52)
```rust
    let address = node_config.indexer_grpc.address;
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/runtime.rs (L123-123)
```rust
        let listener = TcpListener::bind(address).await.unwrap();
```

**File:** crates/crash-handler/src/lib.rs (L56-57)
```rust
    // Kill the process
    process::exit(12);
```

**File:** aptos-node/src/lib.rs (L233-234)
```rust
    // Setup panic handler
    aptos_crash_handler::setup_panic_handler();
```

**File:** aptos-node/src/services.rs (L114-121)
```rust
    let indexer_grpc = bootstrap_indexer_grpc(
        node_config,
        chain_id,
        db_rw.reader.clone(),
        mempool_client_sender.clone(),
        indexer_reader,
        indexer_grpc_port_tx,
    );
```

**File:** api/src/runtime.rs (L212-216)
```rust
    let acceptor = tokio::task::block_in_place(move || {
        runtime_handle
            .block_on(async move { listener.into_acceptor().await })
            .with_context(|| format!("Failed to bind Poem to address: {}", address))
    })?;
```

**File:** config/src/config/indexer_grpc_config.rs (L103-128)
```rust
impl ConfigSanitizer for IndexerGrpcConfig {
    fn sanitize(
        node_config: &NodeConfig,
        _node_type: NodeType,
        _chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();

        if !node_config.indexer_grpc.enabled {
            return Ok(());
        }

        if !node_config.storage.enable_indexer
            && !node_config
                .indexer_table_info
                .table_info_service_mode
                .is_enabled()
        {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "storage.enable_indexer must be true or indexer_table_info.table_info_service_mode must be IndexingOnly if indexer_grpc.enabled is true".to_string(),
            ));
        }
        Ok(())
    }
}
```
