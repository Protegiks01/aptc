# Audit Report

## Title
Insecure PostgreSQL Password Storage and Exposure in Local Testnet Tool

## Summary
The `host_postgres_password` field in `PostgresArgs` is stored as a plain `Option<String>` without memory protection, and is exposed in error messages. This violates the codebase's own secure coding guidelines and creates multiple credential leakage vectors through error output, core dumps, swap files, and memory inspection.

## Finding Description

The `PostgresArgs` struct stores the PostgreSQL password as an unprotected `Option<String>`. [1](#0-0) 

This password is then embedded directly into connection strings without any protection. [2](#0-1) 

The connection string format includes the password in plain text. [3](#0-2) 

**Critical vulnerability**: When database connection fails, the entire connection string including the password is exposed in error messages. [4](#0-3) 

This violates the codebase's secure coding guidelines, which explicitly state: "Do not rely on `Drop` trait in security material treatment after the use, use zeroize to explicit destroy security material" and "Use zeroize for zeroing memory containing sensitive data." [5](#0-4) [6](#0-5) 

The codebase already implements password masking for `IndexerConfig` to prevent exactly this type of leak. [7](#0-6) [8](#0-7) 

However, the local testnet postgres implementation lacks this protection, creating an inconsistency in security practices.

## Impact Explanation

While this affects only the local testnet development tool rather than production blockchain infrastructure, the credential exposure poses risks:

1. **Error Message Exposure**: Password leaked via terminal output, log files, and error reports whenever connection fails
2. **Memory Persistence**: Password stored unprotected in multiple heap locations (PostgresArgs, connection strings, error messages)
3. **Core Dump Leakage**: Process crashes expose password in core dump files
4. **Swap File Leakage**: Memory swapping writes password to disk in plain text
5. **Memory Inspection**: Password readable by any process with memory access privileges

If developers use production database credentials with `--use-host-postgres` (poor practice but possible), this could expose production data.

This qualifies as **Low Severity** per bug bounty criteria: "Minor information leaks" - credential exposure in development tooling.

## Likelihood Explanation

**High likelihood** of password exposure through error messages:
- Connection failures are common during setup and troubleshooting
- Network issues, wrong host/port, authentication failures all trigger the error path
- Error messages are typically displayed on screen and logged

**Medium likelihood** of exposure through core dumps/swap/memory:
- Requires process crash or memory pressure for core dumps/swap
- Requires local machine access for memory inspection
- Less common but possible in debugging scenarios

**Scope limitation**: Only affects users who:
1. Run local testnet with `--use-host-postgres` flag
2. Provide a password via `--host-postgres-password`
3. Experience connection failures or process issues

## Recommendation

**Immediate fixes required**:

1. **Mask password in error messages** (like IndexerConfig does):
```rust
async fn recreate_host_database(&self) -> Result<()> {
    info!("Dropping database {}", self.args.postgres_database);
    let connection_string = self.args.get_connection_string(Some("postgres"), true);
    
    // Mask password in error messages
    let masked_connection_string = if let Ok(mut url) = url::Url::parse(&connection_string) {
        if url.password().is_some() {
            url.set_password(Some("*")).unwrap();
        }
        url.to_string()
    } else {
        connection_string.clone()
    };

    let mut connection = AsyncPgConnection::establish(&connection_string)
        .await
        .with_context(|| format!("Failed to connect to postgres at {}", masked_connection_string))?;
    // ... rest of function
}
```

2. **Use zeroize for password storage** (requires adding `zeroize` dependency and using `Secret<String>` or similar):
```rust
use zeroize::Zeroizing;

#[derive(Clone, Debug, Parser)]
pub struct PostgresArgs {
    // ... other fields ...
    
    /// When --use-host-postgres is set, this is the password to connect with.
    #[clap(long)]
    pub host_postgres_password: Option<Zeroizing<String>>,
}
```

3. **Apply consistent security practices**: Extend the password masking pattern from IndexerConfig to all connection string usage in the codebase.

## Proof of Concept

**Demonstration of password leak through error message**:

```rust
// Run local testnet with wrong postgres configuration
// Command: cargo run -p aptos -- node run-local-testnet \
//   --with-indexer-api \
//   --use-host-postgres \
//   --host-postgres-password "SecretPassword123" \
//   --host-postgres-host "wrong-host" \
//   --host-postgres-port 9999

// Expected output when connection fails:
// Error: Failed to connect to postgres at postgres://postgres:SecretPassword123@wrong-host:9999/postgres
//                                                            ^^^^^^^^^^^^^^^^^^
//                                                            Password exposed!

// The password is now leaked in:
// 1. Terminal output
// 2. Any log files capturing stderr
// 3. Shell history if error is copy-pasted
// 4. Error reporting systems
```

**Notes**

This vulnerability is limited to the local testnet development tool and does not affect core blockchain consensus, execution, or state management. However, it represents a clear violation of the codebase's own security standards (RUST_SECURE_CODING.md) and demonstrates inconsistent security practices compared to the IndexerConfig implementation. The error message leak vector is particularly concerning as it exposes credentials through normal operational failures without requiring privileged access.

### Citations

**File:** crates/aptos/src/node/local_testnet/postgres.rs (L69-71)
```rust
    /// When --use-host-postgres is set, this is the password to connect with.
    #[clap(long)]
    pub host_postgres_password: Option<String>,
```

**File:** crates/aptos/src/node/local_testnet/postgres.rs (L93-99)
```rust
        let password = match self.use_host_postgres {
            true => match &self.host_postgres_password {
                Some(password) => format!(":{}", password),
                None => "".to_string(),
            },
            false => "".to_string(),
        };
```

**File:** crates/aptos/src/node/local_testnet/postgres.rs (L112-115)
```rust
        format!(
            "postgres://{}{}@{}:{}/{}",
            self.postgres_user, password, host, port, database,
        )
```

**File:** crates/aptos/src/node/local_testnet/postgres.rs (L154-156)
```rust
        let mut connection = AsyncPgConnection::establish(&connection_string)
            .await
            .with_context(|| format!("Failed to connect to postgres at {}", connection_string))?;
```

**File:** RUST_SECURE_CODING.md (L96-96)
```markdown
Do not rely on `Drop` trait in security material treatment after the use, use [zeroize](https://docs.rs/zeroize/latest/zeroize/#) to explicit destroy security material, e.g. private keys.
```

**File:** RUST_SECURE_CODING.md (L143-145)
```markdown
### Zeroing Sensitive Data

Use [zeroize](https://docs.rs/zeroize/latest/zeroize/#) for zeroing memory containing sensitive data.
```

**File:** config/src/config/indexer_config.rs (L92-99)
```rust
impl Debug for IndexerConfig {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        let postgres_uri = self.postgres_uri.as_ref().map(|u| {
            let mut parsed_url = url::Url::parse(u).expect("Invalid postgres uri");
            if parsed_url.password().is_some() {
                parsed_url.set_password(Some("*")).unwrap();
            }
            parsed_url.to_string()
```

**File:** aptos-node/src/logger.rs (L91-98)
```rust
    if let Some(u) = &node_config.indexer.postgres_uri {
        let mut parsed_url = url::Url::parse(u).expect("Invalid postgres uri");
        if parsed_url.password().is_some() {
            masked_config = node_config.clone();
            parsed_url.set_password(Some("*")).unwrap();
            masked_config.indexer.postgres_uri = Some(parsed_url.to_string());
            config = &masked_config;
        }
```
