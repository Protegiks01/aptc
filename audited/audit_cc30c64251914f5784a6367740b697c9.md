# Audit Report

## Title
Missing Round ID Validation in ShardedTxnIndexV2 Constructor Causes Executor Shard Panic

## Summary
The `ShardedTxnIndexV2::new()` constructor does not validate that `round_id` parameter is within the valid range (â‰¤ `MAX_ALLOWED_PARTITIONING_ROUNDS` or == `GLOBAL_ROUND_ID`). When combined with misconfigured partitioner settings, this causes executor shards to panic with index-out-of-bounds errors when accessing pre-allocated cross-shard message channels, resulting in validator node crashes and consensus disruption.

## Finding Description

The vulnerability exists across three critical components:

**1. Missing Validation in Constructor:**
The `ShardedTxnIndexV2::new()` constructor accepts any `round_id` value without validation. [1](#0-0) 

**2. Bounded Channel Allocation in Local Executor:**
The local executor pre-allocates cross-shard message channels only for rounds `0..MAX_ALLOWED_PARTITIONING_ROUNDS` (i.e., 0-7). [2](#0-1) 

The `send_cross_shard_msg` and `receive_cross_shard_msg` methods directly index into these channel arrays without bounds checking: [3](#0-2) 

**3. Bounded Channel Allocation in Remote Executor:**
The remote executor service has the same vulnerability, creating channels only for valid round ranges: [4](#0-3) 

And accessing them without validation: [5](#0-4) 

**4. Partitioner Configuration Without Validation:**
The `PartitionerV2` constructor accepts `num_rounds_limit` without validating it against `MAX_ALLOWED_PARTITIONING_ROUNDS`: [6](#0-5) 

The partitioner then creates rounds up to `num_rounds_limit`, potentially exceeding the valid range: [7](#0-6) 

**Constants Definition:** [8](#0-7) 

**Attack Path:**
1. Validator operator configures `PartitionerV2` with `max_partitioning_rounds > MAX_ALLOWED_PARTITIONING_ROUNDS` (e.g., 10 instead of default 4)
2. Partitioner creates `ShardedTxnIndexV2` instances with `round_id` values from 0 to 9
3. These transactions are organized into `SubBlocksForShard` with round indices exceeding valid range
4. During execution, executor shards iterate through sub-blocks and attempt to send/receive cross-shard messages
5. When `round_id >= MAX_ALLOWED_PARTITIONING_ROUNDS`, indexing `message_txs[shard_id][round]` or `message_rxs[round]` triggers index-out-of-bounds panic
6. Validator node crashes, losing liveness and potentially causing consensus disruption

## Impact Explanation

**Severity: High** (Validator node crash)

This vulnerability violates critical invariants:
- **Deterministic Execution Invariant**: Different validators may crash at different times based on configuration, breaking execution determinism
- **Liveness**: Crashed validators cannot participate in consensus
- **Availability**: Requires node restart to recover

The impact meets **High Severity** criteria per Aptos bug bounty:
- Validator node crash (immediate impact)
- Significant protocol violation (consensus disruption if multiple validators affected)

While not **Critical** because it requires operator misconfiguration rather than being directly exploitable by external attackers, any validator crash is a serious availability and consensus concern.

## Likelihood Explanation

**Current Likelihood: Low to Medium**

**Mitigating Factors:**
- Default `max_partitioning_rounds` is 4, well below the limit of 8
- Sharded execution appears primarily used in benchmarking/testing contexts
- Requires validator operator to explicitly misconfigure the partitioner

**Aggravating Factors:**
- No validation prevents misconfiguration
- If sharded execution is deployed to production validators, the risk increases significantly
- Configuration can be set via command-line arguments in executor-benchmark [9](#0-8) 

- Multiple code paths can create invalid round IDs, including using `self.num_rounds()` as round_id: [10](#0-9) 

## Recommendation

**Immediate Fix: Add validation in multiple layers**

1. **Constructor-level validation** in `ShardedTxnIndexV2::new()`:
```rust
pub fn new(round_id: RoundId, shard_id: ShardId, txn_idx1: PrePartitionedTxnIdx) -> Self {
    assert!(
        round_id < MAX_ALLOWED_PARTITIONING_ROUNDS || round_id == GLOBAL_ROUND_ID,
        "Invalid round_id: {}. Must be < {} or == {}",
        round_id,
        MAX_ALLOWED_PARTITIONING_ROUNDS,
        GLOBAL_ROUND_ID
    );
    Self {
        sub_block_idx: SubBlockIdx::new(round_id, shard_id),
        pre_partitioned_txn_idx: txn_idx1,
    }
}
```

2. **Configuration-level validation** in `PartitionerV2::new()`:
```rust
pub fn new(
    num_threads: usize,
    num_rounds_limit: usize,
    cross_shard_dep_avoid_threshold: f32,
    dashmap_num_shards: usize,
    partition_last_round: bool,
    pre_partitioner: Box<dyn PrePartitioner>,
) -> Self {
    assert!(
        num_rounds_limit <= MAX_ALLOWED_PARTITIONING_ROUNDS,
        "num_rounds_limit ({}) exceeds MAX_ALLOWED_PARTITIONING_ROUNDS ({})",
        num_rounds_limit,
        MAX_ALLOWED_PARTITIONING_ROUNDS
    );
    // ... rest of constructor
}
```

3. **Runtime bounds checking** in cross-shard client methods:
```rust
fn send_cross_shard_msg(&self, shard_id: ShardId, round: RoundId, msg: CrossShardMsg) {
    assert!(
        round < MAX_ALLOWED_PARTITIONING_ROUNDS,
        "Round {} exceeds maximum allowed {}",
        round,
        MAX_ALLOWED_PARTITIONING_ROUNDS
    );
    self.message_txs[shard_id][round].send(msg).unwrap()
}
```

## Proof of Concept

```rust
#[test]
#[should_panic(expected = "index out of bounds")]
fn test_invalid_round_id_causes_panic() {
    use aptos_block_partitioner::{
        v2::{config::PartitionerV2Config, PartitionerV2},
        BlockPartitioner,
    };
    use aptos_vm::sharded_block_executor::local_executor_shard::LocalExecutorService;
    use aptos_types::transaction::analyzed_transaction::AnalyzedTransaction;
    
    // Step 1: Create partitioner with invalid configuration
    let partitioner = PartitionerV2::new(
        8,  // num_threads
        10, // num_rounds_limit = 10 > MAX_ALLOWED_PARTITIONING_ROUNDS (8)
        0.9,
        64,
        false,
        Box::new(/* pre_partitioner */),
    );
    
    // Step 2: Create executor shards (allocates channels for rounds 0-7 only)
    let executor_client = LocalExecutorService::setup_local_executor_shards(4, Some(2));
    
    // Step 3: Partition transactions (creates round_ids up to 9)
    let transactions: Vec<AnalyzedTransaction> = /* ... */;
    let partitioned = partitioner.partition(transactions, 4);
    
    // Step 4: Execute partitioned block - PANIC occurs when round >= 8
    let result = executor_client.execute_block(
        Arc::new(mock_state_view),
        partitioned,
        2,
        BlockExecutorConfigFromOnchain::default(),
    );
    // Panic: index out of bounds when accessing message_txs[shard_id][8]
}
```

## Notes

This vulnerability demonstrates a critical defense-in-depth failure where multiple layers (constructor, configuration, runtime) all lack proper validation. While currently low likelihood due to default safe values and limited production deployment, any validator crash vulnerability represents a serious threat to network availability and consensus integrity. The fix should be implemented across all validation layers to prevent both accidental misconfiguration and potential future attack vectors if sharded execution becomes production-critical.

### Citations

**File:** execution/block-partitioner/src/v2/types.rs (L89-94)
```rust
    pub fn new(round_id: RoundId, shard_id: ShardId, txn_idx1: PrePartitionedTxnIdx) -> Self {
        Self {
            sub_block_idx: SubBlockIdx::new(round_id, shard_id),
            pre_partitioned_txn_idx: txn_idx1,
        }
    }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/local_executor_shard.rs (L95-104)
```rust
        let (cross_shard_msg_txs, cross_shard_msg_rxs): (
            Vec<Vec<Sender<CrossShardMsg>>>,
            Vec<Vec<Receiver<CrossShardMsg>>>,
        ) = (0..num_shards)
            .map(|_| {
                (0..MAX_ALLOWED_PARTITIONING_ROUNDS)
                    .map(|_| unbounded())
                    .unzip()
            })
            .unzip();
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/local_executor_shard.rs (L331-337)
```rust
    fn send_cross_shard_msg(&self, shard_id: ShardId, round: RoundId, msg: CrossShardMsg) {
        self.message_txs[shard_id][round].send(msg).unwrap()
    }

    fn receive_cross_shard_msg(&self, current_round: RoundId) -> CrossShardMsg {
        self.message_rxs[current_round].recv().unwrap()
    }
```

**File:** execution/executor-service/src/remote_cross_shard_client.rs (L28-40)
```rust
            for round in 0..MAX_ALLOWED_PARTITIONING_ROUNDS {
                let message_type = format!("cross_shard_{}", round);
                let tx = controller.create_outbound_channel(*remote_address, message_type);
                txs.push(Mutex::new(tx));
            }
            message_txs.push(txs);
        }

        // Create inbound channels for each round
        for round in 0..MAX_ALLOWED_PARTITIONING_ROUNDS {
            let message_type = format!("cross_shard_{}", round);
            let rx = controller.create_inbound_channel(message_type);
            message_rxs.push(Mutex::new(rx));
```

**File:** execution/executor-service/src/remote_cross_shard_client.rs (L55-66)
```rust
    fn send_cross_shard_msg(&self, shard_id: ShardId, round: RoundId, msg: CrossShardMsg) {
        let input_message = bcs::to_bytes(&msg).unwrap();
        let tx = self.message_txs[shard_id][round].lock().unwrap();
        tx.send(Message::new(input_message)).unwrap();
    }

    fn receive_cross_shard_msg(&self, current_round: RoundId) -> CrossShardMsg {
        let rx = self.message_rxs[current_round].lock().unwrap();
        let message = rx.recv().unwrap();
        let msg: CrossShardMsg = bcs::from_bytes(&message.to_bytes()).unwrap();
        msg
    }
```

**File:** execution/block-partitioner/src/v2/mod.rs (L107-129)
```rust
    pub fn new(
        num_threads: usize,
        num_rounds_limit: usize,
        cross_shard_dep_avoid_threshold: f32,
        dashmap_num_shards: usize,
        partition_last_round: bool,
        pre_partitioner: Box<dyn PrePartitioner>,
    ) -> Self {
        let thread_pool = Arc::new(
            ThreadPoolBuilder::new()
                .num_threads(num_threads)
                .build()
                .unwrap(),
        );
        Self {
            pre_partitioner,
            thread_pool,
            max_partitioning_rounds: num_rounds_limit,
            cross_shard_dep_avoid_threshold,
            dashmap_num_shards,
            partition_last_round,
        }
    }
```

**File:** execution/block-partitioner/src/v2/partition_to_matrix.rs (L37-70)
```rust
        for round_id in 0..(state.num_rounds_limit - 1) {
            let (accepted, discarded) = Self::discarding_round(state, round_id, remaining_txns);
            state.finalized_txn_matrix.push(accepted);
            remaining_txns = discarded;
            num_remaining_txns = remaining_txns.iter().map(|ts| ts.len()).sum();

            if num_remaining_txns
                < ((1.0 - state.cross_shard_dep_avoid_threshold) * state.num_txns() as f32) as usize
            {
                break;
            }
        }

        let _timer = MISC_TIMERS_SECONDS.timer_with(&["last_round"]);

        if !state.partition_last_round {
            trace!("Merging txns after discarding stopped.");
            let last_round_txns: Vec<PrePartitionedTxnIdx> =
                remaining_txns.into_iter().flatten().collect();
            remaining_txns = vec![vec![]; state.num_executor_shards];
            remaining_txns[state.num_executor_shards - 1] = last_round_txns;
        }

        let last_round_id = state.finalized_txn_matrix.len();
        state.thread_pool.install(|| {
            (0..state.num_executor_shards)
                .into_par_iter()
                .for_each(|shard_id| {
                    remaining_txns[shard_id].par_iter().for_each(|&txn_idx| {
                        state.update_trackers_on_accepting(txn_idx, last_round_id, shard_id);
                    });
                });
        });
        state.finalized_txn_matrix.push(remaining_txns);
```

**File:** types/src/block_executor/partitioner.rs (L18-22)
```rust
pub type RoundId = usize;

pub static MAX_ALLOWED_PARTITIONING_ROUNDS: usize = 8;
pub static GLOBAL_ROUND_ID: usize = MAX_ALLOWED_PARTITIONING_ROUNDS + 1;
pub static GLOBAL_SHARD_ID: usize = usize::MAX;
```

**File:** execution/executor-benchmark/src/main.rs (L216-259)
```rust
    #[clap(long, default_value = "4")]
    max_partitioning_rounds: usize,
    #[clap(long, default_value = "0.90")]
    partitioner_cross_shard_dep_avoid_threshold: f32,
    #[clap(long)]
    partitioner_version: Option<String>,
    #[clap(long)]
    pre_partitioner: Option<String>,
    #[clap(long, default_value = "2.0")]
    load_imbalance_tolerance: f32,
    #[clap(long, default_value = "8")]
    partitioner_v2_num_threads: usize,
    #[clap(long, default_value = "64")]
    partitioner_v2_dashmap_num_shards: usize,
}

impl ShardingOpt {
    fn pre_partitioner_config(&self) -> Box<dyn PrePartitionerConfig> {
        match self.pre_partitioner.as_deref() {
            None => default_pre_partitioner_config(),
            Some("uniform") => Box::new(UniformPartitionerConfig {}),
            Some("connected-component") => Box::new(ConnectedComponentPartitionerConfig {
                load_imbalance_tolerance: self.load_imbalance_tolerance,
            }),
            _ => panic!("Unknown PrePartitioner: {:?}", self.pre_partitioner),
        }
    }

    fn partitioner_config(&self) -> PartitionerV2Config {
        match self.partitioner_version.as_deref() {
            Some("v2") => PartitionerV2Config {
                num_threads: self.partitioner_v2_num_threads,
                max_partitioning_rounds: self.max_partitioning_rounds,
                cross_shard_dep_avoid_threshold: self.partitioner_cross_shard_dep_avoid_threshold,
                dashmap_num_shards: self.partitioner_v2_dashmap_num_shards,
                partition_last_round: !self.use_global_executor,
                pre_partitioner_config: self.pre_partitioner_config(),
            },
            None => PartitionerV2Config::default(),
            _ => panic!(
                "Unknown partitioner version: {:?}",
                self.partitioner_version
            ),
        }
```

**File:** execution/block-partitioner/src/v2/state.rs (L323-330)
```rust
        // Build dependent edges.
        for &key_idx in self.write_sets[ori_txn_idx].read().unwrap().iter() {
            if Some(txn_idx) == self.last_writer(key_idx, SubBlockIdx { round_id, shard_id }) {
                let start_of_next_sub_block = ShardedTxnIndexV2::new(round_id, shard_id + 1, 0);
                let next_writer = self.first_writer(key_idx, start_of_next_sub_block);
                let end_follower = match next_writer {
                    None => ShardedTxnIndexV2::new(self.num_rounds(), self.num_executor_shards, 0), // Guaranteed to be greater than any invalid idx...
                    Some(idx) => ShardedTxnIndexV2::new(idx.round_id(), idx.shard_id() + 1, 0),
```
