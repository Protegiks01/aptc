# Audit Report

## Title
Case-Insensitive Module Name Collision Bypasses Compatibility Checks and Causes State Inconsistency

## Summary
The module storage system uses case-sensitive identifiers but lacks validation to prevent multiple modules at the same address with names differing only in case. This allows attackers to bypass compatibility checks by publishing case-variant modules (e.g., "MyModule" and "mymodule"), leading to state inconsistencies and potential deterministic execution violations.

## Finding Description

The Aptos module publishing system enforces that module upgrades must pass compatibility checks to prevent breaking changes. However, these checks can be bypassed by publishing modules with case-variant names at the same address.

The vulnerability exists because:

1. **Module names are case-sensitive throughout the system**: The `IdentStr` type uses standard string comparison, and `ModuleId` derives `Hash` and `Eq`, making all comparisons case-sensitive. [1](#0-0) [2](#0-1) 

2. **Storage keys are generated using exact case**: Each case variant creates a different `StateKey`, allowing both "MyModule" and "mymodule" to coexist in storage. [3](#0-2) 

3. **Compatibility checks use the module name from bytecode being published**: When publishing a module, the system extracts the name from the bytecode and looks up existing modules using that exact name. [4](#0-3) 

4. **No validation prevents case-insensitive duplicates**: The duplicate check only catches exact duplicates within the same bundle, not case variants. [5](#0-4) 

**Attack Scenario:**
1. Module "MyModule" is published at address 0x123
2. Attacker crafts bytecode for module "mymodule" (lowercase) at address 0x123
3. During publishing, the compatibility check looks up `existing_module_storage.unmetered_get_deserialized_module(0x123, "mymodule")`
4. This case-sensitive lookup returns `None` (doesn't find "MyModule")
5. Module "mymodule" is published without compatibility validation
6. Storage now contains two modules: `StateKey::module(0x123, "MyModule")` and `StateKey::module(0x123, "mymodule")`

This causes:
- **Bypassed compatibility checks**: Breaking changes can be deployed without validation
- **State inconsistency**: Multiple modules with case-varying names violate uniqueness expectations
- **Metadata lookup failures**: `unmetered_get_module_state_value_metadata` returns different results for different case variants [6](#0-5) 

## Impact Explanation

This is a **Medium Severity** vulnerability based on Aptos bug bounty criteria:

- **State inconsistencies requiring intervention**: Two modules with case-variant names at the same address violate protocol invariants and create ambiguous state
- **Bypassed security controls**: Compatibility checks are a critical safeguard against breaking changes; bypassing them allows incompatible module upgrades
- **Potential deterministic execution violations**: If different nodes have different case-variant modules (due to state sync issues or race conditions), they could execute transactions differently, violating the "Deterministic Execution" invariant

While the Move compiler enforces case-sensitive names in normal compilation, an attacker can craft raw bytecode with arbitrary valid identifiers. This makes the attack feasible for sophisticated actors.

## Likelihood Explanation

**Likelihood: Medium**

This vulnerability requires:
1. Ability to craft raw Move bytecode (moderate technical barrier)
2. Control over an address to publish modules (readily available)
3. Knowledge of existing module names at the target address

The Move package system includes a compile-time check to prevent case-insensitive collisions within packages, but this only applies at build time and doesn't prevent on-chain case variants across different publishing transactions. [7](#0-6) 

The lack of runtime validation makes exploitation straightforward once bytecode is crafted.

## Recommendation

Implement case-insensitive duplicate detection during module publishing. Add a validation step in `StagingModuleStorage::create_with_compat_config` that checks for existing modules with case-insensitive name matches:

```rust
// After line 154 in publishing.rs, add:
let lowercase_name = name.as_str().to_lowercase();
for existing_name in existing_module_storage.get_module_names_at_address(addr)? {
    if existing_name.as_str().to_lowercase() == lowercase_name && existing_name != name {
        return Err(PartialVMError::new(StatusCode::DUPLICATE_MODULE_NAME)
            .with_message(format!(
                "Module {} conflicts with existing module {} (case-insensitive collision)",
                name, existing_name
            ))
            .finish(Location::Undefined));
    }
}
```

This prevents case-variant modules from being published while maintaining backward compatibility for existing modules.

## Proof of Concept

```rust
// Rust test demonstrating the vulnerability
#[test]
fn test_case_variant_module_bypass() {
    // 1. Publish module "MyModule" at address 0x123
    let module1_bytecode = create_module_bytecode(
        AccountAddress::from_hex_literal("0x123").unwrap(),
        "MyModule",
        vec![] // empty module
    );
    
    let result1 = publish_module(&module1_bytecode);
    assert!(result1.is_ok());
    
    // 2. Craft bytecode for "mymodule" (lowercase) at same address
    let module2_bytecode = create_module_bytecode(
        AccountAddress::from_hex_literal("0x123").unwrap(),
        "mymodule", // Different case
        vec![] // incompatible changes that should fail compatibility check
    );
    
    // 3. Publish "mymodule" - compatibility check is bypassed
    let result2 = publish_module(&module2_bytecode);
    assert!(result2.is_ok()); // Succeeds without compatibility validation!
    
    // 4. Verify both modules exist in storage
    let storage_key1 = StateKey::module(
        &AccountAddress::from_hex_literal("0x123").unwrap(),
        IdentStr::new("MyModule").unwrap()
    );
    let storage_key2 = StateKey::module(
        &AccountAddress::from_hex_literal("0x123").unwrap(),
        IdentStr::new("mymodule").unwrap()
    );
    
    assert!(state_view.get_state_value(&storage_key1).unwrap().is_some());
    assert!(state_view.get_state_value(&storage_key2).unwrap().is_some());
    
    // 5. Metadata lookup returns different results for case variants
    let metadata1 = module_storage.unmetered_get_module_state_value_metadata(
        &AccountAddress::from_hex_literal("0x123").unwrap(),
        IdentStr::new("MyModule").unwrap()
    ).unwrap();
    let metadata2 = module_storage.unmetered_get_module_state_value_metadata(
        &AccountAddress::from_hex_literal("0x123").unwrap(),
        IdentStr::new("mymodule").unwrap()
    ).unwrap();
    
    assert!(metadata1.is_some());
    assert!(metadata2.is_some());
    assert_ne!(metadata1, metadata2); // Different metadata for case variants!
}
```

## Notes

This vulnerability affects the core module publishing invariants. The case-sensitivity of identifiers is correct for normal operation, but the lack of validation against case-insensitive collisions creates an exploitable gap. The Move compiler's package-level check prevents this during normal compilation but cannot prevent runtime exploitation via crafted bytecode.

### Citations

**File:** third_party/move/move-core/types/src/identifier.rs (L211-213)
```rust
#[derive(Debug, Eq, Hash, Ord, PartialEq, PartialOrd, RefCast)]
#[repr(transparent)]
pub struct IdentStr(str);
```

**File:** third_party/move/move-core/types/src/language_storage.rs (L387-397)
```rust
#[derive(Serialize, Deserialize, Debug, PartialEq, Hash, Eq, Clone, PartialOrd, Ord)]
#[cfg_attr(
    any(test, feature = "fuzzing"),
    derive(arbitrary::Arbitrary, dearbitrary::Dearbitrary)
)]
#[cfg_attr(any(test, feature = "fuzzing"), derive(Arbitrary))]
#[cfg_attr(any(test, feature = "fuzzing"), proptest(no_params))]
pub struct ModuleId {
    pub address: AccountAddress,
    pub name: Identifier,
}
```

**File:** types/src/state_store/state_key/mod.rs (L173-184)
```rust
    pub fn module(address: &AccountAddress, name: &IdentStr) -> Self {
        Self(
            REGISTRY
                .module(address, name)
                .get_or_add(address, name, || {
                    Ok(StateKeyInner::AccessPath(AccessPath::code_access_path(
                        ModuleId::new(*address, name.to_owned()),
                    )))
                })
                .expect("only possible error is resource path serialization"),
        )
    }
```

**File:** third_party/move/move-vm/runtime/src/storage/publishing.rs (L153-180)
```rust
            let addr = compiled_module.self_addr();
            let name = compiled_module.self_name();

            // Make sure all modules' addresses match the sender. The self address is
            // where the module will actually be published. If we did not check this,
            // the sender could publish a module under anyone's account.
            if addr != sender {
                let msg = format!(
                    "Compiled modules address {} does not match the sender {}",
                    addr, sender
                );
                return Err(verification_error(
                    StatusCode::MODULE_ADDRESS_DOES_NOT_MATCH_SENDER,
                    IndexKind::AddressIdentifier,
                    compiled_module.self_handle_idx().0,
                )
                .with_message(msg)
                .finish(Location::Undefined));
            }

            // All modules can be republished, as long as the new module is compatible
            // with the old module.
            if compatibility.need_check_compat() {
                // INVARIANT:
                //   Old module must be metered at the caller side.
                if let Some(old_module_ref) =
                    existing_module_storage.unmetered_get_deserialized_module(addr, name)?
                {
```

**File:** third_party/move/move-vm/runtime/src/storage/publishing.rs (L207-217)
```rust
            // Publishing the same module in the same bundle is not allowed.
            if prev.is_some() {
                let msg = format!(
                    "Module {}::{} occurs more than once in published bundle",
                    compiled_module.self_addr(),
                    compiled_module.self_name()
                );
                return Err(PartialVMError::new(StatusCode::DUPLICATE_MODULE_NAME)
                    .with_message(msg)
                    .finish(Location::Undefined));
            }
```

**File:** aptos-move/aptos-vm-types/src/module_and_script_storage/state_view_adapter.rs (L164-178)
```rust
    fn unmetered_get_module_state_value_metadata(
        &self,
        address: &AccountAddress,
        module_name: &IdentStr,
    ) -> PartialVMResult<Option<StateValueMetadata>> {
        let state_key = StateKey::module(address, module_name);
        Ok(self
            .storage
            .module_storage()
            .byte_storage()
            .state_view
            .get_state_value(&state_key)
            .map_err(|err| module_storage_error!(address, module_name, err).to_partial())?
            .map(|state_value| state_value.into_metadata()))
    }
```

**File:** third_party/move/tools/move-package/src/compilation/compiled_package.rs (L780-829)
```rust
        // A mapping of (lowercase_name => [info_for_each_occurence]
        let mut insensitive_mapping = BTreeMap::new();
        for compiled_unit in &self.root_compiled_units {
            let is_module = matches!(&compiled_unit.unit, CompiledUnit::Module(_));
            let name = match &compiled_unit.unit {
                CompiledUnit::Script(named) => named.name.as_str(),
                CompiledUnit::Module(named) => named.name.as_str(),
            };
            let entry = insensitive_mapping
                .entry(name.to_lowercase())
                .or_insert_with(Vec::new);
            entry.push((
                name,
                is_module,
                compiled_unit.source_path.to_string_lossy().to_string(),
            ));
        }
        let errs = insensitive_mapping
            .into_iter()
            .filter_map(|(insensitive_name, occurence_infos)| {
                if occurence_infos.len() > 1 {
                    let name_conflict_error_msg = occurence_infos
                        .into_iter()
                        .map(|(name, is_module, fpath)| {
                            format!(
                                "\t{} '{}' at path '{}'",
                                if is_module { "Module" } else { "Script" },
                                name,
                                fpath
                            )
                        })
                        .collect::<Vec<_>>()
                        .join("\n");
                    Some(format!(
                        "The following modules and/or scripts would collide as '{}' on the file system:\n{}",
                        insensitive_name, name_conflict_error_msg
                    ))
                } else {
                    None
                }
            })
            .collect::<Vec<_>>();
        if !errs.is_empty() {
            anyhow::bail!("Module and/or script names found that would cause failures on case insensitive \
                file systems when compiling package '{}':\n{}\nPlease rename these scripts and/or modules to resolve these conflicts.",
                self.compiled_package_info.package_name,
                errs.join("\n"),
            )
        }
        Ok(())
```
