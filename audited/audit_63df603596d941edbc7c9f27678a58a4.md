# Audit Report

## Title
Cryptographic Verification Bypass in DbStateView Allows Unverified State Reads

## Summary
The `DbStateView::get()` function fails to enforce cryptographic verification of state values when Merkle proof retrieval fails, allowing unverified state data to be returned to callers who explicitly requested verified reads through `verified_state_view_at_version()`. This breaks the fundamental security guarantee that all state reads should be cryptographically proven against the ledger root hash. [1](#0-0) 

## Finding Description

The `DbStateView::get()` function implements a two-query pattern with flawed error handling that allows cryptographic verification to be silently bypassed:

**Query 1 (Lines 34-38):** Attempts to retrieve state value with Merkle proof and verify it: [2](#0-1) 

**Query 2 (Lines 40-42):** Returns state value from separate unverified database query: [3](#0-2) 

The critical flaw is the `if let Ok(...)` pattern on line 34. When Query 1 fails with an error (returns `Err`), the error is silently caught and verification is completely skipped. Query 2 then executes and returns an **unverified value** that was never cryptographically proven against the state root hash.

**Proof Verification Logic is Correct:** The Merkle proof verification itself properly distinguishes inclusion and exclusion proofs: [4](#0-3) 

**Root Cause:** The vulnerability is not in proof verification logic but in the error-swallowing pattern that allows verification to be bypassed entirely.

**Attack Path:**

1. **Setup Phase:** Attacker waits for or creates conditions where `get_state_value_with_proof_by_version()` fails:
   - State merkle tree pruned for requested version (natural occurrence)
   - Database inconsistency between `state_merkle_db` and `state_kv_db` 
   - Async commit lag where KV database is updated but merkle tree commit is pending [5](#0-4) 

2. **Verification Bypass:** Client calls `verified_state_view_at_version()` expecting cryptographic guarantees: [6](#0-5) 

3. **Exploitation:** When client reads state:
   - Query 1 fails due to pruned merkle tree (checked at line 685): [7](#0-6) 
   - Verification skipped due to `if let Ok(...)` pattern
   - Query 2 returns unverified value from KV database
   - Client receives unverified data believing it's cryptographically verified

**Concrete Example - Pruning Attack:** [8](#0-7) 

When state merkle tree has been pruned for version V but KV database still contains values for version V (different pruning schedules), the first query returns `Err` (pruned), verification is bypassed, and unverified values are returned.

## Impact Explanation

**High Severity** - This vulnerability breaks **Critical Invariant #4: "State Consistency: State transitions must be atomic and verifiable via Merkle proofs"**.

**Security Impact:**

1. **Consensus Divergence:** If different validators have different database pruning states or inconsistencies, they may return different unverified state values for the same root hash, violating deterministic execution and potentially causing consensus safety violations.

2. **Client Security Compromise:** Light clients and external services using `verified_state_view_at_version()` expect cryptographic proofs that state values match the committed ledger. This bypass allows serving arbitrary unverified data.

3. **Byzantine Attack Vector:** Malicious validators can intentionally create database inconsistencies (through direct database manipulation on compromised nodes) to serve incorrect state while bypassing verification.

Per Aptos bug bounty criteria, this qualifies as **High Severity** ("Significant protocol violations") approaching **Critical** if it can be demonstrated to cause consensus safety violations in practice.

## Likelihood Explanation

**High Likelihood** - This vulnerability can be triggered through multiple natural and adversarial paths:

1. **Natural Occurrence:** State merkle tree pruning is a normal operation. The pruning manager tracks minimum readable versions: [9](#0-8) 

2. **Async Commit Windows:** State merkle tree commits happen asynchronously in a background thread, creating windows where the two databases are inconsistent during normal operation.

3. **Crash Recovery:** Before `sync_commit_progress` runs after node restart, databases may be temporarily inconsistent.

4. **Database Corruption:** Storage layer bugs or disk failures can create persistent inconsistencies.

The vulnerability requires no special attacker privileges - it can be triggered by normal node operations or by compromising a single validator node to manipulate local database state.

## Recommendation

**Fix:** The verification must be mandatory when `maybe_verify_against_state_root_hash` is set. Errors during proof retrieval should propagate to the caller rather than being silently caught:

```rust
fn get(&self, key: &StateKey) -> StateViewResult<Option<(Version, StateValue)>> {
    if let Some(version) = self.version {
        if let Some(root_hash) = self.maybe_verify_against_state_root_hash {
            // Mandatory verification - propagate errors
            let (value, proof) = self.db.get_state_value_with_proof_by_version(key, version)?;
            proof.verify(root_hash, *key.crypto_hash_ref(), value.as_ref())?;
            return Ok(value.map(|v| (version, v)));
        }
        Ok(self.db.get_state_value_with_version_by_version(key, version)?)
    } else {
        Ok(None)
    }
}
```

**Key Changes:**
1. Remove `if let Ok(...)` pattern - errors must propagate with `?` operator
2. Return the verified value directly rather than making a second unverified query
3. This ensures verification is never bypassed when `maybe_verify_against_state_root_hash` is set

## Proof of Concept

```rust
#[test]
fn test_verification_bypass_with_pruned_merkle_tree() {
    use aptos_storage_interface::{DbReader, VerifiedStateViewAtVersion, TStateView};
    use aptos_types::state_store::state_key::StateKey;
    
    // Setup: Create database with state at version 100
    let tmp_dir = TempPath::new();
    let db = AptosDB::new_for_test(&tmp_dir);
    let key = StateKey::raw(b"test_key");
    let value = StateValue::from(b"test_value".to_vec());
    
    // Commit state at version 100
    db.state_store.commit_block_for_test(100, vec![(key.clone(), Some(value.clone()))]);
    let root_hash = db.state_store.get_root_hash(100).unwrap();
    
    // Create LedgerInfo with this root hash
    let ledger_info = create_test_ledger_info(100, root_hash);
    
    // Prune state merkle tree to make version 100 unreadable
    db.state_store.state_db.state_merkle_pruner.prune(101).unwrap();
    
    // Create verified state view - expects cryptographic verification
    let verified_view = db.reader.verified_state_view_at_version(
        Some(100),
        &ledger_info,
    ).unwrap();
    
    // BUG: This should fail with pruning error, but instead returns unverified value
    // because verification is silently bypassed when proof retrieval fails
    match verified_view.get_state_slot(&key) {
        Ok(slot) => {
            // VULNERABILITY: We got a value without cryptographic verification!
            // The function should have failed with a pruning error, but instead
            // returned unverified data from the KV database
            panic!("VULNERABILITY: Verification was bypassed! Got unverified value: {:?}", slot);
        },
        Err(e) => {
            // Expected: Should fail because merkle tree is pruned
            assert!(e.to_string().contains("pruned") || e.to_string().contains("NotFound"));
        }
    }
}
```

**Expected Behavior:** Test should fail at the `panic!` line, demonstrating that unverified values are returned when verification should be mandatory.

**Notes:**
- The vulnerability affects any code path using `verified_state_view_at_version()` expecting cryptographic guarantees
- The async commit pattern in StateMerkleBatchCommitter creates natural windows for exploitation
- Database pruning schedules can legitimately cause merkle tree and KV database to be at different versions
- The security guarantee of "verified state view" is fundamentally broken by this bypass

### Citations

**File:** storage/storage-interface/src/state_store/state_view/db_state_view.rs (L27-46)
```rust
    fn get(&self, key: &StateKey) -> StateViewResult<Option<(Version, StateValue)>> {
        if let Some(version) = self.version {
            if let Some(root_hash) = self.maybe_verify_against_state_root_hash {
                // TODO(aldenhu): sample-verify proof inside DB
                // DB doesn't support returning proofs for buffered state, so only optionally
                // verify proof.
                // TODO: support returning state proof for buffered state.
                if let Ok((value, proof)) =
                    self.db.get_state_value_with_proof_by_version(key, version)
                {
                    proof.verify(root_hash, *key.crypto_hash_ref(), value.as_ref())?;
                }
            }
            Ok(self
                .db
                .get_state_value_with_version_by_version(key, version)?)
        } else {
            Ok(None)
        }
    }
```

**File:** storage/storage-interface/src/state_store/state_view/db_state_view.rs (L115-147)
```rust
impl VerifiedStateViewAtVersion for Arc<dyn DbReader> {
    fn verified_state_view_at_version(
        &self,
        version: Option<Version>,
        ledger_info: &LedgerInfo,
    ) -> StateViewResult<DbStateView> {
        let db = self.clone();

        if let Some(version) = version {
            let txn_with_proof =
                db.get_transaction_by_version(version, ledger_info.version(), false)?;
            txn_with_proof.verify(ledger_info)?;

            let state_root_hash = txn_with_proof
                .proof
                .transaction_info
                .state_checkpoint_hash()
                .ok_or_else(|| StateViewError::NotFound("state_checkpoint_hash".to_string()))?;

            Ok(DbStateView {
                db,
                version: Some(version),
                maybe_verify_against_state_root_hash: Some(state_root_hash),
            })
        } else {
            Ok(DbStateView {
                db,
                version: None,
                maybe_verify_against_state_root_hash: None,
            })
        }
    }
}
```

**File:** types/src/proof/definition.rs (L343-399)
```rust
        match (element_hash, self.leaf) {
            (Some(hash), Some(leaf)) => {
                // This is an inclusion proof, so the key and value hash provided in the proof
                // should match element_key and element_value_hash. `siblings` should prove the
                // route from the leaf node to the root.
                ensure!(
                    element_key == leaf.key,
                    "Keys do not match. Key in proof: {:x}. Expected key: {:x}. \
                     Element hash: {:x}. Value hash in proof {:x}",
                    leaf.key,
                    element_key,
                    hash,
                    leaf.value_hash
                );
                ensure!(
                    hash == leaf.value_hash,
                    "Value hashes do not match for key {:x}. Value hash in proof: {:x}. \
                     Expected value hash: {:x}. ",
                    element_key,
                    leaf.value_hash,
                    hash
                );
            },
            (Some(hash), None) => {
                bail!(
                    "Expected inclusion proof, value hash: {:x}. Found non-inclusion proof.",
                    hash
                )
            },
            (None, Some(leaf)) => {
                // This is a non-inclusion proof. The proof intends to show that if a leaf node
                // representing `element_key` is inserted, it will break a currently existing leaf
                // node represented by `proof_key` into a branch. `siblings` should prove the
                // route from that leaf node to the root.
                ensure!(
                    element_key != leaf.key,
                    "Expected non-inclusion proof, but key exists in proof. \
                     Key: {:x}. Key in proof: {:x}.",
                    element_key,
                    leaf.key,
                );
                ensure!(
                    element_key.common_prefix_bits_len(leaf.key)
                        >= root_depth + self.siblings.len(),
                    "Key would not have ended up in the subtree where the provided key in proof \
                     is the only existing key, if it existed. So this is not a valid \
                     non-inclusion proof. Key: {:x}. Key in proof: {:x}.",
                    element_key,
                    leaf.key
                );
            },
            (None, None) => {
                // This is a non-inclusion proof. The proof intends to show that if a leaf node
                // representing `element_key` is inserted, it will show up at a currently empty
                // position. `sibling` should prove the route from this empty position to the root.
            },
        }
```

**File:** storage/aptosdb/src/state_store/state_merkle_batch_committer.rs (L52-115)
```rust
    pub fn run(self) {
        while let Ok(msg) = self.state_merkle_batch_receiver.recv() {
            let _timer = OTHER_TIMERS_SECONDS.timer_with(&["batch_committer_work"]);
            match msg {
                CommitMessage::Data(StateMerkleCommit {
                    snapshot,
                    hot_batch,
                    cold_batch,
                }) => {
                    let base_version = self.persisted_state.get_state_summary().version();
                    let current_version = snapshot
                        .version()
                        .expect("Current version should not be None");

                    // commit jellyfish merkle nodes
                    let _timer =
                        OTHER_TIMERS_SECONDS.timer_with(&["commit_jellyfish_merkle_nodes"]);
                    if let Some(hot_state_merkle_batch) = hot_batch {
                        self.commit(
                            self.state_db
                                .hot_state_merkle_db
                                .as_ref()
                                .expect("Hot state merkle db must exist."),
                            current_version,
                            hot_state_merkle_batch,
                        )
                        .expect("Hot state merkle nodes commit failed.");
                    }
                    self.commit(&self.state_db.state_merkle_db, current_version, cold_batch)
                        .expect("State merkle nodes commit failed.");

                    info!(
                        version = current_version,
                        base_version = base_version,
                        root_hash = snapshot.summary().root_hash(),
                        hot_root_hash = snapshot.summary().hot_root_hash(),
                        "State snapshot committed."
                    );
                    LATEST_SNAPSHOT_VERSION.set(current_version as i64);
                    // TODO(HotState): no pruning for hot state right now, since we always reset it
                    // upon restart.
                    self.state_db
                        .state_merkle_pruner
                        .maybe_set_pruner_target_db_version(current_version);
                    self.state_db
                        .epoch_snapshot_pruner
                        .maybe_set_pruner_target_db_version(current_version);

                    self.check_usage_consistency(&snapshot).unwrap();

                    snapshot
                        .summary()
                        .global_state_summary
                        .log_generation("buffered_state_commit");
                    self.persisted_state.set(snapshot);
                },
                CommitMessage::Sync(finish_sender) => finish_sender.send(()).unwrap(),
                CommitMessage::Exit => {
                    break;
                },
            }
        }
        trace!("State merkle batch committing thread exit.")
    }
```

**File:** storage/aptosdb/src/db/aptosdb_reader.rs (L677-693)
```rust
    fn get_state_value_with_proof_by_version_ext(
        &self,
        key_hash: &HashValue,
        version: Version,
        root_depth: usize,
        use_hot_state: bool,
    ) -> Result<(Option<StateValue>, SparseMerkleProofExt)> {
        gauged_api("get_state_value_with_proof_by_version_ext", || {
            self.error_if_state_merkle_pruned("State merkle", version)?;

            self.state_store.get_state_value_with_proof_by_version_ext(
                key_hash,
                version,
                root_depth,
                use_hot_state,
            )
        })
```

**File:** storage/aptosdb/src/db/aptosdb_internal.rs (L273-295)
```rust
    pub(super) fn error_if_state_merkle_pruned(
        &self,
        data_type: &str,
        version: Version,
    ) -> Result<()> {
        let min_readable_version = self
            .state_store
            .state_db
            .state_merkle_pruner
            .get_min_readable_version();
        if version >= min_readable_version {
            return Ok(());
        }

        let min_readable_epoch_snapshot_version = self
            .state_store
            .state_db
            .epoch_snapshot_pruner
            .get_min_readable_version();
        if version >= min_readable_epoch_snapshot_version {
            self.ledger_db.metadata_db().ensure_epoch_ending(version)
        } else {
            bail!(
```

**File:** storage/aptosdb/src/state_store/mod.rs (L109-118)
```rust
pub(crate) struct StateDb {
    pub ledger_db: Arc<LedgerDb>,
    pub hot_state_merkle_db: Option<Arc<StateMerkleDb>>,
    pub state_merkle_db: Arc<StateMerkleDb>,
    pub state_kv_db: Arc<StateKvDb>,
    pub state_merkle_pruner: StateMerklePrunerManager<StaleNodeIndexSchema>,
    pub epoch_snapshot_pruner: StateMerklePrunerManager<StaleNodeIndexCrossEpochSchema>,
    pub state_kv_pruner: StateKvPrunerManager,
    pub skip_usage: bool,
}
```
