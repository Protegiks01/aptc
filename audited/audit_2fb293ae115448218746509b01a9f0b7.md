# Audit Report

## Title
Node-Checker API Denial of Service via Malformed Cannot-Be-A-Base URLs

## Summary
The Node-Checker API endpoint `/check` accepts URL parameters from untrusted users without proper validation. When a cannot-be-a-base URL (e.g., `mailto:`, `data:`) is provided with an API port parameter, the service crashes due to an `.unwrap()` panic when attempting to set the port on a URL that doesn't support port configuration. This allows unprivileged attackers to repeatedly crash the node health checking service.

## Finding Description
The `validate_configuration()` function does not validate the optional `node_address` field for proper URL schemes or format. [1](#0-0) 

The Node-Checker exposes an HTTP API that accepts user-supplied URLs through the `/check` endpoint. [2](#0-1) 

When processing requests, a `NodeAddress` is constructed from these untrusted parameters and passed to the runner. [3](#0-2) 

The `SyncRunner` attempts to build an API client for the target node by calling `get_api_client()`. [4](#0-3) 

The `get_api_client()` method internally calls `get_api_url()` to construct the full URL with the port. [5](#0-4) 

The critical vulnerability exists in `get_api_url()` where `url.set_port()` is called with `.unwrap()`. [6](#0-5) 

In the Rust `url` crate, URLs that are "cannot-be-a-base" (such as `mailto:`, `data:`, `javascript:`) do not support hierarchical components like ports. The `set_port()` method returns `Err(())` for such URLs, causing the `.unwrap()` to panic and crash the entire service.

The same vulnerability exists in `get_metrics_url()`. [7](#0-6) 

## Impact Explanation
This vulnerability qualifies as **High Severity** under the Aptos Bug Bounty program's "API crashes" category. An attacker can:

1. **Deny service** to legitimate node operators attempting to validate their node health
2. **Repeatedly exploit** the vulnerability to maintain service disruption
3. **Require operator intervention** to restart the crashed service
4. **Impact network health monitoring** by preventing operators from validating their nodes before joining the network

The node-checker is a critical operational tool that enables node operators to validate their configurations against baseline requirements before connecting to the Aptos network. Disrupting this service affects the network's ability to onboard and maintain healthy nodes.

## Likelihood Explanation
**Likelihood: Very High**

- **Attack Complexity**: Trivial - requires only a single HTTP GET request
- **Attacker Requirements**: Network access to the node-checker API endpoint (typically publicly accessible)
- **Authentication**: None required
- **Reproducibility**: 100% - deterministic panic on cannot-be-a-base URLs
- **Detection**: Difficult - appears as a service crash rather than malicious activity

An attacker can craft a simple request like:
```
GET /check?baseline_configuration_id=devnet_fullnode&node_url=mailto:attack@example.com&api_port=8080
```

This will cause an immediate panic and service termination.

## Recommendation

Add proper URL validation in multiple layers:

1. **In `validate_configuration()`**: Validate baseline node addresses during configuration loading
2. **In `NodeAddress::new()` or via custom deserialization**: Validate URL schemes and ensure they support ports
3. **In `get_api_url()` and `get_metrics_url()`**: Replace `.unwrap()` with proper error handling

**Recommended Fix for `get_api_url()`:**

```rust
pub fn get_api_url(&self) -> Result<Url> {
    let mut url = self.url.clone();
    url.set_port(Some(
        self.api_port
            .context("Can't build API URL without an API port")?,
    ))
    .map_err(|_| anyhow!(
        "Failed to set port on URL {}. URL must use a hierarchical scheme like http:// or https://, not schemes like mailto: or data:",
        url
    ))?;
    Ok(url)
}
```

**Recommended validation in `validate_configuration()`:**

```rust
pub fn validate_configuration(node_configuration: &BaselineConfiguration) -> Result<()> {
    // Validate node_address if present
    if let Some(node_address) = &node_configuration.node_address {
        // Ensure the URL scheme is valid for network communication
        let scheme = node_address.url.scheme();
        if scheme != "http" && scheme != "https" {
            bail!(
                "Invalid URL scheme '{}'. Node addresses must use http:// or https://",
                scheme
            );
        }
        
        // Ensure the URL can have a port set (not cannot-be-a-base)
        if node_address.url.cannot_be_a_base() {
            bail!(
                "Invalid URL format '{}'. URL must support hierarchical components",
                node_address.url
            );
        }
    }
    
    build_checkers(&node_configuration.checkers).context("Failed to build Checkers")?;
    Ok(())
}
```

## Proof of Concept

**HTTP Request to trigger the panic:**

```bash
curl "http://localhost:20121/check?baseline_configuration_id=devnet_fullnode&node_url=mailto:attacker@example.com&api_port=8080"
```

**Expected result**: The node-checker service crashes with a panic trace similar to:
```
thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: ()', ecosystem/node-checker/src/configuration/node_address.rs:79:10
```

**Alternative PoC URLs that trigger the same vulnerability:**
- `data:text/plain,attack`
- `javascript:alert(1)`
- `about:blank`
- Any URL with `cannot_be_a_base: true`

**Notes:**
The vulnerability can also be triggered through the baseline configuration file, but the API endpoint represents the more severe attack vector as it allows remote, unauthenticated exploitation.

### Citations

**File:** ecosystem/node-checker/src/configuration/validate.rs (L24-27)
```rust
pub fn validate_configuration(node_configuration: &BaselineConfiguration) -> Result<()> {
    build_checkers(&node_configuration.checkers).context("Failed to build Checkers")?;
    Ok(())
}
```

**File:** ecosystem/node-checker/src/server/api.rs (L29-44)
```rust
    #[oai(path = "/check", method = "get")]
    async fn check(
        &self,
        /// The ID of the baseline node configuration to use for the evaluation, e.g. devnet_fullnode
        baseline_configuration_id: Query<String>,
        /// The URL of the node to check, e.g. http://44.238.19.217 or http://fullnode.mysite.com
        node_url: Query<Url>,
        /// If given, we will assume the metrics service is available at the given port.
        metrics_port: Query<Option<u16>>,
        /// If given, we will assume the API is available at the given port.
        api_port: Query<Option<u16>>,
        /// If given, we will assume that clients can communicate with your node via noise at the given port.
        noise_port: Query<Option<u16>>,
        /// A public key for the node, e.g. 0x44fd1324c66371b4788af0b901c9eb8088781acb29e6b8b9c791d5d9838fbe1f.
        /// This is only necessary for certain checkers, e.g. HandshakeChecker.
        public_key: Query<Option<String>>,
```

**File:** ecosystem/node-checker/src/server/api.rs (L81-92)
```rust
        let target_node_address = NodeAddress::new(
            node_url.0,
            api_port.0,
            metrics_port.0,
            noise_port.0,
            public_key,
        );

        let complete_evaluation_result = baseline_configuration
            .runner
            .run(&target_node_address)
            .await;
```

**File:** ecosystem/node-checker/src/runner/sync_runner.rs (L121-127)
```rust
        // Build the ApiIndexProvider for the target node.
        if let Ok(api_client) = target_node_address.get_api_client(Duration::from_secs(4)) {
            let api_index_provider = Arc::new(ApiIndexProvider::new(
                self.provider_configs.api_index.clone(),
                api_client,
            ));
            provider_collection.target_api_index_provider = Some(api_index_provider.clone());
```

**File:** ecosystem/node-checker/src/configuration/node_address.rs (L73-81)
```rust
    pub fn get_api_url(&self) -> Result<Url> {
        let mut url = self.url.clone();
        url.set_port(Some(
            self.api_port
                .context("Can't build API URL without an API port")?,
        ))
        .unwrap();
        Ok(url)
    }
```

**File:** ecosystem/node-checker/src/configuration/node_address.rs (L83-92)
```rust
    pub fn get_metrics_url(&self, path: &str) -> Result<Url> {
        let mut url = self.url.clone();
        url.set_port(Some(
            self.api_port
                .context("Can't build metrics URL without a metrics port")?,
        ))
        .unwrap();
        url.set_path(path);
        Ok(url)
    }
```

**File:** ecosystem/node-checker/src/configuration/node_address.rs (L107-115)
```rust
    pub fn get_api_client(&self, timeout: Duration) -> Result<AptosRestClient> {
        let client = reqwest::ClientBuilder::new()
            .timeout(timeout)
            .cookie_provider(self.cookie_store.clone())
            .build()
            .unwrap();

        Ok(AptosRestClient::from((client, self.get_api_url()?)))
    }
```
