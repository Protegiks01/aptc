# Audit Report

## Title
Late-Joining Validators Cannot Participate in Randomness Generation Due to Premature Cleanup of Certified Augmented Data

## Summary
The `remove_certified_aug_data()` function is called aggressively during validator initialization without any retention policy, causing late-joining or restarting validators to lose access to certified augmented data needed to verify randomness shares from other validators. This results in validator liveness failures and inability to participate in consensus.

## Finding Description

The randomness generation protocol in Aptos requires validators to exchange certified augmented data (containing Delta values for augmented public keys) at the start of each epoch. This data is critical for verifying randomness shares throughout the epoch.

**The vulnerability occurs in the cleanup logic:** [1](#0-0) 

When `AugDataStore::new()` is called during validator initialization, it performs aggressive cleanup by:
1. Loading all certified augmented data from persistent storage
2. Filtering by epoch - marking ALL data from non-current epochs for deletion
3. Calling `remove_certified_aug_data()` to delete the filtered data [2](#0-1) 

**There is NO defined cleanup policy or retention period.** The only caller of `remove_certified_aug_data()` is `AugDataStore::new()` - there are no other cleanup mechanisms.

**Attack Scenario:**

1. Network is at epoch N+1, validators V1, V2, V3, V4 are active
2. All validators broadcast their certified augmented data at epoch start (one-time reliable broadcast)
3. V4 crashes or experiences network partition mid-epoch
4. V4 restarts and calls `RandManager::new()` â†’ `AugDataStore::new(epoch=N+1)`
5. `AugDataStore::new()` retrieves stored data, but V4 doesn't have certified aug data from V1, V2, V3 (already broadcasted earlier)
6. V4 broadcasts its own augmented data, receives it certified
7. **Critical Gap**: V4 never receives V1, V2, V3's certified augmented data (no re-request mechanism exists) [3](#0-2) 

**No `RequestCertifiedAugData` message type exists** - validators cannot request historical certified augmented data from peers.

8. When V4 tries to verify randomness shares from V1, V2, V3, verification fails: [4](#0-3) 

9. Failed shares are silently dropped during verification: [5](#0-4) 

10. V4 cannot aggregate enough shares to produce randomness
11. Blocks waiting for randomness get stuck in V4's block queue
12. V4 experiences liveness failure and cannot make consensus progress

**Invariant Broken:** Validator liveness and consensus participation - a validator that restarts mid-epoch becomes permanently unable to participate in randomness generation.

## Impact Explanation

This is a **High Severity** vulnerability per Aptos bug bounty criteria:

- **"Validator node slowdowns"**: Affected validators cannot process blocks waiting for randomness, causing severe performance degradation
- **"Significant protocol violations"**: Breaks the randomness generation protocol's assumption that validators can catch up
- **Partial Loss of Liveness**: Affected validators become unable to participate in consensus for the remainder of the epoch

The certified augmented data is necessary for verifying randomness shares throughout the entire epoch: [6](#0-5) 

Without complete `certified_apks` from all validators, the affected validator cannot verify incoming shares, preventing participation in randomness aggregation.

## Likelihood Explanation

**Likelihood: HIGH**

This vulnerability triggers in common operational scenarios:
- Validator node restarts (software updates, crashes, maintenance)
- Network partitions that cause validators to temporarily fall behind
- New validators joining an active epoch
- Any scenario where a validator's `RandManager` is reinitialized during an epoch

The issue is deterministic - every late-joining/restarting validator will experience this problem. The only recovery is waiting for the next epoch transition where all validators re-broadcast their augmented data. [7](#0-6) 

## Recommendation

**Implement a retention policy and catchup mechanism:**

1. **Add Retention Policy**: Retain certified augmented data for N epochs (e.g., N=2) instead of aggressive same-epoch-only cleanup:

```rust
fn filter_by_epoch<T>(
    epoch: u64,
    all_data: impl Iterator<Item = (AugDataId, T)>,
) -> (Vec<T>, Vec<(AugDataId, T)>) {
    let mut to_remove = vec![];
    let mut to_keep = vec![];
    const RETENTION_EPOCHS: u64 = 2; // Keep data for 2 epochs
    for (id, data) in all_data {
        if epoch.saturating_sub(id.epoch()) > RETENTION_EPOCHS {
            to_remove.push(data)
        } else {
            to_keep.push((id, data))
        }
    }
    (to_remove, to_keep)
}
```

2. **Add RequestCertifiedAugData Message**: Extend the `RandMessage` enum to support requesting missing certified augmented data:

```rust
pub enum RandMessage<S, D> {
    RequestShare(RequestShare),
    RequestCertifiedAugData(RequestCertifiedAugData), // NEW
    Share(RandShare<S>),
    AugData(AugData<D>),
    AugDataSignature(AugDataSignature),
    CertifiedAugData(CertifiedAugData<D>),
    CertifiedAugDataAck(CertifiedAugDataAck),
    FastShare(FastShare<S>),
}
```

3. **Implement Catchup Logic**: When `AugDataStore::new()` detects missing certified augmented data for the current epoch, actively request it from peers before processing blocks.

## Proof of Concept

**Reproduction Steps:**

1. Start a 4-validator network at epoch N+1
2. Wait for all validators to complete augmented data broadcast
3. Stop validator V4
4. Clear V4's `rand_db` certified augmented data or simulate a restart
5. Restart V4's consensus component
6. Observe V4's logs for `"[RandShare] No augmented public key for validator id"` errors
7. Observe V4's block queue growing without randomness being generated
8. Verify V4 cannot make consensus progress for blocks requiring randomness

**Expected Behavior (Vulnerable):**
- V4 drops all randomness shares from V1, V2, V3
- V4's blocks remain stuck in queue waiting for randomness
- V4 experiences liveness failure until epoch transition

**Expected Behavior (Fixed):**
- V4 requests missing certified augmented data from peers
- V4 successfully verifies shares and aggregates randomness
- V4 maintains consensus participation

## Notes

This vulnerability affects the core consensus availability invariant. The randomness generation system assumes validators can always verify shares from peers, but the aggressive cleanup policy breaks this assumption for late-joining validators. The lack of a catchup mechanism means there's no path to recovery within the same epoch.

The issue is particularly severe because it can cascade - if multiple validators experience restarts during an epoch, network-wide randomness generation could be significantly impaired, affecting all blocks that require randomness for proposer selection or other purposes.

### Citations

**File:** consensus/src/rand/rand_gen/aug_data_store.rs (L57-65)
```rust
        let all_certified_data = db.get_all_certified_aug_data().unwrap_or_default();
        let (to_remove, certified_data) =
            Self::filter_by_epoch(epoch, all_certified_data.into_iter());
        if let Err(e) = db.remove_certified_aug_data(to_remove) {
            error!(
                "[AugDataStore] failed to remove certified aug data: {:?}",
                e
            );
        }
```

**File:** consensus/src/rand/rand_gen/storage/db.rs (L114-120)
```rust
    fn remove_certified_aug_data(
        &self,
        certified_aug_data: Vec<CertifiedAugData<D>>,
    ) -> Result<()> {
        Ok(self
            .delete::<CertifiedAugDataSchema<D>>(certified_aug_data.into_iter().map(|d| d.id()))?)
    }
```

**File:** consensus/src/rand/rand_gen/network_messages.rs (L24-33)
```rust
#[derive(Clone, Serialize, Deserialize, EnumConversion)]
pub enum RandMessage<S, D> {
    RequestShare(RequestShare),
    Share(RandShare<S>),
    AugData(AugData<D>),
    AugDataSignature(AugDataSignature),
    CertifiedAugData(CertifiedAugData<D>),
    CertifiedAugDataAck(CertifiedAugDataAck),
    FastShare(FastShare<S>),
}
```

**File:** consensus/src/rand/rand_gen/types.rs (L63-79)
```rust
        let maybe_apk = &rand_config.keys.certified_apks[index];
        if let Some(apk) = maybe_apk.get() {
            WVUF::verify_share(
                &rand_config.vuf_pp,
                apk,
                bcs::to_bytes(&rand_metadata)
                    .map_err(|e| anyhow!("Serialization failed: {}", e))?
                    .as_slice(),
                &self.share,
            )?;
        } else {
            bail!(
                "[RandShare] No augmented public key for validator id {}, {}",
                index,
                author
            );
        }
```

**File:** consensus/src/rand/rand_gen/rand_manager.rs (L238-252)
```rust
                            if msg
                                .verify(
                                    &epoch_state_clone,
                                    &config_clone,
                                    &fast_config_clone,
                                    rand_gen_msg.sender,
                                )
                                .is_ok()
                            {
                                let _ = tx.unbounded_send(RpcRequest {
                                    req: msg,
                                    protocol: rand_gen_msg.protocol,
                                    response_sender: rand_gen_msg.response_sender,
                                });
                            }
```

**File:** types/src/randomness.rs (L103-114)
```rust
#[derive(Clone, SilentDebug)]
pub struct RandKeys {
    // augmented secret / public key share of this validator, obtained from the DKG transcript of last epoch
    pub ask: ASK,
    pub apk: APK,
    // certified augmented public key share of all validators,
    // obtained from all validators in the new epoch,
    // which necessary for verifying randomness shares
    pub certified_apks: Vec<OnceCell<APK>>,
    // public key share of all validators, obtained from the DKG transcript of last epoch
    pub pk_shares: Vec<PKShare>,
}
```

**File:** consensus/src/pipeline/execution_client.rs (L240-251)
```rust
        let rand_manager = RandManager::<Share, AugmentedData>::new(
            self.author,
            epoch_state.clone(),
            signer,
            rand_config,
            fast_rand_config,
            rand_ready_block_tx,
            network_sender.clone(),
            self.rand_storage.clone(),
            self.bounded_executor.clone(),
            &self.consensus_config.rand_rb_config,
        );
```
