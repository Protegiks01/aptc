# Audit Report

## Title
JWK Consensus Resource Exhaustion via Unlimited OIDC Providers in Governance

## Summary
A malicious governance proposal can add an unlimited number of OIDC providers, each spawning an independent JWK observer that performs unconstrained HTTP requests every 10 seconds without timeouts, causing validator resource exhaustion through network connection depletion, CPU overhead, and memory consumption.

## Finding Description

The JWK consensus system allows governance to configure OIDC providers for keyless account validation. However, the implementation has critical resource limit violations:

**1. No Limit on Provider Count**: The Move framework's `jwk_consensus_config.move` only validates for duplicate provider names but enforces no maximum count on the `oidc_providers` vector. [1](#0-0) 

**2. Hardcoded Fetch Interval**: Each OIDC provider spawns a `JWKObserver` with a hardcoded 10-second fetch interval that cannot be controlled by governance. [2](#0-1) 

The same hardcoded interval exists in the per-key consensus manager: [3](#0-2) 

**3. No HTTP Request Timeouts**: The JWK fetching utilities create HTTP clients without any timeout configuration, allowing connections to hang indefinitely. [4](#0-3) 

**4. Two HTTP Requests Per Fetch**: Each observation cycle makes two sequential HTTP requests - one for the OpenID configuration and one for the JWK set. [5](#0-4) 

**Attack Path:**
1. Attacker submits governance proposal adding 200+ OIDC providers (within 1MB governance transaction limit)
2. Each provider's `config_url` points to attacker-controlled slow/unresponsive servers
3. Proposal passes governance vote and becomes active at next epoch
4. Each validator spawns 200+ independent `JWKObserver` tokio tasks [6](#0-5) 
5. Every 10 seconds, 200 observers Ã— 2 requests = 400 HTTP requests per validator
6. Without timeouts, slow servers hold connections open, exhausting file descriptors, network buffers, and CPU

This breaks the **Resource Limits** invariant: "All operations must respect gas, storage, and computational limits."

## Impact Explanation

This qualifies as **High Severity** under the Aptos bug bounty program because it enables **validator node slowdowns**. 

With 200 OIDC providers:
- 400 HTTP requests every 10 seconds per validator
- No timeout means connections accumulate if servers respond slowly
- System file descriptor limits can be reached (typically 1024-65536)
- CPU overhead from managing 200+ tokio tasks and pending HTTP operations
- Memory consumption from buffered HTTP responses
- Network bandwidth consumption if providers return large responses

All active validators are affected simultaneously, potentially degrading network performance and consensus liveness.

## Likelihood Explanation

**Likelihood: Medium**

**Requirements:**
- Attacker needs sufficient stake to create governance proposals
- Proposal must pass governance voting
- Attacker must operate slow/malicious OIDC provider endpoints

**Feasibility:**
- Governance proposals are realistic for well-funded attackers
- Operating slow HTTP servers is trivial
- Attack persists for entire epoch (making it impactful)
- No runtime detection or mitigation exists

The attack is not trivial (requires governance access) but is fully executable within the protocol's design.

## Recommendation

**Immediate Fixes:**

1. **Enforce Maximum Provider Limit** in Move validation:
```move
const MAX_OIDC_PROVIDERS: u64 = 10;

public fun new_v1(oidc_providers: vector<OIDCProvider>): JWKConsensusConfig {
    assert!(
        vector::length(&oidc_providers) <= MAX_OIDC_PROVIDERS,
        error::invalid_argument(ETOO_MANY_PROVIDERS)
    );
    // ... existing duplicate check ...
}
```

2. **Add HTTP Timeout** in `jwk-utils/src/lib.rs`:
```rust
pub async fn fetch_jwks_from_jwks_uri(...) -> Result<Vec<JWK>> {
    let client = reqwest::Client::builder()
        .timeout(Duration::from_secs(5))
        .build()?;
    // ... rest of implementation ...
}
```

3. **Make Fetch Interval Configurable** via on-chain config with minimum threshold:
```rust
// In OnChainJWKConsensusConfig
pub struct ConfigV1 {
    pub oidc_providers: Vec<OIDCProvider>,
    pub fetch_interval_secs: u64, // Minimum 10 seconds
}
```

## Proof of Concept

```move
#[test(framework = @0x1)]
fun test_resource_exhaustion_via_many_providers(framework: signer) {
    use aptos_framework::jwk_consensus_config;
    use std::vector;
    use std::string::utf8;
    
    // Create 200 OIDC providers pointing to slow servers
    let providers = vector::empty<jwk_consensus_config::OIDCProvider>();
    let i = 0;
    while (i < 200) {
        let name = utf8(b"https://malicious-");
        string::append(&mut name, utf8(to_string(i)));
        string::append(&mut name, utf8(b".com"));
        
        let config = utf8(b"https://malicious-");
        string::append(&mut config, utf8(to_string(i)));
        string::append(&mut config, utf8(b".com/.well-known/openid-configuration"));
        
        vector::push_back(&mut providers, 
            jwk_consensus_config::new_oidc_provider(name, config)
        );
        i = i + 1;
    };
    
    // This should fail with a limit check but currently succeeds
    let config = jwk_consensus_config::new_v1(providers);
    jwk_consensus_config::set_for_next_epoch(&framework, config);
    
    // After epoch change, all validators spawn 200 JWKObserver tasks
    // Each makes 2 HTTP requests every 10 seconds without timeout
    // Result: Resource exhaustion across validator set
}
```

**Notes:**
- The security question mentions "extremely short fetch intervals" but the interval is hardcoded to 10 seconds and cannot be controlled via governance
- The actual vulnerability is the unlimited number of providers combined with missing HTTP timeouts
- Even at 10-second intervals, 200+ providers cause significant resource consumption
- The attack vector is valid but the specific premise about configurable intervals is incorrect

### Citations

**File:** aptos-move/framework/aptos-framework/sources/configs/jwk_consensus_config.move (L90-102)
```text
    public fun new_v1(oidc_providers: vector<OIDCProvider>): JWKConsensusConfig {
        let name_set = simple_map::new<String, u64>();
        vector::for_each_ref(&oidc_providers, |provider| {
            let provider: &OIDCProvider = provider;
            let (_, old_value) = simple_map::upsert(&mut name_set, provider.name, 0);
            if (option::is_some(&old_value)) {
                abort(error::invalid_argument(EDUPLICATE_PROVIDERS))
            }
        });
        JWKConsensusConfig {
            variant: copyable_any::pack( ConfigV1 { oidc_providers } )
        }
    }
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager/mod.rs (L108-134)
```rust
        this.jwk_observers = oidc_providers
            .unwrap_or_default()
            .into_provider_vec()
            .into_iter()
            .filter_map(|provider| {
                let OIDCProvider { name, config_url } = provider;
                let maybe_issuer = String::from_utf8(name);
                let maybe_config_url = String::from_utf8(config_url);
                match (maybe_issuer, maybe_config_url) {
                    (Ok(issuer), Ok(config_url)) => Some(JWKObserver::spawn(
                        this.epoch_state.epoch,
                        this.my_addr,
                        issuer,
                        config_url,
                        Duration::from_secs(10),
                        local_observation_tx.clone(),
                    )),
                    (maybe_issuer, maybe_config_url) => {
                        warn!(
                            "unable to spawn observer, issuer={:?}, config_url={:?}",
                            maybe_issuer, maybe_config_url
                        );
                        None
                    },
                }
            })
            .collect();
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager_per_key.rs (L394-401)
```rust
                    (Ok(issuer), Ok(config_url)) => Some(JWKObserver::spawn(
                        this.epoch_state.epoch,
                        this.my_addr,
                        issuer,
                        config_url,
                        Duration::from_secs(10),
                        local_observation_tx.clone(),
                    )),
```

**File:** crates/jwk-utils/src/lib.rs (L25-37)
```rust
pub async fn fetch_jwks_from_jwks_uri(
    my_addr: Option<AccountAddress>,
    jwks_uri: &str,
) -> Result<Vec<JWK>> {
    let client = reqwest::Client::new();
    let mut request_builder = client.get(jwks_uri);
    if let Some(addr) = my_addr {
        request_builder = request_builder.header(COOKIE, addr.to_hex());
    }
    let JWKsResponse { keys } = request_builder.send().await?.json().await?;
    let jwks = keys.into_iter().map(JWK::from).collect();
    Ok(jwks)
}
```

**File:** crates/aptos-jwk-consensus/src/jwk_observer.rs (L102-109)
```rust
async fn fetch_jwks(open_id_config_url: &str, my_addr: Option<AccountAddress>) -> Result<Vec<JWK>> {
    let jwks_uri = fetch_jwks_uri_from_openid_config(open_id_config_url)
        .await
        .map_err(|e| anyhow!("fetch_jwks failed with open-id config request: {e}"))?;
    let jwks = fetch_jwks_from_jwks_uri(my_addr, jwks_uri.as_str())
        .await
        .map_err(|e| anyhow!("fetch_jwks failed with jwks uri request: {e}"))?;
    Ok(jwks)
```
