# Audit Report

## Title
Missing Explicit File-Level Lock in Database Bootstrap Tool Allows Concurrent Access on Non-Standard Filesystems

## Summary
The database bootstrap tool (`storage/db-tool/src/bootstrap.rs`) claims to open the database "exclusively" but relies solely on RocksDB's internal file locking mechanism without explicit verification or fallback. On filesystems that don't properly support file locking (certain NFS configurations, some container overlays), multiple bootstrap processes could run concurrently, causing database corruption.

## Finding Description

The bootstrap tool's `Command::run()` function contains a comment stating the database is opened exclusively: [1](#0-0) 

However, the code opens the database with `readonly: false` and uses `.expect()` to panic on failure: [2](#0-1) 

The database opening flow goes through `AptosDB::open()` → `open_internal()` → `open_dbs()`, which ultimately calls RocksDB's `DB::open_cf_descriptors()`: [3](#0-2) 

Notably, the SchemaDB layer includes a comment acknowledging single-process assumptions: [4](#0-3) 

While RocksDB version 0.24.0 [5](#0-4)  implements file-level locking via a LOCK file under normal circumstances, this mechanism can fail silently on:

1. **Network filesystems** (NFS with certain mount options)
2. **Container overlay filesystems** (some Docker/Kubernetes configurations)
3. **Cloud block storage** with improper locking semantics

Unlike the Move package cache, which implements explicit file locking using `fs2::FileExt::lock_exclusive()` [6](#0-5) , the bootstrap tool has no such defense-in-depth mechanism.

**Exploitation Path:**
1. Deploy validator with database on filesystem lacking proper file locking support
2. Operator accidentally runs two bootstrap processes concurrently (or automated tooling does)
3. Both processes successfully open the database (RocksDB's lock fails silently)
4. Concurrent writes to RocksDB SST files, WAL, and MANIFEST files cause corruption
5. Database becomes unreadable, violating the **State Consistency** invariant

This breaks the critical invariant: "State transitions must be atomic and verifiable via Merkle proofs" - a corrupted database cannot provide valid state proofs.

## Impact Explanation

**Medium Severity** - State inconsistencies requiring intervention

While database corruption is severe, this vulnerability requires:
- Non-standard filesystem configuration (lacking proper file locking)
- Operator error or automated tooling race condition
- Does not directly affect consensus (single validator impact)

However, if multiple validators experience this corruption during genesis bootstrap or disaster recovery, it could cause consensus divergence when they attempt to rejoin the network with corrupted state.

The impact includes:
- **Validator unavailability**: Corrupted database prevents node startup
- **State integrity violation**: Cannot verify Merkle proofs from corrupted DB
- **Recovery complexity**: Requires full database rebuild from network state sync

## Likelihood Explanation

**Low to Medium Likelihood:**

**Factors Increasing Likelihood:**
- Cloud-native deployments increasingly use network-attached storage
- Kubernetes StatefulSets with certain CSI drivers may have unreliable file locking
- Automated deployment scripts could trigger concurrent bootstrap in error scenarios
- Docker volume mounts can exhibit unexpected locking behavior

**Factors Decreasing Likelihood:**
- Most production validators use local SSDs with proper file locking
- RocksDB's locking works correctly on standard Linux filesystems (ext4, xfs)
- Bootstrap is typically run once during initial setup, not frequently
- The `.expect()` will cause panic if RocksDB returns an error

The vulnerability is most likely in:
- Disaster recovery scenarios with rushed operator actions
- Automated deployment pipelines with race conditions
- Development/staging environments with non-standard storage

## Recommendation

Implement explicit application-level file locking before opening the database, following the pattern used by the Move package cache:

```rust
// At the top of bootstrap.rs
use fs2::FileExt;
use std::fs::File;

// In Command::run(), before AptosDB::open():
let lock_path = self.db_dir.join(".bootstrap.lock");
let lock_file = File::create(&lock_path)
    .expect("Failed to create bootstrap lock file");
lock_file.lock_exclusive()
    .expect("Failed to acquire exclusive bootstrap lock - is another bootstrap process running?");

// ... existing AptosDB::open() code ...

// Lock is automatically released when lock_file is dropped at function end
```

This ensures exclusive access regardless of filesystem characteristics and provides a clear error message to operators about concurrent execution attempts.

**Additional Recommendations:**
1. Add validation to check if database is already open by another process before proceeding
2. Document filesystem requirements (must support POSIX file locking) in deployment guides
3. Consider adding a `--force` flag to override stale locks after confirming no other process is running

## Proof of Concept

```rust
// Test demonstrating concurrent corruption risk
// File: storage/db-tool/tests/concurrent_bootstrap_test.rs

use std::sync::Arc;
use std::thread;
use aptos_temppath::TempPath;
use aptos_config::config::{StorageDirPaths, RocksdbConfigs, NO_OP_STORAGE_PRUNER_CONFIG};
use aptos_db::AptosDB;

#[test]
#[ignore] // Only run on filesystems without proper locking
fn test_concurrent_bootstrap_corruption() {
    // This test would need to:
    // 1. Set up a database directory on a filesystem without file locking
    //    (e.g., NFS mount with nolock option)
    // 2. Spawn two threads that simultaneously call AptosDB::open()
    // 3. Demonstrate both threads successfully open the DB
    // 4. Perform conflicting writes
    // 5. Show resulting database corruption
    
    let tmpdir = TempPath::new();
    let db_path = StorageDirPaths::from_path(&tmpdir);
    
    let db_path1 = db_path.clone();
    let db_path2 = db_path.clone();
    
    let handle1 = thread::spawn(move || {
        AptosDB::open(
            db_path1,
            false,
            NO_OP_STORAGE_PRUNER_CONFIG,
            RocksdbConfigs::default(),
            false,
            1000,
            100,
            None,
            Default::default(),
        )
    });
    
    let handle2 = thread::spawn(move || {
        AptosDB::open(
            db_path2,
            false,
            NO_OP_STORAGE_PRUNER_CONFIG,
            RocksdbConfigs::default(),
            false,
            1000,
            100,
            None,
            Default::default(),
        )
    });
    
    // On properly configured filesystems, one of these should fail
    // On filesystems without locking, both may succeed → corruption risk
    let result1 = handle1.join().unwrap();
    let result2 = handle2.join().unwrap();
    
    // Expected: One succeeds, one fails with lock error
    // Actual (on broken FS): Both succeed → corruption
}
```

**Note:** A complete PoC would require setting up a test environment with a filesystem that doesn't support file locking (e.g., NFS with `nolock` mount option) or mocking the RocksDB lock acquisition to simulate failure.

### Citations

**File:** storage/db-tool/src/bootstrap.rs (L49-50)
```rust
        // Opening the DB exclusively, it's not allowed to run this tool alongside a running node which
        // operates on the same DB.
```

**File:** storage/db-tool/src/bootstrap.rs (L51-62)
```rust
        let db = AptosDB::open(
            StorageDirPaths::from_path(&self.db_dir),
            false,
            NO_OP_STORAGE_PRUNER_CONFIG, /* pruner */
            RocksdbConfigs::default(),
            false, /* indexer */
            BUFFERED_STATE_TARGET_ITEMS,
            DEFAULT_MAX_NUM_NODES_PER_LRU_CACHE_SHARD,
            None,
            HotStateConfig::default(),
        )
        .expect("Failed to open DB.");
```

**File:** storage/schemadb/src/lib.rs (L90-91)
```rust
    /// Note that this still assumes there's only one process that opens the same DB.
    /// See `open_as_secondary`
```

**File:** storage/schemadb/src/lib.rs (L172-173)
```rust
            match open_mode {
                ReadWrite => DB::open_cf_descriptors(db_opts, path.de_unc(), all_cfds),
```

**File:** Cargo.toml (L773-773)
```text
rocksdb = { version = "0.24.0", features = ["lz4"] }
```

**File:** third_party/move/tools/move-package-cache/src/file_lock.rs (L44-45)
```rust
                let lock_file = File::create(&lock_path)?;
                lock_file.lock_exclusive()?;
```
