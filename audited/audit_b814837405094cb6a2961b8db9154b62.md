# Audit Report

## Title
Duplicate Transaction IO Gas Charging in Error Path for New Account Transactions

## Summary
The `charge_io_gas_for_transaction()` function can be called multiple times for the same transaction when a transaction successfully executes but fails during the gas charging phase. This occurs specifically for new account transactions (sequence number 0) with lazy account creation enabled, resulting in users being overcharged for transaction IO gas and causing legitimate transactions to fail due to insufficient gas for the duplicate charge.

## Finding Description

The vulnerability exists in the transaction execution flow where gas charging occurs in two separate code paths without deduplication protection.

**Normal Success Path:** [1](#0-0) 

The `charge_change_set_and_respawn_session` function calls `charge_change_set`, which charges transaction IO gas: [2](#0-1) 

**Error Recovery Path:**
When `charge_change_set` fails partway through (after successfully charging transaction IO gas at line 1120, but failing on subsequent event/write charges at lines 1121-1126), the error propagates to `failed_transaction_cleanup`: [3](#0-2) 

For new accounts with lazy account creation enabled, `finish_aborted_transaction` is called, which creates an abort hook session and charges its change set: [4](#0-3) 

At line 743, `charge_change_set` is called again with the same `txn_data`, causing `charge_io_gas_for_transaction` to be invoked a second time at line 1120 with the identical `txn_data.transaction_size()`.

**Root Cause:**
The transaction IO gas is calculated based on transaction size, which remains constant regardless of which change set is being processed. The `charge_io` implementation provides no idempotency protection: [5](#0-4) 

Each call to `charge_io` deducts from the balance and increments `io_gas_used` without checking if the same transaction has already been charged.

**Affected Scenario:**
This affects transactions where:
1. The account has sequence number 0 (first transaction)
2. The account resource doesn't exist yet (new account)
3. DEFAULT_ACCOUNT_RESOURCE or SPONSORED_AUTOMATIC_ACCOUNT_V1_CREATION feature is enabled
4. Transaction execution succeeds, but gas runs out during the charging phase after transaction IO gas is charged [6](#0-5) 

## Impact Explanation

**Severity: Medium** per Aptos bug bounty criteria for "Limited funds loss or manipulation."

**Impact Details:**
1. **Overcharging Users**: Users pay twice the correct amount for transaction IO gas, resulting in direct financial loss
2. **Transaction Failures**: Transactions with sufficient gas for single charging but insufficient for double charging will fail with OUT_OF_GAS errors, even though they should succeed
3. **Deterministic Execution Violation**: Different validators may process identical transactions differently depending on slight timing variations in gas meter state, potentially breaking consensus invariant #1 (Deterministic Execution)
4. **Resource Limits Violation**: Violates invariant #9 that "All operations must respect gas, storage, and computational limits" by charging more than the specified gas parameters

**Quantified Harm:**
- Affects all new account creation transactions on mainnet
- Transaction IO gas is typically charged based on transaction size (e.g., 20 gas units per byte)
- For a 1KB transaction: ~20,000 gas units overcharged = ~0.02 APT overcharged per transaction (at 1 gas unit = 100 Octa = 0.000001 APT)
- With thousands of new accounts daily, this compounds to significant overcharging

## Likelihood Explanation

**Likelihood: Medium-High**

The vulnerability triggers under specific but common conditions:

1. **Frequency**: Every first transaction for new accounts is potentially affected (high frequency on production networks)
2. **Triggering Condition**: Requires the transaction to run out of gas during the charging phase, which is somewhat unusual but can be engineered by an attacker crafting transactions with:
   - Minimal gas allocation
   - Operations that generate many events/writes to consume gas during charging
   - Precisely calculated gas to exhaust between lines 1120-1126 of `charge_change_set`
3. **Feature Dependencies**: Requires DEFAULT_ACCOUNT_RESOURCE or SPONSORED_AUTOMATIC_ACCOUNT_V1_CREATION features enabled (typically enabled on mainnet)
4. **Attack Complexity**: Low - any user can submit transactions; no special privileges required

**Exploitation Scenario:**
An attacker could deliberately craft transactions for new accounts that:
- Include operations generating multiple events/state writes
- Set gas limits precisely to exhaust gas during event/write charging
- Trigger the double-charge condition repeatedly to maximize overcharging impact

## Recommendation

Implement a tracking mechanism to ensure `charge_io_gas_for_transaction` is only called once per transaction execution, regardless of error paths.

**Recommended Fix:**

Add a boolean flag to track whether transaction IO gas has been charged:

```rust
// In TransactionMetadata or gas meter state
struct GasChargingState {
    transaction_io_charged: bool,
}

fn charge_change_set(
    &self,
    change_set: &mut impl ChangeSetInterface,
    gas_meter: &mut impl AptosGasMeter,
    txn_data: &TransactionMetadata,
    resolver: &impl AptosMoveResolver,
    module_storage: &impl AptosModuleStorage,
    charging_state: &mut GasChargingState, // NEW PARAMETER
) -> Result<GasQuantity<Octa>, VMStatus> {
    // Only charge transaction IO gas if not already charged
    if !charging_state.transaction_io_charged {
        gas_meter.charge_io_gas_for_transaction(txn_data.transaction_size())?;
        charging_state.transaction_io_charged = true;
    }
    
    for event in change_set.events_iter() {
        gas_meter.charge_io_gas_for_event(event)?;
    }
    for (key, op_size) in change_set.write_set_size_iter() {
        gas_meter.charge_io_gas_for_write(key, &op_size)?;
    }
    // ... rest of function
}
```

**Alternative Simpler Fix:**

Move the transaction IO gas charging to occur once before any `charge_change_set` calls, in the main execution path before branching:

```rust
// In execute_script_or_entry_function or execute_multisig_transaction
// Charge transaction IO gas once at the beginning
gas_meter.charge_io_gas_for_transaction(txn_data.transaction_size())?;

// Then call charge_change_set without charging transaction IO
fn charge_change_set(
    &self,
    change_set: &mut impl ChangeSetInterface,
    gas_meter: &mut impl AptosGasMeter,
    txn_data: &TransactionMetadata,
    resolver: &impl AptosMoveResolver,
    module_storage: &impl AptosModuleStorage,
) -> Result<GasQuantity<Octa>, VMStatus> {
    // Remove line 1120: gas_meter.charge_io_gas_for_transaction(txn_data.transaction_size())?;
    
    for event in change_set.events_iter() {
        gas_meter.charge_io_gas_for_event(event)?;
    }
    // ... rest unchanged
}
```

## Proof of Concept

```rust
#[test]
fn test_duplicate_transaction_io_gas_charging() {
    use aptos_types::{
        account_address::AccountAddress,
        transaction::{SignedTransaction, TransactionPayload, Script},
    };
    use aptos_vm::AptosVM;
    
    // Setup: Create a new account transaction (sequence number 0)
    let sender = AccountAddress::random();
    let mut vm = AptosVM::new(/* ... */);
    
    // Create a transaction with:
    // 1. Minimal gas allocation
    // 2. Operations that will generate events/writes
    // 3. Precisely calculated to run out of gas during charging phase
    let gas_limit = calculate_precise_gas_for_double_charge_trigger();
    let txn = create_new_account_transaction(sender, gas_limit);
    
    // Execute transaction
    let (vm_status, vm_output) = vm.execute_user_transaction(/* ... */);
    
    // Verify:
    // 1. Transaction failed with OUT_OF_GAS during charging phase
    assert!(matches!(vm_status, VMStatus::Error { status_code: StatusCode::OUT_OF_GAS, .. }));
    
    // 2. Check gas_meter.io_gas_used() shows double charging
    // Expected: transaction_io_gas
    // Actual: 2 * transaction_io_gas
    let actual_io_gas = vm_output.gas_used();
    let expected_io_gas = calculate_single_transaction_io_gas(txn.raw_txn_bytes_len());
    assert!(actual_io_gas > expected_io_gas, 
        "Double charging detected: actual {} > expected {}", 
        actual_io_gas, expected_io_gas);
}

fn calculate_precise_gas_for_double_charge_trigger() -> u64 {
    // Calculate gas that will:
    // 1. Successfully charge transaction IO gas (first call)
    // 2. Successfully charge some events/writes
    // 3. Run out during event/write charging (before storage fees)
    // 4. Trigger error path and second charge_change_set call
    // 5. Fail on second transaction IO gas charge
    
    let intrinsic_gas = 500; // BASE
    let transaction_io_gas = 2000; // For 100 byte transaction
    let event_gas = 1500; // Some events
    
    // Set limit to barely cover first charge but not second
    intrinsic_gas + transaction_io_gas + event_gas // Will fail on second txn IO charge
}
```

**Steps to Reproduce:**
1. Deploy Aptos testnet with DEFAULT_ACCOUNT_RESOURCE feature enabled
2. Create a new account (sequence number 0)
3. Submit a transaction with gas limit calculated to exhaust during charging phase
4. Monitor gas meter state during execution
5. Observe OUT_OF_GAS error with io_gas_used showing double the expected transaction IO gas charge

### Citations

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L561-624)
```rust
    pub(crate) fn failed_transaction_cleanup(
        &self,
        prologue_session_change_set: SystemSessionChangeSet,
        error_vm_status: VMStatus,
        gas_meter: &mut impl AptosGasMeter,
        txn_data: &TransactionMetadata,
        resolver: &impl AptosMoveResolver,
        module_storage: &impl AptosModuleStorage,
        serialized_signers: &SerializedSigners,
        log_context: &AdapterLogSchema,
        change_set_configs: &ChangeSetConfigs,
        traversal_context: &mut TraversalContext,
    ) -> (VMStatus, VMOutput) {
        if self.gas_feature_version() >= 12 {
            // Check if the gas meter's internal counters are consistent.
            //
            // Since we are already in the failure epilogue, there is not much we can do
            // other than logging the inconsistency.
            //
            // This is a tradeoff. We have to either
            //   1. Continue to calculate the gas cost based on the numbers we have.
            //   2. Discard the transaction.
            //
            // Option (2) does not work, since it would enable DoS attacks.
            // Option (1) is not ideal, but optimistically, it should allow the network
            // to continue functioning, less the transactions that run into this problem.
            if let Err(err) = gas_meter.algebra().check_consistency() {
                println!(
                    "[aptos-vm][gas-meter][failure-epilogue] {}",
                    err.message()
                        .unwrap_or("No message found -- this should not happen.")
                );
            }
        }

        let txn_status = TransactionStatus::from_vm_status(
            error_vm_status.clone(),
            self.features(),
            self.gas_feature_version() >= RELEASE_V1_38,
        );

        match txn_status {
            TransactionStatus::Keep(status) => {
                // The transaction should be kept. Run the appropriate post transaction workflows
                // including epilogue. This runs a new session that ignores any side effects that
                // might abort the execution (e.g., spending additional funds needed to pay for
                // gas). Even if the previous failure occurred while running the epilogue, it
                // should not fail now. If it somehow fails here, there is no choice but to
                // discard the transaction.
                let output = self
                    .finish_aborted_transaction(
                        prologue_session_change_set,
                        gas_meter,
                        txn_data,
                        resolver,
                        module_storage,
                        serialized_signers,
                        status,
                        log_context,
                        change_set_configs,
                        traversal_context,
                    )
                    .unwrap_or_else(|status| discarded_output(status.status_code()));
                (error_vm_status, output)
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L689-754)
```rust
    fn finish_aborted_transaction(
        &self,
        prologue_session_change_set: SystemSessionChangeSet,
        gas_meter: &mut impl AptosGasMeter,
        txn_data: &TransactionMetadata,
        resolver: &impl AptosMoveResolver,
        module_storage: &impl AptosModuleStorage,
        serialized_signers: &SerializedSigners,
        status: ExecutionStatus,
        log_context: &AdapterLogSchema,
        change_set_configs: &ChangeSetConfigs,
        traversal_context: &mut TraversalContext,
    ) -> Result<VMOutput, VMStatus> {
        // Storage refund is zero since no slots are deleted in aborted transactions.
        const ZERO_STORAGE_REFUND: u64 = 0;

        let should_create_account_resource =
            should_create_account_resource(txn_data, self.features(), resolver, module_storage)?;

        let (previous_session_change_set, fee_statement) = if should_create_account_resource {
            let mut abort_hook_session =
                AbortHookSession::new(self, txn_data, resolver, prologue_session_change_set);

            abort_hook_session.execute(|session| {
                create_account_if_does_not_exist(
                    session,
                    module_storage,
                    gas_meter,
                    txn_data.sender(),
                    traversal_context,
                )
                // If this fails, it is likely due to out of gas, so we try again without metering
                // and then validate below that we charged sufficiently.
                .or_else(|_err| {
                    create_account_if_does_not_exist(
                        session,
                        module_storage,
                        &mut UnmeteredGasMeter,
                        txn_data.sender(),
                        traversal_context,
                    )
                })
                .map_err(expect_no_verification_errors)
                .or_else(|err| {
                    expect_only_successful_execution(
                        err,
                        &format!("{:?}::{}", ACCOUNT_MODULE, CREATE_ACCOUNT_IF_DOES_NOT_EXIST),
                        log_context,
                    )
                })
            })?;

            let mut abort_hook_session_change_set =
                abort_hook_session.finish(change_set_configs, module_storage)?;
            if let Err(err) = self.charge_change_set(
                &mut abort_hook_session_change_set,
                gas_meter,
                txn_data,
                resolver,
                module_storage,
            ) {
                info!(
                    *log_context,
                    "Failed during charge_change_set: {:?}. Most likely exceeded gas limited.", err,
                );
            };
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1112-1127)
```rust
    fn charge_change_set(
        &self,
        change_set: &mut impl ChangeSetInterface,
        gas_meter: &mut impl AptosGasMeter,
        txn_data: &TransactionMetadata,
        resolver: &impl AptosMoveResolver,
        module_storage: &impl AptosModuleStorage,
    ) -> Result<GasQuantity<Octa>, VMStatus> {
        gas_meter.charge_io_gas_for_transaction(txn_data.transaction_size())?;
        for event in change_set.events_iter() {
            gas_meter.charge_io_gas_for_event(event)?;
        }
        for (key, op_size) in change_set.write_set_size_iter() {
            gas_meter.charge_io_gas_for_write(key, &op_size)?;
        }

```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1142-1156)
```rust
    fn charge_change_set_and_respawn_session<'r>(
        &self,
        mut user_session_change_set: UserSessionChangeSet,
        resolver: &'r impl AptosMoveResolver,
        module_storage: &impl AptosModuleStorage,
        gas_meter: &mut impl AptosGasMeter,
        txn_data: &TransactionMetadata,
    ) -> Result<EpilogueSession<'r>, VMStatus> {
        let storage_refund = self.charge_change_set(
            &mut user_session_change_set,
            gas_meter,
            txn_data,
            resolver,
            module_storage,
        )?;
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L3451-3483)
```rust
pub(crate) fn should_create_account_resource(
    txn_data: &TransactionMetadata,
    features: &Features,
    resolver: &impl AptosMoveResolver,
    module_storage: &impl ModuleStorage,
) -> VMResult<bool> {
    if (features.is_enabled(FeatureFlag::DEFAULT_ACCOUNT_RESOURCE)
        || (features.is_enabled(FeatureFlag::SPONSORED_AUTOMATIC_ACCOUNT_V1_CREATION)
            && txn_data.fee_payer.is_some()))
        && txn_data.replay_protector == ReplayProtector::SequenceNumber(0)
    {
        let account_tag = AccountResource::struct_tag();

        // INVARIANT:
        //   Account lives at a special address, so we should not be charging for it and unmetered
        //   access is safe. There are tests that ensure that address is always special.
        assert!(account_tag.address.is_special());
        let module = module_storage.unmetered_get_existing_deserialized_module(
            &account_tag.address,
            &account_tag.module,
        )?;

        let (maybe_bytes, _) = resolver
            .get_resource_bytes_with_metadata_and_layout(
                &txn_data.sender(),
                &account_tag,
                &module.metadata,
                None,
            )
            .map_err(|e| e.finish(Location::Undefined))?;
        return Ok(maybe_bytes.is_none());
    }
    Ok(false)
```

**File:** aptos-move/aptos-gas-meter/src/algebra.rs (L211-236)
```rust
    fn charge_io(
        &mut self,
        abstract_amount: impl GasExpression<VMGasParameters, Unit = InternalGasUnit>,
    ) -> PartialVMResult<()> {
        let amount = abstract_amount.evaluate(self.feature_version, &self.vm_gas_params);

        match self.balance.checked_sub(amount) {
            Some(new_balance) => {
                self.balance = new_balance;
                self.io_gas_used += amount;
            },
            None => {
                let old_balance = self.balance;
                self.balance = 0.into();
                if self.feature_version >= 12 {
                    self.io_gas_used += old_balance;
                }
                return Err(PartialVMError::new(StatusCode::OUT_OF_GAS));
            },
        };

        if self.feature_version >= 7 && self.io_gas_used > self.max_io_gas {
            Err(PartialVMError::new(StatusCode::IO_LIMIT_REACHED))
        } else {
            Ok(())
        }
```
