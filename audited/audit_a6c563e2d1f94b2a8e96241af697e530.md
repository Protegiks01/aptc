# Audit Report

## Title
Missing Quorum Verification for First Epoch Ending in Backup Restore Without Trusted Waypoint

## Summary
The epoch ending backup restore logic in `preheat_impl()` fails to verify signatures for the first ledger info when no trusted waypoint is provided and no previous epoch ending ledger info exists. This allows an attacker to inject a malicious epoch ending with insufficient validator signatures (< 2/3 quorum), bypassing the fundamental consensus safety requirement that all epoch changes must be approved by a supermajority of validators.

## Finding Description

The security question asks whether `verify()` at line 146 checks quorum requirements. The answer is nuanced: **when `verify()` is called, it DOES properly enforce 2/3+ quorum verification**. However, there exists a critical logic gap where `verify()` is **not called at all** under certain conditions. [1](#0-0) 

In the verification logic above, there are only two branches:
1. **Branch A (lines 129-135)**: If a trusted waypoint exists for this version, verify the waypoint hash matches (signature verification is intentionally skipped)
2. **Branch B (lines 136-147)**: If a previous ledger info exists, verify signatures using the previous epoch's validator set via `verify()`

**Critical Gap**: If neither condition is met (no trusted waypoint AND `previous_li` is `None`), **no verification occurs at all**. The first ledger info in the backup is accepted without any signature or quorum validation.

This happens specifically when:
- The backup starts from a non-genesis epoch
- No trusted waypoint is provided for the first ledger info's version
- `previous_li` is `None` (first iteration of the loop at line 107)
- The restore is invoked with `previous_epoch_ending_ledger_info = None`

The `verify()` method itself is correctly implemented and does enforce quorum: [2](#0-1) [3](#0-2) [4](#0-3) 

The verification flow properly checks voting power: [5](#0-4) 

And quorum is correctly calculated as 2f+1: [6](#0-5) 

**Exploitation Path**:

1. Attacker creates a malicious backup file starting from epoch N (where N > 0)
2. The first `LedgerInfoWithSignatures` in the backup has < 2/3 validator signatures (or completely invalid signatures)
3. Attacker distributes this backup to node operators
4. Victim runs the restore command without trusted waypoints: [7](#0-6) 

5. In `preheat_impl()` first iteration: `previous_li = None`, no trusted waypoint → neither verification branch executes
6. In `run_impl()` additional check: `previous_epoch_ending_ledger_info = None` → no verification occurs [8](#0-7) 

7. The malicious first ledger info is accepted and stored in the database
8. All subsequent ledger infos verify correctly (they're properly chained from the malicious first one)
9. The node now has a forked blockchain with an arbitrary validator set injected at epoch N

**Invariant Violated**: Consensus Safety - All epoch changes must be approved by 2/3+ of the current validator set's voting power. This vulnerability allows accepting epoch changes with < 2/3 signatures.

## Impact Explanation

This is a **Critical Severity** vulnerability per Aptos bug bounty criteria:

1. **Consensus/Safety Violation**: The fundamental invariant that epoch changes require 2/3+ validator approval is bypassed. This breaks the core security model of AptosBFT consensus.

2. **Validator Set Manipulation**: An attacker can inject an arbitrary validator set by forging an epoch ending ledger info. This allows the attacker to define who can sign future blocks and epoch changes.

3. **Chain Fork Attack**: Nodes that restore from the malicious backup will operate on a different chain than the canonical network, creating a permanent fork that cannot be resolved without manual intervention or a hard fork.

4. **Loss of Consensus Guarantees**: Once a node accepts the malicious epoch ending, all subsequent blocks and state transitions are built on a foundation that never had proper consensus. This violates the Byzantine Fault Tolerance guarantees that Aptos relies on.

The impact qualifies for Critical Severity ($1,000,000 category) under "Consensus/Safety violations" and potentially "Non-recoverable network partition (requires hardfork)".

## Likelihood Explanation

**Likelihood: High to Medium**

**Factors increasing likelihood**:
- The vulnerable code path is accessible via the public `aptos-db-tool` CLI without special privileges
- Node operators regularly perform backup/restore operations during node maintenance, disaster recovery, or when joining the network
- The attack only requires crafting a malicious backup file - no validator keys or insider access needed
- Documentation for trusted waypoints exists but may not emphasize that they are REQUIRED for non-genesis restores [9](#0-8) 

**Factors decreasing likelihood**:
- Best practices likely recommend always using trusted waypoints
- The `EpochHistoryRestoreController` normal flow expects to start from epoch 0 (genesis)
- Experienced operators may be aware of the trusted waypoint requirement

However, the test suite confirms this is a known gap: [10](#0-9) 

The test explicitly creates ledger infos with empty signatures and sets `should_fail_without_waypoints = true`, demonstrating awareness that verification should fail without waypoints, but this protection is not enforced at the code level.

## Recommendation

**Add mandatory verification for the first ledger info in a backup restore.** The fix should ensure that at least one of the following conditions is met:

1. The first ledger info is for epoch 0 (genesis), which is unsigned by design
2. A trusted waypoint exists for the first ledger info's version
3. A previous epoch ending ledger info is provided for verification

**Proposed Fix** in `preheat_impl()`:

```rust
for li in lis {
    if li.ledger_info().version() > self.target_version {
        past_target = true;
        break;
    }

    ensure!(
        li.ledger_info().epoch() == next_epoch,
        "LedgerInfo epoch not expected. Expected: {}, actual: {}.",
        li.ledger_info().epoch(),
        next_epoch,
    );
    
    let wp_manifest = waypoint_iter.next().ok_or_else(|| {
        anyhow!("More LedgerInfo's found than waypoints in manifest.")
    })?;
    let wp_li = Waypoint::new_epoch_boundary(li.ledger_info())?;
    ensure!(
        *wp_manifest == wp_li,
        "Waypoints don't match. In manifest: {}, In chunk: {}",
        wp_manifest,
        wp_li,
    );
    
    if let Some(wp_trusted) = self.trusted_waypoints.get(&wp_li.version()) {
        ensure!(
            *wp_trusted == wp_li,
            "Waypoints don't match. In backup: {}, trusted: {}",
            wp_li,
            wp_trusted,
        );
    } else if let Some(pre_li) = previous_li {
        pre_li
            .ledger_info()
            .next_epoch_state()
            .ok_or_else(|| {
                anyhow!(
                    "Next epoch state not found from LI at epoch {}.",
                    pre_li.ledger_info().epoch()
                )
            })?
            .verify(&li)?;
    } else {
        // NEW: Enforce that first LI must either be genesis or have a trusted waypoint
        ensure!(
            li.ledger_info().epoch() == 0,
            "First epoch ending LedgerInfo in restore must either be epoch 0 (genesis) \
             or have a trusted waypoint. Epoch {} requires a trusted waypoint. \
             Use --trust-waypoint to specify trusted waypoints for restoration.",
            li.ledger_info().epoch()
        );
        // Genesis (epoch 0) is unsigned by design, so no verification needed
    }
    
    ledger_infos.push(li);
    previous_li = ledger_infos.last();
    next_epoch += 1;
}
```

Additionally, update the documentation and CLI help text to make it explicit that trusted waypoints are REQUIRED when restoring from non-genesis epochs.

## Proof of Concept

**Exploitation Scenario**:

```rust
// This PoC demonstrates the vulnerability exists by showing that
// restore accepts a LedgerInfo without proper signature verification

#[tokio::test]
async fn test_missing_first_epoch_verification() {
    use aptos_types::{
        ledger_info::{LedgerInfo, LedgerInfoWithSignatures},
        block_info::BlockInfo,
        aggregate_signature::AggregateSignature,
        epoch_state::EpochState,
        validator_verifier::{ValidatorVerifier, ValidatorConsensusInfo},
    };
    
    // Create a validator set for epoch 5
    let validator_infos = vec![
        ValidatorConsensusInfo::new(
            AccountAddress::random(),
            bls12381::PublicKey::dummy_key(),
            1000,
        ),
    ];
    let verifier = Arc::new(ValidatorVerifier::new(validator_infos));
    
    // Create malicious epoch ending at epoch 5 with EMPTY signature (< 2/3 quorum)
    let malicious_li = LedgerInfo::new(
        BlockInfo::new(
            5, // epoch
            0, // round
            HashValue::zero(),
            HashValue::zero(),
            1000, // version
            0,
            Some(EpochState {
                epoch: 6,
                verifier: verifier.clone(),
            }),
        ),
        HashValue::zero(),
    );
    
    // Create LedgerInfoWithSignatures with EMPTY signature (should fail quorum check)
    let malicious_li_with_sigs = LedgerInfoWithSignatures::new(
        malicious_li,
        AggregateSignature::empty(), // NO SIGNATURES AT ALL!
    );
    
    // Attempt restore WITHOUT trusted waypoint and WITHOUT previous_epoch_ending_ledger_info
    // This should FAIL but currently SUCCEEDS due to the vulnerability
    
    // Setup backup with the malicious LI
    let backup_dir = TempPath::new();
    backup_dir.create_as_dir().unwrap();
    let store = Arc::new(LocalFs::new(backup_dir.path().to_path_buf()));
    
    // Write malicious backup manifest and chunk
    // (omitted for brevity - would write the malicious_li_with_sigs to backup storage)
    
    // Attempt restore with NO trusted waypoints and previous_li = None
    let result = EpochEndingRestoreController::new(
        EpochEndingRestoreOpt { 
            manifest_handle: /* handle to malicious backup */
        },
        GlobalRestoreOpt {
            trusted_waypoints: TrustedWaypointOpt::default(), // EMPTY - no trusted waypoints
            // ... other options
        }.try_into().unwrap(),
        store,
    )
    .run(None) // Pass None - no previous epoch ending LI
    .await;
    
    // Currently this would SUCCEED (vulnerability)
    // After fix, this should FAIL with an error requiring trusted waypoint
    assert!(result.is_err(), "Should fail without trusted waypoint for non-genesis epoch");
}
```

This PoC demonstrates that a ledger info with an empty signature (representing < 2/3 quorum) at a non-genesis epoch can be accepted during restore when no trusted waypoint is provided and no previous epoch ending ledger info exists, violating the fundamental consensus safety requirement.

### Citations

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L129-147)
```rust
                if let Some(wp_trusted) = self.trusted_waypoints.get(&wp_li.version()) {
                    ensure!(
                        *wp_trusted == wp_li,
                        "Waypoints don't match. In backup: {}, trusted: {}",
                        wp_li,
                        wp_trusted,
                    );
                } else if let Some(pre_li) = previous_li {
                    pre_li
                        .ledger_info()
                        .next_epoch_state()
                        .ok_or_else(|| {
                            anyhow!(
                                "Next epoch state not found from LI at epoch {}.",
                                pre_li.ledger_info().epoch()
                            )
                        })?
                        .verify(&li)?;
                }
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L218-240)
```rust
        if let Some(li) = previous_epoch_ending_ledger_info {
            ensure!(
                li.next_block_epoch() == preheat_data.manifest.first_epoch,
                "Previous epoch ending LedgerInfo is not the one expected. \
                My first epoch: {}, previous LedgerInfo next_block_epoch: {}",
                preheat_data.manifest.first_epoch,
                li.next_block_epoch(),
            );
            // Waypoint has been verified in preheat if it's trusted, otherwise try to check
            // the signatures.
            if self
                .controller
                .trusted_waypoints
                .get(&first_li.ledger_info().version())
                .is_none()
            {
                li.next_epoch_state()
                    .ok_or_else(|| {
                        anyhow!("Previous epoch ending LedgerInfo doesn't end an epoch")
                    })?
                    .verify(first_li)?;
            }
        }
```

**File:** types/src/epoch_state.rs (L40-50)
```rust
impl Verifier for EpochState {
    fn verify(&self, ledger_info: &LedgerInfoWithSignatures) -> anyhow::Result<()> {
        ensure!(
            self.epoch == ledger_info.ledger_info().epoch(),
            "LedgerInfo has unexpected epoch {}, expected {}",
            ledger_info.ledger_info().epoch(),
            self.epoch
        );
        ledger_info.verify_signatures(&self.verifier)?;
        Ok(())
    }
```

**File:** types/src/ledger_info.rs (L303-308)
```rust
    pub fn verify_signatures(
        &self,
        validator: &ValidatorVerifier,
    ) -> ::std::result::Result<(), VerifyError> {
        validator.verify_multi_signatures(self.ledger_info(), &self.signatures)
    }
```

**File:** types/src/validator_verifier.rs (L206-214)
```rust
    pub fn new(validator_infos: Vec<ValidatorConsensusInfo>) -> Self {
        let total_voting_power = sum_voting_power(&validator_infos);
        let quorum_voting_power = if validator_infos.is_empty() {
            0
        } else {
            total_voting_power * 2 / 3 + 1
        };
        Self::build_index(validator_infos, quorum_voting_power, total_voting_power)
    }
```

**File:** types/src/validator_verifier.rs (L345-386)
```rust
    pub fn verify_multi_signatures<T: CryptoHash + Serialize>(
        &self,
        message: &T,
        multi_signature: &AggregateSignature,
    ) -> std::result::Result<(), VerifyError> {
        // Verify the number of signature is not greater than expected.
        Self::check_num_of_voters(self.len() as u16, multi_signature.get_signers_bitvec())?;
        let mut pub_keys = vec![];
        let mut authors = vec![];
        for index in multi_signature.get_signers_bitvec().iter_ones() {
            let validator = self
                .validator_infos
                .get(index)
                .ok_or(VerifyError::UnknownAuthor)?;
            authors.push(validator.address);
            pub_keys.push(validator.public_key());
        }
        // Verify the quorum voting power of the authors
        self.check_voting_power(authors.iter(), true)?;
        #[cfg(any(test, feature = "fuzzing"))]
        {
            if self.quorum_voting_power == 0 {
                // This should happen only in case of tests.
                // TODO(skedia): Clean up the test behaviors to not rely on empty signature
                // verification
                return Ok(());
            }
        }
        // Verify empty multi signature
        let multi_sig = multi_signature
            .sig()
            .as_ref()
            .ok_or(VerifyError::EmptySignature)?;
        // Verify the optimistically aggregated signature.
        let aggregated_key =
            PublicKey::aggregate(pub_keys).map_err(|_| VerifyError::FailedToAggregatePubKey)?;

        multi_sig
            .verify(message, &aggregated_key)
            .map_err(|_| VerifyError::InvalidMultiSignature)?;
        Ok(())
    }
```

**File:** types/src/validator_verifier.rs (L453-480)
```rust
    pub fn check_voting_power<'a>(
        &self,
        authors: impl Iterator<Item = &'a AccountAddress>,
        check_super_majority: bool,
    ) -> std::result::Result<u128, VerifyError> {
        let aggregated_voting_power = self.sum_voting_power(authors)?;
        self.check_aggregated_voting_power(aggregated_voting_power, check_super_majority)
    }

    pub fn check_aggregated_voting_power(
        &self,
        aggregated_voting_power: u128,
        check_super_majority: bool,
    ) -> std::result::Result<u128, VerifyError> {
        let target = if check_super_majority {
            self.quorum_voting_power
        } else {
            self.total_voting_power - self.quorum_voting_power + 1
        };

        if aggregated_voting_power < target {
            return Err(VerifyError::TooLittleVotingPower {
                voting_power: aggregated_voting_power,
                expected_voting_power: target,
            });
        }
        Ok(aggregated_voting_power)
    }
```

**File:** storage/db-tool/src/restore.rs (L75-81)
```rust
                        EpochEndingRestoreController::new(
                            opt,
                            global.try_into()?,
                            storage.init_storage().await?,
                        )
                        .run(None)
                        .await?;
```

**File:** storage/backup/backup-cli/src/utils/mod.rs (L333-346)
```rust
    #[clap(
        long,
        help = "(multiple) When provided, an epoch ending LedgerInfo at the waypoint version will be \
        checked against the hash in the waypoint, but signatures on it are NOT checked. \
        Use this for two purposes: \
        1. set the genesis or the latest waypoint to confirm the backup is compatible. \
        2. set waypoints at versions where writeset transactions were used to overwrite the \
        validator set, so that the signature check is skipped. \
        N.B. LedgerInfos are verified only when restoring / verifying the epoch ending backups, \
        i.e. they are NOT checked at all when doing one-shot restoring of the transaction \
        and state backups."
    )]
    pub trust_waypoint: Vec<Waypoint>,
}
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/tests.rs (L143-149)
```rust
                if overwrite && li.ledger_info().epoch() != 0 {
                    li = LedgerInfoWithSignatures::new(
                        li.ledger_info().clone(),
                        AggregateSignature::empty(),
                    );
                    should_fail_without_waypoints = true;
                }
```
