# Audit Report

## Title
Composite Key Collision in Token V2 Fungible Asset Indexer Causing Ownership Data Corruption

## Summary
The indexer's `insert_current_token_ownerships_v2()` function incorrectly constructs the composite primary key for fungible token v2 (FT v2) ownerships. Multiple `FungibleAssetStore` objects owned by the same user for the same fungible asset will generate identical primary keys, causing database overwrites and loss of balance tracking data. [1](#0-0) 

## Finding Description
The vulnerability exists in the `get_ft_v2_from_write_resource()` function which extracts fungible token v2 ownership data from blockchain write resources. The function incorrectly sets `storage_id` to the fungible asset metadata address instead of the actual `FungibleAssetStore` object's address. [2](#0-1) 

**The Problem:**

For FT v2, the composite key becomes: `(metadata_address, 0, owner_address, metadata_address)`

This simplifies to effectively: `(metadata_address, owner_address)` with two duplicate fields.

**Attack Scenario:**

1. User creates a primary `FungibleAssetStore` at address `store_A` for fungible asset with metadata at `FA_metadata`
2. User creates a secondary `FungibleAssetStore` at address `store_B` for the same fungible asset [3](#0-2) 

Both stores generate identical indexer keys:
- Store A: `(FA_metadata, 0, user_addr, FA_metadata)` with balance = 1000
- Store B: `(FA_metadata, 0, user_addr, FA_metadata)` with balance = 500

When the indexer processes these in the same transaction batch or across batches, the database's ON CONFLICT clause overwrites the first record with the second: [4](#0-3) 

The database schema confirms this 4-part primary key: [5](#0-4) 

**Why Multiple Stores Exist:**

The Aptos fungible asset framework explicitly supports both primary stores (deterministic addresses) and arbitrary secondary stores. Users can create multiple stores via `fungible_asset::create_store()`: [6](#0-5) 

**The Correct Implementation:**

The `storage_id` should be set to `resource.address` (the store's address), which is available at line 381: [7](#0-6) 

## Impact Explanation

**Severity: Medium** (State inconsistencies requiring intervention)

This vulnerability causes:

1. **Data Integrity Violation**: The indexer database contains incorrect ownership records, with only the last-processed store's balance tracked
2. **Balance Misrepresentation**: Users with multiple stores will have their total balance underreported (only one store counted)
3. **API Data Corruption**: All applications and services relying on the indexer API will receive incorrect balance information
4. **Hidden Holdings**: Malicious actors could exploit this to obfuscate their true token holdings across multiple stores

While this doesn't affect on-chain state or consensus (the blockchain remains correct), it corrupts the indexer's off-chain view of token ownership, which is critical infrastructure for:
- Wallets displaying balances
- DEX interfaces showing available funds
- NFT marketplaces
- Analytics platforms

This meets **Medium Severity** criteria: "State inconsistencies requiring intervention" and "Limited funds loss or manipulation" (via balance misrepresentation enabling incorrect trading decisions).

## Likelihood Explanation

**Likelihood: Medium-High**

While creating multiple `FungibleAssetStore` objects for the same fungible asset is not the default behavior (most users use primary stores), it is:

1. **Explicitly Supported**: The Aptos framework provides `fungible_asset::create_store()` as a public function
2. **Documented Feature**: Multiple stores per user/asset is a legitimate use case (e.g., segregating funds, implementing escrow patterns)
3. **Already Occurring**: Any user who has created secondary stores is already affected
4. **Easy to Exploit**: No special permissions required, just call `create_store()` twice

The vulnerability triggers automatically whenever multiple stores exist for the same (user, metadata) pair.

## Recommendation

**Fix:** Change line 384 in `v2_token_ownerships.rs` to use the store's address instead of the metadata address:

```rust
// BEFORE (incorrect):
let storage_id = token_data_id.clone();

// AFTER (correct):
let storage_id = resource.address.clone();
```

This ensures each `FungibleAssetStore` object generates a unique composite key:
- Store A: `(FA_metadata, 0, user_addr, store_A_address)`
- Store B: `(FA_metadata, 0, user_addr, store_B_address)`

The `resource.address` field contains the store's unique address and is already available in the function.

**Additional Validation:**

After applying the fix, verify that:
1. Existing indexer databases are backfilled to capture previously lost store records
2. Total balance queries correctly aggregate across all stores for a given (user, metadata) pair
3. NFT v2 storage_id logic remains correct (it already uses the token object address appropriately)

## Proof of Concept

```move
// Create a fungible asset with primary store support
module test_addr::collision_poc {
    use aptos_framework::fungible_asset::{Self, Metadata};
    use aptos_framework::object::{Self, Object};
    use aptos_framework::primary_fungible_store;
    use std::signer;
    use std::string;

    public entry fun demonstrate_collision(creator: &signer) {
        // Create a fungible asset
        let constructor_ref = object::create_named_object(creator, b"test_fa");
        primary_fungible_store::create_primary_store_enabled_fungible_asset(
            &constructor_ref,
            option::some(1000000),
            string::utf8(b"Test FA"),
            string::utf8(b"TFA"),
            8,
            string::utf8(b""),
            string::utf8(b""),
        );
        let metadata = object::object_from_constructor_ref<Metadata>(&constructor_ref);
        
        // Create primary store (automatic on first mint)
        let mint_ref = fungible_asset::generate_mint_ref(&constructor_ref);
        primary_fungible_store::mint(&mint_ref, signer::address_of(creator), 1000);
        
        // Create a secondary store
        let store_constructor = object::create_object(signer::address_of(creator));
        let secondary_store = fungible_asset::create_store(&store_constructor, metadata);
        
        // Deposit funds into secondary store
        fungible_asset::deposit(secondary_store, primary_fungible_store::withdraw(creator, metadata, 500));
        
        // At this point:
        // - Primary store has balance 500
        // - Secondary store has balance 500
        // - Total balance SHOULD be 1000
        // - Indexer will only track ONE of these stores (whichever processes last)
        // - Reported balance will be 500 instead of 1000
    }
}
```

**Expected Indexer Behavior (Buggy):**
- Query `current_token_ownerships_v2` for this user and metadata returns ONE row with amount = 500
- Actual on-chain balance = 1000

**Expected Indexer Behavior (Fixed):**
- Query returns TWO rows (one per store)
- Sum of amounts = 1000 (correct)

### Citations

**File:** crates/indexer/src/models/token_models/v2_token_ownerships.rs (L351-425)
```rust
    pub fn get_ft_v2_from_write_resource(
        write_resource: &WriteResource,
        txn_version: i64,
        write_set_change_index: i64,
        txn_timestamp: chrono::NaiveDateTime,
        token_v2_metadata: &TokenV2AggregatedDataMapping,
    ) -> anyhow::Result<Option<(Self, CurrentTokenOwnershipV2)>> {
        let type_str = format!(
            "{}::{}::{}",
            write_resource.data.typ.address,
            write_resource.data.typ.module,
            write_resource.data.typ.name
        );
        if !V2FungibleAssetResource::is_resource_supported(type_str.as_str()) {
            return Ok(None);
        }
        let resource = MoveResource::from_write_resource(
            write_resource,
            0, // Placeholder, this isn't used anyway
            txn_version,
            0, // Placeholder, this isn't used anyway
        );

        if let V2FungibleAssetResource::FungibleAssetStore(inner) =
            V2FungibleAssetResource::from_resource(
                &type_str,
                resource.data.as_ref().unwrap(),
                txn_version,
            )?
        {
            if let Some(metadata) = token_v2_metadata.get(&resource.address) {
                let object_core = &metadata.object.object_core;
                let token_data_id = inner.metadata.get_reference_address();
                let storage_id = token_data_id.clone();
                let is_soulbound = inner.frozen;
                let amount = inner.balance;
                let owner_address = object_core.get_owner_address();

                return Ok(Some((
                    Self {
                        transaction_version: txn_version,
                        write_set_change_index,
                        token_data_id: token_data_id.clone(),
                        property_version_v1: BigDecimal::zero(),
                        owner_address: Some(owner_address.clone()),
                        storage_id: storage_id.clone(),
                        amount: amount.clone(),
                        table_type_v1: None,
                        token_properties_mutated_v1: None,
                        is_soulbound_v2: Some(is_soulbound),
                        token_standard: TokenStandard::V2.to_string(),
                        is_fungible_v2: Some(true),
                        transaction_timestamp: txn_timestamp,
                        non_transferrable_by_owner: Some(is_soulbound),
                    },
                    CurrentTokenOwnershipV2 {
                        token_data_id,
                        property_version_v1: BigDecimal::zero(),
                        owner_address,
                        storage_id,
                        amount,
                        table_type_v1: None,
                        token_properties_mutated_v1: None,
                        is_soulbound_v2: Some(is_soulbound),
                        token_standard: TokenStandard::V2.to_string(),
                        is_fungible_v2: Some(true),
                        last_transaction_version: txn_version,
                        last_transaction_timestamp: txn_timestamp,
                        non_transferrable_by_owner: Some(is_soulbound),
                    },
                )));
            }
        }
        Ok(None)
    }
```

**File:** aptos-move/framework/aptos-framework/sources/fungible_asset.move (L147-155)
```text
    /// The store object that holds fungible assets of a specific type associated with an account.
    struct FungibleStore has key {
        /// The address of the base metadata object.
        metadata: Object<Metadata>,
        /// The balance of the fungible metadata.
        balance: u64,
        /// If true, owner transfer is disabled that only `TransferRef` can move in/out from this store.
        frozen: bool
    }
```

**File:** crates/indexer/src/processors/token_processor.rs (L762-796)
```rust
fn insert_current_token_ownerships_v2(
    conn: &mut PgConnection,
    items_to_insert: &[CurrentTokenOwnershipV2],
) -> Result<(), diesel::result::Error> {
    use schema::current_token_ownerships_v2::dsl::*;

    let chunks = get_chunks(
        items_to_insert.len(),
        CurrentTokenOwnershipV2::field_count(),
    );

    for (start_ind, end_ind) in chunks {
        execute_with_better_error(
            conn,
            diesel::insert_into(schema::current_token_ownerships_v2::table)
                .values(&items_to_insert[start_ind..end_ind])
                .on_conflict((token_data_id, property_version_v1, owner_address, storage_id))
                .do_update()
                .set((
                    amount.eq(excluded(amount)),
                    table_type_v1.eq(excluded(table_type_v1)),
                    token_properties_mutated_v1.eq(excluded(token_properties_mutated_v1)),
                    is_soulbound_v2.eq(excluded(is_soulbound_v2)),
                    token_standard.eq(excluded(token_standard)),
                    is_fungible_v2.eq(excluded(is_fungible_v2)),
                    last_transaction_version.eq(excluded(last_transaction_version)),
                    last_transaction_timestamp.eq(excluded(last_transaction_timestamp)),
                    inserted_at.eq(excluded(inserted_at)),
                    non_transferrable_by_owner.eq(excluded(non_transferrable_by_owner)),
                )),
            Some(" WHERE current_token_ownerships_v2.last_transaction_version <= excluded.last_transaction_version "),
        )?;
    }
    Ok(())
}
```

**File:** crates/indexer/migrations/2023-04-28-053048_object_token_v2/up.sql (L60-80)
```sql
CREATE TABLE IF NOT EXISTS current_token_ownerships_v2 (
  token_data_id VARCHAR(66) NOT NULL,
  property_version_v1 NUMERIC NOT NULL,
  owner_address VARCHAR(66) NOT NULL,
  storage_id VARCHAR(66) NOT NULL,
  amount NUMERIC NOT NULL,
  table_type_v1 VARCHAR(66),
  token_properties_mutated_v1 JSONB,
  is_soulbound_v2 BOOLEAN,
  token_standard VARCHAR(10) NOT NULL,
  is_fungible_v2 BOOLEAN,
  last_transaction_version BIGINT NOT NULL,
  last_transaction_timestamp TIMESTAMP NOT NULL,
  inserted_at TIMESTAMP NOT NULL DEFAULT NOW(),
  PRIMARY KEY (
    token_data_id,
    property_version_v1,
    owner_address,
    storage_id
  )
);
```

**File:** aptos-move/framework/aptos-framework/sources/primary_fungible_store.move (L74-88)
```text
    /// Create a primary store object to hold fungible asset for the given address.
    public fun create_primary_store<T: key>(
        owner_addr: address,
        metadata: Object<T>,
    ): Object<FungibleStore> acquires DeriveRefPod {
        let metadata_addr = metadata.object_address();
        object::address_to_object<Metadata>(metadata_addr);
        let derive_ref = &borrow_global<DeriveRefPod>(metadata_addr).metadata_derive_ref;
        let constructor_ref = &object::create_user_derived_object(owner_addr, derive_ref);
        // Disable ungated transfer as deterministic stores shouldn't be transferrable.
        let transfer_ref = &constructor_ref.generate_transfer_ref();
        transfer_ref.disable_ungated_transfer();

        fungible_asset::create_store(constructor_ref, metadata)
    }
```
