# Audit Report

## Title
SRS Validation Accepts Point at Infinity, Enabling Potential Polynomial Commitment Forgery

## Summary
The Structured Reference String (SRS) validation in `srs.rs` does not explicitly reject the point at infinity (identity element) in `lagr` or `tau_powers` vectors. While the arkworks library's `check()` method validates curve membership and subgroup correctness, it accepts the identity element, which could enable trivial forgery of polynomial commitments if malicious SRS data were injected into the system.

## Finding Description

The `SrsBasis::check()` function validates SRS elements by calling the arkworks `check()` method on each curve point: [1](#0-0) 

This validation checks that each point is a valid curve element in the prime-order subgroup, but **does not explicitly reject the point at infinity (identity element)**. Evidence from the test suite confirms that arkworks accepts the identity element: [2](#0-1) [3](#0-2) 

In contrast, BLS signature validation explicitly rejects the identity point as a security requirement: [4](#0-3) 

When the SRS is used in polynomial commitment schemes, it undergoes multi-scalar multiplication (MSM): [5](#0-4) 

If the SRS contains the point at infinity at position `i`, the commitment computation yields: `scalar_i * O = O` (where O is the identity), effectively zeroing out that term and breaking the binding property of the commitment scheme.

## Impact Explanation

**Current Impact: Medium** - While the validation gap exists as a defense-in-depth weakness, exploitation requires injecting malicious SRS data. In the current implementation, SRS is generated deterministically: [6](#0-5) [7](#0-6) 

However, the structures support serialization/deserialization: [8](#0-7) 

**Potential Critical Impact**: If future implementations allow loading SRS from external sources, files, or attacker-influenced storage, this could enable:
- Breaking binding property of polynomial commitments
- Forging range proofs in DKG protocol
- Corrupting validator randomness generation

## Likelihood Explanation

**Current Likelihood: Low** - The current implementation generates SRS during setup with random trapdoors and does not load from attacker-controlled sources. Public parameters are created deterministically from on-chain DKG session metadata: [9](#0-8) 

However, likelihood increases if:
- Code changes allow loading pre-computed SRS from files/network
- Compromised build/deployment pipelines inject malicious parameters
- Storage corruption or tampering with serialized keys

## Recommendation

Add explicit validation to reject the point at infinity in SRS vectors:

```rust
impl<C: CurveGroup> Valid for SrsBasis<C> {
    fn check(&self) -> Result<(), SerializationError> {
        match self {
            SrsBasis::Lagrange { lagr: lagr_g1 } => {
                for g in lagr_g1 {
                    g.check()?;
                    // Reject identity element (point at infinity)
                    if g.is_zero() {
                        return Err(SerializationError::InvalidData);
                    }
                }
            },
            SrsBasis::PowersOfTau { tau_powers: tau_powers_g1 } => {
                for g in tau_powers_g1 {
                    g.check()?;
                    // Reject identity element (point at infinity)
                    if g.is_zero() {
                        return Err(SerializationError::InvalidData);
                    }
                }
            },
        }
        Ok(())
    }
}
```

Additionally, add validation in `PublicParameters` deserialization and setup functions to mirror the BLS signature validation pattern.

## Proof of Concept

```rust
#[cfg(test)]
mod srs_identity_test {
    use super::*;
    use ark_bn254::{G1Affine, G1Projective};
    use ark_ec::{AffineRepr, CurveGroup};
    use ark_serialize::{CanonicalDeserialize, CanonicalSerialize, Compress, Validate};

    #[test]
    fn test_srs_accepts_point_at_infinity() {
        // Create SRS with point at infinity
        let mut lagr = vec![G1Affine::generator(); 10];
        lagr[5] = G1Affine::zero(); // Insert point at infinity
        
        let srs = SrsBasis::<G1Projective>::Lagrange { lagr };
        
        // Current validation ACCEPTS the identity element
        assert!(srs.check().is_ok(), "Current validation incorrectly accepts point at infinity");
        
        // Serialize and deserialize
        let mut bytes = Vec::new();
        srs.serialize_with_mode(&mut bytes, Compress::Yes).unwrap();
        
        let deserialized = SrsBasis::<G1Projective>::deserialize_with_mode(
            &bytes[..],
            Compress::Yes,
            Validate::Yes
        ).unwrap();
        
        // Validation during deserialization also accepts it
        assert!(deserialized.check().is_ok(), 
                "Deserialization validation incorrectly accepts point at infinity");
    }
}
```

## Notes

While this represents a validation gap that violates the security properties expected of an SRS, the current Aptos DKG implementation generates parameters deterministically without external input. The vulnerability is classified as **defense-in-depth weakness** rather than immediately exploitable, but should be addressed to prevent future exploitation scenarios.

### Citations

**File:** crates/aptos-crypto/src/arkworks/srs.rs (L82-98)
```rust
    fn check(&self) -> Result<(), SerializationError> {
        match self {
            SrsBasis::Lagrange { lagr: lagr_g1 } => {
                for g in lagr_g1 {
                    g.check()?;
                }
            },
            SrsBasis::PowersOfTau {
                tau_powers: tau_powers_g1,
            } => {
                for g in tau_powers_g1 {
                    g.check()?;
                }
            },
        }
        Ok(())
    }
```

**File:** crates/aptos-crypto/src/arkworks/serialization.rs (L72-86)
```rust
        let mut points = vec![G1Affine::zero()]; // Include zero
        let mut g = G1Projective::generator();

        for _ in 0..MAX_DOUBLINGS {
            points.push(g.into());
            g += g; // double for next
        }

        for p in points {
            let serialized = bcs::to_bytes(&A(p)).expect("Serialization failed");
            let deserialized: A = bcs::from_bytes(&serialized).expect("Deserialization failed");

            assert_eq!(deserialized.0, p, "G1 point round-trip failed for {:?}", p);
        }
    }
```

**File:** crates/aptos-crypto/src/arkworks/serialization.rs (L93-106)
```rust
        let mut points = vec![G2Affine::zero()]; // Include zero
        let mut g = G2Projective::generator();

        for _ in 0..MAX_DOUBLINGS {
            points.push(g.into());
            g += g; // double for next
        }

        for p in points {
            let serialized = bcs::to_bytes(&A(p)).expect("Serialization failed");
            let deserialized: A = bcs::from_bytes(&serialized).expect("Deserialization failed");

            assert_eq!(deserialized.0, p, "G2 point round-trip failed for {:?}", p);
        }
```

**File:** aptos-move/framework/aptos-stdlib/sources/cryptography/bls12381.move (L384-390)
```text
    /// Return `true` if the bytes in `public_key` are a valid BLS12-381 public key:
    ///  (1) it is NOT the identity point, and
    ///  (2) it is a BLS12-381 elliptic curve point, and
    ///  (3) it is a prime-order point
    /// Return `false` otherwise.
    /// Does not abort.
    native fun validate_pubkey_internal(public_key: vector<u8>): bool;
```

**File:** crates/aptos-dkg/src/pcs/univariate_hiding_kzg.rs (L370-373)
```rust
    fn msm_eval(input: Self::MsmInput) -> Self::MsmOutput {
        E::G1::msm(input.bases(), &input.scalars())
            .expect("MSM computation failed in univariate KZG")
    }
```

**File:** types/src/dkg/real_dkg/mod.rs (L129-129)
```rust
    let pp = DkgPP::default_with_bls_base();
```

**File:** crates/aptos-dkg/src/range_proofs/dekart_univariate_v2.rs (L265-273)
```rust
        let trapdoor = univariate_hiding_kzg::Trapdoor::<E>::rand(rng);
        let xi_1_proj: E::G1 = group_generators.g1 * trapdoor.xi;

        let (vk_hkzg, ck_S) = univariate_hiding_kzg::setup(
            max_n + 1,
            SrsType::Lagrange,
            group_generators.clone(),
            trapdoor,
        );
```

**File:** crates/aptos-dkg/src/pvss/chunky/public_parameters.rs (L149-155)
```rust
impl<E: Pairing> TryFrom<&[u8]> for PublicParameters<E> {
    type Error = CryptoMaterialError;

    fn try_from(bytes: &[u8]) -> Result<Self, Self::Error> {
        bcs::from_bytes::<PublicParameters<E>>(bytes)
            .map_err(|_| CryptoMaterialError::DeserializationError)
    }
```

**File:** aptos-move/aptos-vm/src/validator_txns/dkg.rs (L105-105)
```rust
        let pub_params = DefaultDKG::new_public_params(&in_progress_session_state.metadata);
```
