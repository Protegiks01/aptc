# Audit Report

## Title
Sensitive Information Disclosure Through Debug Logging in Telemetry Service

## Summary
Multiple debug log statements across the Aptos telemetry service leak sensitive information including peer IDs, chain IDs, node addresses, cryptographic handshake messages, and complete node log contents. If debug logging is accidentally enabled in production, this information could be exposed to unauthorized parties, enabling network mapping, privacy violations, and potential cryptographic analysis.

## Finding Description

The telemetry service contains numerous debug log statements that expose sensitive operational data. While the initially identified log at line 46 is benign, systematic analysis reveals critical information leaks throughout the codebase:

**1. Authentication Request Logging** - The entire authentication request body is logged, including peer_id, chain_id, cryptographic handshake messages, server public keys, and run_uuid: [1](#0-0) 

The AuthRequest structure contains: [2](#0-1) 

**2. Complete Node Log Exposure** - All ingested logs from nodes are logged with full metadata including peer_id, epoch, chain_id, node_type, run_uuid, and the complete log message content: [3](#0-2) 

**3. Custom Contract Sensitive Data** - Multiple endpoints log peer_id and chain_id for custom contract operations: [4](#0-3) [5](#0-4) [6](#0-5) 

**4. Authentication Challenge Logging** - Entire challenge request bodies containing addresses and chain IDs are logged: [7](#0-6) 

**Attack Scenario:**
If debug logging is accidentally enabled in production (via environment variable, configuration error, or deployment mistake), all this sensitive information flows to configured logging backends (local files, CloudWatch, Datadog, etc.). An attacker who gains read access to these logs (through misconfigured permissions, log aggregation systems, or compromised monitoring infrastructure) can:

1. **Map the validator network**: Collect all peer_ids and their associated chain_ids
2. **Track node sessions**: Monitor run_uuid changes to detect restarts and operational patterns
3. **Extract cryptographic material**: Access handshake messages for potential cryptanalysis
4. **Access operational secrets**: Read all node logs which may contain sensitive operational data
5. **Identify node roles**: Determine which nodes are validators, VFNs, or public full nodes

## Impact Explanation

This qualifies as **Low Severity** per the Aptos Bug Bounty program's "Minor information leaks" category. While the information disclosure is real and actionable, it does not directly lead to:
- Loss of funds
- Consensus violations
- Network partition or liveness failures
- Direct system compromise

However, the leaked information provides valuable intelligence for more sophisticated attacks and violates the privacy expectations of node operators.

## Likelihood Explanation

**Likelihood: Medium**

Debug logging being accidentally enabled in production is a common operational mistake that occurs through:
- Environment variable misconfiguration during deployment
- Copy-paste errors from development configurations
- Emergency debugging sessions where debug mode is enabled but not reverted
- Infrastructure-as-code template errors
- Container image build mistakes

Production systems at scale (like Aptos validators) often have complex deployment pipelines where such mistakes can slip through, especially during incident response or emergency maintenance.

## Recommendation

**Immediate Actions:**
1. Audit all debug! macro calls in production code paths
2. Remove or sanitize sensitive data from debug logs
3. Implement logging level guards at compile time for production builds
4. Add automated checks in CI/CD to flag debug logs containing sensitive fields

**Code Fix Example:**

Replace sensitive debug logs with sanitized versions:

```rust
// BEFORE (auth.rs line 32)
debug!("received auth request: {:?}", body);

// AFTER - sanitize sensitive fields
debug!("received auth request for chain_id: {}, peer_id: [REDACTED]", body.chain_id);

// BEFORE (log_ingest.rs line 103)
debug!("ingesting to humio: {:?}", unstructured_log);

// AFTER - remove entirely or sanitize
debug!("ingesting {} log messages to humio", unstructured_log.messages.len());
```

Alternatively, use conditional compilation to exclude debug logs entirely from production builds:

```rust
#[cfg(debug_assertions)]
debug!("received auth request: {:?}", body);
```

## Proof of Concept

**Step 1:** Enable debug logging in production telemetry service by setting the `RUST_LOG` environment variable:
```bash
export RUST_LOG=debug
```

**Step 2:** Submit an authentication request to the telemetry service endpoint. The service will log the complete request including peer_id, chain_id, and cryptographic handshake:

```rust
// This will be logged in plaintext to the configured logging backend:
// debug!("received auth request: AuthRequest { 
//    chain_id: 1, 
//    peer_id: 0xabcd..., 
//    handshake_msg: [crypto bytes],
//    server_public_key: [public key bytes],
//    run_uuid: uuid 
// }")
```

**Step 3:** Check the logging output (stdout, files, or centralized logging) to observe the leaked information.

**Step 4:** An attacker with read access to these logs can now:
- Build a map of all peer_ids and their chains
- Track node session restarts via run_uuid changes
- Collect cryptographic handshake messages for analysis
- Monitor operational patterns and node types

**Verification:** The vulnerability can be confirmed by:
1. Running the telemetry service with `RUST_LOG=debug`
2. Making any authenticated API call
3. Observing the debug output containing full peer_id, chain_id, and other sensitive data

## Notes

While this is categorized as Low severity, information disclosure vulnerabilities are important defense-in-depth measures. The leaked information, particularly peer network topology and cryptographic handshake messages, could be valuable for more sophisticated multi-stage attacks. Production blockchain infrastructure should follow the principle of least information disclosure, especially for network-level operational data.

### Citations

**File:** crates/aptos-telemetry-service/src/auth.rs (L32-32)
```rust
    debug!("received auth request: {:?}", body);
```

**File:** crates/aptos-telemetry-service/src/types/auth.rs (L12-21)
```rust
pub struct AuthRequest {
    pub chain_id: ChainId,
    pub peer_id: PeerId,
    #[serde(default = "default_role_type")]
    pub role_type: RoleType,
    pub server_public_key: x25519::PublicKey,
    pub handshake_msg: Vec<u8>,
    #[serde(default = "default_uuid")]
    pub run_uuid: Uuid,
}
```

**File:** crates/aptos-telemetry-service/src/log_ingest.rs (L103-103)
```rust
    debug!("ingesting to humio: {:?}", unstructured_log);
```

**File:** crates/aptos-telemetry-service/src/custom_contract_ingest.rs (L70-76)
```rust
    debug!(
        "received custom contract '{}' metrics from peer_id: {}, chain_id: {}, body length: {}",
        contract_name,
        peer_id,
        chain_id,
        body.len()
    );
```

**File:** crates/aptos-telemetry-service/src/custom_contract_ingest.rs (L184-190)
```rust
    debug!(
        "received custom contract '{}' logs from peer_id: {}, chain_id: {}, body length: {}",
        contract_name,
        peer_id,
        chain_id,
        body.len()
    );
```

**File:** crates/aptos-telemetry-service/src/custom_contract_ingest.rs (L338-344)
```rust
    debug!(
        "received custom contract '{}' custom event from peer_id: {}, chain_id: {}, events: {}",
        contract_name,
        peer_id,
        chain_id,
        body.events.len()
    );
```

**File:** crates/aptos-telemetry-service/src/custom_contract_auth.rs (L76-79)
```rust
    debug!(
        "received custom contract '{}' auth challenge request: {:?}",
        contract_name, body
    );
```
