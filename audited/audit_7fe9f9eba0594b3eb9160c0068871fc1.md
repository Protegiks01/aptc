# Audit Report

## Title
Payload Poisoning Attack - Invalid Block Payloads Persist After Verification Failure

## Summary
When `verify_payloads_against_ordered_block()` returns an error, the invalid payloads are NOT removed from the payload store. This allows an attacker to poison the store with malicious payloads that permanently prevent consensus observer nodes from processing legitimate blocks for specific (epoch, round) pairs, causing a targeted denial-of-service condition.

## Finding Description

The consensus observer's payload verification process has a critical gap in its error handling that breaks the invariant of resource cleanup after validation failures.

**The Vulnerability Path:**

The function `verify_payloads_against_ordered_block()` validates that stored block payloads match the corresponding ordered blocks. However, when validation fails, the function returns an error without cleaning up the invalid payload from storage. [1](#0-0) 

The verification function only reads from the store using `entry.get()` but never calls `entry.remove()` in any error path. When mismatches are detected (wrong batches, unverified signatures, or missing payloads), the function immediately returns an error without cleanup.

This contrasts with `verify_payload_signatures()` which DOES remove invalid payloads upon signature verification failure: [2](#0-1) 

**The Attack Scenario:**

1. Attacker sends a malicious `BlockPayload` message for (epoch E, round R) that passes initial digest verification but contains incorrect transaction batches
2. The payload is stored in the payload store: [3](#0-2) 

3. When a legitimate `OrderedBlock` arrives for the same (E, R), payload verification is triggered: [4](#0-3) 

4. Verification fails because the stored malicious payload doesn't match the ordered block's expected batches, and the ordered block is rejected WITHOUT removing the invalid payload

5. When the legitimate `BlockPayload` for (E, R) arrives, it's rejected as a duplicate: [5](#0-4) 

6. The node becomes permanently unable to process block (E, R) because:
   - The invalid payload occupies the store slot
   - Legitimate payloads are rejected
   - Ordered block verification always fails
   - No automatic cleanup mechanism exists

**Why Cleanup Doesn't Happen:**

Payloads are only removed during:
- Block commitment (which cannot occur if verification fails)
- Epoch transitions 
- Manual fallback mode entry
- Complete subscription failures [6](#0-5) 

There is no timeout-based cleanup or retry mechanism for failed payload verifications.

## Impact Explanation

**Severity: Medium** per Aptos bug bounty criteria - "State inconsistencies requiring intervention"

**Impact Details:**
- **Affected Components**: Consensus observer nodes (non-validator nodes tracking chain state)
- **Attack Surface**: Any malicious network peer can send BlockPayload messages
- **Denial of Service**: Targeted blocks cannot be processed, forcing nodes into fallback mode or requiring manual intervention
- **Scope Limitation**: Does not affect validator consensus (only observers), does not compromise consensus safety, only impacts liveness of observer nodes
- **Recovery**: Requires fallback to state sync or waiting for epoch transition

This meets Medium severity because it causes operational disruption requiring intervention but does not compromise consensus safety or cause fund loss.

## Likelihood Explanation

**Likelihood: Medium to High**

**Favorable Conditions for Attacker:**
- No authentication required to send BlockPayload messages to consensus observers
- Race condition is winnable if attacker has network proximity to observer nodes
- Attack can be repeated for multiple blocks to maximize disruption
- Low resource cost for attacker (just send malicious messages)

**Mitigating Factors:**
- Requires attacker to send malicious payload before legitimate one arrives
- Only affects consensus observer nodes, not validators
- Nodes can recover via state sync fallback
- Each epoch transition naturally cleans up old payloads

The attack is practical and can cause significant operational issues for observer nodes without requiring sophisticated resources.

## Recommendation

**Fix: Remove invalid payloads when verification fails**

Modify `verify_payloads_against_ordered_block()` to remove payloads that fail verification:

```rust
pub fn verify_payloads_against_ordered_block(
    &mut self,
    ordered_block: &OrderedBlock,
) -> Result<(), Error> {
    for ordered_block in ordered_block.blocks() {
        let block_epoch = ordered_block.epoch();
        let block_round = ordered_block.round();

        match self.block_payloads.lock().entry((block_epoch, block_round)) {
            Entry::Occupied(mut entry) => {
                let transaction_payload = match entry.get() {
                    BlockPayloadStatus::AvailableAndVerified(block_payload) => {
                        block_payload.transaction_payload()
                    },
                    BlockPayloadStatus::AvailableAndUnverified(_) => {
                        // FIXED: Remove the unverified payload
                        entry.remove();
                        return Err(Error::InvalidMessageError(format!(
                            "Payload verification failed! Block payload for epoch: {:?} and round: {:?} is unverified.",
                            ordered_block.epoch(),
                            ordered_block.round()
                        )));
                    },
                };

                let ordered_block_payload = match ordered_block.block().payload() {
                    Some(payload) => payload,
                    None => {
                        // FIXED: Remove the invalid payload
                        entry.remove();
                        return Err(Error::InvalidMessageError(format!(
                            "Payload verification failed! Missing block payload for epoch: {:?} and round: {:?}",
                            ordered_block.epoch(),
                            ordered_block.round()
                        )));
                    },
                };

                // Verify the transaction payload against the ordered block payload
                if let Err(e) = transaction_payload.verify_against_ordered_payload(ordered_block_payload) {
                    // FIXED: Remove the mismatched payload
                    entry.remove();
                    return Err(e);
                }
            },
            Entry::Vacant(_) => {
                return Err(Error::InvalidMessageError(format!(
                    "Payload verification failed! Missing block payload for epoch: {:?} and round: {:?}",
                    ordered_block.epoch(),
                    ordered_block.round()
                )));
            },
        }
    }

    Ok(())
}
```

This ensures invalid payloads are cleaned up immediately upon detection, preventing payload poisoning attacks and allowing legitimate payloads to be accepted.

## Proof of Concept

**Rust Integration Test:**

```rust
#[tokio::test]
async fn test_payload_poisoning_attack() {
    // Setup consensus observer node
    let mut observer = create_test_consensus_observer().await;
    
    // Create malicious payload for epoch 0, round 10
    let malicious_batch_info = create_fake_batch_info();
    let malicious_payload = BlockPayload::new(
        BlockInfo::new(0, 10, HashValue::random(), HashValue::random(), 0, 0, None),
        BlockTransactionPayload::new_with_batches(vec![malicious_batch_info])
    );
    
    // Send malicious payload (passes digest check)
    observer.process_block_payload_message(
        PeerNetworkId::random(),
        Instant::now(),
        malicious_payload.clone()
    ).await;
    
    // Verify malicious payload is stored
    assert!(observer.observer_block_data.lock().existing_payload_entry(&malicious_payload));
    
    // Create legitimate ordered block with different batches
    let legitimate_batches = vec![create_legitimate_batch_info()];
    let ordered_block = OrderedBlock::new(
        vec![create_pipelined_block_with_batches(0, 10, legitimate_batches)],
        create_ledger_info(0, 10)
    );
    
    // Process ordered block - should fail verification
    let result = observer.observer_block_data.lock()
        .verify_payloads_against_ordered_block(&ordered_block);
    assert!(result.is_err());
    
    // VULNERABILITY: Malicious payload still exists
    assert!(observer.observer_block_data.lock().existing_payload_entry(&malicious_payload));
    
    // Send legitimate payload - gets rejected as duplicate
    let legitimate_payload = BlockPayload::new(
        BlockInfo::new(0, 10, HashValue::random(), HashValue::random(), 0, 0, None),
        BlockTransactionPayload::new_with_batches(vec![create_legitimate_batch_info()])
    );
    
    observer.process_block_payload_message(
        PeerNetworkId::random(),
        Instant::now(),
        legitimate_payload
    ).await;
    
    // Verify legitimate payload was rejected (malicious one still in store)
    let stored_payload = get_stored_payload(&observer, 0, 10);
    assert_ne!(stored_payload.batches(), vec![create_legitimate_batch_info()]);
    
    // Node cannot process block (0, 10) - DoS achieved
    println!("âœ“ Payload poisoning attack successful - block processing blocked");
}
```

**Notes**

This vulnerability specifically affects the consensus observer component which is used by non-validator nodes to follow the blockchain state. While it doesn't compromise consensus safety among validators, it creates a denial-of-service vector against observer infrastructure that could impact ecosystem services relying on consensus observers (wallets, indexers, APIs, etc.).

The fix is straightforward and mirrors the existing cleanup behavior in `verify_payload_signatures()`, establishing consistent error handling across all payload verification paths.

### Citations

**File:** consensus/src/consensus_observer/observer/payload_store.rs (L111-119)
```rust
    /// Removes all blocks up to the specified epoch and round (inclusive)
    pub fn remove_blocks_for_epoch_round(&self, epoch: u64, round: Round) {
        // Determine the round to split off
        let split_off_round = round.saturating_add(1);

        // Remove the blocks from the payload store
        let mut block_payloads = self.block_payloads.lock();
        *block_payloads = block_payloads.split_off(&(epoch, split_off_round));
    }
```

**File:** consensus/src/consensus_observer/observer/payload_store.rs (L156-213)
```rust
    /// Verifies all block payloads against the given ordered block.
    /// If verification fails, an error is returned.
    pub fn verify_payloads_against_ordered_block(
        &mut self,
        ordered_block: &OrderedBlock,
    ) -> Result<(), Error> {
        // Verify each of the blocks in the ordered block
        for ordered_block in ordered_block.blocks() {
            // Get the block epoch and round
            let block_epoch = ordered_block.epoch();
            let block_round = ordered_block.round();

            // Fetch the block payload
            match self.block_payloads.lock().entry((block_epoch, block_round)) {
                Entry::Occupied(entry) => {
                    // Get the block transaction payload
                    let transaction_payload = match entry.get() {
                        BlockPayloadStatus::AvailableAndVerified(block_payload) => {
                            block_payload.transaction_payload()
                        },
                        BlockPayloadStatus::AvailableAndUnverified(_) => {
                            // The payload should have already been verified
                            return Err(Error::InvalidMessageError(format!(
                                "Payload verification failed! Block payload for epoch: {:?} and round: {:?} is unverified.",
                                ordered_block.epoch(),
                                ordered_block.round()
                            )));
                        },
                    };

                    // Get the ordered block payload
                    let ordered_block_payload = match ordered_block.block().payload() {
                        Some(payload) => payload,
                        None => {
                            return Err(Error::InvalidMessageError(format!(
                                "Payload verification failed! Missing block payload for epoch: {:?} and round: {:?}",
                                ordered_block.epoch(),
                                ordered_block.round()
                            )));
                        },
                    };

                    // Verify the transaction payload against the ordered block payload
                    transaction_payload.verify_against_ordered_payload(ordered_block_payload)?;
                },
                Entry::Vacant(_) => {
                    // The payload is missing (this should never happen)
                    return Err(Error::InvalidMessageError(format!(
                        "Payload verification failed! Missing block payload for epoch: {:?} and round: {:?}",
                        ordered_block.epoch(),
                        ordered_block.round()
                    )));
                },
            }
        }

        Ok(())
    }
```

**File:** consensus/src/consensus_observer/observer/payload_store.rs (L240-250)
```rust
                        if let Err(error) = block_payload.verify_payload_signatures(epoch_state) {
                            // Log the verification failure
                            error!(
                                LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                                    "Failed to verify the block payload signatures for epoch: {:?} and round: {:?}. Error: {:?}",
                                    epoch, round, error
                                ))
                            );

                            // Remove the block payload from the store
                            entry.remove();
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L370-380)
```rust
        let payload_exists = self
            .observer_block_data
            .lock()
            .existing_payload_entry(&block_payload);

        // If the payload is out of date or already exists, ignore it
        if payload_out_of_date || payload_exists {
            // Update the metrics for the dropped block payload
            update_metrics_for_dropped_block_payload_message(peer_network_id, &block_payload);
            return;
        }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L428-430)
```rust
        self.observer_block_data
            .lock()
            .insert_block_payload(block_payload, verified_payload);
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L754-771)
```rust
        // Verify the block payloads against the ordered block
        if let Err(error) = self
            .observer_block_data
            .lock()
            .verify_payloads_against_ordered_block(&ordered_block)
        {
            // Log the error and update the invalid message counter
            error!(
                LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                    "Failed to verify block payloads against ordered block! Ignoring: {:?}, from peer: {:?}. Error: {:?}",
                    ordered_block.proof_block_info(),
                    peer_network_id,
                    error
                ))
            );
            increment_invalid_message_counter(&peer_network_id, metrics::ORDERED_BLOCK_LABEL);
            return;
        }
```
