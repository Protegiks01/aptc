# Audit Report

## Title
Missing Gas Schedule Parameter Validation Allows Governance-Controlled Economic Security Bypass

## Summary
The Aptos on-chain gas schedule update functions lack validation to prevent `min_price_per_gas_unit` from being set to zero. If a governance proposal sets this parameter to 0, the VM contains special bypass logic that exempts zero-gas-price transactions from storage fees and account creation checks, enabling unlimited state bloat attacks at zero cost.

## Finding Description

The vulnerability exists across multiple components:

**1. Missing Validation in Gas Schedule Updates**

The `gas_schedule.move` module allows updating gas parameters without validating their values. [1](#0-0) 

The code contains explicit TODO comments acknowledging this missing validation: [2](#0-1) 

**2. Gas Price Validation Uses Configurable Minimum**

The VM validates gas prices against the configurable `min_price_per_gas_unit` parameter: [3](#0-2) 

The parameter's default value references a global constant that differs between test and production: [4](#0-3) 

This constant is 0 in test mode and 100 in production: [5](#0-4) 

**3. Special Bypass Logic for Zero Gas Prices**

The VM contains intentional bypass logic for zero gas prices in storage fee processing: [6](#0-5) 

Account creation fee checks are also skipped when `gas_unit_price == 0`: [7](#0-6) 

And in the gas validation: [8](#0-7) 

**Attack Path**:
1. Malicious governance proposal passes to set `min_price_per_gas_unit = 0` in the gas schedule blob
2. Proposal executes via `set_for_next_epoch()` which performs no value validation
3. At next epoch transition, the parameter activates network-wide
4. All validators now accept transactions with `gas_unit_price = 0`
5. Attackers submit unlimited transactions with zero gas price
6. Storage fees bypassed (returns immediately with 0 fee)
7. Account creation fees bypassed
8. Network suffers catastrophic state bloat attack at zero cost

## Impact Explanation

This qualifies as **Critical Severity** per Aptos bug bounty criteria because it enables:

- **Total loss of network liveness**: Unlimited state bloat would halt the network
- **Non-recoverable network partition**: Would require emergency hardfork to fix the gas schedule
- **Consensus violation**: Breaks the "Resource Limits" invariant - operations no longer respect storage limits

The bypass logic explicitly exempts zero-gas-price transactions from ALL storage fees and account creation checks, allowing an attacker to exhaust network storage capacity at zero cost.

## Likelihood Explanation

**Likelihood: LOW to MEDIUM**

The attack requires:
- **Governance compromise**: Attacker must propose and pass a governance vote to modify gas parameters
- **Required stake**: Significant stake required to meet `required_proposer_stake`
- **Voting threshold**: Must achieve `min_voting_threshold` to pass proposal
- **No emergency response**: Assumes no intervention before epoch change activates malicious parameters

However, the vulnerability is **actively documented** in TODO comments, indicating the developers are aware this validation should exist but hasn't been implemented. The special bypass logic for zero gas prices creates an attack surface that shouldn't exist in production code.

## Recommendation

Implement comprehensive validation in `gas_schedule.move` to enforce parameter sanity bounds:

```move
public fun set_for_next_epoch(aptos_framework: &signer, gas_schedule_blob: vector<u8>) acquires GasScheduleV2 {
    system_addresses::assert_aptos_framework(aptos_framework);
    assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));
    let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
    
    // ADD VALIDATION HERE
    validate_gas_schedule_consistency(&new_gas_schedule);
    
    if (exists<GasScheduleV2>(@aptos_framework)) {
        let cur_gas_schedule = borrow_global<GasScheduleV2>(@aptos_framework);
        assert!(
            new_gas_schedule.feature_version >= cur_gas_schedule.feature_version,
            error::invalid_argument(EINVALID_GAS_FEATURE_VERSION)
        );
    };
    config_buffer::upsert(new_gas_schedule);
}

fun validate_gas_schedule_consistency(schedule: &GasScheduleV2) {
    // Enforce min_price_per_gas_unit > 0
    // Enforce min_price_per_gas_unit <= max_price_per_gas_unit
    // Enforce min_transaction_gas_units <= maximum_number_of_gas_units
    // Enforce all other parameter sanity bounds
}
```

Additionally, remove or guard the bypass logic in production builds to prevent zero gas price exploitation.

## Proof of Concept

```move
#[test_only]
module aptos_framework::gas_schedule_exploit_test {
    use aptos_framework::gas_schedule;
    use aptos_framework::aptos_governance;
    use std::bcs;
    
    #[test(framework = @aptos_framework)]
    fun test_zero_gas_price_bypass(framework: &signer) {
        // 1. Create malicious gas schedule with min_price_per_gas_unit = 0
        let malicious_schedule = create_zero_min_price_schedule();
        let schedule_blob = bcs::to_bytes(&malicious_schedule);
        
        // 2. Set malicious schedule (no validation prevents this)
        gas_schedule::set_for_next_epoch(framework, schedule_blob);
        
        // 3. Trigger epoch change
        aptos_governance::reconfigure(framework);
        
        // 4. Submit transaction with gas_unit_price = 0
        // This transaction would now be accepted and bypass all storage fees
        // State bloat attack can proceed at zero cost
    }
}
```

## Notes

**Regarding the original question about transaction generators**: The benchmark transaction generators in `transaction_bench_state.rs` are test infrastructure and NOT production code. They can create transactions with zero gas prices by design for testing purposes. This is not itself a vulnerability.

The ACTUAL vulnerability is that production validators could be configured (via governance) to accept zero gas prices, and the VM has special bypass paths for this case that were intended only for testing but remain active in production code.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L47-48)
```text
        // TODO(Gas): check if gas schedule is consistent
        let gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L91-103)
```text
    public fun set_for_next_epoch(aptos_framework: &signer, gas_schedule_blob: vector<u8>) acquires GasScheduleV2 {
        system_addresses::assert_aptos_framework(aptos_framework);
        assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));
        let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
        if (exists<GasScheduleV2>(@aptos_framework)) {
            let cur_gas_schedule = borrow_global<GasScheduleV2>(@aptos_framework);
            assert!(
                new_gas_schedule.feature_version >= cur_gas_schedule.feature_version,
                error::invalid_argument(EINVALID_GAS_FEATURE_VERSION)
            );
        };
        config_buffer::upsert(new_gas_schedule);
    }
```

**File:** aptos-move/aptos-vm/src/gas.rs (L174-192)
```rust
    // The submitted gas price is less than the minimum gas unit price set by the VM.
    // NB: MIN_PRICE_PER_GAS_UNIT may equal zero, but need not in the future. Hence why
    // we turn off the clippy warning.
    #[allow(clippy::absurd_extreme_comparisons)]
    let below_min_bound = txn_metadata.gas_unit_price() < txn_gas_params.min_price_per_gas_unit;
    if below_min_bound {
        speculative_warn!(
            log_context,
            format!(
                "[VM] Gas unit error; min {}, submitted {}",
                txn_gas_params.min_price_per_gas_unit,
                txn_metadata.gas_unit_price()
            ),
        );
        return Err(VMStatus::error(
            StatusCode::GAS_UNIT_PRICE_BELOW_MIN_BOUND,
            None,
        ));
    }
```

**File:** aptos-move/aptos-vm/src/gas.rs (L219-219)
```rust
    )? && (gas_unit_price != 0 || !features.is_default_account_resource_enabled())
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L59-65)
```rust
        // The minimum gas price that a transaction can be submitted with.
        // TODO(Gas): should probably change this to something > 0
        [
            min_price_per_gas_unit: FeePerGasUnit,
            "min_price_per_gas_unit",
            aptos_global_constants::GAS_UNIT_PRICE
        ],
```

**File:** config/global-constants/src/lib.rs (L23-26)
```rust
#[cfg(any(test, feature = "testing"))]
pub const GAS_UNIT_PRICE: u64 = 0;
#[cfg(not(any(test, feature = "testing")))]
pub const GAS_UNIT_PRICE: u64 = 100;
```

**File:** aptos-move/aptos-gas-meter/src/traits.rs (L168-173)
```rust
        // TODO(Gas): right now, some of our tests use a unit price of 0 and this is a hack
        // to avoid causing them issues. We should revisit the problem and figure out a
        // better way to handle this.
        if gas_unit_price.is_zero() {
            return Ok(0.into());
        }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L762-762)
```rust
            if gas_unit_price != 0 || !self.features().is_default_account_resource_enabled() {
```
