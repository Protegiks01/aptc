# Audit Report

## Title
Logic Inversion in Move Prover's Unconditional Abort Detection Causes Verification Bypass

## Summary
The `unconditional_abort_as_inconsistency` option in the Move Prover has inverted logic that disables abort checking when explicitly enabled and enables it when disabled. This allows contracts with unconditional aborts to pass verification with arbitrary post-conditions when security-conscious developers enable strict checking, potentially leading to deployment of vulnerable contracts that freeze user funds.

## Finding Description

The Move Prover's inconsistency check instrumenter contains a critical logic inversion bug. The `unconditional_abort_as_inconsistency` option is designed to detect functions that unconditionally abort (which can vacuously prove any post-condition). However, the implementation has the condition backwards. [1](#0-0) 

The documentation clearly states that `assert false` should be inserted before aborts when the option is **set** (enabled). However, the actual implementation does the opposite: [2](#0-1) 

The condition `(bc.is_abort() && !options.unconditional_abort_as_inconsistency)` uses negation (`!`), which means:
- When option is TRUE (enabled): abort checks are SKIPPED
- When option is FALSE (disabled): abort checks are PERFORMED

This is completely inverted from the intended behavior described in the comments. The correct condition should be `(bc.is_abort() && options.unconditional_abort_as_inconsistency)` without the negation.

**Attack Scenario:**
1. A developer creates a Move contract with a critical function (e.g., `withdraw_funds`) that has a bug causing unconditional abort
2. The developer enables `unconditional_abort_as_inconsistency` to ensure strict verification
3. Due to the inverted logic, the prover SKIPS checking aborts
4. The function passes verification with a false post-condition like `ensures balance_decreased`
5. The contract is deployed to Aptos mainnet
6. All runtime calls to this function fail, permanently freezing user funds

The bug affects any contract verified with this option enabled, which would typically be security-critical contracts where developers want maximum verification strictness.

## Impact Explanation

This qualifies as **Medium Severity** per the Aptos bug bounty criteria for the following reasons:

**State Inconsistencies Requiring Intervention**: Contracts that pass verification but always abort at runtime create a mismatch between verified behavior and actual behavior. If critical functions like withdrawals or transfers always abort, user funds can become frozen, requiring manual intervention or contract upgrades.

**Limited Funds Loss or Manipulation**: While not directly stealing funds, this bug enables deployment of contracts where fund access functions may always fail. For example, a staking pool withdrawal function that unconditionally aborts would trap all staked funds.

The impact is classified as Medium rather than Critical because:
- It requires the developer to explicitly enable the option
- It affects verification phase, not the blockchain protocol itself
- The blockchain continues to operate correctly; only specific contracts are affected
- Funds are frozen rather than stolen, and recovery may be possible through governance

However, the severity could escalate to High if this affects Aptos Framework contracts or widely-used protocols.

## Likelihood Explanation

**Likelihood: Medium-High**

This bug will affect:
- Security-conscious developers who explicitly enable strict checking
- Projects that use `Prover.toml` configuration files with this option
- Automated verification pipelines that enable comprehensive checks

The default value is `false`, so contracts verified with default settings are paradoxically safer than those with strict checking enabled. However, production-grade contracts often enable stricter verification, making this bug more likely to affect important deployments. [3](#0-2) 

The bug is particularly insidious because it inverts the developer's intent - those seeking maximum verification rigor get minimum checking.

## Recommendation

Fix the logic inversion by removing the negation operator in the condition. The corrected line 78 should be:

```rust
if bc.is_return() || (bc.is_abort() && options.unconditional_abort_as_inconsistency) {
```

This ensures that when `unconditional_abort_as_inconsistency` is TRUE, abort checking is enabled as documented.

Additionally, add integration tests that verify the option works correctly:
- Test that enabling the option causes unconditional abort functions to fail verification
- Test that disabling the option allows unconditional aborts (current default behavior)

## Proof of Concept

**Move Contract demonstrating the vulnerability:**

```move
module 0x42::VulnerableContract {
    use std::signer;
    
    struct Balance has key {
        amount: u64
    }
    
    // This function ALWAYS aborts but has a false post-condition
    public fun withdraw(account: &signer, amount: u64) {
        abort 1  // Always aborts unconditionally
    }
    
    spec withdraw {
        ensures exists<Balance>(signer::address_of(account));  // False claim - never executes
        ensures global<Balance>(signer::address_of(account)).amount == old(global<Balance>(signer::address_of(account)).amount) - amount;  // False claim
    }
}
```

**Verification Test Steps:**

1. Save the above Move module
2. Run Move Prover with `--unconditional-abort-as-inconsistency` flag enabled:
   ```bash
   cargo run -p aptos-framework -- prove \
     --unconditional-abort-as-inconsistency \
     --package vulnerable-contract
   ```
3. **Expected (correct) behavior**: Verification should FAIL with inconsistency error
4. **Actual (buggy) behavior**: Verification PASSES despite unconditional abort

With the default settings (option disabled), the abort would be checked. But when explicitly enabling strict checking, the verification incorrectly succeeds, allowing deployment of this dangerous contract.

**Runtime Demonstration:**
Once deployed, any call to `withdraw()` will fail with abort code 1, effectively freezing all funds that depend on this function.

## Notes

This vulnerability affects the Move Prover verification tool rather than the blockchain runtime itself. However, it has real security implications as it can lead to deployment of contracts that appear verified but will always fail at runtime, potentially freezing user funds or causing denial of service for critical protocol functions.

The bug is particularly dangerous because it specifically affects developers who are trying to be more security-conscious by enabling stricter verification, giving them a false sense of security.

### Citations

**File:** third_party/move/move-prover/bytecode-pipeline/src/inconsistency_check.rs (L11-21)
```rust
//! an `assert false` before
//! - every `return` and
//! - every `abort` (if the `unconditional-abort-as-inconsistency` option is set).
//! In this way, if the instrumented `assert false` can be proved, it means we have an inconsistency
//! in the specifications.
//!
//! A function that unconditionally abort might be considered as some form of inconsistency as well.
//! Consider the function `fun always_abort() { abort 0 }`, it might seem surprising that the prover
//! can prove that `spec always_abort { ensures 1 == 2; }`. If this function aborts unconditionally,
//! any post-condition can be proved. Checking of this behavior is turned-off by default, and can
//! be enabled with the `unconditional-abort-as-inconsistency` flag.
```

**File:** third_party/move/move-prover/bytecode-pipeline/src/inconsistency_check.rs (L78-85)
```rust
            if bc.is_return() || (bc.is_abort() && !options.unconditional_abort_as_inconsistency) {
                let loc = builder.fun_env.get_spec_loc();
                builder.set_loc_and_vc_info(loc, EXPECTED_TO_FAIL);
                let exp = builder.mk_bool_const(false);
                builder.emit_with(|id| Bytecode::Prop(id, PropKind::Assert, exp));
            }
            builder.emit(bc);
        }
```

**File:** third_party/move/move-prover/bytecode-pipeline/src/options.rs (L106-106)
```rust
            unconditional_abort_as_inconsistency: false,
```
