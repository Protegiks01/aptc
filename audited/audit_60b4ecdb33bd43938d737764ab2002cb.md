# Audit Report

## Title
Missing Version Range Validation in Block API Causes Panic on Database Corruption

## Summary
The `render_bcs_block()` function in `api/src/blocks.rs` and the underlying `get_block()` function in `api/src/context.rs` fail to validate that `first_version <= last_version` before performing arithmetic operations. When corrupted block data in the database causes `first_version > last_version`, the code triggers an arithmetic overflow panic due to `overflow-checks = true`, resulting in 500 Internal Server Errors for affected block queries. [1](#0-0) 

## Finding Description

The block retrieval API lacks critical validation of version range invariants. When blocks are queried via `/blocks/by_height` or `/blocks/by_version` endpoints, the code path flows through:

1. **API Layer** - `render_bcs_block()` receives `first_version` and `last_version` from `BcsBlock` without validation [2](#0-1) 

2. **Context Layer** - `get_block()` performs unchecked arithmetic: `(last_version - first_version + 1) as u16` [3](#0-2) 

3. **Storage Layer** - `to_api_block_info()` computes `last_version` as `next_block_info.first_version() - 1` without ensuring it's >= `first_version` [4](#0-3) 

**Attack Scenario:**

If the database contains blocks where Block N+1's `first_version` â‰¤ Block N's `first_version` (due to corruption, restore bugs, or manual manipulation), then:
- `last_version` for Block N = `next_block_info.first_version() - 1` < Block N's `first_version`
- The calculation `(last_version - first_version + 1)` underflows
- With `overflow-checks = true` in the release profile, this causes a panic [5](#0-4) 

The panic is caught by `tokio::task::spawn_blocking` and converted to a 500 error: [6](#0-5) 

**Invariant Violation:**

The code violates the semantic invariant documented in `BcsBlock` that `first_version` is "The first ledger version of the block inclusive" and `last_version` is "The last ledger version of the block inclusive", implying `first_version <= last_version`. [7](#0-6) 

## Impact Explanation

This vulnerability meets **High Severity** criteria per the Aptos bug bounty program:

1. **API Crashes**: Queries for corrupted blocks return 500 Internal Server Errors, making the block API unreliable
2. **Significant Protocol Violation**: The API violates its contract by failing to handle invalid database states gracefully
3. **Operational Impact**: Operators cannot distinguish between temporary failures and database corruption, hindering incident response

While this requires corrupted database state to trigger, the lack of defensive validation means legitimate infrastructure issues (hardware failures, backup/restore bugs) cause cascading failures rather than clear error messages.

## Likelihood Explanation

**Likelihood: Medium-Low**

Requires one of the following conditions:
- Database corruption from hardware/filesystem failures
- Bugs in backup/restore utilities that write blocks out of order
- State sync implementation errors
- Manual database manipulation by node operators

While these scenarios are not common in normal operation, they are realistic failure modes in production systems. The severity is amplified because once corruption occurs, the API becomes unusable for affected blocks rather than reporting the corruption clearly.

## Recommendation

Add explicit validation in multiple layers:

**1. Storage Layer Validation** - In `to_api_block_info()`:
```rust
pub(super) fn to_api_block_info(
    &self,
    block_height: u64,
    block_info: BlockInfo,
) -> Result<(Version, Version, NewBlockEvent)> {
    let committed_version = self.get_latest_ledger_info_version()?;
    ensure!(
        block_info.first_version() <= committed_version,
        "block first version {} > committed version {committed_version}",
        block_info.first_version(),
    );

    let new_block_event = self
        .ledger_db
        .event_db()
        .expect_new_block_event(block_info.first_version())?;

    let last_version = match self.get_raw_block_info_by_height(block_height + 1) {
        Ok(next_block_info) => next_block_info.first_version() - 1,
        Err(AptosDbError::NotFound(..)) => committed_version,
        Err(err) => return Err(err),
    };

    // ADD THIS VALIDATION
    ensure!(
        block_info.first_version() <= last_version,
        "Database corruption: block {} has first_version {} > last_version {}",
        block_height,
        block_info.first_version(),
        last_version
    );

    Ok((
        block_info.first_version(),
        last_version,
        bcs::from_bytes(new_block_event.event_data())?,
    ))
}
```

**2. API Layer Validation** - In `get_block()`:
```rust
fn get_block<E: StdApiError>(
    &self,
    latest_ledger_info: &LedgerInfo,
    with_transactions: bool,
    first_version: Version,
    last_version: Version,
    new_block_event: NewBlockEvent,
) -> Result<BcsBlock, E> {
    let ledger_version = latest_ledger_info.ledger_version.0;

    // ADD THIS VALIDATION
    if first_version > last_version {
        return Err(E::internal_with_code(
            format_err!("Invalid block: first_version {} > last_version {}", first_version, last_version),
            AptosErrorCode::InternalError,
            latest_ledger_info,
        ));
    }

    // ... rest of function
}
```

## Proof of Concept

```rust
#[cfg(test)]
mod test {
    use super::*;
    use aptos_storage_interface::block_info::{BlockInfo, BlockInfoV0};
    use aptos_types::account_config::NewBlockEvent;
    
    #[test]
    #[should_panic(expected = "attempt to subtract with overflow")]
    fn test_invalid_version_range_causes_panic() {
        // Simulate corrupted block data where next block's first_version
        // is less than current block's first_version
        let first_version: u64 = 100;
        let last_version: u64 = 99;  // Invalid: last < first
        
        // This calculation will panic due to overflow-checks = true
        let _max_txns = (last_version - first_version + 1) as u16;
    }
    
    #[tokio::test]
    async fn test_block_api_returns_500_on_corrupted_data() {
        // Integration test would require:
        // 1. Set up test database with corrupted blocks
        // 2. Query block via API
        // 3. Verify 500 error response
        // 
        // This demonstrates the API failure mode when validation is missing
    }
}
```

To properly test this in a full environment, create a database with blocks stored out of order:
1. Manually insert Block N with `first_version = 100`
2. Manually insert Block N+1 with `first_version = 95` (violating ordering)
3. Query Block N via the API
4. Observe 500 Internal Server Error instead of clear corruption error

## Notes

This vulnerability highlights the importance of defensive programming in storage layers. Even though database corruption should be rare, the code should detect and report it clearly rather than panicking. The current implementation fails both fail-safe (panics instead of graceful degradation) and fail-secure (doesn't validate invariants) principles.

The validation should be added at the storage layer to catch corruption as early as possible, and defensively at the API layer to ensure no code path can trigger arithmetic overflow on untrusted data from storage.

### Citations

**File:** api/src/blocks.rs (L139-172)
```rust
    fn render_bcs_block(
        &self,
        accept_type: &AcceptType,
        latest_ledger_info: LedgerInfo,
        bcs_block: BcsBlock,
    ) -> BasicResultWith404<Block> {
        match accept_type {
            AcceptType::Json => {
                let transactions = if let Some(inner) = bcs_block.transactions {
                    Some(self.context.render_transactions_sequential(
                        &latest_ledger_info,
                        inner,
                        bcs_block.block_timestamp,
                    )?)
                } else {
                    None
                };
                let block = Block {
                    block_height: bcs_block.block_height.into(),
                    block_hash: bcs_block.block_hash.into(),
                    block_timestamp: bcs_block.block_timestamp.into(),
                    first_version: bcs_block.first_version.into(),
                    last_version: bcs_block.last_version.into(),
                    transactions,
                };
                BasicResponse::try_from_json((block, &latest_ledger_info, BasicResponseStatus::Ok))
            },
            AcceptType::Bcs => BasicResponse::try_from_bcs((
                bcs_block,
                &latest_ledger_info,
                BasicResponseStatus::Ok,
            )),
        }
    }
```

**File:** api/src/context.rs (L707-710)
```rust
        let max_txns = std::cmp::min(
            self.node_config.api.max_block_transactions_page_size,
            (last_version - first_version + 1) as u16,
        );
```

**File:** api/src/context.rs (L1645-1654)
```rust
pub async fn api_spawn_blocking<F, T, E>(func: F) -> Result<T, E>
where
    F: FnOnce() -> Result<T, E> + Send + 'static,
    T: Send + 'static,
    E: InternalError + Send + 'static,
{
    tokio::task::spawn_blocking(func)
        .await
        .map_err(|err| E::internal_with_code_no_info(err, AptosErrorCode::InternalError))?
}
```

**File:** storage/aptosdb/src/db/aptosdb_internal.rs (L394-398)
```rust
        let last_version = match self.get_raw_block_info_by_height(block_height + 1) {
            Ok(next_block_info) => next_block_info.first_version() - 1,
            Err(AptosDbError::NotFound(..)) => committed_version,
            Err(err) => return Err(err),
        };
```

**File:** Cargo.toml (L921-923)
```text
[profile.release]
debug = true
overflow-checks = true
```

**File:** api/types/src/block.rs (L35-38)
```rust
    /// The first ledger version of the block inclusive
    pub first_version: u64,
    /// The last ledger version of the block inclusive
    pub last_version: u64,
```
