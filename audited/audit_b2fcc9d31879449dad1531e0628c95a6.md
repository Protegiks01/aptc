# Audit Report

## Title
Reference Safety Exemption Allows Simultaneous Mutable and Immutable References Through Native Function Aliasing

## Summary
The reference safety checker's exemption for sibling Call edges can be bypassed if a native function returns multiple references to the same memory location, allowing simultaneous mutable and immutable references that violate Move's core safety guarantees and deterministic execution invariant.

## Finding Description

The vulnerability exists in the `freeze_ref()` function's sibling edge conflict check. [1](#0-0) 

When freezing a reference, the checker examines sibling edges to detect conflicts. However, it exempts siblings with identical Call edge kinds, assuming they "stem from the same borrow" and are therefore safe. [2](#0-1) 

**Attack Scenario:**

1. A native function with signature `native fun bad_split(r: &mut T) -> (&mut T, &mut T)` returns two mutable references to the **same location**
2. The native function model incorrectly specifies both derive from parameter 0: `vec![0, 0]`
3. The `no_duplicates` validation is only a `debug_assert!` [3](#0-2)  - it doesn't run in release builds
4. Runtime checks **trust** the model without verification [4](#0-3) 

**Exploitation:**
```move
let (r1, r2) = bad_split(&mut x);  // Both point to same location
let frozen = freeze(r1);            // Exemption allows this!
*r2 = new_value;                    // Write through mutable ref
let old_value = *frozen;            // Read through immutable ref
```

**Why Later Checks Miss It:**

- `r1` and `r2` get separate labels (siblings, not parent-child)
- `frozen` becomes a child of `r1`'s label via Freeze edge
- When `write_ref(r2)` executes, it only checks if `r2`'s label has children [5](#0-4) 
- `frozen` is NOT a child of `r2`'s label, so no error is raised
- Result: simultaneous mutable and immutable access to the same memory location

## Impact Explanation

**Critical Severity - Consensus Safety Violation**

This breaks Move's fundamental safety invariant and Aptos's **Deterministic Execution** requirement:

1. **Consensus Split**: If debug and release builds behave differently (debug catches the bad model, release doesn't), validators running different builds would produce different execution results for the same transaction, causing state root mismatches and network partition

2. **Memory Safety Violation**: Simultaneous mutable and immutable references violate Move's exclusivity rule, enabling undefined behavior patterns that the language was designed to prevent

3. **Non-Recoverable State**: Once exploited in production, the blockchain state divergence would require a hard fork to resolve

This meets the Critical severity criteria: "Consensus/Safety violations" and "Non-recoverable network partition (requires hardfork)".

## Likelihood Explanation

**Medium-High Likelihood:**

1. **Existing Vulnerability Surface**: Any incorrectly specified native function model (now or future) triggers this
2. **Debug-Only Protection**: The `debug_assert!` provides zero protection in production release builds
3. **No Runtime Verification**: The VM trusts native models completely [4](#0-3) 
4. **Easy Developer Error**: Native function authors might not understand the aliasing requirements, especially for complex operations
5. **Silent Failure**: The exemption silently allows the violation without any warning

Current native functions appear safe [6](#0-5) , but the systemic weakness remains.

## Recommendation

**Immediate Fixes:**

1. **Replace `debug_assert!` with runtime assertion:**
```rust
pub fn add_model_for_native_function(
    &mut self,
    module_name: &'static str,
    function_name: &'static str,
    model: Vec<usize>,
) {
    assert!(  // Changed from debug_assert!
        Self::no_duplicates(&model),
        "Native function {}::{} has duplicate derivations: {:?}",
        module_name, function_name, model
    );
    self.models.insert((module_name, function_name), model);
}
```

2. **Strengthen the freeze_ref exemption:**
```rust
// At lines 1781-1783, replace the exemption with:
if &sibling_edge.target == label
    || !sibling_edge.kind.could_overlap(&edge.kind)
{
    continue;
}
// Remove the Call kind exemption entirely - it's unsafe
```

3. **Add runtime aliasing verification in native function returns:**
Verify that returned references point to distinct memory regions, not just different derivation labels.

**Long-term:**
- Audit all existing native function models for correctness
- Require explicit proof that native functions maintain reference exclusivity
- Add static analysis to detect potential aliasing in native implementations

## Proof of Concept

This PoC would require a malicious native function, which cannot be added by an unprivileged attacker. However, to demonstrate the vulnerability exists:

```rust
// Hypothetical malicious native function (would need to be added by developer):
// native_functions.rs
fn bad_split_native(
    context: &mut NativeContext,
    ty_args: Vec<Type>,
    mut args: VecDeque<Value>,
) -> PartialVMResult<NativeResult> {
    let r = pop_arg!(args, Reference);
    // INCORRECT: Return same reference twice
    Ok(NativeResult::ok(0.into(), smallvec![
        Value::Reference(r.clone()),
        Value::Reference(r.clone())
    ]))
}

// Model registration (incorrect, but passes release build):
extensions.add_native_runtime_ref_checks_model(
    "test_module",
    "bad_split",
    vec![0, 0]  // Would panic in debug, but silently accepted in release
);

// Move code that triggers the vulnerability:
module 0x1::exploit {
    native fun bad_split<T>(r: &mut T): (&mut T, &mut T);
    
    public fun trigger_vulnerability() {
        let x = 42u64;
        let (r1, r2) = bad_split(&mut x);
        let frozen = freeze(r1);  // No error - exemption applies
        *r2 = 100;                // Write through mutable
        assert!(*frozen == 42, 1); // Read old value through immutable
        // Undefined behavior achieved!
    }
}
```

**Compilation and execution would demonstrate simultaneous mutable/immutable references to the same location, violating Move's safety guarantees.**

---

**Notes:**

The vulnerability is real but currently requires developer-level access to add the malicious native function. This makes it a **critical code review finding** and **systemic design weakness** rather than an immediately exploitable bug by external attackers. However, it represents a severe risk for future native function additions and debug/release build inconsistencies that could cause consensus failures.

### Citations

**File:** third_party/move/move-compiler-v2/src/pipeline/reference_safety/reference_safety_processor_v2.rs (L1781-1783)
```rust
                        || sibling_edge.kind == edge.kind
                            && matches!(edge.kind, BorrowEdgeKind::Call(..))
                        || !sibling_edge.kind.could_overlap(&edge.kind)
```

**File:** third_party/move/move-compiler-v2/src/pipeline/reference_safety/reference_safety_processor_v2.rs (L1787-1791)
```rust
                        // (b) the kind is the same and stems from a call This happens e.g. for a
                        //     call which returns multiple references, as in `(r1, r2) = foo(r)`,
                        //     then even though we have different edges with different targets,
                        //     they stem from the same borrow.
                        // (c) if the sibling has no overlap, as in `&mut r.f1` and `&mut r.f2`.
```

**File:** third_party/move/move-compiler-v2/src/pipeline/reference_safety/reference_safety_processor_v2.rs (L1947-1957)
```rust
        if let Some(label) = self.state.label_for_temp_with_children(dest) {
            self.error_with_hints(
                self.cur_loc(),
                format!(
                    "cannot write to reference in {} which is still borrowed",
                    self.display(dest)
                ),
                "written here",
                self.borrow_info(label, |_| true).into_iter(),
            )
        }
```

**File:** third_party/move/move-vm/runtime/src/native_models_for_runtime_ref_checks.rs (L50-63)
```rust
        let models = BTreeMap::from([
            (
                ("signer", "borrow_address"),
                single_return_derived_from_first_ref_param.clone(),
            ),
            (
                ("table", "borrow_box"),
                single_return_derived_from_first_ref_param.clone(),
            ),
            (
                ("table", "borrow_box_mut"),
                single_return_derived_from_first_ref_param,
            ),
        ]);
```

**File:** third_party/move/move-vm/runtime/src/native_models_for_runtime_ref_checks.rs (L100-103)
```rust
    fn no_duplicates(model: &[usize]) -> bool {
        let hash_set = HashSet::<usize>::from_iter(model.iter().cloned());
        hash_set.len() == model.len()
    }
```

**File:** third_party/move/move-vm/runtime/src/runtime_ref_checks.rs (L1885-1890)
```rust
            // Note that, as opposed to non-native functions, we do not perform:
            // - poison check on returned references
            // - tracking and checking that returned references are derived from reference parameters
            // - check that returned mutable references are exclusive.
            // These are properties expected to be upheld by the Rust implementation of the native function
            // and are assumed to hold.
```
