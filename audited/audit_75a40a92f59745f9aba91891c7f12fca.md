# Audit Report

## Title
Integer Overflow in Backup Metadata Continuity Validation Allows Bypass Through Wrapping Semantics

## Summary
The backup system uses unchecked integer addition when validating version continuity across transaction backups. When `backup.last_version` equals `u64::MAX`, the operation `next_ver = backup.last_version + 1` silently wraps to `0` in release builds, allowing crafted malicious backup metadata to bypass continuity checks and potentially corrupt restored blockchain state.

## Finding Description

The vulnerability exists in multiple locations within the backup system where version numbers are incremented without overflow checking: [1](#0-0) [2](#0-1) [3](#0-2) [4](#0-3) 

The Aptos codebase explicitly mandates checked arithmetic for all integer operations to prevent silent overflow: [5](#0-4) 

In contrast, similar version arithmetic in the state-sync system correctly uses `checked_add`: [6](#0-5) 

**Attack Path:**

1. Attacker gains write access to backup storage (e.g., misconfigured cloud storage, leaked credentials)
2. Attacker crafts malicious backup metadata:
   - Backup A: `first_version=0, last_version=u64::MAX`
   - Backup B: `first_version=0, last_version=1000`
3. When `select_transaction_backups()` processes these:
   - After Backup A: `next_ver = u64::MAX + 1` wraps to `0`
   - When validating Backup B: expects `backup.first_version == 0`, which matches
4. Overlapping/discontinuous backups pass validation, corrupting the database during restore

This breaks the **State Consistency** invariant requiring atomic and verifiable state transitions. [7](#0-6) 

## Impact Explanation

This qualifies as **Medium Severity** per Aptos bug bounty criteria: "State inconsistencies requiring intervention."

The vulnerability enables:
- Bypass of backup continuity validation checks
- Restoration of corrupted or inconsistent blockchain state
- Potential database corruption requiring manual intervention
- Undermining of backup integrity guarantees

While the backup system assumes trusted storage, defense-in-depth principles require validating even trusted inputs. Backup storage compromise is a realistic threat vector (cloud misconfigurations, credential leaks, supply chain attacks).

## Likelihood Explanation

**Likelihood: Medium-Low**

Required preconditions:
- Attacker compromises backup storage infrastructure (cloud storage, credentials)
- Victim performs restore operation from compromised backups
- Attacker understands the wrapping behavior to craft exploitable metadata

While backup storage compromise is not trivial, it's more accessible than validator compromise and represents a realistic enterprise security risk. The consistent violation of coding standards across multiple locations suggests this was an oversight rather than intentional design.

## Recommendation

Replace all unchecked version arithmetic with `checked_add()` and return appropriate errors on overflow, consistent with the state-sync implementation pattern:

**Fix for `view.rs:156`:**
```rust
next_ver = backup.last_version
    .checked_add(1)
    .ok_or_else(|| anyhow!("Version overflow in backup continuity check: last_version={}", backup.last_version))?;
```

**Fix for `mod.rs:125, 135`:**
```rust
next_version = backup_meta.last_version
    .checked_add(1)
    .ok_or_else(|| anyhow!("Version overflow in transaction backup compaction"))?;
```

**Fix for `manifest.rs:76`:**
```rust
next_version = chunk.last_version
    .checked_add(1)
    .ok_or_else(|| anyhow!("Version overflow in chunk validation: last_version={}", chunk.last_version))?;
```

This approach mirrors the error handling pattern already established in the state-sync system: [8](#0-7) 

## Proof of Concept

```rust
#[test]
fn test_version_overflow_bypass() {
    use crate::metadata::{TransactionBackupMeta, Metadata};
    use crate::metadata::view::MetadataView;
    use crate::storage::FileHandle;
    use aptos_types::transaction::Version;
    
    // Create malicious backup metadata with u64::MAX
    let backup1 = TransactionBackupMeta {
        first_version: 0,
        last_version: u64::MAX,
        manifest: FileHandle::from("backup1.manifest".to_string()),
    };
    
    // Second backup with first_version=0 (should be rejected but wrapping allows it)
    let backup2 = TransactionBackupMeta {
        first_version: 0,  // Overlaps with backup1!
        last_version: 1000,
        manifest: FileHandle::from("backup2.manifest".to_string()),
    };
    
    let metadata = vec![
        Metadata::TransactionBackup(backup1),
        Metadata::TransactionBackup(backup2),
    ];
    
    let view = MetadataView::new(metadata, vec![]);
    
    // This should fail due to overlapping ranges, but wrapping allows it to pass
    let result = view.select_transaction_backups(0, 1000);
    
    // With current code: passes (VULNERABLE)
    // With fixed code: returns error (SECURE)
    assert!(result.is_err(), "Overlapping backups should be rejected");
}
```

**Notes:**
- The vulnerability affects multiple critical paths in backup validation and restoration
- Similar patterns exist in epoch ending backup validation requiring the same fix
- The state-sync subsystem demonstrates the correct implementation pattern
- This represents a systematic violation of documented Aptos coding standards for integer arithmetic

### Citations

**File:** storage/backup/backup-cli/src/metadata/view.rs (L145-150)
```rust
            ensure!(
                backup.first_version == next_ver,
                "Transaction backup ranges not continuous, expecting version {}, got {}.",
                next_ver,
                backup.first_version,
            );
```

**File:** storage/backup/backup-cli/src/metadata/view.rs (L156-156)
```rust
            next_ver = backup.last_version + 1;
```

**File:** storage/backup/backup-cli/src/metadata/mod.rs (L125-125)
```rust
        let mut next_version = backup_meta.last_version + 1;
```

**File:** storage/backup/backup-cli/src/metadata/mod.rs (L135-135)
```rust
            next_version = backup.last_version + 1;
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/manifest.rs (L76-76)
```rust
            next_version = chunk.last_version + 1;
```

**File:** RUST_CODING_STYLE.md (L220-230)
```markdown
### Integer Arithmetic

As every integer operation (`+`, `-`, `/`, `*`, etc.) implies edge-cases (e.g. overflow `u64::MAX + 1`, underflow `0u64 -1`, division by zero, etc.),
we use checked arithmetic instead of directly using math symbols.
It forces us to think of edge-cases, and handle them explicitly.
This is a brief and simplified mini guide of the different functions that exist to handle integer arithmetic:

- [checked\_](https://doc.rust-lang.org/std/primitive.u32.html#method.checked_add): use this function if you want to handle overflow and underflow as a special edge-case. It returns `None` if an underflow or overflow has happened, and `Some(operation_result)` otherwise.
- [overflowing\_](https://doc.rust-lang.org/std/primitive.u32.html#method.overflowing_add): use this function if you want the result of an overflow to potentially wrap around (e.g. `u64::MAX.overflow_add(10) == (9, true)`). It returns the underflowed or overflowed result as well as a flag indicating if an overflow has occurred or not.
- [wrapping\_](https://doc.rust-lang.org/std/primitive.u32.html#method.wrapping_add): this is similar to overflowing operations, except that it returns the result directly. Use this function if you are sure that you want to handle underflow and overflow by wrapping around.
- [saturating\_](https://doc.rust-lang.org/std/primitive.u32.html#method.saturating_add): if an overflow occurs, the result is kept within the boundary of the type (e.g. `u64::MAX.saturating_add(1) == u64::MAX`).
```

**File:** state-sync/data-streaming-service/src/stream_engine.rs (L568-571)
```rust
        let last_received_version = request_start_version
            .checked_add(num_received_versions as u64)
            .and_then(|version| version.checked_sub(1))
            .ok_or_else(|| Error::IntegerOverflow("Last received version has overflown!".into()))?;
```

**File:** state-sync/data-streaming-service/src/error.rs (L16-17)
```rust
    #[error("An integer overflow has occurred: {0}")]
    IntegerOverflow(String),
```
