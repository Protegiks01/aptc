# Audit Report

## Title
Incomplete Test Native Detection Allowing Event Introspection Natives in Production Builds

## Summary
The `assert_no_test_natives()` function in `aptos-move/aptos-vm/src/natives.rs` contains a name mismatch bug that fails to detect test-only event introspection natives (`emitted_events` and `emitted_events_by_handle`) if the 'testing' feature is accidentally enabled in production builds. While critical authentication-bypass natives are correctly detected, this gap in the detection mechanism represents a defense-in-depth weakness.

## Finding Description
The security question asks how to detect if the 'testing' feature is accidentally enabled in production. Aptos implements a runtime check at node startup via `assert_no_test_natives()` that validates no test-only native functions are present. [1](#0-0) 

This check iterates through all registered natives and fails if specific test-only functions are found: [2](#0-1) 

However, there is a name mismatch bug at line 186. The check looks for `event::emitted_events_internal`, but the actual test-only event natives registered are: [3](#0-2) 

The natives are named `emitted_events` and `emitted_events_by_handle`, not `emitted_events_internal`. This means if the testing feature is enabled, these event introspection natives would bypass detection and remain available in production.

**Impact on Detection:**
- ✓ **Correctly detected:** `unit_test::create_signers_for_testing`, all crypto test natives
- ✗ **Not detected:** `event::emitted_events`, `event::emitted_events_by_handle`

## Impact Explanation
This issue has **LIMITED impact** that does NOT meet the Medium severity threshold for the following reasons:

1. **Event natives are information disclosure only** - They allow reading emitted events but cannot modify state, bypass authentication, or steal funds
2. **Critical natives ARE detected** - The authentication bypass natives (`create_signers_for_testing`) and cryptographic test natives are correctly caught
3. **Multiple preconditions required**:
   - Testing feature must be accidentally enabled in production build
   - Attacker must deploy a custom Move module declaring these natives
   - The on-chain framework's `#[test_only]` declarations are stripped in production

The event introspection capability would allow an attacker to query events emitted during transaction execution, which is sensitive information but not catastrophic. [4](#0-3) 

## Likelihood Explanation
**Likelihood: VERY LOW**

1. **Build misconfiguration unlikely**: Modern Cargo build practices and CI/CD pipelines make accidental feature enabling rare
2. **Detection exists for critical natives**: The startup check successfully prevents the most dangerous scenario (authentication bypass)
3. **Error message guidance**: The panic message provides clear instructions to resolve feature unification issues [5](#0-4) 

However, this bug demonstrates that the detection mechanism relies on manual maintenance and is error-prone.

## Recommendation
**Fix the name mismatch** and implement automated verification:

```rust
pub fn assert_no_test_natives(err_msg: &str) {
    assert!(
        aptos_natives(
            LATEST_GAS_FEATURE_VERSION,
            NativeGasParameters::zeros(),
            MiscGasParameters::zeros(),
            TimedFeaturesBuilder::enable_all().build(),
            Features::default()
        )
        .into_iter()
        .all(|(_, module_name, func_name, _)| {
            !(module_name.as_str() == "unit_test"
                && func_name.as_str() == "create_signers_for_testing"
                || module_name.as_str() == "ed25519"
                    && func_name.as_str() == "generate_keys_internal"
                || module_name.as_str() == "ed25519" && func_name.as_str() == "sign_internal"
                || module_name.as_str() == "multi_ed25519"
                    && func_name.as_str() == "generate_keys_internal"
                || module_name.as_str() == "multi_ed25519" && func_name.as_str() == "sign_internal"
                || module_name.as_str() == "bls12381"
                    && func_name.as_str() == "generate_keys_internal"
                || module_name.as_str() == "bls12381" && func_name.as_str() == "sign_internal"
                || module_name.as_str() == "bls12381"
                    && func_name.as_str() == "generate_proof_of_possession_internal"
                // FIX: Correct the event native names
                || module_name.as_str() == "event"
                    && (func_name.as_str() == "emitted_events" 
                        || func_name.as_str() == "emitted_events_by_handle"))
        }),
        "{}",
        err_msg
    )
}
```

**Additional recommendations:**
1. Add compile-time feature validation in build scripts
2. Create an integration test that verifies all `#[cfg(feature = "testing")]` natives are listed in the check
3. Consider using a whitelist approach instead of hardcoded names

## Proof of Concept
This is a detection mechanism bug, not an exploitable vulnerability. To demonstrate:

1. Compile `aptos-node` with the testing feature:
```bash
cargo build --release --features testing -p aptos-node
```

2. The node will start successfully (demonstrating the bug) because event natives are not detected

3. However, attempting to call critical natives would still fail because they ARE detected:
```
thread 'main' panicked at aptos-node/src/main.rs:23:5:
aptos-node was compiled with feature flags that shouldn't be enabled.
```

This demonstrates the detection works for critical natives but has a gap for event natives.

---

**Notes:**
This finding does NOT meet the threshold for a reportable vulnerability under the strict criteria because:
- Impact is information disclosure only (below Medium severity)
- Critical authentication-bypass protections remain intact
- The detection mechanism successfully prevents the most severe attack scenarios

However, it represents a code quality issue and defense-in-depth weakness that should be addressed to maintain robust security guarantees.

### Citations

**File:** aptos-node/src/main.rs (L21-23)
```rust
fn main() {
    // Check that we are not including any Move test natives
    aptos_vm::natives::assert_no_test_natives(ERROR_MSG_BAD_FEATURE_FLAGS);
```

**File:** aptos-move/aptos-vm/src/natives.rs (L161-191)
```rust
pub fn assert_no_test_natives(err_msg: &str) {
    assert!(
        aptos_natives(
            LATEST_GAS_FEATURE_VERSION,
            NativeGasParameters::zeros(),
            MiscGasParameters::zeros(),
            TimedFeaturesBuilder::enable_all().build(),
            Features::default()
        )
        .into_iter()
        .all(|(_, module_name, func_name, _)| {
            !(module_name.as_str() == "unit_test"
                && func_name.as_str() == "create_signers_for_testing"
                || module_name.as_str() == "ed25519"
                    && func_name.as_str() == "generate_keys_internal"
                || module_name.as_str() == "ed25519" && func_name.as_str() == "sign_internal"
                || module_name.as_str() == "multi_ed25519"
                    && func_name.as_str() == "generate_keys_internal"
                || module_name.as_str() == "multi_ed25519" && func_name.as_str() == "sign_internal"
                || module_name.as_str() == "bls12381"
                    && func_name.as_str() == "generate_keys_internal"
                || module_name.as_str() == "bls12381" && func_name.as_str() == "sign_internal"
                || module_name.as_str() == "bls12381"
                    && func_name.as_str() == "generate_proof_of_possession_internal"
                || module_name.as_str() == "event"
                    && func_name.as_str() == "emitted_events_internal")
        }),
        "{}",
        err_msg
    )
}
```

**File:** aptos-move/framework/src/natives/event.rs (L334-341)
```rust
    #[cfg(feature = "testing")]
    natives.extend([(
        "emitted_events_by_handle",
        native_emitted_events_by_handle as RawSafeNative,
    )]);

    #[cfg(feature = "testing")]
    natives.extend([("emitted_events", native_emitted_events as RawSafeNative)]);
```

**File:** aptos-move/framework/aptos-framework/sources/event.move (L24-25)
```text
    #[test_only]
    public native fun emitted_events<T: drop + store>(): vector<T>;
```

**File:** aptos-node/src/utils.rs (L19-29)
```rust
/// Error message to display when non-production features are enabled
pub const ERROR_MSG_BAD_FEATURE_FLAGS: &str = r#"
aptos-node was compiled with feature flags that shouldn't be enabled.

This is caused by cargo's feature unification.
When you compile two crates with a shared dependency, if one enables a feature flag for the dependency, then it is also enabled for the other crate.

To resolve this issue, try the following methods:
- Recompile `aptos-node` SEPARATELY
- Check if a disallowed feature flag is enabled by a dependency in the build tree
"#;
```
