# Audit Report

## Title
Mixed-Version Batch Message Causes Panic in Batch Coordinator Spawned Task

## Summary
A malicious network peer can trigger a panic in the batch coordinator's spawned task by sending a `ConsensusMsg::BatchMsgV2` message containing mixed V1 and V2 batches. The vulnerability occurs because `persist_and_send_digests()` only checks the first batch's version to determine the processing path, but attempts to convert all batches, causing a panic when V2 batches are encountered in the V1 conversion path.

## Finding Description
The vulnerability exists in the batch version handling logic within the quorum store batch coordinator. The system supports two batch versions (V1 and V2) represented by the `BatchInfoExt` enum with `V1` and `V2` variants. [1](#0-0) 

Network messages can be either `ConsensusMsg::BatchMsg` (containing only V1 batches) or `ConsensusMsg::BatchMsgV2` (containing `BatchInfoExt` which can be either V1 or V2). Both message types are converted to `VerifiedEvent::BatchMsg(Box<BatchMsg<BatchInfoExt>>)` after verification. [2](#0-1) 

The vulnerability occurs in `persist_and_send_digests()` where the code only checks the first batch to determine if all batches are V2: [3](#0-2) 

The problematic flow:
1. Line 102 checks only `persist_requests[0].batch_info().is_v2()`
2. If false (first batch is V1), execution proceeds to the else branch at line 112
3. Line 113 calls `batch_store.persist(persist_requests)` with ALL batches
4. Line 115-118 asserts only the FIRST signed batch info is not V2
5. Line 122-125 attempts to convert ALL signed batch infos using `.try_into().expect("Batch must be V1 batch")`

The `TryFrom` implementation for converting `SignedBatchInfo<BatchInfoExt>` to `SignedBatchInfo<BatchInfo>` explicitly checks that the batch must be V1: [4](#0-3) 

When `batch_store.persist()` processes batches, it preserves their version - V2 batches remain V2 in the output: [5](#0-4) 

**Attack Path:**
1. Attacker crafts a `ConsensusMsg::BatchMsgV2` message
2. The message contains a `BatchMsg<BatchInfoExt>` with:
   - First batch: `Batch<BatchInfoExt>` with `BatchInfoExt::V1 { ... }`
   - Subsequent batches: `Batch<BatchInfoExt>` with `BatchInfoExt::V2 { ... }`
3. The message passes all validation checks (no version consistency check exists)
4. After verification, it becomes `VerifiedEvent::BatchMsg` and is forwarded to BatchCoordinator
5. In `persist_and_send_digests()`, the first batch check passes (is_v2() == false)
6. The code enters the V1 processing path (else branch)
7. `batch_store.persist()` returns mixed V1 and V2 signed batch infos
8. The assertion at line 115-118 passes (only checks first)
9. Line 124's `try_into()` fails on the first V2 signed batch info
10. The `.expect("Batch must be V1 batch")` triggers a panic in the spawned tokio task

The `BatchMsg::verify()` method does not check for version consistency across batches: [6](#0-5) 

## Impact Explanation
This vulnerability qualifies as **High Severity** per Aptos bug bounty criteria:

- **Validator node slowdowns**: The panic occurs in a spawned tokio task responsible for persisting and sending batch digests. While the main node process doesn't crash, the panic disrupts quorum store batch processing functionality.

- **Significant protocol violations**: The quorum store is a critical component for transaction batching and consensus. Disrupting batch processing affects the node's ability to participate effectively in consensus.

- **No privilege required**: Any network peer can send a `ConsensusMsg::BatchMsgV2` message without validator privileges, making this easily exploitable.

The impact is limited to the specific spawned task and doesn't cause complete node failure, but it degrades the node's quorum store functionality which could affect network liveness if multiple nodes are targeted.

## Likelihood Explanation
**Likelihood: High**

- **Low Complexity**: Crafting the malicious message requires only basic knowledge of the serialization format for `ConsensusMsg::BatchMsgV2`
- **No Prerequisites**: No validator credentials or special network position required
- **Easily Repeatable**: Attacker can continuously send malicious messages to multiple nodes
- **No Detection**: The panic occurs in a spawned task, making it less obvious than main process crashes
- **Network Exposure**: All consensus nodes accept network messages from peers, providing attack surface

## Recommendation
Add explicit version consistency validation to prevent mixed-version batches:

**Option 1: Add validation in `BatchMsg::verify()`**
```rust
pub fn verify(
    &self,
    peer_id: PeerId,
    max_num_batches: usize,
    verifier: &ValidatorVerifier,
) -> anyhow::Result<()> {
    ensure!(!self.batches.is_empty(), "Empty message");
    ensure!(
        self.batches.len() <= max_num_batches,
        "Too many batches: {} > {}",
        self.batches.len(),
        max_num_batches
    );
    
    // NEW: Ensure all batches have consistent versions
    if !self.batches.is_empty() {
        let first_is_v2 = self.batches[0].batch_info().is_v2();
        for batch in self.batches.iter().skip(1) {
            ensure!(
                batch.batch_info().is_v2() == first_is_v2,
                "Inconsistent batch versions in message: expected all {}, found mixed",
                if first_is_v2 { "V2" } else { "V1" }
            );
        }
    }
    
    let epoch_authors = verifier.address_to_validator_index();
    for batch in self.batches.iter() {
        ensure!(
            epoch_authors.contains_key(&batch.author()),
            "Invalid author {} for batch {} in current epoch",
            batch.author(),
            batch.digest()
        );
        ensure!(
            batch.author() == peer_id,
            "Batch author doesn't match sender"
        );
        batch.verify()?
    }
    Ok(())
}
```

**Option 2: Fix `persist_and_send_digests()` to check all batches**
```rust
fn persist_and_send_digests(
    &self,
    persist_requests: Vec<PersistedValue<BatchInfoExt>>,
    approx_created_ts_usecs: u64,
) {
    if persist_requests.is_empty() {
        return;
    }

    // NEW: Check ALL batches for consistent version
    let all_v2 = persist_requests.iter().all(|req| req.batch_info().is_v2());
    let all_v1 = persist_requests.iter().all(|req| !req.batch_info().is_v2());
    
    if !all_v2 && !all_v1 {
        error!("Mixed batch versions detected, rejecting batch set");
        return;
    }

    let batch_store = self.batch_store.clone();
    let network_sender = self.network_sender.clone();
    let sender_to_proof_manager = self.sender_to_proof_manager.clone();
    tokio::spawn(async move {
        // Rest of the function unchanged
        ...
    });
}
```

**Recommended approach**: Implement Option 1 as it prevents the issue at the validation boundary, making it a defense-in-depth measure.

## Proof of Concept

```rust
#[cfg(test)]
mod test_mixed_batch_panic {
    use super::*;
    use aptos_consensus_types::proof_of_store::{BatchInfo, BatchInfoExt};
    use aptos_types::PeerId;
    use aptos_crypto::HashValue;
    use aptos_types::quorum_store::BatchId;

    #[tokio::test]
    async fn test_mixed_version_batch_causes_panic() {
        // Setup: Create a BatchMsg with mixed V1 and V2 batches
        
        let author = PeerId::random();
        let batch_id_1 = BatchId::new_random();
        let batch_id_2 = BatchId::new_random();
        
        // Create V1 batch (first batch)
        let v1_batch_info = BatchInfoExt::new_v1(
            author,
            batch_id_1,
            1, // epoch
            1000, // expiration
            HashValue::random(),
            10, // num_txns
            1000, // num_bytes
            0, // gas_bucket_start
        );
        
        // Create V2 batch (second batch)  
        let v2_batch_info = BatchInfoExt::new_v2(
            author,
            batch_id_2,
            1, // epoch
            1000, // expiration
            HashValue::random(),
            10, // num_txns
            1000, // num_bytes
            0, // gas_bucket_start
            BatchKind::Normal,
        );
        
        // Create batches with payload
        let v1_batch = Batch::new_for_test(v1_batch_info, vec![]);
        let v2_batch = Batch::new_for_test(v2_batch_info, vec![]);
        
        // Create BatchMsg with MIXED versions
        let mixed_batch_msg = BatchMsg::new(vec![v1_batch, v2_batch]);
        
        // Simulate network reception and processing
        // When this message is processed by BatchCoordinator,
        // persist_and_send_digests() will:
        // 1. Check first batch: is_v2() = false
        // 2. Take V1 path
        // 3. Call batch_store.persist() which returns mixed signed infos
        // 4. Panic when trying to convert V2 signed info on line 124
        
        // The panic will occur in the spawned tokio task:
        // thread 'tokio-runtime-worker' panicked at 'Batch must be V1 batch'
        
        println!("This PoC demonstrates the attack vector.");
        println!("First batch is V1: {}", !mixed_batch_msg.batches[0].batch_info().is_v2());
        println!("Second batch is V2: {}", mixed_batch_msg.batches[1].batch_info().is_v2());
        println!("This mixed-version message will cause a panic when processed.");
    }
}
```

## Notes
- The vulnerability requires the attacker to be able to send network messages to consensus nodes, which is standard P2P network connectivity
- The panic occurs in a spawned tokio task, not the main task, so the node continues running but with degraded quorum store functionality
- Repeated exploitation could significantly degrade a node's ability to participate in consensus
- The root cause is the assumption that batch version consistency is enforced at message construction time, but no runtime validation exists
- Both V1-only messages (`ConsensusMsg::BatchMsg`) and properly constructed V2-only messages are safe - only mixed-version V2 messages trigger the panic

### Citations

**File:** consensus/consensus-types/src/proof_of_store.rs (L195-203)
```rust
pub enum BatchInfoExt {
    V1 {
        info: BatchInfo,
    },
    V2 {
        info: BatchInfo,
        extra: ExtraBatchInfo,
    },
}
```

**File:** consensus/consensus-types/src/proof_of_store.rs (L520-539)
```rust
impl TryFrom<SignedBatchInfo<BatchInfoExt>> for SignedBatchInfo<BatchInfo> {
    type Error = anyhow::Error;

    fn try_from(signed_batch_info: SignedBatchInfo<BatchInfoExt>) -> Result<Self, Self::Error> {
        ensure!(
            matches!(signed_batch_info.batch_info(), &BatchInfoExt::V1 { .. }),
            "Batch must be V1 type"
        );
        let SignedBatchInfo {
            info,
            signer,
            signature,
        } = signed_batch_info;
        Ok(Self {
            info: info.unpack_info(),
            signer,
            signature,
        })
    }
}
```

**File:** consensus/src/round_manager.rs (L166-183)
```rust
            UnverifiedEvent::BatchMsg(b) => {
                if !self_message {
                    b.verify(peer_id, max_num_batches, validator)?;
                    counters::VERIFY_MSG
                        .with_label_values(&["batch"])
                        .observe(start_time.elapsed().as_secs_f64());
                }
                VerifiedEvent::BatchMsg(Box::new((*b).into()))
            },
            UnverifiedEvent::BatchMsgV2(b) => {
                if !self_message {
                    b.verify(peer_id, max_num_batches, validator)?;
                    counters::VERIFY_MSG
                        .with_label_values(&["batch_v2"])
                        .observe(start_time.elapsed().as_secs_f64());
                }
                VerifiedEvent::BatchMsg(b)
            },
```

**File:** consensus/src/quorum_store/batch_coordinator.rs (L102-134)
```rust
            if persist_requests[0].batch_info().is_v2() {
                let signed_batch_infos = batch_store.persist(persist_requests);
                if !signed_batch_infos.is_empty() {
                    if approx_created_ts_usecs > 0 {
                        observe_batch(approx_created_ts_usecs, peer_id, BatchStage::SIGNED);
                    }
                    network_sender
                        .send_signed_batch_info_msg_v2(signed_batch_infos, vec![peer_id])
                        .await;
                }
            } else {
                let signed_batch_infos = batch_store.persist(persist_requests);
                if !signed_batch_infos.is_empty() {
                    assert!(!signed_batch_infos
                        .first()
                        .expect("must not be empty")
                        .is_v2());
                    if approx_created_ts_usecs > 0 {
                        observe_batch(approx_created_ts_usecs, peer_id, BatchStage::SIGNED);
                    }
                    let signed_batch_infos = signed_batch_infos
                        .into_iter()
                        .map(|sbi| sbi.try_into().expect("Batch must be V1 batch"))
                        .collect();
                    network_sender
                        .send_signed_batch_info_msg(signed_batch_infos, vec![peer_id])
                        .await;
                }
            }
            let _ = sender_to_proof_manager
                .send(ProofManagerCommand::ReceiveBatches(batches))
                .await;
        });
```

**File:** consensus/src/quorum_store/batch_store.rs (L515-521)
```rust
                if !batch_info.is_v2() {
                    self.generate_signed_batch_info(batch_info.info().clone())
                        .ok()
                        .map(|inner| inner.into())
                } else {
                    self.generate_signed_batch_info(batch_info).ok()
                }
```

**File:** consensus/src/quorum_store/types.rs (L433-461)
```rust
    pub fn verify(
        &self,
        peer_id: PeerId,
        max_num_batches: usize,
        verifier: &ValidatorVerifier,
    ) -> anyhow::Result<()> {
        ensure!(!self.batches.is_empty(), "Empty message");
        ensure!(
            self.batches.len() <= max_num_batches,
            "Too many batches: {} > {}",
            self.batches.len(),
            max_num_batches
        );
        let epoch_authors = verifier.address_to_validator_index();
        for batch in self.batches.iter() {
            ensure!(
                epoch_authors.contains_key(&batch.author()),
                "Invalid author {} for batch {} in current epoch",
                batch.author(),
                batch.digest()
            );
            ensure!(
                batch.author() == peer_id,
                "Batch author doesn't match sender"
            );
            batch.verify()?
        }
        Ok(())
    }
```
