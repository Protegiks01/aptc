# Audit Report

## Title
DNS Rebinding Attack in Indexer gRPC Service Registration Enables SSRF and API Disruption

## Summary
The Aptos indexer gRPC infrastructure allows data services to register themselves using DNS names without validation or DNS pinning. This enables DNS rebinding attacks where a malicious service initially registers with a legitimate IP, passes validation, then changes DNS to redirect connections to internal infrastructure, enabling SSRF attacks and API service disruption.

## Finding Description

The indexer gRPC manager accepts service registrations via heartbeat messages containing a `ServiceInfo.address` field, which is an unvalidated string that can contain DNS names. [1](#0-0) 

The address type is defined as a simple String alias with no validation: [2](#0-1) 

When a data service sends a heartbeat, it includes its self-advertised address: [3](#0-2) 

The manager accepts this address without validating that the DNS resolves to the IP address of the incoming connection: [4](#0-3) 

The manager creates lazy gRPC connections to these addresses, which resolve DNS on each connection attempt: [5](#0-4) 

When clients request a data service, the manager returns the stored address string: [6](#0-5) 

The gateway then proxies client requests to this address without DNS pinning: [7](#0-6) 

**Attack Path:**
1. Attacker controls DNS for `malicious.example.com`
2. Initially configure DNS to resolve to attacker's legitimate server at `1.2.3.4`
3. Deploy a functional data service at `1.2.3.4` that responds correctly to pings
4. Register service with address `http://malicious.example.com:50051`
5. Manager validates and stores this address
6. After successful registration, change DNS to point to internal IP (e.g., `127.0.0.1:50051` or `10.0.0.5:50051`)
7. When manager or gateway reconnects, DNS resolves to the new internal target
8. Client requests are now proxied to attacker-controlled internal services

This breaks the security assumption that validated service addresses remain trustworthy after registration.

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos bug bounty criteria because it enables:

1. **API Crashes** (explicitly listed as High severity): When DNS rebinds to unreachable or malicious endpoints, the indexer API will crash or hang, denying service to legitimate clients querying blockchain data.

2. **SSRF Attacks**: The gateway proxies HTTP/2 requests to the rebinded address, allowing attackers to access internal services not exposed to the internet, potentially compromising infrastructure security.

3. **Data Integrity Attacks**: By serving malicious blockchain data, attackers can deceive clients relying on the indexer for transaction history, event data, and blockchain state queries.

While this does not directly affect consensus, transaction execution, or fund security, it severely impacts the availability and integrity of the indexer infrastructure that many Aptos ecosystem participants depend on for blockchain data access.

## Likelihood Explanation

This attack is **highly likely** to occur because:

1. **Low Attacker Requirements**: Only requires DNS control (cheap domain registration) and ability to run a temporarily compliant service
2. **No Authentication**: Service registration via heartbeat has no authentication beyond responding correctly
3. **No Validation**: No IP address validation against DNS resolution or certificate pinning
4. **Automatic Acceptance**: Services are automatically registered upon successful heartbeat
5. **Wide Attack Surface**: Any malicious actor can attempt registration without special privileges

The attack is technically straightforward and requires no insider access or sophisticated exploitation techniques.

## Recommendation

Implement DNS pinning and IP address validation for service registration:

1. **Validate source IP matches DNS resolution**: When receiving heartbeat, verify that the connection's source IP matches the DNS resolution of the advertised address
2. **Implement DNS pinning**: Store the resolved IP address and use it for connections instead of re-resolving DNS
3. **Use TLS with certificate validation**: Require HTTPS addresses with valid certificates to prevent DNS rebinding
4. **Add IP allowlisting**: Optionally allow administrators to configure allowed IP ranges for service registration

**Code Fix Example** (conceptual):

```rust
// In metadata_manager.rs handle_heartbeat
pub(crate) fn handle_heartbeat(&self, peer_ip: IpAddr, address: GrpcAddress, info: Info) -> Result<()> {
    // Resolve DNS and verify it matches peer IP
    let resolved_ips = resolve_dns(&address)?;
    if !resolved_ips.contains(&peer_ip) {
        bail!("Service address DNS does not resolve to connection source IP");
    }
    
    // Store resolved IP for pinning
    let pinned_address = format!("http://{}:{}", peer_ip, extract_port(&address)?);
    
    match info {
        Info::LiveDataServiceInfo(info) => self.handle_live_data_service_info(pinned_address, info),
        // ... other cases
    }
}
```

## Proof of Concept

```rust
// Integration test demonstrating DNS rebinding vulnerability
#[tokio::test]
async fn test_dns_rebinding_attack() {
    // Setup: Attacker controls DNS for evil.com
    // Initially points to 1.2.3.4 (attacker's server)
    // After registration, changes to 127.0.0.1 (localhost)
    
    // Step 1: Deploy malicious service at 1.2.3.4
    let malicious_service = setup_malicious_data_service("1.2.3.4:50051").await;
    
    // Step 2: Register with manager using DNS name
    let mut manager_client = GrpcManagerClient::connect("http://manager:50052").await.unwrap();
    let service_info = ServiceInfo {
        address: Some("http://evil.com:50051".to_string()), // DNS name
        info: Some(Info::LiveDataServiceInfo(/* ... */)),
    };
    manager_client.heartbeat(HeartbeatRequest { 
        service_info: Some(service_info) 
    }).await.unwrap();
    
    // Step 3: Simulate DNS change to localhost
    update_dns_record("evil.com", "127.0.0.1");
    
    // Step 4: Request data service address from manager
    let response = manager_client.get_data_service_for_request(
        GetDataServiceForRequestRequest { user_request: Some(/* ... */) }
    ).await.unwrap();
    
    // Step 5: Verify manager returns the DNS name
    assert_eq!(response.into_inner().data_service_address, "http://evil.com:50051");
    
    // Step 6: Gateway proxies request, DNS now resolves to 127.0.0.1
    // This demonstrates the SSRF vulnerability where requests are sent to localhost
    let gateway_response = gateway_client.get_transactions(/* ... */).await;
    
    // The request is now sent to localhost:50051 instead of the original 1.2.3.4:50051
    assert!(gateway_response.is_err()); // May fail if localhost:50051 not running
}
```

## Notes

This vulnerability affects the indexer gRPC infrastructure components (`ecosystem/indexer-grpc/*`), which are part of the Aptos Core repository but separate from the core consensus protocol. While it does not directly compromise consensus safety, transaction execution, or fund security, it represents a significant infrastructure security issue that enables SSRF attacks and API service disruption, qualifying as High severity per the bug bounty criteria for "API crashes."

### Citations

**File:** protos/rust/src/pb/aptos.indexer.v1.rs (L245-250)
```rust
pub struct ServiceInfo {
    #[prost(string, optional, tag="1")]
    pub address: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(oneof="service_info::Info", tags="2, 3, 4, 5")]
    pub info: ::core::option::Option<service_info::Info>,
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/config.rs (L16-16)
```rust
pub(crate) type GrpcAddress = String;
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/connection_manager.rs (L277-280)
```rust
        let service_info = ServiceInfo {
            address: Some(self.self_advertised_address.clone()),
            info,
        };
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/service.rs (L110-127)
```rust
    async fn heartbeat(
        &self,
        request: Request<HeartbeatRequest>,
    ) -> Result<Response<HeartbeatResponse>, Status> {
        let request = request.into_inner();
        if let Some(service_info) = request.service_info {
            if let Some(address) = service_info.address {
                if let Some(info) = service_info.info {
                    return self
                        .handle_heartbeat(address, info)
                        .await
                        .map_err(|e| Status::internal(format!("Error handling heartbeat: {e}")));
                }
            }
        }

        Err(Status::invalid_argument("Bad request."))
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/service.rs (L177-195)
```rust
        let data_service_address =
            // TODO(grao): Use a simple strategy for now. Consider to make it smarter in the
            // future.
            if let Some(address) = self.pick_live_data_service(starting_version) {
                COUNTER.with_label_values(&["live_data_service_picked"]).inc();
                address
            } else if let Some(address) = self.pick_historical_data_service(starting_version).await {
                COUNTER.with_label_values(&["historical_data_service_picked"]).inc();
                address
            } else {
                COUNTER.with_label_values(&["failed_to_pick_data_service"]).inc();
                return Err(Status::internal(
                    "Cannot find a data service instance to serve the provided request.",
                ));
            };

        Ok(Response::new(GetDataServiceForRequestResponse {
            data_service_address,
        }))
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L89-92)
```rust
    fn new(address: GrpcAddress) -> Self {
        let channel = Channel::from_shared(address)
            .expect("Bad address.")
            .connect_lazy();
```

**File:** ecosystem/indexer-grpc/indexer-grpc-gateway/src/gateway.rs (L143-152)
```rust
    let response: GetDataServiceForRequestResponse = client
        .get_data_service_for_request(grpc_manager_request)
        .await
        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?
        .into_inner();

    let url = Url::from_str(&response.data_service_address).unwrap();
    let mut req = Request::from_parts(head, body);
    req.extensions_mut().insert(url);
    Ok(next.run(req).await)
```
