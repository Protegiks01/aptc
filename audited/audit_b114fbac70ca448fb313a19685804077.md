# Audit Report

## Title
Governance Proposal Override Vulnerability in JWK Patch System Allows Last-Write-Wins Attack

## Summary
The `set_patches` function in the JWK (JSON Web Key) governance system completely replaces the global `Patches` resource without any conflict detection, version checking, or execution ordering guarantees. This allows a malicious governance proposal to override a legitimate security-critical JWK patch by executing after it, completely replacing the intended patches with malicious ones.

## Finding Description

The JWK patching mechanism is used to manage authentication keys for keyless accounts through on-chain governance. When a governance proposal calls `jwks::set_patches()`, it performs a complete replacement of the global `Patches` resource: [1](#0-0) 

The critical issue is at line 381 where the function performs: `borrow_global_mut<Patches>(@aptos_framework).patches = patches;` - a complete vector replacement without any checks for:
- Version numbers or nonces
- Conflicting concurrent proposals  
- Time-based locks after recent updates
- Execution ordering guarantees

The `Patches` resource structure has no built-in protection mechanisms: [2](#0-1) 

**Attack Scenario:**

1. A legitimate governance proposal P1 is created to rotate a compromised JWK (security-critical operation)
2. Attacker observes P1 on-chain and creates malicious proposal P2 with their own JWK patches
3. Both proposals proceed through independent voting periods
4. Both proposals achieve SUCCEEDED state after gathering sufficient votes
5. P1 executes first, installing legitimate security patches via `set_patches()`
6. P2 executes shortly after, calling `set_patches()` which **completely replaces** P1's patches
7. Malicious patches from P2 are now active, overriding the security fix

The governance system has no mechanism to prevent this override. Multiple proposals can be in SUCCEEDED state simultaneously: [3](#0-2) 

Proposals are assigned sequential IDs but can execute in any order once they succeed. The execution hash verification only ensures the correct script executes for each individual proposal: [4](#0-3) 

However, this provides no protection against multiple successful proposals executing conflicting state changes on the same global resource.

## Impact Explanation

**Severity: HIGH** (per Aptos Bug Bounty criteria - "Significant protocol violations")

This vulnerability breaks the **Governance Integrity** invariant by allowing governance decisions to be silently overridden. The impact includes:

1. **Security Fix Override**: Critical security patches (like rotating compromised JWKs) can be nullified by an attacker's proposal executing afterward

2. **Authentication Bypass Risk**: If malicious JWKs are installed, keyless account authentication could be compromised, potentially allowing unauthorized access

3. **Governance Subversion**: The fundamental guarantee that passed governance proposals take effect is violated - a proposal can appear to succeed but be immediately overridden

4. **No Detection Mechanism**: There is no on-chain event or state that indicates one proposal has overridden another, making this attack invisible to monitoring systems

5. **Affects Critical Infrastructure**: JWK management is security-critical for keyless account authentication, making this a high-impact target

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH**

**Attack Requirements:**
- Attacker needs `required_proposer_stake` to create a proposal (achievable with coalition)
- Attacker needs majority voting power (>50%) to pass their proposal
- Both proposals must independently gather sufficient votes
- Attacker must time execution appropriately

**Feasibility Factors:**

The attack is feasible because:
- Governance proposals are public and observable on-chain immediately upon creation
- Voting periods are long (typically days), giving attackers time to organize
- No mechanism prevents multiple proposals from targeting the same resource
- Execution timing is controllable - proposals can execute anytime after reaching SUCCEEDED state
- The override is silent - no conflict detection alerts the community

While requiring significant voting power makes this non-trivial, it's achievable through:
- Coalition of validators with aligned interests
- Compromised validator keys
- Social engineering during contentious governance decisions

The likelihood increases during periods of legitimate governance activity when security-critical patches are being deployed.

## Recommendation

Implement conflict detection and versioning for the `Patches` resource:

**Option 1: Add Version-Based Conflict Detection**

```move
struct Patches has key {
    patches: vector<Patch>,
    version: u64,  // Increment on each update
    last_update_epoch: u64,  // Track when last modified
}

public fun set_patches(fx: &signer, patches: vector<Patch>, expected_version: u64) 
    acquires Patches, PatchedJWKs, ObservedJWKs {
    system_addresses::assert_aptos_framework(fx);
    
    let patches_resource = borrow_global_mut<Patches>(@aptos_framework);
    
    // Conflict detection: abort if version doesn't match expected
    assert!(
        patches_resource.version == expected_version,
        error::invalid_state(EPATCHES_VERSION_MISMATCH)
    );
    
    patches_resource.patches = patches;
    patches_resource.version = patches_resource.version + 1;
    patches_resource.last_update_epoch = reconfiguration::current_epoch();
    
    regenerate_patched_jwks();
}
```

**Option 2: Add Proposal Tracking with Cooldown**

```move
struct PatchesGovernance has key {
    active_proposal_id: Option<u64>,
    last_execution_time: u64,
    minimum_cooldown_secs: u64,  // e.g., 24 hours
}

public fun set_patches(fx: &signer, patches: vector<Patch>, proposal_id: u64) 
    acquires Patches, PatchedJWKs, ObservedJWKs, PatchesGovernance {
    system_addresses::assert_aptos_framework(fx);
    
    let governance = borrow_global_mut<PatchesGovernance>(@aptos_framework);
    let current_time = timestamp::now_seconds();
    
    // Prevent rapid-fire overrides
    assert!(
        current_time >= governance.last_execution_time + governance.minimum_cooldown_secs,
        error::invalid_state(EPATCHES_COOLDOWN_ACTIVE)
    );
    
    governance.active_proposal_id = option::some(proposal_id);
    governance.last_execution_time = current_time;
    
    borrow_global_mut<Patches>(@aptos_framework).patches = patches;
    regenerate_patched_jwks();
    
    // Emit event for monitoring
    emit(PatchesUpdatedEvent { proposal_id, timestamp: current_time });
}
```

**Option 3: Merge-Based Approach Instead of Replacement**

Consider changing the semantics to merge patches rather than replace them, with explicit removal commands if needed.

## Proof of Concept

```move
#[test(aptos_framework = @aptos_framework, proposer1 = @0x100, proposer2 = @0x200)]
fun test_governance_patch_override_vulnerability(
    aptos_framework: &signer,
    proposer1: &signer,
    proposer2: &signer,
) acquires Patches, PatchedJWKs, ObservedJWKs {
    // Setup: Initialize JWK system
    jwks::initialize_for_test(aptos_framework);
    
    // Legitimate proposal: Rotate compromised key
    let legitimate_jwk = jwks::new_rsa_jwk(
        utf8(b"legitimate_key_id"),
        utf8(b"RS256"),
        utf8(b"AQAB"),
        utf8(b"legitimate_public_key_n_value")
    );
    let legitimate_patches = vector[
        jwks::new_patch_upsert_jwk(b"https://legitimate.com", legitimate_jwk)
    ];
    
    // Execute legitimate proposal
    jwks::set_patches(aptos_framework, legitimate_patches);
    
    // Verify legitimate patch is active
    let patched = borrow_global<PatchedJWKs>(@aptos_framework);
    assert!(vector::length(&patched.jwks.entries) == 1, 1);
    
    // Malicious proposal: Override with malicious key
    let malicious_jwk = jwks::new_rsa_jwk(
        utf8(b"malicious_key_id"),
        utf8(b"RS256"),
        utf8(b"AQAB"),
        utf8(b"malicious_public_key_controlled_by_attacker")
    );
    let malicious_patches = vector[
        jwks::new_patch_upsert_jwk(b"https://attacker.com", malicious_jwk)
    ];
    
    // Execute malicious proposal - COMPLETELY REPLACES legitimate patches
    jwks::set_patches(aptos_framework, malicious_patches);
    
    // VULNERABILITY: Legitimate security patch has been overridden
    let patched_after = borrow_global<PatchedJWKs>(@aptos_framework);
    
    // Only malicious patch remains - legitimate patch gone!
    assert!(vector::length(&patched_after.jwks.entries) == 1, 2);
    assert!(
        vector::borrow(&patched_after.jwks.entries, 0).issuer == b"https://attacker.com",
        3
    );
    
    // Legitimate patch has been silently removed - security fix defeated!
}
```

**Notes:**

The vulnerability affects all JWK governance operations and fundamentally undermines the security guarantees of the governance system. The lack of conflict detection creates a race condition where the last proposal to execute wins, regardless of the chronological order of proposal creation or the security criticality of the changes. This is particularly dangerous for JWK management where security fixes must be reliable and tamper-proof.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L160-162)
```text
    struct Patches has key {
        patches: vector<Patch>,
    }
```

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L379-383)
```text
    public fun set_patches(fx: &signer, patches: vector<Patch>) acquires Patches, PatchedJWKs, ObservedJWKs {
        system_addresses::assert_aptos_framework(fx);
        borrow_global_mut<Patches>(@aptos_framework).patches = patches;
        regenerate_patched_jwks();
    }
```

**File:** aptos-move/framework/aptos-framework/sources/voting.move (L313-315)
```text
        let voting_forum = borrow_global_mut<VotingForum<ProposalType>>(voting_forum_address);
        let proposal_id = voting_forum.next_proposal_id;
        voting_forum.next_proposal_id = voting_forum.next_proposal_id + 1;
```

**File:** aptos-move/framework/aptos-framework/sources/voting.move (L447-450)
```text
        assert!(
            transaction_context::get_script_hash() == proposal.execution_hash,
            error::invalid_argument(EPROPOSAL_EXECUTION_HASH_NOT_MATCHING),
        );
```
