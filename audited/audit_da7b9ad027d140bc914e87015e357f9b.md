# Audit Report

## Title
Credential Leakage in NFT Metadata Crawler URL Logging

## Summary
The NFT metadata crawler fails to strip embedded credentials from URLs before logging them, leading to potential credential exposure in log files and monitoring systems. This occurs across multiple components of the crawler and violates security best practices already implemented elsewhere in the Aptos codebase.

## Finding Description

The NFT metadata crawler processes NFT URIs that originate from on-chain Token resources. When these URIs contain embedded credentials in the format `https://user:pass@gateway.ipfs.io/...` or `https://apikey:secret@arweave.net/...`, they are logged without sanitization across multiple components:

**Worker logging functions** log the unsanitized `asset_uri` field in all log statements: [1](#0-0) 

**JSON parser** logs the full URI when making HTTP requests: [2](#0-1) 

**Image optimizer** logs the full URI when fetching images: [3](#0-2) 

**URI parser** returns arweave URLs without credential stripping: [4](#0-3) 

**Attack Path:**
1. An attacker or careless NFT creator mints an NFT with a URI containing credentials (e.g., `https://apikey123:secret456@premium-ipfs-gateway.io/ipfs/QmXXX`)
2. The indexer reads this URI from the on-chain Token resource and publishes it to PubSub
3. The NFT metadata crawler receives and processes the URI
4. The URI with embedded credentials is logged multiple times without sanitization
5. Anyone with access to logs (developers, DevOps, log aggregation services like Datadog/Splunk) can harvest these credentials
6. The harvested credentials can be used to access paid services, causing financial loss to the credential owner

The codebase demonstrates awareness of this security concern, as other components properly sanitize URLs with credentials: [5](#0-4) [6](#0-5) 

## Impact Explanation

This vulnerability qualifies as **Medium severity** under the Aptos bug bounty program criteria for the following reasons:

1. **Limited funds loss**: If leaked credentials are for paid services (premium IPFS gateways, CDN services, cloud storage), unauthorized usage can lead to direct financial loss for the credential owner

2. **Information disclosure**: Credentials exposed in logs can be harvested by anyone with log access, including:
   - Internal developers and operators
   - Third-party log aggregation services
   - Attackers who compromise logging infrastructure
   - Monitoring and alerting systems

3. **Deviation from established security practices**: The codebase already implements credential sanitization in other components, making this an inconsistent security posture that could mislead developers about the safety of logging URLs

4. **Database exposure**: Unsanitized URIs are stored as primary keys in the database: [7](#0-6) 

This amplifies the impact beyond logs to database dumps and queries.

## Likelihood Explanation

**Likelihood: Medium to High**

1. **Easy to exploit**: Any NFT creator can include credentials in their NFT URI, either intentionally or accidentally
2. **Common mistake**: Developers frequently embed API keys or credentials in URLs during development and may forget to remove them
3. **Wide exposure**: Logs are typically forwarded to multiple systems (log aggregation, monitoring, alerting), increasing the attack surface
4. **No validation**: The system accepts any string as a URI without checking for embedded credentials
5. **Production impact**: The NFT metadata crawler runs in production environments processing all NFT URIs on the Aptos blockchain

## Recommendation

Implement URL credential sanitization using the pattern already established in the codebase. Apply the following changes:

**1. Sanitize in Worker logging functions:**
```rust
fn sanitize_url(url: &str) -> String {
    if let Ok(mut parsed) = url::Url::parse(url) {
        if parsed.username() != "" || parsed.password().is_some() {
            let _ = parsed.set_username("");
            let _ = parsed.set_password(None);
            return parsed.to_string();
        }
    }
    url.to_string()
}

fn log_info(&self, message: &str) {
    info!(
        pubsub_message = self.pubsub_message,
        asset_data_id = self.asset_data_id,
        asset_uri = sanitize_url(&self.asset_uri),
        // ... rest of fields
    );
}
```

**2. Sanitize in URIParser::parse()** before returning arweave URLs: [4](#0-3) 

**3. Sanitize in json_parser.rs and image_optimizer.rs** before logging URIs.

**4. Consider sanitizing before database storage** to prevent credential exposure in database dumps.

## Proof of Concept

```rust
#[cfg(test)]
mod credential_leak_test {
    use super::*;
    
    #[test]
    fn test_credentials_leaked_in_arweave_url() {
        let malicious_uri = "https://apikey:secret@arweave.net/data123";
        
        // URIParser returns the URL as-is without stripping credentials
        let result = URIParser::parse(
            "https://gateway.ipfs.io/ipfs/",
            malicious_uri,
            None
        ).unwrap();
        
        // Credentials are preserved in the returned URL
        assert!(result.contains("apikey:secret"));
        
        // This would be logged with credentials intact
        println!("Leaked URI: {}", result);
    }
    
    #[test]
    fn test_credentials_should_be_stripped() {
        let uri_with_creds = "https://user:pass@gateway.ipfs.io/ipfs/QmTest123";
        
        // Proper sanitization (what SHOULD happen)
        let mut parsed = url::Url::parse(uri_with_creds).unwrap();
        assert!(parsed.password().is_some());
        
        parsed.set_password(Some("*")).unwrap();
        let sanitized = parsed.to_string();
        
        // Credentials should be masked
        assert!(!sanitized.contains("pass"));
        assert!(sanitized.contains("*"));
    }
}
```

**Notes**

This vulnerability represents a deviation from security best practices already established in the Aptos codebase. While the credentials are technically public (stored on-chain in NFT metadata), the logging infrastructure significantly amplifies the exposure by:

1. Aggregating credentials from all NFTs in centralized log systems
2. Making credentials easily searchable and harvestable
3. Exposing them to third-party services and monitoring tools
4. Persisting them in log archives and database backups

The fix is straightforward and should follow the sanitization pattern already used in `aptos-node/src/logger.rs` and `config/src/config/indexer_config.rs`. This will align the NFT metadata crawler with the security practices of the rest of the Aptos ecosystem.

### Citations

**File:** ecosystem/nft-metadata-crawler/src/parser/worker.rs (L393-402)
```rust
    fn log_info(&self, message: &str) {
        info!(
            pubsub_message = self.pubsub_message,
            asset_data_id = self.asset_data_id,
            asset_uri = self.asset_uri,
            last_transaction_version = self.last_transaction_version,
            last_transaction_timestamp = self.last_transaction_timestamp.to_string(),
            "[NFT Metadata Crawler] {}",
            message
        );
```

**File:** ecosystem/nft-metadata-crawler/src/utils/json_parser.rs (L53-53)
```rust
                info!(asset_uri = uri, "Sending request for asset_uri");
```

**File:** ecosystem/nft-metadata-crawler/src/utils/image_optimizer.rs (L54-54)
```rust
                info!(image_uri = uri, "Sending request for image");
```

**File:** ecosystem/nft-metadata-crawler/src/utils/uri_parser.rs (L22-25)
```rust
        if uri.contains("arweave.net") {
            PARSE_URI_TYPE_COUNT.with_label_values(&["arweave"]).inc();
            return Ok(uri.to_string());
        }
```

**File:** aptos-node/src/logger.rs (L93-96)
```rust
        if parsed_url.password().is_some() {
            masked_config = node_config.clone();
            parsed_url.set_password(Some("*")).unwrap();
            masked_config.indexer.postgres_uri = Some(parsed_url.to_string());
```

**File:** config/src/config/indexer_config.rs (L96-97)
```rust
            if parsed_url.password().is_some() {
                parsed_url.set_password(Some("*")).unwrap();
```

**File:** ecosystem/nft-metadata-crawler/src/models/parsed_asset_uris.rs (L14-17)
```rust
#[diesel(primary_key(asset_uri))]
#[diesel(table_name = parsed_asset_uris)]
pub struct ParsedAssetUris {
    asset_uri: String,
```
