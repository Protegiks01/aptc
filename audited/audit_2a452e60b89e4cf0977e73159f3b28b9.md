# Audit Report

## Title
Configuration Sanitizer Bypass Allows Persistent Vulnerable Legacy Configurations During Protocol Upgrades

## Summary
The `skip_config_sanitizer` flag in `NodeStartupConfig` is stored within the node configuration file itself and persists across node restarts and protocol upgrades. When set to `true`, it bypasses ALL configuration sanitization checks, allowing legacy vulnerable configurations to persist even when new security rules are added during protocol upgrades. This creates a dangerous upgrade path where mainnet-critical security invariants can be violated.

## Finding Description

The configuration sanitization system in Aptos is designed to enforce security constraints on node configurations based on chain ID and node type. [1](#0-0) 

However, the sanitization can be completely bypassed using the `skip_config_sanitizer` flag: [2](#0-1) 

This flag is defined as part of `NodeStartupConfig` which is serialized and persisted in the node's YAML configuration file: [3](#0-2) 

When a node loads its configuration, it always uses the configuration loader which calls sanitization: [4](#0-3) 

However, since `skip_config_sanitizer` is read from the configuration file itself BEFORE sanitization runs, an old configuration file with this flag set to `true` will bypass all new sanitization rules added during protocol upgrades.

**Critical Bypassed Security Checks:**

1. **ExecutionConfig** requires paranoid verification on mainnet: [5](#0-4) 

2. **SafetyRulesConfig** prohibits in-memory storage and test configs on mainnet: [6](#0-5) 

**Attack Scenario:**
1. A validator operator creates a configuration file with `skip_config_sanitizer: true` (perhaps for testing purposes or convenience)
2. The configuration includes vulnerable settings like `paranoid_hot_potato_verification: false` or `backend: InMemoryStorage` for SafetyRules
3. During a protocol upgrade, new sanitization rules are added to catch additional vulnerabilities
4. The node restarts with the old configuration file
5. Because `skip_config_sanitizer: true` persists in the file, ALL sanitization (both old and new) is bypassed
6. The vulnerable configuration remains active on a mainnet validator

## Impact Explanation

**Critical Severity** - This vulnerability enables multiple consensus-breaking and safety-violating scenarios:

1. **Consensus Safety Violation**: A validator with `SafetyRulesConfig.backend = InMemoryStorage` loses consensus safety data (last_voted_round, preferred_round, etc.) on node restart. [7](#0-6)  This allows double-voting and violates the core AptosBFT safety invariant that validators cannot vote for conflicting blocks.

2. **VM Execution Divergence**: Disabling `paranoid_hot_potato_verification` and `paranoid_type_verification` on mainnet removes critical runtime checks that prevent malformed Move bytecode from executing incorrectly. If one validator has these disabled while others have them enabled, malicious bytecode could execute differently across validators, causing consensus divergence and potential chain splits.

3. **Upgrade Path Vulnerability**: New security fixes implemented as sanitizer rules can be completely bypassed by legacy configurations, making the network unable to enforce new security constraints without manual operator intervention on every affected node.

This breaks the **Consensus Safety** and **Deterministic Execution** invariants from the critical invariants list.

## Likelihood Explanation

**High Likelihood** - This scenario is realistic because:

1. Validator operators may legitimately use `skip_config_sanitizer: true` during testing or development
2. Configuration files are often templated or copied between environments
3. Operators may forget to remove the flag when deploying to production
4. The flag persists silently across upgrades with no warnings
5. There is no forced re-sanitization mechanism during protocol upgrades

The test suite explicitly demonstrates this bypass is intentional: [8](#0-7) 

## Recommendation

**Immediate Fix:**
1. Remove the `skip_config_sanitizer` flag entirely from production code, or make it only available in test builds
2. Add a MANDATORY re-sanitization check during node startup that cannot be bypassed
3. Add explicit validation that mainnet nodes NEVER have `skip_config_sanitizer: true`

**Code Fix:**
```rust
// In config_sanitizer.rs NodeConfig::sanitize()
fn sanitize(
    node_config: &NodeConfig,
    node_type: NodeType,
    chain_id: Option<ChainId>,
) -> Result<(), Error> {
    // CRITICAL: Never allow sanitizer bypass on mainnet
    if let Some(chain_id) = chain_id {
        if chain_id.is_mainnet() && node_config.node_startup.skip_config_sanitizer {
            return Err(Error::ConfigSanitizerFailed(
                "NodeConfig".to_string(),
                "skip_config_sanitizer MUST be false on mainnet for security!".into(),
            ));
        }
    }
    
    // If config sanitization is disabled (non-mainnet only), don't do anything
    if node_config.node_startup.skip_config_sanitizer {
        return Ok(());
    }
    
    // ... rest of sanitization
}
```

**Long-term Solution:**
1. Implement configuration versioning with automatic migration
2. Store a hash of sanitization rules and force re-sanitization when rules change
3. Add telemetry to detect nodes with `skip_config_sanitizer: true` on mainnet
4. Implement configuration hot-reload with mandatory sanitization

## Proof of Concept

```rust
// Test demonstrating the vulnerability
#[test]
fn test_mainnet_sanitizer_bypass_allows_unsafe_config() {
    use aptos_config::config::{
        NodeConfig, NodeStartupConfig, ExecutionConfig, 
        ConsensusConfig, SafetyRulesConfig, SecureBackend
    };
    use aptos_types::chain_id::ChainId;
    use aptos_config::config::config_sanitizer::ConfigSanitizer;
    
    // Create a MAINNET validator config with DANGEROUS settings
    let mut node_config = NodeConfig {
        node_startup: NodeStartupConfig {
            skip_config_sanitizer: true,  // BYPASS FLAG
            ..Default::default()
        },
        execution: ExecutionConfig {
            paranoid_hot_potato_verification: false,  // UNSAFE!
            paranoid_type_verification: false,         // UNSAFE!
            ..Default::default()
        },
        consensus: ConsensusConfig {
            safety_rules: SafetyRulesConfig {
                backend: SecureBackend::InMemoryStorage,  // UNSAFE!
                ..Default::default()
            },
            ..Default::default()
        },
        ..Default::default()
    };
    
    // This should FAIL on mainnet but PASSES due to bypass
    let result = NodeConfig::sanitize(
        &node_config, 
        NodeType::Validator, 
        Some(ChainId::mainnet())
    );
    
    assert!(result.is_ok(), "VULNERABILITY: Unsafe config bypassed mainnet sanitization!");
    
    // Now disable the bypass flag
    node_config.node_startup.skip_config_sanitizer = false;
    
    // This should (and does) fail
    let result = NodeConfig::sanitize(
        &node_config,
        NodeType::Validator,
        Some(ChainId::mainnet())
    );
    
    assert!(result.is_err(), "Expected sanitization to fail for unsafe mainnet config");
}
```

**Notes:**

This vulnerability requires a validator operator to have explicitly set `skip_config_sanitizer: true` in their configuration file. While validator operators are generally trusted, this represents a critical footgun that:

1. Can persist silently across protocol upgrades
2. Bypasses security fixes implemented as new sanitization rules
3. Could lead to consensus divergence or safety violations if the misconfigured node behaves differently from correctly configured validators
4. Has no runtime detection or warning mechanisms

The impact is amplified during protocol upgrades when new security constraints are added but cannot be enforced on nodes with this flag set.

### Citations

**File:** config/src/config/config_sanitizer.rs (L39-71)
```rust
impl ConfigSanitizer for NodeConfig {
    fn sanitize(
        node_config: &NodeConfig,
        node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        // If config sanitization is disabled, don't do anything!
        if node_config.node_startup.skip_config_sanitizer {
            return Ok(());
        }

        // Sanitize all of the sub-configs
        AdminServiceConfig::sanitize(node_config, node_type, chain_id)?;
        ApiConfig::sanitize(node_config, node_type, chain_id)?;
        BaseConfig::sanitize(node_config, node_type, chain_id)?;
        ConsensusConfig::sanitize(node_config, node_type, chain_id)?;
        DagConsensusConfig::sanitize(node_config, node_type, chain_id)?;
        ExecutionConfig::sanitize(node_config, node_type, chain_id)?;
        sanitize_failpoints_config(node_config, node_type, chain_id)?;
        sanitize_fullnode_network_configs(node_config, node_type, chain_id)?;
        IndexerGrpcConfig::sanitize(node_config, node_type, chain_id)?;
        InspectionServiceConfig::sanitize(node_config, node_type, chain_id)?;
        LoggerConfig::sanitize(node_config, node_type, chain_id)?;
        MempoolConfig::sanitize(node_config, node_type, chain_id)?;
        NetbenchConfig::sanitize(node_config, node_type, chain_id)?;
        StateSyncConfig::sanitize(node_config, node_type, chain_id)?;
        StorageConfig::sanitize(node_config, node_type, chain_id)?;
        InternalIndexerDBConfig::sanitize(node_config, node_type, chain_id)?;
        sanitize_validator_network_config(node_config, node_type, chain_id)?;

        Ok(()) // All configs passed validation
    }
}
```

**File:** config/src/config/config_sanitizer.rs (L212-239)
```rust
    fn test_disable_config_sanitizer() {
        // Create a default node config (with sanitization enabled)
        let mut node_config = NodeConfig::default();

        // Set a bad node config for mainnet
        node_config.execution.paranoid_hot_potato_verification = false;

        // Sanitize the config and verify the sanitizer fails
        let error =
            NodeConfig::sanitize(&node_config, NodeType::Validator, Some(ChainId::mainnet()))
                .unwrap_err();
        assert!(matches!(error, Error::ConfigSanitizerFailed(_, _)));

        // Create a node config with the sanitizer disabled
        let mut node_config = NodeConfig {
            node_startup: NodeStartupConfig {
                skip_config_sanitizer: true,
                ..Default::default()
            },
            ..Default::default()
        };

        // Set a bad node config for mainnet
        node_config.execution.paranoid_hot_potato_verification = false;

        // Sanitize the config and verify the sanitizer passes
        NodeConfig::sanitize(&node_config, NodeType::Validator, Some(ChainId::mainnet())).unwrap();
    }
```

**File:** config/src/config/node_startup_config.rs (L6-21)
```rust
#[derive(Clone, Copy, Debug, Deserialize, PartialEq, Eq, Serialize)]
#[serde(default, deny_unknown_fields)]
pub struct NodeStartupConfig {
    pub skip_config_optimizer: bool, // Whether or not to skip the config optimizer at startup
    pub skip_config_sanitizer: bool, // Whether or not to skip the config sanitizer at startup
}

#[allow(clippy::derivable_impls)] // Derive default manually (this is safer than guessing defaults)
impl Default for NodeStartupConfig {
    fn default() -> Self {
        Self {
            skip_config_optimizer: false,
            skip_config_sanitizer: false,
        }
    }
}
```

**File:** config/src/config/node_config.rs (L140-143)
```rust
    pub fn load_from_path<P: AsRef<Path>>(input_path: P) -> Result<Self, Error> {
        let node_config_loader = NodeConfigLoader::new(input_path);
        node_config_loader.load_and_sanitize_config()
    }
```

**File:** config/src/config/execution_config.rs (L166-183)
```rust
        // If this is a mainnet node, ensure that additional verifiers are enabled
        if let Some(chain_id) = chain_id {
            if chain_id.is_mainnet() {
                if !execution_config.paranoid_hot_potato_verification {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "paranoid_hot_potato_verification must be enabled for mainnet nodes!"
                            .into(),
                    ));
                }
                if !execution_config.paranoid_type_verification {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "paranoid_type_verification must be enabled for mainnet nodes!".into(),
                    ));
                }
            }
        }
```

**File:** config/src/config/safety_rules_config.rs (L85-113)
```rust
        if let Some(chain_id) = chain_id {
            // Verify that the secure backend is appropriate for mainnet validators
            if chain_id.is_mainnet()
                && node_type.is_validator()
                && safety_rules_config.backend.is_in_memory()
            {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "The secure backend should not be set to in memory storage in mainnet!"
                        .to_string(),
                ));
            }

            // Verify that the safety rules service is set to local for optimal performance
            if chain_id.is_mainnet() && !safety_rules_config.service.is_local() {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    format!("The safety rules service should be set to local in mainnet for optimal performance! Given config: {:?}", &safety_rules_config.service)
                ));
            }

            // Verify that the safety rules test config is not enabled in mainnet
            if chain_id.is_mainnet() && safety_rules_config.test.is_some() {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "The safety rules test config should not be used in mainnet!".to_string(),
                ));
            }
        }
```

**File:** consensus/safety-rules/src/persistent_safety_storage.rs (L134-170)
```rust
    pub fn safety_data(&mut self) -> Result<SafetyData, Error> {
        if !self.enable_cached_safety_data {
            let _timer = counters::start_timer("get", SAFETY_DATA);
            return self.internal_store.get(SAFETY_DATA).map(|v| v.value)?;
        }

        if let Some(cached_safety_data) = self.cached_safety_data.clone() {
            Ok(cached_safety_data)
        } else {
            let _timer = counters::start_timer("get", SAFETY_DATA);
            let safety_data: SafetyData = self.internal_store.get(SAFETY_DATA).map(|v| v.value)?;
            self.cached_safety_data = Some(safety_data.clone());
            Ok(safety_data)
        }
    }

    pub fn set_safety_data(&mut self, data: SafetyData) -> Result<(), Error> {
        let _timer = counters::start_timer("set", SAFETY_DATA);
        counters::set_state(counters::EPOCH, data.epoch as i64);
        counters::set_state(counters::LAST_VOTED_ROUND, data.last_voted_round as i64);
        counters::set_state(
            counters::HIGHEST_TIMEOUT_ROUND,
            data.highest_timeout_round as i64,
        );
        counters::set_state(counters::PREFERRED_ROUND, data.preferred_round as i64);

        match self.internal_store.set(SAFETY_DATA, data.clone()) {
            Ok(_) => {
                self.cached_safety_data = Some(data);
                Ok(())
            },
            Err(error) => {
                self.cached_safety_data = None;
                Err(Error::SecureStorageUnexpectedError(error.to_string()))
            },
        }
    }
```
