# Audit Report

## Title
Integer Underflow in MixedPayloadClient::pull_payload() Leading to Consensus Divergence

## Summary
The `MixedPayloadClient::pull_payload()` function uses non-saturating subtraction when updating transaction constraints after pulling validator transactions. When backpressure mechanisms heavily reduce `max_txns_after_filtering` while `max_txns.count()` remains high, the code can pull more validator transactions than the filtering limit allows, causing integer underflow that leads to validator panics (debug mode) or incorrect constraint calculations (release mode), breaking consensus determinism.

## Finding Description

The vulnerability occurs in the consensus layer's payload pulling mechanism where validator transactions and user transactions are pulled sequentially with constraint updates. The root cause is that `max_txns.count()` and `max_txns_after_filtering` are adjusted **independently** by backpressure mechanisms, but the validator transaction pulling logic only considers the former while the subtraction operations assume coherence between both values.

**Vulnerability Execution Path:**

1. **Independent Backpressure Adjustment**: The `ProposalGenerator::calculate_max_block_sizes()` function applies backpressure independently to `max_block_txns` and `max_block_txns_after_filtering` through separate code paths, collecting values in separate vectors and taking their minimums independently. [1](#0-0) 

2. **Extreme Backpressure Configuration**: Pipeline backpressure configuration can reduce `max_sending_block_txns_after_filtering_override` to as low as 5 transactions when pipeline latency exceeds 6000ms, while byte-based limits may keep transaction counts higher. [2](#0-1) 

3. **Governance-Controlled Validator Limit**: The `per_block_limit_txn_count` is a u64 field in `ValidatorTxnConfig::V1` that defaults to 2 but can be set to any value through on-chain governance. [3](#0-2) 

4. **Unconstrained Validator Transaction Pulling**: When pulling validator transactions, the limit used is `min(params.max_txns.count(), per_block_limit_txn_count)`, which does not consider `max_txns_after_filtering`. [4](#0-3) 

5. **Integer Underflow on Constraint Update**: After pulling validator transactions, the code performs non-saturating subtraction on u64 fields. If `validator_txns.len() > max_txns_after_filtering`, this causes integer underflow. [5](#0-4) 

**Concrete Exploit Scenario:**
- Pipeline latency exceeds 6000ms, reducing `max_txns_after_filtering` to 5
- `max_txns.count()` remains at 1000 (determined by byte limits)
- Governance proposal increases `per_block_limit_txn_count` from 2 to 100 to accommodate more validator transactions
- Validator pool returns 50 transactions (within the allowed `min(1000, 100) = 100` limit)
- Line 94 executes: `5 - 50` causing integer underflow
  - **Debug mode**: Panics with integer underflow error, validator crashes
  - **Release mode**: Wraps to `u64::MAX - 44 ≈ 18,446,744,073,709,551,571`, allowing virtually unlimited user transactions

## Impact Explanation

**Critical Severity** - This vulnerability violates the **Consensus Determinism** invariant, meeting the "Consensus/Safety Violations (Critical)" category in the Aptos bug bounty program:

1. **Consensus Divergence**: Validators compiled in debug mode will panic and halt when processing proposals under these conditions, while validators in release mode will continue with corrupted constraints (wrapped to ~u64::MAX). This creates a scenario where different validators produce different execution results for the same block proposal, breaking the fundamental consensus safety guarantee that all honest validators reach agreement on the same state.

2. **Validator Unavailability**: Debug-compiled validators experiencing this condition will crash during proposal generation, removing them from network participation. If a sufficient number of validators are affected, this can prevent the network from achieving consensus on new blocks, leading to liveness failures.

3. **Block Size Limit Violation**: In release mode, the wrapped constraint value allows the proposer to pull virtually unlimited user transactions (up to ~18 quintillion), completely bypassing the carefully calibrated block size limits designed to ensure execution completes within acceptable time bounds. This can cause downstream execution failures, state divergence, or chain halts.

4. **Non-deterministic Network Behavior**: The outcome depends on each validator's compilation profile (debug vs release), creating unpredictable network behavior where some validators crash while others process malformed blocks. This non-determinism can be exploited to partition the network by manipulating which validators are online at proposal time.

## Likelihood Explanation

**High Likelihood** under realistic operational conditions:

1. **Backpressure is a Common Occurrence**: Pipeline backpressure triggers regularly in production networks during high transaction load, execution bottlenecks, or state synchronization delays. The backpressure mechanism is designed to activate automatically, making the precondition for `max_txns_after_filtering = 5` achievable without any attacker action.

2. **Governance Parameter Changes are Expected**: The `per_block_limit_txn_count` parameter exists specifically to be adjusted via governance as validator transaction requirements evolve. Reasonable governance proposals might increase this limit from the default 2 to values like 10-100 to accommodate DKG transactions, randomness beacons, or other validator coordination mechanisms. Such proposals would be approved through normal governance processes without recognizing the security implications.

3. **No Protective Validation**: The code contains no assertions, checks, or validation ensuring that `validator_txns.len() <= max_txns_after_filtering` before performing the subtraction. The misalignment between independently-adjusted constraints can occur naturally during normal network operation.

4. **No Malicious Actor Required**: This vulnerability triggers during normal network operation—no attacker coordination, transaction crafting, or Byzantine behavior is required. It simply requires the confluence of (1) heavy network load causing backpressure and (2) a governance-approved increase to validator transaction limits, both of which are legitimate operational scenarios.

## Recommendation

**Immediate Fix**: Replace non-saturating subtraction with saturating subtraction to prevent underflow:

```rust
// Line 94-95 in consensus/src/payload_client/mixed.rs
user_txn_pull_params.max_txns_after_filtering = 
    user_txn_pull_params.max_txns_after_filtering.saturating_sub(validator_txns.len() as u64);
user_txn_pull_params.soft_max_txns_after_filtering = 
    user_txn_pull_params.soft_max_txns_after_filtering.saturating_sub(validator_txns.len() as u64);
```

**Additional Safeguards**:
1. Add validation that `per_block_limit_txn_count <= max_txns_after_filtering` before pulling validator transactions
2. Consider pulling validator transactions with `min(params.max_txns.count(), params.max_txns_after_filtering, per_block_limit_txn_count)` to respect all constraints
3. Add assertion checks in debug builds to catch constraint violations early
4. Update backpressure logic to maintain coherence between `max_txns.count()` and `max_txns_after_filtering`

## Proof of Concept

While a full PoC would require setting up a test network with specific backpressure conditions, the vulnerability can be demonstrated by examining the code paths:

1. Configure pipeline latency to exceed 6000ms (simulated or actual)
2. Observe `calculate_max_block_sizes()` returning `max_block_txns_after_filtering = 5`
3. Set `ValidatorTxnConfig.per_block_limit_txn_count = 100` via governance
4. Ensure validator transaction pool has 50+ pending transactions
5. Call `MixedPayloadClient::pull_payload()` with these parameters
6. Observe integer underflow at line 94 causing panic (debug) or wrap (release)

The vulnerability is evident from static code analysis showing:
- Non-saturating subtraction operations [6](#0-5) 
- Independent constraint adjustments [7](#0-6) 
- Unconstrained validator transaction pulling [8](#0-7) 
- No validation preventing the underflow condition

## Notes

This vulnerability is particularly concerning because it doesn't require any malicious behavior—it can occur during legitimate network operations. The combination of automatic backpressure mechanisms (designed to protect the network) and governance-approved parameter changes (designed to improve validator functionality) creates an unexpected interaction that breaks consensus safety guarantees. The non-deterministic behavior based on compilation profiles makes this especially dangerous, as it could manifest differently across validator implementations.

### Citations

**File:** consensus/src/liveness/proposal_generator.rs (L745-821)
```rust
        let mut values_max_block_txns_after_filtering = vec![self.max_block_txns_after_filtering];
        let mut values_max_block = vec![self.max_block_txns];
        let mut values_proposal_delay = vec![Duration::ZERO];
        let mut block_gas_limit_override = None;

        let chain_health_backoff = self
            .chain_health_backoff_config
            .get_backoff(voting_power_ratio);
        if let Some(value) = chain_health_backoff {
            values_max_block_txns_after_filtering
                .push(value.max_sending_block_txns_after_filtering_override);
            values_max_block.push(
                self.max_block_txns
                    .compute_with_bytes(value.max_sending_block_bytes_override),
            );
            values_proposal_delay.push(Duration::from_millis(value.backoff_proposal_delay_ms));
            CHAIN_HEALTH_BACKOFF_TRIGGERED.observe(1.0);
        } else {
            CHAIN_HEALTH_BACKOFF_TRIGGERED.observe(0.0);
        }

        let pipeline_pending_latency = self.block_store.pipeline_pending_latency(timestamp);
        let pipeline_backpressure = self
            .pipeline_backpressure_config
            .get_backoff(pipeline_pending_latency);
        if let Some(value) = pipeline_backpressure {
            values_max_block_txns_after_filtering
                .push(value.max_sending_block_txns_after_filtering_override);
            values_max_block.push(
                self.max_block_txns
                    .compute_with_bytes(value.max_sending_block_bytes_override),
            );
            values_proposal_delay.push(Duration::from_millis(value.backpressure_proposal_delay_ms));
            PIPELINE_BACKPRESSURE_ON_PROPOSAL_TRIGGERED.observe(1.0);
        } else {
            PIPELINE_BACKPRESSURE_ON_PROPOSAL_TRIGGERED.observe(0.0);
        };

        let mut execution_backpressure_applied = false;
        if let Some(num_blocks_to_look_at) =
            self.pipeline_backpressure_config.num_blocks_to_look_at()
        {
            let (txn_limit, gas_limit) = self
                .pipeline_backpressure_config
                .get_execution_block_txn_and_gas_limit_backoff(
                    &self
                        .block_store
                        .get_recent_block_execution_times(num_blocks_to_look_at),
                    self.max_block_txns_after_filtering,
                    self.max_block_gas_limit,
                );
            if let Some(txn_limit) = txn_limit {
                values_max_block_txns_after_filtering.push(txn_limit);
                execution_backpressure_applied = true;
            }
            block_gas_limit_override = gas_limit;
            if gas_limit.is_some() {
                execution_backpressure_applied = true;
            }
        }
        EXECUTION_BACKPRESSURE_ON_PROPOSAL_TRIGGERED.observe(
            if execution_backpressure_applied {
                1.0
            } else {
                0.0
            },
        );

        let max_block_txns_after_filtering = values_max_block_txns_after_filtering
            .into_iter()
            .min()
            .expect("always initialized to at least one value");

        let max_block_size = values_max_block
            .into_iter()
            .reduce(PayloadTxnsSize::minimum)
            .expect("always initialized to at least one value");
```

**File:** config/src/config/consensus_config.rs (L309-318)
```rust
                PipelineBackpressureValues {
                    back_pressure_pipeline_latency_limit_ms: 6000,
                    // in practice, latencies and delay make it such that ~2 blocks/s is max,
                    // meaning that most aggressively we limit to ~10 TPS
                    // For transactions that are more expensive than that, we should
                    // instead rely on max gas per block to limit latency.
                    max_sending_block_txns_after_filtering_override: 5,
                    max_sending_block_bytes_override: MIN_BLOCK_BYTES_OVERRIDE,
                    backpressure_proposal_delay_ms: 300,
                },
```

**File:** types/src/on_chain_config/consensus_config.rs (L125-144)
```rust
const VTXN_CONFIG_PER_BLOCK_LIMIT_TXN_COUNT_DEFAULT: u64 = 2;
const VTXN_CONFIG_PER_BLOCK_LIMIT_TOTAL_BYTES_DEFAULT: u64 = 2097152; //2MB

#[derive(Clone, Debug, Deserialize, PartialEq, Eq, Serialize)]
pub enum ValidatorTxnConfig {
    /// Disabled. In Jolteon, it also means to not use `BlockType::ProposalExt`.
    V0,
    /// Enabled. Per-block vtxn count and their total bytes are limited.
    V1 {
        per_block_limit_txn_count: u64,
        per_block_limit_total_bytes: u64,
    },
}

impl ValidatorTxnConfig {
    pub fn default_for_genesis() -> Self {
        Self::V1 {
            per_block_limit_txn_count: VTXN_CONFIG_PER_BLOCK_LIMIT_TXN_COUNT_DEFAULT,
            per_block_limit_total_bytes: VTXN_CONFIG_PER_BLOCK_LIMIT_TOTAL_BYTES_DEFAULT,
        }
```

**File:** consensus/src/payload_client/mixed.rs (L65-79)
```rust
        let mut validator_txns = self
            .validator_txn_pool_client
            .pull(
                params.max_poll_time,
                min(
                    params.max_txns.count(),
                    self.validator_txn_config.per_block_limit_txn_count(),
                ),
                min(
                    params.max_txns.size_in_bytes(),
                    self.validator_txn_config.per_block_limit_total_bytes(),
                ),
                validator_txn_filter,
            )
            .await;
```

**File:** consensus/src/payload_client/mixed.rs (L91-95)
```rust
        // Update constraints with validator txn pull results.
        let mut user_txn_pull_params = params;
        user_txn_pull_params.max_txns -= vtxn_size;
        user_txn_pull_params.max_txns_after_filtering -= validator_txns.len() as u64;
        user_txn_pull_params.soft_max_txns_after_filtering -= validator_txns.len() as u64;
```
