# Audit Report

## Title
Governance Vote Direction Manipulation via Partial Voting - Stake Pools Can Vote Both YES and NO on Same Proposal

## Summary
The `partial_vote()` function in Aptos Governance allows a stake pool to vote multiple times on the same proposal in different directions (both YES and NO), violating the fundamental governance invariant that each stake pool should commit to a single voting position. This vulnerability enables manipulation of proposal outcomes by simultaneously boosting both yes and no vote counts.

## Finding Description

The vulnerability exists in how `VotingRecordsV2` tracks voting power usage in the governance system. The system only records the **total amount** of voting power used by each stake pool per proposal, but fails to track the **direction** (yes/no) of those votes. [1](#0-0) 

The `get_remaining_voting_power` function calculates remaining voting power by subtracting the total used voting power from the stake pool's total voting power, without considering vote direction: [2](#0-1) 

The `vote_internal` function updates the used voting power by simply adding to the total, regardless of direction: [3](#0-2) 

The underlying `voting::vote` function adds votes to either `yes_votes` or `no_votes` based solely on the `should_pass` parameter, with no check for previous vote direction: [4](#0-3) 

**Attack Path:**
1. Attacker controls a stake pool with 100 voting power
2. Calls `partial_vote(stake_pool, proposal_id, 50, true)` → adds 50 to `yes_votes`, marks 50 power as used
3. Calls `partial_vote(stake_pool, proposal_id, 50, false)` → adds 50 to `no_votes`, marks 100 total power as used
4. Result: Same stake pool voted 50 YES and 50 NO on the same proposal

The existing test suite only verifies voting multiple times in the **same** direction: [5](#0-4) 

No test exists that verifies prevention of voting in opposite directions, confirming this scenario was not considered during development.

## Impact Explanation

**Severity: HIGH** - This constitutes a significant governance protocol violation that undermines governance integrity.

This vulnerability allows attackers to:
1. **Inflate Vote Counts**: Artificially boost both yes and no vote totals, making governance metrics inaccurate
2. **Trigger Early Resolution**: Vote both ways with large voting power to reach `early_resolution_vote_threshold` when the proposal shouldn't naturally reach this threshold
3. **Manipulate Outcomes**: Near voting deadlines, vote both ways to prevent clear majority formation or influence the final yes/no ratio
4. **Create Governance Deadlock**: Multiple actors voting both ways can create artificial contention on critical proposals

The impact affects critical governance decisions including:
- Network parameter updates via `update_governance_config`
- Framework upgrades through proposal execution
- Validator set changes via staking governance
- Feature flag modifications via `toggle_features`

According to Aptos bug bounty criteria, this meets **High Severity (up to $50,000)** as a significant protocol violation affecting network-wide governance decisions, though it does not directly enable fund theft or consensus breaks.

## Likelihood Explanation

**Likelihood: HIGH** - The attack is trivially exploitable with no technical barriers.

**Attacker Requirements:**
- Control or be the delegated voter for any stake pool (common for validators and large token holders)
- No special privileges beyond normal governance participation rights
- Attack executable via standard transaction submission

**Execution Complexity: LOW**
- Two simple function calls to `partial_vote()` with opposite `should_pass` boolean values
- No sophisticated timing requirements
- No complex state manipulation
- Works on any active proposal during its voting period

The attack has minimal economic cost (only gas fees) and requires no special capabilities beyond what many legitimate governance participants already possess.

## Recommendation

Modify `VotingRecordsV2` to track both the amount and direction of votes. Replace the current `SmartTable<RecordKey, u64>` with a structure that records vote direction:

```move
struct VoteRecord has store, copy, drop {
    voting_power_used: u64,
    vote_direction: Option<bool>, // None if no vote, Some(true) for yes, Some(false) for no
}

struct VotingRecordsV2 has key {
    votes: SmartTable<RecordKey, VoteRecord>
}
```

In `vote_internal`, add validation to ensure the stake pool hasn't voted in the opposite direction:

```move
let vote_record = VotingRecordsV2[@aptos_framework].votes.borrow_with_default(record_key, VoteRecord { voting_power_used: 0, vote_direction: option::none() });

if (option::is_some(&vote_record.vote_direction)) {
    assert!(
        *option::borrow(&vote_record.vote_direction) == should_pass,
        error::invalid_argument(EVOTE_DIRECTION_MISMATCH)
    );
}
```

## Proof of Concept

```move
#[test(aptos_framework = @aptos_framework, proposer = @0x123, voter_1 = @0x234, voter_2 = @0x345)]
public entry fun test_cannot_vote_opposite_directions(
    aptos_framework: signer,
    proposer: signer,
    voter_1: signer,
    voter_2: signer,
) acquires ApprovedExecutionHashes, GovernanceConfig, GovernanceResponsbility, VotingRecords, VotingRecordsV2, GovernanceEvents {
    setup_partial_voting(&aptos_framework, &proposer, &voter_1, &voter_2);
    let voter_1_addr = signer::address_of(&voter_1);
    
    create_proposal_for_test(&proposer, false);
    
    // Vote YES with 50 voting power
    partial_vote(&voter_1, voter_1_addr, 0, 10, true);
    
    // Attempt to vote NO with remaining power - this should fail but currently succeeds
    partial_vote(&voter_1, voter_1_addr, 0, 10, false);
    
    // Verify both votes were counted (demonstrating the vulnerability)
    let (yes_votes, no_votes) = voting::get_votes<GovernanceProposal>(@aptos_framework, 0);
    assert!(yes_votes == 10 && no_votes == 10, 0); // Both directions counted from same stake pool!
}
```

### Citations

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L104-106)
```text
    struct VotingRecordsV2 has key {
        votes: SmartTable<RecordKey, u64>
    }
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L346-348)
```text
        let used_voting_power = *VotingRecordsV2[@aptos_framework].votes.borrow_with_default(record_key, &0);
        get_voting_power(stake_pool) - used_voting_power
    }
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L568-574)
```text
        let record_key = RecordKey {
            stake_pool,
            proposal_id,
        };
        let used_voting_power = VotingRecordsV2[@aptos_framework].votes.borrow_mut_with_default(record_key, 0);
        // This calculation should never overflow because the used voting cannot exceed the total voting power of this stake pool.
        *used_voting_power += voting_power;
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L1088-1090)
```text
        partial_vote(&voter_1, voter_1_addr, 0, 5, true);
        partial_vote(&voter_1, voter_1_addr, 0, 3, true);
        partial_vote(&voter_1, voter_1_addr, 0, 2, true);
```

**File:** aptos-move/framework/aptos-framework/sources/voting.move (L405-409)
```text
        if (should_pass) {
            proposal.yes_votes = proposal.yes_votes + (num_votes as u128);
        } else {
            proposal.no_votes = proposal.no_votes + (num_votes as u128);
        };
```
