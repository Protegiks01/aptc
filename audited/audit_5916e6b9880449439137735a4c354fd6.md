# Audit Report

## Title
State Streaming Service Validation Bypass Enables Resource Exhaustion Attack

## Summary
The `process_new_stream_request()` function in the data streaming service fails to validate critical parameters in stream requests before creating and storing data streams. Specifically, `StateStreamEngine` accepts arbitrary `start_index` values and `TransactionStreamEngine` accepts inverted version ranges without validation, allowing malicious requests to bypass validation in `DataStream::new()` and consume node resources indefinitely.

## Finding Description

The data streaming service creates and stores stream objects in memory before fully validating request parameters. This validation gap exists across multiple stream types:

**Primary Issue: StateStreamEngine Start Index Bypass**

In `StateStreamEngine::new()`, the `start_index` parameter from `GetAllStatesRequest` is accepted without any bounds checking: [1](#0-0) 

The validation in `ensure_data_is_available()` only checks if the version exists, not whether `start_index` is valid: [2](#0-1) 

A malicious request can inject `start_index = u64::MAX` or any value exceeding the actual number of states. The stream is created and stored in the `data_streams` HashMap, and a network request is sent. The invalid `start_index` is only detected later when processing the response: [3](#0-2) 

**Secondary Issue: TransactionStreamEngine Range Bypass**

In `TransactionStreamEngine::new()`, there is no validation that `start_version <= end_version`: [4](#0-3) 

When an inverted range is detected during request creation, it silently returns an empty vector instead of failing: [5](#0-4) 

This causes the stream to remain in memory indefinitely without making progress or being cleaned up.

**Attack Path:**
1. Malicious actor injects crafted `StreamRequestMessage` with invalid parameters
2. `process_new_stream_request()` accepts the message
3. `DataStream::new()` creates stream via `StreamEngine::new()` without validating parameters
4. Stream is stored in `data_streams` HashMap
5. For state streams: Network request sent, only fails after response received
6. For transaction streams: Empty requests generated, stream never completes
7. No cleanup mechanism exists - streams remain allocated indefinitely

The streaming service has no limit on concurrent streams in the `data_streams` HashMap: [6](#0-5) 

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos bug bounty program ("Validator node slowdowns") because it enables resource exhaustion attacks that degrade node performance:

1. **Memory Exhaustion**: Unlimited invalid streams can be created, each allocating memory for stream state, request queues, and notification mappings
2. **Network Bandwidth Waste**: Each invalid state stream generates at least one network request before failing
3. **CPU Overhead**: Processing invalid streams consumes CPU cycles checking progress and managing state
4. **State Sync Disruption**: Resource exhaustion in the streaming service directly impacts state synchronization, preventing nodes from catching up to the network

The "Resource Limits" invariant is violated - the system should enforce limits on all operations, but no bounds exist on the number of concurrent streams or validation of their parameters.

## Likelihood Explanation

**Likelihood: Medium**

While the streaming service is primarily used by internal state sync components (limiting direct external attack surface), exploitation is feasible through:

1. **Compromised Node**: An attacker gaining access to a validator node could inject malicious stream requests internally
2. **State Sync Driver Bugs**: Vulnerabilities in state sync logic could be chained to generate invalid requests
3. **Future API Exposure**: If the streaming API is exposed or extended in future versions, the attack surface increases significantly

The validation gaps represent a systemic issue where security depends on all callers being trusted and bug-free, violating defense-in-depth principles.

## Recommendation

Implement comprehensive parameter validation in `StreamEngine::new()` before creating any stream:

```rust
// In StateStreamEngine::new()
fn new(request: &GetAllStatesRequest) -> Result<Self, Error> {
    // Validate start_index is reasonable (not u64::MAX or close to overflow)
    if request.start_index >= (u64::MAX - 1000000) {
        return Err(Error::UnexpectedErrorEncountered(format!(
            "Invalid start_index: {}. Must be less than u64::MAX - 1000000",
            request.start_index
        )));
    }
    
    // Rest of constructor...
}

// In TransactionStreamEngine::new()  
fn new(stream_request: &StreamRequest) -> Result<Self, Error> {
    match stream_request {
        StreamRequest::GetAllTransactions(request) => {
            // Validate version range
            if request.start_version > request.end_version {
                return Err(Error::UnexpectedErrorEncountered(format!(
                    "Invalid version range: start {} > end {}",
                    request.start_version, request.end_version
                )));
            }
            if request.end_version > request.proof_version {
                return Err(Error::UnexpectedErrorEncountered(format!(
                    "Invalid proof version: end {} > proof {}",
                    request.end_version, request.proof_version
                )));
            }
            // Rest of constructor...
        }
        // Similar validation for other variants
    }
}
```

Additionally, implement a maximum concurrent streams limit in `DataStreamingService`:

```rust
const MAX_CONCURRENT_STREAMS: usize = 100;

fn process_new_stream_request(...) -> Result<DataStreamListener, Error> {
    // Check stream limit before creating
    if self.data_streams.len() >= MAX_CONCURRENT_STREAMS {
        return Err(Error::TooManyStreams(format!(
            "Maximum {} concurrent streams exceeded", 
            MAX_CONCURRENT_STREAMS
        )));
    }
    // Rest of function...
}
```

## Proof of Concept

```rust
// Proof of Concept: Create invalid state stream that bypasses validation
use aptos_data_streaming_service::{
    streaming_client::{GetAllStatesRequest, StreamRequest},
    data_stream::DataStream,
};

#[test]
fn test_state_stream_validation_bypass() {
    // Create malicious request with invalid start_index
    let malicious_request = GetAllStatesRequest {
        version: 1000,
        start_index: u64::MAX, // Invalid: exceeds any reasonable state count
    };
    
    let stream_request = StreamRequest::GetAllStates(malicious_request);
    
    // This should fail but currently succeeds
    let result = StreamEngine::new(
        config,
        &stream_request,
        &advertised_data,
    );
    
    // Stream is created successfully despite invalid start_index
    assert!(result.is_ok(), "Invalid stream should be rejected but was accepted");
    
    // The validation failure only happens later when processing responses,
    // after the stream has already consumed resources and sent network requests
}

#[test]
fn test_transaction_stream_range_bypass() {
    // Create malicious request with inverted version range
    let malicious_request = GetAllTransactionsRequest {
        start_version: 1000,
        end_version: 500, // Invalid: start > end
        proof_version: 2000,
        include_events: false,
    };
    
    let stream_request = StreamRequest::GetAllTransactions(malicious_request);
    
    // This should fail but currently succeeds
    let result = StreamEngine::new(
        config,
        &stream_request,
        &advertised_data,
    );
    
    // Stream is created and stored, but will never complete
    // because create_data_client_request_batch returns empty vec
    assert!(result.is_ok(), "Invalid range should be rejected but was accepted");
}
```

## Notes

This vulnerability demonstrates a critical flaw in the validation architecture where parameter checking is split across multiple layers and some validation occurs too late (after resource allocation). The streaming service assumes all callers are trusted and provide valid inputs, which violates security best practices. While the current attack surface is limited to internal components, this represents a significant security gap that could be exploited through compromised nodes, chained vulnerabilities, or future API changes.

### Citations

**File:** state-sync/data-streaming-service/src/stream_engine.rs (L190-199)
```rust
    fn new(request: &GetAllStatesRequest) -> Result<Self, Error> {
        Ok(StateStreamEngine {
            request: request.clone(),
            state_num_requested: false,
            number_of_states: None,
            next_stream_index: request.start_index,
            next_request_index: request.start_index,
            stream_is_complete: false,
        })
    }
```

**File:** state-sync/data-streaming-service/src/stream_engine.rs (L287-293)
```rust
    fn is_remaining_data_available(&self, advertised_data: &AdvertisedData) -> Result<bool, Error> {
        Ok(AdvertisedData::contains_range(
            self.request.version,
            self.request.version,
            &advertised_data.states,
        ))
    }
```

**File:** state-sync/data-streaming-service/src/stream_engine.rs (L373-380)
```rust
                    if number_of_states < self.next_request_index {
                        return Err(Error::NoDataToFetch(format!(
                            "The next state index to fetch is higher than the \
                            total number of states. Next index: {:?}, total states: {:?}",
                            self.next_request_index, number_of_states
                        )));
                    } else {
                        self.number_of_states = Some(number_of_states);
```

**File:** state-sync/data-streaming-service/src/stream_engine.rs (L1668-1690)
```rust
    fn new(stream_request: &StreamRequest) -> Result<Self, Error> {
        match stream_request {
            StreamRequest::GetAllTransactions(request) => Ok(TransactionStreamEngine {
                request: stream_request.clone(),
                next_stream_version: request.start_version,
                next_request_version: request.start_version,
                stream_is_complete: false,
            }),
            StreamRequest::GetAllTransactionOutputs(request) => Ok(TransactionStreamEngine {
                request: stream_request.clone(),
                next_stream_version: request.start_version,
                next_request_version: request.start_version,
                stream_is_complete: false,
            }),
            StreamRequest::GetAllTransactionsOrOutputs(request) => Ok(TransactionStreamEngine {
                request: stream_request.clone(),
                next_stream_version: request.start_version,
                next_request_version: request.start_version,
                stream_is_complete: false,
            }),
            request => invalid_stream_request!(request),
        }
    }
```

**File:** state-sync/data-streaming-service/src/stream_engine.rs (L2056-2058)
```rust
    if start_index > end_index {
        return Ok(vec![]);
    }
```

**File:** state-sync/data-streaming-service/src/streaming_service.rs (L54-87)
```rust
pub struct DataStreamingService<T> {
    // The configuration for the data client
    data_client_config: AptosDataClientConfig,

    // The configuration for the streaming service
    streaming_service_config: DataStreamingServiceConfig,

    // The data client through which to fetch data from the Aptos network
    aptos_data_client: T,

    // Cached global data summary
    global_data_summary: Arc<ArcSwap<GlobalDataSummary>>,

    // All requested data streams from clients
    data_streams: HashMap<DataStreamId, DataStream<T>>,

    // The listener through which to hear new client stream requests
    stream_requests: StreamingServiceListener,

    // The stream update notifier that notifies the streaming service to check
    // the progress of the data streams. This provides a way for data streams
    // to immediately notify the streaming service when new data is ready.
    stream_update_notifier: aptos_channel::Sender<(), StreamUpdateNotification>,

    // The stream update listener to listen for data stream update notifications
    stream_update_listener: aptos_channel::Receiver<(), StreamUpdateNotification>,

    // Unique ID generators to maintain unique IDs across streams
    stream_id_generator: U64IdGenerator,
    notification_id_generator: Arc<U64IdGenerator>,

    // The time service used to track elapsed time (e.g., for stream progress checks)
    time_service: TimeService,
}
```
