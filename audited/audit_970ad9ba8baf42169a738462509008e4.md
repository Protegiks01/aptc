# Audit Report

## Title
DKGTranscript Author Field Lacks Validation Allowing Validator Attribution Spoofing

## Summary
The `DKGTranscript.metadata.author` field is not validated against the validator set or the actual dealers in the DKG transcript when a `ValidatorTransaction::DKGResult` is included in a block proposal. A malicious validator proposing a block can set this field to any `AccountAddress`, including non-existent addresses or addresses of validators who did not contribute to the DKG result.

## Finding Description
When a validator creates a `ValidatorTransaction::DKGResult` containing a DKG transcript for inclusion in a block, they set the `metadata.author` field. The normal behavior is to set this to their own address: [1](#0-0) 

However, when this transaction is validated during block proposal processing in consensus, the verification flow does NOT validate the `metadata.author` field: [2](#0-1) 

The validation chain proceeds through: [3](#0-2) [4](#0-3) 

The final validation in `RealDKG::verify_transcript_extra()` only checks the dealers inside the PVSS transcript, not the metadata: [5](#0-4) 

This function validates dealer indices, voting power, and transcript consistency, but never checks if `metadata.author` matches any dealer or is even a valid validator address.

During VM execution, the metadata is not passed to the Move function at allâ€”only the transcript bytes: [6](#0-5) 

**Attack Path:**
1. A malicious validator aggregates a valid DKG transcript with sufficient voting power
2. Instead of setting `metadata.author` to their own address, they set it to any arbitrary address (e.g., `AccountAddress::ZERO`, another validator's address, or a non-existent address)
3. They include this `ValidatorTransaction::DKGResult` in their block proposal
4. Other validators accept the block because the PVSS transcript validation passes
5. The spoofed author is recorded and exposed via the REST API [7](#0-6) 

## Impact Explanation
This vulnerability has **Medium** severity impact:

**Attribution and Accountability Loss**: The system loses the ability to reliably track which validator actually proposed the DKG result. This affects:
- Forensic analysis and incident response
- Monitoring systems tracking validator behavior
- Historical record integrity exposed through the REST API
- Any future accountability or reputation systems

**Note**: This does NOT directly impact:
- Consensus safety (the actual DKG transcript is still cryptographically validated)
- Fund security (no funds can be stolen or minted)
- Network availability (liveness is unaffected)
- On-chain state integrity (only metadata is affected, not the transcript execution)

The impact is limited to **information integrity** rather than protocol security, but it undermines a fundamental principle that validators should be accountable for their actions.

## Likelihood Explanation
**Likelihood: Low to Medium**

**Requirements for exploitation:**
- Attacker must be a validator with block proposal rights
- Attacker must have aggregated a valid DKG transcript
- Attacker must be selected to propose a block

**Ease of exploitation:**
- Once requirements are met, exploitation is trivial (simply set a different address)
- No complex cryptographic operations required
- No need for collusion with other validators

**Detection difficulty:**
- Spoofing would be difficult to detect without cross-referencing block proposer with claimed DKG author
- The PVSS transcript dealers can still be extracted and compared, but requires manual analysis

## Recommendation
Add validation in the `DKGTranscript::verify()` method to ensure `metadata.author` is either:
1. A valid validator in the current epoch's validator set, OR
2. One of the dealers present in the PVSS transcript

Recommended fix in `types/src/dkg/mod.rs`:

```rust
pub(crate) fn verify(&self, verifier: &ValidatorVerifier) -> Result<()> {
    // Validate author is a valid validator
    ensure!(
        verifier.get_voting_power(&self.metadata.author).is_some(),
        "DKGTranscript author is not a valid validator"
    );
    
    let transcripts: Transcripts = bcs::from_bytes(&self.transcript_bytes)
        .context("Transcripts deserialization failed")?;
    RealDKG::verify_transcript_extra(&transcripts, verifier, true, None)?;
    
    // Optionally, also verify author is one of the dealers
    let dealer_addrs = verifier.get_ordered_account_addresses();
    let dealers = RealDKG::get_dealers(&transcripts);
    let dealer_set: HashSet<_> = dealers
        .into_iter()
        .filter_map(|idx| dealer_addrs.get(idx as usize))
        .collect();
    
    ensure!(
        dealer_set.contains(&self.metadata.author),
        "DKGTranscript author is not one of the dealers"
    );
    
    Ok(())
}
```

## Proof of Concept
The vulnerability can be demonstrated by modifying the DKG manager to set an arbitrary author:

```rust
// In dkg/src/dkg_manager/mod.rs, replace lines 397-404 with:
let txn = ValidatorTransaction::DKGResult(DKGTranscript {
    metadata: DKGTranscriptMetadata {
        epoch: self.epoch_state.epoch,
        author: AccountAddress::ZERO, // Spoofed author!
    },
    transcript_bytes: bcs::to_bytes(&agg_trx)
        .map_err(|e| anyhow!("transcript serialization error: {e}"))?,
});
```

The modified transaction will pass all validation checks in `round_manager.rs` and `verify_transcript_extra()`, and will be successfully executed by the VM. The spoofed author will appear in API responses and logs, demonstrating the lack of validation.

## Notes
This vulnerability specifically affects the DKG result attribution metadata. While the actual DKG transcript cryptographic validation remains secure (the dealers inside the PVSS transcript are properly validated), the metadata layer lacks integrity checks. This creates a trust gap where validators cannot be held accountable for the DKG results they propose, undermining the transparency and auditability of the DKG process.

### Citations

**File:** dkg/src/dkg_manager/mod.rs (L397-404)
```rust
                let txn = ValidatorTransaction::DKGResult(DKGTranscript {
                    metadata: DKGTranscriptMetadata {
                        epoch: self.epoch_state.epoch,
                        author: self.my_addr,
                    },
                    transcript_bytes: bcs::to_bytes(&agg_trx)
                        .map_err(|e| anyhow!("transcript serialization error: {e}"))?,
                });
```

**File:** consensus/src/round_manager.rs (L1126-1136)
```rust
        if let Some(vtxns) = proposal.validator_txns() {
            for vtxn in vtxns {
                let vtxn_type_name = vtxn.type_name();
                ensure!(
                    is_vtxn_expected(&self.randomness_config, &self.jwk_consensus_config, vtxn),
                    "unexpected validator txn: {:?}",
                    vtxn_type_name
                );
                vtxn.verify(self.epoch_state.verifier.as_ref())
                    .context(format!("{} verify failed", vtxn_type_name))?;
            }
```

**File:** types/src/validator_txn.rs (L45-52)
```rust
    pub fn verify(&self, verifier: &ValidatorVerifier) -> anyhow::Result<()> {
        match self {
            ValidatorTransaction::DKGResult(dkg_result) => dkg_result
                .verify(verifier)
                .context("DKGResult verification failed"),
            ValidatorTransaction::ObservedJWKUpdate(_) => Ok(()),
        }
    }
```

**File:** types/src/dkg/mod.rs (L83-87)
```rust
    pub(crate) fn verify(&self, verifier: &ValidatorVerifier) -> Result<()> {
        let transcripts: Transcripts = bcs::from_bytes(&self.transcript_bytes)
            .context("Transcripts deserialization failed")?;
        RealDKG::verify_transcript_extra(&transcripts, verifier, true, None)
    }
```

**File:** types/src/dkg/real_dkg/mod.rs (L295-329)
```rust
    fn verify_transcript_extra(
        trx: &Self::Transcript,
        verifier: &ValidatorVerifier,
        checks_voting_power: bool,
        ensures_single_dealer: Option<AccountAddress>,
    ) -> anyhow::Result<()> {
        let all_validator_addrs = verifier.get_ordered_account_addresses();
        let main_trx_dealers = trx.main.get_dealers();
        let mut dealer_set = HashSet::with_capacity(main_trx_dealers.len());
        for dealer in main_trx_dealers.iter() {
            if let Some(dealer_addr) = all_validator_addrs.get(dealer.id) {
                dealer_set.insert(*dealer_addr);
            } else {
                bail!("invalid dealer idx");
            }
        }
        ensure!(main_trx_dealers.len() == dealer_set.len());
        if ensures_single_dealer.is_some() {
            let expected_dealer_set: HashSet<AccountAddress> =
                ensures_single_dealer.into_iter().collect();
            ensure!(expected_dealer_set == dealer_set);
        }

        if checks_voting_power {
            verifier
                .check_voting_power(dealer_set.iter(), true)
                .context("not enough power")?;
        }

        if let Some(fast_trx) = &trx.fast {
            ensure!(fast_trx.get_dealers() == main_trx_dealers);
            ensure!(trx.main.get_dealt_public_key() == fast_trx.get_dealt_public_key());
        }
        Ok(())
    }
```

**File:** aptos-move/aptos-vm/src/validator_txns/dkg.rs (L117-120)
```rust
        let args = vec![
            MoveValue::Signer(AccountAddress::ONE),
            dkg_node.transcript_bytes.as_move_value(),
        ];
```

**File:** api/types/src/transaction.rs (L848-860)
```rust
impl From<DKGTranscript> for ExportedDKGTranscript {
    fn from(value: DKGTranscript) -> Self {
        let DKGTranscript {
            metadata,
            transcript_bytes,
        } = value;
        let DKGTranscriptMetadata { epoch, author } = metadata;
        Self {
            epoch: epoch.into(),
            author: author.into(),
            payload: HexEncodedBytes::from(transcript_bytes),
        }
    }
```
