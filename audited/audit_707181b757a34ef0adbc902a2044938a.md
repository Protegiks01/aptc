# Audit Report

## Title
Missing Authentication Key Length Validation During BCS Deserialization Enables Account Bricking via State Corruption

## Summary
The Rust `AccountResource` structure does not validate that the `authentication_key` field is exactly 32 bytes during BCS deserialization, violating a critical invariant enforced by the Move framework. While the Move layer enforces this constraint at all entry points, the absence of Rust-side validation creates a defense-in-depth gap that could enable permanent account bricking if invalid state data enters storage through database corruption, state synchronization bugs, or Move VM vulnerabilities.

## Finding Description

The `AccountResource` struct in Rust deserializes the `authentication_key` as an unconstrained `Vec<u8>`: [1](#0-0) 

When the API deserializes account data from storage, no validation occurs: [2](#0-1) 

The Move framework enforces the 32-byte invariant during account creation: [3](#0-2) 

And during key rotation: [4](#0-3) 

However, if an `authentication_key` with invalid length enters storage (bypassing Move validation through database corruption, state sync exploit, or VM bug), subsequent Move operations would fail. The `from_bcs::to_address()` function explicitly aborts on non-32-byte inputs: [5](#0-4) [6](#0-5) 

Key rotation code uses this function on the stored authentication key: [7](#0-6) 

## Impact Explanation

This represents a **defense-in-depth violation** rather than a directly exploitable vulnerability. The security impact manifests only if invalid state data enters storage through:

1. **Database corruption** (hardware failure, manual tampering)
2. **State synchronization vulnerabilities** (accepting malicious state from Byzantine nodes)
3. **Move VM bugs** (allowing invalid struct construction)

If triggered, affected accounts would be **permanently bricked** - unable to rotate authentication keys or perform operations requiring `from_bcs::to_address()` conversion. This constitutes a **Medium severity** issue under "State inconsistencies requiring intervention" since it would require manual intervention (hard fork or state repair) to fix affected accounts.

## Likelihood Explanation

**Likelihood: LOW** 

This issue cannot be directly exploited by an unprivileged attacker. Exploitation requires:
- A separate vulnerability enabling invalid state injection
- Or privileged access to database/state sync systems

Under normal operation, the Move framework's validation prevents invalid authentication keys from being stored. However, the absence of Rust-side validation violates defense-in-depth principles, where each layer should independently enforce critical invariants.

## Recommendation

Add validation in the `AccountResource` deserialization path:

```rust
impl AccountResource {
    pub fn validate(&self) -> Result<(), anyhow::Error> {
        anyhow::ensure!(
            self.authentication_key.len() == 32,
            "Authentication key must be exactly 32 bytes, got {}",
            self.authentication_key.len()
        );
        Ok(())
    }
}
```

Call this validation immediately after BCS deserialization in `api/src/accounts.rs`:

```rust
let account_resource: AccountResource = bcs::from_bytes(state_value)
    .context("Internal error deserializing response from DB")?;
account_resource.validate()
    .context("Invalid account resource: authentication key length violation")?;
```

## Proof of Concept

A PoC cannot be constructed without a separate vulnerability to inject invalid state. However, the invariant violation can be demonstrated:

**Test showing from_bcs::to_address aborts on invalid length:** [6](#0-5) 

**Rust test demonstrating missing validation:**
```rust
#[test]
fn test_invalid_auth_key_deserialization() {
    // Construct AccountResource with invalid auth key (16 bytes instead of 32)
    let invalid_auth_key = vec![0u8; 16];
    let account = AccountResource::new(
        0,
        invalid_auth_key,
        EventHandle::new(EventKey::new(0, AccountAddress::ZERO), 0),
        EventHandle::new(EventKey::new(1, AccountAddress::ZERO), 0),
    );
    
    // BCS serialization/deserialization succeeds without validation
    let bytes = bcs::to_bytes(&account).unwrap();
    let deserialized: AccountResource = bcs::from_bytes(&bytes).unwrap();
    
    // Demonstrates the validation gap - should have failed
    assert_eq!(deserialized.authentication_key().len(), 16);
}
```

## Notes

While this finding identifies a legitimate defense-in-depth gap, it does not constitute a standalone exploitable vulnerability since:
- Normal operation paths enforce the invariant correctly
- Exploitation requires chaining with another vulnerability
- No unprivileged attack path exists

The recommendation remains valid as a hardening measure to prevent potential state corruption scenarios from cascading into account bricking attacks.

### Citations

**File:** types/src/account_config/resources/core_account.rs (L19-29)
```rust
#[derive(Debug, Eq, PartialEq, Serialize, Deserialize)]
#[cfg_attr(any(test, feature = "fuzzing"), derive(Arbitrary))]
pub struct AccountResource {
    authentication_key: Vec<u8>,
    pub sequence_number: u64,
    guid_creation_num: u64,
    coin_register_events: EventHandle,
    key_rotation_events: EventHandle,
    rotation_capability_offer: Option<AccountAddress>,
    signer_capability_offer: Option<AccountAddress>,
}
```

**File:** api/src/accounts.rs (L269-278)
```rust
            let account_resource: AccountResource = bcs::from_bytes(state_value)
                .context("Internal error deserializing response from DB")
                .map_err(|err| {
                    BasicErrorWith404::internal_with_code(
                        err,
                        AptosErrorCode::InternalError,
                        &self.latest_ledger_info,
                    )
                })?;
            account_resource
```

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L307-311)
```text
        let authentication_key = bcs::to_bytes(&new_address);
        assert!(
            authentication_key.length() == 32,
            error::invalid_argument(EMALFORMED_AUTHENTICATION_KEY)
        );
```

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L443-446)
```text
        assert!(
            new_auth_key.length() == 32,
            error::invalid_argument(EMALFORMED_AUTHENTICATION_KEY)
        );
```

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L638-638)
```text
        let curr_auth_key_as_address = from_bcs::to_address(account_resource.authentication_key);
```

**File:** aptos-move/framework/aptos-stdlib/sources/from_bcs.move (L47-49)
```text
    public fun to_address(v: vector<u8>): address {
        from_bytes<address>(v)
    }
```

**File:** aptos-move/framework/aptos-stdlib/sources/from_bcs.move (L86-91)
```text
    #[test]
    #[expected_failure(abort_code = 0x10001, location = Self)]
    fun test_address_fail() {
        let bad_vec = b"01";
        to_address(bad_vec);
    }
```
