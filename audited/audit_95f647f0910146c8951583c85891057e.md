# Audit Report

## Title
Memory Exhaustion Vulnerability in SafetyRules Process Network Communication

## Summary
The `NetworkStream` implementation used by the SafetyRules process server lacks message size limits, allowing an attacker with network access to send arbitrarily large messages (up to 4GB) that cause memory exhaustion and crash the safety rules process, preventing validator participation in consensus.

## Finding Description

The SafetyRules component can operate in different modes, including a `Process` mode where it runs as a separate process and communicates via TCP. The network communication layer in [1](#0-0)  implements a length-prefixed protocol where a 4-byte prefix indicates the message size, but **no validation is performed on this size value**.

The vulnerability manifests in the message reading flow:

1. The SafetyRules process server accepts connections and reads messages via [2](#0-1) 

2. The `NetworkServer::read()` method calls into [3](#0-2) 

3. The `NetworkStream::read()` accumulates data in a buffer at [4](#0-3)  with no size checks

4. The `read_buffer()` method extracts the length prefix and attempts to read that many bytes at [1](#0-0) 

**Attack Scenario:**

An attacker connects to the SafetyRules process server and sends a malicious message with a crafted 4-byte length prefix (e.g., 0x80000000 = 2GB). The server will attempt to allocate and fill a 2GB buffer, causing:
- Memory exhaustion
- Process crash or unresponsiveness
- SafetyRules unavailability
- Validator unable to sign votes/proposals
- Loss of consensus participation

The serialized `SafetyRulesInput` messages are processed at [5](#0-4)  after the unbounded read completes, but by then the memory has already been allocated.

While the main Aptos network layer enforces `MAX_MESSAGE_SIZE` of 64 MiB at [6](#0-5) , the SafetyRules process networking layer does not inherit or enforce these limits.

**Mitigating Factors:**

The config sanitizer at [7](#0-6)  enforces that mainnet validators use `SafetyRulesService::Local` rather than `Process` mode for performance reasons. This significantly reduces the attack surface in production mainnet. However, the vulnerability remains exploitable in:
- Testnet/devnet deployments using Process mode
- Misconfigured nodes (if sanitizer is bypassed)
- Local attackers with access to the validator machine
- Development/staging environments

## Impact Explanation

**Severity: High**

This vulnerability falls under the "Validator node slowdowns" and "API crashes" categories of High severity in the Aptos bug bounty program. A successful exploit causes:

1. **Validator Liveness Loss**: The safety rules process crash prevents the validator from signing consensus messages, removing it from active participation
2. **Consensus Impact**: If multiple validators are affected, network liveness could be degraded
3. **No Authentication**: The service at [8](#0-7)  has no authentication mechanism, allowing any network peer to attempt exploitation

The impact is NOT Critical because:
- Mainnet validators are configured to use Local mode (per sanitizer enforcement)
- Default configuration binds to localhost as shown in [9](#0-8) 
- No fund theft or consensus safety violation occurs
- The validator can recover by restarting the process

## Likelihood Explanation

**Likelihood: Medium-Low**

The likelihood is reduced by several factors:
1. **Mainnet Protection**: Config sanitizer enforcement means mainnet validators don't use Process mode
2. **Localhost Binding**: Default configuration binds to 127.0.0.1, limiting network exposure
3. **Limited Attack Window**: Requires network access to the SafetyRules process server

However, likelihood increases in:
- Non-mainnet environments (testnets, devnets, private networks)
- Misconfigured deployments
- Scenarios where an attacker has compromised the validator machine

## Recommendation

**Implement message size limits in the NetworkStream layer:**

Add a constant maximum message size and validate it in `read_buffer()`:

```rust
// In secure/net/src/lib.rs, add constant near line 23:
const MAX_NETWORK_MESSAGE_SIZE: usize = 64 * 1024 * 1024; // 64 MiB to match network layer

// Modify read_buffer() at line 479:
fn read_buffer(&mut self) -> Result<Vec<u8>, Error> {
    if self.buffer.len() < 4 {
        return Ok(Vec::new());
    }

    let mut u32_bytes = [0; 4];
    u32_bytes.copy_from_slice(&self.buffer[..4]);
    let data_size = u32::from_le_bytes(u32_bytes) as usize;

    // ADD SIZE VALIDATION HERE:
    if data_size > MAX_NETWORK_MESSAGE_SIZE {
        return Err(Error::DataTooLarge(data_size));
    }

    let remaining_data = &self.buffer[4..];
    if remaining_data.len() < data_size {
        return Ok(Vec::new());
    }

    let returnable_data = remaining_data[..data_size].to_vec();
    self.buffer = remaining_data[data_size..].to_vec();
    Ok(returnable_data)
}
```

Additionally, consider adding authentication to the SafetyRules process service to prevent unauthorized connections.

## Proof of Concept

```rust
// PoC demonstrating memory exhaustion attack
// Place in secure/net/src/lib.rs test module

#[test]
#[should_panic(expected = "DataTooLarge")]
fn test_oversized_message_rejection() {
    use std::net::{IpAddr, Ipv4Addr, SocketAddr};
    use std::io::Write;
    use std::net::TcpStream;
    use aptos_config::utils;

    const TIMEOUT: u64 = 5_000;
    
    // Start server
    let server_port = utils::get_available_port();
    let server_addr = SocketAddr::new(IpAddr::V4(Ipv4Addr::LOCALHOST), server_port);
    let mut server = NetworkServer::new("test".to_string(), server_addr, TIMEOUT);
    
    // Attacker connects and sends malicious message
    let mut attacker_stream = TcpStream::connect(server_addr).unwrap();
    
    // Send length prefix of 2GB (0x80000000)
    let malicious_size: u32 = 0x80000000;
    attacker_stream.write_all(&malicious_size.to_le_bytes()).unwrap();
    
    // Send some data (server will try to allocate 2GB buffer)
    attacker_stream.write_all(&[0u8; 1024]).unwrap();
    
    // Server attempts to read and should reject or crash
    let result = server.read();
    
    // With the fix, this should return DataTooLarge error
    // Without the fix, this causes memory exhaustion
    assert!(result.is_err());
}
```

## Notes

This vulnerability demonstrates a violation of the **Resource Limits** invariant: "All operations must respect gas, storage, and computational limits." While the SafetyRules process is not directly part of the gas-metered execution layer, it still must enforce resource limits to prevent DoS attacks.

The defense-in-depth principle suggests that even though mainnet validators use Local mode, the underlying networking layer should still enforce reasonable limits to prevent exploitation in other contexts (testnets, development, misconfiguration).

### Citations

**File:** secure/net/src/lib.rs (L297-321)
```rust
    pub fn read(&mut self) -> Result<Vec<u8>, Error> {
        self.increment_counter(Method::Read, MethodResult::Query);

        let result = {
            let stream = self.client()?;
            stream.read().map_err(|e| (stream.remote, e))
        };

        if let Err((remote, err)) = &result {
            self.increment_counter(Method::Read, MethodResult::Failure);
            warn!(SecureNetLogSchema::new(
                &self.service,
                NetworkMode::Server,
                LogEvent::DisconnectedPeerOnRead,
            )
            .error(err)
            .remote_peer(remote));

            self.stream = None;
        } else {
            self.increment_counter(Method::Read, MethodResult::Success);
        }

        result.map_err(|err| err.1)
    }
```

**File:** secure/net/src/lib.rs (L430-451)
```rust
    pub fn read(&mut self) -> Result<Vec<u8>, Error> {
        let result = self.read_buffer();
        if !result.is_empty() {
            return Ok(result);
        }

        loop {
            trace!("Attempting to read from stream");
            let read = self.stream.read(&mut self.temp_buffer)?;
            trace!("Read {} bytes from stream", read);
            if read == 0 {
                return Err(Error::RemoteStreamClosed);
            }
            self.buffer.extend(self.temp_buffer[..read].to_vec());
            let result = self.read_buffer();
            if !result.is_empty() {
                trace!("Found a message in the stream");
                return Ok(result);
            }
            trace!("Did not find a message yet, reading again");
        }
    }
```

**File:** secure/net/src/lib.rs (L479-496)
```rust
    fn read_buffer(&mut self) -> Vec<u8> {
        if self.buffer.len() < 4 {
            return Vec::new();
        }

        let mut u32_bytes = [0; 4];
        u32_bytes.copy_from_slice(&self.buffer[..4]);
        let data_size = u32::from_le_bytes(u32_bytes) as usize;

        let remaining_data = &self.buffer[4..];
        if remaining_data.len() < data_size {
            return Vec::new();
        }

        let returnable_data = remaining_data[..data_size].to_vec();
        self.buffer = remaining_data[data_size..].to_vec();
        returnable_data
    }
```

**File:** consensus/safety-rules/src/remote_service.rs (L30-45)
```rust
pub fn execute(storage: PersistentSafetyStorage, listen_addr: SocketAddr, network_timeout_ms: u64) {
    let mut safety_rules = SafetyRules::new(storage, false);
    if let Err(e) = safety_rules.consensus_state() {
        warn!("Unable to print consensus state: {}", e);
    }

    let mut serializer_service = SerializerService::new(safety_rules);
    let mut network_server =
        NetworkServer::new("safety-rules".to_string(), listen_addr, network_timeout_ms);

    loop {
        if let Err(e) = process_one_message(&mut network_server, &mut serializer_service) {
            warn!("Failed to process message: {}", e);
        }
    }
}
```

**File:** consensus/safety-rules/src/remote_service.rs (L47-55)
```rust
fn process_one_message(
    network_server: &mut NetworkServer,
    serializer_service: &mut SerializerService,
) -> Result<(), Error> {
    let request = network_server.read()?;
    let response = serializer_service.handle_message(request)?;
    network_server.write(&response)?;
    Ok(())
}
```

**File:** consensus/safety-rules/src/serializer.rs (L45-82)
```rust
    pub fn handle_message(&mut self, input_message: Vec<u8>) -> Result<Vec<u8>, Error> {
        let input = serde_json::from_slice(&input_message)?;

        let output = match input {
            SafetyRulesInput::ConsensusState => {
                serde_json::to_vec(&self.internal.consensus_state())
            },
            SafetyRulesInput::Initialize(li) => serde_json::to_vec(&self.internal.initialize(&li)),
            SafetyRulesInput::SignProposal(block_data) => {
                serde_json::to_vec(&self.internal.sign_proposal(&block_data))
            },
            SafetyRulesInput::SignTimeoutWithQC(timeout, maybe_tc) => serde_json::to_vec(
                &self
                    .internal
                    .sign_timeout_with_qc(&timeout, maybe_tc.as_ref().as_ref()),
            ),
            SafetyRulesInput::ConstructAndSignVoteTwoChain(vote_proposal, maybe_tc) => {
                serde_json::to_vec(
                    &self.internal.construct_and_sign_vote_two_chain(
                        &vote_proposal,
                        maybe_tc.as_ref().as_ref(),
                    ),
                )
            },
            SafetyRulesInput::ConstructAndSignOrderVote(order_vote_proposal) => serde_json::to_vec(
                &self
                    .internal
                    .construct_and_sign_order_vote(&order_vote_proposal),
            ),
            SafetyRulesInput::SignCommitVote(ledger_info, new_ledger_info) => serde_json::to_vec(
                &self
                    .internal
                    .sign_commit_vote(*ledger_info, *new_ledger_info),
            ),
        };

        Ok(output?)
    }
```

**File:** config/src/config/network_config.rs (L50-50)
```rust
pub const MAX_MESSAGE_SIZE: usize = 64 * 1024 * 1024; /* 64 MiB */
```

**File:** config/src/config/safety_rules_config.rs (L99-104)
```rust
            if chain_id.is_mainnet() && !safety_rules_config.service.is_local() {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    format!("The safety rules service should be set to local in mainnet for optimal performance! Given config: {:?}", &safety_rules_config.service)
                ));
            }
```

**File:** config/src/config/test_data/validator.yaml (L15-16)
```yaml
            type: process
            server_address: "/ip4/127.0.0.1/tcp/5555"
```
