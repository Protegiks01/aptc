# Audit Report

## Title
Integer Overflow Panic in Transaction Range Proof Crashes Backup Service

## Summary
The `get_transaction_range_proof` method in BackupHandler performs unchecked arithmetic that overflows when an attacker provides `last_version = u64::MAX`, causing a panic that crashes the backup service due to Aptos's enabled overflow checks in release builds.

## Finding Description

While all BackupHandler methods properly return `Result` types, panics can still escape through unchecked arithmetic operations in the implementation. The vulnerability exists in the `get_transaction_range_proof` method. [1](#0-0) 

The method validates that `last_version >= first_version` but then performs unchecked arithmetic: `last_version - first_version + 1`. When `last_version = u64::MAX` and `first_version = 0`, the subtraction yields `u64::MAX`, and adding `1` causes integer overflow.

Critically, Aptos explicitly enables overflow checks in release mode: [2](#0-1) 

This means the overflow triggers a panic even in production builds. The panic occurs in the HTTP handler's map closure: [3](#0-2) 

Furthermore, Aptos sets up a global panic handler that terminates the entire process on any thread panic: [4](#0-3) [5](#0-4) 

**Attack Path:**
1. Attacker sends: `GET /transaction_range_proof/0/18446744073709551615` (where 18446744073709551615 = u64::MAX)
2. Request passes validation at line 118-122 (u64::MAX >= 0 is true)
3. Line 124 computes: `num_transactions = u64::MAX - 0 + 1`
4. Overflow triggers panic due to `overflow-checks = true`
5. Panic propagates to global handler
6. `process::exit(12)` crashes entire backup service

## Impact Explanation

**High Severity** - API crashes that cause complete service unavailability.

- The backup service becomes completely unavailable after a single malicious request
- All ongoing backup operations are terminated
- Node operators lose ability to create backups until service is manually restarted
- This breaks the availability guarantee that backup infrastructure must provide
- While not affecting consensus directly, it prevents critical backup operations needed for disaster recovery

## Likelihood Explanation

**High Likelihood:**
- Requires zero authentication or special privileges
- Single HTTP GET request with publicly accessible endpoint
- Trivial to execute: `curl http://backup-service/transaction_range_proof/0/18446744073709551615`
- Deterministic and reproducible on every attempt
- No rate limiting can prevent the first successful crash

## Recommendation

Replace unchecked arithmetic with checked operations that return proper errors:

```rust
pub fn get_transaction_range_proof(
    &self,
    first_version: Version,
    last_version: Version,
) -> Result<(TransactionAccumulatorRangeProof, LedgerInfoWithSignatures)> {
    ensure!(
        last_version >= first_version,
        "Bad transaction range: [{}, {}]",
        first_version,
        last_version
    );
    
    // Use checked arithmetic to prevent overflow
    let num_transactions = last_version
        .checked_sub(first_version)
        .and_then(|diff| diff.checked_add(1))
        .ok_or_else(|| AptosDbError::Other(format!(
            "Transaction range too large: [{}, {}]",
            first_version,
            last_version
        )))?;
    
    let ledger_metadata_db = self.ledger_db.metadata_db();
    let epoch = ledger_metadata_db.get_epoch(last_version)?;
    let ledger_info = ledger_metadata_db.get_latest_ledger_info_in_epoch(epoch)?;
    let accumulator_proof = self
        .ledger_db
        .transaction_accumulator_db()
        .get_transaction_range_proof(
            Some(first_version),
            num_transactions,
            ledger_info.ledger_info().version(),
        )?;
    Ok((accumulator_proof, ledger_info))
}
```

## Proof of Concept

```rust
#[test]
fn test_transaction_range_proof_overflow() {
    use aptos_temppath::TempPath;
    use aptos_db::AptosDB;
    
    let tmpdir = TempPath::new();
    let db = AptosDB::new_for_test(&tmpdir);
    let backup_handler = db.get_backup_handler();
    
    // This should return an error, not panic
    let result = backup_handler.get_transaction_range_proof(0, u64::MAX);
    
    // Currently this panics with overflow in release mode
    // After fix, it should return Err instead
    assert!(result.is_err());
}
```

Alternatively, trigger via HTTP:
```bash
curl -v "http://backup-service-endpoint/transaction_range_proof/0/18446744073709551615"
# Service will crash with exit code 12
```

## Notes

This vulnerability demonstrates that while proper `Result` types are used throughout the BackupHandler API, panics can still escape through arithmetic operations when overflow checks are enabled. Similar patterns should be audited in other methods that perform arithmetic on user-supplied version numbers, particularly in `storage/aptosdb/src/db/aptosdb_reader.rs` which has similar unchecked `last_version - start_version + 1` patterns.

### Citations

**File:** storage/aptosdb/src/backup/backup_handler.rs (L113-124)
```rust
    pub fn get_transaction_range_proof(
        &self,
        first_version: Version,
        last_version: Version,
    ) -> Result<(TransactionAccumulatorRangeProof, LedgerInfoWithSignatures)> {
        ensure!(
            last_version >= first_version,
            "Bad transaction range: [{}, {}]",
            first_version,
            last_version
        );
        let num_transactions = last_version - first_version + 1;
```

**File:** Cargo.toml (L921-923)
```text
[profile.release]
debug = true
overflow-checks = true
```

**File:** storage/backup/backup-service/src/handlers/mod.rs (L114-120)
```rust
    let transaction_range_proof = warp::path!(Version / Version)
        .map(move |first_version, last_version| {
            reply_with_bcs_bytes(
                TRANSACTION_RANGE_PROOF,
                &bh.get_transaction_range_proof(first_version, last_version)?,
            )
        })
```

**File:** crates/crash-handler/src/lib.rs (L26-30)
```rust
pub fn setup_panic_handler() {
    panic::set_hook(Box::new(move |pi: &PanicHookInfo<'_>| {
        handle_panic(pi);
    }));
}
```

**File:** crates/crash-handler/src/lib.rs (L56-57)
```rust
    // Kill the process
    process::exit(12);
```
