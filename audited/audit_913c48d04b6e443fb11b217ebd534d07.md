# Audit Report

## Title
Memory Exhaustion via Unbounded Module Pagination in API Endpoint

## Summary
The `get_modules_by_pagination()` function in the REST API can cause memory exhaustion by loading up to 9,999 large Move modules (each up to 64KB) into memory simultaneously without size validation, potentially consuming ~640MB per request and causing API node crashes through concurrent requests.

## Finding Description

The vulnerability exists in the module pagination endpoint at `/accounts/:address/modules` which calls `get_modules_by_pagination()` to retrieve account modules. The function has three critical flaws: [1](#0-0) 

**Flaw 1: No total size limit**
Unlike `get_state_values()` which enforces `MAX_REQUEST_LIMIT` (20,000 items) and explicitly checks for excess items, `get_modules_by_pagination()` only limits by the user-provided `limit` parameter capped at `max_account_modules_page_size` (9,999): [2](#0-1) [3](#0-2) 

**Flaw 2: Memory allocation per module**
Each module's bytecode is cloned into a new Vec with `v.bytes().to_vec()`, and all modules are collected into memory before returning. For JSON responses, modules are cloned again: [4](#0-3) 

**Flaw 3: No per-module or aggregate size validation**
Modules can be up to 64KB each (transaction size limit): [5](#0-4) 

State write operations allow up to 1MB per item: [6](#0-5) 

**Attack Path:**
1. Attacker deploys 9,999 Move modules of ~64KB each to a controlled account (total ~640MB)
2. Attacker makes concurrent requests: `GET /accounts/{address}/modules?limit=9999`
3. Each request loads all 9,999 modules into API server memory (~640MB per request)
4. With `MAX_BLOCKING_THREADS` = 64, concurrent requests can consume 64 × 640MB = ~40GB
5. API node exhausts memory and crashes [7](#0-6) 

## Impact Explanation

This is **High Severity** per the Aptos Bug Bounty program which lists "API crashes" as a High Severity impact worth up to $50,000.

The vulnerability enables:
- **Denial of Service**: API nodes can be crashed through memory exhaustion
- **Service Degradation**: Multiple concurrent requests amplify memory consumption
- **Node Unavailability**: Critical API infrastructure becomes unresponsive

While not affecting consensus, this breaks the documented invariant "Resource Limits: All operations must respect gas, storage, and computational limits" by allowing unbounded memory allocation in API operations.

## Likelihood Explanation

**Likelihood: Medium-High**

**Attacker Requirements:**
- Ability to deploy modules (requires paying gas and storage fees)
- Economic cost: ~640MB of on-chain storage is expensive but feasible for targeted attacks
- No special permissions required

**Feasibility:**
- Module deployment is permissionless
- API endpoints are publicly accessible
- Concurrent requests can be easily scripted
- No rate limiting mentioned on module size/count

**Amplification:**
- Single malicious account can be reused for multiple attacks
- Concurrent requests multiply the impact
- Attack can target multiple API nodes simultaneously

## Recommendation

Implement multi-layered protections:

**1. Enforce aggregate size limit:**
```rust
pub fn get_modules_by_pagination(
    &self,
    address: AccountAddress,
    prev_state_key: Option<&StateKey>,
    version: u64,
    limit: u64,
) -> Result<(Vec<(ModuleId, Vec<u8>)>, Option<StateKey>)> {
    const MAX_TOTAL_MODULE_BYTES: usize = 10 * 1024 * 1024; // 10MB max total
    
    let mut total_bytes: usize = 0;
    let mut kvs = Vec::new();
    
    let mut module_iter = account_iter
        .filter_map(/* ... */)
        .take(limit as usize + 1);
    
    for item in module_iter.by_ref().take(limit as usize) {
        let (module_id, bytes) = item?;
        total_bytes = total_bytes.checked_add(bytes.len())
            .ok_or_else(|| anyhow!("Total module size overflow"))?;
        
        if total_bytes > MAX_TOTAL_MODULE_BYTES {
            bail!("Total module size exceeds limit of {} bytes", MAX_TOTAL_MODULE_BYTES);
        }
        
        kvs.push((module_id, bytes));
    }
    
    // ... rest of function
}
```

**2. Reduce default page size:**
Lower `DEFAULT_MAX_ACCOUNT_MODULES_PAGE_SIZE` from 9,999 to a more reasonable value like 100-1,000.

**3. Add per-request memory tracking:**
Track cumulative memory allocation per API request and reject requests exceeding a threshold.

## Proof of Concept

**Step 1: Deploy large modules**
```move
// Deploy 100 modules of ~60KB each to address 0xATTACKER
// Each module contains large constant arrays to maximize size
module attacker::large_module_001 {
    const DATA: vector<u8> = x"00010203..."; // ~60KB of data
    public fun dummy() { }
}
// ... repeat for large_module_002 through large_module_100
```

**Step 2: Exploit via API**
```bash
# Monitor API node memory before attack
free -m

# Launch concurrent requests
for i in {1..64}; do
    curl "http://api-node:8080/v1/accounts/0xATTACKER/modules?limit=9999" &
done

# Observe memory exhaustion
free -m
# API node crashes or becomes unresponsive
```

**Expected Result:**
- Memory usage spikes by 100 × 60KB × 64 requests = ~384MB (for 100 modules)
- With 9,999 modules, consumption reaches ~40GB
- API node OOM kills or service degradation

**Verification:**
- Check API node logs for OOM errors
- Monitor response times (should degrade significantly)
- Verify `/metrics` endpoint shows memory pressure

## Notes

The vulnerability is particularly concerning because:
1. Similar functions like `get_resources_by_pagination()` have the same pattern but resources are typically smaller than modules
2. The API configuration allows operators to set `max_account_modules_page_size` arbitrarily high
3. No documentation warns about memory implications of large limits
4. The issue compounds with JSON responses due to additional cloning during ABI parsing

This represents a design flaw where API pagination limits were set based on item count rather than total data size, violating the principle of bounded resource consumption.

### Citations

**File:** api/src/context.rs (L438-468)
```rust
    pub fn get_state_values(
        &self,
        address: AccountAddress,
        version: u64,
    ) -> Result<HashMap<StateKey, StateValue>> {
        let mut iter = if !db_sharding_enabled(&self.node_config) {
            Box::new(
                self.db
                    .get_prefixed_state_value_iterator(
                        &StateKeyPrefix::from(address),
                        None,
                        version,
                    )?
                    .map(|item| item.map_err(|err| anyhow!(err.to_string()))),
            )
        } else {
            self.indexer_reader
                .as_ref()
                .ok_or_else(|| format_err!("Indexer reader doesn't exist"))?
                .get_prefixed_state_value_iterator(&StateKeyPrefix::from(address), None, version)?
        };

        let kvs = iter
            .by_ref()
            .take(MAX_REQUEST_LIMIT as usize)
            .collect::<Result<_>>()?;
        if iter.next().transpose()?.is_some() {
            bail!("Too many state items under account ({:?}).", address);
        }
        Ok(kvs)
    }
```

**File:** api/src/context.rs (L561-615)
```rust
    pub fn get_modules_by_pagination(
        &self,
        address: AccountAddress,
        prev_state_key: Option<&StateKey>,
        version: u64,
        limit: u64,
    ) -> Result<(Vec<(ModuleId, Vec<u8>)>, Option<StateKey>)> {
        let account_iter = if !db_sharding_enabled(&self.node_config) {
            Box::new(
                self.db
                    .get_prefixed_state_value_iterator(
                        &StateKeyPrefix::from(address),
                        prev_state_key,
                        version,
                    )?
                    .map(|item| item.map_err(|err| anyhow!(err.to_string()))),
            )
        } else {
            self.indexer_reader
                .as_ref()
                .ok_or_else(|| format_err!("Indexer reader doesn't exist"))?
                .get_prefixed_state_value_iterator(
                    &StateKeyPrefix::from(address),
                    prev_state_key,
                    version,
                )?
        };
        let mut module_iter = account_iter
            .filter_map(|res| match res {
                Ok((k, v)) => match k.inner() {
                    StateKeyInner::AccessPath(AccessPath { address: _, path }) => {
                        match Path::try_from(path.as_slice()) {
                            Ok(Path::Code(module_id)) => Some(Ok((module_id, v.bytes().to_vec()))),
                            Ok(Path::Resource(_)) | Ok(Path::ResourceGroup(_)) => None,
                            Err(e) => Some(Err(anyhow::Error::from(e))),
                        }
                    }
                    _ => {
                        error!("storage prefix scan return inconsistent key ({:?}) with expected key prefix ({:?}).", k, StateKeyPrefix::from(address));
                        Some(Err(format_err!( "storage prefix scan return inconsistent key ({:?})", k )))
                    }
                },
                Err(e) => Some(Err(e)),
            })
            .take(limit as usize + 1);
        let kvs = module_iter
            .by_ref()
            .take(limit as usize)
            .collect::<Result<_>>()?;
        let next_key = module_iter
            .next()
            .transpose()?
            .map(|(module_id, _v)| StateKey::module_id(&module_id));
        Ok((kvs, next_key))
    }
```

**File:** config/src/config/api_config.rs (L101-101)
```rust
const DEFAULT_MAX_ACCOUNT_MODULES_PAGE_SIZE: u16 = 9999;
```

**File:** api/src/accounts.rs (L518-541)
```rust
    pub fn modules(self, accept_type: &AcceptType) -> BasicResultWith404<Vec<MoveModuleBytecode>> {
        let max_account_modules_page_size = self.context.max_account_modules_page_size();
        let (modules, next_state_key) = self
            .context
            .get_modules_by_pagination(
                self.address.into(),
                self.start.as_ref(),
                self.ledger_version,
                // Just use the max as the default
                determine_limit(
                    self.limit,
                    max_account_modules_page_size,
                    max_account_modules_page_size,
                    &self.latest_ledger_info,
                )? as u64,
            )
            .context("Failed to get modules from storage")
            .map_err(|err| {
                BasicErrorWith404::internal_with_code(
                    err,
                    AptosErrorCode::InternalError,
                    &self.latest_ledger_info,
                )
            })?;
```

**File:** api/src/accounts.rs (L543-560)
```rust
        match accept_type {
            AcceptType::Json => {
                // Read bytecode and parse ABIs for output
                let mut converted_modules = Vec::new();
                for (_, module) in modules {
                    converted_modules.push(
                        MoveModuleBytecode::new(module.clone())
                            .try_parse_abi()
                            .context("Failed to parse move module ABI")
                            .map_err(|err| {
                                BasicErrorWith404::internal_with_code(
                                    err,
                                    AptosErrorCode::InternalError,
                                    &self.latest_ledger_info,
                                )
                            })?,
                    );
                }
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L73-76)
```rust
            max_transaction_size_in_bytes: NumBytes,
            "max_transaction_size_in_bytes",
            64 * 1024
        ],
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L154-157)
```rust
            max_bytes_per_write_op: NumBytes,
            { 5.. => "max_bytes_per_write_op" },
            1 << 20, // a single state item is 1MB max
        ],
```
