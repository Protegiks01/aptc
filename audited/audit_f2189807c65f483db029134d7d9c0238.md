# Audit Report

## Title
Module Metadata Spoofing via Package Name Collision in RestDebuggerInterface

## Summary
The `check_and_obtain_source_code()` function in `rest_interface.rs` validates package identity based solely on the package name without verifying the deployment address. An attacker can publish a package at their own address with a name matching an Aptos framework package (e.g., "AptosFramework"), causing the debugger interface to incorrectly map their modules to `AccountAddress::ONE` (0x1) instead of the attacker's actual address.

## Finding Description

The vulnerability exists in the package identity validation logic within the `check_and_obtain_source_code()` function. The function retrieves the `PackageRegistry` from the correct address but then performs an address-agnostic check: [1](#0-0) 

The check `APTOS_PACKAGES.contains(&target_package.name.as_str())` only validates the package **name**, not whether the package is actually deployed at address 0x1. The `APTOS_PACKAGES` constant is defined as: [2](#0-1) 

**Attack Scenario:**

1. Attacker publishes a package at their address `0xATTACKER`
2. The attacker names their package "AptosFramework" (or any name from `APTOS_PACKAGES`)
3. The package contains modules with names like "coin", "account", etc., matching framework module names
4. When the RestDebuggerInterface processes a transaction calling `0xATTACKER::coin::transfer`:
   - The function correctly fetches `PackageRegistry` from `0xATTACKER` 
   - The `locate_package_with_src` closure finds the attacker's package (named "AptosFramework") containing a module named "coin"
   - Because "AptosFramework" is in `APTOS_PACKAGES`, the code forces the address to `AccountAddress::ONE`
   - The module `0xATTACKER::coin` is incorrectly cached as belonging to address `0x1`

The root cause is in the `locate_package_with_src` closure, which only checks module names without verifying the full module identity: [3](#0-2) 

The comparison at line 141 checks `module_metadata.name == module.name().as_str()` but doesn't validate that the module's address matches the expected address. Combined with the package name check that lacks address validation, this enables metadata spoofing.

## Impact Explanation

This vulnerability has **High** severity impact on the debugging and testing infrastructure:

**Direct Impact:**
- **Testing Infrastructure Compromise**: The E2E comparison testing system relies on accurate package metadata to compile and validate transactions. Spoofed metadata undermines test reliability.
- **Debugging Confusion**: Developers debugging transactions will see incorrect module-to-address mappings, potentially obscuring real security issues.
- **Source Code Misattribution**: The system may display or use source code from the wrong package when analyzing transactions.

**Downstream Implications:**
The cached incorrect mappings are used in: [4](#0-3) 

While this doesn't directly affect consensus or allow fund theft, it represents a **significant protocol violation** per the bug bounty criteria. The integrity of testing and validation infrastructure is critical for maintaining blockchain security. Compromised testing tools can mask vulnerabilities or create false confidence in code correctness.

## Likelihood Explanation

**Likelihood: High**

The attack requires only standard package publishing capabilities:
- No special permissions needed
- No validator access required
- Simple to execute: publish a package with a specific name
- Zero cost beyond standard gas fees
- Difficult to detect without specific monitoring

The on-chain validation in `code.move` prevents module name clashes **within the same address** but explicitly allows packages at different addresses to have identical names: [5](#0-4) 

This check only prevents coexistence issues at a single address, not cross-address name spoofing.

## Recommendation

Add address validation when checking for Aptos framework packages. The package name check must be accompanied by an address verification:

```rust
let target_package_opt = locate_package_with_src(m, &package_registry.packages);
if let Some(target_package) = target_package_opt {
    let mut map = HashMap::new();
    // FIX: Verify both package name AND address for Aptos packages
    if APTOS_PACKAGES.contains(&target_package.name.as_str()) && *addr == AccountAddress::ONE {
        package_cache.insert(
            m.clone(),
            (
                AccountAddress::ONE,
                target_package.name.clone(),
                HashMap::new(),
            ),
        );
        // ... rest of Aptos package handling
    } else if APTOS_PACKAGES.contains(&target_package.name.as_str()) && *addr != AccountAddress::ONE {
        // Package name matches Aptos packages but deployed at wrong address - potential spoofing
        // Log warning and skip this transaction
        eprintln!("Warning: Package '{}' at address {} has name matching Aptos framework but is not at 0x1", 
                  target_package.name, addr);
        return Ok(());
    } else if let Ok(()) = retrieve_dep_packages_with_src(
        // ... existing non-Aptos package handling
    }
}
```

Additionally, enhance the `locate_package_with_src` closure to verify module address when available.

## Proof of Concept

**Move Package Publication Test:**

```move
module 0xATTACKER::spoofed_coin {
    public entry fun transfer() {
        // Malicious implementation
    }
}
```

**Package Metadata:**
```rust
// Publish this package at address 0xATTACKER with:
PackageMetadata {
    name: "AptosFramework".to_string(),  // Spoofed name!
    upgrade_policy: UpgradePolicy { policy: 1 },
    upgrade_number: 0,
    source_digest: "...".to_string(),
    manifest: vec![...],
    modules: vec![
        ModuleMetadata {
            name: "coin".to_string(),  // Matches framework module name
            source: vec![/* source code */],
            source_map: vec![],
            extension: None,
        }
    ],
    deps: vec![],
    extension: None,
}
```

**Exploitation Steps:**
1. Deploy the package with `publish_package_txn` at address `0xATTACKER` with name "AptosFramework"
2. Execute a transaction calling `0xATTACKER::spoofed_coin::transfer`
3. Query the RestDebuggerInterface with `get_and_filter_committed_transactions`
4. Observe that the module cache maps `0xATTACKER::spoofed_coin` to `(AccountAddress::ONE, "AptosFramework", {})`
5. The debugger incorrectly associates the attacker's module with the Aptos Framework

**Validation:**
The vulnerability can be confirmed by examining the `package_cache` after processing such a transaction - the ModuleId will be mapped to address 0x1 despite originating from 0xATTACKER.

---

**Notes:**

This vulnerability specifically affects the `RestDebuggerInterface` used for transaction replay and E2E testing. While it doesn't directly compromise consensus or enable fund theft, it undermines the integrity of critical development and validation infrastructure. The fix requires adding address validation alongside the existing package name checks to prevent metadata spoofing attacks.

### Citations

**File:** aptos-move/aptos-validator-interface/src/rest_interface.rs (L137-151)
```rust
    let locate_package_with_src =
        |module: &ModuleId, packages: &[PackageMetadata]| -> Option<PackageMetadata> {
            for package in packages {
                for module_metadata in &package.modules {
                    if module_metadata.name == module.name().as_str() {
                        if module_metadata.source.is_empty() || package.upgrade_policy.policy == 0 {
                            return None;
                        } else {
                            return Some(package.clone());
                        }
                    }
                }
            }
            None
        };
```

**File:** aptos-move/aptos-validator-interface/src/rest_interface.rs (L158-165)
```rust
        if APTOS_PACKAGES.contains(&target_package.name.as_str()) {
            package_cache.insert(
                m.clone(),
                (
                    AccountAddress::ONE,
                    target_package.name.clone(), // all aptos packages are stored under 0x1
                    HashMap::new(),
                ),
```

**File:** aptos-move/framework/src/built_package.rs (L57-64)
```rust
pub const APTOS_PACKAGES: [&str; 6] = [
    "AptosFramework",
    "MoveStdlib",
    "AptosStdlib",
    "AptosToken",
    "AptosTokenObjects",
    "AptosExperimental",
];
```

**File:** aptos-move/aptos-e2e-comparison-testing/src/data_collection.rs (L298-312)
```rust
                        if let Some((address, package_name, map)) = source_code_data {
                            let package_info_opt = Self::dump_and_check_src(
                                version,
                                address,
                                package_name,
                                map,
                                &mut compilation_cache.lock().unwrap(),
                                current_dir.clone(),
                                &base_experiments,
                            );
                            if package_info_opt.is_none() {
                                return;
                            }
                            version_idx.package_info = package_info_opt.unwrap();
                        }
```

**File:** aptos-move/framework/aptos-framework/sources/code.move (L282-293)
```text
    fun check_coexistence(old_pack: &PackageMetadata, new_modules: &vector<String>) {
        // The modules introduced by each package must not overlap with `names`.
        vector::for_each_ref(&old_pack.modules, |old_mod| {
            let old_mod: &ModuleMetadata = old_mod;
            let j = 0;
            while (j < vector::length(new_modules)) {
                let name = vector::borrow(new_modules, j);
                assert!(&old_mod.name != name, error::already_exists(EMODULE_NAME_CLASH));
                j = j + 1;
            };
        });
    }
```
