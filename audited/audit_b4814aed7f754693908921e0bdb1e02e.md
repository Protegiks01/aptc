# Audit Report

## Title
Resource Group Deletion Invariant Violation: Deleted Groups Can Incorrectly Report Resource Existence

## Summary
The `resource_exists_in_group()` function in `ExecutorViewWithChangeSet` fails to validate that when a resource group's `metadata_op` indicates deletion, all resources in `inner_ops` should also be deletions. During multi-session change set squashing, this can result in a deleted resource group (metadata_op = Deletion) still containing resources with `Some(bytes)` in `inner_ops`, causing `resource_exists_in_group()` to incorrectly report that resources exist when the entire group has been deleted. This breaks the documented resource group deletion invariant and can lead to incorrect transaction validation decisions.

## Finding Description

The vulnerability exists in the interaction between three components:

**1. The `resource_exists_in_group()` Implementation**

The function checks resource existence by examining `inner_ops` without validating the group's deletion state: [1](#0-0) 

The function returns `true` if `write_op.bytes().is_some()` for any resource in `inner_ops`, regardless of whether `metadata_op` indicates the entire group is deleted.

**2. The GroupWrite Invariant**

The `GroupWrite` struct documents a critical invariant that should be maintained: [2](#0-1) 

This states: "If the metadata_op is a deletion, all (correct) inner_ops should be deletions." The comment acknowledges this invariant can be violated during speculative execution, but should be caught during validation.

**3. The Squashing Logic Flaw**

When squashing two `GroupWrite` operations, the code only squashes `inner_ops` entries that exist in both sets: [3](#0-2) 

The critical issue is at lines 623-626: `squash_additional_resource_write_ops` only updates entries present in the additional change set. Resources in the base `inner_ops` that aren't in the additional set remain unchanged, even when `metadata_op` transitions to Deletion.

**Attack Scenario:**

1. **Session 1 (User Transaction)**: Modifies resource R1 in a group:
   - `metadata_op = Modification`
   - `inner_ops = {R1: Modification with Some(bytes)}`

2. **Session 2 (Epilogue/System)**: Deletes the entire group by removing the last remaining resources R2 and R3, but doesn't touch R1 which was already modified:
   - `metadata_op = Deletion` (post_group_size = 0)
   - `inner_ops = {R2: Deletion, R3: Deletion}`

3. **Squashing Result**:
   - `metadata_op`: Modification + Deletion â†’ **Deletion**
   - `inner_ops`: R1 remains as Modification (not in additional), R2 and R3 become Deletion
   - **Final State**: `metadata_op = Deletion`, `inner_ops = {R1: Modification with Some(bytes), R2: Deletion, R3: Deletion}`

4. **Exploitation**: When validation code checks resource existence: [4](#0-3) 

The code at line 419 calls `resource_exists_in_group()` which incorrectly returns `true` for R1 (because it has Some bytes), even though the group is deleted. This causes:
- **New operations** on R1 to be rejected (line 420-423) when they should succeed (the resource doesn't exist in a deleted group)
- **Modify/Delete operations** on R1 to succeed when they should fail (the resource doesn't exist)

## Impact Explanation

**Severity: High** (State Inconsistencies and Validation Bypass)

This vulnerability breaks the **State Consistency** and **Deterministic Execution** invariants:

1. **Incorrect Transaction Validation**: The existence check at validation time (lines 417-424 in session/mod.rs) can produce incorrect results, allowing operations that should fail or blocking operations that should succeed.

2. **Consensus Divergence Risk**: If different validators execute multi-session transactions with different timing or encounter this condition in different orders, they could make different validation decisions, potentially leading to state divergence.

3. **State Corruption**: Allowing modifications to resources that don't exist (because their group is deleted) can lead to inconsistent state that violates Move's resource semantics.

4. **Validation Bypass**: The eventual validation in `map_finalized_group` occurs during finalization: [5](#0-4) 

However, by the time this validation runs, incorrect decisions may have already been made based on the incorrect `resource_exists_in_group()` results during transaction execution.

While this doesn't directly cause fund loss, it represents a significant protocol violation that can lead to state inconsistencies requiring manual intervention, which qualifies as **High severity** per the bug bounty criteria ("Significant protocol violations").

## Likelihood Explanation

**Likelihood: Medium-to-High**

This vulnerability is triggered whenever:
1. A transaction uses multiple sessions (common: user transaction + epilogue)
2. The first session modifies resources in a group
3. The second session deletes the entire group but only explicitly touches some resources
4. Subsequent validation checks resource existence

The multi-session pattern occurs in standard transaction execution: [6](#0-5) 

`RespawnedSession` is used to execute epilogue logic after the main transaction, creating exactly the conditions needed for this bug. Any transaction that modifies a resource group in the user session and then has the epilogue delete that group could trigger this issue.

The vulnerability requires specific but realistic conditions, making it exploitable by attackers who understand the multi-session execution model.

## Recommendation

**Fix 1: Add Metadata Check in `resource_exists_in_group()`**

Modify the function to check if the group is deleted before reporting existence:

```rust
fn resource_exists_in_group(
    &self,
    group_key: &Self::GroupKey,
    resource_tag: &Self::ResourceTag,
) -> PartialVMResult<bool> {
    self.try_get_group_write_from_change_set(group_key, "resource_exists_in_group")?
        .and_then(|group_write| {
            // If the group is being deleted, no resources exist
            if group_write.metadata_op().is_deletion() {
                return None; // Fall through to base view
            }
            group_write.inner_ops().get(resource_tag)
        })
        .map_or_else(
            || {
                self.base_resource_group_view
                    .resource_exists_in_group(group_key, resource_tag)
            },
            |(write_op, _layout)| Ok(write_op.bytes().is_some()),
        )
}
```

**Fix 2: Enhanced Squashing Validation**

Add validation in `squash_additional_resource_writes` to ensure that when `metadata_op` becomes Deletion after squashing, all `inner_ops` are also deletions:

```rust
// After squashing inner_ops and updating metadata_op
if group.metadata_op.is_deletion() {
    // Verify all inner_ops are deletions
    for (tag, (write_op, _)) in group.inner_ops.iter() {
        if write_op.bytes().is_some() {
            return Err(code_invariant_error(format!(
                "Resource group marked for deletion but inner op for tag {:?} has data",
                tag
            )));
        }
    }
}
```

**Fix 3: Clear Inner Ops on Group Deletion**

When metadata_op transitions to Deletion during squashing, clear or mark all remaining inner_ops as deletions.

## Proof of Concept

```rust
#[test]
fn test_resource_group_deletion_invariant_violation() {
    use crate::abstract_write_op::{AbstractResourceWriteOp, GroupWrite};
    use crate::change_set::VMChangeSet;
    use crate::resolver::ResourceGroupSize;
    use aptos_types::state_store::state_key::StateKey;
    use aptos_types::write_set::WriteOp;
    use move_core_types::language_storage::StructTag;
    use move_core_types::account_address::AccountAddress;
    use move_core_types::identifier::Identifier;
    use move_core_types::language_storage::TypeTag;
    use std::collections::BTreeMap;
    
    fn mock_tag_r1() -> StructTag {
        StructTag {
            address: AccountAddress::ONE,
            module: Identifier::new("test").unwrap(),
            name: Identifier::new("R1").unwrap(),
            type_args: vec![],
        }
    }
    
    fn mock_tag_r2() -> StructTag {
        StructTag {
            address: AccountAddress::ONE,
            module: Identifier::new("test").unwrap(),
            name: Identifier::new("R2").unwrap(),
            type_args: vec![],
        }
    }
    
    let group_key = StateKey::raw(b"test_group");
    
    // Session 1: Modify R1
    let mut base_write_set = BTreeMap::new();
    let base_inner_ops = BTreeMap::from([
        (mock_tag_r1(), (WriteOp::legacy_modification(vec![1, 2, 3].into()), None)),
    ]);
    let base_group = GroupWrite::new(
        WriteOp::legacy_modification(vec![].into()),
        base_inner_ops,
        ResourceGroupSize::Combined {
            num_tagged_resources: 1,
            all_tagged_resources_size: 100,
        },
        100,
    );
    base_write_set.insert(
        group_key.clone(),
        AbstractResourceWriteOp::WriteResourceGroup(base_group),
    );
    
    // Session 2: Delete group by removing R2 (doesn't touch R1)
    let mut additional_write_set = BTreeMap::new();
    let additional_inner_ops = BTreeMap::from([
        (mock_tag_r2(), (WriteOp::legacy_deletion(), None)),
    ]);
    let additional_group = GroupWrite::new(
        WriteOp::legacy_deletion(), // Group is being deleted
        additional_inner_ops,
        ResourceGroupSize::zero_combined(),
        100,
    );
    additional_write_set.insert(
        group_key.clone(),
        AbstractResourceWriteOp::WriteResourceGroup(additional_group),
    );
    
    // Squash the change sets
    VMChangeSet::squash_additional_resource_writes(
        &mut base_write_set,
        additional_write_set,
    ).unwrap();
    
    // Extract the squashed result
    if let Some(AbstractResourceWriteOp::WriteResourceGroup(squashed_group)) = 
        base_write_set.get(&group_key) {
        
        // BUG DEMONSTRATED: 
        // metadata_op is Deletion (group is deleted)
        assert!(squashed_group.metadata_op().is_deletion(), 
                "Group metadata_op should be Deletion");
        
        // BUT inner_ops still has R1 with Some(bytes)
        let r1_op = squashed_group.inner_ops().get(&mock_tag_r1());
        assert!(r1_op.is_some(), "R1 should still be in inner_ops");
        
        let (r1_write_op, _) = r1_op.unwrap();
        assert!(r1_write_op.bytes().is_some(), 
                "R1 should have Some(bytes) - THIS IS THE BUG!");
        
        // This violates the invariant: when metadata_op is Deletion,
        // all inner_ops should be deletions (with None bytes)
        println!("VULNERABILITY CONFIRMED:");
        println!("  Group marked as DELETED (metadata_op.is_deletion() = true)");
        println!("  But R1 still has data in inner_ops (bytes = {:?})", 
                 r1_write_op.bytes().unwrap());
        println!("  This will cause resource_exists_in_group() to return true");
        println!("  even though the group is deleted!");
    } else {
        panic!("Expected WriteResourceGroup after squashing");
    }
}
```

This test demonstrates that after squashing, a resource group can have `metadata_op = Deletion` while `inner_ops` still contains resources with `Some(bytes)`, violating the documented invariant and causing incorrect existence checks.

## Notes

The vulnerability exists at the intersection of multiple components and is exacerbated by the fact that:

1. The documented invariant in `GroupWrite` acknowledges it can be violated during speculative execution, but the validation that should catch it (`map_finalized_group`) only runs during finalization, after `resource_exists_in_group()` has already been used for validation decisions.

2. The `RespawnedSession` pattern is used throughout transaction execution, making this scenario common rather than exceptional.

3. The similar functions `get_resource_from_group()` and `resource_size_in_group()` have the same flaw - they don't check `metadata_op` before returning data from `inner_ops`. [7](#0-6) 

A comprehensive fix should address all three functions to ensure consistent behavior.

### Citations

**File:** aptos-move/aptos-vm/src/move_vm_ext/session/view_with_change_set.rs (L313-350)
```rust
    fn get_resource_from_group(
        &self,
        group_key: &Self::GroupKey,
        resource_tag: &Self::ResourceTag,
        maybe_layout: Option<&Self::Layout>,
    ) -> PartialVMResult<Option<Bytes>> {
        self.try_get_group_write_from_change_set(group_key, "get_resource_from_group")?
            .and_then(|group_write| group_write.inner_ops().get(resource_tag))
            .map_or_else(
                || {
                    self.base_resource_group_view.get_resource_from_group(
                        group_key,
                        resource_tag,
                        maybe_layout,
                    )
                },
                |(write_op, layout)| {
                    randomly_check_layout_matches(maybe_layout, layout.as_deref())?;
                    Ok(write_op.extract_raw_bytes())
                },
            )
    }

    fn resource_size_in_group(
        &self,
        group_key: &Self::GroupKey,
        resource_tag: &Self::ResourceTag,
    ) -> PartialVMResult<usize> {
        self.try_get_group_write_from_change_set(group_key, "resource_size_in_group")?
            .and_then(|group_write| group_write.inner_ops().get(resource_tag))
            .map_or_else(
                || {
                    self.base_resource_group_view
                        .resource_size_in_group(group_key, resource_tag)
                },
                |(write_op, _layout)| Ok(write_op.bytes_size()),
            )
    }
```

**File:** aptos-move/aptos-vm/src/move_vm_ext/session/view_with_change_set.rs (L352-366)
```rust
    fn resource_exists_in_group(
        &self,
        group_key: &Self::GroupKey,
        resource_tag: &Self::ResourceTag,
    ) -> PartialVMResult<bool> {
        self.try_get_group_write_from_change_set(group_key, "resource_exists_in_group")?
            .and_then(|group_write| group_write.inner_ops().get(resource_tag))
            .map_or_else(
                || {
                    self.base_resource_group_view
                        .resource_exists_in_group(group_key, resource_tag)
                },
                |(write_op, _layout)| Ok(write_op.bytes().is_some()),
            )
    }
```

**File:** aptos-move/aptos-vm-types/src/abstract_write_op.rs (L160-166)
```rust
    /// If the metadata_op is a deletion, all (correct) inner_ops should be deletions,
    /// and if metadata_op is a creation, then there may not be a creation inner op.
    /// Not vice versa, e.g. for deleted inner ops, other untouched resources may still
    /// exist in the group. Note: During parallel block execution, due to speculative
    /// reads, this invariant may be violated (and lead to speculation error if observed)
    /// but guaranteed to fail validation and lead to correct re-execution in that case.
    pub(crate) inner_ops: BTreeMap<StructTag, (WriteOp, Option<TriompheArc<MoveTypeLayout>>)>,
```

**File:** aptos-move/aptos-vm-types/src/change_set.rs (L600-636)
```rust
                            WriteResourceGroup(group),
                            WriteResourceGroup(GroupWrite {
                                metadata_op: additional_metadata_op,
                                inner_ops: additional_inner_ops,
                                maybe_group_op_size: additional_maybe_group_op_size,
                                prev_group_size: _, // n.b. group.prev_group_size deliberately kept as is
                            }),
                        ) => {
                            // Squashing creation and deletion is a no-op. In that case, we have to
                            // remove the old GroupWrite from the group write set.
                            let to_delete = !WriteOp::squash(
                                &mut group.metadata_op,
                                additional_metadata_op.clone(),
                            )
                            .map_err(|e| {
                                code_invariant_error(format!(
                                    "Error while squashing two group write metadata ops: {}.",
                                    e
                                ))
                            })?;
                            if to_delete {
                                (true, false)
                            } else {
                                Self::squash_additional_resource_write_ops(
                                    &mut group.inner_ops,
                                    additional_inner_ops.clone(),
                                )?;

                                group.maybe_group_op_size = *additional_maybe_group_op_size;

                                //
                                // n.b. group.prev_group_size deliberately kept as is
                                //

                                (false, false)
                            }
                        },
```

**File:** aptos-move/aptos-vm/src/move_vm_ext/session/mod.rs (L417-424)
```rust
                        for (struct_tag, current_op) in resources.iter() {
                            let exists =
                                resolver.resource_exists_in_group(&state_key, struct_tag)?;
                            if matches!(current_op, MoveStorageOp::New(_)) == exists {
                                // Deletion and Modification require resource to exist,
                                // while creation requires the resource to not exist.
                                return Err(common_error());
                            }
```

**File:** aptos-move/block-executor/src/executor_utilities.rs (L110-116)
```rust
    } else if finalized_group.is_empty() != metadata_is_deletion {
        // finalize_group already applies the deletions.
        Err(code_invariant_error(format!(
            "Group is empty = {} but op is deletion = {} in parallel execution",
            finalized_group.is_empty(),
            metadata_is_deletion
        )))
```

**File:** aptos-move/aptos-vm/src/move_vm_ext/session/respawned_session.rs (L38-49)
```rust
    pub fn spawn(
        vm: &AptosVM,
        session_id: SessionId,
        base: &'r impl AptosMoveResolver,
        previous_session_change_set: VMChangeSet,
        user_transaction_context_opt: Option<UserTransactionContext>,
    ) -> RespawnedSession<'r> {
        let executor_view = ExecutorViewWithChangeSet::new(
            base.as_executor_view(),
            base.as_resource_group_view(),
            previous_session_change_set,
        );
```
