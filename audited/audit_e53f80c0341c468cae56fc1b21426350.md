# Audit Report

## Title
Signature Verification Bypass via Epoch-Round Mismatch in SyncInfo Validation

## Summary
The validation at lines 173-176 in `sync_info.rs` uses structural equality to check that `highest_commit_cert` is not empty, but fails to validate the semantic invariant that `round == 0` should only occur at `epoch == 0` (genesis). This allows an attacker to craft a `BlockInfo` with a non-zero epoch and zero round, bypassing signature verification.

## Finding Description

The `SyncInfo::verify()` function contains a critical validation weakness. The check at lines 173-176 validates: [1](#0-0) 

This check uses the `!=` operator against `BlockInfo::empty()`, which is defined as: [2](#0-1) 

**The Core Issue:**
The validation only ensures the commit_info is not *structurally equal* to the specific empty instance (epoch=0, round=0, all fields zero). An attacker can craft a `BlockInfo` with:
- `epoch = E` (matching current network epoch, e.g., 1)
- `round = 0`
- All other fields zero/None

This BlockInfo is NOT equal to `BlockInfo::empty()` because the epoch field differs (E ≠ 0), so it passes the empty check.

**Signature Verification Bypass:**
Subsequently, at lines 196-202, signature verification is conditionally performed: [3](#0-2) 

Since `round == 0`, signature verification is completely SKIPPED. This is intentional for genesis blocks, but the validation doesn't enforce that round 0 should ONLY be valid when epoch is also 0.

Additionally, the `WrappedLedgerInfo::verify()` implementation shows similar logic: [4](#0-3) 

The TODO comment at line 95-97 even acknowledges uncertainty about this validation logic change.

**Attack Scenario:**
1. Network operates at epoch E (e.g., 1), validators have commit round R (e.g., 100)
2. Attacker crafts SyncInfo with:
   - `highest_quorum_cert`: Valid, properly signed QC for epoch E, round R+10
   - `highest_ordered_cert`: Valid cert for epoch E, round R+5
   - `highest_commit_cert`: Malicious cert with epoch=E, round=0, no signatures
3. Victim node receives and validates the SyncInfo
4. All validation checks pass:
   - Epoch consistency checks pass (all match E) [5](#0-4) 
   - Round ordering checks pass (R+10 ≥ R+5 ≥ 0) [6](#0-5) 
   - Empty check passes (epoch E ≠ 0)
   - HQC/HOC signatures verify (they're valid)
   - HCC signature verification is SKIPPED (round == 0)

## Impact Explanation

**Severity Assessment: High**

This vulnerability allows an attacker to bypass signature verification for commit certificates, violating the fundamental cryptographic correctness invariant (Invariant #10). While the immediate practical impact is limited because nodes won't sync to a round-0 certificate in a running network, this represents a significant protocol violation:

1. **Signature Verification Bypass**: The core security guarantee that all certificates must be properly signed is violated
2. **Validation Inconsistency**: The system accepts as "valid" a state that violates the semantic invariant (round=0 should only exist at epoch=0)
3. **Potential for Combined Attacks**: This could be exploited in conjunction with other vulnerabilities, such as during epoch transitions or node startup scenarios

This meets the **High Severity** criteria under "Significant protocol violations" in the Aptos bug bounty program.

## Likelihood Explanation

**Likelihood: Medium**

The attack is straightforward to execute:
- No special validator privileges required
- Can be triggered by any network peer sending a malicious SyncInfo message
- The malicious SyncInfo will pass all validation checks

However, the practical exploitation window is limited because:
- Nodes in a running network won't sync to round-0 certificates
- The invalid certificate doesn't trigger actual state changes in normal operation

## Recommendation

Add an explicit check to enforce the invariant that `round == 0` must only occur at `epoch == 0`:

```rust
// After line 175, add:
ensure!(
    self.highest_commit_cert().commit_info().round() == 0 
        && self.highest_commit_cert().commit_info().epoch() == 0
        || self.highest_commit_cert().commit_info().round() > 0,
    "Invalid epoch-round combination: round 0 must only occur at epoch 0"
);
```

Or more simply, strengthen the genesis check:

```rust
// At line 196-202, replace with:
if self.highest_commit_cert.commit_info().round() == 0 {
    ensure!(
        self.highest_commit_cert.commit_info().epoch() == 0,
        "Genesis certificate (round 0) must have epoch 0, got epoch {}",
        self.highest_commit_cert.commit_info().epoch()
    );
} else {
    self.highest_commit_cert
        .verify(validator)
        .context("Fail to verify commit certificate")?
}
```

Apply the same fix to `WrappedLedgerInfo::verify()` to ensure consistency across the codebase.

## Proof of Concept

```rust
#[test]
fn test_sync_info_accepts_invalid_epoch_round_combination() {
    use consensus_types::sync_info::SyncInfo;
    use types::block_info::BlockInfo;
    use aptos_crypto::hash::HashValue;
    
    // Create a valid HQC for epoch 1, round 10
    let valid_qc = create_valid_qc(1, 10);
    
    // Create a valid HOC for epoch 1, round 5  
    let valid_hoc = create_valid_wrapped_ledger_info(1, 5);
    
    // Create malicious HCC with epoch 1, round 0, no signatures
    let malicious_commit_info = BlockInfo::new(
        1,  // epoch = 1 (not genesis!)
        0,  // round = 0 (triggers signature skip)
        HashValue::zero(),
        HashValue::zero(),
        0,
        1,  // timestamp != 0 to avoid exact match with empty()
        None,
    );
    
    let malicious_hcc = WrappedLedgerInfo::new(
        VoteData::dummy(),
        LedgerInfoWithSignatures::new(
            LedgerInfo::new(malicious_commit_info, HashValue::zero()),
            AggregateSignature::empty(),  // No signatures!
        ),
    );
    
    let sync_info = SyncInfo::new_decoupled(
        valid_qc,
        valid_hoc,
        malicious_hcc,
        None,
    );
    
    // This SHOULD fail but currently PASSES
    assert!(sync_info.verify(&validator_verifier).is_ok());
    
    // The malicious HCC has round=0 but epoch=1, violating the invariant
    assert_eq!(sync_info.highest_commit_cert().commit_info().epoch(), 1);
    assert_eq!(sync_info.highest_commit_cert().commit_info().round(), 0);
    
    // And signature verification was skipped!
    assert_eq!(sync_info.highest_commit_cert().ledger_info().get_num_voters(), 0);
}
```

**Notes:**
- The vulnerability exists in the validation logic that fails to enforce the semantic relationship between epoch and round
- The check at lines 173-176 only validates structural inequality, not semantic correctness
- This allows signature verification bypass for non-genesis blocks by exploiting round=0 behavior
- The fix should explicitly validate that round=0 implies epoch=0 before skipping signature verification

### Citations

**File:** consensus/consensus-types/src/sync_info.rs (L140-146)
```rust
        ensure!(
            epoch == self.highest_ordered_cert().commit_info().epoch(),
            "Multi epoch in SyncInfo - HOC and HQC"
        );
        ensure!(
            epoch == self.highest_commit_cert().commit_info().epoch(),
            "Multi epoch in SyncInfo - HOC and HCC"
```

**File:** consensus/consensus-types/src/sync_info.rs (L152-165)
```rust
        ensure!(
            self.highest_quorum_cert.certified_block().round()
                >= self.highest_ordered_cert().commit_info().round(),
            "HQC has lower round than HOC"
        );

        ensure!(
            self.highest_ordered_round() >= self.highest_commit_round(),
            format!(
                "HOC {} has lower round than HLI {}",
                self.highest_ordered_cert(),
                self.highest_commit_cert()
            )
        );
```

**File:** consensus/consensus-types/src/sync_info.rs (L172-175)
```rust
        ensure!(
            *self.highest_commit_cert().commit_info() != BlockInfo::empty(),
            "HLI has empty commit info"
        );
```

**File:** consensus/consensus-types/src/sync_info.rs (L196-202)
```rust
                // we do not verify genesis ledger info
                if self.highest_commit_cert.commit_info().round() > 0 {
                    self.highest_commit_cert
                        .verify(validator)
                        .context("Fail to verify commit certificate")?
                }
                Ok(())
```

**File:** types/src/block_info.rs (L67-77)
```rust
    pub fn empty() -> Self {
        Self {
            epoch: 0,
            round: 0,
            id: HashValue::zero(),
            executed_state_id: HashValue::zero(),
            version: 0,
            timestamp_usecs: 0,
            next_epoch_state: None,
        }
    }
```

**File:** consensus/consensus-types/src/wrapped_ledger_info.rs (L90-108)
```rust
    pub fn verify(&self, validator: &ValidatorVerifier) -> anyhow::Result<()> {
        // Genesis's QC is implicitly agreed upon, it doesn't have real signatures.
        // If someone sends us a QC on a fake genesis, it'll fail to insert into BlockStore
        // because of the round constraint.

        // TODO: Earlier, we were comparing self.certified_block().round() to 0. Now, we are
        // comparing self.ledger_info().ledger_info().round() to 0. Is this okay?
        if self.ledger_info().ledger_info().round() == 0 {
            ensure!(
                self.ledger_info().get_num_voters() == 0,
                "Genesis QC should not carry signatures"
            );
            return Ok(());
        }
        self.ledger_info()
            .verify_signatures(validator)
            .context("Fail to verify WrappedLedgerInfo")?;
        Ok(())
    }
```
