# Audit Report

## Title
Integer Underflow in Validator Transaction Accounting Allows Violation of Soft Transaction Limits

## Summary
The `pull_payload()` function in `MixedPayloadClient` performs unchecked u64 subtraction when adjusting soft transaction limits after pulling validator transactions. When governance-controlled validator transaction limits exceed backpressure-reduced soft limits, this causes integer underflow leading to validator node panics (debug builds) or excessive user transaction inclusion (release builds).

## Finding Description

The vulnerability exists in the payload pulling logic where validator transactions are prioritized before user transactions. The `MixedPayloadClient::pull_payload` method pulls validator transactions first, then adjusts the soft transaction limit before pulling user transactions. [1](#0-0) 

These lines perform direct u64 subtraction (`-=` operator) without any bounds checking. In Rust, unchecked integer subtraction has different behavior in debug vs release builds:
- **Debug builds**: Panic on underflow
- **Release builds**: Wrap around using two's complement (5 - 10 = u64::MAX - 4)

The `soft_max_txns_after_filtering` parameter can be reduced to as low as 5 transactions under extreme backpressure conditions. The default production configuration includes backpressure values that trigger at 6000ms pipeline latency: [2](#0-1) 

And at voting power below 70%: [3](#0-2) 

When backpressure reduces transaction limits below the configured minimum threshold, the system uses execution backpressure to limit actual execution while keeping block size larger: [4](#0-3) 

This results in `soft_max_txns_after_filtering` being set to the reduced value: [5](#0-4) 

Meanwhile, validator transaction limits are controlled by on-chain governance through `ValidatorTxnConfig`. The default limit is 2 transactions: [6](#0-5) 

However, governance can increase this value through on-chain configuration updates, and there is no validation preventing values higher than potential backpressure thresholds: [7](#0-6) 

When pulling validator transactions, the limit is computed as the minimum of the block transaction count and the governance-configured limit: [8](#0-7) 

The critical issue is that `params.max_txns.count()` is based on byte-limit calculations (which can remain large even under backpressure), not on `soft_max_txns_after_filtering`. This means validator transactions can be pulled up to the governance-configured limit even when `soft_max_txns_after_filtering` is much lower.

**Attack Scenario:**
1. Governance legitimately increases `per_block_limit_txn_count` to 10 to support more validator transactions (DKG, randomness, jwk consensus)
2. Network experiences high load (pipeline latency > 6000ms) or reduced voting power (< 70%)
3. Backpressure reduces `soft_max_txns_after_filtering` to 5 via execution backpressure mechanisms
4. Block size calculations allow pulling up to 10 validator transactions (min(large_byte_based_count, 10) = 10)
5. The subtraction `soft_max_txns_after_filtering (5) -= validator_txns.len() (10)` underflows
6. **Debug mode**: Panic, validator node crash
7. **Release mode**: Wraps to 18,446,744,073,709,551,611, allowing virtually unlimited user transactions

## Impact Explanation

**HIGH Severity (Debug Builds):**
- Validator nodes panic and crash when the underflow occurs
- Affects consensus participation and network liveness
- Multiple validators running debug builds would crash simultaneously under the same backpressure conditions
- Qualifies as "Validator node slowdowns" and "API crashes" per HIGH severity criteria ($50,000 bounty tier)

**MEDIUM to HIGH Severity (Release Builds):**
- Soft transaction limit violated by orders of magnitude (wraps to ~u64::MAX)
- Could pull excessive user transactions beyond intended backpressure constraints
- Potential memory exhaustion as the system attempts to process billions of transactions
- May cause block size violations if actual transaction data matches the wrapped limit
- Could cause "State inconsistencies requiring intervention" (MEDIUM severity)
- Risk of consensus divergence if different validators handle overflow differently

The vulnerability breaks resource limit invariants by allowing unbounded transaction inclusion when backpressure should be limiting throughput.

## Likelihood Explanation

**MODERATE Likelihood:**

The vulnerability requires the intersection of two legitimate system behaviors:

1. **Governance configuration changes**: Increasing `per_block_limit_txn_count` from default (2) to values like 6-20 is reasonable for protocol evolution:
   - DKG transactions for randomness
   - JWK consensus updates
   - Future validator transaction types
   - No technical validation prevents this

2. **Extreme backpressure activation**: Automatically triggered by:
   - Pipeline latency exceeding 6000ms (realistic under network congestion)
   - Voting power falling below 70% (realistic during validator issues)
   - These thresholds are in the default production configuration [9](#0-8) 

The minimum backpressure threshold (MIN_BLOCK_TXNS_AFTER_FILTERING) is set to 100 by default: [10](#0-9) [11](#0-10) 

Any validator transaction limit above 5 creates vulnerability when extreme backpressure reduces execution to 5 transactions. Limits of 6-20 are plausible for supporting multiple protocol features concurrently.

The vulnerability is more likely in release builds where underflow wraps silently, making it harder to detect until downstream effects manifest.

## Recommendation

Use saturating or checked arithmetic for transaction limit adjustments:

```rust
// Replace lines 94-95 in consensus/src/payload_client/mixed.rs
user_txn_pull_params.max_txns_after_filtering = user_txn_pull_params
    .max_txns_after_filtering
    .saturating_sub(validator_txns.len() as u64);
user_txn_pull_params.soft_max_txns_after_filtering = user_txn_pull_params
    .soft_max_txns_after_filtering
    .saturating_sub(validator_txns.len() as u64);
```

Alternatively, add validation to ensure validator transaction limits are compatible with minimum backpressure values, or limit validator transaction pulling based on `soft_max_txns_after_filtering` rather than just `max_txns.count()`.

## Proof of Concept

The vulnerability can be demonstrated by:

1. Configuring a testnet with `ValidatorTxnConfig::V1 { per_block_limit_txn_count: 10, ... }`
2. Triggering extreme backpressure (simulate high pipeline latency or low voting power)
3. Ensuring validator transaction pool has 10+ pending transactions
4. Observing validator node behavior:
   - Debug builds: Panic with integer underflow error
   - Release builds: Attempt to pull excessive user transactions with wrapped limit

The code paths are deterministic and the vulnerability is inherent to the arithmetic operations used.

### Citations

**File:** consensus/src/payload_client/mixed.rs (L69-72)
```rust
                min(
                    params.max_txns.count(),
                    self.validator_txn_config.per_block_limit_txn_count(),
                ),
```

**File:** consensus/src/payload_client/mixed.rs (L94-95)
```rust
        user_txn_pull_params.max_txns_after_filtering -= validator_txns.len() as u64;
        user_txn_pull_params.soft_max_txns_after_filtering -= validator_txns.len() as u64;
```

**File:** config/src/config/consensus_config.rs (L28-28)
```rust
const MIN_BLOCK_TXNS_AFTER_FILTERING: u64 = DEFEAULT_MAX_BATCH_TXNS as u64 * 2;
```

**File:** config/src/config/consensus_config.rs (L258-258)
```rust
            min_max_txns_in_block_after_filtering_from_backpressure: MIN_BLOCK_TXNS_AFTER_FILTERING,
```

**File:** config/src/config/consensus_config.rs (L310-318)
```rust
                    back_pressure_pipeline_latency_limit_ms: 6000,
                    // in practice, latencies and delay make it such that ~2 blocks/s is max,
                    // meaning that most aggressively we limit to ~10 TPS
                    // For transactions that are more expensive than that, we should
                    // instead rely on max gas per block to limit latency.
                    max_sending_block_txns_after_filtering_override: 5,
                    max_sending_block_bytes_override: MIN_BLOCK_BYTES_OVERRIDE,
                    backpressure_proposal_delay_ms: 300,
                },
```

**File:** config/src/config/consensus_config.rs (L354-362)
```rust
                    backoff_if_below_participating_voting_power_percentage: 70,
                    // in practice, latencies and delay make it such that ~2 blocks/s is max,
                    // meaning that most aggressively we limit to ~10 TPS
                    // For transactions that are more expensive than that, we should
                    // instead rely on max gas per block to limit latency.
                    max_sending_block_txns_after_filtering_override: 5,
                    max_sending_block_bytes_override: MIN_BLOCK_BYTES_OVERRIDE,
                    backoff_proposal_delay_ms: 300,
                },
```

**File:** consensus/src/liveness/proposal_generator.rs (L659-660)
```rust
                    soft_max_txns_after_filtering: max_txns_from_block_to_execute
                        .unwrap_or(max_block_txns_after_filtering),
```

**File:** consensus/src/liveness/proposal_generator.rs (L827-837)
```rust
        let (max_block_txns_after_filtering, max_txns_from_block_to_execute) = if self
            .min_max_txns_in_block_after_filtering_from_backpressure
            > max_block_txns_after_filtering
        {
            (
                self.min_max_txns_in_block_after_filtering_from_backpressure,
                Some(max_block_txns_after_filtering),
            )
        } else {
            (max_block_txns_after_filtering, None)
        };
```

**File:** types/src/on_chain_config/consensus_config.rs (L125-126)
```rust
const VTXN_CONFIG_PER_BLOCK_LIMIT_TXN_COUNT_DEFAULT: u64 = 2;
const VTXN_CONFIG_PER_BLOCK_LIMIT_TOTAL_BYTES_DEFAULT: u64 = 2097152; //2MB
```

**File:** types/src/on_chain_config/consensus_config.rs (L128-137)
```rust
#[derive(Clone, Debug, Deserialize, PartialEq, Eq, Serialize)]
pub enum ValidatorTxnConfig {
    /// Disabled. In Jolteon, it also means to not use `BlockType::ProposalExt`.
    V0,
    /// Enabled. Per-block vtxn count and their total bytes are limited.
    V1 {
        per_block_limit_txn_count: u64,
        per_block_limit_total_bytes: u64,
    },
}
```

**File:** config/src/config/quorum_store_config.rs (L13-13)
```rust
pub const DEFEAULT_MAX_BATCH_TXNS: usize = 50;
```
