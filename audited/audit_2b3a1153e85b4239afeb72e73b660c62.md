# Audit Report

## Title
ElGamal Encryption to Identity Public Key Exposes Plaintexts in Veiled Coin Transactions

## Summary
The ElGamal encryption implementations in both Rust and Move lack validation that public keys are not the identity element. This allows attackers to register veiled coin accounts with the identity element as their public key, causing all incoming transfers to leak the plaintext amount directly in the ciphertext, breaking the confidentiality guarantee of veiled transactions.

## Finding Description

The core ElGamal encryption function does not validate that the provided public key is a valid non-identity group element: [1](#0-0) 

When encrypting a message `msg` to a public key `pk` using ElGamal, the ciphertext is computed as:
- `c0 = r * G` (where G is the generator)
- `c1 = msg + r * pk`

If `pk` is the identity element, then `r * pk = identity`, and the ciphertext becomes:
- `c0 = r * G`
- `c1 = msg + identity = msg`

This directly exposes the plaintext message in the ciphertext component `c1`.

In the Move implementation, public keys are created without identity validation: [2](#0-1) 

The veiled coin registration accepts any valid Ristretto point without checking if it's the identity: [3](#0-2) 

**Attack Path:**

1. Attacker registers a veiled coin account using the identity element (32 zero bytes) as their public key
2. Victim sends a fully veiled transfer to the attacker's address
3. The deposit ciphertext is computed as `(r*G, v*G)` where `v` is the transferred amount
4. The zero-knowledge proof verification still passes because it only validates algebraic relationships: [4](#0-3) 

5. The point `v*G` in the ciphertext directly reveals the transferred amount to anyone observing the blockchain

The verification equations at lines 227-235 check that `rho * bar_C + X3 = alpha1 * G + alpha2 * recipient_pk`. When `recipient_pk = identity`, this reduces to `rho * bar_C + X3 = alpha1 * G`, which the prover can satisfy by constructing appropriate proof values.

## Impact Explanation

**Severity: High** - This constitutes a significant privacy breach in confidential transaction systems.

While the current affected code (`veiled_coin`) is marked experimental, the vulnerability exists in the core cryptographic primitives:
- The Rust ElGamal implementation in `aptos-crypto`
- The Move stdlib `ristretto255_elgamal` module (NOT marked experimental)

The stdlib modules are reusable APIs that could be incorporated into production confidential transaction systems, confidential voting mechanisms, or other privacy-preserving protocols. Any future production use of these primitives would inherit this vulnerability.

This breaks the **Cryptographic Correctness** invariant by allowing encryption to degenerate into plaintext exposure. It violates the fundamental security property of ElGamal encryption: semantic security under chosen-plaintext attacks.

## Likelihood Explanation

**Likelihood: Medium-to-High**

Once these ElGamal primitives are used in production (beyond the current experimental veiled_coin):

1. **Technical Feasibility**: Trivial - attacker simply registers with identity element bytes (32 zeros)
2. **Detection Difficulty**: Low - the attack leaves no obvious traces; ciphertexts appear syntactically valid
3. **Barrier to Entry**: None - any user can register with arbitrary public keys

The attack requires no special privileges, advanced cryptographic knowledge, or validator access. The identity element has a simple byte representation that passes all current validation checks.

## Recommendation

Add public key validation to reject the identity element at multiple layers:

**1. Rust ElGamal Layer** - Add validation in the generic encrypt function:

```rust
pub fn encrypt<G: ElGamalFriendlyGroup, R: CryptoRng + RngCore>(
    rng: &mut R,
    pk: &G::Element,
    msg: &G::Element,
) -> Result<(G::Element, G::Element), Error> {
    // Validate pk is not the identity element
    if pk == &G::identity() {  // Requires adding identity() to trait
        return Err(Error::InvalidPublicKey);
    }
    
    let r = G::rand_scalar(rng);
    let c0 = G::generator_mul(&r);
    let c1 = G::add(msg, &G::mul(pk, &r));
    Ok((c0, c1))
}
```

**2. Move Layer** - Add validation in public key creation:

```move
public fun new_pubkey_from_bytes(bytes: vector<u8>): Option<CompressedPubkey> {
    let point = ristretto255::new_compressed_point_from_bytes(bytes);
    if (point.is_some()) {
        let pk_point = point.extract();
        // Reject identity element
        let identity = ristretto255::point_identity_compressed();
        if (ristretto255::compressed_point_equals(&pk_point, &identity)) {
            return std::option::none<CompressedPubkey>()
        };
        let pk = CompressedPubkey { point: pk_point };
        std::option::some(pk)
    } else {
        std::option::none<CompressedPubkey>()
    }
}
```

**3. Veiled Coin Registration** - Add explicit check:

```move
public fun register_internal<CoinType>(
    user: &signer, pk: elgamal::CompressedPubkey
) {
    // Validate pk is not identity
    let pk_point = elgamal::pubkey_to_compressed_point(&pk);
    let identity = ristretto255::point_identity_compressed();
    assert!(
        !ristretto255::compressed_point_equals(&pk_point, &identity),
        error::invalid_argument(EINVALID_PUBLIC_KEY)
    );
    
    // ... rest of function
}
```

## Proof of Concept

```move
#[test_only]
module aptos_experimental::identity_key_attack_test {
    use aptos_std::ristretto255;
    use aptos_std::ristretto255_elgamal as elgamal;
    use std::vector;
    
    #[test]
    fun test_encryption_to_identity_exposes_plaintext() {
        // Create identity element as public key (32 zero bytes)
        let identity_bytes = vector::empty<u8>();
        let i = 0;
        while (i < 32) {
            vector::push_back(&mut identity_bytes, 0u8);
            i = i + 1;
        };
        
        // This should fail but currently succeeds
        let malicious_pk = elgamal::new_pubkey_from_bytes(identity_bytes);
        assert!(malicious_pk.is_some(), 1);
        
        // Encrypt a known value
        let value = ristretto255::new_scalar_from_u32(42);
        let randomness = ristretto255::random_scalar();
        
        let ciphertext = elgamal::new_ciphertext_with_basepoint(
            &value, 
            &randomness, 
            &malicious_pk.extract()
        );
        
        // Extract ciphertext components
        let (left, right) = elgamal::ciphertext_as_points(&ciphertext);
        
        // The left component should equal 42*G (plaintext exposed!)
        let expected_left = ristretto255::basepoint_mul(&value);
        
        // This assertion passes - the plaintext is exposed!
        assert!(ristretto255::point_equals(left, &expected_left), 2);
        
        // The right component is r*G (randomness)
        let expected_right = ristretto255::basepoint_mul(&randomness);
        assert!(ristretto255::point_equals(right, &expected_right), 3);
        
        // Attack successful: ciphertext is (r*G, 42*G) which exposes the value 42
    }
}
```

## Notes

While the current vulnerable code is in the experimental `veiled_coin` module (with explicit warnings about insecurity), the underlying vulnerability exists in the cryptographic stdlib primitives that are NOT marked experimental. These primitives represent a general-purpose API that could be used in future production privacy-preserving protocols. The lack of input validation in cryptographic primitives violates the principle of secure-by-default and creates a footgun for developers building on these APIs.

### Citations

**File:** crates/aptos-crypto/src/elgamal/mod.rs (L51-60)
```rust
pub fn encrypt<G: ElGamalFriendlyGroup, R: CryptoRng + RngCore>(
    rng: &mut R,
    pk: &G::Element,
    msg: &G::Element,
) -> (G::Element, G::Element) {
    let r = G::rand_scalar(rng);
    let c0 = G::generator_mul(&r);
    let c1 = G::add(msg, &G::mul(pk, &r));
    (c0, c1)
}
```

**File:** aptos-move/framework/aptos-stdlib/sources/cryptography/ristretto255_elgamal.move (L42-52)
```text
    public fun new_pubkey_from_bytes(bytes: vector<u8>): Option<CompressedPubkey> {
        let point = ristretto255::new_compressed_point_from_bytes(bytes);
        if (point.is_some()) {
            let pk = CompressedPubkey {
                point: point.extract()
            };
            std::option::some(pk)
        } else {
            std::option::none<CompressedPubkey>()
        }
    }
```

**File:** aptos-move/framework/aptos-experimental/sources/veiled_coin/veiled_coin.move (L522-540)
```text
    public fun register_internal<CoinType>(
        user: &signer, pk: elgamal::CompressedPubkey
    ) {
        let account_addr = signer::address_of(user);
        assert!(
            !has_veiled_coin_store<CoinType>(account_addr),
            error::already_exists(EVEILED_COIN_STORE_ALREADY_PUBLISHED)
        );

        // Note: There is no way to find an ElGamal SK such that the `(0_G, 0_G)` ciphertext below decrypts to a non-zero
        // value. We'd need to have `(r * G, v * G + r * pk) = (0_G, 0_G)`, which implies `r = 0` for any choice of PK/SK.
        // Thus, we must have `v * G = 0_G`, which implies `v = 0`.

        let coin_store = VeiledCoinStore<CoinType> {
            veiled_balance: helpers::get_veiled_balance_zero_ciphertext(),
            pk
        };
        move_to(user, coin_store);
    }
```

**File:** aptos-move/framework/aptos-experimental/sources/veiled_coin/sigma_protos.move (L169-235)
```text
    public fun verify_transfer_subproof(
        sender_pk: &elgamal::CompressedPubkey,
        recipient_pk: &elgamal::CompressedPubkey,
        withdraw_ct: &elgamal::Ciphertext,
        deposit_ct: &elgamal::Ciphertext,
        comm_amount: &pedersen::Commitment,
        sender_new_balance_comm: &pedersen::Commitment,
        sender_curr_balance_ct: &elgamal::Ciphertext,
        proof: &TransferSubproof
    ) {
        let h = pedersen::randomness_base_for_bulletproof();
        let sender_pk_point = elgamal::pubkey_to_point(sender_pk);
        let recipient_pk_point = elgamal::pubkey_to_point(recipient_pk);
        let (big_c, big_d) = elgamal::ciphertext_as_points(withdraw_ct);
        let (bar_big_c, _) = elgamal::ciphertext_as_points(deposit_ct);
        let c = pedersen::commitment_as_point(comm_amount);
        let (c1, c2) = elgamal::ciphertext_as_points(sender_curr_balance_ct);
        let bar_c = pedersen::commitment_as_point(sender_new_balance_comm);

        // TODO: Can be optimized so we don't re-serialize the proof for Fiat-Shamir
        let rho =
            fiat_shamir_transfer_subproof_challenge(
                sender_pk,
                recipient_pk,
                withdraw_ct,
                deposit_ct,
                comm_amount,
                sender_curr_balance_ct,
                sender_new_balance_comm,
                &proof.x1,
                &proof.x2,
                &proof.x3,
                &proof.x4,
                &proof.x5,
                &proof.x6,
                &proof.x7
            );

        let g_alpha2 = ristretto255::basepoint_mul(&proof.alpha2);
        // \rho * D + X1 =? \alpha_2 * g
        let d_acc = ristretto255::point_mul(big_d, &rho);
        ristretto255::point_add_assign(&mut d_acc, &proof.x1);
        assert!(
            ristretto255::point_equals(&d_acc, &g_alpha2),
            error::invalid_argument(ESIGMA_PROTOCOL_VERIFY_FAILED)
        );

        let g_alpha1 = ristretto255::basepoint_mul(&proof.alpha1);
        // \rho * C + X2 =? \alpha_1 * g + \alpha_2 * y
        let big_c_acc = ristretto255::point_mul(big_c, &rho);
        ristretto255::point_add_assign(&mut big_c_acc, &proof.x2);
        let y_alpha2 = ristretto255::point_mul(&sender_pk_point, &proof.alpha2);
        ristretto255::point_add_assign(&mut y_alpha2, &g_alpha1);
        assert!(
            ristretto255::point_equals(&big_c_acc, &y_alpha2),
            error::invalid_argument(ESIGMA_PROTOCOL_VERIFY_FAILED)
        );

        // \rho * \bar{C} + X3 =? \alpha_1 * g + \alpha_2 * \bar{y}
        let big_bar_c_acc = ristretto255::point_mul(bar_big_c, &rho);
        ristretto255::point_add_assign(&mut big_bar_c_acc, &proof.x3);
        let y_bar_alpha2 = ristretto255::point_mul(&recipient_pk_point, &proof.alpha2);
        ristretto255::point_add_assign(&mut y_bar_alpha2, &g_alpha1);
        assert!(
            ristretto255::point_equals(&big_bar_c_acc, &y_bar_alpha2),
            error::invalid_argument(ESIGMA_PROTOCOL_VERIFY_FAILED)
        );
```
