# Audit Report

## Title
Unvalidated Peer Discovery Updates Allow Eclipse Attacks and Network Manipulation via Compromised Discovery Sources

## Summary
The connectivity manager accepts `ConnectivityRequest::UpdateDiscoveredPeers` messages from REST and File discovery sources without cryptographic validation. An attacker who compromises these discovery sources can inject arbitrary peer information (including attacker-controlled peers with matching private keys) into the trusted peer set, enabling eclipse attacks, network partitioning, and consensus manipulation.

## Finding Description

The vulnerability exists in the peer discovery and connectivity management system. When a node is configured to use REST or File-based discovery (common for bootstrapping or testing), the system fetches peer information from external sources and directly updates the trusted peer set without validation.

**Attack Flow:**

1. **Discovery Source Compromise**: The attacker compromises or controls the REST endpoint or discovery file that a target node uses for peer discovery. [1](#0-0) 

2. **Malicious Peer Injection**: The attacker crafts a malicious `ValidatorSet` or `PeerSet` containing their own peer IDs and public keys (for which they possess the corresponding private keys). [2](#0-1) 

3. **Unvalidated Update Propagation**: The discovery listener sends `ConnectivityRequest::UpdateDiscoveredPeers` containing the malicious peer data to the connectivity manager. [3](#0-2) 

4. **Direct Trust Store Update**: The connectivity manager's `handle_update_discovered_peers` function accepts the malicious data and updates internal state without validation. [4](#0-3) 

5. **Trusted Peer Set Corruption**: The function calls `set_trusted_peers` which stores the malicious peer set without any cryptographic verification. [5](#0-4) 

6. **Successful Connection Establishment**: When connections are established, the Noise handshake succeeds because the attacker possesses the private keys corresponding to the injected public keys, allowing them to authenticate as trusted peers.

**Critical Validation Failures:**

- REST discovery performs no signature verification, proof checking, or chain-of-trust validation on responses from the REST endpoint
- File discovery has no integrity checks (checksums, signatures, or access controls)
- The connectivity manager trusts any `PeerSet` received through the internal channel without verifying authenticity
- `PeersAndMetadata::set_trusted_peers()` performs zero validation before updating the trusted peer set

**Security Guarantees Broken:**

This vulnerability violates the **Consensus Safety** invariant. By allowing eclipse attacks through trusted peer manipulation, an attacker can:
- Isolate validator nodes from the legitimate network
- Prevent nodes from receiving valid consensus messages
- Cause non-recoverable network partitions
- Manipulate transaction propagation and consensus participation

## Impact Explanation

**Critical Severity** - This vulnerability meets multiple critical impact categories from the Aptos bug bounty program:

1. **Consensus/Safety Violations**: An attacker can eclipse validator nodes, preventing them from participating in consensus correctly. If multiple validators use compromised discovery sources, the attacker can partition the network.

2. **Non-recoverable Network Partition**: By replacing legitimate validator peers with attacker-controlled proxies across multiple nodes, the attacker can create persistent network partitions that may require manual intervention or a hard fork to resolve.

3. **Total Loss of Liveness**: If enough validators are eclipsed, the network cannot reach quorum, resulting in complete loss of liveness.

The attack enables:
- **Eclipse Attacks**: Complete isolation of target nodes from the legitimate network
- **Man-in-the-Middle**: Interception and manipulation of consensus messages
- **Consensus Disruption**: Prevention of block production and transaction finalization
- **Network Partitioning**: Creation of split-brain scenarios across the validator set

## Likelihood Explanation

**Moderate to High Likelihood:**

**Prerequisites:**
- Target node must be configured to use REST or File discovery (not the default for production validators, but supported and documented)
- Attacker must compromise the REST endpoint OR gain write access to the discovery file
- Attacker generates their own key pairs (trivial operation)

**Likelihood Factors:**

1. **Configuration Dependency**: While production validators typically use on-chain discovery, REST and File discovery are valid configuration options explicitly supported for bootstrapping, testing, and special deployment scenarios. [6](#0-5) 

2. **REST Endpoint Compromise**: REST endpoints can be compromised through DNS hijacking, BGP attacks, compromised infrastructure, or man-in-the-middle attacks on unencrypted connections.

3. **File Manipulation**: Discovery files can be modified if an attacker gains filesystem access or exploits file permission vulnerabilities.

4. **No Mutual Authentication for Discovery**: Unlike on-chain discovery which is cryptographically secured by consensus, REST and File discovery have no built-in authentication or integrity verification. [7](#0-6) 

The vulnerability is especially concerning during:
- Network bootstrapping phases when REST discovery is more commonly used
- Testnet and devnet deployments with relaxed security configurations
- Disaster recovery scenarios when operators may temporarily use alternative discovery methods

## Recommendation

Implement multi-layered validation for discovery updates:

**1. Cryptographic Verification for REST Discovery:**
- Implement signed responses from REST endpoints with validator signatures
- Verify responses against on-chain validator set state
- Add proof-of-inclusion verification for returned peer data
- Implement certificate pinning or mutual TLS for REST connections

**2. Discovery Source Validation in Connectivity Manager:**
```rust
fn handle_update_discovered_peers(
    &mut self,
    src: DiscoverySource,
    new_discovered_peers: PeerSet,
) {
    // Add validation before accepting updates
    if !self.validate_peer_set_authenticity(src, &new_discovered_peers) {
        error!(
            NetworkSchema::new(&self.network_context),
            "Rejected unauthenticated peer discovery update from {:?}",
            src
        );
        return;
    }
    
    // Existing update logic...
}

fn validate_peer_set_authenticity(
    &self,
    src: DiscoverySource,
    peer_set: &PeerSet,
) -> bool {
    match src {
        DiscoverySource::OnChainValidatorSet => true, // Already validated by consensus
        DiscoverySource::Rest | DiscoverySource::File => {
            // Verify against known on-chain state
            // Check cryptographic signatures
            // Validate peer credentials
            self.verify_against_onchain_state(peer_set)
        },
        DiscoverySource::Config => true, // Operator-configured
    }
}
```

**3. File Discovery Integrity:**
- Add digital signatures to discovery files
- Implement checksums and integrity verification
- Enforce strict file permissions and access controls
- Add operator authentication for file updates

**4. Cross-Validation with On-Chain State:**
- Always cross-reference REST/File discovery updates with on-chain validator set
- Reject updates that introduce peers not present in the on-chain validator set
- Add configuration option to restrict discovery to on-chain sources only for production deployments

**5. Rate Limiting and Anomaly Detection:**
- Implement rate limiting for peer set updates
- Detect and alert on suspicious peer replacements
- Add monitoring for discovery source health and consistency

## Proof of Concept

```rust
// Integration test demonstrating the vulnerability
// File: network/framework/src/connectivity_manager/test_exploit.rs

#[tokio::test]
async fn test_malicious_discovery_update_eclipse_attack() {
    use aptos_config::config::{Peer, PeerRole, PeerSet};
    use aptos_crypto::x25519;
    use aptos_types::PeerId;
    use std::collections::HashSet;
    
    // Setup: Create a connectivity manager for a validator
    let (mut conn_mgr, conn_mgr_reqs_tx, _) = 
        build_test_connectivity_manager();
    
    // Attacker generates their own key pair
    let attacker_private_key = x25519::PrivateKey::generate_for_testing();
    let attacker_public_key = attacker_private_key.public_key();
    let attacker_peer_id = PeerId::random();
    
    // Attacker crafts malicious peer set (simulating compromised REST endpoint)
    let mut malicious_peer_set = PeerSet::new();
    let mut attacker_keys = HashSet::new();
    attacker_keys.insert(attacker_public_key);
    
    malicious_peer_set.insert(
        attacker_peer_id,
        Peer::new(
            vec![NetworkAddress::from_str("/ip4/1.2.3.4/tcp/6180").unwrap()],
            attacker_keys,
            PeerRole::Validator,
        ),
    );
    
    // Send malicious update through REST discovery (no validation occurs)
    conn_mgr_reqs_tx
        .send(ConnectivityRequest::UpdateDiscoveredPeers(
            DiscoverySource::Rest,
            malicious_peer_set.clone(),
        ))
        .await
        .unwrap();
    
    // Process the request
    tokio::time::sleep(Duration::from_millis(100)).await;
    
    // VULNERABILITY: Attacker's peer is now in the trusted peer set
    let trusted_peers = conn_mgr
        .peers_and_metadata
        .get_trusted_peers(&NetworkId::Validator)
        .unwrap();
    
    assert!(trusted_peers.contains_key(&attacker_peer_id));
    assert_eq!(
        trusted_peers.get(&attacker_peer_id).unwrap().keys,
        malicious_peer_set.get(&attacker_peer_id).unwrap().keys
    );
    
    // The attacker can now establish connections as a trusted peer
    // because they possess the corresponding private key
    println!("EXPLOIT SUCCESS: Attacker peer {} added to trusted set", 
             attacker_peer_id);
}
```

**Notes**

This vulnerability represents a fundamental trust boundary violation in the peer discovery system. While on-chain discovery is cryptographically secured through the consensus mechanism, REST and File discovery bypass these protections entirely, creating a critical attack surface for eclipse attacks and network manipulation.

The issue is particularly severe because:
1. It affects the network layer foundation that consensus depends on
2. It can be exploited without requiring validator private keys or stake
3. It enables persistent attacks that survive node restarts
4. Detection requires external network monitoring, as compromised nodes may not realize they're eclipsed

Organizations operating Aptos nodes should immediately audit their discovery configurations and migrate to on-chain discovery for production deployments until this vulnerability is patched.

### Citations

**File:** network/discovery/src/rest.rs (L48-51)
```rust
        let response = block_on(self.rest_client.get_account_resource_bcs::<ValidatorSet>(
            AccountAddress::ONE,
            "0x1::stake::ValidatorSet",
        ));
```

**File:** network/discovery/src/lib.rs (L149-149)
```rust
                let request = ConnectivityRequest::UpdateDiscoveredPeers(discovery_source, update);
```

**File:** network/framework/src/connectivity_manager/mod.rs (L492-502)
```rust
                    // If we're using server only auth, we need to not evict unknown peers
                    // TODO: We should prevent `Unknown` from discovery sources
                    if !self.mutual_authentication
                        && metadata.origin == ConnectionOrigin::Inbound
                        && (metadata.role == PeerRole::ValidatorFullNode
                            || metadata.role == PeerRole::Unknown)
                    {
                        None
                    } else {
                        Some(*peer_id) // The peer is stale
                    }
```

**File:** network/framework/src/connectivity_manager/mod.rs (L866-873)
```rust
            ConnectivityRequest::UpdateDiscoveredPeers(src, discovered_peers) => {
                trace!(
                    NetworkSchema::new(&self.network_context),
                    "{} Received updated list of discovered peers: src: {:?}",
                    self.network_context,
                    src,
                );
                self.handle_update_discovered_peers(src, discovered_peers);
```

**File:** network/framework/src/connectivity_manager/mod.rs (L886-898)
```rust
    fn handle_update_discovered_peers(
        &mut self,
        src: DiscoverySource,
        new_discovered_peers: PeerSet,
    ) {
        // Log the update event
        info!(
            NetworkSchema::new(&self.network_context),
            "{} Received updated list of discovered peers! Source: {:?}, num peers: {:?}",
            self.network_context,
            src,
            new_discovered_peers.len()
        );
```

**File:** network/framework/src/application/storage.rs (L361-368)
```rust
    pub fn set_trusted_peers(
        &self,
        network_id: &NetworkId,
        trusted_peer_set: PeerSet,
    ) -> Result<(), Error> {
        let trusted_peers = self.get_trusted_peer_set_for_network(network_id)?;
        trusted_peers.store(Arc::new(trusted_peer_set));
        Ok(())
```

**File:** network/builder/src/builder.rs (L355-385)
```rust
        for discovery_method in config.discovery_methods() {
            let listener = match discovery_method {
                DiscoveryMethod::Onchain => {
                    let reconfig_events = reconfig_subscription_service
                        .as_mut()
                        .expect("An event subscription service is required for on-chain discovery!")
                        .subscribe_to_reconfigurations()
                        .expect("On-chain discovery is unable to subscribe to reconfigurations!");
                    let identity_key = config.identity_key();
                    let pubkey = identity_key.public_key();
                    DiscoveryChangeListener::validator_set(
                        self.network_context,
                        conn_mgr_reqs_tx.clone(),
                        pubkey,
                        reconfig_events,
                    )
                },
                DiscoveryMethod::File(file_discovery) => DiscoveryChangeListener::file(
                    self.network_context,
                    conn_mgr_reqs_tx.clone(),
                    file_discovery.path.as_path(),
                    Duration::from_secs(file_discovery.interval_secs),
                    self.time_service.clone(),
                ),
                DiscoveryMethod::Rest(rest_discovery) => DiscoveryChangeListener::rest(
                    self.network_context,
                    conn_mgr_reqs_tx.clone(),
                    rest_discovery.url.clone(),
                    Duration::from_secs(rest_discovery.interval_secs),
                    self.time_service.clone(),
                ),
```
