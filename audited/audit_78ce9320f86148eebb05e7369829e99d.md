# Audit Report

## Title
Mainnet Validators Not Protected from Identity Information Exposure via ConfigSanitizer

## Summary
Mainnet validators are explicitly prevented from exposing node configuration through `expose_configuration` via a `ConfigSanitizer` check, but no equivalent protection exists for `expose_identity_information`. This inconsistency leaves validator network peer IDs exposed by default, enabling reconnaissance and targeted attacks against validators.

## Finding Description

The Aptos codebase implements a `ConfigSanitizer` for the inspection service that explicitly validates mainnet validator configurations. However, this sanitizer only checks `expose_configuration` and fails to check `expose_identity_information`, creating an inconsistent security posture. [1](#0-0) 

The sanitizer prevents mainnet validators from enabling `expose_configuration`:

However, the default configuration sets `expose_identity_information: true`: [2](#0-1) 

When enabled, this endpoint exposes validator network peer IDs and fullnode network peer IDs: [3](#0-2) 

All validator configuration templates examined (validator.yaml, validator-base.yaml, docker-compose validator configs) lack an explicit `inspection_service` section, meaning they inherit the default `expose_identity_information: true` setting. [4](#0-3) 

**Attack Path:**
1. Mainnet validator operator deploys using default configuration or templates that don't explicitly set `expose_identity_information: false`
2. The inspection service binds to `0.0.0.0:9101` by default
3. If port 9101 is not properly firewalled (bare-metal deployments, misconfigured cloud security groups), the endpoint becomes publicly accessible
4. Attacker queries `http://<validator-ip>:9101/identity_information` to obtain validator peer IDs
5. With known peer IDs, attacker can conduct targeted reconnaissance, network topology mapping, or coordinate more sophisticated attacks

## Impact Explanation

This qualifies as **High Severity** per Aptos bug bounty criteria:

1. **Significant Protocol Violation**: The codebase demonstrates that mainnet validators require special security treatment (as evidenced by the `expose_configuration` sanitizer check), yet this protection is not consistently applied to `expose_identity_information`.

2. **Production Security Hardening Failure**: The inconsistency between protecting `expose_configuration` but not `expose_identity_information` represents a security oversight that could enable attacks against validators.

3. **Validator-Specific Risk**: Unlike fullnodes or public nodes, validators are critical to consensus. Exposing their network identities enables:
   - Targeted reconnaissance for more sophisticated attacks
   - Network topology mapping to identify critical infrastructure
   - Privacy violations for validator operators
   - Foundation for multi-stage attacks requiring validator identification

4. **Default-Unsafe Configuration**: The default setting (`true`) combined with lack of sanitizer enforcement means validators are exposed unless operators explicitly take action—violating security-by-default principles.

## Likelihood Explanation

**High Likelihood** for the following reasons:

1. **Default Configuration Problem**: The vulnerability manifests with default settings, requiring no misconfiguration by the operator.

2. **Template Coverage Gap**: All examined validator configuration templates lack explicit `inspection_service` configuration, relying on defaults.

3. **Inconsistent Security Guidance**: The presence of a sanitizer check for `expose_configuration` but not `expose_identity_information` creates a false sense of security—operators may assume the codebase protects all sensitive endpoints.

4. **Bare-Metal Deployments**: While Docker Compose and Kubernetes deployments add infrastructure-level protections, operators running bare-metal validators or custom deployments may not implement equivalent firewall rules.

5. **Documentation Gap**: No warnings exist in code comments, configuration templates, or the disabled message itself about mainnet-specific security requirements.

## Recommendation

Add a `ConfigSanitizer` check for `expose_identity_information` equivalent to the existing `expose_configuration` check:

```rust
// In config/src/config/inspection_service_config.rs
impl ConfigSanitizer for InspectionServiceConfig {
    fn sanitize(
        node_config: &NodeConfig,
        node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();
        let inspection_service_config = &node_config.inspection_service;

        // Verify that mainnet validators do not expose sensitive endpoints
        if let Some(chain_id) = chain_id {
            if node_type.is_validator() && chain_id.is_mainnet() {
                if inspection_service_config.expose_configuration {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "Mainnet validators should not expose the node configuration!".to_string(),
                    ));
                }
                
                // ADD THIS CHECK:
                if inspection_service_config.expose_identity_information {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "Mainnet validators should not expose identity information! Set inspection_service.expose_identity_information: false".to_string(),
                    ));
                }
            }
        }

        Ok(())
    }
}
```

**Additional Recommendations:**

1. Update validator configuration templates to explicitly set `expose_identity_information: false`
2. Add documentation warnings about the security implications of exposing identity information for mainnet validators
3. Consider changing the default to `false` for improved security-by-default posture
4. Add a startup warning log if a mainnet validator has `expose_identity_information: true`

## Proof of Concept

This can be verified by examining the codebase:

1. **Verify Default Configuration:** [5](#0-4) 

2. **Verify Missing Sanitizer Check:** [6](#0-5) 

3. **Verify Identity Exposure:** [7](#0-6) 

4. **Verify Template Gap:** [8](#0-7) 

The inconsistency is demonstrated by comparing lines 54-64 (sanitizer checks `expose_configuration`) with the absence of any check for `expose_identity_information`, despite both exposing sensitive validator information.

## Notes

This finding represents a **production security hardening issue** rather than a direct consensus or funds-at-risk vulnerability. The severity stems from:

1. **Inconsistent Security Treatment**: The codebase explicitly protects `expose_configuration` for mainnet validators but fails to protect `expose_identity_information`
2. **Security-by-Default Violation**: Default settings expose sensitive information without explicit operator opt-in
3. **Validator-Specific Risk**: Impacts the most critical node type in the network
4. **Documentation/Warning Gap**: No explicit warnings exist for mainnet validator operators

While infrastructure-level protections (firewalls, network policies) can mitigate this issue, relying solely on operational security rather than code-level enforcement creates unnecessary risk and violates defense-in-depth principles.

### Citations

**File:** config/src/config/inspection_service_config.rs (L26-36)
```rust
impl Default for InspectionServiceConfig {
    fn default() -> InspectionServiceConfig {
        InspectionServiceConfig {
            address: "0.0.0.0".to_string(),
            port: 9101,
            expose_configuration: false,
            expose_identity_information: true,
            expose_peer_information: true,
            expose_system_information: true,
        }
    }
```

**File:** config/src/config/inspection_service_config.rs (L45-68)
```rust
impl ConfigSanitizer for InspectionServiceConfig {
    fn sanitize(
        node_config: &NodeConfig,
        node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();
        let inspection_service_config = &node_config.inspection_service;

        // Verify that mainnet validators do not expose the configuration
        if let Some(chain_id) = chain_id {
            if node_type.is_validator()
                && chain_id.is_mainnet()
                && inspection_service_config.expose_configuration
            {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "Mainnet validators should not expose the node configuration!".to_string(),
                ));
            }
        }

        Ok(())
    }
```

**File:** crates/aptos-inspection-service/src/server/identity_information.rs (L13-26)
```rust
pub fn handle_identity_information_request(node_config: &NodeConfig) -> (StatusCode, Body, String) {
    // Only return identity information if the endpoint is enabled
    let (status_code, body) = if node_config.inspection_service.expose_identity_information {
        let identity_information = get_identity_information(node_config);
        (StatusCode::OK, Body::from(identity_information))
    } else {
        (
            StatusCode::FORBIDDEN,
            Body::from(IDENTITY_INFO_DISABLED_MESSAGE),
        )
    };

    (status_code, body, CONTENT_TYPE_TEXT.into())
}
```

**File:** crates/aptos-inspection-service/src/server/identity_information.rs (L29-51)
```rust
fn get_identity_information(node_config: &NodeConfig) -> String {
    let mut identity_information = Vec::<String>::new();
    identity_information.push("Identity Information:".into());

    // If the validator network is configured, fetch the identity information
    if let Some(validator_network) = &node_config.validator_network {
        identity_information.push(format!(
            "\t- Validator network ({}), peer ID: {}",
            validator_network.network_id,
            validator_network.peer_id()
        ));
    }

    // For each fullnode network, fetch the identity information
    for fullnode_network in &node_config.full_node_networks {
        identity_information.push(format!(
            "\t- Fullnode network ({}), peer ID: {}",
            fullnode_network.network_id,
            fullnode_network.peer_id()
        ));
    }

    identity_information.join("\n") // Separate each entry with a newline to construct the output
```

**File:** terraform/helm/aptos-node/files/configs/validator-base.yaml (L1-48)
```yaml
###
### This is the base validator NodeConfig to work with this helm chart
### Additional overrides to the NodeConfig can be specified via .Values.validator.config or .Values.overrideNodeConfig
###
base:
  role: validator
  waypoint:
    from_file: /opt/aptos/genesis/waypoint.txt

consensus:
  safety_rules:
    service:
      type: "local"
    backend:
      type: "on_disk_storage"
      path: secure-data.json
      namespace: ~
    initial_safety_rules_config:
      from_file:
        waypoint:
          from_file: /opt/aptos/genesis/waypoint.txt
        identity_blob_path: /opt/aptos/genesis/validator-identity.yaml

execution:
  genesis_file_location: /opt/aptos/genesis/genesis.blob

full_node_networks:
  - network_id:
      private: "vfn"
    listen_address: "/ip4/0.0.0.0/tcp/6181"
    identity:
      type: "from_config"
      key: "b0f405a3e75516763c43a2ae1d70423699f34cd68fa9f8c6bb2d67aa87d0af69"
      peer_id: "00000000000000000000000000000000d58bc7bb154b38039bc9096ce04e1237"

storage:
  rocksdb_configs:
    enable_storage_sharding: true

api:
  enabled: true
  address: "0.0.0.0:8080"

validator_network:
  discovery_method: "onchain"
  identity:
    type: "from_file"
    path: /opt/aptos/genesis/validator-identity.yaml
```

**File:** docker/compose/aptos-node/validator.yaml (L1-81)
```yaml
base:
  role: "validator"
  data_dir: "/opt/aptos/data"
  waypoint:
    from_file: "/opt/aptos/genesis/waypoint.txt"

consensus:
  safety_rules:
    service:
      type: "local"
    backend:
      type: "on_disk_storage"
      path: secure-data.json
      namespace: ~
    initial_safety_rules_config:
      from_file:
        waypoint:
          from_file: /opt/aptos/genesis/waypoint.txt
        identity_blob_path: /opt/aptos/genesis/validator-identity.yaml

execution:
  genesis_file_location: "/opt/aptos/genesis/genesis.blob"

storage:
  rocksdb_configs:
    enable_storage_sharding: true

validator_network:
  discovery_method: "onchain"
  mutual_authentication: true
  identity:
    type: "from_file"
    path: /opt/aptos/genesis/validator-identity.yaml

full_node_networks:
- network_id:
    private: "vfn"
  listen_address: "/ip4/0.0.0.0/tcp/6181"
  identity:
    type: "from_config"
    key: "b0f405a3e75516763c43a2ae1d70423699f34cd68fa9f8c6bb2d67aa87d0af69"
    peer_id: "00000000000000000000000000000000d58bc7bb154b38039bc9096ce04e1237"

api:
  enabled: true
  address: "0.0.0.0:8080"
```
