# Audit Report

## Title
Non-Atomic Waypoint and SafetyData Updates Lead to Epoch Inconsistency

## Summary
The `guarded_initialize()` function in SafetyRules updates waypoint and safety_data in two separate, non-atomic operations. When the function encounters an error after updating the waypoint but before updating safety_data, it leaves persistent storage in an inconsistent state where waypoint and safety_data reference different epochs. Subsequent calls to `consensus_state()` will return this inconsistent state, potentially affecting consensus safety decisions.

## Finding Description
The vulnerability exists in the epoch transition logic of SafetyRules. During initialization with an `EpochChangeProof`, the system must update both the waypoint (representing the trusted ledger checkpoint) and safety_data (containing the current epoch and voting state). [1](#0-0) 

The update sequence is:
1. Line 280: Waypoint is updated first and persisted to storage
2. Line 283: Safety_data is read to get current_epoch  
3. Lines 284-309: Epoch comparison logic determines if safety_data should be updated
4. Line 296-303: Safety_data is updated ONLY in the `Ordering::Less` branch

The critical flaw is in the `Ordering::Greater` error path (lines 285-292): when `current_epoch > epoch_state.epoch`, the function returns a `WaypointOutOfDate` error. However, the waypoint has **already been updated and persisted** at line 280, while safety_data remains unchanged. This leaves the storage in an inconsistent state.

The underlying storage layer provides no transactional guarantees: [2](#0-1) 

Each `set()` operation is independent, and there's no mechanism to atomically update multiple keys or rollback on error.

When `consensus_state()` is subsequently called, it reads waypoint and safety_data separately: [3](#0-2) 

This returns a `ConsensusState` object containing mismatched epoch information - the waypoint from epoch N+1 and safety_data from epoch N. [4](#0-3) [5](#0-4) 

## Impact Explanation
This qualifies as **Medium Severity** per the Aptos bug bounty criteria: "State inconsistencies requiring intervention."

The impact includes:
- **Consensus state corruption**: SafetyData contains epoch-specific voting constraints (last_voted_round, preferred_round). When mismatched with the waypoint epoch, these constraints become meaningless.
- **Incorrect epoch verification**: The `verify_epoch()` function checks proposals against `safety_data.epoch`, which no longer matches the trusted waypoint epoch.
- **Manual intervention required**: Once the storage is in this inconsistent state, it persists across restarts and requires manual storage repair or re-initialization.
- **Validator operational impact**: Affected validators cannot participate correctly in consensus until the inconsistency is resolved.

While this doesn't directly cause fund loss or total network failure (Critical), it does violate the State Consistency invariant and requires operational intervention to resolve (Medium).

## Likelihood Explanation  
**Likelihood: Medium**

This can occur in several realistic scenarios:

1. **Error condition during epoch transition**: When `current_epoch > epoch_state.epoch` due to proof verification issues or configuration errors
2. **Storage backend failures**: If the storage `set()` operation for safety_data fails after waypoint succeeds
3. **Process crash/restart**: If the validator crashes between lines 280 and 303
4. **Concurrent process access** (OnDiskStorage): OnDiskStorage explicitly states it's not thread-safe and shouldn't be used in production, but if misconfigured with multiple processes, this race is guaranteed [6](#0-5) 

The vulnerability requires no attacker action - it manifests through normal operational conditions during epoch transitions.

## Recommendation
Implement atomic updates for waypoint and safety_data using one of these approaches:

**Option 1: Update order reversal with validation**
```rust
fn guarded_initialize(&mut self, proof: &EpochChangeProof) -> Result<(), Error> {
    let waypoint = self.persistent_storage.waypoint()?;
    let last_li = proof
        .verify(&waypoint)
        .map_err(|e| Error::InvalidEpochChangeProof(format!("{}", e)))?;
    let ledger_info = last_li.ledger_info();
    let epoch_state = ledger_info
        .next_epoch_state()
        .cloned()
        .ok_or(Error::InvalidLedgerInfo)?;

    let new_waypoint = &Waypoint::new_epoch_boundary(ledger_info)
        .map_err(|error| Error::InternalError(error.to_string()))?;
    
    let current_epoch = self.persistent_storage.safety_data()?.epoch;
    
    // VALIDATE BEFORE ANY UPDATES
    match current_epoch.cmp(&epoch_state.epoch) {
        Ordering::Greater => {
            return Err(Error::WaypointOutOfDate(
                waypoint.version(),
                new_waypoint.version(),
                current_epoch,
                epoch_state.epoch,
            ));
        },
        Ordering::Less => {
            // UPDATE SAFETY_DATA FIRST, then waypoint
            self.persistent_storage.set_safety_data(SafetyData::new(
                epoch_state.epoch,
                0,
                0,
                0,
                None,
                0,
            ))?;
            
            // Only update waypoint after safety_data succeeds
            if new_waypoint.version() > waypoint.version() {
                self.persistent_storage.set_waypoint(new_waypoint)?;
            }
            
            info!(SafetyLogSchema::new(LogEntry::Epoch, LogEvent::Update)
                .epoch(epoch_state.epoch));
        },
        Ordering::Equal => {
            // Still update waypoint if needed for Equal case
            if new_waypoint.version() > waypoint.version() {
                self.persistent_storage.set_waypoint(new_waypoint)?;
            }
        },
    };
    self.epoch_state = Some(epoch_state.clone());
    // ... rest of function
}
```

**Option 2: Add rollback on error**
Add a rollback mechanism to restore waypoint if safety_data update fails.

**Option 3: Storage-layer transaction support**
Extend the KVStorage trait to support multi-key atomic transactions.

## Proof of Concept
```rust
#[cfg(test)]
mod test_epoch_inconsistency {
    use super::*;
    use aptos_crypto::hash::HashValue;
    use aptos_secure_storage::{InMemoryStorage, Storage};
    use aptos_types::{
        block_info::BlockInfo,
        epoch_state::EpochState,
        ledger_info::LedgerInfo,
        validator_signer::ValidatorSigner,
        waypoint::Waypoint,
    };

    #[test]
    fn test_waypoint_safety_data_inconsistency_on_error() {
        // Setup: Initialize SafetyRules at epoch 1
        let consensus_private_key = ValidatorSigner::from_int(0).private_key().clone();
        let storage = Storage::from(InMemoryStorage::new());
        let mut safety_storage = PersistentSafetyStorage::initialize(
            storage,
            Author::random(),
            consensus_private_key,
            Waypoint::default(),
            true,
        );
        
        // Set safety_data to epoch 5
        let safety_data = SafetyData::new(5, 0, 0, 0, None, 0);
        safety_storage.set_safety_data(safety_data).unwrap();
        
        // Create waypoint for epoch 3 (older than current epoch 5)
        let li = LedgerInfo::new(
            BlockInfo::new(
                3,
                0,
                HashValue::random(),
                HashValue::random(),
                100,
                1000,
                Some(EpochState::empty()),
            ),
            HashValue::zero(),
        );
        let waypoint_epoch_3 = Waypoint::new_epoch_boundary(&li).unwrap();
        
        // Create SafetyRules and try to initialize with older epoch
        let mut safety_rules = SafetyRules::new(safety_storage, true);
        
        // Craft EpochChangeProof that will update waypoint but fail epoch check
        let proof = create_epoch_change_proof(waypoint_epoch_3);
        
        // This should fail with WaypointOutOfDate error
        let result = safety_rules.initialize(&proof);
        assert!(result.is_err());
        
        // BUG: Waypoint was updated but safety_data was not
        // Verify inconsistency
        let final_waypoint = safety_rules.persistent_storage.waypoint().unwrap();
        let final_safety_data = safety_rules.persistent_storage.safety_data().unwrap();
        
        // Waypoint is at version 100 (epoch 3 boundary)
        assert_eq!(final_waypoint.version(), 100);
        
        // But safety_data is still at epoch 5
        assert_eq!(final_safety_data.epoch, 5);
        
        // This is inconsistent state!
        // consensus_state() will return mismatched epoch information
        let consensus_state = safety_rules.consensus_state().unwrap();
        assert_eq!(consensus_state.waypoint().version(), 100);
        assert_eq!(consensus_state.epoch(), 5);
        
        println!("VULNERABILITY CONFIRMED: Waypoint at version {} but SafetyData at epoch {}",
                 final_waypoint.version(), final_safety_data.epoch);
    }
}
```

**Notes:**
- The vulnerability is deterministic and reproducible in the error path of `guarded_initialize()`
- The issue persists across validator restarts since storage is persistent
- While RwLock prevents concurrent access to SafetyRules, it doesn't prevent the non-atomic storage updates
- The OnDiskStorage implementation explicitly warns about lack of concurrent access support, making this worse in misconfigured deployments
- This affects all storage backends (OnDiskStorage, VaultStorage, InMemoryStorage) since the KVStorage trait provides no transactional guarantees

### Citations

**File:** consensus/safety-rules/src/safety_rules.rs (L247-263)
```rust
    fn guarded_consensus_state(&mut self) -> Result<ConsensusState, Error> {
        let waypoint = self.persistent_storage.waypoint()?;
        let safety_data = self.persistent_storage.safety_data()?;

        trace!(SafetyLogSchema::new(LogEntry::State, LogEvent::Update)
            .author(self.persistent_storage.author()?)
            .epoch(safety_data.epoch)
            .last_voted_round(safety_data.last_voted_round)
            .preferred_round(safety_data.preferred_round)
            .waypoint(waypoint));

        Ok(ConsensusState::new(
            self.persistent_storage.safety_data()?,
            self.persistent_storage.waypoint()?,
            self.signer().is_ok(),
        ))
    }
```

**File:** consensus/safety-rules/src/safety_rules.rs (L265-310)
```rust
    fn guarded_initialize(&mut self, proof: &EpochChangeProof) -> Result<(), Error> {
        let waypoint = self.persistent_storage.waypoint()?;
        let last_li = proof
            .verify(&waypoint)
            .map_err(|e| Error::InvalidEpochChangeProof(format!("{}", e)))?;
        let ledger_info = last_li.ledger_info();
        let epoch_state = ledger_info
            .next_epoch_state()
            .cloned()
            .ok_or(Error::InvalidLedgerInfo)?;

        // Update the waypoint to a newer value, this might still be older than the current epoch.
        let new_waypoint = &Waypoint::new_epoch_boundary(ledger_info)
            .map_err(|error| Error::InternalError(error.to_string()))?;
        if new_waypoint.version() > waypoint.version() {
            self.persistent_storage.set_waypoint(new_waypoint)?;
        }

        let current_epoch = self.persistent_storage.safety_data()?.epoch;
        match current_epoch.cmp(&epoch_state.epoch) {
            Ordering::Greater => {
                // waypoint is not up to the current epoch.
                return Err(Error::WaypointOutOfDate(
                    waypoint.version(),
                    new_waypoint.version(),
                    current_epoch,
                    epoch_state.epoch,
                ));
            },
            Ordering::Less => {
                // start new epoch
                self.persistent_storage.set_safety_data(SafetyData::new(
                    epoch_state.epoch,
                    0,
                    0,
                    0,
                    None,
                    0,
                ))?;

                info!(SafetyLogSchema::new(LogEntry::Epoch, LogEvent::Update)
                    .epoch(epoch_state.epoch));
            },
            Ordering::Equal => (),
        };
        self.epoch_state = Some(epoch_state.clone());
```

**File:** secure/storage/src/kv_storage.rs (L12-24)
```rust
#[enum_dispatch]
pub trait KVStorage {
    /// Returns an error if the backend service is not online and available.
    fn available(&self) -> Result<(), Error>;

    /// Retrieves a value from storage and fails if the backend is unavailable or the process has
    /// invalid permissions.
    fn get<T: DeserializeOwned>(&self, key: &str) -> Result<GetResponse<T>, Error>;

    /// Sets a value in storage and fails if the backend is unavailable or the process has
    /// invalid permissions.
    fn set<T: Serialize>(&mut self, key: &str, value: T) -> Result<(), Error>;

```

**File:** consensus/safety-rules/src/persistent_safety_storage.rs (L134-148)
```rust
    pub fn safety_data(&mut self) -> Result<SafetyData, Error> {
        if !self.enable_cached_safety_data {
            let _timer = counters::start_timer("get", SAFETY_DATA);
            return self.internal_store.get(SAFETY_DATA).map(|v| v.value)?;
        }

        if let Some(cached_safety_data) = self.cached_safety_data.clone() {
            Ok(cached_safety_data)
        } else {
            let _timer = counters::start_timer("get", SAFETY_DATA);
            let safety_data: SafetyData = self.internal_store.get(SAFETY_DATA).map(|v| v.value)?;
            self.cached_safety_data = Some(safety_data.clone());
            Ok(safety_data)
        }
    }
```

**File:** consensus/safety-rules/src/persistent_safety_storage.rs (L172-175)
```rust
    pub fn waypoint(&self) -> Result<Waypoint, Error> {
        let _timer = counters::start_timer("get", WAYPOINT);
        Ok(self.internal_store.get(WAYPOINT).map(|v| v.value)?)
    }
```

**File:** secure/storage/src/on_disk.rs (L16-22)
```rust
/// OnDiskStorage represents a key value store that is persisted to the local filesystem and is
/// intended for single threads (or must be wrapped by a Arc<RwLock<>>). This provides no permission
/// checks and simply offers a proof of concept to unblock building of applications without more
/// complex data stores. Internally, it reads and writes all data to a file, which means that it
/// must make copies of all key material which violates the code base. It violates it because
/// the anticipation is that data stores would securely handle key material. This should not be used
/// in production.
```
