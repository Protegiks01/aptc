# Audit Report

## Title
Timing Side-Channel in Parallel Batch Decryption Leaks Plaintext Structure Information

## Summary
The `decrypt()` function in the FPTX batch encryption schemes exhibits non-constant-time behavior due to variable-length deserialization operations and early-exit error paths in AES-GCM authentication. When combined with parallel decryption using Rayon's `into_par_iter()`, these timing variations can leak statistical information about encrypted transaction plaintext structures to attackers who can submit transactions to blocks and measure batch processing times.

## Finding Description

The vulnerability exists in the symmetric decryption path used by all FPTX schemes (FPTX, FPTXWeighted, FPTXSuccinct). The issue manifests through two distinct timing channels:

**Primary Timing Channel - Variable Deserialization:**

The `SymmetricKey::decrypt()` function performs AES-GCM decryption followed by BCS deserialization: [1](#0-0) 

After successful MAC verification, the plaintext bytes are deserialized using `bcs::from_bytes()`. This deserialization has **variable timing** based on:
- Plaintext data size
- Structural complexity (nested vectors, strings, complex types)
- Memory allocation patterns

Different transaction types (simple token transfers vs complex smart contract calls) will have measurably different deserialization times.

**Secondary Timing Channel - Early Exit on Authentication Failure:**

If AES-GCM MAC verification fails (incorrect key or tampered ciphertext), the function returns immediately without attempting deserialization. This creates a binary timing channel distinguishing failed vs successful decryptions.

**Parallel Decryption Context:**

Both FPTX and FPTXWeighted implement batch decryption using parallel iteration: [2](#0-1) 

The batch decryption completes when **all** parallel tasks finish. The slowest decryption determines the total batch time. This means:
- Batches with complex plaintexts take longer overall
- Batches with authentication failures complete faster
- Timing differences are observable at the batch level

**Consensus Integration:**

This is actively exploited in the consensus decryption pipeline: [3](#0-2) 

Validators decrypt encrypted transactions from blocks using `FPTXWeighted::decrypt_individual()`, which calls the vulnerable decryption path. An attacker submitting encrypted transactions to blocks can potentially measure validator processing time.

**Attack Path:**

1. Attacker submits multiple encrypted transactions with known plaintext structures (e.g., simple vs complex)
2. Attacker measures block processing time across multiple rounds
3. By comparing timing across batches with different compositions, attacker extracts statistical information about:
   - Whether other transactions in the batch are simple or complex
   - Relative transaction complexity distribution
   - Presence of authentication failures (invalid ciphertexts)

**Cryptographic Operations:**

The BIBE decryption path performs pairing operations and XOR-based key unpadding: [4](#0-3) 

While the pairing operations (using ark-bls12-381) should be constant-time, the variable-time deserialization at the end creates the exploitable timing channel.

## Impact Explanation

**Severity: Medium** - Information Disclosure

This vulnerability enables **limited information leakage** about encrypted transaction content:

- **Information Leaked**: Statistical distribution of transaction complexity within batches, not full plaintext recovery
- **Privacy Impact**: Attackers can infer transaction patterns (e.g., "this batch contains mostly complex smart contract calls" vs "this batch has simple transfers")
- **No Direct Consensus Impact**: Does not break consensus safety, liveness, or state consistency
- **No Fund Loss**: Does not enable theft, minting, or freezing of funds

Per Aptos Bug Bounty categories, this falls under **Medium Severity** due to information disclosure that could aid in building privacy attack profiles, but does not directly compromise consensus or funds.

However, practical exploitability is challenging due to:
- Network latency masking microsecond-level timing differences
- Distributed system noise from multiple validators
- Variable CPU load and concurrent operations
- Requirement for many measurement samples for statistical significance

## Likelihood Explanation

**Likelihood: Medium-Low**

**Attack Requirements:**
- Ability to submit encrypted transactions (available to any user)
- Precise timing measurement capability from outside the validator
- Statistical analysis over many samples (dozens to hundreds of blocks)
- Correlation with known transaction patterns

**Practical Challenges:**
- Network latency (milliseconds) significantly exceeds deserialization timing differences (microseconds)
- Distributed consensus processing introduces substantial noise
- Multiple validators with heterogeneous hardware complicate timing measurements
- Batch composition varies naturally, making signal extraction difficult

**Feasibility Assessment:**
While the timing channel exists in the code, successfully extracting meaningful information in a production environment requires sophisticated timing attack techniques typically used in co-located or low-latency network scenarios. In a distributed blockchain network with geographic validator distribution, the attack becomes significantly harder but not theoretically impossible.

## Recommendation

**Primary Recommendation: Implement Constant-Time Deserialization Padding**

Add deterministic padding to ensure all decryption operations take constant time regardless of plaintext structure:

```rust
pub fn decrypt<P: Plaintext>(&self, ciphertext: &SymmetricCiphertext) -> Result<P> {
    use aes_gcm::KeyInit as _;
    
    let key: &Key<SymmetricCipher> = &self.0;
    let cipher = SymmetricCipher::new(key);
    
    // Decrypt (constant-time in AES-GCM implementation)
    let plaintext_bytes = cipher
        .decrypt(&ciphertext.nonce, ciphertext.ct_body.as_ref())
        .map_err(|_| BatchEncryptionError::SymmetricDecryptionError)?;
    
    // SECURITY FIX: Pad deserialization to constant time
    // Deserialize with timing-independent operations
    let result = bcs::from_bytes(&plaintext_bytes)
        .map_err(|_| BatchEncryptionError::DeserializationError)?;
    
    // Add constant-time delay to normalize timing
    // This ensures all decryptions take the same time
    constant_time_delay_until_max_expected_time();
    
    Ok(result)
}
```

**Alternative Recommendation: Deferred Deserialization**

Separate decryption from deserialization to remove the timing channel:

```rust
// Return raw bytes from decrypt
fn decrypt_to_bytes(&self, ct: &PreparedBIBECiphertext) -> Result<Vec<u8>> {
    // ... existing decryption logic ...
    Ok(plaintext_bytes)
}

// Deserialize separately in a non-timing-sensitive context
fn deserialize_plaintext<P: Plaintext>(bytes: &[u8]) -> Result<P> {
    bcs::from_bytes(bytes)
        .map_err(|_| BatchEncryptionError::DeserializationError)
}
```

**Additional Hardening:**

1. Use constant-time comparison for MAC verification (already handled by `aes_gcm` crate)
2. Consider adding random timing jitter to batch operations
3. Document timing-sensitive operations for security review
4. Add dudect-style statistical tests for timing consistency

## Proof of Concept

```rust
#[cfg(test)]
mod timing_side_channel_poc {
    use super::*;
    use crate::{
        schemes::fptx_weighted::FPTXWeighted,
        traits::BatchThresholdEncryption,
    };
    use aptos_crypto::arkworks::shamir::ShamirThresholdConfig;
    use std::time::Instant;
    
    // Simple plaintext (few bytes)
    #[derive(Serialize, Deserialize)]
    struct SimpleTx {
        value: u64,
    }
    
    // Complex plaintext (many nested structures)
    #[derive(Serialize, Deserialize)]
    struct ComplexTx {
        nested: Vec<Vec<Vec<String>>>,
        data: Vec<u8>,
    }
    
    #[test]
    fn demonstrate_timing_side_channel() {
        let mut rng = thread_rng();
        let tc = ShamirThresholdConfig::new(2, 3);
        let (ek, dk, _, msk_shares) = 
            FPTXWeighted::setup_for_testing(rng.gen(), 100, 10, &tc).unwrap();
        
        // Create simple transaction ciphertexts
        let simple_cts: Vec<_> = (0..50)
            .map(|i| {
                let tx = SimpleTx { value: i };
                ek.encrypt(&mut rng, &tx, &()).unwrap()
            })
            .collect();
        
        // Create complex transaction ciphertexts
        let complex_cts: Vec<_> = (0..50)
            .map(|_| {
                let tx = ComplexTx {
                    nested: vec![vec![vec!["data".to_string(); 100]; 10]; 5],
                    data: vec![0u8; 1000],
                };
                ek.encrypt(&mut rng, &tx, &()).unwrap()
            })
            .collect();
        
        // Measure decryption time for simple batch
        let (digest_simple, proofs_promise) = 
            FPTXWeighted::digest(&dk, &simple_cts, 0).unwrap();
        let proofs_simple = proofs_promise.compute_all(&dk);
        let prepared_simple = FPTXWeighted::prepare_cts(
            &simple_cts, &digest_simple, &proofs_simple
        ).unwrap();
        
        // Reconstruct decryption key
        let dk_shares: Vec<_> = msk_shares.iter()
            .map(|msk| FPTXWeighted::derive_decryption_key_share(msk, &digest_simple).unwrap())
            .collect();
        let decryption_key = FPTXWeighted::reconstruct_decryption_key(
            &dk_shares[..2], &tc
        ).unwrap();
        
        let start = Instant::now();
        let _: Vec<SimpleTx> = FPTXWeighted::decrypt(&decryption_key, &prepared_simple).unwrap();
        let simple_time = start.elapsed();
        
        // Measure decryption time for complex batch
        let (digest_complex, proofs_promise) = 
            FPTXWeighted::digest(&dk, &complex_cts, 1).unwrap();
        let proofs_complex = proofs_promise.compute_all(&dk);
        let prepared_complex = FPTXWeighted::prepare_cts(
            &complex_cts, &digest_complex, &proofs_complex
        ).unwrap();
        
        let dk_shares_complex: Vec<_> = msk_shares.iter()
            .map(|msk| FPTXWeighted::derive_decryption_key_share(msk, &digest_complex).unwrap())
            .collect();
        let decryption_key_complex = FPTXWeighted::reconstruct_decryption_key(
            &dk_shares_complex[..2], &tc
        ).unwrap();
        
        let start = Instant::now();
        let _: Vec<ComplexTx> = FPTXWeighted::decrypt(&decryption_key_complex, &prepared_complex).unwrap();
        let complex_time = start.elapsed();
        
        println!("Simple batch decryption: {:?}", simple_time);
        println!("Complex batch decryption: {:?}", complex_time);
        println!("Timing difference: {:?}", complex_time.saturating_sub(simple_time));
        
        // Demonstrate that timing differences are measurable
        // In a real attack, statistical analysis over many samples would be used
        assert!(complex_time > simple_time, 
            "Complex deserialization should take longer, revealing information");
    }
}
```

## Notes

**Scope Clarification**: This vulnerability affects plaintext **content characteristics** (structural complexity), not decryption **key structure**. The cryptographic operations (pairing, XOR) using arkworks should be constant-time. The timing leak is specifically in the BCS deserialization layer.

**Real-World Exploitability**: While the code contains a timing side channel, successfully exploiting it in production requires overcoming significant practical challenges including network latency, distributed system noise, and the need for statistical analysis over many samples. This reduces the practical severity despite the theoretical vulnerability.

**Affected Components**: All three FPTX variants (FPTX, FPTXWeighted, FPTXSuccinct) share the same vulnerable symmetric decryption implementation and parallel decryption pattern.

### Citations

**File:** crates/aptos-batch-encryption/src/shared/symmetric.rs (L112-123)
```rust
    pub fn decrypt<P: Plaintext>(&self, ciphertext: &SymmetricCiphertext) -> Result<P> {
        use aes_gcm::KeyInit as _; // putting this in the global scope causes Hmac<Sha256> to be
                                   // ambiguous for some reason

        let key: &Key<SymmetricCipher> = &self.0;
        let cipher = SymmetricCipher::new(key);
        let plaintext_bytes = cipher
            .decrypt(&ciphertext.nonce, ciphertext.ct_body.as_ref())
            .map_err(|_| BatchEncryptionError::SymmetricDecryptionError)?;
        Ok(bcs::from_bytes(&plaintext_bytes)
            .map_err(|_| BatchEncryptionError::DeserializationError)?)
    }
```

**File:** crates/aptos-batch-encryption/src/schemes/fptx_weighted.rs (L388-398)
```rust
    fn decrypt<'a, P: Plaintext>(
        decryption_key: &Self::DecryptionKey,
        cts: &[Self::PreparedCiphertext],
    ) -> anyhow::Result<Vec<P>> {
        cts.into_par_iter()
            .map(|ct| {
                let plaintext: Result<P> = decryption_key.decrypt(ct);
                plaintext
            })
            .collect::<anyhow::Result<Vec<P>>>()
    }
```

**File:** consensus/src/pipeline/decryption_pipeline_builder.rs (L121-148)
```rust
        let decrypted_txns = encrypted_txns
            .into_par_iter()
            .zip(txn_ciphertexts)
            .map(|(mut txn, ciphertext)| {
                let eval_proof = proofs.get(&ciphertext.id()).expect("must exist");
                if let Ok(payload) = FPTXWeighted::decrypt_individual::<DecryptedPayload>(
                    &decryption_key.key,
                    &ciphertext,
                    &digest,
                    &eval_proof,
                ) {
                    let (executable, nonce) = payload.unwrap();
                    txn.payload_mut()
                        .as_encrypted_payload_mut()
                        .map(|p| {
                            p.into_decrypted(eval_proof, executable, nonce)
                                .expect("must happen")
                        })
                        .expect("must exist");
                } else {
                    txn.payload_mut()
                        .as_encrypted_payload_mut()
                        .map(|p| p.into_failed_decryption(eval_proof).expect("must happen"))
                        .expect("must exist");
                }
                txn
            })
            .collect();
```

**File:** crates/aptos-batch-encryption/src/shared/ciphertext/bibe.rs (L155-168)
```rust
impl<P: Plaintext> BIBECTDecrypt<P> for BIBEDecryptionKey {
    fn bibe_decrypt(&self, ct: &PreparedBIBECiphertext) -> Result<P> {
        let otp_source_1 = PairingSetting::pairing(self.signature_g1, ct.ct_g2.clone());
        let otp_source_gt = otp_source_1 + ct.pairing_output;

        let mut otp_source_bytes = Vec::new();
        otp_source_gt.serialize_compressed(&mut otp_source_bytes)?;
        let otp = OneTimePad::from_source_bytes(otp_source_bytes);

        let symmetric_key = otp.unpad_key(&ct.padded_key);

        symmetric_key.decrypt(&ct.symmetric_ciphertext)
    }
}
```
