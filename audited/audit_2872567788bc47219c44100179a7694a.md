# Audit Report

## Title
Missing Write Set Hash Validation During Backup Restoration Enables Historical Query Poisoning

## Summary
The backup restoration process deserializes write sets from backup files without validating that they match the cryptographic hash (`state_change_hash`) stored in the corresponding `TransactionInfo`. This allows an attacker who compromises backup storage to inject malicious write sets that will be served to auditors querying historical transaction data, enabling them to hide fraudulent activity.

## Finding Description

The vulnerability exists in the backup restoration code path where write sets are loaded from backup files and stored in the database without cryptographic validation.

**Attack Flow:**

1. **Backup File Deserialization**: In `LoadedChunk::load()`, write sets are deserialized from backup files alongside transactions and transaction infos: [1](#0-0) 

2. **Incomplete Verification**: The code verifies transactions, events, and transaction_infos against the signed `LedgerInfo`, but **does not verify write_sets**: [2](#0-1) 

Note that `TransactionListWithProof` (created at lines 157-166) contains only `txns`, `event_vecs`, and `txn_infos` - the `write_sets` are excluded from verification.

3. **Unvalidated Storage**: Write sets are then stored directly to the database without validation: [3](#0-2) 

4. **Missing Validation Point**: During normal transaction execution, `TransactionInfo` includes a `state_change_hash` field that is the cryptographic hash of the write set: [4](#0-3) 

However, this validation is **never performed** during backup restoration.

5. **Validation Method Exists But Unused**: The codebase has a method to validate write sets against transaction info: [5](#0-4) 

This method is called during execution validation but **not during backup restore**.

**Breaking Invariant**: This violates the **State Consistency** invariant: "State transitions must be atomic and verifiable via Merkle proofs." The `state_change_hash` in `TransactionInfo` should cryptographically bind to the write set, but this binding is not verified during restore.

**Attack Scenario:**
1. Attacker compromises backup storage (e.g., leaked S3 credentials)
2. Attacker modifies backup chunk files, replacing write sets while keeping transactions, transaction_infos, and cryptographic proofs intact
3. Node operator restores from compromised backup
4. Modified write sets are stored without validation
5. Historical queries via `get_write_set()` return fraudulent data: [6](#0-5) 

6. Auditors receive incorrect transaction history showing fraudulent state changes or hiding legitimate ones

## Impact Explanation

**Severity: High**

This qualifies as **High severity** under Aptos bug bounty criteria for "Significant protocol violations." Specifically:

- **Breaks Auditability**: Auditors cannot trust historical write set data retrieved from nodes restored from backups
- **Enables Fraud Concealment**: Attackers can retroactively alter the recorded state changes to hide theft or manipulation
- **Protocol Integrity Violation**: The fundamental guarantee that `CryptoHash::hash(write_set) == txn_info.state_change_hash` is violated for restored data
- **Affects All Downstream Systems**: Indexers, block explorers, and compliance tools relying on historical queries receive corrupted data

While this requires compromising backup storage (not direct node access), backup infrastructure is often less secured than live validator nodes, making this a realistic attack surface.

## Likelihood Explanation

**Likelihood: Medium**

**Attack Requirements:**
- Access to backup storage (cloud storage credentials, compromised backup infrastructure)
- Ability to modify backup chunk files
- Target node must restore from compromised backups

**Factors Increasing Likelihood:**
- Backup storage often uses third-party cloud services with shared credential management
- Backup infrastructure typically has less stringent security than validator nodes
- No cryptographic integrity protection on write_sets within backup files (unlike transactions/txn_infos which are covered by ledger_info signatures)
- Common operational practice to restore from backups during node setup or disaster recovery

**Factors Decreasing Likelihood:**
- Requires specific infrastructure access rather than network-level exploit
- Detection possible if auditors manually verify `state_change_hash` matches retrieved write_sets
- Legitimate operators may have additional backup verification procedures

## Recommendation

Add cryptographic validation of write sets against `state_change_hash` during backup restoration:

```rust
// In storage/aptosdb/src/backup/restore_utils.rs, save_transactions_impl()
// After line 260, add validation:

use aptos_crypto::hash::CryptoHash;

// Validate write sets match transaction info hashes
for (idx, (ws, txn_info)) in write_sets.iter().zip(txn_infos.iter()).enumerate() {
    let write_set_hash = CryptoHash::hash(ws);
    ensure!(
        write_set_hash == txn_info.state_change_hash(),
        "Write set hash mismatch at version {}: computed {:?}, expected {:?}",
        first_version + idx as Version,
        write_set_hash,
        txn_info.state_change_hash()
    );
}

// Then proceed with storage
for (idx, ws) in write_sets.iter().enumerate() {
    WriteSetDb::put_write_set(
        first_version + idx as Version,
        ws,
        &mut ledger_db_batch.write_set_db_batches,
    )?;
}
```

This ensures write sets cannot be tampered with even if backup files are compromised, as the `state_change_hash` is protected by the cryptographically signed `LedgerInfo`.

## Proof of Concept

```rust
#[cfg(test)]
mod backup_restore_writeset_validation_test {
    use super::*;
    use aptos_crypto::hash::CryptoHash;
    use aptos_types::{
        transaction::{Transaction, TransactionInfo, TransactionStatus},
        write_set::{WriteSet, WriteSetMut},
        state_store::state_key::StateKey,
        contract_event::ContractEvent,
    };
    
    #[test]
    fn test_malicious_writeset_accepted_without_validation() {
        // Setup: Create a legitimate transaction with correct write_set and txn_info
        let legitimate_write_set = WriteSet::new(vec![]).unwrap();
        let legitimate_hash = CryptoHash::hash(&legitimate_write_set);
        
        let txn_info = TransactionInfo::new(
            HashValue::zero(),
            legitimate_hash, // Correct state_change_hash
            HashValue::zero(),
            None,
            0,
            TransactionStatus::Keep(ExecutionStatus::Success),
            None,
        );
        
        // Attack: Create a different (malicious) write_set
        let malicious_write_set = WriteSet::new(vec![
            (StateKey::raw(b"malicious"), WriteOp::legacy_deletion())
        ]).unwrap();
        
        // Verify hashes don't match (this is the attack)
        let malicious_hash = CryptoHash::hash(&malicious_write_set);
        assert_ne!(legitimate_hash, malicious_hash);
        
        // The current restore_utils::save_transactions_impl() would accept
        // malicious_write_set even though it doesn't match txn_info.state_change_hash
        // because there's no validation performed.
        
        // Expected: Restoration should FAIL with hash mismatch
        // Actual: Restoration SUCCEEDS, storing fraudulent write_set
        
        println!("VULNERABILITY: Malicious write set would be accepted!");
        println!("Expected hash: {:?}", legitimate_hash);
        println!("Malicious hash: {:?}", malicious_hash);
        println!("No validation prevents this during backup restore!");
    }
}
```

**Note**: This PoC demonstrates the conceptual vulnerability. A full integration test would require setting up mock backup files and restore infrastructure, but the core issue is clear: write sets are stored without validation against `state_change_hash` during restoration.

### Citations

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L112-137)
```rust
        while let Some(record_bytes) = file.read_record_bytes().await? {
            let (txn, aux_info, txn_info, events, write_set): (
                _,
                PersistedAuxiliaryInfo,
                _,
                _,
                WriteSet,
            ) = match manifest.format {
                TransactionChunkFormat::V0 => {
                    let (txn, txn_info, events, write_set) = bcs::from_bytes(&record_bytes)?;
                    (
                        txn,
                        PersistedAuxiliaryInfo::None,
                        txn_info,
                        events,
                        write_set,
                    )
                },
                TransactionChunkFormat::V1 => bcs::from_bytes(&record_bytes)?,
            };
            txns.push(txn);
            persisted_aux_info.push(aux_info);
            txn_infos.push(txn_info);
            event_vecs.push(events);
            write_sets.push(write_set);
        }
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L157-167)
```rust
        let txn_list_with_proof =
            TransactionListWithProofV2::new(TransactionListWithAuxiliaryInfos::new(
                TransactionListWithProof::new(
                    txns,
                    Some(event_vecs),
                    Some(manifest.first_version),
                    TransactionInfoListWithProof::new(range_proof, txn_infos),
                ),
                persisted_aux_info,
            ));
        txn_list_with_proof.verify(ledger_info.ledger_info(), Some(manifest.first_version))?;
```

**File:** storage/aptosdb/src/backup/restore_utils.rs (L260-267)
```rust
    // insert changes in write set schema batch
    for (idx, ws) in write_sets.iter().enumerate() {
        WriteSetDb::put_write_set(
            first_version + idx as Version,
            ws,
            &mut ledger_db_batch.write_set_db_batches,
        )?;
    }
```

**File:** execution/executor/src/workflow/do_ledger_update.rs (L76-79)
```rust
                let write_set_hash = CryptoHash::hash(txn_output.write_set());
                let txn_info = TransactionInfo::new(
                    txn.hash(),
                    write_set_hash,
```

**File:** types/src/transaction/mod.rs (L1898-1908)
```rust
        let write_set_hash = CryptoHash::hash(self.write_set());
        ensure!(
            write_set_hash == txn_info.state_change_hash(),
            "{}: version:{}, write_set_hash:{:?}, expected:{:?}, write_set: {:?}, expected(if known): {:?}",
            ERR_MSG,
            version,
            write_set_hash,
            txn_info.state_change_hash(),
            self.write_set,
            expected_write_set,
        );
```

**File:** storage/aptosdb/src/ledger_db/write_set_db.rs (L56-61)
```rust
    /// Returns executed transaction vm output given the `version`.
    pub(crate) fn get_write_set(&self, version: Version) -> Result<WriteSet> {
        self.db
            .get::<WriteSetSchema>(&version)?
            .ok_or_else(|| AptosDbError::NotFound(format!("WriteSet at version {}", version)))
    }
```
