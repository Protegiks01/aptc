# Audit Report

## Title
Blockchain Reorganization Causes Stale `already_proposed` State Leading to Valid Proposal Rejection

## Summary
During blockchain reorganizations, the `already_proposed` state in `UnequivocalProposerElection` is not reset, causing the node to incorrectly reject legitimate proposals from the canonical chain as duplicates, preventing consensus participation.

## Finding Description

The `UnequivocalProposerElection` wrapper maintains an `already_proposed` state to detect equivocation (multiple proposals from the same leader in a round). [1](#0-0) 

When `is_valid_proposal()` processes a proposal, it immediately updates this state for any proposal with a round greater than the stored round, before any other validation or block insertion occurs. [2](#0-1) 

The critical issue occurs during blockchain reorganizations. When a node performs fast-forward sync via `sync_to_highest_quorum_cert()`, it calls `rebuild()` to reconstruct the block tree with blocks from a different fork. [3](#0-2) 

The `rebuild()` method replaces the entire BlockTree structure. [4](#0-3) 

However, the `UnequivocalProposerElection` instance and its `already_proposed` state persist across reorganizations because they are created once per epoch in `RoundManager::new()` and have no reset mechanism. [5](#0-4) 

**Attack Scenario:**

1. Node follows fork A and receives a proposal for round 100 with hash_A
2. `is_valid_proposal()` is called, validates the proposer, and updates `already_proposed = (100, hash_A)`
3. The node then syncs to fork B (the canonical chain) due to receiving higher QCs from peers
4. `sync_up()` → `add_certs()` → `sync_to_highest_quorum_cert()` → `rebuild()` executes
5. The block tree is rebuilt with fork B's blocks, which also has round 100 but with hash_B
6. `already_proposed` still contains `(100, hash_A)` — it was NOT reset
7. When fork B's proposal for round 100 arrives, the validation check at line 70 fails because `hash_B != hash_A`
8. The node rejects the valid canonical proposal as an equivocation attempt
9. For proposals with rounds < 100, they are rejected at line 84 (Ordering::Less returns false)
10. The node cannot process the canonical chain's proposals and becomes stuck

This breaks the **State Consistency** invariant where proposal validation state must remain consistent with the actual blockchain state.

## Impact Explanation

This is **Medium Severity** under the Aptos bug bounty criteria: "State inconsistencies requiring intervention."

**Impact:**
- **Availability**: Affected nodes cannot process legitimate proposals after reorganization, causing them to fall out of consensus
- **Liveness**: Nodes become unable to participate in block validation and voting
- **State Inconsistency**: The proposal tracking state diverges from the actual blockchain state, requiring node restart or manual intervention

This does not directly cause loss of funds or consensus safety violations (nodes don't commit incorrect blocks), but it does prevent affected nodes from participating in the network, which degrades overall network availability and could impact liveness if enough nodes are affected.

## Likelihood Explanation

**Likelihood: Medium to High**

This vulnerability can be triggered in several realistic scenarios:

1. **Network Partitions**: During temporary network splits, nodes may see different forks before reconverging
2. **Slow Sync**: Nodes that fall behind and then fast-forward sync to catch up
3. **Malicious Proposals**: An attacker can send proposals from a minority fork to poison the `already_proposed` state before the node syncs to the canonical chain
4. **Natural Reorganizations**: Small reorganizations can occur naturally in distributed consensus systems

The vulnerability requires:
- No special privileges (any network peer can send proposals)
- No complex timing requirements
- Only requires the node to receive a proposal and then perform a reorganization

Reorganizations are a normal part of blockchain operation, making this a realistic and recurring scenario.

## Recommendation

Add a reset mechanism for the `already_proposed` state that is called during blockchain reorganizations.

**Solution 1: Add a reset method to `UnequivocalProposerElection`**

Add the following method to `unequivocal_proposer_election.rs`:

```rust
pub fn reset_state(&self) {
    let mut already_proposed = self.already_proposed.lock();
    already_proposed.0 = 0;
    already_proposed.1 = HashValue::zero();
}
```

**Solution 2: Call reset during `rebuild()`**

Modify `BlockStore::rebuild()` to accept a callback or signal that can reset dependent state:

```rust
pub async fn rebuild(
    &self,
    root: RootInfo,
    root_metadata: RootMetadata,
    blocks: Vec<Block>,
    quorum_certs: Vec<QuorumCert>,
) {
    // ... existing code ...
    
    // Notify components that depend on block tree state
    // This would require passing the proposer_election reference
    // or using an event/signal mechanism
    
    // ... rest of existing code ...
}
```

**Solution 3: Track the committed root round instead**

Modify `is_valid_proposal()` to compare against the block store's committed/ordered root round rather than just the last seen round, ensuring consistency with the actual chain state:

```rust
pub fn is_valid_proposal(&self, block: &Block, ordered_root_round: Round) -> bool {
    block.author().is_some_and(|author| {
        let valid_author = self.is_valid_proposer(author, block.round());
        if !valid_author {
            return false;
        }
        let mut already_proposed = self.already_proposed.lock();
        
        // Reset state if block tree has reorganized to a different root
        if ordered_root_round > already_proposed.0 {
            already_proposed.0 = ordered_root_round;
            already_proposed.1 = HashValue::zero();
        }
        
        match block.round().cmp(&already_proposed.0) {
            Ordering::Greater => {
                already_proposed.0 = block.round();
                already_proposed.1 = block.id();
                true
            },
            // ... rest of logic ...
        }
    })
}
```

The recommended approach is **Solution 1 + 2**: Add an explicit reset method and call it during `rebuild()` to ensure the proposal validation state stays consistent with the block tree state.

## Proof of Concept

```rust
#[cfg(test)]
mod reorganization_test {
    use super::*;
    use aptos_consensus_types::block::Block;
    use aptos_crypto::HashValue;
    use aptos_types::account_address::AccountAddress;
    
    #[test]
    fn test_already_proposed_stale_after_reorg() {
        // Setup: Create UnequivocalProposerElection
        let proposer = AccountAddress::random();
        let proposer_election = Arc::new(UnequivocalProposerElection::new(
            Arc::new(RotatingProposer::new(vec![proposer], 1))
        ));
        
        // Step 1: Create and validate proposal for round 100 on fork A
        let block_a = Block::new_for_testing(/* round */ 100, proposer);
        assert!(proposer_election.is_valid_proposal(&block_a));
        
        // At this point, already_proposed = (100, block_a.id())
        
        // Step 2: Simulate blockchain reorganization
        // In reality, this would be: sync_to_highest_quorum_cert() -> rebuild()
        // But already_proposed is NOT reset
        
        // Step 3: Create proposal for round 100 on fork B (different hash)
        let block_b = Block::new_for_testing(/* round */ 100, proposer);
        assert_ne!(block_a.id(), block_b.id()); // Different blocks for same round
        
        // Step 4: Validate proposal from fork B
        // This should pass if we reorganized to fork B, but it fails!
        let result = proposer_election.is_valid_proposal(&block_b);
        
        // VULNERABILITY: Valid proposal from canonical fork B is rejected
        assert!(!result, "Valid proposal from reorganized fork should be accepted but is rejected");
        
        // Step 5: Try proposals for rounds < 100
        let block_95 = Block::new_for_testing(/* round */ 95, proposer);
        assert!(!proposer_election.is_valid_proposal(&block_95),
               "Proposals for old rounds are rejected even if they're from the new fork");
    }
}
```

This test demonstrates that once `already_proposed` is set to round 100 with a specific block hash, any subsequent proposal for round 100 with a different hash (as would occur after reorganization to a different fork) is rejected, even though it may be the legitimate proposal from the canonical chain.

## Notes

The vulnerability exists because `UnequivocalProposerElection` was designed to prevent equivocation within a stable chain, but the design did not account for blockchain reorganizations where the chain itself changes. The state becomes stale relative to the actual block tree after `rebuild()` operations.

This issue affects nodes during:
- Fast-forward sync operations [6](#0-5) 
- Any call to `sync_up()` that triggers reorganization [7](#0-6) 
- Recovery from network partitions or catching up from being offline

The fix requires coordinating the proposal validation state with the block tree state lifecycle, ensuring they remain consistent across reorganizations.

### Citations

**File:** consensus/src/liveness/unequivocal_proposer_election.rs (L18-21)
```rust
pub struct UnequivocalProposerElection {
    proposer_election: Arc<dyn ProposerElection + Send + Sync>,
    already_proposed: Mutex<(Round, HashValue)>,
}
```

**File:** consensus/src/liveness/unequivocal_proposer_election.rs (L61-68)
```rust
            let mut already_proposed = self.already_proposed.lock();
            // detect if the leader proposes more than once in this round
            match block.round().cmp(&already_proposed.0) {
                Ordering::Greater => {
                    already_proposed.0 = block.round();
                    already_proposed.1 = block.id();
                    true
                },
```

**File:** consensus/src/block_storage/sync_manager.rs (L279-314)
```rust
    async fn sync_to_highest_quorum_cert(
        &self,
        highest_quorum_cert: QuorumCert,
        highest_commit_cert: WrappedLedgerInfo,
        retriever: &mut BlockRetriever,
    ) -> anyhow::Result<()> {
        if !self.need_sync_for_ledger_info(highest_commit_cert.ledger_info()) {
            return Ok(());
        }

        if let Some(pre_commit_status) = self.pre_commit_status() {
            defer! {
                pre_commit_status.lock().resume();
            }
        }

        let (root, root_metadata, blocks, quorum_certs) = Self::fast_forward_sync(
            &highest_quorum_cert,
            &highest_commit_cert,
            retriever,
            self.storage.clone(),
            self.execution_client.clone(),
            self.payload_manager.clone(),
            self.order_vote_enabled,
            self.window_size,
            Some(self),
        )
        .await?
        .take();
        info!(
            LogSchema::new(LogEvent::CommitViaSync).round(self.ordered_root().round()),
            committed_round = root.commit_root_block.round(),
            block_id = root.commit_root_block.id(),
        );
        self.rebuild(root, root_metadata, blocks, quorum_certs)
            .await;
```

**File:** consensus/src/block_storage/block_store.rs (L352-395)
```rust
    pub async fn rebuild(
        &self,
        root: RootInfo,
        root_metadata: RootMetadata,
        blocks: Vec<Block>,
        quorum_certs: Vec<QuorumCert>,
    ) {
        info!(
            "Rebuilding block tree. root {:?}, blocks {:?}, qcs {:?}",
            root,
            blocks.iter().map(|b| b.id()).collect::<Vec<_>>(),
            quorum_certs
                .iter()
                .map(|qc| qc.certified_block().id())
                .collect::<Vec<_>>()
        );
        let max_pruned_blocks_in_mem = self.inner.read().max_pruned_blocks_in_mem();

        // Rollover the previous highest TC from the old tree to the new one.
        let prev_2chain_htc = self
            .highest_2chain_timeout_cert()
            .map(|tc| tc.as_ref().clone());
        let _ = Self::build(
            root,
            root_metadata,
            blocks,
            quorum_certs,
            prev_2chain_htc,
            self.execution_client.clone(),
            Arc::clone(&self.storage),
            max_pruned_blocks_in_mem,
            Arc::clone(&self.time_service),
            self.vote_back_pressure_limit,
            self.payload_manager.clone(),
            self.order_vote_enabled,
            self.window_size,
            self.pending_blocks.clone(),
            self.pipeline_builder.clone(),
            Some(self.inner.clone()),
        )
        .await;

        self.try_send_for_execution().await;
    }
```

**File:** consensus/src/round_manager.rs (L369-369)
```rust
            proposer_election: Arc::new(UnequivocalProposerElection::new(proposer_election)),
```

**File:** consensus/src/round_manager.rs (L878-906)
```rust
    async fn sync_up(&mut self, sync_info: &SyncInfo, author: Author) -> anyhow::Result<()> {
        let local_sync_info = self.block_store.sync_info();
        if sync_info.has_newer_certificates(&local_sync_info) {
            info!(
                self.new_log(LogEvent::ReceiveNewCertificate)
                    .remote_peer(author),
                "Local state {},\n remote state {}", local_sync_info, sync_info
            );
            // Some information in SyncInfo is ahead of what we have locally.
            // First verify the SyncInfo (didn't verify it in the yet).
            sync_info.verify(&self.epoch_state.verifier).map_err(|e| {
                error!(
                    SecurityEvent::InvalidSyncInfoMsg,
                    sync_info = sync_info,
                    remote_peer = author,
                    error = ?e,
                );
                VerifyError::from(e)
            })?;
            SYNC_INFO_RECEIVED_WITH_NEWER_CERT.inc();
            let result = self
                .block_store
                .add_certs(sync_info, self.create_block_retriever(author))
                .await;
            self.process_certificates().await?;
            result
        } else {
            Ok(())
        }
```
