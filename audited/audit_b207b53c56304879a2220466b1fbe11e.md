# Audit Report

## Title
Critical Configuration Bypass via Sanitizer Skip Flag Allows Validator Network Authentication Bypass

## Summary
An attacker with write access to a validator's configuration file can bypass critical security validations by exploiting both the configuration optimizer's precedence logic and the sanitizer bypass flag (`skip_config_sanitizer`). This allows a validator to operate without mandatory mutual authentication and proper network isolation, breaking the validator network's trust model.

## Finding Description

The Aptos configuration loading system has a two-phase design: an **optimizer** phase that sets secure defaults, followed by a **sanitizer** phase that validates critical security requirements.

The optimizer respects a precedence rule documented in the code: [1](#0-0) 

The optimizer only sets values when they are `.is_null()` in the local config. For validator networks, it attempts to enforce: [2](#0-1) 

However, if an attacker provides explicit (non-null) values in their `local_config_yaml`, the optimizer will **not override them** due to the precedence logic. This is confirmed by the test case: [3](#0-2) 

The sanitizer is designed to catch such misconfigurations: [4](#0-3) 

However, the sanitizer can be completely bypassed via a user-controllable flag: [5](#0-4) 

This flag is part of the serializable configuration structure: [6](#0-5) 

And is loaded from the same YAML file being validated: [7](#0-6) 

**Attack Path:**
1. Attacker crafts malicious `validator.yaml`:
```yaml
node_startup:
  skip_config_sanitizer: true
validator_network:
  network_id: "Public"
  mutual_authentication: false
```

2. Config loading deserializes these values, including `skip_config_sanitizer: true` [8](#0-7) 

3. Optimizer runs but skips setting secure defaults (values are explicitly set, not null) [9](#0-8) 

4. Sanitizer runs but immediately returns without validation [10](#0-9) 

5. Network builder creates `AuthenticationMode::MaybeMutual` instead of `Mutual`: [11](#0-10) 

6. This converts to `HandshakeAuthMode::maybe_mutual()`: [12](#0-11) 

7. In `MaybeMutual` mode, the validator accepts connections from **any peer**, not just trusted validators: [13](#0-12) 

The validator network now operates on the Public network ID and accepts unauthenticated connections, breaking network isolation.

## Impact Explanation

**Critical Severity** - This vulnerability enables:

1. **Consensus Safety Violations**: Malicious peers can connect to the validator network and inject consensus messages, potentially causing:
   - Equivocation detection failures
   - Invalid block proposals reaching consensus nodes
   - Network partition through message flooding

2. **Network Isolation Breach**: The validator network is designed to be isolated from public networks using distinct NetworkIds and mutual authentication. The comment confirms this design: [14](#0-13) 

3. **Authentication Bypass**: In `Mutual` mode, only trusted validators can connect. In `MaybeMutual` mode, any peer can connect: [15](#0-14) 

This meets the **Critical Severity** criteria: "Consensus/Safety violations" and "Significant protocol violations."

## Likelihood Explanation

**Likelihood: Medium-High** in specific scenarios:

1. **Compromised validator nodes**: If an attacker gains filesystem write access through another vulnerability, they can modify the config to maintain persistent access while bypassing security checks.

2. **Supply chain attacks**: Malicious configuration templates distributed through unofficial channels or compromised deployment automation.

3. **Social engineering**: Validator operators may be tricked into using configs from untrusted sources that contain the bypass flags.

4. **Configuration management errors**: Automated deployment systems might inadvertently propagate insecure configurations.

While this requires config file write access (typically requiring privileged access), the severity of the impact and the simplicity of exploitation warrant attention. The design flaw is that security validation can be disabled via the same file being validated, providing no defense-in-depth.

## Recommendation

**1. Remove the `skip_config_sanitizer` flag from user-accessible configuration**, or make it only settable via command-line flags that require explicit operator action:

```rust
// In node_startup_config.rs
#[derive(Clone, Copy, Debug, Deserialize, PartialEq, Eq, Serialize)]
#[serde(default, deny_unknown_fields)]
pub struct NodeStartupConfig {
    pub skip_config_optimizer: bool,
    #[serde(skip)] // Prevent deserialization from config file
    pub skip_config_sanitizer: bool,
}
```

**2. Add an explicit check for critical validator network settings** that cannot be bypassed:

```rust
// In config_sanitizer.rs - add this check before the skip check
fn sanitize_validator_network_config(
    node_config: &NodeConfig,
    node_type: NodeType,
    _chain_id: Option<ChainId>,
) -> Result<(), Error> {
    // ALWAYS enforce validator network security, regardless of skip flags
    if node_type.is_validator() {
        if let Some(validator_network_config) = &node_config.validator_network {
            if !validator_network_config.network_id.is_validator_network() {
                return Err(Error::ConfigSanitizerFailed(
                    "ValidatorNetworkConfigSanitizer".to_string(),
                    "CRITICAL: Validator network must use Validator network ID!".into(),
                ));
            }
            if !validator_network_config.mutual_authentication {
                return Err(Error::ConfigSanitizerFailed(
                    "ValidatorNetworkConfigSanitizer".to_string(),
                    "CRITICAL: Mutual authentication must be enabled for validators!".into(),
                ));
            }
        }
    }
    
    // Now check the skip flag for other validations
    if node_config.node_startup.skip_config_sanitizer {
        return Ok(());
    }
    // ... rest of sanitization
}
```

**3. Add a startup warning** when sanitizer is skipped on validator nodes.

## Proof of Concept

**Create malicious configuration file `malicious_validator.yaml`:**
```yaml
base:
  role: "validator"
  
node_startup:
  skip_config_sanitizer: true
  skip_config_optimizer: true

validator_network:
  network_id: "Public"
  mutual_authentication: false
  listen_address: "/ip4/0.0.0.0/tcp/6180"

storage:
  dir: "/tmp/aptos_test_validator"
  
full_node_networks: []
```

**Rust test to demonstrate the bypass:**
```rust
#[test]
fn test_config_bypass_vulnerability() {
    use aptos_config::config::{NodeConfig, NodeType, PersistableConfig};
    use std::fs;
    use tempfile::TempDir;

    let temp_dir = TempDir::new().unwrap();
    let config_path = temp_dir.path().join("malicious_validator.yaml");
    
    // Write malicious config
    let malicious_yaml = r#"
base:
  role: "validator"
node_startup:
  skip_config_sanitizer: true
validator_network:
  network_id: "Public"
  mutual_authentication: false
  listen_address: "/ip4/0.0.0.0/tcp/6180"
storage:
  dir: "/tmp/test"
full_node_networks: []
"#;
    fs::write(&config_path, malicious_yaml).unwrap();
    
    // Load config - this should fail but won't due to bypass
    let node_config = NodeConfig::load_config(&config_path).unwrap();
    
    // Verify the vulnerability: config loaded with insecure settings
    assert_eq!(node_config.node_startup.skip_config_sanitizer, true);
    assert_eq!(
        node_config.validator_network.as_ref().unwrap().network_id,
        aptos_config::network_id::NetworkId::Public
    );
    assert_eq!(
        node_config.validator_network.as_ref().unwrap().mutual_authentication,
        false
    );
    
    // The sanitizer would catch this, but it's bypassed:
    let result = aptos_config::config::config_sanitizer::ConfigSanitizer::sanitize(
        &node_config,
        NodeType::Validator,
        None,
    );
    
    // This passes because skip_config_sanitizer is true!
    assert!(result.is_ok()); // VULNERABILITY: Should fail but doesn't!
}
```

This demonstrates that a validator can be started with insecure network configuration by bypassing both the optimizer's defaults and the sanitizer's validation checks.

### Citations

**File:** config/src/config/config_optimizer.rs (L66-73)
```rust
/// Note: The config optimizer respects the following order precedence when
/// determining whether or not to optimize a value:
/// 1. If a config value has been set in the local config file, that value
///    should be used (and the optimizer should not override it).
/// 2. If a config value has not been set in the local config file, the
///    optimizer may set the value (but, it is not required to do so).
/// 3. Finally, if the config optimizer chooses not to set a value, the default
///    value is used (as defined in the default implementation).
```

**File:** config/src/config/config_optimizer.rs (L250-261)
```rust
        // We must override the network ID to be a validator
        // network ID (as the config defaults to a public network ID).
        if local_network_config_yaml["network_id"].is_null() {
            validator_network_config.network_id = NetworkId::Validator;
            modified_config = true;
        }

        // We must enable mutual authentication for the validator network
        if local_network_config_yaml["mutual_authentication"].is_null() {
            validator_network_config.mutual_authentication = true;
            modified_config = true;
        }
```

**File:** config/src/config/config_optimizer.rs (L596-618)
```rust
        let local_config_yaml = serde_yaml::from_str(
            r#"
            validator_network_config:
                network_id: "Public"
            "#,
        )
        .unwrap();

        // Optimize the validator network config and verify modifications are made
        let modified_config = optimize_validator_network_config(
            &mut node_config,
            &local_config_yaml,
            NodeType::Validator,
            Some(ChainId::mainnet()),
        )
        .unwrap();
        assert!(modified_config);

        // Verify that the network ID has not changed but that
        // mutual authentication has been enabled.
        let validator_network = node_config.validator_network.unwrap();
        assert_eq!(validator_network.network_id, NetworkId::Public);
        assert!(validator_network.mutual_authentication);
```

**File:** config/src/config/config_sanitizer.rs (L45-48)
```rust
        // If config sanitization is disabled, don't do anything!
        if node_config.node_startup.skip_config_sanitizer {
            return Ok(());
        }
```

**File:** config/src/config/config_sanitizer.rs (L174-197)
```rust
    if let Some(validator_network_config) = validator_network {
        let network_id = validator_network_config.network_id;
        if !network_id.is_validator_network() {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "The validator network config must have a validator network ID!".into(),
            ));
        }

        // Verify that the node is a validator
        if !node_type.is_validator() {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "The validator network config cannot be set for non-validators!".into(),
            ));
        }

        // Ensure that mutual authentication is enabled
        if !validator_network_config.mutual_authentication {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "Mutual authentication must be enabled for the validator network!".into(),
            ));
        }
```

**File:** config/src/config/node_startup_config.rs (L6-11)
```rust
#[derive(Clone, Copy, Debug, Deserialize, PartialEq, Eq, Serialize)]
#[serde(default, deny_unknown_fields)]
pub struct NodeStartupConfig {
    pub skip_config_optimizer: bool, // Whether or not to skip the config optimizer at startup
    pub skip_config_sanitizer: bool, // Whether or not to skip the config sanitizer at startup
}
```

**File:** config/src/config/node_config.rs (L75-75)
```rust
    pub node_startup: NodeStartupConfig,
```

**File:** config/src/config/node_config_loader.rs (L74-74)
```rust
        let mut node_config = NodeConfig::load_config(&self.node_config_path)?;
```

**File:** config/src/config/node_config_loader.rs (L141-141)
```rust
    NodeConfig::optimize(node_config, &local_config_yaml, node_type, chain_id)?;
```

**File:** config/src/config/node_config_loader.rs (L144-144)
```rust
    NodeConfig::sanitize(node_config, node_type, chain_id)
```

**File:** network/builder/src/builder.rs (L171-175)
```rust
        let authentication_mode = if config.mutual_authentication {
            AuthenticationMode::Mutual(identity_key)
        } else {
            AuthenticationMode::MaybeMutual(identity_key)
        };
```

**File:** network/framework/src/peer_manager/builder.rs (L253-262)
```rust
        let (key, auth_mode) = match transport_context.authentication_mode {
            AuthenticationMode::MaybeMutual(key) => (
                key,
                HandshakeAuthMode::maybe_mutual(transport_context.peers_and_metadata),
            ),
            AuthenticationMode::Mutual(key) => (
                key,
                HandshakeAuthMode::mutual(transport_context.peers_and_metadata),
            ),
        };
```

**File:** network/framework/src/noise/handshake.rs (L76-99)
```rust
/// Noise handshake authentication mode.
pub enum HandshakeAuthMode {
    /// In `Mutual` mode, both sides will authenticate each other with their
    /// `trusted_peers` set. We also include replay attack mitigation in this mode.
    ///
    /// For example, in the Aptos validator network, validator peers will only
    /// allow connections from other validator peers. They will use this mode to
    /// check that inbound connections authenticate to a network public key
    /// actually contained in the current validator set.
    Mutual {
        // Only use anti replay protection in mutual-auth scenarios. In theory,
        // this is applicable everywhere; however, we would need to spend some
        // time making this more sophisticated so it garbage collects old
        // timestamps and doesn't use unbounded space. These are not problems in
        // mutual-auth scenarios because we have a bounded set of trusted peers
        // that rarely changes.
        anti_replay_timestamps: RwLock<AntiReplayTimestamps>,
        peers_and_metadata: Arc<PeersAndMetadata>,
    },
    /// In `MaybeMutual` mode, the dialer authenticates the server and the server will allow all
    /// inbound connections from any peer but will mark connections as `Trusted` if the incoming
    /// connection is apart of its trusted peers set.
    MaybeMutual(Arc<PeersAndMetadata>),
}
```

**File:** network/framework/src/noise/handshake.rs (L384-426)
```rust
            HandshakeAuthMode::MaybeMutual(peers_and_metadata) => {
                let trusted_peers = peers_and_metadata.get_trusted_peers(&network_id)?;
                let trusted_peer = trusted_peers.get(&remote_peer_id).cloned();
                match trusted_peer {
                    Some(peer) => {
                        Self::authenticate_inbound(remote_peer_short, &peer, &remote_public_key)
                    },
                    None => {
                        // The peer is not in the trusted peer set. Verify that the Peer ID is
                        // constructed correctly from the public key.
                        let derived_remote_peer_id =
                            aptos_types::account_address::from_identity_public_key(
                                remote_public_key,
                            );
                        if derived_remote_peer_id != remote_peer_id {
                            // The peer ID is not constructed correctly from the public key
                            Err(NoiseHandshakeError::ClientPeerIdMismatch(
                                remote_peer_short,
                                remote_peer_id,
                                derived_remote_peer_id,
                            ))
                        } else {
                            // Try to infer the role from the network context
                            if self.network_context.role().is_validator() {
                                if network_id.is_vfn_network() {
                                    // Inbound connections to validators on the VFN network must be VFNs
                                    Ok(PeerRole::ValidatorFullNode)
                                } else {
                                    // Otherwise, they're unknown. Validators will connect through
                                    // authenticated channels (on the validator network) so shouldn't hit
                                    // this, and PFNs will connect on public networks (which aren't common).
                                    Ok(PeerRole::Unknown)
                                }
                            } else {
                                // We're a VFN or PFN. VFNs get no inbound connections on the vfn network
                                // (so the peer won't be a validator). Thus, we're on the public network
                                // so mark the peer as unknown.
                                Ok(PeerRole::Unknown)
                            }
                        }
                    },
                }
            },
```

**File:** config/src/network_id.rs (L72-76)
```rust
/// A representation of the network being used in communication.
/// There should only be one of each NetworkId used for a single node (except for NetworkId::Public),
/// and handshakes should verify that the NetworkId being used is the same during a handshake,
/// to effectively ensure communication is restricted to a network.  Network should be checked that
/// it is not the `DEFAULT_NETWORK`
```
