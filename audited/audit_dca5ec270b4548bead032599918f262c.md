# Audit Report

## Title
Critical State Manipulation via Unverified WriteSet Application in NoVerify Mode During Database Restore

## Summary
The database restore process uses `VerifyExecutionMode::NoVerify` mode which bypasses critical WriteSet hash verification, allowing arbitrary state changes to be applied directly to the database. An attacker controlling backup storage can inject malicious WriteSets that will be accepted without cryptographic verification against the `state_change_hash` in TransactionInfo, leading to consensus divergence and potential fund theft.

## Finding Description

The `VerifyExecutionMode` enum provides two operational modes for transaction replay during restore operations: [1](#0-0) 

The **NoVerify mode** is explicitly used in production restore paths: [2](#0-1) [3](#0-2) [4](#0-3) 

When transactions are enqueued for replay with NoVerify mode, the critical verification path is skipped: [5](#0-4) 

In the chunk executor, this leads to bypassing execution verification entirely: [6](#0-5) 

The skipped `verify_execution` function contains the critical security check that validates WriteSets match their expected hashes: [7](#0-6) 

This calls `ensure_match_transaction_info` which performs the essential WriteSet hash verification: [8](#0-7) 

The `TransactionInfo` contains the `state_change_hash` which is the hash of the WriteSet: [9](#0-8) 

**Attack Path:**

1. Attacker controls or compromises backup storage source (e.g., cloud storage bucket, backup server)
2. Attacker crafts malicious backup files containing:
   - Valid transactions (copied from legitimate blockchain)
   - Valid TransactionInfo (cryptographically verified via Merkle accumulator)
   - **Modified WriteSets** with arbitrary state changes (different from what execution would produce)
3. Validator operator uses `db-tool` or `RestoreCoordinator` to restore database from compromised source
4. The restore process uses NoVerify mode, skipping `verify_execution`
5. Malicious WriteSets are applied directly via `remove_and_apply`: [10](#0-9) 

6. Database ends up with incorrect state that doesn't match what legitimate transaction execution would produce

**Broken Invariants:**

1. **Deterministic Execution**: Different nodes restoring from different sources can have different state roots for identical transaction versions
2. **State Consistency**: State transitions are not verified via cryptographic proofs (WriteSet hashes)
3. **Consensus Safety**: Network can split if validators restore from different malicious backup sources

## Impact Explanation

This vulnerability meets **Critical Severity** criteria per Aptos Bug Bounty program:

**Consensus/Safety Violations:**
- If different validators restore from different malicious backup sources, they will have different state roots at the same version
- This violates the fundamental consensus invariant that all honest validators must agree on state
- Network cannot recover without hard fork and manual intervention

**Loss of Funds:**
- Attacker can modify WriteSets to change account balances, resource values, or ownership
- Can mint tokens by manipulating coin supply resources
- Can steal funds by changing account resource states

**Permanent State Corruption:**
- Once malicious WriteSets are committed, the database is permanently corrupted
- State root will never match what honest execution would produce
- Requires complete database rebuild from trusted source

**Network Partition:**
- If subset of validators restore from malicious source, network splits
- Different validators commit different blocks for the same height
- Non-recoverable without coordinated hard fork

The impact is **Critical** because:
1. Affects core consensus safety guarantees
2. Enables direct fund theft/minting
3. Can cause permanent network partition
4. Requires no privileged access—only control of backup source

## Likelihood Explanation

**High Likelihood** due to:

**Common Usage Patterns:**
- Validator operators regularly use restore tools for node bootstrap and recovery
- Database restores are standard operational procedures
- Backup sources are often external (cloud storage, third-party providers)

**Attack Feasibility:**
- Attacker only needs to compromise or control backup storage
- No validator-level access required
- No cryptographic key compromise needed
- WriteSets can be crafted to pass basic structural validation

**Attacker Requirements:**
- Control over backup storage source (cloud bucket, backup server)
- OR Man-in-the-middle position during backup download
- OR Compromise of backup provider credentials

**Real-World Scenarios:**
1. Compromised cloud storage credentials
2. Malicious backup service provider
3. Supply chain attack on backup tools
4. Insider threat at backup hosting provider

The likelihood is **High** because:
- Backup storage is frequently outsourced to third parties
- Many operators use public cloud storage
- No additional cryptographic verification layer exists
- Attack is silent—no immediate detection mechanism

## Recommendation

**Immediate Fix: Remove NoVerify Mode from Production Restore Paths**

The NoVerify mode should **never** be used in production restore operations. All transaction replay must verify WriteSets against their cryptographic hashes.

**Code Fix for `coordinators/restore.rs`:**

Replace lines 289-299:
```rust
// BEFORE (VULNERABLE):
TransactionRestoreBatchController::new(
    transaction_restore_opt,
    Arc::clone(&self.storage),
    txn_manifests,
    Some(db_next_version),
    Some((kv_replay_version, true /* only replay KV */)),
    epoch_history.clone(),
    VerifyExecutionMode::NoVerify,  // VULNERABLE
    None,
)

// AFTER (SECURE):
TransactionRestoreBatchController::new(
    transaction_restore_opt,
    Arc::clone(&self.storage),
    txn_manifests,
    Some(db_next_version),
    Some((kv_replay_version, true /* only replay KV */)),
    epoch_history.clone(),
    VerifyExecutionMode::verify_all(),  // Always verify
    None,
)
```

Replace lines 360-371 with same fix.

**Code Fix for `db-tool/src/restore.rs`:**

Replace line 107:
```rust
// BEFORE (VULNERABLE):
VerifyExecutionMode::NoVerify,

// AFTER (SECURE):
VerifyExecutionMode::verify_all(),
```

**Additional Recommendations:**

1. **Add Backup Authentication**: Implement cryptographic signatures on backup files to verify source authenticity

2. **Mandatory Verification**: Make WriteSet verification mandatory and non-bypassable

3. **Audit Logging**: Log all restore operations with backup source and verification mode

4. **Deprecate NoVerify**: Mark `VerifyExecutionMode::NoVerify` as deprecated and restrict to test-only usage

5. **Performance Optimization**: If NoVerify was used for performance, optimize the verification path instead of bypassing it

## Proof of Concept

**Scenario: Malicious Backup Injection**

```rust
// This PoC demonstrates how an attacker can inject malicious WriteSets
// that bypass verification in NoVerify mode

use aptos_types::{
    transaction::{Transaction, TransactionInfo, WriteSet},
    contract_event::ContractEvent,
};
use aptos_executor::chunk_executor::ChunkExecutor;
use aptos_executor_types::{TransactionReplayer, VerifyExecutionMode};

fn exploit_no_verify_mode() {
    // Step 1: Attacker obtains legitimate transaction and TransactionInfo
    // from blockchain (these are cryptographically verified)
    let legitimate_txn = get_transaction_from_blockchain(version);
    let legitimate_txn_info = get_txn_info_from_blockchain(version);
    
    // Step 2: Attacker crafts malicious WriteSet
    // Example: Change account balance from 100 to 1,000,000
    let malicious_write_set = craft_malicious_write_set(
        account_address,
        balance: 1_000_000,  // instead of legitimate 100
    );
    
    // Step 3: Attacker creates backup file with:
    // - Legitimate transaction (hash will match)
    // - Legitimate TransactionInfo (cryptographically verified)  
    // - Malicious WriteSet (NOT verified against state_change_hash)
    let malicious_backup = create_backup_chunk(
        vec![legitimate_txn],
        vec![legitimate_txn_info],
        vec![malicious_write_set],  // MALICIOUS
        vec![vec![]],  // empty events
    );
    
    // Step 4: Victim node restores from malicious backup
    let chunk_executor = ChunkExecutor::new(db);
    
    // With NoVerify mode - VULNERABLE
    chunk_executor.enqueue_chunks(
        transactions,
        persisted_aux_info,
        transaction_infos,
        write_sets,  // Contains MALICIOUS WriteSets
        event_vecs,
        &VerifyExecutionMode::NoVerify,  // Bypasses verification!
    );
    
    // Step 5: Malicious WriteSets are applied without verification
    // The ensure_match_transaction_info check is NEVER called
    // Database now contains incorrect state
    
    // Result: Account balance is 1,000,000 instead of legitimate 100
    // State root differs from what honest execution would produce
}

// Test to verify the vulnerability:
#[test]
fn test_no_verify_bypasses_write_set_validation() {
    // Create test database
    let db = create_test_db();
    
    // Create legitimate transaction that sets balance to 100
    let (txn, txn_info, legitimate_ws) = create_txn_with_balance(100);
    
    // Create malicious WriteSet that sets balance to 1000
    let malicious_ws = create_write_set_with_balance(1000);
    
    // Verify state_change_hash mismatch
    assert_ne!(
        hash(&malicious_ws),
        txn_info.state_change_hash(),
        "Malicious WriteSet has different hash"
    );
    
    // Enqueue with NoVerify mode
    let executor = ChunkExecutor::new(db.clone());
    executor.enqueue_chunks(
        vec![txn],
        vec![PersistedAuxiliaryInfo::None],
        vec![txn_info],
        vec![malicious_ws],  // MALICIOUS
        vec![vec![]],
        &VerifyExecutionMode::NoVerify,
    ).expect("Should succeed with NoVerify");
    
    executor.update_ledger().unwrap();
    executor.commit().unwrap();
    
    // Verify malicious WriteSet was applied
    let account_balance = read_account_balance(&db, account_address);
    assert_eq!(account_balance, 1000, "Malicious balance applied!");
    
    // This should have failed but didn't because NoVerify bypassed verification
}
```

**Attack Demonstration:**

1. Set up malicious backup server with crafted files
2. Operator runs: `aptos-db-tool restore oneoff transaction --storage-url https://malicious-backup.com`
3. NoVerify mode is used (line 107 of db-tool/src/restore.rs)
4. Malicious WriteSets applied without verification
5. Node database is corrupted with attacker-controlled state
6. If multiple nodes restore from malicious source: consensus split
7. If single node restored: state divergence from honest network

This vulnerability has **Critical** severity and should be patched immediately by removing NoVerify mode from all production restore paths.

### Citations

**File:** execution/executor-types/src/lib.rs (L180-188)
```rust
#[derive(Clone)]
pub enum VerifyExecutionMode {
    NoVerify,
    Verify {
        txns_to_skip: Arc<BTreeSet<Version>>,
        lazy_quit: bool,
        seen_error: Arc<AtomicBool>,
    },
}
```

**File:** storage/backup/backup-cli/src/coordinators/restore.rs (L289-299)
```rust
            TransactionRestoreBatchController::new(
                transaction_restore_opt,
                Arc::clone(&self.storage),
                txn_manifests,
                Some(db_next_version),
                Some((kv_replay_version, true /* only replay KV */)),
                epoch_history.clone(),
                VerifyExecutionMode::NoVerify,
                None,
            )
            .run()
```

**File:** storage/backup/backup-cli/src/coordinators/restore.rs (L360-371)
```rust
            TransactionRestoreBatchController::new(
                self.global_opt,
                self.storage,
                txn_manifests,
                first_version,
                replay_version,
                epoch_history,
                VerifyExecutionMode::NoVerify,
                None,
            )
            .run()
            .await?;
```

**File:** storage/db-tool/src/restore.rs (L97-111)
```rust
                    Oneoff::Transaction {
                        storage,
                        opt,
                        global,
                    } => {
                        TransactionRestoreController::new(
                            opt,
                            global.try_into()?,
                            storage.init_storage().await?,
                            None, /* epoch_history */
                            VerifyExecutionMode::NoVerify,
                        )
                        .run()
                        .await?;
                    },
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L670-683)
```rust
                let verify_execution_mode = self.verify_execution_mode.clone();

                async move {
                    let _timer = OTHER_TIMERS_SECONDS.timer_with(&["enqueue_chunks"]);

                    tokio::task::spawn_blocking(move || {
                        chunk_replayer.enqueue_chunks(
                            txns,
                            persisted_aux_info,
                            txn_infos,
                            write_sets,
                            events,
                            &verify_execution_mode,
                        )
```

**File:** execution/executor/src/chunk_executor/mod.rs (L561-575)
```rust
            // Try to run the transactions with the VM
            let next_begin = if verify_execution_mode.should_verify() {
                self.verify_execution(
                    transactions,
                    persisted_aux_info,
                    transaction_infos,
                    write_sets,
                    event_vecs,
                    batch_begin,
                    batch_end,
                    verify_execution_mode,
                )?
            } else {
                batch_end
            };
```

**File:** execution/executor/src/chunk_executor/mod.rs (L629-651)
```rust
        for (version, txn_out, txn_info, write_set, events) in multizip((
            begin_version..end_version,
            &execution_output.to_commit.transaction_outputs,
            transaction_infos.iter(),
            write_sets.iter(),
            event_vecs.iter(),
        )) {
            if let Err(err) = txn_out.ensure_match_transaction_info(
                version,
                txn_info,
                Some(write_set),
                Some(events),
            ) {
                return if verify_execution_mode.is_lazy_quit() {
                    error!("(Not quitting right away.) {}", err);
                    verify_execution_mode.mark_seen_error();
                    Ok(version + 1)
                } else {
                    Err(err)
                };
            }
        }
        Ok(end_version)
```

**File:** execution/executor/src/chunk_executor/mod.rs (L668-688)
```rust
        let (transactions, persisted_aux_info, transaction_outputs) = multizip((
            transactions.drain(..num_txns),
            persisted_aux_info.drain(..num_txns),
            txn_infos.iter(),
            write_sets.drain(..num_txns),
            event_vecs.drain(..num_txns),
        ))
        .map(|(txn, persisted_aux_info, txn_info, write_set, events)| {
            (
                txn,
                persisted_aux_info,
                TransactionOutput::new(
                    write_set,
                    events,
                    txn_info.gas_used(),
                    TransactionStatus::Keep(txn_info.status().clone()),
                    TransactionAuxiliaryData::default(), // No auxiliary data if transaction is not executed through VM
                ),
            )
        })
        .multiunzip();
```

**File:** types/src/transaction/mod.rs (L1898-1908)
```rust
        let write_set_hash = CryptoHash::hash(self.write_set());
        ensure!(
            write_set_hash == txn_info.state_change_hash(),
            "{}: version:{}, write_set_hash:{:?}, expected:{:?}, write_set: {:?}, expected(if known): {:?}",
            ERR_MSG,
            version,
            write_set_hash,
            txn_info.state_change_hash(),
            self.write_set,
            expected_write_set,
        );
```

**File:** types/src/transaction/mod.rs (L2040-2042)
```rust
    /// The hash value summarizing all changes caused to the world state by this transaction.
    /// i.e. hash of the output write set.
    state_change_hash: HashValue,
```
