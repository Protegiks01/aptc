# Audit Report

## Title
Integer Overflow in Move Bytecode Verifier Causes Incorrect Reference Safety Verification

## Summary
The Move bytecode verifier contains an unchecked cast from `usize` to `u16` when building the function name-to-definition mapping, causing functions at indices ≥65,536 to map to incorrect `FunctionDefinitionIndex` values. This leads to verification using wrong function metadata for reference safety checks.

## Finding Description

The `verify_module_impl()` function in the Move bytecode verifier performs an unchecked integer cast when constructing the `name_def_map`: [1](#0-0) 

When a module contains more than 65,536 functions, the cast `idx as u16` wraps around. For example, function at index 65,536 becomes `FunctionDefinitionIndex(0)`, function 65,537 becomes `FunctionDefinitionIndex(1)`, etc.

The Aptos production verifier configuration explicitly allows unlimited functions: [2](#0-1) 

This corrupted `name_def_map` is used during reference safety verification to look up which global resources each function acquires: [3](#0-2) 

When reference safety verification looks up a function at index ≥65,536 by name, it retrieves the wrong `FunctionDefinitionIndex` due to wraparound, using incorrect `acquires_global_resources` metadata. This breaks Move's core safety guarantee that functions correctly declare resource acquisitions.

The BoundsChecker, which runs before the verifier, contains the same vulnerability and cannot catch this issue: [4](#0-3) 

The deserializer has no built-in limit and will load all function definitions: [6](#0-5) 

## Impact Explanation

This vulnerability enables **Verification Bypass** that qualifies as **High Severity** under the Aptos bug bounty program:

1. **Move VM Safety Breach**: Functions at indices ≥65,536 can have reference safety violations that pass verification because checks are performed against the wrong function's `acquires_global_resources` declaration. This breaks Move's core safety guarantee and could potentially enable double-borrows, use-after-free on global resources, or unauthorized resource access.

2. **Reference Safety Compromise**: A malicious module could include functions that access global resources without proper declarations, exploiting the index wraparound to point verification at benign functions' declarations instead.

**Note**: The report's claim of "consensus splits" is **not demonstrated**. The integer overflow is deterministic—all validators running the same code would experience identical wraparound behavior. No evidence is provided showing how this would cause non-deterministic validator decisions or different state roots.

## Likelihood Explanation

**Likelihood: Medium**

The vulnerability is theoretically exploitable through governance proposal, but has practical constraints:

1. **Size Constraints**: Creating 65,537+ functions requires approximately 1-1.5MB when including function definitions, handles, identifiers, and signatures. This is at or exceeds the typical 1MB governance transaction limit, making practical exploitation borderline feasible.

2. **Attack Path**: Requires submitting a governance proposal with the malicious module. No special privileges needed beyond proposal submission capability.

3. **Deterministic Behavior**: The wraparound is predictable and repeatable, making the attack path straightforward once size constraints are overcome.

## Recommendation

Add bounds checking before the cast to prevent wraparound:

```rust
for (idx, func_def) in module.function_defs().iter().enumerate() {
    let fh = module.function_handle_at(func_def.function);
    if idx > u16::MAX as usize {
        return Err(PartialVMError::new(StatusCode::TOO_MANY_FUNCTION_DEFINITIONS));
    }
    name_def_map.insert(fh.name, FunctionDefinitionIndex(idx as u16));
}
```

Alternatively, enforce the `max_function_definitions` limit in production configuration to a safe value below 65,536.

## Proof of Concept

A PoC would require constructing a Move module with 65,537+ minimal functions. Due to size constraints and the complexity of generating such a module within transaction limits, a complete working PoC is not provided. However, the vulnerability is confirmed by code inspection showing the unchecked cast exists in production configuration that allows unlimited functions.

### Citations

**File:** third_party/move/move-bytecode-verifier/src/code_unit_verifier.rs (L52-54)
```rust
        for (idx, func_def) in module.function_defs().iter().enumerate() {
            let fh = module.function_handle_at(func_def.function);
            name_def_map.insert(fh.name, FunctionDefinitionIndex(idx as u16));
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L171-171)
```rust
        max_function_definitions: None,
```

**File:** third_party/move/move-bytecode-verifier/src/reference_safety/mod.rs (L84-95)
```rust
    let acquired_resources = match verifier.name_def_map.get(&function_handle.name) {
        Some(idx) => {
            let func_def = verifier.resolver.function_def_at(*idx)?;
            let fh = verifier.resolver.function_handle_at(func_def.function);
            if function_handle == fh {
                func_def.acquires_global_resources.iter().cloned().collect()
            } else {
                BTreeSet::new()
            }
        },
        None => BTreeSet::new(),
    };
```

**File:** third_party/move/move-binary-format/src/check_bounds.rs (L429-431)
```rust
        self.context = BoundsCheckingContext::ModuleFunction(FunctionDefinitionIndex(
            function_def_idx as TableIndex,
        ));
```

**File:** third_party/move/move-binary-format/src/deserializer.rs (L575-588)
```rust
    fn load<T>(
        &self,
        binary: &VersionedBinary,
        result: &mut Vec<T>,
        deserializer: impl Fn(&mut VersionedCursor) -> BinaryLoaderResult<T>,
    ) -> BinaryLoaderResult<()> {
        let start = self.offset as usize;
        let end = start + self.count as usize;
        let mut cursor = binary.new_cursor(start, end);
        while cursor.position() < self.count as u64 {
            result.push(deserializer(&mut cursor)?)
        }
        Ok(())
    }
```
