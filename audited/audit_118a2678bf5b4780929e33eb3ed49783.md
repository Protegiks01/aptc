# Audit Report

## Title
Gas Schedule Feature Version Lacks Upper Bound Validation Enabling Network Halt via Governance

## Summary
The Move contract `gas_schedule.move` validates only the lower bound of `feature_version` (ensuring new >= current) but lacks upper bound validation. A malicious governance proposal can deploy a gas schedule with an arbitrarily large feature_version (e.g., `u64::MAX`), causing all validator nodes to fail during VM initialization with `VM_STARTUP_FAILURE`, resulting in total network liveness loss.

## Finding Description
While the security question points to lines 61-65 in the Rust file `gas.rs` (which only display `feature_version` for documentation), the actual vulnerability lies in the Move smart contract validation logic. [1](#0-0) 

This validation only ensures the new feature_version is not lower than the current version, but imposes no upper bound. In contrast, the codebase defines a maximum expected version: [2](#0-1) 

**Attack Path:**

1. Attacker submits governance proposal with malicious `GasScheduleV2`:
   - `feature_version: 999999` (or any value >> 45)
   - `entries: vec![]` (empty or incomplete parameter map)

2. Move validation passes because `999999 >= 45`: [1](#0-0) 

3. At epoch transition, `on_new_epoch` applies the new gas schedule: [3](#0-2) 

4. All validator nodes initialize `AptosEnvironment` which calls `from_on_chain_gas_schedule(&map, 999999)`: [4](#0-3) 

5. Parameter extraction fails because expected keys don't exist for version 999999: [5](#0-4) 

6. Error propagates through VM initialization, stored as `Err(String)`: [6](#0-5) 

7. Every transaction execution attempts to retrieve gas parameters: [7](#0-6) 

8. This converts the error to `VM_STARTUP_FAILURE`: [8](#0-7) 

9. **All transactions are rejected** - complete network halt.

## Impact Explanation
This is **Critical Severity** under Aptos Bug Bounty criteria:
- **Total loss of liveness/network availability**: No transactions can be processed
- **Non-recoverable network partition (requires hardfork)**: The malicious gas schedule is stored on-chain; nodes cannot self-recover
- Manual intervention (hardfork) required to restore state and deploy valid gas schedule

All validator nodes simultaneously enter an unusable state where they reject every transaction with `VM_STARTUP_FAILURE`. The network is completely frozen until operators coordinate a hardfork to override the malicious gas schedule.

## Likelihood Explanation
**Likelihood: Medium to High**

Requirements:
- Governance proposal submission (permissionless in Aptos)
- Sufficient voting power to pass proposal OR social engineering to convince legitimate voters
- Knowledge of the missing upper bound validation

The attack is straightforward once the vulnerability is known. While governance approval is required, malicious actors with stake or through proposal manipulation could feasibly execute this. The impact severity (network halt) makes this a high-priority vulnerability despite governance friction.

## Recommendation
Add upper bound validation to the Move contract:

```move
public fun set_for_next_epoch(aptos_framework: &signer, gas_schedule_blob: vector<u8>) acquires GasScheduleV2 {
    system_addresses::assert_aptos_framework(aptos_framework);
    assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));
    let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
    if (exists<GasScheduleV2>(@aptos_framework)) {
        let cur_gas_schedule = borrow_global<GasScheduleV2>(@aptos_framework);
        assert!(
            new_gas_schedule.feature_version >= cur_gas_schedule.feature_version,
            error::invalid_argument(EINVALID_GAS_FEATURE_VERSION)
        );
        // ADD THIS CHECK:
        assert!(
            new_gas_schedule.feature_version <= MAXIMUM_ALLOWED_GAS_FEATURE_VERSION,
            error::invalid_argument(EINVALID_GAS_FEATURE_VERSION)
        );
    };
    config_buffer::upsert(new_gas_schedule);
}
```

Where `MAXIMUM_ALLOWED_GAS_FEATURE_VERSION` is a constant (e.g., `100`) providing headroom beyond current `LATEST_GAS_FEATURE_VERSION` (45) while preventing abuse.

Apply the same fix to `set_for_next_epoch_check_hash` and `set_gas_schedule` functions.

## Proof of Concept

```move
#[test_only]
module aptos_framework::test_gas_schedule_exploit {
    use aptos_framework::gas_schedule;
    use std::bcs;
    use std::vector;
    
    #[test(aptos_framework = @0x1)]
    #[expected_failure(abort_code = 0x50001, location = aptos_framework::gas_schedule)] // VM_STARTUP_FAILURE
    fun test_arbitrary_feature_version_halts_network(aptos_framework: signer) {
        // Setup: Initialize with valid gas schedule version 45
        let valid_schedule = gas_schedule::GasScheduleV2 {
            feature_version: 45,
            entries: vector[
                (b"txn.min_transaction_gas_units".to_string(), 2760000),
                // ... other required parameters
            ],
        };
        move_to(&aptos_framework, valid_schedule);
        
        // Attack: Deploy malicious gas schedule with version 999999
        let malicious_schedule = gas_schedule::GasScheduleV2 {
            feature_version: 999999,
            entries: vector::empty(), // Empty - missing all expected parameters
        };
        let malicious_blob = bcs::to_bytes(&malicious_schedule);
        
        // This SHOULD fail but currently PASSES due to missing upper bound check
        gas_schedule::set_for_next_epoch(&aptos_framework, malicious_blob);
        
        // At epoch transition, VMs would fail to initialize
        // All transactions would be rejected with VM_STARTUP_FAILURE
    }
}
```

**Notes:**
The vulnerability exists in the Move contract validation logic, not in the Rust display code mentioned in the question (lines 61-65 of `gas.rs`). The Rust function `emit_full_gas_schedule()` is purely cosmetic and has no security implications. The critical flaw is the absence of upper bound validation in the on-chain Move contract that actually enforces gas schedule updates.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L97-100)
```text
            assert!(
                new_gas_schedule.feature_version >= cur_gas_schedule.feature_version,
                error::invalid_argument(EINVALID_GAS_FEATURE_VERSION)
            );
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L135-145)
```text
    public(friend) fun on_new_epoch(framework: &signer) acquires GasScheduleV2 {
        system_addresses::assert_aptos_framework(framework);
        if (config_buffer::does_exist<GasScheduleV2>()) {
            let new_gas_schedule = config_buffer::extract_v2<GasScheduleV2>();
            if (exists<GasScheduleV2>(@aptos_framework)) {
                *borrow_global_mut<GasScheduleV2>(@aptos_framework) = new_gas_schedule;
            } else {
                move_to(framework, new_gas_schedule);
            }
        }
    }
```

**File:** aptos-move/aptos-gas-schedule/src/ver.rs (L76-76)
```rust
pub const LATEST_GAS_FEATURE_VERSION: u64 = gas_feature_versions::RELEASE_V1_41;
```

**File:** aptos-move/aptos-vm-environment/src/gas.rs (L33-33)
```rust
                AptosGasParameters::from_on_chain_gas_schedule(&map, feature_version),
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/macros.rs (L38-41)
```rust
                    if let Some(key) = $crate::gas_schedule::macros::define_gas_parameters_extract_key_at_version!($key_bindings, feature_version) {
                        let name = format!("{}.{}", $prefix, key);
                        params.$name = gas_schedule.get(&name).cloned().ok_or_else(|| format!("Gas parameter {} does not exist. Feature version: {}.", name, feature_version))?.into();
                    }
```

**File:** aptos-move/aptos-vm-environment/src/environment.rs (L185-188)
```rust
    gas_params: Result<AptosGasParameters, String>,
    /// Storage gas parameters used in this environment. Error is stored if gas parameters were not
    /// found on-chain.
    storage_gas_params: Result<StorageGasParameters, String>,
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L273-281)
```rust
pub(crate) fn get_or_vm_startup_failure<'a, T>(
    gas_params: &'a Result<T, String>,
    log_context: &AdapterLogSchema,
) -> Result<&'a T, VMStatus> {
    gas_params.as_ref().map_err(|err| {
        let msg = format!("VM Startup Failed. {}", err);
        speculative_error!(log_context, msg.clone());
        VMStatus::error(StatusCode::VM_STARTUP_FAILURE, Some(msg))
    })
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L373-378)
```rust
    pub(crate) fn gas_params(
        &self,
        log_context: &AdapterLogSchema,
    ) -> Result<&AptosGasParameters, VMStatus> {
        get_or_vm_startup_failure(self.move_vm.env.gas_params(), log_context)
    }
```
