# Audit Report

## Title
Indexer Service Crash on Move Framework Event Schema Evolution Due to Missing Version Compatibility Handling

## Summary
The Aptos indexer lacks version compatibility checking when deserializing on-chain Move events. When the Aptos Framework is upgraded via governance to modify event structures (remove fields, rename fields, or change field types), older indexer instances will encounter deserialization failures that trigger process panics, causing complete service disruption and data indexing gaps.

## Finding Description

The indexer's stake event processing chain has a critical fragility when handling event schema evolution: [1](#0-0) 

The `from_event` function uses `serde_json::from_value()` to deserialize event data into hardcoded Rust structs. While this handles **added** fields gracefully (serde ignores unknown fields by default), it **fails catastrophically** when fields are removed, renamed, or have type changes.

The error propagates through the call chain without any recovery mechanism: [2](#0-1) [3](#0-2) 

Most critically, the stake processor uses `.unwrap()` on these fallible operations, converting any error into a **process panic**: [4](#0-3) 

**Attack Scenario (Unintentional but Inevitable):**

1. Governance proposal passes to upgrade the Aptos Framework (e.g., optimizing gas usage by restructuring staking events)
2. The upgrade modifies `VoteEvent` structure in the Move contract: [5](#0-4) 

3. After deployment, validators emit events with the new schema
4. Older indexer instances (not yet upgraded) attempt to deserialize these events
5. Serde fails to find expected fields → `from_event` returns `Err`
6. `.unwrap()` triggers panic → **entire indexer process crashes**
7. All dependent services (APIs, frontends, analytics dashboards, monitoring systems) lose access to recent blockchain data
8. Manual intervention required to upgrade indexer code and restart services

**Real-World Example:**
The current Move contracts already have a schema mismatch that is silently handled (extra `add_stake_fee` field), but the reverse scenario (missing expected fields) would cause immediate failure: [6](#0-5) 

The Rust struct is missing the `add_stake_fee` field but works because extra fields are ignored: [7](#0-6) 

## Impact Explanation

**Severity: HIGH** per Aptos Bug Bounty criteria:
- **API crashes**: Indexer service becomes unavailable, causing all API endpoints serving indexed data to fail
- **Significant protocol violation**: No version compatibility mechanism exists between indexer and on-chain schemas

**Affected Systems:**
- All indexer instances processing stake-related events (proposal votes, delegator activities, rewards)
- REST API endpoints querying indexed data
- Frontend dApps displaying governance votes and staking information  
- Analytics dashboards and monitoring systems
- Historical data queries become stale

**Impact Duration:**
- Immediate: Service disruption from moment of schema-incompatible event
- Persistent: Data gap in indexed records until manual intervention
- Recovery: Requires code deployment, testing, and service restart (hours to days)

## Likelihood Explanation

**Likelihood: HIGH**

This vulnerability WILL be triggered, not by malicious actors, but by the natural evolution of the Aptos protocol:

1. **Framework upgrades are frequent**: The Aptos Framework has been upgraded multiple times since mainnet launch for bug fixes, optimizations, and feature additions

2. **Event schema changes are common**: As staking, governance, and delegation pool logic evolves, event structures may be modified to:
   - Add performance metrics
   - Remove deprecated fields  
   - Optimize gas usage by restructuring data
   - Refactor for code clarity

3. **No coordination mechanism**: There is no version negotiation between on-chain contracts and off-chain indexers. The indexer blindly assumes event schemas never change.

4. **Zero-day window**: Between framework deployment and indexer code update, ALL indexer instances are vulnerable

5. **Cascading failures**: A single incompatible event in any transaction blocks processing of the entire transaction batch, amplifying the impact

## Recommendation

Implement graceful degradation with version compatibility checking:

**Approach 1: Add `#[serde(default)]` and optional fields**
Make all event struct fields optional with defaults to handle missing fields gracefully. When deserialization fails, log the error and skip the event rather than crashing.

**Approach 2: Event schema versioning**
Add version metadata to events and maintain multiple struct versions in the indexer, selecting the appropriate deserializer based on transaction version or event metadata.

**Approach 3: Error recovery with alerting**
Replace `.unwrap()` with proper error handling that logs detailed information, increments error metrics, and continues processing:

```rust
// In stake_processor.rs process_transactions()
let proposal_votes = match ProposalVote::from_transaction(txn) {
    Ok(votes) => votes,
    Err(e) => {
        error!(
            "Failed to parse proposal votes for txn version {}: {}. Skipping.",
            txn_version, e
        );
        INDEXER_ERRORS.with_label_values(&["proposal_vote_parse_error"]).inc();
        vec![] // Skip this transaction's events
    }
};
```

**Approach 4: Schema validation service**
Implement a schema registry that validates event structure compatibility before deployment, with automated alerts when breaking changes are detected.

**Recommended Combined Solution:**
- Make event struct fields use `Option<T>` with `#[serde(default)]`
- Add comprehensive error logging with transaction version context
- Remove all `.unwrap()` calls and use proper error propagation  
- Implement monitoring alerts for deserialization failures
- Add integration tests that verify backward/forward compatibility

## Proof of Concept

**Simulation Steps:**

1. Create a test Move module that emits a modified VoteEvent without the `should_pass` field
2. Deploy this module on a test network
3. Trigger an event emission  
4. Observe the indexer panic when attempting to deserialize:

```rust
// Proof of Concept - Rust test demonstrating the panic
#[test]
#[should_panic(expected = "called `Result::unwrap()` on an `Err` value")]
fn test_missing_field_causes_panic() {
    use serde_json::json;
    
    // Simulate event JSON with missing 'should_pass' field
    let incomplete_event = json!({
        "proposal_id": "1",
        "voter": "0x1",
        "stake_pool": "0x2",
        "num_votes": "1000"
        // Missing: "should_pass": true
    });
    
    // This will return Err because required field is missing
    let result = StakeEvent::from_event(
        "0x1::aptos_governance::VoteEvent",
        &incomplete_event,
        12345
    );
    
    // In production code, this .unwrap() causes the panic
    result.unwrap();
}
```

**Expected Result**: Test panics, demonstrating that the indexer would crash in production.

**Mitigation Verification**: After implementing proper error handling, the test should log an error but continue execution without panicking.

## Notes

This vulnerability represents a **critical reliability gap** in the indexer's design. While not exploitable by malicious actors in the traditional sense, it creates a guaranteed service disruption trigger that will be activated by normal protocol evolution. The lack of version compatibility handling violates fundamental software engineering principles for long-lived systems that undergo schema evolution.

The current codebase already shows evidence of schema drift (the `add_stake_fee` field mismatch), which happens to work due to serde's default behavior of ignoring extra fields. However, the reverse scenario—which WILL occur during future framework upgrades—has catastrophic consequences.

### Citations

**File:** crates/indexer/src/models/stake_models/stake_utils.rs (L59-64)
```rust
pub struct AddStakeEvent {
    #[serde(deserialize_with = "deserialize_from_string")]
    pub amount_added: u64,
    pub delegator_address: String,
    pub pool_address: String,
}
```

**File:** crates/indexer/src/models/stake_models/stake_utils.rs (L184-208)
```rust
    pub fn from_event(
        data_type: &str,
        data: &serde_json::Value,
        txn_version: i64,
    ) -> Result<Option<Self>> {
        match data_type {
            "0x1::aptos_governance::VoteEvent" => serde_json::from_value(data.clone())
                .map(|inner| Some(StakeEvent::GovernanceVoteEvent(inner))),
            "0x1::stake::DistributeRewardsEvent" => serde_json::from_value(data.clone())
                .map(|inner| Some(StakeEvent::DistributeRewardsEvent(inner))),
            "0x1::delegation_pool::AddStakeEvent" => serde_json::from_value(data.clone())
                .map(|inner| Some(StakeEvent::AddStakeEvent(inner))),
            "0x1::delegation_pool::UnlockStakeEvent" => serde_json::from_value(data.clone())
                .map(|inner| Some(StakeEvent::UnlockStakeEvent(inner))),
            "0x1::delegation_pool::WithdrawStakeEvent" => serde_json::from_value(data.clone())
                .map(|inner| Some(StakeEvent::WithdrawStakeEvent(inner))),
            "0x1::delegation_pool::ReactivateStakeEvent" => serde_json::from_value(data.clone())
                .map(|inner| Some(StakeEvent::ReactivateStakeEvent(inner))),
            _ => Ok(None),
        }
        .context(format!(
            "version {} failed! failed to parse type {}, data {:?}",
            txn_version, data_type, data
        ))
    }
```

**File:** crates/indexer/src/models/stake_models/delegator_activities.rs (L43-44)
```rust
            if let Some(staking_event) =
                StakeEvent::from_event(event_type.as_str(), &event.data, txn_version)?
```

**File:** crates/indexer/src/models/stake_models/proposal_votes.rs (L37-38)
```rust
                if let Some(StakeEvent::GovernanceVoteEvent(ev)) =
                    StakeEvent::from_event(event_type.as_str(), &event.data, txn_version)?
```

**File:** crates/indexer/src/processors/stake_processor.rs (L337-343)
```rust
            let current_stake_pool_voter = CurrentStakingPoolVoter::from_transaction(txn).unwrap();
            all_current_stake_pool_voters.extend(current_stake_pool_voter);
            let mut proposal_votes = ProposalVote::from_transaction(txn).unwrap();
            all_proposal_votes.append(&mut proposal_votes);

            // Add delegator activities
            let mut delegator_activities = DelegatedStakingActivity::from_transaction(txn).unwrap();
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L131-137)
```text
    struct VoteEvent has drop, store {
        proposal_id: u64,
        voter: address,
        stake_pool: address,
        num_votes: u64,
        should_pass: bool,
    }
```

**File:** aptos-move/framework/aptos-framework/sources/delegation_pool.move (L369-374)
```text
    struct AddStakeEvent has drop, store {
        pool_address: address,
        delegator_address: address,
        amount_added: u64,
        add_stake_fee: u64,
    }
```
