# Audit Report

## Title
Storage Usage Data Corruption via Untracked State Instances Bypassing Validation

## Summary
The codebase fails to validate `is_untracked()` before storing state storage usage data to the database. When `StateStorageUsage::Untracked` instances are converted to `VersionData` and persisted, they are silently stored as 0 items/0 bytes, permanently corrupting storage accounting. This leads to incorrect gas pricing during epoch reconfiguration and potential storage quota bypass.

## Finding Description

The vulnerability exists in a validation gap where `Untracked` state storage instances can be persisted to the database without proper checking, violating the **State Consistency** and **Deterministic Execution** invariants.

**Vulnerability Flow:**

1. When `enable_storage_sharding=true` (the default configuration), the system sets `skip_usage=true` [1](#0-0) 

2. During state retrieval, if usage metadata is missing from the database and `skip_usage=true`, the system returns `StateStorageUsage::Untracked` instead of failing [2](#0-1) 

3. **Critical Bug**: When committing state, the `put_usage` function does NOT check `is_untracked()` before storing usage data [3](#0-2) 

4. During conversion from `StateStorageUsage` to `VersionData`, the `Untracked` variant returns 0 for both `items()` and `bytes()` methods [4](#0-3) 

5. This causes `VersionData` with (0, 0) to be persisted [5](#0-4) 

6. Upon retrieval, this becomes a `Tracked` instance with 0 items/0 bytes [6](#0-5) 

7. During epoch reconfiguration, these corrupted 0/0 values are used for storage gas calculations [7](#0-6) 

**Evidence of Missing Validation:**

Other parts of the codebase explicitly check `is_untracked()` before critical operations:
- State snapshot validation skips checks if untracked [8](#0-7) 
- State merkle batch committer skips consistency checks if untracked [9](#0-8) 
- The codebase itself acknowledges this as a "hack" [10](#0-9) 

However, the critical `put_usage` function lacks this validation entirely.

## Impact Explanation

**Severity: High** (meets "Significant protocol violations" and "State inconsistencies requiring intervention" criteria)

The impact includes:

1. **Storage Gas Miscalculation**: With 0/0 usage, storage gas curves evaluate at minimum values, making storage effectively free
2. **Storage Quota Bypass**: Storage accounting becomes permanently corrupted, allowing unbounded state growth
3. **Consensus Inconsistency Risk**: Different nodes could have different usage values if some experienced the corruption path and others didn't
4. **State Consistency Violation**: The blockchain state becomes internally inconsistent with incorrect usage metadata

This breaks the **Resource Limits** invariant (#9) which states "All operations must respect gas, storage, and computational limits."

## Likelihood Explanation

**Likelihood: Medium-Low**

The vulnerability requires specific conditions:
- `skip_usage=true` (default when `enable_storage_sharding=true`)
- Missing usage metadata in the database (can occur during state restore operations, database inconsistencies, or failed sync operations)

While the default configuration enables the vulnerability path, triggering it requires operational scenarios like incomplete state restoration. The comment in the code acknowledging this as a "hack" for tests suggests this was a known corner case that wasn't properly hardened.

## Recommendation

Add validation to prevent `Untracked` instances from being persisted: [3](#0-2) 

**Recommended Fix:**
```rust
fn put_usage(state: &State, batch: &mut SchemaBatch) -> Result<()> {
    if let Some(version) = state.version() {
        let usage = state.usage();
        
        // SECURITY FIX: Prevent persisting untracked usage
        ensure!(
            !usage.is_untracked(),
            "Cannot persist untracked state storage usage at version {}. \
             This indicates missing usage tracking and would corrupt storage accounting.",
            version
        );
        
        info!("Write usage at version {version}, {usage:?}.");
        batch.put::<VersionDataSchema>(&version, &usage.into())?;
    } else {
        assert_eq!(state.usage().items(), 0);
        assert_eq!(state.usage().bytes(), 0);
    }

    Ok(())
}
```

Additionally, the `From<StateStorageUsage>` implementation should validate the input:

```rust
impl From<StateStorageUsage> for VersionData {
    fn from(usage: StateStorageUsage) -> Self {
        assert!(
            !usage.is_untracked(),
            "Cannot convert Untracked StateStorageUsage to VersionData"
        );
        Self {
            state_items: usage.items(),
            total_state_bytes: usage.bytes(),
        }
    }
}
```

## Proof of Concept

```rust
#[cfg(test)]
mod storage_usage_corruption_poc {
    use super::*;
    use aptos_types::state_store::state_storage_usage::StateStorageUsage;
    
    #[test]
    #[should_panic(expected = "Cannot persist untracked")]
    fn test_untracked_usage_corruption() {
        // Step 1: Create an Untracked instance (simulating missing metadata scenario)
        let untracked_usage = StateStorageUsage::new_untracked();
        assert!(untracked_usage.is_untracked());
        
        // Step 2: Demonstrate that items() and bytes() return 0 for Untracked
        assert_eq!(untracked_usage.items(), 0);
        assert_eq!(untracked_usage.bytes(), 0);
        
        // Step 3: Convert to VersionData (this silently creates 0/0 data)
        let version_data: VersionData = untracked_usage.into();
        assert_eq!(version_data.state_items, 0);
        assert_eq!(version_data.total_state_bytes, 0);
        
        // Step 4: Retrieve as StateStorageUsage (now it's Tracked with 0/0!)
        let retrieved_usage = version_data.get_state_storage_usage();
        assert!(!retrieved_usage.is_untracked()); // Now it's Tracked!
        assert_eq!(retrieved_usage.items(), 0);   // But with 0 items
        assert_eq!(retrieved_usage.bytes(), 0);   // And 0 bytes - CORRUPTION!
        
        // This demonstrates the data corruption: Untracked -> 0/0 VersionData -> Tracked(0,0)
        // The fix would prevent this by asserting in put_usage() or From::from()
    }
}
```

**Notes:**

The vulnerability is a **defensive programming gap** rather than a directly exploitable attack vector by unprivileged users. However, it represents a serious state consistency issue that could manifest during operational scenarios (state restore, database recovery) and lead to permanent corruption of storage accounting data. The fix is straightforward: add validation checks before persisting untracked instances to prevent silent data corruption.

### Citations

**File:** config/src/config/storage_config.rs (L233-233)
```rust
            enable_storage_sharding: true,
```

**File:** storage/aptosdb/src/state_store/mod.rs (L238-247)
```rust
    fn get_state_storage_usage(&self, version: Option<Version>) -> Result<StateStorageUsage> {
        version.map_or(Ok(StateStorageUsage::zero()), |version| {
            Ok(match self.ledger_db.metadata_db().get_usage(version) {
                Ok(data) => data,
                _ => {
                    ensure!(self.skip_usage, "VersionData at {version} is missing.");
                    StateStorageUsage::new_untracked()
                },
            })
        })
```

**File:** storage/aptosdb/src/state_store/mod.rs (L963-966)
```rust
                        // n.b. all updated state items must be read and recorded in the state cache,
                        // otherwise we can't calculate the correct usage. The is_untracked() hack
                        // is to allow some db tests without real execution layer to pass.
                        assert!(ignore_state_cache_miss, "Must cache read.");
```

**File:** storage/aptosdb/src/state_store/mod.rs (L1017-1028)
```rust
    fn put_usage(state: &State, batch: &mut SchemaBatch) -> Result<()> {
        if let Some(version) = state.version() {
            let usage = state.usage();
            info!("Write usage at version {version}, {usage:?}.");
            batch.put::<VersionDataSchema>(&version, &usage.into())?;
        } else {
            assert_eq!(state.usage().items(), 0);
            assert_eq!(state.usage().bytes(), 0);
        }

        Ok(())
    }
```

**File:** types/src/state_store/state_storage_usage.rs (L30-42)
```rust
    pub fn items(&self) -> usize {
        match self {
            Self::Tracked { items, .. } => *items,
            Self::Untracked => 0,
        }
    }

    pub fn bytes(&self) -> usize {
        match self {
            Self::Tracked { bytes, .. } => *bytes,
            Self::Untracked => 0,
        }
    }
```

**File:** storage/aptosdb/src/schema/version_data/mod.rs (L36-42)
```rust
impl From<StateStorageUsage> for VersionData {
    fn from(usage: StateStorageUsage) -> Self {
        Self {
            state_items: usage.items(),
            total_state_bytes: usage.bytes(),
        }
    }
```

**File:** storage/aptosdb/src/schema/version_data/mod.rs (L45-48)
```rust
impl VersionData {
    pub fn get_state_storage_usage(&self) -> StateStorageUsage {
        StateStorageUsage::new(self.state_items, self.total_state_bytes)
    }
```

**File:** aptos-move/framework/aptos-framework/sources/storage_gas.move (L524-532)
```text
        let (items, bytes) = state_storage::current_items_and_bytes();
        let gas_config = borrow_global<StorageGasConfig>(@aptos_framework);
        let gas = borrow_global_mut<StorageGas>(@aptos_framework);
        gas.per_item_read = calculate_read_gas(&gas_config.item_config, items);
        gas.per_item_create = calculate_create_gas(&gas_config.item_config, items);
        gas.per_item_write = calculate_write_gas(&gas_config.item_config, items);
        gas.per_byte_read = calculate_read_gas(&gas_config.byte_config, bytes);
        gas.per_byte_create = calculate_create_gas(&gas_config.byte_config, bytes);
        gas.per_byte_write = calculate_write_gas(&gas_config.byte_config, bytes);
```

**File:** storage/aptosdb/src/state_store/state_snapshot_committer.rs (L167-175)
```rust
                    if !usage.is_untracked() {
                        assert_eq!(
                            leaf_count,
                            usage.items(),
                            "Num of state items mismatch: jmt: {}, state: {}",
                            leaf_count,
                            usage.items(),
                        );
                    }
```

**File:** storage/aptosdb/src/state_store/state_merkle_batch_committer.rs (L158-165)
```rust
        if !usage_from_in_mem_state.is_untracked() {
            ensure!(
                usage_from_in_mem_state == usage_from_ledger_db,
                "State storage usage info inconsistent. from smt: {:?}, from ledger_db: {:?}",
                usage_from_in_mem_state,
                usage_from_ledger_db,
            );
        }
```
