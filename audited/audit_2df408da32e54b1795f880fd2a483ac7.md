# Audit Report

## Title
Consensus Split Due to Inconsistent Randomness Metadata Generation Across Config Versions

## Summary
Validators running different `OnChainConsensusConfig` versions (V4 vs V5 with `rand_check_enabled=true`) generate different block metadata transactions when randomness is globally enabled, causing deterministic execution violations and consensus failure.

## Finding Description
The vulnerability stems from version-dependent behavior in randomness optimization logic. When randomness is enabled network-wide (`is_randomness_enabled=true`) but validators have different consensus config versions, they produce non-deterministic block metadata: [1](#0-0) 

The `disable_rand_check()` function only affects V5 configs. The `rand_check_enabled()` accessor returns:
- `false` for V1-V4 configs (hardcoded)
- The field value for V5 configs [2](#0-1) 

During block execution, the `rand_check` pipeline phase conditionally skips randomness generation: [3](#0-2) 

Specifically at the critical branching point: [4](#0-3) 

This creates divergent execution paths:
- **V5 validators** (`rand_check_enabled=true`): For blocks without randomness-requiring transactions, return `(Some(None), false)`, creating `BlockMetadataExt::V1` with `randomness: None`
- **V4 validators** or **V5 with `rand_check_enabled=false`**: Always await randomness from `rand_rx`, return `(Some(Some(actual_randomness)), _)`, creating `BlockMetadataExt::V1` with `randomness: Some(value)` [5](#0-4) 

The `BlockMetadataWithRandomness` struct stores randomness as `Option<Randomness>`: [6](#0-5) 

Different `Option` values serialize to different bytes, producing different transaction hashes and ultimately different state roots, violating the **Deterministic Execution** invariant.

## Impact Explanation
**Critical Severity** - This breaks consensus safety, the most fundamental blockchain invariant:

1. **Consensus Split**: Validators cannot agree on block execution results, halting consensus progress
2. **Network Partition**: The network splits into incompatible validator sets based on config versions
3. **Requires Hardfork**: Recovery requires coordinated config rollback or forced upgrade, meeting the "non-recoverable network partition" criterion

The vulnerability becomes active during:
- Config version upgrades when V5 is deployed with `rand_check_enabled=true`
- Deserialization failures causing fallback to V4 default [7](#0-6) 

## Likelihood Explanation
**High Likelihood** during configuration transitions:

1. **Natural Occurrence**: Every upgrade to V5 with `rand_check_enabled=true` risks this condition
2. **Deserialization Fragility**: Any validator failing to parse V5 config falls back to V4 default
3. **Persistent State**: Once triggered, the split persists until manual intervention
4. **No External Dependencies**: Requires only normal block proposal operations

The condition activates when:
- Global randomness is enabled: `is_randomness_enabled=true`
- Validator set has mixed configs (V5 vs V4)
- A block contains no transactions with `#[randomness]` annotation [8](#0-7) 

## Recommendation
Enforce consensus config version uniformity before enabling randomness features:

1. **Add version gate in `rand_check()`**:
```rust
async fn rand_check(...) -> TaskResult<RandResult> {
    // ... existing code ...
    if !is_randomness_enabled {
        return Ok((None, false));
    }
    
    // NEW: Enforce that rand_check optimization requires explicit V5
    if !rand_check_enabled {
        // Preserve old behavior: always generate randomness
        let rand = rand_rx.await.map_err(...)?;
        return Ok((Some(rand), true));
    }
    
    // Only V5 validators with rand_check_enabled reach here
    // ... existing optimization logic ...
}
```

2. **Config validation in epoch transition**:
```rust
// In epoch_manager.rs start_new_epoch
if onchain_randomness_config.randomness_enabled() {
    ensure!(
        matches!(consensus_config, OnChainConsensusConfig::V5 { .. }),
        "Randomness requires OnChainConsensusConfig V5"
    );
}
```

3. **Deprecate mixed-version support**: Document that randomness features require network-wide V5 adoption

## Proof of Concept
```rust
// Simulated scenario in Rust test
#[test]
fn test_consensus_split_mixed_configs() {
    // Setup: Two validators with different configs
    let v5_config = OnChainConsensusConfig::V5 {
        alg: ConsensusAlgorithmConfig::default_for_genesis(),
        vtxn: ValidatorTxnConfig::default_for_genesis(),
        window_size: None,
        rand_check_enabled: true, // V5 with optimization
    };
    
    let v4_config = OnChainConsensusConfig::default(); // Falls back to V4
    
    // Both configs have randomness enabled globally
    let is_randomness_enabled = true;
    
    // Block with no randomness-requiring transactions
    let block = create_block_without_randomness_txns();
    let actual_randomness = Randomness::new(...);
    
    // Validator A (V5): Skips randomness wait
    let rand_check_v5 = v5_config.rand_check_enabled(); // true
    let metadata_v5 = if rand_check_v5 && !has_randomness_txns(&block) {
        BlockMetadataExt::new_v1(..., None) // randomness: None
    } else {
        BlockMetadataExt::new_v1(..., Some(actual_randomness))
    };
    
    // Validator B (V4): Always waits for randomness
    let rand_check_v4 = v4_config.rand_check_enabled(); // false
    let metadata_v4 = BlockMetadataExt::new_v1(..., Some(actual_randomness)); // randomness: Some
    
    // CONSENSUS SPLIT: Different metadata transactions
    assert_ne!(bcs::to_bytes(&metadata_v5), bcs::to_bytes(&metadata_v4));
    // Different transactions → different state roots → consensus failure
}
```

## Notes
The security question's premise incorrectly states older versions "keep randomness checks enabled" - they actually return `false` (disabled). However, this investigation revealed the actual vulnerability: the optimization creates non-deterministic metadata generation across config versions when randomness is globally enabled, violating consensus safety regardless of the semantic interpretation of "enabled."

### Citations

**File:** types/src/on_chain_config/consensus_config.rs (L414-425)
```rust
    pub fn rand_check_enabled(&self) -> bool {
        match self {
            OnChainConsensusConfig::V1(_)
            | OnChainConsensusConfig::V2(_)
            | OnChainConsensusConfig::V3 { .. }
            | OnChainConsensusConfig::V4 { .. } => false,
            OnChainConsensusConfig::V5 {
                rand_check_enabled: rand_check,
                ..
            } => *rand_check,
        }
    }
```

**File:** types/src/on_chain_config/consensus_config.rs (L427-438)
```rust
    pub fn disable_rand_check(&mut self) {
        match self {
            OnChainConsensusConfig::V5 {
                rand_check_enabled, ..
            } => {
                *rand_check_enabled = false;
            },
            _ => {
                // rand_check not supported. No-op.
            },
        }
    }
```

**File:** consensus/src/pipeline/pipeline_builder.rs (L685-783)
```rust
    async fn rand_check(
        prepare_fut: TaskFuture<PrepareResult>,
        parent_block_execute_fut: TaskFuture<ExecuteResult>,
        rand_rx: oneshot::Receiver<Option<Randomness>>,
        executor: Arc<dyn BlockExecutorTrait>,
        block: Arc<Block>,
        is_randomness_enabled: bool,
        rand_check_enabled: bool,
        module_cache: Arc<Mutex<Option<CachedModuleView<CachedStateView>>>>,
    ) -> TaskResult<RandResult> {
        let mut tracker = Tracker::start_waiting("rand_check", &block);
        parent_block_execute_fut.await?;
        let (user_txns, _) = prepare_fut.await?;

        tracker.start_working();
        if !is_randomness_enabled {
            return Ok((None, false));
        }
        let grand_parent_id = block.quorum_cert().parent_block().id();
        let parent_state_view = executor
            .state_view(block.parent_id())
            .map_err(anyhow::Error::from)?;

        let mut has_randomness = false;
        // scope to drop the lock, compiler seems not able to figure out manual drop with async point
        {
            let mut cache_guard = module_cache.lock();
            if let Some(cache_mut) = cache_guard.as_mut() {
                // flush the cache if the execution state view is not linear
                // in case of speculative executing a forked block
                let previous_state_view = cache_mut.state_view_id();
                let expected_state_view = StateViewId::BlockExecution {
                    block_id: grand_parent_id,
                };
                if previous_state_view == expected_state_view {
                    cache_mut.reset_state_view(parent_state_view);
                } else {
                    counters::RAND_BLOCK
                        .with_label_values(&["reset_cache"])
                        .inc();
                    cache_mut.reset_all(parent_state_view);
                }
            } else {
                *cache_guard = Some(CachedModuleView::new(parent_state_view));
            }
            let cache_ref = cache_guard.as_mut().expect("just set");

            for txn in user_txns.iter() {
                if let Some(txn) = txn.borrow_into_inner().try_as_signed_user_txn() {
                    if let Ok(TransactionExecutableRef::EntryFunction(entry_fn)) =
                        txn.executable_ref()
                    {
                        // use the deserialized API to avoid cloning the metadata
                        // should migrate once we move metadata into the extension and avoid cloning
                        if let Ok(Some(module)) = cache_ref.unmetered_get_deserialized_module(
                            entry_fn.module().address(),
                            entry_fn.module().name(),
                        ) {
                            if get_randomness_annotation_for_entry_function(
                                entry_fn,
                                &module.metadata,
                            )
                            .is_some()
                            {
                                has_randomness = true;
                                break;
                            }
                        }
                    }
                }
            }
        }
        let label = if has_randomness {
            "has_rand"
        } else {
            "no_rand"
        };
        counters::RAND_BLOCK.with_label_values(&[label]).inc();
        if has_randomness {
            info!(
                "[Pipeline] Block {} {} {} has randomness txn",
                block.id(),
                block.epoch(),
                block.round()
            );
        }
        drop(tracker);
        // if rand check is enabled and no txn requires randomness, we skip waiting for randomness
        let mut tracker = Tracker::start_waiting("rand_gen", &block);
        tracker.start_working();
        let maybe_rand = if rand_check_enabled && !has_randomness {
            None
        } else {
            rand_rx
                .await
                .map_err(|_| anyhow!("randomness tx cancelled"))?
        };
        Ok((Some(maybe_rand), has_randomness))
    }
```

**File:** consensus/src/pipeline/pipeline_builder.rs (L796-811)
```rust
    ) -> TaskResult<ExecuteResult> {
        let mut tracker = Tracker::start_waiting("execute", &block);
        parent_block_execute_fut.await?;
        let (user_txns, block_gas_limit) = prepare_fut.await?;
        let onchain_execution_config =
            onchain_execution_config.with_block_gas_limit_override(block_gas_limit);

        let (rand_result, _has_randomness) = rand_check.await?;

        tracker.start_working();
        // if randomness is disabled, the metadata skips DKG and triggers immediate reconfiguration
        let metadata_txn = if let Some(maybe_rand) = rand_result {
            block.new_metadata_with_randomness(&validator, maybe_rand)
        } else {
            block.new_block_metadata(&validator).into()
        };
```

**File:** types/src/block_metadata_ext.rs (L23-34)
```rust
#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub struct BlockMetadataWithRandomness {
    pub id: HashValue,
    pub epoch: u64,
    pub round: u64,
    pub proposer: AccountAddress,
    #[serde(with = "serde_bytes")]
    pub previous_block_votes_bitvec: Vec<u8>,
    pub failed_proposer_indices: Vec<u32>,
    pub timestamp_usecs: u64,
    pub randomness: Option<Randomness>,
}
```

**File:** consensus/src/epoch_manager.rs (L1178-1201)
```rust
        let onchain_consensus_config: anyhow::Result<OnChainConsensusConfig> = payload.get();
        let onchain_execution_config: anyhow::Result<OnChainExecutionConfig> = payload.get();
        let onchain_randomness_config_seq_num: anyhow::Result<RandomnessConfigSeqNum> =
            payload.get();
        let randomness_config_move_struct: anyhow::Result<RandomnessConfigMoveStruct> =
            payload.get();
        let onchain_jwk_consensus_config: anyhow::Result<OnChainJWKConsensusConfig> = payload.get();
        let dkg_state = payload.get::<DKGState>();

        if let Err(error) = &onchain_consensus_config {
            warn!("Failed to read on-chain consensus config {}", error);
        }

        if let Err(error) = &onchain_execution_config {
            warn!("Failed to read on-chain execution config {}", error);
        }

        if let Err(error) = &randomness_config_move_struct {
            warn!("Failed to read on-chain randomness config {}", error);
        }

        self.epoch_state = Some(epoch_state.clone());

        let consensus_config = onchain_consensus_config.unwrap_or_default();
```

**File:** consensus/src/pipeline/execution_client.rs (L566-567)
```rust
        let randomness_enabled = onchain_consensus_config.is_vtxn_enabled()
            && onchain_randomness_config.randomness_enabled();
```
