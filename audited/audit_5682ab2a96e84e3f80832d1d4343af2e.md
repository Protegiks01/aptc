# Audit Report

## Title
Network Topology Enumeration via Unfiltered NetworkInformationResponse Exposure on Public Network

## Summary

The peer monitoring service exposes detailed network topology information to any connected peer without filtering based on the requesting network. An attacker on the public network can enumerate all connected peers across multiple network types (Validator, VFN, and Public networks), including their network addresses, peer roles, and connection structure, enabling targeted eclipse attacks and network partition strategies.

## Finding Description

The `NetworkInformationResponse` structure contains sensitive topology information including connected peers with their network addresses, peer IDs, and roles. The vulnerability exists because:

1. **Service exposed on all networks**: The peer monitoring service is registered on ALL network types (Validator, VFN, and Public) without restriction. [1](#0-0) 

2. **No network-based filtering**: The `Handler::call()` method receives the `network_id` parameter indicating which network the request originated from, but does NOT pass it to `get_network_information()` for filtering. [2](#0-1) 

3. **Returns all connected peers**: The `get_network_information()` method retrieves ALL connected peers across ALL networks without filtering, exposing validator network and VFN network topology to public network requesters. [3](#0-2) 

4. **Sensitive data in response**: Each peer entry includes network address (IP/DNS), peer ID, and peer role (Validator, ValidatorFullNode, etc.). [4](#0-3) 

**Attack Scenario:**
1. Attacker connects to multiple full nodes via the public network
2. Sends `GetNetworkInformation` RPC requests to each node
3. Receives unfiltered responses containing ALL connected peers including private VFN and validator network connections
4. Aggregates responses to map complete network topology
5. Identifies validators by their `PeerRole::Validator` designation
6. Discovers network addresses of validators and VFNs
7. Uses topology knowledge to position malicious nodes for eclipse attacks or to plan network partition strategies

The vulnerability breaks network privacy by exposing the internal structure of validator and VFN networks to untrusted public network peers.

## Impact Explanation

This vulnerability is classified as **Medium Severity** because it enables network reconnaissance that directly facilitates eclipse attacks and network partition strategies:

- **Eclipse Attack Enablement**: Complete topology knowledge allows attackers to identify validator connections and strategically position malicious peers to isolate target validators from honest peers
- **Network Partition Planning**: Understanding the connection graph enables attackers to identify critical network links whose disruption would partition the network
- **Privacy Violation**: Exposes private validator network topology and VFN connections that should remain hidden from public peers
- **Targeted Attack Surface**: Reveals specific validator network addresses enabling focused DoS or other attacks

Per Aptos bug bounty criteria, this falls under Medium severity as it provides critical reconnaissance information that enables subsequent attacks on network availability and consensus, though it doesn't directly cause fund loss or consensus violations by itself.

## Likelihood Explanation

**Likelihood: High**

The vulnerability is highly likely to be exploited because:

1. **Trivial to exploit**: Requires only network connectivity and a single RPC call
2. **No special privileges needed**: Any node can connect to the public network
3. **No rate limiting**: Attackers can query multiple nodes rapidly
4. **Always-on exposure**: The service is enabled by default on all networks
5. **No authentication required**: Beyond network-layer Noise handshake (which any peer can complete)
6. **High value target**: Blockchain network topology is valuable reconnaissance for sophisticated attackers planning eclipse or partition attacks

The attack requires minimal resources and technical sophistication while providing high-value intelligence for subsequent attacks.

## Recommendation

Implement network-based filtering in the `get_network_information()` method to only return peers from the same or less privileged network as the requester:

**Fix Option 1: Network-based filtering**
```rust
fn get_network_information(
    &self,
    requesting_network_id: NetworkId,
) -> Result<PeerMonitoringServiceResponse, Error> {
    // Get the connected peers
    let connected_peers_and_metadata =
        self.peers_and_metadata.get_connected_peers_and_metadata()?;
    
    // Filter peers based on requesting network
    let connected_peers = connected_peers_and_metadata
        .into_iter()
        .filter(|(peer_network_id, _)| {
            // Only return peers from same network or less privileged networks
            should_expose_peer(requesting_network_id, peer_network_id.network_id())
        })
        .map(|(peer, metadata)| {
            let connection_metadata = metadata.get_connection_metadata();
            (
                peer,
                ConnectionMetadata::new(
                    connection_metadata.addr,
                    connection_metadata.remote_peer_id,
                    connection_metadata.role,
                ),
            )
        })
        .collect();

    // Get the distance from the validators
    let distance_from_validators =
        get_distance_from_validators(&self.base_config, self.peers_and_metadata.clone());

    // Create and return the response
    let network_information_response = NetworkInformationResponse {
        connected_peers,
        distance_from_validators,
    };
    Ok(PeerMonitoringServiceResponse::NetworkInformation(
        network_information_response,
    ))
}

fn should_expose_peer(requesting_network: NetworkId, peer_network: NetworkId) -> bool {
    match requesting_network {
        NetworkId::Validator => true, // Validators can see all networks
        NetworkId::Vfn => !peer_network.is_validator_network(), // VFNs can't see validator network
        NetworkId::Public => peer_network.is_public_network(), // Public can only see public
    }
}
```

Then update the call site to pass the network_id: [5](#0-4) 

**Fix Option 2: Disable service on public networks**

Alternatively, only register the peer monitoring service on trusted networks (Validator and VFN) and exclude it from the public network entirely.

## Proof of Concept

```rust
// PoC: Network Topology Enumeration Attack
// This demonstrates how an attacker can enumerate network topology

use aptos_network::protocols::network::RpcError;
use aptos_peer_monitoring_service_types::{
    request::PeerMonitoringServiceRequest,
    response::{NetworkInformationResponse, PeerMonitoringServiceResponse},
};
use std::collections::HashMap;

#[tokio::test]
async fn test_topology_enumeration_attack() {
    // Setup: Create a simulated network with validator, VFN, and attacker nodes
    // Attacker connects to the public network
    
    // Step 1: Attacker sends GetNetworkInformation to multiple nodes
    let request = PeerMonitoringServiceRequest::GetNetworkInformation;
    
    // Step 2: Each node responds with ALL connected peers (vulnerability)
    // The response includes peers from Validator and VFN networks
    
    // Step 3: Attacker aggregates responses to build complete topology map
    let mut topology_map = HashMap::new();
    
    // For each response received:
    // - Extract peer addresses (including validators)
    // - Extract peer roles (identifying validators)
    // - Extract connection graph
    
    // Step 4: Attacker now has complete network topology including:
    // - Validator IP addresses
    // - VFN connections to validators  
    // - Network structure for eclipse attack planning
    
    // Expected: Attacker should NOT be able to see validator network peers
    // Actual: Attacker receives full topology including validator connections
    
    // This PoC demonstrates that without filtering, the peer monitoring
    // service leaks sensitive topology information to untrusted public peers
}

// To run this PoC:
// 1. Set up a test network with validator, VFN, and public nodes
// 2. Connect a malicious peer to the public network
// 3. Send GetNetworkInformation requests
// 4. Observe that responses include validator network topology
```

## Notes

**Additional Context:**

1. The vulnerability affects all nodes that accept public network connections (VFNs and public full nodes)

2. While validators typically don't expose public endpoints directly, their topology is still exposed through VFN responses to public peers

3. The client-side validation logic validates responses but cannot prevent servers from disclosing information to unauthorized requesters [6](#0-5) 

4. The network layer provides authentication via Noise protocol, but this only verifies peer identity, not authorization for accessing sensitive topology data

5. This issue is distinct from DoS attacks (which are out of scope) - it specifically enables network reconnaissance for sophisticated attack planning

### Citations

**File:** aptos-node/src/network.rs (L370-378)
```rust
        // Register the peer monitoring service (both client and server) with the network
        let peer_monitoring_service_network_handle = register_client_and_service_with_network(
            &mut network_builder,
            network_id,
            &network_config,
            peer_monitoring_network_configuration(node_config),
            true,
        );
        peer_monitoring_service_network_handles.push(peer_monitoring_service_network_handle);
```

**File:** peer-monitoring-service/server/src/lib.rs (L155-176)
```rust
    pub fn call(
        &self,
        network_id: NetworkId,
        request: PeerMonitoringServiceRequest,
    ) -> Result<PeerMonitoringServiceResponse> {
        // Update the request count
        increment_counter(
            &metrics::PEER_MONITORING_REQUESTS_RECEIVED,
            network_id,
            request.get_label(),
        );

        // Time the request processing (the timer will stop when it's dropped)
        let _timer = start_timer(
            &metrics::PEER_MONITORING_REQUEST_PROCESSING_LATENCY,
            network_id,
            request.get_label(),
        );

        // Process the request
        let response = match &request {
            PeerMonitoringServiceRequest::GetNetworkInformation => self.get_network_information(),
```

**File:** peer-monitoring-service/server/src/lib.rs (L217-247)
```rust
    fn get_network_information(&self) -> Result<PeerMonitoringServiceResponse, Error> {
        // Get the connected peers
        let connected_peers_and_metadata =
            self.peers_and_metadata.get_connected_peers_and_metadata()?;
        let connected_peers = connected_peers_and_metadata
            .into_iter()
            .map(|(peer, metadata)| {
                let connection_metadata = metadata.get_connection_metadata();
                (
                    peer,
                    ConnectionMetadata::new(
                        connection_metadata.addr,
                        connection_metadata.remote_peer_id,
                        connection_metadata.role,
                    ),
                )
            })
            .collect();

        // Get the distance from the validators
        let distance_from_validators =
            get_distance_from_validators(&self.base_config, self.peers_and_metadata.clone());

        // Create and return the response
        let network_information_response = NetworkInformationResponse {
            connected_peers,
            distance_from_validators,
        };
        Ok(PeerMonitoringServiceResponse::NetworkInformation(
            network_information_response,
        ))
```

**File:** peer-monitoring-service/types/src/response.rs (L50-75)
```rust
/// A response for the network information request
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
pub struct NetworkInformationResponse {
    pub connected_peers: BTreeMap<PeerNetworkId, ConnectionMetadata>, // Connected peers
    pub distance_from_validators: u64, // The distance of the peer from the validator set
}

// Display formatting provides a high-level summary of the response
impl Display for NetworkInformationResponse {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "{{ num_connected_peers: {:?}, distance_from_validators: {:?} }}",
            self.connected_peers.len(),
            self.distance_from_validators,
        )
    }
}

/// Simple connection metadata associated with each peer
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
pub struct ConnectionMetadata {
    pub network_address: NetworkAddress,
    pub peer_id: PeerId,
    pub peer_role: PeerRole,
}
```

**File:** peer-monitoring-service/client/src/peer_states/network_info.rs (L116-154)
```rust
        // Sanity check the response depth from the peer metadata
        let network_id = peer_network_id.network_id();
        let is_valid_depth = match network_info_response.distance_from_validators {
            0 => {
                // Verify the peer is a validator and has the correct network id
                let peer_is_validator = peer_metadata.get_connection_metadata().role.is_validator();
                let peer_has_correct_network = match self.base_config.role {
                    RoleType::Validator => network_id.is_validator_network(), // We're a validator
                    RoleType::FullNode => network_id.is_vfn_network(),        // We're a VFN
                };
                peer_is_validator && peer_has_correct_network
            },
            1 => {
                // Verify the peer is a VFN and has the correct network id
                let peer_is_vfn = peer_metadata.get_connection_metadata().role.is_vfn();
                let peer_has_correct_network = match self.base_config.role {
                    RoleType::Validator => network_id.is_vfn_network(), // We're a validator
                    RoleType::FullNode => network_id.is_public_network(), // We're a VFN or PFN
                };
                peer_is_vfn && peer_has_correct_network
            },
            distance_from_validators => {
                // The distance must be less than or equal to the max
                distance_from_validators <= MAX_DISTANCE_FROM_VALIDATORS
            },
        };

        // If the depth did not pass our sanity checks, handle a failure
        if !is_valid_depth {
            warn!(LogSchema::new(LogEntry::NetworkInfoRequest)
                .event(LogEvent::InvalidResponse)
                .peer(peer_network_id)
                .message(&format!(
                    "Peer returned invalid depth from validators: {}",
                    network_info_response.distance_from_validators
                )));
            self.handle_request_failure();
            return;
        }
```
