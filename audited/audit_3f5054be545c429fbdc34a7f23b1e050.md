# Audit Report

## Title
Unbounded Channel Buffer in Cross-Shard Messaging Causes Memory Exhaustion and Validator OOM Crashes

## Summary
The `RemoteCrossShardClient::send_cross_shard_msg()` function uses unbounded channels to buffer cross-shard messages during sharded block execution. When messages are produced faster than the sequential GRPC sender can process them, the unbounded buffer grows without limit, leading to memory exhaustion and out-of-memory (OOM) crashes of validator nodes.

## Finding Description

The vulnerability exists in the cross-shard messaging infrastructure used during sharded block execution. The issue manifests through the following chain:

**1. Unbounded Channel Creation:**
The `NetworkController::create_outbound_channel()` creates unbounded channels using `crossbeam_channel::unbounded()`: [1](#0-0) 

**2. Usage in Cross-Shard Messaging:**
The `RemoteCrossShardClient` uses these unbounded channels to send cross-shard messages: [2](#0-1) 

**3. Sequential Message Processing:**
The `OutboundHandler` processes all messages sequentially in a single async task, sending them via GRPC: [3](#0-2) 

**4. High-Volume Message Generation:**
During sharded block execution, when transactions commit, the `CrossShardCommitSender::send_remote_update_for_success()` sends messages to all dependent shards for each state key written: [4](#0-3) 

**Attack Scenario:**

1. **Setup**: A validator runs in sharded execution mode with 8 shards (MAX_ALLOWED_PARTITIONING_ROUNDS) [5](#0-4) 

2. **Trigger**: Blocks contain transactions with many cross-shard dependencies (e.g., transactions writing to 100 state keys that have dependencies across 7 other shards)

3. **Message Flood**: Each committed transaction generates: 100 state keys × 7 dependent shards = 700 messages

4. **Buffer Accumulation**: With 1000 transactions executing in parallel, this produces ~700,000 messages that queue in the unbounded channel

5. **Processing Bottleneck**: The single-threaded OutboundHandler processes messages sequentially via GRPC. If each GRPC send takes 10ms (due to network latency or slow remote peer), processing 700,000 messages takes ~2 hours

6. **Memory Exhaustion**: Each `RemoteTxnWrite` message contains a `StateKey` and `WriteOp` (typically ~1KB serialized): [6](#0-5) 
   
   Total memory: 700,000 messages × 1KB = ~700MB per block

7. **OOM Crash**: Repeated blocks cause unbounded memory growth until the validator node crashes

**Broken Invariants:**
- **Resource Limits**: "All operations must respect gas, storage, and computational limits" - The unbounded channel violates memory resource limits
- **Validator Availability**: Validator nodes crash, affecting consensus participation

The same vulnerability exists in the `LocalCrossShardClient` implementation which also uses unbounded channels: [7](#0-6) [8](#0-7) 

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos Bug Bounty program criteria:

- **Validator Node Crashes**: OOM crashes directly cause validator unavailability
- **Consensus Disruption**: If multiple validators crash simultaneously when processing the same block, consensus participation is reduced
- **No Recovery Mechanism**: The unbounded channels have no back-pressure or rate limiting, providing no automatic recovery
- **Availability Impact**: Meets "Validator node slowdowns" and "API crashes" High severity criteria

While this doesn't reach Critical severity (no funds loss or permanent network partition), it represents a significant protocol violation that can cause temporary loss of liveness.

## Likelihood Explanation

**Likelihood: Medium-High**

The vulnerability is likely to occur under these conditions:

1. **Sharded Execution Enabled**: The system must be running with sharded block execution (num_shards > 1). This is configurable and used in benchmarks: [9](#0-8) 

2. **High Cross-Shard Dependencies**: Blocks must contain transactions with significant cross-shard dependencies. This occurs naturally in high-throughput scenarios where transactions access overlapping state

3. **Network/Processing Delays**: GRPC message sending must be slower than message production. This happens with:
   - Network congestion or latency
   - Slow/overloaded remote executor services
   - Large message payloads

4. **No Attacker Control Required**: The vulnerability triggers during normal block execution - attackers don't need special privileges, just the ability to submit transactions that create cross-shard dependencies

**Reducing Factors:**
- Sharded execution may not be enabled in all deployments
- Requires sustained high transaction throughput with cross-shard dependencies

## Recommendation

Implement bounded channels with back-pressure mechanisms:

**Fix 1: Use Bounded Channels**
```rust
// In NetworkController::create_outbound_channel()
pub fn create_outbound_channel(
    &mut self,
    remote_peer_addr: SocketAddr,
    message_type: String,
) -> Sender<Message> {
    // Use bounded channel with configurable capacity
    const MAX_CHANNEL_CAPACITY: usize = 10_000;
    let (outbound_sender, outbound_receiver) = bounded(MAX_CHANNEL_CAPACITY);

    self.outbound_handler
        .register_handler(message_type, remote_peer_addr, outbound_receiver);

    outbound_sender
}
```

**Fix 2: Handle Send Failures Gracefully**
```rust
// In RemoteCrossShardClient::send_cross_shard_msg()
fn send_cross_shard_msg(&self, shard_id: ShardId, round: RoundId, msg: CrossShardMsg) {
    let input_message = bcs::to_bytes(&msg).unwrap();
    let tx = self.message_txs[shard_id][round].lock().unwrap();
    
    // Handle channel full scenario with retry or blocking
    match tx.send_timeout(Message::new(input_message), Duration::from_secs(5)) {
        Ok(_) => {},
        Err(SendTimeoutError::Timeout(_)) => {
            // Log and apply back-pressure
            warn!("Cross-shard message channel full, applying back-pressure");
            // Block until capacity available or abort block execution
        },
        Err(SendTimeoutError::Disconnected(_)) => {
            panic!("Cross-shard message channel disconnected");
        }
    }
}
```

**Fix 3: Parallel Message Processing**
Modify `OutboundHandler` to use multiple worker tasks for parallel GRPC sending instead of sequential processing.

**Fix 4: Apply the same fixes to LocalCrossShardClient** [7](#0-6) 

## Proof of Concept

```rust
// PoC: Demonstrate unbounded channel growth in sharded execution
use crossbeam_channel::unbounded;
use std::thread;
use std::time::Duration;

#[test]
fn test_unbounded_channel_memory_exhaustion() {
    let (tx, rx) = unbounded::<Vec<u8>>();
    
    // Simulate fast message production (transaction commits)
    let producer = thread::spawn(move || {
        for i in 0..1_000_000 {
            let msg = vec![0u8; 1024]; // 1KB message
            tx.send(msg).unwrap();
            if i % 100_000 == 0 {
                println!("Sent {} messages", i);
            }
        }
    });
    
    // Simulate slow message consumption (GRPC sends)
    let consumer = thread::spawn(move || {
        let mut processed = 0;
        while let Ok(_msg) = rx.recv() {
            thread::sleep(Duration::from_millis(10)); // Slow GRPC send
            processed += 1;
            if processed % 1000 == 0 {
                println!("Processed {} messages", processed);
            }
        }
    });
    
    producer.join().unwrap();
    // Consumer falls behind, channel buffer grows to ~1GB
    // In bounded channel, producer would block/fail
    consumer.join().unwrap();
}
```

**Reproduction Steps for Remote Executor:**
1. Configure sharded execution with 8 shards
2. Create blocks with 1000 transactions, each writing to 100 state keys with cross-shard dependencies
3. Introduce artificial network delay in GRPC responses (10ms)
4. Monitor memory usage during block execution
5. Observe unbounded memory growth in channel buffers leading to OOM

**Notes**

This vulnerability affects both local and remote cross-shard execution modes. While sharded execution may be an experimental feature, the presence of production code paths with unbounded resource consumption represents a significant security risk that violates the "Resource Limits" invariant. The issue can be triggered without requiring validator insider access - normal transaction submission that creates cross-shard dependencies is sufficient. The fix requires replacing unbounded channels with bounded channels and implementing proper back-pressure mechanisms throughout the cross-shard messaging infrastructure.

### Citations

**File:** secure/net/src/network_controller/mod.rs (L115-126)
```rust
    pub fn create_outbound_channel(
        &mut self,
        remote_peer_addr: SocketAddr,
        message_type: String,
    ) -> Sender<Message> {
        let (outbound_sender, outbound_receiver) = unbounded();

        self.outbound_handler
            .register_handler(message_type, remote_peer_addr, outbound_receiver);

        outbound_sender
    }
```

**File:** execution/executor-service/src/remote_cross_shard_client.rs (L55-59)
```rust
    fn send_cross_shard_msg(&self, shard_id: ShardId, round: RoundId, msg: CrossShardMsg) {
        let input_message = bcs::to_bytes(&msg).unwrap();
        let tx = self.message_txs[shard_id][round].lock().unwrap();
        tx.send(Message::new(input_message)).unwrap();
    }
```

**File:** secure/net/src/network_controller/outbound_handler.rs (L103-162)
```rust
    async fn process_one_outgoing_message(
        outbound_handlers: Vec<(Receiver<Message>, SocketAddr, MessageType)>,
        socket_addr: &SocketAddr,
        inbound_handler: Arc<Mutex<InboundHandler>>,
        grpc_clients: &mut HashMap<SocketAddr, GRPCNetworkMessageServiceClientWrapper>,
    ) {
        loop {
            let mut select = Select::new();
            for (receiver, _, _) in outbound_handlers.iter() {
                select.recv(receiver);
            }

            let index;
            let msg;
            let _timer;
            {
                let oper = select.select();
                _timer = NETWORK_HANDLER_TIMER
                    .with_label_values(&[&socket_addr.to_string(), "outbound_msgs"])
                    .start_timer();
                index = oper.index();
                match oper.recv(&outbound_handlers[index].0) {
                    Ok(m) => {
                        msg = m;
                    },
                    Err(e) => {
                        warn!(
                            "{:?} for outbound handler on {:?}. This can happen in shutdown,\
                             but should not happen otherwise",
                            e.to_string(),
                            socket_addr
                        );
                        return;
                    },
                }
            }

            let remote_addr = &outbound_handlers[index].1;
            let message_type = &outbound_handlers[index].2;

            if message_type.get_type() == "stop_task" {
                return;
            }

            if remote_addr == socket_addr {
                // If the remote address is the same as the local address, then we are sending a message to ourselves
                // so we should just pass it to the inbound handler
                inbound_handler
                    .lock()
                    .unwrap()
                    .send_incoming_message_to_handler(message_type, msg);
            } else {
                grpc_clients
                    .get_mut(remote_addr)
                    .unwrap()
                    .send_message(*socket_addr, msg, message_type)
                    .await;
            }
        }
    }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/cross_shard_client.rs (L103-134)
```rust
    fn send_remote_update_for_success(
        &self,
        txn_idx: TxnIndex,
        txn_output: &OnceCell<TransactionOutput>,
    ) {
        let edges = self.dependent_edges.get(&txn_idx).unwrap();
        let write_set = txn_output
            .get()
            .expect("Committed output must be set")
            .write_set();

        for (state_key, write_op) in write_set.expect_write_op_iter() {
            if let Some(dependent_shard_ids) = edges.get(state_key) {
                for (dependent_shard_id, round_id) in dependent_shard_ids.iter() {
                    trace!("Sending remote update for success for shard id {:?} and txn_idx: {:?}, state_key: {:?}, dependent shard id: {:?}", self.shard_id, txn_idx, state_key, dependent_shard_id);
                    let message = RemoteTxnWriteMsg(RemoteTxnWrite::new(
                        state_key.clone(),
                        Some(write_op.clone()),
                    ));
                    if *round_id == GLOBAL_ROUND_ID {
                        self.cross_shard_client.send_global_msg(message);
                    } else {
                        self.cross_shard_client.send_cross_shard_msg(
                            *dependent_shard_id,
                            *round_id,
                            message,
                        );
                    }
                }
            }
        }
    }
```

**File:** types/src/block_executor/partitioner.rs (L20-20)
```rust
pub static MAX_ALLOWED_PARTITIONING_ROUNDS: usize = 8;
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/messages.rs (L13-18)
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct RemoteTxnWrite {
    state_key: StateKey,
    // The write op is None if the transaction is aborted.
    write_op: Option<WriteOp>,
}
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/local_executor_shard.rs (L95-104)
```rust
        let (cross_shard_msg_txs, cross_shard_msg_rxs): (
            Vec<Vec<Sender<CrossShardMsg>>>,
            Vec<Vec<Receiver<CrossShardMsg>>>,
        ) = (0..num_shards)
            .map(|_| {
                (0..MAX_ALLOWED_PARTITIONING_ROUNDS)
                    .map(|_| unbounded())
                    .unzip()
            })
            .unzip();
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/local_executor_shard.rs (L331-333)
```rust
    fn send_cross_shard_msg(&self, shard_id: ShardId, round: RoundId, msg: CrossShardMsg) {
        self.message_txs[shard_id][round].send(msg).unwrap()
    }
```

**File:** execution/executor-service/src/tests.rs (L61-64)
```rust
    let num_shards = 8;
    let (executor_client, mut executor_services) =
        create_thread_remote_executor_shards(num_shards, Some(2));
    let sharded_block_executor = ShardedBlockExecutor::new(executor_client);
```
