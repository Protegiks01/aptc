# Audit Report

## Title
Race Condition in ChunkExecutor Allows Duplicate Transaction Commits at Wrong Versions

## Summary
A Time-Of-Check-Time-Of-Use (TOCTOU) race condition in the `enqueue_chunk()` function allows concurrent threads to enqueue duplicate transaction chunks, causing the second chunk to be committed at incorrect version numbers with state transitions based on the wrong parent state. This breaks the State Consistency invariant and can lead to database corruption and potential consensus splits.

## Finding Description

The `enqueue_chunk()` function in the ChunkExecutor has a critical atomicity violation between version validation and chunk enqueue operations. [1](#0-0) 

The race window exists because:

1. **Non-atomic read-validate-enqueue sequence**: The function locks `commit_queue` to read `latest_state` at line 301, then releases the lock. The validation check at lines 305-309 uses the cloned `parent_state`, not the current queue state. Finally, it locks again at lines 318-323 to enqueue. [2](#0-1) 

2. **Multiple concurrent readers allowed**: The `with_inner` method uses `RwLock::read()`, allowing multiple threads to execute `enqueue_chunk` concurrently. [3](#0-2) 

3. **State overwrite in enqueue**: The `enqueue_for_ledger_update` function unconditionally overwrites `latest_state` without checking if another chunk was enqueued in the meantime.

**Attack Scenario:**

If a malicious state sync peer sends duplicate chunks for versions 100-109, or if a bug causes duplicate chunk processing:

1. Thread A reads `latest_state.next_version() = 100`, validates chunk (100-109) ✓
2. Thread B reads `latest_state.next_version() = 100` (before A enqueues), validates chunk (100-109) ✓  
3. Thread A executes chunk from state at version 99, enqueues, updates `latest_state.next_version = 110`
4. Thread B executes chunk from state at version 99, enqueues, overwrites `latest_state.next_version = 110`
5. Queue now contains: `[chunk_A(100-109), chunk_B(100-109)]`

When `update_ledger()` processes these: [4](#0-3) 

Chunk A gets `parent_accumulator` with 100 leaves (correct), but Chunk B gets `parent_accumulator` with 110 leaves (after A updated it). [5](#0-4) 

The `first_version()` for commit comes from `parent_accumulator.num_leaves`, so Chunk B will be committed at versions 110-119 instead of 100-109. [6](#0-5) 

**Critical Issue**: Chunk B was executed reading state from version 99 (expecting to be version 100), but gets committed at version 110 (which should read state from version 109). This creates incorrect state transitions - the write sets, gas consumption, and events in Chunk B are all based on the wrong parent state. [7](#0-6) 

The validation in `pre_commit_validation` checks `chunk.first_version == next_version`, which passes because `chunk.first_version` comes from the ledger update output (110), matching the DB's expectation. The bug goes undetected.

## Impact Explanation

**Critical Severity** - This vulnerability causes:

1. **State Consistency Violation**: Transactions are committed with state transitions based on the wrong parent state, violating Invariant #4 ("State Consistency: State transitions must be atomic and verifiable via Merkle proofs")

2. **Potential Consensus Split**: If different nodes experience this race at different times with different chunks, they will have divergent state histories, breaking consensus safety (Invariant #2)

3. **Database Corruption**: The Jellyfish Merkle tree and transaction history become inconsistent, as transactions at version 110+ have incorrect state roots

This meets the **Critical Severity** criteria per Aptos bug bounty: "Consensus/Safety violations" and could lead to "Non-recoverable network partition (requires hardfork)".

## Likelihood Explanation

**Likelihood: Medium-High**

The vulnerability requires:
1. Concurrent calls to `enqueue_chunk()` with duplicate chunks
2. Malicious state sync peer sending duplicates OR bug in state sync driver

State sync operates in a hostile network environment where peers are untrusted. A malicious peer could:
- Send duplicate `TransactionListWithProofV2` for the same version range
- Exploit timing to trigger concurrent processing [8](#0-7) 

The code uses `tokio::task::spawn_blocking` for chunk processing and has `CONCURRENCY_GAUGE` metrics, indicating concurrent execution is expected. [9](#0-8) 

## Recommendation

**Fix: Make version check atomic with enqueue operation**

Replace the two-phase lock pattern with a single atomic operation:

```rust
fn enqueue_chunk<Chunk: TransactionChunk + Sync>(
    &self,
    chunk: Chunk,
    chunk_verifier: Arc<dyn ChunkResultVerifier + Send + Sync>,
    mode_for_log: &'static str,
) -> Result<()> {
    // Acquire lock ONCE for the entire critical section
    let mut commit_queue_guard = self.commit_queue.lock();
    let parent_state = commit_queue_guard.latest_state().clone();
    
    // Validate while holding the lock
    ensure!(
        chunk.first_version() == parent_state.next_version(),
        "Chunk carries unexpected first version. Expected: {}, got: {}",
        parent_state.next_version(),
        chunk.first_version(),
    );
    
    let first_version = parent_state.next_version();
    let num_txns = chunk.len();
    
    // Release lock to avoid holding it during expensive operations
    drop(commit_queue_guard);
    
    let state_view = self.state_view(parent_state.latest())?;
    let execution_output = chunk.into_output::<V>(&parent_state, state_view)?;
    let output = PartialStateComputeResult::new(execution_output);
    
    // Re-acquire lock and verify version hasn't changed
    let mut commit_queue_guard = self.commit_queue.lock();
    ensure!(
        commit_queue_guard.latest_state().next_version() == first_version,
        "Version changed during chunk execution. Expected: {}, got: {}",
        first_version,
        commit_queue_guard.latest_state().next_version(),
    );
    
    commit_queue_guard.enqueue_for_ledger_update(ChunkToUpdateLedger {
        output,
        chunk_verifier,
    })?;
    
    // Lock automatically released
    info!(
        LogSchema::new(LogEntry::ChunkExecutor)
            .first_version_in_request(Some(first_version))
            .num_txns_in_request(num_txns),
        mode = mode_for_log,
        "Enqueued transaction chunk!",
    );
    
    Ok(())
}
```

This ensures that if another thread enqueues a chunk between validation and enqueue, the second check will fail.

## Proof of Concept

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use std::sync::{Arc, Barrier};
    use std::thread;
    
    #[test]
    fn test_concurrent_enqueue_race() {
        // Initialize ChunkExecutor
        let db = create_test_db();
        let executor = Arc::new(ChunkExecutor::<AptosVMBlockExecutor>::new(db));
        executor.reset().unwrap();
        
        // Create two identical chunks for versions 0-9
        let chunk1 = create_test_chunk(0, 10);
        let chunk2 = create_test_chunk(0, 10); // Duplicate!
        let verifier1 = create_test_verifier();
        let verifier2 = create_test_verifier();
        
        // Barrier to synchronize threads
        let barrier = Arc::new(Barrier::new(2));
        let executor1 = executor.clone();
        let executor2 = executor.clone();
        let barrier1 = barrier.clone();
        let barrier2 = barrier.clone();
        
        // Spawn two threads that will race
        let handle1 = thread::spawn(move || {
            barrier1.wait(); // Synchronize
            executor1.enqueue_chunk_by_execution(chunk1, &verifier1, None)
        });
        
        let handle2 = thread::spawn(move || {
            barrier2.wait(); // Synchronize
            executor2.enqueue_chunk_by_execution(chunk2, &verifier2, None)
        });
        
        let result1 = handle1.join().unwrap();
        let result2 = handle2.join().unwrap();
        
        // Both should succeed (demonstrating the bug)
        assert!(result1.is_ok());
        assert!(result2.is_ok());
        
        // Now process both chunks
        executor.update_ledger().unwrap();
        executor.update_ledger().unwrap();
        executor.commit_chunk().unwrap();
        let notification = executor.commit_chunk().unwrap();
        
        // BUG: Second chunk was committed at wrong versions (10-19 instead of 0-9)
        // Verify by checking committed transactions
        assert_eq!(notification.committed_transactions.len(), 10);
        // The transactions are duplicates but at wrong versions!
    }
}
```

**Notes**

The vulnerability is real but requires specific triggering conditions (concurrent duplicate chunks). In production, state sync should deduplicate chunks, but this protection may not be implemented or could have bugs. The fix ensures atomicity between version checking and enqueue operations, preventing the race condition entirely.

### Citations

**File:** execution/executor/src/chunk_executor/mod.rs (L89-106)
```rust
    fn with_inner<F, T>(&self, f: F) -> Result<T>
    where
        F: FnOnce(&ChunkExecutorInner<V>) -> Result<T>,
    {
        let locked = self.inner.read();
        let inner = locked.as_ref().expect("not reset");

        let has_pending_pre_commit = inner.has_pending_pre_commit.load(Ordering::Acquire);
        f(inner).map_err(|error| {
            if has_pending_pre_commit {
                panic!(
                    "Hit error with pending pre-committed ledger, panicking. {:?}",
                    error,
                );
            }
            error
        })
    }
```

**File:** execution/executor/src/chunk_executor/mod.rs (L114-156)
```rust
    fn enqueue_chunk_by_execution(
        &self,
        txn_list_with_proof: TransactionListWithProofV2,
        verified_target_li: &LedgerInfoWithSignatures,
        epoch_change_li: Option<&LedgerInfoWithSignatures>,
    ) -> Result<()> {
        let _guard = CONCURRENCY_GAUGE.concurrency_with(&["chunk", "enqueue_by_execution"]);
        let _timer = EXECUTE_CHUNK.start_timer();

        self.maybe_initialize()?;

        // Verify input data.
        // In consensus-only mode, txn_list_with_proof is fake.
        if !cfg!(feature = "consensus-only-perf-test") {
            txn_list_with_proof.verify(
                verified_target_li.ledger_info(),
                txn_list_with_proof.get_first_transaction_version(),
            )?;
        }

        let (txn_list_with_proof, persisted_aux_info) = txn_list_with_proof.into_parts();
        // Compose enqueue_chunk parameters.
        let TransactionListWithProof {
            transactions,
            events: _,
            first_transaction_version: v,
            proof: txn_infos_with_proof,
        } = txn_list_with_proof;

        let chunk = ChunkToExecute {
            transactions,
            persisted_aux_info,
            first_version: v.ok_or_else(|| anyhow!("first version is None"))?,
        };
        let chunk_verifier = Arc::new(StateSyncChunkVerifier {
            txn_infos_with_proof,
            verified_target_li: verified_target_li.clone(),
            epoch_change_li: epoch_change_li.cloned(),
        });

        // Call the shared implementation.
        self.with_inner(|inner| inner.enqueue_chunk(chunk, chunk_verifier, "execute"))
    }
```

**File:** execution/executor/src/chunk_executor/mod.rs (L295-334)
```rust
    fn enqueue_chunk<Chunk: TransactionChunk + Sync>(
        &self,
        chunk: Chunk,
        chunk_verifier: Arc<dyn ChunkResultVerifier + Send + Sync>,
        mode_for_log: &'static str,
    ) -> Result<()> {
        let parent_state = self.commit_queue.lock().latest_state().clone();

        let first_version = parent_state.next_version();
        ensure!(
            chunk.first_version() == parent_state.next_version(),
            "Chunk carries unexpected first version. Expected: {}, got: {}",
            parent_state.next_version(),
            chunk.first_version(),
        );

        let num_txns = chunk.len();

        let state_view = self.state_view(parent_state.latest())?;
        let execution_output = chunk.into_output::<V>(&parent_state, state_view)?;
        let output = PartialStateComputeResult::new(execution_output);

        // Enqueue for next stage.
        self.commit_queue
            .lock()
            .enqueue_for_ledger_update(ChunkToUpdateLedger {
                output,
                chunk_verifier,
            })?;

        info!(
            LogSchema::new(LogEntry::ChunkExecutor)
                .first_version_in_request(Some(first_version))
                .num_txns_in_request(num_txns),
            mode = mode_for_log,
            "Enqueued transaction chunk!",
        );

        Ok(())
    }
```

**File:** execution/executor/src/chunk_executor/mod.rs (L336-392)
```rust
    pub fn update_ledger(&self) -> Result<()> {
        let _timer = CHUNK_OTHER_TIMERS.timer_with(&["chunk_update_ledger_total"]);

        let (parent_state_summary, parent_accumulator, chunk) =
            self.commit_queue.lock().next_chunk_to_update_ledger()?;
        let ChunkToUpdateLedger {
            output,
            chunk_verifier,
        } = chunk;

        let state_checkpoint_output = DoStateCheckpoint::run(
            &output.execution_output,
            &parent_state_summary,
            &ProvableStateSummary::new_persisted(self.db.reader.as_ref())?,
            Some(
                chunk_verifier
                    .transaction_infos()
                    .iter()
                    .map(|t| t.state_checkpoint_hash())
                    .collect_vec(),
            ),
        )?;

        let ledger_update_output = DoLedgerUpdate::run(
            &output.execution_output,
            &state_checkpoint_output,
            parent_accumulator.clone(),
        )?;

        chunk_verifier.verify_chunk_result(&parent_accumulator, &ledger_update_output)?;

        let ledger_info_opt = chunk_verifier.maybe_select_chunk_ending_ledger_info(
            &ledger_update_output,
            output.execution_output.next_epoch_state.as_ref(),
        )?;
        output.set_state_checkpoint_output(state_checkpoint_output);
        output.set_ledger_update_output(ledger_update_output);

        let first_version = output.execution_output.first_version;
        let num_txns = output.execution_output.num_transactions_to_commit();
        let executed_chunk = ExecutedChunk {
            output,
            ledger_info_opt,
        };

        self.commit_queue
            .lock()
            .save_ledger_update_output(executed_chunk)?;

        info!(
            LogSchema::new(LogEntry::ChunkExecutor)
                .first_version_in_request(Some(first_version))
                .num_txns_in_request(num_txns),
            "Calculated ledger update!",
        );
        Ok(())
    }
```

**File:** execution/executor/src/chunk_executor/chunk_commit_queue.rs (L73-83)
```rust
    pub(crate) fn enqueue_for_ledger_update(
        &mut self,
        chunk_to_update_ledger: ChunkToUpdateLedger,
    ) -> Result<()> {
        let _timer = CHUNK_OTHER_TIMERS.timer_with(&["enqueue_for_ledger_update"]);

        self.latest_state = chunk_to_update_ledger.output.result_state().clone();
        self.to_update_ledger
            .push_back(Some(chunk_to_update_ledger));
        Ok(())
    }
```

**File:** execution/executor-types/src/ledger_update_output.rs (L114-117)
```rust
    pub fn first_version(&self) -> Version {
        self.parent_accumulator.num_leaves
    }
}
```

**File:** execution/executor-types/src/state_compute_result.rs (L158-171)
```rust
    pub fn as_chunk_to_commit(&self) -> ChunkToCommit<'_> {
        ChunkToCommit {
            first_version: self.ledger_update_output.first_version(),
            transactions: &self.execution_output.to_commit.transactions,
            persisted_auxiliary_infos: &self.execution_output.to_commit.persisted_auxiliary_infos,
            transaction_outputs: &self.execution_output.to_commit.transaction_outputs,
            transaction_infos: &self.ledger_update_output.transaction_infos,
            state: &self.execution_output.result_state,
            state_summary: &self.state_checkpoint_output.state_summary,
            state_update_refs: self.execution_output.to_commit.state_update_refs(),
            state_reads: &self.execution_output.state_reads,
            is_reconfig: self.execution_output.next_epoch_state.is_some(),
        }
    }
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L245-261)
```rust
    fn pre_commit_validation(&self, chunk: &ChunkToCommit) -> Result<()> {
        let _timer = OTHER_TIMERS_SECONDS.timer_with(&["save_transactions_validation"]);

        ensure!(!chunk.is_empty(), "chunk is empty, nothing to save.");

        let next_version = self.state_store.current_state_locked().next_version();
        // Ensure the incoming committing requests are always consecutive and the version in
        // buffered state is consistent with that in db.
        ensure!(
            chunk.first_version == next_version,
            "The first version passed in ({}), and the next version expected by db ({}) are inconsistent.",
            chunk.first_version,
            next_version,
        );

        Ok(())
    }
```

**File:** state-sync/state-sync-driver/src/storage_synchronizer.rs (L1026-1064)
```rust
async fn execute_transaction_chunk<ChunkExecutor: ChunkExecutorTrait + 'static>(
    chunk_executor: Arc<ChunkExecutor>,
    transactions_with_proof: TransactionListWithProofV2,
    target_ledger_info: LedgerInfoWithSignatures,
    end_of_epoch_ledger_info: Option<LedgerInfoWithSignatures>,
) -> anyhow::Result<()> {
    // Execute the transaction chunk
    let num_transactions = transactions_with_proof
        .get_transaction_list_with_proof()
        .transactions
        .len();
    let result = tokio::task::spawn_blocking(move || {
        chunk_executor.enqueue_chunk_by_execution(
            transactions_with_proof,
            &target_ledger_info,
            end_of_epoch_ledger_info.as_ref(),
        )
    })
    .await
    .expect("Spawn_blocking(execute_transaction_chunk) failed!");

    // Update the logs and metrics if the chunk was executed successfully
    if result.is_ok() {
        // Log the execution event
        info!(
            LogSchema::new(LogEntry::StorageSynchronizer).message(&format!(
                "Executed a new transaction chunk! Transaction total: {:?}.",
                num_transactions
            ))
        );

        // Update the chunk metrics
        let operation_label =
            metrics::StorageSynchronizerOperations::ExecutedTransactions.get_label();
        update_synchronizer_chunk_metrics(num_transactions, operation_label);
    }

    result
}
```
