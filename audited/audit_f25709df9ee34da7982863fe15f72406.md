# Audit Report

## Title
Event V2 to V1 Translation Produces Off-By-One Sequence Numbers Due to Checkpoint State Timing

## Summary
The `CoinRegisterTranslator` (and other V2 event translators) query the latest state checkpoint to retrieve `AccountResource.coin_register_events().count()` for determining V1 event sequence numbers. However, due to the timing of checkpoint updates relative to transaction processing, the queried counter value reflects state **after** the event was emitted rather than before, causing systematic off-by-one errors in translated V1 event sequence numbers.

## Finding Description

The vulnerability exists in how the `EventV2TranslationEngine` determines sequence numbers for translated V1 events when processing V2 events from committed transactions.

**Event Emission Semantics:**
When a Move `EventHandle` emits an event via `emit_event`, the sequence follows: [1](#0-0) 

The event is written with the **current** counter value (N), then the counter is incremented to N+1. This N+1 value is persisted in the `AccountResource`.

**Translation Flow:**
When the `DBIndexer` processes a transaction containing a V2 `CoinRegister` event: [2](#0-1) 

The translator queries `AccountResource` to get the counter value. This query uses `latest_state_checkpoint_view()`: [3](#0-2) 

Which returns state at the **last checkpoint** version: [4](#0-3) 

**The Critical Timing Issue:**
The checkpoint state can include the transaction being translated when:
1. The transaction triggers a checkpoint (via `sync_commit` or reaching version intervals)
2. The checkpoint is updated in `buffered_state.update()` during `pre_commit_ledger`
3. The `DBIndexer` processes the transaction in the same batch

In this case:
- The `AccountResource` counter = N+1 (after the event was emitted)
- `get_next_sequence_number(&key, N+1)` uses N+1 as the default [5](#0-4) 
- Returns N+1 (when no cache/DB entry exists)
- But the actual V1 event emitted during execution had sequence number **N**
- **Off-by-one error!**

Conversely, when the checkpoint is from **before** the transaction (the common case), the counter would be N, which happens to produce the correct sequence number N through the same logic. This makes the bug subtle and dependent on checkpoint timing.

## Impact Explanation

**Severity: Medium** - "State inconsistencies requiring intervention"

This vulnerability causes:

1. **Event Ordering Violation**: Translated V1 events will have incorrect sequence numbers, breaking the monotonic sequence guarantee that clients rely on for event ordering.

2. **Indexer Data Corruption**: The `EventSequenceNumberSchema` persists incorrect sequence numbers: [6](#0-5) 

Once cached and persisted, subsequent events build on the incorrect base, propagating the error.

3. **API Inconsistency**: Clients querying V1 events via the indexer API will see sequence number gaps or overlaps, potentially causing:
   - Event stream parsing failures
   - Duplicate event processing
   - Missed events due to sequence gaps

4. **No Consensus Impact**: Critically, this does NOT affect consensus because the original V1 events emitted during execution are stored correctly in the main event store. Only the translated/indexed V1 events are affected.

## Likelihood Explanation

**Likelihood: Medium**

The bug occurs when:
1. A transaction emits a V2 event that requires V1 translation
2. The transaction triggers or aligns with a state checkpoint
3. The checkpoint includes the state modifications from that transaction

Given that checkpoints occur every 100,000 versions (TARGET_SNAPSHOT_INTERVAL_IN_VERSION) or on sync commits, the probability per transaction is low (~0.001%). However:
- Every sync_commit transaction is affected
- Transactions near checkpoint boundaries are affected
- The error accumulates in the indexer database over time

## Recommendation

The fix requires querying the state at the transaction version **minus one** to get the counter value **before** the event was emitted:

```rust
pub fn get_state_value_bytes_for_resource_at_version(
    &self,
    address: &AccountAddress,
    struct_tag: &StructTag,
    version: Version, // Transaction version being processed
) -> Result<Option<Bytes>> {
    // Query at version - 1 to get state BEFORE this transaction
    let query_version = version.saturating_sub(1);
    let state_view = self
        .main_db_reader
        .state_view_at_version(Some(query_version))?;
    let state_key = StateKey::resource(address, struct_tag)?;
    let maybe_state_value = state_view.get_state_value(&state_key)?;
    Ok(maybe_state_value.map(|state_value| state_value.bytes().clone()))
}
```

The translator should be modified to pass the transaction version and query the previous version's state to ensure the counter reflects the value **before** the event emission.

## Proof of Concept

The vulnerability can be demonstrated by:

1. Creating a transaction that registers a coin (emitting `CoinRegister` V2 event)
2. Forcing a sync_commit to trigger an immediate checkpoint
3. Processing the transaction through the `DBIndexer`
4. Verifying the translated V1 event has sequence number N+1 instead of N

```rust
// Conceptual PoC - would need integration test framework
#[test]
fn test_sequence_number_off_by_one() {
    // Setup: Account with counter = 5
    // Transaction: register_coin (emits V2 event, counter becomes 6)
    // Force checkpoint at this transaction
    // Process through DBIndexer
    // Verify: Actual V1 event has seq=5, Translated V1 event has seq=6
    assert_ne!(actual_v1_seq, translated_v1_seq); // Off by one
}
```

**Notes**

The vulnerability is subtle because it only manifests when checkpoint timing aligns with transaction processing. The majority of transactions are unaffected (when checkpoints are from earlier versions), which has likely prevented detection. However, the systematic nature of the error for affected transactions creates a reliable data corruption pattern that accumulates in the indexer database over time.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/event.move (L54-60)
```text
    public fun emit_event<T: drop + store>(handle_ref: &mut EventHandle<T>, msg: T) {
        write_to_event_store<T>(bcs::to_bytes(&handle_ref.guid), handle_ref.counter, msg);
        spec {
            assume handle_ref.counter + 1 <= MAX_U64;
        };
        handle_ref.counter += 1;
    }
```

**File:** storage/indexer/src/event_v2_translator.rs (L190-200)
```rust
    pub fn get_next_sequence_number(&self, event_key: &EventKey, default: u64) -> Result<u64> {
        if let Some(seq) = self.get_cached_sequence_number(event_key) {
            Ok(seq + 1)
        } else {
            let seq = self
                .internal_indexer_db
                .get::<EventSequenceNumberSchema>(event_key)?
                .map_or(default, |seq| seq + 1);
            Ok(seq)
        }
    }
```

**File:** storage/indexer/src/event_v2_translator.rs (L202-214)
```rust
    pub fn get_state_value_bytes_for_resource(
        &self,
        address: &AccountAddress,
        struct_tag: &StructTag,
    ) -> Result<Option<Bytes>> {
        let state_view = self
            .main_db_reader
            .latest_state_checkpoint_view()
            .expect("Failed to get state view");
        let state_key = StateKey::resource(address, struct_tag)?;
        let maybe_state_value = state_view.get_state_value(&state_key)?;
        Ok(maybe_state_value.map(|state_value| state_value.bytes().clone()))
    }
```

**File:** storage/indexer/src/event_v2_translator.rs (L324-331)
```rust
        let (key, sequence_number) = if let Some(state_value_bytes) =
            engine.get_state_value_bytes_for_resource(coin_register.account(), &struct_tag)?
        {
            let account_resource: AccountResource = bcs::from_bytes(&state_value_bytes)?;
            let key = *account_resource.coin_register_events().key();
            let sequence_number = engine
                .get_next_sequence_number(&key, account_resource.coin_register_events().count())?;
            (key, sequence_number)
```

**File:** storage/aptosdb/src/db/aptosdb_reader.rs (L812-820)
```rust
    fn get_latest_state_checkpoint_version(&self) -> Result<Option<Version>> {
        gauged_api("get_latest_state_checkpoint_version", || {
            Ok(self
                .state_store
                .current_state_locked()
                .last_checkpoint()
                .version())
        })
    }
```

**File:** storage/indexer/src/db_indexer.rs (L511-521)
```rust
            for event_key in event_keys {
                batch
                    .put::<EventSequenceNumberSchema>(
                        &event_key,
                        &self
                            .event_v2_translation_engine
                            .get_cached_sequence_number(&event_key)
                            .unwrap_or(0),
                    )
                    .expect("Failed to put events by key to a batch");
            }
```
