# Audit Report

## Title
Consensus Split Vulnerability via Silent Deserialization Failure in validator_txn_enabled() Native Function

## Summary
The `validator_txn_enabled()` native function in `consensus_config.rs` uses `unwrap_or_default()` when deserializing the on-chain consensus configuration, silently falling back to a default value (with validator transactions disabled) when deserialization fails. During network upgrades when new `OnChainConsensusConfig` versions are deployed, validators running different code versions will deserialize the same on-chain config differently, causing them to make divergent consensus decisions and violating the Deterministic Execution invariant.

## Finding Description

The vulnerability exists in the native function implementation: [1](#0-0) 

When deserialization fails, the function silently returns `OnChainConsensusConfig::default()`: [2](#0-1) 

This default configuration has validator transactions disabled: [3](#0-2) 

The critical issue manifests in the governance reconfiguration flow where this function determines the execution path: [4](#0-3) 

**Attack Scenario:**

1. The network is running with `OnChainConsensusConfig::V5` that has validator transactions enabled (`ValidatorTxnConfig::V1`)
2. A future version V6 is added to the codebase with additional fields
3. Governance approves and deploys a V6 configuration on-chain via `set_for_next_epoch()` (which only validates non-empty bytes): [5](#0-4) 

4. During the upgrade window, validators are running mixed binary versions:
   - **Upgraded validators**: Have V6 in their enum, successfully deserialize, see `vtxn=enabled`, call `reconfiguration_with_dkg::try_start()`
   - **Non-upgraded validators**: Don't have V6, deserialization fails, fall back to default with `vtxn=disabled`, call `reconfiguration_with_dkg::finish()`

5. The two paths produce completely different state changes:
   - `try_start()` transitions reconfiguration state to Active and starts DKG session: [6](#0-5) 

   - `finish()` clears DKG, applies configs, and immediately reconfigures: [7](#0-6) 

6. Validators compute different state roots for the same `reconfigure()` transaction, causing a permanent consensus split.

## Impact Explanation

**Severity: Critical** - This meets the highest severity criteria for Aptos bug bounty program:

- **Consensus/Safety Violation**: Validators permanently diverge on the global state, breaking the fundamental consensus safety guarantee
- **Non-recoverable Network Partition**: The network splits into two incompatible chains that cannot reconcile, requiring a hardfork to recover
- **Deterministic Execution Violation**: Identical transactions produce different state roots depending on binary version

The impact is severe because:
1. All validators executing the `reconfigure()` transaction will diverge
2. The divergence affects core reconfiguration state and DKG session management
3. Recovery requires coordinated emergency intervention and likely a hardfork
4. The issue is silent - no errors are logged, making diagnosis difficult

## Likelihood Explanation

**Likelihood: Medium-High** during network upgrades

The vulnerability triggers whenever:
1. A new `OnChainConsensusConfig` enum variant is added (happens during major upgrades)
2. The new config is deployed on-chain before 100% of validators have upgraded
3. A governance `reconfigure()` call is made during the mixed-version window

This is likely because:
- Blockchain upgrades routinely add new config versions
- Perfect synchronization of all validator upgrades is practically impossible
- There's a window of several hours/days where validators run mixed versions
- The `set_for_next_epoch()` function provides no validation against this scenario
- No runtime checks prevent deploying configs incompatible with running validators

## Recommendation

**Immediate Fix**: Add explicit deserialization error handling that prevents silent failures:

```rust
pub fn validator_txn_enabled(
    _context: &mut SafeNativeContext,
    _ty_args: &[Type],
    mut args: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    let config_bytes = safely_pop_arg!(args, Vec<u8>);
    
    // CRITICAL: Do not silently fall back to default
    let config = match bcs::from_bytes::<OnChainConsensusConfig>(&config_bytes) {
        Ok(c) => c,
        Err(e) => {
            // Log error and abort transaction rather than returning wrong value
            return Err(SafeNativeError::Abort { 
                abort_code: 0x030001 // ECONFIG_DESERIALIZATION_FAILED
            });
        }
    };
    
    Ok(smallvec![Value::bool(config.is_vtxn_enabled())])
}
```

**Long-term Solutions**:

1. **Add config version validation** in `set_for_next_epoch()` to verify all validators can deserialize the proposed config before accepting it
2. **Implement version compatibility checks** in the framework to reject configs with unsupported versions
3. **Add on-chain validator version tracking** to prevent deploying configs incompatible with the current validator set
4. **Use explicit version negotiation** rather than blind deserialization with fallback

## Proof of Concept

```rust
// Reproduction test for consensus_config.rs
#[test]
fn test_deserialization_mismatch_vulnerability() {
    use aptos_types::on_chain_config::OnChainConsensusConfig;
    use move_core_types::value::MoveValue;
    
    // Simulate V5 config with vtxn enabled
    let config_v5 = OnChainConsensusConfig::V5 {
        alg: ConsensusAlgorithmConfig::default_for_genesis(),
        vtxn: ValidatorTxnConfig::default_for_genesis(), // Enabled
        window_size: None,
        rand_check_enabled: true,
    };
    
    let serialized = bcs::to_bytes(&config_v5).unwrap();
    
    // Simulate old validator code by manually creating invalid variant tag
    // This represents what happens when old code sees new enum variant
    let mut corrupted = serialized.clone();
    corrupted[0] = 99; // Invalid variant tag (simulates V6 seen by V5 code)
    
    // Old behavior with unwrap_or_default
    let result_old = bcs::from_bytes::<OnChainConsensusConfig>(&corrupted)
        .unwrap_or_default();
    
    // Verify it falls back to V4 with vtxn disabled
    assert!(!result_old.is_vtxn_enabled()); // FALSE
    
    // Meanwhile, new validators deserialize correctly
    let result_new = bcs::from_bytes::<OnChainConsensusConfig>(&serialized).unwrap();
    assert!(result_new.is_vtxn_enabled()); // TRUE
    
    // CONSENSUS SPLIT: Same on-chain bytes, different interpretation!
    assert_ne!(result_old.is_vtxn_enabled(), result_new.is_vtxn_enabled());
}
```

**Notes:**

This vulnerability is a **forward compatibility design flaw** that becomes exploitable during network upgrades. While not immediately exploitable in a single-version network, it represents a critical weakness in the upgrade coordination mechanism. The lack of proper validation and error handling creates a time bomb that will detonate during the next `OnChainConsensusConfig` schema upgrade.

The proper security posture requires treating deserialization failures as fatal errors rather than silently substituting default values, especially for consensus-critical configuration that affects execution paths.

### Citations

**File:** aptos-move/framework/src/natives/consensus_config.rs (L13-21)
```rust
pub fn validator_txn_enabled(
    _context: &mut SafeNativeContext,
    _ty_args: &[Type],
    mut args: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    let config_bytes = safely_pop_arg!(args, Vec<u8>);
    let config = bcs::from_bytes::<OnChainConsensusConfig>(&config_bytes).unwrap_or_default();
    Ok(smallvec![Value::bool(config.is_vtxn_enabled())])
}
```

**File:** types/src/on_chain_config/consensus_config.rs (L147-149)
```rust
    pub fn default_if_missing() -> Self {
        Self::V0
    }
```

**File:** types/src/on_chain_config/consensus_config.rs (L443-450)
```rust
impl Default for OnChainConsensusConfig {
    fn default() -> Self {
        OnChainConsensusConfig::V4 {
            alg: ConsensusAlgorithmConfig::default_if_missing(),
            vtxn: ValidatorTxnConfig::default_if_missing(),
            window_size: DEFAULT_WINDOW_SIZE,
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L685-692)
```text
    public entry fun reconfigure(aptos_framework: &signer) {
        system_addresses::assert_aptos_framework(aptos_framework);
        if (consensus_config::validator_txn_enabled() && randomness_config::enabled()) {
            reconfiguration_with_dkg::try_start();
        } else {
            reconfiguration_with_dkg::finish(aptos_framework);
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/consensus_config.move (L52-56)
```text
    public fun set_for_next_epoch(account: &signer, config: vector<u8>) {
        system_addresses::assert_aptos_framework(account);
        assert!(vector::length(&config) > 0, error::invalid_argument(EINVALID_CONFIG));
        std::config_buffer::upsert<ConsensusConfig>(ConsensusConfig {config});
    }
```

**File:** aptos-move/framework/aptos-framework/sources/reconfiguration_with_dkg.move (L24-40)
```text
    public(friend) fun try_start() {
        let incomplete_dkg_session = dkg::incomplete_session();
        if (option::is_some(&incomplete_dkg_session)) {
            let session = option::borrow(&incomplete_dkg_session);
            if (dkg::session_dealer_epoch(session) == reconfiguration::current_epoch()) {
                return
            }
        };
        reconfiguration_state::on_reconfig_start();
        let cur_epoch = reconfiguration::current_epoch();
        dkg::start(
            cur_epoch,
            randomness_config::current(),
            stake::cur_validator_consensus_infos(),
            stake::next_validator_consensus_infos(),
        );
    }
```

**File:** aptos-move/framework/aptos-framework/sources/reconfiguration_with_dkg.move (L46-61)
```text
    public(friend) fun finish(framework: &signer) {
        system_addresses::assert_aptos_framework(framework);
        dkg::try_clear_incomplete_session(framework);
        consensus_config::on_new_epoch(framework);
        execution_config::on_new_epoch(framework);
        gas_schedule::on_new_epoch(framework);
        std::version::on_new_epoch(framework);
        features::on_new_epoch(framework);
        jwk_consensus_config::on_new_epoch(framework);
        jwks::on_new_epoch(framework);
        keyless_account::on_new_epoch(framework);
        randomness_config_seqnum::on_new_epoch(framework);
        randomness_config::on_new_epoch(framework);
        randomness_api_v0_config::on_new_epoch(framework);
        reconfiguration::reconfigure();
    }
```
