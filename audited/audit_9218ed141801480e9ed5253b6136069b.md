# Audit Report

## Title
Move Prover Loop Unrolling Creates Verification Gaps Through Bounded Verification

## Summary
The Move Prover's loop unrolling feature provides only bounded verification, where loops are verified up to a specified iteration count. Code paths beyond this limit remain unverified, creating verification gaps that could allow buggy contracts to pass formal verification and be deployed with undiscovered vulnerabilities.

## Finding Description

The `unroll()` function in the Move Prover's loop analysis pipeline implements bounded loop verification that explicitly limits verification to a pre-defined number of iterations: [1](#0-0) 

When developers specify loop unrolling via `pragma unroll = N` or `invariant [unroll = N] true`, the prover only verifies the first N iterations. After N iterations, a `Stop` operation terminates verification: [2](#0-1) [3](#0-2) 

**Concrete Example from Test Suite:**

The test suite explicitly demonstrates this verification gap: [4](#0-3) 

This function has `assert!(i != 5, 0)` that will abort when i=5. With `unroll = 3`, the prover only checks iterations 0, 1, 2, and never reaches i=5. The specification claims `aborts_if false` (never aborts), but this is **incorrect** for n ≥ 5. Yet the prover accepts this false specification because it stops verification after 3 iterations.

When unroll count is increased to 6, the same code correctly fails verification: [5](#0-4) 

**Production Usage:**

The Aptos Framework uses loop unrolling in critical randomness functions: [6](#0-5) [7](#0-6) 

**Critical Documentation Gap:**

Despite this feature being used in production, there is **no user-facing documentation** warning developers about bounded verification. The Move Specification Language documentation does not mention "unroll", "bounded", or "partial" verification at all. Developers may incorrectly assume that adding loop unrolling pragmas provides complete verification.

## Impact Explanation

This represents **Medium Severity** per Aptos Bug Bounty criteria:

1. **State Inconsistencies**: Contracts verified with insufficient unroll counts may have bugs in later iterations that cause state corruption at runtime, requiring intervention.

2. **Limited Funds Loss**: Financial contracts (staking, vaults, DeFi protocols) with loop-based logic could have bugs beyond the unroll count that manifest as:
   - Incorrect balance calculations after N transactions
   - Failed withdrawal processing for user N+1
   - Reward distribution errors in large validator sets

3. **False Security Guarantee**: Developers deploy contracts marked as "formally verified" with a false sense of security, when critical execution paths remain unverified.

**Example Attack Scenario:**

A developer writes a staking rewards contract:
```move
public fun distribute_rewards(validators: vector<Validator>) {
    let i = 0;
    while ({
        spec { invariant [unroll = 10] true; };
        (i < vector::length(&validators))
    }) {
        process_validator_reward(vector::borrow(&validators, i));
        i = i + 1;
    };
}
```

Developer sets `unroll = 10` thinking "most epochs have ~10 validators". Prover verifies. Contract deployed. Network grows to 15 validators. Bug in `process_validator_reward` at position 11+ causes incorrect reward calculation. Funds distributed incorrectly.

## Likelihood Explanation

**Likelihood: Medium**

**Factors increasing likelihood:**
1. No warnings when developers use loop unrolling
2. Zero user-facing documentation about bounded verification limitations
3. Feature used in production Aptos Framework code
4. Natural developer assumption that "verified = fully verified"
5. Complex contracts with input-dependent loop counts are common

**Factors decreasing likelihood:**
1. Framework code uses exact loop counts matching unroll pragmas (appears safe)
2. Sophisticated developers may understand the limitation from code inspection
3. Requires both insufficient unroll count AND a bug in unverified iterations

**Overall**: The lack of documentation and warnings makes developer error highly probable, but exploitation requires additional bugs in the contract logic.

## Recommendation

**Immediate Actions:**

1. **Add Prominent Warnings**: When `pragma unroll` or `invariant [unroll = N]` is used, emit a compiler warning:
```
Warning: Loop unrolling provides BOUNDED verification only. 
Code beyond iteration N is NOT verified. Ensure loop never exceeds N iterations,
or use loop invariants instead for complete verification.
```

2. **Update Documentation**: Add a dedicated section to `spec-lang.md`:
```markdown
### Loop Unrolling (Bounded Verification)

WARNING: Loop unrolling provides bounded verification only. When you specify
`pragma unroll = N`, the prover verifies only the first N iterations.
If your loop can iterate more than N times, the behavior beyond iteration N
is UNVERIFIED and may contain bugs.

Use loop unrolling only when:
- Loop has a guaranteed maximum iteration count ≤ N
- Loop count is compile-time constant
- You fully understand the verification limitations

For variable-length loops, use loop invariants instead.
```

3. **Runtime Assertion**: For development builds, consider adding optional runtime checks:
```rust
if iteration_count > unroll_count {
    emit_warning!("Loop exceeded unroll count; behavior is unverified");
}
```

4. **Code Review**: Audit all uses of `pragma unroll` in Aptos Framework to ensure loop counts can never exceed unroll limits.

## Proof of Concept

The vulnerability is already demonstrated in the test suite: [4](#0-3) 

**Reproduction Steps:**

1. Navigate to `third_party/move/move-prover/tests/sources/functional/`
2. Observe `loop_unroll.move` function `t5_success`
3. Run Move Prover: It PASSES verification despite incorrect `aborts_if false` spec
4. Compare with `t6_failure` (identical code, `unroll = 6`): It correctly FAILS verification
5. This proves verification gaps exist when unroll count is insufficient

**Expected Output:**
- With `unroll = 3`: Prover succeeds (false negative - bug not detected)
- With `unroll = 6`: Prover fails (correct - bug detected at i=5)

## Notes

**Severity Classification**: While this is documented as expected behavior in code comments, the **complete absence of user-facing documentation and warnings** elevates this to a security concern. Developers cannot be expected to read internal implementation comments to understand critical verification limitations.

**Framework Impact**: The Aptos Framework's use of loop unrolling appears safe because unroll counts exactly match fixed loop iterations. However, any future changes that increase loop bounds could silently break verification guarantees.

**Distinction from Loop Invariants**: Loop invariants provide complete inductive verification for any number of iterations. Loop unrolling is fundamentally limited and should be reserved for performance optimization of loops with provably bounded iteration counts.

### Citations

**File:** third_party/move/move-prover/bytecode-pipeline/src/loop_analysis.rs (L347-358)
```rust
    /// Perform unrolling on the loop (if explicitly requested).
    ///
    /// NOTE: this turns verification into *bounded* verification. All verification conditions post
    /// loop exit is only conditionally verified, conditioned when loop exits within a pre-defined
    /// number of iteration. If the loop iterates more than the pre-defined limit, the prover will
    /// not attempt to prove (or disprove) those verification conditions.
    fn unroll(
        func_env: &FunctionEnv<'_>,
        data: FunctionData,
        loop_header: &Label,
        unrolling_mark: &LoopUnrollingMark,
    ) -> FunctionData {
```

**File:** third_party/move/move-prover/bytecode-pipeline/src/loop_analysis.rs (L377-392)
```rust
        // create the stop block
        let stop_label = builder.new_label();
        builder.set_next_debug_comment(format!(
            "End of bounded loop unrolling for loop: L{}",
            loop_header.as_usize()
        ));
        builder.emit_with(|attr_id| Bytecode::Label(attr_id, stop_label));
        builder.clear_next_debug_comment();

        builder.emit_with(|attr_id| {
            if options.for_interpretation {
                Bytecode::Jump(attr_id, *loop_header)
            } else {
                Bytecode::Call(attr_id, vec![], Operation::Stop, vec![], None)
            }
        });
```

**File:** third_party/move/move-prover/bytecode-pipeline/src/loop_analysis.rs (L401-402)
```rust
        // the last back edge points to the stop block
        label_remapping.insert((*loop_header, unrolling_mark.iter_count), stop_label);
```

**File:** third_party/move/move-prover/tests/sources/functional/loop_unroll.move (L70-86)
```text
    fun t5_success(n: u64): u64 {
        let i = 0;
        while ({
            spec {
                invariant [unroll = 3] true;
            };
            (i < n)
        }) {
            i = i + 1;
            assert!(i != 5, 0);
        };
        i
    }
    spec t5_success {
        // this is expected, as we only unroll the loop 3 times
        aborts_if false;
    }
```

**File:** third_party/move/move-prover/tests/sources/functional/loop_unroll.move (L88-104)
```text
    fun t6_failure(n: u64): u64 {
        let i = 0;
        while ({
            spec {
                invariant [unroll = 6] true;
            };
            (i < n)
        }) {
            i = i + 1;
            assert!(i != 5, 0);
        };
        i
    }
    spec t6_failure {
        // this will not hold when we increase the unroll count
        aborts_if false;
    }
```

**File:** aptos-move/framework/aptos-framework/sources/randomness.spec.move (L63-80)
```text
    spec u16_integer(): u16 {
        pragma unroll = 2;
        include NextBlobAbortsIf;
    }

    spec u32_integer(): u32 {
        pragma unroll = 4;
        include NextBlobAbortsIf;
    }

    spec u64_integer(): u64 {
        pragma unroll = 8;
        include NextBlobAbortsIf;
    }

    spec u128_integer(): u128 {
        pragma unroll = 16;
        include NextBlobAbortsIf;
```

**File:** aptos-move/framework/aptos-framework/sources/randomness.move (L119-132)
```text
    /// Generates an u16 uniformly at random.
    public fun u16_integer(): u16 acquires PerBlockRandomness {
        let raw = next_32_bytes();
        let i = 0;
        let ret: u16 = 0;
        while (i < 2) {
            ret = ret * 256 + (vector::pop_back(&mut raw) as u16);
            i = i + 1;
        };

        event::emit(RandomnessGeneratedEvent {});

        ret
    }
```
