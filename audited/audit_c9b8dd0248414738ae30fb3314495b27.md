# Audit Report

## Title
Direct Coin Transfer Opt-Out Bypass via Fungible Asset Migration

## Summary
The migration from CoinStore to FungibleAsset has broken the `can_receive_direct_coin_transfers` protection mechanism. Users who explicitly opt out of receiving arbitrary coin types can still receive them, violating documented security controls and enabling token spam attacks.

## Finding Description

The Aptos Framework provides a documented mechanism for users to opt out of receiving unsolicited coin transfers via `set_allow_direct_coin_transfers(account, false)`. This security control is stored in the `DirectTransferConfig` resource and is intended to give users control over what coins they accept. [1](#0-0) 

However, this protection is completely bypassed due to the fungible asset migration.

**Root Cause:**

The `coin::is_account_registered<CoinType>` function has been modified to always return `true` after verifying coin initialization: [2](#0-1) 

Note that the `_account_addr` parameter is unused (prefixed with underscore), and the function unconditionally returns `true` after the coin type validation.

**Broken Protection Logic:**

In `aptos_account::deposit_coins`, the protection check is supposed to verify user consent before depositing unregistered coin types: [3](#0-2) 

Since `is_account_registered` always returns `true`, the condition `!coin::is_account_registered<CoinType>(to)` is always `false`. Therefore, the assertion checking `can_receive_direct_coin_transfers(to)` at lines 141-143 **never executes**. The code proceeds directly to `coin::deposit<CoinType>(to, coins)` at line 147, bypassing the user's documented security preference.

**The Opt-Out Mechanism:**

Users can configure their preference via the public entry function: [4](#0-3) 

The check function that should be enforced: [5](#0-4) 

This function returns `false` when a user has explicitly set `allow_arbitrary_coin_transfers: false`, but due to the bypass in `deposit_coins`, this check is never evaluated.

**Execution Flow:**

1. Attacker calls coin transfer to victim who has opted out
2. `deposit_coins` checks `!is_account_registered<CoinType>(to)` â†’ always false
3. Protection check bypassed
4. `coin::deposit` proceeds, converting coin to fungible asset [6](#0-5) 
5. Primary fungible store auto-created if needed [7](#0-6) 
6. Victim receives unwanted coins despite explicit opt-out

## Impact Explanation

This qualifies as **Medium Severity** per the Aptos bug bounty criteria ("State inconsistencies requiring manual intervention"):

1. **Security Control Bypass**: A documented security mechanism (error code EACCOUNT_DOES_NOT_ACCEPT_DIRECT_COIN_TRANSFERS exists at line 27) is completely ineffective. [8](#0-7) 

2. **User Consent Violation**: Users who explicitly configure their accounts to reject arbitrary coins have their preferences ignored

3. **Token Spam Attack Vector**: Attackers can force any account to receive arbitrary tokens, including scam tokens, phishing tokens, or unwanted airdrops

4. **Manual Intervention Required**: Users must manually manage and dispose of unwanted tokens, constituting a state inconsistency requiring intervention

5. **Privacy Breach**: Users cannot control their on-chain token exposure, potentially revealing relationships or attracting unwanted attention

This does not qualify as Critical or High severity because:
- No direct loss of funds occurs
- No consensus violations
- No permanent freezing of assets
- Users can still transfer out unwanted tokens

However, it meets Medium severity as it creates unwanted blockchain state that requires manual cleanup and violates documented security guarantees that users rely upon.

## Likelihood Explanation

**Likelihood: HIGH**

- **Affects All Users**: Every coin transfer in the current codebase is affected
- **No Privileges Required**: Any user can exploit this by simply transferring coins
- **Trivial Execution**: Standard SDK functions execute the bypass automatically
- **Complete Protection Failure**: Users who opted out are 100% unprotected
- **Documented Feature**: The opt-out mechanism is documented, users rely on it, yet it provides zero protection
- **No Preconditions**: Works against any account regardless of configuration or state

## Recommendation

Restore the protection check by fixing `coin::is_account_registered` to properly check account registration status, or alternatively, move the `can_receive_direct_coin_transfers` check to occur before the current short-circuit logic.

**Option 1**: Fix the deposit_coins logic to always check DirectTransferConfig before attempting deposit:

```move
public fun deposit_coins<CoinType>(to: address, coins: Coin<CoinType>) acquires DirectTransferConfig {
    if (!account::exists_at(to)) {
        create_account(to);
    };
    
    // Always check consent for unregistered coin types
    if (!coin::is_account_registered<CoinType>(to)) {
        assert!(
            can_receive_direct_coin_transfers(to),
            error::permission_denied(EACCOUNT_DOES_NOT_ACCEPT_DIRECT_COIN_TRANSFERS)
        );
    };
    
    // Check consent even if "registered" due to FA migration
    if (!primary_fungible_store::primary_store_exists(to, coin::paired_metadata<CoinType>())) {
        assert!(
            can_receive_direct_coin_transfers(to),
            error::permission_denied(EACCOUNT_DOES_NOT_ACCEPT_DIRECT_COIN_TRANSFERS)
        );
    };
    
    coin::deposit<CoinType>(to, coins)
}
```

**Option 2**: Check at the primary_fungible_store level by implementing consent checks in the fungible asset deposit flow.

## Proof of Concept

```move
#[test_only]
module aptos_framework::direct_transfer_bypass_test {
    use aptos_framework::aptos_account;
    use aptos_framework::aptos_coin::AptosCoin;
    use aptos_framework::coin;
    use std::signer;

    #[test(framework = @aptos_framework, alice = @0xa11ce, bob = @0xb0b)]
    fun test_bypass_direct_transfer_opt_out(framework: &signer, alice: &signer, bob: &signer) {
        // Setup accounts
        let alice_addr = signer::address_of(alice);
        let bob_addr = signer::address_of(bob);
        
        aptos_account::create_account(alice_addr);
        aptos_account::create_account(bob_addr);
        
        // Bob explicitly opts out of receiving arbitrary coins
        aptos_account::set_allow_direct_coin_transfers(bob, false);
        
        // Verify Bob has opted out
        assert!(!aptos_account::can_receive_direct_coin_transfers(bob_addr), 0);
        
        // Alice tries to send coins to Bob - this SHOULD fail but DOESN'T
        let coins = coin::mint<AptosCoin>(100, framework);
        
        // This call succeeds even though Bob opted out
        aptos_account::deposit_coins<AptosCoin>(bob_addr, coins);
        
        // Bob now has coins despite opting out - VULNERABILITY CONFIRMED
        assert!(coin::balance<AptosCoin>(bob_addr) == 100, 1);
    }
}
```

## Notes

The fungible asset migration has fundamentally changed how coin registration works, making `is_account_registered` always return true. While this may be intentional for the migration, it has the unintended consequence of disabling the DirectTransferConfig security control that users rely upon. This represents a breaking change to documented security guarantees without corresponding updates to the protection logic.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/aptos_account.move (L26-27)
```text
    /// Account opted out of receiving coins that they did not register to receive.
    const EACCOUNT_DOES_NOT_ACCEPT_DIRECT_COIN_TRANSFERS: u64 = 3;
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_account.move (L33-39)
```text
    /// Configuration for whether an account can receive direct transfers of coins that they have not registered.
    ///
    /// By default, this is enabled. Users can opt-out by disabling at any time.
    struct DirectTransferConfig has key {
        allow_arbitrary_coin_transfers: bool,
        update_coin_transfer_events: EventHandle<DirectCoinTransferConfigUpdatedEvent>
    }
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_account.move (L140-147)
```text
        if (!coin::is_account_registered<CoinType>(to)) {
            assert!(
                can_receive_direct_coin_transfers(to),
                error::permission_denied(EACCOUNT_DOES_NOT_ACCEPT_DIRECT_COIN_TRANSFERS)
            );
            coin::register<CoinType>(&create_signer(to));
        };
        coin::deposit<CoinType>(to, coins)
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_account.move (L208-210)
```text
    public entry fun set_allow_direct_coin_transfers(
        account: &signer, allow: bool
    ) acquires DirectTransferConfig {
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_account.move (L264-269)
```text
    public fun can_receive_direct_coin_transfers(
        account: address
    ): bool acquires DirectTransferConfig {
        !exists<DirectTransferConfig>(account)
            || borrow_global<DirectTransferConfig>(account).allow_arbitrary_coin_transfers
    }
```

**File:** aptos-move/framework/aptos-framework/sources/coin.move (L808-814)
```text
    public fun is_account_registered<CoinType>(_account_addr: address): bool {
        assert!(
            is_coin_initialized<CoinType>(),
            error::invalid_argument(ECOIN_INFO_NOT_PUBLISHED)
        );
        true
    }
```

**File:** aptos-move/framework/aptos-framework/sources/coin.move (L914-918)
```text
    public fun deposit<CoinType>(
        account_addr: address, coin: Coin<CoinType>
    ) acquires CoinConversionMap, CoinInfo {
        primary_fungible_store::deposit(account_addr, coin_to_fungible_asset(coin));
    }
```

**File:** aptos-move/framework/aptos-framework/sources/primary_fungible_store.move (L195-199)
```text
    public fun deposit(owner: address, fa: FungibleAsset) acquires DeriveRefPod {
        let metadata = fa.asset_metadata();
        let store = ensure_primary_store_exists(owner, metadata);
        dispatchable_fungible_asset::deposit(store, fa);
    }
```
