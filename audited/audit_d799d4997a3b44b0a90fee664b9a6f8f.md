# Audit Report

## Title
Peer Reputation Bypass via Invalid Feedback Handling in Stream Termination

## Summary
When `process_terminate_stream_request()` processes notification feedback for empty payload data, the stream is removed before feedback validation. If `handle_notification_feedback()` fails due to unsupported feedback types (specifically `EmptyPayloadData`), the malicious peer that sent the bad data is never penalized through the peer scoring system, even though the stream is already removed.

## Finding Description

The vulnerability exists in the stream termination flow where feedback processing occurs **after** stream removal. The code flow is: [1](#0-0) 

When a malicious peer sends empty payload data to an honest node:

1. The state sync driver correctly detects the empty payload: [2](#0-1) 

2. It calls stream termination with `EmptyPayloadData` feedback: [3](#0-2) 

3. The streaming service removes the stream from the HashMap immediately (line 220), then attempts to process the feedback

4. The feedback processing calls `handle_notification_feedback()`: [4](#0-3) 

5. This calls `extract_response_error()` which **fails** for `EmptyPayloadData` because it's not in the match arms: [5](#0-4) 

6. The error propagates via the `?` operator, causing the entire termination to fail **after** the stream was already removed

7. Critically, `notify_bad_response()` is never called: [6](#0-5) 

8. The malicious peer's score remains unchanged, avoiding penalties that would normally occur: [7](#0-6) 

The `NotificationFeedback` enum includes `EmptyPayloadData` as a valid variant: [8](#0-7) 

Yet it's explicitly used by production code but not handled in `extract_response_error()`, creating a gap where legitimate feedback cannot be processed.

## Impact Explanation

**Medium Severity** - This constitutes a state inconsistency in the peer reputation system:

- Malicious peers can repeatedly send empty payloads without penalty
- The peer scoring mechanism fails to downgrade malicious peers, violating its security guarantee
- Over time with multiple malicious peers, this degrades network health and can contribute to liveness issues
- While not directly causing consensus violations or fund loss, it undermines a critical defense mechanism against malicious network participants
- The peer reputation system is designed to protect validator nodes from resource exhaustion and data quality attacks

This maps to **Medium Severity** in the Aptos bug bounty program: "State inconsistencies requiring intervention" - the peer reputation state becomes inconsistent with actual peer behavior.

## Likelihood Explanation

**High Likelihood**:
- Any peer can send empty payloads at any time (no special privileges required)
- The state sync driver legitimately uses `EmptyPayloadData` feedback in production code
- The bug triggers on every occurrence of empty payload data from peers
- No special timing or race conditions are required
- The vulnerability is deterministic and will occur 100% of the time when a peer sends empty data

## Recommendation

Add `EmptyPayloadData` to the `extract_response_error()` match statement:

```rust
fn extract_response_error(
    notification_feedback: &NotificationFeedback,
) -> Result<ResponseError, Error> {
    match notification_feedback {
        NotificationFeedback::InvalidPayloadData => Ok(ResponseError::InvalidData),
        NotificationFeedback::PayloadTypeIsIncorrect => Ok(ResponseError::InvalidPayloadDataType),
        NotificationFeedback::PayloadProofFailed => Ok(ResponseError::ProofVerificationError),
        NotificationFeedback::EmptyPayloadData => Ok(ResponseError::InvalidData), // ADD THIS
        _ => Err(Error::UnexpectedErrorEncountered(format!(
            "Invalid notification feedback given: {:?}",
            notification_feedback
        ))),
    }
}
```

Alternatively, move the stream removal **after** successful feedback processing, or ensure feedback processing failure doesn't prevent peer penalization:

```rust
fn process_terminate_stream_request(
    &mut self,
    terminate_request: &TerminateStreamRequest,
) -> Result<(), Error> {
    let data_stream_id = &terminate_request.data_stream_id;
    let notification_and_feedback = &terminate_request.notification_and_feedback;

    // Get the stream (but don't remove it yet)
    let data_stream = self.data_streams.get(data_stream_id).ok_or_else(|| {
        Error::UnexpectedErrorEncountered(format!(
            "Unable to find data stream with ID: {:?}",
            data_stream_id
        ))
    })?;

    // Handle feedback BEFORE removing stream
    if let Some(notification_and_feedback) = notification_and_feedback {
        let notification_id = &notification_and_feedback.notification_id;
        let feedback = &notification_and_feedback.notification_feedback;
        if data_stream.sent_notification(notification_id) {
            data_stream.handle_notification_feedback(notification_id, feedback)?;
        } else {
            return Err(Error::UnexpectedErrorEncountered(format!(
                "Data stream ID: {:?} did not appear to send notification ID: {:?}",
                data_stream_id, notification_id,
            )));
        }
    }

    // NOW remove the stream after successful feedback processing
    self.data_streams.remove(data_stream_id);
    
    Ok(())
}
```

## Proof of Concept

```rust
#[tokio::test]
async fn test_empty_payload_feedback_bypasses_peer_penalty() {
    use crate::streaming_service::DataStreamingService;
    use crate::streaming_client::{NotificationAndFeedback, NotificationFeedback, TerminateStreamRequest};
    use crate::tests::streaming_service;
    
    // Create streaming service
    let (_, mut streaming_service) = 
        streaming_service::create_streaming_client_and_server(None, false, false, true, false);
    
    // Create a data stream
    let (new_stream_request, response_receiver) = create_new_stream_request();
    streaming_service.handle_stream_request_message(
        new_stream_request,
        create_stream_update_notifier(),
    );
    let stream_listener = response_receiver.now_or_never().unwrap().unwrap().unwrap();
    let stream_id = stream_listener.data_stream_id;
    
    // Advance stream to get a notification
    streaming_service.check_progress_of_all_data_streams().await;
    let notification = timeout(Duration::from_secs(5), stream_listener.select_next_some())
        .await
        .unwrap();
    
    // Attempt to terminate with EmptyPayloadData feedback
    let feedback = NotificationAndFeedback {
        notification_id: notification.notification_id,
        notification_feedback: NotificationFeedback::EmptyPayloadData,
    };
    let terminate_request = TerminateStreamRequest {
        data_stream_id: stream_id,
        notification_and_feedback: Some(feedback),
    };
    
    // This will fail internally but stream is still removed
    let result = streaming_service.process_terminate_stream_request(&terminate_request);
    
    // BUG: Stream is removed even though feedback processing failed
    assert!(streaming_service.data_streams.get(&stream_id).is_none());
    
    // BUG: The function returns an error, meaning peer was NOT penalized
    assert!(result.is_err());
    
    // Expected: Peer should have been penalized via notify_bad_response()
    // Actual: Peer escapes penalty because feedback processing failed
}
```

## Notes

This vulnerability is confirmed by the existing test case which explicitly verifies that "stream termination [occurs] even if invalid feedback is given": [9](#0-8) 

The test demonstrates awareness of this behavior but treats it as acceptable, when it actually creates a security vulnerability in the peer reputation system.

### Citations

**File:** state-sync/data-streaming-service/src/streaming_service.rs (L220-241)
```rust
        if let Some(data_stream) = self.data_streams.remove(data_stream_id) {
            info!(LogSchema::new(LogEntry::HandleTerminateRequest)
                .stream_id(*data_stream_id)
                .event(LogEvent::Success)
                .message(&format!(
                    "Terminating the data stream with ID: {:?}. Notification and feedback: {:?}",
                    data_stream_id, notification_and_feedback,
                )));

            // Handle any notification feedback
            if let Some(notification_and_feedback) = notification_and_feedback {
                let notification_id = &notification_and_feedback.notification_id;
                let feedback = &notification_and_feedback.notification_feedback;
                if data_stream.sent_notification(notification_id) {
                    data_stream.handle_notification_feedback(notification_id, feedback)?;
                    Ok(())
                } else {
                    Err(Error::UnexpectedErrorEncountered(format!(
                        "Data stream ID: {:?} did not appear to send notification ID: {:?}",
                        data_stream_id, notification_id,
                    )))
                }
```

**File:** state-sync/data-streaming-service/src/streaming_service.rs (L726-791)
```rust
    async fn test_terminate_data_streams_feedback() {
        // Verify stream termination even if invalid feedback is given (i.e., id mismatch)
        for enable_subscription_stream in [false, true] {
            for invalid_feedback in [false, true] {
                // Create a new streaming service
                let (_, mut streaming_service) =
                    tests::streaming_service::create_streaming_client_and_server(
                        None,
                        false,
                        false,
                        true,
                        enable_subscription_stream,
                    );

                // Create multiple data streams
                let num_data_streams = 10;
                let mut stream_ids_and_listeners = vec![];
                for _ in 0..num_data_streams {
                    // Create a new data stream
                    let (new_stream_request, response_receiver) = create_new_stream_request();
                    streaming_service.handle_stream_request_message(
                        new_stream_request,
                        create_stream_update_notifier(),
                    );
                    let data_stream_listener =
                        response_receiver.now_or_never().unwrap().unwrap().unwrap();
                    let data_stream_id = data_stream_listener.data_stream_id;

                    // Remember the data stream id and listener
                    stream_ids_and_listeners.push((data_stream_id, data_stream_listener));
                }

                // Fetch a notification from each data stream and terminate the stream
                for (data_stream_id, data_stream_listener) in &mut stream_ids_and_listeners {
                    let timeout_deadline =
                        Instant::now().add(Duration::from_secs(MAX_STREAM_WAIT_SECS));
                    while Instant::now() < timeout_deadline {
                        streaming_service.check_progress_of_all_data_streams().await;
                        if let Ok(data_notification) = timeout(
                            Duration::from_secs(1),
                            data_stream_listener.select_next_some(),
                        )
                        .await
                        {
                            // Terminate the data stream
                            let notification_id = if invalid_feedback {
                                10101010 // Invalid notification id
                            } else {
                                data_notification.notification_id
                            };
                            let notification_and_feedback = Some(NotificationAndFeedback {
                                notification_id,
                                notification_feedback: NotificationFeedback::InvalidPayloadData,
                            });
                            let (terminate_stream_request, _) = create_terminate_stream_request(
                                *data_stream_id,
                                notification_and_feedback,
                            );
                            streaming_service.handle_stream_request_message(
                                terminate_stream_request,
                                create_stream_update_notifier(),
                            );

                            // Verify the stream has been removed
                            let all_data_stream_ids = streaming_service.get_all_data_stream_ids();
                            assert!(!all_data_stream_ids.contains(data_stream_id));
```

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L1080-1090)
```rust
        // Verify the payload isn't empty
        if epoch_ending_ledger_infos.is_empty() {
            self.reset_active_stream(Some(NotificationAndFeedback::new(
                notification_id,
                NotificationFeedback::EmptyPayloadData,
            )))
            .await?;
            return Err(Error::VerificationError(
                "The epoch ending payload was empty!".into(),
            ));
        }
```

**File:** state-sync/data-streaming-service/src/data_stream.rs (L234-262)
```rust
    pub fn handle_notification_feedback(
        &self,
        notification_id: &NotificationId,
        notification_feedback: &NotificationFeedback,
    ) -> Result<(), Error> {
        if self.stream_end_notification_id == Some(*notification_id) {
            return if matches!(notification_feedback, NotificationFeedback::EndOfStream) {
                Ok(())
            } else {
                Err(Error::UnexpectedErrorEncountered(format!(
                    "Invalid feedback given for stream end: {:?}",
                    notification_feedback
                )))
            };
        }

        let response_context = self
            .notifications_to_responses
            .get(notification_id)
            .ok_or_else(|| {
                Error::UnexpectedErrorEncountered(format!(
                    "Response context missing for notification ID: {:?}",
                    notification_id
                ))
            })?;
        let response_error = extract_response_error(notification_feedback)?;
        self.notify_bad_response(response_context, response_error);

        Ok(())
```

**File:** state-sync/data-streaming-service/src/data_stream.rs (L747-764)
```rust
    fn notify_bad_response(
        &self,
        response_context: &ResponseContext,
        response_error: ResponseError,
    ) {
        let response_id = response_context.id;
        info!(LogSchema::new(LogEntry::ReceivedDataResponse)
            .stream_id(self.data_stream_id)
            .event(LogEvent::Error)
            .message(&format!(
                "Notifying the data client of a bad response. Response id: {:?}, error: {:?}",
                response_id, response_error
            )));

        response_context
            .response_callback
            .notify_bad_response(response_error);
    }
```

**File:** state-sync/data-streaming-service/src/data_stream.rs (L1383-1394)
```rust
fn extract_response_error(
    notification_feedback: &NotificationFeedback,
) -> Result<ResponseError, Error> {
    match notification_feedback {
        NotificationFeedback::InvalidPayloadData => Ok(ResponseError::InvalidData),
        NotificationFeedback::PayloadTypeIsIncorrect => Ok(ResponseError::InvalidPayloadDataType),
        NotificationFeedback::PayloadProofFailed => Ok(ResponseError::ProofVerificationError),
        _ => Err(Error::UnexpectedErrorEncountered(format!(
            "Invalid notification feedback given: {:?}",
            notification_feedback
        ))),
    }
```

**File:** state-sync/aptos-data-client/src/client.rs (L872-880)
```rust
    fn notify_bad_response(
        &self,
        _id: ResponseId,
        peer: PeerNetworkId,
        _request: &StorageServiceRequest,
        error_type: ErrorType,
    ) {
        self.peer_states.update_score_error(peer, error_type);
    }
```

**File:** state-sync/data-streaming-service/src/streaming_client.rs (L279-285)
```rust
pub enum NotificationFeedback {
    EmptyPayloadData,
    EndOfStream,
    InvalidPayloadData,
    PayloadProofFailed,
    PayloadTypeIsIncorrect,
}
```
