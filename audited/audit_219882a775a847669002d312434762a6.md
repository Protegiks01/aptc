# Audit Report

## Title
Computational DoS via Zero-Power Validator Vote Processing in Order Vote Aggregation

## Summary
The `insert_order_vote()` function in the consensus layer logs but does not reject votes from validators with zero voting power. This allows Byzantine validators with zero stake to waste system resources by forcing signature storage and verification, potentially causing validator node slowdowns without contributing to consensus quorum.

## Finding Description

The vulnerability exists in the order vote processing logic where validators with zero voting power are permitted to participate in vote aggregation despite not contributing to quorum formation. [1](#0-0) 

When a validator with zero voting power submits an order vote:

1. The system checks the validator's voting power and finds it is zero
2. A warning is logged but processing continues
3. The signature is added to the `SignatureAggregator` via `add_signature()`
4. The signature is stored in the BTreeMap and included in subsequent aggregation attempts

The `SignatureAggregator` stores all signatures in a BTreeMap: [2](#0-1) 

When checking voting power, the aggregator sums power from ALL voters including zero-power validators: [3](#0-2) 

The `sum_voting_power()` method adds zero for zero-power validators but doesn't filter them out: [4](#0-3) 

**Attack Scenario:**

If the staking system allows zero-power validators (when `minimum_stake = 0`), Byzantine actors can:

1. Register multiple validators with zero stake (up to validator set limit of 65,536)
2. Send order votes with invalid signatures from each zero-power validator
3. Force the system to:
   - Store all signatures in memory (bounded but wasteful)
   - Attempt aggregate signature verification (which fails due to invalid signatures)
   - Fall back to individual signature verification for ALL signatures [5](#0-4) 

The individual verification process is computationally expensive: [6](#0-5) 

**Prerequisite Condition:**

Zero-power validators can only exist in the active set when `minimum_stake` is configured to 0. The staking system filters validators during epoch transitions: [7](#0-6) 

The staking configuration validation permits `minimum_stake = 0`: [8](#0-7) 

## Impact Explanation

**Severity: High** - Validator node slowdowns

Per the Aptos Bug Bounty program, "Validator node slowdowns" qualify as High Severity (up to $50,000).

If zero-power validators flood the system with invalid signatures:
- Each invalid signature forces individual cryptographic verification
- With up to 65,536 zero-power validators (max validator set size), this creates significant computational overhead
- Consensus rounds could be delayed as nodes waste CPU cycles verifying signatures that contribute nothing to quorum
- All validators in the network would be affected simultaneously

This breaks the **Resource Limits** invariant: "All operations must respect gas, storage, and computational limits."

## Likelihood Explanation

**Likelihood: Low-to-Medium** 

The vulnerability requires specific conditions:

1. **Configuration Requirement**: `minimum_stake` must be set to 0 or very low
   - Unlikely in production mainnet (typically requires millions of APT)
   - More common in testnet/devnet environments
   - Could occur via governance attack if attacker controls on-chain governance

2. **Validator Registration**: Attacker must register multiple validators
   - Requires creating validator accounts and joining validator set
   - Bounded by `MAX_VALIDATOR_SET_SIZE` (65,536)
   - Easier when minimum_stake is 0

3. **Economic Disincentive**: Zero-stake validators receive no rewards
   - Limited motivation unless goal is explicit DoS attack

While unlikely in production mainnet, this vulnerability represents a defense-in-depth failure where the code recognizes the issue (via the warning log) but fails to prevent resource waste.

## Recommendation

**Immediate Fix**: Reject votes from zero-power validators instead of just logging them.

```rust
// In insert_order_vote() after line 103:
let validator_voting_power =
    validator_voting_power.expect("Author must exist in the validator set.");

if validator_voting_power == 0 {
    warn!(
        "Rejected order vote with zero voting power from {}",
        order_vote.author()
    );
    return OrderVoteReceptionResult::ErrorAddingVote(
        VerifyError::TooLittleVotingPower {
            voting_power: 0,
            expected_voting_power: 1,
        }
    );
}

// Only add signature if voting power > 0
sig_aggregator.add_signature(order_vote.author(), order_vote.signature_with_status());
```

**Defense-in-Depth**: Ensure staking system enforces minimum voting power requirements strictly at the framework level, preventing zero-power validators from entering the active set regardless of `minimum_stake` configuration.

## Proof of Concept

```rust
#[test]
fn test_zero_power_validator_dos() {
    use aptos_consensus_types::{order_vote::OrderVote, quorum_cert::QuorumCert};
    use aptos_crypto::{bls12381, hash::CryptoHash};
    use aptos_types::{
        block_info::BlockInfo, ledger_info::LedgerInfo,
        validator_verifier::{ValidatorConsensusInfo, ValidatorVerifier},
    };
    
    // Create validator verifier with one honest validator (power=1) and many zero-power validators
    let honest_signer = ValidatorSigner::random([0; 32]);
    let mut validator_infos = vec![
        ValidatorConsensusInfo::new(honest_signer.author(), honest_signer.public_key(), 1)
    ];
    
    // Add 100 zero-power validators
    let zero_power_signers: Vec<ValidatorSigner> = (0..100)
        .map(|i| ValidatorSigner::random([i; 32]))
        .collect();
    
    for signer in &zero_power_signers {
        validator_infos.push(ValidatorConsensusInfo::new(
            signer.author(),
            signer.public_key(),
            0 // Zero voting power
        ));
    }
    
    let verifier = ValidatorVerifier::new_with_quorum_voting_power(validator_infos, 1).unwrap();
    let mut pending_votes = PendingOrderVotes::new();
    
    let li = LedgerInfo::new(BlockInfo::empty(), HashValue::random());
    let qc = QuorumCert::dummy();
    
    // Each zero-power validator sends an INVALID signature
    for signer in &zero_power_signers {
        let vote = OrderVote::new_with_signature(
            signer.author(),
            li.clone(),
            bls12381::Signature::dummy_signature() // Invalid signature
        );
        
        // Vote is accepted despite zero voting power
        pending_votes.insert_order_vote(&vote, &verifier, Some(qc.clone()));
    }
    
    // Now honest validator votes - should reach quorum
    let honest_vote = OrderVote::new_with_signature(
        honest_signer.author(),
        li.clone(),
        honest_signer.sign(&li).unwrap()
    );
    
    // This triggers expensive individual verification of ALL 100 zero-power signatures
    let result = pending_votes.insert_order_vote(&honest_vote, &verifier, None);
    
    // Should succeed but only after verifying all invalid signatures individually
    assert!(matches!(result, OrderVoteReceptionResult::NewLedgerInfoWithSignatures(_)));
}
```

**Notes:**

While this vulnerability exists in the codebase, its practical exploitability in production mainnet is limited by the requirement that `minimum_stake = 0`. However, it represents a clear deviation from defensive programming principles: the code detects zero-power validators but fails to reject their votes, wasting system resources. In testnet/devnet environments or under adversarial governance scenarios, this could enable validator node slowdowns qualifying as High Severity impact.

### Citations

**File:** consensus/src/pending_order_votes.rs (L105-112)
```rust
                if validator_voting_power == 0 {
                    warn!(
                        "Received vote with no voting power, from {}",
                        order_vote.author()
                    );
                }
                sig_aggregator
                    .add_signature(order_vote.author(), order_vote.signature_with_status());
```

**File:** types/src/ledger_info.rs (L460-462)
```rust
    pub fn add_signature(&mut self, validator: AccountAddress, signature: &SignatureWithStatus) {
        self.signatures.insert(validator, signature.clone());
    }
```

**File:** types/src/ledger_info.rs (L488-495)
```rust
    pub fn check_voting_power(
        &self,
        verifier: &ValidatorVerifier,
        check_super_majority: bool,
    ) -> std::result::Result<u128, VerifyError> {
        let all_voters = self.all_voters();
        verifier.check_voting_power(all_voters, check_super_majority)
    }
```

**File:** types/src/ledger_info.rs (L517-536)
```rust
    pub fn aggregate_and_verify(
        &mut self,
        verifier: &ValidatorVerifier,
    ) -> Result<(T, AggregateSignature), VerifyError> {
        let aggregated_sig = self.try_aggregate(verifier)?;

        match verifier.verify_multi_signatures(&self.data, &aggregated_sig) {
            Ok(_) => {
                // We are not marking all the signatures as "verified" here, as two malicious
                // voters can collude and create a valid aggregated signature.
                Ok((self.data.clone(), aggregated_sig))
            },
            Err(_) => {
                self.filter_invalid_signatures(verifier);

                let aggregated_sig = self.try_aggregate(verifier)?;
                Ok((self.data.clone(), aggregated_sig))
            },
        }
    }
```

**File:** types/src/validator_verifier.rs (L287-310)
```rust
    pub fn filter_invalid_signatures<T: Send + Sync + Serialize + CryptoHash>(
        &self,
        message: &T,
        signatures: BTreeMap<AccountAddress, SignatureWithStatus>,
    ) -> BTreeMap<AccountAddress, SignatureWithStatus> {
        signatures
            .into_iter()
            .collect_vec()
            .into_par_iter()
            .with_min_len(4) // At least 4 signatures are verified in each task
            .filter_map(|(account_address, signature)| {
                if signature.is_verified()
                    || self
                        .verify(account_address, message, signature.signature())
                        .is_ok()
                {
                    signature.set_verified();
                    Some((account_address, signature))
                } else {
                    self.add_pessimistic_verify_set(account_address);
                    None
                }
            })
            .collect()
```

**File:** types/src/validator_verifier.rs (L436-448)
```rust
    pub fn sum_voting_power<'a>(
        &self,
        authors: impl Iterator<Item = &'a AccountAddress>,
    ) -> std::result::Result<u128, VerifyError> {
        let mut aggregated_voting_power = 0;
        for account_address in authors {
            match self.get_voting_power(account_address) {
                Some(voting_power) => aggregated_voting_power += voting_power as u128,
                None => return Err(VerifyError::UnknownAuthor),
            }
        }
        Ok(aggregated_voting_power)
    }
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1390-1397)
```text
            // A validator needs at least the min stake required to join the validator set.
            if (new_validator_info.voting_power >= minimum_stake) {
                spec {
                    assume total_voting_power + new_validator_info.voting_power <= MAX_U128;
                };
                total_voting_power = total_voting_power + (new_validator_info.voting_power as u128);
                vector::push_back(&mut next_epoch_validators, new_validator_info);
            };
```

**File:** aptos-move/framework/aptos-framework/sources/configs/staking_config.move (L372-374)
```text
    fun validate_required_stake(minimum_stake: u64, maximum_stake: u64) {
        assert!(minimum_stake <= maximum_stake && maximum_stake > 0, error::invalid_argument(EINVALID_STAKE_RANGE));
    }
```
