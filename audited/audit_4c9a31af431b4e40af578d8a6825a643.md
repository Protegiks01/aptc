# Audit Report

## Title
Missing BCS Stream Validation Allows Padding Injection in Derivable Account Abstract Public Keys

## Summary
The `ethereum_derivable_account.move` and `solana_derivable_account.move` modules fail to validate that all bytes are consumed when deserializing the `abstract_public_key` field from `AbstractAuthenticationData`. This allows attackers to inject arbitrary padding or metadata that becomes part of the address derivation hash but is ignored during signature verification, breaking the one-to-one mapping between external identities and Aptos addresses. [1](#0-0) 

## Finding Description
The derivable account abstraction system derives Aptos addresses by hashing the BCS-serialized `abstract_public_key` along with function info and a scheme byte. [2](#0-1) 

However, when deserializing the `abstract_public_key` for authentication, the Ethereum and Solana implementations do not validate that all bytes were consumed from the BCS stream. [1](#0-0) 

This contrasts with the proper implementation in `sui_derivable_account.move` which includes the validation: [3](#0-2) 

The same pattern is correctly used in all cryptographic key deserialization functions: [4](#0-3) 

**Attack Scenario:**
1. Attacker creates two versions of `abstract_public_key`:
   - `pk_normal = BCS(ethereum_address) || BCS(domain)`
   - `pk_padded = BCS(ethereum_address) || BCS(domain) || [padding_bytes]`

2. Address derivation includes ALL bytes:
   - `addr_normal = SHA3(BCS(func_info) || BCS(pk_normal) || 0x05)` 
   - `addr_padded = SHA3(BCS(func_info) || BCS(pk_padded) || 0x05)`
   - These produce **different addresses**

3. Both deserialize to the **same** `ethereum_address` and `domain` (padding ignored)

4. Both authenticate with the **same** Ethereum signature

This breaks the invariant: **"One external identity deterministically maps to exactly one Aptos address"**

## Impact Explanation
This is a **High Severity** vulnerability based on Aptos bug bounty criteria for "Significant protocol violations":

1. **Protocol Invariant Violation**: Breaks the fundamental assumption that derivable account abstraction provides a deterministic 1:1 mapping between external identities and Aptos addresses.

2. **State Management Issues**: Applications and services relying on deterministic address derivation could experience state inconsistencies when the same external identity controls multiple addresses.

3. **Account Squatting/Griefing**: Attackers can pre-register multiple addresses derived from their external identity, potentially blocking legitimate users or creating confusion in the namespace.

4. **Application-Level Exploits**: Smart contracts and dApps that assume address uniqueness per identity could be exploited for airdrops, voting systems, or access control mechanisms.

The vulnerability affects deterministic execution across validators since all nodes would accept transactions from these malformed addresses, maintaining consensus but violating higher-level protocol semantics.

## Likelihood Explanation
**Likelihood: High**

- **Ease of Exploitation**: Trivial - attacker only needs to append arbitrary bytes to a valid BCS-serialized `abstract_public_key`
- **Attacker Requirements**: None - any user can submit transactions with padded keys
- **Detection Difficulty**: Low - the malformed keys are accepted by the system without error
- **Affected Scope**: All users of Ethereum and Solana derivable account abstractions

The vulnerability is currently exploitable on mainnet if these derivable account features are enabled. [5](#0-4) 

## Recommendation
Add validation to ensure all bytes are consumed after deserializing the `abstract_public_key` and `abstract_signature` fields:

**For `ethereum_derivable_account.move`:**
```move
fun deserialize_abstract_public_key(abstract_public_key: &vector<u8>): SIWEAbstractPublicKey {
    let stream = bcs_stream::new(*abstract_public_key);
    let ethereum_address = bcs_stream::deserialize_vector<u8>(&mut stream, |x| deserialize_u8(x));
    let domain = bcs_stream::deserialize_vector<u8>(&mut stream, |x| deserialize_u8(x));
    assert!(!bcs_stream::has_remaining(&mut stream), EMALFORMED_DATA);  // ADD THIS LINE
    SIWEAbstractPublicKey { ethereum_address, domain }
}
```

Add similar validation to `deserialize_abstract_signature` and apply the same fix to `solana_derivable_account.move`. [6](#0-5) 

Define error constant:
```move
const EMALFORMED_DATA: u64 = <next_available_error_code>;
```

## Proof of Concept
```move
#[test_only]
module aptos_framework::derivable_account_padding_exploit_test {
    use aptos_framework::account_abstraction;
    use aptos_framework::function_info;
    use std::bcs;
    use std::string;
    
    #[test]
    fun test_padding_creates_different_addresses() {
        let func_info = function_info::new_function_info_from_address(
            @aptos_framework,
            string::utf8(b"ethereum_derivable_account"),
            string::utf8(b"authenticate")
        );
        
        // Create normal abstract public key
        let ethereum_addr = b"0x1234567890123456789012345678901234567890";
        let domain = b"example.com";
        
        let mut pk_normal = vector[];
        pk_normal.append(bcs::to_bytes(&ethereum_addr));
        pk_normal.append(bcs::to_bytes(&domain));
        
        // Create padded version with extra bytes
        let mut pk_padded = pk_normal;
        pk_padded.append(vector[0x00, 0x00, 0x00, 0x00]);  // Add padding
        
        // Derive addresses
        let addr_normal = account_abstraction::derive_account_address(func_info, &pk_normal);
        let addr_padded = account_abstraction::derive_account_address(func_info, &pk_padded);
        
        // VULNERABILITY: Different addresses from same identity
        assert!(addr_normal != addr_padded, 0);
        
        // Both would authenticate with the same Ethereum signature
        // because deserialization ignores the padding
    }
}
```

## Notes
This vulnerability is specific to the Move-level deserialization in derivable account implementations, not the Rust `types/src/serde_helper/vec_bytes.rs` file mentioned in the original question. The root cause is the missing `has_remaining` validation that is standard practice throughout the codebase for all other key deserialization functions. [7](#0-6)

### Citations

**File:** aptos-move/framework/aptos-framework/sources/account/common_account_abstractions/ethereum_derivable_account.move (L75-80)
```text
    fun deserialize_abstract_public_key(abstract_public_key: &vector<u8>): SIWEAbstractPublicKey {
        let stream = bcs_stream::new(*abstract_public_key);
        let ethereum_address = bcs_stream::deserialize_vector<u8>(&mut stream, |x| deserialize_u8(x));
        let domain = bcs_stream::deserialize_vector<u8>(&mut stream, |x| deserialize_u8(x));
        SIWEAbstractPublicKey { ethereum_address, domain }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/account/account_abstraction.move (L110-118)
```text
    public fun derive_account_address(derivable_func_info: FunctionInfo, abstract_public_key: &vector<u8>): address {
        // using bcs serialized structs here - this allows for no need for separators.
        // Alternative would've been to create unique string, we would need to convert derivable_func_info into string,
        // then authentication_key to hex, and then we need separators as well - like ::
        let bytes = bcs::to_bytes(&derivable_func_info);
        bytes.append(bcs::to_bytes(abstract_public_key));
        bytes.push_back(DERIVABLE_ABSTRACTION_DERIVED_SCHEME);
        from_bcs::to_address(hash::sha3_256(bytes))
    }
```

**File:** aptos-move/framework/aptos-framework/sources/account/account_abstraction.move (L186-187)
```text
        assert!(features::is_derivable_account_abstraction_enabled(), error::invalid_state(EDERIVABLE_ACCOUNT_ABSTRACTION_NOT_ENABLED));
        system_addresses::assert_aptos_framework(aptos_framework);
```

**File:** aptos-move/framework/aptos-framework/sources/account/common_account_abstractions/sui_derivable_account.move (L113-118)
```text
    fun deserialize_abstract_public_key(abstract_public_key: &vector<u8>): SuiAbstractPublicKey {
        let stream = bcs_stream::new(*abstract_public_key);
        let sui_account_address = bcs_stream::deserialize_vector<u8>(&mut stream, |x| deserialize_u8(x));
        let domain = bcs_stream::deserialize_vector<u8>(&mut stream, |x| deserialize_u8(x));
        assert!(!bcs_stream::has_remaining(&mut stream), EMALFORMED_DATA);
        SuiAbstractPublicKey { sui_account_address, domain }
```

**File:** aptos-move/framework/aptos-stdlib/sources/cryptography/single_key.move (L66-71)
```text
    public fun new_public_key_from_bytes(bytes: vector<u8>): AnyPublicKey {
        let stream = bcs_stream::new(bytes);
        let pk = deserialize_any_public_key(&mut stream);
        assert!(!bcs_stream::has_remaining(&mut stream), error::invalid_argument(E_INVALID_SINGLE_KEY_EXTRA_BYTES));
        pk
    }
```

**File:** aptos-move/framework/aptos-framework/sources/account/common_account_abstractions/solana_derivable_account.move (L60-66)
```text
    fun deserialize_abstract_public_key(abstract_public_key: &vector<u8>):
    (vector<u8>, vector<u8>) {
        let stream = bcs_stream::new(*abstract_public_key);
        let base58_public_key = bcs_stream::deserialize_vector<u8>(&mut stream, |x| deserialize_u8(x));
        let domain = bcs_stream::deserialize_vector<u8>(&mut stream, |x| deserialize_u8(x));
        (base58_public_key, domain)
    }
```

**File:** aptos-move/framework/aptos-stdlib/sources/bcs_stream.move (L39-41)
```text
    public fun has_remaining(stream: &mut BCSStream): bool {
        stream.cur < stream.data.length()
    }
```
