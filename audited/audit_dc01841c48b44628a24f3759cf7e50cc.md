# Audit Report

## Title
Cross-Shard Message Censorship Causes Indefinite Validator Hang in Sharded Block Executor

## Summary
The `RemoteCrossShardClient` implementation lacks timeout mechanisms for cross-shard message reception, allowing a malicious or faulty shard to cause dependent shards to block indefinitely, resulting in complete validator failure and inability to participate in consensus.

## Finding Description

The sharded block executor uses cross-shard messaging to communicate state updates between transaction shards during parallel execution. When a transaction in Shard A writes state that Shard B depends on, Shard A must send the update via `send_cross_shard_msg()`, and Shard B blocks waiting in `receive_cross_shard_msg()`.

**Critical Code Paths:**

1. **Indefinite Blocking in Message Reception:** [1](#0-0) 

2. **Indefinite Blocking in State Value Retrieval:** [2](#0-1) 

3. **Panic on Send Failure:** [3](#0-2) 

4. **No Timeout in Result Collection:** [4](#0-3) 

**Attack Scenario:**

1. Validator deploys sharded execution across multiple machines using `RemoteCrossShardClient`
2. One shard machine becomes compromised or experiences network issues
3. Malicious shard receives sub-block with transactions that other shards depend on
4. Malicious shard either:
   - Skips calling `send_cross_shard_msg()` for specific dependent shards
   - Crashes after receiving `StopMsg` but before sending messages
   - Has network connectivity issues preventing message delivery
5. Dependent shard's `CrossShardCommitReceiver` calls `receive_cross_shard_msg()` and blocks indefinitely [5](#0-4) 

6. When dependent shard's transaction attempts to read cross-shard state, it blocks in `RemoteStateValue::get_value()`'s condition variable wait loop
7. Shard execution never completes
8. Validator cannot produce block execution result
9. Validator cannot vote in consensus round
10. If multiple validators experience this, network liveness degrades

**Security Invariant Violated:**
- **Resource Limits**: No timeout enforcement on blocking operations
- **Deterministic Execution**: Validator fails to produce execution result at all

## Impact Explanation

**Severity: High**

This vulnerability causes **validator node failure** rather than network-wide liveness loss, meeting the **High Severity** criteria: "Validator node slowdowns" (though this is complete failure, not just slowdown).

**Impact Scope:**
- Affected validator completely unable to execute blocks using sharded execution
- Validator cannot participate in consensus voting
- If sharded execution is widely deployed and multiple validators affected, could approach Critical severity (network liveness impact)
- Requires manual intervention (restart with fallback to sequential execution)

**Not Critical Severity because:**
- Attack requires insider access (compromised shard infrastructure within validator)
- Impact limited to validators using remote sharded execution
- Network can continue with â‰¥2/3 honest validators functioning
- Does not cause consensus divergence (validator simply fails vs. producing wrong result)

## Likelihood Explanation

**Likelihood: Medium-High**

**Factors Increasing Likelihood:**
- No timeout protection at any layer (message reception, state value blocking, result collection)
- Simple to exploit once insider access obtained (just don't send messages)
- Network failures can trigger this unintentionally
- Crossbeam channel `recv()` blocks indefinitely without timeout

**Factors Decreasing Likelihood:**
- Requires compromising part of validator's shard infrastructure (insider threat)
- Remote sharded execution may not be widely deployed (optimization feature)
- Validators can fall back to sequential execution

**Attack Complexity:** Low (once insider access obtained - simply not calling `send_cross_shard_msg()`)

## Recommendation

**Immediate Mitigations:**

1. **Add Timeouts to Message Reception:**
```rust
fn receive_cross_shard_msg(&self, current_round: RoundId) -> Result<CrossShardMsg, RecvTimeoutError> {
    let rx = self.message_rxs[current_round].lock().unwrap();
    let message = rx.recv_timeout(Duration::from_secs(30))?;  // Add timeout
    let msg: CrossShardMsg = bcs::from_bytes(&message.to_bytes()).unwrap();
    Ok(msg)
}
```

2. **Add Timeout to RemoteStateValue:**
```rust
pub fn get_value_with_timeout(&self, timeout: Duration) -> Result<Option<StateValue>, TimeoutError> {
    let (lock, cvar) = &*self.value_condition;
    let mut status = lock.lock().unwrap();
    let (status, timeout_result) = cvar.wait_timeout_while(status, timeout, |s| {
        matches!(s, RemoteValueStatus::Waiting)
    }).unwrap();
    
    if timeout_result.timed_out() {
        return Err(TimeoutError);
    }
    
    match &*status {
        RemoteValueStatus::Ready(value) => Ok(value.clone()),
        RemoteValueStatus::Waiting => unreachable!(),
    }
}
```

3. **Add Health Checks:**
    - Implement periodic heartbeat messages between shards
    - Detect and fail-fast on shard communication failures
    - Allow graceful fallback to sequential execution

4. **Improve Error Handling:** [6](#0-5) 
Replace `panic!` with proper error propagation and retry logic.

## Proof of Concept

```rust
// Simulation of the attack scenario
// Place in execution/executor-service/tests/cross_shard_censorship_test.rs

#[test]
#[should_panic(expected = "timeout")]
fn test_malicious_shard_message_drop() {
    use std::sync::{Arc, Mutex};
    use std::thread;
    use std::time::Duration;
    use crossbeam_channel::unbounded;
    use aptos_secure_net::network_controller::NetworkController;
    
    // Setup: Create two shards that communicate
    let mut nc1 = NetworkController::new("shard1".into(), "127.0.0.1:8001".parse().unwrap(), 5000);
    let mut nc2 = NetworkController::new("shard2".into(), "127.0.0.1:8002".parse().unwrap(), 5000);
    
    // Shard 1 -> Shard 2 channel
    let tx = nc1.create_outbound_channel("127.0.0.1:8002".parse().unwrap(), "cross_shard_0".into());
    let rx = nc2.create_inbound_channel("cross_shard_0".into());
    
    nc1.start();
    nc2.start();
    
    // Simulate dependent shard waiting for message
    let receiver_thread = thread::spawn(move || {
        // This will block indefinitely if no message sent
        let _msg = rx.recv().expect("Should receive message");
    });
    
    // Malicious shard: DON'T send the expected message
    // (Simulating selective message dropping)
    thread::sleep(Duration::from_millis(100));
    // tx.send() is never called for this dependent shard
    
    // Try to join with timeout - will fail because receiver blocks forever
    match receiver_thread.join_timeout(Duration::from_secs(2)) {
        Ok(_) => panic!("Should not complete"),
        Err(_) => panic!("timeout"), // Expected - receiver blocked indefinitely
    }
}
```

**Notes:**
- This vulnerability requires compromising part of a validator's shard execution infrastructure (insider threat scenario)
- Does not cause consensus divergence (validator simply fails to produce results)
- Affects validator availability rather than safety
- Can be triggered unintentionally by network failures or bugs
- No recovery mechanism exists; requires manual restart with non-sharded execution

### Citations

**File:** execution/executor-service/src/remote_cross_shard_client.rs (L61-66)
```rust
    fn receive_cross_shard_msg(&self, current_round: RoundId) -> CrossShardMsg {
        let rx = self.message_rxs[current_round].lock().unwrap();
        let message = rx.recv().unwrap();
        let msg: CrossShardMsg = bcs::from_bytes(&message.to_bytes()).unwrap();
        msg
    }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/remote_state_value.rs (L29-39)
```rust
    pub fn get_value(&self) -> Option<StateValue> {
        let (lock, cvar) = &*self.value_condition;
        let mut status = lock.lock().unwrap();
        while let RemoteValueStatus::Waiting = *status {
            status = cvar.wait(status).unwrap();
        }
        match &*status {
            RemoteValueStatus::Ready(value) => value.clone(),
            RemoteValueStatus::Waiting => unreachable!(),
        }
    }
```

**File:** secure/net/src/grpc_network_service/mod.rs (L140-160)
```rust
    pub async fn send_message(
        &mut self,
        sender_addr: SocketAddr,
        message: Message,
        mt: &MessageType,
    ) {
        let request = tonic::Request::new(NetworkMessage {
            message: message.data,
            message_type: mt.get_type(),
        });
        // TODO: Retry with exponential backoff on failures
        match self.remote_channel.simple_msg_exchange(request).await {
            Ok(_) => {},
            Err(e) => {
                panic!(
                    "Error '{}' sending message to {} on node {:?}",
                    e, self.remote_addr, sender_addr
                );
            },
        }
    }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/local_executor_shard.rs (L164-175)
```rust
    fn get_output_from_shards(&self) -> Result<Vec<Vec<Vec<TransactionOutput>>>, VMStatus> {
        let _timer = WAIT_FOR_SHARDED_OUTPUT_SECONDS.start_timer();
        trace!("LocalExecutorClient Waiting for results");
        let mut results = vec![];
        for (i, rx) in self.result_rxs.iter().enumerate() {
            results.push(
                rx.recv()
                    .unwrap_or_else(|_| panic!("Did not receive output from shard {}", i))?,
            );
        }
        Ok(results)
    }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/cross_shard_client.rs (L26-45)
```rust
    pub fn start<S: StateView + Sync + Send>(
        cross_shard_state_view: Arc<CrossShardStateView<S>>,
        cross_shard_client: Arc<dyn CrossShardClient>,
        round: RoundId,
    ) {
        loop {
            let msg = cross_shard_client.receive_cross_shard_msg(round);
            match msg {
                RemoteTxnWriteMsg(txn_commit_msg) => {
                    let (state_key, write_op) = txn_commit_msg.take();
                    cross_shard_state_view
                        .set_value(&state_key, write_op.and_then(|w| w.as_state_value()));
                },
                CrossShardMsg::StopMsg => {
                    trace!("Cross shard commit receiver stopped for round {}", round);
                    break;
                },
            }
        }
    }
```
