# Audit Report

## Title
Script Cache Bypass Enables Execution of Scripts with Outdated Verification After Security Updates

## Summary
The script cache (`SyncScriptCache` and `UnsyncScriptCache`) lacks any invalidation mechanism when bytecode verifier configuration changes. When governance updates verification rules to patch security vulnerabilities, the module cache is properly flushed, but the script cache is not. This allows previously-verified scripts to execute using outdated verification rules, potentially bypassing security fixes and causing consensus divergence across validators with different cache states.

## Finding Description

The Move VM caches scripts by their SHA3-256 hash to avoid redundant deserialization and verification. Scripts are verified using the current `VerifierConfig` when first loaded, then cached indefinitely. [1](#0-0) [2](#0-1) 

When a script is loaded, the loader checks the cache first and returns the cached version if available, completely bypassing re-verification: [3](#0-2) 

Script verification uses the current environment's verifier config: [4](#0-3) 

When the runtime environment changes (including verifier config updates), the system properly flushes module caches: [5](#0-4) 

However, **there is no corresponding flush mechanism for the script cache**. The script cache interface has no `flush()`, `clear()`, or `invalidate()` method. Module cache has explicit flush support: [6](#0-5) 

But script cache has only insert and get operations - no removal or invalidation capabilities.

**Attack Scenario:**

1. At time T₀: Script S is submitted and verified under `VerifierConfig` V1, then cached
2. At time T₁: Security vulnerability discovered in verification logic
3. At time T₂: Governance updates verifier config to V2 with stricter rules that would reject script S
4. At time T₃: Module cache is flushed (per environment change logic), but script cache is NOT
5. At time T₄: Some validators restart for maintenance (clearing their cache), others don't
6. At time T₅: Script S is resubmitted in a new transaction
7. **Validators with cached S**: Use cached version verified under V1 (accepts transaction)
8. **Validators without cached S**: Verify under V2, reject S (rejects transaction)
9. **Result**: Consensus divergence - validators disagree on transaction validity

This breaks the **Deterministic Execution** invariant: validators must produce identical results for identical blocks.

## Impact Explanation

This is a **Medium Severity** vulnerability per the Aptos bug bounty criteria:

- **State inconsistencies requiring intervention**: Validators with different cache states will produce different transaction execution results, violating consensus determinism
- **Bypasses security updates**: Scripts verified under vulnerable verification rules continue executing after governance deploys patches
- **No recovery path**: The only way to purge a problematic cached script is restarting all validators, which is operationally expensive
- **Consensus risk**: Mixed cache states across validators can cause chain splits if new verification rules reject previously-cached scripts

While this doesn't directly cause fund loss, it undermines the security update mechanism and can create consensus inconsistencies that require manual intervention.

## Likelihood Explanation

**Moderate likelihood** due to multiple required conditions:

**Prerequisites:**
- Verifier config update deployed via governance (rare but happens for security patches)
- Script must have been previously submitted and cached
- Validators must have mixed cache states (some cached, some not)
- Same script must be resubmitted after config update

**Likelihood factors:**
- Verifier config updates occur infrequently but are critical security events
- Validator restarts are common (maintenance, crashes, updates, new validators joining)
- Script resubmission is possible for any transaction sender
- The vulnerability window exists from config update until all validators converge to same cache state

**Real-world trigger**: After any verifier config update for security patches, the period where validators have inconsistent cache states (due to restarts) creates vulnerability window.

## Recommendation

Implement script cache invalidation synchronized with verifier config changes. Add flush capability to the `ScriptCache` trait and invoke it when the environment changes:

**1. Add flush method to ScriptCache trait:**

```rust
// In script_cache.rs
pub trait ScriptCache {
    // ... existing methods ...
    
    /// Flushes all cached scripts. Should be called when verification 
    /// configuration changes to ensure scripts are re-verified with new rules.
    fn flush(&mut self);
}
```

**2. Implement flush for both cache types:**

```rust
impl<K, D, V> ScriptCache for UnsyncScriptCache<K, D, V> {
    // ... existing methods ...
    
    fn flush(&mut self) {
        self.script_cache.borrow_mut().clear();
    }
}

impl<K, D, V> ScriptCache for SyncScriptCache<K, D, V> {
    // ... existing methods ...
    
    fn flush(&mut self) {
        self.script_cache.clear();
    }
}
```

**3. Invoke flush when verifier config changes:**

```rust
// In code_cache_global_manager.rs, extend check_ready()
if environment_requires_update {
    if storage_environment.gas_feature_version() >= RELEASE_V1_34 {
        let flush_verifier_cache = self.environment.as_ref().is_none_or(|e| {
            e.verifier_config_bytes() != storage_environment.verifier_config_bytes()
        });
        if flush_verifier_cache {
            RuntimeEnvironment::flush_verified_module_cache();
            // ADD: Flush script cache as well
            // self.script_cache.flush();  // If script cache is managed here
        }
    }
    self.environment = Some(storage_environment);
    self.module_cache.flush();
}
```

**Note**: The exact integration point depends on how script cache is managed in the execution context. The key principle is: **whenever module cache is flushed due to verifier config changes, script cache must also be flushed**.

## Proof of Concept

```rust
// Conceptual PoC - would need full test harness to execute

#[test]
fn test_script_cache_bypass_after_verifier_update() {
    // Setup: Create script and environment with permissive verifier config
    let script_bytes = create_test_script();
    let hash = sha3_256(&script_bytes);
    let mut env_v1 = create_environment_with_config(VerifierConfig::permissive());
    let cache = SyncScriptCache::empty();
    
    // Step 1: Verify and cache script with V1 config
    let verified_script_v1 = verify_and_cache_script(&env_v1, &cache, &script_bytes, &hash);
    assert!(verified_script_v1.is_ok());
    assert!(cache.get_script(&hash).is_some()); // Script cached
    
    // Step 2: Update environment to stricter verifier config V2
    let env_v2 = create_environment_with_config(VerifierConfig::strict());
    // In real code, module cache would be flushed here, but script cache is not
    
    // Step 3: Try to load the same script again
    let cached_result = cache.get_script(&hash);
    assert!(cached_result.is_some()); // Still cached!
    
    // Step 4: Verify this bypasses new verification
    // If we tried to verify from scratch with V2, it should fail
    let fresh_verify_v2 = verify_script_fresh(&env_v2, &script_bytes);
    assert!(fresh_verify_v2.is_err()); // Should reject under V2
    
    // But cached version still returns the V1-verified script
    // This demonstrates the bypass
    assert_ne!(cached_result.is_some(), fresh_verify_v2.is_ok());
}
```

The PoC demonstrates that once a script is cached under permissive verification rules, it remains accessible even after stricter rules are deployed that would reject it. This bypasses the security update mechanism.

---

**Notes:**

This vulnerability is particularly concerning because:
1. It's invisible to operators - there's no indication that cached scripts are using outdated verification
2. It affects a core security mechanism (bytecode verification) that protects against malicious scripts
3. The only remediation is coordinated validator restart, which is operationally expensive
4. It creates a trust issue: security patches to verification rules don't fully protect the network until all cached scripts are invalidated

### Citations

**File:** third_party/move/move-vm/types/src/code/cache/script_cache.rs (L11-41)
```rust
/// Interface used by any script cache implementation.
#[delegatable_trait]
pub trait ScriptCache {
    type Key: Eq + Hash + Clone;
    type Deserialized;
    type Verified;

    /// If the entry associated with the key is vacant, inserts the script and returns its copy.
    /// Otherwise, there is no insertion and the copy of existing entry is returned.
    fn insert_deserialized_script(
        &self,
        key: Self::Key,
        deserialized_script: Self::Deserialized,
    ) -> Arc<Self::Deserialized>;

    /// If the entry associated with the key is vacant, inserts the script and returns its copy.
    /// If the entry associated with the key is occupied, but the entry is not verified, inserts
    /// the script returning the copy. Otherwise, there is no insertion and the copy of existing
    /// (verified) entry is returned.
    fn insert_verified_script(
        &self,
        key: Self::Key,
        verified_script: Self::Verified,
    ) -> Arc<Self::Verified>;

    /// Returns the script if it has been cached before, or [None] otherwise.
    fn get_script(&self, key: &Self::Key) -> Option<Code<Self::Deserialized, Self::Verified>>;

    /// Returns the number of scripts stored in cache.
    fn num_scripts(&self) -> usize;
}
```

**File:** third_party/move/move-vm/types/src/code/cache/script_cache.rs (L120-136)
```rust
/// [Sync] implementation of script cache suitable for multithreaded execution.
pub struct SyncScriptCache<K, D, V> {
    script_cache: DashMap<K, CachePadded<Code<D, V>>>,
}

impl<K, D, V> SyncScriptCache<K, D, V>
where
    K: Eq + Hash + Clone,
    V: Deref<Target = Arc<D>>,
{
    /// Returns an empty script cache.
    pub fn empty() -> Self {
        Self {
            script_cache: DashMap::new(),
        }
    }
}
```

**File:** third_party/move/move-vm/runtime/src/storage/loader/eager.rs (L106-138)
```rust
    fn unmetered_verify_and_cache_script(&self, serialized_script: &[u8]) -> VMResult<Arc<Script>> {
        use Code::*;

        let hash = sha3_256(serialized_script);
        let deserialized_script = match self.module_storage.get_script(&hash) {
            Some(Verified(script)) => return Ok(script),
            Some(Deserialized(deserialized_script)) => deserialized_script,
            None => self
                .runtime_environment()
                .deserialize_into_script(serialized_script)
                .map(Arc::new)?,
        };

        let locally_verified_script = self
            .runtime_environment()
            .build_locally_verified_script(deserialized_script)?;

        let immediate_dependencies = locally_verified_script
            .immediate_dependencies_iter()
            .map(|(addr, name)| {
                self.module_storage
                    .unmetered_get_existing_eagerly_verified_module(addr, name)
            })
            .collect::<VMResult<Vec<_>>>()?;

        let verified_script = self
            .runtime_environment()
            .build_verified_script(locally_verified_script, &immediate_dependencies)?;

        Ok(self
            .module_storage
            .insert_verified_script(hash, verified_script))
    }
```

**File:** third_party/move/move-vm/runtime/src/storage/environment.rs (L141-173)
```rust
    pub fn build_locally_verified_script(
        &self,
        compiled_script: Arc<CompiledScript>,
    ) -> VMResult<LocallyVerifiedScript> {
        move_bytecode_verifier::verify_script_with_config(
            &self.vm_config().verifier_config,
            compiled_script.as_ref(),
        )?;
        Ok(LocallyVerifiedScript(compiled_script))
    }

    /// Creates a verified script by running dependency verification pass over locally verified
    /// script. The caller must provide verified module dependencies.
    pub fn build_verified_script(
        &self,
        locally_verified_script: LocallyVerifiedScript,
        immediate_dependencies: &[Arc<Module>],
    ) -> VMResult<Script> {
        dependencies::verify_script(
            &self.vm_config.verifier_config,
            locally_verified_script.0.as_ref(),
            immediate_dependencies
                .iter()
                .map(|module| module.as_ref().as_ref()),
        )?;
        Script::new(
            locally_verified_script.0,
            self.struct_name_index_map(),
            self.ty_pool(),
            self.module_id_pool(),
        )
        .map_err(|err| err.finish(Location::Script))
    }
```

**File:** aptos-move/block-executor/src/code_cache_global_manager.rs (L115-130)
```rust
        let environment_requires_update = self.environment.as_ref() != Some(&storage_environment);
        if environment_requires_update {
            if storage_environment.gas_feature_version() >= RELEASE_V1_34 {
                let flush_verifier_cache = self.environment.as_ref().is_none_or(|e| {
                    e.verifier_config_bytes() != storage_environment.verifier_config_bytes()
                });
                if flush_verifier_cache {
                    // Additionally, if the verifier config changes, we flush static verifier cache
                    // as well.
                    RuntimeEnvironment::flush_verified_module_cache();
                }
            }

            self.environment = Some(storage_environment);
            self.module_cache.flush();
        }
```

**File:** aptos-move/block-executor/src/code_cache_global.rs (L155-160)
```rust
    /// Flushes all caches.
    pub fn flush(&mut self) {
        self.module_cache.clear();
        self.size = 0;
        self.struct_layouts.clear();
    }
```
