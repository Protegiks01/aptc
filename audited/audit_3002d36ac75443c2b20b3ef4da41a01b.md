# Audit Report

## Title
Network Trust Boundary Violation: Untrusted Peers Can Subscribe to Consensus Observer Without Validation

## Summary
The consensus observer publisher accepts subscription requests from any peer on any NetworkId without validating the source network's trust level. This allows untrusted peers on the Public network to subscribe to VFN publishers and receive real-time consensus updates with the same privileges as trusted VFN or Validator network peers.

## Finding Description

The consensus observer system is designed to allow nodes to observe consensus progress without participating in consensus. However, the implementation fails to enforce trust boundaries based on NetworkId when processing subscription requests.

**The Vulnerability Chain:**

1. **Network Registration Without Differentiation** [1](#0-0) 

The consensus observer protocols are registered on ALL networks where a node operates. For VFNs, this means registration on both NetworkId::Vfn (semi-trusted) and NetworkId::Public (untrusted) networks.

2. **Event Transformation Preserves NetworkId** [2](#0-1) 

Messages from different NetworkIds flow through the same transformation pipeline, with the NetworkId preserved but not used for access control decisions.

3. **No Trust Validation in Subscription Handling** [3](#0-2) 

The `process_network_message` method accepts Subscribe requests from ANY peer without validating the source NetworkId. All peers are treated with equal trust regardless of whether they connect via NetworkId::Validator, NetworkId::Vfn, or NetworkId::Public.

4. **Configuration Shows Trust Hierarchy** [4](#0-3) 

The configuration explicitly defines a trust hierarchy (validators, VFNs, public nodes) with different enablement settings, but this hierarchy is not enforced in subscription validation.

**Attack Scenario:**

1. Attacker connects to a VFN on its Public network endpoint
2. Attacker sends a `ConsensusObserverRequest::Subscribe` RPC request
3. VFN's publisher accepts the subscription without checking that the peer is from NetworkId::Public (untrusted)
4. Attacker receives real-time streams of:
   - `OrderedBlock` messages (blocks as they're ordered by consensus)
   - `CommitDecision` messages (commit decisions before finalization)
   - `BlockPayload` messages (transaction payloads)
   - `OrderedBlockWithWindow` messages (execution windows)
5. Attacker gains the same level of access as trusted VFN peers, violating trust boundaries

**Invariant Violated:**

This breaks the **Access Control** invariant: "System addresses and trusted network boundaries must be protected." The system fails to differentiate between trusted and untrusted networks when granting access to real-time consensus data.

## Impact Explanation

**High Severity** - This qualifies as a "Significant protocol violation" under Aptos bug bounty criteria for the following reasons:

1. **Trust Boundary Violation**: The fundamental security principle of network segmentation is violated. NetworkId::Public peers gain the same privileges as NetworkId::Vfn or NetworkId::Validator peers.

2. **Information Disclosure**: Attackers gain early access to consensus decisions before they're finalized on-chain, potentially enabling:
   - MEV-style attacks through timing advantages
   - Front-running based on pre-finalization block contents
   - Market manipulation through early consensus visibility

3. **Resource Exhaustion Vector**: Multiple untrusted peers can subscribe simultaneously without limits, consuming VFN resources (bandwidth, CPU for serialization, memory for active subscriptions).

4. **Protocol Design Compromise**: The intended trust model (validators → VFNs → public nodes) is undermined by allowing direct subscriptions from untrusted sources.

While this doesn't cause direct fund loss or consensus safety violations (Critical severity), it represents a significant breach of the protocol's security architecture and trust model.

## Likelihood Explanation

**High Likelihood** of exploitation:

1. **Easy to Execute**: Attack requires only standard network connectivity to a VFN's public endpoint and sending a single RPC request.

2. **No Authentication Required**: Public network connections don't require special credentials or validator-level access.

3. **Default Configuration Vulnerable**: VFNs have consensus observer enabled by default (`ENABLE_ON_VALIDATOR_FULLNODES = true`), making all VFNs potentially vulnerable.

4. **No Rate Limiting**: There's no code limiting the number of subscriptions per peer or from untrusted networks.

5. **Discoverable**: VFN endpoints are publicly known, and the consensus observer protocol is standard across all VFNs.

## Recommendation

Implement NetworkId-based trust validation in the subscription handling logic:

**Solution 1: NetworkId Validation in Publisher**

Add validation in `ConsensusPublisher::process_network_message` to reject subscriptions from untrusted networks:

```rust
fn process_network_message(&self, network_message: ConsensusPublisherNetworkMessage) {
    let (peer_network_id, message, response_sender) = network_message.into_parts();
    
    // Validate NetworkId before processing subscription requests
    if !self.is_trusted_network(&peer_network_id) {
        warn!("Rejected subscription from untrusted network: {:?}", peer_network_id);
        response_sender.send(ConsensusObserverResponse::UnsubscribeAck);
        return;
    }
    
    // ... rest of processing
}

fn is_trusted_network(&self, peer_network_id: &PeerNetworkId) -> bool {
    let network_id = peer_network_id.network_id();
    // Only allow Validator and VFN networks for validators
    // Only allow VFN network for VFNs
    matches!(network_id, NetworkId::Validator | NetworkId::Vfn)
}
```

**Solution 2: Network-Specific Registration**

Modify the registration logic to only enable consensus observer on trusted networks:

```rust
// In aptos-node/src/network.rs
if node_config.consensus_observer.is_observer_or_publisher_enabled() {
    // Only register on trusted networks
    if network_id.is_validator_network() || network_id.is_vfn_network() {
        let network_handle = register_client_and_service_with_network(
            &mut network_builder,
            network_id,
            &network_config,
            consensus_observer_network_configuration(node_config),
            false,
        );
        // Add handle...
    }
}
```

**Solution 3: Configuration-Based Trust Policy**

Add configuration options to explicitly control which NetworkIds can subscribe, with rate limiting per trust level.

## Proof of Concept

**Reproduction Steps:**

1. Set up a VFN node with consensus observer enabled (default configuration)
2. From an external node on the public network, establish a connection to the VFN's public endpoint
3. Send a `ConsensusObserverRequest::Subscribe` RPC:

```rust
// Attacker code (simplified)
use aptos_network::protocols::rpc::OutboundRpcRequest;
use consensus_observer::network::observer_message::{
    ConsensusObserverRequest, ConsensusObserverMessage
};

// Connect to VFN public endpoint
let peer_network_id = PeerNetworkId::new(NetworkId::Public, vfn_peer_id);

// Send subscribe request
let request = ConsensusObserverRequest::Subscribe;
let response = consensus_observer_client
    .send_rpc_request_to_peer(&peer_network_id, request, 5000)
    .await;

// Response will be SubscribeAck - subscription accepted!
assert!(matches!(response, Ok(ConsensusObserverResponse::SubscribeAck)));

// Now receive real-time consensus updates
// No NetworkId validation occurred
```

4. Observe that the subscription is accepted without any NetworkId validation
5. Verify that the attacker receives `OrderedBlock`, `CommitDecision`, and `BlockPayload` messages in real-time
6. Confirm no differentiation in treatment compared to trusted VFN network peers

**Expected Behavior:** Subscription from NetworkId::Public should be rejected with appropriate error.

**Actual Behavior:** Subscription is accepted, granting untrusted peer full access to consensus observer stream.

## Notes

- The vulnerability exists because the NetworkId is preserved through the event transformation pipeline but never used for access control decisions
- The trust hierarchy implied by the configuration (validators → VFNs → public nodes) is not enforced at the protocol level
- While consensus data eventually becomes public, early access provides timing advantages and violates the intended security boundaries
- Multiple attack vectors exist: resource exhaustion, timing-based MEV attacks, and trust model compromise

### Citations

**File:** aptos-node/src/network.rs (L336-358)
```rust
        // Register consensus observer (both client and server) with the network
        if node_config
            .consensus_observer
            .is_observer_or_publisher_enabled()
        {
            // Create the network handle for this network type
            let network_handle = register_client_and_service_with_network(
                &mut network_builder,
                network_id,
                &network_config,
                consensus_observer_network_configuration(node_config),
                false,
            );

            // Add the network handle to the set of handles
            if let Some(consensus_observer_network_handles) =
                &mut consensus_observer_network_handles
            {
                consensus_observer_network_handles.push(network_handle);
            } else {
                consensus_observer_network_handles = Some(vec![network_handle]);
            }
        }
```

**File:** consensus/src/consensus_observer/network/network_events.rs (L42-61)
```rust
    pub fn new(network_service_events: NetworkServiceEvents<ConsensusObserverMessage>) -> Self {
        // Transform the event streams to also include the network ID
        let network_events: Vec<_> = network_service_events
            .into_network_and_events()
            .into_iter()
            .map(|(network_id, events)| events.map(move |event| (network_id, event)))
            .collect();
        let network_events = select_all(network_events).fuse();

        // Transform each event to a network message
        let network_message_stream = network_events
            .filter_map(|(network_id, event)| {
                future::ready(Self::event_to_request(network_id, event))
            })
            .boxed();

        Self {
            network_message_stream,
        }
    }
```

**File:** consensus/src/consensus_observer/publisher/consensus_publisher.rs (L167-208)
```rust
    /// Processes a network message received by the consensus publisher
    fn process_network_message(&self, network_message: ConsensusPublisherNetworkMessage) {
        // Unpack the network message
        let (peer_network_id, message, response_sender) = network_message.into_parts();

        // Update the RPC request counter
        metrics::increment_counter(
            &metrics::PUBLISHER_RECEIVED_REQUESTS,
            message.get_label(),
            &peer_network_id,
        );

        // Handle the message
        match message {
            ConsensusObserverRequest::Subscribe => {
                // Add the peer to the set of active subscribers
                self.add_active_subscriber(peer_network_id);
                info!(LogSchema::new(LogEntry::ConsensusPublisher)
                    .event(LogEvent::Subscription)
                    .message(&format!(
                        "New peer subscribed to consensus updates! Peer: {:?}",
                        peer_network_id
                    )));

                // Send a simple subscription ACK
                response_sender.send(ConsensusObserverResponse::SubscribeAck);
            },
            ConsensusObserverRequest::Unsubscribe => {
                // Remove the peer from the set of active subscribers
                self.remove_active_subscriber(&peer_network_id);
                info!(LogSchema::new(LogEntry::ConsensusPublisher)
                    .event(LogEvent::Subscription)
                    .message(&format!(
                        "Peer unsubscribed from consensus updates! Peer: {:?}",
                        peer_network_id
                    )));

                // Send a simple unsubscription ACK
                response_sender.send(ConsensusObserverResponse::UnsubscribeAck);
            },
        }
    }
```

**File:** config/src/config/consensus_observer_config.rs (L11-14)
```rust
// Useful constants for enabling consensus observer on different node types
const ENABLE_ON_VALIDATORS: bool = true;
const ENABLE_ON_VALIDATOR_FULLNODES: bool = true;
const ENABLE_ON_PUBLIC_FULLNODES: bool = false;
```
