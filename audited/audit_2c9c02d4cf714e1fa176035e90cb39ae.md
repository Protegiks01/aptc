# Audit Report

## Title
Missing Governance Validation for RequiredGasDeposit Allows Unreasonably Low Gas Amounts Enabling Randomness API Spam

## Summary
The governance system does not validate the `gas_amount` parameter when updating `RequiredGasDeposit` configuration. A malicious or erroneous governance proposal can set `gas_amount: Some(1)`, making randomness API deposits trivially cheap and enabling spam attacks that could degrade network performance.

## Finding Description

The `RequiredGasDeposit` configuration controls the gas deposit required for transactions using the randomness API. When governance proposals update this value via `randomness_api_v0_config::set_for_next_epoch()`, there is no validation to ensure the `gas_amount` maintains reasonable bounds. [1](#0-0) 

The function accepts any `Option<u64>` value without validation. The governance system validates proposer stake and voting requirements but does not validate the actual parameter values being passed to the execution script: [2](#0-1) 

A governance proposal can execute arbitrary Move code including:
```move
randomness_api_v0_config::set_for_next_epoch(&framework_signer, option::some(1));
```

This would set the required deposit to just 1 gas unit, making randomness API access essentially free. While the `REQUIRED_DEPOSIT_INCONSISTENT_WITH_TXN_MAX_GAS` status code exists: [3](#0-2) 

The validation logic that should enforce minimum bounds is either missing or insufficient. The `RandomnessConfig` structure simply fetches whatever value is stored: [4](#0-3) 

## Impact Explanation

This qualifies as **Medium Severity** per the Aptos bug bounty criteria because it enables:

1. **Resource Exhaustion**: An unreasonably low deposit requirement (e.g., 1 gas unit) removes the economic barrier preventing spam on the randomness API
2. **Network Degradation**: Attackers could flood randomness-consuming transactions at minimal cost, degrading validator performance
3. **State Inconsistencies**: Mass spam could lead to state management issues requiring manual intervention

The impact is limited to Medium (not Critical/High) because:
- It requires passing a governance proposal (high barrier)
- Does not directly cause fund loss or consensus violation
- Can be fixed by another governance proposal
- Does not cause permanent network damage

## Likelihood Explanation

**Likelihood: Low to Medium**

**Requirements:**
- Attacker must create and pass a governance proposal
- Requires significant stake to propose (minimum proposer stake)
- Requires 50%+ voting power to pass
- Takes time (voting duration period)

**However:**
- Could occur accidentally through honest governance error
- No validation provides defense-in-depth
- Once set, immediately exploitable by any user
- Economic damage could be significant before corrective proposal passes

## Recommendation

Add validation to `set_for_next_epoch` to enforce minimum reasonable bounds:

```move
public fun set_for_next_epoch(framework: &signer, gas_amount: Option<u64>) {
    system_addresses::assert_aptos_framework(framework);
    
    // Validate minimum gas amount if specified
    if (option::is_some(&gas_amount)) {
        let amount = *option::borrow(&gas_amount);
        // Minimum should be at least intrinsic gas cost (e.g., 1000)
        assert!(
            amount >= 1000,
            error::invalid_argument(EGAS_AMOUNT_TOO_LOW)
        );
    };
    
    config_buffer::upsert(RequiredGasDeposit { gas_amount });
}
```

Add corresponding error constant:
```move
const EGAS_AMOUNT_TOO_LOW: u64 = 1;
```

The minimum threshold (1000 in example) should be calibrated based on:
- Typical transaction intrinsic costs
- Randomness API operational costs
- Economic spam prevention requirements

## Proof of Concept

**Exploitation Steps:**

1. Create governance proposal with malicious script:
```move
script {
    use aptos_framework::aptos_governance;
    use aptos_framework::randomness_api_v0_config;
    use std::option;

    fun malicious_proposal(core_resources: &signer) {
        let framework_signer = aptos_governance::get_signer_testnet_only(core_resources, @0x1);
        randomness_api_v0_config::set_for_next_epoch(&framework_signer, option::some(1));
        aptos_governance::reconfigure(&framework_signer);
    }
}
```

2. Proposal passes through governance vote

3. After epoch boundary, randomness API transactions require only 1 gas unit deposit

4. Attacker submits thousands of randomness transactions with max_gas=1:
```rust
for _ in 0..10000 {
    // Each transaction costs only 1 gas unit deposit
    submit_randomness_transaction(max_gas: 1);
}
```

5. Network experiences degraded performance due to spam volume

**Verification Test:** [5](#0-4) 

The test infrastructure already demonstrates setting `option::some(10000)` as required gas. Modifying to `option::some(1)` would demonstrate the vulnerability, though the test doesn't validate minimum bounds.

---

**Notes:**

The vulnerability breaks the **Resource Limits** and **Governance Integrity** invariants by allowing governance to set configuration values that undermine the economic security model of the randomness API. While governance is generally trusted, defense-in-depth principles require validation of critical configuration parameters to prevent both malicious proposals and honest mistakes.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/configs/randomness_api_v0_config.move (L25-29)
```text
    /// This can be called by on-chain governance to update `RequiredGasDeposit` for the next epoch.
    public fun set_for_next_epoch(framework: &signer, gas_amount: Option<u64>) {
        system_addresses::assert_aptos_framework(framework);
        config_buffer::upsert(RequiredGasDeposit { gas_amount });
    }
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L405-461)
```text
    public fun create_proposal_v2_impl(
        proposer: &signer,
        stake_pool: address,
        execution_hash: vector<u8>,
        metadata_location: vector<u8>,
        metadata_hash: vector<u8>,
        is_multi_step_proposal: bool,
    ): u64 acquires GovernanceConfig, GovernanceEvents {
        check_governance_permission(proposer);
        let proposer_address = signer::address_of(proposer);
        assert!(
            stake::get_delegated_voter(stake_pool) == proposer_address,
            error::invalid_argument(ENOT_DELEGATED_VOTER)
        );

        // The proposer's stake needs to be at least the required bond amount.
        let governance_config = borrow_global<GovernanceConfig>(@aptos_framework);
        let stake_balance = get_voting_power(stake_pool);
        assert!(
            stake_balance >= governance_config.required_proposer_stake,
            error::invalid_argument(EINSUFFICIENT_PROPOSER_STAKE),
        );

        // The proposer's stake needs to be locked up at least as long as the proposal's voting period.
        let current_time = timestamp::now_seconds();
        let proposal_expiration = current_time + governance_config.voting_duration_secs;
        assert!(
            stake::get_lockup_secs(stake_pool) >= proposal_expiration,
            error::invalid_argument(EINSUFFICIENT_STAKE_LOCKUP),
        );

        // Create and validate proposal metadata.
        let proposal_metadata = create_proposal_metadata(metadata_location, metadata_hash);

        // We want to allow early resolution of proposals if more than 50% of the total supply of the network coins
        // has voted. This doesn't take into subsequent inflation/deflation (rewards are issued every epoch and gas fees
        // are burnt after every transaction), but inflation/delation is very unlikely to have a major impact on total
        // supply during the voting period.
        let total_voting_token_supply = coin::supply<AptosCoin>();
        let early_resolution_vote_threshold = option::none<u128>();
        if (option::is_some(&total_voting_token_supply)) {
            let total_supply = *option::borrow(&total_voting_token_supply);
            // 50% + 1 to avoid rounding errors.
            early_resolution_vote_threshold = option::some(total_supply / 2 + 1);
        };

        let proposal_id = voting::create_proposal_v2(
            proposer_address,
            @aptos_framework,
            governance_proposal::create_proposal(),
            execution_hash,
            governance_config.min_voting_threshold,
            proposal_expiration,
            early_resolution_vote_threshold,
            proposal_metadata,
            is_multi_step_proposal,
        );
```

**File:** third_party/move/move-core/types/src/vm_status.rs (L658-658)
```rust
    REQUIRED_DEPOSIT_INCONSISTENT_WITH_TXN_MAX_GAS = 39,
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L284-298)
```rust
impl RandomnessConfig {
    /// Returns randomness config based on the current state.
    pub fn fetch(state_view: &impl StateView) -> Self {
        let randomness_api_v0_required_deposit = RequiredGasDeposit::fetch_config(state_view)
            .unwrap_or_else(RequiredGasDeposit::default_if_missing)
            .gas_amount;
        let allow_rand_contract_custom_max_gas = AllowCustomMaxGasFlag::fetch_config(state_view)
            .unwrap_or_else(AllowCustomMaxGasFlag::default_if_missing)
            .value;
        Self {
            randomness_api_v0_required_deposit,
            allow_rand_contract_custom_max_gas,
        }
    }
}
```

**File:** testsuite/smoke-test/src/randomness/entry_func_attrs.rs (L184-191)
```rust
    fun main(core_resources: &signer) {{
        let framework_signer = aptos_governance::get_signer_testnet_only(core_resources, @0x1);
        let required_gas = if ({}) {{ option::some(10000) }} else {{ option::none() }};
        randomness_api_v0_config::set_for_next_epoch(&framework_signer, required_gas);
        let allow_custom_max_gas = {};
        randomness_api_v0_config::set_allow_max_gas_flag_for_next_epoch(&framework_signer, allow_custom_max_gas);
        aptos_governance::reconfigure(&framework_signer);
    }}
```
