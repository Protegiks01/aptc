# Audit Report

## Title
Application-Level Rate Limiting Disabled by Default Allows DoS Attacks Against Validators

## Summary
The Aptos validator network has no application-level bandwidth rate limiting enabled by default, relying solely on optional HAProxy infrastructure. The `IP_BYTE_BUCKET_RATE` constant (102400 bytes/s) is defined but never used because `inbound_rate_limit_config` and `outbound_rate_limit_config` are set to `None` by default. Additionally, connection limiting explicitly exempts trusted peers (including validators), leaving the validator network vulnerable to bandwidth exhaustion attacks from authenticated peers or when HAProxy is disabled/bypassed.

## Finding Description

The vulnerability exists across multiple layers of the network stack:

**1. Rate Limiting Disabled by Default**

The `NetworkConfig::network_with_id()` function sets both rate limit configurations to `None`: [1](#0-0) 

This means despite `RateLimitConfig` having a default implementation with `IP_BYTE_BUCKET_RATE = 102400` (100 KiB/s): [2](#0-1) 

The application-level rate limiting is completely disabled unless explicitly configured.

**2. Connection Limiting Excludes Trusted Peers**

Even the connection count limiting (`MAX_INBOUND_CONNECTIONS = 100`) does not protect validators because it only applies to unknown peers: [3](#0-2) 

The validator network uses mutual authentication, meaning all validators are trusted peers and bypass this protection entirely.

**3. HAProxy Protection is Optional and Incomplete**

While HAProxy provides 50 MB/s per-IP rate limiting in production deployments: [4](#0-3) 

This protection:
- Can be disabled (`haproxy.enabled: false`)
- May be bypassed for direct validator-to-validator connections in the full-mesh topology
- Is not present in non-Helm deployments
- Doesn't apply to the VFN network (port 6181)

**4. Validator Network Architecture Amplifies Risk**

Validators maintain a full-mesh network topology: [5](#0-4) 

This means each validator must accept connections from all other validators, amplifying the attack surface.

## Attack Scenarios

**Scenario 1: Malicious Validator Bandwidth Exhaustion**
A compromised validator in the active set can send unlimited traffic to all other validators, consuming their bandwidth and CPU resources without any application-level throttling.

**Scenario 2: HAProxy Bypass**
For deployments without HAProxy or where validators connect directly (bypassing HAProxy), there is zero rate limiting, allowing complete bandwidth saturation.

**Scenario 3: VFN Network Attack**
The VFN network (port 6181) has even weaker protections and could be flooded to disrupt validator-fullnode communication.

## Impact Explanation

**High Severity** - This vulnerability qualifies as High severity per Aptos bug bounty criteria:

1. **Validator Node Slowdowns**: Unlimited inbound traffic can exhaust network bandwidth, CPU resources (for processing), and memory (for buffering), causing degraded validator performance.

2. **Potential Total Loss of Liveness**: If enough validators are simultaneously overwhelmed, the network could fail to reach consensus quorum (>2/3), causing complete liveness failure.

3. **Significant Protocol Violations**: The lack of rate limiting violates the Resource Limits invariant (#9): "All operations must respect gas, storage, and computational limits."

The issue is particularly severe because:
- It affects the core consensus network
- Authenticated peers (validators) can exploit it without detection
- No application-level defense exists by default
- Recovery requires manual intervention to identify and disconnect malicious peers

## Likelihood Explanation

**High Likelihood** - This vulnerability is highly likely to be exploited because:

1. **Easy to Execute**: Any authenticated peer can simply send traffic at maximum rate with no special tooling required.

2. **Low Detection Risk**: Since there's no rate limiting, the attack appears as "legitimate" traffic until bandwidth is exhausted.

3. **Multiple Attack Vectors**: Can be exploited through:
   - Compromised validator nodes
   - Deployments without HAProxy
   - Direct validator-to-validator connections
   - VFN network connections

4. **No Authentication Required for Some Paths**: While validators use mutual auth, the VFN network accepts connections from any fullnode.

5. **Production Impact**: Many deployments may disable HAProxy for performance or run manual configurations without it.

## Recommendation

**Immediate Fixes:**

1. **Enable Default Rate Limiting**: Modify the default `NetworkConfig` to enable rate limiting: [6](#0-5) 

Change lines 158-159 from:
```rust
inbound_rate_limit_config: None,
outbound_rate_limit_config: None,
```

To:
```rust
inbound_rate_limit_config: Some(RateLimitConfig::default()),
outbound_rate_limit_config: Some(RateLimitConfig::default()),
```

2. **Increase Default Rate Limit**: The current `IP_BYTE_BUCKET_RATE` of 102400 (100 KiB/s) is too restrictive. Increase to at least 10 MB/s for validators:

```rust
pub const IP_BYTE_BUCKET_RATE: usize = 10_485_760; /* 10 MiB/s */
```

3. **Apply Rate Limiting to Trusted Peers**: Implement separate, higher rate limits for trusted peers rather than exempting them entirely.

4. **Add Per-Connection Rate Limiting**: In addition to per-IP limiting, add per-connection bandwidth limits.

5. **Document HAProxy Dependency**: Clearly document that HAProxy is required for production deployments and should not be disabled.

**Long-term Fixes:**

1. Implement application-level circuit breakers that auto-disconnect peers exceeding sustained bandwidth thresholds
2. Add bandwidth consumption metrics and alerts
3. Implement adaptive rate limiting based on network conditions
4. Add rate limiting to the validator network specifically, with appropriate limits for consensus traffic

## Proof of Concept

```rust
// Reproduction steps:
// 1. Deploy two validators without HAProxy
// 2. Configure both with default NetworkConfig (rate limiting disabled)
// 3. From validator A, send continuous maximum-size messages to validator B

use aptos_config::config::NetworkConfig;
use aptos_types::network_address::NetworkAddress;

#[test]
fn test_no_rate_limiting_by_default() {
    // Create default validator network config
    let config = NetworkConfig::network_with_id(
        aptos_config::network_id::NetworkId::Validator
    );
    
    // Verify rate limiting is disabled by default
    assert!(config.inbound_rate_limit_config.is_none());
    assert!(config.outbound_rate_limit_config.is_none());
    
    // This means an attacker can send unlimited traffic:
    // - No per-IP byte bucket limiting
    // - No per-connection bandwidth throttling  
    // - Connection count limit only applies to unknown peers
    // - Validators in the active set are trusted peers
    
    // Attack: Send MAX_MESSAGE_SIZE (64 MiB) messages continuously
    // With no rate limiting, this saturates the connection bandwidth
    let max_msg_size = config.max_message_size;
    assert_eq!(max_msg_size, 64 * 1024 * 1024); // 64 MiB
    
    // An attacker can send ~100 such messages per second on a 50 Gbps link,
    // consuming 6.4 GB/s of bandwidth with zero throttling
}
```

**Notes**

The vulnerability is exacerbated by the full-mesh validator topology where each validator must accept connections from all others. With 100+ validators, a single malicious node can impact the entire network. The reliance on optional infrastructure-level protection (HAProxy) creates a single point of failure in the security model. Production deployments may unknowingly operate without adequate protection if HAProxy is disabled for performance tuning or debugging.

### Citations

**File:** config/src/config/network_config.rs (L52-53)
```rust
pub const IP_BYTE_BUCKET_RATE: usize = 102400 /* 100 KiB */;
pub const IP_BYTE_BUCKET_SIZE: usize = IP_BYTE_BUCKET_RATE;
```

**File:** config/src/config/network_config.rs (L135-176)
```rust
    pub fn network_with_id(network_id: NetworkId) -> NetworkConfig {
        let mutual_authentication = network_id.is_validator_network();
        let mut config = Self {
            discovery_method: DiscoveryMethod::None,
            discovery_methods: Vec::new(),
            identity: Identity::None,
            listen_address: "/ip4/0.0.0.0/tcp/6180".parse().unwrap(),
            mutual_authentication,
            network_id,
            runtime_threads: None,
            seed_addrs: HashMap::new(),
            seeds: PeerSet::default(),
            max_frame_size: MAX_FRAME_SIZE,
            enable_proxy_protocol: false,
            max_connection_delay_ms: MAX_CONNECTION_DELAY_MS,
            connectivity_check_interval_ms: CONNECTIVITY_CHECK_INTERVAL_MS,
            network_channel_size: NETWORK_CHANNEL_SIZE,
            connection_backoff_base: CONNECTION_BACKOFF_BASE,
            ping_interval_ms: PING_INTERVAL_MS,
            ping_timeout_ms: PING_TIMEOUT_MS,
            ping_failures_tolerated: PING_FAILURES_TOLERATED,
            max_outbound_connections: MAX_FULLNODE_OUTBOUND_CONNECTIONS,
            max_inbound_connections: MAX_INBOUND_CONNECTIONS,
            inbound_rate_limit_config: None,
            outbound_rate_limit_config: None,
            max_message_size: MAX_MESSAGE_SIZE,
            inbound_rx_buffer_size_bytes: None,
            inbound_tx_buffer_size_bytes: None,
            outbound_rx_buffer_size_bytes: None,
            outbound_tx_buffer_size_bytes: None,
            max_parallel_deserialization_tasks: None,
            enable_latency_aware_dialing: true,
        };

        // Configure the number of parallel deserialization tasks
        config.configure_num_deserialization_tasks();

        // Prepare the identity based on the identity format
        config.prepare_identity();

        config
    }
```

**File:** network/framework/src/peer_manager/mod.rs (L352-389)
```rust
        if conn.metadata.origin == ConnectionOrigin::Inbound {
            // Everything below here is meant for unknown peers only. The role comes from
            // the Noise handshake and if it's not `Unknown` then it is trusted.
            if conn.metadata.role == PeerRole::Unknown {
                // TODO: Keep track of somewhere else to not take this hit in case of DDoS
                // Count unknown inbound connections
                let unknown_inbound_conns = self
                    .active_peers
                    .iter()
                    .filter(|(peer_id, (metadata, _))| {
                        metadata.origin == ConnectionOrigin::Inbound
                            && trusted_peers
                                .get(peer_id)
                                .is_none_or(|peer| peer.role == PeerRole::Unknown)
                    })
                    .count();

                // Reject excessive inbound connections made by unknown peers
                // We control outbound connections with Connectivity manager before we even send them
                // and we must allow connections that already exist to pass through tie breaking.
                if !self
                    .active_peers
                    .contains_key(&conn.metadata.remote_peer_id)
                    && unknown_inbound_conns + 1 > self.inbound_connection_limit
                {
                    info!(
                        NetworkSchema::new(&self.network_context)
                            .connection_metadata_with_address(&conn.metadata),
                        "{} Connection rejected due to connection limit: {}",
                        self.network_context,
                        conn.metadata
                    );
                    counters::connections_rejected(&self.network_context, conn.metadata.origin)
                        .inc();
                    self.disconnect(conn);
                    return;
                }
            }
```

**File:** terraform/helm/aptos-node/files/haproxy.cfg (L54-58)
```text
    # Create TCP request bandwidth limits of 50 MB/s (per source IP)
    filter bwlim-in incoming-src-limit key src table limit-by-src limit 50m
    filter bwlim-out outgoing-src-limit key src table limit-by-src limit 50m
    tcp-request content set-bandwidth-limit incoming-src-limit
    tcp-request content set-bandwidth-limit outgoing-src-limit
```

**File:** network/README.md (L30-35)
```markdown
Validators will only allow connections from other validators. Their identity and
public key information is provided by the [`validator-set-discovery`] protocol,
which updates the eligible member information on each consensus reconfiguration.
Each member of the validator network maintains a full membership view and connects
directly to all other validators in order to maintain a full-mesh network.

```
