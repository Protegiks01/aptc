# Audit Report

## Title
Missing Target Round Validation in Block Retrieval Allows Resource Exhaustion Through Future Round Requests

## Summary
The `BlockRetrievalRequest::V2` construction function `new_with_target_round()` accepts arbitrary `target_round` values without validation. Attackers can request blocks from millions of rounds in the future, forcing validator nodes to perform unnecessary computational work iterating through blocks to check against an impossible condition.

## Finding Description

The block retrieval system in Aptos consensus uses `BlockRetrievalRequestV2` to fetch historical blocks based on a `target_round` parameter. However, there is no validation that `target_round` is within a reasonable range of the current consensus round. [1](#0-0) 

The function simply accepts the `target_round` parameter without any bounds checking. When a node receives such a request, it processes it in `process_block_retrieval_inner()`: [2](#0-1) 

The processing loop checks each block using `is_window_start_block()`: [3](#0-2) 

When `target_round` is set to a value far in the future (e.g., `u64::MAX` or billions), no existing block will satisfy:
- `block.round() == self.target_round()` (no current block has such a high round)
- `block.round() > self.target_round()` (no current block exceeds the future round)

The loop continues iterating through blocks until `num_blocks` is exhausted (max 100 blocks), performing unnecessary work.

In contrast, legitimate usage calculates `target_round` based on consensus state: [4](#0-3) [5](#0-4) 

While `num_blocks` is validated with a maximum limit: [6](#0-5) 

There is **no corresponding validation** for `target_round`. The DAG consensus path has proper validation: [7](#0-6) 

But the block retrieval path lacks this protection.

**Attack Path:**
1. Attacker crafts `BlockRetrievalRequest::V2` with `target_round = u64::MAX` and `num_blocks = 100`
2. Request passes validation (only `num_blocks` is checked)
3. Victim node processes request in `process_block_retrieval_inner()`
4. Node iterates through 100 blocks, checking each against impossible `target_round` condition
5. All checks fail, node returns `NotEnoughBlocks` status after wasting CPU cycles
6. Attacker sends multiple concurrent requests to amplify resource consumption

## Impact Explanation

This vulnerability qualifies as **Medium Severity** under Aptos bug bounty criteria:
- **Validator node slowdowns**: Multiple malicious requests can cause CPU resource exhaustion on validator nodes
- **State inconsistencies requiring intervention**: While not directly causing state issues, widespread exploitation could require operator intervention to maintain network performance

The impact is bounded by the `max_blocks_per_receiving_request` limit (100 blocks with quorum store), preventing Critical severity. However, coordinated attacks with many concurrent requests could significantly degrade validator performance during block synchronization periods.

## Likelihood Explanation

**Likelihood: High**

The attack is trivially exploitable:
- No authentication or special privileges required beyond network connectivity
- Attack can be automated and scaled across multiple peers
- The vulnerability exists in all nodes processing BlockRetrievalRequest::V2 messages
- Detection is difficult as requests appear structurally valid (pass `num_blocks` validation)
- No rate limiting specifically targets malformed `target_round` values

Block retrieval is a frequent operation during consensus synchronization, making this attack vector constantly available.

## Recommendation

Add validation in the block retrieval request handler to reject requests with unreasonable `target_round` values:

**Option 1: Validate in `spawn_block_retrieval_task()`**

```rust
BlockRetrievalRequest::V2(v2) => {
    if v2.num_blocks() > max_blocks_allowed {
        warn!("Ignore block retrieval with too many blocks: {}", v2.num_blocks());
        continue;
    }
    
    // Add target_round validation
    let current_round = block_store.ordered_root().round();
    let max_reasonable_target = current_round + MAX_FUTURE_ROUND_TOLERANCE; // e.g., 1000
    if v2.target_round() > max_reasonable_target {
        warn!(
            "Ignore block retrieval with unreasonable target_round: {} (current: {})",
            v2.target_round(), current_round
        );
        continue;
    }
    
    // Process request...
}
```

**Option 2: Add validation in `BlockRetrievalRequestV2::new_with_target_round()`**

Return `Result<Self, Error>` and validate against a maximum reasonable round offset.

**Recommended constants:**
- `MAX_FUTURE_ROUND_TOLERANCE`: 1000-10000 rounds (allow some clock skew and fast-forward scenarios)
- Align with the `window_size` configuration used in legitimate `calculate_window_start_round()` calls

## Proof of Concept

```rust
// Malicious peer sends this request to a validator node
use aptos_consensus_types::block_retrieval::BlockRetrievalRequest;
use aptos_crypto::hash::HashValue;

// Craft malicious request with future target_round
let malicious_request = BlockRetrievalRequest::new_with_target_round(
    HashValue::random(),  // Any valid block_id
    100,                   // Max allowed num_blocks
    u64::MAX,              // Target round far in the future
);

// When victim node receives this via network RPC:
// 1. Request passes num_blocks validation (100 <= max_blocks_allowed)
// 2. process_block_retrieval_inner() is called
// 3. Loop iterates through 100 blocks checking is_window_start_block()
// 4. All checks fail (no block round >= u64::MAX)
// 5. Returns NotEnoughBlocks after wasting CPU cycles

// Attack amplification:
// Send 1000 concurrent requests from multiple peers
// Each forces victim to check 100 blocks against impossible condition
// Total: 100,000 unnecessary block lookups and comparisons
```

**Notes:**

This vulnerability represents a missing input validation that violates the "Resource Limits" invariant. The bounded nature of the impact (max 100 blocks per request) prevents Critical severity, but the ease of exploitation and potential for validator slowdowns under coordinated attack justifies Medium severity classification. The fix is straightforward and should be applied consistently with the validation pattern already present in the DAG consensus path.

### Citations

**File:** consensus/consensus-types/src/block_retrieval.rs (L24-30)
```rust
    pub fn new_with_target_round(block_id: HashValue, num_blocks: u64, target_round: u64) -> Self {
        Self::V2(BlockRetrievalRequestV2 {
            block_id,
            num_blocks,
            target_round,
        })
    }
```

**File:** consensus/consensus-types/src/block_retrieval.rs (L152-156)
```rust
    pub fn is_window_start_block(&self, block: &Block) -> bool {
        block.round() == self.target_round()
            || (block.round() > self.target_round()
                && block.quorum_cert().certified_block().round() < self.target_round())
    }
```

**File:** consensus/src/block_storage/sync_manager.rs (L349-360)
```rust
            Some(window_size) => {
                let target_round = calculate_window_start_round(
                    highest_commit_cert.ledger_info().ledger_info().round(),
                    window_size,
                )
                .max(1); // Never retrieve genesis block
                let num_blocks = highest_quorum_cert.certified_block().round() - target_round + 1;
                info!(
                    "[FastForwardSync] with window_size: {}, target_round: {}, num_blocks: {}",
                    window_size, target_round, num_blocks
                );
                (TargetBlockRetrieval::TargetRound(target_round), num_blocks)
```

**File:** consensus/src/block_storage/sync_manager.rs (L567-583)
```rust
            BlockRetrievalRequest::V2(req) => {
                while (blocks.len() as u64) < req.num_blocks() {
                    if let Some(executed_block) = self.get_block(id) {
                        if !executed_block.block().is_genesis_block() {
                            blocks.push(executed_block.block().clone());
                        }
                        if req.is_window_start_block(executed_block.block()) {
                            status = BlockRetrievalStatus::SucceededWithTarget;
                            break;
                        }
                        id = executed_block.parent_id();
                    } else {
                        status = BlockRetrievalStatus::NotEnoughBlocks;
                        break;
                    }
                }
            },
```

**File:** consensus/src/util/mod.rs (L26-29)
```rust
pub fn calculate_window_start_round(current_round: Round, window_size: u64) -> Round {
    assert!(window_size > 0);
    (current_round + 1).saturating_sub(window_size)
}
```

**File:** consensus/src/epoch_manager.rs (L608-615)
```rust
                    BlockRetrievalRequest::V2(v2) => {
                        if v2.num_blocks() > max_blocks_allowed {
                            warn!(
                                "Ignore block retrieval with too many blocks: {}",
                                v2.num_blocks()
                            );
                            continue;
                        }
```

**File:** consensus/src/dag/types.rs (L717-724)
```rust
        ensure!(
            self.exists_bitmask.first_round() + self.exists_bitmask.bitmask.len() as u64 - 1
                == target_round,
            "Bitmask length doesn't match, first_round {}, length {}, target {}",
            self.exists_bitmask.first_round(),
            self.exists_bitmask.bitmask.len(),
            target_round
        );
```
