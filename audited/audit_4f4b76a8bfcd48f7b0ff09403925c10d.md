# Audit Report

## Title
Database Primary Key Collision in Fungible Token Ownership Indexing Causes Record Loss

## Summary
The `get_ft_v2_from_write_resource()` function incorrectly uses the fungible asset metadata address as `storage_id`, causing primary key collisions when a single owner possesses multiple `FungibleAssetStore` objects for the same fungible asset type. This results in failed database INSERTs and dropped ownership records in the indexer.

## Finding Description

The Aptos fungible asset framework explicitly allows users to create multiple `FungibleAssetStore` objects for the same metadata to "isolate fungible assets for different purposes" [1](#0-0) . Each store is a distinct object with its own address and can be owned by the same account.

The indexer's `get_ft_v2_from_write_resource()` function extracts fungible token ownership data from blockchain state. At line 384, it sets `storage_id` to `token_data_id` (the metadata address) [2](#0-1) . This is problematic because:

1. `token_data_id` is derived from `inner.metadata.get_reference_address()`, which returns the shared metadata object address [3](#0-2) 

2. The `CurrentTokenOwnershipV2` table uses a composite primary key of `(token_data_id, property_version_v1, owner_address, storage_id)` [4](#0-3) 

3. When the same owner has multiple stores for the same metadata:
   - Both stores have identical `token_data_id` (metadata address)
   - Both have `property_version_v1 = 0` [5](#0-4) 
   - Both have the same `owner_address` (from `object_core.get_owner_address()`) [6](#0-5) 
   - Both have identical `storage_id` (same metadata address)

This creates identical primary keys, causing the second INSERT to fail and the ownership record to be dropped.

**Attack Path:**
1. User deploys a fungible asset with metadata at address `M`
2. User creates Store A at address `S1` for metadata `M` owned by account `U`
3. User creates Store B at address `S2` for metadata `M` owned by account `U`
4. Indexer processes Store A: inserts record with PK = `(M, 0, U, M)`
5. Indexer processes Store B: attempts to insert record with PK = `(M, 0, U, M)` → **COLLISION**
6. Store B's ownership record is dropped from the database

The `resource.address` field contains the unique store address [7](#0-6)  but is not used as `storage_id`, causing this collision.

## Impact Explanation

**Severity: Medium**

This vulnerability causes data integrity issues in the indexer database:

1. **Incomplete Ownership Data**: Fungible token ownership records are silently dropped, causing the indexer API to return incorrect/incomplete balance information for users with multiple stores

2. **Application Failures**: DApps relying on the indexer REST API will receive incorrect token balance data, potentially causing transaction failures or user fund access issues

3. **Indexer Processor Failures**: Depending on INSERT error handling, this could cause the indexer processor to crash or hang, affecting API availability

While this doesn't affect on-chain consensus or execution (the blockchain state remains correct), it creates significant issues for applications and users who rely on the indexer for querying token balances. This qualifies as "Medium Severity: State inconsistencies requiring intervention" per the bug bounty criteria, as the indexer state diverges from actual blockchain state and requires manual intervention to detect and correct.

## Likelihood Explanation

**Likelihood: High**

The vulnerability is highly likely to occur because:

1. **Legitimate Use Case**: Creating multiple stores for the same fungible asset is a documented, intended feature for applications to isolate assets for different purposes (e.g., separate gaming inventories, escrow accounts, vesting schedules)

2. **No Special Privileges Required**: Any user can create multiple stores using the public `create_store()` function [8](#0-7) 

3. **Common Pattern**: Applications using fungible assets for complex use cases will naturally create multiple stores per user, triggering this bug routinely

4. **Silent Failure**: The bug causes silent data loss without obvious errors, making it difficult to detect until users report missing balances

## Recommendation

Change `storage_id` to use the unique FungibleAssetStore object address instead of the shared metadata address:

**File**: `crates/indexer/src/models/token_models/v2_token_ownerships.rs`

**Current code** (line 384): [2](#0-1) 

**Fixed code**:
```rust
let token_data_id = inner.metadata.get_reference_address();
let storage_id = standardize_address(&resource.address); // Use store address, not metadata address
```

This ensures each FungibleAssetStore object gets a unique `storage_id` in the database, preventing collisions while maintaining the ability to link stores to their metadata via `token_data_id`.

## Proof of Concept

**Move Module** (demonstrates creating multiple stores):

```move
module test_addr::multi_store_test {
    use aptos_framework::fungible_asset::{Self, Metadata};
    use aptos_framework::object::{Self, Object};
    use aptos_framework::primary_fungible_store;
    
    /// Creates a fungible asset and two separate stores for the same owner
    public entry fun create_collision_scenario(creator: &signer) {
        // Create fungible asset metadata
        let constructor_ref = object::create_named_object(creator, b"TEST_FA");
        let metadata = fungible_asset::add_fungibility(
            &constructor_ref,
            option::none(), // unlimited supply
            string::utf8(b"Test Token"),
            string::utf8(b"TEST"),
            8,
            string::utf8(b""),
            string::utf8(b"")
        );
        
        // Create first store for creator
        let store1_constructor = object::create_object_from_account(creator);
        let store1 = fungible_asset::create_store(&store1_constructor, metadata);
        
        // Create second store for the SAME creator with SAME metadata
        let store2_constructor = object::create_object_from_account(creator);
        let store2 = fungible_asset::create_store(&store2_constructor, metadata);
        
        // Both stores exist on-chain with same owner and metadata
        // When indexer processes both:
        // - Store 1: PK = (metadata_addr, 0, creator_addr, metadata_addr)
        // - Store 2: PK = (metadata_addr, 0, creator_addr, metadata_addr) <- COLLISION!
        // Store 2's ownership record will be dropped from indexer database
    }
}
```

**Expected Indexer Behavior:**
1. Transaction creates two FungibleAssetStore WriteResources at different addresses
2. Indexer processes first store → successful INSERT with `storage_id = metadata_address`
3. Indexer processes second store → PRIMARY KEY VIOLATION → record dropped
4. Indexer database now missing ownership record for second store despite it existing on-chain

**Verification Steps:**
1. Deploy and execute the above Move module
2. Query indexer API for creator's fungible asset holdings
3. Observe that only one store is returned despite two existing on-chain
4. Directly query blockchain state to confirm both stores exist with balances
5. Confirm indexer database has only one record due to collision

### Citations

**File:** aptos-move/framework/aptos-framework/sources/fungible_asset.move (L878-879)
```text
    /// Allow an object to hold a store for fungible assets.
    /// Applications can use this to create multiple stores for isolating fungible assets for different purposes.
```

**File:** aptos-move/framework/aptos-framework/sources/fungible_asset.move (L880-903)
```text
    public fun create_store<T: key>(
        constructor_ref: &ConstructorRef, metadata: Object<T>
    ): Object<FungibleStore> {
        let store_obj = &constructor_ref.generate_signer();
        move_to(
            store_obj,
            FungibleStore { metadata: metadata.convert(), balance: 0, frozen: false }
        );

        if (is_untransferable(metadata)) {
            constructor_ref.set_untransferable();
        };

        if (default_to_concurrent_fungible_balance()) {
            move_to(
                store_obj,
                ConcurrentFungibleBalance {
                    balance: aggregator_v2::create_unbounded_aggregator()
                }
            );
        };

        constructor_ref.object_from_constructor_ref<FungibleStore>()
    }
```

**File:** crates/indexer/src/models/token_models/v2_token_ownerships.rs (L60-60)
```rust
#[diesel(primary_key(token_data_id, property_version_v1, owner_address, storage_id))]
```

**File:** crates/indexer/src/models/token_models/v2_token_ownerships.rs (L383-384)
```rust
                let token_data_id = inner.metadata.get_reference_address();
                let storage_id = token_data_id.clone();
```

**File:** crates/indexer/src/models/token_models/v2_token_ownerships.rs (L408-408)
```rust
                        property_version_v1: BigDecimal::zero(),
```

**File:** crates/indexer/src/models/token_models/v2_token_utils.rs (L77-79)
```rust
    pub fn get_owner_address(&self) -> String {
        standardize_address(&self.owner)
    }
```

**File:** crates/indexer/src/models/token_models/v2_token_utils.rs (L240-242)
```rust
    pub fn get_reference_address(&self) -> String {
        standardize_address(&self.inner)
    }
```

**File:** crates/indexer/src/models/move_resources.rs (L49-49)
```rust
            address: standardize_address(&write_resource.address.to_string()),
```
