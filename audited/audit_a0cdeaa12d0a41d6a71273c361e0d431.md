# Audit Report

## Title
Database Credential Exposure via Unauthenticated Ready Server Endpoint in Local Testnet

## Summary
The ReadyData struct in the local testnet ready server serializes HealthChecker instances containing PostgreSQL connection strings with embedded passwords. These credentials are exposed via an unauthenticated HTTP endpoint, allowing any attacker who can reach the server to extract database credentials and internal network information.

## Finding Description

The vulnerability exists in the ready server implementation used by the Aptos local testnet. The `ReadyData` struct serializes `HealthChecker` enum instances to JSON and exposes them through an HTTP endpoint without authentication. [1](#0-0) 

The `HealthChecker` enum is marked with `#[derive(Serialize)]` and contains variants that store sensitive connection information: [2](#0-1) 

Critically, the `Postgres` and `Processor` variants store full PostgreSQL connection strings. When `--use-host-postgres` and `--host-postgres-password` flags are used, the connection string includes the password in plaintext format: [3](#0-2) 

The connection string format is `postgres://username:password@host:port/database`, where the password is directly embedded when provided.

These HealthChecker instances are collected and returned as JSON in the ready server's root handler: [4](#0-3) 

The endpoint has no authentication mechanism and when running inside a container (detected by checking `/.dockerenv`), the server binds to `0.0.0.0`, exposing it to the entire network: [5](#0-4) 

**Attack Flow:**
1. Attacker identifies an exposed ready server endpoint (default port 8070)
2. Attacker sends HTTP GET request to `http://<target>:8070/`
3. Server returns JSON containing `ReadyData` with all HealthChecker instances
4. Attacker extracts PostgreSQL connection strings containing:
   - Database passwords (if `--host-postgres-password` was set)
   - Database usernames, hostnames, ports
   - Internal IP addresses and network topology
   - Processor names and database names

## Impact Explanation

This is a **High Severity** vulnerability per Aptos bug bounty criteria for the following reasons:

1. **Information Disclosure**: Exposes database credentials and internal network topology without authentication
2. **Credential Compromise**: Allows attackers to gain unauthorized access to PostgreSQL databases used by indexers and processors
3. **Lateral Movement**: Database access can be leveraged for further network penetration
4. **Data Exfiltration**: Compromised database credentials enable theft of blockchain indexing data
5. **Service Disruption**: Attacker could manipulate or delete database contents, disrupting indexer services

While this affects the local testnet infrastructure rather than consensus or validator operations, it still represents a significant security flaw that can:
- Expose production-like credentials used in development/staging environments
- Compromise CI/CD pipeline secrets if the testnet is used in automated testing
- Enable attackers to manipulate indexer data, affecting applications relying on indexer APIs

## Likelihood Explanation

**Likelihood: High**

1. **Easy Exploitation**: Requires only a single HTTP GET request, no authentication needed
2. **Common Deployment Scenario**: When running in Docker containers (standard practice), the server automatically binds to `0.0.0.0`, exposing it to the network
3. **Default Configuration**: The ready server runs by default when starting a localnet with indexer services
4. **No Security Controls**: Zero authentication, authorization, or rate limiting on the endpoint
5. **Clear Documentation**: The endpoint URL is printed to stdout, making it easily discoverable

## Recommendation

**Immediate Fixes:**

1. **Implement Custom Serialization**: Add custom `Serialize` implementation for `HealthChecker` that redacts sensitive information:

```rust
impl Serialize for HealthChecker {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut state = serializer.serialize_struct("HealthChecker", 2)?;
        match self {
            HealthChecker::Http(_, name) => {
                state.serialize_field("type", "Http")?;
                state.serialize_field("name", name)?;
            }
            HealthChecker::NodeApi(_) => {
                state.serialize_field("type", "NodeApi")?;
                state.serialize_field("name", "Node API")?;
            }
            // Redact connection strings - only expose type
            HealthChecker::Postgres(_) => {
                state.serialize_field("type", "Postgres")?;
                state.serialize_field("name", "[REDACTED]")?;
            }
            HealthChecker::Processor(_, processor_name) => {
                state.serialize_field("type", "Processor")?;
                state.serialize_field("name", processor_name)?;
            }
            // ... handle other variants
        }
        state.end()
    }
}
```

2. **Add Authentication**: Implement token-based authentication for the ready server endpoint

3. **Restrict Binding**: Default to `127.0.0.1` even in containers, require explicit opt-in for `0.0.0.0` binding

4. **Add Warning**: Display prominent warning when credentials are configured, informing users about potential exposure

## Proof of Concept

**Step 1: Start local testnet with host postgres and password**
```bash
aptos node run-localnet \
  --with-indexer-api \
  --use-host-postgres \
  --host-postgres-password "mysecretpassword123" \
  --bind-to 0.0.0.0
```

**Step 2: Query the ready server endpoint**
```bash
curl http://localhost:8070/
```

**Expected Result: Credentials Exposed**
```json
{
  "ready": [
    {
      "Postgres": "postgres://postgres:mysecretpassword123@127.0.0.1:5432/local_testnet"
    },
    {
      "Processor": [
        "postgres://postgres:mysecretpassword123@127.0.0.1:5432/local_testnet",
        "default_processor"
      ]
    }
  ],
  "not_ready": []
}
```

The password `mysecretpassword123` is now exposed in plaintext to any client that can reach the endpoint.

## Notes

This vulnerability is particularly concerning because:
- The local testnet is often used in CI/CD pipelines where secrets might be production-like
- Docker deployments automatically expose the service to the network
- No warnings are provided to users about credential exposure
- The design pattern (deriving Serialize on types containing secrets) is prone to similar issues elsewhere in the codebase

### Citations

**File:** crates/aptos/src/node/local_testnet/ready_server.rs (L104-108)
```rust
#[derive(Serialize)]
struct ReadyData {
    pub ready: Vec<HealthChecker>,
    pub not_ready: Vec<HealthChecker>,
}
```

**File:** crates/aptos/src/node/local_testnet/ready_server.rs (L110-131)
```rust
#[handler]
async fn root(health_checkers: Data<&HealthCheckers>) -> impl IntoResponse + use<> {
    let mut ready = vec![];
    let mut not_ready = vec![];
    for health_checker in &health_checkers.health_checkers {
        // Use timeout since some of these checks can take quite a while if the
        // underlying service is not ready. This is best effort of course, see the docs
        // for tokio::time::timeout for more information.
        match timeout(Duration::from_secs(3), health_checker.check()).await {
            Ok(Ok(())) => ready.push(health_checker.clone()),
            _ => {
                not_ready.push(health_checker.clone());
            },
        }
    }
    let status_code = if not_ready.is_empty() {
        StatusCode::OK
    } else {
        StatusCode::SERVICE_UNAVAILABLE
    };
    Json(ReadyData { ready, not_ready }).with_status(status_code)
}
```

**File:** crates/aptos/src/node/local_testnet/health_checker.rs (L24-42)
```rust
#[derive(Clone, Debug, Eq, Hash, PartialEq, Serialize)]
pub enum HealthChecker {
    /// Check that a HTTP API is up. The second param is the name of the HTTP service.
    Http(Url, String),
    /// Check that the node API is up. This is just a specific case of Http for extra
    /// guarantees around liveliness.
    NodeApi(Url),
    /// Check that a data service GRPC stream is up.
    DataServiceGrpc(Url),
    /// Check that a postgres instance is up.
    Postgres(String),
    /// Check that a processor is successfully processing txns. The first value is the
    /// postgres connection string. The second is the name of the processor. We check
    /// the that last_success_version in the processor_status table is present and > 0.
    Processor(String, String),
    /// Check that the indexer API is up and the metadata has been applied. We only use
    /// this one in the ready server.
    IndexerApiMetadata(Url),
}
```

**File:** crates/aptos/src/node/local_testnet/postgres.rs (L92-116)
```rust
    pub fn get_connection_string(&self, database: Option<&str>, external: bool) -> String {
        let password = match self.use_host_postgres {
            true => match &self.host_postgres_password {
                Some(password) => format!(":{}", password),
                None => "".to_string(),
            },
            false => "".to_string(),
        };
        let port = self.get_postgres_port(external);
        let database = match database {
            Some(database) => database,
            None => &self.postgres_database,
        };
        let host = match self.use_host_postgres {
            true => &self.host_postgres_host,
            false => match external {
                true => "127.0.0.1",
                false => POSTGRES_CONTAINER_NAME,
            },
        };
        format!(
            "postgres://{}{}@{}:{}/{}",
            self.postgres_user, password, host, port, database,
        )
    }
```

**File:** crates/aptos/src/node/local_testnet/mod.rs (L273-283)
```rust
        let running_inside_container = Path::new(".dockerenv").exists();
        let bind_to = match self.bind_to {
            Some(bind_to) => bind_to,
            None => {
                if running_inside_container {
                    Ipv4Addr::new(0, 0, 0, 0)
                } else {
                    Ipv4Addr::new(127, 0, 0, 1)
                }
            },
        };
```
