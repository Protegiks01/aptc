# Audit Report

## Title
Integer Overflow in Indexer Version Tracking Causes Silent Failure and Infinite Reprocessing Loop

## Summary
The indexer's `update_last_processed_version()` function casts blockchain version numbers from `u64` to `i64` for PostgreSQL storage. When versions exceed `i64::MAX` (9,223,372,036,854,775,807), the cast silently overflows to negative numbers, causing database updates to fail without error and creating an infinite reprocessing loop on indexer restart.

## Finding Description

The Aptos indexer tracks the last successfully processed blockchain version in PostgreSQL using a signed 64-bit integer (`i64`/`BIGINT`), while blockchain versions are unsigned 64-bit integers (`u64`). [1](#0-0) 

When a version exceeds `i64::MAX`, the cast on line 175 causes integer overflow:
- Version `9,223,372,036,854,775,808` (i64::MAX + 1) becomes `-9,223,372,036,854,775,808` (i64::MIN) [2](#0-1) 

The database update uses a WHERE clause to ensure versions only increase: [3](#0-2) 

When the new version is negative due to overflow, the WHERE clause comparison (`9,223,372,036,854,775,807 <= -9,223,372,036,854,775,808`) evaluates to FALSE in PostgreSQL, causing the update to affect 0 rows. The `execute_with_better_error` function returns `Ok(0)` without raising an error, and the indexer continues processing without knowing the update failed. [4](#0-3) 

On indexer restart, it reads the stale version from the database and reprocesses from that point: [5](#0-4) [6](#0-5) 

This creates an infinite loop where the indexer continuously reprocesses all versions beyond `i64::MAX` but can never persist its progress.

## Impact Explanation

**Severity: Medium** - This qualifies as "state inconsistencies requiring intervention" per the Aptos bug bounty program.

The indexer is a critical infrastructure component that provides off-chain data access for wallets, explorers, and dapps. When this bug triggers:

1. **Service Degradation**: The indexer cannot track processing progress for any version > i64::MAX
2. **Resource Waste**: Continuous reprocessing wastes significant computational resources and database writes
3. **Data Staleness**: The indexer appears operational but cannot serve data for recent versions
4. **Operational Impact**: Requires manual intervention to fix the database schema and migrate data

However, this does NOT affect:
- Blockchain consensus or validator operations (indexer is read-only)
- User funds or on-chain state
- Transaction execution or validation

## Likelihood Explanation

**Likelihood: Very Low** - Requires blockchain to naturally reach version i64::MAX.

At 10,000 transactions per second (high estimate for sustained throughput):
- Transactions per year: ~315 billion
- Years to reach i64::MAX: ~29,247 years

While extremely unlikely in practice, this represents a **latent correctness bug** that:
- Would be catastrophic if triggered (permanent indexer failure)
- Is difficult to diagnose without understanding the overflow behavior
- Affects a critical infrastructure component
- Violates the principle that blockchain data structures should handle the full u64 range

## Recommendation

**Immediate Fix**: Add overflow detection and validation:

```rust
pub fn update_last_processed_version(&self, processor_name: &str, version: u64) -> Result<()> {
    let mut conn = self.connection_pool.get()?;
    
    // Validate version is within i64 range
    if version > i64::MAX as u64 {
        return Err(anyhow::anyhow!(
            "Version {} exceeds i64::MAX, database schema needs migration",
            version
        ));
    }
    
    let status = ProcessorStatusV2 {
        processor: processor_name.to_owned(),
        last_success_version: version as i64,
    };
    
    let rows_affected = execute_with_better_error(
        &mut conn,
        diesel::insert_into(processor_status::table)
            .values(&status)
            .on_conflict(processor_status::processor)
            .do_update()
            .set((
                processor_status::last_success_version
                    .eq(excluded(processor_status::last_success_version)),
                processor_status::last_updated.eq(excluded(processor_status::last_updated)),
            )),
        Some(" WHERE processor_status.last_success_version <= EXCLUDED.last_success_version "),
    )?;
    
    // Verify update succeeded
    if rows_affected == 0 {
        return Err(anyhow::anyhow!(
            "Failed to update version - possible data race or overflow"
        ));
    }
    
    Ok(())
}
```

**Long-term Fix**: Migrate database schema to use NUMERIC type for unlimited precision, or implement a custom Diesel type mapping `u64` to PostgreSQL's unsigned types.

## Proof of Concept

```rust
#[test]
fn test_version_overflow() {
    // Demonstrate overflow behavior
    let version_at_max: u64 = i64::MAX as u64; // 9,223,372,036,854,775,807
    let version_overflow: u64 = version_at_max + 1; // 9,223,372,036,854,775,808
    
    let casted_at_max = version_at_max as i64;
    let casted_overflow = version_overflow as i64;
    
    assert_eq!(casted_at_max, 9_223_372_036_854_775_807_i64);
    assert_eq!(casted_overflow, -9_223_372_036_854_775_808_i64); // i64::MIN
    
    // Demonstrate WHERE clause failure
    // In PostgreSQL: WHERE 9223372036854775807 <= -9223372036854775808
    // This evaluates to FALSE, causing update to affect 0 rows
    assert!(casted_at_max > casted_overflow); // 9.2e18 > -9.2e18 is TRUE
    
    // Demonstrate restart behavior
    let stored_version: i64 = casted_at_max;
    let next_version_to_process = (stored_version + 1) as u64;
    
    // Indexer would restart from version_overflow, reprocessing same data
    assert_eq!(next_version_to_process, version_overflow);
}
```

## Notes

While this vulnerability has very low likelihood of occurrence in practice, it represents a **systemic design flaw** in the indexer architecture where unsigned blockchain data is stored in signed database columns. This same pattern appears throughout the indexer codebase: [7](#0-6) 

All version fields use `i64`, making this a codebase-wide issue that should be addressed proactively rather than waiting for it to manifest in production.

### Citations

**File:** crates/indexer/src/indexer/tailer.rs (L170-176)
```rust
    pub fn update_last_processed_version(&self, processor_name: &str, version: u64) -> Result<()> {
        let mut conn = self.connection_pool.get()?;

        let status = ProcessorStatusV2 {
            processor: processor_name.to_owned(),
            last_success_version: version as i64,
        };
```

**File:** crates/indexer/src/indexer/tailer.rs (L177-189)
```rust
        execute_with_better_error(
            &mut conn,
            diesel::insert_into(processor_status::table)
                .values(&status)
                .on_conflict(processor_status::processor)
                .do_update()
                .set((
                    processor_status::last_success_version
                        .eq(excluded(processor_status::last_success_version)),
                    processor_status::last_updated.eq(excluded(processor_status::last_updated)),
                )),
            Some(" WHERE processor_status.last_success_version <= EXCLUDED.last_success_version "),
        )?;
```

**File:** crates/indexer/src/indexer/tailer.rs (L194-200)
```rust
    pub fn get_start_version(&self, processor_name: &String) -> Result<Option<i64>> {
        let mut conn = self.connection_pool.get()?;

        match ProcessorStatusV2Query::get_by_processor(processor_name, &mut conn)? {
            Some(status) => Ok(Some(status.last_success_version + 1)),
            None => Ok(None),
        }
```

**File:** crates/indexer/src/schema.rs (L607-612)
```rust
    processor_status (processor) {
        #[max_length = 50]
        processor -> Varchar,
        last_success_version -> Int8,
        last_updated -> Timestamp,
    }
```

**File:** crates/indexer/src/runtime.rs (L163-172)
```rust
    let starting_version_from_db_short = tailer
        .get_start_version(&processor_name)
        .unwrap_or_else(|e| panic!("Failed to get starting version: {:?}", e))
        .unwrap_or_else(|| {
            info!(
                processor_name = processor_name,
                "No starting version from db so starting from version 0"
            );
            0
        }) as u64;
```

**File:** crates/indexer/src/runtime.rs (L251-261)
```rust
        tailer
            .update_last_processed_version(&processor_name, batch_end_version)
            .unwrap_or_else(|e| {
                error!(
                    processor_name = processor_name,
                    end_version = batch_end_version,
                    error = format!("{:?}", e),
                    "Failed to update last processed version!"
                );
                panic!("Failed to update last processed version: {:?}", e);
            });
```

**File:** crates/indexer/src/models/transactions.rs (L34-50)
```rust
pub struct Transaction {
    pub version: i64,
    pub block_height: i64,
    pub hash: String,
    pub type_: String,
    pub payload: Option<serde_json::Value>,
    pub state_change_hash: String,
    pub event_root_hash: String,
    pub state_checkpoint_hash: Option<String>,
    pub gas_used: BigDecimal,
    pub success: bool,
    pub vm_status: String,
    pub accumulator_root_hash: String,
    pub num_events: i64,
    pub num_write_set_changes: i64,
    pub epoch: i64,
}
```
