# Audit Report

## Title
Byzantine Validator Can Force Premature Batch Expiration via Timestamp Manipulation

## Summary
A Byzantine validator acting as block proposer can set a block timestamp up to 5 minutes in the future (within the allowed TIMEBOUND), causing premature expiration of all quorum store batches and enabling transaction censorship and block composition manipulation.

## Finding Description

The vulnerability exists in the interaction between block timestamp validation and quorum store batch expiration logic. [1](#0-0) 

Block timestamps are validated to be at most 5 minutes (300 seconds) ahead of wall clock time. This passes validation in `verify_well_formed()`, allowing honest validators to vote for such blocks. [2](#0-1) 

The `TimeExpirations::expire()` function at line 81 compares batch expiration times against the provided `certified_time` without any validation that this timestamp represents a reasonable time progression. [3](#0-2) 

When a block commits, `update_certified_timestamp()` is called with the block's timestamp, which then calls `clear_expired_payload()`. The expiration check uses `certified_time - expiration_buffer_usecs` (certified_time - 60 seconds). [4](#0-3) 

Batches are created with expiration times of only 60 seconds in the future for local batches.

**Attack Execution:**
1. Byzantine validator becomes leader for a round
2. Proposes block with timestamp = current_time + 300 seconds (maximum allowed by TIMEBOUND)
3. Block passes `verify_well_formed()` validation
4. Honest validators vote for the block (it's valid according to all checks)
5. Block commits with certified_time = current_time + 300 seconds
6. `update_certified_timestamp(current_time + 300s)` is called
7. `clear_expired_payload()` expires batches where expiry <= (current_time + 300s - 60s) = current_time + 240s
8. All batches created in the last ~3 minutes are immediately expired, including fresh batches that should live for 60 seconds [5](#0-4) 

The `notify_commit()` function unconditionally passes the block timestamp as certified_time without any validation of timestamp reasonableness.

## Impact Explanation

**Critical Severity** - This vulnerability enables:

1. **Transaction Censorship**: By expiring competitor validators' batches prematurely, a Byzantine proposer can exclude transactions from blocks
2. **Block Composition Manipulation**: Attacker controls which transactions are available for inclusion
3. **Consensus Protocol Violation**: Breaks the fairness guarantee that all validators' transactions have equal opportunity for inclusion
4. **Liveness Impact**: Legitimate transactions in expired batches must be resubmitted, delaying confirmation

This meets Critical severity criteria as it causes "Consensus/Safety violations" and "Significant protocol violations" affecting the entire network.

## Likelihood Explanation

**High Likelihood** - This attack is highly feasible:

1. **Minimal Requirements**: Requires only being a validator (no 1/3+ stake needed)
2. **Guaranteed Opportunity**: Leaders rotate regularly; any Byzantine validator will eventually be leader
3. **No Detection**: The timestamp is within protocol-allowed bounds, making the attack appear legitimate
4. **Automatic Propagation**: Once the block commits, the damage is done automatically via the expiration logic
5. **Repeatable**: Can be executed every time the Byzantine validator is leader

## Recommendation

Implement strict timestamp validation that limits timestamp progression to reasonable bounds relative to batch expiration times:

**Fix in `batch_store.rs`:**
```rust
pub fn update_certified_timestamp(&self, certified_time: u64) {
    let last_time = self.last_certified_time.load(Ordering::Relaxed);
    
    // Limit timestamp progression to prevent premature batch expiration
    // Max progression should be significantly less than batch expiry gap
    const MAX_TIMESTAMP_PROGRESSION_USECS: u64 = 30_000_000; // 30 seconds
    
    let bounded_certified_time = if certified_time > last_time {
        last_time + std::cmp::min(
            certified_time - last_time,
            MAX_TIMESTAMP_PROGRESSION_USECS
        )
    } else {
        certified_time
    };
    
    self.last_certified_time
        .fetch_max(bounded_certified_time, Ordering::SeqCst);

    let expired_keys = self.clear_expired_payload(bounded_certified_time);
    // ...
}
```

**Alternative Fix in `block.rs`:**
Reduce TIMEBOUND from 300 seconds to 10-15 seconds to match typical block times and prevent large timestamp jumps.

## Proof of Concept

```rust
// Test in consensus/src/quorum_store/tests/batch_store_test.rs

#[tokio::test]
async fn test_timestamp_manipulation_premature_expiration() {
    let batch_store = create_batch_store_for_test(
        0, // epoch
        true, // is_new_epoch  
        0, // last_certified_time
        60_000_000, // expiration_buffer = 60 seconds
    );
    
    let current_time = 1000_000_000; // 1000 seconds in microseconds
    
    // Create a batch with normal expiration (current_time + 60s)
    let batch = create_test_batch(
        current_time + 60_000_000 // expiry = current_time + 60 seconds
    );
    batch_store.save(&batch).unwrap();
    
    // Byzantine validator proposes block with timestamp 5 minutes ahead
    let byzantine_timestamp = current_time + 300_000_000; // +300 seconds
    
    // Update with malicious timestamp
    batch_store.update_certified_timestamp(byzantine_timestamp);
    
    // Batch should be expired even though it was created less than 60s ago
    // Expiration check: expiry <= (byzantine_timestamp - 60s)
    //                  60 <= (300 - 60) = 240 âœ“ (EXPIRED!)
    
    // Verify batch was prematurely expired
    let result = batch_store.get_batch_from_local(&batch.digest());
    assert!(result.is_err(), "Batch should be expired");
}
```

**Notes:**
The attack exploits the mismatch between the 5-minute TIMEBOUND allowance and the 60-second batch expiration window. The fix must either reduce TIMEBOUND significantly or implement rate limiting on timestamp progression in the batch expiration logic.

### Citations

**File:** consensus/consensus-types/src/block.rs (L521-540)
```rust
        if self.is_nil_block() || parent.has_reconfiguration() {
            ensure!(
                self.timestamp_usecs() == parent.timestamp_usecs(),
                "Nil/reconfig suffix block must have same timestamp as parent"
            );
        } else {
            ensure!(
                self.timestamp_usecs() > parent.timestamp_usecs(),
                "Blocks must have strictly increasing timestamps"
            );

            let current_ts = duration_since_epoch();

            // we can say that too far is 5 minutes in the future
            const TIMEBOUND: u64 = 300_000_000;
            ensure!(
                self.timestamp_usecs() <= (current_ts.as_micros() as u64).saturating_add(TIMEBOUND),
                "Blocks must not be too far in the future"
            );
        }
```

**File:** consensus/src/quorum_store/utils.rs (L75-89)
```rust
    /// Expire and return items corresponding to expiration <= given certified time.
    /// Unwrap is safe because peek() is called in loop condition.
    #[allow(clippy::unwrap_used)]
    pub(crate) fn expire(&mut self, certified_time: u64) -> HashSet<I> {
        let mut ret = HashSet::new();
        while let Some((Reverse(t), _)) = self.expiries.peek() {
            if *t <= certified_time {
                let (_, item) = self.expiries.pop().unwrap();
                ret.insert(item);
            } else {
                break;
            }
        }
        ret
    }
```

**File:** consensus/src/quorum_store/batch_store.rs (L443-448)
```rust
    pub(crate) fn clear_expired_payload(&self, certified_time: u64) -> Vec<HashValue> {
        // To help slow nodes catch up via execution without going to state sync we keep the blocks for 60 extra seconds
        // after the expiration time. This will help remote peers fetch batches that just expired but are within their
        // execution window.
        let expiration_time = certified_time.saturating_sub(self.expiration_buffer_usecs);
        let expired_digests = self.expirations.lock().expire(expiration_time);
```

**File:** consensus/src/quorum_store/batch_generator.rs (L383-384)
```rust
        let expiry_time = aptos_infallible::duration_since_epoch().as_micros() as u64
            + self.config.batch_expiry_gap_when_init_usecs;
```

**File:** consensus/src/payload_manager/quorum_store_payload_manager.rs (L168-170)
```rust
    fn notify_commit(&self, block_timestamp: u64, payloads: Vec<Payload>) {
        self.batch_reader
            .update_certified_timestamp(block_timestamp);
```
