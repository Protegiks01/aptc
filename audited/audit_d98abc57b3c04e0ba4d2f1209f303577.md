# Audit Report

## Title
Metadata Format Upgrade Path Causes Consensus Split and Forced Hard Fork

## Summary
The Aptos metadata validation system lacks forward compatibility for metadata format changes. When a new metadata version is introduced, non-upgraded validators reject modules with unknown metadata keys, while upgraded validators accept them, causing a consensus split that requires a hard fork to resolve.

## Finding Description
The vulnerability exists in the metadata validation logic that runs during consensus-critical module publishing operations. [1](#0-0) 

The `check_metadata_format` function explicitly rejects any unknown metadata key. This validation occurs during transaction execution in the module publishing path: [2](#0-1) 

This validation is called from the consensus-critical transaction execution path: [3](#0-2) 

Which is part of the module publishing validation flow: [4](#0-3) 

Called during transaction execution: [5](#0-4) 

**Attack Scenario:**
1. A critical bug is discovered in `RuntimeModuleMetadataV1` requiring a new `RuntimeModuleMetadataV2` format with key `APTOS_METADATA_KEY_V2`
2. A protocol upgrade is proposed to add V2 support
3. During rolling upgrade (60% validators upgraded, 40% not):
   - A user publishes a module with V2 metadata
   - Upgraded validators: Accept transaction (valid V2 metadata)
   - Non-upgraded validators: Reject with `MalformedError::UnknownKey`
4. **Consensus splits** - validators produce different state roots for the same block
5. Network partitions into two chains, requiring manual hard fork intervention

This breaks the critical invariant: "**Deterministic Execution**: All validators must produce identical state roots for identical blocks"

## Impact Explanation
**Critical Severity** - Non-recoverable network partition requiring hard fork.

This vulnerability forces an unplanned hard fork whenever:
- Metadata format bugs require introducing new versions
- Protocol upgrades aren't perfectly coordinated across all validators
- Any user publishes a module during the upgrade window

Unlike typical upgrade bugs that cause temporary liveness issues, this creates **permanent chain splits** where validators cannot reconcile their state without manual intervention. This matches the bug bounty's Critical category: "Non-recoverable network partition (requires hardfork)".

Historical precedent: Bitcoin's BIP66 incident caused a similar consensus split when validation rules changed without forward compatibility, requiring emergency hard fork coordination.

## Likelihood Explanation
**High Likelihood** during protocol upgrades:

- Metadata changes are likely given the system's complexity and evolving requirements
- Rolling upgrades are standard practice for blockchain networks
- The current metadata system already has V0→V1 evolution, indicating format changes occur
- No technical barrier prevents users from publishing modules during upgrades
- No graceful degradation or soft fork mechanism exists

The vulnerability triggers automatically when any transaction contains unsupported metadata during validator version skew - no sophisticated attack required.

## Recommendation
Implement forward compatibility for metadata keys:

```rust
fn check_metadata_format(module: &CompiledModule) -> Result<(), MalformedError> {
    let mut exist = false;
    let mut compilation_key_exist = false;
    for data in module.metadata.iter() {
        if data.key == *APTOS_METADATA_KEY || data.key == *APTOS_METADATA_KEY_V1 {
            if exist {
                return Err(MalformedError::DuplicateKey);
            }
            exist = true;
            
            if data.key == *APTOS_METADATA_KEY {
                bcs::from_bytes::<RuntimeModuleMetadata>(&data.value)
                    .map_err(|e| MalformedError::DeserializedError(data.key.clone(), e))?;
            } else if data.key == *APTOS_METADATA_KEY_V1 {
                bcs::from_bytes::<RuntimeModuleMetadataV1>(&data.value)
                    .map_err(|e| MalformedError::DeserializedError(data.key.clone(), e))?;
            }
        } else if data.key == *COMPILATION_METADATA_KEY {
            if compilation_key_exist {
                return Err(MalformedError::DuplicateKey);
            }
            compilation_key_exist = true;
            bcs::from_bytes::<CompilationMetadata>(&data.value)
                .map_err(|e| MalformedError::DeserializedError(data.key.clone(), e))?;
        } else if data.key.starts_with(b"aptos::") {
            // Forward compatibility: Allow unknown aptos:: metadata keys
            // Old validators ignore, new validators validate
            continue;
        } else {
            return Err(MalformedError::UnknownKey(data.key.clone()));
        }
    }
    Ok(())
}
```

Alternative approach: Gate new metadata validation behind feature flags that activate after all validators upgrade.

## Proof of Concept

```rust
#[test]
fn test_metadata_consensus_split() {
    use move_core_types::metadata::Metadata;
    use move_binary_format::CompiledModule;
    
    // Simulate upgraded validator
    let module_with_v2_metadata = CompiledModule {
        metadata: vec![
            Metadata {
                key: b"aptos::metadata_v2".to_vec(), // New V2 key
                value: vec![0x01, 0x02], // Some V2 data
            }
        ],
        // ... other fields
    };
    
    // Old validator behavior (current code)
    let old_validator_result = check_metadata_format(&module_with_v2_metadata);
    assert!(old_validator_result.is_err()); // Rejects unknown key
    
    // New validator behavior (would need to support V2)
    // Would accept the module, causing consensus split
    
    // Result: Validators disagree on transaction validity -> chain fork
}
```

**Steps to demonstrate:**
1. Deploy two validator nodes with different code versions
2. Submit transaction publishing module with new metadata key
3. Observe upgraded validator accepts, non-upgraded validator rejects
4. Verify state root divergence causes consensus failure

**Notes:**

This vulnerability is a design flaw in the metadata validation system's lack of forward compatibility. The system currently supports backward compatibility (V0→V1 upgrade path) but completely lacks forward compatibility (old nodes handling new formats). This asymmetry makes protocol upgrades unsafe without perfect coordination.

The issue is particularly severe because metadata validation is feature-gated (`are_resource_groups_enabled()`) but once enabled, provides no escape hatch for unknown keys. Any future metadata evolution becomes a potential consensus bomb.

### Citations

**File:** types/src/vm/module_metadata.rs (L253-283)
```rust
fn check_metadata_format(module: &CompiledModule) -> Result<(), MalformedError> {
    let mut exist = false;
    let mut compilation_key_exist = false;
    for data in module.metadata.iter() {
        if data.key == *APTOS_METADATA_KEY || data.key == *APTOS_METADATA_KEY_V1 {
            if exist {
                return Err(MalformedError::DuplicateKey);
            }
            exist = true;

            if data.key == *APTOS_METADATA_KEY {
                bcs::from_bytes::<RuntimeModuleMetadata>(&data.value)
                    .map_err(|e| MalformedError::DeserializedError(data.key.clone(), e))?;
            } else if data.key == *APTOS_METADATA_KEY_V1 {
                bcs::from_bytes::<RuntimeModuleMetadataV1>(&data.value)
                    .map_err(|e| MalformedError::DeserializedError(data.key.clone(), e))?;
            }
        } else if data.key == *COMPILATION_METADATA_KEY {
            if compilation_key_exist {
                return Err(MalformedError::DuplicateKey);
            }
            compilation_key_exist = true;
            bcs::from_bytes::<CompilationMetadata>(&data.value)
                .map_err(|e| MalformedError::DeserializedError(data.key.clone(), e))?;
        } else {
            return Err(MalformedError::UnknownKey(data.key.clone()));
        }
    }

    Ok(())
}
```

**File:** types/src/vm/module_metadata.rs (L441-451)
```rust
pub fn verify_module_metadata_for_module_publishing(
    module: &CompiledModule,
    features: &Features,
) -> Result<(), MetaDataValidationError> {
    if features.is_enabled(FeatureFlag::SAFER_METADATA) {
        check_module_complexity(module)?;
    }

    if features.are_resource_groups_enabled() {
        check_metadata_format(module)?;
    }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1081-1088)
```rust
        let user_session_change_set = self.resolve_pending_code_publish_and_finish_user_session(
            session,
            resolver,
            code_storage,
            gas_meter,
            traversal_context,
            change_set_configs,
        )?;
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1561-1568)
```rust
        self.validate_publish_request(
            module_storage,
            traversal_context,
            gas_meter,
            modules,
            expected_modules,
            allowed_deps,
        )?;
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1715-1716)
```rust
            verify_module_metadata_for_module_publishing(m, self.features())
                .map_err(|err| Self::metadata_validation_error(&err.to_string()))?;
```
