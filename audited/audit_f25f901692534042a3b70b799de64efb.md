# Audit Report

## Title
Information Leakage of Internal Network Addresses Through Transport Error Propagation

## Summary
The `BoxedTransport` wrapper transparently propagates errors from inner transports without sanitizing sensitive network topology information. When TCP connection failures occur, error messages containing internal IP addresses, DNS names, and network configuration details are logged at WARN level, potentially exposing infrastructure information to attackers with access to node logs.

## Finding Description
The vulnerability exists in the error propagation path from the TCP transport layer through `BoxedTransport` to the logging layer:

1. **Error Creation with NetworkAddress**: The `invalid_addr_error()` function embeds the complete `NetworkAddress` in error messages: [1](#0-0) 

2. **Transparent Error Propagation**: `BoxedTransport` passes errors through unchanged using the `?` operator: [2](#0-1) [3](#0-2) 

3. **NetworkAddress Display Format**: The `Display` implementation for `Protocol::NoiseIK` includes public keys, and IP addresses are displayed in full: [4](#0-3) 

4. **Error Logging**: Transport failures are logged with full error details including addresses: [5](#0-4) 

Additional leakage occurs through:
- DNS resolution failures exposing DNS names and IP filters: [6](#0-5) 

- HTTP proxy responses included in error messages: [7](#0-6) [8](#0-7) 

**Note on Private Keys**: Private keys are properly protected - `x25519::PrivateKey` uses `SilentDebug` which prevents key material leakage: [9](#0-8) 

## Impact Explanation
This is a **Low to Medium Severity** information disclosure vulnerability:

- **Information Exposed**: Internal IP addresses (e.g., `/ip4/10.0.0.1/tcp/6180`), DNS names, network topology hints, proxy configurations
- **Exploitation Requirement**: Requires access to node logs (through misconfigured log aggregation, compromised monitoring infrastructure, or insider access)
- **Security Impact**: Enables network reconnaissance for multi-stage attacks but does not directly compromise funds, consensus, or availability

Per Aptos bug bounty criteria, this falls under **Low Severity** ("Minor information leaks" - up to $1,000) rather than Medium, as it requires privileged access (log visibility) to exploit and does not directly impact critical system operations.

## Likelihood Explanation
**Likelihood: Medium**

- **Trigger**: Easy - any connection failure triggers the error (malicious peer attempts, network issues)
- **Exploitation**: Requires log access through:
  - Misconfigured cloud logging (publicly accessible log streams)
  - Compromised log aggregation systems (Splunk, ELK, CloudWatch)
  - Insider threat with infrastructure access
  - Side-channel attacks on monitoring systems

While triggering the condition is trivial, actual exploitation requires overcoming the log access barrier, which significantly reduces the practical likelihood for external attackers.

## Recommendation
Implement error sanitization at the `BoxedTransport` layer to strip sensitive information:

```rust
// In network/netcore/src/transport/boxed.rs
impl<O, E> Transport for BoxedTransport<O, E>
where
    E: ::std::error::Error + Send + Sync + 'static,
{
    fn listen_on(
        &self,
        addr: NetworkAddress,
    ) -> Result<(Self::Listener, NetworkAddress), Self::Error> {
        self.inner.listen_on(addr).map_err(|e| {
            // Sanitize error to avoid leaking internal addresses
            sanitize_transport_error(e)
        })
    }

    fn dial(&self, peer_id: PeerId, addr: NetworkAddress) -> Result<Self::Outbound, Self::Error> {
        self.inner.dial(peer_id, addr).map_err(|e| {
            // Sanitize error to avoid leaking internal addresses
            sanitize_transport_error(e)
        })
    }
}
```

Additionally, modify error construction to avoid embedding full addresses:
- Replace specific addresses with generic descriptions
- Use separate structured logging fields for sensitive data with appropriate log level filtering
- Implement address redaction for internal IP ranges in error messages

## Proof of Concept
```rust
// Rust test to demonstrate information leakage
#[test]
fn test_internal_ip_leakage_in_errors() {
    use aptos_netcore::transport::{TcpTransport, Transport, TransportExt};
    use aptos_types::PeerId;
    
    // Create a boxed transport
    let transport = TcpTransport::default().boxed();
    
    // Attempt to dial an internal IP that will fail
    let internal_addr = "/ip4/10.0.0.1/tcp/6180".parse().unwrap();
    let peer_id = PeerId::random();
    
    // This will create an error containing the internal IP
    match transport.dial(peer_id, internal_addr) {
        Err(e) => {
            let error_msg = format!("{}", e);
            // Verify that internal IP is leaked in error message
            assert!(error_msg.contains("10.0.0.1"), 
                "Internal IP should be present in error: {}", error_msg);
            println!("LEAKED: {}", error_msg);
        }
        Ok(_) => panic!("Expected error"),
    }
}
```

**Note**: This PoC demonstrates the technical issue but does not constitute a Critical/High severity vulnerability as it requires log access for exploitation and does not break consensus, execution, or state management invariants.

### Citations

**File:** network/netcore/src/transport/tcp.rs (L246-255)
```rust
        Err(last_err.unwrap_or_else(|| {
            io::Error::new(
                io::ErrorKind::InvalidInput,
                format!(
                    "could not resolve dns name to any address: name: {}, ip filter: {:?}",
                    dns_name.as_ref(),
                    ip_filter,
                ),
            )
        }))
```

**File:** network/netcore/src/transport/tcp.rs (L279-282)
```rust
                return Err(io::Error::other(format!(
                    "HTTP proxy CONNECT failed. Len == 0. Message: {}",
                    String::from_utf8_lossy(msg)
                )));
```

**File:** network/netcore/src/transport/tcp.rs (L289-292)
```rust
                    return Err(io::Error::other(format!(
                        "HTTP proxy CONNECT failed! Unexpected message: {}",
                        String::from_utf8_lossy(msg)
                    )));
```

**File:** network/netcore/src/transport/tcp.rs (L303-308)
```rust
fn invalid_addr_error(addr: &NetworkAddress) -> io::Error {
    io::Error::new(
        io::ErrorKind::InvalidInput,
        format!("Invalid NetworkAddress: '{}'", addr),
    )
}
```

**File:** network/netcore/src/transport/boxed.rs (L30-34)
```rust
    fn listen_on(&self, addr: NetworkAddress) -> Result<(Listener<O, E>, NetworkAddress), E> {
        let (listener, addr) = self.listen_on(addr)?;
        let listener = listener
            .map(|result| result.map(|(incoming, addr)| (incoming.boxed() as Inbound<O, E>, addr)));
        Ok((listener.boxed() as Listener<O, E>, addr))
```

**File:** network/netcore/src/transport/boxed.rs (L37-40)
```rust
    fn dial(&self, peer_id: PeerId, addr: NetworkAddress) -> Result<Outbound<O, E>, E> {
        let outgoing = self.dial(peer_id, addr)?;
        Ok(outgoing.boxed() as Outbound<O, E>)
    }
```

**File:** types/src/network_address/mod.rs (L598-618)
```rust
impl fmt::Display for Protocol {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        use self::Protocol::*;
        match self {
            Ip4(addr) => write!(f, "/ip4/{}", addr),
            Ip6(addr) => write!(f, "/ip6/{}", addr),
            Dns(domain) => write!(f, "/dns/{}", domain),
            Dns4(domain) => write!(f, "/dns4/{}", domain),
            Dns6(domain) => write!(f, "/dns6/{}", domain),
            Tcp(port) => write!(f, "/tcp/{}", port),
            Memory(port) => write!(f, "/memory/{}", port),
            NoiseIK(pubkey) => write!(
                f,
                "/noise-ik/{}",
                pubkey
                    .to_encoded_string()
                    .expect("ValidCryptoMaterialStringExt::to_encoded_string is infallible")
            ),
            Handshake(version) => write!(f, "/handshake/{}", version),
        }
    }
```

**File:** network/framework/src/peer_manager/transport.rs (L259-269)
```rust
                warn!(
                    NetworkSchema::new(&self.network_context)
                        .remote_peer(&peer_id)
                        .network_address(&addr),
                    error = %err,
                    "{} Outbound connection failed for peer {} at {}: {}",
                    self.network_context,
                    peer_id.short_str(),
                    addr,
                    err
                );
```

**File:** crates/aptos-crypto/src/x25519.rs (L66-66)
```rust
#[derive(DeserializeKey, SilentDisplay, SilentDebug, SerializeKey)]
```
