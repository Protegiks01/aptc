# Audit Report

## Title
Consensus Safety Violation Due to Non-Deterministic Configuration Fallback During Epoch Transitions

## Summary
The `BlockHotStateOpAccumulator` is optionally initialized based on the `add_block_limit_outcome_onchain()` flag from on-chain execution configuration. During epoch transitions, if some validators fail to read the on-chain configuration while others succeed, they will use different configurations throughout the epoch. This causes validators to generate different block epilogue transactions (`StateCheckpoint` vs `BlockEpilogue`), leading to divergent state roots and consensus failure.

## Finding Description

The vulnerability exists in the epoch initialization flow where validators read on-chain execution configuration: [1](#0-0) 

When `payload.get()` fails to retrieve `OnChainExecutionConfig`, the code only logs a warning and falls back to `OnChainExecutionConfig::default_if_missing()`, which returns `OnChainExecutionConfig::Missing`: [2](#0-1) 

This `Missing` variant causes `block_gas_limit_type()` to return `BlockGasLimitType::NoLimit`: [3](#0-2) 

Which in turn makes `add_block_limit_outcome_onchain()` return `false`: [4](#0-3) 

This flag controls two critical behaviors:

**1. BlockHotStateOpAccumulator Initialization:** [5](#0-4) 

**2. Block Epilogue Transaction Type:** [6](#0-5) 

**Attack Scenario:**

1. Epoch N ends, validators prepare for epoch N+1
2. Validator A successfully reads on-chain config: `add_block_limit_outcome_onchain = true`
3. Validator B experiences transient database error, falls back to default: `add_block_limit_outcome_onchain = false`
4. Both validators enter epoch N+1 with different configurations
5. During block execution:
   - Validator A: Creates `Some(BlockHotStateOpAccumulator)`, generates `Transaction::BlockEpilogue`
   - Validator B: Creates `None`, generates `Transaction::StateCheckpoint`

**Consensus Divergence:**

The different transaction types execute differently in the VM: [7](#0-6) 

`StateCheckpoint` returns empty VMOutput, while `BlockEpilogue` may execute fee distribution logic: [8](#0-7) 

The different transactions result in:
- Different transaction hashes
- Different block output structures  
- Different state roots
- **Consensus failure** - validators cannot agree on block validity

## Impact Explanation

**Severity: CRITICAL (Consensus/Safety Violation)**

This vulnerability breaks the fundamental **Deterministic Execution** invariant: "All validators must produce identical state roots for identical blocks."

The impact qualifies as **Critical Severity** per Aptos bug bounty criteria:
- **Consensus/Safety violations**: Different validators compute different state roots for the same block
- **Non-recoverable network partition**: Once validators enter an epoch with different configurations, every block in that epoch will diverge, requiring manual intervention or hard fork to resolve
- **Total loss of liveness**: The network cannot make progress when validators disagree on block validity

The configuration persists for the entire epoch: [9](#0-8) 

This means a single configuration mismatch at epoch boundary causes consensus failure for all subsequent blocks until the next epoch.

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH**

While the on-chain configuration should be identical for all validators, mismatches can occur through:

1. **Transient Database Errors**: Temporary I/O failures, disk issues, or database connection problems during epoch transition
2. **State Sync Delays**: Validators lagging in state synchronization may have incomplete or corrupted on-chain config data
3. **BCS Deserialization Bugs**: Version-specific parsing differences or malformed config data
4. **Resource Exhaustion**: Memory pressure or CPU contention causing read failures
5. **Network Partitions**: Brief network issues during critical config read window

The graceful fallback behavior makes this more dangerous - validators continue operating with different configurations rather than failing fast and alerting operators: [10](#0-9) 

## Recommendation

**Immediate Fix: Enforce Consensus-Critical Configuration Reads**

The epoch transition should **fail-fast** if on-chain configuration cannot be read, rather than silently falling back to defaults:

```rust
// In consensus/src/epoch_manager.rs, line 1202-1203
let execution_config = onchain_execution_config
    .expect("CRITICAL: Failed to read on-chain execution config. Cannot safely proceed with epoch transition.");
```

**Long-term Solution: Configuration Consistency Verification**

1. **Mandatory Configuration Reads**: Treat configuration read failures as fatal errors that prevent epoch transition
2. **Pre-Epoch Validation**: Verify all validators can successfully read the same configuration before epoch start
3. **Configuration Hash Consensus**: Include a hash of the execution config in the epoch state, forcing validators to agree on configuration before proceeding
4. **Monitoring and Alerts**: Add metrics for configuration read failures to detect issues early

**Additional Safety Measure:**

Add a configuration consistency check in the block execution path:

```rust
// In aptos-move/block-executor/src/executor.rs
fn gen_block_epilogue() {
    // Before generating epilogue, verify configuration consistency
    if self.config.onchain.block_gas_limit_type.add_block_limit_outcome_onchain() {
        assert!(
            self.hot_state_op_accumulator.is_some(),
            "Configuration inconsistency: add_block_limit_outcome_onchain=true but accumulator is None"
        );
    }
}
```

## Proof of Concept

```rust
// Test demonstrating consensus divergence
#[test]
fn test_config_mismatch_causes_consensus_divergence() {
    // Setup: Two validators with different configs
    let config_a = BlockExecutorConfigFromOnchain::new(
        BlockGasLimitType::ComplexLimitV1 {
            // ... with add_block_limit_outcome_onchain: true
            add_block_limit_outcome_onchain: true,
            // ... other fields
        },
        false,
        Some(90),
    );
    
    let config_b = BlockExecutorConfigFromOnchain::new(
        BlockGasLimitType::NoLimit, // add_block_limit_outcome_onchain() returns false
        false,
        Some(90),
    );
    
    // Execute the same block with both configs
    let block = create_test_block();
    
    let output_a = execute_block(&block, config_a);
    let output_b = execute_block(&block, config_b);
    
    // Extract epilogue transactions
    let (_, epilogue_a) = output_a.into_inner();
    let (_, epilogue_b) = output_b.into_inner();
    
    // Verify different transaction types generated
    match (epilogue_a, epilogue_b) {
        (Some(Transaction::BlockEpilogue(_)), Some(Transaction::StateCheckpoint(_))) => {
            // SUCCESS: Demonstrates different validators generate different epilogue types
            println!("VULNERABILITY CONFIRMED: Different epilogue transactions generated");
        },
        _ => panic!("Expected different epilogue transaction types"),
    }
    
    // These different transactions would lead to different state roots
    // causing consensus failure
}
```

**Notes**

The vulnerability is amplified by the fact that `BlockHotStateOpAccumulator` being `None` vs `Some` also affects which state keys are marked as "hot" in the block end info. Even if both validators somehow generated `BlockEpilogue` transactions, they could still diverge on the set of keys to promote to hot state, as seen here: [11](#0-10) 

This creates multiple layers where the configuration mismatch can cause consensus divergence, making the vulnerability even more critical.

### Citations

**File:** consensus/src/epoch_manager.rs (L1178-1203)
```rust
        let onchain_consensus_config: anyhow::Result<OnChainConsensusConfig> = payload.get();
        let onchain_execution_config: anyhow::Result<OnChainExecutionConfig> = payload.get();
        let onchain_randomness_config_seq_num: anyhow::Result<RandomnessConfigSeqNum> =
            payload.get();
        let randomness_config_move_struct: anyhow::Result<RandomnessConfigMoveStruct> =
            payload.get();
        let onchain_jwk_consensus_config: anyhow::Result<OnChainJWKConsensusConfig> = payload.get();
        let dkg_state = payload.get::<DKGState>();

        if let Err(error) = &onchain_consensus_config {
            warn!("Failed to read on-chain consensus config {}", error);
        }

        if let Err(error) = &onchain_execution_config {
            warn!("Failed to read on-chain execution config {}", error);
        }

        if let Err(error) = &randomness_config_move_struct {
            warn!("Failed to read on-chain randomness config {}", error);
        }

        self.epoch_state = Some(epoch_state.clone());

        let consensus_config = onchain_consensus_config.unwrap_or_default();
        let execution_config = onchain_execution_config
            .unwrap_or_else(|_| OnChainExecutionConfig::default_if_missing());
```

**File:** types/src/on_chain_config/execution_config.rs (L42-58)
```rust
    /// The per-block gas limit being used.
    pub fn block_gas_limit_type(&self) -> BlockGasLimitType {
        match &self {
            OnChainExecutionConfig::Missing => BlockGasLimitType::NoLimit,
            OnChainExecutionConfig::V1(_config) => BlockGasLimitType::NoLimit,
            OnChainExecutionConfig::V2(config) => config
                .block_gas_limit
                .map_or(BlockGasLimitType::NoLimit, BlockGasLimitType::Limit),
            OnChainExecutionConfig::V3(config) => config
                .block_gas_limit
                .map_or(BlockGasLimitType::NoLimit, BlockGasLimitType::Limit),
            OnChainExecutionConfig::V4(config) => config.block_gas_limit_type.clone(),
            OnChainExecutionConfig::V5(config) => config.block_gas_limit_type.clone(),
            OnChainExecutionConfig::V6(config) => config.block_gas_limit_type.clone(),
            OnChainExecutionConfig::V7(config) => config.block_gas_limit_type.clone(),
        }
    }
```

**File:** types/src/on_chain_config/execution_config.rs (L135-140)
```rust
    /// The default values to use when on-chain config is not initialized.
    /// This value should not be changed, for replay purposes.
    pub fn default_if_missing() -> Self {
        OnChainExecutionConfig::Missing
    }
}
```

**File:** types/src/on_chain_config/execution_config.rs (L398-407)
```rust
    pub fn add_block_limit_outcome_onchain(&self) -> bool {
        match self {
            BlockGasLimitType::NoLimit => false,
            BlockGasLimitType::Limit(_) => false,
            BlockGasLimitType::ComplexLimitV1 {
                add_block_limit_outcome_onchain,
                ..
            } => *add_block_limit_outcome_onchain,
        }
    }
```

**File:** aptos-move/block-executor/src/limit_processor.rs (L44-46)
```rust
        let hot_state_op_accumulator = block_gas_limit_type
            .add_block_limit_outcome_onchain()
            .then(BlockHotStateOpAccumulator::new);
```

**File:** aptos-move/block-executor/src/limit_processor.rs (L294-303)
```rust
    fn get_keys_to_make_hot(&self) -> BTreeSet<T::Key> {
        if self.hot_state_op_accumulator.is_none() {
            warn!("BlockHotStateOpAccumulator is not set.");
        }

        self.hot_state_op_accumulator
            .as_ref()
            .map(|x| x.get_keys_to_make_hot())
            .unwrap_or_default()
    }
```

**File:** aptos-move/block-executor/src/executor.rs (L2015-2022)
```rust
        if !self
            .config
            .onchain
            .block_gas_limit_type
            .add_block_limit_outcome_onchain()
        {
            return Ok(T::state_checkpoint(block_id));
        }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L2559-2625)
```rust
        let (block_id, fee_distribution) = match block_epilogue {
            BlockEpiloguePayload::V0 { .. } => {
                let status = TransactionStatus::Keep(ExecutionStatus::Success);
                let output = VMOutput::empty_with_status(status);
                return Ok((VMStatus::Executed, output));
            },
            BlockEpiloguePayload::V1 {
                block_id,
                fee_distribution,
                ..
            } => (block_id, fee_distribution),
        };

        let mut gas_meter = UnmeteredGasMeter;
        let mut session = self.new_session(resolver, SessionId::block_epilogue(block_id), None);

        let (validator_indices, amounts) = match fee_distribution {
            FeeDistribution::V0 { amount } => amount
                .into_iter()
                .map(|(validator_index, amount)| {
                    (MoveValue::U64(validator_index), MoveValue::U64(amount))
                })
                .unzip(),
        };

        let args = vec![
            MoveValue::Signer(AccountAddress::ZERO), // Run as 0x0
            MoveValue::Vector(validator_indices),
            MoveValue::Vector(amounts),
        ];

        let traversal_storage = TraversalStorage::new();
        let mut traversal_context = TraversalContext::new(&traversal_storage);

        let output = match session
            .execute_function_bypass_visibility(
                &BLOCK_MODULE,
                BLOCK_EPILOGUE,
                vec![],
                serialize_values(&args),
                &mut gas_meter,
                &mut traversal_context,
                module_storage,
            )
            .map(|_return_vals| ())
            .or_else(|e| expect_only_successful_execution(e, BLOCK_EPILOGUE.as_str(), log_context))
        {
            Ok(_) => get_system_transaction_output(
                session,
                module_storage,
                &self.storage_gas_params(log_context)?.change_set_configs,
            )?,
            Err(e) => {
                error!(
                    "Unexpected error from BlockEpilogue txn: {e:?}, fallback to return success."
                );
                let status = TransactionStatus::Keep(ExecutionStatus::Success);
                VMOutput::empty_with_status(status)
            },
        };

        SYSTEM_TRANSACTIONS_EXECUTED.inc();

        // TODO(HotState): generate an output according to the block end info in the
        //   transaction. (maybe resort to the move resolver, but for simplicity I would
        //   just include the full slot in both the transaction and the output).
        Ok((VMStatus::Executed, output))
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L3014-3024)
```rust
            Transaction::StateCheckpoint(_) => {
                let status = TransactionStatus::Keep(ExecutionStatus::Success);
                let output = VMOutput::empty_with_status(status);
                (VMStatus::Executed, output)
            },
            Transaction::BlockEpilogue(block_epilogue) => self.process_block_epilogue(
                resolver,
                code_storage,
                block_epilogue.clone(),
                log_context,
            )?,
```

**File:** consensus/src/state_computer.rs (L247-261)
```rust
        *self.state.write() = Some(MutableState {
            validators: epoch_state
                .verifier
                .get_ordered_account_addresses_iter()
                .collect::<Vec<_>>()
                .into(),
            payload_manager,
            transaction_shuffler,
            block_executor_onchain_config,
            transaction_deduper,
            is_randomness_enabled: randomness_enabled,
            consensus_onchain_config,
            persisted_auxiliary_info_version,
            network_sender,
        });
```
