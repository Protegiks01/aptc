# Audit Report

## Title
Missing Gas Schedule Parameter Validation Enables Network-Wide Denial of Service via Scaling Factor Manipulation

## Summary
The gas schedule update mechanism lacks validation checks on critical parameters, allowing a malicious or buggy governance proposal to set `gas_unit_scaling_factor` to extreme values (very large or very small), causing complete network denial of service by making transactions either impossibly expensive or essentially free.

## Finding Description

The `gas_unit_scaling_factor` parameter controls the conversion between internal gas units (used for precise calculations) and external gas units (what users specify). This parameter is stored on-chain and can be modified through governance proposals. [1](#0-0) 

The parameter is defined with a default value of 1,000,000: [2](#0-1) [3](#0-2) 

The critical vulnerability lies in the gas schedule update functions, which contain explicit TODO comments indicating missing validation: [4](#0-3) [5](#0-4) [6](#0-5) 

The conversion logic multiplies user-specified gas by the scaling factor when converting to internal units: [7](#0-6) 

**Attack Scenario 1 - Extremely Large Scaling Factor:**
If `gas_unit_scaling_factor` is set to a very large value (e.g., 10^15):
- User specifies `max_gas_amount = 2,000,000` external units
- Internal budget = `2,000,000 * 10^15` (saturates at u64::MAX due to `saturating_mul`)
- User can execute billions of operations
- When converting back to external units for charging, the huge scaling factor causes division that rounds to near-zero
- Final charge ≈ 1-2 external gas units regardless of actual computation performed
- Result: Transactions become essentially free, enabling network spam

**Attack Scenario 2 - Extremely Small Scaling Factor:**
If `gas_unit_scaling_factor` is set to 1 (or any value < ~1,000):
- The intrinsic gas requirement (minimum 2,760,000 internal units) converts to external units: [8](#0-7) 

- External intrinsic gas = 2,760,000 / 1 = 2,760,000 external units
- But `maximum_number_of_gas_units = 2,000,000`: [9](#0-8) 

- Transaction validation rejects all transactions where intrinsic gas exceeds max allowed: [10](#0-9) 

- Result: ALL transactions are rejected at validation, complete network halt

The storage fee calculation also uses the scaling factor, enabling similar distortions: [11](#0-10) 

## Impact Explanation

This is a **CRITICAL** severity vulnerability matching the "Non-recoverable network partition (requires hardfork)" category because:

1. **Total Loss of Network Liveness**: Either attack scenario causes complete network disruption
2. **Requires Hardfork**: Once exploited, the only recovery is governance proposal to fix the parameter, but if scaling factor is too small, even governance transactions cannot execute
3. **Affects All Validators**: All nodes would be affected simultaneously since gas schedule is consensus-critical state
4. **Breaks Core Invariants**: Violates "Resource Limits" (gas limits become meaningless) and "Move VM Safety" (bytecode execution no longer respects proper gas accounting)

## Likelihood Explanation

**Likelihood: Medium**

While this requires governance access, it can occur through:
1. **Malicious Governance Proposal**: Compromised governance participant or social engineering attack
2. **Buggy Proposal**: Typo in gas schedule parameters (e.g., missing/extra zeros)
3. **Malicious Insider**: Aptos team member or validator with governance influence

The presence of multiple TODO comments acknowledging the missing validation suggests this is a known but unaddressed risk. The lack of any bounds checking makes exploitation straightforward once governance access is obtained.

## Recommendation

Implement comprehensive validation in the gas schedule update functions:

```move
public fun set_for_next_epoch(aptos_framework: &signer, gas_schedule_blob: vector<u8>) acquires GasScheduleV2 {
    system_addresses::assert_aptos_framework(aptos_framework);
    assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));
    let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
    
    // ADD VALIDATION HERE
    validate_gas_schedule(&new_gas_schedule);
    
    if (exists<GasScheduleV2>(@aptos_framework)) {
        let cur_gas_schedule = borrow_global<GasScheduleV2>(@aptos_framework);
        assert!(
            new_gas_schedule.feature_version >= cur_gas_schedule.feature_version,
            error::invalid_argument(EINVALID_GAS_FEATURE_VERSION)
        );
    };
    config_buffer::upsert(new_gas_schedule);
}

fun validate_gas_schedule(schedule: &GasScheduleV2) {
    // Extract and validate gas_unit_scaling_factor
    let scaling_factor = extract_u64(schedule, b"txn.gas_unit_scaling_factor");
    
    // Require scaling factor to be within reasonable bounds
    // Min: 100,000 (prevents intrinsic gas overflow)
    // Max: 10,000,000 (prevents gas becoming too cheap)
    assert!(scaling_factor >= 100000, error::invalid_argument(EINVALID_GAS_SCHEDULE));
    assert!(scaling_factor <= 10000000, error::invalid_argument(EINVALID_GAS_SCHEDULE));
    
    // Validate other critical parameters
    // - Ensure min_transaction_gas_units is reasonable
    // - Ensure maximum_number_of_gas_units is compatible with scaling factor
    // - Validate storage fee parameters are non-zero
    // ... additional validation logic
}
```

## Proof of Concept

```move
#[test_only]
module aptos_framework::gas_schedule_attack_test {
    use aptos_framework::gas_schedule;
    use std::vector;
    
    #[test(aptos_framework = @aptos_framework)]
    #[expected_failure] // Should fail with validation, but currently doesn't
    fun test_extreme_scaling_factor_attack(aptos_framework: &signer) {
        // Create a malicious gas schedule with extremely large scaling factor
        let malicious_schedule = create_malicious_gas_schedule(999999999999999); // 10^15
        
        // This should fail validation but currently succeeds
        gas_schedule::set_for_next_epoch(aptos_framework, malicious_schedule);
        
        // After this, transactions would cost almost nothing
        // Internal gas = external_gas * 999999999999999
        // Final charge = (internal_used / 999999999999999) ≈ 0
    }
    
    #[test(aptos_framework = @aptos_framework)]
    #[expected_failure] // Should fail with validation, but currently doesn't  
    fun test_tiny_scaling_factor_attack(aptos_framework: &signer) {
        // Create a malicious gas schedule with tiny scaling factor
        let malicious_schedule = create_malicious_gas_schedule(1);
        
        // This should fail validation but currently succeeds
        gas_schedule::set_for_next_epoch(aptos_framework, malicious_schedule);
        
        // After this, no transactions can execute
        // Intrinsic gas in external units = 2,760,000 / 1 = 2,760,000
        // But max_gas_amount limit = 2,000,000
        // All transactions rejected!
    }
}
```

**Notes:**

While this vulnerability requires governance-level access to exploit, it represents a critical missing security control that violates defense-in-depth principles. The explicit TODO comments in the code confirm this is a known but unimplemented validation requirement. A properly designed system should validate all critical parameters to prevent both malicious and accidental misconfigurations that could cause network-wide impact.

### Citations

**File:** aptos-move/aptos-gas-meter/src/traits.rs (L247-249)
```rust
    fn gas_unit_scaling_factor(&self) -> GasScalingFactor {
        self.algebra().vm_gas_params().txn.scaling_factor()
    }
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L22-22)
```rust
const GAS_SCALING_FACTOR: u64 = 1_000_000;
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L33-36)
```rust
            min_transaction_gas_units: InternalGas,
            "min_transaction_gas_units",
            2_760_000
        ],
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L55-58)
```rust
            maximum_number_of_gas_units: Gas,
            "maximum_number_of_gas_units",
            aptos_global_constants::MAX_GAS_AMOUNT
        ],
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L83-86)
```rust
            gas_unit_scaling_factor: GasScalingFactor,
            "gas_unit_scaling_factor",
            GAS_SCALING_FACTOR
        ],
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L47-47)
```text
        // TODO(Gas): check if gas schedule is consistent
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L67-67)
```text
            // TODO(Gas): check if gas schedule is consistent
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L75-75)
```text
            // TODO(Gas): check if gas schedule is consistent
```

**File:** third_party/move/move-core/types/src/gas_algebra.rs (L389-396)
```rust
    pub fn to_unit_with_params<P, T>(self, params: &P) -> GasQuantity<T>
    where
        U: ToUnitWithParams<P, T>,
    {
        let multiplier = <U as ToUnitWithParams<P, T>>::multiplier(params);
        assert_ne!(multiplier, 0);
        GasQuantity::new(self.val.saturating_mul(multiplier))
    }
```

**File:** aptos-move/aptos-vm/src/gas.rs (L154-172)
```rust
    let intrinsic_gas = txn_gas_params
        .calculate_intrinsic_gas(raw_bytes_len)
        .evaluate(gas_feature_version, &gas_params.vm);
    let total_rounded: Gas =
        (intrinsic_gas + keyless + slh_dsa_sha2_128s).to_unit_round_up_with_params(txn_gas_params);
    if txn_metadata.max_gas_amount() < total_rounded {
        speculative_warn!(
            log_context,
            format!(
                "[VM] Gas unit error; min {}, submitted {}",
                total_rounded,
                txn_metadata.max_gas_amount()
            ),
        );
        return Err(VMStatus::error(
            StatusCode::MAX_GAS_UNITS_BELOW_MIN_TRANSACTION_GAS_UNITS,
            None,
        ));
    }
```

**File:** aptos-move/aptos-gas-meter/src/algebra.rs (L260-263)
```rust
        let gas_consumed_internal = div_ceil(
            (u64::from(amount) as u128) * (u64::from(txn_params.gas_unit_scaling_factor) as u128),
            u64::from(gas_unit_price) as u128,
        );
```
