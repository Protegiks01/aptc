# Audit Report

## Title
SafetyData Field Migration Causes Consensus Safety State Loss During Validator Upgrades

## Summary
When validators upgrade to a new version of Aptos Core that adds fields to `SafetyData` (such as `one_chain_round`), the `#[serde(default)]` migration strategy causes critical consensus safety state to be reset to default values (0), allowing validators to operate with incomplete safety information and potentially enabling Byzantine validators to sign conflicting timeouts during upgrade windows.

## Finding Description

The `SafetyData` struct stores critical consensus safety state that prevents validators from violating safety rules. When new fields like `one_chain_round` are added to this struct, they use `#[serde(default)]` for backward compatibility during deserialization: [1](#0-0) 

The `one_chain_round` field tracks the highest 1-chain (certified block) round the validator has observed. This is updated whenever a validator observes a QC: [2](#0-1) 

This field is critical for the `safe_to_timeout` safety check in the 2-chain consensus protocol: [3](#0-2) 

**The vulnerability occurs during validator upgrades:**

1. **Pre-upgrade state**: A validator operates with old code (without `one_chain_round` field), observing QCs up to round 100. The persisted `SafetyData` contains `{epoch: 5, last_voted_round: 98, preferred_round: 97}`.

2. **Upgrade**: The validator restarts with new code. During deserialization, `#[serde(default)]` sets `one_chain_round: 0`, resulting in `{epoch: 5, last_voted_round: 98, preferred_round: 97, one_chain_round: 0}`.

3. **State corruption**: The validator has "forgotten" all 1-chain observations from before the upgrade, creating an inconsistent state where `last_voted_round: 98` but `one_chain_round: 0`.

4. **Exploitation window**: A Byzantine validator with this corrupted state can now sign timeouts that reference old QCs, because the safety check `qc_round >= one_chain_round` becomes ineffective when `one_chain_round: 0`.

5. **Consensus safety risk**: If multiple validators upgrade simultaneously during a network-wide upgrade, they all have `one_chain_round: 0`. Byzantine validators among them can exploit this window to sign timeouts with regressed QCs, potentially enabling conflicting consensus branches.

The existing test only verifies successful deserialization but doesn't validate the consistency or safety of defaulted values: [4](#0-3) 

Note how the test creates `OldSafetyData` with `preferred_round: 100`, which after deserialization results in `preferred_round: 100` but `one_chain_round: 0` - an inconsistent state that is never validated.

## Impact Explanation

This is a **High Severity** vulnerability per Aptos bug bounty criteria for "Significant protocol violations":

- **Consensus Safety Weakening**: The `one_chain_round >= qc_round` check is specifically designed to prevent validators from regressing to older certified states. Resetting this to 0 eliminates this protection.

- **Chain Fork Risk**: During coordinated network upgrades when many validators restart with corrupted state, Byzantine validators can exploit this window to sign timeouts with stale QCs that would normally be rejected.

- **Upgrade Window Vulnerability**: The issue affects all validators during SafetyData schema changes, creating a synchronized vulnerability window across the network.

While not Critical severity, this is serious because:
- It directly weakens consensus safety guarantees
- Occurs during routine network upgrades (high probability event)
- Affects all upgrading validators simultaneously
- Creates exploitable opportunities for Byzantine actors that wouldn't exist with correct state

## Likelihood Explanation

**Medium likelihood** because:

- **Triggering condition**: Occurs during any validator upgrade when `SafetyData` schema changes (has happened with `one_chain_round` and `highest_timeout_round` additions)
- **Exploitation requirements**: Requires Byzantine validator(s) with corrupted state to actively exploit by using old QCs instead of their actual highest QCs
- **Coordination factor**: More impactful during network-wide coordinated upgrades when many validators restart simultaneously with corrupted state
- **Detection difficulty**: The inconsistent state is not validated, so validators continue operating without detecting the corruption

The likelihood is Medium (not High or Critical) because exploitation requires:
1. A version upgrade with SafetyData schema changes
2. Byzantine validator(s) actively exploiting their corrupted state
3. Sufficient number of affected validators for meaningful consensus impact

However, the combination of routine upgrades + Byzantine behavior within expected threat model (<1/3) makes this a realistic attack vector.

## Recommendation

Implement SafetyData migration validation and correction:

1. **Validate consistency after deserialization**: Check that defaulted fields are consistent with existing fields (e.g., `one_chain_round` should be at least as high as `preferred_round`)

2. **Initialize from block store**: When `one_chain_round` defaults to 0, reinitialize it from the highest QC in the block store if available

3. **Add migration tests**: Test that migrations preserve safety properties and detect inconsistent states

4. **Consider alternative migration strategy**: Instead of `#[serde(default)]`, use explicit migration logic that can set appropriate values based on existing state

Example fix:
```rust
// After deserializing SafetyData, validate and correct
if safety_data.one_chain_round == 0 && safety_data.preferred_round > 0 {
    // Attempt to reinitialize from block store
    if let Some(highest_qc) = block_store.highest_quorum_cert() {
        safety_data.one_chain_round = highest_qc.certified_block().round();
    } else {
        // Conservative: set to preferred_round as lower bound
        safety_data.one_chain_round = safety_data.preferred_round;
    }
    persistent_storage.set_safety_data(safety_data)?;
}
```

## Proof of Concept

The vulnerability can be demonstrated by:

1. Creating a validator with old SafetyData format (without `one_chain_round`)
2. Persisting state after voting in high rounds (e.g., round 100)
3. Restarting with new code that includes `one_chain_round`
4. Observing that `one_chain_round: 0` while `last_voted_round: 100`
5. Verifying that `safe_to_timeout` would accept timeouts with old QCs that should be rejected

A concrete test would extend the existing `test_safety_data_upgrade` to validate safety properties after migration, rather than just successful deserialization.

## Notes

This vulnerability is particularly concerning because:

1. **Silent corruption**: The state corruption happens silently during normal upgrade operations without any error or warning
2. **Network-wide impact**: During coordinated upgrades, many validators simultaneously have corrupted state
3. **Byzantine opportunity**: Creates a time-limited window where Byzantine validators can exploit weakened safety checks
4. **No detection**: The inconsistent state is never validated, so validators operate normally despite the corruption

The core issue is that `#[serde(default)]` is convenient for backward compatibility but insufficient for maintaining consensus safety invariants across schema changes. Critical safety state requires explicit migration logic that preserves security properties.

### Citations

**File:** consensus/consensus-types/src/safety_data.rs (L15-17)
```rust
    // highest 1-chain round, used for 2-chain
    #[serde(default)]
    pub one_chain_round: u64,
```

**File:** consensus/consensus-types/src/safety_data.rs (L53-70)
```rust
#[test]
fn test_safety_data_upgrade() {
    #[derive(Debug, Deserialize, Eq, PartialEq, Serialize, Clone, Default)]
    struct OldSafetyData {
        pub epoch: u64,
        pub last_voted_round: u64,
        pub preferred_round: u64,
        pub last_vote: Option<Vote>,
    }
    let old_data = OldSafetyData {
        epoch: 1,
        last_voted_round: 10,
        preferred_round: 100,
        last_vote: None,
    };
    let value = serde_json::to_value(old_data).unwrap();
    let _: SafetyData = serde_json::from_value(value).unwrap();
}
```

**File:** consensus/safety-rules/src/safety_rules.rs (L135-146)
```rust
    pub(crate) fn observe_qc(&self, qc: &QuorumCert, safety_data: &mut SafetyData) -> bool {
        let mut updated = false;
        let one_chain = qc.certified_block().round();
        let two_chain = qc.parent_block().round();
        if one_chain > safety_data.one_chain_round {
            safety_data.one_chain_round = one_chain;
            trace!(
                SafetyLogSchema::new(LogEntry::OneChainRound, LogEvent::Update)
                    .preferred_round(safety_data.one_chain_round)
            );
            updated = true;
        }
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L121-145)
```rust
    /// Core safety timeout rule for 2-chain protocol. Return success if 1 and 2 are true
    /// 1. round == timeout.qc.round + 1 || round == tc.round + 1
    /// 2. timeout.qc.round >= one_chain_round
    fn safe_to_timeout(
        &self,
        timeout: &TwoChainTimeout,
        maybe_tc: Option<&TwoChainTimeoutCertificate>,
        safety_data: &SafetyData,
    ) -> Result<(), Error> {
        let round = timeout.round();
        let qc_round = timeout.hqc_round();
        let tc_round = maybe_tc.map_or(0, |tc| tc.round());
        if (round == next_round(qc_round)? || round == next_round(tc_round)?)
            && qc_round >= safety_data.one_chain_round
        {
            Ok(())
        } else {
            Err(Error::NotSafeToTimeout(
                round,
                qc_round,
                tc_round,
                safety_data.one_chain_round,
            ))
        }
    }
```
